enum	O
uyytokentype	enum
{	O
EQ	int
=	O
258	int
,	O
LT	int
=	O
259	int
,	O
GT	int
=	O
260	int
,	O
NE	int
=	O
261	int
,	O
LE	int
=	O
262	int
,	O
GE	int
=	O
263	int
,	O
NUL	int
=	O
264	int
,	O
BOGUS	int
=	O
265	int
,	O
STRING	int
=	O
266	int
,	O
QUOTE	int
=	O
267	int
}	O
;	O
static	O
grad_locus_t	struct
start_loc	struct
;	O
static	O
void	O
*	O
closure	pointer
;	O
static	O
register_rule_fp	pointer
add_entry	pointer
;	O
static	O
grad_avp_t	struct
*	O
grad_create_pair0	function
(	O
char	O
*	O
name	pointer
,	O
int	O
op	enum
,	O
char	O
*	O
valstr	pointer
)	O
;	O
int	O
uyyerror	function
(	O
char	O
*	O
s	pointer
)	O
;	O
extern	O
int	O
uyylex	function
(	O
)	O
;	O
typedef	O
union	O
YYSTYPE	union
{	O
char	O
*	O
string	pointer
;	O
grad_matching_rule_t	struct
*	O
rule	pointer
;	O
struct	O
{	O
grad_avp_t	struct
*	O
lhs	pointer
,	O
*	O
rhs	pointer
;	O
}	O
descr	struct
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
enum	O
grad_operator	enum
op	enum
;	O
}	O
YYSTYPE	union
;	O
typedef	O
unsigned	O
char	O
uyytype_uint8	char
;	O
typedef	O
signed	O
char	O
uyytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
uyytype_uint16	short
;	O
typedef	O
short	O
int	O
uyytype_int16	short
;	O
union	O
uyyalloc	union
{	O
uyytype_int16	short
uyyss	short
;	O
YYSTYPE	union
uyyvs	union
;	O
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyytranslate	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
13	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyyprhs	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
4	int
,	O
6	int
,	O
8	int
,	O
11	int
,	O
14	int
,	O
17	int
,	O
20	int
,	O
22	int
,	O
25	int
,	O
27	int
,	O
29	int
,	O
31	int
,	O
35	int
,	O
39	int
,	O
43	int
,	O
45	int
,	O
47	int
,	O
49	int
,	O
51	int
,	O
53	int
,	O
55	int
,	O
57	int
}	O
;	O
static	O
const	O
uyytype_int8	char
uyyrhs	array
[	O
]	O
=	O
{	O
15	int
,	O
0	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
16	int
,	O
17	int
,	O
-	O
1	int
,	O
16	int
,	O
1	int
,	O
-	O
1	int
,	O
18	int
,	O
19	int
,	O
-	O
1	int
,	O
18	int
,	O
1	int
,	O
-	O
1	int
,	O
24	int
,	O
-	O
1	int
,	O
20	int
,	O
20	int
,	O
-	O
1	int
,	O
9	int
,	O
-	O
1	int
,	O
21	int
,	O
-	O
1	int
,	O
22	int
,	O
-	O
1	int
,	O
21	int
,	O
13	int
,	O
22	int
,	O
-	O
1	int
,	O
11	int
,	O
23	int
,	O
24	int
,	O
-	O
1	int
,	O
11	int
,	O
23	int
,	O
10	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
6	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
,	O
8	int
,	O
-	O
1	int
,	O
11	int
,	O
-	O
1	int
,	O
12	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyyrline	array
[	O
]	O
=	O
{	O
0	int
,	O
82	int
,	O
82	int
,	O
83	int
,	O
86	int
,	O
89	int
,	O
90	int
,	O
96	int
,	O
100	int
,	O
112	int
,	O
118	int
,	O
125	int
,	O
129	int
,	O
132	int
,	O
133	int
,	O
144	int
,	O
148	int
,	O
154	int
,	O
158	int
,	O
162	int
,	O
166	int
,	O
170	int
,	O
174	int
,	O
180	int
,	O
181	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
uyytname	array
[	O
]	O
=	O
{	O
"$end"	pointer
,	O
"error"	pointer
,	O
"$undefined"	pointer
,	O
"EQ"	pointer
,	O
"LT"	pointer
,	O
"GT"	pointer
,	O
"NE"	pointer
,	O
"LE"	pointer
,	O
"GE"	pointer
,	O
"NUL"	pointer
,	O
"BOGUS"	pointer
,	O
"STRING"	pointer
,	O
"QUOTE"	pointer
,	O
"','"	pointer
,	O
"$accept"	pointer
,	O
"input"	pointer
,	O
"list"	pointer
,	O
"entry"	pointer
,	O
"user"	pointer
,	O
"descr"	pointer
,	O
"npairlist"	pointer
,	O
"pairlist"	pointer
,	O
"pair"	pointer
,	O
"op"	pointer
,	O
"value"	pointer
,	O
0	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyyr1	array
[	O
]	O
=	O
{	O
0	int
,	O
14	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
17	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
21	int
,	O
21	int
,	O
22	int
,	O
22	int
,	O
23	int
,	O
23	int
,	O
23	int
,	O
23	int
,	O
23	int
,	O
23	int
,	O
24	int
,	O
24	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyyr2	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyydefact	array
[	O
]	O
=	O
{	O
2	int
,	O
23	int
,	O
24	int
,	O
0	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
9	int
,	O
1	int
,	O
6	int
,	O
5	int
,	O
8	int
,	O
11	int
,	O
0	int
,	O
7	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
0	int
,	O
10	int
,	O
0	int
,	O
16	int
,	O
15	int
,	O
14	int
}	O
;	O
static	O
const	O
uyytype_int8	char
uyydefgoto	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
24	int
,	O
7	int
}	O
;	O
static	O
const	O
uyytype_int8	char
uyypact	array
[	O
]	O
=	O
{	O
-	O
2	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
7	int
,	O
0	int
,	O
-	O
9	int
,	O
4	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
13	int
,	O
-	O
9	int
,	O
-	O
3	int
,	O
1	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
8	int
,	O
-	O
9	int
,	O
11	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
}	O
;	O
static	O
const	O
uyytype_int8	char
uyypgoto	array
[	O
]	O
=	O
{	O
-	O
9	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
19	int
,	O
-	O
9	int
,	O
-	O
9	int
,	O
9	int
,	O
-	O
9	int
,	O
-	O
1	int
,	O
-	O
9	int
,	O
2	int
}	O
;	O
static	O
const	O
uyytype_int8	char
uyytable	array
[	O
]	O
=	O
{	O
-	O
3	int
,	O
9	int
,	O
27	int
,	O
1	int
,	O
2	int
,	O
11	int
,	O
12	int
,	O
8	int
,	O
13	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
12	int
,	O
26	int
,	O
13	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
13	int
,	O
10	int
,	O
25	int
,	O
29	int
,	O
28	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyycheck	array
[	O
]	O
=	O
{	O
0	int
,	O
1	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
1	int
,	O
9	int
,	O
0	int
,	O
11	int
,	O
11	int
,	O
12	int
,	O
11	int
,	O
12	int
,	O
9	int
,	O
13	int
,	O
11	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
11	int
,	O
4	int
,	O
15	int
,	O
26	int
,	O
24	int
}	O
;	O
static	O
const	O
uyytype_uint8	char
uyystos	array
[	O
]	O
=	O
{	O
0	int
,	O
11	int
,	O
12	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
24	int
,	O
0	int
,	O
1	int
,	O
17	int
,	O
1	int
,	O
9	int
,	O
11	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
23	int
,	O
20	int
,	O
13	int
,	O
10	int
,	O
24	int
,	O
22	int
}	O
;	O
static	O
void	O
uyy_symbol_value_print	function
(	O
FILE	struct
*	O
uyyoutput	pointer
,	O
int	O
uyytype	int
,	O
YYSTYPE	union
const	O
*	O
const	O
uyyvaluep	pointer
)	O
{	O
if	O
(	O
!	O
uyyvaluep	pointer
)	O
return	O
;	O
YYUSE	O
(	O
uyyoutput	pointer
)	O
;	O
switch	O
(	O
uyytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
uyy_symbol_print	function
(	O
FILE	struct
*	O
uyyoutput	pointer
,	O
int	O
uyytype	int
,	O
YYSTYPE	union
const	O
*	O
const	O
uyyvaluep	pointer
)	O
{	O
if	O
(	O
uyytype	int
<	O
YYNTOKENS	int
)	O
YYFPRINTF	O
(	O
uyyoutput	pointer
,	O
"token %s ("	pointer
,	O
uyytname	array
[	O
uyytype	int
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
uyyoutput	pointer
,	O
"nterm %s ("	pointer
,	O
uyytname	array
[	O
uyytype	int
]	O
)	O
;	O
uyy_symbol_value_print	function
(	O
uyyoutput	pointer
,	O
uyytype	int
,	O
uyyvaluep	pointer
)	O
;	O
YYFPRINTF	O
(	O
uyyoutput	pointer
,	O
")"	pointer
)	O
;	O
}	O
static	O
void	O
uyy_stack_print	function
(	O
uyytype_int16	short
*	O
bottom	pointer
,	O
uyytype_int16	short
*	O
top	pointer
)	O
{	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"Stack now"	pointer
)	O
;	O
for	O
(	O
;	O
bottom	pointer
<=	O
top	pointer
;	O
++	O
bottom	pointer
)	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
" %d"	pointer
,	O
*	O
bottom	pointer
)	O
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
uyy_reduce_print	function
(	O
YYSTYPE	union
*	O
uyyvsp	pointer
,	O
int	O
uyyrule	int
)	O
{	O
int	O
uyynrhs	int
=	O
uyyr2	array
[	O
uyyrule	int
]	O
;	O
int	O
uyyi	int
;	O
unsigned	O
long	O
int	O
uyylno	long
=	O
uyyrline	array
[	O
uyyrule	int
]	O
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"Reducing stack by rule %d (line %lu):\n"	pointer
,	O
uyyrule	int
-	O
1	int
,	O
uyylno	long
)	O
;	O
for	O
(	O
uyyi	int
=	O
0	int
;	O
uyyi	int
<	O
uyynrhs	int
;	O
uyyi	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"   $%d = "	pointer
,	O
uyyi	int
+	O
1	int
)	O
;	O
uyy_symbol_print	function
(	O
stderr	pointer
,	O
uyyrhs	array
[	O
uyyprhs	array
[	O
uyyrule	int
]	O
+	O
uyyi	int
]	O
,	O
&	O
(	O
uyyvsp	pointer
[	O
(	O
uyyi	int
+	O
1	int
)	O
-	O
(	O
uyynrhs	int
)	O
]	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
int	O
uyydebug	int
;	O
static	O
void	O
uyydestruct	function
(	O
const	O
char	O
*	O
uyymsg	pointer
,	O
int	O
uyytype	int
,	O
YYSTYPE	union
*	O
uyyvaluep	pointer
)	O
{	O
YYUSE	O
(	O
uyyvaluep	pointer
)	O
;	O
if	O
(	O
!	O
uyymsg	pointer
)	O
uyymsg	pointer
=	O
"Deleting"	pointer
;	O
YY_SYMBOL_PRINT	O
(	O
uyymsg	pointer
,	O
uyytype	int
,	O
uyyvaluep	pointer
,	O
uyylocationp	O
)	O
;	O
switch	O
(	O
uyytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
uyyparse	function
(	O
void	O
)	O
;	O
int	O
uyychar	int
;	O
YYSTYPE	union
uyylval	union
;	O
int	O
uyynerrs	int
;	O
int	O
uyyparse	function
(	O
void	O
)	O
{	O
int	O
uyystate	int
;	O
int	O
uyyn	int
;	O
int	O
uyyresult	int
;	O
int	O
uyyerrstatus	int
;	O
int	O
uyytoken	int
=	O
0	int
;	O
uyytype_int16	short
uyyssa	array
[	O
YYINITDEPTH	int
]	O
;	O
uyytype_int16	short
*	O
uyyss	short
=	O
uyyssa	array
;	O
uyytype_int16	short
*	O
uyyssp	pointer
;	O
YYSTYPE	union
uyyvsa	array
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union
*	O
uyyvs	union
=	O
uyyvsa	array
;	O
YYSTYPE	union
*	O
uyyvsp	pointer
;	O
YYSIZE_T	O
uyystacksize	long
=	O
YYINITDEPTH	int
;	O
YYSTYPE	union
uyyval	union
;	O
int	O
uyylen	int
=	O
0	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Starting parse\n"	pointer
)	O
)	O
;	O
uyystate	int
=	O
0	int
;	O
uyyerrstatus	int
=	O
0	int
;	O
uyynerrs	int
=	O
0	int
;	O
uyychar	int
=	O
YYEMPTY	O
;	O
uyyssp	pointer
=	O
uyyss	short
;	O
uyyvsp	pointer
=	O
uyyvs	union
;	O
goto	O
uyysetstate	O
;	O
uyynewstate	O
:	O
uyyssp	pointer
++	O
;	O
uyysetstate	O
:	O
*	O
uyyssp	pointer
=	O
uyystate	int
;	O
if	O
(	O
uyyss	short
+	O
uyystacksize	long
-	O
1	int
<=	O
uyyssp	pointer
)	O
{	O
YYSIZE_T	O
uyysize	long
=	O
uyyssp	pointer
-	O
uyyss	short
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
uyystacksize	long
)	O
goto	O
uyyexhaustedlab	O
;	O
uyystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
uyystacksize	long
)	O
uyystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
uyytype_int16	short
*	O
uyyss1	pointer
=	O
uyyss	short
;	O
union	O
uyyalloc	union
*	O
uyyptr	pointer
=	O
(	O
union	O
uyyalloc	union
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
uyystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
uyyptr	pointer
)	O
goto	O
uyyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
uyyss	short
)	O
;	O
YYSTACK_RELOCATE	O
(	O
uyyvs	union
)	O
;	O
if	O
(	O
uyyss1	pointer
!=	O
uyyssa	array
)	O
YYSTACK_FREE	O
(	O
uyyss1	pointer
)	O
;	O
}	O
uyyssp	pointer
=	O
uyyss	short
+	O
uyysize	long
-	O
1	int
;	O
uyyvsp	pointer
=	O
uyyvs	union
+	O
uyysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Stack size increased to %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
uyystacksize	long
)	O
)	O
;	O
if	O
(	O
uyyss	short
+	O
uyystacksize	long
-	O
1	int
<=	O
uyyssp	pointer
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Entering state %d\n"	pointer
,	O
uyystate	int
)	O
)	O
;	O
goto	O
uyybackup	O
;	O
uyybackup	O
:	O
uyyn	int
=	O
uyypact	array
[	O
uyystate	int
]	O
;	O
if	O
(	O
uyyn	int
==	O
YYPACT_NINF	O
)	O
goto	O
uyydefault	O
;	O
if	O
(	O
uyychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Reading a token: "	pointer
)	O
)	O
;	O
uyychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
uyychar	int
<=	O
YYEOF	int
)	O
{	O
uyychar	int
=	O
uyytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Now at end of input.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
uyytoken	int
=	O
YYTRANSLATE	O
(	O
uyychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	pointer
,	O
uyytoken	int
,	O
&	O
uyylval	union
,	O
&	O
uyylloc	O
)	O
;	O
}	O
uyyn	int
+=	O
uyytoken	int
;	O
if	O
(	O
uyyn	int
<	O
0	int
||	O
YYLAST	int
<	O
uyyn	int
||	O
uyycheck	array
[	O
uyyn	int
]	O
!=	O
uyytoken	int
)	O
goto	O
uyydefault	O
;	O
uyyn	int
=	O
uyytable	array
[	O
uyyn	int
]	O
;	O
if	O
(	O
uyyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
uyyn	int
==	O
0	int
||	O
uyyn	int
==	O
YYTABLE_NINF	O
)	O
goto	O
uyyerrlab	O
;	O
uyyn	int
=	O
-	O
uyyn	int
;	O
goto	O
uyyreduce	O
;	O
}	O
if	O
(	O
uyyn	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
if	O
(	O
uyyerrstatus	int
)	O
uyyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
uyytoken	int
,	O
&	O
uyylval	union
,	O
&	O
uyylloc	O
)	O
;	O
if	O
(	O
uyychar	int
!=	O
YYEOF	int
)	O
uyychar	int
=	O
YYEMPTY	O
;	O
uyystate	int
=	O
uyyn	int
;	O
*	O
++	O
uyyvsp	pointer
=	O
uyylval	union
;	O
goto	O
uyynewstate	O
;	O
uyydefault	O
:	O
uyyn	int
=	O
uyydefact	array
[	O
uyystate	int
]	O
;	O
if	O
(	O
uyyn	int
==	O
0	int
)	O
goto	O
uyyerrlab	O
;	O
goto	O
uyyreduce	O
;	O
uyyreduce	O
:	O
uyylen	int
=	O
uyyr2	array
[	O
uyyn	int
]	O
;	O
uyyval	union
=	O
uyyvsp	pointer
[	O
1	int
-	O
uyylen	int
]	O
;	O
YY_REDUCE_PRINT	O
(	O
uyyn	int
)	O
;	O
switch	O
(	O
uyyn	int
)	O
{	O
case	O
4	int
:	O
{	O
}	O
break	O
;	O
case	O
6	int
:	O
{	O
grad_parser_lex_sync	function
(	O
)	O
;	O
uyyerrok	O
;	O
uyyclearin	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
add_entry	pointer
(	O
closure	pointer
,	O
&	O
start_loc	struct
,	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	pointer
)	O
,	O
(	O
uyyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
descr	struct
)	O
.	O
lhs	pointer
,	O
(	O
uyyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
descr	struct
)	O
.	O
rhs	pointer
)	O
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"discarding user `%s'"	pointer
)	O
,	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	pointer
)	O
)	O
;	O
if	O
(	O
grad_parser_lex_sync	function
(	O
)	O
<=	O
0	int
)	O
uyychar	int
=	O
0	int
;	O
else	O
{	O
uyyerrok	O
;	O
uyyclearin	O
;	O
}	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
start_loc	struct
=	O
grad_parser_source_locus	struct
;	O
}	O
break	O
;	O
case	O
10	int
:	O
{	O
(	O
uyyval	union
.	O
descr	struct
)	O
.	O
lhs	pointer
=	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
pair	pointer
)	O
;	O
(	O
uyyval	union
.	O
descr	struct
)	O
.	O
rhs	pointer
=	O
(	O
uyyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
pair	pointer
)	O
;	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
(	O
uyyval	union
.	O
pair	pointer
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
if	O
(	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pair	pointer
)	O
)	O
{	O
if	O
(	O
(	O
uyyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pair	pointer
)	O
)	O
grad_avl_add_list	function
(	O
&	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pair	pointer
)	O
,	O
(	O
uyyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pair	pointer
)	O
)	O
;	O
(	O
uyyval	union
.	O
pair	pointer
)	O
=	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pair	pointer
)	O
;	O
}	O
else	O
(	O
uyyval	union
.	O
pair	pointer
)	O
=	O
(	O
uyyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pair	pointer
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
(	O
uyyval	union
.	O
pair	pointer
)	O
=	O
grad_create_pair0	function
(	O
(	O
uyyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
,	O
(	O
uyyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
op	enum
)	O
,	O
(	O
uyyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
(	O
uyyval	union
.	O
op	enum
)	O
=	O
grad_operator_equal	int
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
(	O
uyyval	union
.	O
op	enum
)	O
=	O
grad_operator_less_than	int
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
(	O
uyyval	union
.	O
op	enum
)	O
=	O
grad_operator_greater_than	int
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
(	O
uyyval	union
.	O
op	enum
)	O
=	O
grad_operator_not_equal	int
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
(	O
uyyval	union
.	O
op	enum
)	O
=	O
grad_operator_less_equal	int
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
(	O
uyyval	union
.	O
op	enum
)	O
=	O
grad_operator_greater_equal	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	pointer
,	O
uyyr1	array
[	O
uyyn	int
]	O
,	O
&	O
uyyval	union
,	O
&	O
uyyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
uyylen	int
)	O
;	O
uyylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
uyyss	short
,	O
uyyssp	pointer
)	O
;	O
*	O
++	O
uyyvsp	pointer
=	O
uyyval	union
;	O
uyyn	int
=	O
uyyr1	array
[	O
uyyn	int
]	O
;	O
uyystate	int
=	O
uyypgoto	array
[	O
uyyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
uyyssp	pointer
;	O
if	O
(	O
0	int
<=	O
uyystate	int
&&	O
uyystate	int
<=	O
YYLAST	int
&&	O
uyycheck	array
[	O
uyystate	int
]	O
==	O
*	O
uyyssp	pointer
)	O
uyystate	int
=	O
uyytable	array
[	O
uyystate	int
]	O
;	O
else	O
uyystate	int
=	O
uyydefgoto	array
[	O
uyyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
uyynewstate	O
;	O
uyyerrlab	O
:	O
if	O
(	O
!	O
uyyerrstatus	int
)	O
{	O
++	O
uyynerrs	int
;	O
uyyerror	function
(	O
YY_	O
(	O
"syntax error"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
uyyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
uyychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
uyychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
uyydestruct	function
(	O
"Error: discarding"	pointer
,	O
uyytoken	int
,	O
&	O
uyylval	union
)	O
;	O
uyychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
uyyerrlab1	O
;	O
uyyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
uyyerrorlab	O
;	O
YYPOPSTACK	O
(	O
uyylen	int
)	O
;	O
uyylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
uyyss	short
,	O
uyyssp	pointer
)	O
;	O
uyystate	int
=	O
*	O
uyyssp	pointer
;	O
goto	O
uyyerrlab1	O
;	O
uyyerrlab1	O
:	O
uyyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
uyyn	int
=	O
uyypact	array
[	O
uyystate	int
]	O
;	O
if	O
(	O
uyyn	int
!=	O
YYPACT_NINF	O
)	O
{	O
uyyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
uyyn	int
&&	O
uyyn	int
<=	O
YYLAST	int
&&	O
uyycheck	array
[	O
uyyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
uyyn	int
=	O
uyytable	array
[	O
uyyn	int
]	O
;	O
if	O
(	O
0	int
<	O
uyyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
uyyssp	pointer
==	O
uyyss	short
)	O
YYABORT	O
;	O
uyydestruct	function
(	O
"Error: popping"	pointer
,	O
uyystos	array
[	O
uyystate	int
]	O
,	O
uyyvsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
uyystate	int
=	O
*	O
uyyssp	pointer
;	O
YY_STACK_PRINT	O
(	O
uyyss	short
,	O
uyyssp	pointer
)	O
;	O
}	O
if	O
(	O
uyyn	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
*	O
++	O
uyyvsp	pointer
=	O
uyylval	union
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
uyystos	array
[	O
uyyn	int
]	O
,	O
uyyvsp	pointer
,	O
uyylsp	O
)	O
;	O
uyystate	int
=	O
uyyn	int
;	O
goto	O
uyynewstate	O
;	O
uyyacceptlab	O
:	O
uyyresult	int
=	O
0	int
;	O
goto	O
uyyreturn	O
;	O
uyyabortlab	O
:	O
uyyresult	int
=	O
1	int
;	O
goto	O
uyyreturn	O
;	O
uyyexhaustedlab	O
:	O
uyyerror	function
(	O
YY_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
uyyresult	int
=	O
2	int
;	O
uyyreturn	O
:	O
if	O
(	O
uyychar	int
!=	O
YYEOF	int
&&	O
uyychar	int
!=	O
YYEMPTY	O
)	O
uyydestruct	function
(	O
"Cleanup: discarding lookahead"	pointer
,	O
uyytoken	int
,	O
&	O
uyylval	union
)	O
;	O
YYPOPSTACK	O
(	O
uyylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
uyyss	short
,	O
uyyssp	pointer
)	O
;	O
while	O
(	O
uyyssp	pointer
!=	O
uyyss	short
)	O
{	O
uyydestruct	function
(	O
"Cleanup: popping"	pointer
,	O
uyystos	array
[	O
*	O
uyyssp	pointer
]	O
,	O
uyyvsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
uyyss	short
!=	O
uyyssa	array
)	O
YYSTACK_FREE	O
(	O
uyyss	short
)	O
;	O
return	O
YYID	O
(	O
uyyresult	int
)	O
;	O
}	O
int	O
uyyerror	function
(	O
char	O
*	O
s	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
grad_parser_source_locus	struct
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
return	O
0	int
;	O
}	O
grad_avp_t	struct
*	O
grad_create_pair0	function
(	O
char	O
*	O
name	pointer
,	O
int	O
op	enum
,	O
char	O
*	O
valstr	pointer
)	O
{	O
return	O
grad_create_pair	function
(	O
&	O
grad_parser_source_locus	struct
,	O
name	pointer
,	O
op	enum
,	O
valstr	pointer
)	O
;	O
}	O
grad_avp_t	struct
*	O
grad_create_pair	function
(	O
grad_locus_t	struct
*	O
loc	struct
,	O
char	O
*	O
name	pointer
,	O
enum	O
grad_operator	enum
op	enum
,	O
char	O
*	O
valstr	pointer
)	O
{	O
grad_dict_attr_t	struct
*	O
attr	pointer
=	O
NULL	O
;	O
grad_dict_value_t	struct
*	O
dval	pointer
;	O
grad_avp_t	struct
*	O
pair	pointer
,	O
*	O
pair2	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
x	int
;	O
time_t	long
timeval	struct
;	O
struct	O
tm	struct
*	O
tm	struct
,	O
tms	struct
;	O
if	O
(	O
(	O
attr	pointer
=	O
grad_attr_name_to_dict	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"unknown attribute `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
pair	pointer
=	O
grad_avp_alloc	function
(	O
)	O
;	O
pair	pointer
->	O
next	pointer
=	O
NULL	O
;	O
pair	pointer
->	O
name	pointer
=	O
attr	pointer
->	O
name	pointer
;	O
pair	pointer
->	O
attribute	int
=	O
attr	pointer
->	O
value	pointer
;	O
pair	pointer
->	O
type	enum
=	O
attr	pointer
->	O
type	enum
;	O
pair	pointer
->	O
prop	int
=	O
attr	pointer
->	O
prop	int
;	O
pair	pointer
->	O
operator	enum
=	O
op	enum
;	O
if	O
(	O
valstr	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
{	O
pair	pointer
->	O
eval_type	enum
=	O
grad_eval_interpret	int
;	O
pair	pointer
->	O
avp_strvalue	O
=	O
grad_estrdup	function
(	O
valstr	pointer
+	O
1	int
)	O
;	O
pair	pointer
->	O
avp_strlength	O
=	O
strlen	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
return	O
pair	pointer
;	O
}	O
pair	pointer
->	O
eval_type	enum
=	O
grad_eval_const	int
;	O
switch	O
(	O
pair	pointer
->	O
type	enum
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
if	O
(	O
pair	pointer
->	O
attribute	int
==	O
DA_EXEC_PROGRAM	int
||	O
pair	pointer
->	O
attribute	int
==	O
DA_EXEC_PROGRAM_WAIT	int
)	O
{	O
if	O
(	O
valstr	pointer
[	O
0	int
]	O
!=	O
'/'	O
&&	O
valstr	pointer
[	O
0	int
]	O
!=	O
'|'	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"%s: not an absolute pathname"	pointer
)	O
,	O
name	pointer
)	O
;	O
grad_avp_free	function
(	O
pair	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
pair	pointer
->	O
avp_strvalue	O
=	O
grad_estrdup	function
(	O
valstr	pointer
)	O
;	O
pair	pointer
->	O
avp_strlength	O
=	O
strlen	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
if	O
(	O
attr	pointer
->	O
parser	pointer
&&	O
attr	pointer
->	O
parser	pointer
(	O
pair	pointer
,	O
&	O
s	pointer
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s %s: %s"	pointer
,	O
_	O
(	O
"attribute"	pointer
)	O
,	O
pair	pointer
->	O
name	pointer
,	O
s	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
grad_avp_free	function
(	O
pair	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
if	O
(	O
attr	pointer
->	O
value	pointer
==	O
DA_NAS_PORT_ID	int
)	O
{	O
for	O
(	O
s	pointer
=	O
valstr	pointer
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
s	pointer
)	O
)	O
break	O
;	O
if	O
(	O
*	O
s	pointer
)	O
{	O
pair	pointer
->	O
type	enum
=	O
GRAD_TYPE_STRING	int
;	O
pair	pointer
->	O
avp_strvalue	O
=	O
grad_estrdup	function
(	O
valstr	pointer
)	O
;	O
pair	pointer
->	O
avp_strlength	O
=	O
strlen	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
isdigit	function
(	O
*	O
valstr	pointer
)	O
)	O
{	O
pair	pointer
->	O
avp_lvalue	O
=	O
atoi	function
(	O
valstr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
dval	pointer
=	O
grad_value_name_to_value	function
(	O
valstr	pointer
,	O
pair	pointer
->	O
attribute	int
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_avp_free	function
(	O
pair	pointer
)	O
;	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"value %s is not declared for attribute %s"	pointer
)	O
,	O
valstr	pointer
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
pair	pointer
->	O
avp_lvalue	O
=	O
dval	pointer
->	O
value	pointer
;	O
}	O
break	O
;	O
case	O
GRAD_TYPE_IPADDR	int
:	O
if	O
(	O
pair	pointer
->	O
attribute	int
!=	O
DA_FRAMED_IP_ADDRESS	int
)	O
{	O
pair	pointer
->	O
avp_lvalue	O
=	O
grad_ip_gethostaddr	function
(	O
valstr	pointer
)	O
;	O
}	O
else	O
{	O
x	int
=	O
0	int
;	O
if	O
(	O
valstr	pointer
[	O
0	int
]	O
)	O
{	O
for	O
(	O
s	pointer
=	O
valstr	pointer
;	O
s	pointer
[	O
1	int
]	O
;	O
s	pointer
++	O
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'+'	O
)	O
{	O
*	O
s	pointer
=	O
0	int
;	O
x	int
=	O
1	int
;	O
}	O
}	O
pair	pointer
->	O
avp_lvalue	O
=	O
grad_ip_gethostaddr	function
(	O
valstr	pointer
)	O
;	O
if	O
(	O
x	int
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
buf	pointer
[	O
INT_BUFSIZE_BOUND	O
(	O
long	O
)	O
]	O
;	O
grad_longtostr	function
(	O
pair	pointer
->	O
avp_lvalue	O
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
grad_astrcat	function
(	O
&	O
s	pointer
,	O
buf	pointer
,	O
"+"	pointer
,	O
"%{NAS-Port-Id}"	pointer
,	O
NULL	O
)	O
;	O
pair	pointer
->	O
avp_strvalue	O
=	O
grad_estrdup	function
(	O
s	pointer
)	O
;	O
pair	pointer
->	O
avp_strlength	O
=	O
strlen	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
pair	pointer
->	O
eval_type	enum
=	O
grad_eval_interpret	int
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
GRAD_TYPE_DATE	int
:	O
timeval	struct
=	O
time	struct
(	O
0	int
)	O
;	O
tm	struct
=	O
localtime_r	function
(	O
&	O
timeval	struct
,	O
&	O
tms	struct
)	O
;	O
if	O
(	O
grad_parse_time_string	function
(	O
valstr	pointer
,	O
tm	struct
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"%s: can't parse date"	pointer
)	O
,	O
name	pointer
)	O
;	O
grad_avp_free	function
(	O
pair	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
pair	pointer
->	O
avp_lvalue	O
=	O
(	O
grad_uint32_t	int
)	O
mktime	function
(	O
tm	struct
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"%s: unknown attribute type %d"	pointer
)	O
,	O
name	pointer
,	O
pair	pointer
->	O
type	enum
)	O
;	O
grad_avp_free	function
(	O
pair	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
extern	O
int	O
uyydebug	int
;	O
int	O
grad_parse_rule_file	function
(	O
char	O
*	O
file	pointer
,	O
void	O
*	O
c	pointer
,	O
register_rule_fp	pointer
f	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
grad_parser_lex_init	function
(	O
file	pointer
)	O
)	O
return	O
-	O
1	int
;	O
closure	pointer
=	O
c	pointer
;	O
add_entry	pointer
=	O
f	pointer
;	O
uyydebug	int
=	O
0	int
;	O
rc	int
=	O
uyyparse	function
(	O
)	O
;	O
grad_parser_lex_finish	function
(	O
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
grad_enable_rule_debug	function
(	O
int	O
val	array
)	O
{	O
uyydebug	int
=	O
val	array
;	O
grad_log_loc	function
(	O
GRAD_LOG_NOTICE	int
,	O
&	O
grad_parser_source_locus	struct
,	O
uyydebug	int
?	O
_	O
(	O
"enabled userfile parser debugging"	pointer
)	O
:	O
_	O
(	O
"disabled userfile parser debugging"	pointer
)	O
)	O
;	O
}	O
