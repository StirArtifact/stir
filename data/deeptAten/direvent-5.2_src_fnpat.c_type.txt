static	O
void	O
filename_pattern_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
struct	O
filename_pattern	struct
*	O
pat	pointer
=	O
p	pointer
;	O
switch	O
(	O
pat	pointer
->	O
type	enum
)	O
{	O
case	O
PAT_EXACT	int
:	O
case	O
PAT_GLOB	int
:	O
free	function
(	O
pat	pointer
->	O
v	union
.	O
glob	pointer
)	O
;	O
break	O
;	O
case	O
PAT_REGEX	int
:	O
regfree	function
(	O
&	O
pat	pointer
->	O
v	union
.	O
re	struct
)	O
;	O
}	O
free	function
(	O
pat	pointer
)	O
;	O
}	O
struct	O
filpatlist	struct
{	O
grecs_list_ptr_t	pointer
list	pointer
;	O
}	O
;	O
static	O
int	O
is_glob	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
return	O
strcspn	function
(	O
str	pointer
,	O
"[]*?"	pointer
)	O
<	O
strlen	function
(	O
str	pointer
)	O
;	O
}	O
void	O
filpatlist_add_pattern	function
(	O
filpatlist_t	pointer
*	O
fptr	pointer
,	O
struct	O
filename_pattern	struct
*	O
pat	pointer
)	O
{	O
grecs_list_ptr_t	pointer
list	pointer
;	O
if	O
(	O
!	O
*	O
fptr	pointer
)	O
{	O
*	O
fptr	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
fptr	pointer
)	O
)	O
;	O
(	O
*	O
fptr	pointer
)	O
->	O
list	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
(	O
*	O
fptr	pointer
)	O
->	O
list	pointer
->	O
free_entry	pointer
=	O
filename_pattern_free	function
;	O
}	O
list	pointer
=	O
(	O
*	O
fptr	pointer
)	O
->	O
list	pointer
;	O
grecs_list_append	function
(	O
list	pointer
,	O
pat	pointer
)	O
;	O
}	O
void	O
filpatlist_add_exact	function
(	O
filpatlist_t	pointer
*	O
fptr	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
struct	O
filename_pattern	struct
*	O
pat	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
pat	pointer
)	O
)	O
;	O
pat	pointer
->	O
neg	int
=	O
0	int
;	O
pat	pointer
->	O
type	enum
=	O
PAT_EXACT	int
;	O
pat	pointer
->	O
v	union
.	O
glob	pointer
=	O
estrdup	function
(	O
arg	pointer
)	O
;	O
filpatlist_add_pattern	function
(	O
fptr	pointer
,	O
pat	pointer
)	O
;	O
}	O
int	O
filpatlist_add	function
(	O
filpatlist_t	pointer
*	O
fptr	pointer
,	O
char	O
const	O
*	O
arg	pointer
,	O
grecs_locus_t	struct
*	O
loc	pointer
)	O
{	O
int	O
flags	int
=	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
;	O
struct	O
filename_pattern	struct
*	O
pat	pointer
;	O
pat	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
pat	pointer
)	O
)	O
;	O
if	O
(	O
*	O
arg	pointer
==	O
'!'	O
)	O
{	O
pat	pointer
->	O
neg	int
=	O
1	int
;	O
++	O
arg	pointer
;	O
}	O
else	O
pat	pointer
->	O
neg	int
=	O
0	int
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
q	pointer
,	O
*	O
p	pointer
;	O
pat	pointer
->	O
type	enum
=	O
PAT_REGEX	int
;	O
p	pointer
=	O
strchr	function
(	O
arg	pointer
+	O
1	int
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
grecs_error	function
(	O
loc	pointer
,	O
0	int
,	O
_	O
(	O
"unterminated regexp"	pointer
)	O
)	O
;	O
free	function
(	O
pat	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
q	pointer
=	O
p	pointer
+	O
1	int
;	O
*	O
q	pointer
;	O
q	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
q	pointer
)	O
{	O
case	O
'b'	O
:	O
flags	int
&=	O
~	O
REG_EXTENDED	int
;	O
break	O
;	O
case	O
'i'	O
:	O
flags	int
|=	O
REG_ICASE	O
;	O
break	O
;	O
default	O
:	O
grecs_error	function
(	O
loc	pointer
,	O
0	int
,	O
_	O
(	O
"unrecognized flag: %c"	pointer
)	O
,	O
*	O
q	pointer
)	O
;	O
free	function
(	O
pat	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
*	O
p	pointer
=	O
0	int
;	O
rc	int
=	O
regcomp	function
(	O
&	O
pat	pointer
->	O
v	union
.	O
re	struct
,	O
arg	pointer
+	O
1	int
,	O
flags	int
)	O
;	O
*	O
p	pointer
=	O
'/'	O
;	O
if	O
(	O
rc	int
)	O
{	O
char	O
errbuf	array
[	O
128	int
]	O
;	O
regerror	function
(	O
rc	int
,	O
&	O
pat	pointer
->	O
v	union
.	O
re	struct
,	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
)	O
;	O
grecs_error	function
(	O
loc	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
errbuf	array
)	O
;	O
filename_pattern_free	function
(	O
pat	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
pat	pointer
->	O
type	enum
=	O
is_glob	function
(	O
arg	pointer
)	O
?	O
PAT_GLOB	int
:	O
PAT_EXACT	int
;	O
pat	pointer
->	O
v	union
.	O
glob	pointer
=	O
estrdup	function
(	O
arg	pointer
)	O
;	O
}	O
filpatlist_add_pattern	function
(	O
fptr	pointer
,	O
pat	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
filpatlist_destroy	function
(	O
filpatlist_t	pointer
*	O
fptr	pointer
)	O
{	O
if	O
(	O
fptr	pointer
&&	O
*	O
fptr	pointer
)	O
{	O
grecs_list_free	function
(	O
(	O
*	O
fptr	pointer
)	O
->	O
list	pointer
)	O
;	O
free	function
(	O
*	O
fptr	pointer
)	O
;	O
*	O
fptr	pointer
=	O
NULL	O
;	O
}	O
}	O
int	O
filpatlist_is_empty	function
(	O
filpatlist_t	pointer
fp	pointer
)	O
{	O
if	O
(	O
!	O
fp	pointer
)	O
return	O
1	int
;	O
return	O
grecs_list_size	function
(	O
fp	pointer
->	O
list	pointer
)	O
==	O
0	int
;	O
}	O
int	O
filpatlist_match	function
(	O
filpatlist_t	pointer
fp	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
if	O
(	O
!	O
fp	pointer
||	O
!	O
fp	pointer
->	O
list	pointer
)	O
return	O
0	int
;	O
for	O
(	O
ep	pointer
=	O
fp	pointer
->	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
struct	O
filename_pattern	struct
*	O
pat	pointer
=	O
ep	pointer
->	O
data	pointer
;	O
int	O
rc	int
;	O
switch	O
(	O
pat	pointer
->	O
type	enum
)	O
{	O
case	O
PAT_EXACT	int
:	O
rc	int
=	O
strcmp	function
(	O
pat	pointer
->	O
v	union
.	O
glob	pointer
,	O
name	pointer
)	O
;	O
break	O
;	O
case	O
PAT_GLOB	int
:	O
rc	int
=	O
fnmatch	function
(	O
pat	pointer
->	O
v	union
.	O
glob	pointer
,	O
name	pointer
,	O
FNM_PATHNAME	O
)	O
;	O
break	O
;	O
case	O
PAT_REGEX	int
:	O
rc	int
=	O
regexec	function
(	O
&	O
pat	pointer
->	O
v	union
.	O
re	struct
,	O
name	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
pat	pointer
->	O
neg	int
)	O
rc	int
=	O
!	O
rc	int
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
