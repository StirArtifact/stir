struct	O
string_data	struct
{	O
int	O
color	int
;	O
int	O
size	int
;	O
int	O
origin	int
;	O
int	O
liberties	int
;	O
int	O
neighbors	int
;	O
int	O
mark	char
;	O
}	O
;	O
struct	O
string_liberties_data	struct
{	O
int	O
list	array
[	O
MAX_LIBERTIES	int
]	O
;	O
}	O
;	O
struct	O
string_neighbors_data	struct
{	O
int	O
list	array
[	O
MAXCHAIN	int
]	O
;	O
}	O
;	O
struct	O
change_stack_entry	struct
{	O
int	O
*	O
address	pointer
;	O
int	O
value	pointer
;	O
}	O
;	O
struct	O
vertex_stack_entry	struct
{	O
Intersection	char
*	O
address	pointer
;	O
int	O
value	pointer
;	O
}	O
;	O
static	O
struct	O
string_data	struct
string	int
[	O
MAX_STRINGS	O
]	O
;	O
static	O
struct	O
string_liberties_data	struct
string_libs	array
[	O
MAX_STRINGS	O
]	O
;	O
static	O
struct	O
string_neighbors_data	struct
string_neighbors	array
[	O
MAX_STRINGS	O
]	O
;	O
static	O
struct	O
change_stack_entry	struct
change_stack	array
[	O
STACK_SIZE	O
]	O
;	O
static	O
struct	O
change_stack_entry	struct
*	O
change_stack_pointer	pointer
;	O
static	O
struct	O
vertex_stack_entry	struct
vertex_stack	array
[	O
STACK_SIZE	O
]	O
;	O
static	O
struct	O
vertex_stack_entry	struct
*	O
vertex_stack_pointer	pointer
;	O
static	O
int	O
string_number	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
next_stone	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
next_string	int
;	O
static	O
int	O
ml	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
liberty_mark	int
;	O
static	O
int	O
string_mark	int
;	O
static	O
void	O
really_do_trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
do_trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
ignore_ko	int
)	O
;	O
static	O
void	O
undo_trymove	function
(	O
void	O
)	O
;	O
static	O
int	O
do_approxlib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
;	O
static	O
int	O
slow_approxlib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
;	O
static	O
int	O
do_accuratelib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
;	O
static	O
int	O
is_superko_violation	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
enum	O
ko_rules	enum
type	enum
)	O
;	O
static	O
void	O
new_position	function
(	O
void	O
)	O
;	O
static	O
int	O
propagate_string	function
(	O
int	O
stone	int
,	O
int	O
str	int
)	O
;	O
static	O
void	O
find_liberties_and_neighbors	function
(	O
int	O
s	int
)	O
;	O
static	O
int	O
do_remove_string	function
(	O
int	O
s	int
)	O
;	O
static	O
void	O
do_commit_suicide	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
void	O
do_play_move	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
komaster	int
,	O
kom_pos	int
;	O
static	O
int	O
trymove_counter	int
=	O
0	int
;	O
int	O
deltai	array
[	O
8	int
]	O
=	O
{	O
1	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
}	O
;	O
int	O
deltaj	array
[	O
8	int
]	O
=	O
{	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
int	O
delta	array
[	O
8	int
]	O
=	O
{	O
NS	O
,	O
-	O
1	int
,	O
-	O
NS	O
,	O
1	int
,	O
NS	O
-	O
1	int
,	O
-	O
NS	O
-	O
1	int
,	O
-	O
NS	O
+	O
1	int
,	O
NS	O
+	O
1	int
}	O
;	O
void	O
store_board	function
(	O
struct	O
board_state	struct
*	O
state	pointer
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
state	pointer
->	O
board_size	int
=	O
board_size	int
;	O
memcpy	function
(	O
state	pointer
->	O
board	pointer
,	O
board	pointer
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
memcpy	function
(	O
state	pointer
->	O
initial_board	array
,	O
initial_board	array
,	O
sizeof	O
(	O
initial_board	array
)	O
)	O
;	O
state	pointer
->	O
board_ko_pos	int
=	O
board_ko_pos	int
;	O
state	pointer
->	O
white_captured	int
=	O
white_captured	int
;	O
state	pointer
->	O
black_captured	int
=	O
black_captured	int
;	O
state	pointer
->	O
initial_board_ko_pos	int
=	O
initial_board_ko_pos	int
;	O
state	pointer
->	O
initial_white_captured	int
=	O
initial_white_captured	int
;	O
state	pointer
->	O
initial_black_captured	int
=	O
initial_black_captured	int
;	O
state	pointer
->	O
move_history_pointer	int
=	O
move_history_pointer	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
move_history_pointer	int
;	O
k	int
++	O
)	O
{	O
state	pointer
->	O
move_history_color	array
[	O
k	int
]	O
=	O
move_history_color	array
[	O
k	int
]	O
;	O
state	pointer
->	O
move_history_pos	array
[	O
k	int
]	O
=	O
move_history_pos	array
[	O
k	int
]	O
;	O
state	pointer
->	O
move_history_hash	array
[	O
k	int
]	O
=	O
move_history_hash	array
[	O
k	int
]	O
;	O
}	O
state	pointer
->	O
komi	float
=	O
komi	float
;	O
state	pointer
->	O
handicap	int
=	O
handicap	int
;	O
state	pointer
->	O
move_number	int
=	O
movenum	int
;	O
}	O
void	O
restore_board	function
(	O
struct	O
board_state	struct
*	O
state	pointer
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
board_size	int
=	O
state	pointer
->	O
board_size	int
;	O
memcpy	function
(	O
board	pointer
,	O
state	pointer
->	O
board	pointer
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
memcpy	function
(	O
initial_board	array
,	O
state	pointer
->	O
initial_board	array
,	O
sizeof	O
(	O
initial_board	array
)	O
)	O
;	O
board_ko_pos	int
=	O
state	pointer
->	O
board_ko_pos	int
;	O
white_captured	int
=	O
state	pointer
->	O
white_captured	int
;	O
black_captured	int
=	O
state	pointer
->	O
black_captured	int
;	O
initial_board_ko_pos	int
=	O
state	pointer
->	O
initial_board_ko_pos	int
;	O
initial_white_captured	int
=	O
state	pointer
->	O
initial_white_captured	int
;	O
initial_black_captured	int
=	O
state	pointer
->	O
initial_black_captured	int
;	O
move_history_pointer	int
=	O
state	pointer
->	O
move_history_pointer	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
move_history_pointer	int
;	O
k	int
++	O
)	O
{	O
move_history_color	array
[	O
k	int
]	O
=	O
state	pointer
->	O
move_history_color	array
[	O
k	int
]	O
;	O
move_history_pos	array
[	O
k	int
]	O
=	O
state	pointer
->	O
move_history_pos	array
[	O
k	int
]	O
;	O
move_history_hash	array
[	O
k	int
]	O
=	O
state	pointer
->	O
move_history_hash	array
[	O
k	int
]	O
;	O
}	O
komi	float
=	O
state	pointer
->	O
komi	float
;	O
handicap	int
=	O
state	pointer
->	O
handicap	int
;	O
movenum	int
=	O
state	pointer
->	O
move_number	int
;	O
hashdata_recalc	function
(	O
&	O
board_hash	struct
,	O
board	pointer
,	O
board_ko_pos	int
)	O
;	O
new_position	function
(	O
)	O
;	O
}	O
void	O
clear_board	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
board_size	int
>	O
0	int
&&	O
board_size	int
<=	O
MAX_BOARD	int
)	O
;	O
memset	function
(	O
board	pointer
,	O
EMPTY	int
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
memset	function
(	O
initial_board	array
,	O
EMPTY	int
,	O
sizeof	O
(	O
initial_board	array
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
BOARDSIZE	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
I	O
(	O
k	int
)	O
,	O
J	O
(	O
k	int
)	O
)	O
)	O
{	O
board	pointer
[	O
k	int
]	O
=	O
GRAY	int
;	O
initial_board	array
[	O
k	int
]	O
=	O
GRAY	int
;	O
}	O
}	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
white_captured	int
=	O
0	int
;	O
black_captured	int
=	O
0	int
;	O
komaster	int
=	O
EMPTY	int
;	O
kom_pos	int
=	O
NO_MOVE	O
;	O
initial_board_ko_pos	int
=	O
NO_MOVE	O
;	O
initial_white_captured	int
=	O
0	int
;	O
initial_black_captured	int
=	O
0	int
;	O
move_history_pointer	int
=	O
0	int
;	O
movenum	int
=	O
0	int
;	O
handicap	int
=	O
0	int
;	O
hashdata_recalc	function
(	O
&	O
board_hash	struct
,	O
board	pointer
,	O
board_ko_pos	int
)	O
;	O
new_position	function
(	O
)	O
;	O
}	O
int	O
test_gray_border	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
board_size	int
>	O
0	int
&&	O
board_size	int
<=	O
MAX_BOARD	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
BOARDSIZE	O
;	O
k	int
++	O
)	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
I	O
(	O
k	int
)	O
,	O
J	O
(	O
k	int
)	O
)	O
)	O
if	O
(	O
board	pointer
[	O
k	int
]	O
!=	O
GRAY	int
)	O
return	O
k	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
stack	array
[	O
MAXSTACK	O
]	O
;	O
static	O
int	O
move_color	array
[	O
MAXSTACK	O
]	O
;	O
static	O
Hash_data	struct
board_hash_stack	array
[	O
MAXSTACK	O
]	O
;	O
int	O
trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	pointer
,	O
int	O
str	int
)	O
{	O
UNUSED	O
(	O
str	int
)	O
;	O
if	O
(	O
!	O
do_trymove	function
(	O
pos	int
,	O
color	int
,	O
0	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
if	O
(	O
message	pointer
==	O
NULL	O
)	O
message	pointer
=	O
"UNKNOWN"	pointer
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
if	O
(	O
komaster	int
!=	O
EMPTY	int
)	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"%s (variation %d, hash %s, komaster %s:%s)"	pointer
,	O
message	pointer
,	O
count_variations	int
,	O
hashdata_to_string	function
(	O
&	O
board_hash	struct
)	O
,	O
color_to_string	function
(	O
komaster	int
)	O
,	O
location_to_string	function
(	O
kom_pos	int
)	O
)	O
;	O
else	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"%s (variation %d, hash %s)"	pointer
,	O
message	pointer
,	O
count_variations	int
,	O
hashdata_to_string	function
(	O
&	O
board_hash	struct
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
komaster	int
!=	O
EMPTY	int
)	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"%s at %s (variation %d, hash %s, komaster %s:%s)"	pointer
,	O
message	pointer
,	O
location_to_string	function
(	O
pos	int
)	O
,	O
count_variations	int
,	O
hashdata_to_string	function
(	O
&	O
board_hash	struct
)	O
,	O
color_to_string	function
(	O
komaster	int
)	O
,	O
location_to_string	function
(	O
kom_pos	int
)	O
)	O
;	O
else	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"%s at %s (variation %d, hash %s)"	pointer
,	O
message	pointer
,	O
location_to_string	function
(	O
pos	int
)	O
,	O
count_variations	int
,	O
hashdata_to_string	function
(	O
&	O
board_hash	struct
)	O
)	O
;	O
}	O
sgftreeAddPlayLast	function
(	O
sgf_dumptree	pointer
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
count_variations	int
)	O
count_variations	int
++	O
;	O
stats	struct
.	O
nodes	int
++	O
;	O
return	O
1	int
;	O
}	O
int	O
tryko	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	pointer
)	O
{	O
if	O
(	O
!	O
do_trymove	function
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
if	O
(	O
message	pointer
==	O
NULL	O
)	O
message	pointer
=	O
"UNKNOWN"	pointer
;	O
if	O
(	O
komaster	int
!=	O
EMPTY	int
)	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"tryko: %s (variation %d, %s, komaster %s:%s)"	pointer
,	O
message	pointer
,	O
count_variations	int
,	O
hashdata_to_string	function
(	O
&	O
board_hash	struct
)	O
,	O
color_to_string	function
(	O
komaster	int
)	O
,	O
location_to_string	function
(	O
kom_pos	int
)	O
)	O
;	O
else	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"tryko: %s (variation %d, %s)"	pointer
,	O
message	pointer
,	O
count_variations	int
,	O
hashdata_to_string	function
(	O
&	O
board_hash	struct
)	O
)	O
;	O
sgftreeAddPlayLast	function
(	O
sgf_dumptree	pointer
,	O
color	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"tenuki (ko threat)"	pointer
)	O
;	O
sgftreeAddPlayLast	function
(	O
sgf_dumptree	pointer
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"tenuki (answers ko threat)"	pointer
)	O
;	O
sgftreeAddPlayLast	function
(	O
sgf_dumptree	pointer
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
count_variations	int
)	O
count_variations	int
++	O
;	O
stats	struct
.	O
nodes	int
++	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
really_do_trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
BEGIN_CHANGE_RECORD	O
(	O
)	O
;	O
PUSH_VALUE	O
(	O
board_ko_pos	int
)	O
;	O
memcpy	function
(	O
&	O
board_hash_stack	array
[	O
stackp	int
]	O
,	O
&	O
board_hash	struct
,	O
sizeof	O
(	O
board_hash	struct
)	O
)	O
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
board_hash	struct
,	O
board_ko_pos	int
)	O
;	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
stackp	int
++	O
;	O
if	O
(	O
pos	int
!=	O
PASS_MOVE	int
)	O
{	O
PUSH_VALUE	O
(	O
black_captured	int
)	O
;	O
PUSH_VALUE	O
(	O
white_captured	int
)	O
;	O
do_play_move	function
(	O
pos	int
,	O
color	int
)	O
;	O
}	O
}	O
static	O
int	O
do_trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
ignore_ko	int
)	O
{	O
gg_assert	O
(	O
color	int
==	O
BLACK	int
||	O
color	int
==	O
WHITE	int
)	O
;	O
if	O
(	O
pos	int
!=	O
PASS_MOVE	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
shadow	array
[	O
pos	int
]	O
=	O
1	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
ignore_ko	int
&&	O
pos	int
==	O
board_ko_pos	int
)	O
{	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
is_suicide	function
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
>=	O
MAXSTACK	O
-	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: Truncating search. This is beyond my reading ability!\n"	pointer
)	O
;	O
if	O
(	O
0	int
)	O
{	O
ASSERT1	O
(	O
0	int
&&	O
"trymove stack overflow"	pointer
,	O
pos	int
)	O
;	O
}	O
fflush	function
(	O
stderr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
trymove_counter	int
++	O
;	O
stack	array
[	O
stackp	int
]	O
=	O
pos	int
;	O
move_color	array
[	O
stackp	int
]	O
=	O
color	int
;	O
really_do_trymove	function
(	O
pos	int
,	O
color	int
)	O
;	O
return	O
1	int
;	O
}	O
void	O
popgo	function
(	O
)	O
{	O
undo_trymove	function
(	O
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
int	O
is_tryko	int
=	O
0	int
;	O
char	O
*	O
sgf_comment	pointer
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
sgf_dumptree	pointer
->	O
lastnode	pointer
,	O
"C "	pointer
,	O
&	O
sgf_comment	pointer
)	O
&&	O
strncmp	function
(	O
sgf_comment	pointer
,	O
"tryko:"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
is_tryko	int
=	O
1	int
;	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"(next variation: %d)"	pointer
,	O
count_variations	int
)	O
;	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
sgf_dumptree	pointer
->	O
lastnode	pointer
=	O
sgf_dumptree	pointer
->	O
lastnode	pointer
->	O
parent	pointer
;	O
if	O
(	O
is_tryko	int
)	O
sgf_dumptree	pointer
->	O
lastnode	pointer
=	O
sgf_dumptree	pointer
->	O
lastnode	pointer
->	O
parent	pointer
->	O
parent	pointer
;	O
}	O
}	O
static	O
void	O
undo_trymove	function
(	O
)	O
{	O
gg_assert	O
(	O
change_stack_pointer	pointer
-	O
change_stack	array
<=	O
STACK_SIZE	O
)	O
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"Change stack size = %d\n"	pointer
,	O
change_stack_pointer	pointer
-	O
change_stack	array
)	O
;	O
gprintf	function
(	O
"Vertex stack size = %d\n"	pointer
,	O
vertex_stack_pointer	pointer
-	O
vertex_stack	array
)	O
;	O
}	O
POP_MOVE	O
(	O
)	O
;	O
POP_VERTICES	O
(	O
)	O
;	O
stackp	int
--	O
;	O
memcpy	function
(	O
&	O
board_hash	struct
,	O
&	O
(	O
board_hash_stack	array
[	O
stackp	int
]	O
)	O
,	O
sizeof	O
(	O
board_hash	struct
)	O
)	O
;	O
}	O
void	O
dump_stack	function
(	O
void	O
)	O
{	O
do_dump_stack	function
(	O
)	O
;	O
if	O
(	O
count_variations	int
)	O
gprintf	function
(	O
"%o (variation %d)"	pointer
,	O
count_variations	int
-	O
1	int
)	O
;	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
void	O
do_dump_stack	function
(	O
void	O
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
stackp	int
;	O
n	int
++	O
)	O
gprintf	function
(	O
"%o%s:%1m "	pointer
,	O
move_color	array
[	O
n	int
]	O
==	O
BLACK	int
?	O
"B"	pointer
:	O
"W"	pointer
,	O
stack	array
[	O
n	int
]	O
)	O
;	O
}	O
static	O
void	O
reset_move_history	function
(	O
void	O
)	O
{	O
memcpy	function
(	O
initial_board	array
,	O
board	pointer
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
initial_board_ko_pos	int
=	O
board_ko_pos	int
;	O
initial_white_captured	int
=	O
white_captured	int
;	O
initial_black_captured	int
=	O
black_captured	int
;	O
move_history_pointer	int
=	O
0	int
;	O
}	O
void	O
add_stone	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
board	pointer
[	O
pos	int
]	O
=	O
color	int
;	O
hashdata_invert_stone	function
(	O
&	O
board_hash	struct
,	O
pos	int
,	O
color	int
)	O
;	O
reset_move_history	function
(	O
)	O
;	O
new_position	function
(	O
)	O
;	O
}	O
void	O
remove_stone	function
(	O
int	O
pos	int
)	O
{	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
,	O
pos	int
)	O
;	O
hashdata_invert_stone	function
(	O
&	O
board_hash	struct
,	O
pos	int
,	O
board	pointer
[	O
pos	int
]	O
)	O
;	O
board	pointer
[	O
pos	int
]	O
=	O
EMPTY	int
;	O
reset_move_history	function
(	O
)	O
;	O
new_position	function
(	O
)	O
;	O
}	O
static	O
void	O
play_move_no_history	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
update_internals	int
)	O
{	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
board_hash	struct
,	O
board_ko_pos	int
)	O
;	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
pos	int
!=	O
PASS_MOVE	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
is_suicide	function
(	O
pos	int
,	O
color	int
)	O
)	O
do_play_move	function
(	O
pos	int
,	O
color	int
)	O
;	O
else	O
do_commit_suicide	function
(	O
pos	int
,	O
color	int
)	O
;	O
}	O
if	O
(	O
update_internals	int
||	O
next_string	int
==	O
MAX_STRINGS	O
)	O
new_position	function
(	O
)	O
;	O
else	O
CLEAR_STACKS	O
(	O
)	O
;	O
}	O
static	O
void	O
replay_move_history	function
(	O
int	O
n	int
)	O
{	O
int	O
k	int
;	O
memcpy	function
(	O
board	pointer
,	O
initial_board	array
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
board_ko_pos	int
=	O
initial_board_ko_pos	int
;	O
white_captured	int
=	O
initial_white_captured	int
;	O
black_captured	int
=	O
initial_black_captured	int
;	O
new_position	function
(	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
play_move_no_history	function
(	O
move_history_pos	array
[	O
k	int
]	O
,	O
move_history_color	array
[	O
k	int
]	O
,	O
0	int
)	O
;	O
new_position	function
(	O
)	O
;	O
}	O
void	O
play_move	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
WHITE	int
||	O
color	int
==	O
BLACK	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
pos	int
==	O
PASS_MOVE	int
||	O
ON_BOARD1	O
(	O
pos	int
)	O
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
pos	int
==	O
PASS_MOVE	int
||	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
komaster	int
==	O
EMPTY	int
&&	O
kom_pos	int
==	O
NO_MOVE	O
,	O
pos	int
)	O
;	O
if	O
(	O
move_history_pointer	int
>=	O
MAX_MOVE_HISTORY	int
)	O
{	O
int	O
number_collapsed_moves	int
=	O
1	int
+	O
MAX_MOVE_HISTORY	int
/	O
10	int
;	O
int	O
k	int
;	O
Intersection	char
saved_board	array
[	O
BOARDSIZE	O
]	O
;	O
int	O
saved_board_ko_pos	int
=	O
board_ko_pos	int
;	O
int	O
saved_white_captured	int
=	O
white_captured	int
;	O
int	O
saved_black_captured	int
=	O
black_captured	int
;	O
memcpy	function
(	O
saved_board	array
,	O
board	pointer
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
replay_move_history	function
(	O
number_collapsed_moves	int
)	O
;	O
memcpy	function
(	O
initial_board	array
,	O
board	pointer
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
initial_board_ko_pos	int
=	O
board_ko_pos	int
;	O
initial_white_captured	int
=	O
white_captured	int
;	O
initial_black_captured	int
=	O
black_captured	int
;	O
for	O
(	O
k	int
=	O
number_collapsed_moves	int
;	O
k	int
<	O
move_history_pointer	int
;	O
k	int
++	O
)	O
{	O
move_history_color	array
[	O
k	int
-	O
number_collapsed_moves	int
]	O
=	O
move_history_color	array
[	O
k	int
]	O
;	O
move_history_pos	array
[	O
k	int
-	O
number_collapsed_moves	int
]	O
=	O
move_history_pos	array
[	O
k	int
]	O
;	O
move_history_hash	array
[	O
k	int
-	O
number_collapsed_moves	int
]	O
=	O
move_history_hash	array
[	O
k	int
]	O
;	O
}	O
move_history_pointer	int
-=	O
number_collapsed_moves	int
;	O
memcpy	function
(	O
board	pointer
,	O
saved_board	array
,	O
sizeof	O
(	O
board	pointer
)	O
)	O
;	O
board_ko_pos	int
=	O
saved_board_ko_pos	int
;	O
white_captured	int
=	O
saved_white_captured	int
;	O
black_captured	int
=	O
saved_black_captured	int
;	O
new_position	function
(	O
)	O
;	O
}	O
move_history_color	array
[	O
move_history_pointer	int
]	O
=	O
color	int
;	O
move_history_pos	array
[	O
move_history_pointer	int
]	O
=	O
pos	int
;	O
move_history_hash	array
[	O
move_history_pointer	int
]	O
=	O
board_hash	struct
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
move_history_hash	array
[	O
move_history_pointer	int
]	O
,	O
board_ko_pos	int
)	O
;	O
move_history_pointer	int
++	O
;	O
play_move_no_history	function
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
;	O
movenum	int
++	O
;	O
}	O
int	O
undo_move	function
(	O
int	O
n	int
)	O
{	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
move_history_pointer	int
<	O
n	int
)	O
return	O
0	int
;	O
replay_move_history	function
(	O
move_history_pointer	int
-	O
n	int
)	O
;	O
move_history_pointer	int
-=	O
n	int
;	O
movenum	int
-=	O
n	int
;	O
return	O
1	int
;	O
}	O
int	O
get_last_opponent_move	function
(	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
move_history_pointer	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
move_history_color	array
[	O
k	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
move_history_pos	array
[	O
k	int
]	O
;	O
return	O
PASS_MOVE	int
;	O
}	O
int	O
get_last_move	function
(	O
)	O
{	O
if	O
(	O
move_history_pointer	int
==	O
0	int
)	O
return	O
PASS_MOVE	int
;	O
return	O
move_history_pos	array
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
}	O
int	O
get_last_player	function
(	O
)	O
{	O
if	O
(	O
move_history_pointer	int
==	O
0	int
)	O
return	O
EMPTY	int
;	O
return	O
move_history_color	array
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
}	O
int	O
is_pass	function
(	O
int	O
pos	int
)	O
{	O
return	O
pos	int
==	O
0	int
;	O
}	O
int	O
is_legal	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
return	O
1	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
pos	int
==	O
board_ko_pos	int
)	O
{	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
stackp	int
>=	O
MAXSTACK	O
-	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: Truncating search. This is beyond my reading ability!\n"	pointer
)	O
;	O
if	O
(	O
0	int
)	O
{	O
ASSERT1	O
(	O
0	int
&&	O
"is_legal stack overflow"	pointer
,	O
pos	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
is_suicide	function
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
is_suicide	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
is_illegal_ko_capture	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
return	O
(	O
pos	int
==	O
board_ko_pos	int
&&	O
(	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
||	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
)	O
;	O
}	O
int	O
is_allowed_move	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
return	O
1	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
ko_rule	enum
!=	O
NONE	int
&&	O
pos	int
==	O
board_ko_pos	int
&&	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
is_suicide	function
(	O
pos	int
,	O
color	int
)	O
)	O
if	O
(	O
suicide_rule	enum
==	O
FORBIDDEN	int
||	O
(	O
suicide_rule	enum
==	O
ALLOWED	int
&&	O
!	O
has_neighbor	function
(	O
pos	int
,	O
color	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
is_superko_violation	function
(	O
pos	int
,	O
color	int
,	O
ko_rule	enum
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
set_new_komaster	function
(	O
int	O
new_komaster	int
)	O
{	O
PUSH_VALUE	O
(	O
komaster	int
)	O
;	O
hashdata_invert_komaster	function
(	O
&	O
board_hash	struct
,	O
komaster	int
)	O
;	O
komaster	int
=	O
new_komaster	int
;	O
hashdata_invert_komaster	function
(	O
&	O
board_hash	struct
,	O
komaster	int
)	O
;	O
}	O
static	O
void	O
set_new_kom_pos	function
(	O
int	O
new_kom_pos	int
)	O
{	O
PUSH_VALUE	O
(	O
kom_pos	int
)	O
;	O
hashdata_invert_kom_pos	function
(	O
&	O
board_hash	struct
,	O
kom_pos	int
)	O
;	O
kom_pos	int
=	O
new_kom_pos	int
;	O
hashdata_invert_kom_pos	function
(	O
&	O
board_hash	struct
,	O
kom_pos	int
)	O
;	O
}	O
int	O
komaster_trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	pointer
,	O
int	O
str	int
,	O
int	O
*	O
is_conditional_ko	pointer
,	O
int	O
consider_conditional_ko	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
ko_move	int
;	O
int	O
kpos	int
;	O
int	O
previous_board_ko_pos	int
=	O
board_ko_pos	int
;	O
*	O
is_conditional_ko	pointer
=	O
0	int
;	O
ko_move	int
=	O
is_ko	function
(	O
pos	int
,	O
color	int
,	O
&	O
kpos	int
)	O
;	O
if	O
(	O
ko_move	int
)	O
{	O
if	O
(	O
komaster	int
==	O
other	int
&&	O
pos	int
==	O
kom_pos	int
)	O
return	O
0	int
;	O
if	O
(	O
komaster	int
==	O
GRAY_WHITE	int
||	O
komaster	int
==	O
GRAY_BLACK	int
)	O
return	O
0	int
;	O
if	O
(	O
komaster	int
==	O
color	int
&&	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
kpos	int
,	O
kom_pos	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
komaster	int
==	O
WEAK_KO	int
)	O
{	O
if	O
(	O
pos	int
!=	O
board_ko_pos	int
&&	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
kpos	int
,	O
kom_pos	int
)	O
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
message	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
!	O
consider_conditional_ko	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
tryko	function
(	O
pos	int
,	O
color	int
,	O
message	pointer
)	O
)	O
return	O
0	int
;	O
*	O
is_conditional_ko	pointer
=	O
1	int
;	O
if	O
(	O
komaster	int
==	O
EMPTY	int
||	O
komaster	int
==	O
WEAK_KO	int
)	O
{	O
set_new_komaster	function
(	O
color	int
)	O
;	O
set_new_kom_pos	function
(	O
kpos	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
if	O
(	O
(	O
(	O
komaster	int
==	O
color	int
||	O
(	O
komaster	int
==	O
GRAY_WHITE	int
&&	O
color	int
==	O
WHITE	int
)	O
||	O
(	O
komaster	int
==	O
GRAY_BLACK	int
&&	O
color	int
==	O
BLACK	int
)	O
)	O
&&	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
kom_pos	int
]	O
)	O
||	O
(	O
!	O
is_ko	function
(	O
kom_pos	int
,	O
other	int
,	O
NULL	O
)	O
&&	O
is_suicide	function
(	O
kom_pos	int
,	O
other	int
)	O
)	O
)	O
)	O
)	O
{	O
set_new_komaster	function
(	O
EMPTY	int
)	O
;	O
set_new_kom_pos	function
(	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
komaster	int
==	O
WEAK_KO	int
)	O
{	O
set_new_komaster	function
(	O
EMPTY	int
)	O
;	O
set_new_kom_pos	function
(	O
NO_MOVE	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
if	O
(	O
komaster	int
==	O
other	int
)	O
{	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
set_new_komaster	function
(	O
GRAY_BLACK	int
)	O
;	O
else	O
set_new_komaster	function
(	O
GRAY_WHITE	int
)	O
;	O
}	O
else	O
if	O
(	O
komaster	int
==	O
color	int
)	O
{	O
set_new_kom_pos	function
(	O
kpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
previous_board_ko_pos	int
!=	O
NO_MOVE	O
)	O
{	O
set_new_komaster	function
(	O
WEAK_KO	int
)	O
;	O
set_new_kom_pos	function
(	O
previous_board_ko_pos	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
get_komaster	function
(	O
)	O
{	O
return	O
komaster	int
;	O
}	O
int	O
get_kom_pos	function
(	O
)	O
{	O
return	O
kom_pos	int
;	O
}	O
int	O
is_edge_vertex	function
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
SW	O
(	O
pos	int
)	O
)	O
||	O
!	O
ON_BOARD	O
(	O
NE	O
(	O
pos	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
edge_distance	function
(	O
int	O
pos	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
return	O
gg_min	O
(	O
gg_min	O
(	O
i	int
,	O
board_size	int
-	O
1	int
-	O
i	int
)	O
,	O
gg_min	O
(	O
j	int
,	O
board_size	int
-	O
1	int
-	O
j	int
)	O
)	O
;	O
}	O
int	O
is_corner_vertex	function
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
(	O
!	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
||	O
!	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
&&	O
(	O
!	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
||	O
!	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rotate1	function
(	O
int	O
pos	int
,	O
int	O
rot	int
)	O
{	O
int	O
bs	int
=	O
board_size	int
-	O
1	int
;	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
gg_assert	O
(	O
rot	int
>=	O
0	int
&&	O
rot	int
<	O
8	int
)	O
;	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
return	O
PASS_MOVE	int
;	O
if	O
(	O
rot	int
==	O
0	int
)	O
return	O
pos	int
;	O
if	O
(	O
rot	int
==	O
1	int
)	O
return	O
POS	O
(	O
bs	int
-	O
j	int
,	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
2	int
)	O
return	O
POS	O
(	O
bs	int
-	O
i	int
,	O
bs	int
-	O
j	int
)	O
;	O
if	O
(	O
rot	int
==	O
3	int
)	O
return	O
POS	O
(	O
j	int
,	O
bs	int
-	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
4	int
)	O
return	O
POS	O
(	O
j	int
,	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
5	int
)	O
return	O
POS	O
(	O
bs	int
-	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
rot	int
==	O
6	int
)	O
return	O
POS	O
(	O
bs	int
-	O
j	int
,	O
bs	int
-	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
7	int
)	O
return	O
POS	O
(	O
i	int
,	O
bs	int
-	O
j	int
)	O
;	O
return	O
PASS_MOVE	int
;	O
}	O
int	O
are_neighbors	function
(	O
int	O
pos1	int
,	O
int	O
pos2	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos1	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
return	O
(	O
gg_abs	O
(	O
pos1	int
-	O
pos2	int
)	O
==	O
NS	O
||	O
gg_abs	O
(	O
pos1	int
-	O
pos2	int
)	O
==	O
WE	int
)	O
;	O
else	O
return	O
neighbor_of_string	function
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
return	O
neighbor_of_string	function
(	O
pos2	int
,	O
pos1	int
)	O
;	O
else	O
return	O
adjacent_strings	function
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
}	O
int	O
countlib	function
(	O
int	O
str	int
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
return	O
string	int
[	O
string_number	array
[	O
str	int
]	O
]	O
.	O
liberties	int
;	O
}	O
int	O
findlib	function
(	O
int	O
str	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
k	int
;	O
int	O
liberties	int
;	O
int	O
s	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
libs	pointer
!=	O
NULL	O
,	O
str	int
)	O
;	O
s	int
=	O
string_number	array
[	O
str	int
]	O
;	O
liberties	int
=	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties	int
<=	O
MAX_LIBERTIES	int
||	O
maxlib	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
maxlib	int
&&	O
k	int
<	O
liberties	int
;	O
k	int
++	O
)	O
libs	pointer
[	O
k	int
]	O
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
}	O
else	O
{	O
int	O
pos	int
;	O
liberty_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
,	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
k	int
<	O
maxlib	int
&&	O
k	int
<	O
liberties	int
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	pointer
[	O
k	int
++	O
]	O
=	O
SOUTH	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	pointer
[	O
k	int
++	O
]	O
=	O
WEST	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	pointer
[	O
k	int
++	O
]	O
=	O
NORTH	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	pointer
[	O
k	int
++	O
]	O
=	O
EAST	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
}	O
}	O
return	O
liberties	int
;	O
}	O
int	O
fastlib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
ignore_captures	int
)	O
{	O
int	O
ally1	int
=	O
-	O
1	int
;	O
int	O
ally2	int
=	O
-	O
1	int
;	O
int	O
fast_liberties	int
=	O
0	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
ally1	int
=	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
{	O
ally2	int
=	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
&&	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally2	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
ally2	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
{	O
if	O
(	O
ally2	int
<	O
0	int
)	O
ally2	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
else	O
if	O
(	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally2	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
ally1	int
=	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
{	O
ally2	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
&&	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally2	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
ally2	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
ally1	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
ally2	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
ally1	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
ignore_captures	int
)	O
{	O
if	O
(	O
ally1	int
<	O
0	int
)	O
{	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
ally2	int
<	O
0	int
)	O
{	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
fast_liberties	int
+=	O
string	int
[	O
ally1	int
]	O
.	O
liberties	int
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
fast_liberties	int
+=	O
string	int
[	O
ally1	int
]	O
.	O
liberties	int
+	O
string	int
[	O
ally2	int
]	O
.	O
liberties	int
-	O
count_common_libs	function
(	O
string	int
[	O
ally1	int
]	O
.	O
origin	int
,	O
string	int
[	O
ally2	int
]	O
.	O
origin	int
)	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
LIBERTY	O
(	O
neighbor	int
)	O
&&	O
(	O
ally1	int
<	O
0	int
||	O
!	O
NEIGHBOR_OF_STRING	O
(	O
neighbor	int
,	O
ally1	int
,	O
color	int
)	O
)	O
&&	O
(	O
ally2	int
<	O
0	int
||	O
!	O
NEIGHBOR_OF_STRING	O
(	O
neighbor	int
,	O
ally2	int
,	O
color	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
neighbor	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
LIBERTIES	O
(	O
neighbor	int
)	O
==	O
1	int
)	O
{	O
int	O
neighbor_size	int
=	O
COUNTSTONES	O
(	O
neighbor	int
)	O
;	O
if	O
(	O
neighbor_size	int
==	O
1	int
||	O
(	O
neighbor_size	int
==	O
2	int
&&	O
ally1	int
<	O
0	int
)	O
)	O
fast_liberties	int
++	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
ally1	int
>=	O
0	int
)	O
{	O
fast_liberties	int
+=	O
string	int
[	O
ally1	int
]	O
.	O
liberties	int
-	O
1	int
;	O
if	O
(	O
ally2	int
>=	O
0	int
)	O
fast_liberties	int
+=	O
string	int
[	O
ally2	int
]	O
.	O
liberties	int
-	O
count_common_libs	function
(	O
string	int
[	O
ally1	int
]	O
.	O
origin	int
,	O
string	int
[	O
ally2	int
]	O
.	O
origin	int
)	O
;	O
}	O
}	O
return	O
fast_liberties	int
;	O
}	O
struct	O
board_cache_entry	struct
{	O
int	O
threshold	int
;	O
int	O
liberties	int
;	O
Hash_data	struct
position_hash	struct
;	O
}	O
;	O
static	O
struct	O
board_cache_entry	struct
approxlib_cache	array
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
void	O
clear_approxlib_cache	function
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
approxlib_cache	array
[	O
pos	int
]	O
[	O
0	int
]	O
.	O
threshold	int
=	O
0	int
;	O
approxlib_cache	array
[	O
pos	int
]	O
[	O
1	int
]	O
.	O
threshold	int
=	O
0	int
;	O
}	O
}	O
int	O
approxlib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
liberties	int
;	O
struct	O
board_cache_entry	struct
*	O
entry	pointer
=	O
&	O
approxlib_cache	array
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
libs	pointer
)	O
{	O
if	O
(	O
hashdata_is_equal	O
(	O
board_hash	struct
,	O
entry	pointer
->	O
position_hash	struct
)	O
&&	O
maxlib	int
<=	O
entry	pointer
->	O
threshold	int
)	O
{	O
return	O
entry	pointer
->	O
liberties	int
;	O
}	O
liberties	int
=	O
fastlib	function
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
;	O
if	O
(	O
liberties	int
>=	O
0	int
)	O
{	O
entry	pointer
->	O
threshold	int
=	O
MAXLIBS	O
;	O
entry	pointer
->	O
liberties	int
=	O
liberties	int
;	O
entry	pointer
->	O
position_hash	struct
=	O
board_hash	struct
;	O
return	O
liberties	int
;	O
}	O
}	O
entry	pointer
->	O
threshold	int
=	O
maxlib	int
;	O
if	O
(	O
maxlib	int
<=	O
MAX_LIBERTIES	int
)	O
liberties	int
=	O
do_approxlib	function
(	O
pos	int
,	O
color	int
,	O
maxlib	int
,	O
libs	pointer
)	O
;	O
else	O
liberties	int
=	O
slow_approxlib	function
(	O
pos	int
,	O
color	int
,	O
maxlib	int
,	O
libs	pointer
)	O
;	O
entry	pointer
->	O
liberties	int
=	O
liberties	int
;	O
entry	pointer
->	O
position_hash	struct
=	O
board_hash	struct
;	O
return	O
liberties	int
;	O
}	O
static	O
int	O
do_approxlib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
k	int
;	O
int	O
liberties	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
MARK_LIBERTY	O
(	O
pos	int
)	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
SOUTH	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
WEST	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
NORTH	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
EAST	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
!=	O
NULL	O
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
libs	pointer
)	O
approxlib_cache	array
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
.	O
threshold	int
=	O
MAXLIBS	O
;	O
return	O
liberties	int
;	O
}	O
static	O
int	O
slow_approxlib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
k	int
;	O
int	O
liberties	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
MARK_LIBERTY	O
(	O
pos	int
)	O
;	O
string_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos	int
+	O
d	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
pos	int
+	O
d	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
==	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
pos	int
+	O
d	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
d	int
]	O
==	O
color	int
&&	O
UNMARKED_STRING	O
(	O
pos	int
+	O
d	int
)	O
)	O
{	O
int	O
s	int
=	O
string_number	array
[	O
pos	int
+	O
d	int
]	O
;	O
int	O
pos2	int
;	O
pos2	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
4	int
;	O
l	int
++	O
)	O
{	O
int	O
d2	int
=	O
delta	array
[	O
l	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos2	int
+	O
d2	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
pos2	int
+	O
d2	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
==	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
pos2	int
+	O
d2	int
)	O
;	O
}	O
}	O
pos2	int
=	O
NEXT_STONE	O
(	O
pos2	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos2	int
)	O
)	O
;	O
MARK_STRING	O
(	O
pos	int
+	O
d	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
libs	pointer
)	O
approxlib_cache	array
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
.	O
threshold	int
=	O
MAXLIBS	O
;	O
return	O
liberties	int
;	O
}	O
static	O
struct	O
board_cache_entry	struct
accuratelib_cache	array
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
void	O
clear_accuratelib_cache	function
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
accuratelib_cache	array
[	O
pos	int
]	O
[	O
0	int
]	O
.	O
threshold	int
=	O
0	int
;	O
accuratelib_cache	array
[	O
pos	int
]	O
[	O
1	int
]	O
.	O
threshold	int
=	O
0	int
;	O
}	O
}	O
int	O
accuratelib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
liberties	int
;	O
struct	O
board_cache_entry	struct
*	O
entry	pointer
=	O
&	O
accuratelib_cache	array
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
libs	pointer
)	O
{	O
if	O
(	O
hashdata_is_equal	O
(	O
board_hash	struct
,	O
entry	pointer
->	O
position_hash	struct
)	O
&&	O
maxlib	int
<=	O
entry	pointer
->	O
threshold	int
)	O
{	O
return	O
entry	pointer
->	O
liberties	int
;	O
}	O
liberties	int
=	O
fastlib	function
(	O
pos	int
,	O
color	int
,	O
0	int
)	O
;	O
if	O
(	O
liberties	int
>=	O
0	int
)	O
{	O
entry	pointer
->	O
threshold	int
=	O
MAXLIBS	O
;	O
entry	pointer
->	O
liberties	int
=	O
liberties	int
;	O
entry	pointer
->	O
position_hash	struct
=	O
board_hash	struct
;	O
return	O
liberties	int
;	O
}	O
}	O
liberties	int
=	O
do_accuratelib	function
(	O
pos	int
,	O
color	int
,	O
maxlib	int
,	O
libs	pointer
)	O
;	O
entry	pointer
->	O
threshold	int
=	O
liberties	int
<	O
maxlib	int
?	O
MAXLIBS	O
:	O
maxlib	int
;	O
entry	pointer
->	O
liberties	int
=	O
liberties	int
;	O
entry	pointer
->	O
position_hash	struct
=	O
board_hash	struct
;	O
return	O
liberties	int
;	O
}	O
static	O
int	O
do_accuratelib	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
k	int
,	O
l	int
;	O
int	O
liberties	int
=	O
0	int
;	O
int	O
lib	int
;	O
int	O
captured	array
[	O
4	int
]	O
;	O
int	O
captures	int
=	O
0	int
;	O
string_mark	int
++	O
;	O
liberty_mark	int
++	O
;	O
MARK_LIBERTY	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos2	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
pos2	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
pos2	int
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
pos2	int
,	O
color	int
)	O
)	O
{	O
struct	O
string_data	struct
*	O
s	int
=	O
&	O
string	int
[	O
string_number	array
[	O
pos2	int
]	O
]	O
;	O
struct	O
string_liberties_data	struct
*	O
sl	pointer
=	O
&	O
string_libs	array
[	O
string_number	array
[	O
pos2	int
]	O
]	O
;	O
if	O
(	O
s	int
->	O
liberties	int
<=	O
MAX_LIBERTIES	int
||	O
maxlib	int
<=	O
MAX_LIBERTIES	int
-	O
1	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
s	int
->	O
liberties	int
;	O
l	int
++	O
)	O
{	O
lib	int
=	O
sl	pointer
->	O
list	array
[	O
l	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
int	O
stone	int
=	O
pos2	int
;	O
do	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
SOUTH	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
SOUTH	O
(	O
stone	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
WEST	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
WEST	O
(	O
stone	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
NORTH	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
NORTH	O
(	O
stone	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
EAST	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
EAST	O
(	O
stone	int
)	O
)	O
;	O
}	O
stone	int
=	O
NEXT_STONE	O
(	O
stone	int
)	O
;	O
}	O
while	O
(	O
stone	int
!=	O
pos2	int
)	O
;	O
}	O
MARK_STRING	O
(	O
pos2	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
string	int
[	O
string_number	array
[	O
pos2	int
]	O
]	O
.	O
liberties	int
==	O
1	int
)	O
{	O
captured	array
[	O
captures	int
++	O
]	O
=	O
pos2	int
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
captures	int
;	O
k	int
++	O
)	O
{	O
lib	int
=	O
captured	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
MARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
&&	O
!	O
MARKED_COLOR_STRING	O
(	O
WEST	O
(	O
lib	int
)	O
,	O
color	int
)	O
&&	O
!	O
MARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
&&	O
!	O
MARKED_COLOR_STRING	O
(	O
EAST	O
(	O
lib	int
)	O
,	O
color	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
k	int
;	O
l	int
++	O
)	O
if	O
(	O
string_number	array
[	O
captured	array
[	O
l	int
]	O
]	O
==	O
string_number	array
[	O
lib	int
]	O
)	O
break	O
;	O
if	O
(	O
l	int
==	O
k	int
)	O
{	O
do	O
{	O
if	O
(	O
MARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
||	O
MARKED_COLOR_STRING	O
(	O
WEST	O
(	O
lib	int
)	O
,	O
color	int
)	O
||	O
MARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
||	O
MARKED_COLOR_STRING	O
(	O
EAST	O
(	O
lib	int
)	O
,	O
color	int
)	O
)	O
{	O
if	O
(	O
libs	pointer
)	O
libs	pointer
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
}	O
lib	int
=	O
NEXT_STONE	O
(	O
lib	int
)	O
;	O
}	O
while	O
(	O
lib	int
!=	O
captured	array
[	O
k	int
]	O
)	O
;	O
}	O
}	O
return	O
liberties	int
;	O
}	O
int	O
count_common_libs	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
all_libs1	array
[	O
MAXLIBS	O
]	O
,	O
*	O
libs1	pointer
;	O
int	O
liberties1	int
,	O
liberties2	int
;	O
int	O
commonlibs	int
=	O
0	int
;	O
int	O
k	int
,	O
n	int
,	O
tmp	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
n	int
=	O
string_number	array
[	O
str1	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties1	int
>	O
string	int
[	O
string_number	array
[	O
str2	int
]	O
]	O
.	O
liberties	int
)	O
{	O
n	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
if	O
(	O
liberties1	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
libs1	pointer
=	O
string_libs	array
[	O
n	int
]	O
.	O
list	array
;	O
n	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
liberties2	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties2	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
liberty_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
MARK_LIBERTY	O
(	O
libs1	pointer
[	O
k	int
]	O
)	O
;	O
libs1	pointer
=	O
string_libs	array
[	O
n	int
]	O
.	O
list	array
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties2	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
UNMARKED_LIBERTY	O
(	O
libs1	pointer
[	O
k	int
]	O
)	O
)	O
commonlibs	int
++	O
;	O
return	O
commonlibs	int
;	O
}	O
}	O
else	O
{	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
all_libs1	array
)	O
;	O
libs1	pointer
=	O
all_libs1	array
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
libs1	pointer
[	O
k	int
]	O
,	O
string_number	array
[	O
str2	int
]	O
,	O
board	pointer
[	O
str2	int
]	O
)	O
)	O
commonlibs	int
++	O
;	O
return	O
commonlibs	int
;	O
}	O
int	O
find_common_libs	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	pointer
)	O
{	O
int	O
all_libs1	array
[	O
MAXLIBS	O
]	O
,	O
*	O
libs1	pointer
;	O
int	O
liberties1	int
,	O
liberties2	int
;	O
int	O
commonlibs	int
=	O
0	int
;	O
int	O
k	int
,	O
n	int
,	O
tmp	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
ASSERT1	O
(	O
libs	pointer
!=	O
NULL	O
,	O
str1	int
)	O
;	O
n	int
=	O
string_number	array
[	O
str1	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties1	int
>	O
string	int
[	O
string_number	array
[	O
str2	int
]	O
]	O
.	O
liberties	int
)	O
{	O
n	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
if	O
(	O
liberties1	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
libs1	pointer
=	O
string_libs	array
[	O
n	int
]	O
.	O
list	array
;	O
n	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
liberties2	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties2	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
liberty_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
MARK_LIBERTY	O
(	O
libs1	pointer
[	O
k	int
]	O
)	O
;	O
libs1	pointer
=	O
string_libs	array
[	O
n	int
]	O
.	O
list	array
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties2	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
UNMARKED_LIBERTY	O
(	O
libs1	pointer
[	O
k	int
]	O
)	O
)	O
{	O
if	O
(	O
commonlibs	int
<	O
maxlib	int
)	O
libs	pointer
[	O
commonlibs	int
]	O
=	O
libs1	pointer
[	O
k	int
]	O
;	O
commonlibs	int
++	O
;	O
}	O
return	O
commonlibs	int
;	O
}	O
}	O
else	O
{	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
all_libs1	array
)	O
;	O
libs1	pointer
=	O
all_libs1	array
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
libs1	pointer
[	O
k	int
]	O
,	O
string_number	array
[	O
str2	int
]	O
,	O
board	pointer
[	O
str2	int
]	O
)	O
)	O
{	O
if	O
(	O
commonlibs	int
<	O
maxlib	int
)	O
libs	pointer
[	O
commonlibs	int
]	O
=	O
libs1	pointer
[	O
k	int
]	O
;	O
commonlibs	int
++	O
;	O
}	O
return	O
commonlibs	int
;	O
}	O
int	O
have_common_lib	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
lib	int
)	O
{	O
int	O
all_libs1	array
[	O
MAXLIBS	O
]	O
,	O
*	O
libs1	pointer
;	O
int	O
liberties1	int
;	O
int	O
k	int
,	O
n	int
,	O
tmp	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
n	int
=	O
string_number	array
[	O
str1	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties1	int
>	O
string	int
[	O
string_number	array
[	O
str2	int
]	O
]	O
.	O
liberties	int
)	O
{	O
n	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
if	O
(	O
liberties1	int
<=	O
MAX_LIBERTIES	int
)	O
libs1	pointer
=	O
string_libs	array
[	O
n	int
]	O
.	O
list	array
;	O
else	O
{	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
all_libs1	array
)	O
;	O
libs1	pointer
=	O
all_libs1	array
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
libs1	pointer
[	O
k	int
]	O
,	O
string_number	array
[	O
str2	int
]	O
,	O
board	pointer
[	O
str2	int
]	O
)	O
)	O
{	O
if	O
(	O
lib	int
)	O
*	O
lib	int
=	O
libs1	pointer
[	O
k	int
]	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
countstones	function
(	O
int	O
str	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
return	O
COUNTSTONES	O
(	O
str	int
)	O
;	O
}	O
int	O
findstones	function
(	O
int	O
str	int
,	O
int	O
maxstones	int
,	O
int	O
*	O
stones	pointer
)	O
{	O
int	O
s	int
;	O
int	O
size	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
s	int
=	O
string_number	array
[	O
str	int
]	O
;	O
size	int
=	O
string	int
[	O
s	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
maxstones	int
&&	O
k	int
<	O
size	int
;	O
k	int
++	O
)	O
{	O
stones	pointer
[	O
k	int
]	O
=	O
pos	int
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
return	O
size	int
;	O
}	O
int	O
count_adjacent_stones	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
maxstones	int
)	O
{	O
int	O
s1	int
,	O
s2	int
;	O
int	O
size	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
count	int
=	O
0	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
s1	int
=	O
string_number	array
[	O
str1	int
]	O
;	O
s2	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
size	int
=	O
string	int
[	O
s1	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
size	int
&&	O
count	int
<	O
maxstones	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
s2	int
,	O
board	pointer
[	O
str2	int
]	O
)	O
)	O
count	int
++	O
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
return	O
count	int
;	O
}	O
int	O
chainlinks	function
(	O
int	O
str	int
,	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
)	O
{	O
struct	O
string_data	struct
*	O
s	int
;	O
struct	O
string_neighbors_data	struct
*	O
sn	pointer
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
sn	pointer
=	O
&	O
string_neighbors	array
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
adj	array
[	O
k	int
]	O
=	O
string	int
[	O
sn	pointer
->	O
list	array
[	O
k	int
]	O
]	O
.	O
origin	int
;	O
return	O
s	int
->	O
neighbors	int
;	O
}	O
int	O
chainlinks2	function
(	O
int	O
str	int
,	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
,	O
int	O
lib	int
)	O
{	O
struct	O
string_data	struct
*	O
s	int
,	O
*	O
t	pointer
;	O
struct	O
string_neighbors_data	struct
*	O
sn	pointer
;	O
int	O
k	int
;	O
int	O
neighbors	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
neighbors	int
=	O
0	int
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
sn	pointer
=	O
&	O
string_neighbors	array
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
t	pointer
=	O
&	O
string	int
[	O
sn	pointer
->	O
list	array
[	O
k	int
]	O
]	O
;	O
if	O
(	O
t	pointer
->	O
liberties	int
==	O
lib	int
)	O
adj	array
[	O
neighbors	int
++	O
]	O
=	O
t	pointer
->	O
origin	int
;	O
}	O
return	O
neighbors	int
;	O
}	O
int	O
chainlinks3	function
(	O
int	O
str	int
,	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
,	O
int	O
lib	int
)	O
{	O
struct	O
string_data	struct
*	O
s	int
,	O
*	O
t	pointer
;	O
struct	O
string_neighbors_data	struct
*	O
sn	pointer
;	O
int	O
k	int
;	O
int	O
neighbors	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
neighbors	int
=	O
0	int
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
sn	pointer
=	O
&	O
string_neighbors	array
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
t	pointer
=	O
&	O
string	int
[	O
sn	pointer
->	O
list	array
[	O
k	int
]	O
]	O
;	O
if	O
(	O
t	pointer
->	O
liberties	int
<=	O
lib	int
)	O
adj	array
[	O
neighbors	int
++	O
]	O
=	O
t	pointer
->	O
origin	int
;	O
}	O
return	O
neighbors	int
;	O
}	O
int	O
extended_chainlinks	function
(	O
int	O
str	int
,	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
,	O
int	O
both_colors	int
)	O
{	O
struct	O
string_data	struct
*	O
s	int
;	O
struct	O
string_neighbors_data	struct
*	O
sn	pointer
;	O
int	O
n	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
sn	pointer
=	O
&	O
string_neighbors	array
[	O
string_number	array
[	O
str	int
]	O
]	O
;	O
string_mark	int
++	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
s	int
->	O
neighbors	int
;	O
n	int
++	O
)	O
{	O
adj	array
[	O
n	int
]	O
=	O
string	int
[	O
sn	pointer
->	O
list	array
[	O
n	int
]	O
]	O
.	O
origin	int
;	O
MARK_STRING	O
(	O
adj	array
[	O
n	int
]	O
)	O
;	O
}	O
liberties	int
=	O
findlib	function
(	O
str	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	int
;	O
r	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
(	O
board	pointer
[	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
||	O
(	O
both_colors	int
&&	O
board	pointer
[	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
board	pointer
[	O
str	int
]	O
)	O
)	O
&&	O
UNMARKED_STRING	O
(	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
{	O
adj	array
[	O
n	int
]	O
=	O
string	int
[	O
string_number	array
[	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
]	O
.	O
origin	int
;	O
MARK_STRING	O
(	O
adj	array
[	O
n	int
]	O
)	O
;	O
n	int
++	O
;	O
}	O
}	O
}	O
return	O
n	int
;	O
}	O
int	O
send_two_return_one	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
lib	int
=	O
NO_MOVE	O
;	O
int	O
friendly_neighbor	int
=	O
NO_MOVE	O
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
move	pointer
]	O
==	O
EMPTY	int
,	O
move	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
int	O
s	int
;	O
if	O
(	O
friendly_neighbor	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
friendly_neighbor	int
=	O
pos	int
;	O
s	int
=	O
string_number	array
[	O
pos	int
]	O
;	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
size	int
!=	O
1	int
||	O
string	int
[	O
s	int
]	O
.	O
liberties	int
!=	O
2	int
)	O
return	O
0	int
;	O
lib	int
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
0	int
]	O
+	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
1	int
]	O
-	O
move	pointer
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
string	int
[	O
string_number	array
[	O
pos	int
]	O
]	O
.	O
liberties	int
==	O
1	int
)	O
return	O
0	int
;	O
}	O
if	O
(	O
friendly_neighbor	int
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
lib	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
)	O
return	O
0	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
string	int
[	O
string_number	array
[	O
pos	int
]	O
]	O
.	O
liberties	int
<	O
2	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
find_origin	function
(	O
int	O
str	int
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
return	O
string	int
[	O
string_number	array
[	O
str	int
]	O
]	O
.	O
origin	int
;	O
}	O
int	O
is_self_atari	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
trivial_liberties	int
=	O
0	int
;	O
int	O
captures	int
=	O
0	int
;	O
int	O
far_liberties	int
=	O
0	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
string_mark	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
}	O
if	O
(	O
trivial_liberties	int
+	O
captures	int
>=	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
far_liberties	int
>	O
0	int
)	O
+	O
captures	int
>=	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
captures	int
==	O
0	int
&&	O
far_liberties	int
+	O
trivial_liberties	int
<=	O
1	int
)	O
return	O
1	int
;	O
return	O
accuratelib	function
(	O
pos	int
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
<=	O
1	int
;	O
}	O
int	O
liberty_of_string	function
(	O
int	O
pos	int
,	O
int	O
str	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
return	O
0	int
;	O
return	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
string_number	array
[	O
str	int
]	O
,	O
board	pointer
[	O
str	int
]	O
)	O
;	O
}	O
int	O
second_order_liberty_of_string	function
(	O
int	O
pos	int
,	O
int	O
str	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
,	O
string_number	array
[	O
str	int
]	O
,	O
board	pointer
[	O
str	int
]	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
neighbor_of_string	function
(	O
int	O
pos	int
,	O
int	O
str	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
str	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
return	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
string_number	array
[	O
str	int
]	O
,	O
color	int
)	O
;	O
}	O
int	O
has_neighbor	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
return	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
||	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
||	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
||	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
;	O
}	O
int	O
same_string	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
return	O
string_number	array
[	O
str1	int
]	O
==	O
string_number	array
[	O
str2	int
]	O
;	O
}	O
int	O
adjacent_strings	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
s1	int
,	O
s2	int
;	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
s1	int
=	O
string_number	array
[	O
str1	int
]	O
;	O
s2	int
=	O
string_number	array
[	O
str2	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s1	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
if	O
(	O
string_neighbors	array
[	O
s1	int
]	O
.	O
list	array
[	O
k	int
]	O
==	O
s2	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
is_ko	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
*	O
ko_pos	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
captures	int
=	O
0	int
;	O
int	O
kpos	int
=	O
0	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
WHITE	int
||	O
color	int
==	O
BLACK	int
,	O
pos	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
SOUTH	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
WEST	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
NORTH	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
EAST	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
captures	int
==	O
1	int
)	O
{	O
if	O
(	O
ko_pos	int
)	O
*	O
ko_pos	int
=	O
kpos	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
is_ko_point	function
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
color	int
;	O
if	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
color	int
=	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
else	O
color	int
=	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
color	int
)	O
&&	O
is_ko	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
struct	O
string_data	struct
*	O
s	int
=	O
&	O
string	int
[	O
string_number	array
[	O
pos	int
]	O
]	O
;	O
struct	O
string_liberties_data	struct
*	O
sl	pointer
=	O
&	O
string_libs	array
[	O
string_number	array
[	O
pos	int
]	O
]	O
;	O
if	O
(	O
s	int
->	O
liberties	int
==	O
1	int
&&	O
s	int
->	O
size	int
==	O
1	int
&&	O
is_ko	function
(	O
sl	pointer
->	O
list	array
[	O
0	int
]	O
,	O
OTHER_COLOR	O
(	O
s	int
->	O
color	int
)	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
is_superko_violation	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
enum	O
ko_rules	enum
type	enum
)	O
{	O
Hash_data	struct
this_board_hash	struct
=	O
board_hash	struct
;	O
Hash_data	struct
new_board_hash	struct
;	O
int	O
k	int
;	O
if	O
(	O
type	enum
==	O
NONE	int
||	O
type	enum
==	O
SIMPLE	int
)	O
return	O
0	int
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
this_board_hash	struct
,	O
board_ko_pos	int
)	O
;	O
really_do_trymove	function
(	O
pos	int
,	O
color	int
)	O
;	O
new_board_hash	struct
=	O
board_hash	struct
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
new_board_hash	struct
,	O
board_ko_pos	int
)	O
;	O
undo_trymove	function
(	O
)	O
;	O
if	O
(	O
type	enum
==	O
PSK	int
&&	O
hashdata_is_equal	O
(	O
this_board_hash	struct
,	O
new_board_hash	struct
)	O
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
move_history_pointer	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
hashdata_is_equal	O
(	O
move_history_hash	array
[	O
k	int
]	O
,	O
new_board_hash	struct
)	O
&&	O
(	O
type	enum
==	O
PSK	int
||	O
move_history_color	array
[	O
k	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
does_capture_something	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
mark_string	function
(	O
int	O
str	int
,	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
mark	char
)	O
{	O
int	O
pos	int
=	O
str	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
do	O
{	O
mx	array
[	O
pos	int
]	O
=	O
mark	char
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
pos	int
!=	O
str	int
)	O
;	O
}	O
int	O
move_in_stack	function
(	O
int	O
pos	int
,	O
int	O
cutoff	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
cutoff	int
;	O
k	int
<	O
stackp	int
;	O
k	int
++	O
)	O
if	O
(	O
stack	array
[	O
k	int
]	O
==	O
pos	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
get_move_from_stack	function
(	O
int	O
k	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
color	int
)	O
{	O
gg_assert	O
(	O
k	int
<	O
stackp	int
)	O
;	O
*	O
move	pointer
=	O
stack	array
[	O
k	int
]	O
;	O
*	O
color	int
=	O
move_color	array
[	O
k	int
]	O
;	O
}	O
int	O
stones_on_board	function
(	O
int	O
color	int
)	O
{	O
static	O
int	O
stone_count_for_position	int
=	O
-	O
1	int
;	O
static	O
int	O
white_stones	int
=	O
0	int
;	O
static	O
int	O
black_stones	int
=	O
0	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
stone_count_for_position	int
!=	O
position_number	int
)	O
{	O
int	O
pos	int
;	O
white_stones	int
=	O
0	int
;	O
black_stones	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
white_stones	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
black_stones	int
++	O
;	O
}	O
stone_count_for_position	int
=	O
position_number	int
;	O
}	O
return	O
(	O
(	O
color	int
&	O
BLACK	int
?	O
black_stones	int
:	O
0	int
)	O
+	O
(	O
color	int
&	O
WHITE	int
?	O
white_stones	int
:	O
0	int
)	O
)	O
;	O
}	O
void	O
reset_trymove_counter	function
(	O
)	O
{	O
trymove_counter	int
=	O
0	int
;	O
}	O
int	O
get_trymove_counter	function
(	O
)	O
{	O
return	O
trymove_counter	int
;	O
}	O
static	O
void	O
new_position	function
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
int	O
s	int
;	O
position_number	int
++	O
;	O
next_string	int
=	O
0	int
;	O
liberty_mark	int
=	O
0	int
;	O
string_mark	int
=	O
0	int
;	O
CLEAR_STACKS	O
(	O
)	O
;	O
memset	function
(	O
string	int
,	O
0	int
,	O
sizeof	O
(	O
string	int
)	O
)	O
;	O
memset	function
(	O
string_libs	array
,	O
0	int
,	O
sizeof	O
(	O
string_libs	array
)	O
)	O
;	O
memset	function
(	O
string_neighbors	array
,	O
0	int
,	O
sizeof	O
(	O
string_neighbors	array
)	O
)	O
;	O
memset	function
(	O
ml	array
,	O
0	int
,	O
sizeof	O
(	O
ml	array
)	O
)	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
next_stone	array
,	O
sizeof	O
(	O
next_stone	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
string_number	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
string_number	array
[	O
pos	int
]	O
==	O
-	O
1	int
)	O
{	O
string_number	array
[	O
pos	int
]	O
=	O
next_string	int
;	O
string	int
[	O
next_string	int
]	O
.	O
size	int
=	O
propagate_string	function
(	O
pos	int
,	O
pos	int
)	O
;	O
string	int
[	O
next_string	int
]	O
.	O
color	int
=	O
board	pointer
[	O
pos	int
]	O
;	O
string	int
[	O
next_string	int
]	O
.	O
origin	int
=	O
pos	int
;	O
string	int
[	O
next_string	int
]	O
.	O
mark	char
=	O
0	int
;	O
next_string	int
++	O
;	O
PARANOID1	O
(	O
next_string	int
<	O
MAX_STRINGS	O
,	O
pos	int
)	O
;	O
}	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
next_string	int
;	O
s	int
++	O
)	O
{	O
find_liberties_and_neighbors	function
(	O
s	int
)	O
;	O
}	O
}	O
static	O
int	O
propagate_string	function
(	O
int	O
stone	int
,	O
int	O
str	int
)	O
{	O
int	O
size	int
=	O
1	int
;	O
int	O
k	int
;	O
if	O
(	O
stone	int
==	O
str	int
)	O
{	O
next_stone	array
[	O
stone	int
]	O
=	O
stone	int
;	O
}	O
else	O
{	O
string_number	array
[	O
stone	int
]	O
=	O
string_number	array
[	O
str	int
]	O
;	O
next_stone	array
[	O
stone	int
]	O
=	O
next_stone	array
[	O
str	int
]	O
;	O
next_stone	array
[	O
str	int
]	O
=	O
stone	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
stone	int
+	O
d	int
)	O
&&	O
board	pointer
[	O
stone	int
+	O
d	int
]	O
==	O
board	pointer
[	O
stone	int
]	O
&&	O
string_number	array
[	O
stone	int
+	O
d	int
]	O
==	O
-	O
1	int
)	O
size	int
+=	O
propagate_string	function
(	O
stone	int
+	O
d	int
,	O
str	int
)	O
;	O
}	O
return	O
size	int
;	O
}	O
static	O
void	O
find_liberties_and_neighbors	function
(	O
int	O
s	int
)	O
{	O
int	O
pos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
string	int
[	O
s	int
]	O
.	O
color	int
)	O
;	O
liberty_mark	int
++	O
;	O
string_mark	int
++	O
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos	int
)	O
)	O
;	O
}	O
static	O
void	O
update_liberties	function
(	O
int	O
s	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
liberties	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
&&	O
k	int
<	O
MAX_LIBERTIES	int
;	O
k	int
++	O
)	O
{	O
PUSH_VALUE	O
(	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
)	O
;	O
}	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos	int
)	O
)	O
;	O
}	O
static	O
void	O
remove_neighbor	function
(	O
int	O
str_number	int
,	O
int	O
n	int
)	O
{	O
int	O
k	int
;	O
int	O
done	int
=	O
0	int
;	O
struct	O
string_data	struct
*	O
s	int
=	O
&	O
string	int
[	O
str_number	int
]	O
;	O
struct	O
string_neighbors_data	struct
*	O
sn	pointer
=	O
&	O
string_neighbors	array
[	O
str_number	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
if	O
(	O
sn	pointer
->	O
list	array
[	O
k	int
]	O
==	O
n	int
)	O
{	O
PUSH_VALUE	O
(	O
sn	pointer
->	O
list	array
[	O
s	int
->	O
neighbors	int
-	O
1	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
sn	pointer
->	O
list	array
[	O
k	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
s	int
->	O
neighbors	int
)	O
;	O
sn	pointer
->	O
list	array
[	O
k	int
]	O
=	O
sn	pointer
->	O
list	array
[	O
s	int
->	O
neighbors	int
-	O
1	int
]	O
;	O
s	int
->	O
neighbors	int
--	O
;	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
gg_assert	O
(	O
done	int
)	O
;	O
}	O
static	O
void	O
remove_liberty	function
(	O
int	O
str_number	int
,	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
struct	O
string_data	struct
*	O
s	int
=	O
&	O
string	int
[	O
str_number	int
]	O
;	O
struct	O
string_liberties_data	struct
*	O
sl	pointer
=	O
&	O
string_libs	array
[	O
str_number	int
]	O
;	O
if	O
(	O
s	int
->	O
liberties	int
>	O
MAX_LIBERTIES	int
)	O
update_liberties	function
(	O
str_number	int
)	O
;	O
else	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
liberties	int
;	O
k	int
++	O
)	O
if	O
(	O
sl	pointer
->	O
list	array
[	O
k	int
]	O
==	O
pos	int
)	O
{	O
PUSH_VALUE	O
(	O
sl	pointer
->	O
list	array
[	O
s	int
->	O
liberties	int
-	O
1	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
sl	pointer
->	O
list	array
[	O
k	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
s	int
->	O
liberties	int
)	O
;	O
sl	pointer
->	O
list	array
[	O
k	int
]	O
=	O
sl	pointer
->	O
list	array
[	O
s	int
->	O
liberties	int
-	O
1	int
]	O
;	O
s	int
->	O
liberties	int
--	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
do_remove_string	function
(	O
int	O
s	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
size	int
=	O
string	int
[	O
s	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
PUSH_VALUE	O
(	O
string_number	array
[	O
pos	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
next_stone	array
[	O
pos	int
]	O
)	O
;	O
DO_REMOVE_STONE	O
(	O
pos	int
)	O
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos	int
)	O
)	O
;	O
if	O
(	O
size	int
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
string_neighbors	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
remove_neighbor	function
(	O
neighbor	int
,	O
s	int
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
)	O
;	O
if	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
<	O
MAX_LIBERTIES	int
)	O
string_libs	array
[	O
neighbor	int
]	O
.	O
list	array
[	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
]	O
=	O
pos	int
;	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
size	int
==	O
2	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
string	int
[	O
s	int
]	O
.	O
color	int
)	O
;	O
int	O
pos2	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
string_neighbors	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
remove_neighbor	function
(	O
neighbor	int
,	O
s	int
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
)	O
;	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
neighbor	int
,	O
other	int
)	O
)	O
{	O
if	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
<	O
MAX_LIBERTIES	int
)	O
string_libs	array
[	O
neighbor	int
]	O
.	O
list	array
[	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
]	O
=	O
pos	int
;	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
++	O
;	O
}	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
pos2	int
,	O
neighbor	int
,	O
other	int
)	O
)	O
{	O
if	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
<	O
MAX_LIBERTIES	int
)	O
string_libs	array
[	O
neighbor	int
]	O
.	O
list	array
[	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
]	O
=	O
pos2	int
;	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
++	O
;	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
remove_neighbor	function
(	O
string_neighbors	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
,	O
s	int
)	O
;	O
update_liberties	function
(	O
string_neighbors	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
color	int
==	O
WHITE	int
)	O
white_captured	int
+=	O
size	int
;	O
else	O
black_captured	int
+=	O
size	int
;	O
return	O
size	int
;	O
}	O
static	O
void	O
create_new_string	function
(	O
int	O
pos	int
)	O
{	O
int	O
s	int
;	O
int	O
color	int
=	O
board	pointer
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
PUSH_VALUE	O
(	O
next_string	int
)	O
;	O
s	int
=	O
next_string	int
++	O
;	O
PARANOID1	O
(	O
s	int
<	O
MAX_STRINGS	O
,	O
pos	int
)	O
;	O
string_number	array
[	O
pos	int
]	O
=	O
s	int
;	O
next_stone	array
[	O
pos	int
]	O
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
color	int
=	O
color	int
;	O
string	int
[	O
s	int
]	O
.	O
size	int
=	O
1	int
;	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
=	O
0	int
;	O
string	int
[	O
s	int
]	O
.	O
mark	char
=	O
0	int
;	O
string_mark	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
}	O
}	O
static	O
void	O
extend_neighbor_string	function
(	O
int	O
pos	int
,	O
int	O
s	int
)	O
{	O
int	O
k	int
;	O
int	O
liberties_updated	int
=	O
0	int
;	O
int	O
color	int
=	O
board	pointer
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos2	int
=	O
string	int
[	O
s	int
]	O
.	O
origin	int
;	O
next_stone	array
[	O
pos	int
]	O
=	O
next_stone	array
[	O
pos2	int
]	O
;	O
PUSH_VALUE	O
(	O
next_stone	array
[	O
pos2	int
]	O
)	O
;	O
next_stone	array
[	O
pos2	int
]	O
=	O
pos	int
;	O
if	O
(	O
pos	int
<	O
pos2	int
)	O
{	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
origin	int
)	O
;	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
pos	int
;	O
}	O
string_number	array
[	O
pos	int
]	O
=	O
s	int
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
size	int
)	O
;	O
string	int
[	O
s	int
]	O
.	O
size	int
++	O
;	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
liberties	int
>	O
MAX_LIBERTIES	int
)	O
{	O
update_liberties	function
(	O
s	int
)	O
;	O
liberties_updated	int
=	O
1	int
;	O
}	O
else	O
{	O
remove_liberty	function
(	O
s	int
,	O
pos	int
)	O
;	O
}	O
string_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
string	int
[	O
string_neighbors	array
[	O
s	int
]	O
.	O
list	array
[	O
k	int
]	O
]	O
.	O
mark	char
=	O
string_mark	int
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
}	O
}	O
static	O
void	O
assimilate_string	function
(	O
int	O
s	int
,	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
int	O
last	pointer
;	O
int	O
s2	int
=	O
string_number	array
[	O
pos	int
]	O
;	O
string	int
[	O
s	int
]	O
.	O
size	int
+=	O
string	int
[	O
s2	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s2	int
)	O
;	O
do	O
{	O
PUSH_VALUE	O
(	O
string_number	array
[	O
pos	int
]	O
)	O
;	O
string_number	array
[	O
pos	int
]	O
=	O
s	int
;	O
last	pointer
=	O
pos	int
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s2	int
,	O
pos	int
)	O
)	O
;	O
{	O
int	O
pos2	int
=	O
string	int
[	O
s	int
]	O
.	O
origin	int
;	O
PUSH_VALUE	O
(	O
next_stone	array
[	O
last	pointer
]	O
)	O
;	O
PUSH_VALUE	O
(	O
next_stone	array
[	O
pos2	int
]	O
)	O
;	O
next_stone	array
[	O
last	pointer
]	O
=	O
next_stone	array
[	O
pos2	int
]	O
;	O
next_stone	array
[	O
pos2	int
]	O
=	O
string	int
[	O
s2	int
]	O
.	O
origin	int
;	O
if	O
(	O
string	int
[	O
s2	int
]	O
.	O
origin	int
<	O
pos2	int
)	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
string	int
[	O
s2	int
]	O
.	O
origin	int
;	O
}	O
if	O
(	O
string	int
[	O
s2	int
]	O
.	O
liberties	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s2	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
string_libs	array
[	O
s2	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos2	int
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
pos2	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
liberty_mark	int
++	O
;	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
update_liberties	function
(	O
s	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
t	pointer
=	O
string_neighbors	array
[	O
s2	int
]	O
.	O
list	array
[	O
k	int
]	O
;	O
remove_neighbor	function
(	O
t	pointer
,	O
s2	int
)	O
;	O
if	O
(	O
string	int
[	O
t	pointer
]	O
.	O
mark	char
!=	O
string_mark	int
)	O
{	O
PUSH_VALUE	O
(	O
string	int
[	O
t	pointer
]	O
.	O
neighbors	int
)	O
;	O
string_neighbors	array
[	O
t	pointer
]	O
.	O
list	array
[	O
string	int
[	O
t	pointer
]	O
.	O
neighbors	int
++	O
]	O
=	O
s	int
;	O
string_neighbors	array
[	O
s	int
]	O
.	O
list	array
[	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
++	O
]	O
=	O
t	pointer
;	O
string	int
[	O
t	pointer
]	O
.	O
mark	char
=	O
string_mark	int
;	O
}	O
}	O
}	O
static	O
void	O
assimilate_neighbor_strings	function
(	O
int	O
pos	int
)	O
{	O
int	O
s	int
;	O
int	O
color	int
=	O
board	pointer
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
PUSH_VALUE	O
(	O
next_string	int
)	O
;	O
s	int
=	O
next_string	int
++	O
;	O
PARANOID1	O
(	O
s	int
<	O
MAX_STRINGS	O
,	O
pos	int
)	O
;	O
string_number	array
[	O
pos	int
]	O
=	O
s	int
;	O
next_stone	array
[	O
pos	int
]	O
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
color	int
=	O
color	int
;	O
string	int
[	O
s	int
]	O
.	O
size	int
=	O
1	int
;	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
string_mark	int
++	O
;	O
string	int
[	O
s	int
]	O
.	O
mark	char
=	O
string_mark	int
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	function
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	function
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	function
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	function
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
do_commit_suicide	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	function
(	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	function
(	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	function
(	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	function
(	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
white_captured	int
++	O
;	O
else	O
black_captured	int
++	O
;	O
}	O
static	O
void	O
do_play_move	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
captured_stones	pointer
=	O
0	int
;	O
int	O
neighbor_allies	int
=	O
0	int
;	O
int	O
s	int
=	O
-	O
1	int
;	O
string_mark	int
++	O
;	O
DO_ADD_STONE	O
(	O
pos	int
,	O
color	int
)	O
;	O
string_number	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	function
(	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
captured_stones	pointer
+=	O
do_remove_string	function
(	O
string_number	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	function
(	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
captured_stones	pointer
+=	O
do_remove_string	function
(	O
string_number	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	function
(	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
captured_stones	pointer
+=	O
do_remove_string	function
(	O
string_number	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	function
(	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
}	O
else	O
captured_stones	pointer
+=	O
do_remove_string	function
(	O
string_number	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
neighbor_allies	int
==	O
0	int
)	O
create_new_string	function
(	O
pos	int
)	O
;	O
else	O
if	O
(	O
neighbor_allies	int
==	O
1	int
)	O
{	O
gg_assert	O
(	O
s	int
>=	O
0	int
)	O
;	O
extend_neighbor_string	function
(	O
pos	int
,	O
s	int
)	O
;	O
return	O
;	O
}	O
else	O
{	O
assimilate_neighbor_strings	function
(	O
pos	int
)	O
;	O
return	O
;	O
}	O
s	int
=	O
string_number	array
[	O
pos	int
]	O
;	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
liberties	int
==	O
1	int
&&	O
string	int
[	O
s	int
]	O
.	O
size	int
==	O
1	int
&&	O
captured_stones	pointer
==	O
1	int
)	O
{	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
board_hash	struct
,	O
board_ko_pos	int
)	O
;	O
board_ko_pos	int
=	O
string_libs	array
[	O
s	int
]	O
.	O
list	array
[	O
0	int
]	O
;	O
hashdata_invert_ko	function
(	O
&	O
board_hash	struct
,	O
board_ko_pos	int
)	O
;	O
}	O
}	O
void	O
incremental_order_moves	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
str	int
,	O
int	O
*	O
number_edges	pointer
,	O
int	O
*	O
number_same_string	pointer
,	O
int	O
*	O
number_own	pointer
,	O
int	O
*	O
number_opponent	pointer
,	O
int	O
*	O
captured_stones	pointer
,	O
int	O
*	O
threatened_stones	pointer
,	O
int	O
*	O
saved_stones	pointer
,	O
int	O
*	O
number_open	pointer
)	O
{	O
string_mark	int
++	O
;	O
code1	O
(	O
SOUTH	O
(	O
move	pointer
)	O
)	O
;	O
code1	O
(	O
WEST	O
(	O
move	pointer
)	O
)	O
;	O
code1	O
(	O
NORTH	O
(	O
move	pointer
)	O
)	O
;	O
code1	O
(	O
EAST	O
(	O
move	pointer
)	O
)	O
;	O
}	O
int	O
square_dist	function
(	O
int	O
pos1	int
,	O
int	O
pos2	int
)	O
{	O
int	O
idist	int
=	O
I	O
(	O
pos1	int
)	O
-	O
I	O
(	O
pos2	int
)	O
;	O
int	O
jdist	int
=	O
J	O
(	O
pos1	int
)	O
-	O
J	O
(	O
pos2	int
)	O
;	O
return	O
idist	int
*	O
idist	int
+	O
jdist	int
*	O
jdist	int
;	O
}	O
