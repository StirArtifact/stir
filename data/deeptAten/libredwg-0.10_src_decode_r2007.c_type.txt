static	O
unsigned	O
int	O
loglevel	int
;	O
static	O
unsigned	O
int	O
cur_ver	int
=	O
0	int
;	O
typedef	O
struct	O
r2007_file_header	struct
{	O
int64_t	long
header_size	int
;	O
int64_t	long
file_size	long
;	O
int64_t	long
pages_map_crc_compressed	long
;	O
int64_t	long
pages_map_correction	long
;	O
int64_t	long
pages_map_crc_seed	long
;	O
int64_t	long
pages_map2_offset	long
;	O
int64_t	long
pages_map2_id	long
;	O
int64_t	long
pages_map_offset	long
;	O
int64_t	long
pages_map_id	long
;	O
int64_t	long
header2_offset	long
;	O
int64_t	long
pages_map_size_comp	long
;	O
int64_t	long
pages_map_size_uncomp	long
;	O
int64_t	long
pages_amount	long
;	O
int64_t	long
pages_maxid	long
;	O
int64_t	long
unknown1	char
;	O
int64_t	long
unknown2	char
;	O
int64_t	long
pages_map_crc_uncomp	long
;	O
int64_t	long
unknown3	double
;	O
int64_t	long
unknown4	long
;	O
int64_t	long
unknown5	long
;	O
int64_t	long
num_sections	int
;	O
int64_t	long
sections_map_crc_uncomp	long
;	O
int64_t	long
sections_map_size_comp	long
;	O
int64_t	long
sections_map2_id	long
;	O
int64_t	long
sections_map_id	long
;	O
int64_t	long
sections_map_size_uncomp	long
;	O
int64_t	long
sections_map_crc_comp	long
;	O
int64_t	long
sections_map_correction	long
;	O
int64_t	long
sections_map_crc_seed	long
;	O
int64_t	long
stream_version	long
;	O
int64_t	long
crc_seed	long
;	O
int64_t	long
crc_seed_encoded	long
;	O
int64_t	long
random_seed	long
;	O
int64_t	long
header_crc	long
;	O
}	O
r2007_file_header	struct
;	O
typedef	O
struct	O
_r2007_page	struct
{	O
int64_t	long
id	int
;	O
uint64_t	long
size	char
;	O
uint64_t	long
offset	double
;	O
struct	O
_r2007_page	struct
*	O
next	pointer
;	O
}	O
r2007_page	struct
;	O
typedef	O
struct	O
_r2007_section_page	struct
{	O
uint64_t	long
offset	double
;	O
uint64_t	long
size	char
;	O
int64_t	long
id	int
;	O
uint64_t	long
uncomp_size	long
;	O
uint64_t	long
comp_size	long
;	O
uint64_t	long
checksum	int
;	O
uint64_t	long
crc	long
;	O
}	O
r2007_section_page	struct
;	O
typedef	O
struct	O
_r2007_section	struct
{	O
uint64_t	long
data_size	int
;	O
uint64_t	long
max_size	int
;	O
int64_t	long
encrypted	int
;	O
uint64_t	long
hashcode	long
;	O
int64_t	long
name_length	long
;	O
int64_t	long
unknown	char
;	O
int64_t	long
encoded	long
;	O
int64_t	long
num_pages	long
;	O
DWGCHAR	O
*	O
name	pointer
;	O
Dwg_Section_Type	enum
type	short
;	O
r2007_section_page	struct
*	O
*	O
pages	pointer
;	O
struct	O
_r2007_section	struct
*	O
next	pointer
;	O
}	O
r2007_section	struct
;	O
int	O
rs_decode_block	function
(	O
BITCODE_RC	char
*	O
blk	struct
,	O
int	O
fix	int
)	O
;	O
static	O
r2007_section	struct
*	O
get_section	function
(	O
r2007_section	struct
*	O
sections_map	pointer
,	O
Dwg_Section_Type	enum
sec_type	enum
)	O
;	O
static	O
r2007_page	struct
*	O
get_page	function
(	O
r2007_page	struct
*	O
pages_map	pointer
,	O
int64_t	long
id	int
)	O
;	O
static	O
void	O
pages_destroy	function
(	O
r2007_page	struct
*	O
page	pointer
)	O
;	O
static	O
void	O
sections_destroy	function
(	O
r2007_section	struct
*	O
section	pointer
)	O
;	O
static	O
r2007_section	struct
*	O
read_sections_map	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
int64_t	long
size_comp	long
,	O
int64_t	long
size_uncomp	long
,	O
int64_t	long
correction	long
)	O
ATTRIBUTE_MALLOC	O
;	O
static	O
int	O
read_data_section	function
(	O
Bit_Chain	struct
*	O
sec_dat	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
,	O
Dwg_Section_Type	enum
sec_type	enum
)	O
;	O
static	O
int	O
read_2007_section_classes	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
;	O
static	O
int	O
read_2007_section_header	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
;	O
static	O
int	O
read_2007_section_handles	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
;	O
static	O
int	O
read_2007_section_summary	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
;	O
static	O
int	O
read_2007_section_preview	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
;	O
static	O
r2007_page	struct
*	O
read_pages_map	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
int64_t	long
size_comp	long
,	O
int64_t	long
size_uncomp	long
,	O
int64_t	long
correction	long
)	O
ATTRIBUTE_MALLOC	O
;	O
static	O
int	O
read_file_header	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
r2007_file_header	struct
*	O
restrict	O
file_header	pointer
)	O
;	O
static	O
void	O
read_instructions	function
(	O
BITCODE_RC	char
*	O
restrict	O
*	O
restrict	O
src	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
opcode	pointer
,	O
uint32_t	int
*	O
restrict	O
offset	double
,	O
uint32_t	int
*	O
restrict	O
length	double
)	O
;	O
static	O
inline	O
BITCODE_RC	char
*	O
copy_bytes_2	function
(	O
BITCODE_RC	char
*	O
restrict	O
dst	pointer
,	O
const	O
BITCODE_RC	char
*	O
restrict	O
src	pointer
)	O
;	O
static	O
inline	O
BITCODE_RC	char
*	O
copy_bytes_3	function
(	O
BITCODE_RC	char
*	O
restrict	O
dst	pointer
,	O
const	O
BITCODE_RC	char
*	O
restrict	O
src	pointer
)	O
;	O
static	O
void	O
copy_bytes	function
(	O
BITCODE_RC	char
*	O
dst	pointer
,	O
uint32_t	int
length	double
,	O
uint32_t	int
offset	double
)	O
;	O
static	O
uint32_t	int
read_literal_length	function
(	O
BITCODE_RC	char
*	O
restrict	O
*	O
restrict	O
src	pointer
,	O
unsigned	O
char	O
opcode	pointer
)	O
;	O
static	O
void	O
copy_compressed_bytes	function
(	O
BITCODE_RC	char
*	O
restrict	O
dst	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
src	pointer
,	O
int	O
length	double
)	O
;	O
static	O
DWGCHAR	O
*	O
bfr_read_string	function
(	O
BITCODE_RC	char
*	O
restrict	O
*	O
restrict	O
src	pointer
,	O
int64_t	long
size	char
)	O
ATTRIBUTE_MALLOC	O
;	O
static	O
BITCODE_RC	char
*	O
decode_rs	function
(	O
const	O
BITCODE_RC	char
*	O
src	pointer
,	O
int	O
block_count	int
,	O
int	O
data_size	int
,	O
const	O
unsigned	O
src_size	int
)	O
ATTRIBUTE_MALLOC	O
;	O
static	O
int	O
decompress_r2007	function
(	O
BITCODE_RC	char
*	O
restrict	O
dst	pointer
,	O
const	O
unsigned	O
dst_size	int
,	O
BITCODE_RC	char
*	O
restrict	O
src	pointer
,	O
const	O
unsigned	O
src_size	int
)	O
;	O
static	O
inline	O
BITCODE_RC	char
*	O
copy_bytes_2	function
(	O
BITCODE_RC	char
*	O
dst	pointer
,	O
const	O
BITCODE_RC	char
*	O
src	pointer
)	O
{	O
dst	pointer
[	O
0	int
]	O
=	O
src	pointer
[	O
1	int
]	O
;	O
dst	pointer
[	O
1	int
]	O
=	O
src	pointer
[	O
0	int
]	O
;	O
return	O
dst	pointer
+	O
2	int
;	O
}	O
static	O
inline	O
BITCODE_RC	char
*	O
copy_bytes_3	function
(	O
BITCODE_RC	char
*	O
dst	pointer
,	O
const	O
BITCODE_RC	char
*	O
src	pointer
)	O
{	O
dst	pointer
[	O
0	int
]	O
=	O
src	pointer
[	O
2	int
]	O
;	O
dst	pointer
[	O
1	int
]	O
=	O
src	pointer
[	O
1	int
]	O
;	O
dst	pointer
[	O
2	int
]	O
=	O
src	pointer
[	O
0	int
]	O
;	O
return	O
dst	pointer
+	O
3	int
;	O
}	O
static	O
void	O
copy_bytes	function
(	O
BITCODE_RC	char
*	O
dst	pointer
,	O
uint32_t	int
length	double
,	O
uint32_t	int
offset	double
)	O
{	O
BITCODE_RC	char
*	O
src	pointer
=	O
dst	pointer
-	O
offset	double
;	O
while	O
(	O
length	double
--	O
>	O
0	int
)	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
}	O
static	O
void	O
copy_compressed_bytes	function
(	O
BITCODE_RC	char
*	O
restrict	O
dst	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
src	pointer
,	O
int	O
length	double
)	O
{	O
while	O
(	O
length	double
>=	O
32	int
)	O
{	O
copy_16	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
src	pointer
+=	O
32	int
;	O
length	double
-=	O
32	int
;	O
}	O
switch	O
(	O
length	double
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
1	int
:	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
copy_2	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
3	int
:	O
copy_3	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
copy_4	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
5	int
:	O
copy_1	O
(	O
4	int
)	O
;	O
copy_4	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
6	int
:	O
copy_1	O
(	O
5	int
)	O
;	O
copy_4	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
7	int
:	O
copy_2	O
(	O
5	int
)	O
;	O
copy_4	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
8	int
:	O
copy_8	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
9	int
:	O
copy_1	O
(	O
8	int
)	O
;	O
copy_8	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
10	int
:	O
copy_1	O
(	O
9	int
)	O
;	O
copy_8	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
11	int
:	O
copy_2	O
(	O
9	int
)	O
;	O
copy_8	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
12	int
:	O
copy_4	O
(	O
8	int
)	O
;	O
copy_8	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
13	int
:	O
copy_1	O
(	O
12	int
)	O
;	O
copy_4	O
(	O
8	int
)	O
;	O
copy_8	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
14	int
:	O
copy_1	O
(	O
13	int
)	O
;	O
copy_4	O
(	O
9	int
)	O
;	O
copy_8	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
15	int
:	O
copy_2	O
(	O
13	int
)	O
;	O
copy_4	O
(	O
9	int
)	O
;	O
copy_8	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
16	int
:	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
17	int
:	O
copy_8	O
(	O
9	int
)	O
;	O
copy_1	O
(	O
8	int
)	O
;	O
copy_8	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
18	int
:	O
copy_1	O
(	O
17	int
)	O
;	O
copy_16	O
(	O
1	int
)	O
;	O
copy_1	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
19	int
:	O
copy_3	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
20	int
:	O
copy_4	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
21	int
:	O
copy_1	O
(	O
20	int
)	O
;	O
copy_4	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
22	int
:	O
copy_2	O
(	O
20	int
)	O
;	O
copy_4	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
23	int
:	O
copy_3	O
(	O
20	int
)	O
;	O
copy_4	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
24	int
:	O
copy_8	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
25	int
:	O
copy_8	O
(	O
17	int
)	O
;	O
copy_1	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
26	int
:	O
copy_1	O
(	O
25	int
)	O
;	O
copy_8	O
(	O
17	int
)	O
;	O
copy_1	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
27	int
:	O
copy_2	O
(	O
25	int
)	O
;	O
copy_8	O
(	O
17	int
)	O
;	O
copy_1	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
28	int
:	O
copy_4	O
(	O
24	int
)	O
;	O
copy_8	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
29	int
:	O
copy_1	O
(	O
28	int
)	O
;	O
copy_4	O
(	O
24	int
)	O
;	O
copy_8	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
30	int
:	O
copy_2	O
(	O
28	int
)	O
;	O
copy_4	O
(	O
24	int
)	O
;	O
copy_8	O
(	O
16	int
)	O
;	O
copy_16	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
31	int
:	O
copy_1	O
(	O
30	int
)	O
;	O
copy_4	O
(	O
26	int
)	O
;	O
copy_8	O
(	O
18	int
)	O
;	O
copy_16	O
(	O
2	int
)	O
;	O
copy_2	O
(	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Wrong length %d"	pointer
,	O
length	double
)	O
;	O
}	O
}	O
static	O
uint32_t	int
read_literal_length	function
(	O
BITCODE_RC	char
*	O
restrict	O
*	O
src	pointer
,	O
unsigned	O
char	O
opcode	pointer
)	O
{	O
uint32_t	int
length	double
=	O
opcode	pointer
+	O
8	int
;	O
if	O
(	O
length	double
==	O
0x17	int
)	O
{	O
int	O
n	int
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
length	double
+=	O
n	int
;	O
if	O
(	O
n	int
==	O
0xff	int
)	O
{	O
do	O
{	O
n	int
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
n	int
|=	O
(	O
*	O
(	O
*	O
src	pointer
)	O
++	O
<<	O
8	int
)	O
;	O
length	double
+=	O
n	int
;	O
}	O
while	O
(	O
n	int
==	O
0xFFFF	int
)	O
;	O
}	O
}	O
return	O
length	double
;	O
}	O
static	O
void	O
read_instructions	function
(	O
BITCODE_RC	char
*	O
restrict	O
*	O
src	pointer
,	O
unsigned	O
char	O
*	O
restrict	O
opcode	pointer
,	O
uint32_t	int
*	O
restrict	O
offset	double
,	O
uint32_t	int
*	O
restrict	O
length	double
)	O
{	O
switch	O
(	O
*	O
opcode	pointer
>>	O
4	int
)	O
{	O
case	O
0	int
:	O
*	O
length	double
=	O
(	O
*	O
opcode	pointer
&	O
0xf	int
)	O
+	O
0x13	int
;	O
*	O
offset	double
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
opcode	pointer
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
length	double
=	O
(	O
(	O
*	O
opcode	pointer
>>	O
3	int
)	O
&	O
0x10	int
)	O
+	O
*	O
length	double
;	O
*	O
offset	double
=	O
(	O
(	O
*	O
opcode	pointer
&	O
0x78	int
)	O
<<	O
5	int
)	O
+	O
1	int
+	O
*	O
offset	double
;	O
break	O
;	O
case	O
1	int
:	O
*	O
length	double
=	O
(	O
*	O
opcode	pointer
&	O
0xf	int
)	O
+	O
3	int
;	O
*	O
offset	double
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
opcode	pointer
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
offset	double
=	O
(	O
(	O
*	O
opcode	pointer
&	O
0xf8	int
)	O
<<	O
5	int
)	O
+	O
1	int
+	O
*	O
offset	double
;	O
break	O
;	O
case	O
2	int
:	O
*	O
offset	double
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
offset	double
=	O
(	O
(	O
*	O
(	O
*	O
src	pointer
)	O
++	O
<<	O
8	int
)	O
&	O
0xff00	int
)	O
|	O
*	O
offset	double
;	O
*	O
length	double
=	O
*	O
opcode	pointer
&	O
7	int
;	O
if	O
(	O
(	O
*	O
opcode	pointer
&	O
8	int
)	O
==	O
0	int
)	O
{	O
*	O
opcode	pointer
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
length	double
=	O
(	O
*	O
opcode	pointer
&	O
0xf8	int
)	O
+	O
*	O
length	double
;	O
}	O
else	O
{	O
(	O
*	O
offset	double
)	O
++	O
;	O
*	O
length	double
=	O
(	O
*	O
(	O
*	O
src	pointer
)	O
++	O
<<	O
3	int
)	O
+	O
*	O
length	double
;	O
*	O
opcode	pointer
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
length	double
=	O
(	O
(	O
(	O
*	O
opcode	pointer
&	O
0xf8	int
)	O
<<	O
8	int
)	O
+	O
*	O
length	double
)	O
+	O
0x100	int
;	O
}	O
break	O
;	O
default	O
:	O
*	O
length	double
=	O
*	O
opcode	pointer
>>	O
4	int
;	O
*	O
offset	double
=	O
*	O
opcode	pointer
&	O
15	int
;	O
*	O
opcode	pointer
=	O
*	O
(	O
*	O
src	pointer
)	O
++	O
;	O
*	O
offset	double
=	O
(	O
(	O
(	O
*	O
opcode	pointer
&	O
0xf8	int
)	O
<<	O
1	int
)	O
+	O
*	O
offset	double
)	O
+	O
1	int
;	O
break	O
;	O
}	O
}	O
static	O
int	O
decompress_r2007	function
(	O
BITCODE_RC	char
*	O
restrict	O
dst	pointer
,	O
const	O
unsigned	O
dst_size	int
,	O
BITCODE_RC	char
*	O
restrict	O
src	pointer
,	O
const	O
unsigned	O
src_size	int
)	O
{	O
uint32_t	int
length	double
=	O
0	int
;	O
uint32_t	int
offset	double
=	O
0	int
;	O
BITCODE_RC	char
*	O
dst_start	pointer
=	O
dst	pointer
;	O
BITCODE_RC	char
*	O
dst_end	pointer
=	O
dst	pointer
+	O
dst_size	int
;	O
BITCODE_RC	char
*	O
src_end	pointer
=	O
src	pointer
+	O
src_size	int
;	O
unsigned	O
char	O
opcode	pointer
;	O
LOG_INSANE	O
(	O
"decompress_r2007 (%p, %d, %p, %d)\n"	pointer
,	O
dst	pointer
,	O
dst_size	int
,	O
src	pointer
,	O
src_size	int
)	O
;	O
if	O
(	O
!	O
dst	pointer
||	O
!	O
src	pointer
||	O
!	O
dst_size	int
||	O
src_size	int
<	O
2	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid argument to %s\n"	pointer
,	O
__FUNCTION__	O
)	O
;	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
opcode	pointer
=	O
*	O
src	pointer
++	O
;	O
if	O
(	O
(	O
opcode	pointer
&	O
0xf0	int
)	O
==	O
0x20	int
)	O
{	O
src	pointer
+=	O
2	int
;	O
length	double
=	O
*	O
src	pointer
++	O
&	O
0x07	int
;	O
if	O
(	O
length	double
==	O
0	int
)	O
{	O
LOG_ERROR	O
(	O
"Decompression error: zero length"	pointer
)	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
}	O
while	O
(	O
src	pointer
<	O
src_end	pointer
)	O
{	O
if	O
(	O
length	double
==	O
0	int
)	O
length	double
=	O
read_literal_length	function
(	O
&	O
src	pointer
,	O
opcode	pointer
)	O
;	O
if	O
(	O
(	O
dst	pointer
+	O
length	double
)	O
>	O
dst_end	pointer
||	O
(	O
src	pointer
+	O
length	double
)	O
>	O
src_end	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Decompression error: length overflow"	pointer
)	O
;	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
LOG_INSANE	O
(	O
"copy_compressed_bytes (%p, %p, %u)\n"	pointer
,	O
dst	pointer
,	O
src	pointer
,	O
length	double
)	O
;	O
copy_compressed_bytes	function
(	O
dst	pointer
,	O
src	pointer
,	O
length	double
)	O
;	O
dst	pointer
+=	O
length	double
;	O
src	pointer
+=	O
length	double
;	O
length	double
=	O
0	int
;	O
if	O
(	O
src	pointer
>=	O
src_end	pointer
)	O
return	O
0	int
;	O
opcode	pointer
=	O
*	O
src	pointer
++	O
;	O
read_instructions	function
(	O
&	O
src	pointer
,	O
&	O
opcode	pointer
,	O
&	O
offset	double
,	O
&	O
length	double
)	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
(	O
dst	pointer
+	O
length	double
)	O
>	O
dst_end	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Decompression error: length overflow"	pointer
)	O
;	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
if	O
(	O
offset	double
>	O
(	O
uint32_t	int
)	O
(	O
dst	pointer
-	O
dst_start	pointer
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Decompression error: offset underflow"	pointer
)	O
;	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
LOG_INSANE	O
(	O
"copy_bytes (%p, %u, %u)\n"	pointer
,	O
dst	pointer
,	O
length	double
,	O
offset	double
)	O
;	O
copy_bytes	function
(	O
dst	pointer
,	O
length	double
,	O
offset	double
)	O
;	O
dst	pointer
+=	O
length	double
;	O
length	double
=	O
(	O
opcode	pointer
&	O
7	int
)	O
;	O
if	O
(	O
length	double
!=	O
0	int
||	O
src	pointer
>=	O
src_end	pointer
)	O
break	O
;	O
opcode	pointer
=	O
*	O
src	pointer
++	O
;	O
if	O
(	O
(	O
opcode	pointer
>>	O
4	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
opcode	pointer
>>	O
4	int
)	O
==	O
0x0f	int
)	O
opcode	pointer
&=	O
0xf	int
;	O
read_instructions	function
(	O
(	O
unsigned	O
char	O
*	O
*	O
)	O
&	O
src	pointer
,	O
&	O
opcode	pointer
,	O
&	O
offset	double
,	O
&	O
length	double
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
ATTRIBUTE_MALLOC	O
static	O
BITCODE_RC	char
*	O
decode_rs	function
(	O
const	O
BITCODE_RC	char
*	O
src	pointer
,	O
int	O
block_count	int
,	O
int	O
data_size	int
,	O
const	O
unsigned	O
src_size	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
const	O
BITCODE_RC	char
*	O
src_base	pointer
=	O
src	pointer
;	O
BITCODE_RC	char
*	O
dst_base	pointer
,	O
*	O
dst	pointer
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
block_count	int
*	O
data_size	int
>	O
src_size	int
)	O
{	O
LOG_ERROR	O
(	O
"decode_rs src overflow: %ld > %u"	pointer
,	O
(	O
long	O
)	O
block_count	int
*	O
data_size	int
,	O
src_size	int
)	O
return	O
NULL	O
;	O
}	O
dst_base	pointer
=	O
dst	pointer
=	O
(	O
BITCODE_RC	char
*	O
)	O
calloc	function
(	O
block_count	int
,	O
data_size	int
)	O
;	O
if	O
(	O
!	O
dst	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
block_count	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
data_size	int
;	O
++	O
j	int
)	O
{	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
;	O
src	pointer
+=	O
block_count	int
;	O
}	O
src	pointer
=	O
++	O
src_base	pointer
;	O
}	O
return	O
dst_base	pointer
;	O
}	O
static	O
BITCODE_RC	char
*	O
read_system_page	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
int64_t	long
size_comp	long
,	O
int64_t	long
size_uncomp	long
,	O
int64_t	long
repeat_count	long
)	O
{	O
int	O
i	int
;	O
int	O
error	int
=	O
0	int
;	O
int64_t	long
pesize	long
;	O
int64_t	long
block_count	int
;	O
int64_t	long
page_size	long
;	O
long	O
pedata_size	long
;	O
BITCODE_RC	char
*	O
rsdata	pointer
;	O
BITCODE_RC	char
*	O
pedata	pointer
;	O
BITCODE_RC	char
*	O
data	pointer
;	O
pesize	long
=	O
(	O
(	O
size_comp	long
+	O
7	int
)	O
&	O
~	O
7	int
)	O
*	O
repeat_count	long
;	O
block_count	int
=	O
(	O
pesize	long
+	O
238	int
)	O
/	O
239	int
;	O
page_size	long
=	O
(	O
block_count	int
*	O
255	int
+	O
7	int
)	O
&	O
~	O
7	int
;	O
assert	O
(	O
(	O
uint64_t	long
)	O
size_comp	long
<	O
dat	pointer
->	O
size	char
)	O
;	O
assert	O
(	O
(	O
uint64_t	long
)	O
size_uncomp	long
<	O
dat	pointer
->	O
size	char
)	O
;	O
assert	O
(	O
(	O
uint64_t	long
)	O
repeat_count	long
<	O
DBG_MAX_COUNT	int
)	O
;	O
assert	O
(	O
(	O
uint64_t	long
)	O
page_size	long
<	O
DBG_MAX_COUNT	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
page_size	long
>	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid page_size %ld > %lu bytes left"	pointer
,	O
(	O
long	O
)	O
page_size	long
,	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
)	O
;	O
return	O
NULL	O
;	O
}	O
data	pointer
=	O
(	O
BITCODE_RC	char
*	O
)	O
calloc	function
(	O
size_uncomp	long
+	O
page_size	long
,	O
1	int
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
return	O
NULL	O
;	O
}	O
rsdata	pointer
=	O
&	O
data	pointer
[	O
size_uncomp	long
]	O
;	O
bit_read_fixed	function
(	O
dat	pointer
,	O
rsdata	pointer
,	O
page_size	long
)	O
;	O
pedata_size	long
=	O
block_count	int
*	O
239	int
;	O
pedata	pointer
=	O
decode_rs	function
(	O
rsdata	pointer
,	O
block_count	int
,	O
239	int
,	O
page_size	long
)	O
;	O
if	O
(	O
!	O
pedata	pointer
)	O
{	O
free	function
(	O
data	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
size_comp	long
<	O
size_uncomp	long
)	O
error	int
=	O
decompress_r2007	function
(	O
data	pointer
,	O
size_uncomp	long
,	O
pedata	pointer
,	O
MIN	O
(	O
pedata_size	long
,	O
size_comp	long
)	O
)	O
;	O
else	O
memcpy	function
(	O
data	pointer
,	O
pedata	pointer
,	O
size_uncomp	long
)	O
;	O
free	function
(	O
pedata	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
free	function
(	O
data	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
data	pointer
;	O
}	O
static	O
int	O
read_data_page	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
decomp	pointer
,	O
int64_t	long
page_size	long
,	O
int64_t	long
size_comp	long
,	O
int64_t	long
size_uncomp	long
)	O
{	O
int	O
i	int
;	O
int	O
error	int
=	O
0	int
;	O
int64_t	long
pesize	long
;	O
int64_t	long
block_count	int
;	O
BITCODE_RC	char
*	O
rsdata	pointer
;	O
BITCODE_RC	char
*	O
pedata	pointer
;	O
long	O
pedata_size	long
;	O
pesize	long
=	O
(	O
(	O
size_comp	long
+	O
7	int
)	O
&	O
~	O
7	int
)	O
;	O
block_count	int
=	O
(	O
pesize	long
+	O
0xFB	int
-	O
1	int
)	O
/	O
0xFB	int
;	O
pedata_size	long
=	O
block_count	int
*	O
0xFB	int
;	O
rsdata	pointer
=	O
(	O
BITCODE_RC	char
*	O
)	O
calloc	function
(	O
1	int
,	O
page_size	long
)	O
;	O
if	O
(	O
rsdata	pointer
==	O
NULL	O
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
bit_read_fixed	function
(	O
dat	pointer
,	O
rsdata	pointer
,	O
page_size	long
)	O
;	O
pedata	pointer
=	O
decode_rs	function
(	O
rsdata	pointer
,	O
block_count	int
,	O
0xFB	int
,	O
page_size	long
)	O
;	O
if	O
(	O
!	O
pedata	pointer
)	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
if	O
(	O
size_comp	long
<	O
size_uncomp	long
)	O
error	int
=	O
decompress_r2007	function
(	O
decomp	pointer
,	O
size_uncomp	long
,	O
pedata	pointer
,	O
MIN	O
(	O
pedata_size	long
,	O
size_comp	long
)	O
)	O
;	O
else	O
memcpy	function
(	O
decomp	pointer
,	O
pedata	pointer
,	O
size_uncomp	long
)	O
;	O
free	function
(	O
pedata	pointer
)	O
;	O
free	function
(	O
rsdata	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_data_section	function
(	O
Bit_Chain	struct
*	O
sec_dat	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
,	O
Dwg_Section_Type	enum
sec_type	enum
)	O
{	O
r2007_section	struct
*	O
section	pointer
;	O
r2007_page	struct
*	O
page	pointer
;	O
uint64_t	long
max_decomp_size	int
;	O
BITCODE_RC	char
*	O
decomp	pointer
;	O
int	O
error	int
=	O
0	int
,	O
i	int
;	O
section	pointer
=	O
get_section	function
(	O
sections_map	pointer
,	O
sec_type	enum
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to find section %d"	pointer
,	O
(	O
int	O
)	O
sec_type	enum
)	O
return	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
}	O
max_decomp_size	int
=	O
section	pointer
->	O
data_size	int
;	O
if	O
(	O
max_decomp_size	int
>	O
0x2f000000	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid max decompression size %"	pointer
PRIu64	O
,	O
max_decomp_size	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
decomp	pointer
=	O
calloc	function
(	O
max_decomp_size	int
,	O
1	int
)	O
;	O
if	O
(	O
decomp	pointer
==	O
NULL	O
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
sec_dat	pointer
->	O
bit	char
=	O
0	int
;	O
sec_dat	pointer
->	O
byte	char
=	O
0	int
;	O
sec_dat	pointer
->	O
size	char
=	O
max_decomp_size	int
;	O
sec_dat	pointer
->	O
version	short
=	O
dat	pointer
->	O
version	short
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
section	pointer
->	O
num_pages	long
;	O
i	int
++	O
)	O
{	O
r2007_section_page	struct
*	O
section_page	pointer
=	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
;	O
page	pointer
=	O
get_page	function
(	O
pages_map	pointer
,	O
section_page	pointer
->	O
id	int
)	O
;	O
if	O
(	O
page	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
LOG_ERROR	O
(	O
"Failed to find page %d"	pointer
,	O
(	O
int	O
)	O
section_page	pointer
->	O
id	int
)	O
return	O
DWG_ERR_PAGENOTFOUND	int
;	O
}	O
if	O
(	O
section_page	pointer
->	O
offset	double
>	O
max_decomp_size	int
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
LOG_ERROR	O
(	O
"Invalid section_page->offset %ld > %ld"	pointer
,	O
(	O
long	O
)	O
section_page	pointer
->	O
offset	double
,	O
(	O
long	O
)	O
max_decomp_size	int
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
dat	pointer
->	O
byte	char
=	O
page	pointer
->	O
offset	double
;	O
if	O
(	O
section_page	pointer
->	O
comp_size	long
!=	O
section_page	pointer
->	O
uncomp_size	long
)	O
{	O
error	int
=	O
read_data_page	function
(	O
dat	pointer
,	O
&	O
decomp	pointer
[	O
section_page	pointer
->	O
offset	double
]	O
,	O
page	pointer
->	O
size	char
,	O
section_page	pointer
->	O
comp_size	long
,	O
section_page	pointer
->	O
uncomp_size	long
)	O
;	O
if	O
(	O
error	int
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
LOG_ERROR	O
(	O
"Failed to read compressed page"	pointer
)	O
return	O
error	int
;	O
}	O
}	O
else	O
{	O
memcpy	function
(	O
&	O
decomp	pointer
[	O
section_page	pointer
->	O
offset	double
]	O
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
section_page	pointer
->	O
uncomp_size	long
)	O
;	O
}	O
}	O
sec_dat	pointer
->	O
chain	pointer
=	O
decomp	pointer
;	O
return	O
0	int
;	O
}	O
static	O
DWGCHAR	O
*	O
bfr_read_string	function
(	O
BITCODE_RC	char
*	O
restrict	O
*	O
restrict	O
src	pointer
,	O
int64_t	long
size	char
)	O
{	O
uint16_t	short
*	O
ptr	pointer
=	O
(	O
uint16_t	short
*	O
)	O
*	O
src	pointer
;	O
int32_t	int
length	double
=	O
0	int
,	O
wsize	int
;	O
DWGCHAR	O
*	O
str	struct
,	O
*	O
str_base	pointer
;	O
int	O
i	int
;	O
if	O
(	O
size	char
<=	O
0	int
)	O
return	O
NULL	O
;	O
while	O
(	O
*	O
ptr	pointer
!=	O
0	int
&&	O
length	double
*	O
2	int
<	O
size	char
)	O
{	O
ptr	pointer
++	O
;	O
length	double
++	O
;	O
}	O
wsize	int
=	O
length	double
*	O
sizeof	O
(	O
DWGCHAR	O
)	O
+	O
sizeof	O
(	O
DWGCHAR	O
)	O
;	O
str	struct
=	O
str_base	pointer
=	O
(	O
DWGCHAR	O
*	O
)	O
malloc	function
(	O
wsize	int
)	O
;	O
if	O
(	O
!	O
str	struct
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
ptr	pointer
=	O
(	O
uint16_t	short
*	O
)	O
*	O
src	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	double
;	O
i	int
++	O
)	O
{	O
*	O
str	struct
++	O
=	O
(	O
DWGCHAR	O
)	O
(	O
*	O
ptr	pointer
++	O
)	O
;	O
}	O
*	O
src	pointer
+=	O
size	char
;	O
*	O
str	struct
=	O
0	int
;	O
return	O
str_base	pointer
;	O
}	O
static	O
r2007_section	struct
*	O
read_sections_map	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
int64_t	long
size_comp	long
,	O
int64_t	long
size_uncomp	long
,	O
int64_t	long
correction	long
)	O
{	O
BITCODE_RC	char
*	O
data	pointer
;	O
r2007_section	struct
*	O
sections	pointer
=	O
NULL	O
,	O
*	O
last_section	pointer
=	O
NULL	O
,	O
*	O
section	pointer
=	O
NULL	O
;	O
BITCODE_RC	char
*	O
ptr	pointer
,	O
*	O
ptr_end	pointer
;	O
int	O
i	int
,	O
j	int
=	O
0	int
;	O
data	pointer
=	O
read_system_page	function
(	O
dat	pointer
,	O
size_comp	long
,	O
size_uncomp	long
,	O
correction	long
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read system page"	pointer
)	O
return	O
NULL	O
;	O
}	O
ptr	pointer
=	O
data	pointer
;	O
ptr_end	pointer
=	O
data	pointer
+	O
size_uncomp	long
;	O
LOG_TRACE	O
(	O
"\n=== System Section (Section Map) ===\n"	pointer
)	O
while	O
(	O
ptr	pointer
<	O
ptr_end	pointer
)	O
{	O
section	pointer
=	O
(	O
r2007_section	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
r2007_section	struct
)	O
)	O
;	O
if	O
(	O
!	O
section	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
sections_destroy	function
(	O
sections	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
bfr_read	function
(	O
section	pointer
,	O
&	O
ptr	pointer
,	O
64	int
)	O
;	O
LOG_TRACE	O
(	O
"\nSection [%d]:\n"	pointer
,	O
j	int
)	O
LOG_TRACE	O
(	O
"  data size:     %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
data_size	int
)	O
LOG_TRACE	O
(	O
"  max size:      %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
max_size	int
)	O
LOG_TRACE	O
(	O
"  encryption:    %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
encrypted	int
)	O
LOG_HANDLE	O
(	O
"  hashcode:      %"	pointer
PRIx64	O
"\n"	pointer
,	O
section	pointer
->	O
hashcode	long
)	O
LOG_HANDLE	O
(	O
"  name length:   %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
name_length	long
)	O
LOG_TRACE	O
(	O
"  unknown:       %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
unknown	char
)	O
LOG_TRACE	O
(	O
"  encoding:      %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
encoded	long
)	O
LOG_TRACE	O
(	O
"  num pages:     %"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
num_pages	long
)	O
;	O
if	O
(	O
section	pointer
->	O
data_size	int
>	O
10	int
*	O
dat	pointer
->	O
size	char
||	O
section	pointer
->	O
name_length	long
>=	O
(	O
int64_t	long
)	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid System Section"	pointer
)	O
;	O
free	function
(	O
section	pointer
)	O
;	O
free	function
(	O
data	pointer
)	O
;	O
sections_destroy	function
(	O
sections	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
sections	pointer
)	O
{	O
sections	pointer
=	O
last_section	pointer
=	O
section	pointer
;	O
}	O
else	O
{	O
last_section	pointer
->	O
next	pointer
=	O
section	pointer
;	O
last_section	pointer
=	O
section	pointer
;	O
}	O
j	int
++	O
;	O
if	O
(	O
ptr	pointer
>=	O
ptr_end	pointer
)	O
break	O
;	O
section	pointer
->	O
name	pointer
=	O
bfr_read_string	function
(	O
&	O
ptr	pointer
,	O
section	pointer
->	O
name_length	long
)	O
;	O
LOG_TRACE	O
(	O
"  name:          "	pointer
)	O
LOG_TEXT_UNICODE	O
(	O
TRACE	pointer
,	O
section	pointer
->	O
name	pointer
)	O
LOG_TRACE	O
(	O
"\n\n"	pointer
)	O
section	pointer
->	O
type	short
=	O
dwg_section_type	function
(	O
section	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
section	pointer
->	O
num_pages	long
<=	O
0	int
)	O
continue	O
;	O
if	O
(	O
section	pointer
->	O
num_pages	long
>	O
0xf0000	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid num_pages %lu, skip"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
num_pages	long
)	O
;	O
continue	O
;	O
}	O
section	pointer
->	O
pages	pointer
=	O
(	O
r2007_section_page	struct
*	O
*	O
)	O
calloc	function
(	O
(	O
size_t	long
)	O
section	pointer
->	O
num_pages	long
,	O
sizeof	O
(	O
r2007_section_page	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
section	pointer
->	O
pages	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
if	O
(	O
sections	pointer
)	O
sections_destroy	function
(	O
sections	pointer
)	O
;	O
else	O
sections_destroy	function
(	O
section	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
section	pointer
->	O
num_pages	long
;	O
i	int
++	O
)	O
{	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
=	O
(	O
r2007_section_page	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
r2007_section_page	struct
)	O
)	O
;	O
if	O
(	O
!	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
if	O
(	O
sections	pointer
)	O
sections_destroy	function
(	O
sections	pointer
)	O
;	O
else	O
sections_destroy	function
(	O
section	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ptr	pointer
+	O
56	int
>=	O
ptr_end	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Section[%d]->pages[%d] overflow"	pointer
,	O
j	int
,	O
i	int
)	O
;	O
section	pointer
->	O
num_pages	long
=	O
i	int
;	O
break	O
;	O
}	O
bfr_read	function
(	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
,	O
&	O
ptr	pointer
,	O
56	int
)	O
;	O
LOG_TRACE	O
(	O
" Page[%d]: "	pointer
,	O
i	int
)	O
LOG_TRACE	O
(	O
" offset: 0x%07"	pointer
PRIx64	O
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
offset	double
)	O
;	O
LOG_TRACE	O
(	O
" size: %5"	pointer
PRIu64	O
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
" id: %4"	pointer
PRIu64	O
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
id	int
)	O
;	O
LOG_TRACE	O
(	O
" uncomp_size: %5"	pointer
PRIu64	O
"\n"	pointer
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
uncomp_size	long
)	O
;	O
LOG_HANDLE	O
(	O
" comp_size: %5"	pointer
PRIu64	O
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
comp_size	long
)	O
;	O
LOG_HANDLE	O
(	O
" checksum: %016"	pointer
PRIx64	O
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
checksum	int
)	O
;	O
LOG_HANDLE	O
(	O
" crc64: %016"	pointer
PRIx64	O
"\n"	pointer
,	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
crc	long
)	O
;	O
if	O
(	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
size	char
>=	O
DBG_MAX_SIZE	int
||	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
uncomp_size	long
>=	O
DBG_MAX_SIZE	int
||	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
comp_size	long
>=	O
DBG_MAX_SIZE	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid section->pages[%d].*size"	pointer
,	O
i	int
)	O
;	O
section	pointer
->	O
num_pages	long
=	O
i	int
;	O
return	O
sections	pointer
;	O
}	O
assert	O
(	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
size	char
<	O
DBG_MAX_SIZE	int
)	O
;	O
assert	O
(	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
uncomp_size	long
<	O
DBG_MAX_SIZE	int
)	O
;	O
assert	O
(	O
section	pointer
->	O
pages	pointer
[	O
i	int
]	O
->	O
comp_size	long
<	O
DBG_MAX_SIZE	int
)	O
;	O
}	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
sections	pointer
;	O
}	O
static	O
r2007_page	struct
*	O
read_pages_map	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
int64_t	long
size_comp	long
,	O
int64_t	long
size_uncomp	long
,	O
int64_t	long
correction	long
)	O
{	O
BITCODE_RC	char
*	O
data	pointer
,	O
*	O
ptr	pointer
,	O
*	O
ptr_end	pointer
;	O
r2007_page	struct
*	O
pages	pointer
=	O
NULL	O
,	O
*	O
last_page	pointer
=	O
NULL	O
,	O
*	O
page	pointer
;	O
int64_t	long
offset	double
=	O
0x480	int
;	O
data	pointer
=	O
read_system_page	function
(	O
dat	pointer
,	O
size_comp	long
,	O
size_uncomp	long
,	O
correction	long
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read system page"	pointer
)	O
return	O
NULL	O
;	O
}	O
ptr	pointer
=	O
data	pointer
;	O
ptr_end	pointer
=	O
data	pointer
+	O
size_uncomp	long
;	O
LOG_TRACE	O
(	O
"\n=== System Section (Pages Map) ===\n"	pointer
)	O
while	O
(	O
ptr	pointer
<	O
ptr_end	pointer
)	O
{	O
page	pointer
=	O
(	O
r2007_page	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
r2007_page	struct
)	O
)	O
;	O
if	O
(	O
page	pointer
==	O
NULL	O
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
free	function
(	O
data	pointer
)	O
;	O
pages_destroy	function
(	O
pages	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ptr	pointer
+	O
16	int
>	O
ptr_end	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Page out of bounds"	pointer
)	O
free	function
(	O
data	pointer
)	O
;	O
pages_destroy	function
(	O
pages	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
page	pointer
->	O
size	char
=	O
bfr_read_uint64	O
(	O
ptr	pointer
)	O
;	O
page	pointer
->	O
id	int
=	O
bfr_read_int64	O
(	O
ptr	pointer
)	O
;	O
page	pointer
->	O
offset	double
=	O
offset	double
;	O
offset	double
+=	O
page	pointer
->	O
size	char
;	O
LOG_TRACE	O
(	O
"Page [%3"	pointer
PRId64	O
"]: "	pointer
,	O
page	pointer
->	O
id	int
)	O
LOG_TRACE	O
(	O
"size: %6"	pointer
PRIu64	O
" "	pointer
,	O
page	pointer
->	O
size	char
)	O
LOG_TRACE	O
(	O
"id: 0x%04"	pointer
PRIx64	O
" "	pointer
,	O
page	pointer
->	O
id	int
)	O
LOG_TRACE	O
(	O
"offset: 0x%"	pointer
PRIx64	O
" \n"	pointer
,	O
page	pointer
->	O
offset	double
)	O
page	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
pages	pointer
==	O
NULL	O
)	O
pages	pointer
=	O
last_page	pointer
=	O
page	pointer
;	O
else	O
{	O
last_page	pointer
->	O
next	pointer
=	O
page	pointer
;	O
last_page	pointer
=	O
page	pointer
;	O
}	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
pages	pointer
;	O
}	O
static	O
r2007_page	struct
*	O
get_page	function
(	O
r2007_page	struct
*	O
pages_map	pointer
,	O
int64_t	long
id	int
)	O
{	O
r2007_page	struct
*	O
page	pointer
=	O
pages_map	pointer
;	O
while	O
(	O
page	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
page	pointer
->	O
id	int
==	O
id	int
)	O
break	O
;	O
page	pointer
=	O
page	pointer
->	O
next	pointer
;	O
}	O
return	O
page	pointer
;	O
}	O
static	O
void	O
pages_destroy	function
(	O
r2007_page	struct
*	O
page	pointer
)	O
{	O
r2007_page	struct
*	O
next	pointer
;	O
while	O
(	O
page	pointer
!=	O
0	int
)	O
{	O
next	pointer
=	O
page	pointer
->	O
next	pointer
;	O
free	function
(	O
page	pointer
)	O
;	O
page	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
r2007_section	struct
*	O
get_section	function
(	O
r2007_section	struct
*	O
sections_map	pointer
,	O
Dwg_Section_Type	enum
sec_type	enum
)	O
{	O
r2007_section	struct
*	O
section	pointer
=	O
sections_map	pointer
;	O
while	O
(	O
section	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
section	pointer
->	O
type	short
==	O
sec_type	enum
)	O
break	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
;	O
}	O
return	O
section	pointer
;	O
}	O
static	O
void	O
sections_destroy	function
(	O
r2007_section	struct
*	O
section	pointer
)	O
{	O
r2007_section	struct
*	O
next	pointer
;	O
while	O
(	O
section	pointer
!=	O
0	int
)	O
{	O
next	pointer
=	O
section	pointer
->	O
next	pointer
;	O
if	O
(	O
section	pointer
->	O
pages	pointer
)	O
{	O
while	O
(	O
section	pointer
->	O
num_pages	long
--	O
>	O
0	int
)	O
{	O
free	function
(	O
section	pointer
->	O
pages	pointer
[	O
section	pointer
->	O
num_pages	long
]	O
)	O
;	O
}	O
free	function
(	O
section	pointer
->	O
pages	pointer
)	O
;	O
}	O
if	O
(	O
section	pointer
->	O
name	pointer
)	O
free	function
(	O
section	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
section	pointer
)	O
;	O
section	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
int	O
read_file_header	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
r2007_file_header	struct
*	O
restrict	O
file_header	pointer
)	O
{	O
BITCODE_RC	char
data	pointer
[	O
0x3d8	int
]	O
;	O
BITCODE_RC	char
*	O
pedata	pointer
;	O
uint64_t	long
seqence_crc	long
;	O
uint64_t	long
seqence_key	long
;	O
uint64_t	long
compr_crc	long
;	O
int32_t	int
compr_len	int
,	O
len2	int
;	O
int	O
i	int
;	O
int	O
error	int
=	O
0	int
,	O
errcount	int
=	O
0	int
;	O
const	O
int	O
pedata_size	long
=	O
3	int
*	O
239	int
;	O
dat	pointer
->	O
byte	char
=	O
0x80	int
;	O
LOG_TRACE	O
(	O
"\n=== File header ===\n"	pointer
)	O
memset	function
(	O
file_header	pointer
,	O
0	int
,	O
sizeof	O
(	O
r2007_file_header	struct
)	O
)	O
;	O
bit_read_fixed	function
(	O
dat	pointer
,	O
data	pointer
,	O
0x3d8	int
)	O
;	O
pedata	pointer
=	O
decode_rs	function
(	O
data	pointer
,	O
3	int
,	O
239	int
,	O
0x3d8	int
)	O
;	O
if	O
(	O
!	O
pedata	pointer
)	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
seqence_crc	long
=	O
*	O
(	O
(	O
uint64_t	long
*	O
)	O
pedata	pointer
)	O
;	O
seqence_key	long
=	O
*	O
(	O
(	O
uint64_t	long
*	O
)	O
&	O
pedata	pointer
[	O
8	int
]	O
)	O
;	O
compr_crc	long
=	O
*	O
(	O
(	O
uint64_t	long
*	O
)	O
&	O
pedata	pointer
[	O
16	int
]	O
)	O
;	O
compr_len	int
=	O
*	O
(	O
(	O
int32_t	int
*	O
)	O
&	O
pedata	pointer
[	O
24	int
]	O
)	O
;	O
len2	int
=	O
*	O
(	O
(	O
int32_t	int
*	O
)	O
&	O
pedata	pointer
[	O
28	int
]	O
)	O
;	O
LOG_TRACE	O
(	O
"seqence_crc64: %016lX\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
seqence_crc	long
)	O
;	O
LOG_TRACE	O
(	O
"seqence_key:   %016lX\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
seqence_key	long
)	O
;	O
LOG_TRACE	O
(	O
"compr_crc64:   %016lX\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
compr_crc	long
)	O
;	O
LOG_TRACE	O
(	O
"compr_len:     %d\n"	pointer
,	O
(	O
int	O
)	O
compr_len	int
)	O
;	O
LOG_TRACE	O
(	O
"len2:          %d\n"	pointer
,	O
(	O
int	O
)	O
len2	int
)	O
;	O
if	O
(	O
compr_len	int
>	O
0	int
)	O
error	int
=	O
decompress_r2007	function
(	O
(	O
BITCODE_RC	char
*	O
)	O
file_header	pointer
,	O
0x110	int
,	O
&	O
pedata	pointer
[	O
32	int
]	O
,	O
MIN	O
(	O
compr_len	int
,	O
pedata_size	long
-	O
32	int
)	O
)	O
;	O
else	O
memcpy	function
(	O
file_header	pointer
,	O
&	O
pedata	pointer
[	O
32	int
]	O
,	O
sizeof	O
(	O
r2007_file_header	struct
)	O
)	O
;	O
if	O
(	O
!	O
error	int
)	O
{	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
header_size	int
)	O
;	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
file_size	long
)	O
;	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
pages_map_offset	long
)	O
;	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
header2_offset	long
)	O
;	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
pages_map_offset	long
)	O
;	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
pages_map_size_comp	long
)	O
;	O
VALID_SIZE	O
(	O
file_header	pointer
->	O
pages_map_size_uncomp	long
)	O
;	O
VALID_COUNT	O
(	O
file_header	pointer
->	O
pages_maxid	long
)	O
;	O
VALID_COUNT	O
(	O
file_header	pointer
->	O
pages_amount	long
)	O
;	O
VALID_COUNT	O
(	O
file_header	pointer
->	O
num_sections	int
)	O
;	O
}	O
free	function
(	O
pedata	pointer
)	O
;	O
return	O
error	int
;	O
}	O
unsigned	O
long	O
obj_stream_position	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
str_dat	pointer
)	O
{	O
unsigned	O
long	O
p1	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
SINCE	O
(	O
R_2007	int
)	O
{	O
unsigned	O
long	O
p2	long
=	O
bit_position	function
(	O
hdl_dat	pointer
)	O
;	O
unsigned	O
long	O
p3	long
=	O
bit_position	function
(	O
str_dat	pointer
)	O
;	O
if	O
(	O
p2	long
>	O
p1	long
)	O
return	O
p3	long
>	O
p2	long
?	O
p3	long
:	O
p2	long
;	O
else	O
return	O
p3	long
>	O
p1	long
?	O
p3	long
:	O
p1	long
;	O
}	O
else	O
{	O
return	O
p1	long
;	O
}	O
}	O
int	O
obj_handle_stream	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
hdl_dat	pointer
)	O
{	O
long	O
unsigned	O
int	O
bit8	long
=	O
obj	pointer
->	O
bitsize	int
/	O
8	int
;	O
long	O
unsigned	O
int	O
pos	long
=	O
dat	pointer
->	O
byte	char
;	O
obj	pointer
->	O
hdlpos	long
=	O
obj	pointer
->	O
bitsize	int
;	O
hdl_dat	pointer
->	O
byte	char
=	O
bit8	long
;	O
hdl_dat	pointer
->	O
bit	char
=	O
obj	pointer
->	O
bitsize	int
%	O
8	int
;	O
if	O
(	O
!	O
obj	pointer
->	O
handlestream_size	long
)	O
{	O
obj	pointer
->	O
handlestream_size	long
=	O
(	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
-	O
obj	pointer
->	O
bitsize	int
;	O
LOG_TRACE	O
(	O
" Hdlsize: %lu,"	pointer
,	O
obj	pointer
->	O
handlestream_size	long
)	O
;	O
}	O
hdl_dat	pointer
->	O
size	char
=	O
obj	pointer
->	O
size	char
;	O
pos	long
=	O
(	O
pos	long
*	O
8	int
)	O
+	O
obj	pointer
->	O
bitsize	int
+	O
obj	pointer
->	O
handlestream_size	long
;	O
LOG_HANDLE	O
(	O
" hdl_dat: @%lu.%u - @%lu.%lu (%lu)"	pointer
,	O
bit8	long
,	O
hdl_dat	pointer
->	O
bit	char
,	O
pos	long
/	O
8	int
,	O
pos	long
%	O
8	int
,	O
hdl_dat	pointer
->	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"\n"	pointer
)	O
return	O
0	int
;	O
}	O
int	O
obj_string_stream	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
str	struct
)	O
{	O
BITCODE_RL	int
start	struct
=	O
obj	pointer
->	O
bitsize	int
-	O
1	int
;	O
BITCODE_RL	int
data_size	int
=	O
0	int
;	O
BITCODE_RL	int
old_size	int
;	O
BITCODE_RL	int
old_byte	int
;	O
old_size	int
=	O
str	struct
->	O
size	char
;	O
old_byte	int
=	O
str	struct
->	O
byte	char
;	O
str	struct
->	O
chain	pointer
+=	O
str	struct
->	O
byte	char
;	O
str	struct
->	O
byte	char
=	O
0	int
;	O
str	struct
->	O
bit	char
=	O
0	int
;	O
str	struct
->	O
size	char
=	O
(	O
obj	pointer
->	O
bitsize	int
/	O
8	int
)	O
+	O
(	O
(	O
obj	pointer
->	O
bitsize	int
%	O
8	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
bit_advance_position	function
(	O
str	struct
,	O
start	struct
-	O
8	int
)	O
;	O
if	O
(	O
str	struct
->	O
byte	char
>=	O
old_size	int
-	O
old_byte	int
)	O
{	O
LOG_WARN	O
(	O
"obj_string_stream overflow"	pointer
)	O
;	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
LOG_HANDLE	O
(	O
" obj string stream +%u: @%lu.%u (%lu)"	pointer
,	O
start	struct
,	O
str	struct
->	O
byte	char
,	O
str	struct
->	O
bit	char
&	O
7	int
,	O
bit_position	function
(	O
str	struct
)	O
)	O
;	O
obj	pointer
->	O
has_strings	char
=	O
bit_read_B	function
(	O
str	struct
)	O
;	O
LOG_TRACE	O
(	O
" has_strings: %d\n"	pointer
,	O
(	O
int	O
)	O
obj	pointer
->	O
has_strings	char
)	O
;	O
if	O
(	O
!	O
obj	pointer
->	O
has_strings	char
)	O
{	O
str	struct
->	O
size	char
=	O
0	int
;	O
return	O
0	int
;	O
}	O
bit_advance_position	function
(	O
str	struct
,	O
-	O
1	int
)	O
;	O
str	struct
->	O
byte	char
-=	O
2	int
;	O
LOG_HANDLE	O
(	O
" @%lu.%u"	pointer
,	O
str	struct
->	O
byte	char
,	O
str	struct
->	O
bit	char
&	O
7	int
)	O
;	O
data_size	int
=	O
(	O
BITCODE_RL	int
)	O
bit_read_RS	function
(	O
str	struct
)	O
;	O
LOG_HANDLE	O
(	O
" data_size: %u/0x%x"	pointer
,	O
data_size	int
,	O
data_size	int
)	O
;	O
if	O
(	O
data_size	int
&	O
0x8000	int
)	O
{	O
BITCODE_RS	short
hi_size	short
;	O
bit_advance_position	function
(	O
str	struct
,	O
-	O
1	int
)	O
;	O
str	struct
->	O
byte	char
-=	O
4	int
;	O
data_size	int
&=	O
0x7FFF	int
;	O
hi_size	short
=	O
bit_read_RS	function
(	O
str	struct
)	O
;	O
data_size	int
|=	O
(	O
hi_size	short
<<	O
15	int
)	O
;	O
LOG_HANDLE	O
(	O
" data_size: %u/0x%x\n"	pointer
,	O
data_size	int
,	O
data_size	int
)	O
;	O
}	O
else	O
LOG_HANDLE	O
(	O
"\n"	pointer
)	O
;	O
str	struct
->	O
byte	char
-=	O
2	int
;	O
if	O
(	O
data_size	int
>	O
obj	pointer
->	O
bitsize	int
)	O
{	O
LOG_WARN	O
(	O
"Invalid string stream data_size: @%lu.%u\n"	pointer
,	O
str	struct
->	O
byte	char
,	O
str	struct
->	O
bit	char
&	O
7	int
)	O
;	O
obj	pointer
->	O
has_strings	char
=	O
0	int
;	O
bit_reset_chain	function
(	O
str	struct
)	O
;	O
return	O
DWG_ERR_NOTYETSUPPORTED	int
;	O
}	O
obj	pointer
->	O
stringstream_size	int
=	O
data_size	int
;	O
bit_advance_position	function
(	O
str	struct
,	O
-	O
(	O
int	O
)	O
data_size	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
section_string_stream	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
BITCODE_RL	int
bitsize	int
,	O
Bit_Chain	struct
*	O
restrict	O
str	struct
)	O
{	O
BITCODE_RL	int
start	struct
;	O
BITCODE_RL	int
data_size	int
;	O
BITCODE_B	char
endbit	char
;	O
PRE	O
(	O
R_2010	int
)	O
{	O
start	struct
=	O
bitsize	int
+	O
159	int
;	O
}	O
else	O
{	O
start	struct
=	O
bitsize	int
+	O
191	int
;	O
}	O
*	O
str	struct
=	O
*	O
dat	pointer
;	O
bit_set_position	function
(	O
str	struct
,	O
start	struct
)	O
;	O
LOG_TRACE	O
(	O
"section string stream\n  pos: "	pointer
FORMAT_RL	O
", %lu/%u\n"	pointer
,	O
start	struct
,	O
str	struct
->	O
byte	char
,	O
str	struct
->	O
bit	char
)	O
;	O
endbit	char
=	O
bit_read_B	function
(	O
str	struct
)	O
;	O
LOG_HANDLE	O
(	O
"  endbit: %d\n"	pointer
,	O
(	O
int	O
)	O
endbit	char
)	O
;	O
if	O
(	O
!	O
endbit	char
)	O
return	O
;	O
start	struct
-=	O
16	int
;	O
bit_set_position	function
(	O
str	struct
,	O
start	struct
)	O
;	O
LOG_HANDLE	O
(	O
"  pos: "	pointer
FORMAT_RL	O
", %lu\n"	pointer
,	O
start	struct
,	O
str	struct
->	O
byte	char
)	O
;	O
data_size	int
=	O
bit_read_RS	function
(	O
str	struct
)	O
;	O
LOG_HANDLE	O
(	O
"  data_size: "	pointer
FORMAT_RL	O
"\n"	pointer
,	O
data_size	int
)	O
;	O
if	O
(	O
data_size	int
&	O
0x8000	int
)	O
{	O
BITCODE_RS	short
hi_size	short
;	O
start	struct
-=	O
16	int
;	O
data_size	int
&=	O
0x7FFF	int
;	O
bit_set_position	function
(	O
str	struct
,	O
start	struct
)	O
;	O
LOG_HANDLE	O
(	O
"  pos: "	pointer
FORMAT_RL	O
", %lu\n"	pointer
,	O
start	struct
,	O
str	struct
->	O
byte	char
)	O
;	O
hi_size	short
=	O
bit_read_RS	function
(	O
str	struct
)	O
;	O
data_size	int
|=	O
(	O
hi_size	short
<<	O
15	int
)	O
;	O
LOG_HANDLE	O
(	O
"  hi_size: "	pointer
FORMAT_RS	O
", data_size: "	pointer
FORMAT_RL	O
"\n"	pointer
,	O
hi_size	short
,	O
data_size	int
)	O
;	O
}	O
start	struct
-=	O
data_size	int
;	O
bit_set_position	function
(	O
str	struct
,	O
start	struct
)	O
;	O
LOG_HANDLE	O
(	O
"  pos: "	pointer
FORMAT_RL	O
", %lu/%u\n"	pointer
,	O
start	struct
,	O
str	struct
->	O
byte	char
,	O
str	struct
->	O
bit	char
)	O
;	O
}	O
static	O
int	O
read_2007_section_classes	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
{	O
BITCODE_RL	int
size	char
,	O
i	int
;	O
BITCODE_BS	short
max_num	short
;	O
Bit_Chain	struct
sec_dat	pointer
=	O
{	O
0	int
}	O
,	O
str	struct
=	O
{	O
0	int
}	O
;	O
int	O
error	int
;	O
char	O
c	char
;	O
error	int
=	O
read_data_section	function
(	O
&	O
sec_dat	pointer
,	O
dat	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
,	O
SECTION_CLASSES	int
)	O
;	O
if	O
(	O
error	int
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read class section"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
&	O
sec_dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_CLASS_BEGIN	int
)	O
)	O
)	O
{	O
BITCODE_RL	int
bitsize	int
=	O
0	int
;	O
LOG_TRACE	O
(	O
"\nClasses\n-------------------\n"	pointer
)	O
size	char
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"size: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
size	char
)	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
{	O
bitsize	int
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
bitsize	int
)	O
}	O
max_num	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"max_num: "	pointer
FORMAT_BS	O
" [BS]\n"	pointer
,	O
max_num	short
)	O
c	char
=	O
bit_read_RC	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"c: "	pointer
FORMAT_RC	pointer
" [RC]\n"	pointer
,	O
c	char
)	O
c	char
=	O
bit_read_RC	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"c: "	pointer
FORMAT_RC	pointer
" [RC]\n"	pointer
,	O
c	char
)	O
c	char
=	O
bit_read_B	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"c: "	pointer
FORMAT_B	pointer
" [B]\n"	pointer
,	O
c	char
)	O
;	O
dwg	pointer
->	O
layout_type	int
=	O
0	int
;	O
dwg	pointer
->	O
num_classes	short
=	O
max_num	short
-	O
499	int
;	O
if	O
(	O
max_num	short
<	O
500	int
||	O
max_num	short
>	O
5000	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid max class number %d"	pointer
,	O
max_num	short
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
assert	O
(	O
max_num	short
>=	O
500	int
)	O
;	O
assert	O
(	O
max_num	short
<	O
5000	int
)	O
;	O
section_string_stream	function
(	O
&	O
sec_dat	pointer
,	O
bitsize	int
,	O
&	O
str	struct
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
=	O
(	O
Dwg_Class	struct
*	O
)	O
calloc	function
(	O
dwg	pointer
->	O
num_classes	short
,	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dwg_class	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_classes	short
;	O
i	int
++	O
)	O
{	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
number	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
proxyflag	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
appname	pointer
=	O
(	O
char	O
*	O
)	O
bit_read_TU	function
(	O
&	O
str	struct
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
cppname	pointer
=	O
(	O
char	O
*	O
)	O
bit_read_TU	function
(	O
&	O
str	struct
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname_u	pointer
=	O
bit_read_TU	function
(	O
&	O
str	struct
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
is_zombie	char
=	O
bit_read_B	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
item_class_id	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
num_instances	int
=	O
bit_read_BL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dwg_version	int
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
maint_version	int
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_1	double
=	O
bit_read_BL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_2	double
=	O
bit_read_BL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"-------------------\n"	pointer
)	O
LOG_TRACE	O
(	O
"Number:           %d\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
number	short
)	O
LOG_TRACE	O
(	O
"Proxyflag:        0x%x\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
proxyflag	short
)	O
LOG_TRACE_TU	O
(	O
"Application name"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
appname	pointer
,	O
0	int
)	O
LOG_TRACE_TU	O
(	O
"C++ class name  "	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
cppname	pointer
,	O
0	int
)	O
LOG_TRACE_TU	O
(	O
"DXF record name "	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname_u	pointer
,	O
0	int
)	O
LOG_TRACE	O
(	O
"Class ID:         0x%x "	pointer
"(0x1f3 for object, 0x1f2 for entity)\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
item_class_id	short
)	O
LOG_TRACE	O
(	O
"instance count:   %u\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
num_instances	int
)	O
LOG_TRACE	O
(	O
"dwg version:      %u (%u)\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dwg_version	int
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
maint_version	int
)	O
LOG_HANDLE	O
(	O
"unknown:          %u %u\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_1	double
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_2	double
)	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
=	O
bit_convert_TU	function
(	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname_u	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
&&	O
strEQc	O
(	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
,	O
"LAYOUT"	pointer
)	O
)	O
dwg	pointer
->	O
layout_type	int
=	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
number	short
;	O
}	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Failed to find class section sentinel"	pointer
)	O
;	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
DWG_ERR_CLASSESNOTFOUND	int
;	O
}	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
read_2007_section_header	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
hdl_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
{	O
Bit_Chain	struct
sec_dat	pointer
=	O
{	O
0	int
}	O
,	O
str_dat	pointer
=	O
{	O
0	int
}	O
;	O
int	O
error	int
;	O
LOG_TRACE	O
(	O
"\nSection Header\n-------------------\n"	pointer
)	O
;	O
error	int
=	O
read_data_section	function
(	O
&	O
sec_dat	pointer
,	O
dat	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
,	O
SECTION_HEADER	int
)	O
;	O
if	O
(	O
error	int
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read header section"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
&	O
sec_dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_VARIABLE_BEGIN	int
)	O
)	O
)	O
{	O
BITCODE_RL	int
endbits	int
=	O
160	int
;	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"size: "	pointer
FORMAT_RL	O
"\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
)	O
;	O
*	O
hdl_dat	pointer
=	O
sec_dat	pointer
;	O
if	O
(	O
dat	pointer
->	O
version	short
==	O
R_2007	int
)	O
{	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
)	O
;	O
endbits	int
+=	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
;	O
bit_set_position	function
(	O
hdl_dat	pointer
,	O
endbits	int
)	O
;	O
section_string_stream	function
(	O
&	O
sec_dat	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
,	O
&	O
str_dat	pointer
)	O
;	O
}	O
dwg_decode_header_variables	function
(	O
&	O
sec_dat	pointer
,	O
hdl_dat	pointer
,	O
&	O
str_dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
else	O
{	O
DEBUG_HERE	O
;	O
error	int
=	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
}	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2007_section_handles	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl	array
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
{	O
static	O
Bit_Chain	struct
obj_dat	struct
=	O
{	O
0	int
}	O
,	O
hdl_dat	pointer
=	O
{	O
0	int
}	O
;	O
BITCODE_RS	short
section_size	short
=	O
0	int
;	O
long	O
unsigned	O
int	O
endpos	long
;	O
int	O
error	int
;	O
error	int
=	O
read_data_section	function
(	O
&	O
obj_dat	struct
,	O
dat	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
,	O
SECTION_OBJECTS	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
||	O
!	O
obj_dat	struct
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read objects section"	pointer
)	O
;	O
if	O
(	O
obj_dat	struct
.	O
chain	pointer
)	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
LOG_TRACE	O
(	O
"\nHandles\n-------------------\n"	pointer
)	O
error	int
=	O
read_data_section	function
(	O
&	O
hdl_dat	pointer
,	O
dat	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
,	O
SECTION_HANDLES	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
||	O
!	O
hdl_dat	pointer
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read handles section"	pointer
)	O
;	O
if	O
(	O
obj_dat	struct
.	O
chain	pointer
)	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
if	O
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
endpos	long
=	O
hdl_dat	pointer
.	O
byte	char
+	O
hdl_dat	pointer
.	O
size	char
;	O
dwg	pointer
->	O
num_objects	int
=	O
0	int
;	O
do	O
{	O
long	O
unsigned	O
int	O
last_offset	long
;	O
long	O
unsigned	O
int	O
oldpos	long
=	O
0	int
;	O
long	O
unsigned	O
int	O
startpos	long
=	O
hdl_dat	pointer
.	O
byte	char
;	O
uint16_t	short
crc1	short
,	O
crc2	short
;	O
section_size	short
=	O
bit_read_RS_LE	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\nSection size: %u\n"	pointer
,	O
section_size	short
)	O
;	O
if	O
(	O
section_size	short
>	O
2050	int
)	O
{	O
LOG_ERROR	O
(	O
"Object-map/handles section size greater than 2050!"	pointer
)	O
;	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
last_offset	long
=	O
0	int
;	O
while	O
(	O
(	O
long	O
)	O
(	O
hdl_dat	pointer
.	O
byte	char
-	O
startpos	long
)	O
<	O
(	O
long	O
)	O
section_size	short
)	O
{	O
int	O
added	int
;	O
BITCODE_UMC	long
handleoff	long
;	O
BITCODE_MC	long
offset	double
;	O
oldpos	long
=	O
hdl_dat	pointer
.	O
byte	char
;	O
handleoff	long
=	O
bit_read_UMC	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
offset	double
=	O
bit_read_MC	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
last_offset	long
+=	O
offset	double
;	O
LOG_TRACE	O
(	O
"\nNext object: %lu "	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_TRACE	O
(	O
"Handleoff: "	pointer
FORMAT_MC	pointer
" [UMC] "	pointer
"Offset: "	pointer
FORMAT_MC	pointer
" [MC] @%lu\n"	pointer
,	O
handleoff	long
,	O
offset	double
,	O
last_offset	long
)	O
if	O
(	O
hdl_dat	pointer
.	O
byte	char
==	O
oldpos	long
)	O
break	O
;	O
added	int
=	O
dwg_decode_add_object	function
(	O
dwg	pointer
,	O
&	O
obj_dat	struct
,	O
hdl	array
,	O
last_offset	long
)	O
;	O
if	O
(	O
added	int
>	O
0	int
)	O
error	int
|=	O
added	int
;	O
}	O
if	O
(	O
hdl_dat	pointer
.	O
byte	char
==	O
oldpos	long
)	O
break	O
;	O
crc1	short
=	O
bit_calc_CRC	function
(	O
0xC0C1	int
,	O
&	O
(	O
hdl_dat	pointer
.	O
chain	pointer
[	O
startpos	long
]	O
)	O
,	O
hdl_dat	pointer
.	O
byte	char
-	O
startpos	long
)	O
;	O
crc2	short
=	O
bit_read_RS_LE	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
if	O
(	O
crc1	short
==	O
crc2	short
)	O
{	O
LOG_INSANE	O
(	O
"Handles section page CRC: %04X from %lx-%lx\n"	pointer
,	O
crc2	short
,	O
startpos	long
,	O
hdl_dat	pointer
.	O
byte	char
-	O
2	int
)	O
;	O
}	O
else	O
{	O
LOG_WARN	O
(	O
"Handles section page CRC mismatch: %04X vs calc. %04X "	pointer
"from %lx-%lx\n"	pointer
,	O
crc2	short
,	O
crc1	short
,	O
startpos	long
,	O
hdl_dat	pointer
.	O
byte	char
-	O
2	int
)	O
;	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
}	O
if	O
(	O
hdl_dat	pointer
.	O
byte	char
>=	O
endpos	long
)	O
break	O
;	O
}	O
while	O
(	O
section_size	short
>	O
2	int
)	O
;	O
if	O
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
;	O
if	O
(	O
obj_dat	struct
.	O
chain	pointer
)	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2007_section_summary	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
{	O
static	O
Bit_Chain	struct
old_dat	struct
,	O
obj_dat	struct
=	O
{	O
0	int
}	O
;	O
Bit_Chain	struct
*	O
str_dat	pointer
;	O
struct	O
Dwg_SummaryInfo	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
summaryinfo	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
int	O
error	int
;	O
BITCODE_RL	int
rcount1	int
=	O
0	int
,	O
rcount2	int
=	O
0	int
;	O
old_dat	struct
=	O
*	O
dat	pointer
;	O
error	int
=	O
read_data_section	function
(	O
&	O
obj_dat	struct
,	O
dat	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
,	O
SECTION_SUMMARYINFO	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
||	O
!	O
obj_dat	struct
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read SummaryInfo section"	pointer
)	O
;	O
if	O
(	O
obj_dat	struct
.	O
chain	pointer
)	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
summaryinfo_address	int
!=	O
(	O
BITCODE_RL	int
)	O
dat	pointer
->	O
byte	char
)	O
LOG_WARN	O
(	O
"summaryinfo_address mismatch: "	pointer
FORMAT_RL	O
" != %lu"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
summaryinfo_address	int
,	O
dat	pointer
->	O
byte	char
)	O
;	O
LOG_TRACE	O
(	O
"\nSummaryInfo\n-------------------\n"	pointer
)	O
str_dat	pointer
=	O
dat	pointer
=	O
&	O
obj_dat	struct
;	O
if	O
(	O
obj_dat	struct
.	O
chain	pointer
)	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
*	O
dat	pointer
=	O
old_dat	struct
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2007_section_preview	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
,	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
)	O
{	O
static	O
Bit_Chain	struct
sec_dat	pointer
=	O
{	O
0	int
}	O
;	O
int	O
error	int
;	O
BITCODE_RL	int
size	char
;	O
unsigned	O
char	O
*	O
sentinel	enum
;	O
error	int
=	O
read_data_section	function
(	O
&	O
sec_dat	pointer
,	O
dat	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
,	O
SECTION_PREVIEW	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read uncompressed %s section"	pointer
,	O
"Preview"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
!=	O
(	O
BITCODE_RL	int
)	O
dat	pointer
->	O
byte	char
)	O
LOG_WARN	O
(	O
"thumbnail_address mismatch: "	pointer
FORMAT_RL	O
" != %lu"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
,	O
dat	pointer
->	O
byte	char
)	O
;	O
LOG_TRACE	O
(	O
"\nPreview\n-------------------\n"	pointer
)	O
if	O
(	O
!	O
sec_dat	pointer
.	O
chain	pointer
||	O
sec_dat	pointer
.	O
size	char
<	O
16	int
)	O
{	O
LOG_WARN	O
(	O
"Empty thumbnail"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
sentinel	enum
=	O
dwg_sentinel	function
(	O
DWG_SENTINEL_THUMBNAIL_BEGIN	int
)	O
;	O
if	O
(	O
memcmp	function
(	O
sentinel	enum
,	O
sec_dat	pointer
.	O
chain	pointer
,	O
16	int
)	O
)	O
{	O
LOG_WARN	O
(	O
"thumbnail sentinel mismatch"	pointer
)	O
;	O
return	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
}	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
=	O
sec_dat	pointer
.	O
size	char
-	O
32	int
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
=	O
sec_dat	pointer
.	O
chain	pointer
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
byte	char
=	O
16	int
;	O
dwg_bmp	function
(	O
dwg	pointer
,	O
&	O
size	char
)	O
;	O
if	O
(	O
abs	function
(	O
(	O
int	O
)	O
(	O
(	O
long	O
)	O
size	char
-	O
(	O
long	O
)	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
)	O
>	O
200	int
)	O
LOG_WARN	O
(	O
"thumbnail.size mismatch: %lu != "	pointer
FORMAT_RL	O
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
,	O
size	char
)	O
;	O
dat	pointer
->	O
byte	char
+=	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
;	O
return	O
error	int
;	O
}	O
void	O
read_r2007_init	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
if	O
(	O
dwg	pointer
->	O
opts	int
)	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
}	O
int	O
read_r2007_meta_data	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
r2007_file_header	struct
file_header	pointer
;	O
r2007_page	struct
*	O
restrict	O
pages_map	pointer
,	O
*	O
restrict	O
page	pointer
;	O
r2007_section	struct
*	O
restrict	O
sections_map	pointer
=	O
NULL	O
;	O
int	O
error	int
;	O
read_r2007_init	function
(	O
dwg	pointer
)	O
;	O
error	int
=	O
read_file_header	function
(	O
dat	pointer
,	O
&	O
file_header	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
)	O
return	O
error	int
;	O
dat	pointer
->	O
byte	char
+=	O
0x28	int
;	O
dat	pointer
->	O
byte	char
+=	O
file_header	pointer
.	O
pages_map_offset	long
;	O
pages_map	pointer
=	O
read_pages_map	function
(	O
dat	pointer
,	O
file_header	pointer
.	O
pages_map_size_comp	long
,	O
file_header	pointer
.	O
pages_map_size_uncomp	long
,	O
file_header	pointer
.	O
pages_map_correction	long
)	O
;	O
if	O
(	O
!	O
pages_map	pointer
)	O
return	O
DWG_ERR_PAGENOTFOUND	int
;	O
page	pointer
=	O
get_page	function
(	O
pages_map	pointer
,	O
file_header	pointer
.	O
sections_map_id	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to find sections page map %d"	pointer
,	O
(	O
int	O
)	O
file_header	pointer
.	O
sections_map_id	long
)	O
;	O
error	int
|=	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
goto	O
error	int
;	O
}	O
dat	pointer
->	O
byte	char
=	O
page	pointer
->	O
offset	double
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
file_header	pointer
.	O
sections_map_size_comp	long
>	O
dat	pointer
->	O
byte	char
-	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"%s Invalid comp_data_size %lu > %lu bytes left"	pointer
,	O
__FUNCTION__	O
,	O
(	O
unsigned	O
long	O
)	O
file_header	pointer
.	O
sections_map_size_comp	long
,	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
)	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
goto	O
error	int
;	O
}	O
sections_map	pointer
=	O
read_sections_map	function
(	O
dat	pointer
,	O
file_header	pointer
.	O
sections_map_size_comp	long
,	O
file_header	pointer
.	O
sections_map_size_uncomp	long
,	O
file_header	pointer
.	O
sections_map_correction	long
)	O
;	O
if	O
(	O
!	O
sections_map	pointer
)	O
goto	O
error	int
;	O
error	int
=	O
read_2007_section_header	function
(	O
dat	pointer
,	O
hdl_dat	pointer
,	O
dwg	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
summaryinfo_address	int
)	O
error	int
|=	O
read_2007_section_summary	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
)	O
;	O
error	int
|=	O
read_2007_section_classes	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
)	O
;	O
error	int
|=	O
read_2007_section_handles	function
(	O
dat	pointer
,	O
hdl_dat	pointer
,	O
dwg	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
)	O
error	int
|=	O
read_2007_section_preview	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
sections_map	pointer
,	O
pages_map	pointer
)	O
;	O
error	int
:	O
pages_destroy	function
(	O
pages_map	pointer
)	O
;	O
if	O
(	O
sections_map	pointer
)	O
sections_destroy	function
(	O
sections_map	pointer
)	O
;	O
return	O
error	int
;	O
}	O
