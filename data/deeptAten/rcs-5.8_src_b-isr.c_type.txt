void	O
maybe_reset_sigchld	function
(	O
void	O
)	O
{	O
}	O
static	O
void	O
werr	function
(	O
char	O
const	O
*	O
s	pointer
)	O
{	O
ssize_t	long
len	char
;	O
if	O
(	O
!	O
(	O
len	char
=	O
strlen	function
(	O
s	pointer
)	O
)	O
)	O
return	O
;	O
if	O
(	O
len	char
!=	O
write	pointer
(	O
STDERR_FILENO	int
,	O
s	pointer
,	O
len	char
)	O
)	O
PROGRAM	O
(	O
exiterr	pointer
)	O
(	O
)	O
;	O
}	O
void	O
complain_signal	function
(	O
char	O
const	O
*	O
msg	pointer
,	O
int	O
signo	int
)	O
{	O
werr	function
(	O
msg	pointer
)	O
;	O
werr	function
(	O
": "	pointer
)	O
;	O
werr	function
(	O
strsignal	function
(	O
signo	int
)	O
)	O
;	O
werr	function
(	O
"\n"	pointer
)	O
;	O
}	O
struct	O
isr_scratch	struct
{	O
sig_atomic_t	int
volatile	O
held	int
,	O
level	int
;	O
siginfo_t	struct
bufinfo	struct
;	O
siginfo_t	struct
*	O
volatile	O
held_info	pointer
;	O
char	O
const	O
*	O
access_name	pointer
;	O
struct	O
{	O
bool	bool
regular	bool
;	O
bool	bool
memory_map	bool
;	O
}	O
catching	struct
;	O
bool	bool
*	O
be_quiet	pointer
;	O
}	O
;	O
void	O
access_page	function
(	O
struct	O
isr_scratch	struct
*	O
scratch	pointer
,	O
char	O
const	O
*	O
filename	pointer
,	O
char	O
const	O
*	O
p	pointer
)	O
{	O
char	O
volatile	O
t	char
;	O
ISR	O
(	O
access_name	pointer
)	O
=	O
filename	pointer
;	O
t	char
=	O
*	O
p	pointer
;	O
ISR	O
(	O
access_name	pointer
)	O
=	O
NULL	O
;	O
}	O
static	O
void	O
ignore	function
(	O
struct	O
isr_scratch	struct
*	O
scratch	pointer
)	O
{	O
++	O
ISR	O
(	O
level	int
)	O
;	O
}	O
static	O
void	O
catchsigaction	function
(	O
int	O
signo	int
,	O
siginfo_t	struct
*	O
info	pointer
,	O
RCS_UNUSED	O
void	O
*	O
uc	pointer
)	O
{	O
struct	O
isr_scratch	struct
*	O
scratch	pointer
=	O
ISR_SCRATCH	O
;	O
bool	bool
from_mmap	bool
=	O
MMAP_SIGNAL	int
&&	O
MMAP_SIGNAL	int
==	O
signo	int
;	O
if	O
(	O
ISR	O
(	O
level	int
)	O
)	O
{	O
ISR	O
(	O
held	int
)	O
=	O
signo	int
;	O
if	O
(	O
info	pointer
)	O
{	O
ISR	O
(	O
bufinfo	struct
)	O
=	O
*	O
info	pointer
;	O
ISR	O
(	O
held_info	pointer
)	O
=	O
&	O
ISR	O
(	O
bufinfo	struct
)	O
;	O
}	O
return	O
;	O
}	O
ignore	function
(	O
scratch	pointer
)	O
;	O
setrid	function
(	O
)	O
;	O
if	O
(	O
!	O
*	O
ISR	O
(	O
be_quiet	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
from_mmap	bool
&&	O
ISR	O
(	O
access_name	pointer
)	O
)	O
)	O
{	O
char	O
*	O
nRCS	pointer
=	O
"\nRCS"	pointer
;	O
if	O
(	O
from_mmap	bool
&&	O
info	pointer
&&	O
info	pointer
->	O
si_errno	int
)	O
{	O
errno	O
=	O
info	pointer
->	O
si_errno	int
;	O
perror	function
(	O
nRCS	pointer
++	O
)	O
;	O
}	O
if	O
(	O
info	pointer
)	O
psiginfo	function
(	O
info	pointer
,	O
nRCS	pointer
)	O
;	O
else	O
complain_signal	function
(	O
nRCS	pointer
,	O
signo	int
)	O
;	O
}	O
werr	function
(	O
"RCS: "	pointer
)	O
;	O
if	O
(	O
from_mmap	bool
)	O
{	O
if	O
(	O
ISR	O
(	O
access_name	pointer
)	O
)	O
{	O
werr	function
(	O
ISR	O
(	O
access_name	pointer
)	O
)	O
;	O
werr	function
(	O
": Permission denied.  "	pointer
)	O
;	O
}	O
else	O
werr	function
(	O
"Was a file changed by some other process?  "	pointer
)	O
;	O
}	O
werr	function
(	O
"Cleaning up.\n"	pointer
)	O
;	O
}	O
PROGRAM	O
(	O
exiterr	pointer
)	O
(	O
)	O
;	O
}	O
static	O
void	O
setup_catchsig	function
(	O
size_t	long
count	long
,	O
int	O
const	O
set	O
[	O
count	long
]	O
)	O
{	O
sigset_t	struct
blocked	struct
;	O
sigemptyset	function
(	O
&	O
blocked	struct
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
MUST	O
(	O
sigaddset	function
(	O
&	O
blocked	struct
,	O
set	O
[	O
i	int
]	O
)	O
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
struct	O
sigaction	struct
act	struct
;	O
int	O
sig	int
=	O
set	O
[	O
i	int
]	O
;	O
MUST	O
(	O
sigaction	struct
(	O
sig	int
,	O
NULL	O
,	O
&	O
act	struct
)	O
)	O
;	O
if	O
(	O
SIG_IGN	O
!=	O
act	struct
.	O
sa_handler	pointer
)	O
{	O
act	struct
.	O
sa_sigaction	pointer
=	O
catchsigaction	function
;	O
act	struct
.	O
sa_flags	int
|=	O
SA_SIGINFO	int
|	O
SA_ONSTACK	int
;	O
act	struct
.	O
sa_mask	struct
=	O
blocked	struct
;	O
if	O
(	O
PROB	O
(	O
sigaction	struct
(	O
sig	int
,	O
&	O
act	struct
,	O
NULL	O
)	O
)	O
)	O
{	O
fail	O
:	O
fatal_sys	function
(	O
"signal handling"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
struct	O
isr_scratch	struct
*	O
isr_init	function
(	O
bool	bool
*	O
be_quiet	pointer
)	O
{	O
struct	O
isr_scratch	struct
*	O
scratch	pointer
=	O
ZLLOC	O
(	O
1	int
,	O
struct	O
isr_scratch	struct
)	O
;	O
stack_t	struct
ss	struct
=	O
{	O
.	O
ss_sp	pointer
=	O
alloc	function
(	O
PLEXUS	O
,	O
"sigaltstack"	pointer
,	O
ISR_STACK_SIZE	O
)	O
,	O
.	O
ss_size	long
=	O
ISR_STACK_SIZE	O
,	O
.	O
ss_flags	int
=	O
0	int
}	O
;	O
if	O
(	O
PROB	O
(	O
sigaltstack	function
(	O
&	O
ss	struct
,	O
NULL	O
)	O
)	O
)	O
fatal_sys	function
(	O
"sigaltstack"	pointer
)	O
;	O
ISR	O
(	O
be_quiet	pointer
)	O
=	O
be_quiet	pointer
;	O
return	O
scratch	pointer
;	O
}	O
void	O
isr_do	function
(	O
struct	O
isr_scratch	struct
*	O
scratch	pointer
,	O
enum	O
isr_actions	enum
action	enum
)	O
{	O
switch	O
(	O
action	enum
)	O
{	O
case	O
ISR_CATCHINTS	int
:	O
{	O
int	O
const	O
regular	bool
[	O
]	O
=	O
{	O
SIGHUP	int
,	O
SIGINT	int
,	O
SIGQUIT	int
,	O
SIGPIPE	int
,	O
SIGTERM	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
,	O
}	O
;	O
if	O
(	O
!	O
ISR	O
(	O
catching	struct
.	O
regular	bool
)	O
)	O
{	O
ISR	O
(	O
catching	struct
.	O
regular	bool
)	O
=	O
true	int
;	O
setup_catchsig	function
(	O
COUNT	O
(	O
regular	bool
)	O
,	O
regular	bool
)	O
;	O
}	O
}	O
break	O
;	O
case	O
ISR_IGNOREINTS	int
:	O
ignore	function
(	O
scratch	pointer
)	O
;	O
break	O
;	O
case	O
ISR_RESTOREINTS	int
:	O
if	O
(	O
!	O
--	O
ISR	O
(	O
level	int
)	O
&&	O
ISR	O
(	O
held	int
)	O
)	O
catchsigaction	function
(	O
ISR	O
(	O
held	int
)	O
,	O
ISR	O
(	O
held_info	pointer
)	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ISR_CATCHMMAPINTS	int
:	O
{	O
int	O
const	O
mmapsigs	array
[	O
]	O
=	O
{	O
MMAP_SIGNAL	int
}	O
;	O
if	O
(	O
MMAP_SIGNAL	int
&&	O
!	O
ISR	O
(	O
catching	struct
.	O
memory_map	bool
)	O
)	O
{	O
ISR	O
(	O
catching	struct
.	O
memory_map	bool
)	O
=	O
true	int
;	O
setup_catchsig	function
(	O
COUNT	O
(	O
mmapsigs	array
)	O
,	O
mmapsigs	array
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
