struct	O
elf_info_failed	struct
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
bfd_boolean	int
failed	int
;	O
}	O
;	O
struct	O
elf_find_verdep_info	struct
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
unsigned	O
int	O
vers	int
;	O
bfd_boolean	int
failed	int
;	O
}	O
;	O
static	O
bfd_boolean	int
_bfd_elf_fix_symbol_flags	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
,	O
struct	O
elf_info_failed	struct
*	O
)	O
;	O
asection	struct
*	O
_bfd_elf_section_for_symbol	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
unsigned	O
long	O
r_symndx	long
,	O
bfd_boolean	int
discard	enum
)	O
{	O
if	O
(	O
r_symndx	long
>=	O
cookie	pointer
->	O
locsymcount	long
||	O
ELF_ST_BIND	O
(	O
cookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
.	O
st_info	array
)	O
!=	O
STB_LOCAL	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
cookie	pointer
->	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
cookie	pointer
->	O
extsymoff	long
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
discarded_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
)	O
return	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
else	O
return	O
NULL	O
;	O
}	O
else	O
{	O
asection	struct
*	O
isec	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
isym	pointer
=	O
&	O
cookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
;	O
isec	pointer
=	O
bfd_section_from_elf_index	function
(	O
cookie	pointer
->	O
abfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
isec	pointer
!=	O
NULL	O
&&	O
discard	enum
?	O
discarded_section	function
(	O
isec	pointer
)	O
:	O
1	int
)	O
return	O
isec	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
elf_link_hash_entry	struct
*	O
_bfd_elf_define_linkage_sym	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_new	int
;	O
bh	pointer
=	O
&	O
h	pointer
->	O
root	struct
;	O
}	O
else	O
bh	pointer
=	O
NULL	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
abfd	pointer
,	O
name	pointer
,	O
BSF_GLOBAL	O
,	O
sec	pointer
,	O
0	int
,	O
NULL	O
,	O
FALSE	int
,	O
bed	pointer
->	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
return	O
NULL	O
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
BFD_ASSERT	O
(	O
h	pointer
!=	O
NULL	O
)	O
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
non_elf	int
=	O
0	int
;	O
h	pointer
->	O
root	struct
.	O
linker_def	int
=	O
1	int
;	O
h	pointer
->	O
type	enum
=	O
STT_OBJECT	int
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_INTERNAL	int
)	O
h	pointer
->	O
other	int
=	O
(	O
h	pointer
->	O
other	int
&	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
)	O
|	O
STV_HIDDEN	int
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
return	O
h	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_create_got_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
flagword	int
flags	int
;	O
asection	struct
*	O
s	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
sgot	pointer
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
flags	int
=	O
bed	pointer
->	O
dynamic_sec_flags	int
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.got"	pointer
:	O
".rel.got"	pointer
)	O
,	O
(	O
bed	pointer
->	O
dynamic_sec_flags	int
|	O
SEC_READONLY	int
)	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
srelgot	pointer
=	O
s	pointer
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".got"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
sgot	pointer
=	O
s	pointer
;	O
if	O
(	O
bed	pointer
->	O
want_got_plt	int
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".got.plt"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
sgotplt	pointer
=	O
s	pointer
;	O
}	O
s	pointer
->	O
size	long
+=	O
bed	pointer
->	O
got_header_size	long
;	O
if	O
(	O
bed	pointer
->	O
want_got_sym	int
)	O
{	O
h	pointer
=	O
_bfd_elf_define_linkage_sym	function
(	O
abfd	pointer
,	O
info	pointer
,	O
s	pointer
,	O
"_GLOBAL_OFFSET_TABLE_"	pointer
)	O
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
hgot	pointer
=	O
h	pointer
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_link_create_dynstrtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
;	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
hash_table	pointer
->	O
dynobj	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
BFD_PLUGIN	int
)	O
)	O
!=	O
0	int
)	O
{	O
bfd	struct
*	O
ibfd	pointer
;	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
(	O
ibfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
BFD_LINKER_CREATED	int
|	O
BFD_PLUGIN	int
)	O
)	O
==	O
0	int
&&	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
elf_object_id	O
(	O
ibfd	pointer
)	O
==	O
elf_hash_table_id	O
(	O
hash_table	pointer
)	O
&&	O
!	O
(	O
(	O
s	pointer
=	O
ibfd	pointer
->	O
sections	pointer
)	O
!=	O
NULL	O
&&	O
s	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
)	O
{	O
abfd	pointer
=	O
ibfd	pointer
;	O
break	O
;	O
}	O
}	O
hash_table	pointer
->	O
dynobj	pointer
=	O
abfd	pointer
;	O
}	O
if	O
(	O
hash_table	pointer
->	O
dynstr	pointer
==	O
NULL	O
)	O
{	O
hash_table	pointer
->	O
dynstr	pointer
=	O
_bfd_elf_strtab_init	function
(	O
)	O
;	O
if	O
(	O
hash_table	pointer
->	O
dynstr	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_link_create_dynamic_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
flagword	int
flags	int
;	O
asection	struct
*	O
s	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
_bfd_elf_link_create_dynstrtab	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
abfd	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynobj	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
flags	int
=	O
bed	pointer
->	O
dynamic_sec_flags	int
;	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
!	O
info	pointer
->	O
nointerp	int
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".interp"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".gnu.version_d"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".gnu.version"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
1	int
)	O
)	O
return	O
FALSE	int
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".gnu.version_r"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".dynsym"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynsym	pointer
=	O
s	pointer
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".dynstr"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".dynamic"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
_bfd_elf_define_linkage_sym	function
(	O
abfd	pointer
,	O
info	pointer
,	O
s	pointer
,	O
"_DYNAMIC"	pointer
)	O
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
hdynamic	pointer
=	O
h	pointer
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
emit_hash	int
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".hash"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_hash_entry	char
;	O
}	O
if	O
(	O
info	pointer
->	O
emit_gnu_hash	int
&&	O
bed	pointer
->	O
record_xhash_symbol	pointer
==	O
NULL	O
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".gnu.hash"	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
64	int
)	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
0	int
;	O
else	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
4	int
;	O
}	O
if	O
(	O
bed	pointer
->	O
elf_backend_create_dynamic_sections	pointer
==	O
NULL	O
||	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_create_dynamic_sections	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_create_dynamic_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
flagword	int
flags	int
,	O
pltflags	int
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
asection	struct
*	O
s	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
flags	int
=	O
bed	pointer
->	O
dynamic_sec_flags	int
;	O
pltflags	int
=	O
flags	int
;	O
if	O
(	O
bed	pointer
->	O
plt_not_loaded	int
)	O
pltflags	int
&=	O
~	O
(	O
SEC_CODE	int
|	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
;	O
else	O
pltflags	int
|=	O
SEC_ALLOC	int
|	O
SEC_CODE	int
|	O
SEC_LOAD	int
;	O
if	O
(	O
bed	pointer
->	O
plt_readonly	int
)	O
pltflags	int
|=	O
SEC_READONLY	int
;	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".plt"	pointer
,	O
pltflags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
plt_alignment	int
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
splt	pointer
=	O
s	pointer
;	O
if	O
(	O
bed	pointer
->	O
want_plt_sym	int
)	O
{	O
h	pointer
=	O
_bfd_elf_define_linkage_sym	function
(	O
abfd	pointer
,	O
info	pointer
,	O
s	pointer
,	O
"_PROCEDURE_LINKAGE_TABLE_"	pointer
)	O
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
hplt	pointer
=	O
h	pointer
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.plt"	pointer
:	O
".rel.plt"	pointer
)	O
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
srelplt	pointer
=	O
s	pointer
;	O
if	O
(	O
!	O
_bfd_elf_create_got_section	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
want_dynbss	int
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".dynbss"	pointer
,	O
SEC_ALLOC	int
|	O
SEC_LINKER_CREATED	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
sdynbss	pointer
=	O
s	pointer
;	O
if	O
(	O
bed	pointer
->	O
want_dynrelro	int
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".data.rel.ro"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
sdynrelro	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.bss"	pointer
:	O
".rel.bss"	pointer
)	O
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
srelbss	pointer
=	O
s	pointer
;	O
if	O
(	O
bed	pointer
->	O
want_dynrelro	int
)	O
{	O
s	pointer
=	O
(	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.data.rel.ro"	pointer
:	O
".rel.data.rel.ro"	pointer
)	O
,	O
flags	int
|	O
SEC_READONLY	int
)	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
sreldynrelro	pointer
=	O
s	pointer
;	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_link_record_dynamic_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
{	O
struct	O
elf_strtab_hash	O
*	O
dynstr	pointer
;	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
size_t	long
indx	long
;	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_INTERNAL	int
:	O
case	O
STV_HIDDEN	int
:	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefined	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
)	O
{	O
h	pointer
->	O
forced_local	int
=	O
1	int
;	O
if	O
(	O
!	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
is_relocatable_executable	int
)	O
return	O
TRUE	int
;	O
}	O
default	O
:	O
break	O
;	O
}	O
h	pointer
->	O
dynindx	long
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynsymcount	int
;	O
++	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynsymcount	int
;	O
dynstr	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
;	O
if	O
(	O
dynstr	pointer
==	O
NULL	O
)	O
{	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
=	O
dynstr	pointer
=	O
_bfd_elf_strtab_init	function
(	O
)	O
;	O
if	O
(	O
dynstr	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
p	pointer
=	O
strchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
*	O
p	pointer
=	O
0	int
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
dynstr	pointer
,	O
name	pointer
,	O
p	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
*	O
p	pointer
=	O
ELF_VER_CHR	char
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
h	pointer
->	O
dynstr_index	long
=	O
indx	long
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
bfd_elf_link_mark_dynamic_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
struct	O
bfd_elf_dynamic_list	struct
*	O
d	double
=	O
info	pointer
->	O
dynamic_list	pointer
;	O
if	O
(	O
h	pointer
->	O
dynamic	int
||	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
return	O
;	O
if	O
(	O
(	O
info	pointer
->	O
dynamic_data	int
&&	O
(	O
h	pointer
->	O
type	enum
==	O
STT_OBJECT	int
||	O
h	pointer
->	O
type	enum
==	O
STT_COMMON	int
||	O
(	O
sym	pointer
!=	O
NULL	O
&&	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_OBJECT	int
||	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_COMMON	int
)	O
)	O
)	O
)	O
||	O
(	O
d	double
!=	O
NULL	O
&&	O
h	pointer
->	O
non_elf	int
&&	O
(	O
*	O
d	double
->	O
match	pointer
)	O
(	O
&	O
d	double
->	O
head	pointer
,	O
NULL	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
)	O
)	O
{	O
h	pointer
->	O
dynamic	int
=	O
1	int
;	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_dynamic	int
=	O
1	int
;	O
}	O
}	O
bfd_boolean	int
bfd_elf_record_link_assignment	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd_boolean	int
provide	int
,	O
bfd_boolean	int
hidden	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
*	O
hv	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
TRUE	int
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
htab	struct
,	O
name	pointer
,	O
!	O
provide	int
,	O
TRUE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
provide	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
versioned	int
==	O
unknown	int
)	O
{	O
char	O
*	O
version	short
=	O
strrchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
version	short
)	O
{	O
if	O
(	O
version	short
>	O
name	pointer
&&	O
version	short
[	O
-	O
1	int
]	O
!=	O
ELF_VER_CHR	char
)	O
h	pointer
->	O
versioned	int
=	O
versioned_hidden	int
;	O
else	O
h	pointer
->	O
versioned	int
=	O
versioned	int
;	O
}	O
}	O
if	O
(	O
h	pointer
->	O
non_elf	int
)	O
{	O
bfd_elf_link_mark_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
h	pointer
->	O
non_elf	int
=	O
0	int
;	O
}	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
case	O
bfd_link_hash_common	int
:	O
break	O
;	O
case	O
bfd_link_hash_undefweak	int
:	O
case	O
bfd_link_hash_undefined	int
:	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_new	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
next	pointer
!=	O
NULL	O
||	O
htab	struct
->	O
root	struct
.	O
undefs_tail	pointer
==	O
&	O
h	pointer
->	O
root	struct
)	O
bfd_link_repair_undef_list	function
(	O
&	O
htab	struct
->	O
root	struct
)	O
;	O
break	O
;	O
case	O
bfd_link_hash_new	int
:	O
break	O
;	O
case	O
bfd_link_hash_indirect	int
:	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
hv	pointer
=	O
h	pointer
;	O
while	O
(	O
hv	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
hv	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
hv	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hv	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
hv	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_indirect	int
;	O
hv	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
hv	pointer
)	O
;	O
break	O
;	O
default	O
:	O
BFD_FAIL	O
(	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
provide	int
&&	O
h	pointer
->	O
def_dynamic	int
&&	O
!	O
h	pointer
->	O
def_regular	int
)	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
if	O
(	O
h	pointer
->	O
def_dynamic	int
&&	O
!	O
h	pointer
->	O
def_regular	int
)	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
=	O
NULL	O
;	O
h	pointer
->	O
mark	int
=	O
1	int
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
if	O
(	O
hidden	int
)	O
{	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_INTERNAL	int
)	O
h	pointer
->	O
other	int
=	O
(	O
h	pointer
->	O
other	int
&	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
)	O
|	O
STV_HIDDEN	int
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_HIDDEN	int
||	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_INTERNAL	int
)	O
)	O
h	pointer
->	O
forced_local	int
=	O
1	int
;	O
if	O
(	O
(	O
h	pointer
->	O
def_dynamic	int
||	O
h	pointer
->	O
ref_dynamic	int
||	O
bfd_link_dll	O
(	O
info	pointer
)	O
||	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
is_relocatable_executable	int
)	O
&&	O
!	O
h	pointer
->	O
forced_local	int
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
is_weakalias	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
def	struct
=	O
weakdef	function
(	O
h	pointer
)	O
;	O
if	O
(	O
def	struct
->	O
dynindx	long
==	O
-	O
1	int
&&	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
def	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
int	O
bfd_elf_link_record_local_dynamic_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
long	O
input_indx	long
)	O
{	O
bfd_size_type	long
amt	long
;	O
struct	O
elf_link_local_dynamic_entry	struct
*	O
entry	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
eht	pointer
;	O
struct	O
elf_strtab_hash	O
*	O
dynstr	pointer
;	O
size_t	long
dynstr_index	long
;	O
char	O
*	O
name	pointer
;	O
Elf_External_Sym_Shndx	struct
eshndx	struct
;	O
char	O
esym	array
[	O
sizeof	O
(	O
Elf64_External_Sym	struct
)	O
]	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
0	int
;	O
for	O
(	O
entry	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynlocal	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
if	O
(	O
entry	pointer
->	O
input_bfd	pointer
==	O
input_bfd	pointer
&&	O
entry	pointer
->	O
input_indx	long
==	O
input_indx	long
)	O
return	O
1	int
;	O
amt	long
=	O
sizeof	O
(	O
*	O
entry	pointer
)	O
;	O
entry	pointer
=	O
(	O
struct	O
elf_link_local_dynamic_entry	struct
*	O
)	O
bfd_alloc	function
(	O
input_bfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
bfd_elf_get_elf_syms	function
(	O
input_bfd	pointer
,	O
&	O
elf_tdata	O
(	O
input_bfd	pointer
)	O
->	O
symtab_hdr	struct
,	O
1	int
,	O
input_indx	long
,	O
&	O
entry	pointer
->	O
isym	pointer
,	O
esym	array
,	O
&	O
eshndx	struct
)	O
)	O
{	O
bfd_release	function
(	O
input_bfd	pointer
,	O
entry	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
entry	pointer
->	O
isym	pointer
.	O
st_shndx	array
!=	O
SHN_UNDEF	int
&&	O
entry	pointer
->	O
isym	pointer
.	O
st_shndx	array
<	O
SHN_LORESERVE	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
s	pointer
=	O
bfd_section_from_elf_index	function
(	O
input_bfd	pointer
,	O
entry	pointer
->	O
isym	pointer
.	O
st_shndx	array
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
bfd_is_abs_section	function
(	O
s	pointer
->	O
output_section	pointer
)	O
)	O
{	O
bfd_release	function
(	O
input_bfd	pointer
,	O
entry	pointer
)	O
;	O
return	O
2	int
;	O
}	O
}	O
name	pointer
=	O
(	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
elf_tdata	O
(	O
input_bfd	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_link	array
,	O
entry	pointer
->	O
isym	pointer
.	O
st_name	array
)	O
)	O
;	O
dynstr	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
;	O
if	O
(	O
dynstr	pointer
==	O
NULL	O
)	O
{	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
=	O
dynstr	pointer
=	O
_bfd_elf_strtab_init	function
(	O
)	O
;	O
if	O
(	O
dynstr	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
}	O
dynstr_index	long
=	O
_bfd_elf_strtab_add	function
(	O
dynstr	pointer
,	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
dynstr_index	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
0	int
;	O
entry	pointer
->	O
isym	pointer
.	O
st_name	array
=	O
dynstr_index	long
;	O
eht	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
entry	pointer
->	O
next	pointer
=	O
eht	pointer
->	O
dynlocal	pointer
;	O
eht	pointer
->	O
dynlocal	pointer
=	O
entry	pointer
;	O
entry	pointer
->	O
input_bfd	pointer
=	O
input_bfd	pointer
;	O
entry	pointer
->	O
input_indx	long
=	O
input_indx	long
;	O
eht	pointer
->	O
dynsymcount	int
++	O
;	O
entry	pointer
->	O
isym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
ELF_ST_TYPE	O
(	O
entry	pointer
->	O
isym	pointer
.	O
st_info	array
)	O
)	O
;	O
return	O
1	int
;	O
}	O
long	O
_bfd_elf_link_lookup_local_dynindx	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
long	O
input_indx	long
)	O
{	O
struct	O
elf_link_local_dynamic_entry	struct
*	O
e	pointer
;	O
for	O
(	O
e	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynlocal	pointer
;	O
e	pointer
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
)	O
if	O
(	O
e	pointer
->	O
input_bfd	pointer
==	O
input_bfd	pointer
&&	O
e	pointer
->	O
input_indx	long
==	O
input_indx	long
)	O
return	O
e	pointer
->	O
dynindx	long
;	O
return	O
-	O
1	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_renumber_hash_table_dynsyms	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
size_t	long
*	O
count	int
=	O
(	O
size_t	long
*	O
)	O
data	pointer
;	O
if	O
(	O
h	pointer
->	O
forced_local	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
h	pointer
->	O
dynindx	long
=	O
++	O
(	O
*	O
count	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_renumber_local_hash_table_dynsyms	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
size_t	long
*	O
count	int
=	O
(	O
size_t	long
*	O
)	O
data	pointer
;	O
if	O
(	O
!	O
h	pointer
->	O
forced_local	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
h	pointer
->	O
dynindx	long
=	O
++	O
(	O
*	O
count	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_omit_section_dynsym_default	function
(	O
bfd	struct
*	O
output_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
p	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
asection	struct
*	O
ip	pointer
;	O
switch	O
(	O
elf_section_data	O
(	O
p	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
)	O
{	O
case	O
SHT_PROGBITS	int
:	O
case	O
SHT_NOBITS	int
:	O
case	O
SHT_NULL	int
:	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
text_index_section	pointer
!=	O
NULL	O
)	O
return	O
p	pointer
!=	O
htab	struct
->	O
text_index_section	pointer
&&	O
p	pointer
!=	O
htab	struct
->	O
data_index_section	pointer
;	O
return	O
(	O
htab	struct
->	O
dynobj	pointer
!=	O
NULL	O
&&	O
(	O
ip	pointer
=	O
bfd_get_linker_section	function
(	O
htab	struct
->	O
dynobj	pointer
,	O
p	pointer
->	O
name	pointer
)	O
)	O
!=	O
NULL	O
&&	O
ip	pointer
->	O
output_section	pointer
==	O
p	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
}	O
bfd_boolean	int
_bfd_elf_omit_section_dynsym_all	function
(	O
bfd	struct
*	O
output_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
p	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
long	O
_bfd_elf_link_renumber_dynsyms	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
unsigned	O
long	O
*	O
section_sym_count	pointer
)	O
{	O
unsigned	O
long	O
dynsymcount	int
=	O
0	int
;	O
bfd_boolean	int
do_sec	int
=	O
section_sym_count	pointer
!=	O
NULL	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
is_relocatable_executable	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
asection	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
output_bfd	pointer
->	O
sections	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
p	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
(	O
p	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_relocs	int
&&	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_omit_section_dynsym	pointer
)	O
(	O
output_bfd	pointer
,	O
info	pointer
,	O
p	pointer
)	O
)	O
{	O
++	O
dynsymcount	int
;	O
if	O
(	O
do_sec	int
)	O
elf_section_data	O
(	O
p	pointer
)	O
->	O
dynindx	long
=	O
dynsymcount	int
;	O
}	O
else	O
if	O
(	O
do_sec	int
)	O
elf_section_data	O
(	O
p	pointer
)	O
->	O
dynindx	long
=	O
0	int
;	O
}	O
if	O
(	O
do_sec	int
)	O
*	O
section_sym_count	pointer
=	O
dynsymcount	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_link_renumber_local_hash_table_dynsyms	function
,	O
&	O
dynsymcount	int
)	O
;	O
if	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynlocal	pointer
)	O
{	O
struct	O
elf_link_local_dynamic_entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynlocal	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
p	pointer
->	O
dynindx	long
=	O
++	O
dynsymcount	int
;	O
}	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
local_dynsymcount	long
=	O
dynsymcount	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_link_renumber_hash_table_dynsyms	function
,	O
&	O
dynsymcount	int
)	O
;	O
dynsymcount	int
++	O
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynsymcount	int
=	O
dynsymcount	int
;	O
return	O
dynsymcount	int
;	O
}	O
static	O
void	O
elf_merge_st_other	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
Elf_Internal_Sym	struct
*	O
isym	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_boolean	int
definition	int
,	O
bfd_boolean	int
dynamic	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_merge_symbol_attribute	pointer
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_merge_symbol_attribute	pointer
)	O
(	O
h	pointer
,	O
isym	pointer
,	O
definition	int
,	O
dynamic	int
)	O
;	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
unsigned	O
symvis	int
=	O
ELF_ST_VISIBILITY	O
(	O
isym	pointer
->	O
st_other	array
)	O
;	O
unsigned	O
hvis	int
=	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
;	O
if	O
(	O
symvis	int
-	O
1	int
<	O
hvis	int
-	O
1	int
)	O
h	pointer
->	O
other	int
=	O
symvis	int
|	O
(	O
h	pointer
->	O
other	int
&	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
definition	int
&&	O
ELF_ST_VISIBILITY	O
(	O
isym	pointer
->	O
st_other	array
)	O
!=	O
STV_DEFAULT	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
h	pointer
->	O
protected_def	int
=	O
1	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_merge_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
asection	struct
*	O
*	O
psec	pointer
,	O
bfd_vma	long
*	O
pvalue	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hash	pointer
,	O
bfd	struct
*	O
*	O
poldbfd	pointer
,	O
bfd_boolean	int
*	O
pold_weak	pointer
,	O
unsigned	O
int	O
*	O
pold_alignment	pointer
,	O
bfd_boolean	int
*	O
skip	pointer
,	O
bfd_boolean	int
*	O
override	pointer
,	O
bfd_boolean	int
*	O
type_change_ok	int
,	O
bfd_boolean	int
*	O
size_change_ok	pointer
,	O
bfd_boolean	int
*	O
matched	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
,	O
*	O
oldsec	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
hi	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
flip	pointer
;	O
int	O
bind	int
;	O
bfd	struct
*	O
oldbfd	pointer
;	O
bfd_boolean	int
newdyn	int
,	O
olddyn	int
,	O
olddef	int
,	O
newdef	int
,	O
newdyncommon	int
,	O
olddyncommon	int
;	O
bfd_boolean	int
newweak	int
,	O
oldweak	int
,	O
newfunc	pointer
,	O
oldfunc	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
char	O
*	O
new_version	pointer
;	O
bfd_boolean	int
default_sym	int
=	O
*	O
matched	pointer
;	O
*	O
skip	pointer
=	O
FALSE	int
;	O
*	O
override	pointer
=	O
FALSE	int
;	O
sec	pointer
=	O
*	O
psec	pointer
;	O
bind	int
=	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
;	O
if	O
(	O
!	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
)	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
TRUE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
else	O
h	pointer
=	O
(	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bfd_wrapped_link_hash_lookup	function
(	O
abfd	pointer
,	O
info	pointer
,	O
name	pointer
,	O
TRUE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
*	O
sym_hash	pointer
=	O
h	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
versioned	int
!=	O
unversioned	int
)	O
{	O
new_version	pointer
=	O
strrchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
new_version	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
versioned	int
==	O
unknown	int
)	O
{	O
if	O
(	O
new_version	pointer
>	O
name	pointer
&&	O
new_version	pointer
[	O
-	O
1	int
]	O
!=	O
ELF_VER_CHR	char
)	O
h	pointer
->	O
versioned	int
=	O
versioned_hidden	int
;	O
else	O
h	pointer
->	O
versioned	int
=	O
versioned	int
;	O
}	O
new_version	pointer
+=	O
1	int
;	O
if	O
(	O
new_version	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
new_version	pointer
=	O
NULL	O
;	O
}	O
else	O
h	pointer
->	O
versioned	int
=	O
unversioned	int
;	O
}	O
else	O
new_version	pointer
=	O
NULL	O
;	O
hi	pointer
=	O
h	pointer
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
!	O
*	O
matched	pointer
)	O
{	O
if	O
(	O
hi	pointer
==	O
h	pointer
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
)	O
*	O
matched	pointer
=	O
TRUE	int
;	O
else	O
{	O
bfd_boolean	int
old_hidden	int
=	O
h	pointer
->	O
versioned	int
==	O
versioned_hidden	int
;	O
bfd_boolean	int
new_hidden	int
=	O
hi	pointer
->	O
versioned	int
==	O
versioned_hidden	int
;	O
if	O
(	O
!	O
old_hidden	int
&&	O
!	O
new_hidden	int
)	O
*	O
matched	pointer
=	O
TRUE	int
;	O
else	O
{	O
char	O
*	O
old_version	pointer
;	O
if	O
(	O
h	pointer
->	O
versioned	int
>=	O
versioned	int
)	O
old_version	pointer
=	O
strrchr	function
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
ELF_VER_CHR	char
)	O
+	O
1	int
;	O
else	O
old_version	pointer
=	O
NULL	O
;	O
*	O
matched	pointer
=	O
(	O
old_version	pointer
==	O
new_version	pointer
||	O
(	O
old_version	pointer
!=	O
NULL	O
&&	O
new_version	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
old_version	pointer
,	O
new_version	pointer
)	O
==	O
0	int
)	O
)	O
;	O
}	O
}	O
}	O
oldbfd	pointer
=	O
NULL	O
;	O
oldsec	pointer
=	O
NULL	O
;	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
default	O
:	O
break	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
case	O
bfd_link_hash_undefweak	int
:	O
oldbfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
;	O
break	O
;	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
oldbfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
oldsec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
break	O
;	O
case	O
bfd_link_hash_common	int
:	O
oldbfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
owner	pointer
;	O
oldsec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
;	O
if	O
(	O
pold_alignment	pointer
)	O
*	O
pold_alignment	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
;	O
break	O
;	O
}	O
if	O
(	O
poldbfd	pointer
&&	O
*	O
poldbfd	pointer
==	O
NULL	O
)	O
*	O
poldbfd	pointer
=	O
oldbfd	pointer
;	O
newweak	int
=	O
bind	int
==	O
STB_WEAK	int
;	O
oldweak	int
=	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
;	O
if	O
(	O
pold_weak	pointer
)	O
*	O
pold_weak	pointer
=	O
oldweak	int
;	O
bfd_elf_link_mark_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
,	O
sym	pointer
)	O
;	O
newdyn	int
=	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
;	O
if	O
(	O
newdyn	int
)	O
{	O
if	O
(	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
)	O
{	O
if	O
(	O
bind	int
!=	O
STB_WEAK	int
)	O
{	O
h	pointer
->	O
ref_dynamic_nonweak	int
=	O
1	int
;	O
hi	pointer
->	O
ref_dynamic_nonweak	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
matched	pointer
)	O
h	pointer
->	O
dynamic_def	int
=	O
1	int
;	O
hi	pointer
->	O
dynamic_def	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
)	O
{	O
h	pointer
->	O
non_elf	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
abfd	pointer
==	O
oldbfd	pointer
&&	O
(	O
newweak	int
||	O
oldweak	int
)	O
&&	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
||	O
!	O
h	pointer
->	O
def_regular	int
)	O
)	O
return	O
TRUE	int
;	O
olddyn	int
=	O
FALSE	int
;	O
if	O
(	O
oldbfd	pointer
!=	O
NULL	O
)	O
olddyn	int
=	O
(	O
oldbfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
;	O
else	O
if	O
(	O
oldsec	pointer
!=	O
NULL	O
)	O
{	O
olddyn	int
=	O
(	O
oldsec	pointer
->	O
symbol	pointer
->	O
flags	int
&	O
BSF_DYNAMIC	O
)	O
!=	O
0	int
;	O
}	O
if	O
(	O
oldbfd	pointer
!=	O
NULL	O
&&	O
(	O
oldbfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
&&	O
newdyn	int
!=	O
olddyn	int
)	O
{	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_dynamic	int
=	O
TRUE	int
;	O
hi	pointer
->	O
root	struct
.	O
non_ir_ref_dynamic	int
=	O
TRUE	int
;	O
}	O
newdef	int
=	O
!	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
&&	O
!	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
;	O
olddef	int
=	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefined	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_common	int
)	O
;	O
newfunc	pointer
=	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
STT_NOTYPE	int
&&	O
bed	pointer
->	O
is_function_type	pointer
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
)	O
;	O
oldfunc	int
=	O
(	O
h	pointer
->	O
type	enum
!=	O
STT_NOTYPE	int
&&	O
bed	pointer
->	O
is_function_type	pointer
(	O
h	pointer
->	O
type	enum
)	O
)	O
;	O
if	O
(	O
!	O
(	O
newfunc	pointer
&&	O
oldfunc	int
)	O
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
h	pointer
->	O
type	enum
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
STT_NOTYPE	int
&&	O
h	pointer
->	O
type	enum
!=	O
STT_NOTYPE	int
&&	O
(	O
newdef	int
||	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
)	O
&&	O
(	O
olddef	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
)	O
{	O
if	O
(	O
newdyn	int
&&	O
!	O
olddyn	int
)	O
{	O
*	O
skip	pointer
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
hi	pointer
!=	O
h	pointer
&&	O
!	O
newdyn	int
&&	O
olddyn	int
)	O
{	O
h	pointer
=	O
hi	pointer
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
h	pointer
->	O
forced_local	int
=	O
0	int
;	O
h	pointer
->	O
ref_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
dynamic_def	int
=	O
0	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
next	pointer
||	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
==	O
&	O
h	pointer
->	O
root	struct
)	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
}	O
else	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_new	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
NULL	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
oldbfd	pointer
!=	O
NULL	O
&&	O
(	O
oldbfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
h	pointer
->	O
type	enum
&&	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_TLS	int
||	O
h	pointer
->	O
type	enum
==	O
STT_TLS	int
)	O
)	O
{	O
bfd	struct
*	O
ntbfd	pointer
,	O
*	O
tbfd	pointer
;	O
bfd_boolean	int
ntdef	int
,	O
tdef	int
;	O
asection	struct
*	O
ntsec	pointer
,	O
*	O
tsec	pointer
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_TLS	int
)	O
{	O
ntbfd	pointer
=	O
abfd	pointer
;	O
ntsec	pointer
=	O
sec	pointer
;	O
ntdef	int
=	O
newdef	int
;	O
tbfd	pointer
=	O
oldbfd	pointer
;	O
tsec	pointer
=	O
oldsec	pointer
;	O
tdef	int
=	O
olddef	int
;	O
}	O
else	O
{	O
ntbfd	pointer
=	O
oldbfd	pointer
;	O
ntsec	pointer
=	O
oldsec	pointer
;	O
ntdef	int
=	O
olddef	int
;	O
tbfd	pointer
=	O
abfd	pointer
;	O
tsec	pointer
=	O
sec	pointer
;	O
tdef	int
=	O
newdef	int
;	O
}	O
if	O
(	O
tdef	int
&&	O
ntdef	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%s: TLS definition in %pB section %pA "	pointer
"mismatches non-TLS definition in %pB section %pA"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
tbfd	pointer
,	O
tsec	pointer
,	O
ntbfd	pointer
,	O
ntsec	pointer
)	O
;	O
else	O
if	O
(	O
!	O
tdef	int
&&	O
!	O
ntdef	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%s: TLS reference in %pB "	pointer
"mismatches non-TLS reference in %pB"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
tbfd	pointer
,	O
ntbfd	pointer
)	O
;	O
else	O
if	O
(	O
tdef	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%s: TLS definition in %pB section %pA "	pointer
"mismatches non-TLS reference in %pB"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
tbfd	pointer
,	O
tsec	pointer
,	O
ntbfd	pointer
)	O
;	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"%s: TLS reference in %pB "	pointer
"mismatches non-TLS definition in %pB section %pA"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
tbfd	pointer
,	O
ntbfd	pointer
,	O
ntsec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
newdyn	int
&&	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_DEFAULT	int
&&	O
!	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
)	O
{	O
*	O
skip	pointer
=	O
TRUE	int
;	O
h	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
hi	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_PROTECTED	int
)	O
return	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
!	O
newdyn	int
&&	O
ELF_ST_VISIBILITY	O
(	O
sym	pointer
->	O
st_other	array
)	O
!=	O
STV_DEFAULT	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
{	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
{	O
if	O
(	O
h	pointer
->	O
ref_regular	int
)	O
{	O
hi	pointer
->	O
root	struct
.	O
type	enum
=	O
h	pointer
->	O
root	struct
.	O
type	enum
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_indirect	int
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
info	pointer
,	O
hi	pointer
,	O
h	pointer
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
hi	pointer
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
sym	pointer
->	O
st_other	array
)	O
!=	O
STV_PROTECTED	int
)	O
{	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
h	pointer
->	O
forced_local	int
=	O
0	int
;	O
h	pointer
->	O
ref_dynamic	int
=	O
0	int
;	O
}	O
else	O
h	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
size	long
=	O
0	int
;	O
h	pointer
->	O
type	enum
=	O
0	int
;	O
h	pointer
=	O
hi	pointer
;	O
}	O
else	O
h	pointer
=	O
hi	pointer
;	O
}	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
next	pointer
||	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
==	O
&	O
h	pointer
->	O
root	struct
)	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
}	O
else	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_new	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
sym	pointer
->	O
st_other	array
)	O
!=	O
STV_PROTECTED	int
)	O
{	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
h	pointer
->	O
forced_local	int
=	O
0	int
;	O
h	pointer
->	O
ref_dynamic	int
=	O
0	int
;	O
}	O
else	O
h	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
size	long
=	O
0	int
;	O
h	pointer
->	O
type	enum
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
newdef	int
&&	O
!	O
newdyn	int
&&	O
(	O
olddyn	int
||	O
h	pointer
->	O
root	struct
.	O
ldscript_def	int
)	O
)	O
newweak	int
=	O
FALSE	int
;	O
if	O
(	O
olddef	int
&&	O
newdyn	int
)	O
oldweak	int
=	O
FALSE	int
;	O
if	O
(	O
newfunc	pointer
&&	O
oldfunc	int
)	O
*	O
type_change_ok	int
=	O
TRUE	int
;	O
if	O
(	O
oldweak	int
||	O
newweak	int
||	O
(	O
newdef	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
)	O
*	O
type_change_ok	int
=	O
TRUE	int
;	O
if	O
(	O
*	O
type_change_ok	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
*	O
size_change_ok	pointer
=	O
TRUE	int
;	O
if	O
(	O
newdyn	int
&&	O
newdef	int
&&	O
!	O
newweak	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
&&	O
sym	pointer
->	O
st_size	long
>	O
0	int
&&	O
!	O
newfunc	pointer
)	O
newdyncommon	int
=	O
TRUE	int
;	O
else	O
newdyncommon	int
=	O
FALSE	int
;	O
if	O
(	O
olddyn	int
&&	O
olddef	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
def_dynamic	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
&&	O
h	pointer
->	O
size	long
>	O
0	int
&&	O
!	O
oldfunc	int
)	O
olddyncommon	int
=	O
TRUE	int
;	O
else	O
olddyncommon	int
=	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
merge_symbol	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
bed	pointer
->	O
merge_symbol	pointer
(	O
h	pointer
,	O
sym	pointer
,	O
psec	pointer
,	O
newdef	int
,	O
olddef	int
,	O
oldbfd	pointer
,	O
oldsec	pointer
)	O
)	O
return	O
FALSE	int
;	O
sec	pointer
=	O
*	O
psec	pointer
;	O
}	O
if	O
(	O
olddef	int
&&	O
!	O
olddyn	int
&&	O
!	O
oldweak	int
&&	O
newdef	int
&&	O
!	O
newdyn	int
&&	O
!	O
newweak	int
&&	O
!	O
default_sym	int
&&	O
h	pointer
->	O
def_regular	int
&&	O
!	O
(	O
oldbfd	pointer
!=	O
NULL	O
&&	O
(	O
oldbfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
)	O
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_definition	pointer
)	O
(	O
info	pointer
,	O
&	O
h	pointer
->	O
root	struct
,	O
abfd	pointer
,	O
sec	pointer
,	O
*	O
pvalue	pointer
)	O
;	O
*	O
skip	pointer
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
olddyncommon	int
&&	O
newdyncommon	int
&&	O
sym	pointer
->	O
st_size	long
!=	O
h	pointer
->	O
size	long
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_common	pointer
)	O
(	O
info	pointer
,	O
&	O
h	pointer
->	O
root	struct
,	O
abfd	pointer
,	O
bfd_link_hash_common	int
,	O
sym	pointer
->	O
st_size	long
)	O
;	O
if	O
(	O
sym	pointer
->	O
st_size	long
>	O
h	pointer
->	O
size	long
)	O
h	pointer
->	O
size	long
=	O
sym	pointer
->	O
st_size	long
;	O
*	O
size_change_ok	pointer
=	O
TRUE	int
;	O
}	O
if	O
(	O
newdyn	int
&&	O
newdef	int
&&	O
(	O
olddef	int
||	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
&&	O
(	O
newweak	int
||	O
newfunc	pointer
)	O
)	O
)	O
)	O
{	O
*	O
override	pointer
=	O
TRUE	int
;	O
newdef	int
=	O
FALSE	int
;	O
newdyncommon	int
=	O
FALSE	int
;	O
*	O
psec	pointer
=	O
sec	pointer
=	O
bfd_und_section_ptr	O
;	O
*	O
size_change_ok	pointer
=	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
*	O
type_change_ok	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
newdyncommon	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
{	O
*	O
override	pointer
=	O
TRUE	int
;	O
newdef	int
=	O
FALSE	int
;	O
newdyncommon	int
=	O
FALSE	int
;	O
*	O
pvalue	pointer
=	O
sym	pointer
->	O
st_size	long
;	O
*	O
psec	pointer
=	O
sec	pointer
=	O
bed	pointer
->	O
common_section	pointer
(	O
oldsec	pointer
)	O
;	O
*	O
size_change_ok	pointer
=	O
TRUE	int
;	O
}	O
if	O
(	O
newdef	int
&&	O
olddef	int
&&	O
newweak	int
)	O
{	O
if	O
(	O
!	O
(	O
oldbfd	pointer
!=	O
NULL	O
&&	O
(	O
oldbfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
)	O
)	O
{	O
newdef	int
=	O
FALSE	int
;	O
*	O
skip	pointer
=	O
TRUE	int
;	O
}	O
elf_merge_st_other	function
(	O
abfd	pointer
,	O
h	pointer
,	O
sym	pointer
,	O
sec	pointer
,	O
newdef	int
,	O
newdyn	int
)	O
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_INTERNAL	int
:	O
case	O
STV_HIDDEN	int
:	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
break	O
;	O
}	O
}	O
flip	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
newdyn	int
&&	O
(	O
newdef	int
||	O
(	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
&&	O
(	O
oldweak	int
||	O
oldfunc	int
)	O
)	O
)	O
&&	O
olddyn	int
&&	O
olddef	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
*	O
size_change_ok	pointer
=	O
TRUE	int
;	O
olddef	int
=	O
FALSE	int
;	O
olddyncommon	int
=	O
FALSE	int
;	O
if	O
(	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
)	O
{	O
if	O
(	O
oldfunc	int
)	O
{	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
type	enum
=	O
STT_NOTYPE	int
;	O
}	O
*	O
type_change_ok	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
flip	pointer
=	O
hi	pointer
;	O
else	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
newdyn	int
&&	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
&&	O
olddyncommon	int
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_common	pointer
)	O
(	O
info	pointer
,	O
&	O
h	pointer
->	O
root	struct
,	O
abfd	pointer
,	O
bfd_link_hash_common	int
,	O
sym	pointer
->	O
st_size	long
)	O
;	O
if	O
(	O
h	pointer
->	O
size	long
>	O
*	O
pvalue	pointer
)	O
*	O
pvalue	pointer
=	O
h	pointer
->	O
size	long
;	O
BFD_ASSERT	O
(	O
pold_alignment	pointer
)	O
;	O
*	O
pold_alignment	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
alignment_power	int
;	O
olddef	int
=	O
FALSE	int
;	O
olddyncommon	int
=	O
FALSE	int
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
*	O
size_change_ok	pointer
=	O
TRUE	int
;	O
*	O
type_change_ok	int
=	O
TRUE	int
;	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
flip	pointer
=	O
hi	pointer
;	O
else	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flip	pointer
!=	O
NULL	O
)	O
{	O
flip	pointer
->	O
root	struct
.	O
type	enum
=	O
h	pointer
->	O
root	struct
.	O
type	enum
;	O
flip	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_indirect	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
flip	pointer
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
info	pointer
,	O
flip	pointer
,	O
h	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
def_dynamic	int
)	O
{	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
flip	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_add_default_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_vma	long
value	long
,	O
bfd	struct
*	O
*	O
poldbfd	pointer
,	O
bfd_boolean	int
*	O
dynsym	pointer
)	O
{	O
bfd_boolean	int
type_change_ok	int
;	O
bfd_boolean	int
size_change_ok	pointer
;	O
bfd_boolean	int
skip	pointer
;	O
char	O
*	O
shortname	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
hi	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_boolean	int
collect	int
;	O
bfd_boolean	int
dynamic	int
;	O
bfd_boolean	int
override	pointer
;	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
,	O
shortlen	long
;	O
asection	struct
*	O
tmp_sec	pointer
;	O
bfd_boolean	int
matched	pointer
;	O
if	O
(	O
h	pointer
->	O
versioned	int
==	O
unversioned	int
||	O
h	pointer
->	O
versioned	int
==	O
versioned_hidden	int
)	O
return	O
TRUE	int
;	O
p	pointer
=	O
strchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
h	pointer
->	O
versioned	int
==	O
unknown	int
)	O
{	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
h	pointer
->	O
versioned	int
=	O
unversioned	int
;	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
!=	O
ELF_VER_CHR	char
)	O
{	O
h	pointer
->	O
versioned	int
=	O
versioned_hidden	int
;	O
return	O
TRUE	int
;	O
}	O
else	O
h	pointer
->	O
versioned	int
=	O
versioned	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
collect	int
=	O
bed	pointer
->	O
collect	int
;	O
dynamic	int
=	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
;	O
shortlen	long
=	O
p	pointer
-	O
name	pointer
;	O
shortname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
shortlen	long
+	O
1	int
)	O
;	O
if	O
(	O
shortname	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
shortname	pointer
,	O
name	pointer
,	O
shortlen	long
)	O
;	O
shortname	pointer
[	O
shortlen	long
]	O
=	O
'\0'	O
;	O
type_change_ok	int
=	O
FALSE	int
;	O
size_change_ok	pointer
=	O
FALSE	int
;	O
matched	pointer
=	O
TRUE	int
;	O
tmp_sec	pointer
=	O
sec	pointer
;	O
if	O
(	O
!	O
_bfd_elf_merge_symbol	function
(	O
abfd	pointer
,	O
info	pointer
,	O
shortname	pointer
,	O
sym	pointer
,	O
&	O
tmp_sec	pointer
,	O
&	O
value	long
,	O
&	O
hi	pointer
,	O
poldbfd	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
skip	pointer
,	O
&	O
override	pointer
,	O
&	O
type_change_ok	int
,	O
&	O
size_change_ok	pointer
,	O
&	O
matched	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
skip	pointer
)	O
goto	O
nondefault	O
;	O
if	O
(	O
hi	pointer
->	O
def_regular	int
||	O
ELF_COMMON_DEF_P	O
(	O
hi	pointer
)	O
)	O
{	O
if	O
(	O
hi	pointer
->	O
verinfo	union
.	O
vertree	pointer
==	O
NULL	O
&&	O
info	pointer
->	O
version_info	pointer
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
hide	pointer
;	O
hi	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
bfd_find_version_for_sym	function
(	O
info	pointer
->	O
version_info	pointer
,	O
hi	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
&	O
hide	pointer
)	O
;	O
if	O
(	O
hi	pointer
->	O
verinfo	union
.	O
vertree	pointer
!=	O
NULL	O
&&	O
hide	pointer
)	O
{	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
hi	pointer
,	O
TRUE	int
)	O
;	O
goto	O
nondefault	O
;	O
}	O
}	O
if	O
(	O
hi	pointer
->	O
verinfo	union
.	O
vertree	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
p	pointer
+	O
1	int
+	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'@'	O
)	O
,	O
hi	pointer
->	O
verinfo	union
.	O
vertree	pointer
->	O
name	pointer
)	O
!=	O
0	int
)	O
goto	O
nondefault	O
;	O
}	O
if	O
(	O
!	O
override	pointer
)	O
{	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
bh	pointer
=	O
&	O
hi	pointer
->	O
root	struct
;	O
if	O
(	O
bh	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
bh	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
(	O
bh	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
{	O
bh	pointer
->	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
bh	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
bh	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
}	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
abfd	pointer
,	O
shortname	pointer
,	O
BSF_INDIRECT	O
,	O
bfd_ind_section_ptr	O
,	O
0	int
,	O
name	pointer
,	O
FALSE	int
,	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
hi	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
}	O
}	O
else	O
{	O
while	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
hi	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_indirect	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
hi	pointer
;	O
if	O
(	O
h	pointer
->	O
def_dynamic	int
)	O
{	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
hi	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
if	O
(	O
hi	pointer
->	O
ref_regular	int
||	O
hi	pointer
->	O
def_regular	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
hi	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
hi	pointer
=	O
h	pointer
;	O
}	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
hi	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
ht	pointer
;	O
ht	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
info	pointer
,	O
ht	pointer
,	O
hi	pointer
)	O
;	O
ht	pointer
->	O
ref_dynamic_nonweak	int
|=	O
hi	pointer
->	O
ref_dynamic_nonweak	int
;	O
hi	pointer
->	O
dynamic_def	int
|=	O
ht	pointer
->	O
dynamic_def	int
;	O
if	O
(	O
!	O
*	O
dynsym	pointer
)	O
{	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
hi	pointer
->	O
def_dynamic	int
||	O
hi	pointer
->	O
ref_dynamic	int
)	O
*	O
dynsym	pointer
=	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
hi	pointer
->	O
ref_regular	int
)	O
*	O
dynsym	pointer
=	O
TRUE	int
;	O
}	O
}	O
}	O
nondefault	O
:	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
shortname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
len	long
)	O
;	O
if	O
(	O
shortname	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
shortname	pointer
,	O
name	pointer
,	O
shortlen	long
)	O
;	O
memcpy	function
(	O
shortname	pointer
+	O
shortlen	long
,	O
p	pointer
+	O
1	int
,	O
len	long
-	O
shortlen	long
)	O
;	O
type_change_ok	int
=	O
FALSE	int
;	O
size_change_ok	pointer
=	O
FALSE	int
;	O
tmp_sec	pointer
=	O
sec	pointer
;	O
if	O
(	O
!	O
_bfd_elf_merge_symbol	function
(	O
abfd	pointer
,	O
info	pointer
,	O
shortname	pointer
,	O
sym	pointer
,	O
&	O
tmp_sec	pointer
,	O
&	O
value	long
,	O
&	O
hi	pointer
,	O
poldbfd	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
skip	pointer
,	O
&	O
override	pointer
,	O
&	O
type_change_ok	int
,	O
&	O
size_change_ok	pointer
,	O
&	O
matched	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
skip	pointer
)	O
return	O
TRUE	int
;	O
if	O
(	O
override	pointer
)	O
{	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
hi	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unexpected redefinition of indirect versioned symbol `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
shortname	pointer
)	O
;	O
}	O
else	O
{	O
bh	pointer
=	O
&	O
hi	pointer
->	O
root	struct
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
abfd	pointer
,	O
shortname	pointer
,	O
BSF_INDIRECT	O
,	O
bfd_ind_section_ptr	O
,	O
0	int
,	O
name	pointer
,	O
FALSE	int
,	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
hi	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
{	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
hi	pointer
)	O
;	O
h	pointer
->	O
ref_dynamic_nonweak	int
|=	O
hi	pointer
->	O
ref_dynamic_nonweak	int
;	O
hi	pointer
->	O
dynamic_def	int
|=	O
h	pointer
->	O
dynamic_def	int
;	O
if	O
(	O
!	O
*	O
dynsym	pointer
)	O
{	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
hi	pointer
->	O
ref_dynamic	int
)	O
*	O
dynsym	pointer
=	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
hi	pointer
->	O
ref_regular	int
)	O
*	O
dynsym	pointer
=	O
TRUE	int
;	O
}	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_export_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
elf_info_failed	struct
*	O
eif	pointer
=	O
(	O
struct	O
elf_info_failed	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
eif	pointer
->	O
info	pointer
->	O
export_dynamic	int
&&	O
!	O
h	pointer
->	O
dynamic	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
(	O
h	pointer
->	O
def_regular	int
||	O
h	pointer
->	O
ref_regular	int
)	O
&&	O
!	O
bfd_hide_sym_by_version	function
(	O
eif	pointer
->	O
info	pointer
->	O
version_info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
eif	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_link_find_version_dependencies	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
elf_find_verdep_info	struct
*	O
rinfo	pointer
=	O
(	O
struct	O
elf_find_verdep_info	struct
*	O
)	O
data	pointer
;	O
Elf_Internal_Verneed	struct
*	O
t	pointer
;	O
Elf_Internal_Vernaux	struct
*	O
a	pointer
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
!	O
h	pointer
->	O
def_dynamic	int
||	O
h	pointer
->	O
def_regular	int
||	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
||	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
==	O
NULL	O
||	O
(	O
elf_dyn_lib_class	O
(	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_bfd	pointer
)	O
&	O
(	O
DYN_AS_NEEDED	int
|	O
DYN_DT_NEEDED	int
|	O
DYN_NO_NEEDED	int
)	O
)	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
t	pointer
=	O
elf_tdata	O
(	O
rinfo	pointer
->	O
info	pointer
->	O
output_bfd	pointer
)	O
->	O
verref	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
vn_nextref	pointer
)	O
{	O
if	O
(	O
t	pointer
->	O
vn_bfd	pointer
!=	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_bfd	pointer
)	O
continue	O
;	O
for	O
(	O
a	pointer
=	O
t	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
if	O
(	O
a	pointer
->	O
vna_nodename	pointer
==	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_nodename	pointer
)	O
return	O
TRUE	int
;	O
break	O
;	O
}	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
{	O
amt	long
=	O
sizeof	O
*	O
t	pointer
;	O
t	pointer
=	O
(	O
Elf_Internal_Verneed	struct
*	O
)	O
bfd_zalloc	function
(	O
rinfo	pointer
->	O
info	pointer
->	O
output_bfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
{	O
rinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
t	pointer
->	O
vn_bfd	pointer
=	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_bfd	pointer
;	O
t	pointer
->	O
vn_nextref	pointer
=	O
elf_tdata	O
(	O
rinfo	pointer
->	O
info	pointer
->	O
output_bfd	pointer
)	O
->	O
verref	pointer
;	O
elf_tdata	O
(	O
rinfo	pointer
->	O
info	pointer
->	O
output_bfd	pointer
)	O
->	O
verref	pointer
=	O
t	pointer
;	O
}	O
amt	long
=	O
sizeof	O
*	O
a	pointer
;	O
a	pointer
=	O
(	O
Elf_Internal_Vernaux	struct
*	O
)	O
bfd_zalloc	function
(	O
rinfo	pointer
->	O
info	pointer
->	O
output_bfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
a	pointer
==	O
NULL	O
)	O
{	O
rinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
a	pointer
->	O
vna_nodename	pointer
=	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_nodename	pointer
;	O
a	pointer
->	O
vna_flags	array
=	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_flags	array
;	O
a	pointer
->	O
vna_nextptr	pointer
=	O
t	pointer
->	O
vn_auxptr	pointer
;	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_exp_refno	int
=	O
rinfo	pointer
->	O
vers	int
;	O
++	O
rinfo	pointer
->	O
vers	int
;	O
a	pointer
->	O
vna_other	array
=	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_exp_refno	int
+	O
1	int
;	O
t	pointer
->	O
vn_auxptr	pointer
=	O
a	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_link_hide_versioned_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
version_p	pointer
,	O
struct	O
bfd_elf_version_tree	struct
*	O
*	O
t_p	pointer
,	O
bfd_boolean	int
*	O
hide	pointer
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
;	O
for	O
(	O
t	pointer
=	O
info	pointer
->	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
t	pointer
->	O
name	pointer
,	O
version_p	pointer
)	O
==	O
0	int
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
alc	pointer
;	O
struct	O
bfd_elf_version_expr	struct
*	O
d	double
;	O
len	long
=	O
version_p	pointer
-	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
alc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
alc	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
alc	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
len	long
-	O
1	int
)	O
;	O
alc	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
alc	pointer
[	O
len	long
-	O
2	int
]	O
==	O
ELF_VER_CHR	char
)	O
alc	pointer
[	O
len	long
-	O
2	int
]	O
=	O
'\0'	O
;	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
t	pointer
;	O
t	pointer
->	O
used	int
=	O
TRUE	int
;	O
d	double
=	O
NULL	O
;	O
if	O
(	O
t	pointer
->	O
globals	struct
.	O
list	pointer
!=	O
NULL	O
)	O
d	double
=	O
(	O
*	O
t	pointer
->	O
match	pointer
)	O
(	O
&	O
t	pointer
->	O
globals	struct
,	O
NULL	O
,	O
alc	pointer
)	O
;	O
if	O
(	O
d	double
==	O
NULL	O
&&	O
t	pointer
->	O
locals	struct
.	O
list	pointer
!=	O
NULL	O
)	O
{	O
d	double
=	O
(	O
*	O
t	pointer
->	O
match	pointer
)	O
(	O
&	O
t	pointer
->	O
locals	struct
,	O
NULL	O
,	O
alc	pointer
)	O
;	O
if	O
(	O
d	double
!=	O
NULL	O
&&	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
!	O
info	pointer
->	O
export_dynamic	int
)	O
*	O
hide	pointer
=	O
TRUE	int
;	O
}	O
free	function
(	O
alc	pointer
)	O
;	O
break	O
;	O
}	O
}	O
*	O
t_p	pointer
=	O
t	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_link_hide_sym_by_version	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
bfd_boolean	int
hide	pointer
=	O
FALSE	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
&&	O
!	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
return	O
TRUE	int
;	O
p	pointer
=	O
strchr	function
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
==	O
NULL	O
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
;	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
ELF_VER_CHR	char
)	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
!=	O
'\0'	O
&&	O
_bfd_elf_link_hide_versioned_symbol	function
(	O
info	pointer
,	O
h	pointer
,	O
p	pointer
,	O
&	O
t	pointer
,	O
&	O
hide	pointer
)	O
&&	O
hide	pointer
)	O
{	O
if	O
(	O
hide	pointer
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
==	O
NULL	O
&&	O
info	pointer
->	O
version_info	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
bfd_find_version_for_sym	function
(	O
info	pointer
->	O
version_info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
&	O
hide	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
!=	O
NULL	O
&&	O
hide	pointer
)	O
{	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_link_assign_sym_version	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
elf_info_failed	struct
*	O
sinfo	pointer
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_info_failed	struct
eif	pointer
;	O
char	O
*	O
p	pointer
;	O
bfd_boolean	int
hide	pointer
;	O
sinfo	pointer
=	O
(	O
struct	O
elf_info_failed	struct
*	O
)	O
data	pointer
;	O
info	pointer
=	O
sinfo	pointer
->	O
info	pointer
;	O
eif	pointer
.	O
failed	int
=	O
FALSE	int
;	O
eif	pointer
.	O
info	pointer
=	O
info	pointer
;	O
if	O
(	O
!	O
_bfd_elf_fix_symbol_flags	function
(	O
h	pointer
,	O
&	O
eif	pointer
)	O
)	O
{	O
if	O
(	O
eif	pointer
.	O
failed	int
)	O
sinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
&&	O
!	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
{	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
discarded_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
hide	pointer
=	O
FALSE	int
;	O
p	pointer
=	O
strchr	function
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
==	O
NULL	O
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
;	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
ELF_VER_CHR	char
)	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
_bfd_elf_link_hide_versioned_symbol	function
(	O
info	pointer
,	O
h	pointer
,	O
p	pointer
,	O
&	O
t	pointer
,	O
&	O
hide	pointer
)	O
)	O
{	O
sinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
hide	pointer
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
&&	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
*	O
pp	pointer
;	O
int	O
version_index	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
t	pointer
=	O
(	O
struct	O
bfd_elf_version_tree	struct
*	O
)	O
bfd_zalloc	function
(	O
info	pointer
->	O
output_bfd	pointer
,	O
sizeof	O
*	O
t	pointer
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
{	O
sinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
t	pointer
->	O
name	pointer
=	O
p	pointer
;	O
t	pointer
->	O
name_indx	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
t	pointer
->	O
used	int
=	O
TRUE	int
;	O
version_index	int
=	O
1	int
;	O
if	O
(	O
sinfo	pointer
->	O
info	pointer
->	O
version_info	pointer
!=	O
NULL	O
&&	O
sinfo	pointer
->	O
info	pointer
->	O
version_info	pointer
->	O
vernum	int
==	O
0	int
)	O
version_index	int
=	O
0	int
;	O
for	O
(	O
pp	pointer
=	O
&	O
sinfo	pointer
->	O
info	pointer
->	O
version_info	pointer
;	O
*	O
pp	pointer
!=	O
NULL	O
;	O
pp	pointer
=	O
&	O
(	O
*	O
pp	pointer
)	O
->	O
next	pointer
)	O
++	O
version_index	int
;	O
t	pointer
->	O
vernum	int
=	O
version_index	int
;	O
*	O
pp	pointer
=	O
t	pointer
;	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
t	pointer
;	O
}	O
else	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: version node not found for symbol %s"	pointer
)	O
,	O
info	pointer
->	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
sinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
hide	pointer
&&	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
==	O
NULL	O
&&	O
sinfo	pointer
->	O
info	pointer
->	O
version_info	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
bfd_find_version_for_sym	function
(	O
sinfo	pointer
->	O
info	pointer
->	O
version_info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
&	O
hide	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
!=	O
NULL	O
&&	O
hide	pointer
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_read_relocs_from_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
,	O
void	O
*	O
external_relocs	pointer
,	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
void	O
(	O
*	O
swap_in	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
bfd_byte	char
*	O
,	O
Elf_Internal_Rela	struct
*	O
)	O
;	O
const	O
bfd_byte	char
*	O
erela	pointer
;	O
const	O
bfd_byte	char
*	O
erelaend	pointer
;	O
Elf_Internal_Rela	struct
*	O
irela	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
size_t	long
nsyms	int
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
shdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bread	function
(	O
external_relocs	pointer
,	O
shdr	pointer
->	O
sh_size	array
,	O
abfd	pointer
)	O
!=	O
shdr	pointer
->	O
sh_size	array
)	O
return	O
FALSE	int
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
nsyms	int
=	O
NUM_SHDR_ENTRIES	O
(	O
symtab_hdr	struct
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
shdr	pointer
->	O
sh_entsize	array
==	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
swap_in	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_in	pointer
;	O
else	O
if	O
(	O
shdr	pointer
->	O
sh_entsize	array
==	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
)	O
swap_in	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_in	pointer
;	O
else	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
erela	pointer
=	O
(	O
const	O
bfd_byte	char
*	O
)	O
external_relocs	pointer
;	O
erelaend	pointer
=	O
erela	pointer
+	O
shdr	pointer
->	O
sh_size	array
-	O
shdr	pointer
->	O
sh_entsize	array
;	O
irela	pointer
=	O
internal_relocs	pointer
;	O
while	O
(	O
erela	pointer
<=	O
erelaend	pointer
)	O
{	O
bfd_vma	long
r_symndx	long
;	O
(	O
*	O
swap_in	pointer
)	O
(	O
abfd	pointer
,	O
erela	pointer
,	O
irela	pointer
)	O
;	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
irela	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
64	int
)	O
r_symndx	long
>>=	O
24	int
;	O
if	O
(	O
nsyms	int
>	O
0	int
)	O
{	O
if	O
(	O
(	O
size_t	long
)	O
r_symndx	long
>=	O
nsyms	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: bad reloc symbol index (%#"	pointer
PRIx64	O
" >= %#lx)"	pointer
" for offset %#"	pointer
PRIx64	O
" in section `%pA'"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
r_symndx	long
,	O
(	O
unsigned	O
long	O
)	O
nsyms	int
,	O
(	O
uint64_t	long
)	O
irela	pointer
->	O
r_offset	array
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
if	O
(	O
r_symndx	long
!=	O
STN_UNDEF	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: non-zero symbol index (%#"	pointer
PRIx64	O
")"	pointer
" for offset %#"	pointer
PRIx64	O
" in section `%pA'"	pointer
" when the object file has no symbol table"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
r_symndx	long
,	O
(	O
uint64_t	long
)	O
irela	pointer
->	O
r_offset	array
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
irela	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
;	O
erela	pointer
+=	O
shdr	pointer
->	O
sh_entsize	array
;	O
}	O
return	O
TRUE	int
;	O
}	O
Elf_Internal_Rela	struct
*	O
_bfd_elf_link_read_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
o	pointer
,	O
void	O
*	O
external_relocs	pointer
,	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
,	O
bfd_boolean	int
keep_memory	int
)	O
{	O
void	O
*	O
alloc1	pointer
=	O
NULL	O
;	O
Elf_Internal_Rela	struct
*	O
alloc2	pointer
=	O
NULL	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
Elf_Internal_Rela	struct
*	O
internal_rela_relocs	pointer
;	O
if	O
(	O
esdo	pointer
->	O
relocs	pointer
!=	O
NULL	O
)	O
return	O
esdo	pointer
->	O
relocs	pointer
;	O
if	O
(	O
o	pointer
->	O
reloc_count	int
==	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
)	O
{	O
bfd_size_type	long
size	long
;	O
size	long
=	O
(	O
bfd_size_type	long
)	O
o	pointer
->	O
reloc_count	int
*	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
;	O
if	O
(	O
keep_memory	int
)	O
internal_relocs	pointer
=	O
alloc2	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
size	long
)	O
;	O
else	O
internal_relocs	pointer
=	O
alloc2	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
external_relocs	pointer
==	O
NULL	O
)	O
{	O
bfd_size_type	long
size	long
=	O
0	int
;	O
if	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
size	long
+=	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_size	array
;	O
if	O
(	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
)	O
size	long
+=	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_size	array
;	O
alloc1	pointer
=	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
alloc1	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
external_relocs	pointer
=	O
alloc1	pointer
;	O
}	O
internal_rela_relocs	pointer
=	O
internal_relocs	pointer
;	O
if	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
{	O
if	O
(	O
!	O
elf_link_read_relocs_from_section	function
(	O
abfd	pointer
,	O
o	pointer
,	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
,	O
external_relocs	pointer
,	O
internal_relocs	pointer
)	O
)	O
goto	O
error_return	O
;	O
external_relocs	pointer
=	O
(	O
(	O
(	O
bfd_byte	char
*	O
)	O
external_relocs	pointer
)	O
+	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_size	array
)	O
;	O
internal_rela_relocs	pointer
+=	O
(	O
NUM_SHDR_ENTRIES	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
;	O
}	O
if	O
(	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
&&	O
(	O
!	O
elf_link_read_relocs_from_section	function
(	O
abfd	pointer
,	O
o	pointer
,	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
,	O
external_relocs	pointer
,	O
internal_rela_relocs	pointer
)	O
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
keep_memory	int
)	O
esdo	pointer
->	O
relocs	pointer
=	O
internal_relocs	pointer
;	O
if	O
(	O
alloc1	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc1	pointer
)	O
;	O
return	O
internal_relocs	pointer
;	O
error_return	O
:	O
if	O
(	O
alloc1	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc1	pointer
)	O
;	O
if	O
(	O
alloc2	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
keep_memory	int
)	O
bfd_release	function
(	O
abfd	pointer
,	O
alloc2	pointer
)	O
;	O
else	O
free	function
(	O
alloc2	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_link_size_reloc_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_elf_section_reloc_data	struct
*	O
reldata	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
rel_hdr	pointer
=	O
reldata	pointer
->	O
hdr	pointer
;	O
rel_hdr	pointer
->	O
sh_size	array
=	O
rel_hdr	pointer
->	O
sh_entsize	array
*	O
reldata	pointer
->	O
count	int
;	O
rel_hdr	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
rel_hdr	pointer
->	O
sh_size	array
)	O
;	O
if	O
(	O
rel_hdr	pointer
->	O
contents	pointer
==	O
NULL	O
&&	O
rel_hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
reldata	pointer
->	O
hashes	pointer
==	O
NULL	O
&&	O
reldata	pointer
->	O
count	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
p	pointer
;	O
p	pointer
=	O
(	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
)	O
bfd_zmalloc	function
(	O
reldata	pointer
->	O
count	int
*	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
reldata	pointer
->	O
hashes	pointer
=	O
p	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_link_output_relocs	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
Elf_Internal_Shdr	struct
*	O
input_rel_hdr	pointer
,	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
rel_hash	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
Elf_Internal_Rela	struct
*	O
irela	pointer
;	O
Elf_Internal_Rela	struct
*	O
irelaend	pointer
;	O
bfd_byte	char
*	O
erel	pointer
;	O
struct	O
bfd_elf_section_reloc_data	struct
*	O
output_reldata	pointer
;	O
asection	struct
*	O
output_section	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
void	O
(	O
*	O
swap_out	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
Elf_Internal_Rela	struct
*	O
,	O
bfd_byte	char
*	O
)	O
;	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
;	O
output_section	pointer
=	O
input_section	pointer
->	O
output_section	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
esdo	pointer
=	O
elf_section_data	O
(	O
output_section	pointer
)	O
;	O
if	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
&&	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_entsize	array
==	O
input_rel_hdr	pointer
->	O
sh_entsize	array
)	O
{	O
output_reldata	pointer
=	O
&	O
esdo	pointer
->	O
rel	pointer
;	O
swap_out	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_out	pointer
;	O
}	O
else	O
if	O
(	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
&&	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_entsize	array
==	O
input_rel_hdr	pointer
->	O
sh_entsize	array
)	O
{	O
output_reldata	pointer
=	O
&	O
esdo	pointer
->	O
rela	struct
;	O
swap_out	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_out	pointer
;	O
}	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation size mismatch in %pB section %pA"	pointer
)	O
,	O
output_bfd	pointer
,	O
input_section	pointer
->	O
owner	pointer
,	O
input_section	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
erel	pointer
=	O
output_reldata	pointer
->	O
hdr	pointer
->	O
contents	pointer
;	O
erel	pointer
+=	O
output_reldata	pointer
->	O
count	int
*	O
input_rel_hdr	pointer
->	O
sh_entsize	array
;	O
irela	pointer
=	O
internal_relocs	pointer
;	O
irelaend	pointer
=	O
irela	pointer
+	O
(	O
NUM_SHDR_ENTRIES	O
(	O
input_rel_hdr	pointer
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
;	O
while	O
(	O
irela	pointer
<	O
irelaend	pointer
)	O
{	O
(	O
*	O
swap_out	pointer
)	O
(	O
output_bfd	pointer
,	O
irela	pointer
,	O
erel	pointer
)	O
;	O
irela	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
;	O
erel	pointer
+=	O
input_rel_hdr	pointer
->	O
sh_entsize	array
;	O
}	O
output_reldata	pointer
->	O
count	int
+=	O
NUM_SHDR_ENTRIES	O
(	O
input_rel_hdr	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_link_hash_fixup_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
return	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_fix_symbol_flags	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
struct	O
elf_info_failed	struct
*	O
eif	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
h	pointer
->	O
non_elf	int
)	O
{	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
{	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
h	pointer
->	O
ref_regular_nonweak	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
(	O
bfd_get_flavour	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
)	O
{	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
h	pointer
->	O
ref_regular_nonweak	int
=	O
1	int
;	O
}	O
else	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
}	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
(	O
h	pointer
->	O
def_dynamic	int
||	O
h	pointer
->	O
ref_dynamic	int
)	O
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
eif	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
?	O
(	O
bfd_get_flavour	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
:	O
(	O
bfd_is_abs_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
&&	O
!	O
h	pointer
->	O
def_dynamic	int
)	O
)	O
)	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
elf_hash_table	O
(	O
eif	pointer
->	O
info	pointer
)	O
->	O
dynobj	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_fixup_symbol	pointer
&&	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_fixup_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
ref_regular	int
&&	O
!	O
h	pointer
->	O
def_dynamic	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
BFD_PLUGIN	int
)	O
)	O
==	O
0	int
)	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
&&	O
h	pointer
->	O
indx	long
==	O
-	O
3	int
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_DEFAULT	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
bfd_link_executable	O
(	O
eif	pointer
->	O
info	pointer
)	O
&&	O
h	pointer
->	O
versioned	int
==	O
versioned_hidden	int
&&	O
!	O
eif	pointer
->	O
info	pointer
->	O
export_dynamic	int
&&	O
!	O
h	pointer
->	O
dynamic	int
&&	O
!	O
h	pointer
->	O
ref_dynamic	int
&&	O
h	pointer
->	O
def_regular	int
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
h	pointer
->	O
needs_plt	int
&&	O
bfd_link_pic	O
(	O
eif	pointer
->	O
info	pointer
)	O
&&	O
is_elf_hash_table	O
(	O
eif	pointer
->	O
info	pointer
->	O
hash	long
)	O
&&	O
(	O
SYMBOLIC_BIND	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
)	O
||	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_DEFAULT	int
)	O
&&	O
h	pointer
->	O
def_regular	int
)	O
{	O
bfd_boolean	int
force_local	int
;	O
force_local	int
=	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_INTERNAL	int
||	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_HIDDEN	int
)	O
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
,	O
force_local	int
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
is_weakalias	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
def	struct
=	O
weakdef	function
(	O
h	pointer
)	O
;	O
if	O
(	O
def	struct
->	O
def_regular	int
||	O
def	struct
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
)	O
{	O
h	pointer
=	O
def	struct
;	O
while	O
(	O
(	O
h	pointer
=	O
h	pointer
->	O
u	union
.	O
alias	pointer
)	O
!=	O
def	struct
)	O
h	pointer
->	O
is_weakalias	int
=	O
0	int
;	O
}	O
else	O
{	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
BFD_ASSERT	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
;	O
BFD_ASSERT	O
(	O
def	struct
->	O
def_dynamic	int
)	O
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
def	struct
,	O
h	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_adjust_dynamic_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
elf_info_failed	struct
*	O
eif	pointer
=	O
(	O
struct	O
elf_info_failed	struct
*	O
)	O
data	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
eif	pointer
->	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
_bfd_elf_fix_symbol_flags	function
(	O
h	pointer
,	O
eif	pointer
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
=	O
elf_hash_table	O
(	O
eif	pointer
->	O
info	pointer
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
htab	struct
->	O
dynobj	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
if	O
(	O
eif	pointer
->	O
info	pointer
->	O
dynamic_undefined_weak	int
==	O
0	int
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
eif	pointer
->	O
info	pointer
->	O
dynamic_undefined_weak	int
>	O
0	int
&&	O
h	pointer
->	O
ref_regular	int
&&	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_DEFAULT	int
&&	O
!	O
bfd_hide_sym_by_version	function
(	O
eif	pointer
->	O
info	pointer
->	O
version_info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
eif	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
h	pointer
->	O
needs_plt	int
&&	O
h	pointer
->	O
type	enum
!=	O
STT_GNU_IFUNC	int
&&	O
(	O
h	pointer
->	O
def_regular	int
||	O
!	O
h	pointer
->	O
def_dynamic	int
||	O
(	O
!	O
h	pointer
->	O
ref_regular	int
&&	O
(	O
!	O
h	pointer
->	O
is_weakalias	int
||	O
weakdef	function
(	O
h	pointer
)	O
->	O
dynindx	long
==	O
-	O
1	int
)	O
)	O
)	O
)	O
{	O
h	pointer
->	O
plt	union
=	O
elf_hash_table	O
(	O
eif	pointer
->	O
info	pointer
)	O
->	O
init_plt_offset	union
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
h	pointer
->	O
dynamic_adjusted	int
)	O
return	O
TRUE	int
;	O
h	pointer
->	O
dynamic_adjusted	int
=	O
1	int
;	O
if	O
(	O
h	pointer
->	O
is_weakalias	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
def	struct
=	O
weakdef	function
(	O
h	pointer
)	O
;	O
def	struct
->	O
ref_regular	int
=	O
1	int
;	O
if	O
(	O
!	O
_bfd_elf_adjust_dynamic_symbol	function
(	O
def	struct
,	O
eif	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
h	pointer
->	O
size	long
==	O
0	int
&&	O
h	pointer
->	O
type	enum
==	O
STT_NOTYPE	int
&&	O
!	O
h	pointer
->	O
needs_plt	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: type and size of dynamic symbol `%s' are not defined"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_adjust_dynamic_symbol	pointer
)	O
(	O
eif	pointer
->	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
eif	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_adjust_dynamic_copy	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
asection	struct
*	O
dynbss	pointer
)	O
{	O
unsigned	O
int	O
power_of_two	int
;	O
bfd_vma	long
mask	int
;	O
asection	struct
*	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
power_of_two	int
=	O
bfd_section_alignment	function
(	O
sec	pointer
)	O
;	O
mask	int
=	O
(	O
(	O
bfd_vma	long
)	O
1	int
<<	O
power_of_two	int
)	O
-	O
1	int
;	O
while	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
&	O
mask	int
)	O
!=	O
0	int
)	O
{	O
mask	int
>>=	O
1	int
;	O
--	O
power_of_two	int
;	O
}	O
if	O
(	O
power_of_two	int
>	O
bfd_section_alignment	function
(	O
dynbss	pointer
)	O
)	O
{	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
dynbss	pointer
,	O
power_of_two	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
dynbss	pointer
->	O
size	long
=	O
BFD_ALIGN	O
(	O
dynbss	pointer
->	O
size	long
,	O
mask	int
+	O
1	int
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
dynbss	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
dynbss	pointer
->	O
size	long
;	O
dynbss	pointer
->	O
size	long
+=	O
h	pointer
->	O
size	long
;	O
if	O
(	O
h	pointer
->	O
protected_def	int
&&	O
(	O
!	O
info	pointer
->	O
extern_protected_data	int
||	O
(	O
info	pointer
->	O
extern_protected_data	int
<	O
0	int
&&	O
!	O
get_elf_backend_data	O
(	O
dynbss	pointer
->	O
owner	pointer
)	O
->	O
extern_protected_data	int
)	O
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P: copy reloc against protected `%pT' is dangerous\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_link_sec_merge_syms	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
(	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
->	O
flags	int
&	O
SEC_MERGE	int
)	O
&&	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_MERGE	int
)	O
{	O
bfd	struct
*	O
output_bfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
data	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
_bfd_merged_section_offset	function
(	O
output_bfd	pointer
,	O
&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
,	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_dynamic_symbol_p	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_boolean	int
not_local_protected	int
)	O
{	O
bfd_boolean	int
binding_stays_local_p	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
forced_local	int
)	O
return	O
FALSE	int
;	O
binding_stays_local_p	int
=	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
SYMBOLIC_BIND	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
;	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_INTERNAL	int
:	O
case	O
STV_HIDDEN	int
:	O
return	O
FALSE	int
;	O
case	O
STV_PROTECTED	int
:	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
hash_table	pointer
)	O
)	O
return	O
FALSE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
hash_table	pointer
->	O
dynobj	pointer
)	O
;	O
if	O
(	O
!	O
not_local_protected	int
||	O
!	O
bed	pointer
->	O
is_function_type	pointer
(	O
h	pointer
->	O
type	enum
)	O
)	O
binding_stays_local_p	int
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
&&	O
!	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
return	O
TRUE	int
;	O
return	O
!	O
binding_stays_local_p	int
;	O
}	O
bfd_boolean	int
_bfd_elf_symbol_refs_local_p	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_boolean	int
local_protected	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_HIDDEN	int
||	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_INTERNAL	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
forced_local	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
;	O
else	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
SYMBOLIC_BIND	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_DEFAULT	int
)	O
return	O
FALSE	int
;	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
hash_table	pointer
)	O
)	O
return	O
TRUE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
hash_table	pointer
->	O
dynobj	pointer
)	O
;	O
if	O
(	O
(	O
!	O
info	pointer
->	O
extern_protected_data	int
||	O
(	O
info	pointer
->	O
extern_protected_data	int
<	O
0	int
&&	O
!	O
bed	pointer
->	O
extern_protected_data	int
)	O
)	O
&&	O
!	O
bed	pointer
->	O
is_function_type	pointer
(	O
h	pointer
->	O
type	enum
)	O
)	O
return	O
TRUE	int
;	O
return	O
local_protected	int
;	O
}	O
struct	O
bfd_section	struct
*	O
_bfd_elf_tls_setup	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
bfd_section	struct
*	O
sec	pointer
,	O
*	O
tls	pointer
;	O
unsigned	O
int	O
align	int
=	O
0	int
;	O
for	O
(	O
sec	pointer
=	O
obfd	pointer
->	O
sections	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
break	O
;	O
tls	pointer
=	O
sec	pointer
;	O
for	O
(	O
;	O
sec	pointer
!=	O
NULL	O
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
sec	pointer
->	O
alignment_power	int
>	O
align	int
)	O
align	int
=	O
sec	pointer
->	O
alignment_power	int
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
tls_sec	pointer
=	O
tls	pointer
;	O
if	O
(	O
tls	pointer
!=	O
NULL	O
)	O
tls	pointer
->	O
alignment_power	int
=	O
align	int
;	O
return	O
tls	pointer
;	O
}	O
static	O
bfd_boolean	int
is_global_data_symbol_definition	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
STB_GLOBAL	int
&&	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
<	O
STB_LOOS	int
)	O
return	O
FALSE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
is_function_type	pointer
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
sym	pointer
->	O
st_shndx	array
==	O
SHN_UNDEF	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
common_definition	pointer
(	O
sym	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
sym	pointer
->	O
st_shndx	array
>=	O
SHN_LORESERVE	O
&&	O
sym	pointer
->	O
st_shndx	array
<	O
SHN_ABS	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_is_defined_archive_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
carsym	struct
*	O
symdef	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
size_t	long
symcount	int
;	O
size_t	long
extsymcount	long
;	O
size_t	long
extsymoff	long
;	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
Elf_Internal_Sym	struct
*	O
isymend	pointer
;	O
bfd_boolean	int
result	int
;	O
abfd	pointer
=	O
_bfd_get_elt_at_filepos	function
(	O
abfd	pointer
,	O
symdef	pointer
->	O
file_offset	long
)	O
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
abfd	pointer
,	O
bfd_object	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
abfd	pointer
->	O
plugin_format	enum
==	O
bfd_plugin_yes	int
||	O
(	O
abfd	pointer
->	O
plugin_format	enum
==	O
bfd_plugin_unknown	int
&&	O
bfd_link_plugin_object_p	function
(	O
abfd	pointer
)	O
)	O
)	O
{	O
abfd	pointer
=	O
abfd	pointer
->	O
plugin_dummy_bfd	pointer
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
}	O
else	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
||	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
else	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynsymtab_hdr	struct
;	O
symcount	int
=	O
hdr	pointer
->	O
sh_size	array
/	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
elf_bad_symtab	O
(	O
abfd	pointer
)	O
)	O
{	O
extsymcount	long
=	O
symcount	int
;	O
extsymoff	long
=	O
0	int
;	O
}	O
else	O
{	O
extsymcount	long
=	O
symcount	int
-	O
hdr	pointer
->	O
sh_info	array
;	O
extsymoff	long
=	O
hdr	pointer
->	O
sh_info	array
;	O
}	O
if	O
(	O
extsymcount	long
==	O
0	int
)	O
return	O
FALSE	int
;	O
isymbuf	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
extsymcount	long
,	O
extsymoff	long
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
isymbuf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
result	int
=	O
FALSE	int
;	O
for	O
(	O
isym	pointer
=	O
isymbuf	pointer
,	O
isymend	pointer
=	O
isymbuf	pointer
+	O
extsymcount	long
;	O
isym	pointer
<	O
isymend	pointer
;	O
isym	pointer
++	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
isym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
symdef	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
result	int
=	O
is_global_data_symbol_definition	function
(	O
abfd	pointer
,	O
isym	pointer
)	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
isymbuf	pointer
)	O
;	O
return	O
result	int
;	O
}	O
bfd_boolean	int
_bfd_elf_add_dynamic_entry	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_vma	long
tag	int
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
asection	struct
*	O
s	pointer
;	O
bfd_size_type	long
newsize	long
;	O
bfd_byte	char
*	O
newcontents	pointer
;	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
hash_table	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
tag	int
==	O
DT_RELA	int
||	O
tag	int
==	O
DT_REL	int
)	O
hash_table	pointer
->	O
dynamic_relocs	int
=	O
TRUE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
hash_table	pointer
->	O
dynobj	pointer
)	O
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
hash_table	pointer
->	O
dynobj	pointer
,	O
".dynamic"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
newsize	long
=	O
s	pointer
->	O
size	long
+	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
;	O
newcontents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_realloc	function
(	O
s	pointer
->	O
contents	pointer
,	O
newsize	long
)	O
;	O
if	O
(	O
newcontents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
dyn	struct
.	O
d_tag	array
=	O
tag	int
;	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
=	O
val	array
;	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_out	pointer
(	O
hash_table	pointer
->	O
dynobj	pointer
,	O
&	O
dyn	struct
,	O
newcontents	pointer
+	O
s	pointer
->	O
size	long
)	O
;	O
s	pointer
->	O
size	long
=	O
newsize	long
;	O
s	pointer
->	O
contents	pointer
=	O
newcontents	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
elf_add_dt_needed_tag	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
soname	pointer
,	O
bfd_boolean	int
do_it	int
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
;	O
size_t	long
strindex	long
;	O
if	O
(	O
!	O
_bfd_elf_link_create_dynstrtab	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
-	O
1	int
;	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
strindex	long
=	O
_bfd_elf_strtab_add	function
(	O
hash_table	pointer
->	O
dynstr	pointer
,	O
soname	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
strindex	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
_bfd_elf_strtab_refcount	function
(	O
hash_table	pointer
->	O
dynstr	pointer
,	O
strindex	long
)	O
!=	O
1	int
)	O
{	O
asection	struct
*	O
sdyn	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_byte	char
*	O
extdyn	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
hash_table	pointer
->	O
dynobj	pointer
)	O
;	O
sdyn	pointer
=	O
bfd_get_linker_section	function
(	O
hash_table	pointer
->	O
dynobj	pointer
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
sdyn	pointer
!=	O
NULL	O
)	O
for	O
(	O
extdyn	pointer
=	O
sdyn	pointer
->	O
contents	pointer
;	O
extdyn	pointer
<	O
sdyn	pointer
->	O
contents	pointer
+	O
sdyn	pointer
->	O
size	long
;	O
extdyn	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_in	pointer
(	O
hash_table	pointer
->	O
dynobj	pointer
,	O
extdyn	pointer
,	O
&	O
dyn	struct
)	O
;	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_NEEDED	int
&&	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
==	O
strindex	long
)	O
{	O
_bfd_elf_strtab_delref	function
(	O
hash_table	pointer
->	O
dynstr	pointer
,	O
strindex	long
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
do_it	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_link_create_dynamic_sections	function
(	O
hash_table	pointer
->	O
dynobj	pointer
,	O
info	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_NEEDED	int
,	O
strindex	long
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
_bfd_elf_strtab_delref	function
(	O
hash_table	pointer
->	O
dynstr	pointer
,	O
strindex	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
bfd_boolean	int
on_needed_list	function
(	O
const	O
char	O
*	O
soname	pointer
,	O
struct	O
bfd_link_needed_list	struct
*	O
needed	pointer
,	O
struct	O
bfd_link_needed_list	struct
*	O
stop	pointer
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
look	pointer
;	O
for	O
(	O
look	pointer
=	O
needed	pointer
;	O
look	pointer
!=	O
stop	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
soname	pointer
,	O
look	pointer
->	O
name	pointer
)	O
==	O
0	int
&&	O
(	O
(	O
elf_dyn_lib_class	O
(	O
look	pointer
->	O
by	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
==	O
0	int
||	O
on_needed_list	function
(	O
elf_dt_name	O
(	O
look	pointer
->	O
by	pointer
)	O
,	O
needed	pointer
,	O
look	pointer
)	O
)	O
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
int	O
elf_sort_symbol	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
struct	O
elf_link_hash_entry	struct
*	O
h1	pointer
;	O
const	O
struct	O
elf_link_hash_entry	struct
*	O
h2	pointer
;	O
bfd_signed_vma	long
vdiff	long
;	O
int	O
sdiff	int
;	O
const	O
char	O
*	O
n1	pointer
;	O
const	O
char	O
*	O
n2	pointer
;	O
h1	pointer
=	O
*	O
(	O
const	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
)	O
arg1	pointer
;	O
h2	pointer
=	O
*	O
(	O
const	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
)	O
arg2	pointer
;	O
vdiff	long
=	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
-	O
h2	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
if	O
(	O
vdiff	long
!=	O
0	int
)	O
return	O
vdiff	long
>	O
0	int
?	O
1	int
:	O
-	O
1	int
;	O
sdiff	int
=	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
id	int
-	O
h2	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
id	int
;	O
if	O
(	O
sdiff	int
!=	O
0	int
)	O
return	O
sdiff	int
;	O
vdiff	long
=	O
h1	pointer
->	O
size	long
-	O
h2	pointer
->	O
size	long
;	O
if	O
(	O
vdiff	long
!=	O
0	int
)	O
return	O
vdiff	long
>	O
0	int
?	O
1	int
:	O
-	O
1	int
;	O
if	O
(	O
h1	pointer
->	O
type	enum
!=	O
h2	pointer
->	O
type	enum
)	O
return	O
h1	pointer
->	O
type	enum
-	O
h2	pointer
->	O
type	enum
;	O
n1	pointer
=	O
h1	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
n2	pointer
=	O
h2	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
while	O
(	O
*	O
n1	pointer
==	O
*	O
n2	pointer
)	O
{	O
if	O
(	O
*	O
n1	pointer
==	O
0	int
)	O
break	O
;	O
++	O
n1	pointer
;	O
++	O
n2	pointer
;	O
}	O
if	O
(	O
*	O
n1	pointer
==	O
'_'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
n2	pointer
==	O
'_'	O
)	O
return	O
1	int
;	O
return	O
*	O
n1	pointer
-	O
*	O
n2	pointer
;	O
}	O
static	O
bfd_boolean	int
elf_adjust_dynstr_offsets	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
elf_strtab_hash	O
*	O
dynstr	pointer
=	O
(	O
struct	O
elf_strtab_hash	O
*	O
)	O
data	pointer
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
h	pointer
->	O
dynstr_index	long
=	O
_bfd_elf_strtab_offset	function
(	O
dynstr	pointer
,	O
h	pointer
->	O
dynstr_index	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_finalize_dynstr	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
struct	O
elf_link_local_dynamic_entry	struct
*	O
entry	pointer
;	O
struct	O
elf_strtab_hash	O
*	O
dynstr	pointer
=	O
hash_table	pointer
->	O
dynstr	pointer
;	O
bfd	struct
*	O
dynobj	pointer
=	O
hash_table	pointer
->	O
dynobj	pointer
;	O
asection	struct
*	O
sdyn	pointer
;	O
bfd_size_type	long
size	long
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_byte	char
*	O
extdyn	pointer
;	O
_bfd_elf_strtab_finalize	function
(	O
dynstr	pointer
)	O
;	O
size	long
=	O
_bfd_elf_strtab_size	function
(	O
dynstr	pointer
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
dynobj	pointer
)	O
;	O
sdyn	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".dynamic"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
sdyn	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
extdyn	pointer
=	O
sdyn	pointer
->	O
contents	pointer
;	O
extdyn	pointer
<	O
sdyn	pointer
->	O
contents	pointer
+	O
sdyn	pointer
->	O
size	long
;	O
extdyn	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_in	pointer
(	O
dynobj	pointer
,	O
extdyn	pointer
,	O
&	O
dyn	struct
)	O
;	O
switch	O
(	O
dyn	struct
.	O
d_tag	array
)	O
{	O
case	O
DT_STRSZ	int
:	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
=	O
size	long
;	O
break	O
;	O
case	O
DT_NEEDED	int
:	O
case	O
DT_SONAME	int
:	O
case	O
DT_RPATH	int
:	O
case	O
DT_RUNPATH	int
:	O
case	O
DT_FILTER	int
:	O
case	O
DT_AUXILIARY	int
:	O
case	O
DT_AUDIT	int
:	O
case	O
DT_DEPAUDIT	int
:	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
=	O
_bfd_elf_strtab_offset	function
(	O
dynstr	pointer
,	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
)	O
;	O
break	O
;	O
default	O
:	O
continue	O
;	O
}	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_out	pointer
(	O
dynobj	pointer
,	O
&	O
dyn	struct
,	O
extdyn	pointer
)	O
;	O
}	O
for	O
(	O
entry	pointer
=	O
hash_table	pointer
->	O
dynlocal	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
entry	pointer
->	O
isym	pointer
.	O
st_name	array
=	O
_bfd_elf_strtab_offset	function
(	O
dynstr	pointer
,	O
entry	pointer
->	O
isym	pointer
.	O
st_name	array
)	O
;	O
elf_link_hash_traverse	O
(	O
hash_table	pointer
,	O
elf_adjust_dynstr_offsets	function
,	O
dynstr	pointer
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverdefs	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_byte	char
*	O
p	pointer
;	O
size_t	long
i	pointer
;	O
Elf_Internal_Verdef	struct
def	struct
;	O
Elf_Internal_Verdaux	struct
defaux	struct
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version_d"	pointer
)	O
;	O
p	pointer
=	O
s	pointer
->	O
contents	pointer
;	O
do	O
{	O
_bfd_elf_swap_verdef_in	function
(	O
output_bfd	pointer
,	O
(	O
Elf_External_Verdef	struct
*	O
)	O
p	pointer
,	O
&	O
def	struct
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
if	O
(	O
def	struct
.	O
vd_aux	array
!=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
)	O
continue	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
def	struct
.	O
vd_cnt	array
;	O
++	O
i	pointer
)	O
{	O
_bfd_elf_swap_verdaux_in	function
(	O
output_bfd	pointer
,	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
p	pointer
,	O
&	O
defaux	struct
)	O
;	O
defaux	struct
.	O
vda_name	array
=	O
_bfd_elf_strtab_offset	function
(	O
dynstr	pointer
,	O
defaux	struct
.	O
vda_name	array
)	O
;	O
_bfd_elf_swap_verdaux_out	function
(	O
output_bfd	pointer
,	O
&	O
defaux	struct
,	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
}	O
}	O
while	O
(	O
def	struct
.	O
vd_next	array
)	O
;	O
}	O
if	O
(	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
verref	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_byte	char
*	O
p	pointer
;	O
size_t	long
i	pointer
;	O
Elf_Internal_Verneed	struct
need	struct
;	O
Elf_Internal_Vernaux	struct
needaux	struct
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version_r"	pointer
)	O
;	O
p	pointer
=	O
s	pointer
->	O
contents	pointer
;	O
do	O
{	O
_bfd_elf_swap_verneed_in	function
(	O
output_bfd	pointer
,	O
(	O
Elf_External_Verneed	struct
*	O
)	O
p	pointer
,	O
&	O
need	struct
)	O
;	O
need	struct
.	O
vn_file	array
=	O
_bfd_elf_strtab_offset	function
(	O
dynstr	pointer
,	O
need	struct
.	O
vn_file	array
)	O
;	O
_bfd_elf_swap_verneed_out	function
(	O
output_bfd	pointer
,	O
&	O
need	struct
,	O
(	O
Elf_External_Verneed	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
need	struct
.	O
vn_cnt	array
;	O
++	O
i	pointer
)	O
{	O
_bfd_elf_swap_vernaux_in	function
(	O
output_bfd	pointer
,	O
(	O
Elf_External_Vernaux	struct
*	O
)	O
p	pointer
,	O
&	O
needaux	struct
)	O
;	O
needaux	struct
.	O
vna_name	array
=	O
_bfd_elf_strtab_offset	function
(	O
dynstr	pointer
,	O
needaux	struct
.	O
vna_name	array
)	O
;	O
_bfd_elf_swap_vernaux_out	function
(	O
output_bfd	pointer
,	O
&	O
needaux	struct
,	O
(	O
Elf_External_Vernaux	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Vernaux	struct
)	O
;	O
}	O
}	O
while	O
(	O
need	struct
.	O
vn_next	array
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_default_relocs_compatible	function
(	O
const	O
bfd_target	struct
*	O
input	pointer
,	O
const	O
bfd_target	struct
*	O
output	pointer
)	O
{	O
return	O
input	pointer
==	O
output	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_relocs_compatible	function
(	O
const	O
bfd_target	struct
*	O
input	pointer
,	O
const	O
bfd_target	struct
*	O
output	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
obed	pointer
,	O
*	O
ibed	pointer
;	O
if	O
(	O
input	pointer
==	O
output	pointer
)	O
return	O
TRUE	int
;	O
ibed	pointer
=	O
xvec_get_elf_backend_data	O
(	O
input	pointer
)	O
;	O
obed	pointer
=	O
xvec_get_elf_backend_data	O
(	O
output	pointer
)	O
;	O
if	O
(	O
ibed	pointer
->	O
arch	enum
!=	O
obed	pointer
->	O
arch	enum
)	O
return	O
FALSE	int
;	O
return	O
ibed	pointer
->	O
relocs_compatible	pointer
==	O
obed	pointer
->	O
relocs_compatible	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_notice_as_needed	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
enum	O
notice_asneeded_action	enum
act	enum
)	O
{	O
return	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
notice	pointer
)	O
(	O
info	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
act	enum
,	O
0	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_link_check_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
&&	O
is_elf_hash_table	O
(	O
htab	struct
)	O
&&	O
bed	pointer
->	O
check_relocs	pointer
!=	O
NULL	O
&&	O
elf_object_id	O
(	O
abfd	pointer
)	O
==	O
elf_hash_table_id	O
(	O
htab	struct
)	O
&&	O
(	O
*	O
bed	pointer
->	O
relocs_compatible	pointer
)	O
(	O
abfd	pointer
->	O
xvec	pointer
,	O
info	pointer
->	O
output_bfd	pointer
->	O
xvec	pointer
)	O
)	O
{	O
asection	struct
*	O
o	pointer
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
;	O
bfd_boolean	int
ok	int
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
||	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
||	O
o	pointer
->	O
reloc_count	int
==	O
0	int
||	O
(	O
(	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
||	O
info	pointer
->	O
strip	enum
==	O
strip_debugger	int
)	O
&&	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
||	O
bfd_is_abs_section	function
(	O
o	pointer
->	O
output_section	pointer
)	O
)	O
continue	O
;	O
internal_relocs	pointer
=	O
_bfd_elf_link_read_relocs	function
(	O
abfd	pointer
,	O
o	pointer
,	O
NULL	O
,	O
NULL	O
,	O
info	pointer
->	O
keep_memory	int
)	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
ok	int
=	O
(	O
*	O
bed	pointer
->	O
check_relocs	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
internal_relocs	pointer
)	O
;	O
if	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
relocs	pointer
!=	O
internal_relocs	pointer
)	O
free	function
(	O
internal_relocs	pointer
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_add_object_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
ehdr	pointer
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
size_t	long
symcount	int
;	O
size_t	long
extsymcount	long
;	O
size_t	long
extsymoff	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hash	pointer
;	O
bfd_boolean	int
dynamic	int
;	O
Elf_External_Versym	struct
*	O
extversym	pointer
=	O
NULL	O
;	O
Elf_External_Versym	struct
*	O
extversym_end	pointer
=	O
NULL	O
;	O
Elf_External_Versym	struct
*	O
ever	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
weaks	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
nondeflt_vers	pointer
=	O
NULL	O
;	O
size_t	long
nondeflt_vers_cnt	long
=	O
0	int
;	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
=	O
NULL	O
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
Elf_Internal_Sym	struct
*	O
isymend	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_boolean	int
add_needed	int
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
bfd_size_type	long
amt	long
;	O
void	O
*	O
alloc_mark	pointer
=	O
NULL	O
;	O
struct	O
bfd_hash_entry	struct
*	O
*	O
old_table	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
old_size	int
=	O
0	int
;	O
unsigned	O
int	O
old_count	int
=	O
0	int
;	O
void	O
*	O
old_tab	pointer
=	O
NULL	O
;	O
void	O
*	O
old_ent	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
old_undefs	pointer
=	O
NULL	O
;	O
struct	O
bfd_link_hash_entry	struct
*	O
old_undefs_tail	pointer
=	O
NULL	O
;	O
void	O
*	O
old_strtab	pointer
=	O
NULL	O
;	O
size_t	long
tabsize	long
=	O
0	int
;	O
asection	struct
*	O
s	pointer
;	O
bfd_boolean	int
just_syms	int
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
dynamic	int
=	O
FALSE	int
;	O
else	O
{	O
dynamic	int
=	O
TRUE	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
||	O
!	O
is_elf_hash_table	O
(	O
htab	struct
)	O
||	O
info	pointer
->	O
output_bfd	pointer
->	O
xvec	pointer
!=	O
abfd	pointer
->	O
xvec	pointer
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
else	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
ehdr	pointer
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
info	pointer
->	O
warn_alternate_em	int
&&	O
bed	pointer
->	O
elf_machine_code	int
!=	O
ehdr	pointer
->	O
e_machine	array
&&	O
(	O
(	O
bed	pointer
->	O
elf_machine_alt1	int
!=	O
0	int
&&	O
ehdr	pointer
->	O
e_machine	array
==	O
bed	pointer
->	O
elf_machine_alt1	int
)	O
||	O
(	O
bed	pointer
->	O
elf_machine_alt2	int
!=	O
0	int
&&	O
ehdr	pointer
->	O
e_machine	array
==	O
bed	pointer
->	O
elf_machine_alt2	int
)	O
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"alternate ELF machine code found (%d) in %pB, expecting %d"	pointer
)	O
,	O
ehdr	pointer
->	O
e_machine	array
,	O
abfd	pointer
,	O
bed	pointer
->	O
elf_machine_code	int
)	O
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
".gnu.warning."	pointer
)	O
)	O
{	O
char	O
*	O
msg	pointer
;	O
bfd_size_type	long
sz	long
;	O
name	pointer
+=	O
sizeof	O
".gnu.warning."	pointer
-	O
1	int
;	O
if	O
(	O
dynamic	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
htab	struct
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
continue	O
;	O
}	O
sz	long
=	O
s	pointer
->	O
size	long
;	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sz	long
+	O
1	int
)	O
;	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
s	pointer
,	O
msg	pointer
,	O
0	int
,	O
sz	long
)	O
)	O
goto	O
error_return	O
;	O
msg	pointer
[	O
sz	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
abfd	pointer
,	O
name	pointer
,	O
BSF_WARNING	O
,	O
s	pointer
,	O
0	int
,	O
msg	pointer
,	O
FALSE	int
,	O
bed	pointer
->	O
collect	int
,	O
NULL	O
)	O
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
s	pointer
->	O
size	long
=	O
0	int
;	O
s	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
}	O
}	O
}	O
just_syms	int
=	O
(	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
)	O
!=	O
NULL	O
&&	O
s	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
;	O
add_needed	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
if	O
(	O
!	O
just_syms	int
&&	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
info	pointer
->	O
nointerp	int
&&	O
(	O
info	pointer
->	O
export_dynamic	int
||	O
info	pointer
->	O
dynamic	int
)	O
)	O
)	O
&&	O
is_elf_hash_table	O
(	O
htab	struct
)	O
&&	O
info	pointer
->	O
output_bfd	pointer
->	O
xvec	pointer
==	O
abfd	pointer
->	O
xvec	pointer
&&	O
!	O
htab	struct
->	O
dynamic_sections_created	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_link_create_dynamic_sections	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
htab	struct
)	O
)	O
goto	O
error_return	O
;	O
else	O
{	O
const	O
char	O
*	O
soname	pointer
=	O
NULL	O
;	O
char	O
*	O
audit	pointer
=	O
NULL	O
;	O
struct	O
bfd_link_needed_list	struct
*	O
rpath	pointer
=	O
NULL	O
,	O
*	O
runpath	pointer
=	O
NULL	O
;	O
const	O
Elf_Internal_Phdr	struct
*	O
phdr	pointer
;	O
int	O
ret	pointer
;	O
if	O
(	O
just_syms	int
)	O
abort	function
(	O
)	O
;	O
add_needed	int
=	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
(	O
DYN_AS_NEEDED	int
|	O
DYN_DT_NEEDED	int
|	O
DYN_NO_NEEDED	int
)	O
)	O
==	O
0	int
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
bfd_byte	char
*	O
dynbuf	pointer
;	O
bfd_byte	char
*	O
extdyn	pointer
;	O
unsigned	O
int	O
elfsec	int
;	O
unsigned	O
long	O
shlink	long
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
s	pointer
,	O
&	O
dynbuf	pointer
)	O
)	O
{	O
error_free_dyn	O
:	O
free	function
(	O
dynbuf	pointer
)	O
;	O
goto	O
error_return	O
;	O
}	O
elfsec	int
=	O
_bfd_elf_section_from_bfd_section	function
(	O
abfd	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
elfsec	int
==	O
SHN_BAD	O
)	O
goto	O
error_free_dyn	O
;	O
shlink	long
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elfsec	int
]	O
->	O
sh_link	array
;	O
for	O
(	O
extdyn	pointer
=	O
dynbuf	pointer
;	O
extdyn	pointer
<=	O
dynbuf	pointer
+	O
s	pointer
->	O
size	long
-	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
;	O
extdyn	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_in	pointer
(	O
abfd	pointer
,	O
extdyn	pointer
,	O
&	O
dyn	struct
)	O
;	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_SONAME	int
)	O
{	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
soname	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
if	O
(	O
soname	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
}	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_NEEDED	int
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
n	long
,	O
*	O
*	O
pn	pointer
;	O
char	O
*	O
fnm	pointer
,	O
*	O
anm	pointer
;	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
bfd_link_needed_list	struct
)	O
;	O
n	long
=	O
(	O
struct	O
bfd_link_needed_list	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
fnm	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
||	O
fnm	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
amt	long
=	O
strlen	function
(	O
fnm	pointer
)	O
+	O
1	int
;	O
anm	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
anm	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
memcpy	function
(	O
anm	pointer
,	O
fnm	pointer
,	O
amt	long
)	O
;	O
n	long
->	O
name	pointer
=	O
anm	pointer
;	O
n	long
->	O
by	pointer
=	O
abfd	pointer
;	O
n	long
->	O
next	pointer
=	O
NULL	O
;	O
for	O
(	O
pn	pointer
=	O
&	O
htab	struct
->	O
needed	pointer
;	O
*	O
pn	pointer
!=	O
NULL	O
;	O
pn	pointer
=	O
&	O
(	O
*	O
pn	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pn	pointer
=	O
n	long
;	O
}	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_RUNPATH	int
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
n	long
,	O
*	O
*	O
pn	pointer
;	O
char	O
*	O
fnm	pointer
,	O
*	O
anm	pointer
;	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
bfd_link_needed_list	struct
)	O
;	O
n	long
=	O
(	O
struct	O
bfd_link_needed_list	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
fnm	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
||	O
fnm	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
amt	long
=	O
strlen	function
(	O
fnm	pointer
)	O
+	O
1	int
;	O
anm	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
anm	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
memcpy	function
(	O
anm	pointer
,	O
fnm	pointer
,	O
amt	long
)	O
;	O
n	long
->	O
name	pointer
=	O
anm	pointer
;	O
n	long
->	O
by	pointer
=	O
abfd	pointer
;	O
n	long
->	O
next	pointer
=	O
NULL	O
;	O
for	O
(	O
pn	pointer
=	O
&	O
runpath	pointer
;	O
*	O
pn	pointer
!=	O
NULL	O
;	O
pn	pointer
=	O
&	O
(	O
*	O
pn	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pn	pointer
=	O
n	long
;	O
}	O
if	O
(	O
!	O
runpath	pointer
&&	O
dyn	struct
.	O
d_tag	array
==	O
DT_RPATH	int
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
n	long
,	O
*	O
*	O
pn	pointer
;	O
char	O
*	O
fnm	pointer
,	O
*	O
anm	pointer
;	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
bfd_link_needed_list	struct
)	O
;	O
n	long
=	O
(	O
struct	O
bfd_link_needed_list	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
fnm	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
||	O
fnm	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
amt	long
=	O
strlen	function
(	O
fnm	pointer
)	O
+	O
1	int
;	O
anm	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
anm	pointer
==	O
NULL	O
)	O
goto	O
error_free_dyn	O
;	O
memcpy	function
(	O
anm	pointer
,	O
fnm	pointer
,	O
amt	long
)	O
;	O
n	long
->	O
name	pointer
=	O
anm	pointer
;	O
n	long
->	O
by	pointer
=	O
abfd	pointer
;	O
n	long
->	O
next	pointer
=	O
NULL	O
;	O
for	O
(	O
pn	pointer
=	O
&	O
rpath	pointer
;	O
*	O
pn	pointer
!=	O
NULL	O
;	O
pn	pointer
=	O
&	O
(	O
*	O
pn	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pn	pointer
=	O
n	long
;	O
}	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_AUDIT	int
)	O
{	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
audit	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
}	O
}	O
free	function
(	O
dynbuf	pointer
)	O
;	O
}	O
if	O
(	O
runpath	pointer
)	O
rpath	pointer
=	O
runpath	pointer
;	O
if	O
(	O
rpath	pointer
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
*	O
pn	pointer
;	O
for	O
(	O
pn	pointer
=	O
&	O
htab	struct
->	O
runpath	pointer
;	O
*	O
pn	pointer
!=	O
NULL	O
;	O
pn	pointer
=	O
&	O
(	O
*	O
pn	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pn	pointer
=	O
rpath	pointer
;	O
}	O
phdr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
+	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
;	O
while	O
(	O
phdr	pointer
--	O
>	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
)	O
if	O
(	O
phdr	pointer
->	O
p_type	array
==	O
PT_GNU_RELRO	O
)	O
{	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
s	pointer
->	O
vma	long
>=	O
phdr	pointer
->	O
p_vaddr	array
&&	O
s	pointer
->	O
vma	long
+	O
s	pointer
->	O
size	long
<=	O
phdr	pointer
->	O
p_vaddr	array
+	O
phdr	pointer
->	O
p_memsz	array
)	O
s	pointer
->	O
flags	int
|=	O
SEC_READONLY	int
;	O
break	O
;	O
}	O
bfd_section_list_clear	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
soname	pointer
==	O
NULL	O
||	O
*	O
soname	pointer
==	O
'\0'	O
)	O
{	O
soname	pointer
=	O
elf_dt_name	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
soname	pointer
==	O
NULL	O
||	O
*	O
soname	pointer
==	O
'\0'	O
)	O
soname	pointer
=	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
;	O
}	O
elf_dt_name	O
(	O
abfd	pointer
)	O
=	O
soname	pointer
;	O
ret	pointer
=	O
elf_add_dt_needed_tag	function
(	O
abfd	pointer
,	O
info	pointer
,	O
soname	pointer
,	O
add_needed	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
ret	pointer
>	O
0	int
)	O
return	O
TRUE	int
;	O
elf_dt_audit	O
(	O
abfd	pointer
)	O
=	O
audit	pointer
;	O
}	O
if	O
(	O
!	O
dynamic	int
||	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
else	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynsymtab_hdr	struct
;	O
symcount	int
=	O
hdr	pointer
->	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
elf_bad_symtab	O
(	O
abfd	pointer
)	O
)	O
{	O
extsymcount	long
=	O
symcount	int
;	O
extsymoff	long
=	O
0	int
;	O
}	O
else	O
{	O
extsymcount	long
=	O
symcount	int
-	O
hdr	pointer
->	O
sh_info	array
;	O
extsymoff	long
=	O
hdr	pointer
->	O
sh_info	array
;	O
}	O
sym_hash	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
extsymcount	long
!=	O
0	int
)	O
{	O
isymbuf	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
extsymcount	long
,	O
extsymoff	long
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
isymbuf	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
sym_hash	pointer
==	O
NULL	O
)	O
{	O
amt	long
=	O
extsymcount	long
;	O
amt	long
*=	O
sizeof	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
;	O
sym_hash	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
sym_hash	pointer
==	O
NULL	O
)	O
goto	O
error_free_sym	O
;	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
=	O
sym_hash	pointer
;	O
}	O
}	O
if	O
(	O
dynamic	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_slurp_version_tables	function
(	O
abfd	pointer
,	O
info	pointer
->	O
default_imported_symver	int
)	O
)	O
goto	O
error_free_sym	O
;	O
if	O
(	O
elf_dynversym	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
versymhdr	pointer
;	O
versymhdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynversym_hdr	struct
;	O
amt	long
=	O
versymhdr	pointer
->	O
sh_size	array
;	O
extversym	pointer
=	O
(	O
Elf_External_Versym	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
extversym	pointer
==	O
NULL	O
)	O
goto	O
error_free_sym	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
versymhdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
extversym	pointer
,	O
amt	long
,	O
abfd	pointer
)	O
!=	O
amt	long
)	O
goto	O
error_free_vers	O
;	O
extversym_end	pointer
=	O
extversym	pointer
+	O
(	O
amt	long
/	O
sizeof	O
(	O
*	O
extversym	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
size_t	long
entsize	int
;	O
for	O
(	O
entsize	int
=	O
0	int
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
size	long
;	O
i	pointer
++	O
)	O
{	O
struct	O
bfd_hash_entry	struct
*	O
p	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
for	O
(	O
p	pointer
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
[	O
i	pointer
]	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
p	pointer
;	O
entsize	int
+=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
entsize	int
+=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
;	O
}	O
}	O
tabsize	long
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
size	long
*	O
sizeof	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
;	O
old_tab	pointer
=	O
bfd_malloc	function
(	O
tabsize	long
+	O
entsize	int
)	O
;	O
if	O
(	O
old_tab	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
alloc_mark	pointer
=	O
bfd_hash_allocate	function
(	O
&	O
htab	struct
->	O
root	struct
.	O
table	pointer
,	O
1	int
)	O
;	O
if	O
(	O
alloc_mark	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
notice_as_needed	int
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
notice_as_needed	int
)	O
)	O
goto	O
error_free_vers	O
;	O
old_ent	pointer
=	O
(	O
char	O
*	O
)	O
old_tab	pointer
+	O
tabsize	long
;	O
memcpy	function
(	O
old_tab	pointer
,	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
,	O
tabsize	long
)	O
;	O
old_undefs	pointer
=	O
htab	struct
->	O
root	struct
.	O
undefs	pointer
;	O
old_undefs_tail	pointer
=	O
htab	struct
->	O
root	struct
.	O
undefs_tail	pointer
;	O
old_table	pointer
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
;	O
old_size	int
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
size	long
;	O
old_count	int
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
count	int
;	O
old_strtab	pointer
=	O
_bfd_elf_strtab_save	function
(	O
htab	struct
->	O
dynstr	pointer
)	O
;	O
if	O
(	O
old_strtab	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
size	long
;	O
i	pointer
++	O
)	O
{	O
struct	O
bfd_hash_entry	struct
*	O
p	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
for	O
(	O
p	pointer
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
[	O
i	pointer
]	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
memcpy	function
(	O
old_ent	pointer
,	O
p	pointer
,	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
)	O
;	O
old_ent	pointer
=	O
(	O
char	O
*	O
)	O
old_ent	pointer
+	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
p	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
{	O
memcpy	function
(	O
old_ent	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
,	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
)	O
;	O
old_ent	pointer
=	O
(	O
char	O
*	O
)	O
old_ent	pointer
+	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
;	O
}	O
}	O
}	O
}	O
weaks	pointer
=	O
NULL	O
;	O
if	O
(	O
extversym	pointer
==	O
NULL	O
)	O
ever	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
extversym	pointer
+	O
extsymoff	long
<	O
extversym_end	pointer
)	O
ever	pointer
=	O
extversym	pointer
+	O
extsymoff	long
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: invalid version offset %lx (max %lx)"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
long	O
)	O
extsymoff	long
,	O
(	O
long	O
)	O
(	O
extversym_end	pointer
-	O
extversym	pointer
)	O
/	O
sizeof	O
(	O
*	O
extversym	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_free_vers	O
;	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
abfd	pointer
->	O
lto_slim_object	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: plugin needed to handle lto object"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
}	O
for	O
(	O
isym	pointer
=	O
isymbuf	pointer
,	O
isymend	pointer
=	O
isymbuf	pointer
+	O
extsymcount	long
;	O
isym	pointer
<	O
isymend	pointer
;	O
isym	pointer
++	O
,	O
sym_hash	pointer
++	O
,	O
ever	pointer
=	O
(	O
ever	pointer
!=	O
NULL	O
?	O
ever	pointer
+	O
1	int
:	O
NULL	O
)	O
)	O
{	O
int	O
bind	int
;	O
bfd_vma	long
value	long
;	O
asection	struct
*	O
sec	pointer
,	O
*	O
new_sec	pointer
;	O
flagword	int
flags	int
;	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
hi	pointer
;	O
bfd_boolean	int
definition	int
;	O
bfd_boolean	int
size_change_ok	pointer
;	O
bfd_boolean	int
type_change_ok	int
;	O
bfd_boolean	int
new_weak	int
;	O
bfd_boolean	int
old_weak	int
;	O
bfd_boolean	int
override	pointer
;	O
bfd_boolean	int
common	int
;	O
bfd_boolean	int
discarded	int
;	O
unsigned	O
int	O
old_alignment	int
;	O
unsigned	O
int	O
shindex	int
;	O
bfd	struct
*	O
old_bfd	pointer
;	O
bfd_boolean	int
matched	pointer
;	O
override	pointer
=	O
FALSE	int
;	O
flags	int
=	O
BSF_NO_FLAGS	int
;	O
sec	pointer
=	O
NULL	O
;	O
value	long
=	O
isym	pointer
->	O
st_value	array
;	O
common	int
=	O
bed	pointer
->	O
common_definition	pointer
(	O
isym	pointer
)	O
;	O
if	O
(	O
common	int
&&	O
info	pointer
->	O
inhibit_common_definition	int
)	O
{	O
isym	pointer
->	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
common	int
=	O
FALSE	int
;	O
}	O
discarded	int
=	O
FALSE	int
;	O
bind	int
=	O
ELF_ST_BIND	O
(	O
isym	pointer
->	O
st_info	array
)	O
;	O
switch	O
(	O
bind	int
)	O
{	O
case	O
STB_LOCAL	int
:	O
if	O
(	O
elf_bad_symtab	O
(	O
abfd	pointer
)	O
)	O
continue	O
;	O
shindex	int
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_shstrndx	array
;	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shindex	int
,	O
hdr	pointer
->	O
sh_name	array
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %s local symbol at index %lu"	pointer
" (>= sh_info of %lu)"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
,	O
(	O
long	O
)	O
(	O
isym	pointer
-	O
isymbuf	pointer
+	O
extsymoff	long
)	O
,	O
(	O
long	O
)	O
extsymoff	long
)	O
;	O
if	O
(	O
dynamic	int
)	O
continue	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_free_vers	O
;	O
case	O
STB_GLOBAL	int
:	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
!=	O
SHN_UNDEF	int
&&	O
!	O
common	int
)	O
flags	int
=	O
BSF_GLOBAL	O
;	O
break	O
;	O
case	O
STB_WEAK	int
:	O
flags	int
=	O
BSF_WEAK	O
;	O
break	O
;	O
case	O
STB_GNU_UNIQUE	int
:	O
flags	int
=	O
BSF_GNU_UNIQUE	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_UNDEF	int
)	O
sec	pointer
=	O
bfd_und_section_ptr	O
;	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_ABS	O
)	O
sec	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
)	O
{	O
sec	pointer
=	O
bfd_com_section_ptr	O
;	O
value	long
=	O
isym	pointer
->	O
st_size	long
;	O
}	O
else	O
{	O
sec	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
sec	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
if	O
(	O
discarded_section	function
(	O
sec	pointer
)	O
)	O
{	O
sec	pointer
=	O
bfd_und_section_ptr	O
;	O
discarded	int
=	O
TRUE	int
;	O
isym	pointer
->	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
}	O
else	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
EXEC_P	int
|	O
DYNAMIC	int
)	O
)	O
!=	O
0	int
)	O
value	long
-=	O
sec	pointer
->	O
vma	long
;	O
}	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
isym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
{	O
asection	struct
*	O
xc	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
"COMMON"	pointer
)	O
;	O
if	O
(	O
xc	pointer
==	O
NULL	O
)	O
{	O
flagword	int
sflags	int
=	O
(	O
SEC_ALLOC	int
|	O
SEC_IS_COMMON	int
|	O
SEC_KEEP	int
|	O
SEC_EXCLUDE	int
)	O
;	O
xc	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
"COMMON"	pointer
,	O
sflags	int
)	O
;	O
if	O
(	O
xc	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
}	O
sec	pointer
=	O
xc	pointer
;	O
}	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
&&	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_TLS	int
&&	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
asection	struct
*	O
tcomm	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".tcommon"	pointer
)	O
;	O
if	O
(	O
tcomm	pointer
==	O
NULL	O
)	O
{	O
flagword	int
sflags	int
=	O
(	O
SEC_ALLOC	int
|	O
SEC_THREAD_LOCAL	int
|	O
SEC_IS_COMMON	int
|	O
SEC_LINKER_CREATED	int
)	O
;	O
tcomm	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
".tcommon"	pointer
,	O
sflags	int
)	O
;	O
if	O
(	O
tcomm	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
}	O
sec	pointer
=	O
tcomm	pointer
;	O
}	O
else	O
if	O
(	O
bed	pointer
->	O
elf_add_symbol_hook	pointer
)	O
{	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_add_symbol_hook	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
isym	pointer
,	O
&	O
name	pointer
,	O
&	O
flags	int
,	O
&	O
sec	pointer
,	O
&	O
value	long
)	O
)	O
goto	O
error_free_vers	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
continue	O
;	O
}	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_TLS	int
&&	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
if	O
(	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
||	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
)	O
definition	int
=	O
FALSE	int
;	O
else	O
definition	int
=	O
TRUE	int
;	O
size_change_ok	pointer
=	O
FALSE	int
;	O
type_change_ok	int
=	O
bed	pointer
->	O
type_change_ok	int
;	O
old_weak	int
=	O
FALSE	int
;	O
matched	pointer
=	O
FALSE	int
;	O
old_alignment	int
=	O
0	int
;	O
old_bfd	pointer
=	O
NULL	O
;	O
new_sec	pointer
=	O
sec	pointer
;	O
if	O
(	O
is_elf_hash_table	O
(	O
htab	struct
)	O
)	O
{	O
Elf_Internal_Versym	struct
iver	struct
;	O
unsigned	O
int	O
vernum	int
=	O
0	int
;	O
bfd_boolean	int
skip	pointer
;	O
if	O
(	O
ever	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
info	pointer
->	O
default_imported_symver	int
)	O
iver	struct
.	O
vs_vers	array
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
;	O
else	O
iver	struct
.	O
vs_vers	array
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ever	pointer
>=	O
extversym_end	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: not enough version information"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_free_vers	O
;	O
}	O
else	O
_bfd_elf_swap_versym_in	function
(	O
abfd	pointer
,	O
ever	pointer
,	O
&	O
iver	struct
)	O
;	O
vernum	int
=	O
iver	struct
.	O
vs_vers	array
&	O
VERSYM_VERSION	int
;	O
if	O
(	O
(	O
iver	struct
.	O
vs_vers	array
&	O
VERSYM_HIDDEN	int
)	O
!=	O
0	int
||	O
(	O
vernum	int
>	O
1	int
&&	O
(	O
!	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
||	O
bed	pointer
->	O
is_function_type	pointer
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
)	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
verstr	pointer
;	O
size_t	long
namelen	long
,	O
verlen	long
,	O
newlen	long
;	O
char	O
*	O
newname	pointer
,	O
*	O
p	pointer
;	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
!=	O
SHN_UNDEF	int
)	O
{	O
if	O
(	O
vernum	int
>	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
)	O
verstr	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
vernum	int
>	O
1	int
)	O
verstr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
[	O
vernum	int
-	O
1	int
]	O
.	O
vd_nodename	pointer
;	O
else	O
verstr	pointer
=	O
""	pointer
;	O
if	O
(	O
verstr	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %s: invalid version %u (max %d)"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
,	O
vernum	int
,	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_free_vers	O
;	O
}	O
}	O
else	O
{	O
Elf_Internal_Verneed	struct
*	O
t	pointer
;	O
verstr	pointer
=	O
NULL	O
;	O
for	O
(	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
vn_nextref	pointer
)	O
{	O
Elf_Internal_Vernaux	struct
*	O
a	pointer
;	O
for	O
(	O
a	pointer
=	O
t	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
{	O
if	O
(	O
a	pointer
->	O
vna_other	array
==	O
vernum	int
)	O
{	O
verstr	pointer
=	O
a	pointer
->	O
vna_nodename	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
a	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
verstr	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %s: invalid needed version %d"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
,	O
vernum	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_free_vers	O
;	O
}	O
}	O
namelen	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
verlen	long
=	O
strlen	function
(	O
verstr	pointer
)	O
;	O
newlen	long
=	O
namelen	long
+	O
verlen	long
+	O
2	int
;	O
if	O
(	O
(	O
iver	struct
.	O
vs_vers	array
&	O
VERSYM_HIDDEN	int
)	O
==	O
0	int
&&	O
isym	pointer
->	O
st_shndx	array
!=	O
SHN_UNDEF	int
)	O
++	O
newlen	long
;	O
newname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
htab	struct
->	O
root	struct
.	O
table	pointer
,	O
newlen	long
)	O
;	O
if	O
(	O
newname	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
memcpy	function
(	O
newname	pointer
,	O
name	pointer
,	O
namelen	long
)	O
;	O
p	pointer
=	O
newname	pointer
+	O
namelen	long
;	O
*	O
p	pointer
++	O
=	O
ELF_VER_CHR	char
;	O
if	O
(	O
(	O
iver	struct
.	O
vs_vers	array
&	O
VERSYM_HIDDEN	int
)	O
==	O
0	int
&&	O
isym	pointer
->	O
st_shndx	array
!=	O
SHN_UNDEF	int
)	O
*	O
p	pointer
++	O
=	O
ELF_VER_CHR	char
;	O
memcpy	function
(	O
p	pointer
,	O
verstr	pointer
,	O
verlen	long
+	O
1	int
)	O
;	O
name	pointer
=	O
newname	pointer
;	O
}	O
if	O
(	O
!	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
&&	O
!	O
dynamic	int
&&	O
abfd	pointer
->	O
no_export	int
&&	O
ELF_ST_VISIBILITY	O
(	O
isym	pointer
->	O
st_other	array
)	O
!=	O
STV_INTERNAL	int
)	O
isym	pointer
->	O
st_other	array
=	O
(	O
STV_HIDDEN	int
|	O
(	O
isym	pointer
->	O
st_other	array
&	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
!	O
_bfd_elf_merge_symbol	function
(	O
abfd	pointer
,	O
info	pointer
,	O
name	pointer
,	O
isym	pointer
,	O
&	O
sec	pointer
,	O
&	O
value	long
,	O
sym_hash	pointer
,	O
&	O
old_bfd	pointer
,	O
&	O
old_weak	int
,	O
&	O
old_alignment	int
,	O
&	O
skip	pointer
,	O
&	O
override	pointer
,	O
&	O
type_change_ok	int
,	O
&	O
size_change_ok	pointer
,	O
&	O
matched	pointer
)	O
)	O
goto	O
error_free_vers	O
;	O
if	O
(	O
skip	pointer
)	O
continue	O
;	O
if	O
(	O
override	pointer
&&	O
matched	pointer
)	O
definition	int
=	O
FALSE	int
;	O
h	pointer
=	O
*	O
sym_hash	pointer
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
!=	O
NULL	O
&&	O
vernum	int
>	O
1	int
&&	O
definition	int
)	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
[	O
vernum	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
abfd	pointer
,	O
name	pointer
,	O
flags	int
,	O
sec	pointer
,	O
value	long
,	O
NULL	O
,	O
FALSE	int
,	O
bed	pointer
->	O
collect	int
,	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
)	O
sym_hash	pointer
)	O
)	O
)	O
goto	O
error_free_vers	O
;	O
h	pointer
=	O
*	O
sym_hash	pointer
;	O
hi	pointer
=	O
h	pointer
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
discarded	int
)	O
h	pointer
->	O
indx	long
=	O
-	O
3	int
;	O
*	O
sym_hash	pointer
=	O
h	pointer
;	O
new_weak	int
=	O
(	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
;	O
if	O
(	O
dynamic	int
&&	O
definition	int
&&	O
new_weak	int
&&	O
!	O
bed	pointer
->	O
is_function_type	pointer
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
)	O
&&	O
is_elf_hash_table	O
(	O
htab	struct
)	O
&&	O
h	pointer
->	O
u	union
.	O
alias	pointer
==	O
NULL	O
)	O
{	O
h	pointer
->	O
u	union
.	O
alias	pointer
=	O
weaks	pointer
;	O
weaks	pointer
=	O
h	pointer
;	O
}	O
if	O
(	O
(	O
common	int
||	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
)	O
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
{	O
unsigned	O
int	O
align	int
;	O
if	O
(	O
common	int
)	O
align	int
=	O
bfd_log2	function
(	O
isym	pointer
->	O
st_value	array
)	O
;	O
else	O
{	O
align	int
=	O
new_sec	pointer
->	O
alignment_power	int
;	O
}	O
if	O
(	O
align	int
>	O
old_alignment	int
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
align	int
;	O
else	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
old_alignment	int
;	O
}	O
if	O
(	O
is_elf_hash_table	O
(	O
htab	struct
)	O
)	O
{	O
bfd_boolean	int
dynsym	pointer
=	O
FALSE	int
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
;	O
else	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
if	O
(	O
!	O
definition	int
)	O
{	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
if	O
(	O
bind	int
!=	O
STB_WEAK	int
)	O
h	pointer
->	O
ref_regular_nonweak	int
=	O
1	int
;	O
}	O
else	O
{	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
if	O
(	O
h	pointer
->	O
def_dynamic	int
)	O
{	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
h	pointer
==	O
hi	pointer
||	O
!	O
hi	pointer
->	O
forced_local	int
)	O
&&	O
(	O
bfd_link_dll	O
(	O
info	pointer
)	O
||	O
h	pointer
->	O
def_dynamic	int
||	O
h	pointer
->	O
ref_dynamic	int
)	O
)	O
dynsym	pointer
=	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
definition	int
)	O
{	O
h	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
hi	pointer
->	O
ref_dynamic	int
=	O
1	int
;	O
}	O
else	O
{	O
h	pointer
->	O
def_dynamic	int
=	O
1	int
;	O
hi	pointer
->	O
def_dynamic	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
h	pointer
==	O
hi	pointer
||	O
!	O
hi	pointer
->	O
forced_local	int
)	O
&&	O
(	O
h	pointer
->	O
def_regular	int
||	O
h	pointer
->	O
ref_regular	int
||	O
(	O
h	pointer
->	O
is_weakalias	int
&&	O
weakdef	function
(	O
h	pointer
)	O
->	O
dynindx	long
!=	O
-	O
1	int
)	O
)	O
)	O
dynsym	pointer
=	O
TRUE	int
;	O
}	O
if	O
(	O
definition	int
||	O
(	O
!	O
override	pointer
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
)	O
if	O
(	O
!	O
_bfd_elf_add_default_symbol	function
(	O
abfd	pointer
,	O
info	pointer
,	O
h	pointer
,	O
name	pointer
,	O
isym	pointer
,	O
sec	pointer
,	O
value	long
,	O
&	O
old_bfd	pointer
,	O
&	O
dynsym	pointer
)	O
)	O
goto	O
error_free_vers	O
;	O
if	O
(	O
(	O
old_alignment	int
||	O
common	int
)	O
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_common	int
)	O
{	O
unsigned	O
int	O
common_align	int
;	O
unsigned	O
int	O
normal_align	int
;	O
unsigned	O
int	O
symbol_align	int
;	O
bfd	struct
*	O
normal_bfd	pointer
;	O
bfd	struct
*	O
common_bfd	pointer
;	O
BFD_ASSERT	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
;	O
symbol_align	int
=	O
ffs	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
)	O
-	O
1	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
BFD_PLUGIN	int
)	O
)	O
==	O
0	int
)	O
{	O
normal_align	int
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
alignment_power	int
;	O
if	O
(	O
normal_align	int
>	O
symbol_align	int
)	O
normal_align	int
=	O
symbol_align	int
;	O
}	O
else	O
normal_align	int
=	O
symbol_align	int
;	O
if	O
(	O
old_alignment	int
)	O
{	O
common_align	int
=	O
old_alignment	int
;	O
common_bfd	pointer
=	O
old_bfd	pointer
;	O
normal_bfd	pointer
=	O
abfd	pointer
;	O
}	O
else	O
{	O
common_align	int
=	O
bfd_log2	function
(	O
isym	pointer
->	O
st_value	array
)	O
;	O
common_bfd	pointer
=	O
abfd	pointer
;	O
normal_bfd	pointer
=	O
old_bfd	pointer
;	O
}	O
if	O
(	O
normal_align	int
<	O
common_align	int
)	O
{	O
if	O
(	O
normal_bfd	pointer
==	O
NULL	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: alignment %u of common symbol `%s' in %pB is"	pointer
" greater than the alignment (%u) of its section %pA"	pointer
)	O
,	O
1	int
<<	O
common_align	int
,	O
name	pointer
,	O
common_bfd	pointer
,	O
1	int
<<	O
normal_align	int
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
;	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: alignment %u of symbol `%s' in %pB"	pointer
" is smaller than %u in %pB"	pointer
)	O
,	O
1	int
<<	O
normal_align	int
,	O
name	pointer
,	O
normal_bfd	pointer
,	O
1	int
<<	O
common_align	int
,	O
common_bfd	pointer
)	O
;	O
}	O
}	O
if	O
(	O
isym	pointer
->	O
st_size	long
!=	O
0	int
&&	O
isym	pointer
->	O
st_shndx	array
!=	O
SHN_UNDEF	int
&&	O
(	O
definition	int
||	O
h	pointer
->	O
size	long
==	O
0	int
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
size	long
!=	O
0	int
&&	O
h	pointer
->	O
size	long
!=	O
isym	pointer
->	O
st_size	long
&&	O
!	O
size_change_ok	pointer
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: size of symbol `%s' changed"	pointer
" from %"	pointer
PRIu64	O
" in %pB to %"	pointer
PRIu64	O
" in %pB"	pointer
)	O
,	O
name	pointer
,	O
(	O
uint64_t	long
)	O
h	pointer
->	O
size	long
,	O
old_bfd	pointer
,	O
(	O
uint64_t	long
)	O
isym	pointer
->	O
st_size	long
,	O
abfd	pointer
)	O
;	O
h	pointer
->	O
size	long
=	O
isym	pointer
->	O
st_size	long
;	O
}	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
h	pointer
->	O
size	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
size	long
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
!=	O
STT_NOTYPE	int
&&	O
(	O
(	O
definition	int
&&	O
!	O
new_weak	int
)	O
||	O
(	O
old_weak	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
||	O
h	pointer
->	O
type	enum
==	O
STT_NOTYPE	int
)	O
)	O
{	O
unsigned	O
int	O
type	enum
=	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
;	O
if	O
(	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_FUNC	int
;	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
type	enum
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
STT_NOTYPE	int
&&	O
!	O
type_change_ok	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: type of symbol `%s' changed"	pointer
" from %d to %d in %pB"	pointer
)	O
,	O
name	pointer
,	O
h	pointer
->	O
type	enum
,	O
type	enum
,	O
abfd	pointer
)	O
;	O
h	pointer
->	O
type	enum
=	O
type	enum
;	O
}	O
}	O
elf_merge_st_other	function
(	O
abfd	pointer
,	O
h	pointer
,	O
isym	pointer
,	O
sec	pointer
,	O
definition	int
,	O
dynamic	int
)	O
;	O
if	O
(	O
definition	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
dynsym	pointer
=	O
FALSE	int
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
dynsym	pointer
=	O
FALSE	int
;	O
if	O
(	O
definition	int
)	O
{	O
h	pointer
->	O
target_internal	int
=	O
isym	pointer
->	O
st_target_internal	char
;	O
h	pointer
->	O
unique_global	int
=	O
(	O
flags	int
&	O
BSF_GNU_UNIQUE	O
)	O
!=	O
0	int
;	O
}	O
if	O
(	O
definition	int
&&	O
!	O
dynamic	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
ELF_VER_CHR	char
)	O
{	O
if	O
(	O
!	O
nondeflt_vers	pointer
)	O
{	O
amt	long
=	O
(	O
(	O
isymend	pointer
-	O
isym	pointer
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
)	O
;	O
nondeflt_vers	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
!	O
nondeflt_vers	pointer
)	O
goto	O
error_free_vers	O
;	O
}	O
nondeflt_vers	pointer
[	O
nondeflt_vers_cnt	long
++	O
]	O
=	O
h	pointer
;	O
}	O
}	O
if	O
(	O
dynsym	pointer
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
goto	O
error_free_vers	O
;	O
if	O
(	O
h	pointer
->	O
is_weakalias	int
&&	O
weakdef	function
(	O
h	pointer
)	O
->	O
dynindx	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
weakdef	function
(	O
h	pointer
)	O
)	O
)	O
goto	O
error_free_vers	O
;	O
}	O
}	O
else	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_INTERNAL	int
:	O
case	O
STV_HIDDEN	int
:	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
dynsym	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
add_needed	int
&&	O
matched	pointer
&&	O
definition	int
&&	O
(	O
(	O
dynsym	pointer
&&	O
h	pointer
->	O
ref_regular_nonweak	int
&&	O
(	O
old_bfd	pointer
==	O
NULL	O
||	O
(	O
old_bfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
)	O
)	O
||	O
(	O
h	pointer
->	O
ref_dynamic_nonweak	int
&&	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
&&	O
!	O
on_needed_list	function
(	O
elf_dt_name	O
(	O
abfd	pointer
)	O
,	O
htab	struct
->	O
needed	pointer
,	O
NULL	O
)	O
)	O
)	O
)	O
{	O
int	O
ret	pointer
;	O
const	O
char	O
*	O
soname	pointer
=	O
elf_dt_name	O
(	O
abfd	pointer
)	O
;	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
"%!"	pointer
,	O
soname	pointer
,	O
old_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
if	O
(	O
old_bfd	pointer
!=	O
NULL	O
&&	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
DYN_NO_NEEDED	int
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: undefined reference to symbol '%s'"	pointer
)	O
,	O
old_bfd	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_missing_dso	int
)	O
;	O
goto	O
error_free_vers	O
;	O
}	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
=	O
(	O
enum	O
dynamic_lib_link_class	enum
)	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
~	O
DYN_AS_NEEDED	int
)	O
;	O
add_needed	int
=	O
TRUE	int
;	O
ret	pointer
=	O
elf_add_dt_needed_tag	function
(	O
abfd	pointer
,	O
info	pointer
,	O
soname	pointer
,	O
add_needed	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
goto	O
error_free_vers	O
;	O
BFD_ASSERT	O
(	O
ret	pointer
==	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
info	pointer
->	O
lto_plugin_active	int
&&	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
&&	O
!	O
just_syms	int
&&	O
extsymcount	long
)	O
{	O
int	O
r_sym_shift	int
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
r_sym_shift	int
=	O
8	int
;	O
else	O
r_sym_shift	int
=	O
32	int
;	O
sym_hash	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
;	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
*	O
relend	pointer
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
||	O
s	pointer
->	O
reloc_count	int
==	O
0	int
||	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
||	O
(	O
(	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
||	O
info	pointer
->	O
strip	enum
==	O
strip_debugger	int
)	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
)	O
continue	O
;	O
internal_relocs	pointer
=	O
_bfd_elf_link_read_relocs	function
(	O
abfd	pointer
,	O
s	pointer
,	O
NULL	O
,	O
NULL	O
,	O
info	pointer
->	O
keep_memory	int
)	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
)	O
goto	O
error_free_vers	O
;	O
rel	pointer
=	O
internal_relocs	pointer
;	O
relend	pointer
=	O
rel	pointer
+	O
s	pointer
->	O
reloc_count	int
;	O
for	O
(	O
;	O
rel	pointer
<	O
relend	pointer
;	O
rel	pointer
++	O
)	O
{	O
unsigned	O
long	O
r_symndx	long
=	O
rel	pointer
->	O
r_info	array
>>	O
r_sym_shift	int
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
if	O
(	O
r_symndx	long
<	O
extsymoff	long
)	O
continue	O
;	O
h	pointer
=	O
sym_hash	pointer
[	O
r_symndx	long
-	O
extsymoff	long
]	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_regular	int
=	O
1	int
;	O
}	O
if	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
relocs	pointer
!=	O
internal_relocs	pointer
)	O
free	function
(	O
internal_relocs	pointer
)	O
;	O
}	O
}	O
if	O
(	O
extversym	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
extversym	pointer
)	O
;	O
extversym	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
isymbuf	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
isymbuf	pointer
)	O
;	O
isymbuf	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
old_ent	pointer
=	O
(	O
char	O
*	O
)	O
old_tab	pointer
+	O
tabsize	long
;	O
memset	function
(	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
,	O
0	int
,	O
extsymcount	long
*	O
sizeof	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
)	O
;	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
=	O
old_table	pointer
;	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
size	long
=	O
old_size	int
;	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
count	int
=	O
old_count	int
;	O
memcpy	function
(	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
,	O
old_tab	pointer
,	O
tabsize	long
)	O
;	O
htab	struct
->	O
root	struct
.	O
undefs	pointer
=	O
old_undefs	pointer
;	O
htab	struct
->	O
root	struct
.	O
undefs_tail	pointer
=	O
old_undefs_tail	pointer
;	O
_bfd_elf_strtab_restore	function
(	O
htab	struct
->	O
dynstr	pointer
,	O
old_strtab	pointer
)	O
;	O
free	function
(	O
old_strtab	pointer
)	O
;	O
old_strtab	pointer
=	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
size	long
;	O
i	pointer
++	O
)	O
{	O
struct	O
bfd_hash_entry	struct
*	O
p	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
bfd_size_type	long
size	long
;	O
unsigned	O
int	O
alignment_power	int
;	O
unsigned	O
int	O
non_ir_ref_dynamic	int
;	O
for	O
(	O
p	pointer
=	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
table	pointer
[	O
i	pointer
]	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
p	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
{	O
size	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
size	long
;	O
alignment_power	int
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
;	O
}	O
else	O
{	O
size	long
=	O
0	int
;	O
alignment_power	int
=	O
0	int
;	O
}	O
non_ir_ref_dynamic	int
=	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_dynamic	int
;	O
memcpy	function
(	O
p	pointer
,	O
old_ent	pointer
,	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
)	O
;	O
old_ent	pointer
=	O
(	O
char	O
*	O
)	O
old_ent	pointer
+	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
p	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
{	O
memcpy	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
,	O
old_ent	pointer
,	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
)	O
;	O
old_ent	pointer
=	O
(	O
char	O
*	O
)	O
old_ent	pointer
+	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
entsize	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
}	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
{	O
if	O
(	O
size	long
>	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
size	long
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
size	long
=	O
size	long
;	O
if	O
(	O
alignment_power	int
>	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
alignment_power	int
;	O
}	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_dynamic	int
=	O
non_ir_ref_dynamic	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
notice_as_needed	int
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
notice_not_needed	int
)	O
)	O
goto	O
error_free_vers	O
;	O
free	function
(	O
old_tab	pointer
)	O
;	O
objalloc_free_block	function
(	O
(	O
struct	O
objalloc	struct
*	O
)	O
htab	struct
->	O
root	struct
.	O
table	pointer
.	O
memory	pointer
,	O
alloc_mark	pointer
)	O
;	O
if	O
(	O
nondeflt_vers	pointer
!=	O
NULL	O
)	O
free	function
(	O
nondeflt_vers	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
old_tab	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
notice_as_needed	int
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
notice_needed	int
)	O
)	O
goto	O
error_free_vers	O
;	O
free	function
(	O
old_tab	pointer
)	O
;	O
old_tab	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
nondeflt_vers	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
cnt	long
,	O
symidx	long
;	O
for	O
(	O
cnt	long
=	O
0	int
;	O
cnt	long
<	O
nondeflt_vers_cnt	long
;	O
++	O
cnt	long
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
nondeflt_vers	pointer
[	O
cnt	long
]	O
,	O
*	O
hi	pointer
;	O
char	O
*	O
shortname	pointer
,	O
*	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
)	O
continue	O
;	O
amt	long
=	O
p	pointer
-	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
shortname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
shortname	pointer
)	O
goto	O
error_free_vers	O
;	O
memcpy	function
(	O
shortname	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
amt	long
)	O
;	O
shortname	pointer
[	O
amt	long
]	O
=	O
'\0'	O
;	O
hi	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bfd_link_hash_lookup	function
(	O
&	O
htab	struct
->	O
root	struct
,	O
shortname	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
hi	pointer
!=	O
NULL	O
&&	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
h	pointer
->	O
root	struct
.	O
type	enum
&&	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
==	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
&&	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
{	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
hi	pointer
,	O
TRUE	int
)	O
;	O
hi	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_indirect	int
;	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_copy_indirect_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
hi	pointer
)	O
;	O
sym_hash	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
sym_hash	pointer
)	O
for	O
(	O
symidx	long
=	O
0	int
;	O
symidx	long
<	O
extsymcount	long
;	O
++	O
symidx	long
)	O
if	O
(	O
sym_hash	pointer
[	O
symidx	long
]	O
==	O
hi	pointer
)	O
{	O
sym_hash	pointer
[	O
symidx	long
]	O
=	O
h	pointer
;	O
break	O
;	O
}	O
}	O
free	function
(	O
shortname	pointer
)	O
;	O
}	O
free	function
(	O
nondeflt_vers	pointer
)	O
;	O
nondeflt_vers	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
weaks	pointer
!=	O
NULL	O
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
hpp	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
hppend	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sorted_sym_hash	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
size_t	long
sym_count	long
;	O
amt	long
=	O
extsymcount	long
;	O
amt	long
*=	O
sizeof	O
(	O
*	O
sorted_sym_hash	pointer
)	O
;	O
sorted_sym_hash	pointer
=	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
sorted_sym_hash	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
sym_hash	pointer
=	O
sorted_sym_hash	pointer
;	O
hpp	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
hppend	pointer
=	O
hpp	pointer
+	O
extsymcount	long
;	O
sym_count	long
=	O
0	int
;	O
for	O
(	O
;	O
hpp	pointer
<	O
hppend	pointer
;	O
hpp	pointer
++	O
)	O
{	O
h	pointer
=	O
*	O
hpp	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
!	O
bed	pointer
->	O
is_function_type	pointer
(	O
h	pointer
->	O
type	enum
)	O
)	O
{	O
*	O
sym_hash	pointer
=	O
h	pointer
;	O
sym_hash	pointer
++	O
;	O
sym_count	long
++	O
;	O
}	O
}	O
qsort	function
(	O
sorted_sym_hash	pointer
,	O
sym_count	long
,	O
sizeof	O
(	O
*	O
sorted_sym_hash	pointer
)	O
,	O
elf_sort_symbol	function
)	O
;	O
while	O
(	O
weaks	pointer
!=	O
NULL	O
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
hlook	pointer
;	O
asection	struct
*	O
slook	pointer
;	O
bfd_vma	long
vlook	long
;	O
size_t	long
i	pointer
,	O
j	long
,	O
idx	int
=	O
0	int
;	O
hlook	pointer
=	O
weaks	pointer
;	O
weaks	pointer
=	O
hlook	pointer
->	O
u	union
.	O
alias	pointer
;	O
hlook	pointer
->	O
u	union
.	O
alias	pointer
=	O
NULL	O
;	O
if	O
(	O
hlook	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
hlook	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
continue	O
;	O
slook	pointer
=	O
hlook	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
vlook	long
=	O
hlook	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
i	pointer
=	O
0	int
;	O
j	long
=	O
sym_count	long
;	O
while	O
(	O
i	pointer
!=	O
j	long
)	O
{	O
bfd_signed_vma	long
vdiff	long
;	O
idx	int
=	O
(	O
i	pointer
+	O
j	long
)	O
/	O
2	int
;	O
h	pointer
=	O
sorted_sym_hash	pointer
[	O
idx	int
]	O
;	O
vdiff	long
=	O
vlook	long
-	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
if	O
(	O
vdiff	long
<	O
0	int
)	O
j	long
=	O
idx	int
;	O
else	O
if	O
(	O
vdiff	long
>	O
0	int
)	O
i	pointer
=	O
idx	int
+	O
1	int
;	O
else	O
{	O
int	O
sdiff	int
=	O
slook	pointer
->	O
id	int
-	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
id	int
;	O
if	O
(	O
sdiff	int
<	O
0	int
)	O
j	long
=	O
idx	int
;	O
else	O
if	O
(	O
sdiff	int
>	O
0	int
)	O
i	pointer
=	O
idx	int
+	O
1	int
;	O
else	O
break	O
;	O
}	O
}	O
if	O
(	O
i	pointer
==	O
j	long
)	O
continue	O
;	O
while	O
(	O
++	O
idx	int
!=	O
j	long
)	O
{	O
h	pointer
=	O
sorted_sym_hash	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
slook	pointer
||	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
!=	O
vlook	long
)	O
break	O
;	O
}	O
while	O
(	O
idx	int
--	O
!=	O
i	pointer
)	O
{	O
h	pointer
=	O
sorted_sym_hash	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
slook	pointer
||	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
!=	O
vlook	long
)	O
break	O
;	O
else	O
if	O
(	O
h	pointer
!=	O
hlook	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
t	pointer
;	O
hlook	pointer
->	O
u	union
.	O
alias	pointer
=	O
h	pointer
;	O
hlook	pointer
->	O
is_weakalias	int
=	O
1	int
;	O
t	pointer
=	O
h	pointer
;	O
if	O
(	O
t	pointer
->	O
u	union
.	O
alias	pointer
!=	O
NULL	O
)	O
while	O
(	O
t	pointer
->	O
u	union
.	O
alias	pointer
!=	O
h	pointer
)	O
t	pointer
=	O
t	pointer
->	O
u	union
.	O
alias	pointer
;	O
t	pointer
->	O
u	union
.	O
alias	pointer
=	O
hlook	pointer
;	O
if	O
(	O
hlook	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
err_free_sym_hash	O
:	O
free	function
(	O
sorted_sym_hash	pointer
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
hlook	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
hlook	pointer
)	O
)	O
goto	O
err_free_sym_hash	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
free	function
(	O
sorted_sym_hash	pointer
)	O
;	O
}	O
if	O
(	O
bed	pointer
->	O
check_directives	pointer
&&	O
!	O
(	O
*	O
bed	pointer
->	O
check_directives	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
dynamic	int
&&	O
!	O
info	pointer
->	O
traditional_format	int
&&	O
is_elf_hash_table	O
(	O
htab	struct
)	O
&&	O
(	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
&&	O
info	pointer
->	O
strip	enum
!=	O
strip_debugger	int
)	O
)	O
{	O
asection	struct
*	O
stabstr	pointer
;	O
stabstr	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".stabstr"	pointer
)	O
;	O
if	O
(	O
stabstr	pointer
!=	O
NULL	O
)	O
{	O
bfd_size_type	long
string_offset	long
=	O
0	int
;	O
asection	struct
*	O
stab	pointer
;	O
for	O
(	O
stab	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
stab	pointer
;	O
stab	pointer
=	O
stab	pointer
->	O
next	pointer
)	O
if	O
(	O
CONST_STRNEQ	O
(	O
stab	pointer
->	O
name	pointer
,	O
".stab"	pointer
)	O
&&	O
(	O
!	O
stab	pointer
->	O
name	pointer
[	O
5	int
]	O
||	O
(	O
stab	pointer
->	O
name	pointer
[	O
5	int
]	O
==	O
'.'	O
&&	O
ISDIGIT	O
(	O
stab	pointer
->	O
name	pointer
[	O
6	int
]	O
)	O
)	O
)	O
&&	O
(	O
stab	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
==	O
0	int
&&	O
!	O
bfd_is_abs_section	function
(	O
stab	pointer
->	O
output_section	pointer
)	O
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
secdata	pointer
;	O
secdata	pointer
=	O
elf_section_data	O
(	O
stab	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_link_section_stabs	function
(	O
abfd	pointer
,	O
&	O
htab	struct
->	O
stab_info	struct
,	O
stab	pointer
,	O
stabstr	pointer
,	O
&	O
secdata	pointer
->	O
sec_info	pointer
,	O
&	O
string_offset	long
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
secdata	pointer
->	O
sec_info	pointer
)	O
stab	pointer
->	O
sec_info_type	int
=	O
SEC_INFO_TYPE_STABS	int
;	O
}	O
}	O
}	O
if	O
(	O
is_elf_hash_table	O
(	O
htab	struct
)	O
&&	O
add_needed	int
)	O
{	O
struct	O
elf_link_loaded_list	struct
*	O
n	long
;	O
n	long
=	O
(	O
struct	O
elf_link_loaded_list	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
n	long
)	O
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
n	long
->	O
abfd	pointer
=	O
abfd	pointer
;	O
n	long
->	O
next	pointer
=	O
htab	struct
->	O
loaded	pointer
;	O
htab	struct
->	O
loaded	pointer
=	O
n	long
;	O
}	O
return	O
TRUE	int
;	O
error_free_vers	O
:	O
if	O
(	O
old_tab	pointer
!=	O
NULL	O
)	O
free	function
(	O
old_tab	pointer
)	O
;	O
if	O
(	O
old_strtab	pointer
!=	O
NULL	O
)	O
free	function
(	O
old_strtab	pointer
)	O
;	O
if	O
(	O
nondeflt_vers	pointer
!=	O
NULL	O
)	O
free	function
(	O
nondeflt_vers	pointer
)	O
;	O
if	O
(	O
extversym	pointer
!=	O
NULL	O
)	O
free	function
(	O
extversym	pointer
)	O
;	O
error_free_sym	O
:	O
if	O
(	O
isymbuf	pointer
!=	O
NULL	O
)	O
free	function
(	O
isymbuf	pointer
)	O
;	O
error_return	O
:	O
return	O
FALSE	int
;	O
}	O
struct	O
elf_link_hash_entry	struct
*	O
_bfd_elf_archive_symbol_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
copy	int
;	O
size_t	long
len	long
,	O
first	long
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
return	O
h	pointer
;	O
p	pointer
=	O
strchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
p	pointer
[	O
1	int
]	O
!=	O
ELF_VER_CHR	char
)	O
return	O
h	pointer
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
copy	int
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
copy	int
==	O
NULL	O
)	O
return	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
-	O
1	int
;	O
first	long
=	O
p	pointer
-	O
name	pointer
+	O
1	int
;	O
memcpy	function
(	O
copy	int
,	O
name	pointer
,	O
first	long
)	O
;	O
memcpy	function
(	O
copy	int
+	O
first	long
,	O
name	pointer
+	O
first	long
+	O
1	int
,	O
len	long
-	O
first	long
)	O
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
copy	int
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
copy	int
[	O
first	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
copy	int
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
}	O
bfd_release	function
(	O
abfd	pointer
,	O
copy	int
)	O
;	O
return	O
h	pointer
;	O
}	O
static	O
bfd_boolean	int
elf_link_add_archive_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
symindex	long
c	struct
;	O
unsigned	O
char	O
*	O
included	pointer
=	O
NULL	O
;	O
carsym	struct
*	O
symdefs	pointer
;	O
bfd_boolean	int
loop	int
;	O
bfd_size_type	long
amt	long
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
(	O
*	O
archive_symbol_lookup	pointer
)	O
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
const	O
char	O
*	O
)	O
;	O
if	O
(	O
!	O
bfd_has_map	function
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
bfd_openr_next_archived_file	function
(	O
abfd	pointer
,	O
NULL	O
)	O
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
bfd_set_error	function
(	O
bfd_error_no_armap	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
c	struct
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdef_count	long
;	O
if	O
(	O
c	struct
==	O
0	int
)	O
return	O
TRUE	int
;	O
amt	long
=	O
c	struct
;	O
amt	long
*=	O
sizeof	O
(	O
*	O
included	pointer
)	O
;	O
included	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zmalloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
included	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
symdefs	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdefs	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
archive_symbol_lookup	pointer
=	O
bed	pointer
->	O
elf_backend_archive_symbol_lookup	pointer
;	O
do	O
{	O
file_ptr	long
last	long
;	O
symindex	long
i	pointer
;	O
carsym	struct
*	O
symdef	pointer
;	O
carsym	struct
*	O
symdefend	pointer
;	O
loop	int
=	O
FALSE	int
;	O
last	long
=	O
-	O
1	int
;	O
symdef	pointer
=	O
symdefs	pointer
;	O
symdefend	pointer
=	O
symdef	pointer
+	O
c	struct
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
symdef	pointer
<	O
symdefend	pointer
;	O
symdef	pointer
++	O
,	O
i	pointer
++	O
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
bfd	struct
*	O
element	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
undefs_tail	pointer
;	O
symindex	long
mark	int
;	O
if	O
(	O
included	pointer
[	O
i	pointer
]	O
)	O
continue	O
;	O
if	O
(	O
symdef	pointer
->	O
file_offset	long
==	O
last	long
)	O
{	O
included	pointer
[	O
i	pointer
]	O
=	O
TRUE	int
;	O
continue	O
;	O
}	O
h	pointer
=	O
archive_symbol_lookup	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
symdef	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
h	pointer
==	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
-	O
1	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
{	O
if	O
(	O
!	O
elf_link_is_defined_archive_symbol	function
(	O
abfd	pointer
,	O
symdef	pointer
)	O
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefined	int
)	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
)	O
included	pointer
[	O
i	pointer
]	O
=	O
TRUE	int
;	O
continue	O
;	O
}	O
element	pointer
=	O
_bfd_get_elt_at_filepos	function
(	O
abfd	pointer
,	O
symdef	pointer
->	O
file_offset	long
)	O
;	O
if	O
(	O
element	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
element	pointer
,	O
bfd_object	int
)	O
)	O
goto	O
error_return	O
;	O
undefs_tail	pointer
=	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
;	O
if	O
(	O
!	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
add_archive_element	pointer
)	O
(	O
info	pointer
,	O
element	pointer
,	O
symdef	pointer
->	O
name	pointer
,	O
&	O
element	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
bfd_link_add_symbols	O
(	O
element	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
undefs_tail	pointer
!=	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
)	O
loop	int
=	O
TRUE	int
;	O
mark	int
=	O
i	pointer
;	O
do	O
{	O
included	pointer
[	O
mark	int
]	O
=	O
TRUE	int
;	O
if	O
(	O
mark	int
==	O
0	int
)	O
break	O
;	O
--	O
mark	int
;	O
}	O
while	O
(	O
symdefs	pointer
[	O
mark	int
]	O
.	O
file_offset	long
==	O
symdef	pointer
->	O
file_offset	long
)	O
;	O
last	long
=	O
symdef	pointer
->	O
file_offset	long
;	O
}	O
}	O
while	O
(	O
loop	int
)	O
;	O
free	function
(	O
included	pointer
)	O
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
included	pointer
!=	O
NULL	O
)	O
free	function
(	O
included	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
bfd_elf_link_add_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
switch	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_object	int
:	O
return	O
elf_link_add_object_symbols	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
case	O
bfd_archive	int
:	O
return	O
elf_link_add_archive_symbols	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
default	O
:	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
struct	O
hash_codes_info	struct
{	O
unsigned	O
long	O
*	O
hashcodes	pointer
;	O
bfd_boolean	int
error	int
;	O
}	O
;	O
static	O
bfd_boolean	int
elf_collect_hash_codes	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
hash_codes_info	struct
*	O
inf	pointer
=	O
(	O
struct	O
hash_codes_info	struct
*	O
)	O
data	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
long	O
ha	long
;	O
char	O
*	O
alc	pointer
=	O
NULL	O
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
if	O
(	O
h	pointer
->	O
versioned	int
>=	O
versioned	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
alc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
p	pointer
-	O
name	pointer
+	O
1	int
)	O
;	O
if	O
(	O
alc	pointer
==	O
NULL	O
)	O
{	O
inf	pointer
->	O
error	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
memcpy	function
(	O
alc	pointer
,	O
name	pointer
,	O
p	pointer
-	O
name	pointer
)	O
;	O
alc	pointer
[	O
p	pointer
-	O
name	pointer
]	O
=	O
'\0'	O
;	O
name	pointer
=	O
alc	pointer
;	O
}	O
}	O
ha	long
=	O
bfd_elf_hash	function
(	O
name	pointer
)	O
;	O
*	O
(	O
inf	pointer
->	O
hashcodes	pointer
)	O
++	O
=	O
ha	long
;	O
h	pointer
->	O
u	union
.	O
elf_hash_value	long
=	O
ha	long
;	O
if	O
(	O
alc	pointer
!=	O
NULL	O
)	O
free	function
(	O
alc	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
struct	O
collect_gnu_hash_codes	struct
{	O
bfd	struct
*	O
output_bfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
long	O
int	O
nsyms	int
;	O
unsigned	O
long	O
int	O
maskbits	long
;	O
unsigned	O
long	O
int	O
*	O
hashcodes	pointer
;	O
unsigned	O
long	O
int	O
*	O
hashval	pointer
;	O
unsigned	O
long	O
int	O
*	O
indx	long
;	O
unsigned	O
long	O
int	O
*	O
counts	pointer
;	O
bfd_vma	long
*	O
bitmask	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
bfd_size_type	long
xlat	long
;	O
long	O
int	O
min_dynindx	long
;	O
unsigned	O
long	O
int	O
bucketcount	long
;	O
unsigned	O
long	O
int	O
symindx	long
;	O
long	O
int	O
local_indx	long
;	O
long	O
int	O
shift1	long
,	O
shift2	long
;	O
unsigned	O
long	O
int	O
mask	int
;	O
bfd_boolean	int
error	int
;	O
}	O
;	O
static	O
bfd_boolean	int
elf_collect_gnu_hash_codes	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
collect_gnu_hash_codes	struct
*	O
s	pointer
=	O
(	O
struct	O
collect_gnu_hash_codes	struct
*	O
)	O
data	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
long	O
ha	long
;	O
char	O
*	O
alc	pointer
=	O
NULL	O
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
*	O
s	pointer
->	O
bed	pointer
->	O
elf_hash_symbol	pointer
)	O
(	O
h	pointer
)	O
)	O
return	O
TRUE	int
;	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
if	O
(	O
h	pointer
->	O
versioned	int
>=	O
versioned	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
name	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
alc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
p	pointer
-	O
name	pointer
+	O
1	int
)	O
;	O
if	O
(	O
alc	pointer
==	O
NULL	O
)	O
{	O
s	pointer
->	O
error	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
memcpy	function
(	O
alc	pointer
,	O
name	pointer
,	O
p	pointer
-	O
name	pointer
)	O
;	O
alc	pointer
[	O
p	pointer
-	O
name	pointer
]	O
=	O
'\0'	O
;	O
name	pointer
=	O
alc	pointer
;	O
}	O
}	O
ha	long
=	O
bfd_elf_gnu_hash	function
(	O
name	pointer
)	O
;	O
s	pointer
->	O
hashcodes	pointer
[	O
s	pointer
->	O
nsyms	int
]	O
=	O
ha	long
;	O
s	pointer
->	O
hashval	pointer
[	O
h	pointer
->	O
dynindx	long
]	O
=	O
ha	long
;	O
++	O
s	pointer
->	O
nsyms	int
;	O
if	O
(	O
s	pointer
->	O
min_dynindx	long
<	O
0	int
||	O
s	pointer
->	O
min_dynindx	long
>	O
h	pointer
->	O
dynindx	long
)	O
s	pointer
->	O
min_dynindx	long
=	O
h	pointer
->	O
dynindx	long
;	O
if	O
(	O
alc	pointer
!=	O
NULL	O
)	O
free	function
(	O
alc	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_gnu_hash_process_symidx	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
collect_gnu_hash_codes	struct
*	O
s	pointer
=	O
(	O
struct	O
collect_gnu_hash_codes	struct
*	O
)	O
data	pointer
;	O
unsigned	O
long	O
int	O
bucket	long
;	O
unsigned	O
long	O
int	O
val	array
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
*	O
s	pointer
->	O
bed	pointer
->	O
elf_hash_symbol	pointer
)	O
(	O
h	pointer
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
dynindx	long
>=	O
s	pointer
->	O
min_dynindx	long
)	O
{	O
if	O
(	O
s	pointer
->	O
bed	pointer
->	O
record_xhash_symbol	pointer
!=	O
NULL	O
)	O
{	O
(	O
*	O
s	pointer
->	O
bed	pointer
->	O
record_xhash_symbol	pointer
)	O
(	O
h	pointer
,	O
0	int
)	O
;	O
s	pointer
->	O
local_indx	long
++	O
;	O
}	O
else	O
h	pointer
->	O
dynindx	long
=	O
s	pointer
->	O
local_indx	long
++	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bucket	long
=	O
s	pointer
->	O
hashval	pointer
[	O
h	pointer
->	O
dynindx	long
]	O
%	O
s	pointer
->	O
bucketcount	long
;	O
val	array
=	O
(	O
s	pointer
->	O
hashval	pointer
[	O
h	pointer
->	O
dynindx	long
]	O
>>	O
s	pointer
->	O
shift1	long
)	O
&	O
(	O
(	O
s	pointer
->	O
maskbits	long
>>	O
s	pointer
->	O
shift1	long
)	O
-	O
1	int
)	O
;	O
s	pointer
->	O
bitmask	pointer
[	O
val	array
]	O
|=	O
(	O
(	O
bfd_vma	long
)	O
1	int
)	O
<<	O
(	O
s	pointer
->	O
hashval	pointer
[	O
h	pointer
->	O
dynindx	long
]	O
&	O
s	pointer
->	O
mask	int
)	O
;	O
s	pointer
->	O
bitmask	pointer
[	O
val	array
]	O
|=	O
(	O
(	O
bfd_vma	long
)	O
1	int
)	O
<<	O
(	O
(	O
s	pointer
->	O
hashval	pointer
[	O
h	pointer
->	O
dynindx	long
]	O
>>	O
s	pointer
->	O
shift2	long
)	O
&	O
s	pointer
->	O
mask	int
)	O
;	O
val	array
=	O
s	pointer
->	O
hashval	pointer
[	O
h	pointer
->	O
dynindx	long
]	O
&	O
~	O
(	O
unsigned	O
long	O
int	O
)	O
1	int
;	O
if	O
(	O
s	pointer
->	O
counts	pointer
[	O
bucket	long
]	O
==	O
1	int
)	O
val	array
|=	O
1	int
;	O
bfd_put_32	O
(	O
s	pointer
->	O
output_bfd	pointer
,	O
val	array
,	O
s	pointer
->	O
contents	pointer
+	O
(	O
s	pointer
->	O
indx	long
[	O
bucket	long
]	O
-	O
s	pointer
->	O
symindx	long
)	O
*	O
4	int
)	O
;	O
--	O
s	pointer
->	O
counts	pointer
[	O
bucket	long
]	O
;	O
if	O
(	O
s	pointer
->	O
bed	pointer
->	O
record_xhash_symbol	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
xlat_loc	long
=	O
s	pointer
->	O
xlat	long
+	O
(	O
s	pointer
->	O
indx	long
[	O
bucket	long
]	O
++	O
-	O
s	pointer
->	O
symindx	long
)	O
*	O
4	int
;	O
(	O
*	O
s	pointer
->	O
bed	pointer
->	O
record_xhash_symbol	pointer
)	O
(	O
h	pointer
,	O
xlat_loc	long
)	O
;	O
}	O
else	O
h	pointer
->	O
dynindx	long
=	O
s	pointer
->	O
indx	long
[	O
bucket	long
]	O
++	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_hash_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
return	O
!	O
(	O
h	pointer
->	O
forced_local	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
)	O
;	O
}	O
static	O
const	O
size_t	long
elf_buckets	array
[	O
]	O
=	O
{	O
1	int
,	O
3	int
,	O
17	int
,	O
37	int
,	O
67	int
,	O
97	int
,	O
131	int
,	O
197	int
,	O
263	int
,	O
521	int
,	O
1031	int
,	O
2053	int
,	O
4099	int
,	O
8209	int
,	O
16411	int
,	O
32771	int
,	O
0	int
}	O
;	O
static	O
size_t	long
compute_bucket_count	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
long	O
int	O
*	O
hashcodes	pointer
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
long	O
int	O
nsyms	int
,	O
int	O
gnu_hash	int
)	O
{	O
size_t	long
best_size	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
i	pointer
;	O
if	O
(	O
info	pointer
->	O
optimize	int
)	O
{	O
size_t	long
minsize	long
;	O
size_t	long
maxsize	long
;	O
BFD_HOST_U_64_BIT	O
best_chlen	long
=	O
~	O
(	O
(	O
BFD_HOST_U_64_BIT	O
)	O
0	int
)	O
;	O
bfd	struct
*	O
dynobj	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynobj	pointer
;	O
size_t	long
dynsymcount	int
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynsymcount	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
dynobj	pointer
)	O
;	O
unsigned	O
long	O
int	O
*	O
counts	pointer
;	O
bfd_size_type	long
amt	long
;	O
unsigned	O
int	O
no_improvement_count	int
=	O
0	int
;	O
minsize	long
=	O
nsyms	int
/	O
4	int
;	O
if	O
(	O
minsize	long
==	O
0	int
)	O
minsize	long
=	O
1	int
;	O
best_size	long
=	O
maxsize	long
=	O
nsyms	int
*	O
2	int
;	O
if	O
(	O
gnu_hash	int
)	O
{	O
if	O
(	O
minsize	long
<	O
2	int
)	O
minsize	long
=	O
2	int
;	O
if	O
(	O
(	O
best_size	long
&	O
31	int
)	O
==	O
0	int
)	O
++	O
best_size	long
;	O
}	O
amt	long
=	O
maxsize	long
;	O
amt	long
*=	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
;	O
counts	pointer
=	O
(	O
unsigned	O
long	O
int	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
counts	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
for	O
(	O
i	pointer
=	O
minsize	long
;	O
i	pointer
<	O
maxsize	long
;	O
++	O
i	pointer
)	O
{	O
BFD_HOST_U_64_BIT	O
max	long
;	O
unsigned	O
long	O
int	O
j	long
;	O
unsigned	O
long	O
int	O
fact	long
;	O
if	O
(	O
gnu_hash	int
&&	O
(	O
i	pointer
&	O
31	int
)	O
==	O
0	int
)	O
continue	O
;	O
memset	function
(	O
counts	pointer
,	O
'\0'	O
,	O
i	pointer
*	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nsyms	int
;	O
++	O
j	long
)	O
++	O
counts	pointer
[	O
hashcodes	pointer
[	O
j	long
]	O
%	O
i	pointer
]	O
;	O
max	long
=	O
(	O
2	int
+	O
dynsymcount	int
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_hash_entry	char
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
i	pointer
;	O
++	O
j	long
)	O
max	long
+=	O
counts	pointer
[	O
j	long
]	O
*	O
counts	pointer
[	O
j	long
]	O
;	O
fact	long
=	O
i	pointer
/	O
(	O
BFD_TARGET_PAGESIZE	O
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_hash_entry	char
)	O
+	O
1	int
;	O
max	long
*=	O
fact	long
*	O
fact	long
;	O
if	O
(	O
max	long
<	O
best_chlen	long
)	O
{	O
best_chlen	long
=	O
max	long
;	O
best_size	long
=	O
i	pointer
;	O
no_improvement_count	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
++	O
no_improvement_count	int
==	O
100	int
)	O
break	O
;	O
}	O
free	function
(	O
counts	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
elf_buckets	array
[	O
i	pointer
]	O
!=	O
0	int
;	O
i	pointer
++	O
)	O
{	O
best_size	long
=	O
elf_buckets	array
[	O
i	pointer
]	O
;	O
if	O
(	O
nsyms	int
<	O
elf_buckets	array
[	O
i	pointer
+	O
1	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
gnu_hash	int
&&	O
best_size	long
<	O
2	int
)	O
best_size	long
=	O
2	int
;	O
}	O
return	O
best_size	long
;	O
}	O
bfd_boolean	int
_bfd_elf_size_group_sections	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
ibfd	pointer
;	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
!=	O
NULL	O
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
s	pointer
=	O
ibfd	pointer
->	O
sections	pointer
)	O
!=	O
NULL	O
&&	O
s	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_JUST_SYMS	int
&&	O
!	O
_bfd_elf_fixup_group_sections	function
(	O
ibfd	pointer
,	O
bfd_abs_section_ptr	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_stack_segment_size	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
legacy_symbol	pointer
,	O
bfd_vma	long
default_size	long
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
NULL	O
;	O
if	O
(	O
legacy_symbol	pointer
)	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
legacy_symbol	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h	pointer
->	O
def_regular	int
&&	O
(	O
h	pointer
->	O
type	enum
==	O
STT_NOTYPE	int
||	O
h	pointer
->	O
type	enum
==	O
STT_OBJECT	int
)	O
)	O
{	O
h	pointer
->	O
type	enum
=	O
STT_OBJECT	int
;	O
if	O
(	O
info	pointer
->	O
stacksize	long
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: stack size specified and %s set"	pointer
)	O
,	O
output_bfd	pointer
,	O
legacy_symbol	pointer
)	O
;	O
else	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %s not absolute"	pointer
)	O
,	O
output_bfd	pointer
,	O
legacy_symbol	pointer
)	O
;	O
else	O
info	pointer
->	O
stacksize	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
}	O
if	O
(	O
!	O
info	pointer
->	O
stacksize	long
)	O
info	pointer
->	O
stacksize	long
=	O
default_size	long
;	O
if	O
(	O
h	pointer
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
output_bfd	pointer
,	O
legacy_symbol	pointer
,	O
BSF_GLOBAL	O
,	O
bfd_abs_section_ptr	O
,	O
info	pointer
->	O
stacksize	long
>=	O
0	int
?	O
info	pointer
->	O
stacksize	long
:	O
0	int
,	O
NULL	O
,	O
FALSE	int
,	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
->	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
type	enum
=	O
STT_OBJECT	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
struct	O
elf_gc_sweep_symbol_info	struct
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
void	O
(	O
*	O
hide_symbol	pointer
)	O
(	O
struct	O
bfd_link_info	struct
*	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
,	O
bfd_boolean	int
)	O
;	O
}	O
;	O
static	O
bfd_boolean	int
elf_gc_sweep_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
mark	int
&&	O
(	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
!	O
(	O
(	O
h	pointer
->	O
def_regular	int
||	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
&&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
gc_mark	int
)	O
)	O
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
)	O
{	O
struct	O
elf_gc_sweep_symbol_info	struct
*	O
inf	pointer
;	O
inf	pointer
=	O
(	O
struct	O
elf_gc_sweep_symbol_info	struct
*	O
)	O
data	pointer
;	O
(	O
*	O
inf	pointer
->	O
hide_symbol	pointer
)	O
(	O
inf	pointer
->	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
h	pointer
->	O
def_regular	int
=	O
0	int
;	O
h	pointer
->	O
ref_regular	int
=	O
0	int
;	O
h	pointer
->	O
ref_regular_nonweak	int
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_size_dynamic_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
const	O
char	O
*	O
soname	pointer
,	O
const	O
char	O
*	O
rpath	pointer
,	O
const	O
char	O
*	O
filter_shlib	pointer
,	O
const	O
char	O
*	O
audit	pointer
,	O
const	O
char	O
*	O
depaudit	pointer
,	O
const	O
char	O
*	O
const	O
*	O
auxiliary_filters	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
*	O
sinterpptr	pointer
)	O
{	O
bfd	struct
*	O
dynobj	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
*	O
sinterpptr	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
TRUE	int
;	O
dynobj	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynobj	pointer
;	O
if	O
(	O
dynobj	pointer
!=	O
NULL	O
&&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
verdefs	pointer
;	O
struct	O
elf_info_failed	struct
asvinfo	struct
;	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
;	O
struct	O
bfd_elf_version_expr	struct
*	O
d	double
;	O
asection	struct
*	O
s	pointer
;	O
size_t	long
soname_indx	long
;	O
if	O
(	O
info	pointer
->	O
export_dynamic	int
||	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
info	pointer
->	O
dynamic	int
)	O
)	O
{	O
struct	O
elf_info_failed	struct
eif	pointer
;	O
eif	pointer
.	O
info	pointer
=	O
info	pointer
;	O
eif	pointer
.	O
failed	int
=	O
FALSE	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_elf_export_symbol	function
,	O
&	O
eif	pointer
)	O
;	O
if	O
(	O
eif	pointer
.	O
failed	int
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
soname	pointer
!=	O
NULL	O
)	O
{	O
soname_indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
soname	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
soname_indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_SONAME	int
,	O
soname_indx	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
soname_indx	long
=	O
(	O
size_t	long
)	O
-	O
1	int
;	O
for	O
(	O
t	pointer
=	O
info	pointer
->	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
for	O
(	O
d	double
=	O
t	pointer
->	O
globals	struct
.	O
list	pointer
;	O
d	double
!=	O
NULL	O
;	O
d	double
=	O
d	double
->	O
next	pointer
)	O
if	O
(	O
!	O
d	double
->	O
symver	int
&&	O
d	double
->	O
literal	int
)	O
{	O
const	O
char	O
*	O
verstr	pointer
,	O
*	O
name	pointer
;	O
size_t	long
namelen	long
,	O
verlen	long
,	O
newlen	long
;	O
char	O
*	O
newname	pointer
,	O
*	O
p	pointer
,	O
leading_char	char
;	O
struct	O
elf_link_hash_entry	struct
*	O
newh	pointer
;	O
leading_char	char
=	O
bfd_get_symbol_leading_char	function
(	O
output_bfd	pointer
)	O
;	O
name	pointer
=	O
d	double
->	O
pattern	pointer
;	O
namelen	long
=	O
strlen	function
(	O
name	pointer
)	O
+	O
(	O
leading_char	char
!=	O
'\0'	O
)	O
;	O
verstr	pointer
=	O
t	pointer
->	O
name	pointer
;	O
verlen	long
=	O
strlen	function
(	O
verstr	pointer
)	O
;	O
newlen	long
=	O
namelen	long
+	O
verlen	long
+	O
3	int
;	O
newname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
newlen	long
)	O
;	O
if	O
(	O
newname	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
newname	pointer
[	O
0	int
]	O
=	O
leading_char	char
;	O
memcpy	function
(	O
newname	pointer
+	O
(	O
leading_char	char
!=	O
'\0'	O
)	O
,	O
name	pointer
,	O
namelen	long
)	O
;	O
p	pointer
=	O
newname	pointer
+	O
namelen	long
;	O
*	O
p	pointer
++	O
=	O
ELF_VER_CHR	char
;	O
memcpy	function
(	O
p	pointer
,	O
verstr	pointer
,	O
verlen	long
+	O
1	int
)	O
;	O
newh	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
newname	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
newh	pointer
==	O
NULL	O
||	O
(	O
newh	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
newh	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
)	O
{	O
*	O
p	pointer
++	O
=	O
ELF_VER_CHR	char
;	O
memcpy	function
(	O
p	pointer
,	O
verstr	pointer
,	O
verlen	long
+	O
1	int
)	O
;	O
newh	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
newname	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
}	O
free	function
(	O
newname	pointer
)	O
;	O
if	O
(	O
newh	pointer
!=	O
NULL	O
&&	O
!	O
newh	pointer
->	O
def_dynamic	int
&&	O
(	O
newh	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
newh	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
d	double
->	O
symver	int
=	O
1	int
;	O
}	O
asvinfo	struct
.	O
info	pointer
=	O
info	pointer
;	O
asvinfo	struct
.	O
failed	int
=	O
FALSE	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_elf_link_assign_sym_version	function
,	O
&	O
asvinfo	struct
)	O
;	O
if	O
(	O
asvinfo	struct
.	O
failed	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
info	pointer
->	O
allow_undefined_version	int
)	O
{	O
bfd_boolean	int
all_defined	int
=	O
TRUE	int
;	O
for	O
(	O
t	pointer
=	O
info	pointer
->	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
for	O
(	O
d	double
=	O
t	pointer
->	O
globals	struct
.	O
list	pointer
;	O
d	double
!=	O
NULL	O
;	O
d	double
=	O
d	double
->	O
next	pointer
)	O
if	O
(	O
d	double
->	O
literal	int
&&	O
!	O
d	double
->	O
symver	int
&&	O
!	O
d	double
->	O
script	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%s: undefined version: %s"	pointer
)	O
,	O
d	double
->	O
pattern	pointer
,	O
t	pointer
->	O
name	pointer
)	O
;	O
all_defined	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
all_defined	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version_d"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
verdefs	pointer
=	O
info	pointer
->	O
version_info	pointer
;	O
if	O
(	O
verdefs	pointer
!=	O
NULL	O
&&	O
verdefs	pointer
->	O
vernum	int
==	O
0	int
)	O
verdefs	pointer
=	O
verdefs	pointer
->	O
next	pointer
;	O
if	O
(	O
verdefs	pointer
==	O
NULL	O
&&	O
!	O
info	pointer
->	O
create_default_symver	int
)	O
s	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
else	O
{	O
unsigned	O
int	O
cdefs	int
;	O
bfd_size_type	long
size	long
;	O
bfd_byte	char
*	O
p	pointer
;	O
Elf_Internal_Verdef	struct
def	struct
;	O
Elf_Internal_Verdaux	struct
defaux	struct
;	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
cdefs	int
=	O
0	int
;	O
size	long
=	O
0	int
;	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
++	O
cdefs	int
;	O
if	O
(	O
info	pointer
->	O
create_default_symver	int
)	O
{	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
++	O
cdefs	int
;	O
}	O
for	O
(	O
t	pointer
=	O
verdefs	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_version_deps	struct
*	O
n	long
;	O
if	O
(	O
t	pointer
->	O
vernum	int
==	O
0	int
)	O
continue	O
;	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
++	O
cdefs	int
;	O
for	O
(	O
n	long
=	O
t	pointer
->	O
deps	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
}	O
s	pointer
->	O
size	long
=	O
size	long
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_alloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
s	pointer
->	O
contents	pointer
==	O
NULL	O
&&	O
s	pointer
->	O
size	long
!=	O
0	int
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
s	pointer
->	O
contents	pointer
;	O
def	struct
.	O
vd_version	array
=	O
VER_DEF_CURRENT	int
;	O
def	struct
.	O
vd_flags	array
=	O
VER_FLG_BASE	int
;	O
def	struct
.	O
vd_ndx	array
=	O
1	int
;	O
def	struct
.	O
vd_cnt	array
=	O
1	int
;	O
if	O
(	O
info	pointer
->	O
create_default_symver	int
)	O
{	O
def	struct
.	O
vd_aux	array
=	O
2	int
*	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
def	struct
.	O
vd_next	array
=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
}	O
else	O
{	O
def	struct
.	O
vd_aux	array
=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
def	struct
.	O
vd_next	array
=	O
(	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
+	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
)	O
;	O
}	O
if	O
(	O
soname_indx	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
_bfd_elf_strtab_addref	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
soname_indx	long
)	O
;	O
def	struct
.	O
vd_hash	array
=	O
bfd_elf_hash	function
(	O
soname	pointer
)	O
;	O
defaux	struct
.	O
vda_name	array
=	O
soname_indx	long
;	O
name	pointer
=	O
soname	pointer
;	O
}	O
else	O
{	O
size_t	long
indx	long
;	O
name	pointer
=	O
lbasename	function
(	O
output_bfd	pointer
->	O
filename	pointer
)	O
;	O
def	struct
.	O
vd_hash	array
=	O
bfd_elf_hash	function
(	O
name	pointer
)	O
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
defaux	struct
.	O
vda_name	array
=	O
indx	long
;	O
}	O
defaux	struct
.	O
vda_next	array
=	O
0	int
;	O
_bfd_elf_swap_verdef_out	function
(	O
output_bfd	pointer
,	O
&	O
def	struct
,	O
(	O
Elf_External_Verdef	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
if	O
(	O
info	pointer
->	O
create_default_symver	int
)	O
{	O
bh	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
dynobj	pointer
,	O
name	pointer
,	O
BSF_GLOBAL	O
,	O
bfd_abs_section_ptr	O
,	O
0	int
,	O
NULL	O
,	O
FALSE	int
,	O
get_elf_backend_data	O
(	O
dynobj	pointer
)	O
->	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
h	pointer
->	O
non_elf	int
=	O
0	int
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
type	enum
=	O
STT_OBJECT	int
;	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
def	struct
.	O
vd_flags	array
=	O
0	int
;	O
def	struct
.	O
vd_ndx	array
=	O
2	int
;	O
def	struct
.	O
vd_aux	array
=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
if	O
(	O
verdefs	pointer
)	O
def	struct
.	O
vd_next	array
=	O
(	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
+	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
)	O
;	O
else	O
def	struct
.	O
vd_next	array
=	O
0	int
;	O
_bfd_elf_swap_verdef_out	function
(	O
output_bfd	pointer
,	O
&	O
def	struct
,	O
(	O
Elf_External_Verdef	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
}	O
_bfd_elf_swap_verdaux_out	function
(	O
output_bfd	pointer
,	O
&	O
defaux	struct
,	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
for	O
(	O
t	pointer
=	O
verdefs	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
int	O
cdeps	int
;	O
struct	O
bfd_elf_version_deps	struct
*	O
n	long
;	O
if	O
(	O
t	pointer
->	O
vernum	int
==	O
0	int
)	O
continue	O
;	O
cdeps	int
=	O
0	int
;	O
for	O
(	O
n	long
=	O
t	pointer
->	O
deps	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
++	O
cdeps	int
;	O
bh	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
dynobj	pointer
,	O
t	pointer
->	O
name	pointer
,	O
BSF_GLOBAL	O
,	O
bfd_abs_section_ptr	O
,	O
0	int
,	O
NULL	O
,	O
FALSE	int
,	O
get_elf_backend_data	O
(	O
dynobj	pointer
)	O
->	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
h	pointer
->	O
non_elf	int
=	O
0	int
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
type	enum
=	O
STT_OBJECT	int
;	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
=	O
t	pointer
;	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
def	struct
.	O
vd_version	array
=	O
VER_DEF_CURRENT	int
;	O
def	struct
.	O
vd_flags	array
=	O
0	int
;	O
if	O
(	O
t	pointer
->	O
globals	struct
.	O
list	pointer
==	O
NULL	O
&&	O
t	pointer
->	O
locals	struct
.	O
list	pointer
==	O
NULL	O
&&	O
!	O
t	pointer
->	O
used	int
)	O
def	struct
.	O
vd_flags	array
|=	O
VER_FLG_WEAK	int
;	O
def	struct
.	O
vd_ndx	array
=	O
t	pointer
->	O
vernum	int
+	O
(	O
info	pointer
->	O
create_default_symver	int
?	O
2	int
:	O
1	int
)	O
;	O
def	struct
.	O
vd_cnt	array
=	O
cdeps	int
+	O
1	int
;	O
def	struct
.	O
vd_hash	array
=	O
bfd_elf_hash	function
(	O
t	pointer
->	O
name	pointer
)	O
;	O
def	struct
.	O
vd_aux	array
=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
def	struct
.	O
vd_next	array
=	O
0	int
;	O
if	O
(	O
t	pointer
->	O
next	pointer
!=	O
NULL	O
&&	O
t	pointer
->	O
next	pointer
->	O
vernum	int
==	O
0	int
)	O
BFD_ASSERT	O
(	O
t	pointer
->	O
next	pointer
->	O
next	pointer
==	O
NULL	O
)	O
;	O
if	O
(	O
t	pointer
->	O
next	pointer
!=	O
NULL	O
&&	O
t	pointer
->	O
next	pointer
->	O
vernum	int
!=	O
0	int
)	O
def	struct
.	O
vd_next	array
=	O
(	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
+	O
(	O
cdeps	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
)	O
;	O
_bfd_elf_swap_verdef_out	function
(	O
output_bfd	pointer
,	O
&	O
def	struct
,	O
(	O
Elf_External_Verdef	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
defaux	struct
.	O
vda_name	array
=	O
h	pointer
->	O
dynstr_index	long
;	O
_bfd_elf_strtab_addref	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
h	pointer
->	O
dynstr_index	long
)	O
;	O
defaux	struct
.	O
vda_next	array
=	O
0	int
;	O
if	O
(	O
t	pointer
->	O
deps	pointer
!=	O
NULL	O
)	O
defaux	struct
.	O
vda_next	array
=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
t	pointer
->	O
name_indx	int
=	O
defaux	struct
.	O
vda_name	array
;	O
_bfd_elf_swap_verdaux_out	function
(	O
output_bfd	pointer
,	O
&	O
defaux	struct
,	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
for	O
(	O
n	long
=	O
t	pointer
->	O
deps	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
{	O
if	O
(	O
n	long
->	O
version_needed	pointer
==	O
NULL	O
)	O
{	O
defaux	struct
.	O
vda_name	array
=	O
0	int
;	O
}	O
else	O
{	O
defaux	struct
.	O
vda_name	array
=	O
n	long
->	O
version_needed	pointer
->	O
name_indx	int
;	O
_bfd_elf_strtab_addref	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
defaux	struct
.	O
vda_name	array
)	O
;	O
}	O
if	O
(	O
n	long
->	O
next	pointer
==	O
NULL	O
)	O
defaux	struct
.	O
vda_next	array
=	O
0	int
;	O
else	O
defaux	struct
.	O
vda_next	array
=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
_bfd_elf_swap_verdaux_out	function
(	O
output_bfd	pointer
,	O
&	O
defaux	struct
,	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
}	O
}	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverdefs	int
=	O
cdefs	int
;	O
}	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
if	O
(	O
info	pointer
->	O
gc_sections	int
&&	O
bed	pointer
->	O
can_gc_sections	int
)	O
{	O
struct	O
elf_gc_sweep_symbol_info	struct
sweep_info	struct
;	O
sweep_info	struct
.	O
info	pointer
=	O
info	pointer
;	O
sweep_info	struct
.	O
hide_symbol	pointer
=	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_gc_sweep_symbol	function
,	O
&	O
sweep_info	struct
)	O
;	O
}	O
if	O
(	O
dynobj	pointer
!=	O
NULL	O
&&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
struct	O
elf_find_verdep_info	struct
sinfo	pointer
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version_r"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
sinfo	pointer
.	O
info	pointer
=	O
info	pointer
;	O
sinfo	pointer
.	O
vers	int
=	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverdefs	int
;	O
if	O
(	O
sinfo	pointer
.	O
vers	int
==	O
0	int
)	O
sinfo	pointer
.	O
vers	int
=	O
1	int
;	O
sinfo	pointer
.	O
failed	int
=	O
FALSE	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_elf_link_find_version_dependencies	function
,	O
&	O
sinfo	pointer
)	O
;	O
if	O
(	O
sinfo	pointer
.	O
failed	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
verref	pointer
==	O
NULL	O
)	O
s	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
else	O
{	O
Elf_Internal_Verneed	struct
*	O
vn	pointer
;	O
unsigned	O
int	O
size	long
;	O
unsigned	O
int	O
crefs	int
;	O
bfd_byte	char
*	O
p	pointer
;	O
size	long
=	O
0	int
;	O
crefs	int
=	O
0	int
;	O
for	O
(	O
vn	pointer
=	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
verref	pointer
;	O
vn	pointer
!=	O
NULL	O
;	O
vn	pointer
=	O
vn	pointer
->	O
vn_nextref	pointer
)	O
{	O
Elf_Internal_Vernaux	struct
*	O
a	pointer
;	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
;	O
++	O
crefs	int
;	O
for	O
(	O
a	pointer
=	O
vn	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
size	long
+=	O
sizeof	O
(	O
Elf_External_Vernaux	struct
)	O
;	O
}	O
s	pointer
->	O
size	long
=	O
size	long
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_alloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
s	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
s	pointer
->	O
contents	pointer
;	O
for	O
(	O
vn	pointer
=	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
verref	pointer
;	O
vn	pointer
!=	O
NULL	O
;	O
vn	pointer
=	O
vn	pointer
->	O
vn_nextref	pointer
)	O
{	O
unsigned	O
int	O
caux	int
;	O
Elf_Internal_Vernaux	struct
*	O
a	pointer
;	O
size_t	long
indx	long
;	O
caux	int
=	O
0	int
;	O
for	O
(	O
a	pointer
=	O
vn	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
++	O
caux	int
;	O
vn	pointer
->	O
vn_version	array
=	O
VER_NEED_CURRENT	int
;	O
vn	pointer
->	O
vn_cnt	array
=	O
caux	int
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
elf_dt_name	O
(	O
vn	pointer
->	O
vn_bfd	pointer
)	O
!=	O
NULL	O
?	O
elf_dt_name	O
(	O
vn	pointer
->	O
vn_bfd	pointer
)	O
:	O
lbasename	function
(	O
vn	pointer
->	O
vn_bfd	pointer
->	O
filename	pointer
)	O
,	O
FALSE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
vn	pointer
->	O
vn_file	array
=	O
indx	long
;	O
vn	pointer
->	O
vn_aux	array
=	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
;	O
if	O
(	O
vn	pointer
->	O
vn_nextref	pointer
==	O
NULL	O
)	O
vn	pointer
->	O
vn_next	array
=	O
0	int
;	O
else	O
vn	pointer
->	O
vn_next	array
=	O
(	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
+	O
caux	int
*	O
sizeof	O
(	O
Elf_External_Vernaux	struct
)	O
)	O
;	O
_bfd_elf_swap_verneed_out	function
(	O
output_bfd	pointer
,	O
vn	pointer
,	O
(	O
Elf_External_Verneed	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
;	O
for	O
(	O
a	pointer
=	O
vn	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
{	O
a	pointer
->	O
vna_hash	array
=	O
bfd_elf_hash	function
(	O
a	pointer
->	O
vna_nodename	pointer
)	O
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
a	pointer
->	O
vna_nodename	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
a	pointer
->	O
vna_name	array
=	O
indx	long
;	O
if	O
(	O
a	pointer
->	O
vna_nextptr	pointer
==	O
NULL	O
)	O
a	pointer
->	O
vna_next	array
=	O
0	int
;	O
else	O
a	pointer
->	O
vna_next	array
=	O
sizeof	O
(	O
Elf_External_Vernaux	struct
)	O
;	O
_bfd_elf_swap_vernaux_out	function
(	O
output_bfd	pointer
,	O
a	pointer
,	O
(	O
Elf_External_Vernaux	struct
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf_External_Vernaux	struct
)	O
;	O
}	O
}	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverrefs	int
=	O
crefs	int
;	O
}	O
}	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
init_got_refcount	union
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
init_got_offset	union
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
init_plt_refcount	union
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
init_plt_offset	union
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
!	O
_bfd_elf_size_group_sections	function
(	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_always_size_sections	pointer
&&	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_always_size_sections	pointer
)	O
(	O
output_bfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
execstack	int
)	O
elf_stack_flags	O
(	O
output_bfd	pointer
)	O
=	O
PF_R	O
|	O
PF_W	O
|	O
PF_X	O
;	O
else	O
if	O
(	O
info	pointer
->	O
noexecstack	int
)	O
elf_stack_flags	O
(	O
output_bfd	pointer
)	O
=	O
PF_R	O
|	O
PF_W	O
;	O
else	O
{	O
bfd	struct
*	O
inputobj	pointer
;	O
asection	struct
*	O
notesec	pointer
=	O
NULL	O
;	O
int	O
exec	int
=	O
0	int
;	O
for	O
(	O
inputobj	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
inputobj	pointer
;	O
inputobj	pointer
=	O
inputobj	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
if	O
(	O
inputobj	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
|	O
BFD_PLUGIN	int
|	O
BFD_LINKER_CREATED	int
)	O
)	O
continue	O
;	O
s	pointer
=	O
inputobj	pointer
->	O
sections	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
s	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
inputobj	pointer
,	O
".note.GNU-stack"	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
exec	int
=	O
PF_X	O
;	O
notesec	pointer
=	O
s	pointer
;	O
}	O
else	O
if	O
(	O
bed	pointer
->	O
default_execstack	int
)	O
exec	int
=	O
PF_X	O
;	O
}	O
if	O
(	O
notesec	pointer
||	O
info	pointer
->	O
stacksize	long
>	O
0	int
)	O
elf_stack_flags	O
(	O
output_bfd	pointer
)	O
=	O
PF_R	O
|	O
PF_W	O
|	O
exec	int
;	O
if	O
(	O
notesec	pointer
&&	O
exec	int
&&	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
notesec	pointer
->	O
output_section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
notesec	pointer
->	O
output_section	pointer
->	O
flags	int
|=	O
SEC_CODE	int
;	O
}	O
if	O
(	O
dynobj	pointer
!=	O
NULL	O
&&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
{	O
struct	O
elf_info_failed	struct
eif	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
asection	struct
*	O
dynstr	pointer
;	O
asection	struct
*	O
s	pointer
;	O
*	O
sinterpptr	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".interp"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
*	O
sinterpptr	pointer
!=	O
NULL	O
||	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
info	pointer
->	O
nointerp	int
)	O
;	O
if	O
(	O
info	pointer
->	O
symbolic	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_SYMBOLIC	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
info	pointer
->	O
flags	int
|=	O
DF_SYMBOLIC	O
;	O
}	O
if	O
(	O
rpath	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
indx	long
;	O
bfd_vma	long
tag	int
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
rpath	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
tag	int
=	O
info	pointer
->	O
new_dtags	int
?	O
DT_RUNPATH	int
:	O
DT_RPATH	int
;	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
tag	int
,	O
indx	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
filter_shlib	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
indx	long
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
filter_shlib	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_FILTER	int
,	O
indx	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
auxiliary_filters	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
const	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
auxiliary_filters	pointer
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
{	O
size_t	long
indx	long
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
*	O
p	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_AUXILIARY	int
,	O
indx	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
audit	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
indx	long
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
audit	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_AUDIT	int
,	O
indx	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
depaudit	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
indx	long
;	O
indx	long
=	O
_bfd_elf_strtab_add	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
depaudit	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_DEPAUDIT	int
,	O
indx	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
eif	pointer
.	O
info	pointer
=	O
info	pointer
;	O
eif	pointer
.	O
failed	int
=	O
FALSE	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_elf_adjust_dynamic_symbol	function
,	O
&	O
eif	pointer
)	O
;	O
if	O
(	O
eif	pointer
.	O
failed	int
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
(	O
info	pointer
->	O
init_function	pointer
?	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
info	pointer
->	O
init_function	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
ref_regular	int
||	O
h	pointer
->	O
def_regular	int
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_INIT	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
h	pointer
=	O
(	O
info	pointer
->	O
fini_function	pointer
?	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
info	pointer
->	O
fini_function	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
ref_regular	int
||	O
h	pointer
->	O
def_regular	int
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_FINI	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".preinit_array"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
linker_has_input	int
)	O
{	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
bfd	struct
*	O
sub	pointer
;	O
asection	struct
*	O
o	pointer
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
)	O
!=	O
NULL	O
&&	O
o	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
for	O
(	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
if	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_PREINIT_ARRAY	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: .preinit_array section is not allowed in DSO"	pointer
)	O
,	O
sub	pointer
)	O
;	O
break	O
;	O
}	O
bfd_set_error	function
(	O
bfd_error_nonrepresentable_section	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_PREINIT_ARRAY	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_PREINIT_ARRAYSZ	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".init_array"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
linker_has_input	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_INIT_ARRAY	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_INIT_ARRAYSZ	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".fini_array"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
linker_has_input	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_FINI_ARRAY	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_FINI_ARRAYSZ	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
dynstr	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".dynstr"	pointer
)	O
;	O
if	O
(	O
dynstr	pointer
!=	O
NULL	O
&&	O
dynstr	pointer
->	O
output_section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
{	O
bfd_size_type	long
strsize	long
;	O
strsize	long
=	O
_bfd_elf_strtab_size	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
)	O
;	O
if	O
(	O
(	O
info	pointer
->	O
emit_hash	int
&&	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_HASH	int
,	O
0	int
)	O
)	O
||	O
(	O
info	pointer
->	O
emit_gnu_hash	int
&&	O
(	O
bed	pointer
->	O
record_xhash_symbol	pointer
==	O
NULL	O
&&	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_GNU_HASH	int
,	O
0	int
)	O
)	O
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_STRTAB	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_SYMTAB	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_STRSZ	int
,	O
strsize	long
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_SYMENT	int
,	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
_bfd_elf_maybe_strip_eh_frame_hdr	function
(	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
dynobj	pointer
!=	O
NULL	O
&&	O
bed	pointer
->	O
elf_backend_size_dynamic_sections	pointer
!=	O
NULL	O
&&	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_size_dynamic_sections	pointer
)	O
(	O
output_bfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
dynobj	pointer
!=	O
NULL	O
&&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
{	O
if	O
(	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverdefs	int
)	O
{	O
unsigned	O
int	O
crefs	int
=	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverdefs	int
;	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VERDEF	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VERDEFNUM	int
,	O
crefs	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
info	pointer
->	O
new_dtags	int
&&	O
info	pointer
->	O
flags	int
)	O
||	O
(	O
info	pointer
->	O
flags	int
&	O
DF_STATIC_TLS	O
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_FLAGS	int
,	O
info	pointer
->	O
flags	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
info	pointer
->	O
flags	int
&	O
DF_BIND_NOW	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_BIND_NOW	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
flags_1	long
)	O
{	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
info	pointer
->	O
flags_1	long
&=	O
~	O
(	O
DF_1_INITFIRST	int
|	O
DF_1_NODELETE	int
|	O
DF_1_NOOPEN	int
)	O
;	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_FLAGS_1	int
,	O
info	pointer
->	O
flags_1	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverrefs	int
)	O
{	O
unsigned	O
int	O
crefs	int
=	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverrefs	int
;	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VERNEED	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VERNEEDNUM	int
,	O
crefs	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverrefs	int
==	O
0	int
&&	O
elf_tdata	O
(	O
output_bfd	pointer
)	O
->	O
cverdefs	int
==	O
0	int
)	O
||	O
_bfd_elf_link_renumber_dynsyms	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
NULL	O
)	O
<=	O
1	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version"	pointer
)	O
;	O
s	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_elf_init_1_index_section	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
asection	struct
*	O
found	pointer
=	O
NULL	O
;	O
for	O
(	O
s	pointer
=	O
output_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_EXCLUDE	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
SEC_ALLOC	int
&&	O
!	O
_bfd_elf_omit_section_dynsym_default	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
s	pointer
)	O
)	O
{	O
found	pointer
=	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
text_index_section	pointer
=	O
found	pointer
;	O
}	O
void	O
_bfd_elf_init_2_index_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
asection	struct
*	O
found	pointer
=	O
NULL	O
;	O
for	O
(	O
s	pointer
=	O
output_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_EXCLUDE	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
SEC_ALLOC	int
&&	O
!	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
&&	O
!	O
_bfd_elf_omit_section_dynsym_default	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
s	pointer
)	O
)	O
{	O
found	pointer
=	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
data_index_section	pointer
=	O
found	pointer
;	O
for	O
(	O
s	pointer
=	O
output_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_EXCLUDE	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
SEC_ALLOC	int
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
&&	O
!	O
_bfd_elf_omit_section_dynsym_default	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
s	pointer
)	O
)	O
{	O
found	pointer
=	O
s	pointer
;	O
break	O
;	O
}	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
text_index_section	pointer
=	O
found	pointer
;	O
}	O
bfd_boolean	int
bfd_elf_size_dynsym_hash_dynstr	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
long	O
section_sym_count	pointer
;	O
bfd_size_type	long
dynsymcount	int
=	O
0	int
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
TRUE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_init_index_section	pointer
)	O
(	O
output_bfd	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
||	O
bed	pointer
->	O
always_renumber_dynsyms	int
)	O
dynsymcount	int
=	O
_bfd_elf_link_renumber_dynsyms	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
&	O
section_sym_count	pointer
)	O
;	O
if	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
{	O
bfd	struct
*	O
dynobj	pointer
;	O
asection	struct
*	O
s	pointer
;	O
unsigned	O
int	O
dtagcount	int
;	O
dynobj	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynobj	pointer
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
)	O
{	O
s	pointer
->	O
size	long
=	O
dynsymcount	int
*	O
sizeof	O
(	O
Elf_External_Versym	struct
)	O
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
s	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VERSYM	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynsym	pointer
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
s	pointer
->	O
size	long
=	O
dynsymcount	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_alloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
s	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
++	O
section_sym_count	pointer
;	O
memset	function
(	O
s	pointer
->	O
contents	pointer
,	O
0	int
,	O
section_sym_count	pointer
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
bucketcount	long
=	O
0	int
;	O
if	O
(	O
info	pointer
->	O
emit_hash	int
)	O
{	O
unsigned	O
long	O
int	O
*	O
hashcodes	pointer
;	O
struct	O
hash_codes_info	struct
hashinf	struct
;	O
bfd_size_type	long
amt	long
;	O
unsigned	O
long	O
int	O
nsyms	int
;	O
size_t	long
bucketcount	long
;	O
size_t	long
hash_entry_size	long
;	O
amt	long
=	O
dynsymcount	int
*	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
;	O
hashcodes	pointer
=	O
(	O
unsigned	O
long	O
int	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
hashcodes	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
hashinf	struct
.	O
hashcodes	pointer
=	O
hashcodes	pointer
;	O
hashinf	struct
.	O
error	int
=	O
FALSE	int
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_collect_hash_codes	function
,	O
&	O
hashinf	struct
)	O
;	O
if	O
(	O
hashinf	struct
.	O
error	int
)	O
{	O
free	function
(	O
hashcodes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
nsyms	int
=	O
hashinf	struct
.	O
hashcodes	pointer
-	O
hashcodes	pointer
;	O
bucketcount	long
=	O
compute_bucket_count	function
(	O
info	pointer
,	O
hashcodes	pointer
,	O
nsyms	int
,	O
0	int
)	O
;	O
free	function
(	O
hashcodes	pointer
)	O
;	O
if	O
(	O
bucketcount	long
==	O
0	int
&&	O
nsyms	int
>	O
0	int
)	O
return	O
FALSE	int
;	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
bucketcount	long
=	O
bucketcount	long
;	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".hash"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
hash_entry_size	long
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
;	O
s	pointer
->	O
size	long
=	O
(	O
(	O
2	int
+	O
bucketcount	long
+	O
dynsymcount	int
)	O
*	O
hash_entry_size	long
)	O
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
s	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
bfd_put	O
(	O
8	int
*	O
hash_entry_size	long
,	O
output_bfd	pointer
,	O
bucketcount	long
,	O
s	pointer
->	O
contents	pointer
)	O
;	O
bfd_put	O
(	O
8	int
*	O
hash_entry_size	long
,	O
output_bfd	pointer
,	O
dynsymcount	int
,	O
s	pointer
->	O
contents	pointer
+	O
hash_entry_size	long
)	O
;	O
}	O
if	O
(	O
info	pointer
->	O
emit_gnu_hash	int
)	O
{	O
size_t	long
i	pointer
,	O
cnt	long
;	O
unsigned	O
char	O
*	O
contents	pointer
;	O
struct	O
collect_gnu_hash_codes	struct
cinfo	struct
;	O
bfd_size_type	long
amt	long
;	O
size_t	long
bucketcount	long
;	O
memset	function
(	O
&	O
cinfo	struct
,	O
0	int
,	O
sizeof	O
(	O
cinfo	struct
)	O
)	O
;	O
amt	long
=	O
dynsymcount	int
*	O
2	int
*	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
;	O
cinfo	struct
.	O
hashcodes	pointer
=	O
(	O
long	O
unsigned	O
int	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
cinfo	struct
.	O
hashcodes	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
cinfo	struct
.	O
hashval	pointer
=	O
cinfo	struct
.	O
hashcodes	pointer
+	O
dynsymcount	int
;	O
cinfo	struct
.	O
min_dynindx	long
=	O
-	O
1	int
;	O
cinfo	struct
.	O
output_bfd	pointer
=	O
output_bfd	pointer
;	O
cinfo	struct
.	O
bed	pointer
=	O
bed	pointer
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_collect_gnu_hash_codes	function
,	O
&	O
cinfo	struct
)	O
;	O
if	O
(	O
cinfo	struct
.	O
error	int
)	O
{	O
free	function
(	O
cinfo	struct
.	O
hashcodes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
bucketcount	long
=	O
compute_bucket_count	function
(	O
info	pointer
,	O
cinfo	struct
.	O
hashcodes	pointer
,	O
cinfo	struct
.	O
nsyms	int
,	O
1	int
)	O
;	O
if	O
(	O
bucketcount	long
==	O
0	int
)	O
{	O
free	function
(	O
cinfo	struct
.	O
hashcodes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
GNU_HASH_SECTION_NAME	O
(	O
bed	pointer
)	O
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
cinfo	struct
.	O
nsyms	int
==	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
cinfo	struct
.	O
min_dynindx	long
==	O
-	O
1	int
)	O
;	O
free	function
(	O
cinfo	struct
.	O
hashcodes	pointer
)	O
;	O
s	pointer
->	O
size	long
=	O
5	int
*	O
4	int
+	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
/	O
8	int
;	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
s	pointer
->	O
contents	pointer
=	O
contents	pointer
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
1	int
,	O
contents	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
1	int
,	O
contents	pointer
+	O
4	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
1	int
,	O
contents	pointer
+	O
8	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
contents	pointer
+	O
12	int
)	O
;	O
bfd_put	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
,	O
output_bfd	pointer
,	O
0	int
,	O
contents	pointer
+	O
16	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
contents	pointer
+	O
16	int
+	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
/	O
8	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
long	O
int	O
maskwords	long
,	O
maskbitslog2	long
,	O
x	long
;	O
BFD_ASSERT	O
(	O
cinfo	struct
.	O
min_dynindx	long
!=	O
-	O
1	int
)	O
;	O
x	long
=	O
cinfo	struct
.	O
nsyms	int
;	O
maskbitslog2	long
=	O
1	int
;	O
while	O
(	O
(	O
x	long
>>=	O
1	int
)	O
!=	O
0	int
)	O
++	O
maskbitslog2	long
;	O
if	O
(	O
maskbitslog2	long
<	O
3	int
)	O
maskbitslog2	long
=	O
5	int
;	O
else	O
if	O
(	O
(	O
1	int
<<	O
(	O
maskbitslog2	long
-	O
2	int
)	O
)	O
&	O
cinfo	struct
.	O
nsyms	int
)	O
maskbitslog2	long
=	O
maskbitslog2	long
+	O
3	int
;	O
else	O
maskbitslog2	long
=	O
maskbitslog2	long
+	O
2	int
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
64	int
)	O
{	O
if	O
(	O
maskbitslog2	long
==	O
5	int
)	O
maskbitslog2	long
=	O
6	int
;	O
cinfo	struct
.	O
shift1	long
=	O
6	int
;	O
}	O
else	O
cinfo	struct
.	O
shift1	long
=	O
5	int
;	O
cinfo	struct
.	O
mask	int
=	O
(	O
1	int
<<	O
cinfo	struct
.	O
shift1	long
)	O
-	O
1	int
;	O
cinfo	struct
.	O
shift2	long
=	O
maskbitslog2	long
;	O
cinfo	struct
.	O
maskbits	long
=	O
1	int
<<	O
maskbitslog2	long
;	O
maskwords	long
=	O
1	int
<<	O
(	O
maskbitslog2	long
-	O
cinfo	struct
.	O
shift1	long
)	O
;	O
amt	long
=	O
bucketcount	long
*	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
*	O
2	int
;	O
amt	long
+=	O
maskwords	long
*	O
sizeof	O
(	O
bfd_vma	long
)	O
;	O
cinfo	struct
.	O
bitmask	pointer
=	O
(	O
bfd_vma	long
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
cinfo	struct
.	O
bitmask	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
cinfo	struct
.	O
hashcodes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
cinfo	struct
.	O
counts	pointer
=	O
(	O
long	O
unsigned	O
int	O
*	O
)	O
(	O
cinfo	struct
.	O
bitmask	pointer
+	O
maskwords	long
)	O
;	O
cinfo	struct
.	O
indx	long
=	O
cinfo	struct
.	O
counts	pointer
+	O
bucketcount	long
;	O
cinfo	struct
.	O
symindx	long
=	O
dynsymcount	int
-	O
cinfo	struct
.	O
nsyms	int
;	O
memset	function
(	O
cinfo	struct
.	O
bitmask	pointer
,	O
0	int
,	O
maskwords	long
*	O
sizeof	O
(	O
bfd_vma	long
)	O
)	O
;	O
memset	function
(	O
cinfo	struct
.	O
counts	pointer
,	O
0	int
,	O
bucketcount	long
*	O
sizeof	O
(	O
cinfo	struct
.	O
counts	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
cinfo	struct
.	O
nsyms	int
;	O
++	O
i	pointer
)	O
++	O
cinfo	struct
.	O
counts	pointer
[	O
cinfo	struct
.	O
hashcodes	pointer
[	O
i	pointer
]	O
%	O
bucketcount	long
]	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
cnt	long
=	O
cinfo	struct
.	O
symindx	long
;	O
i	pointer
<	O
bucketcount	long
;	O
++	O
i	pointer
)	O
if	O
(	O
cinfo	struct
.	O
counts	pointer
[	O
i	pointer
]	O
!=	O
0	int
)	O
{	O
cinfo	struct
.	O
indx	long
[	O
i	pointer
]	O
=	O
cnt	long
;	O
cnt	long
+=	O
cinfo	struct
.	O
counts	pointer
[	O
i	pointer
]	O
;	O
}	O
BFD_ASSERT	O
(	O
cnt	long
==	O
dynsymcount	int
)	O
;	O
cinfo	struct
.	O
bucketcount	long
=	O
bucketcount	long
;	O
cinfo	struct
.	O
local_indx	long
=	O
cinfo	struct
.	O
min_dynindx	long
;	O
s	pointer
->	O
size	long
=	O
(	O
4	int
+	O
bucketcount	long
+	O
cinfo	struct
.	O
nsyms	int
)	O
*	O
4	int
;	O
s	pointer
->	O
size	long
+=	O
cinfo	struct
.	O
maskbits	long
/	O
8	int
;	O
if	O
(	O
bed	pointer
->	O
record_xhash_symbol	pointer
!=	O
NULL	O
)	O
s	pointer
->	O
size	long
+=	O
cinfo	struct
.	O
nsyms	int
*	O
4	int
;	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
output_bfd	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
cinfo	struct
.	O
bitmask	pointer
)	O
;	O
free	function
(	O
cinfo	struct
.	O
hashcodes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
s	pointer
->	O
contents	pointer
=	O
contents	pointer
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
bucketcount	long
,	O
contents	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
cinfo	struct
.	O
symindx	long
,	O
contents	pointer
+	O
4	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
maskwords	long
,	O
contents	pointer
+	O
8	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
cinfo	struct
.	O
shift2	long
,	O
contents	pointer
+	O
12	int
)	O
;	O
contents	pointer
+=	O
16	int
+	O
cinfo	struct
.	O
maskbits	long
/	O
8	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
bucketcount	long
;	O
++	O
i	pointer
)	O
{	O
if	O
(	O
cinfo	struct
.	O
counts	pointer
[	O
i	pointer
]	O
==	O
0	int
)	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
contents	pointer
)	O
;	O
else	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
cinfo	struct
.	O
indx	long
[	O
i	pointer
]	O
,	O
contents	pointer
)	O
;	O
contents	pointer
+=	O
4	int
;	O
}	O
cinfo	struct
.	O
contents	pointer
=	O
contents	pointer
;	O
cinfo	struct
.	O
xlat	long
=	O
contents	pointer
+	O
cinfo	struct
.	O
nsyms	int
*	O
4	int
-	O
s	pointer
->	O
contents	pointer
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_gnu_hash_process_symidx	function
,	O
&	O
cinfo	struct
)	O
;	O
contents	pointer
=	O
s	pointer
->	O
contents	pointer
+	O
16	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
maskwords	long
;	O
++	O
i	pointer
)	O
{	O
bfd_put	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
,	O
output_bfd	pointer
,	O
cinfo	struct
.	O
bitmask	pointer
[	O
i	pointer
]	O
,	O
contents	pointer
)	O
;	O
contents	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
/	O
8	int
;	O
}	O
free	function
(	O
cinfo	struct
.	O
bitmask	pointer
)	O
;	O
free	function
(	O
cinfo	struct
.	O
hashcodes	pointer
)	O
;	O
}	O
}	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".dynstr"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
elf_finalize_dynstr	function
(	O
output_bfd	pointer
,	O
info	pointer
)	O
;	O
s	pointer
->	O
size	long
=	O
_bfd_elf_strtab_size	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
)	O
;	O
for	O
(	O
dtagcount	int
=	O
0	int
;	O
dtagcount	int
<=	O
info	pointer
->	O
spare_dynamic_tags	int
;	O
++	O
dtagcount	int
)	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_NULL	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
merge_sections_remove_hook	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
BFD_ASSERT	O
(	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_MERGE	int
)	O
;	O
sec	pointer
->	O
sec_info_type	int
=	O
SEC_INFO_TYPE_NONE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_merge_sections	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
ibfd	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
!=	O
NULL	O
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
(	O
ibfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
&&	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
)	O
)	O
for	O
(	O
sec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
&&	O
!	O
bfd_is_abs_section	function
(	O
sec	pointer
->	O
output_section	pointer
)	O
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
secdata	pointer
;	O
secdata	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_add_merge_section	function
(	O
obfd	pointer
,	O
&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
merge_info	pointer
,	O
sec	pointer
,	O
&	O
secdata	pointer
->	O
sec_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
else	O
if	O
(	O
secdata	pointer
->	O
sec_info	pointer
)	O
sec	pointer
->	O
sec_info_type	int
=	O
SEC_INFO_TYPE_MERGE	int
;	O
}	O
if	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
merge_info	pointer
!=	O
NULL	O
)	O
_bfd_merge_sections	pointer
(	O
obfd	pointer
,	O
info	pointer
,	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
merge_info	pointer
,	O
merge_sections_remove_hook	function
)	O
;	O
return	O
TRUE	int
;	O
}	O
struct	O
bfd_hash_entry	struct
*	O
_bfd_elf_link_hash_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
entry	pointer
=	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
elf_link_hash_entry	struct
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
entry	pointer
;	O
}	O
entry	pointer
=	O
_bfd_link_hash_newfunc	function
(	O
entry	pointer
,	O
table	pointer
,	O
string	pointer
)	O
;	O
if	O
(	O
entry	pointer
!=	O
NULL	O
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
ret	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
entry	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
(	O
struct	O
elf_link_hash_table	struct
*	O
)	O
table	pointer
;	O
ret	pointer
->	O
indx	long
=	O
-	O
1	int
;	O
ret	pointer
->	O
dynindx	long
=	O
-	O
1	int
;	O
ret	pointer
->	O
got	union
=	O
htab	struct
->	O
init_got_refcount	union
;	O
ret	pointer
->	O
plt	union
=	O
htab	struct
->	O
init_plt_refcount	union
;	O
memset	function
(	O
&	O
ret	pointer
->	O
size	long
,	O
0	int
,	O
(	O
sizeof	O
(	O
struct	O
elf_link_hash_entry	struct
)	O
-	O
offsetof	O
(	O
struct	O
elf_link_hash_entry	struct
,	O
size	long
)	O
)	O
)	O
;	O
ret	pointer
->	O
non_elf	int
=	O
1	int
;	O
}	O
return	O
entry	pointer
;	O
}	O
void	O
_bfd_elf_link_hash_copy_indirect	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
dir	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
ind	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
if	O
(	O
dir	pointer
->	O
versioned	int
!=	O
versioned_hidden	int
)	O
dir	pointer
->	O
ref_dynamic	int
|=	O
ind	pointer
->	O
ref_dynamic	int
;	O
dir	pointer
->	O
ref_regular	int
|=	O
ind	pointer
->	O
ref_regular	int
;	O
dir	pointer
->	O
ref_regular_nonweak	int
|=	O
ind	pointer
->	O
ref_regular_nonweak	int
;	O
dir	pointer
->	O
non_got_ref	int
|=	O
ind	pointer
->	O
non_got_ref	int
;	O
dir	pointer
->	O
needs_plt	int
|=	O
ind	pointer
->	O
needs_plt	int
;	O
dir	pointer
->	O
pointer_equality_needed	int
|=	O
ind	pointer
->	O
pointer_equality_needed	int
;	O
if	O
(	O
ind	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_indirect	int
)	O
return	O
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
ind	pointer
->	O
got	union
.	O
refcount	int
>	O
htab	struct
->	O
init_got_refcount	union
.	O
refcount	int
)	O
{	O
if	O
(	O
dir	pointer
->	O
got	union
.	O
refcount	int
<	O
0	int
)	O
dir	pointer
->	O
got	union
.	O
refcount	int
=	O
0	int
;	O
dir	pointer
->	O
got	union
.	O
refcount	int
+=	O
ind	pointer
->	O
got	union
.	O
refcount	int
;	O
ind	pointer
->	O
got	union
.	O
refcount	int
=	O
htab	struct
->	O
init_got_refcount	union
.	O
refcount	int
;	O
}	O
if	O
(	O
ind	pointer
->	O
plt	union
.	O
refcount	int
>	O
htab	struct
->	O
init_plt_refcount	union
.	O
refcount	int
)	O
{	O
if	O
(	O
dir	pointer
->	O
plt	union
.	O
refcount	int
<	O
0	int
)	O
dir	pointer
->	O
plt	union
.	O
refcount	int
=	O
0	int
;	O
dir	pointer
->	O
plt	union
.	O
refcount	int
+=	O
ind	pointer
->	O
plt	union
.	O
refcount	int
;	O
ind	pointer
->	O
plt	union
.	O
refcount	int
=	O
htab	struct
->	O
init_plt_refcount	union
.	O
refcount	int
;	O
}	O
if	O
(	O
ind	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
dir	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
_bfd_elf_strtab_delref	function
(	O
htab	struct
->	O
dynstr	pointer
,	O
dir	pointer
->	O
dynstr_index	long
)	O
;	O
dir	pointer
->	O
dynindx	long
=	O
ind	pointer
->	O
dynindx	long
;	O
dir	pointer
->	O
dynstr_index	long
=	O
ind	pointer
->	O
dynstr_index	long
;	O
ind	pointer
->	O
dynindx	long
=	O
-	O
1	int
;	O
ind	pointer
->	O
dynstr_index	long
=	O
0	int
;	O
}	O
}	O
void	O
_bfd_elf_link_hash_hide_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_boolean	int
force_local	int
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
STT_GNU_IFUNC	int
)	O
{	O
h	pointer
->	O
plt	union
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
init_plt_offset	union
;	O
h	pointer
->	O
needs_plt	int
=	O
0	int
;	O
}	O
if	O
(	O
force_local	int
)	O
{	O
h	pointer
->	O
forced_local	int
=	O
1	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
{	O
_bfd_elf_strtab_delref	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
h	pointer
->	O
dynstr_index	long
)	O
;	O
h	pointer
->	O
dynindx	long
=	O
-	O
1	int
;	O
h	pointer
->	O
dynstr_index	long
=	O
0	int
;	O
}	O
}	O
}	O
void	O
_bfd_elf_link_hide_symbol	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
struct	O
elf_link_hash_entry	struct
*	O
eh	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
(	O
info	pointer
,	O
eh	pointer
,	O
TRUE	int
)	O
;	O
eh	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
eh	pointer
->	O
ref_dynamic	int
=	O
0	int
;	O
eh	pointer
->	O
dynamic_def	int
=	O
0	int
;	O
}	O
}	O
bfd_boolean	int
_bfd_elf_link_hash_table_init	function
(	O
struct	O
elf_link_hash_table	struct
*	O
table	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_hash_entry	struct
*	O
(	O
*	O
newfunc	pointer
)	O
(	O
struct	O
bfd_hash_entry	struct
*	O
,	O
struct	O
bfd_hash_table	struct
*	O
,	O
const	O
char	O
*	O
)	O
,	O
unsigned	O
int	O
entsize	int
,	O
enum	O
elf_target_id	enum
target_id	enum
)	O
{	O
bfd_boolean	int
ret	pointer
;	O
int	O
can_refcount	int
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
can_refcount	int
;	O
table	pointer
->	O
init_got_refcount	union
.	O
refcount	int
=	O
can_refcount	int
-	O
1	int
;	O
table	pointer
->	O
init_plt_refcount	union
.	O
refcount	int
=	O
can_refcount	int
-	O
1	int
;	O
table	pointer
->	O
init_got_offset	union
.	O
offset	long
=	O
-	O
(	O
bfd_vma	long
)	O
1	int
;	O
table	pointer
->	O
init_plt_offset	union
.	O
offset	long
=	O
-	O
(	O
bfd_vma	long
)	O
1	int
;	O
table	pointer
->	O
dynsymcount	int
=	O
1	int
;	O
ret	pointer
=	O
_bfd_link_hash_table_init	function
(	O
&	O
table	pointer
->	O
root	struct
,	O
abfd	pointer
,	O
newfunc	pointer
,	O
entsize	int
)	O
;	O
table	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_elf_hash_table	int
;	O
table	pointer
->	O
hash_table_id	enum
=	O
target_id	enum
;	O
return	O
ret	pointer
;	O
}	O
struct	O
bfd_link_hash_table	struct
*	O
_bfd_elf_link_hash_table_create	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
ret	pointer
;	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
elf_link_hash_table	struct
)	O
;	O
ret	pointer
=	O
(	O
struct	O
elf_link_hash_table	struct
*	O
)	O
bfd_zmalloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
_bfd_elf_link_hash_table_init	function
(	O
ret	pointer
,	O
abfd	pointer
,	O
_bfd_elf_link_hash_newfunc	function
,	O
sizeof	O
(	O
struct	O
elf_link_hash_entry	struct
)	O
,	O
GENERIC_ELF_DATA	int
)	O
)	O
{	O
free	function
(	O
ret	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
ret	pointer
->	O
root	struct
.	O
hash_table_free	pointer
=	O
_bfd_elf_link_hash_table_free	function
;	O
return	O
&	O
ret	pointer
->	O
root	struct
;	O
}	O
void	O
_bfd_elf_link_hash_table_free	function
(	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
htab	struct
=	O
(	O
struct	O
elf_link_hash_table	struct
*	O
)	O
obfd	pointer
->	O
link	function
.	O
hash	long
;	O
if	O
(	O
htab	struct
->	O
dynstr	pointer
!=	O
NULL	O
)	O
_bfd_elf_strtab_free	function
(	O
htab	struct
->	O
dynstr	pointer
)	O
;	O
_bfd_merge_sections_free	function
(	O
htab	struct
->	O
merge_info	pointer
)	O
;	O
_bfd_generic_link_hash_table_free	function
(	O
obfd	pointer
)	O
;	O
}	O
void	O
bfd_elf_set_dt_needed_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_object	int
)	O
elf_dt_name	O
(	O
abfd	pointer
)	O
=	O
name	pointer
;	O
}	O
int	O
bfd_elf_get_dyn_lib_class	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
int	O
lib_class	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_object	int
)	O
lib_class	int
=	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
;	O
else	O
lib_class	int
=	O
0	int
;	O
return	O
lib_class	int
;	O
}	O
void	O
bfd_elf_set_dyn_lib_class	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
enum	O
dynamic_lib_link_class	enum
lib_class	int
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_object	int
)	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
=	O
lib_class	int
;	O
}	O
struct	O
bfd_link_needed_list	struct
*	O
bfd_elf_get_needed_list	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
NULL	O
;	O
return	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
needed	pointer
;	O
}	O
struct	O
bfd_link_needed_list	struct
*	O
bfd_elf_get_runpath_list	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
NULL	O
;	O
return	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
runpath	pointer
;	O
}	O
const	O
char	O
*	O
bfd_elf_get_dt_soname	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_object	int
)	O
return	O
elf_dt_name	O
(	O
abfd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
bfd_boolean	int
bfd_elf_get_bfd_needed_list	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_needed_list	struct
*	O
*	O
pneeded	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_byte	char
*	O
dynbuf	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
elfsec	int
;	O
unsigned	O
long	O
shlink	long
;	O
bfd_byte	char
*	O
extdyn	pointer
,	O
*	O
extdynend	pointer
;	O
size_t	long
extdynsize	long
;	O
void	O
(	O
*	O
swap_dyn_in	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
void	O
*	O
,	O
Elf_Internal_Dyn	struct
*	O
)	O
;	O
*	O
pneeded	pointer
=	O
NULL	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_format	function
(	O
abfd	pointer
)	O
!=	O
bfd_object	int
)	O
return	O
TRUE	int
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
s	pointer
->	O
size	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
s	pointer
,	O
&	O
dynbuf	pointer
)	O
)	O
goto	O
error_return	O
;	O
elfsec	int
=	O
_bfd_elf_section_from_bfd_section	function
(	O
abfd	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
elfsec	int
==	O
SHN_BAD	O
)	O
goto	O
error_return	O
;	O
shlink	long
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elfsec	int
]	O
->	O
sh_link	array
;	O
extdynsize	long
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
sizeof_dyn	char
;	O
swap_dyn_in	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
swap_dyn_in	pointer
;	O
extdyn	pointer
=	O
dynbuf	pointer
;	O
extdynend	pointer
=	O
extdyn	pointer
+	O
s	pointer
->	O
size	long
;	O
for	O
(	O
;	O
extdyn	pointer
<	O
extdynend	pointer
;	O
extdyn	pointer
+=	O
extdynsize	long
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
(	O
*	O
swap_dyn_in	pointer
)	O
(	O
abfd	pointer
,	O
extdyn	pointer
,	O
&	O
dyn	struct
)	O
;	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_NULL	int
)	O
break	O
;	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_NEEDED	int
)	O
{	O
const	O
char	O
*	O
string	pointer
;	O
struct	O
bfd_link_needed_list	struct
*	O
l	pointer
;	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
bfd_size_type	long
amt	long
;	O
string	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
if	O
(	O
string	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
amt	long
=	O
sizeof	O
*	O
l	pointer
;	O
l	pointer
=	O
(	O
struct	O
bfd_link_needed_list	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
l	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
l	pointer
->	O
by	pointer
=	O
abfd	pointer
;	O
l	pointer
->	O
name	pointer
=	O
string	pointer
;	O
l	pointer
->	O
next	pointer
=	O
*	O
pneeded	pointer
;	O
*	O
pneeded	pointer
=	O
l	pointer
;	O
}	O
}	O
free	function
(	O
dynbuf	pointer
)	O
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
dynbuf	pointer
!=	O
NULL	O
)	O
free	function
(	O
dynbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
struct	O
elf_symbuf_symbol	struct
{	O
unsigned	O
long	O
st_name	array
;	O
unsigned	O
char	O
st_info	array
;	O
unsigned	O
char	O
st_other	array
;	O
}	O
;	O
struct	O
elf_symbuf_head	struct
{	O
struct	O
elf_symbuf_symbol	struct
*	O
ssym	pointer
;	O
size_t	long
count	int
;	O
unsigned	O
int	O
st_shndx	array
;	O
}	O
;	O
struct	O
elf_symbol	struct
{	O
union	O
{	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
struct	O
elf_symbuf_symbol	struct
*	O
ssym	pointer
;	O
void	O
*	O
p	pointer
;	O
}	O
u	union
;	O
const	O
char	O
*	O
name	pointer
;	O
}	O
;	O
static	O
int	O
elf_sort_elf_symbol	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
Elf_Internal_Sym	struct
*	O
s1	pointer
=	O
*	O
(	O
const	O
Elf_Internal_Sym	struct
*	O
*	O
)	O
arg1	pointer
;	O
const	O
Elf_Internal_Sym	struct
*	O
s2	pointer
=	O
*	O
(	O
const	O
Elf_Internal_Sym	struct
*	O
*	O
)	O
arg2	pointer
;	O
if	O
(	O
s1	pointer
->	O
st_shndx	array
!=	O
s2	pointer
->	O
st_shndx	array
)	O
return	O
s1	pointer
->	O
st_shndx	array
>	O
s2	pointer
->	O
st_shndx	array
?	O
1	int
:	O
-	O
1	int
;	O
if	O
(	O
s1	pointer
!=	O
s2	pointer
)	O
return	O
s1	pointer
>	O
s2	pointer
?	O
1	int
:	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
elf_sym_name_compare	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
struct	O
elf_symbol	struct
*	O
s1	pointer
=	O
(	O
const	O
struct	O
elf_symbol	struct
*	O
)	O
arg1	pointer
;	O
const	O
struct	O
elf_symbol	struct
*	O
s2	pointer
=	O
(	O
const	O
struct	O
elf_symbol	struct
*	O
)	O
arg2	pointer
;	O
int	O
ret	pointer
=	O
strcmp	function
(	O
s1	pointer
->	O
name	pointer
,	O
s2	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
return	O
ret	pointer
;	O
if	O
(	O
s1	pointer
->	O
u	union
.	O
p	pointer
!=	O
s2	pointer
->	O
u	union
.	O
p	pointer
)	O
return	O
s1	pointer
->	O
u	union
.	O
p	pointer
>	O
s2	pointer
->	O
u	union
.	O
p	pointer
?	O
1	int
:	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
elf_symbuf_head	struct
*	O
elf_create_symbuf	function
(	O
size_t	long
symcount	int
,	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
)	O
{	O
Elf_Internal_Sym	struct
*	O
*	O
ind	pointer
,	O
*	O
*	O
indbufend	pointer
,	O
*	O
*	O
indbuf	pointer
;	O
struct	O
elf_symbuf_symbol	struct
*	O
ssym	pointer
;	O
struct	O
elf_symbuf_head	struct
*	O
ssymbuf	pointer
,	O
*	O
ssymhead	pointer
;	O
size_t	long
i	pointer
,	O
shndx_count	long
,	O
total_size	long
;	O
indbuf	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
*	O
)	O
bfd_malloc2	function
(	O
symcount	int
,	O
sizeof	O
(	O
*	O
indbuf	pointer
)	O
)	O
;	O
if	O
(	O
indbuf	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
ind	pointer
=	O
indbuf	pointer
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symcount	int
;	O
i	pointer
++	O
)	O
if	O
(	O
isymbuf	pointer
[	O
i	pointer
]	O
.	O
st_shndx	array
!=	O
SHN_UNDEF	int
)	O
*	O
ind	pointer
++	O
=	O
&	O
isymbuf	pointer
[	O
i	pointer
]	O
;	O
indbufend	pointer
=	O
ind	pointer
;	O
qsort	function
(	O
indbuf	pointer
,	O
indbufend	pointer
-	O
indbuf	pointer
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
,	O
elf_sort_elf_symbol	function
)	O
;	O
shndx_count	long
=	O
0	int
;	O
if	O
(	O
indbufend	pointer
>	O
indbuf	pointer
)	O
for	O
(	O
ind	pointer
=	O
indbuf	pointer
,	O
shndx_count	long
++	O
;	O
ind	pointer
<	O
indbufend	pointer
-	O
1	int
;	O
ind	pointer
++	O
)	O
if	O
(	O
ind	pointer
[	O
0	int
]	O
->	O
st_shndx	array
!=	O
ind	pointer
[	O
1	int
]	O
->	O
st_shndx	array
)	O
shndx_count	long
++	O
;	O
total_size	long
=	O
(	O
(	O
shndx_count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
ssymbuf	pointer
)	O
+	O
(	O
indbufend	pointer
-	O
indbuf	pointer
)	O
*	O
sizeof	O
(	O
*	O
ssym	pointer
)	O
)	O
;	O
ssymbuf	pointer
=	O
(	O
struct	O
elf_symbuf_head	struct
*	O
)	O
bfd_malloc	function
(	O
total_size	long
)	O
;	O
if	O
(	O
ssymbuf	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
indbuf	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
ssym	pointer
=	O
(	O
struct	O
elf_symbuf_symbol	struct
*	O
)	O
(	O
ssymbuf	pointer
+	O
shndx_count	long
+	O
1	int
)	O
;	O
ssymbuf	pointer
->	O
ssym	pointer
=	O
NULL	O
;	O
ssymbuf	pointer
->	O
count	int
=	O
shndx_count	long
;	O
ssymbuf	pointer
->	O
st_shndx	array
=	O
0	int
;	O
for	O
(	O
ssymhead	pointer
=	O
ssymbuf	pointer
,	O
ind	pointer
=	O
indbuf	pointer
;	O
ind	pointer
<	O
indbufend	pointer
;	O
ssym	pointer
++	O
,	O
ind	pointer
++	O
)	O
{	O
if	O
(	O
ind	pointer
==	O
indbuf	pointer
||	O
ssymhead	pointer
->	O
st_shndx	array
!=	O
(	O
*	O
ind	pointer
)	O
->	O
st_shndx	array
)	O
{	O
ssymhead	pointer
++	O
;	O
ssymhead	pointer
->	O
ssym	pointer
=	O
ssym	pointer
;	O
ssymhead	pointer
->	O
count	int
=	O
0	int
;	O
ssymhead	pointer
->	O
st_shndx	array
=	O
(	O
*	O
ind	pointer
)	O
->	O
st_shndx	array
;	O
}	O
ssym	pointer
->	O
st_name	array
=	O
(	O
*	O
ind	pointer
)	O
->	O
st_name	array
;	O
ssym	pointer
->	O
st_info	array
=	O
(	O
*	O
ind	pointer
)	O
->	O
st_info	array
;	O
ssym	pointer
->	O
st_other	array
=	O
(	O
*	O
ind	pointer
)	O
->	O
st_other	array
;	O
ssymhead	pointer
->	O
count	int
++	O
;	O
}	O
BFD_ASSERT	O
(	O
(	O
size_t	long
)	O
(	O
ssymhead	pointer
-	O
ssymbuf	pointer
)	O
==	O
shndx_count	long
&&	O
(	O
(	O
(	O
bfd_hostptr_t	long
)	O
ssym	pointer
-	O
(	O
bfd_hostptr_t	long
)	O
ssymbuf	pointer
)	O
==	O
total_size	long
)	O
)	O
;	O
free	function
(	O
indbuf	pointer
)	O
;	O
return	O
ssymbuf	pointer
;	O
}	O
static	O
bfd_boolean	int
bfd_elf_match_symbols_in_sections	function
(	O
asection	struct
*	O
sec1	pointer
,	O
asection	struct
*	O
sec2	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
bfd1	pointer
,	O
*	O
bfd2	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed1	pointer
,	O
*	O
bed2	pointer
;	O
Elf_Internal_Shdr	struct
*	O
hdr1	pointer
,	O
*	O
hdr2	pointer
;	O
size_t	long
symcount1	long
,	O
symcount2	long
;	O
Elf_Internal_Sym	struct
*	O
isymbuf1	pointer
,	O
*	O
isymbuf2	pointer
;	O
struct	O
elf_symbuf_head	struct
*	O
ssymbuf1	pointer
,	O
*	O
ssymbuf2	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
,	O
*	O
isymend	pointer
;	O
struct	O
elf_symbol	struct
*	O
symtable1	pointer
=	O
NULL	O
,	O
*	O
symtable2	pointer
=	O
NULL	O
;	O
size_t	long
count1	long
,	O
count2	long
,	O
i	pointer
;	O
unsigned	O
int	O
shndx1	int
,	O
shndx2	int
;	O
bfd_boolean	int
result	int
;	O
bfd1	pointer
=	O
sec1	pointer
->	O
owner	pointer
;	O
bfd2	pointer
=	O
sec2	pointer
->	O
owner	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
bfd1	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
bfd2	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
elf_section_type	O
(	O
sec1	pointer
)	O
!=	O
elf_section_type	O
(	O
sec2	pointer
)	O
)	O
return	O
FALSE	int
;	O
shndx1	int
=	O
_bfd_elf_section_from_bfd_section	function
(	O
bfd1	pointer
,	O
sec1	pointer
)	O
;	O
shndx2	int
=	O
_bfd_elf_section_from_bfd_section	function
(	O
bfd2	pointer
,	O
sec2	pointer
)	O
;	O
if	O
(	O
shndx1	int
==	O
SHN_BAD	O
||	O
shndx2	int
==	O
SHN_BAD	O
)	O
return	O
FALSE	int
;	O
bed1	pointer
=	O
get_elf_backend_data	O
(	O
bfd1	pointer
)	O
;	O
bed2	pointer
=	O
get_elf_backend_data	O
(	O
bfd2	pointer
)	O
;	O
hdr1	pointer
=	O
&	O
elf_tdata	O
(	O
bfd1	pointer
)	O
->	O
symtab_hdr	struct
;	O
symcount1	long
=	O
hdr1	pointer
->	O
sh_size	array
/	O
bed1	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
hdr2	pointer
=	O
&	O
elf_tdata	O
(	O
bfd2	pointer
)	O
->	O
symtab_hdr	struct
;	O
symcount2	long
=	O
hdr2	pointer
->	O
sh_size	array
/	O
bed2	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
symcount1	long
==	O
0	int
||	O
symcount2	long
==	O
0	int
)	O
return	O
FALSE	int
;	O
result	int
=	O
FALSE	int
;	O
isymbuf1	pointer
=	O
NULL	O
;	O
isymbuf2	pointer
=	O
NULL	O
;	O
ssymbuf1	pointer
=	O
(	O
struct	O
elf_symbuf_head	struct
*	O
)	O
elf_tdata	O
(	O
bfd1	pointer
)	O
->	O
symbuf	pointer
;	O
ssymbuf2	pointer
=	O
(	O
struct	O
elf_symbuf_head	struct
*	O
)	O
elf_tdata	O
(	O
bfd2	pointer
)	O
->	O
symbuf	pointer
;	O
if	O
(	O
ssymbuf1	pointer
==	O
NULL	O
)	O
{	O
isymbuf1	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
bfd1	pointer
,	O
hdr1	pointer
,	O
symcount1	long
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
isymbuf1	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
!	O
info	pointer
->	O
reduce_memory_overheads	int
)	O
{	O
ssymbuf1	pointer
=	O
elf_create_symbuf	function
(	O
symcount1	long
,	O
isymbuf1	pointer
)	O
;	O
elf_tdata	O
(	O
bfd1	pointer
)	O
->	O
symbuf	pointer
=	O
ssymbuf1	pointer
;	O
}	O
}	O
if	O
(	O
ssymbuf1	pointer
==	O
NULL	O
||	O
ssymbuf2	pointer
==	O
NULL	O
)	O
{	O
isymbuf2	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
bfd2	pointer
,	O
hdr2	pointer
,	O
symcount2	long
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
isymbuf2	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
ssymbuf1	pointer
!=	O
NULL	O
&&	O
!	O
info	pointer
->	O
reduce_memory_overheads	int
)	O
{	O
ssymbuf2	pointer
=	O
elf_create_symbuf	function
(	O
symcount2	long
,	O
isymbuf2	pointer
)	O
;	O
elf_tdata	O
(	O
bfd2	pointer
)	O
->	O
symbuf	pointer
=	O
ssymbuf2	pointer
;	O
}	O
}	O
if	O
(	O
ssymbuf1	pointer
!=	O
NULL	O
&&	O
ssymbuf2	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
lo	long
,	O
hi	pointer
,	O
mid	long
;	O
struct	O
elf_symbol	struct
*	O
symp	pointer
;	O
struct	O
elf_symbuf_symbol	struct
*	O
ssym	pointer
,	O
*	O
ssymend	pointer
;	O
lo	long
=	O
0	int
;	O
hi	pointer
=	O
ssymbuf1	pointer
->	O
count	int
;	O
ssymbuf1	pointer
++	O
;	O
count1	long
=	O
0	int
;	O
while	O
(	O
lo	long
<	O
hi	pointer
)	O
{	O
mid	long
=	O
(	O
lo	long
+	O
hi	pointer
)	O
/	O
2	int
;	O
if	O
(	O
shndx1	int
<	O
ssymbuf1	pointer
[	O
mid	long
]	O
.	O
st_shndx	array
)	O
hi	pointer
=	O
mid	long
;	O
else	O
if	O
(	O
shndx1	int
>	O
ssymbuf1	pointer
[	O
mid	long
]	O
.	O
st_shndx	array
)	O
lo	long
=	O
mid	long
+	O
1	int
;	O
else	O
{	O
count1	long
=	O
ssymbuf1	pointer
[	O
mid	long
]	O
.	O
count	int
;	O
ssymbuf1	pointer
+=	O
mid	long
;	O
break	O
;	O
}	O
}	O
lo	long
=	O
0	int
;	O
hi	pointer
=	O
ssymbuf2	pointer
->	O
count	int
;	O
ssymbuf2	pointer
++	O
;	O
count2	long
=	O
0	int
;	O
while	O
(	O
lo	long
<	O
hi	pointer
)	O
{	O
mid	long
=	O
(	O
lo	long
+	O
hi	pointer
)	O
/	O
2	int
;	O
if	O
(	O
shndx2	int
<	O
ssymbuf2	pointer
[	O
mid	long
]	O
.	O
st_shndx	array
)	O
hi	pointer
=	O
mid	long
;	O
else	O
if	O
(	O
shndx2	int
>	O
ssymbuf2	pointer
[	O
mid	long
]	O
.	O
st_shndx	array
)	O
lo	long
=	O
mid	long
+	O
1	int
;	O
else	O
{	O
count2	long
=	O
ssymbuf2	pointer
[	O
mid	long
]	O
.	O
count	int
;	O
ssymbuf2	pointer
+=	O
mid	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
count1	long
==	O
0	int
||	O
count2	long
==	O
0	int
||	O
count1	long
!=	O
count2	long
)	O
goto	O
done	O
;	O
symtable1	pointer
=	O
(	O
struct	O
elf_symbol	struct
*	O
)	O
bfd_malloc	function
(	O
count1	long
*	O
sizeof	O
(	O
*	O
symtable1	pointer
)	O
)	O
;	O
symtable2	pointer
=	O
(	O
struct	O
elf_symbol	struct
*	O
)	O
bfd_malloc	function
(	O
count2	long
*	O
sizeof	O
(	O
*	O
symtable2	pointer
)	O
)	O
;	O
if	O
(	O
symtable1	pointer
==	O
NULL	O
||	O
symtable2	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
symp	pointer
=	O
symtable1	pointer
;	O
for	O
(	O
ssym	pointer
=	O
ssymbuf1	pointer
->	O
ssym	pointer
,	O
ssymend	pointer
=	O
ssym	pointer
+	O
count1	long
;	O
ssym	pointer
<	O
ssymend	pointer
;	O
ssym	pointer
++	O
,	O
symp	pointer
++	O
)	O
{	O
symp	pointer
->	O
u	union
.	O
ssym	pointer
=	O
ssym	pointer
;	O
symp	pointer
->	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
bfd1	pointer
,	O
hdr1	pointer
->	O
sh_link	array
,	O
ssym	pointer
->	O
st_name	array
)	O
;	O
}	O
symp	pointer
=	O
symtable2	pointer
;	O
for	O
(	O
ssym	pointer
=	O
ssymbuf2	pointer
->	O
ssym	pointer
,	O
ssymend	pointer
=	O
ssym	pointer
+	O
count2	long
;	O
ssym	pointer
<	O
ssymend	pointer
;	O
ssym	pointer
++	O
,	O
symp	pointer
++	O
)	O
{	O
symp	pointer
->	O
u	union
.	O
ssym	pointer
=	O
ssym	pointer
;	O
symp	pointer
->	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
bfd2	pointer
,	O
hdr2	pointer
->	O
sh_link	array
,	O
ssym	pointer
->	O
st_name	array
)	O
;	O
}	O
qsort	function
(	O
symtable1	pointer
,	O
count1	long
,	O
sizeof	O
(	O
struct	O
elf_symbol	struct
)	O
,	O
elf_sym_name_compare	function
)	O
;	O
qsort	function
(	O
symtable2	pointer
,	O
count1	long
,	O
sizeof	O
(	O
struct	O
elf_symbol	struct
)	O
,	O
elf_sym_name_compare	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count1	long
;	O
i	pointer
++	O
)	O
if	O
(	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
ssym	pointer
->	O
st_info	array
!=	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
ssym	pointer
->	O
st_info	array
||	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
ssym	pointer
->	O
st_other	array
!=	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
ssym	pointer
->	O
st_other	array
||	O
strcmp	function
(	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
name	pointer
,	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
name	pointer
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
result	int
=	O
TRUE	int
;	O
goto	O
done	O
;	O
}	O
symtable1	pointer
=	O
(	O
struct	O
elf_symbol	struct
*	O
)	O
bfd_malloc	function
(	O
symcount1	long
*	O
sizeof	O
(	O
struct	O
elf_symbol	struct
)	O
)	O
;	O
symtable2	pointer
=	O
(	O
struct	O
elf_symbol	struct
*	O
)	O
bfd_malloc	function
(	O
symcount2	long
*	O
sizeof	O
(	O
struct	O
elf_symbol	struct
)	O
)	O
;	O
if	O
(	O
symtable1	pointer
==	O
NULL	O
||	O
symtable2	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
count1	long
=	O
0	int
;	O
for	O
(	O
isym	pointer
=	O
isymbuf1	pointer
,	O
isymend	pointer
=	O
isym	pointer
+	O
symcount1	long
;	O
isym	pointer
<	O
isymend	pointer
;	O
isym	pointer
++	O
)	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
shndx1	int
)	O
symtable1	pointer
[	O
count1	long
++	O
]	O
.	O
u	union
.	O
isym	pointer
=	O
isym	pointer
;	O
count2	long
=	O
0	int
;	O
for	O
(	O
isym	pointer
=	O
isymbuf2	pointer
,	O
isymend	pointer
=	O
isym	pointer
+	O
symcount2	long
;	O
isym	pointer
<	O
isymend	pointer
;	O
isym	pointer
++	O
)	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
shndx2	int
)	O
symtable2	pointer
[	O
count2	long
++	O
]	O
.	O
u	union
.	O
isym	pointer
=	O
isym	pointer
;	O
if	O
(	O
count1	long
==	O
0	int
||	O
count2	long
==	O
0	int
||	O
count1	long
!=	O
count2	long
)	O
goto	O
done	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count1	long
;	O
i	pointer
++	O
)	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
bfd1	pointer
,	O
hdr1	pointer
->	O
sh_link	array
,	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
isym	pointer
->	O
st_name	array
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count2	long
;	O
i	pointer
++	O
)	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
bfd2	pointer
,	O
hdr2	pointer
->	O
sh_link	array
,	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
isym	pointer
->	O
st_name	array
)	O
;	O
qsort	function
(	O
symtable1	pointer
,	O
count1	long
,	O
sizeof	O
(	O
struct	O
elf_symbol	struct
)	O
,	O
elf_sym_name_compare	function
)	O
;	O
qsort	function
(	O
symtable2	pointer
,	O
count1	long
,	O
sizeof	O
(	O
struct	O
elf_symbol	struct
)	O
,	O
elf_sym_name_compare	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count1	long
;	O
i	pointer
++	O
)	O
if	O
(	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
isym	pointer
->	O
st_info	array
!=	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
isym	pointer
->	O
st_info	array
||	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
isym	pointer
->	O
st_other	array
!=	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
u	union
.	O
isym	pointer
->	O
st_other	array
||	O
strcmp	function
(	O
symtable1	pointer
[	O
i	pointer
]	O
.	O
name	pointer
,	O
symtable2	pointer
[	O
i	pointer
]	O
.	O
name	pointer
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
result	int
=	O
TRUE	int
;	O
done	O
:	O
if	O
(	O
symtable1	pointer
)	O
free	function
(	O
symtable1	pointer
)	O
;	O
if	O
(	O
symtable2	pointer
)	O
free	function
(	O
symtable2	pointer
)	O
;	O
if	O
(	O
isymbuf1	pointer
)	O
free	function
(	O
isymbuf1	pointer
)	O
;	O
if	O
(	O
isymbuf2	pointer
)	O
free	function
(	O
isymbuf2	pointer
)	O
;	O
return	O
result	int
;	O
}	O
bfd_boolean	int
_bfd_elf_match_sections_by_type	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
asection	struct
*	O
asec	pointer
,	O
bfd	struct
*	O
bbfd	pointer
,	O
const	O
asection	struct
*	O
bsec	pointer
)	O
{	O
if	O
(	O
asec	pointer
==	O
NULL	O
||	O
bsec	pointer
==	O
NULL	O
||	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
||	O
bbfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
return	O
elf_section_type	O
(	O
asec	pointer
)	O
==	O
elf_section_type	O
(	O
bsec	pointer
)	O
;	O
}	O
struct	O
elf_final_link_info	struct
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
bfd	struct
*	O
output_bfd	pointer
;	O
struct	O
elf_strtab_hash	O
*	O
symstrtab	pointer
;	O
asection	struct
*	O
hash_sec	pointer
;	O
asection	struct
*	O
symver_sec	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
void	O
*	O
external_relocs	pointer
;	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
;	O
bfd_byte	char
*	O
external_syms	pointer
;	O
Elf_External_Sym_Shndx	struct
*	O
locsym_shndx	pointer
;	O
Elf_Internal_Sym	struct
*	O
internal_syms	pointer
;	O
long	O
*	O
indices	pointer
;	O
asection	struct
*	O
*	O
sections	pointer
;	O
Elf_External_Sym_Shndx	struct
*	O
symshndxbuf	pointer
;	O
size_t	long
filesym_count	long
;	O
}	O
;	O
struct	O
elf_outext_info	struct
{	O
bfd_boolean	int
failed	int
;	O
bfd_boolean	int
localsyms	int
;	O
bfd_boolean	int
file_sym_done	int
;	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
;	O
}	O
;	O
static	O
void	O
set_symbol_value	function
(	O
bfd	struct
*	O
bfd_with_globals	pointer
,	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
,	O
size_t	long
locsymcount	long
,	O
size_t	long
symidx	long
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
size_t	long
extsymoff	long
=	O
locsymcount	long
;	O
if	O
(	O
symidx	long
<	O
locsymcount	long
)	O
{	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
sym	pointer
=	O
isymbuf	pointer
+	O
symidx	long
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STB_LOCAL	int
)	O
{	O
sym	pointer
->	O
st_shndx	array
=	O
SHN_ABS	O
;	O
sym	pointer
->	O
st_value	array
=	O
val	array
;	O
return	O
;	O
}	O
BFD_ASSERT	O
(	O
elf_bad_symtab	O
(	O
bfd_with_globals	pointer
)	O
)	O
;	O
extsymoff	long
=	O
0	int
;	O
}	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
bfd_with_globals	pointer
)	O
;	O
h	pointer
=	O
sym_hashes	pointer
[	O
symidx	long
-	O
extsymoff	long
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
val	array
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
}	O
static	O
bfd_boolean	int
resolve_symbol	function
(	O
const	O
char	O
*	O
name	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
,	O
bfd_vma	long
*	O
result	int
,	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
,	O
size_t	long
locsymcount	long
)	O
{	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
global_entry	pointer
;	O
const	O
char	O
*	O
candidate	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
size_t	long
i	pointer
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
input_bfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
locsymcount	long
;	O
++	O
i	pointer
)	O
{	O
sym	pointer
=	O
isymbuf	pointer
+	O
i	pointer
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
STB_LOCAL	int
)	O
continue	O
;	O
candidate	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
->	O
sh_link	array
,	O
sym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
candidate	pointer
&&	O
strcmp	function
(	O
candidate	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
flinfo	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
;	O
*	O
result	int
=	O
_bfd_elf_rel_local_sym	function
(	O
input_bfd	pointer
,	O
sym	pointer
,	O
&	O
sec	pointer
,	O
0	int
)	O
;	O
*	O
result	int
+=	O
sec	pointer
->	O
output_offset	long
+	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
return	O
TRUE	int
;	O
}	O
}	O
global_entry	pointer
=	O
bfd_link_hash_lookup	function
(	O
flinfo	pointer
->	O
info	pointer
->	O
hash	long
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
!	O
global_entry	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
global_entry	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
global_entry	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
{	O
*	O
result	int
=	O
(	O
global_entry	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
+	O
global_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
global_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
resolve_section	function
(	O
const	O
char	O
*	O
name	pointer
,	O
asection	struct
*	O
sections	pointer
,	O
bfd_vma	long
*	O
result	int
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
asection	struct
*	O
curr	pointer
;	O
unsigned	O
int	O
len	long
;	O
for	O
(	O
curr	pointer
=	O
sections	pointer
;	O
curr	pointer
;	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
curr	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
*	O
result	int
=	O
curr	pointer
->	O
vma	long
;	O
return	O
TRUE	int
;	O
}	O
for	O
(	O
curr	pointer
=	O
sections	pointer
;	O
curr	pointer
;	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
)	O
{	O
len	long
=	O
strlen	function
(	O
curr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
len	long
>	O
strlen	function
(	O
name	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
strncmp	function
(	O
curr	pointer
->	O
name	pointer
,	O
name	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
".end"	pointer
,	O
name	pointer
+	O
len	long
,	O
4	int
)	O
==	O
0	int
)	O
{	O
*	O
result	int
=	O
(	O
curr	pointer
->	O
vma	long
+	O
curr	pointer
->	O
size	long
/	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
curr	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
undefined_reference	function
(	O
const	O
char	O
*	O
reftype	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"undefined %s reference in complex symbol: %s"	pointer
)	O
,	O
reftype	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
eval_symbol	function
(	O
bfd_vma	long
*	O
result	int
,	O
const	O
char	O
*	O
*	O
symp	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
,	O
bfd_vma	long
dot	long
,	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
,	O
size_t	long
locsymcount	long
,	O
int	O
signed_p	int
)	O
{	O
size_t	long
len	long
;	O
size_t	long
symlen	long
;	O
bfd_vma	long
a	pointer
;	O
bfd_vma	long
b	pointer
;	O
char	O
symbuf	pointer
[	O
4096	int
]	O
;	O
const	O
char	O
*	O
sym	pointer
=	O
*	O
symp	pointer
;	O
const	O
char	O
*	O
symend	pointer
;	O
bfd_boolean	int
symbol_is_section	int
=	O
FALSE	int
;	O
len	long
=	O
strlen	function
(	O
sym	pointer
)	O
;	O
symend	pointer
=	O
sym	pointer
+	O
len	long
;	O
if	O
(	O
len	long
<	O
1	int
||	O
len	long
>	O
sizeof	O
(	O
symbuf	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
switch	O
(	O
*	O
sym	pointer
)	O
{	O
case	O
'.'	O
:	O
*	O
result	int
=	O
dot	long
;	O
*	O
symp	pointer
=	O
sym	pointer
+	O
1	int
;	O
return	O
TRUE	int
;	O
case	O
'#'	O
:	O
++	O
sym	pointer
;	O
*	O
result	int
=	O
strtoul	function
(	O
sym	pointer
,	O
(	O
char	O
*	O
*	O
)	O
symp	pointer
,	O
16	int
)	O
;	O
return	O
TRUE	int
;	O
case	O
'S'	O
:	O
symbol_is_section	int
=	O
TRUE	int
;	O
case	O
's'	O
:	O
++	O
sym	pointer
;	O
symlen	long
=	O
strtol	function
(	O
sym	pointer
,	O
(	O
char	O
*	O
*	O
)	O
symp	pointer
,	O
10	int
)	O
;	O
sym	pointer
=	O
*	O
symp	pointer
+	O
1	int
;	O
if	O
(	O
symend	pointer
<	O
sym	pointer
||	O
symlen	long
+	O
1	int
>	O
sizeof	O
(	O
symbuf	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
memcpy	function
(	O
symbuf	pointer
,	O
sym	pointer
,	O
symlen	long
)	O
;	O
symbuf	pointer
[	O
symlen	long
]	O
=	O
'\0'	O
;	O
*	O
symp	pointer
=	O
sym	pointer
+	O
symlen	long
;	O
if	O
(	O
symbol_is_section	int
)	O
{	O
if	O
(	O
!	O
resolve_section	function
(	O
symbuf	pointer
,	O
flinfo	pointer
->	O
output_bfd	pointer
->	O
sections	pointer
,	O
result	int
,	O
input_bfd	pointer
)	O
&&	O
!	O
resolve_symbol	function
(	O
symbuf	pointer
,	O
input_bfd	pointer
,	O
flinfo	pointer
,	O
result	int
,	O
isymbuf	pointer
,	O
locsymcount	long
)	O
)	O
{	O
undefined_reference	function
(	O
"section"	pointer
,	O
symbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
resolve_symbol	function
(	O
symbuf	pointer
,	O
input_bfd	pointer
,	O
flinfo	pointer
,	O
result	int
,	O
isymbuf	pointer
,	O
locsymcount	long
)	O
&&	O
!	O
resolve_section	function
(	O
symbuf	pointer
,	O
flinfo	pointer
->	O
output_bfd	pointer
->	O
sections	pointer
,	O
result	int
,	O
input_bfd	pointer
)	O
)	O
{	O
undefined_reference	function
(	O
"symbol"	pointer
,	O
symbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
default	O
:	O
UNARY_OP	O
(	O
0	int
-	O
)	O
;	O
BINARY_OP	O
(	O
<<	O
)	O
;	O
BINARY_OP	O
(	O
>>	O
)	O
;	O
BINARY_OP	O
(	O
==	O
)	O
;	O
BINARY_OP	O
(	O
!=	O
)	O
;	O
BINARY_OP	O
(	O
<=	O
)	O
;	O
BINARY_OP	O
(	O
>=	O
)	O
;	O
BINARY_OP	O
(	O
&&	O
)	O
;	O
BINARY_OP	O
(	O
||	O
)	O
;	O
UNARY_OP	O
(	O
~	O
)	O
;	O
UNARY_OP	O
(	O
!	O
)	O
;	O
BINARY_OP	O
(	O
*	O
)	O
;	O
BINARY_OP	O
(	O
/	O
)	O
;	O
BINARY_OP	O
(	O
%	O
)	O
;	O
BINARY_OP	O
(	O
^	O
)	O
;	O
BINARY_OP	O
(	O
|	O
)	O
;	O
BINARY_OP	O
(	O
&	O
)	O
;	O
BINARY_OP	O
(	O
+	O
)	O
;	O
BINARY_OP	O
(	O
-	O
)	O
;	O
BINARY_OP	O
(	O
<	O
)	O
;	O
BINARY_OP	O
(	O
>	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"unknown operator '%c' in complex symbol"	pointer
)	O
,	O
*	O
sym	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
void	O
put_value	function
(	O
bfd_vma	long
size	long
,	O
unsigned	O
long	O
chunksz	long
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
bfd_vma	long
x	long
,	O
bfd_byte	char
*	O
location	pointer
)	O
{	O
location	pointer
+=	O
(	O
size	long
-	O
chunksz	long
)	O
;	O
for	O
(	O
;	O
size	long
;	O
size	long
-=	O
chunksz	long
,	O
location	pointer
-=	O
chunksz	long
)	O
{	O
switch	O
(	O
chunksz	long
)	O
{	O
case	O
1	int
:	O
bfd_put_8	O
(	O
input_bfd	pointer
,	O
x	long
,	O
location	pointer
)	O
;	O
x	long
>>=	O
8	int
;	O
break	O
;	O
case	O
2	int
:	O
bfd_put_16	O
(	O
input_bfd	pointer
,	O
x	long
,	O
location	pointer
)	O
;	O
x	long
>>=	O
16	int
;	O
break	O
;	O
case	O
4	int
:	O
bfd_put_32	O
(	O
input_bfd	pointer
,	O
x	long
,	O
location	pointer
)	O
;	O
x	long
>>=	O
16	int
;	O
x	long
>>=	O
16	int
;	O
break	O
;	O
case	O
8	int
:	O
bfd_put_64	O
(	O
input_bfd	pointer
,	O
x	long
,	O
location	pointer
)	O
;	O
x	long
>>=	O
32	int
;	O
x	long
>>=	O
32	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
bfd_vma	long
get_value	function
(	O
bfd_vma	long
size	long
,	O
unsigned	O
long	O
chunksz	long
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
bfd_byte	char
*	O
location	pointer
)	O
{	O
int	O
shift	int
;	O
bfd_vma	long
x	long
=	O
0	int
;	O
BFD_ASSERT	O
(	O
chunksz	long
<=	O
sizeof	O
(	O
x	long
)	O
&&	O
size	long
>=	O
chunksz	long
&&	O
chunksz	long
!=	O
0	int
&&	O
(	O
size	long
%	O
chunksz	long
)	O
==	O
0	int
&&	O
input_bfd	pointer
!=	O
NULL	O
&&	O
location	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
chunksz	long
==	O
sizeof	O
(	O
x	long
)	O
)	O
{	O
BFD_ASSERT	O
(	O
size	long
==	O
chunksz	long
)	O
;	O
shift	int
=	O
0	int
;	O
}	O
else	O
shift	int
=	O
8	int
*	O
chunksz	long
;	O
for	O
(	O
;	O
size	long
;	O
size	long
-=	O
chunksz	long
,	O
location	pointer
+=	O
chunksz	long
)	O
{	O
switch	O
(	O
chunksz	long
)	O
{	O
case	O
1	int
:	O
x	long
=	O
(	O
x	long
<<	O
shift	int
)	O
|	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
location	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
x	long
=	O
(	O
x	long
<<	O
shift	int
)	O
|	O
bfd_get_16	O
(	O
input_bfd	pointer
,	O
location	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
x	long
=	O
(	O
x	long
<<	O
shift	int
)	O
|	O
bfd_get_32	O
(	O
input_bfd	pointer
,	O
location	pointer
)	O
;	O
break	O
;	O
case	O
8	int
:	O
x	long
=	O
(	O
x	long
<<	O
shift	int
)	O
|	O
bfd_get_64	O
(	O
input_bfd	pointer
,	O
location	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
return	O
x	long
;	O
}	O
static	O
void	O
decode_complex_addend	function
(	O
unsigned	O
long	O
*	O
start	pointer
,	O
unsigned	O
long	O
*	O
oplen	pointer
,	O
unsigned	O
long	O
*	O
len	long
,	O
unsigned	O
long	O
*	O
wordsz	pointer
,	O
unsigned	O
long	O
*	O
chunksz	long
,	O
unsigned	O
long	O
*	O
lsb0_p	pointer
,	O
unsigned	O
long	O
*	O
signed_p	int
,	O
unsigned	O
long	O
*	O
trunc_p	pointer
,	O
unsigned	O
long	O
encoded	pointer
)	O
{	O
*	O
start	pointer
=	O
encoded	pointer
&	O
0x3F	int
;	O
*	O
len	long
=	O
(	O
encoded	pointer
>>	O
6	int
)	O
&	O
0x3F	int
;	O
*	O
oplen	pointer
=	O
(	O
encoded	pointer
>>	O
12	int
)	O
&	O
0x3F	int
;	O
*	O
wordsz	pointer
=	O
(	O
encoded	pointer
>>	O
18	int
)	O
&	O
0xF	int
;	O
*	O
chunksz	long
=	O
(	O
encoded	pointer
>>	O
22	int
)	O
&	O
0xF	int
;	O
*	O
lsb0_p	pointer
=	O
(	O
encoded	pointer
>>	O
27	int
)	O
&	O
1	int
;	O
*	O
signed_p	int
=	O
(	O
encoded	pointer
>>	O
28	int
)	O
&	O
1	int
;	O
*	O
trunc_p	pointer
=	O
(	O
encoded	pointer
>>	O
29	int
)	O
&	O
1	int
;	O
}	O
bfd_reloc_status_type	enum
bfd_elf_perform_complex_relocation	function
(	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
bfd_vma	long
relocation	pointer
)	O
{	O
bfd_vma	long
shift	int
,	O
x	long
,	O
mask	int
;	O
unsigned	O
long	O
start	pointer
,	O
oplen	pointer
,	O
len	long
,	O
wordsz	pointer
,	O
chunksz	long
,	O
lsb0_p	pointer
,	O
signed_p	int
,	O
trunc_p	pointer
;	O
bfd_reloc_status_type	enum
r	enum
;	O
bfd_size_type	long
octets	long
;	O
decode_complex_addend	function
(	O
&	O
start	pointer
,	O
&	O
oplen	pointer
,	O
&	O
len	long
,	O
&	O
wordsz	pointer
,	O
&	O
chunksz	long
,	O
&	O
lsb0_p	pointer
,	O
&	O
signed_p	int
,	O
&	O
trunc_p	pointer
,	O
rel	pointer
->	O
r_addend	array
)	O
;	O
mask	int
=	O
(	O
(	O
(	O
1L	int
<<	O
(	O
len	long
-	O
1	int
)	O
)	O
-	O
1	int
)	O
<<	O
1	int
)	O
|	O
1	int
;	O
if	O
(	O
lsb0_p	pointer
)	O
shift	int
=	O
(	O
start	pointer
+	O
1	int
)	O
-	O
len	long
;	O
else	O
shift	int
=	O
(	O
8	int
*	O
wordsz	pointer
)	O
-	O
(	O
start	pointer
+	O
len	long
)	O
;	O
octets	long
=	O
rel	pointer
->	O
r_offset	array
*	O
bfd_octets_per_byte	function
(	O
input_bfd	pointer
,	O
input_section	pointer
)	O
;	O
x	long
=	O
get_value	function
(	O
wordsz	pointer
,	O
chunksz	long
,	O
input_bfd	pointer
,	O
contents	pointer
+	O
octets	long
)	O
;	O
r	enum
=	O
bfd_reloc_ok	int
;	O
if	O
(	O
!	O
trunc_p	pointer
)	O
r	enum
=	O
bfd_check_overflow	function
(	O
(	O
signed_p	int
?	O
complain_overflow_signed	int
:	O
complain_overflow_unsigned	int
)	O
,	O
len	long
,	O
0	int
,	O
(	O
8	int
*	O
wordsz	pointer
)	O
,	O
relocation	pointer
)	O
;	O
x	long
=	O
(	O
x	long
&	O
~	O
(	O
mask	int
<<	O
shift	int
)	O
)	O
|	O
(	O
(	O
relocation	pointer
&	O
mask	int
)	O
<<	O
shift	int
)	O
;	O
put_value	function
(	O
wordsz	pointer
,	O
chunksz	long
,	O
input_bfd	pointer
,	O
x	long
,	O
contents	pointer
+	O
octets	long
)	O
;	O
return	O
r	enum
;	O
}	O
static	O
bfd_vma	long
ext32l_r_offset	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
union	O
aligned32	union
{	O
uint32_t	int
v	int
;	O
unsigned	O
char	O
c	struct
[	O
4	int
]	O
;	O
}	O
;	O
const	O
union	O
aligned32	union
*	O
a	pointer
=	O
(	O
const	O
union	O
aligned32	union
*	O
)	O
&	O
(	O
(	O
const	O
Elf32_External_Rel	struct
*	O
)	O
p	pointer
)	O
->	O
r_offset	array
;	O
uint32_t	int
aval	int
=	O
(	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
0	int
]	O
|	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
1	int
]	O
<<	O
8	int
|	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
2	int
]	O
<<	O
16	int
|	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
3	int
]	O
<<	O
24	int
)	O
;	O
return	O
aval	int
;	O
}	O
static	O
bfd_vma	long
ext32b_r_offset	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
union	O
aligned32	union
{	O
uint32_t	int
v	int
;	O
unsigned	O
char	O
c	struct
[	O
4	int
]	O
;	O
}	O
;	O
const	O
union	O
aligned32	union
*	O
a	pointer
=	O
(	O
const	O
union	O
aligned32	union
*	O
)	O
&	O
(	O
(	O
const	O
Elf32_External_Rel	struct
*	O
)	O
p	pointer
)	O
->	O
r_offset	array
;	O
uint32_t	int
aval	int
=	O
(	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
0	int
]	O
<<	O
24	int
|	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
1	int
]	O
<<	O
16	int
|	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
2	int
]	O
<<	O
8	int
|	O
(	O
uint32_t	int
)	O
a	pointer
->	O
c	struct
[	O
3	int
]	O
)	O
;	O
return	O
aval	int
;	O
}	O
static	O
bfd_vma	long
ext64l_r_offset	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
union	O
aligned64	union
{	O
uint64_t	long
v	int
;	O
unsigned	O
char	O
c	struct
[	O
8	int
]	O
;	O
}	O
;	O
const	O
union	O
aligned64	union
*	O
a	pointer
=	O
(	O
const	O
union	O
aligned64	union
*	O
)	O
&	O
(	O
(	O
const	O
Elf64_External_Rel	struct
*	O
)	O
p	pointer
)	O
->	O
r_offset	array
;	O
uint64_t	long
aval	int
=	O
(	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
0	int
]	O
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
1	int
]	O
<<	O
8	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
2	int
]	O
<<	O
16	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
3	int
]	O
<<	O
24	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
4	int
]	O
<<	O
32	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
5	int
]	O
<<	O
40	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
6	int
]	O
<<	O
48	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
7	int
]	O
<<	O
56	int
)	O
;	O
return	O
aval	int
;	O
}	O
static	O
bfd_vma	long
ext64b_r_offset	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
union	O
aligned64	union
{	O
uint64_t	long
v	int
;	O
unsigned	O
char	O
c	struct
[	O
8	int
]	O
;	O
}	O
;	O
const	O
union	O
aligned64	union
*	O
a	pointer
=	O
(	O
const	O
union	O
aligned64	union
*	O
)	O
&	O
(	O
(	O
const	O
Elf64_External_Rel	struct
*	O
)	O
p	pointer
)	O
->	O
r_offset	array
;	O
uint64_t	long
aval	int
=	O
(	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
0	int
]	O
<<	O
56	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
1	int
]	O
<<	O
48	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
2	int
]	O
<<	O
40	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
3	int
]	O
<<	O
32	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
4	int
]	O
<<	O
24	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
5	int
]	O
<<	O
16	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
6	int
]	O
<<	O
8	int
|	O
(	O
uint64_t	long
)	O
a	pointer
->	O
c	struct
[	O
7	int
]	O
)	O
;	O
return	O
aval	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_adjust_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_elf_section_reloc_data	struct
*	O
reldata	pointer
,	O
bfd_boolean	int
sort	int
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_byte	char
*	O
erela	pointer
;	O
void	O
(	O
*	O
swap_in	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
bfd_byte	char
*	O
,	O
Elf_Internal_Rela	struct
*	O
)	O
;	O
void	O
(	O
*	O
swap_out	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
Elf_Internal_Rela	struct
*	O
,	O
bfd_byte	char
*	O
)	O
;	O
bfd_vma	long
r_type_mask	long
;	O
int	O
r_sym_shift	int
;	O
unsigned	O
int	O
count	int
=	O
reldata	pointer
->	O
count	int
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
rel_hash	pointer
=	O
reldata	pointer
->	O
hashes	pointer
;	O
if	O
(	O
reldata	pointer
->	O
hdr	pointer
->	O
sh_entsize	array
==	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
{	O
swap_in	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_in	pointer
;	O
swap_out	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_out	pointer
;	O
}	O
else	O
if	O
(	O
reldata	pointer
->	O
hdr	pointer
->	O
sh_entsize	array
==	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
)	O
{	O
swap_in	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_in	pointer
;	O
swap_out	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_out	pointer
;	O
}	O
else	O
abort	function
(	O
)	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
>	O
MAX_INT_RELS_PER_EXT_REL	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
{	O
r_type_mask	long
=	O
0xff	int
;	O
r_sym_shift	int
=	O
8	int
;	O
}	O
else	O
{	O
r_type_mask	long
=	O
0xffffffff	int
;	O
r_sym_shift	int
=	O
32	int
;	O
}	O
erela	pointer
=	O
reldata	pointer
->	O
hdr	pointer
->	O
contents	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
,	O
rel_hash	pointer
++	O
,	O
erela	pointer
+=	O
reldata	pointer
->	O
hdr	pointer
->	O
sh_entsize	array
)	O
{	O
Elf_Internal_Rela	struct
irela	pointer
[	O
MAX_INT_RELS_PER_EXT_REL	int
]	O
;	O
unsigned	O
int	O
j	long
;	O
if	O
(	O
*	O
rel_hash	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
(	O
*	O
rel_hash	pointer
)	O
->	O
indx	long
==	O
-	O
2	int
&&	O
info	pointer
->	O
gc_sections	int
&&	O
!	O
info	pointer
->	O
gc_keep_exported	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB:%pA: error: relocation references symbol %s which was removed by garbage collection"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
,	O
(	O
*	O
rel_hash	pointer
)	O
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB:%pA: error: try relinking with --gc-keep-exported enabled"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
BFD_ASSERT	O
(	O
(	O
*	O
rel_hash	pointer
)	O
->	O
indx	long
>=	O
0	int
)	O
;	O
(	O
*	O
swap_in	pointer
)	O
(	O
abfd	pointer
,	O
erela	pointer
,	O
irela	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
;	O
j	long
++	O
)	O
irela	pointer
[	O
j	long
]	O
.	O
r_info	array
=	O
(	O
(	O
bfd_vma	long
)	O
(	O
*	O
rel_hash	pointer
)	O
->	O
indx	long
<<	O
r_sym_shift	int
|	O
(	O
irela	pointer
[	O
j	long
]	O
.	O
r_info	array
&	O
r_type_mask	long
)	O
)	O
;	O
(	O
*	O
swap_out	pointer
)	O
(	O
abfd	pointer
,	O
irela	pointer
,	O
erela	pointer
)	O
;	O
}	O
if	O
(	O
bed	pointer
->	O
elf_backend_update_relocs	pointer
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_update_relocs	pointer
)	O
(	O
sec	pointer
,	O
reldata	pointer
)	O
;	O
if	O
(	O
sort	int
&&	O
count	int
!=	O
0	int
)	O
{	O
bfd_vma	long
(	O
*	O
ext_r_off	pointer
)	O
(	O
const	O
void	O
*	O
)	O
;	O
bfd_vma	long
r_off	long
;	O
size_t	long
elt_size	long
;	O
bfd_byte	char
*	O
base	int
,	O
*	O
end	pointer
,	O
*	O
p	pointer
,	O
*	O
loc	pointer
;	O
bfd_byte	char
*	O
buf	pointer
=	O
NULL	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
{	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
header_byteorder	enum
==	O
BFD_ENDIAN_LITTLE	int
)	O
ext_r_off	pointer
=	O
ext32l_r_offset	function
;	O
else	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
header_byteorder	enum
==	O
BFD_ENDIAN_BIG	int
)	O
ext_r_off	pointer
=	O
ext32b_r_offset	function
;	O
else	O
abort	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
header_byteorder	enum
==	O
BFD_ENDIAN_LITTLE	int
)	O
ext_r_off	pointer
=	O
ext64l_r_offset	function
;	O
else	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
header_byteorder	enum
==	O
BFD_ENDIAN_BIG	int
)	O
ext_r_off	pointer
=	O
ext64b_r_offset	function
;	O
else	O
abort	function
(	O
)	O
;	O
}	O
elt_size	long
=	O
reldata	pointer
->	O
hdr	pointer
->	O
sh_entsize	array
;	O
base	int
=	O
reldata	pointer
->	O
hdr	pointer
->	O
contents	pointer
;	O
end	pointer
=	O
base	int
+	O
count	int
*	O
elt_size	long
;	O
if	O
(	O
elt_size	long
>	O
sizeof	O
(	O
Elf64_External_Rela	struct
)	O
)	O
abort	function
(	O
)	O
;	O
r_off	long
=	O
(	O
*	O
ext_r_off	pointer
)	O
(	O
base	int
)	O
;	O
for	O
(	O
p	pointer
=	O
loc	pointer
=	O
base	int
;	O
(	O
p	pointer
+=	O
elt_size	long
)	O
<	O
end	pointer
;	O
)	O
{	O
bfd_vma	long
r_off2	long
=	O
(	O
*	O
ext_r_off	pointer
)	O
(	O
p	pointer
)	O
;	O
if	O
(	O
r_off	long
>	O
r_off2	long
)	O
{	O
r_off	long
=	O
r_off2	long
;	O
loc	pointer
=	O
p	pointer
;	O
}	O
}	O
if	O
(	O
loc	pointer
!=	O
base	int
)	O
{	O
bfd_byte	char
onebuf	array
[	O
sizeof	O
(	O
Elf64_External_Rela	struct
)	O
]	O
;	O
memcpy	function
(	O
onebuf	array
,	O
loc	pointer
,	O
elt_size	long
)	O
;	O
memmove	function
(	O
base	int
+	O
elt_size	long
,	O
base	int
,	O
loc	pointer
-	O
base	int
)	O
;	O
memcpy	function
(	O
base	int
,	O
onebuf	array
,	O
elt_size	long
)	O
;	O
}	O
for	O
(	O
p	pointer
=	O
base	int
+	O
elt_size	long
;	O
(	O
p	pointer
+=	O
elt_size	long
)	O
<	O
end	pointer
;	O
)	O
{	O
r_off	long
=	O
(	O
*	O
ext_r_off	pointer
)	O
(	O
p	pointer
)	O
;	O
loc	pointer
=	O
p	pointer
-	O
elt_size	long
;	O
while	O
(	O
r_off	long
<	O
(	O
*	O
ext_r_off	pointer
)	O
(	O
loc	pointer
)	O
)	O
loc	pointer
-=	O
elt_size	long
;	O
loc	pointer
+=	O
elt_size	long
;	O
if	O
(	O
loc	pointer
!=	O
p	pointer
)	O
{	O
size_t	long
sortlen	long
=	O
p	pointer
-	O
loc	pointer
;	O
bfd_vma	long
r_off2	long
=	O
(	O
*	O
ext_r_off	pointer
)	O
(	O
loc	pointer
)	O
;	O
size_t	long
runlen	long
=	O
elt_size	long
;	O
size_t	long
buf_size	long
=	O
96	int
*	O
1024	int
;	O
while	O
(	O
p	pointer
+	O
runlen	long
<	O
end	pointer
&&	O
(	O
sortlen	long
<=	O
buf_size	long
||	O
runlen	long
+	O
elt_size	long
<=	O
buf_size	long
)	O
&&	O
r_off2	long
>	O
(	O
*	O
ext_r_off	pointer
)	O
(	O
p	pointer
+	O
runlen	long
)	O
)	O
runlen	long
+=	O
elt_size	long
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
{	O
buf	pointer
=	O
bfd_malloc	function
(	O
buf_size	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
runlen	long
<	O
sortlen	long
)	O
{	O
memcpy	function
(	O
buf	pointer
,	O
p	pointer
,	O
runlen	long
)	O
;	O
memmove	function
(	O
loc	pointer
+	O
runlen	long
,	O
loc	pointer
,	O
sortlen	long
)	O
;	O
memcpy	function
(	O
loc	pointer
,	O
buf	pointer
,	O
runlen	long
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
buf	pointer
,	O
loc	pointer
,	O
sortlen	long
)	O
;	O
memmove	function
(	O
loc	pointer
,	O
p	pointer
,	O
runlen	long
)	O
;	O
memcpy	function
(	O
loc	pointer
+	O
runlen	long
,	O
buf	pointer
,	O
sortlen	long
)	O
;	O
}	O
p	pointer
+=	O
runlen	long
-	O
elt_size	long
;	O
}	O
}	O
free	function
(	O
reldata	pointer
->	O
hashes	pointer
)	O
;	O
reldata	pointer
->	O
hashes	pointer
=	O
NULL	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
struct	O
elf_link_sort_rela	struct
{	O
union	O
{	O
bfd_vma	long
offset	long
;	O
bfd_vma	long
sym_mask	long
;	O
}	O
u	union
;	O
enum	O
elf_reloc_type_class	enum
type	enum
;	O
Elf_Internal_Rela	struct
rela	struct
[	O
1	int
]	O
;	O
}	O
;	O
static	O
int	O
elf_link_sort_cmp1	function
(	O
const	O
void	O
*	O
A	pointer
,	O
const	O
void	O
*	O
B	pointer
)	O
{	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
a	pointer
=	O
(	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
A	pointer
;	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
b	pointer
=	O
(	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
B	pointer
;	O
int	O
relativea	int
,	O
relativeb	int
;	O
relativea	int
=	O
a	pointer
->	O
type	enum
==	O
reloc_class_relative	int
;	O
relativeb	int
=	O
b	pointer
->	O
type	enum
==	O
reloc_class_relative	int
;	O
if	O
(	O
relativea	int
<	O
relativeb	int
)	O
return	O
1	int
;	O
if	O
(	O
relativea	int
>	O
relativeb	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
a	pointer
->	O
rela	struct
->	O
r_info	array
&	O
a	pointer
->	O
u	union
.	O
sym_mask	long
)	O
<	O
(	O
b	pointer
->	O
rela	struct
->	O
r_info	array
&	O
b	pointer
->	O
u	union
.	O
sym_mask	long
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
a	pointer
->	O
rela	struct
->	O
r_info	array
&	O
a	pointer
->	O
u	union
.	O
sym_mask	long
)	O
>	O
(	O
b	pointer
->	O
rela	struct
->	O
r_info	array
&	O
b	pointer
->	O
u	union
.	O
sym_mask	long
)	O
)	O
return	O
1	int
;	O
if	O
(	O
a	pointer
->	O
rela	struct
->	O
r_offset	array
<	O
b	pointer
->	O
rela	struct
->	O
r_offset	array
)	O
return	O
-	O
1	int
;	O
if	O
(	O
a	pointer
->	O
rela	struct
->	O
r_offset	array
>	O
b	pointer
->	O
rela	struct
->	O
r_offset	array
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
elf_link_sort_cmp2	function
(	O
const	O
void	O
*	O
A	pointer
,	O
const	O
void	O
*	O
B	pointer
)	O
{	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
a	pointer
=	O
(	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
A	pointer
;	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
b	pointer
=	O
(	O
const	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
B	pointer
;	O
if	O
(	O
a	pointer
->	O
type	enum
<	O
b	pointer
->	O
type	enum
)	O
return	O
-	O
1	int
;	O
if	O
(	O
a	pointer
->	O
type	enum
>	O
b	pointer
->	O
type	enum
)	O
return	O
1	int
;	O
if	O
(	O
a	pointer
->	O
u	union
.	O
offset	long
<	O
b	pointer
->	O
u	union
.	O
offset	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
a	pointer
->	O
u	union
.	O
offset	long
>	O
b	pointer
->	O
u	union
.	O
offset	long
)	O
return	O
1	int
;	O
if	O
(	O
a	pointer
->	O
rela	struct
->	O
r_offset	array
<	O
b	pointer
->	O
rela	struct
->	O
r_offset	array
)	O
return	O
-	O
1	int
;	O
if	O
(	O
a	pointer
->	O
rela	struct
->	O
r_offset	array
>	O
b	pointer
->	O
rela	struct
->	O
r_offset	array
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
elf_link_sort_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
*	O
psec	pointer
)	O
{	O
asection	struct
*	O
dynamic_relocs	int
;	O
asection	struct
*	O
rela_dyn	pointer
;	O
asection	struct
*	O
rel_dyn	pointer
;	O
bfd_size_type	long
count	int
,	O
size	long
;	O
size_t	long
i	pointer
,	O
ret	pointer
,	O
sort_elt	long
,	O
ext_size	long
;	O
bfd_byte	char
*	O
sort	int
,	O
*	O
s_non_relative	pointer
,	O
*	O
p	pointer
;	O
struct	O
elf_link_sort_rela	struct
*	O
sq	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
int	O
i2e	int
=	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
;	O
unsigned	O
int	O
opb	int
=	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
NULL	O
)	O
;	O
void	O
(	O
*	O
swap_in	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
bfd_byte	char
*	O
,	O
Elf_Internal_Rela	struct
*	O
)	O
;	O
void	O
(	O
*	O
swap_out	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
Elf_Internal_Rela	struct
*	O
,	O
bfd_byte	char
*	O
)	O
;	O
struct	O
bfd_link_order	struct
*	O
lo	long
;	O
bfd_vma	long
r_sym_mask	long
;	O
bfd_boolean	int
use_rela	int
;	O
rela_dyn	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".rela.dyn"	pointer
)	O
;	O
rel_dyn	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".rel.dyn"	pointer
)	O
;	O
if	O
(	O
rela_dyn	pointer
!=	O
NULL	O
&&	O
rela_dyn	pointer
->	O
size	long
>	O
0	int
&&	O
rel_dyn	pointer
!=	O
NULL	O
&&	O
rel_dyn	pointer
->	O
size	long
>	O
0	int
)	O
{	O
bfd_boolean	int
use_rela_initialised	int
=	O
FALSE	int
;	O
use_rela	int
=	O
TRUE	int
;	O
for	O
(	O
lo	long
=	O
rela_dyn	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
lo	long
!=	O
NULL	O
;	O
lo	long
=	O
lo	long
->	O
next	pointer
)	O
if	O
(	O
lo	long
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
asection	struct
*	O
o	pointer
=	O
lo	long
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
if	O
(	O
(	O
o	pointer
->	O
size	long
%	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
o	pointer
->	O
size	long
%	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
==	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
use_rela_initialised	int
&&	O
!	O
use_rela	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to sort relocs - "	pointer
"they are in more than one size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
use_rela	int
=	O
TRUE	int
;	O
use_rela_initialised	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
o	pointer
->	O
size	long
%	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
==	O
0	int
)	O
{	O
if	O
(	O
use_rela_initialised	int
&&	O
use_rela	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to sort relocs - "	pointer
"they are in more than one size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
use_rela	int
=	O
FALSE	int
;	O
use_rela_initialised	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to sort relocs - "	pointer
"they are of an unknown size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
for	O
(	O
lo	long
=	O
rel_dyn	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
lo	long
!=	O
NULL	O
;	O
lo	long
=	O
lo	long
->	O
next	pointer
)	O
if	O
(	O
lo	long
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
asection	struct
*	O
o	pointer
=	O
lo	long
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
if	O
(	O
(	O
o	pointer
->	O
size	long
%	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
o	pointer
->	O
size	long
%	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
==	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
use_rela_initialised	int
&&	O
!	O
use_rela	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to sort relocs - "	pointer
"they are in more than one size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
use_rela	int
=	O
TRUE	int
;	O
use_rela_initialised	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
o	pointer
->	O
size	long
%	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
==	O
0	int
)	O
{	O
if	O
(	O
use_rela_initialised	int
&&	O
use_rela	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to sort relocs - "	pointer
"they are in more than one size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
use_rela	int
=	O
FALSE	int
;	O
use_rela_initialised	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to sort relocs - "	pointer
"they are of an unknown size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
use_rela_initialised	int
)	O
use_rela	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
rela_dyn	pointer
!=	O
NULL	O
&&	O
rela_dyn	pointer
->	O
size	long
>	O
0	int
)	O
use_rela	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
rel_dyn	pointer
!=	O
NULL	O
&&	O
rel_dyn	pointer
->	O
size	long
>	O
0	int
)	O
use_rela	int
=	O
FALSE	int
;	O
else	O
return	O
0	int
;	O
if	O
(	O
use_rela	int
)	O
{	O
dynamic_relocs	int
=	O
rela_dyn	pointer
;	O
ext_size	long
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
;	O
swap_in	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_in	pointer
;	O
swap_out	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_out	pointer
;	O
}	O
else	O
{	O
dynamic_relocs	int
=	O
rel_dyn	pointer
;	O
ext_size	long
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
;	O
swap_in	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_in	pointer
;	O
swap_out	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_out	pointer
;	O
}	O
size	long
=	O
0	int
;	O
for	O
(	O
lo	long
=	O
dynamic_relocs	int
->	O
map_head	union
.	O
link_order	pointer
;	O
lo	long
!=	O
NULL	O
;	O
lo	long
=	O
lo	long
->	O
next	pointer
)	O
if	O
(	O
lo	long
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
size	long
+=	O
lo	long
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
size	long
;	O
if	O
(	O
size	long
!=	O
dynamic_relocs	int
->	O
size	long
)	O
return	O
0	int
;	O
sort_elt	long
=	O
(	O
sizeof	O
(	O
struct	O
elf_link_sort_rela	struct
)	O
+	O
(	O
i2e	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
)	O
;	O
count	int
=	O
dynamic_relocs	int
->	O
size	long
/	O
ext_size	long
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
sort	int
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_zmalloc	function
(	O
sort_elt	long
*	O
count	int
)	O
;	O
if	O
(	O
sort	int
==	O
NULL	O
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
warning	pointer
)	O
(	O
info	pointer
,	O
_	O
(	O
"not enough memory to sort relocations"	pointer
)	O
,	O
0	int
,	O
abfd	pointer
,	O
0	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
r_sym_mask	long
=	O
~	O
(	O
bfd_vma	long
)	O
0xff	int
;	O
else	O
r_sym_mask	long
=	O
~	O
(	O
bfd_vma	long
)	O
0xffffffff	int
;	O
for	O
(	O
lo	long
=	O
dynamic_relocs	int
->	O
map_head	union
.	O
link_order	pointer
;	O
lo	long
!=	O
NULL	O
;	O
lo	long
=	O
lo	long
->	O
next	pointer
)	O
if	O
(	O
lo	long
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
bfd_byte	char
*	O
erel	pointer
,	O
*	O
erelend	pointer
;	O
asection	struct
*	O
o	pointer
=	O
lo	long
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
if	O
(	O
o	pointer
->	O
contents	pointer
==	O
NULL	O
&&	O
o	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
free	function
(	O
sort	int
)	O
;	O
return	O
0	int
;	O
}	O
erel	pointer
=	O
o	pointer
->	O
contents	pointer
;	O
erelend	pointer
=	O
o	pointer
->	O
contents	pointer
+	O
o	pointer
->	O
size	long
;	O
p	pointer
=	O
sort	int
+	O
o	pointer
->	O
output_offset	long
*	O
opb	int
/	O
ext_size	long
*	O
sort_elt	long
;	O
while	O
(	O
erel	pointer
<	O
erelend	pointer
)	O
{	O
struct	O
elf_link_sort_rela	struct
*	O
s	pointer
=	O
(	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
p	pointer
;	O
(	O
*	O
swap_in	pointer
)	O
(	O
abfd	pointer
,	O
erel	pointer
,	O
s	pointer
->	O
rela	struct
)	O
;	O
s	pointer
->	O
type	enum
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_reloc_type_class	pointer
)	O
(	O
info	pointer
,	O
o	pointer
,	O
s	pointer
->	O
rela	struct
)	O
;	O
s	pointer
->	O
u	union
.	O
sym_mask	long
=	O
r_sym_mask	long
;	O
p	pointer
+=	O
sort_elt	long
;	O
erel	pointer
+=	O
ext_size	long
;	O
}	O
}	O
qsort	function
(	O
sort	int
,	O
count	int
,	O
sort_elt	long
,	O
elf_link_sort_cmp1	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
p	pointer
=	O
sort	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
,	O
p	pointer
+=	O
sort_elt	long
)	O
{	O
struct	O
elf_link_sort_rela	struct
*	O
s	pointer
=	O
(	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
p	pointer
;	O
if	O
(	O
s	pointer
->	O
type	enum
!=	O
reloc_class_relative	int
)	O
break	O
;	O
}	O
ret	pointer
=	O
i	pointer
;	O
s_non_relative	pointer
=	O
p	pointer
;	O
sq	pointer
=	O
(	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
s_non_relative	pointer
;	O
for	O
(	O
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
,	O
p	pointer
+=	O
sort_elt	long
)	O
{	O
struct	O
elf_link_sort_rela	struct
*	O
sp	pointer
=	O
(	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
p	pointer
;	O
if	O
(	O
(	O
(	O
sp	pointer
->	O
rela	struct
->	O
r_info	array
^	O
sq	pointer
->	O
rela	struct
->	O
r_info	array
)	O
&	O
r_sym_mask	long
)	O
!=	O
0	int
)	O
sq	pointer
=	O
sp	pointer
;	O
sp	pointer
->	O
u	union
.	O
offset	long
=	O
sq	pointer
->	O
rela	struct
->	O
r_offset	array
;	O
}	O
qsort	function
(	O
s_non_relative	pointer
,	O
count	int
-	O
ret	pointer
,	O
sort_elt	long
,	O
elf_link_sort_cmp2	function
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
srelplt	pointer
&&	O
htab	struct
->	O
srelplt	pointer
->	O
output_section	pointer
==	O
dynamic_relocs	int
)	O
{	O
sq	pointer
=	O
(	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
sort	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
sq	pointer
[	O
count	int
-	O
i	pointer
-	O
1	int
]	O
.	O
type	enum
!=	O
reloc_class_plt	int
)	O
break	O
;	O
if	O
(	O
i	pointer
!=	O
0	int
&&	O
htab	struct
->	O
srelplt	pointer
->	O
size	long
==	O
i	pointer
*	O
ext_size	long
)	O
{	O
struct	O
bfd_link_order	struct
*	O
*	O
plo	pointer
;	O
for	O
(	O
plo	pointer
=	O
&	O
dynamic_relocs	int
->	O
map_head	union
.	O
link_order	pointer
;	O
*	O
plo	pointer
!=	O
NULL	O
;	O
)	O
if	O
(	O
(	O
*	O
plo	pointer
)	O
->	O
type	enum
==	O
bfd_indirect_link_order	int
&&	O
(	O
*	O
plo	pointer
)	O
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
==	O
htab	struct
->	O
srelplt	pointer
)	O
{	O
lo	long
=	O
*	O
plo	pointer
;	O
*	O
plo	pointer
=	O
lo	long
->	O
next	pointer
;	O
}	O
else	O
plo	pointer
=	O
&	O
(	O
*	O
plo	pointer
)	O
->	O
next	pointer
;	O
*	O
plo	pointer
=	O
lo	long
;	O
lo	long
->	O
next	pointer
=	O
NULL	O
;	O
dynamic_relocs	int
->	O
map_tail	union
.	O
link_order	pointer
=	O
lo	long
;	O
}	O
}	O
p	pointer
=	O
sort	int
;	O
for	O
(	O
lo	long
=	O
dynamic_relocs	int
->	O
map_head	union
.	O
link_order	pointer
;	O
lo	long
!=	O
NULL	O
;	O
lo	long
=	O
lo	long
->	O
next	pointer
)	O
if	O
(	O
lo	long
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
bfd_byte	char
*	O
erel	pointer
,	O
*	O
erelend	pointer
;	O
asection	struct
*	O
o	pointer
=	O
lo	long
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
erel	pointer
=	O
o	pointer
->	O
contents	pointer
;	O
erelend	pointer
=	O
o	pointer
->	O
contents	pointer
+	O
o	pointer
->	O
size	long
;	O
o	pointer
->	O
output_offset	long
=	O
(	O
p	pointer
-	O
sort	int
)	O
/	O
sort_elt	long
*	O
ext_size	long
/	O
opb	int
;	O
while	O
(	O
erel	pointer
<	O
erelend	pointer
)	O
{	O
struct	O
elf_link_sort_rela	struct
*	O
s	pointer
=	O
(	O
struct	O
elf_link_sort_rela	struct
*	O
)	O
p	pointer
;	O
(	O
*	O
swap_out	pointer
)	O
(	O
abfd	pointer
,	O
s	pointer
->	O
rela	struct
,	O
erel	pointer
)	O
;	O
p	pointer
+=	O
sort_elt	long
;	O
erel	pointer
+=	O
ext_size	long
;	O
}	O
}	O
free	function
(	O
sort	int
)	O
;	O
*	O
psec	pointer
=	O
dynamic_relocs	int
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
elf_link_output_symstrtab	function
(	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
Elf_Internal_Sym	struct
*	O
elfsym	pointer
,	O
asection	struct
*	O
input_sec	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
int	O
(	O
*	O
output_symbol_hook	pointer
)	O
(	O
struct	O
bfd_link_info	struct
*	O
,	O
const	O
char	O
*	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_size_type	long
strtabsize	long
;	O
BFD_ASSERT	O
(	O
elf_onesymtab	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
;	O
output_symbol_hook	pointer
=	O
bed	pointer
->	O
elf_backend_link_output_symbol_hook	pointer
;	O
if	O
(	O
output_symbol_hook	pointer
!=	O
NULL	O
)	O
{	O
int	O
ret	pointer
=	O
(	O
*	O
output_symbol_hook	pointer
)	O
(	O
flinfo	pointer
->	O
info	pointer
,	O
name	pointer
,	O
elfsym	pointer
,	O
input_sec	pointer
,	O
h	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
1	int
)	O
return	O
ret	pointer
;	O
}	O
if	O
(	O
ELF_ST_TYPE	O
(	O
elfsym	pointer
->	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
elf_tdata	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
->	O
has_gnu_osabi	enum
|=	O
elf_gnu_osabi_ifunc	int
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
elfsym	pointer
->	O
st_info	array
)	O
==	O
STB_GNU_UNIQUE	int
)	O
elf_tdata	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
->	O
has_gnu_osabi	enum
|=	O
elf_gnu_osabi_unique	int
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
*	O
name	pointer
==	O
'\0'	O
||	O
(	O
input_sec	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
)	O
elfsym	pointer
->	O
st_name	array
=	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
;	O
else	O
{	O
elfsym	pointer
->	O
st_name	array
=	O
(	O
unsigned	O
long	O
)	O
_bfd_elf_strtab_add	function
(	O
flinfo	pointer
->	O
symstrtab	pointer
,	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
elfsym	pointer
->	O
st_name	array
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
return	O
0	int
;	O
}	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
;	O
strtabsize	long
=	O
hash_table	pointer
->	O
strtabsize	long
;	O
if	O
(	O
strtabsize	long
<=	O
hash_table	pointer
->	O
strtabcount	long
)	O
{	O
strtabsize	long
+=	O
strtabsize	long
;	O
hash_table	pointer
->	O
strtabsize	long
=	O
strtabsize	long
;	O
strtabsize	long
*=	O
sizeof	O
(	O
*	O
hash_table	pointer
->	O
strtab	pointer
)	O
;	O
hash_table	pointer
->	O
strtab	pointer
=	O
(	O
struct	O
elf_sym_strtab	struct
*	O
)	O
bfd_realloc	function
(	O
hash_table	pointer
->	O
strtab	pointer
,	O
strtabsize	long
)	O
;	O
if	O
(	O
hash_table	pointer
->	O
strtab	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
}	O
hash_table	pointer
->	O
strtab	pointer
[	O
hash_table	pointer
->	O
strtabcount	long
]	O
.	O
sym	pointer
=	O
*	O
elfsym	pointer
;	O
hash_table	pointer
->	O
strtab	pointer
[	O
hash_table	pointer
->	O
strtabcount	long
]	O
.	O
dest_index	long
=	O
hash_table	pointer
->	O
strtabcount	long
;	O
hash_table	pointer
->	O
strtab	pointer
[	O
hash_table	pointer
->	O
strtabcount	long
]	O
.	O
destshndx_index	long
=	O
flinfo	pointer
->	O
symshndxbuf	pointer
?	O
bfd_get_symcount	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
:	O
0	int
;	O
flinfo	pointer
->	O
output_bfd	pointer
->	O
symcount	int
+=	O
1	int
;	O
hash_table	pointer
->	O
strtabcount	long
+=	O
1	int
;	O
return	O
1	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_swap_symbols_out	function
(	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
hash_table	pointer
=	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
;	O
bfd_size_type	long
amt	long
;	O
size_t	long
i	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_byte	char
*	O
symbuf	pointer
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
file_ptr	long
pos	long
;	O
bfd_boolean	int
ret	pointer
;	O
if	O
(	O
!	O
hash_table	pointer
->	O
strtabcount	long
)	O
return	O
TRUE	int
;	O
BFD_ASSERT	O
(	O
elf_onesymtab	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
;	O
amt	long
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
*	O
hash_table	pointer
->	O
strtabcount	long
;	O
symbuf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
symbuf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
flinfo	pointer
->	O
symshndxbuf	pointer
)	O
{	O
amt	long
=	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
amt	long
*=	O
bfd_get_symcount	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
;	O
flinfo	pointer
->	O
symshndxbuf	pointer
=	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
bfd_zmalloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
symshndxbuf	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
symbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hash_table	pointer
->	O
strtabcount	long
;	O
i	pointer
++	O
)	O
{	O
struct	O
elf_sym_strtab	struct
*	O
elfsym	pointer
=	O
&	O
hash_table	pointer
->	O
strtab	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
=	O
0	int
;	O
else	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
=	O
(	O
unsigned	O
long	O
)	O
_bfd_elf_strtab_offset	function
(	O
flinfo	pointer
->	O
symstrtab	pointer
,	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
)	O
;	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_out	pointer
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
&	O
elfsym	pointer
->	O
sym	pointer
,	O
(	O
(	O
bfd_byte	char
*	O
)	O
symbuf	pointer
+	O
(	O
elfsym	pointer
->	O
dest_index	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
)	O
,	O
(	O
flinfo	pointer
->	O
symshndxbuf	pointer
+	O
elfsym	pointer
->	O
destshndx_index	long
)	O
)	O
;	O
}	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
callbacks	pointer
->	O
examine_strtab	pointer
)	O
flinfo	pointer
->	O
info	pointer
->	O
callbacks	pointer
->	O
examine_strtab	pointer
(	O
hash_table	pointer
->	O
strtab	pointer
,	O
hash_table	pointer
->	O
strtabcount	long
,	O
flinfo	pointer
->	O
symstrtab	pointer
)	O
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
pos	long
=	O
hdr	pointer
->	O
sh_offset	array
+	O
hdr	pointer
->	O
sh_size	array
;	O
amt	long
=	O
hash_table	pointer
->	O
strtabcount	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
bfd_seek	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
==	O
0	int
&&	O
bfd_bwrite	function
(	O
symbuf	pointer
,	O
amt	long
,	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
==	O
amt	long
)	O
{	O
hdr	pointer
->	O
sh_size	array
+=	O
amt	long
;	O
ret	pointer
=	O
TRUE	int
;	O
}	O
else	O
ret	pointer
=	O
FALSE	int
;	O
free	function
(	O
symbuf	pointer
)	O
;	O
free	function
(	O
hash_table	pointer
->	O
strtab	pointer
)	O
;	O
hash_table	pointer
->	O
strtab	pointer
=	O
NULL	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
check_dynsym	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
st_shndx	array
>=	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
&&	O
sym	pointer
->	O
st_shndx	array
<	O
SHN_LORESERVE	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: too many sections: %d (>= %d)"	pointer
)	O
,	O
abfd	pointer
,	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
,	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_nonrepresentable_section	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_link_check_versioned_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
struct	O
elf_link_loaded_list	struct
*	O
loaded	pointer
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
default	O
:	O
abfd	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
case	O
bfd_link_hash_undefweak	int
:	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
||	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
||	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
DYN_DT_NEEDED	int
)	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
break	O
;	O
case	O
bfd_link_hash_common	int
:	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
owner	pointer
;	O
break	O
;	O
}	O
BFD_ASSERT	O
(	O
abfd	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
loaded	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
loaded	pointer
;	O
loaded	pointer
!=	O
NULL	O
;	O
loaded	pointer
=	O
loaded	pointer
->	O
next	pointer
)	O
{	O
bfd	struct
*	O
input	pointer
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
size_t	long
symcount	int
;	O
size_t	long
extsymcount	long
;	O
size_t	long
extsymoff	long
;	O
Elf_Internal_Shdr	struct
*	O
versymhdr	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
Elf_Internal_Sym	struct
*	O
isymend	pointer
;	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
;	O
Elf_External_Versym	struct
*	O
ever	pointer
;	O
Elf_External_Versym	struct
*	O
extversym	pointer
;	O
input	pointer
=	O
loaded	pointer
->	O
abfd	pointer
;	O
if	O
(	O
input	pointer
==	O
abfd	pointer
||	O
(	O
input	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
||	O
elf_dynversym	O
(	O
input	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
input	pointer
)	O
->	O
dynsymtab_hdr	struct
;	O
symcount	int
=	O
hdr	pointer
->	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
elf_bad_symtab	O
(	O
input	pointer
)	O
)	O
{	O
extsymcount	long
=	O
symcount	int
;	O
extsymoff	long
=	O
0	int
;	O
}	O
else	O
{	O
extsymcount	long
=	O
symcount	int
-	O
hdr	pointer
->	O
sh_info	array
;	O
extsymoff	long
=	O
hdr	pointer
->	O
sh_info	array
;	O
}	O
if	O
(	O
extsymcount	long
==	O
0	int
)	O
continue	O
;	O
isymbuf	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
input	pointer
,	O
hdr	pointer
,	O
extsymcount	long
,	O
extsymoff	long
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
isymbuf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
versymhdr	pointer
=	O
&	O
elf_tdata	O
(	O
input	pointer
)	O
->	O
dynversym_hdr	struct
;	O
extversym	pointer
=	O
(	O
Elf_External_Versym	struct
*	O
)	O
bfd_malloc	function
(	O
versymhdr	pointer
->	O
sh_size	array
)	O
;	O
if	O
(	O
extversym	pointer
==	O
NULL	O
)	O
goto	O
error_ret	O
;	O
if	O
(	O
bfd_seek	function
(	O
input	pointer
,	O
versymhdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
(	O
bfd_bread	function
(	O
extversym	pointer
,	O
versymhdr	pointer
->	O
sh_size	array
,	O
input	pointer
)	O
!=	O
versymhdr	pointer
->	O
sh_size	array
)	O
)	O
{	O
free	function
(	O
extversym	pointer
)	O
;	O
error_ret	O
:	O
free	function
(	O
isymbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
ever	pointer
=	O
extversym	pointer
+	O
extsymoff	long
;	O
isymend	pointer
=	O
isymbuf	pointer
+	O
extsymcount	long
;	O
for	O
(	O
isym	pointer
=	O
isymbuf	pointer
;	O
isym	pointer
<	O
isymend	pointer
;	O
isym	pointer
++	O
,	O
ever	pointer
++	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
Elf_Internal_Versym	struct
iver	struct
;	O
unsigned	O
short	O
version_index	int
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STB_LOCAL	int
||	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_UNDEF	int
)	O
continue	O
;	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
input	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
isym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
!=	O
0	int
)	O
continue	O
;	O
_bfd_elf_swap_versym_in	function
(	O
input	pointer
,	O
ever	pointer
,	O
&	O
iver	struct
)	O
;	O
if	O
(	O
(	O
iver	struct
.	O
vs_vers	array
&	O
VERSYM_HIDDEN	int
)	O
==	O
0	int
&&	O
!	O
(	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
forced_local	int
)	O
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
version_index	int
=	O
iver	struct
.	O
vs_vers	array
&	O
VERSYM_VERSION	int
;	O
if	O
(	O
version_index	int
==	O
1	int
||	O
version_index	int
==	O
2	int
)	O
{	O
free	function
(	O
extversym	pointer
)	O
;	O
free	function
(	O
isymbuf	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
free	function
(	O
extversym	pointer
)	O
;	O
free	function
(	O
isymbuf	pointer
)	O
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
int	O
elf_link_convert_common_type	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
int	O
type	enum
)	O
{	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
switch	O
(	O
info	pointer
->	O
elf_stt_common	int
)	O
{	O
case	O
unchanged	int
:	O
break	O
;	O
case	O
elf_stt_common	int
:	O
type	enum
=	O
STT_COMMON	int
;	O
break	O
;	O
case	O
no_elf_stt_common	int
:	O
type	enum
=	O
STT_OBJECT	int
;	O
break	O
;	O
}	O
return	O
type	enum
;	O
}	O
static	O
bfd_boolean	int
elf_link_output_extsym	function
(	O
struct	O
bfd_hash_entry	struct
*	O
bh	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
struct	O
elf_outext_info	struct
*	O
eoinfo	pointer
=	O
(	O
struct	O
elf_outext_info	struct
*	O
)	O
data	pointer
;	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
=	O
eoinfo	pointer
->	O
flinfo	pointer
;	O
bfd_boolean	int
strip	enum
;	O
Elf_Internal_Sym	struct
sym	pointer
;	O
asection	struct
*	O
input_sec	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
long	O
indx	long
;	O
int	O
ret	pointer
;	O
unsigned	O
int	O
type	enum
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
{	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
)	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
eoinfo	pointer
->	O
localsyms	int
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
forced_local	int
)	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
h	pointer
->	O
forced_local	int
)	O
return	O
TRUE	int
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
{	O
bfd_boolean	int
ignore_undef	int
=	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_ignore_undef_symbol	pointer
)	O
ignore_undef	int
=	O
bed	pointer
->	O
elf_backend_ignore_undef_symbol	pointer
(	O
h	pointer
)	O
;	O
if	O
(	O
!	O
ignore_undef	int
&&	O
h	pointer
->	O
ref_dynamic_nonweak	int
&&	O
(	O
!	O
h	pointer
->	O
ref_regular	int
||	O
flinfo	pointer
->	O
info	pointer
->	O
gc_sections	int
)	O
&&	O
!	O
elf_link_check_versioned_symbol	function
(	O
flinfo	pointer
->	O
info	pointer
,	O
bed	pointer
,	O
h	pointer
)	O
&&	O
flinfo	pointer
->	O
info	pointer
->	O
unresolved_syms_in_shared_libs	enum
!=	O
RM_IGNORE	int
)	O
(	O
*	O
flinfo	pointer
->	O
info	pointer
->	O
callbacks	pointer
->	O
undefined_symbol	pointer
)	O
(	O
flinfo	pointer
->	O
info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
ref_regular	int
?	O
NULL	O
:	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
,	O
NULL	O
,	O
0	int
,	O
flinfo	pointer
->	O
info	pointer
->	O
unresolved_syms_in_shared_libs	enum
==	O
RM_GENERATE_ERROR	int
)	O
;	O
if	O
(	O
h	pointer
->	O
indx	long
==	O
-	O
3	int
)	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
bfd_link_executable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
&&	O
h	pointer
->	O
forced_local	int
&&	O
h	pointer
->	O
ref_dynamic	int
&&	O
h	pointer
->	O
def_regular	int
&&	O
!	O
h	pointer
->	O
dynamic_def	int
&&	O
h	pointer
->	O
ref_dynamic_nonweak	int
&&	O
!	O
elf_link_check_versioned_symbol	function
(	O
flinfo	pointer
->	O
info	pointer
,	O
bed	pointer
,	O
h	pointer
)	O
)	O
{	O
bfd	struct
*	O
def_bfd	pointer
;	O
const	O
char	O
*	O
msg	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
hi	pointer
=	O
h	pointer
;	O
while	O
(	O
hi	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
hi	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_INTERNAL	int
)	O
msg	pointer
=	O
_	O
(	O
"%pB: internal symbol `%s' in %pB is referenced by DSO"	pointer
)	O
;	O
else	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_HIDDEN	int
)	O
msg	pointer
=	O
_	O
(	O
"%pB: hidden symbol `%s' in %pB is referenced by DSO"	pointer
)	O
;	O
else	O
msg	pointer
=	O
_	O
(	O
"%pB: local symbol `%s' in %pB is referenced by DSO"	pointer
)	O
;	O
def_bfd	pointer
=	O
flinfo	pointer
->	O
output_bfd	pointer
;	O
if	O
(	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
def_bfd	pointer
=	O
hi	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
_bfd_error_handler	function
(	O
msg	pointer
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
def_bfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
strip	enum
=	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
indx	long
==	O
-	O
2	int
)	O
;	O
else	O
if	O
(	O
(	O
h	pointer
->	O
def_dynamic	int
||	O
h	pointer
->	O
ref_dynamic	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
)	O
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
!	O
h	pointer
->	O
ref_regular	int
)	O
strip	enum
=	O
TRUE	int
;	O
else	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
)	O
strip	enum
=	O
TRUE	int
;	O
else	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
bfd_hash_lookup	function
(	O
flinfo	pointer
->	O
info	pointer
->	O
keep_hash	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
strip	enum
=	O
TRUE	int
;	O
else	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
strip_discarded	int
&&	O
discarded_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
)	O
||	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
&&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
)	O
)	O
strip	enum
=	O
TRUE	int
;	O
else	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
&&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
strip	enum
=	O
TRUE	int
;	O
type	enum
=	O
h	pointer
->	O
type	enum
;	O
if	O
(	O
strip	enum
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
type	enum
!=	O
STT_GNU_IFUNC	int
&&	O
!	O
h	pointer
->	O
forced_local	int
)	O
return	O
TRUE	int
;	O
sym	pointer
.	O
st_value	array
=	O
0	int
;	O
sym	pointer
.	O
st_size	long
=	O
h	pointer
->	O
size	long
;	O
sym	pointer
.	O
st_other	array
=	O
h	pointer
->	O
other	int
;	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
default	O
:	O
case	O
bfd_link_hash_new	int
:	O
case	O
bfd_link_hash_warning	int
:	O
abort	function
(	O
)	O
;	O
return	O
FALSE	int
;	O
case	O
bfd_link_hash_undefined	int
:	O
case	O
bfd_link_hash_undefweak	int
:	O
input_sec	pointer
=	O
bfd_und_section_ptr	O
;	O
sym	pointer
.	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
break	O
;	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
{	O
input_sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
if	O
(	O
input_sec	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
sym	pointer
.	O
st_shndx	array
=	O
_bfd_elf_section_from_bfd_section	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
input_sec	pointer
->	O
output_section	pointer
)	O
;	O
if	O
(	O
sym	pointer
.	O
st_shndx	array
==	O
SHN_BAD	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: could not find output section %pA for input section %pA"	pointer
)	O
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
input_sec	pointer
->	O
output_section	pointer
,	O
input_sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_nonrepresentable_section	int
)	O
;	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
sym	pointer
.	O
st_value	array
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
input_sec	pointer
->	O
output_offset	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
{	O
sym	pointer
.	O
st_value	array
+=	O
input_sec	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_TLS	int
)	O
{	O
asection	struct
*	O
tls_sec	pointer
=	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
tls_sec	pointer
;	O
if	O
(	O
tls_sec	pointer
!=	O
NULL	O
)	O
sym	pointer
.	O
st_value	array
-=	O
tls_sec	pointer
->	O
vma	long
;	O
}	O
}	O
}	O
else	O
{	O
BFD_ASSERT	O
(	O
input_sec	pointer
->	O
owner	pointer
==	O
NULL	O
||	O
(	O
input_sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
;	O
sym	pointer
.	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
input_sec	pointer
=	O
bfd_und_section_ptr	O
;	O
}	O
}	O
break	O
;	O
case	O
bfd_link_hash_common	int
:	O
input_sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
;	O
sym	pointer
.	O
st_shndx	array
=	O
bed	pointer
->	O
common_section_index	pointer
(	O
input_sec	pointer
)	O
;	O
sym	pointer
.	O
st_value	array
=	O
1	int
<<	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
;	O
break	O
;	O
case	O
bfd_link_hash_indirect	int
:	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
type	enum
==	O
STT_COMMON	int
||	O
type	enum
==	O
STT_OBJECT	int
)	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
case	O
bfd_link_hash_common	int
:	O
type	enum
=	O
elf_link_convert_common_type	function
(	O
flinfo	pointer
->	O
info	pointer
,	O
type	enum
)	O
;	O
break	O
;	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
if	O
(	O
bed	pointer
->	O
common_definition	pointer
(	O
&	O
sym	pointer
)	O
)	O
type	enum
=	O
elf_link_convert_common_type	function
(	O
flinfo	pointer
->	O
info	pointer
,	O
type	enum
)	O
;	O
else	O
type	enum
=	O
STT_OBJECT	int
;	O
break	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
case	O
bfd_link_hash_undefweak	int
:	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
forced_local	int
)	O
{	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
type	enum
)	O
;	O
sym	pointer
.	O
st_other	array
&=	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
h	pointer
->	O
unique_global	int
&&	O
h	pointer
->	O
def_regular	int
)	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_GNU_UNIQUE	int
,	O
type	enum
)	O
;	O
else	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_WEAK	int
,	O
type	enum
)	O
;	O
else	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_GLOBAL	int
,	O
type	enum
)	O
;	O
sym	pointer
.	O
st_target_internal	char
=	O
h	pointer
->	O
target_internal	int
;	O
if	O
(	O
(	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
h	pointer
->	O
def_regular	int
&&	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
||	O
(	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
||	O
h	pointer
->	O
forced_local	int
)	O
&&	O
(	O
(	O
bfd_link_pic	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
&&	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_DEFAULT	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
)	O
)	O
||	O
!	O
h	pointer
->	O
forced_local	int
)	O
&&	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
dynamic_sections_created	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_finish_dynamic_symbol	pointer
)	O
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
flinfo	pointer
->	O
info	pointer
,	O
h	pointer
,	O
&	O
sym	pointer
)	O
)	O
)	O
{	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
sym	pointer
.	O
st_shndx	array
==	O
SHN_UNDEF	int
&&	O
h	pointer
->	O
ref_regular	int
&&	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
.	O
st_info	array
)	O
==	O
STB_GLOBAL	int
||	O
ELF_ST_BIND	O
(	O
sym	pointer
.	O
st_info	array
)	O
==	O
STB_WEAK	int
)	O
)	O
{	O
int	O
bindtype	int
;	O
type	enum
=	O
ELF_ST_TYPE	O
(	O
sym	pointer
.	O
st_info	array
)	O
;	O
if	O
(	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
type	enum
=	O
STT_FUNC	int
;	O
if	O
(	O
h	pointer
->	O
ref_regular_nonweak	int
)	O
bindtype	int
=	O
STB_GLOBAL	int
;	O
else	O
bindtype	int
=	O
STB_WEAK	int
;	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
bindtype	int
,	O
type	enum
)	O
;	O
}	O
if	O
(	O
sym	pointer
.	O
st_shndx	array
==	O
SHN_UNDEF	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
sym	pointer
.	O
st_size	long
=	O
0	int
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
&&	O
ELF_ST_VISIBILITY	O
(	O
sym	pointer
.	O
st_other	array
)	O
!=	O
STV_DEFAULT	int
&&	O
ELF_ST_BIND	O
(	O
sym	pointer
.	O
st_info	array
)	O
!=	O
STB_WEAK	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
&&	O
!	O
h	pointer
->	O
def_regular	int
)	O
{	O
const	O
char	O
*	O
msg	pointer
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
sym	pointer
.	O
st_other	array
)	O
==	O
STV_PROTECTED	int
)	O
msg	pointer
=	O
_	O
(	O
"%pB: protected symbol `%s' isn't defined"	pointer
)	O
;	O
else	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
sym	pointer
.	O
st_other	array
)	O
==	O
STV_INTERNAL	int
)	O
msg	pointer
=	O
_	O
(	O
"%pB: internal symbol `%s' isn't defined"	pointer
)	O
;	O
else	O
msg	pointer
=	O
_	O
(	O
"%pB: hidden symbol `%s' isn't defined"	pointer
)	O
;	O
_bfd_error_handler	function
(	O
msg	pointer
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
dynamic_sections_created	int
&&	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
dynsym	pointer
!=	O
NULL	O
&&	O
!	O
discarded_section	function
(	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
dynsym	pointer
)	O
)	O
{	O
bfd_byte	char
*	O
esym	array
;	O
if	O
(	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
==	O
NULL	O
&&	O
(	O
!	O
bfd_link_executable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
||	O
h	pointer
->	O
ref_dynamic	int
||	O
!	O
h	pointer
->	O
def_regular	int
)	O
)	O
{	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
ELF_VER_CHR	char
)	O
;	O
if	O
(	O
p	pointer
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: no symbol version section for versioned symbol `%s'"	pointer
)	O
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
sym	pointer
.	O
st_name	array
=	O
h	pointer
->	O
dynstr_index	long
;	O
esym	array
=	O
(	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
dynsym	pointer
->	O
contents	pointer
+	O
h	pointer
->	O
dynindx	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
;	O
if	O
(	O
!	O
check_dynsym	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
&	O
sym	pointer
)	O
)	O
{	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_out	pointer
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
&	O
sym	pointer
,	O
esym	array
,	O
0	int
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
hash_sec	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
hash_entry_size	long
;	O
bfd_byte	char
*	O
bucketpos	pointer
;	O
bfd_vma	long
chain	long
;	O
size_t	long
bucketcount	long
;	O
size_t	long
bucket	long
;	O
bucketcount	long
=	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
bucketcount	long
;	O
bucket	long
=	O
h	pointer
->	O
u	union
.	O
elf_hash_value	long
%	O
bucketcount	long
;	O
hash_entry_size	long
=	O
elf_section_data	O
(	O
flinfo	pointer
->	O
hash_sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
;	O
bucketpos	pointer
=	O
(	O
(	O
bfd_byte	char
*	O
)	O
flinfo	pointer
->	O
hash_sec	pointer
->	O
contents	pointer
+	O
(	O
bucket	long
+	O
2	int
)	O
*	O
hash_entry_size	long
)	O
;	O
chain	long
=	O
bfd_get	O
(	O
8	int
*	O
hash_entry_size	long
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
bucketpos	pointer
)	O
;	O
bfd_put	O
(	O
8	int
*	O
hash_entry_size	long
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
h	pointer
->	O
dynindx	long
,	O
bucketpos	pointer
)	O
;	O
bfd_put	O
(	O
8	int
*	O
hash_entry_size	long
,	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
chain	long
,	O
(	O
(	O
bfd_byte	char
*	O
)	O
flinfo	pointer
->	O
hash_sec	pointer
->	O
contents	pointer
+	O
(	O
bucketcount	long
+	O
2	int
+	O
h	pointer
->	O
dynindx	long
)	O
*	O
hash_entry_size	long
)	O
)	O
;	O
}	O
if	O
(	O
flinfo	pointer
->	O
symver_sec	pointer
!=	O
NULL	O
&&	O
flinfo	pointer
->	O
symver_sec	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
Elf_Internal_Versym	struct
iversym	struct
;	O
Elf_External_Versym	struct
*	O
eversym	pointer
;	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
&&	O
!	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
==	O
NULL	O
||	O
(	O
elf_dyn_lib_class	O
(	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_bfd	pointer
)	O
&	O
(	O
DYN_AS_NEEDED	int
|	O
DYN_DT_NEEDED	int
|	O
DYN_NO_NEEDED	int
)	O
)	O
)	O
iversym	struct
.	O
vs_vers	array
=	O
0	int
;	O
else	O
iversym	struct
.	O
vs_vers	array
=	O
h	pointer
->	O
verinfo	union
.	O
verdef	pointer
->	O
vd_exp_refno	int
+	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
==	O
NULL	O
)	O
iversym	struct
.	O
vs_vers	array
=	O
1	int
;	O
else	O
iversym	struct
.	O
vs_vers	array
=	O
h	pointer
->	O
verinfo	union
.	O
vertree	pointer
->	O
vernum	int
+	O
1	int
;	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
create_default_symver	int
)	O
iversym	struct
.	O
vs_vers	array
++	O
;	O
}	O
if	O
(	O
h	pointer
->	O
versioned	int
==	O
versioned_hidden	int
&&	O
h	pointer
->	O
def_regular	int
)	O
iversym	struct
.	O
vs_vers	array
|=	O
VERSYM_HIDDEN	int
;	O
eversym	pointer
=	O
(	O
Elf_External_Versym	struct
*	O
)	O
flinfo	pointer
->	O
symver_sec	pointer
->	O
contents	pointer
;	O
eversym	pointer
+=	O
h	pointer
->	O
dynindx	long
;	O
_bfd_elf_swap_versym_out	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
,	O
&	O
iversym	struct
,	O
eversym	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
input_sec	pointer
==	O
bfd_und_section_ptr	O
&&	O
h	pointer
->	O
indx	long
!=	O
-	O
2	int
&&	O
(	O
h	pointer
->	O
mark	int
!=	O
1	int
||	O
ELF_ST_BIND	O
(	O
sym	pointer
.	O
st_info	array
)	O
!=	O
STB_GLOBAL	int
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
strip	enum
)	O
return	O
TRUE	int
;	O
if	O
(	O
(	O
input_sec	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
eoinfo	pointer
->	O
localsyms	int
&&	O
!	O
eoinfo	pointer
->	O
file_sym_done	int
&&	O
eoinfo	pointer
->	O
flinfo	pointer
->	O
filesym_count	long
!=	O
0	int
)	O
{	O
Elf_Internal_Sym	struct
fsym	struct
;	O
memset	function
(	O
&	O
fsym	struct
,	O
0	int
,	O
sizeof	O
(	O
fsym	struct
)	O
)	O
;	O
fsym	struct
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_FILE	int
)	O
;	O
fsym	struct
.	O
st_shndx	array
=	O
SHN_ABS	O
;	O
if	O
(	O
!	O
elf_link_output_symstrtab	function
(	O
eoinfo	pointer
->	O
flinfo	pointer
,	O
NULL	O
,	O
&	O
fsym	struct
,	O
bfd_und_section_ptr	O
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
eoinfo	pointer
->	O
file_sym_done	int
=	O
TRUE	int
;	O
}	O
indx	long
=	O
bfd_get_symcount	function
(	O
flinfo	pointer
->	O
output_bfd	pointer
)	O
;	O
ret	pointer
=	O
elf_link_output_symstrtab	function
(	O
flinfo	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
&	O
sym	pointer
,	O
input_sec	pointer
,	O
h	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
eoinfo	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
ret	pointer
==	O
1	int
)	O
h	pointer
->	O
indx	long
=	O
indx	long
;	O
else	O
if	O
(	O
h	pointer
->	O
indx	long
==	O
-	O
2	int
)	O
abort	function
(	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_section_ignore_discarded_relocs	function
(	O
asection	struct
*	O
sec	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
switch	O
(	O
sec	pointer
->	O
sec_info_type	int
)	O
{	O
case	O
SEC_INFO_TYPE_STABS	int
:	O
case	O
SEC_INFO_TYPE_EH_FRAME	int
:	O
case	O
SEC_INFO_TYPE_EH_FRAME_ENTRY	int
:	O
return	O
TRUE	int
;	O
default	O
:	O
break	O
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
sec	pointer
->	O
owner	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_ignore_discarded_relocs	pointer
!=	O
NULL	O
&&	O
(	O
*	O
bed	pointer
->	O
elf_backend_ignore_discarded_relocs	pointer
)	O
(	O
sec	pointer
)	O
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
unsigned	O
int	O
_bfd_elf_default_action_discarded	function
(	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
return	O
PRETEND	int
;	O
if	O
(	O
strcmp	function
(	O
".eh_frame"	pointer
,	O
sec	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
".gcc_except_table"	pointer
,	O
sec	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
COMPLAIN	int
|	O
PRETEND	int
;	O
}	O
static	O
asection	struct
*	O
match_group_member	function
(	O
asection	struct
*	O
sec	pointer
,	O
asection	struct
*	O
group	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
first	long
=	O
elf_next_in_group	O
(	O
group	pointer
)	O
;	O
asection	struct
*	O
s	pointer
=	O
first	long
;	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bfd_elf_match_symbols_in_sections	function
(	O
s	pointer
,	O
sec	pointer
,	O
info	pointer
)	O
)	O
return	O
s	pointer
;	O
s	pointer
=	O
elf_next_in_group	O
(	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
first	long
)	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
asection	struct
*	O
_bfd_elf_check_kept_section	function
(	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
kept	pointer
;	O
kept	pointer
=	O
sec	pointer
->	O
kept_section	pointer
;	O
if	O
(	O
kept	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
kept	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
kept	pointer
=	O
match_group_member	function
(	O
sec	pointer
,	O
kept	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
kept	pointer
!=	O
NULL	O
&&	O
(	O
(	O
sec	pointer
->	O
rawsize	long
!=	O
0	int
?	O
sec	pointer
->	O
rawsize	long
:	O
sec	pointer
->	O
size	long
)	O
!=	O
(	O
kept	pointer
->	O
rawsize	long
!=	O
0	int
?	O
kept	pointer
->	O
rawsize	long
:	O
kept	pointer
->	O
size	long
)	O
)	O
)	O
kept	pointer
=	O
NULL	O
;	O
sec	pointer
->	O
kept_section	pointer
=	O
kept	pointer
;	O
}	O
return	O
kept	pointer
;	O
}	O
static	O
bfd_boolean	int
elf_link_input_bfd	function
(	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
)	O
{	O
int	O
(	O
*	O
relocate_section	pointer
)	O
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
bfd_byte	char
*	O
,	O
Elf_Internal_Rela	struct
*	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
asection	struct
*	O
*	O
)	O
;	O
bfd	struct
*	O
output_bfd	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
size_t	long
locsymcount	long
;	O
size_t	long
extsymoff	long
;	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
Elf_Internal_Sym	struct
*	O
isymend	pointer
;	O
long	O
*	O
pindex	pointer
;	O
asection	struct
*	O
*	O
ppsection	pointer
;	O
asection	struct
*	O
o	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
;	O
bfd_size_type	long
address_size	long
;	O
bfd_vma	long
r_type_mask	long
;	O
int	O
r_sym_shift	int
;	O
bfd_boolean	int
have_file_sym	int
=	O
FALSE	int
;	O
output_bfd	pointer
=	O
flinfo	pointer
->	O
output_bfd	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
relocate_section	pointer
=	O
bed	pointer
->	O
elf_backend_relocate_section	pointer
;	O
if	O
(	O
(	O
input_bfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
input_bfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
if	O
(	O
elf_bad_symtab	O
(	O
input_bfd	pointer
)	O
)	O
{	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
extsymoff	long
=	O
0	int
;	O
}	O
else	O
{	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
extsymoff	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
}	O
isymbuf	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
symtab_hdr	struct
->	O
contents	pointer
;	O
if	O
(	O
isymbuf	pointer
==	O
NULL	O
&&	O
locsymcount	long
!=	O
0	int
)	O
{	O
isymbuf	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
locsymcount	long
,	O
0	int
,	O
flinfo	pointer
->	O
internal_syms	pointer
,	O
flinfo	pointer
->	O
external_syms	pointer
,	O
flinfo	pointer
->	O
locsym_shndx	pointer
)	O
;	O
if	O
(	O
isymbuf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
isymend	pointer
=	O
isymbuf	pointer
+	O
locsymcount	long
;	O
for	O
(	O
isym	pointer
=	O
isymbuf	pointer
,	O
pindex	pointer
=	O
flinfo	pointer
->	O
indices	pointer
,	O
ppsection	pointer
=	O
flinfo	pointer
->	O
sections	pointer
;	O
isym	pointer
<	O
isymend	pointer
;	O
isym	pointer
++	O
,	O
pindex	pointer
++	O
,	O
ppsection	pointer
++	O
)	O
{	O
asection	struct
*	O
isec	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
Elf_Internal_Sym	struct
osym	pointer
;	O
long	O
indx	long
;	O
int	O
ret	pointer
;	O
*	O
pindex	pointer
=	O
-	O
1	int
;	O
if	O
(	O
elf_bad_symtab	O
(	O
input_bfd	pointer
)	O
)	O
{	O
if	O
(	O
ELF_ST_BIND	O
(	O
isym	pointer
->	O
st_info	array
)	O
!=	O
STB_LOCAL	int
)	O
{	O
*	O
ppsection	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_UNDEF	int
)	O
isec	pointer
=	O
bfd_und_section_ptr	O
;	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_ABS	O
)	O
isec	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
)	O
isec	pointer
=	O
bfd_com_section_ptr	O
;	O
else	O
{	O
isec	pointer
=	O
bfd_section_from_elf_index	function
(	O
input_bfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
isec	pointer
==	O
NULL	O
)	O
{	O
isec	pointer
=	O
bfd_und_section_ptr	O
;	O
}	O
else	O
if	O
(	O
isec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_MERGE	int
&&	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
!=	O
STT_SECTION	int
)	O
isym	pointer
->	O
st_value	array
=	O
_bfd_merged_section_offset	function
(	O
output_bfd	pointer
,	O
&	O
isec	pointer
,	O
elf_section_data	O
(	O
isec	pointer
)	O
->	O
sec_info	pointer
,	O
isym	pointer
->	O
st_value	array
)	O
;	O
}	O
*	O
ppsection	pointer
=	O
isec	pointer
;	O
if	O
(	O
isec	pointer
==	O
bfd_und_section_ptr	O
)	O
continue	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_SECTION	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
)	O
continue	O
;	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
discard	enum
==	O
discard_all	int
)	O
continue	O
;	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
!=	O
SHN_UNDEF	int
&&	O
isym	pointer
->	O
st_shndx	array
<	O
SHN_LORESERVE	O
&&	O
bfd_section_removed_from_list	function
(	O
output_bfd	pointer
,	O
isec	pointer
->	O
output_section	pointer
)	O
)	O
continue	O
;	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
->	O
sh_link	array
,	O
isym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
(	O
bfd_hash_lookup	function
(	O
flinfo	pointer
->	O
info	pointer
->	O
keep_hash	pointer
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
)	O
||	O
(	O
(	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
discard	enum
==	O
discard_sec_merge	int
&&	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
||	O
flinfo	pointer
->	O
info	pointer
->	O
discard	enum
==	O
discard_l	int
)	O
&&	O
bfd_is_local_label_name	function
(	O
input_bfd	pointer
,	O
name	pointer
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_FILE	int
)	O
{	O
if	O
(	O
input_bfd	pointer
->	O
lto_output	int
)	O
continue	O
;	O
have_file_sym	int
=	O
TRUE	int
;	O
flinfo	pointer
->	O
filesym_count	long
+=	O
1	int
;	O
}	O
if	O
(	O
!	O
have_file_sym	int
)	O
{	O
have_file_sym	int
=	O
TRUE	int
;	O
flinfo	pointer
->	O
filesym_count	long
+=	O
1	int
;	O
memset	function
(	O
&	O
osym	pointer
,	O
0	int
,	O
sizeof	O
(	O
osym	pointer
)	O
)	O
;	O
osym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_FILE	int
)	O
;	O
osym	pointer
.	O
st_shndx	array
=	O
SHN_ABS	O
;	O
if	O
(	O
!	O
elf_link_output_symstrtab	function
(	O
flinfo	pointer
,	O
(	O
input_bfd	pointer
->	O
lto_output	int
?	O
NULL	O
:	O
input_bfd	pointer
->	O
filename	pointer
)	O
,	O
&	O
osym	pointer
,	O
bfd_abs_section_ptr	O
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
osym	pointer
=	O
*	O
isym	pointer
;	O
osym	pointer
.	O
st_shndx	array
=	O
_bfd_elf_section_from_bfd_section	function
(	O
output_bfd	pointer
,	O
isec	pointer
->	O
output_section	pointer
)	O
;	O
if	O
(	O
osym	pointer
.	O
st_shndx	array
==	O
SHN_BAD	O
)	O
return	O
FALSE	int
;	O
osym	pointer
.	O
st_value	array
+=	O
isec	pointer
->	O
output_offset	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
{	O
osym	pointer
.	O
st_value	array
+=	O
isec	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
osym	pointer
.	O
st_info	array
)	O
==	O
STT_TLS	int
)	O
{	O
if	O
(	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
tls_sec	pointer
!=	O
NULL	O
)	O
osym	pointer
.	O
st_value	array
-=	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
tls_sec	pointer
->	O
vma	long
;	O
else	O
osym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
ELF_ST_BIND	O
(	O
osym	pointer
.	O
st_info	array
)	O
,	O
STT_NOTYPE	int
)	O
;	O
}	O
}	O
indx	long
=	O
bfd_get_symcount	function
(	O
output_bfd	pointer
)	O
;	O
ret	pointer
=	O
elf_link_output_symstrtab	function
(	O
flinfo	pointer
,	O
name	pointer
,	O
&	O
osym	pointer
,	O
isec	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
return	O
FALSE	int
;	O
else	O
if	O
(	O
ret	pointer
==	O
1	int
)	O
*	O
pindex	pointer
=	O
indx	long
;	O
}	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
{	O
r_type_mask	long
=	O
0xff	int
;	O
r_sym_shift	int
=	O
8	int
;	O
address_size	long
=	O
4	int
;	O
}	O
else	O
{	O
r_type_mask	long
=	O
0xffffffff	int
;	O
r_sym_shift	int
=	O
32	int
;	O
address_size	long
=	O
8	int
;	O
}	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
input_bfd	pointer
)	O
;	O
for	O
(	O
o	pointer
=	O
input_bfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
bfd_byte	char
*	O
contents	pointer
;	O
if	O
(	O
!	O
o	pointer
->	O
linker_mark	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
!	O
flinfo	pointer
->	O
info	pointer
->	O
resolve_section_groups	int
&&	O
(	O
o	pointer
->	O
flags	int
&	O
(	O
SEC_LINKER_CREATED	int
|	O
SEC_GROUP	int
)	O
)	O
==	O
SEC_GROUP	int
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
sec_data	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
unsigned	O
long	O
symndx	long
=	O
sec_data	pointer
->	O
this_hdr	struct
.	O
sh_info	array
;	O
asection	struct
*	O
osec	pointer
=	O
o	pointer
->	O
output_section	pointer
;	O
BFD_ASSERT	O
(	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
;	O
if	O
(	O
symndx	long
>=	O
locsymcount	long
||	O
(	O
elf_bad_symtab	O
(	O
input_bfd	pointer
)	O
&&	O
flinfo	pointer
->	O
sections	pointer
[	O
symndx	long
]	O
==	O
NULL	O
)	O
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
sym_hashes	pointer
[	O
symndx	long
-	O
extsymoff	long
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
h	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
-	O
2	int
;	O
}	O
else	O
if	O
(	O
ELF_ST_TYPE	O
(	O
isymbuf	pointer
[	O
symndx	long
]	O
.	O
st_info	array
)	O
==	O
STT_SECTION	int
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
flinfo	pointer
->	O
sections	pointer
[	O
symndx	long
]	O
->	O
output_section	pointer
;	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
sec	pointer
->	O
target_index	int
;	O
}	O
else	O
{	O
if	O
(	O
flinfo	pointer
->	O
indices	pointer
[	O
symndx	long
]	O
==	O
-	O
1	int
)	O
{	O
Elf_Internal_Sym	struct
sym	pointer
=	O
isymbuf	pointer
[	O
symndx	long
]	O
;	O
asection	struct
*	O
sec	pointer
=	O
flinfo	pointer
->	O
sections	pointer
[	O
symndx	long
]	O
->	O
output_section	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
long	O
indx	long
;	O
int	O
ret	pointer
;	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
->	O
sh_link	array
,	O
sym	pointer
.	O
st_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sym	pointer
.	O
st_shndx	array
=	O
_bfd_elf_section_from_bfd_section	function
(	O
output_bfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
sym	pointer
.	O
st_shndx	array
==	O
SHN_BAD	O
)	O
return	O
FALSE	int
;	O
sym	pointer
.	O
st_value	array
+=	O
o	pointer
->	O
output_offset	long
;	O
indx	long
=	O
bfd_get_symcount	function
(	O
output_bfd	pointer
)	O
;	O
ret	pointer
=	O
elf_link_output_symstrtab	function
(	O
flinfo	pointer
,	O
name	pointer
,	O
&	O
sym	pointer
,	O
o	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
return	O
FALSE	int
;	O
else	O
if	O
(	O
ret	pointer
==	O
1	int
)	O
flinfo	pointer
->	O
indices	pointer
[	O
symndx	long
]	O
=	O
indx	long
;	O
else	O
abort	function
(	O
)	O
;	O
}	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
flinfo	pointer
->	O
indices	pointer
[	O
symndx	long
]	O
;	O
}	O
}	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
||	O
(	O
o	pointer
->	O
size	long
==	O
0	int
&&	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
NULL	O
)	O
{	O
contents	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
;	O
if	O
(	O
bed	pointer
->	O
caches_rawsize	int
&&	O
o	pointer
->	O
rawsize	long
!=	O
0	int
&&	O
o	pointer
->	O
rawsize	long
<	O
o	pointer
->	O
size	long
)	O
{	O
memcpy	function
(	O
flinfo	pointer
->	O
contents	pointer
,	O
contents	pointer
,	O
o	pointer
->	O
rawsize	long
)	O
;	O
contents	pointer
=	O
flinfo	pointer
->	O
contents	pointer
;	O
}	O
}	O
else	O
{	O
contents	pointer
=	O
flinfo	pointer
->	O
contents	pointer
;	O
if	O
(	O
!	O
bfd_get_full_section_contents	function
(	O
input_bfd	pointer
,	O
o	pointer
,	O
&	O
contents	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
;	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
*	O
relend	pointer
;	O
int	O
action_discarded	enum
;	O
int	O
ret	pointer
;	O
internal_relocs	pointer
=	O
_bfd_elf_link_read_relocs	function
(	O
input_bfd	pointer
,	O
o	pointer
,	O
flinfo	pointer
->	O
external_relocs	pointer
,	O
flinfo	pointer
->	O
internal_relocs	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
&&	O
o	pointer
->	O
reloc_count	int
>	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
o	pointer
->	O
size	long
>	O
address_size	long
&&	O
(	O
(	O
strncmp	function
(	O
o	pointer
->	O
name	pointer
,	O
".ctors"	pointer
,	O
6	int
)	O
==	O
0	int
&&	O
strcmp	function
(	O
o	pointer
->	O
output_section	pointer
->	O
name	pointer
,	O
".init_array"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strncmp	function
(	O
o	pointer
->	O
name	pointer
,	O
".dtors"	pointer
,	O
6	int
)	O
==	O
0	int
&&	O
strcmp	function
(	O
o	pointer
->	O
output_section	pointer
->	O
name	pointer
,	O
".fini_array"	pointer
)	O
==	O
0	int
)	O
)	O
&&	O
(	O
o	pointer
->	O
name	pointer
[	O
6	int
]	O
==	O
0	int
||	O
o	pointer
->	O
name	pointer
[	O
6	int
]	O
==	O
'.'	O
)	O
)	O
{	O
if	O
(	O
o	pointer
->	O
size	long
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
!=	O
o	pointer
->	O
reloc_count	int
*	O
address_size	long
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"error: %pB: size of section %pA is not "	pointer
"multiple of address size"	pointer
)	O
,	O
input_bfd	pointer
,	O
o	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
o	pointer
->	O
flags	int
|=	O
SEC_ELF_REVERSE_COPY	int
;	O
}	O
action_discarded	enum
=	O
-	O
1	int
;	O
if	O
(	O
!	O
elf_section_ignore_discarded_relocs	function
(	O
o	pointer
)	O
)	O
action_discarded	enum
=	O
(	O
*	O
bed	pointer
->	O
action_discarded	enum
)	O
(	O
o	pointer
)	O
;	O
rel	pointer
=	O
internal_relocs	pointer
;	O
relend	pointer
=	O
rel	pointer
+	O
o	pointer
->	O
reloc_count	int
;	O
for	O
(	O
;	O
rel	pointer
<	O
relend	pointer
;	O
rel	pointer
++	O
)	O
{	O
unsigned	O
long	O
r_symndx	long
=	O
rel	pointer
->	O
r_info	array
>>	O
r_sym_shift	int
;	O
unsigned	O
int	O
s_type	int
;	O
asection	struct
*	O
*	O
ps	pointer
,	O
*	O
sec	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
sym_name	pointer
;	O
if	O
(	O
r_symndx	long
==	O
STN_UNDEF	int
)	O
continue	O
;	O
if	O
(	O
r_symndx	long
>=	O
locsymcount	long
||	O
(	O
elf_bad_symtab	O
(	O
input_bfd	pointer
)	O
&&	O
flinfo	pointer
->	O
sections	pointer
[	O
r_symndx	long
]	O
==	O
NULL	O
)	O
)	O
{	O
h	pointer
=	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
extsymoff	long
]	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"error: %pB contains a reloc (%#"	pointer
PRIx64	O
") for section %pA "	pointer
"that references a non-existent global symbol"	pointer
)	O
,	O
input_bfd	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_info	array
,	O
o	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
s_type	int
=	O
h	pointer
->	O
type	enum
;	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_regular	int
||	O
h	pointer
->	O
root	struct
.	O
non_ir_ref_dynamic	int
)	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
&&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
{	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
}	O
ps	pointer
=	O
NULL	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
ps	pointer
=	O
&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
sym_name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
}	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
sym	pointer
=	O
isymbuf	pointer
+	O
r_symndx	long
;	O
s_type	int
=	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
;	O
ps	pointer
=	O
&	O
flinfo	pointer
->	O
sections	pointer
[	O
r_symndx	long
]	O
;	O
sym_name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
sym	pointer
,	O
*	O
ps	pointer
)	O
;	O
}	O
if	O
(	O
(	O
s_type	int
==	O
STT_RELC	int
||	O
s_type	int
==	O
STT_SRELC	int
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
{	O
bfd_vma	long
val	array
;	O
bfd_vma	long
dot	long
=	O
(	O
rel	pointer
->	O
r_offset	array
+	O
o	pointer
->	O
output_offset	long
+	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
)	O
;	O
if	O
(	O
!	O
eval_symbol	function
(	O
&	O
val	array
,	O
&	O
sym_name	pointer
,	O
input_bfd	pointer
,	O
flinfo	pointer
,	O
dot	long
,	O
isymbuf	pointer
,	O
locsymcount	long
,	O
s_type	int
==	O
STT_SRELC	int
)	O
)	O
return	O
FALSE	int
;	O
set_symbol_value	function
(	O
input_bfd	pointer
,	O
isymbuf	pointer
,	O
locsymcount	long
,	O
r_symndx	long
,	O
val	array
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
action_discarded	enum
!=	O
-	O
1	int
&&	O
ps	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
sec	pointer
=	O
*	O
ps	pointer
)	O
!=	O
NULL	O
&&	O
discarded_section	function
(	O
sec	pointer
)	O
)	O
{	O
BFD_ASSERT	O
(	O
r_symndx	long
!=	O
STN_UNDEF	int
)	O
;	O
if	O
(	O
action_discarded	enum
&	O
COMPLAIN	int
)	O
(	O
*	O
flinfo	pointer
->	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
)	O
(	O
_	O
(	O
"%X`%s' referenced in section `%pA' of %pB: "	pointer
"defined in discarded section `%pA' of %pB\n"	pointer
)	O
,	O
sym_name	pointer
,	O
o	pointer
,	O
input_bfd	pointer
,	O
sec	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
;	O
if	O
(	O
action_discarded	enum
&	O
PRETEND	int
)	O
{	O
asection	struct
*	O
kept	pointer
;	O
kept	pointer
=	O
_bfd_elf_check_kept_section	function
(	O
sec	pointer
,	O
flinfo	pointer
->	O
info	pointer
)	O
;	O
if	O
(	O
kept	pointer
!=	O
NULL	O
)	O
{	O
*	O
ps	pointer
=	O
kept	pointer
;	O
continue	O
;	O
}	O
}	O
}	O
}	O
}	O
ret	pointer
=	O
(	O
*	O
relocate_section	pointer
)	O
(	O
output_bfd	pointer
,	O
flinfo	pointer
->	O
info	pointer
,	O
input_bfd	pointer
,	O
o	pointer
,	O
contents	pointer
,	O
internal_relocs	pointer
,	O
isymbuf	pointer
,	O
flinfo	pointer
->	O
sections	pointer
)	O
;	O
if	O
(	O
!	O
ret	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
ret	pointer
==	O
2	int
||	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
||	O
flinfo	pointer
->	O
info	pointer
->	O
emitrelocations	int
)	O
{	O
Elf_Internal_Rela	struct
*	O
irela	pointer
;	O
Elf_Internal_Rela	struct
*	O
irelaend	pointer
,	O
*	O
irelamid	pointer
;	O
bfd_vma	long
last_offset	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
rel_hash	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
rel_hash_list	pointer
,	O
*	O
*	O
rela_hash_list	pointer
;	O
Elf_Internal_Shdr	struct
*	O
input_rel_hdr	pointer
,	O
*	O
input_rela_hdr	pointer
;	O
unsigned	O
int	O
next_erel	int
;	O
bfd_boolean	int
rela_normal	int
;	O
struct	O
bfd_elf_section_data	struct
*	O
esdi	pointer
,	O
*	O
esdo	pointer
;	O
esdi	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
esdo	pointer
=	O
elf_section_data	O
(	O
o	pointer
->	O
output_section	pointer
)	O
;	O
rela_normal	int
=	O
FALSE	int
;	O
irela	pointer
=	O
internal_relocs	pointer
;	O
irelaend	pointer
=	O
irela	pointer
+	O
o	pointer
->	O
reloc_count	int
;	O
rel_hash	pointer
=	O
esdo	pointer
->	O
rel	pointer
.	O
hashes	pointer
+	O
esdo	pointer
->	O
rel	pointer
.	O
count	int
;	O
irelamid	pointer
=	O
irela	pointer
;	O
if	O
(	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
!=	O
NULL	O
)	O
irelamid	pointer
+=	O
(	O
NUM_SHDR_ENTRIES	O
(	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
;	O
rel_hash_list	pointer
=	O
rel_hash	pointer
;	O
rela_hash_list	pointer
=	O
NULL	O
;	O
last_offset	long
=	O
o	pointer
->	O
output_offset	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
last_offset	long
+=	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
for	O
(	O
next_erel	int
=	O
0	int
;	O
irela	pointer
<	O
irelaend	pointer
;	O
irela	pointer
++	O
,	O
next_erel	int
++	O
)	O
{	O
unsigned	O
long	O
r_symndx	long
;	O
asection	struct
*	O
sec	pointer
;	O
Elf_Internal_Sym	struct
sym	pointer
;	O
if	O
(	O
next_erel	int
==	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
{	O
rel_hash	pointer
++	O
;	O
next_erel	int
=	O
0	int
;	O
}	O
if	O
(	O
irela	pointer
==	O
irelamid	pointer
)	O
{	O
rel_hash	pointer
=	O
esdo	pointer
->	O
rela	struct
.	O
hashes	pointer
+	O
esdo	pointer
->	O
rela	struct
.	O
count	int
;	O
rela_hash_list	pointer
=	O
rel_hash	pointer
;	O
rela_normal	int
=	O
bed	pointer
->	O
rela_normal	int
;	O
}	O
irela	pointer
->	O
r_offset	array
=	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
flinfo	pointer
->	O
info	pointer
,	O
o	pointer
,	O
irela	pointer
->	O
r_offset	array
)	O
;	O
if	O
(	O
irela	pointer
->	O
r_offset	array
>=	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
{	O
irela	pointer
->	O
r_offset	array
=	O
last_offset	long
;	O
irela	pointer
->	O
r_info	array
=	O
0	int
;	O
irela	pointer
->	O
r_addend	array
=	O
0	int
;	O
continue	O
;	O
}	O
irela	pointer
->	O
r_offset	array
+=	O
o	pointer
->	O
output_offset	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
irela	pointer
->	O
r_offset	array
+=	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
last_offset	long
=	O
irela	pointer
->	O
r_offset	array
;	O
r_symndx	long
=	O
irela	pointer
->	O
r_info	array
>>	O
r_sym_shift	int
;	O
if	O
(	O
r_symndx	long
==	O
STN_UNDEF	int
)	O
continue	O
;	O
if	O
(	O
r_symndx	long
>=	O
locsymcount	long
||	O
(	O
elf_bad_symtab	O
(	O
input_bfd	pointer
)	O
&&	O
flinfo	pointer
->	O
sections	pointer
[	O
r_symndx	long
]	O
==	O
NULL	O
)	O
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
rh	pointer
;	O
unsigned	O
long	O
indx	long
;	O
indx	long
=	O
r_symndx	long
-	O
extsymoff	long
;	O
rh	pointer
=	O
elf_sym_hashes	O
(	O
input_bfd	pointer
)	O
[	O
indx	long
]	O
;	O
while	O
(	O
rh	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
rh	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
rh	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
rh	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
BFD_ASSERT	O
(	O
rh	pointer
->	O
indx	long
<	O
0	int
)	O
;	O
rh	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
*	O
rel_hash	pointer
=	O
rh	pointer
;	O
continue	O
;	O
}	O
*	O
rel_hash	pointer
=	O
NULL	O
;	O
sym	pointer
=	O
isymbuf	pointer
[	O
r_symndx	long
]	O
;	O
sec	pointer
=	O
flinfo	pointer
->	O
sections	pointer
[	O
r_symndx	long
]	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
.	O
st_info	array
)	O
==	O
STT_SECTION	int
)	O
{	O
r_symndx	long
=	O
STN_UNDEF	int
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
)	O
;	O
else	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
owner	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
asection	struct
*	O
osec	pointer
=	O
sec	pointer
->	O
output_section	pointer
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
osec	pointer
)	O
&&	O
sec	pointer
->	O
kept_section	pointer
!=	O
NULL	O
&&	O
sec	pointer
->	O
kept_section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
osec	pointer
=	O
sec	pointer
->	O
kept_section	pointer
->	O
output_section	pointer
;	O
irela	pointer
->	O
r_addend	array
-=	O
osec	pointer
->	O
vma	long
;	O
}	O
if	O
(	O
!	O
bfd_is_abs_section	function
(	O
osec	pointer
)	O
)	O
{	O
r_symndx	long
=	O
osec	pointer
->	O
target_index	int
;	O
if	O
(	O
r_symndx	long
==	O
STN_UNDEF	int
)	O
{	O
irela	pointer
->	O
r_addend	array
+=	O
osec	pointer
->	O
vma	long
;	O
osec	pointer
=	O
_bfd_nearby_section	function
(	O
output_bfd	pointer
,	O
osec	pointer
,	O
osec	pointer
->	O
vma	long
)	O
;	O
irela	pointer
->	O
r_addend	array
-=	O
osec	pointer
->	O
vma	long
;	O
r_symndx	long
=	O
osec	pointer
->	O
target_index	int
;	O
}	O
}	O
}	O
if	O
(	O
rela_normal	int
)	O
irela	pointer
->	O
r_addend	array
+=	O
sec	pointer
->	O
output_offset	long
;	O
}	O
else	O
{	O
if	O
(	O
flinfo	pointer
->	O
indices	pointer
[	O
r_symndx	long
]	O
==	O
-	O
1	int
)	O
{	O
unsigned	O
long	O
shlink	long
;	O
const	O
char	O
*	O
name	pointer
;	O
asection	struct
*	O
osec	pointer
;	O
long	O
indx	long
;	O
if	O
(	O
flinfo	pointer
->	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
shlink	long
=	O
symtab_hdr	struct
->	O
sh_link	array
;	O
name	pointer
=	O
(	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
shlink	long
,	O
sym	pointer
.	O
st_name	array
)	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
osec	pointer
=	O
sec	pointer
->	O
output_section	pointer
;	O
sym	pointer
.	O
st_shndx	array
=	O
_bfd_elf_section_from_bfd_section	function
(	O
output_bfd	pointer
,	O
osec	pointer
)	O
;	O
if	O
(	O
sym	pointer
.	O
st_shndx	array
==	O
SHN_BAD	O
)	O
return	O
FALSE	int
;	O
sym	pointer
.	O
st_value	array
+=	O
sec	pointer
->	O
output_offset	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
)	O
{	O
sym	pointer
.	O
st_value	array
+=	O
osec	pointer
->	O
vma	long
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
.	O
st_info	array
)	O
==	O
STT_TLS	int
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
tls_sec	pointer
!=	O
NULL	O
)	O
sym	pointer
.	O
st_value	array
-=	O
htab	struct
->	O
tls_sec	pointer
->	O
vma	long
;	O
else	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
.	O
st_info	array
)	O
,	O
STT_NOTYPE	int
)	O
;	O
}	O
}	O
indx	long
=	O
bfd_get_symcount	function
(	O
output_bfd	pointer
)	O
;	O
ret	pointer
=	O
elf_link_output_symstrtab	function
(	O
flinfo	pointer
,	O
name	pointer
,	O
&	O
sym	pointer
,	O
sec	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
return	O
FALSE	int
;	O
else	O
if	O
(	O
ret	pointer
==	O
1	int
)	O
flinfo	pointer
->	O
indices	pointer
[	O
r_symndx	long
]	O
=	O
indx	long
;	O
else	O
abort	function
(	O
)	O
;	O
}	O
r_symndx	long
=	O
flinfo	pointer
->	O
indices	pointer
[	O
r_symndx	long
]	O
;	O
}	O
irela	pointer
->	O
r_info	array
=	O
(	O
(	O
bfd_vma	long
)	O
r_symndx	long
<<	O
r_sym_shift	int
|	O
(	O
irela	pointer
->	O
r_info	array
&	O
r_type_mask	long
)	O
)	O
;	O
}	O
input_rel_hdr	pointer
=	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
;	O
if	O
(	O
input_rel_hdr	pointer
&&	O
input_rel_hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
bed	pointer
->	O
elf_backend_emit_relocs	pointer
(	O
output_bfd	pointer
,	O
o	pointer
,	O
input_rel_hdr	pointer
,	O
internal_relocs	pointer
,	O
rel_hash_list	pointer
)	O
)	O
return	O
FALSE	int
;	O
internal_relocs	pointer
+=	O
(	O
NUM_SHDR_ENTRIES	O
(	O
input_rel_hdr	pointer
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
;	O
rel_hash_list	pointer
+=	O
NUM_SHDR_ENTRIES	O
(	O
input_rel_hdr	pointer
)	O
;	O
}	O
input_rela_hdr	pointer
=	O
esdi	pointer
->	O
rela	struct
.	O
hdr	pointer
;	O
if	O
(	O
input_rela_hdr	pointer
&&	O
input_rela_hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
bed	pointer
->	O
elf_backend_emit_relocs	pointer
(	O
output_bfd	pointer
,	O
o	pointer
,	O
input_rela_hdr	pointer
,	O
internal_relocs	pointer
,	O
rela_hash_list	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
if	O
(	O
bed	pointer
->	O
elf_backend_write_section	pointer
&&	O
(	O
*	O
bed	pointer
->	O
elf_backend_write_section	pointer
)	O
(	O
output_bfd	pointer
,	O
flinfo	pointer
->	O
info	pointer
,	O
o	pointer
,	O
contents	pointer
)	O
)	O
{	O
}	O
else	O
switch	O
(	O
o	pointer
->	O
sec_info_type	int
)	O
{	O
case	O
SEC_INFO_TYPE_STABS	int
:	O
if	O
(	O
!	O
(	O
_bfd_write_section_stabs	function
(	O
output_bfd	pointer
,	O
&	O
elf_hash_table	O
(	O
flinfo	pointer
->	O
info	pointer
)	O
->	O
stab_info	struct
,	O
o	pointer
,	O
&	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
sec_info	pointer
,	O
contents	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
SEC_INFO_TYPE_MERGE	int
:	O
if	O
(	O
!	O
_bfd_write_merged_section	function
(	O
output_bfd	pointer
,	O
o	pointer
,	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
sec_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
SEC_INFO_TYPE_EH_FRAME	int
:	O
{	O
if	O
(	O
!	O
_bfd_elf_write_section_eh_frame	function
(	O
output_bfd	pointer
,	O
flinfo	pointer
->	O
info	pointer
,	O
o	pointer
,	O
contents	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
SEC_INFO_TYPE_EH_FRAME_ENTRY	int
:	O
{	O
if	O
(	O
!	O
_bfd_elf_write_section_eh_frame_entry	function
(	O
output_bfd	pointer
,	O
flinfo	pointer
->	O
info	pointer
,	O
o	pointer
,	O
contents	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
default	O
:	O
{	O
if	O
(	O
!	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
)	O
{	O
file_ptr	long
offset	long
=	O
(	O
file_ptr	long
)	O
o	pointer
->	O
output_offset	long
;	O
bfd_size_type	long
todo	long
=	O
o	pointer
->	O
size	long
;	O
offset	long
*=	O
bfd_octets_per_byte	function
(	O
output_bfd	pointer
,	O
o	pointer
)	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_ELF_REVERSE_COPY	int
)	O
)	O
{	O
do	O
{	O
todo	long
-=	O
address_size	long
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
o	pointer
->	O
output_section	pointer
,	O
contents	pointer
+	O
todo	long
,	O
offset	long
,	O
address_size	long
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
todo	long
==	O
0	int
)	O
break	O
;	O
offset	long
+=	O
address_size	long
;	O
}	O
while	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
o	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
offset	long
,	O
todo	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_reloc_link_order	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
output_section	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
)	O
{	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
long	O
indx	long
;	O
bfd_vma	long
offset	long
;	O
bfd_vma	long
addend	long
;	O
struct	O
bfd_elf_section_reloc_data	struct
*	O
reldata	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
rel_hash_ptr	pointer
;	O
Elf_Internal_Shdr	struct
*	O
rel_hdr	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
Elf_Internal_Rela	struct
irel	array
[	O
MAX_INT_RELS_PER_EXT_REL	int
]	O
;	O
bfd_byte	char
*	O
erel	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
=	O
elf_section_data	O
(	O
output_section	pointer
)	O
;	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
output_bfd	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
reloc	enum
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
addend	long
=	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
;	O
if	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
reldata	pointer
=	O
&	O
esdo	pointer
->	O
rel	pointer
;	O
else	O
if	O
(	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
)	O
reldata	pointer
=	O
&	O
esdo	pointer
->	O
rela	struct
;	O
else	O
{	O
reldata	pointer
=	O
NULL	O
;	O
BFD_ASSERT	O
(	O
0	int
)	O
;	O
}	O
rel_hash_ptr	pointer
=	O
reldata	pointer
->	O
hashes	pointer
+	O
reldata	pointer
->	O
count	int
;	O
if	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
)	O
{	O
indx	long
=	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
section	pointer
->	O
target_index	int
;	O
BFD_ASSERT	O
(	O
indx	long
!=	O
0	int
)	O
;	O
*	O
rel_hash_ptr	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
(	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bfd_wrapped_link_hash_lookup	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
{	O
asection	struct
*	O
section	pointer
;	O
section	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
indx	long
=	O
section	pointer
->	O
output_section	pointer
->	O
target_index	int
;	O
*	O
rel_hash_ptr	pointer
=	O
NULL	O
;	O
addend	long
+=	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
section	pointer
->	O
output_offset	long
;	O
}	O
else	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
*	O
rel_hash_ptr	pointer
=	O
h	pointer
;	O
indx	long
=	O
0	int
;	O
}	O
else	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
unattached_reloc	pointer
)	O
(	O
info	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
indx	long
=	O
0	int
;	O
}	O
}	O
if	O
(	O
howto	pointer
->	O
partial_inplace	int
&&	O
addend	long
!=	O
0	int
)	O
{	O
bfd_size_type	long
size	long
;	O
bfd_reloc_status_type	enum
rstat	enum
;	O
bfd_byte	char
*	O
buf	pointer
;	O
bfd_boolean	int
ok	int
;	O
const	O
char	O
*	O
sym_name	pointer
;	O
bfd_size_type	long
octets	long
;	O
size	long
=	O
(	O
bfd_size_type	long
)	O
bfd_get_reloc_size	function
(	O
howto	pointer
)	O
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_zmalloc	function
(	O
size	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
&&	O
size	long
!=	O
0	int
)	O
return	O
FALSE	int
;	O
rstat	enum
=	O
_bfd_relocate_contents	function
(	O
howto	pointer
,	O
output_bfd	pointer
,	O
addend	long
,	O
buf	pointer
)	O
;	O
switch	O
(	O
rstat	enum
)	O
{	O
case	O
bfd_reloc_ok	int
:	O
break	O
;	O
default	O
:	O
case	O
bfd_reloc_outofrange	int
:	O
abort	function
(	O
)	O
;	O
case	O
bfd_reloc_overflow	int
:	O
if	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
)	O
sym_name	pointer
=	O
bfd_section_name	function
(	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
section	pointer
)	O
;	O
else	O
sym_name	pointer
=	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
;	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
info	pointer
,	O
NULL	O
,	O
sym_name	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
addend	long
,	O
NULL	O
,	O
NULL	O
,	O
(	O
bfd_vma	long
)	O
0	int
)	O
;	O
break	O
;	O
}	O
octets	long
=	O
link_order	pointer
->	O
offset	long
*	O
bfd_octets_per_byte	function
(	O
output_bfd	pointer
,	O
output_section	pointer
)	O
;	O
ok	int
=	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
output_section	pointer
,	O
buf	pointer
,	O
octets	long
,	O
size	long
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
FALSE	int
;	O
}	O
offset	long
=	O
link_order	pointer
->	O
offset	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
offset	long
+=	O
output_section	pointer
->	O
vma	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
;	O
i	pointer
++	O
)	O
{	O
irel	array
[	O
i	pointer
]	O
.	O
r_offset	array
=	O
offset	long
;	O
irel	array
[	O
i	pointer
]	O
.	O
r_info	array
=	O
0	int
;	O
irel	array
[	O
i	pointer
]	O
.	O
r_addend	array
=	O
0	int
;	O
}	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
irel	array
[	O
0	int
]	O
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
howto	pointer
->	O
type	enum
)	O
;	O
else	O
irel	array
[	O
0	int
]	O
.	O
r_info	array
=	O
ELF64_R_INFO	O
(	O
indx	long
,	O
howto	pointer
->	O
type	enum
)	O
;	O
rel_hdr	pointer
=	O
reldata	pointer
->	O
hdr	pointer
;	O
erel	pointer
=	O
rel_hdr	pointer
->	O
contents	pointer
;	O
if	O
(	O
rel_hdr	pointer
->	O
sh_type	array
==	O
SHT_REL	int
)	O
{	O
erel	pointer
+=	O
reldata	pointer
->	O
count	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
;	O
(	O
*	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_out	pointer
)	O
(	O
output_bfd	pointer
,	O
irel	array
,	O
erel	pointer
)	O
;	O
}	O
else	O
{	O
irel	array
[	O
0	int
]	O
.	O
r_addend	array
=	O
addend	long
;	O
erel	pointer
+=	O
reldata	pointer
->	O
count	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
;	O
(	O
*	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_out	pointer
)	O
(	O
output_bfd	pointer
,	O
irel	array
,	O
erel	pointer
)	O
;	O
}	O
++	O
reldata	pointer
->	O
count	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
compare_link_order	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
bfd_link_order	struct
*	O
alo	pointer
=	O
*	O
(	O
const	O
struct	O
bfd_link_order	struct
*	O
*	O
)	O
a	pointer
;	O
const	O
struct	O
bfd_link_order	struct
*	O
blo	pointer
=	O
*	O
(	O
const	O
struct	O
bfd_link_order	struct
*	O
*	O
)	O
b	pointer
;	O
asection	struct
*	O
asec	pointer
=	O
elf_linked_to_section	O
(	O
alo	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
)	O
;	O
asection	struct
*	O
bsec	pointer
=	O
elf_linked_to_section	O
(	O
blo	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
)	O
;	O
bfd_vma	long
apos	long
=	O
asec	pointer
->	O
output_section	pointer
->	O
lma	long
+	O
asec	pointer
->	O
output_offset	long
;	O
bfd_vma	long
bpos	long
=	O
bsec	pointer
->	O
output_section	pointer
->	O
lma	long
+	O
bsec	pointer
->	O
output_offset	long
;	O
if	O
(	O
apos	long
<	O
bpos	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
apos	long
>	O
bpos	long
)	O
return	O
1	int
;	O
if	O
(	O
asec	pointer
->	O
size	long
<	O
bsec	pointer
->	O
size	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
asec	pointer
->	O
size	long
>	O
bsec	pointer
->	O
size	long
)	O
return	O
1	int
;	O
apos	long
=	O
asec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
asec	pointer
->	O
output_offset	long
;	O
bpos	long
=	O
bsec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
bsec	pointer
->	O
output_offset	long
;	O
if	O
(	O
apos	long
<	O
bpos	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
apos	long
>	O
bpos	long
)	O
return	O
1	int
;	O
return	O
asec	pointer
->	O
id	int
-	O
bsec	pointer
->	O
id	int
;	O
}	O
static	O
bfd_boolean	int
elf_fixup_link_order	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
o	pointer
)	O
{	O
size_t	long
seen_linkorder	long
;	O
size_t	long
seen_other	long
;	O
size_t	long
n	long
;	O
struct	O
bfd_link_order	struct
*	O
p	pointer
;	O
bfd	struct
*	O
sub	pointer
;	O
struct	O
bfd_link_order	struct
*	O
*	O
sections	pointer
;	O
asection	struct
*	O
s	pointer
,	O
*	O
other_sec	pointer
,	O
*	O
linkorder_sec	pointer
;	O
bfd_vma	long
offset	long
;	O
other_sec	pointer
=	O
NULL	O
;	O
linkorder_sec	pointer
=	O
NULL	O
;	O
seen_other	long
=	O
0	int
;	O
seen_linkorder	long
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
s	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
sub	pointer
=	O
s	pointer
->	O
owner	pointer
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
&&	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
elf_section_data	O
(	O
s	pointer
)	O
!=	O
NULL	O
&&	O
elf_linked_to_section	O
(	O
s	pointer
)	O
!=	O
NULL	O
)	O
{	O
seen_linkorder	long
++	O
;	O
linkorder_sec	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
seen_other	long
++	O
;	O
other_sec	pointer
=	O
s	pointer
;	O
}	O
}	O
else	O
seen_other	long
++	O
;	O
if	O
(	O
seen_other	long
&&	O
seen_linkorder	long
)	O
{	O
if	O
(	O
other_sec	pointer
&&	O
linkorder_sec	pointer
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pA has both ordered [`%pA' in %pB] "	pointer
"and unordered [`%pA' in %pB] sections"	pointer
)	O
,	O
o	pointer
,	O
linkorder_sec	pointer
,	O
linkorder_sec	pointer
->	O
owner	pointer
,	O
other_sec	pointer
,	O
other_sec	pointer
->	O
owner	pointer
)	O
;	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pA has both ordered and unordered sections"	pointer
)	O
,	O
o	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
seen_linkorder	long
)	O
return	O
TRUE	int
;	O
sections	pointer
=	O
bfd_malloc	function
(	O
seen_linkorder	long
*	O
sizeof	O
(	O
*	O
sections	pointer
)	O
)	O
;	O
if	O
(	O
sections	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
seen_linkorder	long
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
sections	pointer
[	O
seen_linkorder	long
++	O
]	O
=	O
p	pointer
;	O
qsort	function
(	O
sections	pointer
,	O
seen_linkorder	long
,	O
sizeof	O
(	O
*	O
sections	pointer
)	O
,	O
compare_link_order	function
)	O
;	O
offset	long
=	O
0	int
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
seen_linkorder	long
;	O
n	long
++	O
)	O
{	O
bfd_vma	long
mask	int
;	O
s	pointer
=	O
sections	pointer
[	O
n	long
]	O
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
mask	int
=	O
~	O
(	O
bfd_vma	long
)	O
0	int
<<	O
s	pointer
->	O
alignment_power	int
;	O
offset	long
=	O
(	O
offset	long
+	O
~	O
mask	int
)	O
&	O
mask	int
;	O
s	pointer
->	O
output_offset	long
=	O
offset	long
/	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
s	pointer
)	O
;	O
sections	pointer
[	O
n	long
]	O
->	O
offset	long
=	O
offset	long
;	O
offset	long
+=	O
sections	pointer
[	O
n	long
]	O
->	O
size	long
;	O
}	O
free	function
(	O
sections	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_output_implib	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_boolean	int
ret	pointer
=	O
FALSE	int
;	O
bfd	struct
*	O
implib_bfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
flagword	int
flags	int
;	O
enum	O
bfd_architecture	enum
arch	enum
;	O
unsigned	O
int	O
mach	long
;	O
asymbol	struct
*	O
*	O
sympp	pointer
=	O
NULL	O
;	O
long	O
symsize	long
;	O
long	O
symcount	int
;	O
long	O
src_count	long
;	O
elf_symbol_type	struct
*	O
osymbuf	pointer
;	O
implib_bfd	pointer
=	O
info	pointer
->	O
out_implib_bfd	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
bfd_set_format	function
(	O
implib_bfd	pointer
,	O
bfd_object	int
)	O
)	O
return	O
FALSE	int
;	O
flags	int
=	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
;	O
flags	int
&=	O
~	O
HAS_RELOC	int
;	O
if	O
(	O
!	O
bfd_set_start_address	function
(	O
implib_bfd	pointer
,	O
0	int
)	O
||	O
!	O
bfd_set_file_flags	function
(	O
implib_bfd	pointer
,	O
flags	int
&	O
~	O
EXEC_P	int
)	O
)	O
return	O
FALSE	int
;	O
arch	enum
=	O
bfd_get_arch	function
(	O
abfd	pointer
)	O
;	O
mach	long
=	O
bfd_get_mach	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
bfd_set_arch_mach	O
(	O
implib_bfd	pointer
,	O
arch	enum
,	O
mach	long
)	O
&&	O
(	O
abfd	pointer
->	O
target_defaulted	int
||	O
bfd_get_arch	function
(	O
abfd	pointer
)	O
!=	O
bfd_get_arch	function
(	O
implib_bfd	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
symsize	long
=	O
bfd_get_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
symsize	long
<	O
0	int
)	O
return	O
FALSE	int
;	O
sympp	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
symsize	long
)	O
;	O
if	O
(	O
sympp	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
abfd	pointer
,	O
sympp	pointer
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
goto	O
free_sym_buf	O
;	O
if	O
(	O
!	O
bfd_copy_private_header_data	function
(	O
abfd	pointer
,	O
implib_bfd	pointer
)	O
)	O
goto	O
free_sym_buf	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_filter_implib_symbols	pointer
)	O
symcount	int
=	O
bed	pointer
->	O
elf_backend_filter_implib_symbols	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
sympp	pointer
,	O
symcount	int
)	O
;	O
else	O
symcount	int
=	O
_bfd_elf_filter_global_symbols	function
(	O
abfd	pointer
,	O
info	pointer
,	O
sympp	pointer
,	O
symcount	int
)	O
;	O
if	O
(	O
symcount	int
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_symbols	int
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: no symbol found for import library"	pointer
)	O
,	O
implib_bfd	pointer
)	O
;	O
goto	O
free_sym_buf	O
;	O
}	O
osymbuf	pointer
=	O
(	O
elf_symbol_type	struct
*	O
)	O
bfd_alloc2	function
(	O
implib_bfd	pointer
,	O
symcount	int
,	O
sizeof	O
(	O
*	O
osymbuf	pointer
)	O
)	O
;	O
if	O
(	O
osymbuf	pointer
==	O
NULL	O
)	O
goto	O
free_sym_buf	O
;	O
for	O
(	O
src_count	long
=	O
0	int
;	O
src_count	long
<	O
symcount	int
;	O
src_count	long
++	O
)	O
{	O
memcpy	function
(	O
&	O
osymbuf	pointer
[	O
src_count	long
]	O
,	O
(	O
elf_symbol_type	struct
*	O
)	O
sympp	pointer
[	O
src_count	long
]	O
,	O
sizeof	O
(	O
*	O
osymbuf	pointer
)	O
)	O
;	O
osymbuf	pointer
[	O
src_count	long
]	O
.	O
symbol	pointer
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
osymbuf	pointer
[	O
src_count	long
]	O
.	O
internal_elf_sym	struct
.	O
st_shndx	array
=	O
SHN_ABS	O
;	O
osymbuf	pointer
[	O
src_count	long
]	O
.	O
symbol	pointer
.	O
value	long
+=	O
sympp	pointer
[	O
src_count	long
]	O
->	O
section	pointer
->	O
vma	long
;	O
osymbuf	pointer
[	O
src_count	long
]	O
.	O
internal_elf_sym	struct
.	O
st_value	array
=	O
osymbuf	pointer
[	O
src_count	long
]	O
.	O
symbol	pointer
.	O
value	long
;	O
sympp	pointer
[	O
src_count	long
]	O
=	O
&	O
osymbuf	pointer
[	O
src_count	long
]	O
.	O
symbol	pointer
;	O
}	O
bfd_set_symtab	function
(	O
implib_bfd	pointer
,	O
sympp	pointer
,	O
symcount	int
)	O
;	O
if	O
(	O
!	O
bfd_copy_private_bfd_data	function
(	O
abfd	pointer
,	O
implib_bfd	pointer
)	O
)	O
goto	O
free_sym_buf	O
;	O
if	O
(	O
!	O
bfd_close	function
(	O
implib_bfd	pointer
)	O
)	O
goto	O
free_sym_buf	O
;	O
ret	pointer
=	O
TRUE	int
;	O
free_sym_buf	O
:	O
free	function
(	O
sympp	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
elf_final_link_free	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
struct	O
elf_final_link_info	struct
*	O
flinfo	pointer
)	O
{	O
asection	struct
*	O
o	pointer
;	O
if	O
(	O
flinfo	pointer
->	O
symstrtab	pointer
!=	O
NULL	O
)	O
_bfd_elf_strtab_free	function
(	O
flinfo	pointer
->	O
symstrtab	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
contents	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
external_relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
external_relocs	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
internal_relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
internal_relocs	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
external_syms	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
external_syms	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
locsym_shndx	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
locsym_shndx	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
internal_syms	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
internal_syms	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
indices	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
indices	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
sections	pointer
!=	O
NULL	O
)	O
free	function
(	O
flinfo	pointer
->	O
sections	pointer
)	O
;	O
if	O
(	O
flinfo	pointer
->	O
symshndxbuf	pointer
!=	O
NULL	O
&&	O
flinfo	pointer
->	O
symshndxbuf	pointer
!=	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
-	O
1	int
)	O
free	function
(	O
flinfo	pointer
->	O
symshndxbuf	pointer
)	O
;	O
for	O
(	O
o	pointer
=	O
obfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
&&	O
esdo	pointer
->	O
rel	pointer
.	O
hashes	pointer
!=	O
NULL	O
)	O
free	function
(	O
esdo	pointer
->	O
rel	pointer
.	O
hashes	pointer
)	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
&&	O
esdo	pointer
->	O
rela	struct
.	O
hashes	pointer
!=	O
NULL	O
)	O
free	function
(	O
esdo	pointer
->	O
rela	struct
.	O
hashes	pointer
)	O
;	O
}	O
}	O
bfd_boolean	int
bfd_elf_final_link	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_boolean	int
dynamic	int
;	O
bfd_boolean	int
emit_relocs	int
;	O
bfd	struct
*	O
dynobj	pointer
;	O
struct	O
elf_final_link_info	struct
flinfo	pointer
;	O
asection	struct
*	O
o	pointer
;	O
struct	O
bfd_link_order	struct
*	O
p	pointer
;	O
bfd	struct
*	O
sub	pointer
;	O
bfd_size_type	long
max_contents_size	long
;	O
bfd_size_type	long
max_external_reloc_size	long
;	O
bfd_size_type	long
max_internal_reloc_count	long
;	O
bfd_size_type	long
max_sym_count	long
;	O
bfd_size_type	long
max_sym_shndx_count	long
;	O
Elf_Internal_Sym	struct
elfsym	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
Elf_Internal_Shdr	struct
*	O
symtab_shndx_hdr	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_outext_info	struct
eoinfo	pointer
;	O
bfd_boolean	int
merged	int
;	O
size_t	long
relativecount	long
=	O
0	int
;	O
asection	struct
*	O
reldyn	pointer
=	O
0	int
;	O
bfd_size_type	long
amt	long
;	O
asection	struct
*	O
attr_section	pointer
=	O
NULL	O
;	O
bfd_vma	long
attr_size	long
=	O
0	int
;	O
const	O
char	O
*	O
std_attrs_section	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
bfd_boolean	int
sections_removed	int
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
htab	struct
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
abfd	pointer
->	O
flags	int
|=	O
DYNAMIC	int
;	O
dynamic	int
=	O
htab	struct
->	O
dynamic_sections_created	int
;	O
dynobj	pointer
=	O
htab	struct
->	O
dynobj	pointer
;	O
emit_relocs	int
=	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
||	O
info	pointer
->	O
emitrelocations	int
)	O
;	O
flinfo	pointer
.	O
info	pointer
=	O
info	pointer
;	O
flinfo	pointer
.	O
output_bfd	pointer
=	O
abfd	pointer
;	O
flinfo	pointer
.	O
symstrtab	pointer
=	O
_bfd_elf_strtab_init	function
(	O
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
symstrtab	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
flinfo	pointer
.	O
hash_sec	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
symver_sec	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
flinfo	pointer
.	O
hash_sec	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".hash"	pointer
)	O
;	O
flinfo	pointer
.	O
symver_sec	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".gnu.version"	pointer
)	O
;	O
}	O
flinfo	pointer
.	O
contents	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
external_relocs	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
internal_relocs	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
external_syms	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
locsym_shndx	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
internal_syms	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
indices	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
sections	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
symshndxbuf	pointer
=	O
NULL	O
;	O
flinfo	pointer
.	O
filesym_count	long
=	O
0	int
;	O
sections_removed	int
=	O
FALSE	int
;	O
std_attrs_section	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
obj_attrs_section	pointer
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
bfd_boolean	int
remove_section	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
std_attrs_section	pointer
&&	O
strcmp	function
(	O
o	pointer
->	O
name	pointer
,	O
std_attrs_section	pointer
)	O
==	O
0	int
)	O
||	O
strcmp	function
(	O
o	pointer
->	O
name	pointer
,	O
".gnu.attributes"	pointer
)	O
==	O
0	int
)	O
{	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
asection	struct
*	O
input_section	pointer
;	O
if	O
(	O
p	pointer
->	O
type	enum
!=	O
bfd_indirect_link_order	int
)	O
continue	O
;	O
input_section	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
input_section	pointer
->	O
flags	int
&=	O
~	O
SEC_HAS_CONTENTS	int
;	O
}	O
attr_size	long
=	O
bfd_elf_obj_attr_size	function
(	O
abfd	pointer
)	O
;	O
bfd_set_section_size	function
(	O
o	pointer
,	O
attr_size	long
)	O
;	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
=	O
NULL	O
;	O
if	O
(	O
attr_size	long
)	O
attr_section	pointer
=	O
o	pointer
;	O
else	O
remove_section	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
&&	O
o	pointer
->	O
size	long
==	O
0	int
)	O
{	O
remove_section	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
remove_section	int
)	O
{	O
o	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
bfd_section_list_remove	function
(	O
abfd	pointer
,	O
o	pointer
)	O
;	O
abfd	pointer
->	O
section_count	int
--	O
;	O
sections_removed	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
sections_removed	int
)	O
_bfd_fix_excluded_sec_syms	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
max_contents_size	long
=	O
0	int
;	O
max_external_reloc_size	long
=	O
0	int
;	O
max_internal_reloc_count	long
=	O
0	int
;	O
max_sym_count	long
=	O
0	int
;	O
max_sym_shndx_count	long
=	O
0	int
;	O
merged	int
=	O
FALSE	int
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
o	pointer
->	O
reloc_count	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
int	O
reloc_count	int
=	O
0	int
;	O
unsigned	O
int	O
additional_reloc_count	int
=	O
0	int
;	O
struct	O
bfd_elf_section_data	struct
*	O
esdi	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
||	O
p	pointer
->	O
type	enum
==	O
bfd_symbol_reloc_link_order	int
)	O
reloc_count	int
=	O
1	int
;	O
else	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
sec	pointer
->	O
linker_mark	int
=	O
TRUE	int
;	O
if	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
merged	int
=	O
TRUE	int
;	O
if	O
(	O
sec	pointer
->	O
rawsize	long
>	O
max_contents_size	long
)	O
max_contents_size	long
=	O
sec	pointer
->	O
rawsize	long
;	O
if	O
(	O
sec	pointer
->	O
size	long
>	O
max_contents_size	long
)	O
max_contents_size	long
=	O
sec	pointer
->	O
size	long
;	O
if	O
(	O
bfd_get_flavour	function
(	O
sec	pointer
->	O
owner	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
{	O
size_t	long
sym_count	long
;	O
if	O
(	O
elf_bad_symtab	O
(	O
sec	pointer
->	O
owner	pointer
)	O
)	O
sym_count	long
=	O
(	O
elf_tdata	O
(	O
sec	pointer
->	O
owner	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
;	O
else	O
sym_count	long
=	O
elf_tdata	O
(	O
sec	pointer
->	O
owner	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_info	array
;	O
if	O
(	O
sym_count	long
>	O
max_sym_count	long
)	O
max_sym_count	long
=	O
sym_count	long
;	O
if	O
(	O
sym_count	long
>	O
max_sym_shndx_count	long
&&	O
elf_symtab_shndx_list	O
(	O
sec	pointer
->	O
owner	pointer
)	O
!=	O
NULL	O
)	O
max_sym_shndx_count	long
=	O
sym_count	long
;	O
if	O
(	O
esdo	pointer
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_REL	int
||	O
esdo	pointer
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_RELA	int
)	O
;	O
else	O
if	O
(	O
emit_relocs	int
)	O
{	O
reloc_count	int
=	O
sec	pointer
->	O
reloc_count	int
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_count_additional_relocs	pointer
)	O
{	O
int	O
c	struct
;	O
c	struct
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_count_additional_relocs	pointer
)	O
(	O
sec	pointer
)	O
;	O
additional_reloc_count	int
+=	O
c	struct
;	O
}	O
}	O
else	O
if	O
(	O
bed	pointer
->	O
elf_backend_count_relocs	pointer
)	O
reloc_count	int
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_count_relocs	pointer
)	O
(	O
info	pointer
,	O
sec	pointer
)	O
;	O
esdi	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
)	O
{	O
size_t	long
ext_size	long
=	O
0	int
;	O
if	O
(	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
!=	O
NULL	O
)	O
ext_size	long
=	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_size	array
;	O
if	O
(	O
esdi	pointer
->	O
rela	struct
.	O
hdr	pointer
!=	O
NULL	O
)	O
ext_size	long
+=	O
esdi	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_size	array
;	O
if	O
(	O
ext_size	long
>	O
max_external_reloc_size	long
)	O
max_external_reloc_size	long
=	O
ext_size	long
;	O
if	O
(	O
sec	pointer
->	O
reloc_count	int
>	O
max_internal_reloc_count	long
)	O
max_internal_reloc_count	long
=	O
sec	pointer
->	O
reloc_count	int
;	O
}	O
}	O
}	O
if	O
(	O
reloc_count	int
==	O
0	int
)	O
continue	O
;	O
reloc_count	int
+=	O
additional_reloc_count	int
;	O
o	pointer
->	O
reloc_count	int
+=	O
reloc_count	int
;	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
&&	O
emit_relocs	int
)	O
{	O
if	O
(	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
{	O
esdo	pointer
->	O
rel	pointer
.	O
count	int
+=	O
NUM_SHDR_ENTRIES	O
(	O
esdi	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
;	O
esdo	pointer
->	O
rel	pointer
.	O
count	int
+=	O
additional_reloc_count	int
;	O
}	O
if	O
(	O
esdi	pointer
->	O
rela	struct
.	O
hdr	pointer
)	O
{	O
esdo	pointer
->	O
rela	struct
.	O
count	int
+=	O
NUM_SHDR_ENTRIES	O
(	O
esdi	pointer
->	O
rela	struct
.	O
hdr	pointer
)	O
;	O
esdo	pointer
->	O
rela	struct
.	O
count	int
+=	O
additional_reloc_count	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
o	pointer
->	O
use_rela_p	int
)	O
esdo	pointer
->	O
rela	struct
.	O
count	int
+=	O
reloc_count	int
;	O
else	O
esdo	pointer
->	O
rel	pointer
.	O
count	int
+=	O
reloc_count	int
;	O
}	O
}	O
if	O
(	O
o	pointer
->	O
reloc_count	int
>	O
0	int
)	O
o	pointer
->	O
flags	int
|=	O
SEC_RELOC	int
;	O
else	O
{	O
o	pointer
->	O
flags	int
&=	O
~	O
SEC_RELOC	int
;	O
}	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
&&	O
!	O
o	pointer
->	O
user_set_vma	int
)	O
o	pointer
->	O
vma	long
=	O
0	int
;	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
merged	int
)	O
elf_link_hash_traverse	O
(	O
htab	struct
,	O
_bfd_elf_link_sec_merge_syms	function
,	O
abfd	pointer
)	O
;	O
abfd	pointer
->	O
symcount	int
=	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
||	O
emit_relocs	int
;	O
BFD_ASSERT	O
(	O
!	O
abfd	pointer
->	O
output_has_begun	int
)	O
;	O
if	O
(	O
!	O
_bfd_elf_compute_section_file_positions	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
&&	O
!	O
(	O
_bfd_elf_link_size_reloc_section	function
(	O
abfd	pointer
,	O
&	O
esdo	pointer
->	O
rel	pointer
)	O
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
&&	O
!	O
(	O
_bfd_elf_link_size_reloc_section	function
(	O
abfd	pointer
,	O
&	O
esdo	pointer
->	O
rela	struct
)	O
)	O
)	O
goto	O
error_return	O
;	O
}	O
o	pointer
->	O
target_index	int
=	O
0	int
;	O
esdo	pointer
->	O
rel	pointer
.	O
count	int
=	O
0	int
;	O
esdo	pointer
->	O
rela	struct
.	O
count	int
=	O
0	int
;	O
if	O
(	O
(	O
esdo	pointer
->	O
this_hdr	struct
.	O
sh_offset	array
==	O
(	O
file_ptr	long
)	O
-	O
1	int
)	O
&&	O
!	O
bfd_section_is_ctf	function
(	O
o	pointer
)	O
)	O
{	O
unsigned	O
char	O
*	O
contents	pointer
=	O
esdo	pointer
->	O
this_hdr	struct
.	O
contents	pointer
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_ELF_COMPRESS	int
)	O
==	O
0	int
||	O
contents	pointer
!=	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_malloc	function
(	O
esdo	pointer
->	O
this_hdr	struct
.	O
sh_size	array
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
esdo	pointer
->	O
this_hdr	struct
.	O
contents	pointer
=	O
contents	pointer
;	O
}	O
}	O
abfd	pointer
->	O
symcount	int
=	O
0	int
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
symtab_hdr	struct
->	O
sh_type	array
=	O
SHT_SYMTAB	int
;	O
symtab_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
symtab_hdr	struct
->	O
sh_addralign	array
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
if	O
(	O
max_sym_count	long
<	O
20	int
)	O
max_sym_count	long
=	O
20	int
;	O
htab	struct
->	O
strtabsize	long
=	O
max_sym_count	long
;	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
struct	O
elf_sym_strtab	struct
)	O
;	O
htab	struct
->	O
strtab	pointer
=	O
(	O
struct	O
elf_sym_strtab	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
htab	struct
->	O
strtab	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
flinfo	pointer
.	O
symshndxbuf	pointer
=	O
(	O
elf_numsections	O
(	O
abfd	pointer
)	O
>	O
(	O
SHN_LORESERVE	O
&	O
0xFFFF	int
)	O
?	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
-	O
1	int
:	O
NULL	O
)	O
;	O
if	O
(	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
||	O
emit_relocs	int
)	O
{	O
file_ptr	long
off	long
=	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
;	O
_bfd_elf_assign_file_position_for_section	function
(	O
symtab_hdr	struct
,	O
off	long
,	O
TRUE	int
)	O
;	O
elfsym	pointer
.	O
st_value	array
=	O
0	int
;	O
elfsym	pointer
.	O
st_size	long
=	O
0	int
;	O
elfsym	pointer
.	O
st_info	array
=	O
0	int
;	O
elfsym	pointer
.	O
st_other	array
=	O
0	int
;	O
elfsym	pointer
.	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
elfsym	pointer
.	O
st_target_internal	char
=	O
0	int
;	O
if	O
(	O
elf_link_output_symstrtab	function
(	O
&	O
flinfo	pointer
,	O
NULL	O
,	O
&	O
elfsym	pointer
,	O
bfd_und_section_ptr	O
,	O
NULL	O
)	O
!=	O
1	int
)	O
goto	O
error_return	O
;	O
elfsym	pointer
.	O
st_size	long
=	O
0	int
;	O
elfsym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_SECTION	int
)	O
;	O
elfsym	pointer
.	O
st_other	array
=	O
0	int
;	O
elfsym	pointer
.	O
st_value	array
=	O
0	int
;	O
elfsym	pointer
.	O
st_target_internal	char
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
o	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
i	pointer
)	O
;	O
if	O
(	O
o	pointer
!=	O
NULL	O
)	O
{	O
o	pointer
->	O
target_index	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
elfsym	pointer
.	O
st_shndx	array
=	O
i	pointer
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
elfsym	pointer
.	O
st_value	array
=	O
o	pointer
->	O
vma	long
;	O
if	O
(	O
elf_link_output_symstrtab	function
(	O
&	O
flinfo	pointer
,	O
NULL	O
,	O
&	O
elfsym	pointer
,	O
o	pointer
,	O
NULL	O
)	O
!=	O
1	int
)	O
goto	O
error_return	O
;	O
}	O
}	O
}	O
if	O
(	O
max_contents_size	long
!=	O
0	int
)	O
{	O
flinfo	pointer
.	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
max_contents_size	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
contents	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
max_external_reloc_size	long
!=	O
0	int
)	O
{	O
flinfo	pointer
.	O
external_relocs	pointer
=	O
bfd_malloc	function
(	O
max_external_reloc_size	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
external_relocs	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
max_internal_reloc_count	long
!=	O
0	int
)	O
{	O
amt	long
=	O
max_internal_reloc_count	long
*	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
;	O
flinfo	pointer
.	O
internal_relocs	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
internal_relocs	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
max_sym_count	long
!=	O
0	int
)	O
{	O
amt	long
=	O
max_sym_count	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
flinfo	pointer
.	O
external_syms	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
external_syms	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
;	O
flinfo	pointer
.	O
internal_syms	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
internal_syms	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
long	O
)	O
;	O
flinfo	pointer
.	O
indices	pointer
=	O
(	O
long	O
int	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
indices	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
flinfo	pointer
.	O
sections	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
sections	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
max_sym_shndx_count	long
!=	O
0	int
)	O
{	O
amt	long
=	O
max_sym_shndx_count	long
*	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
flinfo	pointer
.	O
locsym_shndx	pointer
=	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flinfo	pointer
.	O
locsym_shndx	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
htab	struct
->	O
tls_sec	pointer
)	O
{	O
bfd_vma	long
base	int
,	O
end	pointer
=	O
0	int
;	O
asection	struct
*	O
sec	pointer
;	O
for	O
(	O
sec	pointer
=	O
htab	struct
->	O
tls_sec	pointer
;	O
sec	pointer
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
bfd_size_type	long
size	long
=	O
sec	pointer
->	O
size	long
;	O
if	O
(	O
size	long
==	O
0	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
)	O
{	O
struct	O
bfd_link_order	struct
*	O
ord	pointer
=	O
sec	pointer
->	O
map_tail	union
.	O
link_order	pointer
;	O
if	O
(	O
ord	pointer
!=	O
NULL	O
)	O
size	long
=	O
ord	pointer
->	O
offset	long
+	O
ord	pointer
->	O
size	long
;	O
}	O
end	pointer
=	O
sec	pointer
->	O
vma	long
+	O
size	long
;	O
}	O
base	int
=	O
htab	struct
->	O
tls_sec	pointer
->	O
vma	long
;	O
if	O
(	O
bed	pointer
->	O
static_tls_alignment	int
==	O
1	int
)	O
end	pointer
=	O
align_power	O
(	O
end	pointer
,	O
htab	struct
->	O
tls_sec	pointer
->	O
alignment_power	int
)	O
;	O
htab	struct
->	O
tls_size	long
=	O
end	pointer
-	O
base	int
;	O
}	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
elf_fixup_link_order	function
(	O
abfd	pointer
,	O
o	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
_bfd_elf_fixup_eh_frame_hdr	function
(	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
sub	pointer
->	O
output_has_begun	int
=	O
FALSE	int
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
&&	O
(	O
bfd_get_flavour	function
(	O
(	O
sub	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
owner	pointer
)	O
)	O
==	O
bfd_target_elf_flavour	int
)	O
&&	O
elf_elfheader	O
(	O
sub	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
)	O
{	O
if	O
(	O
!	O
sub	pointer
->	O
output_has_begun	int
)	O
{	O
if	O
(	O
!	O
elf_link_input_bfd	function
(	O
&	O
flinfo	pointer
,	O
sub	pointer
)	O
)	O
goto	O
error_return	O
;	O
sub	pointer
->	O
output_has_begun	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
||	O
p	pointer
->	O
type	enum
==	O
bfd_symbol_reloc_link_order	int
)	O
{	O
if	O
(	O
!	O
elf_reloc_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
p	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
_bfd_default_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
p	pointer
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
&&	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
&&	O
(	O
elf_elfheader	O
(	O
sub	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
!=	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
)	O
)	O
{	O
const	O
char	O
*	O
iclass	pointer
,	O
*	O
oclass	pointer
;	O
switch	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
)	O
{	O
case	O
ELFCLASS64	int
:	O
oclass	pointer
=	O
"ELFCLASS64"	pointer
;	O
break	O
;	O
case	O
ELFCLASS32	int
:	O
oclass	pointer
=	O
"ELFCLASS32"	pointer
;	O
break	O
;	O
case	O
ELFCLASSNONE	int
:	O
oclass	pointer
=	O
"ELFCLASSNONE"	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
switch	O
(	O
elf_elfheader	O
(	O
sub	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
)	O
{	O
case	O
ELFCLASS64	int
:	O
iclass	pointer
=	O
"ELFCLASS64"	pointer
;	O
break	O
;	O
case	O
ELFCLASS32	int
:	O
iclass	pointer
=	O
"ELFCLASS32"	pointer
;	O
break	O
;	O
case	O
ELFCLASSNONE	int
:	O
iclass	pointer
=	O
"ELFCLASSNONE"	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: file class %s incompatible with %s"	pointer
)	O
,	O
sub	pointer
,	O
iclass	pointer
,	O
oclass	pointer
)	O
;	O
}	O
goto	O
error_return	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
info	pointer
->	O
reduce_memory_overheads	int
)	O
{	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
elf_tdata	O
(	O
sub	pointer
)	O
->	O
symbuf	pointer
)	O
{	O
free	function
(	O
elf_tdata	O
(	O
sub	pointer
)	O
->	O
symbuf	pointer
)	O
;	O
elf_tdata	O
(	O
sub	pointer
)	O
->	O
symbuf	pointer
=	O
NULL	O
;	O
}	O
}	O
eoinfo	pointer
.	O
failed	int
=	O
FALSE	int
;	O
eoinfo	pointer
.	O
flinfo	pointer
=	O
&	O
flinfo	pointer
;	O
eoinfo	pointer
.	O
localsyms	int
=	O
TRUE	int
;	O
eoinfo	pointer
.	O
file_sym_done	int
=	O
FALSE	int
;	O
bfd_hash_traverse	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
elf_link_output_extsym	function
,	O
&	O
eoinfo	pointer
)	O
;	O
if	O
(	O
eoinfo	pointer
.	O
failed	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_output_arch_local_syms	pointer
&&	O
(	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
||	O
emit_relocs	int
)	O
)	O
{	O
typedef	O
int	O
(	O
*	O
out_sym_func	pointer
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
;	O
if	O
(	O
!	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_output_arch_local_syms	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
&	O
flinfo	pointer
,	O
(	O
out_sym_func	pointer
)	O
elf_link_output_symstrtab	function
)	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
symtab_hdr	struct
->	O
sh_info	array
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
dynamic	int
&&	O
htab	struct
->	O
dynsym	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
dynsym	pointer
->	O
output_section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
{	O
Elf_Internal_Sym	struct
sym	pointer
;	O
bfd_byte	char
*	O
dynsym	pointer
=	O
htab	struct
->	O
dynsym	pointer
->	O
contents	pointer
;	O
o	pointer
=	O
htab	struct
->	O
dynsym	pointer
->	O
output_section	pointer
;	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
htab	struct
->	O
local_dynsymcount	long
+	O
1	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
htab	struct
->	O
is_relocatable_executable	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
sym	pointer
.	O
st_size	long
=	O
0	int
;	O
sym	pointer
.	O
st_name	array
=	O
0	int
;	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_SECTION	int
)	O
;	O
sym	pointer
.	O
st_other	array
=	O
0	int
;	O
sym	pointer
.	O
st_target_internal	char
=	O
0	int
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
int	O
indx	long
;	O
bfd_byte	char
*	O
dest	pointer
;	O
long	O
dynindx	long
;	O
dynindx	long
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
dynindx	long
;	O
if	O
(	O
dynindx	long
<=	O
0	int
)	O
continue	O
;	O
indx	long
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
BFD_ASSERT	O
(	O
indx	long
>	O
0	int
)	O
;	O
sym	pointer
.	O
st_shndx	array
=	O
indx	long
;	O
if	O
(	O
!	O
check_dynsym	function
(	O
abfd	pointer
,	O
&	O
sym	pointer
)	O
)	O
return	O
FALSE	int
;	O
sym	pointer
.	O
st_value	array
=	O
s	pointer
->	O
vma	long
;	O
dest	pointer
=	O
dynsym	pointer
+	O
dynindx	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_out	pointer
(	O
abfd	pointer
,	O
&	O
sym	pointer
,	O
dest	pointer
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
dynlocal	pointer
)	O
{	O
struct	O
elf_link_local_dynamic_entry	struct
*	O
e	pointer
;	O
for	O
(	O
e	pointer
=	O
htab	struct
->	O
dynlocal	pointer
;	O
e	pointer
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_byte	char
*	O
dest	pointer
;	O
sym	pointer
=	O
e	pointer
->	O
isym	pointer
;	O
sym	pointer
.	O
st_other	array
&=	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
;	O
s	pointer
=	O
bfd_section_from_elf_index	function
(	O
e	pointer
->	O
input_bfd	pointer
,	O
e	pointer
->	O
isym	pointer
.	O
st_shndx	array
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
sym	pointer
.	O
st_shndx	array
=	O
elf_section_data	O
(	O
s	pointer
->	O
output_section	pointer
)	O
->	O
this_idx	int
;	O
if	O
(	O
!	O
check_dynsym	function
(	O
abfd	pointer
,	O
&	O
sym	pointer
)	O
)	O
return	O
FALSE	int
;	O
sym	pointer
.	O
st_value	array
=	O
(	O
s	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
s	pointer
->	O
output_offset	long
+	O
e	pointer
->	O
isym	pointer
.	O
st_value	array
)	O
;	O
}	O
dest	pointer
=	O
dynsym	pointer
+	O
e	pointer
->	O
dynindx	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_out	pointer
(	O
abfd	pointer
,	O
&	O
sym	pointer
,	O
dest	pointer
,	O
0	int
)	O
;	O
}	O
}	O
}	O
eoinfo	pointer
.	O
failed	int
=	O
FALSE	int
;	O
eoinfo	pointer
.	O
localsyms	int
=	O
FALSE	int
;	O
eoinfo	pointer
.	O
flinfo	pointer
=	O
&	O
flinfo	pointer
;	O
bfd_hash_traverse	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
elf_link_output_extsym	function
,	O
&	O
eoinfo	pointer
)	O
;	O
if	O
(	O
eoinfo	pointer
.	O
failed	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_output_arch_syms	pointer
&&	O
(	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
||	O
emit_relocs	int
)	O
)	O
{	O
typedef	O
int	O
(	O
*	O
out_sym_func	pointer
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
;	O
if	O
(	O
!	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_output_arch_syms	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
,	O
&	O
flinfo	pointer
,	O
(	O
out_sym_func	pointer
)	O
elf_link_output_symstrtab	function
)	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
_bfd_elf_strtab_finalize	function
(	O
flinfo	pointer
.	O
symstrtab	pointer
)	O
;	O
if	O
(	O
!	O
elf_link_swap_symbols_out	function
(	O
&	O
flinfo	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
>	O
0	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symstrtab_hdr	pointer
=	O
NULL	O
;	O
file_ptr	long
off	long
=	O
symtab_hdr	struct
->	O
sh_offset	array
+	O
symtab_hdr	struct
->	O
sh_size	array
;	O
if	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
)	O
{	O
symtab_shndx_hdr	pointer
=	O
&	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
->	O
hdr	pointer
;	O
if	O
(	O
symtab_shndx_hdr	pointer
!=	O
NULL	O
&&	O
symtab_shndx_hdr	pointer
->	O
sh_name	array
!=	O
0	int
)	O
{	O
symtab_shndx_hdr	pointer
->	O
sh_type	array
=	O
SHT_SYMTAB_SHNDX	int
;	O
symtab_shndx_hdr	pointer
->	O
sh_entsize	array
=	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
symtab_shndx_hdr	pointer
->	O
sh_addralign	array
=	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
amt	long
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
*	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
symtab_shndx_hdr	pointer
->	O
sh_size	array
=	O
amt	long
;	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
symtab_shndx_hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
symtab_shndx_hdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
(	O
bfd_bwrite	function
(	O
flinfo	pointer
.	O
symshndxbuf	pointer
,	O
amt	long
,	O
abfd	pointer
)	O
!=	O
amt	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
symstrtab_hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
;	O
symstrtab_hdr	pointer
->	O
sh_type	array
=	O
SHT_STRTAB	int
;	O
symstrtab_hdr	pointer
->	O
sh_flags	array
=	O
bed	pointer
->	O
elf_strtab_flags	long
;	O
symstrtab_hdr	pointer
->	O
sh_addr	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_size	array
=	O
_bfd_elf_strtab_size	function
(	O
flinfo	pointer
.	O
symstrtab	pointer
)	O
;	O
symstrtab_hdr	pointer
->	O
sh_entsize	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_link	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_info	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_addralign	array
=	O
1	int
;	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
symstrtab_hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
off	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
symstrtab_hdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
!	O
_bfd_elf_strtab_emit	function
(	O
abfd	pointer
,	O
flinfo	pointer
.	O
symstrtab	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
out_implib_bfd	pointer
&&	O
!	O
elf_output_implib	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: failed to generate import library"	pointer
)	O
,	O
info	pointer
->	O
out_implib_bfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
esdo	pointer
=	O
elf_section_data	O
(	O
o	pointer
)	O
;	O
bfd_boolean	int
sort	int
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
)	O
continue	O
;	O
sort	int
=	O
bed	pointer
->	O
sort_relocs_p	pointer
==	O
NULL	O
||	O
(	O
*	O
bed	pointer
->	O
sort_relocs_p	pointer
)	O
(	O
o	pointer
)	O
;	O
if	O
(	O
esdo	pointer
->	O
rel	pointer
.	O
hdr	pointer
!=	O
NULL	O
&&	O
!	O
elf_link_adjust_relocs	function
(	O
abfd	pointer
,	O
o	pointer
,	O
&	O
esdo	pointer
->	O
rel	pointer
,	O
sort	int
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
esdo	pointer
->	O
rela	struct
.	O
hdr	pointer
!=	O
NULL	O
&&	O
!	O
elf_link_adjust_relocs	function
(	O
abfd	pointer
,	O
o	pointer
,	O
&	O
esdo	pointer
->	O
rela	struct
,	O
sort	int
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
o	pointer
->	O
reloc_count	int
=	O
0	int
;	O
}	O
if	O
(	O
dynamic	int
&&	O
info	pointer
->	O
combreloc	int
&&	O
dynobj	pointer
!=	O
NULL	O
)	O
relativecount	long
=	O
elf_link_sort_relocs	function
(	O
abfd	pointer
,	O
info	pointer
,	O
&	O
reldyn	pointer
)	O
;	O
if	O
(	O
dynamic	int
)	O
{	O
bfd_byte	char
*	O
dyncon	pointer
,	O
*	O
dynconend	pointer
;	O
o	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".dynamic"	pointer
)	O
;	O
BFD_ASSERT	O
(	O
o	pointer
!=	O
NULL	O
)	O
;	O
dyncon	pointer
=	O
o	pointer
->	O
contents	pointer
;	O
dynconend	pointer
=	O
o	pointer
->	O
contents	pointer
+	O
o	pointer
->	O
size	long
;	O
for	O
(	O
;	O
dyncon	pointer
<	O
dynconend	pointer
;	O
dyncon	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
type	enum
;	O
bfd_size_type	long
sh_size	array
;	O
bfd_vma	long
sh_addr	array
;	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_in	pointer
(	O
dynobj	pointer
,	O
dyncon	pointer
,	O
&	O
dyn	struct
)	O
;	O
switch	O
(	O
dyn	struct
.	O
d_tag	array
)	O
{	O
default	O
:	O
continue	O
;	O
case	O
DT_NULL	int
:	O
if	O
(	O
relativecount	long
>	O
0	int
&&	O
dyncon	pointer
+	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
<	O
dynconend	pointer
)	O
{	O
switch	O
(	O
elf_section_data	O
(	O
reldyn	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
)	O
{	O
case	O
SHT_REL	int
:	O
dyn	struct
.	O
d_tag	array
=	O
DT_RELCOUNT	int
;	O
break	O
;	O
case	O
SHT_RELA	int
:	O
dyn	struct
.	O
d_tag	array
=	O
DT_RELACOUNT	int
;	O
break	O
;	O
default	O
:	O
continue	O
;	O
}	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
=	O
relativecount	long
;	O
relativecount	long
=	O
0	int
;	O
break	O
;	O
}	O
continue	O
;	O
case	O
DT_INIT	int
:	O
name	pointer
=	O
info	pointer
->	O
init_function	pointer
;	O
goto	O
get_sym	O
;	O
case	O
DT_FINI	int
:	O
name	pointer
=	O
info	pointer
->	O
fini_function	pointer
;	O
get_sym	O
:	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
htab	struct
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
{	O
dyn	struct
.	O
d_un	union
.	O
d_ptr	array
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
o	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
if	O
(	O
o	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
dyn	struct
.	O
d_un	union
.	O
d_ptr	array
+=	O
(	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
o	pointer
->	O
output_offset	long
)	O
;	O
else	O
{	O
dyn	struct
.	O
d_un	union
.	O
d_ptr	array
=	O
0	int
;	O
}	O
break	O
;	O
}	O
}	O
continue	O
;	O
case	O
DT_PREINIT_ARRAYSZ	int
:	O
name	pointer
=	O
".preinit_array"	pointer
;	O
goto	O
get_out_size	O
;	O
case	O
DT_INIT_ARRAYSZ	int
:	O
name	pointer
=	O
".init_array"	pointer
;	O
goto	O
get_out_size	O
;	O
case	O
DT_FINI_ARRAYSZ	int
:	O
name	pointer
=	O
".fini_array"	pointer
;	O
get_out_size	O
:	O
o	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
o	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"could not find section %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
o	pointer
->	O
size	long
==	O
0	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: %s section has zero size"	pointer
)	O
,	O
name	pointer
)	O
;	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
=	O
o	pointer
->	O
size	long
;	O
break	O
;	O
case	O
DT_PREINIT_ARRAY	int
:	O
name	pointer
=	O
".preinit_array"	pointer
;	O
goto	O
get_out_vma	O
;	O
case	O
DT_INIT_ARRAY	int
:	O
name	pointer
=	O
".init_array"	pointer
;	O
goto	O
get_out_vma	O
;	O
case	O
DT_FINI_ARRAY	int
:	O
name	pointer
=	O
".fini_array"	pointer
;	O
get_out_vma	O
:	O
o	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
goto	O
do_vma	O
;	O
case	O
DT_HASH	int
:	O
name	pointer
=	O
".hash"	pointer
;	O
goto	O
get_vma	O
;	O
case	O
DT_GNU_HASH	int
:	O
name	pointer
=	O
".gnu.hash"	pointer
;	O
goto	O
get_vma	O
;	O
case	O
DT_STRTAB	int
:	O
name	pointer
=	O
".dynstr"	pointer
;	O
goto	O
get_vma	O
;	O
case	O
DT_SYMTAB	int
:	O
name	pointer
=	O
".dynsym"	pointer
;	O
goto	O
get_vma	O
;	O
case	O
DT_VERDEF	int
:	O
name	pointer
=	O
".gnu.version_d"	pointer
;	O
goto	O
get_vma	O
;	O
case	O
DT_VERNEED	int
:	O
name	pointer
=	O
".gnu.version_r"	pointer
;	O
goto	O
get_vma	O
;	O
case	O
DT_VERSYM	int
:	O
name	pointer
=	O
".gnu.version"	pointer
;	O
get_vma	O
:	O
o	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
name	pointer
)	O
;	O
do_vma	O
:	O
if	O
(	O
o	pointer
==	O
NULL	O
||	O
bfd_is_abs_section	function
(	O
o	pointer
->	O
output_section	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"could not find section %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
elf_section_data	O
(	O
o	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_NOTE	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: section '%s' is being made into a note"	pointer
)	O
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_nonrepresentable_section	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
dyn	struct
.	O
d_un	union
.	O
d_ptr	array
=	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
o	pointer
->	O
output_offset	long
;	O
break	O
;	O
case	O
DT_REL	int
:	O
case	O
DT_RELA	int
:	O
case	O
DT_RELSZ	int
:	O
case	O
DT_RELASZ	int
:	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_REL	int
||	O
dyn	struct
.	O
d_tag	array
==	O
DT_RELSZ	int
)	O
type	enum
=	O
SHT_REL	int
;	O
else	O
type	enum
=	O
SHT_RELA	int
;	O
sh_size	array
=	O
0	int
;	O
sh_addr	array
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
hdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
type	enum
&&	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
{	O
sh_size	array
+=	O
hdr	pointer
->	O
sh_size	array
;	O
if	O
(	O
sh_addr	array
==	O
0	int
||	O
sh_addr	array
>	O
hdr	pointer
->	O
sh_addr	array
)	O
sh_addr	array
=	O
hdr	pointer
->	O
sh_addr	array
;	O
}	O
}	O
if	O
(	O
bed	pointer
->	O
dtrel_excludes_plt	int
&&	O
htab	struct
->	O
srelplt	pointer
!=	O
NULL	O
)	O
{	O
sh_size	array
-=	O
htab	struct
->	O
srelplt	pointer
->	O
size	long
;	O
if	O
(	O
sh_size	array
==	O
0	int
)	O
sh_addr	array
=	O
0	int
;	O
else	O
if	O
(	O
sh_addr	array
==	O
(	O
htab	struct
->	O
srelplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
srelplt	pointer
->	O
output_offset	long
)	O
)	O
sh_addr	array
+=	O
htab	struct
->	O
srelplt	pointer
->	O
size	long
;	O
}	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_RELSZ	int
||	O
dyn	struct
.	O
d_tag	array
==	O
DT_RELASZ	int
)	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
=	O
sh_size	array
;	O
else	O
dyn	struct
.	O
d_un	union
.	O
d_ptr	array
=	O
sh_addr	array
;	O
break	O
;	O
}	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_out	pointer
(	O
dynobj	pointer
,	O
&	O
dyn	struct
,	O
dyncon	pointer
)	O
;	O
}	O
}	O
if	O
(	O
dynobj	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_finish_dynamic_sections	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
(	O
(	O
info	pointer
->	O
warn_shared_textrel	int
&&	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
||	O
info	pointer
->	O
error_textrel	int
)	O
&&	O
(	O
o	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".dynamic"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
bfd_byte	char
*	O
dyncon	pointer
,	O
*	O
dynconend	pointer
;	O
dyncon	pointer
=	O
o	pointer
->	O
contents	pointer
;	O
dynconend	pointer
=	O
o	pointer
->	O
contents	pointer
+	O
o	pointer
->	O
size	long
;	O
for	O
(	O
;	O
dyncon	pointer
<	O
dynconend	pointer
;	O
dyncon	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_in	pointer
(	O
dynobj	pointer
,	O
dyncon	pointer
,	O
&	O
dyn	struct
)	O
;	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_TEXTREL	int
)	O
{	O
if	O
(	O
info	pointer
->	O
error_textrel	int
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P%X: read-only segment has dynamic relocations\n"	pointer
)	O
)	O
;	O
else	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: creating a DT_TEXTREL in a shared object\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
o	pointer
=	O
dynobj	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
||	O
o	pointer
->	O
size	long
==	O
0	int
||	O
o	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
)	O
continue	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
htab	struct
->	O
stab_info	struct
.	O
stabstr	pointer
==	O
o	pointer
)	O
continue	O
;	O
if	O
(	O
htab	struct
->	O
eh_info	struct
.	O
hdr_sec	pointer
==	O
o	pointer
)	O
continue	O
;	O
if	O
(	O
strcmp	function
(	O
o	pointer
->	O
name	pointer
,	O
".dynstr"	pointer
)	O
!=	O
0	int
)	O
{	O
bfd_size_type	long
octets	long
=	O
(	O
(	O
file_ptr	long
)	O
o	pointer
->	O
output_offset	long
*	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
o	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
o	pointer
->	O
output_section	pointer
,	O
o	pointer
->	O
contents	pointer
,	O
octets	long
,	O
o	pointer
->	O
size	long
)	O
)	O
goto	O
error_return	O
;	O
}	O
else	O
{	O
file_ptr	long
off	long
;	O
off	long
=	O
elf_section_data	O
(	O
o	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_offset	array
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
off	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
!	O
_bfd_elf_strtab_emit	function
(	O
abfd	pointer
,	O
htab	struct
->	O
dynstr	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
info	pointer
->	O
resolve_section_groups	int
)	O
{	O
bfd_boolean	int
failed	int
=	O
FALSE	int
;	O
BFD_ASSERT	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
;	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
bfd_elf_set_group_contents	function
,	O
&	O
failed	int
)	O
;	O
if	O
(	O
failed	int
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
htab	struct
->	O
stab_info	struct
.	O
stabstr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
_bfd_write_stab_strings	function
(	O
abfd	pointer
,	O
&	O
htab	struct
->	O
stab_info	struct
)	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
!	O
_bfd_elf_write_section_eh_frame_hdr	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
info	pointer
->	O
callbacks	pointer
->	O
emit_ctf	pointer
)	O
info	pointer
->	O
callbacks	pointer
->	O
emit_ctf	pointer
(	O
)	O
;	O
elf_final_link_free	function
(	O
abfd	pointer
,	O
&	O
flinfo	pointer
)	O
;	O
if	O
(	O
attr_section	pointer
)	O
{	O
bfd_byte	char
*	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
attr_size	long
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
bfd_elf_set_obj_attr_contents	function
(	O
abfd	pointer
,	O
contents	pointer
,	O
attr_size	long
)	O
;	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
attr_section	pointer
,	O
contents	pointer
,	O
0	int
,	O
attr_size	long
)	O
;	O
free	function
(	O
contents	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
error_return	O
:	O
elf_final_link_free	function
(	O
abfd	pointer
,	O
&	O
flinfo	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
init_reloc_cookie	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
cookie	pointer
->	O
abfd	pointer
=	O
abfd	pointer
;	O
cookie	pointer
->	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
cookie	pointer
->	O
bad_symtab	int
=	O
elf_bad_symtab	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
cookie	pointer
->	O
bad_symtab	int
)	O
{	O
cookie	pointer
->	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
cookie	pointer
->	O
extsymoff	long
=	O
0	int
;	O
}	O
else	O
{	O
cookie	pointer
->	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
cookie	pointer
->	O
extsymoff	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
}	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
32	int
)	O
cookie	pointer
->	O
r_sym_shift	int
=	O
8	int
;	O
else	O
cookie	pointer
->	O
r_sym_shift	int
=	O
32	int
;	O
cookie	pointer
->	O
locsyms	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
symtab_hdr	struct
->	O
contents	pointer
;	O
if	O
(	O
cookie	pointer
->	O
locsyms	pointer
==	O
NULL	O
&&	O
cookie	pointer
->	O
locsymcount	long
!=	O
0	int
)	O
{	O
cookie	pointer
->	O
locsyms	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
cookie	pointer
->	O
locsymcount	long
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
cookie	pointer
->	O
locsyms	pointer
==	O
NULL	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P%X: can not read symbols: %E\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
keep_memory	int
)	O
symtab_hdr	struct
->	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
cookie	pointer
->	O
locsyms	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
fini_reloc_cookie	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
if	O
(	O
cookie	pointer
->	O
locsyms	pointer
!=	O
NULL	O
&&	O
symtab_hdr	struct
->	O
contents	pointer
!=	O
(	O
unsigned	O
char	O
*	O
)	O
cookie	pointer
->	O
locsyms	pointer
)	O
free	function
(	O
cookie	pointer
->	O
locsyms	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
init_reloc_cookie_rels	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
reloc_count	int
==	O
0	int
)	O
{	O
cookie	pointer
->	O
rels	pointer
=	O
NULL	O
;	O
cookie	pointer
->	O
relend	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
cookie	pointer
->	O
rels	pointer
=	O
_bfd_elf_link_read_relocs	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
NULL	O
,	O
NULL	O
,	O
info	pointer
->	O
keep_memory	int
)	O
;	O
if	O
(	O
cookie	pointer
->	O
rels	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
cookie	pointer
->	O
rel	pointer
=	O
cookie	pointer
->	O
rels	pointer
;	O
cookie	pointer
->	O
relend	pointer
=	O
cookie	pointer
->	O
rels	pointer
+	O
sec	pointer
->	O
reloc_count	int
;	O
}	O
cookie	pointer
->	O
rel	pointer
=	O
cookie	pointer
->	O
rels	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
fini_reloc_cookie_rels	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
cookie	pointer
->	O
rels	pointer
&&	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
relocs	pointer
!=	O
cookie	pointer
->	O
rels	pointer
)	O
free	function
(	O
cookie	pointer
->	O
rels	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
init_reloc_cookie_for_section	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
!	O
init_reloc_cookie	function
(	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
)	O
goto	O
error1	O
;	O
if	O
(	O
!	O
init_reloc_cookie_rels	function
(	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
goto	O
error2	O
;	O
return	O
TRUE	int
;	O
error2	O
:	O
fini_reloc_cookie	function
(	O
cookie	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
;	O
error1	O
:	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
fini_reloc_cookie_for_section	function
(	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
fini_reloc_cookie_rels	function
(	O
cookie	pointer
,	O
sec	pointer
)	O
;	O
fini_reloc_cookie	function
(	O
cookie	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
;	O
}	O
asection	struct
*	O
_bfd_elf_gc_mark_hook	function
(	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
return	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
case	O
bfd_link_hash_common	int
:	O
return	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
;	O
default	O
:	O
break	O
;	O
}	O
}	O
else	O
return	O
bfd_section_from_elf_index	function
(	O
sec	pointer
->	O
owner	pointer
,	O
sym	pointer
->	O
st_shndx	array
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
asection	struct
*	O
elf_gc_mark_debug_section	function
(	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
return	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
}	O
else	O
{	O
asection	struct
*	O
isec	pointer
=	O
bfd_section_from_elf_index	function
(	O
sec	pointer
->	O
owner	pointer
,	O
sym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
return	O
isec	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
asection	struct
*	O
_bfd_elf_gc_mark_rsec	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
bfd_boolean	int
*	O
start_stop	int
)	O
{	O
unsigned	O
long	O
r_symndx	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
*	O
hw	pointer
;	O
r_symndx	long
=	O
cookie	pointer
->	O
rel	pointer
->	O
r_info	array
>>	O
cookie	pointer
->	O
r_sym_shift	int
;	O
if	O
(	O
r_symndx	long
==	O
STN_UNDEF	int
)	O
return	O
NULL	O
;	O
if	O
(	O
r_symndx	long
>=	O
cookie	pointer
->	O
locsymcount	long
||	O
ELF_ST_BIND	O
(	O
cookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
.	O
st_info	array
)	O
!=	O
STB_LOCAL	int
)	O
{	O
h	pointer
=	O
cookie	pointer
->	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
cookie	pointer
->	O
extsymoff	long
]	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: corrupt input: %pB\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
h	pointer
->	O
mark	int
=	O
1	int
;	O
hw	pointer
=	O
h	pointer
;	O
while	O
(	O
hw	pointer
->	O
is_weakalias	int
)	O
{	O
hw	pointer
=	O
hw	pointer
->	O
u	union
.	O
alias	pointer
;	O
hw	pointer
->	O
mark	int
=	O
1	int
;	O
}	O
if	O
(	O
start_stop	int
!=	O
NULL	O
)	O
{	O
if	O
(	O
h	pointer
->	O
start_stop	int
)	O
{	O
asection	struct
*	O
s	pointer
=	O
h	pointer
->	O
u2	union
.	O
start_stop_section	pointer
;	O
*	O
start_stop	int
=	O
!	O
s	pointer
->	O
gc_mark	int
;	O
return	O
s	pointer
;	O
}	O
}	O
return	O
(	O
*	O
gc_mark_hook	pointer
)	O
(	O
sec	pointer
,	O
info	pointer
,	O
cookie	pointer
->	O
rel	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
*	O
gc_mark_hook	pointer
)	O
(	O
sec	pointer
,	O
info	pointer
,	O
cookie	pointer
->	O
rel	pointer
,	O
NULL	O
,	O
&	O
cookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_gc_mark_reloc	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
asection	struct
*	O
rsec	pointer
;	O
bfd_boolean	int
start_stop	int
=	O
FALSE	int
;	O
rsec	pointer
=	O
_bfd_elf_gc_mark_rsec	function
(	O
info	pointer
,	O
sec	pointer
,	O
gc_mark_hook	pointer
,	O
cookie	pointer
,	O
&	O
start_stop	int
)	O
;	O
while	O
(	O
rsec	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
rsec	pointer
->	O
gc_mark	int
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
rsec	pointer
->	O
owner	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
(	O
rsec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
rsec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
_bfd_elf_gc_mark	function
(	O
info	pointer
,	O
rsec	pointer
,	O
gc_mark_hook	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
start_stop	int
)	O
break	O
;	O
rsec	pointer
=	O
bfd_get_next_section_by_name	function
(	O
rsec	pointer
->	O
owner	pointer
,	O
rsec	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_gc_mark	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
)	O
{	O
bfd_boolean	int
ret	pointer
;	O
asection	struct
*	O
group_sec	pointer
,	O
*	O
eh_frame	pointer
;	O
sec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
group_sec	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
next_in_group	pointer
;	O
if	O
(	O
group_sec	pointer
&&	O
!	O
group_sec	pointer
->	O
gc_mark	int
)	O
if	O
(	O
!	O
_bfd_elf_gc_mark	function
(	O
info	pointer
,	O
group_sec	pointer
,	O
gc_mark_hook	pointer
)	O
)	O
return	O
FALSE	int
;	O
ret	pointer
=	O
TRUE	int
;	O
eh_frame	pointer
=	O
elf_eh_frame_section	O
(	O
sec	pointer
->	O
owner	pointer
)	O
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
&&	O
sec	pointer
->	O
reloc_count	int
>	O
0	int
&&	O
sec	pointer
!=	O
eh_frame	pointer
)	O
{	O
struct	O
elf_reloc_cookie	struct
cookie	pointer
;	O
if	O
(	O
!	O
init_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
{	O
for	O
(	O
;	O
cookie	pointer
.	O
rel	pointer
<	O
cookie	pointer
.	O
relend	pointer
;	O
cookie	pointer
.	O
rel	pointer
++	O
)	O
if	O
(	O
!	O
_bfd_elf_gc_mark_reloc	function
(	O
info	pointer
,	O
sec	pointer
,	O
gc_mark_hook	pointer
,	O
&	O
cookie	pointer
)	O
)	O
{	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
fini_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
sec	pointer
)	O
;	O
}	O
}	O
if	O
(	O
ret	pointer
&&	O
eh_frame	pointer
&&	O
elf_fde_list	O
(	O
sec	pointer
)	O
)	O
{	O
struct	O
elf_reloc_cookie	struct
cookie	pointer
;	O
if	O
(	O
!	O
init_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
eh_frame	pointer
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
{	O
if	O
(	O
!	O
_bfd_elf_gc_mark_fdes	function
(	O
info	pointer
,	O
sec	pointer
,	O
eh_frame	pointer
,	O
gc_mark_hook	pointer
,	O
&	O
cookie	pointer
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
fini_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
eh_frame	pointer
)	O
;	O
}	O
}	O
eh_frame	pointer
=	O
elf_section_eh_frame_entry	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
ret	pointer
&&	O
eh_frame	pointer
&&	O
!	O
eh_frame	pointer
->	O
gc_mark	int
)	O
if	O
(	O
!	O
_bfd_elf_gc_mark	function
(	O
info	pointer
,	O
eh_frame	pointer
,	O
gc_mark_hook	pointer
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
_bfd_elf_gc_mark_debug_special_section_group	function
(	O
asection	struct
*	O
grp	pointer
)	O
{	O
asection	struct
*	O
ssec	pointer
;	O
asection	struct
*	O
msec	pointer
;	O
bfd_boolean	int
is_special_grp	int
=	O
TRUE	int
;	O
bfd_boolean	int
is_debug_grp	int
=	O
TRUE	int
;	O
ssec	pointer
=	O
msec	pointer
=	O
elf_next_in_group	O
(	O
grp	pointer
)	O
;	O
do	O
{	O
if	O
(	O
(	O
msec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
==	O
0	int
)	O
is_debug_grp	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
msec	pointer
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
)	O
!=	O
0	int
)	O
is_special_grp	int
=	O
FALSE	int
;	O
msec	pointer
=	O
elf_next_in_group	O
(	O
msec	pointer
)	O
;	O
}	O
while	O
(	O
msec	pointer
!=	O
ssec	pointer
)	O
;	O
if	O
(	O
is_debug_grp	int
||	O
is_special_grp	int
)	O
{	O
do	O
{	O
msec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
msec	pointer
=	O
elf_next_in_group	O
(	O
msec	pointer
)	O
;	O
}	O
while	O
(	O
msec	pointer
!=	O
ssec	pointer
)	O
;	O
}	O
}	O
bfd_boolean	int
_bfd_elf_gc_mark_extra_sections	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
elf_gc_mark_hook_fn	pointer
mark_hook	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
bfd	struct
*	O
ibfd	pointer
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
!=	O
NULL	O
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
isec	pointer
;	O
bfd_boolean	int
some_kept	int
;	O
bfd_boolean	int
debug_frag_seen	int
;	O
bfd_boolean	int
has_kept_debug_info	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
continue	O
;	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
if	O
(	O
isec	pointer
==	O
NULL	O
||	O
isec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
debug_frag_seen	int
=	O
some_kept	int
=	O
has_kept_debug_info	int
=	O
FALSE	int
;	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
)	O
isec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
else	O
if	O
(	O
isec	pointer
->	O
gc_mark	int
&&	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
elf_section_type	O
(	O
isec	pointer
)	O
!=	O
SHT_NOTE	int
)	O
some_kept	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
debug_frag_seen	int
&&	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
&&	O
CONST_STRNEQ	O
(	O
isec	pointer
->	O
name	pointer
,	O
".debug_line."	pointer
)	O
)	O
debug_frag_seen	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
some_kept	int
)	O
continue	O
;	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
_bfd_elf_gc_mark_debug_special_section_group	function
(	O
isec	pointer
)	O
;	O
else	O
if	O
(	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
||	O
(	O
isec	pointer
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
)	O
==	O
0	int
)	O
&&	O
elf_next_in_group	O
(	O
isec	pointer
)	O
==	O
NULL	O
)	O
isec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
if	O
(	O
isec	pointer
->	O
gc_mark	int
&&	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
has_kept_debug_info	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
debug_frag_seen	int
)	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
&&	O
isec	pointer
->	O
gc_mark	int
==	O
0	int
)	O
{	O
unsigned	O
int	O
ilen	int
;	O
asection	struct
*	O
dsec	pointer
;	O
ilen	int
=	O
strlen	function
(	O
isec	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
dsec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
dsec	pointer
!=	O
NULL	O
;	O
dsec	pointer
=	O
dsec	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
int	O
dlen	int
;	O
if	O
(	O
dsec	pointer
->	O
gc_mark	int
==	O
0	int
||	O
(	O
dsec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
==	O
0	int
)	O
continue	O
;	O
dlen	int
=	O
strlen	function
(	O
dsec	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
dlen	int
>	O
ilen	int
&&	O
strncmp	function
(	O
dsec	pointer
->	O
name	pointer
+	O
(	O
dlen	int
-	O
ilen	int
)	O
,	O
isec	pointer
->	O
name	pointer
,	O
ilen	int
)	O
==	O
0	int
)	O
dsec	pointer
->	O
gc_mark	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
has_kept_debug_info	int
)	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
if	O
(	O
isec	pointer
->	O
gc_mark	int
&&	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
if	O
(	O
!	O
_bfd_elf_gc_mark	function
(	O
info	pointer
,	O
isec	pointer
,	O
elf_gc_mark_debug_section	function
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_gc_sweep	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
sub	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
o	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
elf_object_id	O
(	O
sub	pointer
)	O
!=	O
elf_hash_table_id	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
)	O
||	O
!	O
(	O
*	O
bed	pointer
->	O
relocs_compatible	pointer
)	O
(	O
sub	pointer
->	O
xvec	pointer
,	O
abfd	pointer
->	O
xvec	pointer
)	O
)	O
continue	O
;	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
if	O
(	O
o	pointer
==	O
NULL	O
||	O
o	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
for	O
(	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
{	O
asection	struct
*	O
first	long
=	O
elf_next_in_group	O
(	O
o	pointer
)	O
;	O
o	pointer
->	O
gc_mark	int
=	O
first	long
->	O
gc_mark	int
;	O
}	O
if	O
(	O
o	pointer
->	O
gc_mark	int
)	O
continue	O
;	O
if	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
continue	O
;	O
o	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
if	O
(	O
info	pointer
->	O
print_gc_sections	int
&&	O
o	pointer
->	O
size	long
!=	O
0	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"removing unused section '%pA' in file '%pB'"	pointer
)	O
,	O
o	pointer
,	O
sub	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_gc_propagate_vtable_entries_used	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
okp	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
start_stop	int
||	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
==	O
NULL	O
||	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
==	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
&&	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
[	O
-	O
1	int
]	O
)	O
return	O
TRUE	int
;	O
elf_gc_propagate_vtable_entries_used	function
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
,	O
okp	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
==	O
NULL	O
)	O
{	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
;	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
;	O
}	O
else	O
{	O
size_t	long
n	long
;	O
bfd_boolean	int
*	O
cu	pointer
,	O
*	O
pu	pointer
;	O
cu	pointer
=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
;	O
cu	pointer
[	O
-	O
1	int
]	O
=	O
TRUE	int
;	O
pu	pointer
=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
;	O
if	O
(	O
pu	pointer
!=	O
NULL	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
int	O
log_file_align	char
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
log_file_align	char
=	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
n	long
=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
>>	O
log_file_align	char
;	O
while	O
(	O
n	long
--	O
)	O
{	O
if	O
(	O
*	O
pu	pointer
)	O
*	O
cu	pointer
=	O
TRUE	int
;	O
pu	pointer
++	O
;	O
cu	pointer
++	O
;	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_gc_smash_unused_vtentry_relocs	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
okp	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
bfd_vma	long
hstart	long
,	O
hend	long
;	O
Elf_Internal_Rela	struct
*	O
relstart	pointer
,	O
*	O
relend	pointer
,	O
*	O
rel	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
int	O
log_file_align	char
;	O
if	O
(	O
h	pointer
->	O
start_stop	int
||	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
==	O
NULL	O
||	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
BFD_ASSERT	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
;	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
hstart	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
hend	long
=	O
hstart	long
+	O
h	pointer
->	O
size	long
;	O
relstart	pointer
=	O
_bfd_elf_link_read_relocs	function
(	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
,	O
NULL	O
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
if	O
(	O
!	O
relstart	pointer
)	O
return	O
*	O
(	O
bfd_boolean	int
*	O
)	O
okp	pointer
=	O
FALSE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
sec	pointer
->	O
owner	pointer
)	O
;	O
log_file_align	char
=	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
relend	pointer
=	O
relstart	pointer
+	O
sec	pointer
->	O
reloc_count	int
;	O
for	O
(	O
rel	pointer
=	O
relstart	pointer
;	O
rel	pointer
<	O
relend	pointer
;	O
++	O
rel	pointer
)	O
if	O
(	O
rel	pointer
->	O
r_offset	array
>=	O
hstart	long
&&	O
rel	pointer
->	O
r_offset	array
<	O
hend	long
)	O
{	O
if	O
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
&&	O
(	O
rel	pointer
->	O
r_offset	array
-	O
hstart	long
)	O
<	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
)	O
{	O
bfd_vma	long
entry	pointer
=	O
(	O
rel	pointer
->	O
r_offset	array
-	O
hstart	long
)	O
>>	O
log_file_align	char
;	O
if	O
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
[	O
entry	pointer
]	O
)	O
continue	O
;	O
}	O
rel	pointer
->	O
r_offset	array
=	O
rel	pointer
->	O
r_info	array
=	O
rel	pointer
->	O
r_addend	array
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_gc_mark_dynamic_ref_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
struct	O
bfd_elf_dynamic_list	struct
*	O
d	double
=	O
info	pointer
->	O
dynamic_list	pointer
;	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
(	O
h	pointer
->	O
ref_dynamic	int
&&	O
!	O
h	pointer
->	O
forced_local	int
)	O
||	O
(	O
(	O
h	pointer
->	O
def_regular	int
||	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
&&	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_INTERNAL	int
&&	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_HIDDEN	int
&&	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
info	pointer
->	O
gc_keep_exported	int
||	O
info	pointer
->	O
export_dynamic	int
||	O
(	O
h	pointer
->	O
dynamic	int
&&	O
d	double
!=	O
NULL	O
&&	O
(	O
*	O
d	double
->	O
match	pointer
)	O
(	O
&	O
d	double
->	O
head	pointer
,	O
NULL	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
)	O
)	O
&&	O
(	O
h	pointer
->	O
versioned	int
>=	O
versioned	int
||	O
!	O
bfd_hide_sym_by_version	function
(	O
info	pointer
->	O
version_info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
)	O
)	O
)	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_elf_gc_keep	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
bfd_sym_chain	struct
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
info	pointer
->	O
gc_sym_list	pointer
;	O
sym	pointer
!=	O
NULL	O
;	O
sym	pointer
=	O
sym	pointer
->	O
next	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
sym	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
!	O
bfd_is_abs_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
&&	O
!	O
bfd_is_und_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
}	O
}	O
bfd_boolean	int
bfd_elf_parse_eh_frame_entries	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
!=	O
NULL	O
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
struct	O
elf_reloc_cookie	struct
cookie	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
continue	O
;	O
sec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
if	O
(	O
!	O
init_reloc_cookie	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
ibfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
sec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
CONST_STRNEQ	O
(	O
bfd_section_name	function
(	O
sec	pointer
)	O
,	O
".eh_frame_entry"	pointer
)	O
&&	O
init_reloc_cookie_rels	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
ibfd	pointer
,	O
sec	pointer
)	O
)	O
{	O
_bfd_elf_parse_eh_frame_entry	function
(	O
info	pointer
,	O
sec	pointer
,	O
&	O
cookie	pointer
)	O
;	O
fini_reloc_cookie_rels	function
(	O
&	O
cookie	pointer
,	O
sec	pointer
)	O
;	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_gc_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_boolean	int
ok	int
=	O
TRUE	int
;	O
bfd	struct
*	O
sub	pointer
;	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
if	O
(	O
!	O
bed	pointer
->	O
can_gc_sections	int
||	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: gc-sections option ignored"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
bed	pointer
->	O
gc_keep	pointer
(	O
info	pointer
)	O
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
info	pointer
->	O
eh_frame_hdr_type	int
!=	O
COMPACT_EH_HDR	int
&&	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
struct	O
elf_reloc_cookie	struct
cookie	pointer
;	O
sec	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
sub	pointer
,	O
".eh_frame"	pointer
)	O
;	O
while	O
(	O
sec	pointer
&&	O
init_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
)	O
)	O
{	O
_bfd_elf_parse_eh_frame	function
(	O
sub	pointer
,	O
info	pointer
,	O
sec	pointer
,	O
&	O
cookie	pointer
)	O
;	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
)	O
elf_eh_frame_section	O
(	O
sub	pointer
)	O
=	O
sec	pointer
;	O
fini_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
sec	pointer
)	O
;	O
sec	pointer
=	O
bfd_get_next_section_by_name	function
(	O
NULL	O
,	O
sec	pointer
)	O
;	O
}	O
}	O
elf_link_hash_traverse	O
(	O
htab	struct
,	O
elf_gc_propagate_vtable_entries_used	function
,	O
&	O
ok	int
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
FALSE	int
;	O
elf_link_hash_traverse	O
(	O
htab	struct
,	O
elf_gc_smash_unused_vtentry_relocs	function
,	O
&	O
ok	int
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
htab	struct
->	O
dynamic_sections_created	int
||	O
info	pointer
->	O
gc_keep_exported	int
)	O
elf_link_hash_traverse	O
(	O
htab	struct
,	O
bed	pointer
->	O
gc_mark_dynamic_ref	pointer
,	O
info	pointer
)	O
;	O
gc_mark_hook	pointer
=	O
bed	pointer
->	O
gc_mark_hook	pointer
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
o	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
elf_object_id	O
(	O
sub	pointer
)	O
!=	O
elf_hash_table_id	O
(	O
htab	struct
)	O
||	O
!	O
(	O
*	O
bed	pointer
->	O
relocs_compatible	pointer
)	O
(	O
sub	pointer
->	O
xvec	pointer
,	O
abfd	pointer
->	O
xvec	pointer
)	O
)	O
continue	O
;	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
if	O
(	O
o	pointer
==	O
NULL	O
||	O
o	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
for	O
(	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
o	pointer
->	O
gc_mark	int
&&	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_KEEP	int
)	O
!=	O
0	int
||	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
(	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_PREINIT_ARRAY	int
)	O
||	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_INIT_ARRAY	int
)	O
||	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_FINI_ARRAY	int
)	O
)	O
)	O
||	O
(	O
elf_section_data	O
(	O
o	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_NOTE	int
&&	O
elf_next_in_group	O
(	O
o	pointer
)	O
==	O
NULL	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_gc_mark	function
(	O
info	pointer
,	O
o	pointer
,	O
gc_mark_hook	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
bed	pointer
->	O
gc_mark_extra_sections	pointer
(	O
info	pointer
,	O
gc_mark_hook	pointer
)	O
;	O
return	O
elf_gc_sweep	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
bfd_boolean	int
bfd_elf_gc_record_vtinherit	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_vma	long
offset	long
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
,	O
*	O
*	O
sym_hashes_end	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
search	pointer
,	O
*	O
child	pointer
;	O
size_t	long
extsymcount	long
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
extsymcount	long
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
!	O
elf_bad_symtab	O
(	O
abfd	pointer
)	O
)	O
extsymcount	long
-=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_info	array
;	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
sym_hashes_end	pointer
=	O
sym_hashes	pointer
+	O
extsymcount	long
;	O
for	O
(	O
search	pointer
=	O
sym_hashes	pointer
;	O
search	pointer
!=	O
sym_hashes_end	pointer
;	O
++	O
search	pointer
)	O
{	O
if	O
(	O
(	O
child	pointer
=	O
*	O
search	pointer
)	O
!=	O
NULL	O
&&	O
(	O
child	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
child	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
child	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
sec	pointer
&&	O
child	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
==	O
offset	long
)	O
goto	O
win	O
;	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %pA+%#"	pointer
PRIx64	O
": no symbol found for INHERIT"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
,	O
(	O
uint64_t	long
)	O
offset	long
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
win	O
:	O
if	O
(	O
!	O
child	pointer
->	O
u2	union
.	O
vtable	pointer
)	O
{	O
child	pointer
->	O
u2	union
.	O
vtable	pointer
=	O
(	O
(	O
struct	O
elf_link_virtual_table_entry	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
child	pointer
->	O
u2	union
.	O
vtable	pointer
)	O
)	O
)	O
;	O
if	O
(	O
!	O
child	pointer
->	O
u2	union
.	O
vtable	pointer
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
h	pointer
)	O
{	O
child	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
-	O
1	int
;	O
}	O
else	O
child	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
parent	pointer
=	O
h	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_gc_record_vtentry	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_vma	long
addend	long
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
unsigned	O
int	O
log_file_align	char
=	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
if	O
(	O
!	O
h	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: section '%pA': corrupt VTENTRY entry"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
)	O
{	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
=	O
(	O
(	O
struct	O
elf_link_virtual_table_entry	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
)	O
)	O
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
addend	long
>=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
)	O
{	O
size_t	long
size	long
,	O
bytes	long
,	O
file_align	long
;	O
bfd_boolean	int
*	O
ptr	pointer
=	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
;	O
file_align	long
=	O
1	int
<<	O
log_file_align	char
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
size	long
=	O
addend	long
+	O
file_align	long
;	O
else	O
{	O
size	long
=	O
h	pointer
->	O
size	long
;	O
if	O
(	O
addend	long
>=	O
size	long
)	O
{	O
size	long
=	O
addend	long
+	O
file_align	long
;	O
}	O
}	O
size	long
=	O
(	O
size	long
+	O
file_align	long
-	O
1	int
)	O
&	O
-	O
file_align	long
;	O
bytes	long
=	O
(	O
(	O
size	long
>>	O
log_file_align	char
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
bfd_boolean	int
)	O
;	O
if	O
(	O
ptr	pointer
)	O
{	O
ptr	pointer
=	O
(	O
bfd_boolean	int
*	O
)	O
bfd_realloc	function
(	O
ptr	pointer
-	O
1	int
,	O
bytes	long
)	O
;	O
if	O
(	O
ptr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
oldbytes	long
;	O
oldbytes	long
=	O
(	O
(	O
(	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
>>	O
log_file_align	char
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
bfd_boolean	int
)	O
)	O
;	O
memset	function
(	O
(	O
(	O
char	O
*	O
)	O
ptr	pointer
)	O
+	O
oldbytes	long
,	O
0	int
,	O
bytes	long
-	O
oldbytes	long
)	O
;	O
}	O
}	O
else	O
ptr	pointer
=	O
(	O
bfd_boolean	int
*	O
)	O
bfd_zmalloc	function
(	O
bytes	long
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
=	O
ptr	pointer
+	O
1	int
;	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
size	long
=	O
size	long
;	O
}	O
h	pointer
->	O
u2	union
.	O
vtable	pointer
->	O
used	int
[	O
addend	long
>>	O
log_file_align	char
]	O
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
flag_name	pointer
;	O
flagword	int
flag_value	int
;	O
}	O
elf_flags_to_name_table	struct
;	O
static	O
elf_flags_to_name_table	struct
elf_flags_to_names	array
[	O
]	O
=	O
{	O
{	O
"SHF_WRITE"	pointer
,	O
SHF_WRITE	O
}	O
,	O
{	O
"SHF_ALLOC"	pointer
,	O
SHF_ALLOC	O
}	O
,	O
{	O
"SHF_EXECINSTR"	pointer
,	O
SHF_EXECINSTR	O
}	O
,	O
{	O
"SHF_MERGE"	pointer
,	O
SHF_MERGE	O
}	O
,	O
{	O
"SHF_STRINGS"	pointer
,	O
SHF_STRINGS	O
}	O
,	O
{	O
"SHF_INFO_LINK"	pointer
,	O
SHF_INFO_LINK	O
}	O
,	O
{	O
"SHF_LINK_ORDER"	pointer
,	O
SHF_LINK_ORDER	O
}	O
,	O
{	O
"SHF_OS_NONCONFORMING"	pointer
,	O
SHF_OS_NONCONFORMING	O
}	O
,	O
{	O
"SHF_GROUP"	pointer
,	O
SHF_GROUP	O
}	O
,	O
{	O
"SHF_TLS"	pointer
,	O
SHF_TLS	O
}	O
,	O
{	O
"SHF_MASKOS"	pointer
,	O
SHF_MASKOS	int
}	O
,	O
{	O
"SHF_EXCLUDE"	pointer
,	O
SHF_EXCLUDE	int
}	O
,	O
}	O
;	O
bfd_boolean	int
bfd_elf_lookup_section_flags	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
flag_info	struct
*	O
flaginfo	pointer
,	O
asection	struct
*	O
section	pointer
)	O
{	O
const	O
bfd_vma	long
sh_flags	array
=	O
elf_section_flags	O
(	O
section	pointer
)	O
;	O
if	O
(	O
!	O
flaginfo	pointer
->	O
flags_initialized	int
)	O
{	O
bfd	struct
*	O
obfd	pointer
=	O
info	pointer
->	O
output_bfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
;	O
struct	O
flag_info_list	struct
*	O
tf	pointer
=	O
flaginfo	pointer
->	O
flag_list	pointer
;	O
int	O
with_hex	int
=	O
0	int
;	O
int	O
without_hex	int
=	O
0	int
;	O
for	O
(	O
tf	pointer
=	O
flaginfo	pointer
->	O
flag_list	pointer
;	O
tf	pointer
!=	O
NULL	O
;	O
tf	pointer
=	O
tf	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
i	pointer
;	O
flagword	int
(	O
*	O
lookup	pointer
)	O
(	O
char	O
*	O
)	O
;	O
lookup	pointer
=	O
bed	pointer
->	O
elf_backend_lookup_section_flags_hook	pointer
;	O
if	O
(	O
lookup	pointer
!=	O
NULL	O
)	O
{	O
flagword	int
hexval	int
=	O
(	O
*	O
lookup	pointer
)	O
(	O
(	O
char	O
*	O
)	O
tf	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
hexval	int
!=	O
0	int
)	O
{	O
if	O
(	O
tf	pointer
->	O
with	enum
==	O
with_flags	int
)	O
with_hex	int
|=	O
hexval	int
;	O
else	O
if	O
(	O
tf	pointer
->	O
with	enum
==	O
without_flags	int
)	O
without_hex	int
|=	O
hexval	int
;	O
tf	pointer
->	O
valid	int
=	O
TRUE	int
;	O
continue	O
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
elf_flags_to_names	array
)	O
;	O
++	O
i	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
tf	pointer
->	O
name	pointer
,	O
elf_flags_to_names	array
[	O
i	pointer
]	O
.	O
flag_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
tf	pointer
->	O
with	enum
==	O
with_flags	int
)	O
with_hex	int
|=	O
elf_flags_to_names	array
[	O
i	pointer
]	O
.	O
flag_value	int
;	O
else	O
if	O
(	O
tf	pointer
->	O
with	enum
==	O
without_flags	int
)	O
without_hex	int
|=	O
elf_flags_to_names	array
[	O
i	pointer
]	O
.	O
flag_value	int
;	O
tf	pointer
->	O
valid	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
tf	pointer
->	O
valid	int
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"unrecognized INPUT_SECTION_FLAG %s\n"	pointer
)	O
,	O
tf	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
flaginfo	pointer
->	O
flags_initialized	int
=	O
TRUE	int
;	O
flaginfo	pointer
->	O
only_with_flags	int
|=	O
with_hex	int
;	O
flaginfo	pointer
->	O
not_with_flags	int
|=	O
without_hex	int
;	O
}	O
if	O
(	O
(	O
flaginfo	pointer
->	O
only_with_flags	int
&	O
sh_flags	array
)	O
!=	O
flaginfo	pointer
->	O
only_with_flags	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
flaginfo	pointer
->	O
not_with_flags	int
&	O
sh_flags	array
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
struct	O
alloc_got_off_arg	struct
{	O
bfd_vma	long
gotoff	long
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
}	O
;	O
static	O
bfd_boolean	int
elf_gc_allocate_got_offsets	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
struct	O
alloc_got_off_arg	struct
*	O
gofarg	pointer
=	O
(	O
struct	O
alloc_got_off_arg	struct
*	O
)	O
arg	pointer
;	O
bfd	struct
*	O
obfd	pointer
=	O
gofarg	pointer
->	O
info	pointer
->	O
output_bfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
got	union
.	O
refcount	int
>	O
0	int
)	O
{	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
gofarg	pointer
->	O
gotoff	long
;	O
gofarg	pointer
->	O
gotoff	long
+=	O
bed	pointer
->	O
got_elt_size	pointer
(	O
obfd	pointer
,	O
gofarg	pointer
->	O
info	pointer
,	O
h	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_gc_common_finalize_got_offsets	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
i	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_vma	long
gotoff	long
;	O
struct	O
alloc_got_off_arg	struct
gofarg	pointer
;	O
BFD_ASSERT	O
(	O
abfd	pointer
==	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bed	pointer
->	O
want_got_plt	int
)	O
gotoff	long
=	O
0	int
;	O
else	O
gotoff	long
=	O
bed	pointer
->	O
got_header_size	long
;	O
for	O
(	O
i	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
i	pointer
;	O
i	pointer
=	O
i	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
bfd_signed_vma	long
*	O
local_got	union
;	O
size_t	long
j	long
,	O
locsymcount	long
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
if	O
(	O
bfd_get_flavour	function
(	O
i	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
continue	O
;	O
local_got	union
=	O
elf_local_got_refcounts	O
(	O
i	pointer
)	O
;	O
if	O
(	O
!	O
local_got	union
)	O
continue	O
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
i	pointer
)	O
->	O
symtab_hdr	struct
;	O
if	O
(	O
elf_bad_symtab	O
(	O
i	pointer
)	O
)	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
else	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
locsymcount	long
;	O
++	O
j	long
)	O
{	O
if	O
(	O
local_got	union
[	O
j	long
]	O
>	O
0	int
)	O
{	O
local_got	union
[	O
j	long
]	O
=	O
gotoff	long
;	O
gotoff	long
+=	O
bed	pointer
->	O
got_elt_size	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
NULL	O
,	O
i	pointer
,	O
j	long
)	O
;	O
}	O
else	O
local_got	union
[	O
j	long
]	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
}	O
gofarg	pointer
.	O
gotoff	long
=	O
gotoff	long
;	O
gofarg	pointer
.	O
info	pointer
=	O
info	pointer
;	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
elf_gc_allocate_got_offsets	function
,	O
&	O
gofarg	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_gc_common_final_link	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
!	O
bfd_elf_gc_common_finalize_got_offsets	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
bfd_elf_final_link	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
bfd_boolean	int
bfd_elf_reloc_symbol_deleted_p	function
(	O
bfd_vma	long
offset	long
,	O
void	O
*	O
cookie	pointer
)	O
{	O
struct	O
elf_reloc_cookie	struct
*	O
rcookie	pointer
=	O
(	O
struct	O
elf_reloc_cookie	struct
*	O
)	O
cookie	pointer
;	O
if	O
(	O
rcookie	pointer
->	O
bad_symtab	int
)	O
rcookie	pointer
->	O
rel	pointer
=	O
rcookie	pointer
->	O
rels	pointer
;	O
for	O
(	O
;	O
rcookie	pointer
->	O
rel	pointer
<	O
rcookie	pointer
->	O
relend	pointer
;	O
rcookie	pointer
->	O
rel	pointer
++	O
)	O
{	O
unsigned	O
long	O
r_symndx	long
;	O
if	O
(	O
!	O
rcookie	pointer
->	O
bad_symtab	int
)	O
if	O
(	O
rcookie	pointer
->	O
rel	pointer
->	O
r_offset	array
>	O
offset	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
rcookie	pointer
->	O
rel	pointer
->	O
r_offset	array
!=	O
offset	long
)	O
continue	O
;	O
r_symndx	long
=	O
rcookie	pointer
->	O
rel	pointer
->	O
r_info	array
>>	O
rcookie	pointer
->	O
r_sym_shift	int
;	O
if	O
(	O
r_symndx	long
==	O
STN_UNDEF	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
r_symndx	long
>=	O
rcookie	pointer
->	O
locsymcount	long
||	O
ELF_ST_BIND	O
(	O
rcookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
.	O
st_info	array
)	O
!=	O
STB_LOCAL	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
rcookie	pointer
->	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
rcookie	pointer
->	O
extsymoff	long
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
rcookie	pointer
->	O
abfd	pointer
||	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
kept_section	pointer
!=	O
NULL	O
||	O
discarded_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
)	O
)	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
asection	struct
*	O
isec	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
isym	pointer
=	O
&	O
rcookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
;	O
isec	pointer
=	O
bfd_section_from_elf_index	function
(	O
rcookie	pointer
->	O
abfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
isec	pointer
!=	O
NULL	O
&&	O
(	O
isec	pointer
->	O
kept_section	pointer
!=	O
NULL	O
||	O
discarded_section	function
(	O
isec	pointer
)	O
)	O
)	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
int	O
bfd_elf_discard_info	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_reloc_cookie	struct
cookie	pointer
;	O
asection	struct
*	O
o	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
int	O
changed	int
=	O
0	int
;	O
if	O
(	O
info	pointer
->	O
traditional_format	int
||	O
!	O
is_elf_hash_table	O
(	O
info	pointer
->	O
hash	long
)	O
)	O
return	O
0	int
;	O
o	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".stab"	pointer
)	O
;	O
if	O
(	O
o	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
o	pointer
->	O
map_head	union
.	O
s	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
map_head	union
.	O
s	pointer
)	O
{	O
if	O
(	O
i	pointer
->	O
size	long
==	O
0	int
||	O
i	pointer
->	O
reloc_count	int
==	O
0	int
||	O
i	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_STABS	int
)	O
continue	O
;	O
abfd	pointer
=	O
i	pointer
->	O
owner	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
continue	O
;	O
if	O
(	O
!	O
init_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
i	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
_bfd_discard_section_stabs	function
(	O
abfd	pointer
,	O
i	pointer
,	O
elf_section_data	O
(	O
i	pointer
)	O
->	O
sec_info	pointer
,	O
bfd_elf_reloc_symbol_deleted_p	function
,	O
&	O
cookie	pointer
)	O
)	O
changed	int
=	O
1	int
;	O
fini_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
i	pointer
)	O
;	O
}	O
}	O
o	pointer
=	O
NULL	O
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
!=	O
COMPACT_EH_HDR	int
)	O
o	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".eh_frame"	pointer
)	O
;	O
if	O
(	O
o	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
i	pointer
;	O
int	O
eh_changed	int
=	O
0	int
;	O
unsigned	O
int	O
eh_alignment	int
;	O
for	O
(	O
i	pointer
=	O
o	pointer
->	O
map_head	union
.	O
s	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
map_head	union
.	O
s	pointer
)	O
{	O
if	O
(	O
i	pointer
->	O
size	long
==	O
0	int
)	O
continue	O
;	O
abfd	pointer
=	O
i	pointer
->	O
owner	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
continue	O
;	O
if	O
(	O
!	O
init_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
i	pointer
)	O
)	O
return	O
-	O
1	int
;	O
_bfd_elf_parse_eh_frame	function
(	O
abfd	pointer
,	O
info	pointer
,	O
i	pointer
,	O
&	O
cookie	pointer
)	O
;	O
if	O
(	O
_bfd_elf_discard_section_eh_frame	function
(	O
abfd	pointer
,	O
info	pointer
,	O
i	pointer
,	O
bfd_elf_reloc_symbol_deleted_p	function
,	O
&	O
cookie	pointer
)	O
)	O
{	O
eh_changed	int
=	O
1	int
;	O
if	O
(	O
i	pointer
->	O
size	long
!=	O
i	pointer
->	O
rawsize	long
)	O
changed	int
=	O
1	int
;	O
}	O
fini_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
i	pointer
)	O
;	O
}	O
eh_alignment	int
=	O
1	int
<<	O
o	pointer
->	O
alignment_power	int
;	O
for	O
(	O
i	pointer
=	O
o	pointer
->	O
map_tail	union
.	O
s	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
map_tail	union
.	O
s	pointer
)	O
if	O
(	O
i	pointer
->	O
size	long
==	O
0	int
)	O
i	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
else	O
if	O
(	O
i	pointer
->	O
size	long
>	O
4	int
)	O
break	O
;	O
if	O
(	O
i	pointer
!=	O
NULL	O
)	O
i	pointer
=	O
i	pointer
->	O
map_tail	union
.	O
s	pointer
;	O
for	O
(	O
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
map_tail	union
.	O
s	pointer
)	O
if	O
(	O
i	pointer
->	O
size	long
==	O
4	int
)	O
BFD_FAIL	O
(	O
)	O
;	O
else	O
{	O
bfd_size_type	long
size	long
=	O
(	O
i	pointer
->	O
size	long
+	O
eh_alignment	int
-	O
1	int
)	O
&	O
-	O
eh_alignment	int
;	O
if	O
(	O
i	pointer
->	O
size	long
!=	O
size	long
)	O
{	O
i	pointer
->	O
size	long
=	O
size	long
;	O
changed	int
=	O
1	int
;	O
eh_changed	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
eh_changed	int
)	O
elf_link_hash_traverse	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_elf_adjust_eh_frame_global_symbol	function
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
abfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
asection	struct
*	O
s	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
continue	O
;	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
s	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
continue	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_discard_info	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
init_reloc_cookie	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
abfd	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_discard_info	pointer
)	O
(	O
abfd	pointer
,	O
&	O
cookie	pointer
,	O
info	pointer
)	O
)	O
changed	int
=	O
1	int
;	O
fini_reloc_cookie	function
(	O
&	O
cookie	pointer
,	O
abfd	pointer
)	O
;	O
}	O
}	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
COMPACT_EH_HDR	int
)	O
_bfd_elf_end_eh_frame_parsing	function
(	O
info	pointer
)	O
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
&&	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
_bfd_elf_discard_section_eh_frame_hdr	function
(	O
output_bfd	pointer
,	O
info	pointer
)	O
)	O
changed	int
=	O
1	int
;	O
return	O
changed	int
;	O
}	O
bfd_boolean	int
_bfd_elf_section_already_linked	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
flagword	int
flags	int
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
key	long
;	O
struct	O
bfd_section_already_linked	function
*	O
l	pointer
;	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
already_linked_list	pointer
;	O
if	O
(	O
sec	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
)	O
return	O
FALSE	int
;	O
flags	int
=	O
sec	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_LINK_ONCE	int
)	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
elf_sec_group	O
(	O
sec	pointer
)	O
!=	O
NULL	O
)	O
return	O
FALSE	int
;	O
name	pointer
=	O
sec	pointer
->	O
name	pointer
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
&&	O
elf_next_in_group	O
(	O
sec	pointer
)	O
!=	O
NULL	O
&&	O
elf_group_name	O
(	O
elf_next_in_group	O
(	O
sec	pointer
)	O
)	O
!=	O
NULL	O
)	O
key	long
=	O
elf_group_name	O
(	O
elf_next_in_group	O
(	O
sec	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
".gnu.linkonce."	pointer
)	O
&&	O
(	O
key	long
=	O
strchr	function
(	O
name	pointer
+	O
sizeof	O
(	O
".gnu.linkonce."	pointer
)	O
-	O
1	int
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
key	long
++	O
;	O
else	O
key	long
=	O
name	pointer
;	O
}	O
already_linked_list	pointer
=	O
bfd_section_already_linked_table_lookup	function
(	O
key	long
)	O
;	O
for	O
(	O
l	pointer
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
==	O
(	O
l	pointer
->	O
sec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
&&	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
l	pointer
->	O
sec	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
)	O
||	O
(	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
_bfd_handle_already_linked	function
(	O
sec	pointer
,	O
l	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
{	O
asection	struct
*	O
first	long
=	O
elf_next_in_group	O
(	O
sec	pointer
)	O
;	O
asection	struct
*	O
s	pointer
=	O
first	long
;	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
s	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
s	pointer
->	O
kept_section	pointer
=	O
l	pointer
->	O
sec	pointer
;	O
s	pointer
=	O
elf_next_in_group	O
(	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
first	long
)	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
{	O
asection	struct
*	O
first	long
=	O
elf_next_in_group	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
first	long
!=	O
NULL	O
&&	O
elf_next_in_group	O
(	O
first	long
)	O
==	O
first	long
)	O
for	O
(	O
l	pointer
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
l	pointer
->	O
sec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
==	O
0	int
&&	O
bfd_elf_match_symbols_in_sections	function
(	O
l	pointer
->	O
sec	pointer
,	O
first	long
,	O
info	pointer
)	O
)	O
{	O
first	long
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
first	long
->	O
kept_section	pointer
=	O
l	pointer
->	O
sec	pointer
;	O
sec	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
break	O
;	O
}	O
}	O
else	O
for	O
(	O
l	pointer
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
if	O
(	O
l	pointer
->	O
sec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
{	O
asection	struct
*	O
first	long
=	O
elf_next_in_group	O
(	O
l	pointer
->	O
sec	pointer
)	O
;	O
if	O
(	O
first	long
!=	O
NULL	O
&&	O
elf_next_in_group	O
(	O
first	long
)	O
==	O
first	long
&&	O
bfd_elf_match_symbols_in_sections	function
(	O
first	long
,	O
sec	pointer
,	O
info	pointer
)	O
)	O
{	O
sec	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
sec	pointer
->	O
kept_section	pointer
=	O
first	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
==	O
0	int
&&	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
".gnu.linkonce.r."	pointer
)	O
)	O
for	O
(	O
l	pointer
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
l	pointer
->	O
sec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
==	O
0	int
&&	O
CONST_STRNEQ	O
(	O
l	pointer
->	O
sec	pointer
->	O
name	pointer
,	O
".gnu.linkonce.t."	pointer
)	O
)	O
{	O
if	O
(	O
abfd	pointer
!=	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
)	O
sec	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
bfd_section_already_linked_table_insert	function
(	O
already_linked_list	pointer
,	O
sec	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: already_linked_table: %E\n"	pointer
)	O
)	O
;	O
return	O
sec	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
;	O
}	O
bfd_boolean	int
_bfd_elf_common_definition	function
(	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
return	O
sym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
;	O
}	O
unsigned	O
int	O
_bfd_elf_common_section_index	function
(	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
SHN_COMMON	O
;	O
}	O
asection	struct
*	O
_bfd_elf_common_section	function
(	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
bfd_com_section_ptr	O
;	O
}	O
bfd_vma	long
_bfd_elf_default_got_elt_size	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
ibfd	pointer
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
long	O
symndx	long
ATTRIBUTE_UNUSED	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
return	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
/	O
8	int
;	O
}	O
static	O
const	O
char	O
*	O
get_dynamic_reloc_section_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_boolean	int
is_rela	int
)	O
{	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
old_name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
const	O
char	O
*	O
prefix	pointer
=	O
is_rela	int
?	O
".rela"	pointer
:	O
".rel"	pointer
;	O
if	O
(	O
old_name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
name	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
strlen	function
(	O
prefix	pointer
)	O
+	O
strlen	function
(	O
old_name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
name	pointer
,	O
"%s%s"	pointer
,	O
prefix	pointer
,	O
old_name	pointer
)	O
;	O
return	O
name	pointer
;	O
}	O
asection	struct
*	O
_bfd_elf_get_dynamic_reloc_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_boolean	int
is_rela	int
)	O
{	O
asection	struct
*	O
reloc_sec	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sreloc	pointer
;	O
if	O
(	O
reloc_sec	pointer
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
get_dynamic_reloc_section_name	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
is_rela	int
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
reloc_sec	pointer
=	O
bfd_get_linker_section	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
reloc_sec	pointer
!=	O
NULL	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sreloc	pointer
=	O
reloc_sec	pointer
;	O
}	O
}	O
return	O
reloc_sec	pointer
;	O
}	O
asection	struct
*	O
_bfd_elf_make_dynamic_reloc_section	function
(	O
asection	struct
*	O
sec	pointer
,	O
bfd	struct
*	O
dynobj	pointer
,	O
unsigned	O
int	O
alignment	int
,	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_rela	int
)	O
{	O
asection	struct
*	O
reloc_sec	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sreloc	pointer
;	O
if	O
(	O
reloc_sec	pointer
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
get_dynamic_reloc_section_name	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
is_rela	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
reloc_sec	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
reloc_sec	pointer
==	O
NULL	O
)	O
{	O
flagword	int
flags	int
=	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_IN_MEMORY	int
|	O
SEC_LINKER_CREATED	int
)	O
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
flags	int
|=	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
;	O
reloc_sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
name	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
reloc_sec	pointer
!=	O
NULL	O
)	O
{	O
elf_section_type	O
(	O
reloc_sec	pointer
)	O
=	O
is_rela	int
?	O
SHT_RELA	int
:	O
SHT_REL	int
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
reloc_sec	pointer
,	O
alignment	int
)	O
)	O
reloc_sec	pointer
=	O
NULL	O
;	O
}	O
}	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sreloc	pointer
=	O
reloc_sec	pointer
;	O
}	O
return	O
reloc_sec	pointer
;	O
}	O
void	O
_bfd_elf_copy_link_hash_symbol_type	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
hdest	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
hsrc	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
ehdest	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hdest	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
ehsrc	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
hsrc	pointer
;	O
Elf_Internal_Sym	struct
isym	pointer
;	O
ehdest	pointer
->	O
type	enum
=	O
ehsrc	pointer
->	O
type	enum
;	O
ehdest	pointer
->	O
target_internal	int
=	O
ehsrc	pointer
->	O
target_internal	int
;	O
isym	pointer
.	O
st_other	array
=	O
ehsrc	pointer
->	O
other	int
;	O
elf_merge_st_other	function
(	O
abfd	pointer
,	O
ehdest	pointer
,	O
&	O
isym	pointer
,	O
NULL	O
,	O
TRUE	int
,	O
FALSE	int
)	O
;	O
}	O
void	O
elf_append_rela	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
s	pointer
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_byte	char
*	O
loc	pointer
=	O
s	pointer
->	O
contents	pointer
+	O
(	O
s	pointer
->	O
reloc_count	int
++	O
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
)	O
;	O
BFD_ASSERT	O
(	O
loc	pointer
+	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
<=	O
s	pointer
->	O
contents	pointer
+	O
s	pointer
->	O
size	long
)	O
;	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_out	pointer
(	O
abfd	pointer
,	O
rel	pointer
,	O
loc	pointer
)	O
;	O
}	O
void	O
elf_append_rel	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
s	pointer
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_byte	char
*	O
loc	pointer
=	O
s	pointer
->	O
contents	pointer
+	O
(	O
s	pointer
->	O
reloc_count	int
++	O
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
;	O
BFD_ASSERT	O
(	O
loc	pointer
+	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
<=	O
s	pointer
->	O
contents	pointer
+	O
s	pointer
->	O
size	long
)	O
;	O
bed	pointer
->	O
s	pointer
->	O
swap_reloc_out	pointer
(	O
abfd	pointer
,	O
rel	pointer
,	O
loc	pointer
)	O
;	O
}	O
struct	O
bfd_link_hash_entry	struct
*	O
bfd_elf_define_start_stop	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
symbol	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
symbol	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
(	O
(	O
h	pointer
->	O
ref_regular	int
||	O
h	pointer
->	O
def_dynamic	int
)	O
&&	O
!	O
h	pointer
->	O
def_regular	int
)	O
)	O
)	O
{	O
bfd_boolean	int
was_dynamic	int
=	O
h	pointer
->	O
ref_dynamic	int
||	O
h	pointer
->	O
def_dynamic	int
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
sec	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
0	int
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
def_dynamic	int
=	O
0	int
;	O
h	pointer
->	O
start_stop	int
=	O
1	int
;	O
h	pointer
->	O
u2	union
.	O
start_stop_section	pointer
=	O
sec	pointer
;	O
if	O
(	O
symbol	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_DEFAULT	int
)	O
h	pointer
->	O
other	int
=	O
(	O
h	pointer
->	O
other	int
&	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
)	O
|	O
STV_PROTECTED	int
;	O
if	O
(	O
was_dynamic	int
)	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
;	O
}	O
return	O
&	O
h	pointer
->	O
root	struct
;	O
}	O
return	O
NULL	O
;	O
}	O
