extern	O
char	O
*	O
*	O
environ	pointer
;	O
static	O
int	O
Gverbose	int
;	O
static	O
int	O
Gbe_silent	int
;	O
static	O
int	O
fdgo	function
(	O
int	O
select_ret	int
,	O
int	O
read_ret	int
,	O
char	O
*	O
location	pointer
,	O
int	O
Gbe_silent	int
)	O
{	O
if	O
(	O
select_ret	int
>	O
0	int
&&	O
read_ret	int
<=	O
0	int
)	O
{	O
if	O
(	O
read_ret	int
<	O
0	int
)	O
{	O
if	O
(	O
Gbe_silent	int
<	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: fdgo(): read error, loc=%s, errno=%d: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
location	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
select_ret	int
<	O
0	int
)	O
{	O
if	O
(	O
Gbe_silent	int
<	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: fdgo(): select error, loc=%s, errno=%d: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
location	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
select_ret	int
>	O
0	int
&&	O
read_ret	int
>	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
select_ret	int
==	O
0	int
&&	O
read_ret	int
==	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
static	O
ssize_t	long
read_line	function
(	O
int	O
fd	int
,	O
void	O
*	O
buf	pointer
,	O
size_t	long
len	int
)	O
{	O
return	O
swgp_read_line	function
(	O
fd	int
,	O
(	O
STROB	struct
*	O
)	O
buf	pointer
,	O
DO_NOT_APPEND	int
)	O
;	O
}	O
static	O
void	O
read_pipe	function
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
void	O
*	O
buf	pointer
,	O
int	O
*	O
readReturn	pointer
,	O
char	O
*	O
location	pointer
,	O
uintmax_t	long
*	O
statbytes	pointer
,	O
ssize_t	long
(	O
*	O
wf	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
,	O
ssize_t	long
(	O
*	O
rf	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
int	O
ret	int
;	O
int	O
wret	int
;	O
ret	int
=	O
(	O
*	O
rf	pointer
)	O
(	O
ifd	int
,	O
buf	pointer
,	O
SWLIB_PIPE_BUF	int
)	O
;	O
if	O
(	O
readReturn	pointer
)	O
*	O
readReturn	pointer
=	O
ret	int
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
if	O
(	O
!	O
Gbe_silent	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"read error ret = %d location=[%s]\n"	pointer
,	O
ret	int
,	O
location	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
Gverbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"GOT EOF read returned [%d] location=[%s]"	pointer
" fd=[%d]\n"	pointer
,	O
ret	int
,	O
location	pointer
,	O
ifd	int
)	O
;	O
}	O
else	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
if	O
(	O
ofd	int
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
wret	int
=	O
(	O
*	O
wf	pointer
)	O
(	O
ofd	int
,	O
buf	pointer
,	O
ret	int
)	O
)	O
!=	O
ret	int
)	O
{	O
if	O
(	O
!	O
Gbe_silent	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"write error ret=%d at location %s\n"	pointer
,	O
wret	int
,	O
location	pointer
)	O
;	O
if	O
(	O
readReturn	pointer
)	O
*	O
readReturn	pointer
=	O
wret	int
;	O
}	O
else	O
{	O
if	O
(	O
statbytes	pointer
)	O
(	O
*	O
statbytes	pointer
)	O
+=	O
wret	int
;	O
}	O
}	O
}	O
}	O
static	O
int	O
doExhaustFd_i	function
(	O
void	O
*	O
buf	pointer
,	O
int	O
fd_from	int
,	O
char	O
*	O
location	pointer
,	O
int	O
sec	int
,	O
int	O
usec	int
,	O
int	O
*	O
readReturn	pointer
,	O
ssize_t	long
(	O
*	O
f_read	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
fd_set	struct
rfds	struct
;	O
fd_set	struct
efds	struct
;	O
struct	O
timeval	struct
tv	struct
;	O
int	O
retval	int
;	O
int	O
maxfd	int
=	O
fd_from	int
;	O
FD_ZERO	O
(	O
&	O
rfds	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
efds	struct
)	O
;	O
tv	struct
.	O
tv_sec	long
=	O
sec	int
;	O
tv	struct
.	O
tv_usec	long
=	O
usec	int
;	O
FD_ZERO	O
(	O
&	O
rfds	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
efds	struct
)	O
;	O
if	O
(	O
fd_from	int
>	O
0	int
)	O
FD_SET	O
(	O
fd_from	int
,	O
&	O
rfds	struct
)	O
;	O
if	O
(	O
fd_from	int
>	O
0	int
)	O
FD_SET	O
(	O
fd_from	int
,	O
&	O
efds	struct
)	O
;	O
*	O
readReturn	pointer
=	O
0	int
;	O
retval	int
=	O
select	function
(	O
maxfd	int
+	O
1	int
,	O
&	O
rfds	struct
,	O
NULL	O
,	O
&	O
efds	struct
,	O
&	O
tv	struct
)	O
;	O
if	O
(	O
retval	int
>	O
0	int
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd_from	int
,	O
&	O
efds	struct
)	O
)	O
{	O
*	O
readReturn	pointer
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd_from	int
,	O
&	O
rfds	struct
)	O
)	O
{	O
if	O
(	O
fd_from	int
>	O
0	int
)	O
read_pipe	function
(	O
-	O
1	int
,	O
fd_from	int
,	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
readReturn	pointer
,	O
"ret2"	pointer
,	O
NULL	O
,	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
NULL	O
)	O
,	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
f_read	pointer
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
retval	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
{	O
if	O
(	O
Gverbose	int
>	O
6	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: select: (errno=EINTR): %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s:%d select retval = %d fd_from=%d"	pointer
" location=[%d] : %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
retval	int
,	O
fd_from	int
,	O
__LINE__	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
retval	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
retval	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: select error (errno=%d): %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s:%d select retval = %d fd_from=%d"	pointer
" location=[%d] : %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
retval	int
,	O
fd_from	int
,	O
__LINE__	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
retval	int
=	O
0	int
;	O
}	O
return	O
retval	int
;	O
}	O
static	O
int	O
doPumpCycle	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
char	O
*	O
location	pointer
,	O
int	O
sec	int
,	O
int	O
usec	int
,	O
int	O
*	O
readReturn	pointer
,	O
uintmax_t	long
*	O
statbytes	pointer
)	O
{	O
fd_set	struct
rfds	struct
;	O
struct	O
timeval	struct
tv	struct
;	O
int	O
retval	int
;	O
int	O
maxfd	int
=	O
ifd	int
;	O
FD_ZERO	O
(	O
&	O
rfds	struct
)	O
;	O
FD_SET	O
(	O
ifd	int
,	O
&	O
rfds	struct
)	O
;	O
tv	struct
.	O
tv_sec	long
=	O
sec	int
;	O
tv	struct
.	O
tv_usec	long
=	O
usec	int
;	O
FD_ZERO	O
(	O
&	O
rfds	struct
)	O
;	O
FD_SET	O
(	O
ifd	int
,	O
&	O
rfds	struct
)	O
;	O
*	O
readReturn	pointer
=	O
0	int
;	O
retval	int
=	O
select	function
(	O
maxfd	int
+	O
1	int
,	O
&	O
rfds	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct
)	O
;	O
if	O
(	O
retval	int
>	O
0	int
)	O
{	O
retval	int
=	O
1	int
;	O
if	O
(	O
FD_ISSET	O
(	O
ifd	int
,	O
&	O
rfds	struct
)	O
)	O
{	O
read_pipe	function
(	O
ofd	int
,	O
ifd	int
,	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
readReturn	pointer
,	O
location	pointer
,	O
statbytes	pointer
,	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_unix_safe_write	function
)	O
,	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_unix_safe_read	function
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
retval	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"select retval = %d ofd=%d ifd=%d"	pointer
" location=[%d] : %s\n"	pointer
,	O
retval	int
,	O
ofd	int
,	O
ifd	int
,	O
__LINE__	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
retval	int
=	O
0	int
;	O
}	O
return	O
retval	int
;	O
}	O
static	O
int	O
sumpPump	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
char	O
*	O
location	pointer
,	O
int	O
sec	int
,	O
int	O
usec	int
,	O
int	O
loopcount	int
,	O
uintmax_t	long
*	O
statbytes	pointer
)	O
{	O
int	O
count	int
=	O
0	int
;	O
int	O
rret	int
,	O
selret	int
,	O
retval	int
=	O
1	int
;	O
while	O
(	O
loopcount	int
==	O
0	int
||	O
count	int
<	O
loopcount	int
)	O
{	O
selret	int
=	O
doPumpCycle	function
(	O
buf	pointer
,	O
ofd	int
,	O
ifd	int
,	O
location	pointer
,	O
sec	int
,	O
usec	int
,	O
&	O
rret	int
,	O
statbytes	pointer
)	O
;	O
count	int
++	O
;	O
retval	int
=	O
fdgo	function
(	O
selret	int
,	O
rret	int
,	O
location	pointer
,	O
Gbe_silent	int
)	O
;	O
if	O
(	O
Gverbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swssh: sumpPump: fdgo(%d, %d, %s) returned %d\n"	pointer
,	O
selret	int
,	O
rret	int
,	O
location	pointer
,	O
retval	int
)	O
;	O
}	O
if	O
(	O
retval	int
<	O
0	int
)	O
{	O
if	O
(	O
Gbe_silent	int
<	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"sumpPump internal error: loc=1\n"	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
retval	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
loopcount	int
==	O
0	int
&&	O
retval	int
>	O
0	int
&&	O
rret	int
==	O
0	int
)	O
{	O
retval	int
=	O
0	int
;	O
break	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
return	O
retval	int
;	O
}	O
int	O
swgp_stdioPump	function
(	O
int	O
stdoutfd	int
,	O
int	O
outputpipefd	int
,	O
int	O
inputpipefd	int
,	O
int	O
stdinfd	int
,	O
int	O
opt_verbose	int
,	O
int	O
opt_be_silent	int
,	O
int	O
pid	int
,	O
int	O
*	O
waitret	pointer
,	O
int	O
*	O
statusp	pointer
,	O
int	O
*	O
cancel	pointer
,	O
uintmax_t	long
*	O
statbytes	pointer
)	O
{	O
int	O
ret0	int
,	O
ret1	int
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
haveclose0	int
=	O
0	int
;	O
int	O
haveclose1	int
=	O
0	int
;	O
int	O
have_checked_for_epipe	int
=	O
0	int
;	O
char	O
buf	pointer
[	O
SWLIB_PIPE_BUF	int
]	O
;	O
Gverbose	int
=	O
opt_verbose	int
;	O
Gbe_silent	int
=	O
opt_be_silent	int
;	O
if	O
(	O
stdoutfd	int
>=	O
0	int
)	O
{	O
ret1	int
=	O
sumpPump	function
(	O
buf	pointer
,	O
stdoutfd	int
,	O
outputpipefd	int
,	O
"ret1"	pointer
,	O
0	int
,	O
SWGP_USEC	int
,	O
1	int
,	O
statbytes	pointer
)	O
;	O
}	O
else	O
{	O
ret1	int
=	O
0	int
;	O
}	O
if	O
(	O
ret1	int
<	O
0	int
)	O
retval	int
--	O
;	O
ret0	int
=	O
sumpPump	function
(	O
buf	pointer
,	O
inputpipefd	int
,	O
stdinfd	int
,	O
"ret0"	pointer
,	O
0	int
,	O
SWGP_USEC	int
,	O
1	int
,	O
statbytes	pointer
)	O
;	O
while	O
(	O
(	O
ret0	int
>	O
0	int
||	O
ret1	int
>	O
0	int
)	O
&&	O
(	O
cancel	pointer
==	O
(	O
int	O
*	O
)	O
NULL	O
||	O
*	O
cancel	pointer
==	O
(	O
int	O
)	O
0	int
)	O
)	O
{	O
if	O
(	O
ret1	int
>	O
0	int
)	O
{	O
ret1	int
=	O
sumpPump	function
(	O
buf	pointer
,	O
stdoutfd	int
,	O
outputpipefd	int
,	O
"ret1"	pointer
,	O
0	int
,	O
SWGP_USEC	int
,	O
1	int
,	O
statbytes	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ret1	int
<	O
0	int
)	O
retval	int
--	O
;	O
if	O
(	O
haveclose1	int
==	O
0	int
)	O
{	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"closing (ret1) outputpipefd fd=%d\n"	pointer
,	O
outputpipefd	int
)	O
;	O
}	O
close	pointer
(	O
outputpipefd	int
)	O
;	O
haveclose1	int
=	O
1	int
;	O
}	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fd0=%d fd1=%d ret"	pointer
" (ret1)finishvalue=%d loc=d\n"	pointer
,	O
stdoutfd	int
,	O
outputpipefd	int
,	O
ret1	int
)	O
;	O
}	O
}	O
if	O
(	O
ret0	int
>	O
0	int
)	O
{	O
ret0	int
=	O
sumpPump	function
(	O
buf	pointer
,	O
inputpipefd	int
,	O
stdinfd	int
,	O
"ret0"	pointer
,	O
0	int
,	O
SWGP_USEC	int
,	O
1	int
,	O
statbytes	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ret0	int
<	O
0	int
)	O
retval	int
--	O
;	O
if	O
(	O
haveclose0	int
==	O
0	int
)	O
{	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"closing (ret0) inputpipefd fd=%d\n"	pointer
,	O
inputpipefd	int
)	O
;	O
}	O
close	pointer
(	O
inputpipefd	int
)	O
;	O
haveclose0	int
=	O
1	int
;	O
}	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fd2=%d fd3=%d ret"	pointer
" (ret0)finishvalue=%d loc=e\n"	pointer
,	O
inputpipefd	int
,	O
stdinfd	int
,	O
ret0	int
)	O
;	O
}	O
}	O
if	O
(	O
ret1	int
<=	O
0	int
&&	O
ret0	int
>	O
0	int
&&	O
have_checked_for_epipe	int
==	O
0	int
)	O
{	O
have_checked_for_epipe	int
=	O
1	int
;	O
if	O
(	O
stdinfd	int
!=	O
STDIN_FILENO	int
)	O
close	pointer
(	O
stdinfd	int
)	O
;	O
if	O
(	O
1	int
)	O
{	O
if	O
(	O
pid	int
>	O
0	int
&&	O
waitret	pointer
&&	O
statusp	pointer
)	O
{	O
if	O
(	O
opt_verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"CHECKING pid %d in swgp_stdioPump\n"	pointer
,	O
(	O
int	O
)	O
pid	int
)	O
;	O
*	O
waitret	pointer
=	O
waitpid	function
(	O
pid	int
,	O
statusp	pointer
,	O
WNOHANG	int
)	O
;	O
if	O
(	O
*	O
waitret	pointer
>	O
0	int
)	O
{	O
if	O
(	O
opt_verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Good stop.\n"	pointer
)	O
;	O
ret0	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
*	O
waitret	pointer
==	O
0	int
)	O
{	O
ret0	int
=	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: expected a child"	pointer
" status: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: may require SIGINT or"	pointer
" a EOF to terminate.\n"	pointer
)	O
;	O
ret0	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
ret0	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
ret0	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
cancel	pointer
!=	O
(	O
int	O
*	O
)	O
NULL	O
&&	O
*	O
cancel	pointer
!=	O
(	O
int	O
)	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
ret0	int
<	O
0	int
)	O
{	O
if	O
(	O
opt_be_silent	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swssh: stdioPump ERROR on ret0\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
ret1	int
<	O
0	int
)	O
{	O
if	O
(	O
Gbe_silent	int
<	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"swssh: stdioPump ERROR on ret1\n"	pointer
)	O
;	O
}	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fd0=%d fd1=%d ret1 finishvalue=%d loc=f\n"	pointer
,	O
stdoutfd	int
,	O
outputpipefd	int
,	O
ret1	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"fd2=%d fd3=%d ret0 finishvalue=%d loc=g\n"	pointer
,	O
inputpipefd	int
,	O
stdinfd	int
,	O
ret0	int
)	O
;	O
}	O
if	O
(	O
haveclose0	int
==	O
0	int
)	O
{	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"closing2 (ret0) inputpipefd fd=%d\n"	pointer
,	O
inputpipefd	int
)	O
;	O
}	O
close	pointer
(	O
inputpipefd	int
)	O
;	O
haveclose0	int
=	O
1	int
;	O
}	O
if	O
(	O
haveclose1	int
==	O
0	int
)	O
{	O
if	O
(	O
opt_verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"closing2 (ret1) outputpipefd fd=%d\n"	pointer
,	O
outputpipefd	int
)	O
;	O
}	O
close	pointer
(	O
outputpipefd	int
)	O
;	O
haveclose1	int
=	O
1	int
;	O
}	O
if	O
(	O
stdoutfd	int
!=	O
STDOUT_FILENO	int
&&	O
stdoutfd	int
>=	O
0	int
)	O
close	pointer
(	O
stdoutfd	int
)	O
;	O
if	O
(	O
retval	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"got error darnit in stdioPump\n"	pointer
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
Sigfunc	function
*	O
swgp_signal	function
(	O
int	O
signo	int
,	O
Sigfunc	function
*	O
func	pointer
)	O
{	O
struct	O
sigaction	struct
act	struct
,	O
oact	struct
;	O
act	struct
.	O
sa_handler	pointer
=	O
func	pointer
;	O
sigemptyset	function
(	O
&	O
act	struct
.	O
sa_mask	struct
)	O
;	O
act	struct
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
signo	int
==	O
SIGALRM	int
)	O
{	O
act	struct
.	O
sa_flags	int
|=	O
SA_INTERRUPT	int
;	O
}	O
else	O
{	O
act	struct
.	O
sa_flags	int
|=	O
SA_RESTART	int
;	O
}	O
if	O
(	O
sigaction	struct
(	O
signo	int
,	O
&	O
act	struct
,	O
&	O
oact	struct
)	O
<	O
0	int
)	O
return	O
(	O
SIG_ERR	O
)	O
;	O
return	O
(	O
oact	struct
.	O
sa_handler	pointer
)	O
;	O
}	O
int	O
swgp_signal_block	function
(	O
int	O
signo	int
,	O
sigset_t	struct
*	O
oset	pointer
)	O
{	O
int	O
ret	int
;	O
sigset_t	struct
newmask	struct
;	O
sigemptyset	function
(	O
&	O
newmask	struct
)	O
;	O
sigaddset	function
(	O
&	O
newmask	struct
,	O
signo	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
newmask	struct
,	O
oset	pointer
)	O
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"swgp_signal_block error, signal=%d: %s\n"	pointer
,	O
signo	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swgp_signal_unblock	function
(	O
int	O
signo	int
,	O
sigset_t	struct
*	O
oset	pointer
)	O
{	O
int	O
ret	int
;	O
sigset_t	struct
newmask	struct
;	O
sigemptyset	function
(	O
&	O
newmask	struct
)	O
;	O
sigaddset	function
(	O
&	O
newmask	struct
,	O
signo	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
sigprocmask	function
(	O
SIG_UNBLOCK	int
,	O
&	O
newmask	struct
,	O
oset	pointer
)	O
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"swgp_signal_block error, signal=%d: %s\n"	pointer
,	O
signo	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swgp_sig_handler_ignore	function
(	O
int	O
signo	int
)	O
{	O
return	O
;	O
}	O
void	O
swgp_sig_handler_exit	function
(	O
int	O
signo	int
)	O
{	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
swgp_write_as_echo_line	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
len	int
;	O
STROB	struct
*	O
btmp	pointer
;	O
btmp	pointer
=	O
strob_open	function
(	O
90	int
)	O
;	O
strob_sprintf	function
(	O
btmp	pointer
,	O
0	int
,	O
"%s\n"	pointer
,	O
buf	pointer
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strob_strlen	function
(	O
btmp	pointer
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
uxfio_write	function
,	O
fd	int
,	O
strob_str	function
(	O
btmp	pointer
)	O
,	O
len	int
)	O
;	O
strob_close	function
(	O
btmp	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
len	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
swgp_read_line	function
(	O
int	O
fd	int
,	O
STROB	struct
*	O
buf	pointer
,	O
int	O
do_append	int
)	O
{	O
int	O
n	long
;	O
char	O
c	int
[	O
2	int
]	O
;	O
int	O
count	int
=	O
0	int
;	O
c	int
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
do_append	int
==	O
0	int
)	O
{	O
strob_strcpy	function
(	O
(	O
STROB	struct
*	O
)	O
buf	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
n	long
=	O
uxfio_unix_safe_read	function
(	O
fd	int
,	O
(	O
void	O
*	O
)	O
&	O
c	int
,	O
1	int
)	O
;	O
while	O
(	O
n	long
==	O
1	int
&&	O
c	int
[	O
0	int
]	O
!=	O
'\n'	O
)	O
{	O
strob_strcat	function
(	O
(	O
STROB	struct
*	O
)	O
buf	pointer
,	O
c	int
)	O
;	O
count	int
++	O
;	O
n	long
=	O
uxfio_unix_safe_read	function
(	O
fd	int
,	O
(	O
void	O
*	O
)	O
&	O
c	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
==	O
1	int
&&	O
c	int
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
count	int
++	O
;	O
strob_strcat	function
(	O
(	O
STROB	struct
*	O
)	O
buf	pointer
,	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
count	int
;	O
}	O
int	O
swgp_find_lowest_fd	function
(	O
int	O
start	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
dup	function
(	O
0	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
close	pointer
(	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swgp_check_fds	function
(	O
void	O
)	O
{	O
int	O
open_max	int
;	O
int	O
tmpfd	int
;	O
int	O
max_fd	int
;	O
open_max	int
=	O
swgp_close_all_fd	function
(	O
-	O
1	int
)	O
;	O
tmpfd	int
=	O
dup	function
(	O
STDIN_FILENO	int
)	O
;	O
if	O
(	O
tmpfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: available file descriptors look suspicious, exiting now\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
max_fd	int
=	O
dup2	function
(	O
tmpfd	int
,	O
open_max	int
-	O
1	int
)	O
;	O
close	pointer
(	O
tmpfd	int
)	O
;	O
if	O
(	O
max_fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: available file descriptors look suspicious, exiting now\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
close	pointer
(	O
max_fd	int
)	O
;	O
if	O
(	O
max_fd	int
-	O
3	int
<	O
SWBIS_MIN_FD_AVAIL	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: max fd available is %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
max_fd	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: available file descriptors look suspicious, exiting now\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
;	O
}	O
int	O
swgp_close_all_fd	function
(	O
int	O
start	int
)	O
{	O
int	O
i	int
;	O
int	O
open_max	int
;	O
open_max	int
=	O
sysconf	function
(	O
_SC_OPEN_MAX	int
)	O
;	O
if	O
(	O
open_max	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: sysconf: open_max not determined.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
open_max	int
=	O
SWBIS_SC_OPEN_MAX	int
;	O
}	O
else	O
{	O
;	O
}	O
if	O
(	O
open_max	int
<	O
16	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the maximum number of open file descriptors\n"	pointer
"%s: was determined to be %d.\n"	pointer
"%s: swbis requires more than this for its checks\n"	pointer
"%s: against file descriptor leaks, and its normal\n"	pointer
"%s: operations.\n"	pointer
"%s"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swlib_utilname_get	function
(	O
)	O
,	O
open_max	int
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swlib_utilname_get	function
(	O
)	O
,	O
""	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
start	int
>=	O
(	O
open_max	int
-	O
3	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Oops, something is using all the file descriptors\n"	pointer
"%s: swbis chooses not to continue\n"	pointer
"%s"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swlib_utilname_get	function
(	O
)	O
,	O
""	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
start	int
>=	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
<	O
open_max	int
;	O
i	int
++	O
)	O
close	pointer
(	O
i	int
)	O
;	O
}	O
else	O
{	O
}	O
return	O
open_max	int
;	O
}	O
int	O
swgpReadFdNonblock	function
(	O
char	O
*	O
pipe_buf	pointer
,	O
int	O
fd_from	int
,	O
int	O
*	O
len	int
)	O
{	O
int	O
ret	int
;	O
*	O
len	int
=	O
0	int
;	O
*	O
pipe_buf	pointer
=	O
'\0'	O
;	O
ret	int
=	O
doExhaustFd_i	function
(	O
(	O
void	O
*	O
)	O
pipe_buf	pointer
,	O
fd_from	int
,	O
"ret2"	pointer
,	O
0	int
,	O
1000	int
,	O
len	int
,	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_unix_safe_read	function
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swgpReadLine	function
(	O
STROB	struct
*	O
buf	pointer
,	O
int	O
fd_from	int
,	O
int	O
*	O
readReturn	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
doExhaustFd_i	function
(	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
fd_from	int
,	O
"ReadLine"	pointer
,	O
0	int
,	O
40000	int
,	O
readReturn	pointer
,	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
read_line	function
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
