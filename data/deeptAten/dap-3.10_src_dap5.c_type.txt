extern	O
dataobs	struct
dap_obs	array
[	O
]	O
;	O
extern	O
FILE	struct
*	O
dap_lst	pointer
;	O
extern	O
FILE	struct
*	O
dap_err	pointer
;	O
extern	O
int	O
dap_ono	int
;	O
extern	O
char	O
*	O
dap_dapname	pointer
;	O
static	O
int	O
matchmark	function
(	O
int	O
*	O
markv	array
,	O
int	O
*	O
xmarkv	pointer
,	O
int	O
nmark	int
,	O
double	O
level	double
)	O
{	O
int	O
i	int
;	O
int	O
diff	int
;	O
if	O
(	O
xmarkv	pointer
[	O
0	int
]	O
<	O
0	int
)	O
return	O
!	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
for	O
(	O
diff	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
!	O
diff	int
&&	O
i	int
<	O
nmark	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
i	int
]	O
]	O
>	O
0	int
)	O
diff	int
=	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
markv	array
[	O
i	int
]	O
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_str	pointer
[	O
xmarkv	pointer
[	O
i	int
]	O
]	O
)	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
i	int
]	O
]	O
==	O
INT	int
)	O
diff	int
=	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
markv	array
[	O
i	int
]	O
]	O
!=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_int	pointer
[	O
xmarkv	pointer
[	O
i	int
]	O
]	O
)	O
;	O
else	O
diff	int
=	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
markv	array
[	O
i	int
]	O
]	O
!=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_dbl	pointer
[	O
xmarkv	pointer
[	O
i	int
]	O
]	O
)	O
;	O
}	O
return	O
!	O
diff	int
;	O
}	O
void	O
linreg1	function
(	O
double	O
*	O
*	O
xymat	pointer
,	O
int	O
*	O
varv	array
,	O
int	O
nx0	int
,	O
int	O
nx	int
,	O
int	O
ny	int
,	O
int	O
nobs	int
,	O
int	O
*	O
xvarv	pointer
,	O
int	O
*	O
markv	array
,	O
int	O
*	O
xmarkv	pointer
,	O
int	O
nmark	int
,	O
double	O
level	double
,	O
int	O
respn	int
,	O
int	O
param1n	int
,	O
int	O
param2n	int
,	O
int	O
covn	int
,	O
int	O
partv	array
[	O
]	O
)	O
{	O
double	O
*	O
invmem	pointer
;	O
double	O
*	O
*	O
inv	pointer
;	O
int	O
r	double
,	O
c	int
;	O
int	O
rr	int
,	O
cc	int
;	O
double	O
pivot	double
;	O
double	O
tmp	double
,	O
tmp2	double
;	O
int	O
typen	int
;	O
double	O
dnobs	double
;	O
double	O
*	O
rss0	pointer
,	O
*	O
rss1	pointer
,	O
*	O
rss	pointer
;	O
double	O
*	O
f	pointer
,	O
*	O
fch	pointer
;	O
int	O
df	int
;	O
double	O
ddf	double
;	O
double	O
xi	double
,	O
xj	double
;	O
static	O
double	O
tpt	double
;	O
int	O
yn	function
;	O
int	O
i	int
,	O
j	int
;	O
double	O
*	O
pred	pointer
;	O
double	O
*	O
sepred	pointer
;	O
int	O
v	int
;	O
dap_swap	function
(	O
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(linreg1) Missing _type_ variable.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
invmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nx	int
*	O
nx	int
,	O
""	pointer
)	O
;	O
inv	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nx	int
,	O
""	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nx	int
;	O
r	double
++	O
)	O
inv	pointer
[	O
r	double
]	O
=	O
invmem	pointer
+	O
r	double
*	O
nx	int
;	O
rss0	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
rss1	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
rss	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
f	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
fch	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
pred	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
sepred	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
ny	int
,	O
""	pointer
)	O
;	O
dnobs	double
=	O
(	O
double	O
)	O
nobs	int
;	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
+	O
ny	int
;	O
c	int
++	O
)	O
xymat	pointer
[	O
0	int
]	O
[	O
c	int
]	O
/=	O
dnobs	double
;	O
for	O
(	O
r	double
=	O
1	int
;	O
r	double
<	O
nx	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
r	double
==	O
c	int
)	O
inv	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
1.0	int
;	O
else	O
inv	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
==	O
1	int
)	O
{	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
ny	int
;	O
cc	int
++	O
)	O
rss0	pointer
[	O
cc	int
]	O
=	O
xymat	pointer
[	O
nx	int
+	O
cc	int
]	O
[	O
nx	int
+	O
cc	int
]	O
;	O
}	O
if	O
(	O
c	int
==	O
nx0	int
)	O
{	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
ny	int
;	O
cc	int
++	O
)	O
rss1	pointer
[	O
cc	int
]	O
=	O
xymat	pointer
[	O
nx	int
+	O
cc	int
]	O
[	O
nx	int
+	O
cc	int
]	O
;	O
}	O
pivot	double
=	O
xymat	pointer
[	O
c	int
]	O
[	O
c	int
]	O
;	O
if	O
(	O
pivot	double
!=	O
0.0	int
)	O
{	O
for	O
(	O
rr	int
=	O
c	int
+	O
1	int
;	O
rr	int
<	O
nx	int
+	O
ny	int
;	O
rr	int
++	O
)	O
{	O
tmp	double
=	O
xymat	pointer
[	O
rr	int
]	O
[	O
c	int
]	O
/	O
pivot	double
;	O
xymat	pointer
[	O
rr	int
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nx	int
+	O
ny	int
;	O
cc	int
++	O
)	O
{	O
if	O
(	O
rr	int
<	O
nx	int
||	O
cc	int
<	O
nx	int
||	O
rr	int
==	O
cc	int
)	O
{	O
xymat	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
-=	O
tmp	double
*	O
xymat	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
if	O
(	O
fabs	function
(	O
xymat	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
)	O
<	O
dap_tol	double
*	O
pivot	double
)	O
xymat	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
=	O
0.0	int
;	O
}	O
}	O
if	O
(	O
rr	int
<	O
nx	int
)	O
{	O
for	O
(	O
cc	int
=	O
1	int
;	O
cc	int
<	O
nx	int
;	O
cc	int
++	O
)	O
{	O
inv	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
-=	O
tmp	double
*	O
inv	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
if	O
(	O
fabs	function
(	O
inv	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
)	O
<	O
dap_tol	double
*	O
pivot	double
)	O
inv	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
=	O
0.0	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(linreg1) X'X matrix is singular.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
nx	int
-	O
1	int
;	O
c	int
>	O
0	int
;	O
--	O
c	int
)	O
{	O
for	O
(	O
r	double
=	O
c	int
-	O
1	int
;	O
r	double
>	O
0	int
;	O
--	O
r	double
)	O
{	O
tmp	double
=	O
xymat	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
xymat	pointer
[	O
c	int
]	O
[	O
c	int
]	O
;	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nx	int
+	O
ny	int
;	O
cc	int
++	O
)	O
xymat	pointer
[	O
r	double
]	O
[	O
cc	int
]	O
-=	O
tmp	double
*	O
xymat	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nx	int
;	O
cc	int
++	O
)	O
inv	pointer
[	O
r	double
]	O
[	O
cc	int
]	O
-=	O
tmp	double
*	O
inv	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
}	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nx	int
+	O
ny	int
;	O
cc	int
++	O
)	O
xymat	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
/=	O
xymat	pointer
[	O
c	int
]	O
[	O
c	int
]	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nx	int
;	O
cc	int
++	O
)	O
inv	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
/=	O
xymat	pointer
[	O
c	int
]	O
[	O
c	int
]	O
;	O
}	O
df	int
=	O
nobs	int
-	O
nx	int
;	O
ddf	double
=	O
(	O
double	O
)	O
df	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ny	int
;	O
c	int
++	O
)	O
{	O
rss	pointer
[	O
c	int
]	O
=	O
xymat	pointer
[	O
nx	int
+	O
c	int
]	O
[	O
nx	int
+	O
c	int
]	O
;	O
f	pointer
[	O
c	int
]	O
=	O
(	O
rss0	pointer
[	O
c	int
]	O
-	O
rss	pointer
[	O
c	int
]	O
)	O
/	O
rss	pointer
[	O
c	int
]	O
*	O
ddf	double
/	O
(	O
(	O
double	O
)	O
nx	int
-	O
1	int
)	O
;	O
fch	pointer
[	O
c	int
]	O
=	O
(	O
rss1	pointer
[	O
c	int
]	O
-	O
rss	pointer
[	O
c	int
]	O
)	O
/	O
rss	pointer
[	O
c	int
]	O
*	O
ddf	double
/	O
(	O
(	O
double	O
)	O
nx	int
-	O
nx0	int
)	O
;	O
}	O
for	O
(	O
r	double
=	O
1	int
;	O
r	double
<	O
nx	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
xymat	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
inv	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
for	O
(	O
r	double
=	O
1	int
;	O
r	double
<	O
nx	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
xymat	pointer
[	O
r	double
]	O
[	O
0	int
]	O
-=	O
xymat	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
xymat	pointer
[	O
0	int
]	O
[	O
c	int
]	O
;	O
xymat	pointer
[	O
0	int
]	O
[	O
0	int
]	O
=	O
1.0	int
/	O
dnobs	double
;	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
xymat	pointer
[	O
0	int
]	O
[	O
0	int
]	O
-=	O
xymat	pointer
[	O
0	int
]	O
[	O
c	int
]	O
*	O
xymat	pointer
[	O
c	int
]	O
[	O
0	int
]	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ny	int
;	O
c	int
++	O
)	O
for	O
(	O
cc	int
=	O
1	int
;	O
cc	int
<	O
nx	int
;	O
cc	int
++	O
)	O
xymat	pointer
[	O
0	int
]	O
[	O
nx	int
+	O
c	int
]	O
-=	O
xymat	pointer
[	O
0	int
]	O
[	O
cc	int
]	O
*	O
xymat	pointer
[	O
cc	int
]	O
[	O
nx	int
+	O
c	int
]	O
;	O
for	O
(	O
c	int
=	O
1	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
xymat	pointer
[	O
0	int
]	O
[	O
c	int
]	O
=	O
xymat	pointer
[	O
c	int
]	O
[	O
0	int
]	O
;	O
dap_ono	int
=	O
2	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nmark	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
;	O
else	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Reduced | full model regressors:"	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nx0	int
;	O
r	double
++	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
r	double
]	O
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
" |"	pointer
)	O
;	O
while	O
(	O
r	double
<	O
nx	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
r	double
++	O
]	O
]	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of observations = %d\n"	pointer
,	O
nobs	int
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ny	int
;	O
c	int
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nResponse: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nx	int
+	O
c	int
]	O
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"   F0(%d, %d) = %.6g, Prob[F > F0] = %.5f\n   R-sq = %.6g, Adj R-sq = %.6g\n"	pointer
,	O
nx	int
-	O
1	int
,	O
nobs	int
-	O
nx	int
,	O
f	pointer
[	O
c	int
]	O
,	O
0.00001	int
*	O
ceil	function
(	O
100000.0	int
*	O
probf	function
(	O
f	pointer
[	O
c	int
]	O
,	O
nx	int
-	O
1	int
,	O
nobs	int
-	O
nx	int
)	O
)	O
,	O
1.0	int
-	O
rss	pointer
[	O
c	int
]	O
/	O
rss0	pointer
[	O
c	int
]	O
,	O
1.0	int
-	O
rss	pointer
[	O
c	int
]	O
*	O
(	O
(	O
double	O
)	O
(	O
nobs	int
-	O
1	int
)	O
)	O
/	O
(	O
rss0	pointer
[	O
c	int
]	O
*	O
ddf	double
)	O
)	O
;	O
if	O
(	O
nx0	int
>	O
1	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"   F-change(%d, %d) = %.6g, Prob[F > F-change] = %.5f\n"	pointer
,	O
nx	int
-	O
nx0	int
,	O
nobs	int
-	O
nx	int
,	O
fch	pointer
[	O
c	int
]	O
,	O
0.00001	int
*	O
ceil	function
(	O
100000.0	int
*	O
probf	function
(	O
fch	pointer
[	O
c	int
]	O
,	O
nx	int
-	O
nx0	int
,	O
nobs	int
-	O
nx	int
)	O
)	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\n   Parameter           Estimate    Std Error   T0[%6d]  Prob[|T|>|T0|]\n"	pointer
,	O
nobs	int
-	O
nx	int
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nx	int
;	O
r	double
++	O
)	O
{	O
tmp	double
=	O
sqrt	function
(	O
rss	pointer
[	O
c	int
]	O
/	O
ddf	double
*	O
xymat	pointer
[	O
r	double
]	O
[	O
r	double
]	O
)	O
;	O
tmp2	double
=	O
xymat	pointer
[	O
r	double
]	O
[	O
nx	int
+	O
c	int
]	O
/	O
tmp	double
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"   %-15s %12.6g %12.6g %12.6g  %14.5f\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
r	double
]	O
]	O
,	O
xymat	pointer
[	O
r	double
]	O
[	O
nx	int
+	O
c	int
]	O
,	O
tmp	double
,	O
tmp2	double
,	O
0.00001	int
*	O
ceil	function
(	O
200000.0	int
*	O
probt	function
(	O
fabs	function
(	O
tmp2	double
)	O
,	O
nobs	int
-	O
nx	int
)	O
)	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"ESTIMATE"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
respn	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nx	int
+	O
c	int
]	O
]	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
r	double
]	O
]	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
,	O
""	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
=	O
xymat	pointer
[	O
r	double
]	O
[	O
nx	int
+	O
c	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"COVAR"	pointer
)	O
;	O
for	O
(	O
yn	function
=	O
0	int
;	O
yn	function
<	O
ny	int
;	O
yn	function
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
respn	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nx	int
+	O
yn	function
]	O
]	O
)	O
;	O
tmp	double
=	O
rss	pointer
[	O
yn	function
]	O
/	O
ddf	double
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nx	int
;	O
r	double
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
r	double
]	O
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nx	int
;	O
c	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
c	int
]	O
]	O
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
=	O
tmp	double
*	O
xymat	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
}	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
level	double
<	O
1.0	int
)	O
tpt	double
=	O
tpoint	function
(	O
0.5	int
*	O
(	O
1.0	int
-	O
level	double
)	O
,	O
nobs	int
-	O
nx	int
)	O
;	O
else	O
tpt	double
=	O
0.0	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
=	O
1.0	int
;	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
<	O
0	int
)	O
{	O
dap_rewind	function
(	O
)	O
;	O
step	function
(	O
)	O
;	O
}	O
while	O
(	O
matchmark	function
(	O
markv	array
,	O
xmarkv	pointer
,	O
nmark	int
,	O
level	double
)	O
)	O
{	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_dbl	pointer
[	O
xvarv	pointer
[	O
i	int
-	O
1	int
]	O
]	O
;	O
}	O
else	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"OBS"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
for	O
(	O
yn	function
=	O
0	int
;	O
yn	function
<	O
ny	int
;	O
yn	function
++	O
)	O
{	O
for	O
(	O
pred	pointer
[	O
yn	function
]	O
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
pred	pointer
[	O
yn	function
]	O
+=	O
xymat	pointer
[	O
i	int
]	O
[	O
nx	int
+	O
yn	function
]	O
*	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
;	O
for	O
(	O
sepred	pointer
[	O
yn	function
]	O
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
xi	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nx	int
;	O
j	int
++	O
)	O
{	O
xj	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
j	int
]	O
]	O
;	O
sepred	pointer
[	O
yn	function
]	O
+=	O
xi	double
*	O
rss	pointer
[	O
yn	function
]	O
/	O
ddf	double
*	O
xymat	pointer
[	O
i	int
]	O
[	O
j	int
]	O
*	O
xj	double
;	O
}	O
}	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"PRED"	pointer
)	O
;	O
for	O
(	O
yn	function
=	O
0	int
;	O
yn	function
<	O
ny	int
;	O
yn	function
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
+	O
yn	function
]	O
]	O
=	O
pred	pointer
[	O
yn	function
]	O
;	O
output	function
(	O
)	O
;	O
if	O
(	O
tpt	double
!=	O
0.0	int
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"LOWER"	pointer
)	O
;	O
for	O
(	O
yn	function
=	O
0	int
;	O
yn	function
<	O
ny	int
;	O
yn	function
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
+	O
yn	function
]	O
]	O
=	O
pred	pointer
[	O
yn	function
]	O
-	O
tpt	double
*	O
sqrt	function
(	O
sepred	pointer
[	O
yn	function
]	O
)	O
;	O
output	function
(	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"UPPER"	pointer
)	O
;	O
for	O
(	O
yn	function
=	O
0	int
;	O
yn	function
<	O
ny	int
;	O
yn	function
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
+	O
yn	function
]	O
]	O
=	O
pred	pointer
[	O
yn	function
]	O
+	O
tpt	double
*	O
sqrt	function
(	O
sepred	pointer
[	O
yn	function
]	O
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
dap_ono	int
=	O
1	int
;	O
dap_mark	function
(	O
)	O
;	O
if	O
(	O
!	O
step	function
(	O
)	O
)	O
break	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
dap_swap	function
(	O
)	O
;	O
dap_free	function
(	O
invmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
inv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
rss0	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
rss1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
rss	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
f	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
fch	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
pred	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sepred	pointer
,	O
""	pointer
)	O
;	O
}	O
void	O
linreg	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
ylist	array
,	O
char	O
*	O
x0list	array
,	O
char	O
*	O
x1list	array
,	O
char	O
*	O
marks	array
,	O
char	O
*	O
xname	array
,	O
double	O
level	double
)	O
{	O
char	O
*	O
regname	pointer
;	O
int	O
*	O
varv	array
;	O
int	O
*	O
xvarv	pointer
;	O
int	O
ny	int
;	O
int	O
nx0	int
,	O
nx1	int
;	O
int	O
nx	int
;	O
int	O
nvar	int
;	O
int	O
nxx	int
;	O
int	O
*	O
markv	array
;	O
int	O
*	O
xmarkv	pointer
;	O
int	O
nmark	int
;	O
int	O
v	int
,	O
w	int
;	O
double	O
tmp	double
;	O
int	O
nobs	int
;	O
double	O
dnobs	double
;	O
double	O
*	O
xymem	pointer
;	O
double	O
*	O
*	O
xymat	pointer
;	O
int	O
more	int
;	O
char	O
*	O
covset	pointer
;	O
int	O
param1n	int
,	O
param2n	int
,	O
respn	int
,	O
covn	int
;	O
int	O
paramlen1	int
,	O
paramlen	int
;	O
char	O
paramstr	array
[	O
14	int
]	O
;	O
char	O
*	O
partstr	pointer
;	O
int	O
*	O
partv	array
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(linreg) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
xvarv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
xmarkv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
partv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
regname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
regname	pointer
,	O
fname	array
,	O
".reg"	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
dap_vd	function
(	O
"_intercept_ -1"	pointer
,	O
0	int
)	O
;	O
nx0	int
=	O
dap_list	function
(	O
"_intercept_"	pointer
,	O
varv	array
,	O
dap_maxvar	int
)	O
;	O
nx0	int
+=	O
dap_list	function
(	O
x0list	array
,	O
varv	array
+	O
1	int
,	O
dap_maxvar	int
)	O
;	O
nx1	int
=	O
dap_list	function
(	O
x1list	array
,	O
varv	array
+	O
nx0	int
,	O
dap_maxvar	int
)	O
;	O
nx	int
=	O
nx0	int
+	O
nx1	int
;	O
ny	int
=	O
dap_list	function
(	O
ylist	array
,	O
varv	array
+	O
nx	int
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
nx	int
+	O
ny	int
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
covset	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
covset	pointer
,	O
fname	array
)	O
;	O
strcat	function
(	O
covset	pointer
,	O
".cov"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
1	int
,	O
paramlen	int
=	O
strlen	function
(	O
"_intercept_"	pointer
)	O
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
paramlen1	int
=	O
strlen	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
paramlen1	int
>	O
paramlen	int
)	O
paramlen	int
=	O
paramlen1	int
;	O
}	O
dap_ono	int
=	O
2	int
;	O
dap_clearobs	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_response_ %d"	pointer
,	O
paramlen	int
)	O
;	O
respn	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_param1_ %d"	pointer
,	O
paramlen	int
)	O
;	O
param1n	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_param2_ %d"	pointer
,	O
paramlen	int
)	O
;	O
param2n	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
covn	int
=	O
dap_vd	function
(	O
"_cov_ -1"	pointer
,	O
0	int
)	O
;	O
partstr	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
marks	array
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nmark	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
partstr	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
;	O
sprintf	function
(	O
partstr	pointer
+	O
strlen	function
(	O
partstr	pointer
)	O
,	O
" %d"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
;	O
partv	array
[	O
v	int
]	O
=	O
dap_vd	function
(	O
partstr	pointer
,	O
1	int
)	O
;	O
}	O
outset	function
(	O
covset	pointer
,	O
""	pointer
)	O
;	O
dap_ono	int
=	O
0	int
;	O
xymem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
nvar	int
,	O
""	pointer
)	O
;	O
xymat	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
xymat	pointer
[	O
v	int
]	O
=	O
xymem	pointer
+	O
v	int
*	O
nvar	int
;	O
dap_ono	int
=	O
1	int
;	O
if	O
(	O
xname	array
&&	O
xname	array
[	O
0	int
]	O
)	O
{	O
inset	function
(	O
xname	array
)	O
;	O
nxx	int
=	O
dap_list	function
(	O
x0list	array
,	O
xvarv	pointer
,	O
dap_maxvar	int
)	O
;	O
nxx	int
+=	O
dap_list	function
(	O
x1list	array
,	O
xvarv	pointer
+	O
nxx	int
,	O
dap_maxvar	int
)	O
;	O
if	O
(	O
nxx	int
!=	O
nx	int
-	O
1	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(linreg) %s and %s have different numbers (%d and %d) of x-variables.\n"	pointer
,	O
fname	array
,	O
xname	array
,	O
nx	int
-	O
1	int
,	O
nxx	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nmark	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nmark	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
(	O
xmarkv	pointer
[	O
v	int
]	O
=	O
dap_varnum	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(linreg) Mark variable %s in %s not in %s.\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
,	O
fname	array
,	O
xname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
step	function
(	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(linreg) No data in %s.\n"	pointer
,	O
xname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
xvarv	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
xmarkv	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
}	O
dap_ono	int
=	O
0	int
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(linreg) Variable %s not double.\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
xymat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
=	O
0.0	int
;	O
}	O
outset	function
(	O
regname	pointer
,	O
""	pointer
)	O
;	O
for	O
(	O
nobs	int
=	O
0	int
,	O
dap_mark	function
(	O
)	O
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
dap_swap	function
(	O
)	O
;	O
linreg1	function
(	O
xymat	pointer
,	O
varv	array
,	O
nx0	int
,	O
nx	int
,	O
ny	int
,	O
nobs	int
,	O
xvarv	pointer
,	O
markv	array
,	O
xmarkv	pointer
,	O
nmark	int
,	O
level	double
,	O
respn	int
,	O
param1n	int
,	O
param2n	int
,	O
covn	int
,	O
partv	array
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
xymat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
=	O
0.0	int
;	O
}	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
nobs	int
)	O
{	O
dnobs	double
=	O
(	O
double	O
)	O
nobs	int
;	O
for	O
(	O
v	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
tmp	double
=	O
xymat	pointer
[	O
0	int
]	O
[	O
v	int
]	O
-	O
dnobs	double
*	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
for	O
(	O
w	int
=	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
if	O
(	O
v	int
<	O
nx	int
||	O
w	int
<	O
nx	int
||	O
v	int
==	O
w	int
)	O
xymat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
+=	O
tmp	double
*	O
(	O
xymat	pointer
[	O
0	int
]	O
[	O
w	int
]	O
-	O
dnobs	double
*	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
)	O
/	O
(	O
dnobs	double
*	O
(	O
dnobs	double
+	O
1.0	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
w	int
=	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
xymat	pointer
[	O
0	int
]	O
[	O
w	int
]	O
+=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
;	O
}	O
dap_free	function
(	O
regname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xvarv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xmarkv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xymem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xymat	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
covset	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partstr	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partv	array
,	O
""	pointer
)	O
;	O
}	O
void	O
dap_parsey	function
(	O
char	O
*	O
yspec	array
,	O
int	O
*	O
varv	array
)	O
{	O
int	O
l	int
;	O
int	O
i	int
;	O
char	O
*	O
vname	array
;	O
int	O
vn	int
;	O
int	O
ntrials	int
;	O
vname	array
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
"dap_namelen"	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
yspec	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
yspec	array
[	O
l	int
+	O
i	int
]	O
&&	O
yspec	array
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
&&	O
yspec	array
[	O
l	int
+	O
i	int
]	O
!=	O
'/'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array
[	O
i	int
]	O
=	O
yspec	array
[	O
l	int
+	O
i	int
]	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Variable name too long: %s\n"	pointer
,	O
yspec	array
+	O
l	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
l	int
+=	O
i	int
;	O
if	O
(	O
(	O
vn	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Unknown variable: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
vn	int
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Events variable not double: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
varv	array
[	O
0	int
]	O
=	O
vn	int
;	O
while	O
(	O
yspec	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
if	O
(	O
yspec	array
[	O
l	int
]	O
==	O
'/'	O
)	O
{	O
for	O
(	O
l	int
++	O
;	O
yspec	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
yspec	array
[	O
l	int
+	O
i	int
]	O
&&	O
yspec	array
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array
[	O
i	int
]	O
=	O
yspec	array
[	O
l	int
+	O
i	int
]	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Variable name too long: %s\n"	pointer
,	O
yspec	array
+	O
l	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ntrials	int
=	O
0	int
;	O
'0'	O
<=	O
vname	array
[	O
i	int
]	O
&&	O
vname	array
[	O
i	int
]	O
<=	O
'9'	O
;	O
i	int
++	O
)	O
ntrials	int
=	O
10	int
*	O
ntrials	int
+	O
vname	array
[	O
i	int
]	O
-	O
'0'	O
;	O
if	O
(	O
i	int
)	O
{	O
if	O
(	O
vname	array
[	O
i	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Invalid number of trials: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
varv	array
[	O
1	int
]	O
=	O
-	O
ntrials	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
vn	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Unknown variable: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
vn	int
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Trials variable not double: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
varv	array
[	O
1	int
]	O
=	O
vn	int
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(parsey) Expected / in yspec at: %s\n"	pointer
,	O
yspec	array
+	O
l	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dap_free	function
(	O
vname	array
,	O
""	pointer
)	O
;	O
}	O
static	O
double	O
vlen	function
(	O
double	O
*	O
v	int
,	O
int	O
nv	int
)	O
{	O
int	O
i	int
;	O
double	O
len	double
;	O
for	O
(	O
len	double
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nv	int
;	O
i	int
++	O
)	O
len	double
+=	O
v	int
[	O
i	int
]	O
*	O
v	int
[	O
i	int
]	O
;	O
return	O
sqrt	function
(	O
len	double
)	O
;	O
}	O
static	O
double	O
vdiff	function
(	O
double	O
*	O
v0	pointer
,	O
double	O
*	O
v1	pointer
,	O
int	O
nv	int
)	O
{	O
int	O
i	int
;	O
double	O
tmp	double
;	O
double	O
diff	int
;	O
for	O
(	O
diff	int
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nv	int
;	O
i	int
++	O
)	O
{	O
tmp	double
=	O
v0	pointer
[	O
i	int
]	O
-	O
v1	pointer
[	O
i	int
]	O
;	O
diff	int
+=	O
tmp	double
*	O
tmp	double
;	O
}	O
return	O
sqrt	function
(	O
diff	int
)	O
;	O
}	O
int	O
dap_invert	function
(	O
double	O
*	O
*	O
a	double
,	O
int	O
nrc	int
)	O
{	O
double	O
*	O
invmem	pointer
;	O
double	O
*	O
*	O
inv	pointer
;	O
int	O
r	double
,	O
c	int
;	O
int	O
cc	int
;	O
double	O
tmp	double
;	O
double	O
mult	double
;	O
invmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nrc	int
*	O
nrc	int
,	O
""	pointer
)	O
;	O
inv	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nrc	int
,	O
""	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrc	int
;	O
r	double
++	O
)	O
{	O
inv	pointer
[	O
r	double
]	O
=	O
invmem	pointer
+	O
r	double
*	O
nrc	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nrc	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
r	double
==	O
c	int
)	O
inv	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
1.0	int
;	O
else	O
inv	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nrc	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
a	double
[	O
c	int
]	O
[	O
c	int
]	O
!=	O
0.0	int
)	O
{	O
tmp	double
=	O
a	double
[	O
c	int
]	O
[	O
c	int
]	O
;	O
for	O
(	O
r	double
=	O
c	int
+	O
1	int
;	O
r	double
<	O
nrc	int
;	O
r	double
++	O
)	O
{	O
mult	double
=	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
/	O
tmp	double
;	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nrc	int
;	O
cc	int
++	O
)	O
{	O
a	double
[	O
r	double
]	O
[	O
cc	int
]	O
-=	O
mult	double
*	O
a	double
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
if	O
(	O
fabs	function
(	O
a	double
[	O
r	double
]	O
[	O
cc	int
]	O
)	O
<	O
dap_tol	double
*	O
tmp	double
)	O
a	double
[	O
r	double
]	O
[	O
cc	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nrc	int
;	O
cc	int
++	O
)	O
{	O
inv	pointer
[	O
r	double
]	O
[	O
cc	int
]	O
-=	O
mult	double
*	O
inv	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
if	O
(	O
fabs	function
(	O
inv	pointer
[	O
r	double
]	O
[	O
cc	int
]	O
)	O
<	O
dap_tol	double
*	O
tmp	double
)	O
inv	pointer
[	O
r	double
]	O
[	O
cc	int
]	O
=	O
0.0	int
;	O
}	O
}	O
}	O
else	O
return	O
0	int
;	O
}	O
for	O
(	O
c	int
=	O
nrc	int
-	O
1	int
;	O
c	int
>=	O
0	int
;	O
--	O
c	int
)	O
{	O
tmp	double
=	O
a	double
[	O
c	int
]	O
[	O
c	int
]	O
;	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nrc	int
;	O
cc	int
++	O
)	O
a	double
[	O
c	int
]	O
[	O
cc	int
]	O
/=	O
tmp	double
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nrc	int
;	O
cc	int
++	O
)	O
inv	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
/=	O
tmp	double
;	O
for	O
(	O
r	double
=	O
c	int
-	O
1	int
;	O
r	double
>=	O
0	int
;	O
--	O
r	double
)	O
{	O
tmp	double
=	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
;	O
for	O
(	O
cc	int
=	O
c	int
;	O
cc	int
<	O
nrc	int
;	O
cc	int
++	O
)	O
a	double
[	O
r	double
]	O
[	O
cc	int
]	O
-=	O
tmp	double
*	O
a	double
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nrc	int
;	O
cc	int
++	O
)	O
inv	pointer
[	O
r	double
]	O
[	O
cc	int
]	O
-=	O
tmp	double
*	O
inv	pointer
[	O
c	int
]	O
[	O
cc	int
]	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrc	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nrc	int
;	O
c	int
++	O
)	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
=	O
inv	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
dap_free	function
(	O
invmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
inv	pointer
,	O
""	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
double	O
irls	function
(	O
double	O
*	O
*	O
x	array
,	O
double	O
*	O
*	O
y	pointer
,	O
double	O
*	O
pr	double
,	O
double	O
*	O
beta0	pointer
,	O
double	O
*	O
*	O
cov	pointer
,	O
int	O
nx	int
,	O
int	O
nobs	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
double	O
*	O
beta1	pointer
;	O
double	O
*	O
v	int
;	O
double	O
*	O
step	function
;	O
double	O
loglike0	double
,	O
loglike1	double
;	O
int	O
niter	int
;	O
double	O
maxv	double
;	O
double	O
maxcov	double
;	O
double	O
tmp	double
;	O
beta1	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nx	int
,	O
""	pointer
)	O
;	O
v	int
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nx	int
,	O
""	pointer
)	O
;	O
step	function
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nx	int
,	O
""	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
beta1	pointer
[	O
i	int
]	O
=	O
0.0	int
;	O
for	O
(	O
loglike1	double
=	O
0.0	int
,	O
n	int
=	O
0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
)	O
{	O
pr	double
[	O
n	int
]	O
=	O
0.5	int
;	O
loglike1	double
+=	O
y	pointer
[	O
1	int
]	O
[	O
n	int
]	O
;	O
}	O
loglike1	double
*=	O
log	function
(	O
0.5	int
)	O
;	O
niter	int
=	O
0	int
;	O
do	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
beta0	pointer
[	O
i	int
]	O
=	O
beta1	pointer
[	O
i	int
]	O
;	O
loglike0	double
=	O
loglike1	double
;	O
for	O
(	O
i	int
=	O
0	int
,	O
maxv	double
=	O
0.0	int
,	O
maxcov	double
=	O
0.0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
v	int
[	O
i	int
]	O
=	O
0.0	int
,	O
n	int
=	O
0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
)	O
v	int
[	O
i	int
]	O
+=	O
x	array
[	O
i	int
]	O
[	O
n	int
]	O
*	O
(	O
y	pointer
[	O
0	int
]	O
[	O
n	int
]	O
-	O
y	pointer
[	O
1	int
]	O
[	O
n	int
]	O
*	O
pr	double
[	O
n	int
]	O
)	O
;	O
if	O
(	O
(	O
tmp	double
=	O
fabs	function
(	O
v	int
[	O
i	int
]	O
)	O
)	O
>	O
maxv	double
)	O
maxv	double
=	O
tmp	double
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nx	int
;	O
j	int
++	O
)	O
{	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
=	O
0.0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
)	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
+=	O
y	pointer
[	O
1	int
]	O
[	O
n	int
]	O
*	O
pr	double
[	O
n	int
]	O
*	O
(	O
1.0	int
-	O
pr	double
[	O
n	int
]	O
)	O
*	O
x	array
[	O
i	int
]	O
[	O
n	int
]	O
*	O
x	array
[	O
j	int
]	O
[	O
n	int
]	O
;	O
if	O
(	O
(	O
tmp	double
=	O
fabs	function
(	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
)	O
)	O
>	O
maxcov	double
)	O
maxcov	double
=	O
tmp	double
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
v	int
[	O
i	int
]	O
)	O
<	O
dap_ctol	double
*	O
maxv	double
)	O
v	int
[	O
i	int
]	O
=	O
0.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nx	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
)	O
<	O
dap_ctol	double
*	O
maxcov	double
)	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
=	O
0.0	int
;	O
}	O
}	O
if	O
(	O
!	O
dap_invert	function
(	O
cov	pointer
,	O
nx	int
)	O
)	O
{	O
fputs	function
(	O
"(irls) X'DX matrix is singular\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
step	function
[	O
i	int
]	O
=	O
0.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nx	int
;	O
j	int
++	O
)	O
step	function
[	O
i	int
]	O
+=	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
*	O
v	int
[	O
j	int
]	O
;	O
}	O
for	O
(	O
;	O
niter	int
<=	O
dap_maxiter	int
;	O
niter	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
beta1	pointer
[	O
i	int
]	O
=	O
beta0	pointer
[	O
i	int
]	O
+	O
step	function
[	O
i	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
,	O
loglike1	double
=	O
0.0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
)	O
{	O
for	O
(	O
pr	double
[	O
n	int
]	O
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
pr	double
[	O
n	int
]	O
+=	O
x	array
[	O
i	int
]	O
[	O
n	int
]	O
*	O
beta1	pointer
[	O
i	int
]	O
;	O
pr	double
[	O
n	int
]	O
=	O
1.0	int
/	O
(	O
1.0	int
+	O
exp	function
(	O
-	O
pr	double
[	O
n	int
]	O
)	O
)	O
;	O
loglike1	double
+=	O
y	pointer
[	O
0	int
]	O
[	O
n	int
]	O
*	O
log	function
(	O
pr	double
[	O
n	int
]	O
)	O
+	O
(	O
y	pointer
[	O
1	int
]	O
[	O
n	int
]	O
-	O
y	pointer
[	O
0	int
]	O
[	O
n	int
]	O
)	O
*	O
log	function
(	O
1.0	int
-	O
pr	double
[	O
n	int
]	O
)	O
;	O
}	O
if	O
(	O
loglike1	double
>=	O
loglike0	double
)	O
break	O
;	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
step	function
[	O
i	int
]	O
*=	O
0.5	int
;	O
}	O
}	O
}	O
while	O
(	O
++	O
niter	int
<=	O
dap_maxiter	int
&&	O
vdiff	function
(	O
beta1	pointer
,	O
beta0	pointer
,	O
nx	int
)	O
>	O
dap_ctol	double
*	O
vlen	function
(	O
beta0	pointer
,	O
nx	int
)	O
)	O
;	O
if	O
(	O
niter	int
>	O
dap_maxiter	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Failed to converge after %d iterations.\n"	pointer
,	O
dap_maxiter	int
)	O
;	O
dap_free	function
(	O
beta1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
v	int
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
step	function
,	O
""	pointer
)	O
;	O
return	O
loglike0	double
;	O
}	O
void	O
logreg1	function
(	O
double	O
*	O
*	O
y	pointer
,	O
double	O
*	O
*	O
x	array
,	O
int	O
nx0	int
,	O
int	O
nx	int
,	O
int	O
nobs	int
,	O
int	O
*	O
varv	array
,	O
int	O
*	O
xvarv	pointer
,	O
int	O
*	O
markv	array
,	O
int	O
*	O
xmarkv	pointer
,	O
int	O
nmark	int
,	O
double	O
level	double
,	O
int	O
param1n	int
,	O
int	O
param2n	int
,	O
int	O
covn	int
,	O
int	O
partv	array
[	O
]	O
)	O
{	O
int	O
typen	int
;	O
double	O
*	O
covmem	pointer
;	O
double	O
*	O
*	O
cov	pointer
;	O
double	O
*	O
pr	double
;	O
double	O
*	O
beta	pointer
;	O
int	O
i	int
,	O
j	int
;	O
double	O
tmp	double
,	O
tmp2	double
;	O
double	O
loglike0	double
,	O
loglike1	double
;	O
static	O
double	O
npt	double
;	O
double	O
xi	double
,	O
xj	double
;	O
double	O
logit	double
;	O
double	O
selogit	double
;	O
int	O
ntrials	int
;	O
int	O
v	int
;	O
covmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
cov	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dap_maxvar	int
;	O
i	int
++	O
)	O
cov	pointer
[	O
i	int
]	O
=	O
covmem	pointer
+	O
i	int
*	O
dap_maxvar	int
;	O
beta	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nx	int
,	O
""	pointer
)	O
;	O
dap_swap	function
(	O
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(logreg1) Missing _type_ variable.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
pr	double
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
nobs	int
*	O
sizeof	O
(	O
double	O
)	O
,	O
""	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Reduced | full model regressors:"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx0	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
" |"	pointer
)	O
;	O
while	O
(	O
i	int
<	O
nx	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
i	int
++	O
]	O
]	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of observations = %d\n"	pointer
,	O
nobs	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ntrials	int
=	O
0	int
;	O
i	int
<	O
nobs	int
;	O
i	int
++	O
)	O
ntrials	int
+=	O
(	O
int	O
)	O
rint	function
(	O
y	pointer
[	O
1	int
]	O
[	O
i	int
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of trials = %d\n"	pointer
,	O
ntrials	int
)	O
;	O
if	O
(	O
varv	array
[	O
nx	int
+	O
1	int
]	O
>=	O
0	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Events / Trials: %s / %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nx	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nx	int
+	O
1	int
]	O
]	O
)	O
;	O
else	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Events / Trials: %s / %d\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nx	int
]	O
]	O
,	O
-	O
varv	array
[	O
nx	int
+	O
1	int
]	O
)	O
;	O
loglike0	double
=	O
irls	function
(	O
x	array
,	O
y	pointer
,	O
pr	double
,	O
beta	pointer
,	O
cov	pointer
,	O
nx0	int
,	O
nobs	int
)	O
;	O
loglike1	double
=	O
irls	function
(	O
x	array
,	O
y	pointer
,	O
pr	double
,	O
beta	pointer
,	O
cov	pointer
,	O
nx	int
,	O
nobs	int
)	O
;	O
dap_free	function
(	O
pr	double
,	O
""	pointer
)	O
;	O
dap_ono	int
=	O
2	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nmark	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
;	O
else	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"-2 (Lred - Lfull) = %.6g = ChiSq0[%d]\n"	pointer
,	O
tmp	double
=	O
-	O
2.0	int
*	O
(	O
loglike0	double
-	O
loglike1	double
)	O
,	O
nx	int
-	O
nx0	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[ChiSq > ChiSq0] = %.5f\n\n"	pointer
,	O
0.00001	int
*	O
ceil	function
(	O
100000.0	int
*	O
probchisq	function
(	O
fabs	function
(	O
tmp	double
)	O
,	O
nx	int
-	O
nx0	int
)	O
)	O
)	O
;	O
fputs	function
(	O
"  Parameter           Estimate    Std Error   Wald ChiSq  Prob[ChiSq>Wald ChiSq]\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
tmp	double
=	O
sqrt	function
(	O
cov	pointer
[	O
i	int
]	O
[	O
i	int
]	O
)	O
;	O
tmp2	double
=	O
beta	pointer
[	O
i	int
]	O
*	O
beta	pointer
[	O
i	int
]	O
/	O
cov	pointer
[	O
i	int
]	O
[	O
i	int
]	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"  %-15s %12.6g %12.6g %12.6g  %14.5f\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
,	O
beta	pointer
[	O
i	int
]	O
,	O
tmp	double
,	O
tmp2	double
,	O
0.00001	int
*	O
ceil	function
(	O
100000.0	int
*	O
probchisq	function
(	O
fabs	function
(	O
tmp2	double
)	O
,	O
1	int
)	O
)	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"ESTIMATE"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
,	O
""	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
=	O
beta	pointer
[	O
i	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"COVAR"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nx	int
;	O
j	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
j	int
]	O
]	O
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
=	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
fabs	function
(	O
level	double
)	O
<	O
1.0	int
)	O
npt	double
=	O
-	O
zpoint	function
(	O
0.5	int
*	O
(	O
1.0	int
-	O
level	double
)	O
)	O
;	O
else	O
npt	double
=	O
0.0	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
=	O
1.0	int
;	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
<	O
0	int
)	O
{	O
dap_rewind	function
(	O
)	O
;	O
step	function
(	O
)	O
;	O
}	O
while	O
(	O
matchmark	function
(	O
markv	array
,	O
xmarkv	pointer
,	O
nmark	int
,	O
level	double
)	O
)	O
{	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_dbl	pointer
[	O
xvarv	pointer
[	O
i	int
-	O
1	int
]	O
]	O
;	O
}	O
for	O
(	O
logit	double
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
logit	double
+=	O
beta	pointer
[	O
i	int
]	O
*	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
;	O
for	O
(	O
selogit	double
=	O
0.0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
nx	int
;	O
i	int
++	O
)	O
{	O
xi	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
i	int
]	O
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nx	int
;	O
j	int
++	O
)	O
{	O
xj	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
j	int
]	O
]	O
;	O
selogit	double
+=	O
xi	double
*	O
cov	pointer
[	O
i	int
]	O
[	O
j	int
]	O
*	O
xj	double
;	O
}	O
}	O
selogit	double
=	O
sqrt	function
(	O
selogit	double
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"PRED"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
]	O
]	O
=	O
1.0	int
/	O
(	O
1.0	int
+	O
exp	function
(	O
-	O
logit	double
)	O
)	O
;	O
output	function
(	O
)	O
;	O
if	O
(	O
npt	double
!=	O
0.0	int
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"LOWER"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
]	O
]	O
=	O
1.0	int
/	O
(	O
1.0	int
+	O
exp	function
(	O
-	O
logit	double
+	O
npt	double
*	O
selogit	double
)	O
)	O
;	O
output	function
(	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"UPPER"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
]	O
]	O
=	O
1.0	int
/	O
(	O
1.0	int
+	O
exp	function
(	O
-	O
logit	double
-	O
npt	double
*	O
selogit	double
)	O
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
dap_ono	int
=	O
1	int
;	O
dap_mark	function
(	O
)	O
;	O
if	O
(	O
!	O
step	function
(	O
)	O
)	O
break	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
xvarv	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
dap_swap	function
(	O
)	O
;	O
dap_free	function
(	O
covmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
cov	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
beta	pointer
,	O
""	pointer
)	O
;	O
}	O
void	O
logreg	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
yspec	array
,	O
char	O
*	O
x0list	array
,	O
char	O
*	O
x1list	array
,	O
char	O
*	O
marks	array
,	O
char	O
*	O
xname	array
,	O
double	O
level	double
)	O
{	O
char	O
*	O
regname	pointer
;	O
int	O
*	O
varv	array
;	O
int	O
*	O
xvarv	pointer
;	O
int	O
nx0	int
,	O
nx1	int
;	O
int	O
nx	int
;	O
int	O
nxx	int
;	O
int	O
*	O
markv	array
;	O
int	O
*	O
xmarkv	pointer
;	O
int	O
nmark	int
;	O
double	O
*	O
xmem	pointer
;	O
double	O
*	O
*	O
x	array
;	O
double	O
*	O
ymem	pointer
;	O
double	O
*	O
y	pointer
[	O
2	int
]	O
;	O
int	O
v	int
;	O
int	O
nobs	int
;	O
int	O
more	int
;	O
char	O
*	O
covset	pointer
;	O
int	O
param1n	int
,	O
param2n	int
,	O
covn	int
;	O
int	O
paramlen1	int
,	O
paramlen	int
;	O
char	O
paramstr	array
[	O
14	int
]	O
;	O
char	O
*	O
partstr	pointer
;	O
int	O
*	O
partv	array
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(logreg) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
xvarv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
xmarkv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
partv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
regname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
regname	pointer
,	O
fname	array
,	O
".lgr"	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
dap_vd	function
(	O
"_intercept_ -1"	pointer
,	O
0	int
)	O
;	O
nx0	int
=	O
dap_list	function
(	O
"_intercept_"	pointer
,	O
varv	array
,	O
dap_maxvar	int
)	O
;	O
nx0	int
+=	O
dap_list	function
(	O
x0list	array
,	O
varv	array
+	O
1	int
,	O
dap_maxvar	int
)	O
;	O
nx1	int
=	O
dap_list	function
(	O
x1list	array
,	O
varv	array
+	O
nx0	int
,	O
dap_maxvar	int
)	O
;	O
nx	int
=	O
nx0	int
+	O
nx1	int
;	O
dap_parsey	function
(	O
yspec	array
,	O
varv	array
+	O
nx	int
)	O
;	O
xmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nx	int
*	O
dap_maxval	int
,	O
"dap_maxval"	pointer
)	O
;	O
x	array
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nx	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nx	int
;	O
v	int
++	O
)	O
x	array
[	O
v	int
]	O
=	O
xmem	pointer
+	O
v	int
*	O
dap_maxval	int
;	O
ymem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
2	int
*	O
dap_maxval	int
,	O
"dap_maxval"	pointer
)	O
;	O
y	pointer
[	O
0	int
]	O
=	O
ymem	pointer
;	O
y	pointer
[	O
1	int
]	O
=	O
ymem	pointer
+	O
dap_maxval	int
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
covset	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
covset	pointer
,	O
fname	array
)	O
;	O
strcat	function
(	O
covset	pointer
,	O
".cov"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
1	int
,	O
paramlen	int
=	O
strlen	function
(	O
"_intercept_"	pointer
)	O
;	O
v	int
<	O
nx	int
;	O
v	int
++	O
)	O
{	O
paramlen1	int
=	O
strlen	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
paramlen1	int
>	O
paramlen	int
)	O
paramlen	int
=	O
paramlen1	int
;	O
}	O
dap_ono	int
=	O
2	int
;	O
dap_clearobs	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_param1_ %d"	pointer
,	O
paramlen	int
)	O
;	O
param1n	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_param2_ %d"	pointer
,	O
paramlen	int
)	O
;	O
param2n	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
covn	int
=	O
dap_vd	function
(	O
"_cov_ -1"	pointer
,	O
0	int
)	O
;	O
partstr	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
marks	array
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nmark	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
partstr	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
;	O
sprintf	function
(	O
partstr	pointer
+	O
strlen	function
(	O
partstr	pointer
)	O
,	O
" %d"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
;	O
partv	array
[	O
v	int
]	O
=	O
dap_vd	function
(	O
partstr	pointer
,	O
1	int
)	O
;	O
}	O
outset	function
(	O
covset	pointer
,	O
""	pointer
)	O
;	O
dap_ono	int
=	O
1	int
;	O
if	O
(	O
xname	array
&&	O
xname	array
[	O
0	int
]	O
)	O
{	O
inset	function
(	O
xname	array
)	O
;	O
nxx	int
=	O
dap_list	function
(	O
x0list	array
,	O
xvarv	pointer
,	O
dap_maxvar	int
)	O
;	O
nxx	int
+=	O
dap_list	function
(	O
x1list	array
,	O
xvarv	pointer
+	O
nxx	int
,	O
dap_maxvar	int
)	O
;	O
if	O
(	O
nxx	int
!=	O
nx	int
-	O
1	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(logreg) %s and %s have different numbers (%d and %d) of x-variables.\n"	pointer
,	O
fname	array
,	O
xname	array
,	O
nx	int
-	O
1	int
,	O
nxx	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nmark	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nmark	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
(	O
xmarkv	pointer
[	O
v	int
]	O
=	O
dap_varnum	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(logreg) Mark variable %s in %s not in %s.\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
v	int
]	O
]	O
,	O
fname	array
,	O
xname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
step	function
(	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(logreg) No data in %s.\n"	pointer
,	O
(	O
xname	array
[	O
0	int
]	O
?	O
xname	array
:	O
fname	array
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
xvarv	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
xmarkv	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
}	O
dap_ono	int
=	O
0	int
;	O
outset	function
(	O
regname	pointer
,	O
""	pointer
)	O
;	O
for	O
(	O
nobs	int
=	O
0	int
,	O
dap_mark	function
(	O
)	O
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
dap_swap	function
(	O
)	O
;	O
logreg1	function
(	O
y	pointer
,	O
x	array
,	O
nx0	int
,	O
nx	int
,	O
nobs	int
,	O
varv	array
,	O
xvarv	pointer
,	O
markv	array
,	O
xmarkv	pointer
,	O
nmark	int
,	O
level	double
,	O
param1n	int
,	O
param2n	int
,	O
covn	int
,	O
partv	array
)	O
;	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
x	array
[	O
0	int
]	O
[	O
nobs	int
]	O
=	O
1.0	int
;	O
for	O
(	O
v	int
=	O
1	int
;	O
v	int
<	O
nx	int
;	O
v	int
++	O
)	O
x	array
[	O
v	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
y	pointer
[	O
0	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
]	O
]	O
;	O
if	O
(	O
varv	array
[	O
nx	int
+	O
1	int
]	O
>=	O
0	int
)	O
y	pointer
[	O
1	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
nx	int
+	O
1	int
]	O
]	O
;	O
else	O
y	pointer
[	O
1	int
]	O
[	O
nobs	int
]	O
=	O
-	O
(	O
double	O
)	O
varv	array
[	O
nx	int
+	O
1	int
]	O
;	O
}	O
else	O
{	O
fputs	function
(	O
"(logreg) Too many data.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
dap_free	function
(	O
regname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xvarv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xmarkv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
x	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
ymem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
covset	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partstr	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partv	array
,	O
""	pointer
)	O
;	O
}	O
typedef	O
struct	O
{	O
int	O
val_class	int
;	O
double	O
val_val	double
;	O
}	O
value	struct
;	O
static	O
int	O
valcmp1	function
(	O
value	struct
*	O
v1	pointer
,	O
value	struct
*	O
v2	pointer
)	O
{	O
if	O
(	O
v1	pointer
->	O
val_val	double
<	O
v2	pointer
->	O
val_val	double
)	O
return	O
-	O
1	int
;	O
if	O
(	O
v1	pointer
->	O
val_val	double
>	O
v2	pointer
->	O
val_val	double
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
double	O
probkol	function
(	O
double	O
d	double
,	O
double	O
n	int
)	O
{	O
double	O
lambda	double
;	O
double	O
l	int
;	O
double	O
k	double
;	O
double	O
term	double
;	O
int	O
sign	int
;	O
if	O
(	O
d	double
==	O
0.0	int
)	O
return	O
0.0	int
;	O
lambda	double
=	O
d	double
*	O
sqrt	function
(	O
n	int
)	O
;	O
lambda	double
*=	O
-	O
2.0	int
*	O
lambda	double
;	O
for	O
(	O
k	double
=	O
1.0	int
,	O
l	int
=	O
0.0	int
,	O
sign	int
=	O
1	int
;	O
(	O
term	double
=	O
exp	function
(	O
k	double
*	O
k	double
*	O
lambda	double
)	O
)	O
>	O
dap_ktol	double
;	O
k	double
+=	O
1.0	int
,	O
sign	int
=	O
-	O
sign	int
)	O
l	int
+=	O
(	O
sign	int
>	O
0	int
?	O
term	double
:	O
-	O
term	double
)	O
;	O
return	O
2.0	int
*	O
l	int
;	O
}	O
static	O
int	O
(	O
*	O
pvalcmp1	pointer
)	O
(	O
)	O
=	O
&	O
valcmp1	function
;	O
static	O
void	O
nonpar1	function
(	O
value	struct
*	O
val	pointer
,	O
int	O
nval	int
,	O
char	O
*	O
*	O
level	double
,	O
int	O
nlevels	int
,	O
int	O
*	O
varv	array
,	O
int	O
nvar	int
)	O
{	O
int	O
rank	int
,	O
ntied	int
,	O
tied	int
;	O
int	O
tottied	int
;	O
double	O
tiecorr	double
;	O
double	O
drank	double
;	O
double	O
dn	double
;	O
double	O
stat0	double
,	O
stat	double
;	O
double	O
prob	double
;	O
int	O
*	O
levnobs	pointer
;	O
int	O
minnobs	int
;	O
int	O
*	O
rank1	pointer
;	O
int	O
r	double
;	O
int	O
levn	int
;	O
double	O
*	O
sumr	pointer
;	O
double	O
tmp	double
,	O
tmp1	double
;	O
double	O
kold	double
;	O
int	O
kolr	int
;	O
double	O
kolval	double
;	O
double	O
f	pointer
[	O
2	int
]	O
;	O
tmp	double
=	O
0.0	int
;	O
tmp1	double
=	O
0.0	int
;	O
kolr	int
=	O
0	int
;	O
kolval	double
=	O
0.0	int
;	O
dap_swap	function
(	O
)	O
;	O
levnobs	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nlevels	int
,	O
""	pointer
)	O
;	O
sumr	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nlevels	int
,	O
""	pointer
)	O
;	O
rank1	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxex2	int
,	O
"dap_maxex2"	pointer
)	O
;	O
dn	double
=	O
(	O
double	O
)	O
nval	int
;	O
if	O
(	O
nvar	int
==	O
2	int
)	O
{	O
qsort	function
(	O
val	pointer
,	O
nval	int
,	O
sizeof	O
(	O
value	struct
)	O
,	O
pvalcmp1	pointer
)	O
;	O
for	O
(	O
levn	int
=	O
0	int
;	O
levn	int
<	O
nlevels	int
;	O
levn	int
++	O
)	O
levnobs	pointer
[	O
levn	int
]	O
=	O
0	int
;	O
for	O
(	O
rank	int
=	O
0	int
;	O
rank	int
<	O
nval	int
;	O
rank	int
++	O
)	O
levnobs	pointer
[	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
]	O
++	O
;	O
if	O
(	O
nlevels	int
==	O
2	int
)	O
{	O
for	O
(	O
rank	int
=	O
0	int
,	O
stat0	double
=	O
0.0	int
,	O
stat	double
=	O
0.0	int
,	O
tottied	int
=	O
0	int
,	O
tiecorr	double
=	O
0.0	int
,	O
f	pointer
[	O
0	int
]	O
=	O
0.0	int
,	O
f	pointer
[	O
1	int
]	O
=	O
0.0	int
,	O
kold	double
=	O
0.0	int
;	O
rank	int
<	O
nval	int
;	O
)	O
{	O
for	O
(	O
ntied	int
=	O
1	int
;	O
rank	int
+	O
ntied	int
<	O
nval	int
&&	O
fabs	function
(	O
val	pointer
[	O
rank	int
+	O
ntied	int
]	O
.	O
val_val	double
-	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
)	O
<	O
dap_tol	double
*	O
(	O
fabs	function
(	O
val	pointer
[	O
rank	int
+	O
ntied	int
]	O
.	O
val_val	double
)	O
+	O
fabs	function
(	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
)	O
)	O
;	O
ntied	int
++	O
)	O
;	O
drank	double
=	O
(	O
(	O
double	O
)	O
(	O
2	int
*	O
rank	int
+	O
ntied	int
+	O
1	int
)	O
)	O
/	O
2.0	int
;	O
if	O
(	O
ntied	int
>	O
1	int
)	O
{	O
tottied	int
+=	O
ntied	int
;	O
tiecorr	double
+=	O
(	O
double	O
)	O
(	O
ntied	int
*	O
(	O
ntied	int
+	O
1	int
)	O
*	O
(	O
ntied	int
-	O
1	int
)	O
)	O
;	O
}	O
for	O
(	O
tied	int
=	O
0	int
;	O
tied	int
<	O
ntied	int
;	O
tied	int
++	O
,	O
rank	int
++	O
)	O
{	O
if	O
(	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
)	O
{	O
stat0	double
+=	O
drank	double
;	O
f	pointer
[	O
1	int
]	O
+=	O
1.0	int
;	O
}	O
else	O
{	O
stat	double
+=	O
drank	double
;	O
f	pointer
[	O
0	int
]	O
+=	O
1.0	int
;	O
}	O
tmp1	double
=	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
;	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
=	O
drank	double
;	O
}	O
tmp	double
=	O
fabs	function
(	O
f	pointer
[	O
1	int
]	O
/	O
(	O
(	O
double	O
)	O
levnobs	pointer
[	O
1	int
]	O
)	O
-	O
f	pointer
[	O
0	int
]	O
/	O
(	O
(	O
double	O
)	O
levnobs	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
tmp	double
>	O
kold	double
)	O
{	O
kold	double
=	O
tmp	double
;	O
kolr	int
=	O
rank	int
;	O
kolval	double
=	O
tmp1	double
;	O
}	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nResponse: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Classified by %s:"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
1	int
]	O
]	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	int
;	O
r	double
++	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s (%d)"	pointer
,	O
level	double
[	O
r	double
]	O
,	O
levnobs	pointer
[	O
r	double
]	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of tied observations = %d\n"	pointer
,	O
tottied	int
)	O
;	O
if	O
(	O
levnobs	pointer
[	O
0	int
]	O
<	O
levnobs	pointer
[	O
1	int
]	O
)	O
{	O
levn	int
=	O
0	int
;	O
stat0	double
=	O
stat	double
;	O
}	O
else	O
levn	int
=	O
1	int
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nWilcoxon rank sum statistic S0 (%s) = %g\n"	pointer
,	O
level	double
[	O
0	int
]	O
,	O
stat0	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Expected under H0 = %g\n"	pointer
,	O
(	O
(	O
double	O
)	O
levnobs	pointer
[	O
levn	int
]	O
)	O
*	O
(	O
dn	double
+	O
1.0	int
)	O
/	O
2.0	int
)	O
;	O
stat0	double
=	O
fabs	function
(	O
stat0	double
-	O
(	O
(	O
double	O
)	O
levnobs	pointer
[	O
levn	int
]	O
)	O
*	O
(	O
dn	double
+	O
1.0	int
)	O
/	O
2.0	int
)	O
;	O
if	O
(	O
nval	int
<	O
dap_maxex2	int
)	O
{	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
levnobs	pointer
[	O
levn	int
]	O
;	O
r	double
++	O
)	O
rank1	pointer
[	O
r	double
]	O
=	O
r	double
;	O
rank1	pointer
[	O
r	double
]	O
=	O
nval	int
;	O
for	O
(	O
prob	double
=	O
0.0	int
;	O
;	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
,	O
stat	double
=	O
-	O
(	O
(	O
double	O
)	O
levnobs	pointer
[	O
levn	int
]	O
)	O
*	O
(	O
dn	double
+	O
1.0	int
)	O
/	O
2.0	int
;	O
r	double
<	O
levnobs	pointer
[	O
levn	int
]	O
;	O
r	double
++	O
)	O
stat	double
+=	O
val	pointer
[	O
rank1	pointer
[	O
r	double
]	O
]	O
.	O
val_val	double
;	O
if	O
(	O
fabs	function
(	O
stat	double
)	O
>=	O
stat0	double
)	O
prob	double
+=	O
1.0	int
;	O
for	O
(	O
r	double
=	O
levnobs	pointer
[	O
levn	int
]	O
-	O
1	int
;	O
r	double
>=	O
0	int
&&	O
rank1	pointer
[	O
r	double
]	O
+	O
1	int
==	O
rank1	pointer
[	O
r	double
+	O
1	int
]	O
;	O
--	O
r	double
)	O
;	O
if	O
(	O
r	double
>=	O
0	int
)	O
{	O
rank1	pointer
[	O
r	double
]	O
++	O
;	O
for	O
(	O
r	double
++	O
;	O
r	double
<	O
levnobs	pointer
[	O
levn	int
]	O
;	O
r	double
++	O
)	O
rank1	pointer
[	O
r	double
]	O
=	O
rank1	pointer
[	O
r	double
-	O
1	int
]	O
+	O
1	int
;	O
}	O
else	O
break	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[|S - E(S)| >= |S0 - E(S)|] = %.4g (exact)\n"	pointer
,	O
prob	double
/	O
dap_bincoeff	function
(	O
dn	double
,	O
(	O
double	O
)	O
levnobs	pointer
[	O
levn	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
stat0	double
>=	O
0.5	int
)	O
stat0	double
-=	O
0.5	int
;	O
prob	double
=	O
2.0	int
*	O
(	O
1.0	int
-	O
probz	function
(	O
stat0	double
/	O
sqrt	function
(	O
(	O
(	O
double	O
)	O
(	O
levnobs	pointer
[	O
0	int
]	O
*	O
levnobs	pointer
[	O
1	int
]	O
)	O
)	O
*	O
(	O
(	O
dn	double
+	O
1.0	int
)	O
-	O
tiecorr	double
/	O
(	O
dn	double
*	O
(	O
dn	double
-	O
1.0	int
)	O
)	O
)	O
/	O
12.0	int
)	O
)	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[|S - E(S)| >= |S0 - E(S)|] = %.4g\n"	pointer
,	O
prob	double
)	O
;	O
fputs	function
(	O
"(normal approximation, with continuity correction)\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nKolmogorov statistic D0 = %g\n"	pointer
,	O
kold	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Maximum deviation at %g for level %s\n"	pointer
,	O
kolval	double
,	O
level	double
[	O
val	pointer
[	O
kolr	int
]	O
.	O
val_class	int
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[D >= D0] = %.4g\n"	pointer
,	O
probkol	function
(	O
kold	double
,	O
(	O
(	O
double	O
)	O
(	O
levnobs	pointer
[	O
0	int
]	O
*	O
levnobs	pointer
[	O
1	int
]	O
)	O
)	O
/	O
dn	double
)	O
)	O
;	O
}	O
else	O
if	O
(	O
nlevels	int
>	O
2	int
)	O
{	O
for	O
(	O
levn	int
=	O
0	int
;	O
levn	int
<	O
nlevels	int
;	O
levn	int
++	O
)	O
sumr	pointer
[	O
levn	int
]	O
=	O
0.0	int
;	O
for	O
(	O
rank	int
=	O
0	int
,	O
tottied	int
=	O
0	int
,	O
tiecorr	double
=	O
0.0	int
;	O
rank	int
<	O
nval	int
;	O
)	O
{	O
for	O
(	O
ntied	int
=	O
1	int
;	O
rank	int
+	O
ntied	int
<	O
nval	int
&&	O
fabs	function
(	O
val	pointer
[	O
rank	int
+	O
ntied	int
]	O
.	O
val_val	double
-	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
)	O
<	O
dap_tol	double
*	O
(	O
fabs	function
(	O
val	pointer
[	O
rank	int
+	O
ntied	int
]	O
.	O
val_val	double
)	O
+	O
fabs	function
(	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
)	O
)	O
;	O
ntied	int
++	O
)	O
;	O
drank	double
=	O
(	O
(	O
double	O
)	O
(	O
2	int
*	O
rank	int
+	O
ntied	int
+	O
1	int
)	O
)	O
/	O
2.0	int
;	O
if	O
(	O
ntied	int
>	O
1	int
)	O
{	O
tottied	int
+=	O
ntied	int
;	O
tiecorr	double
+=	O
(	O
double	O
)	O
(	O
ntied	int
*	O
(	O
ntied	int
+	O
1	int
)	O
*	O
(	O
ntied	int
-	O
1	int
)	O
)	O
;	O
}	O
for	O
(	O
tied	int
=	O
0	int
;	O
tied	int
<	O
ntied	int
;	O
tied	int
++	O
,	O
rank	int
++	O
)	O
{	O
sumr	pointer
[	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
]	O
+=	O
drank	double
;	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
=	O
drank	double
;	O
}	O
}	O
for	O
(	O
stat0	double
=	O
0.0	int
,	O
levn	int
=	O
0	int
;	O
levn	int
<	O
nlevels	int
;	O
levn	int
++	O
)	O
{	O
tmp	double
=	O
sumr	pointer
[	O
levn	int
]	O
/	O
(	O
(	O
double	O
)	O
levnobs	pointer
[	O
levn	int
]	O
)	O
-	O
0.5	int
*	O
(	O
dn	double
+	O
1.0	int
)	O
;	O
stat0	double
+=	O
tmp	double
*	O
tmp	double
*	O
(	O
double	O
)	O
levnobs	pointer
[	O
levn	int
]	O
;	O
}	O
stat0	double
*=	O
12.0	int
/	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
-	O
tiecorr	double
/	O
(	O
dn	double
-	O
1.0	int
)	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nResponse: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Classified by %s:"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
1	int
]	O
]	O
)	O
;	O
for	O
(	O
levn	int
=	O
0	int
,	O
minnobs	int
=	O
levnobs	pointer
[	O
0	int
]	O
;	O
levn	int
<	O
nlevels	int
;	O
levn	int
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s (%d)"	pointer
,	O
level	double
[	O
levn	int
]	O
,	O
levnobs	pointer
[	O
levn	int
]	O
)	O
;	O
if	O
(	O
levnobs	pointer
[	O
levn	int
]	O
<	O
minnobs	int
)	O
minnobs	int
=	O
levnobs	pointer
[	O
levn	int
]	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of tied observations = %d\n"	pointer
,	O
tottied	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Kruskal-Wallis statistic T0 = %g\n"	pointer
,	O
stat0	double
)	O
;	O
prob	double
=	O
probchisq	function
(	O
stat0	double
,	O
nlevels	int
-	O
1	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[T >= T0] = %g (chi-squared approximation, df = %d)\n"	pointer
,	O
prob	double
,	O
nlevels	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
nlevels	int
==	O
3	int
&&	O
minnobs	int
<	O
6	int
)	O
||	O
minnobs	int
<	O
5	int
)	O
fputs	function
(	O
"Warning: sample may be too small for this approximation.\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nResponse: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of non-zero observations = %d\n"	pointer
,	O
nval	int
)	O
;	O
qsort	function
(	O
val	pointer
,	O
nval	int
,	O
sizeof	O
(	O
value	struct
)	O
,	O
pvalcmp1	pointer
)	O
;	O
for	O
(	O
rank	int
=	O
0	int
,	O
stat0	double
=	O
0.0	int
,	O
tottied	int
=	O
0	int
,	O
tiecorr	double
=	O
0	int
,	O
levnobs	pointer
[	O
0	int
]	O
=	O
0	int
;	O
rank	int
<	O
nval	int
;	O
)	O
{	O
for	O
(	O
ntied	int
=	O
1	int
;	O
rank	int
+	O
ntied	int
<	O
nval	int
&&	O
fabs	function
(	O
val	pointer
[	O
rank	int
+	O
ntied	int
]	O
.	O
val_val	double
-	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
)	O
<	O
dap_tol	double
*	O
(	O
fabs	function
(	O
val	pointer
[	O
rank	int
+	O
ntied	int
]	O
.	O
val_val	double
)	O
+	O
fabs	function
(	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
)	O
)	O
;	O
ntied	int
++	O
)	O
;	O
drank	double
=	O
(	O
(	O
double	O
)	O
(	O
2	int
*	O
rank	int
+	O
ntied	int
+	O
1	int
)	O
)	O
/	O
2.0	int
;	O
if	O
(	O
ntied	int
>	O
1	int
)	O
{	O
tottied	int
+=	O
ntied	int
;	O
tiecorr	double
+=	O
(	O
(	O
double	O
)	O
(	O
ntied	int
*	O
(	O
ntied	int
+	O
1	int
)	O
*	O
(	O
ntied	int
-	O
1	int
)	O
)	O
)	O
/	O
2.0	int
;	O
}	O
for	O
(	O
tied	int
=	O
0	int
;	O
tied	int
<	O
ntied	int
;	O
tied	int
++	O
,	O
rank	int
++	O
)	O
{	O
if	O
(	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
)	O
{	O
stat0	double
+=	O
drank	double
;	O
levnobs	pointer
[	O
0	int
]	O
++	O
;	O
}	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
=	O
drank	double
;	O
}	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of tied observations = %d\n"	pointer
,	O
tottied	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of positive observations = %d\n"	pointer
,	O
levnobs	pointer
[	O
0	int
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nWilcoxon signed rank statistic W0 = %g\n"	pointer
,	O
stat0	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Expected under H0 = %g\n"	pointer
,	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
/	O
4.0	int
)	O
;	O
stat0	double
=	O
fabs	function
(	O
stat0	double
-	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
/	O
4.0	int
)	O
;	O
if	O
(	O
nval	int
<=	O
dap_maxex1	int
)	O
{	O
for	O
(	O
rank	int
=	O
0	int
;	O
rank	int
<	O
nval	int
;	O
rank	int
++	O
)	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
=	O
0	int
;	O
prob	double
=	O
0.0	int
;	O
do	O
{	O
for	O
(	O
rank	int
=	O
0	int
,	O
stat	double
=	O
-	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
/	O
4.0	int
;	O
rank	int
<	O
nval	int
;	O
rank	int
++	O
)	O
{	O
if	O
(	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
)	O
stat	double
+=	O
val	pointer
[	O
rank	int
]	O
.	O
val_val	double
;	O
}	O
if	O
(	O
fabs	function
(	O
stat	double
)	O
>=	O
stat0	double
)	O
prob	double
+=	O
1.0	int
;	O
for	O
(	O
rank	int
=	O
0	int
;	O
rank	int
<	O
nval	int
;	O
rank	int
++	O
)	O
{	O
if	O
(	O
!	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
)	O
{	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
val	pointer
[	O
rank	int
]	O
.	O
val_class	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
rank	int
<	O
nval	int
)	O
;	O
for	O
(	O
rank	int
=	O
0	int
;	O
rank	int
<	O
nval	int
;	O
rank	int
++	O
)	O
prob	double
/=	O
2.0	int
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[|W - E(W)| >= |W0 - E(W)|] = %.4g (exact)\n"	pointer
,	O
prob	double
)	O
;	O
}	O
else	O
{	O
prob	double
=	O
2.0	int
*	O
probt	function
(	O
stat0	double
*	O
sqrt	function
(	O
(	O
dn	double
-	O
1.0	int
)	O
/	O
(	O
dn	double
*	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
*	O
(	O
2.0	int
*	O
dn	double
+	O
1.0	int
)	O
-	O
tiecorr	double
)	O
/	O
24.0	int
-	O
stat0	double
*	O
stat0	double
)	O
)	O
,	O
nval	int
-	O
1	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Prob[|W - E(W)| >= |W0 - E(W)|] = %.4g\n"	pointer
,	O
prob	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"(t-approximation, df = %d, with continuity correction)\n"	pointer
,	O
nval	int
-	O
1	int
)	O
;	O
}	O
}	O
dap_free	function
(	O
levnobs	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
rank1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sumr	pointer
,	O
""	pointer
)	O
;	O
dap_swap	function
(	O
)	O
;	O
}	O
static	O
int	O
findlev	function
(	O
char	O
*	O
levname	pointer
,	O
char	O
*	O
*	O
level	double
,	O
int	O
*	O
nlevels	int
)	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
*	O
nlevels	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
levname	pointer
,	O
level	double
[	O
l	int
]	O
)	O
)	O
return	O
l	int
;	O
}	O
if	O
(	O
*	O
nlevels	int
<	O
dap_maxlev	int
)	O
{	O
strcpy	function
(	O
level	double
[	O
*	O
nlevels	int
]	O
,	O
levname	pointer
)	O
;	O
return	O
(	O
*	O
nlevels	int
)	O
++	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(findlev) Too many levels (%s)\n"	pointer
,	O
levname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
nonparam	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
variables	pointer
,	O
char	O
*	O
marks	array
)	O
{	O
int	O
varv	array
[	O
2	int
]	O
;	O
int	O
nvar	int
;	O
int	O
*	O
markv	array
;	O
int	O
nmark	int
;	O
value	struct
*	O
val	pointer
;	O
int	O
nval	int
;	O
int	O
nobs	int
;	O
char	O
*	O
levmem	pointer
;	O
char	O
*	O
*	O
level	double
;	O
int	O
nlevels	int
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(nonparam) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
levmem	pointer
=	O
dap_malloc	function
(	O
dap_maxlev	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
,	O
"dap_maxlev, dap_strlen"	pointer
)	O
;	O
level	double
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlev	int
,	O
"dap_maxlev"	pointer
)	O
;	O
for	O
(	O
nlevels	int
=	O
0	int
;	O
nlevels	int
<	O
dap_maxlev	int
;	O
nlevels	int
++	O
)	O
level	double
[	O
nlevels	int
]	O
=	O
levmem	pointer
+	O
nlevels	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
nvar	int
=	O
dap_list	function
(	O
variables	pointer
,	O
varv	array
,	O
dap_maxvar	int
)	O
;	O
if	O
(	O
!	O
nvar	int
)	O
{	O
fputs	function
(	O
"(nonparam) No variables specified.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nvar	int
>	O
2	int
)	O
{	O
fputs	function
(	O
"(nonparam) At most one response and one class variable allowed\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(nonparam) Variable must be dap_double: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nvar	int
==	O
2	int
&&	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
1	int
]	O
]	O
<=	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(nonparam) Classification variable must be dap_char: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
1	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
val	pointer
=	O
(	O
value	struct
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
value	struct
)	O
*	O
dap_maxval	int
,	O
"dap_maxval"	pointer
)	O
;	O
for	O
(	O
more	int
=	O
1	int
,	O
nlevels	int
=	O
0	int
,	O
nval	int
=	O
0	int
,	O
nobs	int
=	O
0	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
dap_swap	function
(	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Number of observations = %d\n"	pointer
,	O
nobs	int
)	O
;	O
nonpar1	function
(	O
val	pointer
,	O
nval	int
,	O
level	double
,	O
nlevels	int
,	O
varv	array
,	O
nvar	int
)	O
;	O
if	O
(	O
!	O
more	int
)	O
break	O
;	O
nval	int
=	O
0	int
;	O
nobs	int
=	O
0	int
;	O
nlevels	int
=	O
0	int
;	O
}	O
if	O
(	O
nval	int
>=	O
dap_maxval	int
)	O
{	O
fputs	function
(	O
"(nonparam) Too many values.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nvar	int
==	O
2	int
)	O
{	O
val	pointer
[	O
nval	int
]	O
.	O
val_class	int
=	O
findlev	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varv	array
[	O
1	int
]	O
]	O
,	O
level	double
,	O
&	O
nlevels	int
)	O
;	O
val	pointer
[	O
nval	int
]	O
.	O
val_val	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
;	O
nval	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
!=	O
0.0	int
)	O
{	O
val	pointer
[	O
nval	int
]	O
.	O
val_class	int
=	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
>	O
0.0	int
)	O
;	O
val	pointer
[	O
nval	int
]	O
.	O
val_val	double
=	O
fabs	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
nval	int
++	O
;	O
}	O
}	O
}	O
dap_free	function
(	O
val	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
levmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
level	double
,	O
""	pointer
)	O
;	O
}	O
