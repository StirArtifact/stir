lang_statement_list_type	struct
constructor_list	struct
;	O
bfd_boolean	int
constructors_sorted	int
;	O
struct	O
set_info	struct
*	O
sets	pointer
;	O
void	O
ldctor_add_set_entry	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_reloc_code_real_type	enum
reloc	enum
,	O
const	O
char	O
*	O
name	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
value	long
)	O
{	O
struct	O
set_info	struct
*	O
p	pointer
;	O
struct	O
set_element	struct
*	O
e	pointer
;	O
struct	O
set_element	struct
*	O
*	O
epp	pointer
;	O
for	O
(	O
p	pointer
=	O
sets	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
h	pointer
==	O
h	pointer
)	O
break	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
p	pointer
=	O
(	O
struct	O
set_info	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
set_info	struct
)	O
)	O
;	O
p	pointer
->	O
next	pointer
=	O
sets	pointer
;	O
sets	pointer
=	O
p	pointer
;	O
p	pointer
->	O
h	pointer
=	O
h	pointer
;	O
p	pointer
->	O
reloc	enum
=	O
reloc	enum
;	O
p	pointer
->	O
count	int
=	O
0	int
;	O
p	pointer
->	O
elements	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
reloc	enum
!=	O
reloc	enum
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: different relocs used in set %s\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
p	pointer
->	O
elements	pointer
!=	O
NULL	O
&&	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
bfd_get_target	function
(	O
section	pointer
->	O
owner	pointer
)	O
,	O
bfd_get_target	function
(	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
->	O
owner	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: different object file formats composing set %s\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
return	O
;	O
}	O
}	O
e	pointer
=	O
(	O
struct	O
set_element	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
set_element	struct
)	O
)	O
;	O
e	pointer
->	O
u	union
.	O
next	pointer
=	O
NULL	O
;	O
e	pointer
->	O
name	pointer
=	O
name	pointer
;	O
e	pointer
->	O
section	pointer
=	O
section	pointer
;	O
e	pointer
->	O
value	long
=	O
value	long
;	O
for	O
(	O
epp	pointer
=	O
&	O
p	pointer
->	O
elements	pointer
;	O
*	O
epp	pointer
!=	O
NULL	O
;	O
epp	pointer
=	O
&	O
(	O
*	O
epp	pointer
)	O
->	O
u	union
.	O
next	pointer
)	O
;	O
*	O
epp	pointer
=	O
e	pointer
;	O
++	O
p	pointer
->	O
count	int
;	O
}	O
static	O
int	O
ctor_prio	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
while	O
(	O
*	O
name	pointer
==	O
'_'	O
)	O
++	O
name	pointer
;	O
if	O
(	O
!	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
"GLOBAL_"	pointer
)	O
)	O
return	O
-	O
1	int
;	O
name	pointer
+=	O
sizeof	O
"GLOBAL_"	pointer
-	O
1	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
!=	O
name	pointer
[	O
2	int
]	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
name	pointer
[	O
1	int
]	O
!=	O
'I'	O
&&	O
name	pointer
[	O
1	int
]	O
!=	O
'D'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
name	pointer
[	O
3	int
]	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
atoi	function
(	O
name	pointer
+	O
3	int
)	O
;	O
}	O
static	O
int	O
ctor_cmp	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
const	O
struct	O
set_element	struct
*	O
pe1	pointer
=	O
*	O
(	O
const	O
struct	O
set_element	struct
*	O
*	O
)	O
p1	pointer
;	O
const	O
struct	O
set_element	struct
*	O
pe2	pointer
=	O
*	O
(	O
const	O
struct	O
set_element	struct
*	O
*	O
)	O
p2	pointer
;	O
const	O
char	O
*	O
n1	pointer
;	O
const	O
char	O
*	O
n2	pointer
;	O
int	O
prio1	int
;	O
int	O
prio2	int
;	O
n1	pointer
=	O
pe1	pointer
->	O
name	pointer
;	O
if	O
(	O
n1	pointer
==	O
NULL	O
)	O
n1	pointer
=	O
""	pointer
;	O
n2	pointer
=	O
pe2	pointer
->	O
name	pointer
;	O
if	O
(	O
n2	pointer
==	O
NULL	O
)	O
n2	pointer
=	O
""	pointer
;	O
prio1	int
=	O
ctor_prio	function
(	O
n1	pointer
)	O
;	O
prio2	int
=	O
ctor_prio	function
(	O
n2	pointer
)	O
;	O
if	O
(	O
prio1	int
<	O
prio2	int
)	O
return	O
1	int
;	O
if	O
(	O
prio1	int
>	O
prio2	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pe1	pointer
->	O
u	union
.	O
idx	long
<	O
pe2	pointer
->	O
u	union
.	O
idx	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pe1	pointer
->	O
u	union
.	O
idx	long
>	O
pe2	pointer
->	O
u	union
.	O
idx	long
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
ldctor_build_sets	function
(	O
void	O
)	O
{	O
static	O
bfd_boolean	int
called	int
;	O
bfd_boolean	int
header_printed	int
;	O
struct	O
set_info	struct
*	O
p	pointer
;	O
if	O
(	O
called	int
)	O
return	O
;	O
called	int
=	O
TRUE	int
;	O
if	O
(	O
constructors_sorted	int
)	O
{	O
for	O
(	O
p	pointer
=	O
sets	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
int	O
c	struct
,	O
i	pointer
;	O
struct	O
set_element	struct
*	O
e	pointer
,	O
*	O
enext	pointer
;	O
struct	O
set_element	struct
*	O
*	O
array	pointer
;	O
if	O
(	O
p	pointer
->	O
elements	pointer
==	O
NULL	O
)	O
continue	O
;	O
c	struct
=	O
0	int
;	O
for	O
(	O
e	pointer
=	O
p	pointer
->	O
elements	pointer
;	O
e	pointer
!=	O
NULL	O
;	O
e	pointer
=	O
e	pointer
->	O
u	union
.	O
next	pointer
)	O
++	O
c	struct
;	O
array	pointer
=	O
(	O
struct	O
set_element	struct
*	O
*	O
)	O
xmalloc	function
(	O
c	struct
*	O
sizeof	O
*	O
array	pointer
)	O
;	O
i	pointer
=	O
0	int
;	O
for	O
(	O
e	pointer
=	O
p	pointer
->	O
elements	pointer
;	O
e	pointer
!=	O
NULL	O
;	O
e	pointer
=	O
enext	pointer
)	O
{	O
array	pointer
[	O
i	pointer
]	O
=	O
e	pointer
;	O
enext	pointer
=	O
e	pointer
->	O
u	union
.	O
next	pointer
;	O
e	pointer
->	O
u	union
.	O
idx	long
=	O
i	pointer
;	O
++	O
i	pointer
;	O
}	O
qsort	function
(	O
array	pointer
,	O
c	struct
,	O
sizeof	O
*	O
array	pointer
,	O
ctor_cmp	function
)	O
;	O
e	pointer
=	O
array	pointer
[	O
0	int
]	O
;	O
p	pointer
->	O
elements	pointer
=	O
e	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
c	struct
-	O
1	int
;	O
i	pointer
++	O
)	O
array	pointer
[	O
i	pointer
]	O
->	O
u	union
.	O
next	pointer
=	O
array	pointer
[	O
i	pointer
+	O
1	int
]	O
;	O
array	pointer
[	O
i	pointer
]	O
->	O
u	union
.	O
next	pointer
=	O
NULL	O
;	O
free	function
(	O
array	pointer
)	O
;	O
}	O
}	O
lang_list_init	function
(	O
&	O
constructor_list	struct
)	O
;	O
push_stat_ptr	function
(	O
&	O
constructor_list	struct
)	O
;	O
header_printed	int
=	O
FALSE	int
;	O
for	O
(	O
p	pointer
=	O
sets	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
struct	O
set_element	struct
*	O
e	pointer
;	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
int	O
reloc_size	int
,	O
size	int
;	O
if	O
(	O
p	pointer
->	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
p	pointer
->	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
continue	O
;	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
p	pointer
->	O
reloc	enum
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %s does not support reloc %s for set %s\n"	pointer
)	O
,	O
bfd_get_target	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
,	O
bfd_get_reloc_code_name	function
(	O
p	pointer
->	O
reloc	enum
)	O
,	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
)	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
->	O
owner	pointer
,	O
p	pointer
->	O
reloc	enum
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
->	O
owner	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: special section %s does not support reloc %s for set %s\n"	pointer
)	O
,	O
bfd_section_name	function
(	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
)	O
,	O
bfd_get_reloc_code_name	function
(	O
p	pointer
->	O
reloc	enum
)	O
,	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %s does not support reloc %s for set %s\n"	pointer
)	O
,	O
bfd_get_target	function
(	O
p	pointer
->	O
elements	pointer
->	O
section	pointer
->	O
owner	pointer
)	O
,	O
bfd_get_reloc_code_name	function
(	O
p	pointer
->	O
reloc	enum
)	O
,	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
reloc_size	int
=	O
bfd_get_reloc_size	function
(	O
howto	pointer
)	O
;	O
switch	O
(	O
reloc_size	int
)	O
{	O
case	O
1	int
:	O
size	int
=	O
BYTE	int
;	O
break	O
;	O
case	O
2	int
:	O
size	int
=	O
SHORT	int
;	O
break	O
;	O
case	O
4	int
:	O
size	int
=	O
LONG	int
;	O
break	O
;	O
case	O
8	int
:	O
if	O
(	O
howto	pointer
->	O
complain_on_overflow	enum
==	O
complain_overflow_signed	int
)	O
size	int
=	O
SQUAD	int
;	O
else	O
size	int
=	O
QUAD	int
;	O
break	O
;	O
default	O
:	O
einfo	pointer
(	O
_	O
(	O
"%X%P: unsupported size %d for set %s\n"	pointer
)	O
,	O
bfd_get_reloc_size	function
(	O
howto	pointer
)	O
,	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
size	int
=	O
LONG	int
;	O
break	O
;	O
}	O
lang_add_assignment	function
(	O
exp_assign	function
(	O
"."	pointer
,	O
exp_unop	function
(	O
ALIGN_K	int
,	O
exp_intop	function
(	O
reloc_size	int
)	O
)	O
,	O
FALSE	int
)	O
)	O
;	O
lang_add_assignment	function
(	O
exp_assign	function
(	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
,	O
exp_nameop	function
(	O
NAME	int
,	O
"."	pointer
)	O
,	O
FALSE	int
)	O
)	O
;	O
lang_add_data	function
(	O
size	int
,	O
exp_intop	function
(	O
p	pointer
->	O
count	int
)	O
)	O
;	O
for	O
(	O
e	pointer
=	O
p	pointer
->	O
elements	pointer
;	O
e	pointer
!=	O
NULL	O
;	O
e	pointer
=	O
e	pointer
->	O
u	union
.	O
next	pointer
)	O
{	O
if	O
(	O
config	struct
.	O
map_file	pointer
!=	O
NULL	O
)	O
{	O
int	O
len	long
;	O
if	O
(	O
!	O
header_printed	int
)	O
{	O
minfo	pointer
(	O
_	O
(	O
"\nSet                 Symbol\n\n"	pointer
)	O
)	O
;	O
header_printed	int
=	O
TRUE	int
;	O
}	O
minfo	pointer
(	O
"%s"	pointer
,	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
p	pointer
->	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
if	O
(	O
len	long
>=	O
19	int
)	O
{	O
print_nl	function
(	O
)	O
;	O
len	long
=	O
0	int
;	O
}	O
while	O
(	O
len	long
<	O
20	int
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
if	O
(	O
e	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
"%pT\n"	pointer
,	O
e	pointer
->	O
name	pointer
)	O
;	O
else	O
minfo	pointer
(	O
"%G\n"	pointer
,	O
e	pointer
->	O
section	pointer
->	O
owner	pointer
,	O
e	pointer
->	O
section	pointer
,	O
e	pointer
->	O
value	long
)	O
;	O
}	O
if	O
(	O
!	O
bfd_is_abs_section	function
(	O
e	pointer
->	O
section	pointer
)	O
)	O
e	pointer
->	O
section	pointer
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
lang_add_reloc	function
(	O
p	pointer
->	O
reloc	enum
,	O
howto	pointer
,	O
e	pointer
->	O
section	pointer
,	O
e	pointer
->	O
name	pointer
,	O
exp_intop	function
(	O
e	pointer
->	O
value	long
)	O
)	O
;	O
else	O
lang_add_data	function
(	O
size	int
,	O
exp_relop	function
(	O
e	pointer
->	O
section	pointer
,	O
e	pointer
->	O
value	long
)	O
)	O
;	O
}	O
lang_add_data	function
(	O
size	int
,	O
exp_intop	function
(	O
0	int
)	O
)	O
;	O
}	O
pop_stat_ptr	function
(	O
)	O
;	O
}	O
