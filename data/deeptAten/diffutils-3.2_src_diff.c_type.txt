struct	O
regexp_list	struct
{	O
char	O
*	O
regexps	pointer
;	O
size_t	long
len	long
;	O
size_t	long
size	long
;	O
bool	bool
multiple_regexps	bool
;	O
struct	O
re_pattern_buffer	struct
*	O
buf	pointer
;	O
}	O
;	O
static	O
int	O
compare_files	function
(	O
struct	O
comparison	struct
const	O
*	O
,	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
add_regexp	function
(	O
struct	O
regexp_list	struct
*	O
,	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
summarize_regexp_list	function
(	O
struct	O
regexp_list	struct
*	O
)	O
;	O
static	O
void	O
specify_style	function
(	O
enum	O
output_style	enum
)	O
;	O
static	O
void	O
specify_value	function
(	O
char	O
const	O
*	O
*	O
,	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
try_help	function
(	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
check_stdout	function
(	O
void	O
)	O
;	O
static	O
void	O
usage	function
(	O
void	O
)	O
;	O
static	O
bool	bool
recursive	bool
;	O
static	O
struct	O
regexp_list	struct
function_regexp_list	struct
;	O
static	O
struct	O
regexp_list	struct
ignore_regexp_list	struct
;	O
enum	O
{	O
binary	int
=	O
true	int
}	O
;	O
static	O
bool	bool
new_file	bool
;	O
static	O
bool	bool
unidirectional_new_file	bool
;	O
static	O
bool	bool
report_identical_files	bool
;	O
static	O
char	O
const	O
shortopts	array
[	O
]	O
=	O
"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:yZ"	pointer
;	O
enum	O
{	O
BINARY_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
FROM_FILE_OPTION	int
,	O
HELP_OPTION	int
,	O
HORIZON_LINES_OPTION	int
,	O
IGNORE_FILE_NAME_CASE_OPTION	int
,	O
INHIBIT_HUNK_MERGE_OPTION	int
,	O
LEFT_COLUMN_OPTION	int
,	O
LINE_FORMAT_OPTION	int
,	O
NO_IGNORE_FILE_NAME_CASE_OPTION	int
,	O
NORMAL_OPTION	int
,	O
SDIFF_MERGE_ASSIST_OPTION	int
,	O
STRIP_TRAILING_CR_OPTION	int
,	O
SUPPRESS_BLANK_EMPTY_OPTION	int
,	O
SUPPRESS_COMMON_LINES_OPTION	int
,	O
TABSIZE_OPTION	int
,	O
TO_FILE_OPTION	int
,	O
UNCHANGED_LINE_FORMAT_OPTION	int
,	O
OLD_LINE_FORMAT_OPTION	int
,	O
NEW_LINE_FORMAT_OPTION	int
,	O
UNCHANGED_GROUP_FORMAT_OPTION	int
,	O
OLD_GROUP_FORMAT_OPTION	int
,	O
NEW_GROUP_FORMAT_OPTION	int
,	O
CHANGED_GROUP_FORMAT_OPTION	int
}	O
;	O
static	O
char	O
const	O
group_format_option	array
[	O
]	O
[	O
sizeof	O
"--unchanged-group-format"	pointer
]	O
=	O
{	O
"--unchanged-group-format"	pointer
,	O
"--old-group-format"	pointer
,	O
"--new-group-format"	pointer
,	O
"--changed-group-format"	pointer
}	O
;	O
static	O
char	O
const	O
line_format_option	array
[	O
]	O
[	O
sizeof	O
"--unchanged-line-format"	pointer
]	O
=	O
{	O
"--unchanged-line-format"	pointer
,	O
"--old-line-format"	pointer
,	O
"--new-line-format"	pointer
}	O
;	O
static	O
struct	O
option	struct
const	O
longopts	array
[	O
]	O
=	O
{	O
{	O
"binary"	pointer
,	O
0	int
,	O
0	int
,	O
BINARY_OPTION	int
}	O
,	O
{	O
"brief"	pointer
,	O
0	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"changed-group-format"	pointer
,	O
1	int
,	O
0	int
,	O
CHANGED_GROUP_FORMAT_OPTION	int
}	O
,	O
{	O
"context"	pointer
,	O
2	int
,	O
0	int
,	O
'C'	O
}	O
,	O
{	O
"ed"	pointer
,	O
0	int
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"exclude"	pointer
,	O
1	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"exclude-from"	pointer
,	O
1	int
,	O
0	int
,	O
'X'	O
}	O
,	O
{	O
"expand-tabs"	pointer
,	O
0	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"forward-ed"	pointer
,	O
0	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"from-file"	pointer
,	O
1	int
,	O
0	int
,	O
FROM_FILE_OPTION	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
HELP_OPTION	int
}	O
,	O
{	O
"horizon-lines"	pointer
,	O
1	int
,	O
0	int
,	O
HORIZON_LINES_OPTION	int
}	O
,	O
{	O
"ifdef"	pointer
,	O
1	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"ignore-all-space"	pointer
,	O
0	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"ignore-blank-lines"	pointer
,	O
0	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"ignore-case"	pointer
,	O
0	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"ignore-file-name-case"	pointer
,	O
0	int
,	O
0	int
,	O
IGNORE_FILE_NAME_CASE_OPTION	int
}	O
,	O
{	O
"ignore-matching-lines"	pointer
,	O
1	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"ignore-space-change"	pointer
,	O
0	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"ignore-tab-expansion"	pointer
,	O
0	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"ignore-trailing-space"	pointer
,	O
0	int
,	O
0	int
,	O
'Z'	O
}	O
,	O
{	O
"inhibit-hunk-merge"	pointer
,	O
0	int
,	O
0	int
,	O
INHIBIT_HUNK_MERGE_OPTION	int
}	O
,	O
{	O
"initial-tab"	pointer
,	O
0	int
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"label"	pointer
,	O
1	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"left-column"	pointer
,	O
0	int
,	O
0	int
,	O
LEFT_COLUMN_OPTION	int
}	O
,	O
{	O
"line-format"	pointer
,	O
1	int
,	O
0	int
,	O
LINE_FORMAT_OPTION	int
}	O
,	O
{	O
"minimal"	pointer
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"new-file"	pointer
,	O
0	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"new-group-format"	pointer
,	O
1	int
,	O
0	int
,	O
NEW_GROUP_FORMAT_OPTION	int
}	O
,	O
{	O
"new-line-format"	pointer
,	O
1	int
,	O
0	int
,	O
NEW_LINE_FORMAT_OPTION	int
}	O
,	O
{	O
"no-ignore-file-name-case"	pointer
,	O
0	int
,	O
0	int
,	O
NO_IGNORE_FILE_NAME_CASE_OPTION	int
}	O
,	O
{	O
"normal"	pointer
,	O
0	int
,	O
0	int
,	O
NORMAL_OPTION	int
}	O
,	O
{	O
"old-group-format"	pointer
,	O
1	int
,	O
0	int
,	O
OLD_GROUP_FORMAT_OPTION	int
}	O
,	O
{	O
"old-line-format"	pointer
,	O
1	int
,	O
0	int
,	O
OLD_LINE_FORMAT_OPTION	int
}	O
,	O
{	O
"paginate"	pointer
,	O
0	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"rcs"	pointer
,	O
0	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"recursive"	pointer
,	O
0	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"report-identical-files"	pointer
,	O
0	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"sdiff-merge-assist"	pointer
,	O
0	int
,	O
0	int
,	O
SDIFF_MERGE_ASSIST_OPTION	int
}	O
,	O
{	O
"show-c-function"	pointer
,	O
0	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"show-function-line"	pointer
,	O
1	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"side-by-side"	pointer
,	O
0	int
,	O
0	int
,	O
'y'	O
}	O
,	O
{	O
"speed-large-files"	pointer
,	O
0	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"starting-file"	pointer
,	O
1	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"strip-trailing-cr"	pointer
,	O
0	int
,	O
0	int
,	O
STRIP_TRAILING_CR_OPTION	int
}	O
,	O
{	O
"suppress-blank-empty"	pointer
,	O
0	int
,	O
0	int
,	O
SUPPRESS_BLANK_EMPTY_OPTION	int
}	O
,	O
{	O
"suppress-common-lines"	pointer
,	O
0	int
,	O
0	int
,	O
SUPPRESS_COMMON_LINES_OPTION	int
}	O
,	O
{	O
"tabsize"	pointer
,	O
1	int
,	O
0	int
,	O
TABSIZE_OPTION	int
}	O
,	O
{	O
"text"	pointer
,	O
0	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"to-file"	pointer
,	O
1	int
,	O
0	int
,	O
TO_FILE_OPTION	int
}	O
,	O
{	O
"unchanged-group-format"	pointer
,	O
1	int
,	O
0	int
,	O
UNCHANGED_GROUP_FORMAT_OPTION	int
}	O
,	O
{	O
"unchanged-line-format"	pointer
,	O
1	int
,	O
0	int
,	O
UNCHANGED_LINE_FORMAT_OPTION	int
}	O
,	O
{	O
"unidirectional-new-file"	pointer
,	O
0	int
,	O
0	int
,	O
'P'	O
}	O
,	O
{	O
"unified"	pointer
,	O
2	int
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"width"	pointer
,	O
1	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
char	O
*	O
option_list	function
(	O
char	O
*	O
*	O
optionvec	pointer
,	O
int	O
count	int
)	O
{	O
int	O
i	int
;	O
size_t	long
size	long
=	O
1	int
;	O
char	O
*	O
result	pointer
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
size	long
+=	O
1	int
+	O
shell_quote_length	function
(	O
optionvec	pointer
[	O
i	int
]	O
)	O
;	O
p	pointer
=	O
result	pointer
=	O
xmalloc	function
(	O
size	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
p	pointer
=	O
shell_quote_copy	function
(	O
p	pointer
,	O
optionvec	pointer
[	O
i	int
]	O
)	O
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
result	pointer
;	O
}	O
static	O
int	O
exclude_options	function
(	O
void	O
)	O
{	O
return	O
EXCLUDE_WILDCARDS	O
|	O
(	O
ignore_file_name_case	bool
?	O
FNM_CASEFOLD	O
:	O
0	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
exit_status	int
=	O
EXIT_SUCCESS	int
;	O
int	O
c	int
;	O
int	O
i	int
;	O
int	O
prev	int
=	O
-	O
1	int
;	O
lin	long
ocontext	long
=	O
-	O
1	int
;	O
bool	bool
explicit_context	bool
=	O
false	int
;	O
size_t	long
width	long
=	O
0	int
;	O
bool	bool
show_c_function	bool
=	O
false	int
;	O
char	O
const	O
*	O
from_file	pointer
=	O
NULL	O
;	O
char	O
const	O
*	O
to_file	pointer
=	O
NULL	O
;	O
uintmax_t	long
numval	long
;	O
char	O
*	O
numend	pointer
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
initialize_main	O
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	pointer
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
c_stack_action	function
(	O
0	int
)	O
;	O
function_regexp_list	struct
.	O
buf	pointer
=	O
&	O
function_regexp	struct
;	O
ignore_regexp_list	struct
.	O
buf	pointer
=	O
&	O
ignore_regexp	struct
;	O
re_set_syntax	function
(	O
RE_SYNTAX_GREP	O
|	O
RE_NO_POSIX_BACKTRACKING	O
)	O
;	O
excluded	pointer
=	O
new_exclude	function
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
shortopts	array
,	O
longopts	array
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
!	O
ISDIGIT	O
(	O
prev	int
)	O
)	O
ocontext	long
=	O
c	int
-	O
'0'	O
;	O
else	O
if	O
(	O
LIN_MAX	O
/	O
10	int
<	O
ocontext	long
||	O
(	O
(	O
ocontext	long
=	O
10	int
*	O
ocontext	long
+	O
c	int
-	O
'0'	O
)	O
<	O
0	int
)	O
)	O
ocontext	long
=	O
LIN_MAX	O
;	O
break	O
;	O
case	O
'a'	O
:	O
text	bool
=	O
true	int
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
ignore_white_space	enum
<	O
IGNORE_SPACE_CHANGE	int
)	O
ignore_white_space	enum
=	O
IGNORE_SPACE_CHANGE	int
;	O
break	O
;	O
case	O
'Z'	O
:	O
if	O
(	O
ignore_white_space	enum
<	O
IGNORE_SPACE_CHANGE	int
)	O
ignore_white_space	enum
|=	O
IGNORE_TRAILING_SPACE	int
;	O
break	O
;	O
case	O
'B'	O
:	O
ignore_blank_lines	bool
=	O
true	int
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'U'	O
:	O
{	O
if	O
(	O
optarg	pointer
)	O
{	O
numval	long
=	O
strtoumax	function
(	O
optarg	pointer
,	O
&	O
numend	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
numend	pointer
)	O
try_help	function
(	O
"invalid context length `%s'"	pointer
,	O
optarg	pointer
)	O
;	O
if	O
(	O
LIN_MAX	O
<	O
numval	long
)	O
numval	long
=	O
LIN_MAX	O
;	O
}	O
else	O
numval	long
=	O
3	int
;	O
specify_style	function
(	O
c	int
==	O
'U'	O
?	O
OUTPUT_UNIFIED	int
:	O
OUTPUT_CONTEXT	int
)	O
;	O
if	O
(	O
context	long
<	O
numval	long
)	O
context	long
=	O
numval	long
;	O
explicit_context	bool
=	O
true	int
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
specify_style	function
(	O
OUTPUT_CONTEXT	int
)	O
;	O
if	O
(	O
context	long
<	O
3	int
)	O
context	long
=	O
3	int
;	O
break	O
;	O
case	O
'd'	O
:	O
minimal	bool
=	O
true	int
;	O
break	O
;	O
case	O
'D'	O
:	O
specify_style	function
(	O
OUTPUT_IFDEF	int
)	O
;	O
{	O
static	O
char	O
const	O
C_ifdef_group_formats	array
[	O
]	O
=	O
"%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n"	pointer
;	O
char	O
*	O
b	struct
=	O
xmalloc	function
(	O
sizeof	O
C_ifdef_group_formats	array
+	O
7	int
*	O
strlen	function
(	O
optarg	pointer
)	O
-	O
14	int
-	O
8	int
)	O
;	O
sprintf	function
(	O
b	struct
,	O
C_ifdef_group_formats	array
,	O
0	int
,	O
optarg	pointer
,	O
optarg	pointer
,	O
0	int
,	O
optarg	pointer
,	O
optarg	pointer
,	O
0	int
,	O
optarg	pointer
,	O
optarg	pointer
,	O
optarg	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
group_format	array
/	O
sizeof	O
group_format	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
{	O
specify_value	function
(	O
&	O
group_format	array
[	O
i	int
]	O
,	O
b	struct
,	O
"-D"	pointer
)	O
;	O
b	struct
+=	O
strlen	function
(	O
b	struct
)	O
+	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
'e'	O
:	O
specify_style	function
(	O
OUTPUT_ED	int
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
if	O
(	O
ignore_white_space	enum
<	O
IGNORE_SPACE_CHANGE	int
)	O
ignore_white_space	enum
|=	O
IGNORE_TAB_EXPANSION	int
;	O
break	O
;	O
case	O
'f'	O
:	O
specify_style	function
(	O
OUTPUT_FORWARD_ED	int
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
add_regexp	function
(	O
&	O
function_regexp_list	struct
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
break	O
;	O
case	O
'H'	O
:	O
speed_large_files	bool
=	O
true	int
;	O
break	O
;	O
case	O
'i'	O
:	O
ignore_case	bool
=	O
true	int
;	O
break	O
;	O
case	O
'I'	O
:	O
add_regexp	function
(	O
&	O
ignore_regexp_list	struct
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
!	O
pr_program	array
[	O
0	int
]	O
)	O
try_help	function
(	O
"pagination not supported on this host"	pointer
,	O
NULL	O
)	O
;	O
paginate	bool
=	O
true	int
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
if	O
(	O
!	O
file_label	array
[	O
0	int
]	O
)	O
file_label	array
[	O
0	int
]	O
=	O
optarg	pointer
;	O
else	O
if	O
(	O
!	O
file_label	array
[	O
1	int
]	O
)	O
file_label	array
[	O
1	int
]	O
=	O
optarg	pointer
;	O
else	O
fatal	function
(	O
"too many file label options"	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
specify_style	function
(	O
OUTPUT_RCS	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
new_file	bool
=	O
true	int
;	O
break	O
;	O
case	O
'p'	O
:	O
show_c_function	bool
=	O
true	int
;	O
add_regexp	function
(	O
&	O
function_regexp_list	struct
,	O
"^[[:alpha:]$_]"	pointer
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
unidirectional_new_file	bool
=	O
true	int
;	O
break	O
;	O
case	O
'q'	O
:	O
brief	bool
=	O
true	int
;	O
break	O
;	O
case	O
'r'	O
:	O
recursive	bool
=	O
true	int
;	O
break	O
;	O
case	O
's'	O
:	O
report_identical_files	bool
=	O
true	int
;	O
break	O
;	O
case	O
'S'	O
:	O
specify_value	function
(	O
&	O
starting_file	pointer
,	O
optarg	pointer
,	O
"-S"	pointer
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
expand_tabs	bool
=	O
true	int
;	O
break	O
;	O
case	O
'T'	O
:	O
initial_tab	bool
=	O
true	int
;	O
break	O
;	O
case	O
'u'	O
:	O
specify_style	function
(	O
OUTPUT_UNIFIED	int
)	O
;	O
if	O
(	O
context	long
<	O
3	int
)	O
context	long
=	O
3	int
;	O
break	O
;	O
case	O
'v'	O
:	O
version_etc	function
(	O
stdout	pointer
,	O
PROGRAM_NAME	pointer
,	O
PACKAGE_NAME	pointer
,	O
Version	pointer
,	O
AUTHORS	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
check_stdout	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
'w'	O
:	O
ignore_white_space	enum
=	O
IGNORE_ALL_SPACE	int
;	O
break	O
;	O
case	O
'x'	O
:	O
add_exclude	function
(	O
excluded	pointer
,	O
optarg	pointer
,	O
exclude_options	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
add_exclude_file	function
(	O
add_exclude	function
,	O
excluded	pointer
,	O
optarg	pointer
,	O
exclude_options	function
(	O
)	O
,	O
'\n'	O
)	O
)	O
pfatal_with_name	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
specify_style	function
(	O
OUTPUT_SDIFF	int
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
numval	long
=	O
strtoumax	function
(	O
optarg	pointer
,	O
&	O
numend	pointer
,	O
10	int
)	O
;	O
if	O
(	O
!	O
(	O
0	int
<	O
numval	long
&&	O
numval	long
<=	O
SIZE_MAX	O
)	O
||	O
*	O
numend	pointer
)	O
try_help	function
(	O
"invalid width `%s'"	pointer
,	O
optarg	pointer
)	O
;	O
if	O
(	O
width	long
!=	O
numval	long
)	O
{	O
if	O
(	O
width	long
)	O
fatal	function
(	O
"conflicting width options"	pointer
)	O
;	O
width	long
=	O
numval	long
;	O
}	O
break	O
;	O
case	O
BINARY_OPTION	int
:	O
break	O
;	O
case	O
FROM_FILE_OPTION	int
:	O
specify_value	function
(	O
&	O
from_file	pointer
,	O
optarg	pointer
,	O
"--from-file"	pointer
)	O
;	O
break	O
;	O
case	O
HELP_OPTION	int
:	O
usage	function
(	O
)	O
;	O
check_stdout	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
HORIZON_LINES_OPTION	int
:	O
numval	long
=	O
strtoumax	function
(	O
optarg	pointer
,	O
&	O
numend	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
numend	pointer
)	O
try_help	function
(	O
"invalid horizon length `%s'"	pointer
,	O
optarg	pointer
)	O
;	O
horizon_lines	long
=	O
MAX	O
(	O
horizon_lines	long
,	O
MIN	O
(	O
numval	long
,	O
LIN_MAX	O
)	O
)	O
;	O
break	O
;	O
case	O
IGNORE_FILE_NAME_CASE_OPTION	int
:	O
ignore_file_name_case	bool
=	O
true	int
;	O
break	O
;	O
case	O
INHIBIT_HUNK_MERGE_OPTION	int
:	O
break	O
;	O
case	O
LEFT_COLUMN_OPTION	int
:	O
left_column	bool
=	O
true	int
;	O
break	O
;	O
case	O
LINE_FORMAT_OPTION	int
:	O
specify_style	function
(	O
OUTPUT_IFDEF	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
line_format	array
/	O
sizeof	O
line_format	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
specify_value	function
(	O
&	O
line_format	array
[	O
i	int
]	O
,	O
optarg	pointer
,	O
"--line-format"	pointer
)	O
;	O
break	O
;	O
case	O
NO_IGNORE_FILE_NAME_CASE_OPTION	int
:	O
ignore_file_name_case	bool
=	O
false	int
;	O
break	O
;	O
case	O
NORMAL_OPTION	int
:	O
specify_style	function
(	O
OUTPUT_NORMAL	int
)	O
;	O
break	O
;	O
case	O
SDIFF_MERGE_ASSIST_OPTION	int
:	O
specify_style	function
(	O
OUTPUT_SDIFF	int
)	O
;	O
sdiff_merge_assist	bool
=	O
true	int
;	O
break	O
;	O
case	O
STRIP_TRAILING_CR_OPTION	int
:	O
strip_trailing_cr	bool
=	O
true	int
;	O
break	O
;	O
case	O
SUPPRESS_BLANK_EMPTY_OPTION	int
:	O
suppress_blank_empty	bool
=	O
true	int
;	O
break	O
;	O
case	O
SUPPRESS_COMMON_LINES_OPTION	int
:	O
suppress_common_lines	bool
=	O
true	int
;	O
break	O
;	O
case	O
TABSIZE_OPTION	int
:	O
numval	long
=	O
strtoumax	function
(	O
optarg	pointer
,	O
&	O
numend	pointer
,	O
10	int
)	O
;	O
if	O
(	O
!	O
(	O
0	int
<	O
numval	long
&&	O
numval	long
<=	O
SIZE_MAX	O
)	O
||	O
*	O
numend	pointer
)	O
try_help	function
(	O
"invalid tabsize `%s'"	pointer
,	O
optarg	pointer
)	O
;	O
if	O
(	O
tabsize	long
!=	O
numval	long
)	O
{	O
if	O
(	O
tabsize	long
)	O
fatal	function
(	O
"conflicting tabsize options"	pointer
)	O
;	O
tabsize	long
=	O
numval	long
;	O
}	O
break	O
;	O
case	O
TO_FILE_OPTION	int
:	O
specify_value	function
(	O
&	O
to_file	pointer
,	O
optarg	pointer
,	O
"--to-file"	pointer
)	O
;	O
break	O
;	O
case	O
UNCHANGED_LINE_FORMAT_OPTION	int
:	O
case	O
OLD_LINE_FORMAT_OPTION	int
:	O
case	O
NEW_LINE_FORMAT_OPTION	int
:	O
specify_style	function
(	O
OUTPUT_IFDEF	int
)	O
;	O
c	int
-=	O
UNCHANGED_LINE_FORMAT_OPTION	int
;	O
specify_value	function
(	O
&	O
line_format	array
[	O
c	int
]	O
,	O
optarg	pointer
,	O
line_format_option	array
[	O
c	int
]	O
)	O
;	O
break	O
;	O
case	O
UNCHANGED_GROUP_FORMAT_OPTION	int
:	O
case	O
OLD_GROUP_FORMAT_OPTION	int
:	O
case	O
NEW_GROUP_FORMAT_OPTION	int
:	O
case	O
CHANGED_GROUP_FORMAT_OPTION	int
:	O
specify_style	function
(	O
OUTPUT_IFDEF	int
)	O
;	O
c	int
-=	O
UNCHANGED_GROUP_FORMAT_OPTION	int
;	O
specify_value	function
(	O
&	O
group_format	array
[	O
c	int
]	O
,	O
optarg	pointer
,	O
group_format_option	array
[	O
c	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
try_help	function
(	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
prev	int
=	O
c	int
;	O
}	O
if	O
(	O
output_style	enum
==	O
OUTPUT_UNSPECIFIED	int
)	O
{	O
if	O
(	O
show_c_function	bool
)	O
{	O
specify_style	function
(	O
OUTPUT_CONTEXT	int
)	O
;	O
if	O
(	O
ocontext	long
<	O
0	int
)	O
context	long
=	O
3	int
;	O
}	O
else	O
specify_style	function
(	O
OUTPUT_NORMAL	int
)	O
;	O
}	O
if	O
(	O
output_style	enum
!=	O
OUTPUT_CONTEXT	int
||	O
hard_locale	function
(	O
LC_TIME	O
)	O
)	O
{	O
time_format	pointer
=	O
"%Y-%m-%d %H:%M:%S.%N %z"	pointer
;	O
}	O
else	O
{	O
time_format	pointer
=	O
"%a %b %e %T %Y"	pointer
;	O
}	O
if	O
(	O
0	int
<=	O
ocontext	long
&&	O
(	O
output_style	enum
==	O
OUTPUT_CONTEXT	int
||	O
output_style	enum
==	O
OUTPUT_UNIFIED	int
)	O
&&	O
(	O
context	long
<	O
ocontext	long
||	O
(	O
ocontext	long
<	O
context	long
&&	O
!	O
explicit_context	bool
)	O
)	O
)	O
context	long
=	O
ocontext	long
;	O
if	O
(	O
!	O
tabsize	long
)	O
tabsize	long
=	O
8	int
;	O
if	O
(	O
!	O
width	long
)	O
width	long
=	O
130	int
;	O
{	O
intmax_t	long
t	struct
=	O
expand_tabs	bool
?	O
1	int
:	O
tabsize	long
;	O
intmax_t	long
w	long
=	O
width	long
;	O
intmax_t	long
off	long
=	O
(	O
w	long
+	O
t	struct
+	O
GUTTER_WIDTH_MINIMUM	int
)	O
/	O
(	O
2	int
*	O
t	struct
)	O
*	O
t	struct
;	O
sdiff_half_width	long
=	O
MAX	O
(	O
0	int
,	O
MIN	O
(	O
off	long
-	O
GUTTER_WIDTH_MINIMUM	int
,	O
w	long
-	O
off	long
)	O
)	O
,	O
sdiff_column2_offset	long
=	O
sdiff_half_width	long
?	O
off	long
:	O
w	long
;	O
}	O
if	O
(	O
horizon_lines	long
<	O
context	long
)	O
horizon_lines	long
=	O
context	long
;	O
summarize_regexp_list	function
(	O
&	O
function_regexp_list	struct
)	O
;	O
summarize_regexp_list	function
(	O
&	O
ignore_regexp_list	struct
)	O
;	O
if	O
(	O
output_style	enum
==	O
OUTPUT_IFDEF	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
line_format	array
/	O
sizeof	O
line_format	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
line_format	array
[	O
i	int
]	O
)	O
line_format	array
[	O
i	int
]	O
=	O
"%l\n"	pointer
;	O
if	O
(	O
!	O
group_format	array
[	O
OLD	int
]	O
)	O
group_format	array
[	O
OLD	int
]	O
=	O
group_format	array
[	O
CHANGED	int
]	O
?	O
group_format	array
[	O
CHANGED	int
]	O
:	O
"%<"	pointer
;	O
if	O
(	O
!	O
group_format	array
[	O
NEW	int
]	O
)	O
group_format	array
[	O
NEW	int
]	O
=	O
group_format	array
[	O
CHANGED	int
]	O
?	O
group_format	array
[	O
CHANGED	int
]	O
:	O
"%>"	pointer
;	O
if	O
(	O
!	O
group_format	array
[	O
UNCHANGED	int
]	O
)	O
group_format	array
[	O
UNCHANGED	int
]	O
=	O
"%="	pointer
;	O
if	O
(	O
!	O
group_format	array
[	O
CHANGED	int
]	O
)	O
group_format	array
[	O
CHANGED	int
]	O
=	O
concat	function
(	O
group_format	array
[	O
OLD	int
]	O
,	O
group_format	array
[	O
NEW	int
]	O
,	O
""	pointer
)	O
;	O
}	O
no_diff_means_no_output	bool
=	O
(	O
output_style	enum
==	O
OUTPUT_IFDEF	int
?	O
(	O
!	O
*	O
group_format	array
[	O
UNCHANGED	int
]	O
||	O
(	O
STREQ	O
(	O
group_format	array
[	O
UNCHANGED	int
]	O
,	O
"%="	pointer
)	O
&&	O
!	O
*	O
line_format	array
[	O
UNCHANGED	int
]	O
)	O
)	O
:	O
(	O
output_style	enum
!=	O
OUTPUT_SDIFF	int
)	O
|	O
suppress_common_lines	bool
)	O
;	O
files_can_be_treated_as_binary	bool
=	O
(	O
brief	bool
&	O
binary	int
&	O
~	O
(	O
ignore_blank_lines	bool
|	O
ignore_case	bool
|	O
strip_trailing_cr	bool
|	O
(	O
ignore_regexp_list	struct
.	O
regexps	pointer
||	O
ignore_white_space	enum
)	O
)	O
)	O
;	O
switch_string	pointer
=	O
option_list	function
(	O
argv	pointer
+	O
1	int
,	O
optind	int
-	O
1	int
)	O
;	O
if	O
(	O
from_file	pointer
)	O
{	O
if	O
(	O
to_file	pointer
)	O
fatal	function
(	O
"--from-file and --to-file both specified"	pointer
)	O
;	O
else	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
int	O
status	int
=	O
compare_files	function
(	O
NULL	O
,	O
from_file	pointer
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
if	O
(	O
exit_status	int
<	O
status	int
)	O
exit_status	int
=	O
status	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
to_file	pointer
)	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
int	O
status	int
=	O
compare_files	function
(	O
NULL	O
,	O
argv	pointer
[	O
optind	int
]	O
,	O
to_file	pointer
)	O
;	O
if	O
(	O
exit_status	int
<	O
status	int
)	O
exit_status	int
=	O
status	int
;	O
}	O
else	O
{	O
if	O
(	O
argc	int
-	O
optind	int
!=	O
2	int
)	O
{	O
if	O
(	O
argc	int
-	O
optind	int
<	O
2	int
)	O
try_help	function
(	O
"missing operand after `%s'"	pointer
,	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
)	O
;	O
else	O
try_help	function
(	O
"extra operand `%s'"	pointer
,	O
argv	pointer
[	O
optind	int
+	O
2	int
]	O
)	O
;	O
}	O
exit_status	int
=	O
compare_files	function
(	O
NULL	O
,	O
argv	pointer
[	O
optind	int
]	O
,	O
argv	pointer
[	O
optind	int
+	O
1	int
]	O
)	O
;	O
}	O
}	O
print_message_queue	function
(	O
)	O
;	O
check_stdout	function
(	O
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
return	O
exit_status	int
;	O
}	O
static	O
void	O
add_regexp	function
(	O
struct	O
regexp_list	struct
*	O
reglist	pointer
,	O
char	O
const	O
*	O
pattern	pointer
)	O
{	O
size_t	long
patlen	long
=	O
strlen	function
(	O
pattern	pointer
)	O
;	O
char	O
const	O
*	O
m	pointer
=	O
re_compile_pattern	function
(	O
pattern	pointer
,	O
patlen	long
,	O
reglist	pointer
->	O
buf	pointer
)	O
;	O
if	O
(	O
m	pointer
!=	O
0	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
"%s: %s"	pointer
,	O
pattern	pointer
,	O
m	pointer
)	O
;	O
else	O
{	O
char	O
*	O
regexps	pointer
=	O
reglist	pointer
->	O
regexps	pointer
;	O
size_t	long
len	long
=	O
reglist	pointer
->	O
len	long
;	O
bool	bool
multiple_regexps	bool
=	O
reglist	pointer
->	O
multiple_regexps	bool
=	O
regexps	pointer
!=	O
0	int
;	O
size_t	long
newlen	long
=	O
reglist	pointer
->	O
len	long
=	O
len	long
+	O
2	int
*	O
multiple_regexps	bool
+	O
patlen	long
;	O
size_t	long
size	long
=	O
reglist	pointer
->	O
size	long
;	O
if	O
(	O
size	long
<=	O
newlen	long
)	O
{	O
if	O
(	O
!	O
size	long
)	O
size	long
=	O
1	int
;	O
do	O
size	long
*=	O
2	int
;	O
while	O
(	O
size	long
<=	O
newlen	long
)	O
;	O
reglist	pointer
->	O
size	long
=	O
size	long
;	O
reglist	pointer
->	O
regexps	pointer
=	O
regexps	pointer
=	O
xrealloc	function
(	O
regexps	pointer
,	O
size	long
)	O
;	O
}	O
if	O
(	O
multiple_regexps	bool
)	O
{	O
regexps	pointer
[	O
len	long
++	O
]	O
=	O
'\\'	O
;	O
regexps	pointer
[	O
len	long
++	O
]	O
=	O
'|'	O
;	O
}	O
memcpy	function
(	O
regexps	pointer
+	O
len	long
,	O
pattern	pointer
,	O
patlen	long
+	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
summarize_regexp_list	function
(	O
struct	O
regexp_list	struct
*	O
reglist	pointer
)	O
{	O
if	O
(	O
reglist	pointer
->	O
regexps	pointer
)	O
{	O
reglist	pointer
->	O
buf	pointer
->	O
fastmap	pointer
=	O
xmalloc	function
(	O
1	int
<<	O
CHAR_BIT	O
)	O
;	O
if	O
(	O
reglist	pointer
->	O
multiple_regexps	bool
)	O
{	O
char	O
const	O
*	O
m	pointer
=	O
re_compile_pattern	function
(	O
reglist	pointer
->	O
regexps	pointer
,	O
reglist	pointer
->	O
len	long
,	O
reglist	pointer
->	O
buf	pointer
)	O
;	O
if	O
(	O
m	pointer
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
"%s: %s"	pointer
,	O
reglist	pointer
->	O
regexps	pointer
,	O
m	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
try_help	function
(	O
char	O
const	O
*	O
reason_msgid	pointer
,	O
char	O
const	O
*	O
operand	pointer
)	O
{	O
if	O
(	O
reason_msgid	pointer
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
reason_msgid	pointer
)	O
,	O
operand	pointer
)	O
;	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"Try `%s --help' for more information."	pointer
)	O
,	O
program_name	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
void	O
check_stdout	function
(	O
void	O
)	O
{	O
if	O
(	O
ferror	function
(	O
stdout	pointer
)	O
)	O
fatal	function
(	O
"write failed"	pointer
)	O
;	O
else	O
if	O
(	O
fclose	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
pfatal_with_name	function
(	O
_	O
(	O
"standard output"	pointer
)	O
)	O
;	O
}	O
static	O
char	O
const	O
*	O
const	O
option_help_msgid	array
[	O
]	O
=	O
{	O
N_	O
(	O
"    --normal                  output a normal diff (the default)"	pointer
)	O
,	O
N_	O
(	O
"-q, --brief                   report only when files differ"	pointer
)	O
,	O
N_	O
(	O
"-s, --report-identical-files  report when two files are the same"	pointer
)	O
,	O
N_	O
(	O
"-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context"	pointer
)	O
,	O
N_	O
(	O
"-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context"	pointer
)	O
,	O
N_	O
(	O
"-e, --ed                      output an ed script"	pointer
)	O
,	O
N_	O
(	O
"-n, --rcs                     output an RCS format diff"	pointer
)	O
,	O
N_	O
(	O
"-y, --side-by-side            output in two columns"	pointer
)	O
,	O
N_	O
(	O
"-W, --width=NUM               output at most NUM (default 130) print columns"	pointer
)	O
,	O
N_	O
(	O
"    --left-column             output only the left column of common lines"	pointer
)	O
,	O
N_	O
(	O
"    --suppress-common-lines   do not output common lines"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-p, --show-c-function         show which C function each change is in"	pointer
)	O
,	O
N_	O
(	O
"-F, --show-function-line=RE   show the most recent line matching RE"	pointer
)	O
,	O
N_	O
(	O
"    --label LABEL             use LABEL instead of file name\n"	pointer
"                                (can be repeated)"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-t, --expand-tabs             expand tabs to spaces in output"	pointer
)	O
,	O
N_	O
(	O
"-T, --initial-tab             make tabs line up by prepending a tab"	pointer
)	O
,	O
N_	O
(	O
"    --tabsize=NUM             tab stops every NUM (default 8) print columns"	pointer
)	O
,	O
N_	O
(	O
"    --suppress-blank-empty    suppress space or tab before empty output lines"	pointer
)	O
,	O
N_	O
(	O
"-l, --paginate                pass output through `pr' to paginate it"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-r, --recursive                 recursively compare any subdirectories found"	pointer
)	O
,	O
N_	O
(	O
"-N, --new-file                  treat absent files as empty"	pointer
)	O
,	O
N_	O
(	O
"    --unidirectional-new-file   treat absent first files as empty"	pointer
)	O
,	O
N_	O
(	O
"    --ignore-file-name-case     ignore case when comparing file names"	pointer
)	O
,	O
N_	O
(	O
"    --no-ignore-file-name-case  consider case when comparing file names"	pointer
)	O
,	O
N_	O
(	O
"-x, --exclude=PAT               exclude files that match PAT"	pointer
)	O
,	O
N_	O
(	O
"-X, --exclude-from=FILE         exclude files that match any pattern in FILE"	pointer
)	O
,	O
N_	O
(	O
"-S, --starting-file=FILE        start with FILE when comparing directories"	pointer
)	O
,	O
N_	O
(	O
"    --from-file=FILE1           compare FILE1 to all operands;\n"	pointer
"                                  FILE1 can be a directory"	pointer
)	O
,	O
N_	O
(	O
"    --to-file=FILE2             compare all operands to FILE2;\n"	pointer
"                                  FILE2 can be a directory"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-i, --ignore-case               ignore case differences in file contents"	pointer
)	O
,	O
N_	O
(	O
"-E, --ignore-tab-expansion      ignore changes due to tab expansion"	pointer
)	O
,	O
N_	O
(	O
"-Z, --ignore-trailing-space     ignore white space at line end"	pointer
)	O
,	O
N_	O
(	O
"-b, --ignore-space-change       ignore changes in the amount of white space"	pointer
)	O
,	O
N_	O
(	O
"-w, --ignore-all-space          ignore all white space"	pointer
)	O
,	O
N_	O
(	O
"-B, --ignore-blank-lines        ignore changes whose lines are all blank"	pointer
)	O
,	O
N_	O
(	O
"-I, --ignore-matching-lines=RE  ignore changes whose lines all match RE"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-a, --text                      treat all files as text"	pointer
)	O
,	O
N_	O
(	O
"    --strip-trailing-cr         strip trailing carriage return on input"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-D, --ifdef=NAME                output merged file with `#ifdef NAME' diffs"	pointer
)	O
,	O
N_	O
(	O
"    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"	pointer
)	O
,	O
N_	O
(	O
"    --line-format=LFMT          format all input lines with LFMT"	pointer
)	O
,	O
N_	O
(	O
"    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"	pointer
)	O
,	O
N_	O
(	O
"  These format options provide fine-grained control over the output\n"	pointer
"    of diff, generalizing -D/--ifdef."	pointer
)	O
,	O
N_	O
(	O
"  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."	pointer
)	O
,	O
N_	O
(	O
"  GFMT (only) may contain:\n    %<  lines from FILE1\n    %>  lines from FILE2\n    %=  lines common to FILE1 and FILE2\n    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n      LETTERs are as follows for new group, lower case for old group:\n        F  first line number\n        L  last line number\n        N  number of lines = L-F+1\n        E  F-1\n        M  L+1\n    %(A=B?T:E)  if A equals B then T else E"	pointer
)	O
,	O
N_	O
(	O
"  LFMT (only) may contain:\n    %L  contents of line\n    %l  contents of line, excluding any trailing newline\n    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"	pointer
)	O
,	O
N_	O
(	O
"  Both GFMT and LFMT may contain:\n    %%  %\n    %c'C'  the single character C\n    %c'\\OOO'  the character with octal code OOO\n    C    the character C (other characters represent themselves)"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"-d, --minimal            try hard to find a smaller set of changes"	pointer
)	O
,	O
N_	O
(	O
"    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix"	pointer
)	O
,	O
N_	O
(	O
"    --speed-large-files  assume large files and many scattered small changes"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"    --help               display this help and exit"	pointer
)	O
,	O
N_	O
(	O
"-v, --version            output version information and exit"	pointer
)	O
,	O
""	pointer
,	O
N_	O
(	O
"FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."	pointer
)	O
,	O
N_	O
(	O
"If --from-file or --to-file is given, there are no restrictions on FILE(s)."	pointer
)	O
,	O
N_	O
(	O
"If a FILE is `-', read standard input."	pointer
)	O
,	O
N_	O
(	O
"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."	pointer
)	O
,	O
0	int
}	O
;	O
static	O
void	O
usage	function
(	O
void	O
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	pointer
;	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... FILES\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"%s\n\n"	pointer
,	O
_	O
(	O
"Compare FILES line by line."	pointer
)	O
)	O
;	O
fputs	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
option_help_msgid	array
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
!	O
*	O
*	O
p	pointer
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
else	O
{	O
char	O
const	O
*	O
msg	pointer
=	O
_	O
(	O
*	O
p	pointer
)	O
;	O
char	O
const	O
*	O
nl	pointer
;	O
while	O
(	O
(	O
nl	pointer
=	O
strchr	function
(	O
msg	pointer
,	O
'\n'	O
)	O
)	O
)	O
{	O
int	O
msglen	int
=	O
nl	pointer
+	O
1	int
-	O
msg	pointer
;	O
printf	function
(	O
"  %.*s"	pointer
,	O
msglen	int
,	O
msg	pointer
)	O
;	O
msg	pointer
=	O
nl	pointer
+	O
1	int
;	O
}	O
printf	function
(	O
"  %s\n"	pointer
+	O
2	int
*	O
(	O
*	O
msg	pointer
!=	O
' '	O
&&	O
*	O
msg	pointer
!=	O
'-'	O
)	O
,	O
msg	pointer
)	O
;	O
}	O
}	O
emit_bug_reporting_address	function
(	O
)	O
;	O
}	O
static	O
void	O
specify_value	function
(	O
char	O
const	O
*	O
*	O
var	pointer
,	O
char	O
const	O
*	O
value	pointer
,	O
char	O
const	O
*	O
option	struct
)	O
{	O
if	O
(	O
*	O
var	pointer
&&	O
!	O
STREQ	O
(	O
*	O
var	pointer
,	O
value	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"conflicting %s option value `%s'"	pointer
)	O
,	O
option	struct
,	O
value	pointer
)	O
;	O
try_help	function
(	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
*	O
var	pointer
=	O
value	pointer
;	O
}	O
static	O
void	O
specify_style	function
(	O
enum	O
output_style	enum
style	enum
)	O
{	O
if	O
(	O
output_style	enum
!=	O
style	enum
)	O
{	O
if	O
(	O
output_style	enum
!=	O
OUTPUT_UNSPECIFIED	int
)	O
try_help	function
(	O
"conflicting output style options"	pointer
,	O
NULL	O
)	O
;	O
output_style	enum
=	O
style	enum
;	O
}	O
}	O
static	O
void	O
set_mtime_to_now	function
(	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
gettime	function
(	O
&	O
STAT_TIMESPEC	O
(	O
st	pointer
,	O
st_mtim	struct
)	O
)	O
;	O
}	O
static	O
int	O
compare_files	function
(	O
struct	O
comparison	struct
const	O
*	O
parent	pointer
,	O
char	O
const	O
*	O
name0	pointer
,	O
char	O
const	O
*	O
name1	pointer
)	O
{	O
struct	O
comparison	struct
cmp	struct
;	O
register	O
int	O
f	pointer
;	O
int	O
status	int
=	O
EXIT_SUCCESS	int
;	O
bool	bool
same_files	bool
;	O
char	O
*	O
free0	pointer
;	O
char	O
*	O
free1	pointer
;	O
if	O
(	O
!	O
(	O
(	O
name0	pointer
&&	O
name1	pointer
)	O
||	O
(	O
unidirectional_new_file	bool
&&	O
name1	pointer
)	O
||	O
new_file	bool
)	O
)	O
{	O
char	O
const	O
*	O
name	pointer
=	O
name0	pointer
?	O
name0	pointer
:	O
name1	pointer
;	O
char	O
const	O
*	O
dir	pointer
=	O
parent	pointer
->	O
file	array
[	O
!	O
name0	pointer
]	O
.	O
name	pointer
;	O
message	function
(	O
"Only in %s: %s\n"	pointer
,	O
dir	pointer
,	O
name	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
memset	function
(	O
cmp	struct
.	O
file	array
,	O
0	int
,	O
sizeof	O
cmp	struct
.	O
file	array
)	O
;	O
cmp	struct
.	O
parent	pointer
=	O
parent	pointer
;	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
=	O
name0	pointer
?	O
UNOPENED	O
:	O
NONEXISTENT	O
;	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
=	O
name1	pointer
?	O
UNOPENED	O
:	O
NONEXISTENT	O
;	O
if	O
(	O
!	O
name0	pointer
)	O
name0	pointer
=	O
name1	pointer
;	O
if	O
(	O
!	O
name1	pointer
)	O
name1	pointer
=	O
name0	pointer
;	O
if	O
(	O
!	O
parent	pointer
)	O
{	O
free0	pointer
=	O
NULL	O
;	O
free1	pointer
=	O
NULL	O
;	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
=	O
name0	pointer
;	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
=	O
name1	pointer
;	O
}	O
else	O
{	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
=	O
free0	pointer
=	O
file_name_concat	function
(	O
parent	pointer
->	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
name0	pointer
,	O
NULL	O
)	O
;	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
=	O
free1	pointer
=	O
file_name_concat	function
(	O
parent	pointer
->	O
file	array
[	O
1	int
]	O
.	O
name	pointer
,	O
name1	pointer
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
2	int
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
!=	O
NONEXISTENT	O
)	O
{	O
if	O
(	O
f	pointer
&&	O
file_name_cmp	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
name	pointer
,	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
=	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
;	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
=	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
name	pointer
,	O
"-"	pointer
)	O
)	O
{	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
=	O
STDIN_FILENO	int
;	O
if	O
(	O
O_BINARY	int
&&	O
binary	int
&&	O
!	O
isatty	function
(	O
STDIN_FILENO	int
)	O
)	O
xfreopen	function
(	O
NULL	O
,	O
"rb"	pointer
,	O
stdin	pointer
)	O
;	O
if	O
(	O
fstat	function
(	O
STDIN_FILENO	int
,	O
&	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
)	O
!=	O
0	int
)	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
=	O
ERRNO_ENCODE	O
(	O
errno	O
)	O
;	O
else	O
{	O
if	O
(	O
S_ISREG	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
pos	long
=	O
lseek	function
(	O
STDIN_FILENO	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
pos	long
<	O
0	int
)	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
=	O
ERRNO_ENCODE	O
(	O
errno	O
)	O
;	O
else	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_size	long
=	O
MAX	O
(	O
0	int
,	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_size	long
-	O
pos	long
)	O
;	O
}	O
set_mtime_to_now	function
(	O
&	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
)	O
;	O
}	O
}	O
else	O
if	O
(	O
stat	struct
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
name	pointer
,	O
&	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
)	O
!=	O
0	int
)	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
=	O
ERRNO_ENCODE	O
(	O
errno	O
)	O
;	O
}	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
2	int
;	O
f	pointer
++	O
)	O
if	O
(	O
(	O
new_file	bool
||	O
(	O
f	pointer
==	O
0	int
&&	O
unidirectional_new_file	bool
)	O
)	O
&&	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
==	O
UNOPENED	O
?	O
(	O
S_ISREG	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
&&	O
!	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_mode	int
&	O
(	O
S_IRWXU	O
|	O
S_IRWXG	O
|	O
S_IRWXO	O
)	O
)	O
&&	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_size	long
==	O
0	int
)	O
:	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
==	O
ERRNO_ENCODE	O
(	O
ENOENT	int
)	O
&&	O
!	O
parent	pointer
&&	O
cmp	struct
.	O
file	array
[	O
1	int
-	O
f	pointer
]	O
.	O
desc	int
==	O
UNOPENED	O
)	O
)	O
)	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
=	O
NONEXISTENT	O
;	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
2	int
;	O
f	pointer
++	O
)	O
if	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
==	O
NONEXISTENT	O
)	O
{	O
memset	function
(	O
&	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
,	O
0	int
,	O
sizeof	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
)	O
;	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
stat	struct
.	O
st_mode	int
=	O
cmp	struct
.	O
file	array
[	O
1	int
-	O
f	pointer
]	O
.	O
stat	struct
.	O
st_mode	int
;	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
2	int
;	O
f	pointer
++	O
)	O
{	O
int	O
e	int
=	O
ERRNO_DECODE	O
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
desc	int
)	O
;	O
if	O
(	O
0	int
<=	O
e	int
)	O
{	O
errno	O
=	O
e	int
;	O
perror_with_name	function
(	O
cmp	struct
.	O
file	array
[	O
f	pointer
]	O
.	O
name	pointer
)	O
;	O
status	int
=	O
EXIT_TROUBLE	int
;	O
}	O
}	O
if	O
(	O
status	int
==	O
EXIT_SUCCESS	int
&&	O
!	O
parent	pointer
&&	O
DIR_P	O
(	O
0	int
)	O
!=	O
DIR_P	O
(	O
1	int
)	O
)	O
{	O
int	O
fnm_arg	int
=	O
DIR_P	O
(	O
0	int
)	O
;	O
int	O
dir_arg	int
=	O
1	int
-	O
fnm_arg	int
;	O
char	O
const	O
*	O
fnm	pointer
=	O
cmp	struct
.	O
file	array
[	O
fnm_arg	int
]	O
.	O
name	pointer
;	O
char	O
const	O
*	O
dir	pointer
=	O
cmp	struct
.	O
file	array
[	O
dir_arg	int
]	O
.	O
name	pointer
;	O
char	O
const	O
*	O
filename	pointer
=	O
cmp	struct
.	O
file	array
[	O
dir_arg	int
]	O
.	O
name	pointer
=	O
free0	pointer
=	O
find_dir_file_pathname	function
(	O
dir	pointer
,	O
last_component	function
(	O
fnm	pointer
)	O
)	O
;	O
if	O
(	O
STREQ	O
(	O
fnm	pointer
,	O
"-"	pointer
)	O
)	O
fatal	function
(	O
"cannot compare `-' to a directory"	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
cmp	struct
.	O
file	array
[	O
dir_arg	int
]	O
.	O
stat	struct
)	O
!=	O
0	int
)	O
{	O
perror_with_name	function
(	O
filename	pointer
)	O
;	O
status	int
=	O
EXIT_TROUBLE	int
;	O
}	O
}	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
}	O
else	O
if	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
NONEXISTENT	O
&&	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
==	O
NONEXISTENT	O
)	O
{	O
}	O
else	O
if	O
(	O
(	O
same_files	bool
=	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
!=	O
NONEXISTENT	O
&&	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
!=	O
NONEXISTENT	O
&&	O
0	int
<	O
same_file	O
(	O
&	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
,	O
&	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
stat	struct
)	O
&&	O
same_file_attributes	O
(	O
&	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
,	O
&	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
stat	struct
)	O
)	O
)	O
&&	O
no_diff_means_no_output	bool
)	O
{	O
}	O
else	O
if	O
(	O
DIR_P	O
(	O
0	int
)	O
&	O
DIR_P	O
(	O
1	int
)	O
)	O
{	O
if	O
(	O
output_style	enum
==	O
OUTPUT_IFDEF	int
)	O
fatal	function
(	O
"-D option not supported with directories"	pointer
)	O
;	O
if	O
(	O
parent	pointer
&&	O
!	O
recursive	bool
)	O
{	O
message	function
(	O
"Common subdirectories: %s and %s\n"	pointer
,	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
)	O
;	O
}	O
else	O
status	int
=	O
diff_dirs	function
(	O
&	O
cmp	struct
,	O
compare_files	function
)	O
;	O
}	O
else	O
if	O
(	O
(	O
DIR_P	O
(	O
0	int
)	O
|	O
DIR_P	O
(	O
1	int
)	O
)	O
||	O
(	O
parent	pointer
&&	O
(	O
!	O
S_ISREG	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
||	O
!	O
S_ISREG	O
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
NONEXISTENT	O
||	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
==	O
NONEXISTENT	O
)	O
{	O
if	O
(	O
(	O
DIR_P	O
(	O
0	int
)	O
|	O
DIR_P	O
(	O
1	int
)	O
)	O
&&	O
recursive	bool
&&	O
(	O
new_file	bool
||	O
(	O
unidirectional_new_file	bool
&&	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
NONEXISTENT	O
)	O
)	O
)	O
status	int
=	O
diff_dirs	function
(	O
&	O
cmp	struct
,	O
compare_files	function
)	O
;	O
else	O
{	O
char	O
const	O
*	O
dir	pointer
;	O
assert	O
(	O
parent	pointer
)	O
;	O
dir	pointer
=	O
parent	pointer
->	O
file	array
[	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
NONEXISTENT	O
]	O
.	O
name	pointer
;	O
message	function
(	O
"Only in %s: %s\n"	pointer
,	O
dir	pointer
,	O
name0	pointer
)	O
;	O
status	int
=	O
EXIT_FAILURE	int
;	O
}	O
}	O
else	O
{	O
message5	function
(	O
"File %s is a %s while file %s is a %s\n"	pointer
,	O
file_label	array
[	O
0	int
]	O
?	O
file_label	array
[	O
0	int
]	O
:	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
file_type	function
(	O
&	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
)	O
,	O
file_label	array
[	O
1	int
]	O
?	O
file_label	array
[	O
1	int
]	O
:	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
,	O
file_type	function
(	O
&	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
stat	struct
)	O
)	O
;	O
status	int
=	O
EXIT_FAILURE	int
;	O
}	O
}	O
else	O
if	O
(	O
files_can_be_treated_as_binary	bool
&&	O
S_ISREG	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
&&	O
S_ISREG	O
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
&&	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
stat	struct
.	O
st_size	long
!=	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
stat	struct
.	O
st_size	long
)	O
{	O
message	function
(	O
"Files %s and %s differ\n"	pointer
,	O
file_label	array
[	O
0	int
]	O
?	O
file_label	array
[	O
0	int
]	O
:	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
file_label	array
[	O
1	int
]	O
?	O
file_label	array
[	O
1	int
]	O
:	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
)	O
;	O
status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
int	O
oflags	int
=	O
O_RDONLY	int
|	O
(	O
binary	int
?	O
O_BINARY	int
:	O
0	int
)	O
;	O
if	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
UNOPENED	O
)	O
if	O
(	O
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
=	O
open	function
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
oflags	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
perror_with_name	function
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
)	O
;	O
status	int
=	O
EXIT_TROUBLE	int
;	O
}	O
if	O
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
==	O
UNOPENED	O
)	O
{	O
if	O
(	O
same_files	bool
)	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
=	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
;	O
else	O
if	O
(	O
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
=	O
open	function
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
,	O
oflags	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
perror_with_name	function
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
)	O
;	O
status	int
=	O
EXIT_TROUBLE	int
;	O
}	O
}	O
if	O
(	O
status	int
==	O
EXIT_SUCCESS	int
)	O
status	int
=	O
diff_2_files	function
(	O
&	O
cmp	struct
)	O
;	O
if	O
(	O
0	int
<=	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
&&	O
close	function
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
)	O
!=	O
0	int
)	O
{	O
perror_with_name	function
(	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
)	O
;	O
status	int
=	O
EXIT_TROUBLE	int
;	O
}	O
if	O
(	O
0	int
<=	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
&&	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
desc	int
!=	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
&&	O
close	function
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
desc	int
)	O
!=	O
0	int
)	O
{	O
perror_with_name	function
(	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
)	O
;	O
status	int
=	O
EXIT_TROUBLE	int
;	O
}	O
}	O
if	O
(	O
status	int
==	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
report_identical_files	bool
&&	O
!	O
DIR_P	O
(	O
0	int
)	O
)	O
message	function
(	O
"Files %s and %s are identical\n"	pointer
,	O
file_label	array
[	O
0	int
]	O
?	O
file_label	array
[	O
0	int
]	O
:	O
cmp	struct
.	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
file_label	array
[	O
1	int
]	O
?	O
file_label	array
[	O
1	int
]	O
:	O
cmp	struct
.	O
file	array
[	O
1	int
]	O
.	O
name	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fflush	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
pfatal_with_name	function
(	O
_	O
(	O
"standard output"	pointer
)	O
)	O
;	O
}	O
free	function
(	O
free0	pointer
)	O
;	O
free	function
(	O
free1	pointer
)	O
;	O
return	O
status	int
;	O
}	O
