pthread_mutex_t	union
counter_mutex_in	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
pthread_mutex_t	union
counter_mutex_out	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
pthread_mutex_t	union
counter_mutex_create	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
pthread_mutex_t	union
counter_mutex_malloc	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
void	O
INIT	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
void	O
THREAD	function
(	O
void	O
)	O
;	O
void	O
END	function
(	O
void	O
)	O
;	O
enum	O
{	O
MAXTHREADS	int
=	O
65535	int
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
INIT	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
THREAD	function
(	O
)	O
;	O
END	function
(	O
)	O
;	O
xexit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
INIT	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
hostent	struct
*	O
h	pointer
;	O
size_t	long
len	long
;	O
FILE	struct
*	O
reqfp	pointer
;	O
logfd	int
=	O
-	O
1	int
;	O
debug	int
=	O
0	int
;	O
proxyknife_in_type	int
=	O
IN_FILE	int
;	O
mem_init	function
(	O
)	O
;	O
READCONF	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
test	struct
.	O
httptestmethod	int
==	O
HTTP_GET	int
)	O
{	O
build_req_get_via_http_proxy	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
test	struct
.	O
httptestmethod	int
==	O
HTTP_CONNECT	int
)	O
{	O
build_con_via_http_proxy	function
(	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: INIT: "	pointer
"HTTP Test Method is not supported now: %d!\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
,	O
test	struct
.	O
httptestmethod	int
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
test	struct
.	O
socks5testmethod	int
!=	O
SOCKS5_CONNECT	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: INIT:Socks5 Test Method %d is not supported now\n"	pointer
,	O
progname	pointer
,	O
test	struct
.	O
socks5testmethod	int
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
test	struct
.	O
socks4testmethod	int
!=	O
SOCKS4_CONNECT	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: INIT:Socks4 Test Method %d is not supported now\n"	pointer
,	O
progname	pointer
,	O
test	struct
.	O
socks4testmethod	int
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
target	struct
.	O
checkreqin	pointer
!=	O
NULL	O
)	O
{	O
target	struct
.	O
req	pointer
=	O
read_binary_file	function
(	O
target	struct
.	O
checkreqin	pointer
,	O
&	O
len	long
)	O
;	O
if	O
(	O
target	struct
.	O
req	pointer
==	O
NULL	O
)	O
{	O
perror	function
(	O
target	struct
.	O
checkreqin	pointer
)	O
;	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
__FILE__	O
":Do not use %s!\n"	pointer
,	O
target	struct
.	O
checkreqin	pointer
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
target	struct
.	O
checkreqin	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
len	long
==	O
0	int
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
__FILE__	O
":%s is null!\n"	pointer
,	O
target	struct
.	O
checkreqin	pointer
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
target	struct
.	O
req	pointer
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
target	struct
.	O
checkreqin	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug	int
)	O
printf	function
(	O
"Using request from %s:%s\n"	pointer
,	O
target	struct
.	O
checkreqin	pointer
,	O
target	struct
.	O
req	pointer
)	O
;	O
}	O
}	O
else	O
{	O
http_build_get	function
(	O
)	O
;	O
}	O
if	O
(	O
my	struct
.	O
mytype	int
==	O
HTTP_CONNECT_AUTH	int
)	O
{	O
http_build_auth	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
my	struct
.	O
mytype	int
==	O
SOCKS5_CONNECT_AUTH	int
)	O
{	O
s5_build_auth	function
(	O
)	O
;	O
}	O
if	O
(	O
my	struct
.	O
mytype	int
!=	O
DIRECT	int
)	O
{	O
h	pointer
=	O
gethostbyname	function
(	O
(	O
const	O
char	O
*	O
)	O
my	struct
.	O
myhost	pointer
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
herror	function
(	O
my	struct
.	O
myhost	pointer
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
)	O
&	O
(	O
my	struct
.	O
myhost	pointer
)	O
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
my	struct
.	O
myip	struct
=	O
*	O
(	O
struct	O
in_addr	struct
*	O
)	O
(	O
h	pointer
->	O
h_addr	O
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
)	O
&	O
(	O
my	struct
.	O
myhost	pointer
)	O
)	O
;	O
}	O
my	struct
.	O
myaddr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
my	struct
.	O
myaddr	struct
.	O
sin_addr	struct
=	O
my	struct
.	O
myip	struct
;	O
my	struct
.	O
myaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
my	struct
.	O
myport	int
)	O
;	O
memset	function
(	O
&	O
(	O
my	struct
.	O
myaddr	struct
.	O
sin_zero	array
)	O
,	O
0	int
,	O
sizeof	O
(	O
my	struct
.	O
myaddr	struct
.	O
sin_zero	array
)	O
)	O
;	O
}	O
if	O
(	O
proxyknife_in_type	int
==	O
IN_FILE	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
proxyknife_in	pointer
,	O
"-"	pointer
)	O
)	O
{	O
in	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
in	pointer
=	O
fopen	function
(	O
proxyknife_in	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
in	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
__FILE__	O
" INIT:open %s "	pointer
,	O
proxyknife_in	pointer
)	O
;	O
perror	function
(	O
"fopen"	pointer
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
proxyknife_in	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
proxyknife_in	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
proxyknife_in_type	int
==	O
IN_HTTP	int
)	O
{	O
fetchproxylist	function
(	O
proxyknife_in	pointer
)	O
;	O
proxyknife_in_buffer_cur	pointer
=	O
proxyknife_in_buffer	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
__FILE__	O
" INIT:proxyknife_in_type unknown: %d !\n"	pointer
,	O
proxyknife_in_type	int
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
proxyknife_in	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
out	pointer
=	O
fopen	function
(	O
proxyknife_out	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
out	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
__FILE__	O
" INIT:open %s "	pointer
,	O
proxyknife_out	pointer
)	O
;	O
perror	function
(	O
"fopen"	pointer
)	O
;	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
proxyknife_out	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
xfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
proxyknife_out	pointer
)	O
;	O
setvbuf	function
(	O
out	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
_IONBF	int
,	O
0	int
)	O
;	O
setvbuf	function
(	O
stdout	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
_IONBF	int
,	O
0	int
)	O
;	O
setvbuf	function
(	O
stderr	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
_IONBF	int
,	O
0	int
)	O
;	O
if	O
(	O
logfilename	pointer
!=	O
NULL	O
)	O
{	O
len	long
=	O
strlen	function
(	O
LOGSTDERR	pointer
)	O
+	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
logfilename	pointer
,	O
LOGSTDERR	pointer
,	O
len	long
)	O
!=	O
0	int
)	O
{	O
logfd	int
=	O
open	function
(	O
logfilename	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
logfd	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"INIT:open"	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug	int
)	O
{	O
printf	function
(	O
"Dup stderr to log file %d (%s)now!\n"	pointer
,	O
logfd	int
,	O
logfilename	pointer
)	O
;	O
}	O
if	O
(	O
dup2	function
(	O
logfd	int
,	O
2	int
)	O
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"INIT:dup2"	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
THREAD	function
(	O
)	O
{	O
int	O
tidnum	array
[	O
MAXTHREADS	int
]	O
,	O
mainret	int
,	O
i	pointer
;	O
pthread_attr_t	union
attr	union
;	O
pthread_t	long
tid	array
[	O
MAXTHREADS	int
]	O
;	O
void	O
*	O
status	int
;	O
if	O
(	O
(	O
threads	int
>	O
MAXTHREADS	int
)	O
||	O
(	O
threads	int
<	O
1	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: THREAD:Threads between [1,%d] is permitted."	pointer
"Please modify \"thread=\" in .conf"	pointer
"then  try again\n"	pointer
,	O
progname	pointer
,	O
MAXTHREADS	int
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
SIG_ERR	O
==	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Signal redefine failed\n"	pointer
)	O
;	O
}	O
pthread_attr_init	function
(	O
&	O
attr	union
)	O
;	O
pthread_attr_setdetachstate	function
(	O
&	O
attr	union
,	O
PTHREAD_CREATE_JOINABLE	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
threads	int
;	O
i	pointer
++	O
)	O
{	O
tidnum	array
[	O
i	pointer
]	O
=	O
i	pointer
;	O
if	O
(	O
(	O
mainret	int
=	O
pthread_create	function
(	O
tid	array
+	O
i	pointer
,	O
&	O
attr	union
,	O
loop	function
,	O
tidnum	array
+	O
i	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
debug	int
)	O
printf	function
(	O
"%s %s: THREAD:thread %d create %d\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
,	O
i	pointer
,	O
tid	array
[	O
i	pointer
]	O
)	O
;	O
}	O
else	O
{	O
perror	function
(	O
"THREAD:pthread_create"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
pthread_attr_destroy	function
(	O
&	O
attr	union
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
threads	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
pthread_join	function
(	O
tid	array
[	O
i	pointer
]	O
,	O
&	O
status	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
debug	int
)	O
printf	function
(	O
"join thread %d\n"	pointer
,	O
i	pointer
,	O
*	O
(	O
int	O
*	O
)	O
status	int
)	O
;	O
}	O
else	O
{	O
perror	function
(	O
"THREAD:pthread_join"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
pthread_mutex_destroy	function
(	O
&	O
counter_mutex_in	union
)	O
;	O
pthread_mutex_destroy	function
(	O
&	O
counter_mutex_out	union
)	O
;	O
pthread_mutex_destroy	function
(	O
&	O
counter_mutex_create	union
)	O
;	O
pthread_mutex_destroy	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
}	O
void	O
END	function
(	O
)	O
{	O
if	O
(	O
in	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
in	pointer
)	O
;	O
fclose	function
(	O
out	pointer
)	O
;	O
if	O
(	O
logfd	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
logfd	int
)	O
;	O
}	O
