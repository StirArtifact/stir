pthread_mutex_t	union
monitor_lock	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
union	O
_p_lock	union
{	O
pthread_rwlock_t	union
mutex	union
;	O
}	O
;	O
typedef	O
union	O
_p_lock	union
*	O
p_lock_t	pointer
;	O
static	O
int	O
monitor_pthread_create	function
(	O
p_lock_t	pointer
*	O
)	O
;	O
static	O
void	O
monitor_pthread_destroy	function
(	O
p_lock_t	pointer
*	O
)	O
;	O
static	O
int	O
monitor_pthread_rdlock	function
(	O
p_lock_t	pointer
)	O
;	O
static	O
int	O
monitor_pthread_wrlock	function
(	O
p_lock_t	pointer
)	O
;	O
static	O
int	O
monitor_pthread_unlock	function
(	O
p_lock_t	pointer
)	O
;	O
int	O
mu_monitor_create	function
(	O
mu_monitor_t	pointer
*	O
pmonitor	pointer
,	O
int	O
flags	int
,	O
void	O
*	O
owner	pointer
)	O
{	O
mu_monitor_t	pointer
monitor	pointer
;	O
if	O
(	O
pmonitor	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
monitor	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
monitor	pointer
)	O
)	O
;	O
if	O
(	O
monitor	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
{	O
int	O
status	int
=	O
monitor_pthread_create	function
(	O
(	O
p_lock_t	pointer
*	O
)	O
&	O
(	O
monitor	pointer
->	O
data	pointer
)	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	function
(	O
monitor	pointer
)	O
;	O
return	O
status	int
;	O
}	O
}	O
monitor	pointer
->	O
owner	pointer
=	O
owner	pointer
;	O
monitor	pointer
->	O
allocated	int
=	O
1	int
;	O
monitor	pointer
->	O
flags	int
=	O
flags	int
;	O
*	O
pmonitor	pointer
=	O
monitor	pointer
;	O
return	O
0	int
;	O
}	O
void	O
*	O
mu_monitor_get_owner	function
(	O
mu_monitor_t	pointer
monitor	pointer
)	O
{	O
return	O
(	O
monitor	pointer
==	O
NULL	O
)	O
?	O
NULL	O
:	O
monitor	pointer
->	O
owner	pointer
;	O
}	O
void	O
mu_monitor_destroy	function
(	O
mu_monitor_t	pointer
*	O
pmonitor	pointer
,	O
void	O
*	O
owner	pointer
)	O
{	O
if	O
(	O
pmonitor	pointer
&&	O
*	O
pmonitor	pointer
)	O
{	O
mu_monitor_t	pointer
monitor	pointer
=	O
*	O
pmonitor	pointer
;	O
if	O
(	O
monitor	pointer
->	O
owner	pointer
==	O
owner	pointer
)	O
{	O
if	O
(	O
monitor	pointer
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
monitor_pthread_destroy	function
(	O
(	O
p_lock_t	pointer
*	O
)	O
&	O
(	O
monitor	pointer
->	O
data	pointer
)	O
)	O
;	O
}	O
free	function
(	O
monitor	pointer
)	O
;	O
*	O
pmonitor	pointer
=	O
NULL	O
;	O
}	O
}	O
int	O
mu_monitor_rdlock	function
(	O
mu_monitor_t	pointer
monitor	pointer
)	O
{	O
if	O
(	O
monitor	pointer
)	O
{	O
if	O
(	O
!	O
monitor	pointer
->	O
allocated	int
)	O
{	O
int	O
status	int
=	O
STATIC_LOCK	O
(	O
&	O
monitor_lock	union
)	O
;	O
if	O
(	O
monitor	pointer
->	O
data	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
monitor	pointer
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
status	int
=	O
monitor_pthread_create	function
(	O
(	O
p_lock_t	pointer
*	O
)	O
&	O
(	O
monitor	pointer
->	O
data	pointer
)	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union
)	O
;	O
return	O
status	int
;	O
}	O
}	O
monitor	pointer
->	O
allocated	int
=	O
1	int
;	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union
)	O
;	O
}	O
if	O
(	O
monitor	pointer
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
return	O
monitor_pthread_rdlock	function
(	O
(	O
p_lock_t	pointer
)	O
monitor	pointer
->	O
data	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_monitor_wrlock	function
(	O
mu_monitor_t	pointer
monitor	pointer
)	O
{	O
if	O
(	O
monitor	pointer
)	O
{	O
if	O
(	O
!	O
monitor	pointer
->	O
allocated	int
)	O
{	O
int	O
status	int
=	O
STATIC_LOCK	O
(	O
&	O
monitor_lock	union
)	O
;	O
if	O
(	O
monitor	pointer
->	O
data	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
monitor	pointer
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
status	int
=	O
monitor_pthread_create	function
(	O
(	O
p_lock_t	pointer
*	O
)	O
&	O
(	O
monitor	pointer
->	O
data	pointer
)	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union
)	O
;	O
return	O
status	int
;	O
}	O
}	O
monitor	pointer
->	O
allocated	int
=	O
1	int
;	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union
)	O
;	O
}	O
if	O
(	O
monitor	pointer
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
return	O
monitor_pthread_wrlock	function
(	O
(	O
p_lock_t	pointer
)	O
monitor	pointer
->	O
data	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_monitor_unlock	function
(	O
mu_monitor_t	pointer
monitor	pointer
)	O
{	O
if	O
(	O
monitor	pointer
)	O
{	O
if	O
(	O
monitor	pointer
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
return	O
monitor_pthread_unlock	function
(	O
(	O
p_lock_t	pointer
)	O
monitor	pointer
->	O
data	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_monitor_wait	function
(	O
mu_monitor_t	pointer
monitor	pointer
MU_ARG_UNUSED	O
)	O
{	O
return	O
ENOSYS	int
;	O
}	O
int	O
mu_monitor_notify	function
(	O
mu_monitor_t	pointer
monitor	pointer
MU_ARG_UNUSED	O
)	O
{	O
return	O
ENOSYS	int
;	O
}	O
static	O
int	O
monitor_pthread_create	function
(	O
p_lock_t	pointer
*	O
plock	pointer
)	O
{	O
int	O
status	int
;	O
p_lock_t	pointer
lock	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
lock	pointer
)	O
)	O
;	O
if	O
(	O
lock	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
status	int
=	O
RWLOCK_INIT	O
(	O
&	O
(	O
lock	pointer
->	O
mutex	union
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	function
(	O
lock	pointer
)	O
;	O
return	O
status	int
;	O
}	O
*	O
plock	pointer
=	O
lock	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
monitor_pthread_destroy	function
(	O
p_lock_t	pointer
*	O
plock	pointer
)	O
{	O
p_lock_t	pointer
lock	pointer
=	O
*	O
plock	pointer
;	O
if	O
(	O
lock	pointer
)	O
{	O
RWLOCK_DESTROY	O
(	O
&	O
(	O
lock	pointer
->	O
mutex	union
)	O
)	O
;	O
free	function
(	O
lock	pointer
)	O
;	O
}	O
*	O
plock	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
monitor_pthread_rdlock	function
(	O
p_lock_t	pointer
lock	pointer
)	O
{	O
return	O
RWLOCK_RDLOCK	O
(	O
&	O
(	O
lock	pointer
->	O
mutex	union
)	O
)	O
;	O
}	O
static	O
int	O
monitor_pthread_wrlock	function
(	O
p_lock_t	pointer
lock	pointer
)	O
{	O
return	O
RWLOCK_WRLOCK	O
(	O
&	O
(	O
lock	pointer
->	O
mutex	union
)	O
)	O
;	O
}	O
static	O
int	O
monitor_pthread_unlock	function
(	O
p_lock_t	pointer
lock	pointer
)	O
{	O
return	O
RWLOCK_UNLOCK	O
(	O
&	O
(	O
lock	pointer
->	O
mutex	union
)	O
)	O
;	O
}	O
