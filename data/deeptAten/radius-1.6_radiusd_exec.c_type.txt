int	O
radius_get_user_ids	function
(	O
RADIUS_USER	struct
*	O
usr	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
=	O
getpwnam	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
pwd	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"no such user: %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
grad_string_replace	function
(	O
&	O
usr	pointer
->	O
username	pointer
,	O
name	pointer
)	O
;	O
usr	pointer
->	O
uid	int
=	O
pwd	pointer
->	O
pw_uid	int
;	O
usr	pointer
->	O
gid	int
=	O
pwd	pointer
->	O
pw_gid	int
;	O
return	O
0	int
;	O
}	O
int	O
radius_switch_to_user	function
(	O
RADIUS_USER	struct
*	O
usr	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
gid_t	int
emptygidset	array
[	O
1	int
]	O
;	O
if	O
(	O
usr	pointer
->	O
username	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
emptygidset	array
[	O
0	int
]	O
=	O
usr	pointer
->	O
gid	int
?	O
usr	pointer
->	O
gid	int
:	O
getegid	function
(	O
)	O
;	O
if	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
&&	O
setgroups	function
(	O
1	int
,	O
emptygidset	array
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"setgroups(1, %lu) failed"	pointer
)	O
,	O
(	O
u_long	long
)	O
emptygidset	array
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
setegid	function
(	O
usr	pointer
->	O
gid	int
)	O
)	O
<	O
0	int
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"setegid(%lu) failed"	pointer
)	O
,	O
(	O
u_long	long
)	O
usr	pointer
->	O
gid	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
usr	pointer
->	O
gid	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
setgid	function
(	O
usr	pointer
->	O
gid	int
)	O
)	O
<	O
0	int
&&	O
getegid	function
(	O
)	O
!=	O
usr	pointer
->	O
gid	int
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"setgid(%lu) failed"	pointer
)	O
,	O
(	O
u_long	long
)	O
usr	pointer
->	O
gid	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
getegid	function
(	O
)	O
!=	O
usr	pointer
->	O
gid	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"cannot set effective gid to %lu"	pointer
)	O
,	O
(	O
u_long	long
)	O
usr	pointer
->	O
gid	int
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
&&	O
usr	pointer
->	O
uid	int
!=	O
0	int
)	O
{	O
uid_t	int
euid	int
;	O
if	O
(	O
setuid	function
(	O
usr	pointer
->	O
uid	int
)	O
||	O
geteuid	function
(	O
)	O
!=	O
usr	pointer
->	O
uid	int
||	O
(	O
getuid	function
(	O
)	O
!=	O
usr	pointer
->	O
uid	int
&&	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
||	O
getuid	function
(	O
)	O
==	O
0	int
)	O
)	O
)	O
{	O
if	O
(	O
geteuid	function
(	O
)	O
!=	O
usr	pointer
->	O
uid	int
)	O
{	O
if	O
(	O
setreuid	function
(	O
usr	pointer
->	O
uid	int
,	O
-	O
1	int
)	O
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"setreuid(%lu,-1) failed"	pointer
)	O
,	O
(	O
u_long	long
)	O
usr	pointer
->	O
uid	int
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
if	O
(	O
setuid	function
(	O
usr	pointer
->	O
uid	int
)	O
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"second setuid(%lu) failed"	pointer
)	O
,	O
(	O
u_long	long
)	O
usr	pointer
->	O
uid	int
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"setuid(%lu) failed"	pointer
)	O
,	O
(	O
u_long	long
)	O
usr	pointer
->	O
uid	int
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
euid	int
=	O
geteuid	function
(	O
)	O
;	O
if	O
(	O
usr	pointer
->	O
uid	int
!=	O
0	int
&&	O
setuid	function
(	O
0	int
)	O
==	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"seteuid(0) succeeded when it should not"	pointer
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
usr	pointer
->	O
uid	int
!=	O
euid	int
&&	O
setuid	function
(	O
euid	int
)	O
==	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"cannot drop non-root setuid privileges"	pointer
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
radius_exec_command	function
(	O
char	O
*	O
cmd	pointer
)	O
{	O
int	O
n	long
;	O
grad_avp_t	struct
*	O
vp	pointer
;	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
RETSIGTYPE	void
(	O
*	O
oldsig	pointer
)	O
(	O
)	O
;	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"radius_exec_command(): won't execute, not an absolute pathname: %s"	pointer
)	O
,	O
cmd	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
oldsig	pointer
=	O
grad_set_signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
)	O
==	O
SIG_ERR	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't reset SIGCHLD"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
==	O
0	int
)	O
{	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
grad_argcv_get	function
(	O
cmd	pointer
,	O
""	pointer
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
for	O
(	O
n	long
=	O
grad_max_fd	function
(	O
)	O
;	O
n	long
>	O
2	int
;	O
n	long
--	O
)	O
close	pointer
(	O
n	long
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
chdir	function
(	O
"/tmp"	pointer
)	O
;	O
if	O
(	O
radius_switch_to_user	function
(	O
&	O
exec_user	struct
)	O
)	O
exit	function
(	O
2	int
)	O
;	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
openlog	function
(	O
"radiusd"	pointer
,	O
LOG_PID	int
,	O
LOG_USER	O
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"can't run %s (ruid=%lu, euid=%lu): %m"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
(	O
u_long	long
)	O
getuid	function
(	O
)	O
,	O
(	O
u_long	long
)	O
geteuid	function
(	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"fork"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
grad_set_signal	function
(	O
SIGCHLD	int
,	O
oldsig	pointer
)	O
==	O
SIG_ERR	O
)	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't restore SIGCHLD"	pointer
)	O
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"returned: %d"	pointer
,	O
status	int
)	O
;	O
if	O
(	O
status	int
==	O
2	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't run external program `%s' "	pointer
"(reason reported via syslog channel "	pointer
"user.err)"	pointer
)	O
,	O
cmd	pointer
)	O
;	O
}	O
}	O
else	O
{	O
char	O
buffer	pointer
[	O
RAD_BUFFER_SIZE	int
]	O
;	O
format_exit_status	function
(	O
buffer	pointer
,	O
sizeof	O
buffer	pointer
,	O
status	int
)	O
;	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"external program `%s' %s"	pointer
)	O
,	O
cmd	pointer
,	O
buffer	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
int	O
radius_exec_program	function
(	O
char	O
*	O
cmd	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply	pointer
,	O
int	O
exec_wait	int
)	O
{	O
int	O
p	pointer
[	O
2	int
]	O
;	O
int	O
n	long
;	O
char	O
*	O
ptr	pointer
,	O
*	O
errp	pointer
;	O
grad_avp_t	struct
*	O
vp	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
int	O
line_num	int
;	O
char	O
buffer	pointer
[	O
RAD_BUFFER_SIZE	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
RETSIGTYPE	void
(	O
*	O
oldsig	pointer
)	O
(	O
)	O
;	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"radius_exec_program(): won't execute, not an absolute pathname: %s"	pointer
)	O
,	O
cmd	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
exec_wait	int
)	O
{	O
if	O
(	O
pipe	function
(	O
p	pointer
)	O
!=	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"couldn't open pipe"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
oldsig	pointer
=	O
grad_set_signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
)	O
==	O
SIG_ERR	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't reset SIGCHLD"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
==	O
0	int
)	O
{	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"command line: %s"	pointer
,	O
cmd	pointer
)	O
;	O
grad_argcv_get	function
(	O
cmd	pointer
,	O
""	pointer
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
exec_wait	int
)	O
{	O
if	O
(	O
close	pointer
(	O
p	pointer
[	O
0	int
]	O
)	O
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't close pipe"	pointer
)	O
)	O
;	O
if	O
(	O
p	pointer
[	O
1	int
]	O
!=	O
1	int
&&	O
dup2	function
(	O
p	pointer
[	O
1	int
]	O
,	O
1	int
)	O
!=	O
1	int
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't dup stdout"	pointer
)	O
)	O
;	O
}	O
else	O
close	pointer
(	O
1	int
)	O
;	O
for	O
(	O
n	long
=	O
grad_max_fd	function
(	O
)	O
;	O
n	long
>=	O
3	int
;	O
n	long
--	O
)	O
close	pointer
(	O
n	long
)	O
;	O
chdir	function
(	O
"/tmp"	pointer
)	O
;	O
if	O
(	O
radius_switch_to_user	function
(	O
&	O
exec_user	struct
)	O
)	O
exit	function
(	O
2	int
)	O
;	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
openlog	function
(	O
"radiusd"	pointer
,	O
LOG_PID	int
,	O
LOG_USER	O
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"can't run %s (ruid=%lu, euid=%lu): %m"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
(	O
u_long	long
)	O
getuid	function
(	O
)	O
,	O
(	O
u_long	long
)	O
geteuid	function
(	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"fork"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
exec_wait	int
)	O
return	O
0	int
;	O
if	O
(	O
close	pointer
(	O
p	pointer
[	O
1	int
]	O
)	O
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't close pipe"	pointer
)	O
)	O
;	O
fp	pointer
=	O
fdopen	function
(	O
p	pointer
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
vp	pointer
=	O
NULL	O
;	O
line_num	int
=	O
0	int
;	O
while	O
(	O
ptr	pointer
=	O
fgets	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
fp	pointer
)	O
)	O
{	O
line_num	int
++	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"got `%s'"	pointer
,	O
buffer	pointer
)	O
;	O
if	O
(	O
userparse	function
(	O
ptr	pointer
,	O
&	O
vp	pointer
,	O
&	O
errp	pointer
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"<stdout of %s>:%d: %s"	pointer
)	O
,	O
cmd	pointer
,	O
line_num	int
,	O
errp	pointer
)	O
;	O
grad_avl_free	function
(	O
vp	pointer
)	O
;	O
vp	pointer
=	O
NULL	O
;	O
}	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
grad_set_signal	function
(	O
SIGCHLD	int
,	O
oldsig	pointer
)	O
==	O
SIG_ERR	O
)	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't restore SIGCHLD"	pointer
)	O
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"returned: %d"	pointer
,	O
status	int
)	O
;	O
if	O
(	O
status	int
==	O
2	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't run external program `%s' "	pointer
"(reason reported via syslog channel "	pointer
"user.err)"	pointer
)	O
,	O
cmd	pointer
)	O
;	O
}	O
}	O
else	O
{	O
format_exit_status	function
(	O
buffer	pointer
,	O
sizeof	O
buffer	pointer
,	O
status	int
)	O
;	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"external program `%s' %s"	pointer
)	O
,	O
cmd	pointer
,	O
buffer	pointer
)	O
;	O
}	O
if	O
(	O
vp	pointer
&&	O
reply	pointer
)	O
grad_avl_merge	function
(	O
reply	pointer
,	O
&	O
vp	pointer
)	O
;	O
grad_avl_free	function
(	O
vp	pointer
)	O
;	O
return	O
status	int
;	O
}	O
pid_t	int
radius_run_filter	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
errfile	pointer
,	O
int	O
*	O
p	pointer
)	O
{	O
pid_t	int
pid	int
;	O
int	O
rightp	array
[	O
2	int
]	O
,	O
leftp	array
[	O
2	int
]	O
;	O
int	O
i	int
;	O
pipe	function
(	O
leftp	array
)	O
;	O
pipe	function
(	O
rightp	array
)	O
;	O
switch	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
leftp	array
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
close	pointer
(	O
0	int
)	O
;	O
dup2	function
(	O
leftp	array
[	O
0	int
]	O
,	O
0	int
)	O
;	O
}	O
close	pointer
(	O
leftp	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rightp	array
[	O
1	int
]	O
!=	O
1	int
)	O
{	O
close	pointer
(	O
1	int
)	O
;	O
dup2	function
(	O
rightp	array
[	O
1	int
]	O
,	O
1	int
)	O
;	O
}	O
close	pointer
(	O
rightp	array
[	O
0	int
]	O
)	O
;	O
i	int
=	O
open	function
(	O
errfile	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_APPEND	int
,	O
0644	int
)	O
;	O
if	O
(	O
i	int
>	O
0	int
&&	O
i	int
!=	O
2	int
)	O
{	O
dup2	function
(	O
i	int
,	O
2	int
)	O
;	O
close	pointer
(	O
i	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
grad_max_fd	function
(	O
)	O
;	O
i	int
>	O
2	int
;	O
i	int
--	O
)	O
close	pointer
(	O
i	int
)	O
;	O
if	O
(	O
radius_switch_to_user	function
(	O
&	O
exec_user	struct
)	O
)	O
exit	function
(	O
2	int
)	O
;	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
openlog	function
(	O
"radiusd"	pointer
,	O
LOG_PID	int
,	O
LOG_USER	O
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"can't run %s (ruid=%d, euid=%d): %m"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
getuid	function
(	O
)	O
,	O
geteuid	function
(	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
case	O
-	O
1	int
:	O
close	pointer
(	O
rightp	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
rightp	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
leftp	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
leftp	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
p	pointer
[	O
0	int
]	O
=	O
rightp	array
[	O
0	int
]	O
;	O
close	pointer
(	O
rightp	array
[	O
1	int
]	O
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
leftp	array
[	O
1	int
]	O
;	O
close	pointer
(	O
leftp	array
[	O
0	int
]	O
)	O
;	O
}	O
return	O
pid	int
;	O
}	O
typedef	O
struct	O
filter_symbol	struct
Filter	struct
;	O
struct	O
filter_symbol	struct
{	O
struct	O
filter_symbol	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
line_num	int
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
char	O
*	O
errfile	pointer
;	O
struct	O
{	O
char	O
*	O
input_fmt	pointer
;	O
int	O
wait_reply	int
;	O
int	O
on_fail	int
;	O
}	O
descr	array
[	O
FILTER_MAX	int
]	O
;	O
pid_t	int
pid	int
;	O
size_t	long
lines_input	long
;	O
size_t	long
lines_output	long
;	O
int	O
input	pointer
;	O
int	O
output	pointer
;	O
}	O
;	O
static	O
grad_symtab_t	struct
*	O
filter_tab	pointer
;	O
struct	O
cleanup_info	struct
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
}	O
;	O
static	O
int	O
filter_cleanup_proc	function
(	O
void	O
*	O
ptr	pointer
,	O
grad_symbol_t	struct
*	O
sym	pointer
)	O
{	O
struct	O
cleanup_info	struct
*	O
info	pointer
=	O
ptr	pointer
;	O
Filter	struct
*	O
filter	pointer
=	O
(	O
Filter	struct
*	O
)	O
sym	pointer
;	O
if	O
(	O
filter	pointer
->	O
pid	int
==	O
info	pointer
->	O
pid	int
)	O
{	O
static	O
char	O
buffer	pointer
[	O
512	int
]	O
;	O
format_exit_status	function
(	O
buffer	pointer
,	O
sizeof	O
buffer	pointer
,	O
info	pointer
->	O
status	int
)	O
;	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"filter %s (pid %d) %s (in: %u, out: %u)"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
,	O
filter	pointer
->	O
pid	int
,	O
buffer	pointer
,	O
filter	pointer
->	O
lines_input	long
,	O
filter	pointer
->	O
lines_output	long
)	O
;	O
filter	pointer
->	O
pid	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
filter_cleanup	function
(	O
pid_t	int
pid	int
,	O
int	O
status	int
)	O
{	O
struct	O
cleanup_info	struct
info	pointer
;	O
info	pointer
.	O
pid	int
=	O
pid	int
;	O
info	pointer
.	O
status	int
=	O
status	int
;	O
grad_symtab_iterate	function
(	O
filter_tab	pointer
,	O
filter_cleanup_proc	function
,	O
&	O
info	pointer
)	O
;	O
}	O
void	O
filter_close	function
(	O
Filter	struct
*	O
filter	pointer
)	O
{	O
if	O
(	O
filter	pointer
->	O
pid	int
==	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
filter	pointer
->	O
input	pointer
>=	O
0	int
)	O
{	O
close	pointer
(	O
filter	pointer
->	O
input	pointer
)	O
;	O
filter	pointer
->	O
input	pointer
=	O
-	O
1	int
;	O
}	O
if	O
(	O
filter	pointer
->	O
output	pointer
>=	O
0	int
)	O
{	O
close	pointer
(	O
filter	pointer
->	O
output	pointer
)	O
;	O
filter	pointer
->	O
output	pointer
=	O
-	O
1	int
;	O
}	O
if	O
(	O
filter	pointer
->	O
pid	int
>	O
0	int
)	O
{	O
kill	function
(	O
filter	pointer
->	O
pid	int
,	O
SIGTERM	int
)	O
;	O
filter	pointer
->	O
pid	int
=	O
0	int
;	O
}	O
}	O
void	O
filter_kill	function
(	O
Filter	struct
*	O
filter	pointer
)	O
{	O
if	O
(	O
filter	pointer
->	O
pid	int
==	O
0	int
)	O
return	O
;	O
kill	function
(	O
filter	pointer
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
}	O
static	O
Filter	struct
*	O
filter_open	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
int	O
type	enum
,	O
int	O
*	O
errp	pointer
)	O
{	O
Filter	struct
*	O
filter	pointer
=	O
grad_sym_lookup	function
(	O
filter_tab	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
filter	pointer
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"filter %s is not declared"	pointer
)	O
,	O
name	pointer
)	O
;	O
*	O
errp	pointer
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
*	O
errp	pointer
=	O
filter	pointer
->	O
descr	array
[	O
type	enum
]	O
.	O
on_fail	int
;	O
if	O
(	O
filter	pointer
&&	O
filter	pointer
->	O
pid	int
<=	O
0	int
)	O
{	O
int	O
pipe	function
[	O
2	int
]	O
;	O
filter	pointer
->	O
pid	int
=	O
radius_run_filter	function
(	O
filter	pointer
->	O
argc	int
,	O
filter	pointer
->	O
argv	pointer
,	O
filter	pointer
->	O
errfile	pointer
,	O
pipe	function
)	O
;	O
if	O
(	O
filter	pointer
->	O
pid	int
<=	O
0	int
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"cannot run filter %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
filter	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
filter	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
wait_reply	int
&&	O
!	O
filter	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
wait_reply	int
)	O
{	O
close	pointer
(	O
pipe	function
[	O
0	int
]	O
)	O
;	O
filter	pointer
->	O
input	pointer
=	O
-	O
1	int
;	O
}	O
else	O
filter	pointer
->	O
input	pointer
=	O
pipe	function
[	O
0	int
]	O
;	O
filter	pointer
->	O
output	pointer
=	O
pipe	function
[	O
1	int
]	O
;	O
filter	pointer
->	O
lines_input	long
=	O
0	int
;	O
filter	pointer
->	O
lines_output	long
=	O
0	int
;	O
}	O
}	O
if	O
(	O
filter	pointer
&&	O
kill	function
(	O
filter	pointer
->	O
pid	int
,	O
0	int
)	O
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"filter %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
filter_close	function
(	O
filter	pointer
)	O
;	O
filter	pointer
=	O
NULL	O
;	O
}	O
return	O
filter	pointer
;	O
}	O
char	O
*	O
filter_xlate	function
(	O
struct	O
obstack	struct
*	O
sp	pointer
,	O
char	O
*	O
fmt	pointer
,	O
radiusd_request_t	struct
*	O
radreq	pointer
)	O
{	O
return	O
util_xlate	function
(	O
sp	pointer
,	O
fmt	pointer
,	O
radreq	pointer
->	O
request	pointer
)	O
;	O
}	O
static	O
int	O
filter_write	function
(	O
Filter	struct
*	O
filter	pointer
,	O
char	O
*	O
fmt	pointer
,	O
radiusd_request_t	struct
*	O
radreq	pointer
)	O
{	O
int	O
rc	int
,	O
length	short
;	O
struct	O
obstack	struct
stack	struct
;	O
char	O
*	O
str	pointer
;	O
if	O
(	O
!	O
fmt	pointer
)	O
return	O
-	O
1	int
;	O
obstack_init	O
(	O
&	O
stack	struct
)	O
;	O
str	pointer
=	O
filter_xlate	function
(	O
&	O
stack	struct
,	O
fmt	pointer
,	O
radreq	pointer
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
{	O
rc	int
=	O
length	short
=	O
0	int
;	O
}	O
else	O
{	O
char	O
nl	int
=	O
'\n'	O
;	O
length	short
=	O
strlen	function
(	O
str	pointer
)	O
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"%s < \"%s\""	pointer
,	O
filter	pointer
->	O
name	pointer
,	O
str	pointer
)	O
;	O
rc	int
=	O
write	pointer
(	O
filter	pointer
->	O
output	pointer
,	O
str	pointer
,	O
length	short
)	O
;	O
if	O
(	O
rc	int
==	O
length	short
)	O
{	O
if	O
(	O
write	pointer
(	O
filter	pointer
->	O
output	pointer
,	O
&	O
nl	int
,	O
1	int
)	O
==	O
1	int
)	O
rc	int
++	O
;	O
}	O
}	O
obstack_free	function
(	O
&	O
stack	struct
,	O
NULL	O
)	O
;	O
filter	pointer
->	O
lines_output	long
++	O
;	O
return	O
rc	int
!=	O
length	short
+	O
1	int
;	O
}	O
static	O
int	O
filter_read	function
(	O
Filter	struct
*	O
filter	pointer
,	O
int	O
type	enum
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	int
)	O
{	O
int	O
rc	int
;	O
int	O
rbytes	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
rc	int
=	O
-	O
1	int
;	O
if	O
(	O
rbytes	int
>=	O
buflen	int
-	O
1	int
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
if	O
(	O
read	pointer
(	O
filter	pointer
->	O
input	pointer
,	O
buffer	pointer
+	O
rbytes	int
,	O
1	int
)	O
!=	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
break	O
;	O
}	O
rbytes	int
++	O
;	O
if	O
(	O
buffer	pointer
[	O
rbytes	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
rc	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
buffer	pointer
[	O
rbytes	int
]	O
=	O
0	int
;	O
filter	pointer
->	O
lines_input	long
++	O
;	O
return	O
rbytes	int
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
filter_auth	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply_pairs	pointer
)	O
{	O
Filter	struct
*	O
filter	pointer
;	O
int	O
rc	int
=	O
-	O
1	int
;	O
int	O
err	long
;	O
filter	pointer
=	O
filter_open	function
(	O
name	pointer
,	O
req	pointer
,	O
R_AUTH	int
,	O
&	O
err	long
)	O
;	O
if	O
(	O
!	O
filter	pointer
)	O
return	O
err	long
;	O
if	O
(	O
filter	pointer
->	O
pid	int
==	O
-	O
1	int
)	O
rc	int
=	O
err	long
;	O
else	O
if	O
(	O
filter_write	function
(	O
filter	pointer
,	O
filter	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
input_fmt	pointer
,	O
req	pointer
)	O
)	O
rc	int
=	O
err	long
;	O
else	O
if	O
(	O
!	O
filter	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
wait_reply	int
)	O
rc	int
=	O
0	int
;	O
else	O
{	O
int	O
status	int
;	O
char	O
buffer	pointer
[	O
1024	int
]	O
;	O
status	int
=	O
filter_read	function
(	O
filter	pointer
,	O
R_AUTH	int
,	O
buffer	pointer
,	O
sizeof	O
buffer	pointer
)	O
;	O
if	O
(	O
status	int
<=	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"reading from filter %s"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
)	O
;	O
filter_close	function
(	O
filter	pointer
)	O
;	O
rc	int
=	O
err	long
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
buffer	pointer
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
ptr	pointer
;	O
grad_avp_t	struct
*	O
vp	pointer
=	O
NULL	O
;	O
char	O
*	O
errp	pointer
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"%s > \"%s\""	pointer
,	O
filter	pointer
->	O
name	pointer
,	O
buffer	pointer
)	O
;	O
rc	int
=	O
strtoul	function
(	O
buffer	pointer
,	O
&	O
ptr	pointer
,	O
0	int
)	O
;	O
if	O
(	O
userparse	function
(	O
ptr	pointer
,	O
&	O
vp	pointer
,	O
&	O
errp	pointer
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"<stdout of %s>:%d: %s"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
,	O
filter	pointer
->	O
lines_output	long
,	O
errp	pointer
)	O
;	O
grad_avl_free	function
(	O
vp	pointer
)	O
;	O
}	O
else	O
grad_avl_merge	function
(	O
reply_pairs	pointer
,	O
&	O
vp	pointer
)	O
;	O
}	O
else	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"filter %s (auth): bad output: %s"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
,	O
buffer	pointer
)	O
;	O
rc	int
=	O
err	long
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
filter_acct	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
)	O
{	O
Filter	struct
*	O
filter	pointer
;	O
int	O
rc	int
=	O
-	O
1	int
;	O
int	O
err	long
;	O
filter	pointer
=	O
filter_open	function
(	O
name	pointer
,	O
req	pointer
,	O
R_ACCT	int
,	O
&	O
err	long
)	O
;	O
if	O
(	O
!	O
filter	pointer
)	O
return	O
err	long
;	O
if	O
(	O
filter	pointer
->	O
pid	int
==	O
-	O
1	int
)	O
rc	int
=	O
err	long
;	O
else	O
if	O
(	O
filter_write	function
(	O
filter	pointer
,	O
filter	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
input_fmt	pointer
,	O
req	pointer
)	O
)	O
rc	int
=	O
err	long
;	O
else	O
if	O
(	O
!	O
filter	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
wait_reply	int
)	O
rc	int
=	O
0	int
;	O
else	O
{	O
int	O
status	int
;	O
char	O
buffer	pointer
[	O
1024	int
]	O
;	O
status	int
=	O
filter_read	function
(	O
filter	pointer
,	O
R_ACCT	int
,	O
buffer	pointer
,	O
sizeof	O
buffer	pointer
)	O
;	O
if	O
(	O
status	int
<=	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"reading from filter %s"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
)	O
;	O
rc	int
=	O
err	long
;	O
filter_close	function
(	O
filter	pointer
)	O
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
buffer	pointer
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
ptr	pointer
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"%s > \"%s\""	pointer
,	O
filter	pointer
->	O
name	pointer
,	O
buffer	pointer
)	O
;	O
rc	int
=	O
strtoul	function
(	O
buffer	pointer
,	O
&	O
ptr	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
isspace	function
(	O
*	O
ptr	pointer
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"filter %s (acct): bad output: %s"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
,	O
buffer	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"filter %s (acct): bad output: %s"	pointer
)	O
,	O
filter	pointer
->	O
name	pointer
,	O
buffer	pointer
)	O
;	O
rc	int
=	O
err	long
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
struct	O
filter_symbol	struct
filter_symbol	struct
;	O
static	O
int	O
free_symbol_entry	function
(	O
Filter	struct
*	O
filter	pointer
)	O
{	O
grad_free	function
(	O
filter	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
input_fmt	pointer
)	O
;	O
grad_free	function
(	O
filter	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
input_fmt	pointer
)	O
;	O
grad_argcv_free	function
(	O
filter	pointer
->	O
argc	int
,	O
filter	pointer
->	O
argv	pointer
)	O
;	O
grad_free	function
(	O
filter	pointer
->	O
errfile	pointer
)	O
;	O
if	O
(	O
filter	pointer
->	O
pid	int
>	O
0	int
)	O
filter_close	function
(	O
filter	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
filters_stmt_term	function
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
{	O
if	O
(	O
filter_tab	pointer
)	O
grad_symtab_clear	function
(	O
filter_tab	pointer
)	O
;	O
else	O
filter_tab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
Filter	struct
)	O
,	O
free_symbol_entry	function
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
filter_stmt_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
memset	function
(	O
&	O
filter_symbol	struct
,	O
0	int
,	O
sizeof	O
filter_symbol	struct
)	O
;	O
filter_symbol	struct
.	O
line_num	int
=	O
cfg_line_num	int
;	O
filter_symbol	struct
.	O
name	pointer
=	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
;	O
filter_symbol	struct
.	O
errfile	pointer
=	O
NULL	O
;	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
wait_reply	int
=	O
1	int
;	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
wait_reply	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
filter_stmt_end	function
(	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
filter_symbol	struct
.	O
argc	int
)	O
{	O
Filter	struct
*	O
sym	pointer
=	O
grad_sym_lookup_or_install	function
(	O
filter_tab	pointer
,	O
filter_symbol	struct
.	O
name	pointer
,	O
1	int
)	O
;	O
if	O
(	O
sym	pointer
->	O
argc	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: filter already declared at %s:%d"	pointer
)	O
,	O
cfg_filename	pointer
,	O
cfg_line_num	int
,	O
cfg_filename	pointer
,	O
sym	pointer
->	O
line_num	int
)	O
;	O
return	O
0	int
;	O
}	O
sym	pointer
->	O
line_num	int
=	O
filter_symbol	struct
.	O
line_num	int
;	O
sym	pointer
->	O
argc	int
=	O
filter_symbol	struct
.	O
argc	int
;	O
sym	pointer
->	O
argv	pointer
=	O
filter_symbol	struct
.	O
argv	pointer
;	O
sym	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
input_fmt	pointer
=	O
grad_estrdup	function
(	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
input_fmt	pointer
)	O
;	O
sym	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
input_fmt	pointer
=	O
grad_estrdup	function
(	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
input_fmt	pointer
)	O
;	O
sym	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
wait_reply	int
=	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
wait_reply	int
;	O
sym	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
wait_reply	int
=	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
wait_reply	int
;	O
sym	pointer
->	O
descr	array
[	O
R_AUTH	int
]	O
.	O
on_fail	int
=	O
!	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
on_fail	int
;	O
sym	pointer
->	O
descr	array
[	O
R_ACCT	int
]	O
.	O
on_fail	int
=	O
!	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
on_fail	int
;	O
sym	pointer
->	O
errfile	pointer
=	O
grad_estrdup	function
(	O
filter_symbol	struct
.	O
errfile	pointer
)	O
;	O
sym	pointer
->	O
pid	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
exec_path_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
grad_argcv_get	function
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
""	pointer
,	O
NULL	O
,	O
&	O
filter_symbol	struct
.	O
argc	int
,	O
&	O
filter_symbol	struct
.	O
argv	pointer
)	O
)	O
{	O
grad_argcv_free	function
(	O
filter_symbol	struct
.	O
argc	int
,	O
filter_symbol	struct
.	O
argv	pointer
)	O
;	O
filter_symbol	struct
.	O
argc	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
error_log_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
filter_symbol	struct
.	O
errfile	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
filter_symbol	struct
.	O
errfile	pointer
=	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
;	O
else	O
{	O
char	O
*	O
p	pointer
=	O
grad_mkfilename	function
(	O
grad_log_dir	pointer
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
)	O
;	O
filter_symbol	struct
.	O
errfile	pointer
=	O
cfg_malloc	function
(	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
NULL	O
)	O
;	O
strcpy	function
(	O
filter_symbol	struct
.	O
errfile	pointer
,	O
p	pointer
)	O
;	O
grad_free	function
(	O
p	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_store_format_ptr	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
*	O
(	O
char	O
*	O
*	O
)	O
handler_data	pointer
=	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
cfg_stmt	struct
filter_auth_stmt	array
[	O
]	O
=	O
{	O
{	O
"input-format"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
_store_format_ptr	function
,	O
&	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
input_fmt	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"wait-reply"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
wait_reply	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"success-on-failure"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
filter_symbol	struct
.	O
descr	array
[	O
R_AUTH	int
]	O
.	O
on_fail	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
static	O
struct	O
cfg_stmt	struct
filter_acct_stmt	array
[	O
]	O
=	O
{	O
{	O
"input-format"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
_store_format_ptr	function
,	O
&	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
input_fmt	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"wait-reply"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
wait_reply	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"success-on-failure"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
filter_symbol	struct
.	O
descr	array
[	O
R_ACCT	int
]	O
.	O
on_fail	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
static	O
struct	O
cfg_stmt	struct
filter_stmt	array
[	O
]	O
=	O
{	O
{	O
"exec-path"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
exec_path_handler	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"error-log"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
error_log_handler	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"auth"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
filter_auth_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"acct"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
filter_acct_stmt	array
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
struct	O
cfg_stmt	struct
filters_stmt	array
[	O
]	O
=	O
{	O
{	O
"filter"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
filter_stmt_handler	function
,	O
NULL	O
,	O
filter_stmt	array
,	O
filter_stmt_end	function
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
