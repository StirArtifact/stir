static	O
abstract_catalog_reader_ty	struct
*	O
callback_arg	pointer
;	O
abstract_catalog_reader_ty	struct
*	O
catalog_reader_alloc	function
(	O
abstract_catalog_reader_class_ty	struct
*	O
method_table	pointer
)	O
{	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
;	O
pop	pointer
=	O
(	O
abstract_catalog_reader_ty	struct
*	O
)	O
xmalloc	function
(	O
method_table	pointer
->	O
size	long
)	O
;	O
pop	pointer
->	O
methods	pointer
=	O
method_table	pointer
;	O
if	O
(	O
method_table	pointer
->	O
constructor	pointer
)	O
method_table	pointer
->	O
constructor	pointer
(	O
pop	pointer
)	O
;	O
return	O
pop	pointer
;	O
}	O
void	O
catalog_reader_free	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
destructor	pointer
)	O
pop	pointer
->	O
methods	pointer
->	O
destructor	pointer
(	O
pop	pointer
)	O
;	O
free	function
(	O
pop	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
call_parse_brief	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
parse_brief	pointer
)	O
pop	pointer
->	O
methods	pointer
->	O
parse_brief	pointer
(	O
pop	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
call_parse_debrief	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
parse_debrief	pointer
)	O
pop	pointer
->	O
methods	pointer
->	O
parse_debrief	pointer
(	O
pop	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
call_directive_domain	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
directive_domain	pointer
)	O
pop	pointer
->	O
methods	pointer
->	O
directive_domain	pointer
(	O
pop	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
call_directive_message	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
char	O
*	O
msgctxt	pointer
,	O
char	O
*	O
msgid	pointer
,	O
lex_pos_ty	struct
*	O
msgid_pos	pointer
,	O
char	O
*	O
msgid_plural	pointer
,	O
char	O
*	O
msgstr	pointer
,	O
size_t	long
msgstr_len	long
,	O
lex_pos_ty	struct
*	O
msgstr_pos	pointer
,	O
char	O
*	O
prev_msgctxt	pointer
,	O
char	O
*	O
prev_msgid	pointer
,	O
char	O
*	O
prev_msgid_plural	pointer
,	O
bool	bool
force_fuzzy	bool
,	O
bool	bool
obsolete	bool
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
directive_message	pointer
)	O
pop	pointer
->	O
methods	pointer
->	O
directive_message	pointer
(	O
pop	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
msgid_pos	pointer
,	O
msgid_plural	pointer
,	O
msgstr	pointer
,	O
msgstr_len	long
,	O
msgstr_pos	pointer
,	O
prev_msgctxt	pointer
,	O
prev_msgid	pointer
,	O
prev_msgid_plural	pointer
,	O
force_fuzzy	bool
,	O
obsolete	bool
)	O
;	O
}	O
static	O
inline	O
void	O
call_comment	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
comment	pointer
!=	O
NULL	O
)	O
pop	pointer
->	O
methods	pointer
->	O
comment	pointer
(	O
pop	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
call_comment_dot	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
comment_dot	pointer
!=	O
NULL	O
)	O
pop	pointer
->	O
methods	pointer
->	O
comment_dot	pointer
(	O
pop	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
call_comment_filepos	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
line	long
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
comment_filepos	pointer
)	O
pop	pointer
->	O
methods	pointer
->	O
comment_filepos	pointer
(	O
pop	pointer
,	O
name	pointer
,	O
line	long
)	O
;	O
}	O
static	O
inline	O
void	O
call_comment_special	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
pop	pointer
->	O
methods	pointer
->	O
comment_special	pointer
!=	O
NULL	O
)	O
pop	pointer
->	O
methods	pointer
->	O
comment_special	pointer
(	O
pop	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
parse_start	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
)	O
{	O
callback_arg	pointer
=	O
pop	pointer
;	O
call_parse_brief	function
(	O
pop	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
parse_end	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
)	O
{	O
call_parse_debrief	function
(	O
pop	pointer
)	O
;	O
callback_arg	pointer
=	O
NULL	O
;	O
}	O
void	O
catalog_reader_parse	function
(	O
abstract_catalog_reader_ty	struct
*	O
pop	pointer
,	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
real_filename	pointer
,	O
const	O
char	O
*	O
logical_filename	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
)	O
{	O
error_message_count	int
=	O
0	int
;	O
parse_start	function
(	O
pop	pointer
)	O
;	O
input_syntax	pointer
->	O
parse	pointer
(	O
pop	pointer
,	O
fp	pointer
,	O
real_filename	pointer
,	O
logical_filename	pointer
)	O
;	O
parse_end	function
(	O
pop	pointer
)	O
;	O
if	O
(	O
error_message_count	int
>	O
0	int
)	O
po_xerror	pointer
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
xasprintf	function
(	O
ngettext	function
(	O
"found %d fatal error"	pointer
,	O
"found %d fatal errors"	pointer
,	O
error_message_count	int
)	O
,	O
error_message_count	int
)	O
)	O
;	O
}	O
void	O
po_callback_domain	function
(	O
char	O
*	O
name	pointer
)	O
{	O
call_directive_domain	function
(	O
callback_arg	pointer
,	O
name	pointer
)	O
;	O
}	O
void	O
po_callback_message	function
(	O
char	O
*	O
msgctxt	pointer
,	O
char	O
*	O
msgid	pointer
,	O
lex_pos_ty	struct
*	O
msgid_pos	pointer
,	O
char	O
*	O
msgid_plural	pointer
,	O
char	O
*	O
msgstr	pointer
,	O
size_t	long
msgstr_len	long
,	O
lex_pos_ty	struct
*	O
msgstr_pos	pointer
,	O
char	O
*	O
prev_msgctxt	pointer
,	O
char	O
*	O
prev_msgid	pointer
,	O
char	O
*	O
prev_msgid_plural	pointer
,	O
bool	bool
force_fuzzy	bool
,	O
bool	bool
obsolete	bool
)	O
{	O
call_directive_message	function
(	O
callback_arg	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
msgid_pos	pointer
,	O
msgid_plural	pointer
,	O
msgstr	pointer
,	O
msgstr_len	long
,	O
msgstr_pos	pointer
,	O
prev_msgctxt	pointer
,	O
prev_msgid	pointer
,	O
prev_msgid_plural	pointer
,	O
force_fuzzy	bool
,	O
obsolete	bool
)	O
;	O
}	O
void	O
po_callback_comment	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
call_comment	function
(	O
callback_arg	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
po_callback_comment_dot	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
call_comment_dot	function
(	O
callback_arg	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
po_callback_comment_filepos	function
(	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
line	long
)	O
{	O
call_comment_filepos	function
(	O
callback_arg	pointer
,	O
name	pointer
,	O
line	long
)	O
;	O
}	O
void	O
po_callback_comment_special	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
call_comment_special	function
(	O
callback_arg	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
po_parse_comment_special	function
(	O
const	O
char	O
*	O
s	pointer
,	O
bool	bool
*	O
fuzzyp	pointer
,	O
enum	O
is_format	enum
formatp	array
[	O
NFORMATS	int
]	O
,	O
struct	O
argument_range	struct
*	O
rangep	pointer
,	O
enum	O
is_wrap	O
*	O
wrapp	pointer
,	O
enum	O
is_syntax_check	O
scp	array
[	O
NSYNTAXCHECKS	int
]	O
)	O
{	O
size_t	long
i	long
;	O
*	O
fuzzyp	pointer
=	O
false	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
formatp	array
[	O
i	long
]	O
=	O
undecided	int
;	O
rangep	pointer
->	O
min	int
=	O
-	O
1	int
;	O
rangep	pointer
->	O
max	int
=	O
-	O
1	int
;	O
*	O
wrapp	pointer
=	O
undecided	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
scp	array
[	O
i	long
]	O
=	O
undecided	int
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
t	pointer
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
strchr	function
(	O
"\n \t\r\f\v,"	pointer
,	O
*	O
s	pointer
)	O
!=	O
NULL	O
)	O
s	pointer
++	O
;	O
t	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
strchr	function
(	O
"\n \t\r\f\v,"	pointer
,	O
*	O
s	pointer
)	O
==	O
NULL	O
)	O
s	pointer
++	O
;	O
if	O
(	O
s	pointer
!=	O
t	pointer
)	O
{	O
size_t	long
len	long
=	O
s	pointer
-	O
t	pointer
;	O
if	O
(	O
len	long
==	O
5	int
&&	O
memcmp	function
(	O
t	pointer
,	O
"fuzzy"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
*	O
fuzzyp	pointer
=	O
true	int
;	O
continue	O
;	O
}	O
if	O
(	O
len	long
>=	O
7	int
&&	O
memcmp	function
(	O
t	pointer
+	O
len	long
-	O
7	int
,	O
"-format"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
n	long
;	O
enum	O
is_format	enum
value	enum
;	O
p	pointer
=	O
t	pointer
;	O
n	long
=	O
len	long
-	O
7	int
;	O
if	O
(	O
n	long
>=	O
3	int
&&	O
memcmp	function
(	O
p	pointer
,	O
"no-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
3	int
;	O
n	long
-=	O
3	int
;	O
value	enum
=	O
no	int
;	O
}	O
else	O
if	O
(	O
n	long
>=	O
9	int
&&	O
memcmp	function
(	O
p	pointer
,	O
"possible-"	pointer
,	O
9	int
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
9	int
;	O
n	long
-=	O
9	int
;	O
value	enum
=	O
possible	int
;	O
}	O
else	O
if	O
(	O
n	long
>=	O
11	int
&&	O
memcmp	function
(	O
p	pointer
,	O
"impossible-"	pointer
,	O
11	int
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
11	int
;	O
n	long
-=	O
11	int
;	O
value	enum
=	O
impossible	int
;	O
}	O
else	O
value	enum
=	O
yes	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
strlen	function
(	O
format_language	array
[	O
i	long
]	O
)	O
==	O
n	long
&&	O
memcmp	function
(	O
format_language	array
[	O
i	long
]	O
,	O
p	pointer
,	O
n	long
)	O
==	O
0	int
)	O
{	O
formatp	array
[	O
i	long
]	O
=	O
value	enum
;	O
break	O
;	O
}	O
if	O
(	O
i	long
<	O
NFORMATS	int
)	O
continue	O
;	O
}	O
if	O
(	O
len	long
==	O
6	int
&&	O
memcmp	function
(	O
t	pointer
,	O
"range:"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
strchr	function
(	O
"\n \t\r\f\v,"	pointer
,	O
*	O
s	pointer
)	O
!=	O
NULL	O
)	O
s	pointer
++	O
;	O
t	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
strchr	function
(	O
"\n \t\r\f\v,"	pointer
,	O
*	O
s	pointer
)	O
==	O
NULL	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
t	pointer
>=	O
'0'	O
&&	O
*	O
t	pointer
<=	O
'9'	O
)	O
{	O
unsigned	O
int	O
min	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
t	pointer
>=	O
'0'	O
&&	O
*	O
t	pointer
<=	O
'9'	O
;	O
t	pointer
++	O
)	O
{	O
if	O
(	O
min	int
<=	O
INT_MAX	O
/	O
10	int
)	O
{	O
min	int
=	O
10	int
*	O
min	int
+	O
(	O
*	O
t	pointer
-	O
'0'	O
)	O
;	O
if	O
(	O
min	int
>	O
INT_MAX	O
)	O
min	int
=	O
INT_MAX	O
;	O
}	O
else	O
min	int
=	O
INT_MAX	O
;	O
}	O
if	O
(	O
*	O
t	pointer
++	O
==	O
'.'	O
)	O
if	O
(	O
*	O
t	pointer
++	O
==	O
'.'	O
)	O
if	O
(	O
*	O
t	pointer
>=	O
'0'	O
&&	O
*	O
t	pointer
<=	O
'9'	O
)	O
{	O
unsigned	O
int	O
max	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
t	pointer
>=	O
'0'	O
&&	O
*	O
t	pointer
<=	O
'9'	O
;	O
t	pointer
++	O
)	O
{	O
if	O
(	O
max	int
<=	O
INT_MAX	O
/	O
10	int
)	O
{	O
max	int
=	O
10	int
*	O
max	int
+	O
(	O
*	O
t	pointer
-	O
'0'	O
)	O
;	O
if	O
(	O
max	int
>	O
INT_MAX	O
)	O
max	int
=	O
INT_MAX	O
;	O
}	O
else	O
max	int
=	O
INT_MAX	O
;	O
}	O
if	O
(	O
min	int
<=	O
max	int
)	O
{	O
rangep	pointer
->	O
min	int
=	O
min	int
;	O
rangep	pointer
->	O
max	int
=	O
max	int
;	O
continue	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
len	long
==	O
4	int
&&	O
memcmp	function
(	O
t	pointer
,	O
"wrap"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
*	O
wrapp	pointer
=	O
yes	int
;	O
continue	O
;	O
}	O
if	O
(	O
len	long
==	O
7	int
&&	O
memcmp	function
(	O
t	pointer
,	O
"no-wrap"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
*	O
wrapp	pointer
=	O
no	int
;	O
continue	O
;	O
}	O
if	O
(	O
len	long
>=	O
6	int
&&	O
memcmp	function
(	O
t	pointer
+	O
len	long
-	O
6	int
,	O
"-check"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
n	long
;	O
enum	O
is_syntax_check	O
value	enum
;	O
p	pointer
=	O
t	pointer
;	O
n	long
=	O
len	long
-	O
6	int
;	O
if	O
(	O
n	long
>=	O
3	int
&&	O
memcmp	function
(	O
p	pointer
,	O
"no-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
3	int
;	O
n	long
-=	O
3	int
;	O
value	enum
=	O
no	int
;	O
}	O
else	O
value	enum
=	O
yes	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
if	O
(	O
strlen	function
(	O
syntax_check_name	array
[	O
i	long
]	O
)	O
==	O
n	long
&&	O
memcmp	function
(	O
syntax_check_name	array
[	O
i	long
]	O
,	O
p	pointer
,	O
n	long
)	O
==	O
0	int
)	O
{	O
scp	array
[	O
i	long
]	O
=	O
value	enum
;	O
break	O
;	O
}	O
if	O
(	O
i	long
<	O
NSYNTAXCHECKS	int
)	O
continue	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
po_parse_comment_filepos	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
||	O
*	O
s	pointer
==	O
'\t'	O
||	O
*	O
s	pointer
==	O
'\n'	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
string_start	pointer
=	O
s	pointer
;	O
do	O
s	pointer
++	O
;	O
while	O
(	O
!	O
(	O
*	O
s	pointer
==	O
'\0'	O
||	O
*	O
s	pointer
==	O
' '	O
||	O
*	O
s	pointer
==	O
'\t'	O
||	O
*	O
s	pointer
==	O
'\n'	O
)	O
)	O
;	O
{	O
const	O
char	O
*	O
p	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
':'	O
)	O
{	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
{	O
size_t	long
n	long
=	O
0	int
;	O
do	O
{	O
n	long
=	O
n	long
*	O
10	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
||	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
const	O
char	O
*	O
string_end	pointer
=	O
s	pointer
;	O
size_t	long
string_length	long
=	O
string_end	pointer
-	O
string_start	pointer
;	O
char	O
*	O
string	pointer
=	O
XNMALLOC	O
(	O
string_length	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
string	pointer
,	O
string_start	pointer
,	O
string_length	long
)	O
;	O
string	pointer
[	O
string_length	long
]	O
=	O
'\0'	O
;	O
po_callback_comment_filepos	function
(	O
string	pointer
,	O
n	long
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
s	pointer
=	O
p	pointer
;	O
continue	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
s	pointer
[	O
-	O
1	int
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
{	O
size_t	long
n	long
=	O
0	int
;	O
do	O
{	O
n	long
=	O
n	long
*	O
10	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
||	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
const	O
char	O
*	O
string_end	pointer
=	O
s	pointer
-	O
1	int
;	O
size_t	long
string_length	long
=	O
string_end	pointer
-	O
string_start	pointer
;	O
char	O
*	O
string	pointer
=	O
XNMALLOC	O
(	O
string_length	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
string	pointer
,	O
string_start	pointer
,	O
string_length	long
)	O
;	O
string	pointer
[	O
string_length	long
]	O
=	O
'\0'	O
;	O
po_callback_comment_filepos	function
(	O
string	pointer
,	O
n	long
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
s	pointer
=	O
p	pointer
;	O
continue	O
;	O
}	O
}	O
}	O
{	O
const	O
char	O
*	O
p	pointer
=	O
s	pointer
;	O
while	O
(	O
p	pointer
>	O
string_start	pointer
)	O
{	O
p	pointer
--	O
;	O
if	O
(	O
!	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
)	O
{	O
p	pointer
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
p	pointer
<	O
s	pointer
&&	O
p	pointer
>	O
string_start	pointer
+	O
1	int
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
string_end	pointer
=	O
p	pointer
-	O
1	int
;	O
{	O
size_t	long
n	long
=	O
0	int
;	O
do	O
{	O
n	long
=	O
n	long
*	O
10	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
p	pointer
<	O
s	pointer
)	O
;	O
{	O
size_t	long
string_length	long
=	O
string_end	pointer
-	O
string_start	pointer
;	O
char	O
*	O
string	pointer
=	O
XNMALLOC	O
(	O
string_length	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
string	pointer
,	O
string_start	pointer
,	O
string_length	long
)	O
;	O
string	pointer
[	O
string_length	long
]	O
=	O
'\0'	O
;	O
po_callback_comment_filepos	function
(	O
string	pointer
,	O
n	long
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
}	O
{	O
const	O
char	O
*	O
string_end	pointer
=	O
s	pointer
;	O
size_t	long
string_length	long
=	O
string_end	pointer
-	O
string_start	pointer
;	O
char	O
*	O
string	pointer
=	O
XNMALLOC	O
(	O
string_length	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
string	pointer
,	O
string_start	pointer
,	O
string_length	long
)	O
;	O
string	pointer
[	O
string_length	long
]	O
=	O
'\0'	O
;	O
po_callback_comment_filepos	function
(	O
string	pointer
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
bool	bool
po_parse_comment_solaris_filepos	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
[	O
0	int
]	O
==	O
' '	O
&&	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'F'	O
||	O
s	pointer
[	O
1	int
]	O
==	O
'f'	O
)	O
&&	O
s	pointer
[	O
2	int
]	O
==	O
'i'	O
&&	O
s	pointer
[	O
3	int
]	O
==	O
'l'	O
&&	O
s	pointer
[	O
4	int
]	O
==	O
'e'	O
&&	O
s	pointer
[	O
5	int
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
string_start	pointer
;	O
const	O
char	O
*	O
string_end	pointer
;	O
{	O
const	O
char	O
*	O
p	pointer
=	O
s	pointer
+	O
6	int
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
string_start	pointer
=	O
p	pointer
;	O
}	O
for	O
(	O
string_end	pointer
=	O
string_start	pointer
;	O
*	O
string_end	pointer
!=	O
'\0'	O
;	O
string_end	pointer
++	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
string_end	pointer
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
{	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'l'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'i'	O
&&	O
p	pointer
[	O
2	int
]	O
==	O
'n'	O
&&	O
p	pointer
[	O
3	int
]	O
==	O
'e'	O
)	O
{	O
p	pointer
+=	O
4	int
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'n'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'u'	O
&&	O
p	pointer
[	O
2	int
]	O
==	O
'm'	O
&&	O
p	pointer
[	O
3	int
]	O
==	O
'b'	O
&&	O
p	pointer
[	O
4	int
]	O
==	O
'e'	O
&&	O
p	pointer
[	O
5	int
]	O
==	O
'r'	O
)	O
{	O
p	pointer
+=	O
6	int
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
':'	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
{	O
size_t	long
n	long
=	O
0	int
;	O
do	O
{	O
n	long
=	O
n	long
*	O
10	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
size_t	long
string_length	long
=	O
string_end	pointer
-	O
string_start	pointer
;	O
char	O
*	O
string	pointer
=	O
XNMALLOC	O
(	O
string_length	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
string	pointer
,	O
string_start	pointer
,	O
string_length	long
)	O
;	O
string	pointer
[	O
string_length	long
]	O
=	O
'\0'	O
;	O
po_callback_comment_filepos	function
(	O
string	pointer
,	O
n	long
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
return	O
true	int
;	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
return	O
false	int
;	O
}	O
void	O
po_callback_comment_dispatcher	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
)	O
{	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
po_callback_comment_dot	function
(	O
s	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
':'	O
)	O
{	O
po_parse_comment_filepos	function
(	O
s	pointer
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
','	O
||	O
*	O
s	pointer
==	O
'!'	O
)	O
{	O
po_callback_comment_special	function
(	O
s	pointer
+	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
po_parse_comment_solaris_filepos	function
(	O
s	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
po_callback_comment	function
(	O
s	pointer
)	O
;	O
}	O
}	O
}	O
