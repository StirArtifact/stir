int	O
number_zerop	function
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	function
(	O
x	int
)	O
==	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
return	O
(	O
0	int
)	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
sf	function
(	O
x	int
)	O
==	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
lf	function
(	O
x	int
)	O
==	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_complex	O
:	O
return	O
(	O
number_zerop	function
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
&&	O
number_zerop	function
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
;	O
default	O
:	O
FEwrong_type_argument	function
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
number_plusp	function
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	function
(	O
x	int
)	O
>	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_bignum	O
:	O
if	O
(	O
big_sign	function
(	O
x	int
)	O
>	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_ratio	O
:	O
if	O
(	O
number_plusp	function
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
sf	function
(	O
x	int
)	O
>	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
lf	function
(	O
x	int
)	O
>	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	function
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
number_minusp	function
(	O
object	O
x	int
)	O
{	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	function
(	O
x	int
)	O
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_bignum	O
:	O
if	O
(	O
big_sign	function
(	O
x	int
)	O
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_ratio	O
:	O
if	O
(	O
number_minusp	function
(	O
x	int
->	O
rat	O
.	O
rat_num	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
sf	function
(	O
x	int
)	O
<	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
lf	function
(	O
x	int
)	O
<	O
0.0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	function
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
number_oddp	function
(	O
object	O
x	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
type_of	function
(	O
x	int
)	O
==	O
t_fixnum	O
)	O
i	int
=	O
fix	function
(	O
x	int
)	O
;	O
else	O
if	O
(	O
type_of	function
(	O
x	int
)	O
==	O
t_bignum	O
)	O
i	int
=	O
MP_LOW	function
(	O
MP	function
(	O
x	int
)	O
,	O
lgef	function
(	O
MP	function
(	O
x	int
)	O
)	O
)	O
;	O
else	O
FEwrong_type_argument	function
(	O
sLinteger	O
,	O
x	int
)	O
;	O
return	O
(	O
i	int
&	O
1	int
)	O
;	O
}	O
int	O
number_evenp	function
(	O
object	O
x	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
type_of	function
(	O
x	int
)	O
==	O
t_fixnum	O
)	O
i	int
=	O
fix	function
(	O
x	int
)	O
;	O
else	O
if	O
(	O
type_of	function
(	O
x	int
)	O
==	O
t_bignum	O
)	O
i	int
=	O
MP_LOW	function
(	O
MP	function
(	O
x	int
)	O
,	O
lgef	function
(	O
MP	function
(	O
x	int
)	O
)	O
)	O
;	O
else	O
FEwrong_type_argument	function
(	O
sLinteger	O
,	O
x	int
)	O
;	O
return	O
(	O
~	O
i	int
&	O
1	int
)	O
;	O
}	O
LFD	function
(	O
Lzerop	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
1	int
)	O
;	O
check_type_number	function
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_zerop	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	function
(	O
Lplusp	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
1	int
)	O
;	O
check_type_or_rational_float	function
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_plusp	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	function
(	O
Lminusp	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
1	int
)	O
;	O
check_type_or_rational_float	function
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_minusp	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	function
(	O
Loddp	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
1	int
)	O
;	O
check_type_integer	function
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_oddp	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
LFD	function
(	O
Levenp	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
1	int
)	O
;	O
check_type_integer	function
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number_evenp	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
void	O
gcl_init_num_pred	function
(	O
void	O
)	O
{	O
big_register_1	O
=	O
new_bignum	function
(	O
)	O
;	O
ZERO_BIG	function
(	O
big_register_1	O
)	O
;	O
enter_mark_origin	function
(	O
&	O
big_register_1	O
)	O
;	O
make_function	function
(	O
"ZEROP"	pointer
,	O
Lzerop	int
)	O
;	O
make_function	function
(	O
"PLUSP"	pointer
,	O
Lplusp	int
)	O
;	O
make_function	function
(	O
"MINUSP"	pointer
,	O
Lminusp	int
)	O
;	O
make_function	function
(	O
"ODDP"	pointer
,	O
Loddp	int
)	O
;	O
make_function	function
(	O
"EVENP"	pointer
,	O
Levenp	int
)	O
;	O
}	O
