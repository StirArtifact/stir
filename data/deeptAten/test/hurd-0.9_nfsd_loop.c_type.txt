void	O
*	O
server_loop	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
int	O
fd	int
=	O
(	O
int	O
)	O
arg	pointer
;	O
char	O
buf	array
[	O
MAXIOSIZE	int
]	O
;	O
int	O
xid	int
;	O
int	O
*	O
p	pointer
,	O
*	O
r	pointer
;	O
char	O
*	O
rbuf	pointer
;	O
struct	O
cached_reply	struct
*	O
cr	pointer
;	O
int	O
program	int
;	O
struct	O
sockaddr_in	struct
sender	struct
;	O
int	O
version	int
;	O
int	O
procedure	struct
;	O
struct	O
proctable	struct
*	O
table	pointer
=	O
0	int
;	O
struct	O
procedure	struct
*	O
proc	pointer
;	O
struct	O
idspec	struct
*	O
cred	pointer
;	O
struct	O
cache_handle	struct
*	O
c	pointer
,	O
fakec	struct
;	O
error_t	int
err	long
;	O
socklen_t	int
addrlen	int
;	O
int	O
cc	int
;	O
memset	function
(	O
&	O
fakec	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
cache_handle	struct
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	pointer
=	O
(	O
int	O
*	O
)	O
buf	array
;	O
proc	pointer
=	O
0	int
;	O
addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
;	O
cc	int
=	O
recvfrom	function
(	O
fd	int
,	O
buf	array
,	O
MAXIOSIZE	int
,	O
0	int
,	O
&	O
sender	struct
,	O
&	O
addrlen	int
)	O
;	O
if	O
(	O
cc	int
==	O
-	O
1	int
)	O
continue	O
;	O
xid	int
=	O
*	O
(	O
p	pointer
++	O
)	O
;	O
if	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
!=	O
CALL	O
)	O
continue	O
;	O
p	pointer
++	O
;	O
cr	pointer
=	O
check_cached_replies	function
(	O
xid	int
,	O
&	O
sender	struct
)	O
;	O
if	O
(	O
cr	pointer
->	O
data	pointer
)	O
goto	O
repost_reply	O
;	O
r	pointer
=	O
(	O
int	O
*	O
)	O
(	O
rbuf	pointer
=	O
malloc	function
(	O
MAXIOSIZE	int
)	O
)	O
;	O
if	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
!=	O
RPC_MSG_VERSION	O
)	O
{	O
*	O
(	O
r	pointer
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
MSG_DENIED	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
RPC_MISMATCH	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
RPC_MSG_VERSION	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
RPC_MSG_VERSION	O
)	O
;	O
goto	O
send_reply	O
;	O
}	O
p	pointer
++	O
;	O
program	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
switch	O
(	O
program	int
)	O
{	O
case	O
MOUNTPROG	O
:	O
version	int
=	O
MOUNTVERS	O
;	O
table	pointer
=	O
&	O
mounttable	struct
;	O
break	O
;	O
case	O
NFS_PROGRAM	O
:	O
version	int
=	O
NFS_VERSION	O
;	O
table	pointer
=	O
&	O
nfs2table	struct
;	O
break	O
;	O
case	O
PMAPPROG	O
:	O
version	int
=	O
PMAPVERS	O
;	O
table	pointer
=	O
&	O
pmaptable	struct
;	O
break	O
;	O
default	O
:	O
*	O
(	O
r	pointer
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
PROG_UNAVAIL	O
)	O
;	O
goto	O
send_reply	O
;	O
}	O
if	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
!=	O
version	int
)	O
{	O
*	O
(	O
r	pointer
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
PROG_MISMATCH	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
version	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
version	int
)	O
;	O
goto	O
send_reply	O
;	O
}	O
p	pointer
++	O
;	O
procedure	struct
=	O
htonl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
procedure	struct
<	O
table	pointer
->	O
min	int
||	O
procedure	struct
>	O
table	pointer
->	O
max	int
||	O
table	pointer
->	O
procs	array
[	O
procedure	struct
-	O
table	pointer
->	O
min	int
]	O
.	O
func	pointer
==	O
0	int
)	O
{	O
*	O
(	O
r	pointer
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
PROC_UNAVAIL	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
table	pointer
->	O
min	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
table	pointer
->	O
max	int
)	O
;	O
goto	O
send_reply	O
;	O
}	O
proc	pointer
=	O
&	O
table	pointer
->	O
procs	array
[	O
procedure	struct
-	O
table	pointer
->	O
min	int
]	O
;	O
p	pointer
=	O
process_cred	function
(	O
p	pointer
,	O
&	O
cred	pointer
)	O
;	O
if	O
(	O
proc	pointer
->	O
need_handle	int
)	O
p	pointer
=	O
lookup_cache_handle	function
(	O
p	pointer
,	O
&	O
c	pointer
,	O
cred	pointer
)	O
;	O
else	O
{	O
fakec	struct
.	O
ids	pointer
=	O
cred	pointer
;	O
c	pointer
=	O
&	O
fakec	struct
;	O
}	O
if	O
(	O
proc	pointer
->	O
alloc_reply	pointer
)	O
{	O
size_t	long
amt	long
;	O
amt	long
=	O
(	O
*	O
proc	pointer
->	O
alloc_reply	pointer
)	O
(	O
p	pointer
,	O
version	int
)	O
+	O
256	int
;	O
if	O
(	O
amt	long
>	O
MAXIOSIZE	int
)	O
{	O
free	function
(	O
rbuf	pointer
)	O
;	O
r	pointer
=	O
(	O
int	O
*	O
)	O
(	O
rbuf	pointer
=	O
malloc	function
(	O
amt	long
)	O
)	O
;	O
}	O
}	O
*	O
(	O
r	pointer
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
SUCCESS	O
)	O
;	O
if	O
(	O
!	O
proc	pointer
->	O
process_error	int
)	O
(	O
void	O
)	O
(	O
*	O
proc	pointer
->	O
func	pointer
)	O
(	O
c	pointer
,	O
p	pointer
,	O
&	O
r	pointer
,	O
version	int
)	O
;	O
else	O
{	O
if	O
(	O
c	pointer
)	O
{	O
int	O
*	O
errloc	pointer
=	O
r	pointer
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
err	long
=	O
(	O
*	O
proc	pointer
->	O
func	pointer
)	O
(	O
c	pointer
,	O
p	pointer
,	O
&	O
r	pointer
,	O
version	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
r	pointer
=	O
errloc	pointer
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
nfs_error_trans	function
(	O
err	long
,	O
version	int
)	O
)	O
;	O
}	O
}	O
else	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
nfs_error_trans	function
(	O
ESTALE	int
,	O
version	int
)	O
)	O
;	O
}	O
cred_rele	function
(	O
cred	pointer
)	O
;	O
if	O
(	O
c	pointer
&&	O
c	pointer
!=	O
&	O
fakec	struct
)	O
cache_handle_rele	function
(	O
c	pointer
)	O
;	O
send_reply	O
:	O
cr	pointer
->	O
data	pointer
=	O
rbuf	pointer
;	O
cr	pointer
->	O
len	long
=	O
(	O
char	O
*	O
)	O
r	pointer
-	O
rbuf	pointer
;	O
repost_reply	O
:	O
sendto	function
(	O
fd	int
,	O
cr	pointer
->	O
data	pointer
,	O
cr	pointer
->	O
len	long
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sender	struct
,	O
addrlen	int
)	O
;	O
release_cached_reply	function
(	O
cr	pointer
)	O
;	O
}	O
}	O
