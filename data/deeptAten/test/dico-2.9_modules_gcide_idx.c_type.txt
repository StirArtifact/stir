struct	O
gcide_idx_cache	struct
{	O
size_t	long
pageno	long
;	O
unsigned	O
refcount	int
;	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
}	O
;	O
struct	O
gcide_idx_file	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
fd	int
;	O
struct	O
gcide_idx_header	struct
header	struct
;	O
size_t	long
cache_size	long
;	O
size_t	long
cache_used	long
;	O
struct	O
gcide_idx_cache	struct
*	O
*	O
cache	pointer
;	O
size_t	long
compare_count	long
;	O
}	O
;	O
static	O
void	O
_free_index	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
)	O
{	O
size_t	long
i	long
;	O
free	function
(	O
file	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
file	pointer
->	O
cache_used	long
;	O
i	long
++	O
)	O
{	O
free	function
(	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
->	O
page	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
file	pointer
->	O
cache	pointer
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
}	O
static	O
int	O
_idx_full_read	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
void	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
while	O
(	O
size	long
)	O
{	O
ssize_t	long
rc	int
=	O
read	function
(	O
file	pointer
->	O
fd	int
,	O
p	pointer
,	O
size	long
)	O
;	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
continue	O
;	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"error reading from `%s'"	pointer
)	O
,	O
file	pointer
->	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"short read while reading from `%s'"	pointer
)	O
,	O
file	pointer
->	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
+=	O
rc	int
;	O
size	long
-=	O
rc	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_open_index	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
)	O
{	O
off_t	long
total	long
;	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
_idx_full_read	function
(	O
file	pointer
,	O
&	O
file	pointer
->	O
header	struct
,	O
sizeof	O
(	O
file	pointer
->	O
header	struct
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
memcmp	function
(	O
file	pointer
->	O
header	struct
.	O
ihdr_magic	array
,	O
GCIDE_IDX_MAGIC	pointer
,	O
GCIDE_IDX_MAGIC_LEN	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"file `%s' is not a valid gcide index file"	pointer
)	O
,	O
file	pointer
->	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fstat	function
(	O
file	pointer
->	O
fd	int
,	O
&	O
st	struct
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"fstat `%s'"	pointer
,	O
file	pointer
->	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
total	long
=	O
(	O
file	pointer
->	O
header	struct
.	O
ihdr_num_pages	long
+	O
1	int
)	O
*	O
file	pointer
->	O
header	struct
.	O
ihdr_pagesize	long
;	O
if	O
(	O
total	long
!=	O
st	struct
.	O
st_size	long
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"index file `%s' is corrupted"	pointer
)	O
,	O
file	pointer
->	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
gcide_idx_file	struct
*	O
gcide_idx_file_open	function
(	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
cachesize	long
)	O
{	O
int	O
fd	int
;	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
;	O
file	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
file	pointer
)	O
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
file	pointer
->	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
->	O
name	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
fd	int
=	O
open	function
(	O
name	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot open index file `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
}	O
file	pointer
->	O
fd	int
=	O
fd	int
;	O
if	O
(	O
_open_index	function
(	O
file	pointer
)	O
)	O
{	O
_free_index	function
(	O
file	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
file	pointer
->	O
cache_size	long
=	O
cachesize	long
;	O
return	O
file	pointer
;	O
}	O
void	O
gcide_idx_file_close	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
file	pointer
)	O
{	O
close	function
(	O
file	pointer
->	O
fd	int
)	O
;	O
_free_index	function
(	O
file	pointer
)	O
;	O
}	O
}	O
size_t	long
gcide_idx_headwords	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
)	O
{	O
return	O
file	pointer
->	O
header	struct
.	O
ihdr_num_headwords	long
;	O
}	O
size_t	long
gcide_idx_defs	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
)	O
{	O
return	O
file	pointer
->	O
header	struct
.	O
ihdr_num_defs	long
;	O
}	O
static	O
struct	O
gcide_idx_cache	struct
*	O
_cache_alloc	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
)	O
{	O
struct	O
gcide_idx_cache	struct
*	O
cp	pointer
;	O
if	O
(	O
!	O
file	pointer
->	O
cache	pointer
)	O
{	O
file	pointer
->	O
cache	pointer
=	O
calloc	function
(	O
file	pointer
->	O
cache_size	long
,	O
sizeof	O
(	O
file	pointer
->	O
cache	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
file	pointer
->	O
cache	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
file	pointer
->	O
cache_used	long
<	O
file	pointer
->	O
cache_size	long
)	O
{	O
if	O
(	O
file	pointer
->	O
cache_used	long
&&	O
file	pointer
->	O
cache	pointer
[	O
file	pointer
->	O
cache_used	long
-	O
1	int
]	O
->	O
refcount	int
==	O
0	int
)	O
return	O
file	pointer
->	O
cache	pointer
[	O
file	pointer
->	O
cache_used	long
-	O
1	int
]	O
;	O
cp	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
cp	pointer
)	O
)	O
;	O
if	O
(	O
!	O
cp	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
cp	pointer
->	O
page	pointer
=	O
malloc	function
(	O
file	pointer
->	O
header	struct
.	O
ihdr_pagesize	long
)	O
;	O
if	O
(	O
!	O
cp	pointer
->	O
page	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
cp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
file	pointer
->	O
cache	pointer
[	O
file	pointer
->	O
cache_used	long
++	O
]	O
=	O
cp	pointer
;	O
}	O
else	O
cp	pointer
=	O
file	pointer
->	O
cache	pointer
[	O
file	pointer
->	O
cache_used	long
-	O
1	int
]	O
;	O
cp	pointer
->	O
pageno	long
=	O
0	int
;	O
cp	pointer
->	O
refcount	int
=	O
0	int
;	O
return	O
cp	pointer
;	O
}	O
static	O
void	O
_cache_promote	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
int	O
n	long
)	O
{	O
int	O
i	long
;	O
unsigned	O
refcount	int
=	O
++	O
file	pointer
->	O
cache	pointer
[	O
n	long
]	O
->	O
refcount	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	long
=	O
n	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
->	O
refcount	int
>=	O
refcount	int
)	O
break	O
;	O
i	long
++	O
;	O
if	O
(	O
i	long
!=	O
n	long
)	O
{	O
struct	O
gcide_idx_cache	struct
*	O
tmp	pointer
=	O
file	pointer
->	O
cache	pointer
[	O
n	long
]	O
;	O
file	pointer
->	O
cache	pointer
[	O
n	long
]	O
=	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
;	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
=	O
tmp	pointer
;	O
}	O
}	O
static	O
struct	O
gcide_idx_cache	struct
*	O
_cache_find_page	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
size_t	long
n	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
file	pointer
->	O
cache_used	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
->	O
pageno	long
==	O
n	long
)	O
{	O
struct	O
gcide_idx_cache	struct
*	O
cp	pointer
=	O
file	pointer
->	O
cache	pointer
[	O
i	long
]	O
;	O
_cache_promote	function
(	O
file	pointer
,	O
n	long
)	O
;	O
return	O
cp	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
gcide_idx_page	struct
*	O
_idx_get_page	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
size_t	long
n	long
)	O
{	O
off_t	long
off	long
;	O
struct	O
gcide_idx_cache	struct
*	O
cp	pointer
;	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
size_t	long
i	long
;	O
cp	pointer
=	O
_cache_find_page	function
(	O
file	pointer
,	O
n	long
)	O
;	O
if	O
(	O
cp	pointer
)	O
return	O
cp	pointer
->	O
page	pointer
;	O
off	long
=	O
(	O
n	long
+	O
1	int
)	O
*	O
file	pointer
->	O
header	struct
.	O
ihdr_pagesize	long
;	O
if	O
(	O
lseek	function
(	O
file	pointer
->	O
fd	int
,	O
off	long
,	O
SEEK_SET	int
)	O
!=	O
off	long
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"seek error on `%s' while positioning to %lu"	pointer
)	O
,	O
file	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
off	long
)	O
;	O
return	O
NULL	O
;	O
}	O
cp	pointer
=	O
_cache_alloc	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
cp	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
_idx_full_read	function
(	O
file	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
file	pointer
->	O
header	struct
.	O
ihdr_pagesize	long
)	O
)	O
return	O
NULL	O
;	O
cp	pointer
->	O
refcount	int
++	O
;	O
page	pointer
=	O
cp	pointer
->	O
page	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
i	long
++	O
)	O
page	pointer
->	O
ipg_ref	array
[	O
i	long
]	O
.	O
ref_headword	pointer
=	O
(	O
char	O
*	O
)	O
page	pointer
+	O
page	pointer
->	O
ipg_ref	array
[	O
i	long
]	O
.	O
ref_hwoff	long
;	O
return	O
page	pointer
;	O
}	O
int	O
gcide_idx_enumerate	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
int	O
(	O
*	O
fun	pointer
)	O
(	O
struct	O
gcide_ref	struct
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
file	pointer
->	O
header	struct
.	O
ihdr_num_pages	long
;	O
i	long
++	O
)	O
{	O
int	O
j	int
;	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
=	O
_idx_get_page	function
(	O
file	pointer
,	O
i	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
-	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
j	int
++	O
)	O
if	O
(	O
fun	pointer
(	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
j	int
]	O
,	O
data	pointer
)	O
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_compare	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
char	O
*	O
hw	pointer
,	O
struct	O
gcide_ref	struct
*	O
ref	pointer
,	O
size_t	long
hwlen	long
)	O
{	O
file	pointer
->	O
compare_count	long
++	O
;	O
if	O
(	O
hwlen	long
)	O
{	O
if	O
(	O
hwlen	long
>	O
ref	pointer
->	O
ref_hwlen	long
)	O
hwlen	long
=	O
ref	pointer
->	O
ref_hwlen	long
;	O
return	O
utf8_strncasecmp	function
(	O
hw	pointer
,	O
ref	pointer
->	O
ref_headword	pointer
,	O
hwlen	long
)	O
;	O
}	O
return	O
utf8_strcasecmp	function
(	O
hw	pointer
,	O
ref	pointer
->	O
ref_headword	pointer
)	O
;	O
}	O
static	O
size_t	long
_idx_ref_locate	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
,	O
char	O
*	O
headword	pointer
,	O
size_t	long
hwlen	long
)	O
{	O
size_t	long
l	long
,	O
u	long
,	O
idx	long
;	O
int	O
res	int
;	O
l	long
=	O
0	int
;	O
u	long
=	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
while	O
(	O
l	long
<	O
u	long
)	O
{	O
idx	long
=	O
(	O
l	long
+	O
u	long
)	O
/	O
2	int
;	O
res	int
=	O
_compare	function
(	O
file	pointer
,	O
headword	pointer
,	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
idx	long
]	O
,	O
hwlen	long
)	O
;	O
if	O
(	O
res	int
<	O
0	int
)	O
u	long
=	O
idx	long
;	O
else	O
if	O
(	O
res	int
>	O
0	int
)	O
l	long
=	O
idx	long
+	O
1	int
;	O
else	O
return	O
idx	long
;	O
}	O
return	O
REF_NOT_FOUND	O
;	O
}	O
static	O
size_t	long
_idx_page_locate	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
char	O
*	O
headword	pointer
,	O
size_t	long
hwlen	long
)	O
{	O
size_t	long
l	long
,	O
u	long
,	O
idx	long
;	O
int	O
res	int
;	O
l	long
=	O
0	int
;	O
u	long
=	O
file	pointer
->	O
header	struct
.	O
ihdr_num_pages	long
;	O
while	O
(	O
l	long
<	O
u	long
)	O
{	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
idx	long
=	O
(	O
l	long
+	O
u	long
)	O
/	O
2	int
;	O
page	pointer
=	O
_idx_get_page	function
(	O
file	pointer
,	O
idx	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
REF_NOT_FOUND	O
;	O
res	int
=	O
_compare	function
(	O
file	pointer
,	O
headword	pointer
,	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
0	int
]	O
,	O
hwlen	long
)	O
;	O
if	O
(	O
res	int
<	O
0	int
)	O
u	long
=	O
idx	long
;	O
else	O
if	O
(	O
res	int
==	O
0	int
)	O
return	O
idx	long
;	O
else	O
{	O
res	int
=	O
_compare	function
(	O
file	pointer
,	O
headword	pointer
,	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
-	O
1	int
]	O
,	O
hwlen	long
)	O
;	O
if	O
(	O
res	int
>	O
0	int
)	O
l	long
=	O
idx	long
+	O
1	int
;	O
else	O
return	O
idx	long
;	O
}	O
}	O
return	O
REF_NOT_FOUND	O
;	O
}	O
struct	O
gcide_iterator	struct
{	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
;	O
char	O
*	O
headword	pointer
;	O
size_t	long
hwlen	long
;	O
size_t	long
start_pageno	long
;	O
size_t	long
start_refno	long
;	O
size_t	long
cur_pageno	long
;	O
size_t	long
cur_refno	long
;	O
size_t	long
page_numrefs	long
;	O
size_t	long
compare_count	long
;	O
size_t	long
numrefs	long
;	O
size_t	long
curref	long
;	O
char	O
*	O
prevbuf	pointer
;	O
size_t	long
prevsize	long
;	O
int	O
flags	int
;	O
}	O
;	O
gcide_iterator_t	pointer
gcide_idx_locate	function
(	O
struct	O
gcide_idx_file	struct
*	O
file	pointer
,	O
char	O
*	O
headword	pointer
,	O
size_t	long
hwlen	long
)	O
{	O
size_t	long
pageno	long
,	O
refno	long
;	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
struct	O
gcide_iterator	struct
*	O
itr	pointer
;	O
file	pointer
->	O
compare_count	long
=	O
0	int
;	O
pageno	long
=	O
_idx_page_locate	function
(	O
file	pointer
,	O
headword	pointer
,	O
hwlen	long
)	O
;	O
if	O
(	O
pageno	long
==	O
REF_NOT_FOUND	O
)	O
return	O
NULL	O
;	O
page	pointer
=	O
_idx_get_page	function
(	O
file	pointer
,	O
pageno	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
NULL	O
;	O
refno	long
=	O
_idx_ref_locate	function
(	O
file	pointer
,	O
page	pointer
,	O
headword	pointer
,	O
hwlen	long
)	O
;	O
if	O
(	O
refno	long
==	O
REF_NOT_FOUND	O
)	O
return	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
refno	long
>	O
0	int
)	O
{	O
if	O
(	O
_compare	function
(	O
file	pointer
,	O
headword	pointer
,	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
refno	long
-	O
1	int
]	O
,	O
hwlen	long
)	O
>	O
0	int
)	O
break	O
;	O
--	O
refno	long
;	O
}	O
if	O
(	O
refno	long
==	O
0	int
)	O
{	O
if	O
(	O
pageno	long
==	O
0	int
)	O
break	O
;	O
page	pointer
=	O
_idx_get_page	function
(	O
file	pointer
,	O
--	O
pageno	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
NULL	O
;	O
refno	long
=	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
}	O
}	O
if	O
(	O
refno	long
==	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
)	O
{	O
pageno	long
++	O
;	O
refno	long
=	O
0	int
;	O
}	O
itr	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
itr	pointer
)	O
)	O
;	O
if	O
(	O
!	O
itr	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
hwlen	long
)	O
{	O
itr	pointer
->	O
headword	pointer
=	O
malloc	function
(	O
hwlen	long
)	O
;	O
if	O
(	O
itr	pointer
->	O
headword	pointer
)	O
memcpy	function
(	O
itr	pointer
->	O
headword	pointer
,	O
headword	pointer
,	O
hwlen	long
)	O
;	O
}	O
else	O
itr	pointer
->	O
headword	pointer
=	O
strdup	function
(	O
headword	pointer
)	O
;	O
if	O
(	O
!	O
itr	pointer
->	O
headword	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
itr	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
itr	pointer
->	O
hwlen	long
=	O
hwlen	long
;	O
itr	pointer
->	O
file	pointer
=	O
file	pointer
;	O
itr	pointer
->	O
start_pageno	long
=	O
itr	pointer
->	O
cur_pageno	long
=	O
pageno	long
;	O
itr	pointer
->	O
start_refno	long
=	O
itr	pointer
->	O
cur_refno	long
=	O
refno	long
;	O
itr	pointer
->	O
page_numrefs	long
=	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
itr	pointer
->	O
curref	long
=	O
itr	pointer
->	O
numrefs	long
=	O
0	int
;	O
itr	pointer
->	O
compare_count	long
=	O
file	pointer
->	O
compare_count	long
;	O
return	O
itr	pointer
;	O
}	O
void	O
gcide_iterator_free	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
if	O
(	O
itr	pointer
)	O
{	O
free	function
(	O
itr	pointer
->	O
headword	pointer
)	O
;	O
free	function
(	O
itr	pointer
)	O
;	O
}	O
}	O
int	O
gcide_iterator_next	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
size_t	long
pageno	long
,	O
refno	long
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
itr	pointer
->	O
numrefs	long
&&	O
itr	pointer
->	O
curref	long
==	O
itr	pointer
->	O
numrefs	long
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
itr	pointer
->	O
cur_refno	long
<	O
itr	pointer
->	O
page_numrefs	long
-	O
1	int
)	O
{	O
pageno	long
=	O
itr	pointer
->	O
cur_pageno	long
;	O
refno	long
=	O
itr	pointer
->	O
cur_refno	long
+	O
1	int
;	O
}	O
else	O
if	O
(	O
itr	pointer
->	O
cur_pageno	long
==	O
itr	pointer
->	O
file	pointer
->	O
header	struct
.	O
ihdr_num_pages	long
)	O
{	O
if	O
(	O
!	O
itr	pointer
->	O
numrefs	long
)	O
itr	pointer
->	O
numrefs	long
=	O
itr	pointer
->	O
curref	long
+	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
pageno	long
=	O
itr	pointer
->	O
cur_pageno	long
+	O
1	int
;	O
refno	long
=	O
0	int
;	O
}	O
page	pointer
=	O
_idx_get_page	function
(	O
itr	pointer
->	O
file	pointer
,	O
pageno	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
itr	pointer
->	O
numrefs	long
&&	O
_compare	function
(	O
itr	pointer
->	O
file	pointer
,	O
itr	pointer
->	O
headword	pointer
,	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
refno	long
]	O
,	O
itr	pointer
->	O
hwlen	long
)	O
)	O
{	O
if	O
(	O
!	O
itr	pointer
->	O
numrefs	long
)	O
itr	pointer
->	O
numrefs	long
=	O
itr	pointer
->	O
curref	long
+	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
itr	pointer
->	O
page_numrefs	long
=	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
itr	pointer
->	O
cur_pageno	long
=	O
pageno	long
;	O
itr	pointer
->	O
cur_refno	long
=	O
refno	long
;	O
itr	pointer
->	O
curref	long
++	O
;	O
return	O
0	int
;	O
}	O
int	O
gcide_iterator_rewind	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
-	O
1	int
;	O
itr	pointer
->	O
cur_pageno	long
=	O
itr	pointer
->	O
start_pageno	long
;	O
itr	pointer
->	O
cur_refno	long
=	O
itr	pointer
->	O
start_refno	long
;	O
itr	pointer
->	O
curref	long
=	O
0	int
;	O
page	pointer
=	O
_idx_get_page	function
(	O
itr	pointer
->	O
file	pointer
,	O
itr	pointer
->	O
cur_pageno	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
-	O
1	int
;	O
itr	pointer
->	O
page_numrefs	long
=	O
page	pointer
->	O
ipg_header	union
.	O
hdr	pointer
.	O
phdr_numentries	long
;	O
return	O
0	int
;	O
}	O
struct	O
gcide_ref	struct
*	O
gcide_iterator_ref	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
struct	O
gcide_idx_page	struct
*	O
page	pointer
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
NULL	O
;	O
page	pointer
=	O
_idx_get_page	function
(	O
itr	pointer
->	O
file	pointer
,	O
itr	pointer
->	O
cur_pageno	long
)	O
;	O
if	O
(	O
!	O
page	pointer
)	O
return	O
NULL	O
;	O
return	O
&	O
page	pointer
->	O
ipg_ref	array
[	O
itr	pointer
->	O
cur_refno	long
]	O
;	O
}	O
size_t	long
gcide_iterator_count	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
0	int
;	O
if	O
(	O
!	O
itr	pointer
->	O
numrefs	long
)	O
{	O
while	O
(	O
gcide_iterator_next	function
(	O
itr	pointer
)	O
==	O
0	int
)	O
;	O
gcide_iterator_rewind	function
(	O
itr	pointer
)	O
;	O
}	O
return	O
itr	pointer
->	O
numrefs	long
;	O
}	O
size_t	long
gcide_iterator_compare_count	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
return	O
itr	pointer
->	O
compare_count	long
;	O
}	O
void	O
gcide_iterator_store_flags	function
(	O
gcide_iterator_t	pointer
itr	pointer
,	O
int	O
flags	int
)	O
{	O
itr	pointer
->	O
flags	int
=	O
flags	int
;	O
}	O
int	O
gcide_iterator_flags	function
(	O
gcide_iterator_t	pointer
itr	pointer
)	O
{	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
0	int
;	O
return	O
itr	pointer
->	O
flags	int
;	O
}	O
