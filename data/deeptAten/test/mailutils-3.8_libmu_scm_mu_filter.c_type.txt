static	O
void	O
argv_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
mu_argv_free	O
(	O
(	O
char	O
*	O
*	O
)	O
p	pointer
)	O
;	O
}	O
static	O
SCM	O
make_filter_port	function
(	O
SCM	O
port	O
,	O
SCM	O
name	int
,	O
SCM	O
args	int
,	O
int	O
filter_mode	int
,	O
char	O
const	O
*	O
func_name	pointer
)	O
{	O
char	O
*	array
fltname	pointer
;	O
mu_stream_t	O
filter	pointer
;	O
mu_stream_t	O
instr	pointer
;	O
size_t	O
argc	long
=	O
0	pointer
;	O
char	O
*	O
*	pointer
argv	pointer
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
flags	int
=	O
0	int
;	O
char	O
*	O
port_mode	pointer
;	O
SCM_ASSERT	O
(	O
scm_port_p	O
(	O
port	O
)	O
,	O
port	O
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
name	pointer
)	O
,	O
name	O
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_VALIDATE_REST_ARGUMENT	O
(	O
args	O
)	O
;	O
port_mode	O
=	O
scm_to_locale_string	function
(	O
scm_port_mode	O
(	O
port	pointer
)	O
)	O
;	O
if	O
(	O
strchr	O
(	O
port_mode	pointer
,	O
'r'	O
)	O
)	O
flags	O
|=	O
MU_STREAM_READ	int
;	O
if	O
(	O
strchr	O
(	O
port_mode	pointer
,	O
'w'	O
)	O
)	O
flags	O
|=	O
MU_STREAM_WRITE	int
;	O
free	O
(	O
port_mode	pointer
)	O
;	O
if	O
(	O
!	O
flags	O
||	O
(	int
(	O
flags	O
&	O
(	int
MU_STREAM_READ	O
|	O
MU_STREAM_WRITE	int
)	O
)	O
==	O
(	int
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
)	O
scm_out_of_range	O
(	O
FUNC_NAME	O
,	O
port	int
)	O
;	O
scm_dynwind_begin	O
(	O
0	O
)	O
;	O
fltname	O
=	O
scm_to_locale_string	int
(	O
name	O
)	O
;	O
scm_dynwind_free	O
(	O
fltname	O
)	O
;	O
rc	O
=	O
mu_scm_port_stream_create	function
(	O
&	O
instr	pointer
,	O
port	O
)	O
;	O
if	O
(	O
rc	O
)	O
{	O
mu_scm_error	O
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to convert transport port ~A"	O
,	O
scm_list_1	int
(	O
port	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
scm_is_null	O
(	O
args	pointer
)	O
)	O
{	O
size_t	O
n	O
;	O
argc	O
=	O
scm_to_size_t	O
(	O
scm_length	O
(	O
args	pointer
)	O
)	O
+	O
1	int
;	O
argv	O
=	O
calloc	function
(	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
argv	O
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	O
)	O
mu_scm_error	O
(	O
FUNC_NAME	O
,	O
ENOMEM	int
,	O
"Cannot allocate memory"	O
,	O
SCM_BOOL_F	O
)	O
;	O
argv	O
[	O
0	int
]	O
=	O
strdup	O
(	O
fltname	O
)	O
;	O
n	O
=	O
1	int
;	O
for	O
(	O
;	int
!	O
scm_is_null	O
(	O
args	pointer
)	O
;	O
args	O
=	O
SCM_CDR	function
(	O
args	int
)	O
)	O
{	O
SCM	O
arg	int
=	O
SCM_CAR	function
(	O
args	int
)	O
;	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
arg	pointer
)	O
,	O
arg	O
,	O
SCM_ARGn	int
,	O
FUNC_NAME	int
)	O
;	O
argv	O
[	O
n	int
]	O
=	O
scm_to_locale_string	O
(	O
arg	O
)	O
;	O
n	O
++	O
;	O
}	O
argv	O
[	O
n	int
]	O
=	O
NULL	O
;	O
scm_dynwind_unwind_handler	O
(	O
argv_free	O
,	O
argv	int
,	O
SCM_F_WIND_EXPLICITLY	O
)	O
;	O
}	O
rc	O
=	O
mu_filter_create_args	function
(	O
&	O
filter	struct
,	O
instr	O
,	O
fltname	O
,	O
argc	O
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	O
,	O
filter_mode	O
,	O
flags	int
)	O
;	O
if	O
(	O
rc	O
)	O
{	O
mu_scm_error	O
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to create filter ~A"	O
,	O
scm_list_1	int
(	O
name	O
)	O
)	O
;	O
}	O
scm_dynwind_end	O
(	O
)	O
;	O
return	O
mu_port_make_from_stream	int
(	O
filter	O
,	O
flags	O
==	O
MU_STREAM_READ	int
?	O
SCM_RDNG	int
:	O
SCM_WRTNG	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	O
(	O
scm_mu_encoder_port	pointer
,	O
"mu-encoder-port"	pointer
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	int
SCM	O
port	O
,	O
SCM	O
name	O
,	O
SCM	O
args	O
)	O
,	O
"Create encoding port using Mailutils filter @var{name} with optional arguments\n"	O
"@var{args}. The @var{port} argument must be a port opened either for\n"	O
"writing or for reading, but not both. The returned port will have the same\n"	O
"mode as @var{port}."	O
"\n\n"	O
"If @var{port} is open for reading, data will be read from it, passed through the\n"	O
"filter and returned. If it is open for writing, data written to the returned\n"	O
"port will be passed through filter and its output will be written to @var{port}.\n"	O
)	O
{	O
return	O
make_filter_port	int
(	O
port	O
,	O
name	O
,	O
args	O
,	O
MU_FILTER_ENCODE	O
,	O
FUNC_NAME	int
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	O
(	O
scm_mu_decoder_port	pointer
,	O
"mu-decoder-port"	pointer
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	int
SCM	O
port	O
,	O
SCM	O
name	O
,	O
SCM	O
args	O
)	O
,	O
"Create a decoding port using Mailutils filter @var{name} with optional arguments\n"	O
"@var{args}. The @var{port} argument must be a port opened either for\n"	O
"writing or for reading, but not both. The returned port will have the same\n"	O
"mode as @var{port}."	O
"\n\n"	O
"If @var{port} is open for reading, data will be read from it, passed through the\n"	O
"filter and returned. If it is open for writing, data written to the returned\n"	O
"port will be passed through filter and its output will be written to @var{port}.\n"	O
)	O
{	O
return	O
make_filter_port	int
(	O
port	O
,	O
name	O
,	O
args	O
,	O
MU_FILTER_DECODE	O
,	O
FUNC_NAME	int
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	O
(	O
scm_mu_header_decode	pointer
,	O
"mu-header-decode"	pointer
,	O
1	int
,	O
1	int
,	O
0	int
,	O
(	int
SCM	O
hdr	O
,	O
SCM	O
charset	O
)	O
,	O
"Decode the header value @var{hdr}, encoded as per RFC 2047.\n"	O
"Optional @var{charset} defaults to @samp{utf-8}.\n"	O
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	O
res	int
;	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
hdr	O
)	O
,	O
hdr	O
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	O
(	O
0	O
)	O
;	O
if	O
(	O
SCM_UNBNDP	O
(	O
charset	int
)	O
)	O
c_charset	O
=	O
"utf-8"	int
;	O
else	O
{	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
charset	pointer
)	O
,	O
charset	O
,	O
SCM_ARG2	int
,	O
FUNC_NAME	O
)	O
;	O
c_charset	O
=	O
scm_to_locale_string	function
(	O
charset	O
)	O
;	O
scm_dynwind_free	O
(	O
c_charset	O
)	O
;	O
}	O
c_hdr	O
=	O
scm_to_locale_string	function
(	O
hdr	O
)	O
;	O
scm_dynwind_free	O
(	O
c_hdr	O
)	O
;	O
rc	O
=	O
mu_rfc2047_decode	function
(	O
c_charset	O
,	O
c_hdr	int
,	O
&	int
c_res	pointer
)	O
;	O
if	O
(	O
rc	O
)	O
mu_scm_error	O
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't convert header value"	O
,	O
SCM_BOOL_F	int
)	O
;	O
scm_dynwind_end	O
(	O
)	O
;	O
res	O
=	O
scm_from_locale_string	function
(	O
c_res	O
)	O
;	O
free	O
(	O
c_res	pointer
)	O
;	O
return	O
res	int
;	O
}	O
SCM_DEFINE_PUBLIC	O
(	O
scm_mu_header_encode	pointer
,	O
"mu-header-encode"	pointer
,	O
1	int
,	O
2	int
,	O
0	int
,	O
(	int
SCM	O
hdr	O
,	O
SCM	O
encoding	O
,	O
SCM	O
charset	O
)	O
,	O
"Encode the string @var{hdr} as per RFC 2047.\n"	O
"Both @var{encoding} and @var{charset} are optional.\n"	O
"Allowed values for @var{encoding} are @samp{base64} and @samp{quoted-printable}.\n"	O
"Default is selected depending on number of printable characters in @var{hdr}.\n"	O
"Optional @var{charset} defaults to @samp{utf-8}.\n"	O
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_encoding	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	O
res	int
;	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
hdr	O
)	O
,	O
hdr	O
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	O
(	O
0	O
)	O
;	O
if	O
(	O
SCM_UNBNDP	O
(	O
encoding	int
)	O
)	O
c_encoding	O
=	O
NULL	int
;	O
else	O
{	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
encoding	pointer
)	O
,	O
encoding	O
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_encoding	O
=	O
scm_to_locale_string	function
(	O
encoding	O
)	O
;	O
scm_dynwind_free	O
(	O
c_encoding	O
)	O
;	O
}	O
if	O
(	O
SCM_UNBNDP	O
(	O
charset	int
)	O
)	O
c_charset	O
=	O
"utf-8"	int
;	O
else	O
{	O
SCM_ASSERT	O
(	O
scm_is_string	O
(	O
charset	pointer
)	O
,	O
charset	O
,	O
SCM_ARG3	int
,	O
FUNC_NAME	int
)	O
;	O
c_charset	O
=	O
scm_to_locale_string	function
(	O
charset	O
)	O
;	O
scm_dynwind_free	O
(	O
c_charset	O
)	O
;	O
}	O
c_hdr	O
=	O
scm_to_locale_string	function
(	O
hdr	O
)	O
;	O
scm_dynwind_free	O
(	O
c_hdr	O
)	O
;	O
if	O
(	O
!	O
c_encoding	O
)	O
{	O
size_t	function
len	O
=	O
strlen	function
(	O
c_hdr	pointer
)	O
;	O
size_t	O
i	O
,	O
enc	int
;	O
enc	O
=	O
0	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
mu_isprint	O
(	O
c_hdr	O
[	O
i	int
]	O
)	O
)	O
enc	O
++	O
;	O
c_encoding	O
=	O
(	function
enc	O
>	O
len	O
/	O
2	int
)	O
?	O
"base64"	O
:	O
"quoted-printable"	O
;	O
}	O
rc	O
=	O
mu_rfc2047_encode	function
(	O
c_charset	O
,	O
c_encoding	O
,	O
c_hdr	O
,	O
&	O
c_res	pointer
)	O
;	O
if	O
(	O
rc	O
)	O
mu_scm_error	O
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't encode header value"	O
,	O
SCM_BOOL_F	int
)	O
;	O
scm_dynwind_end	O
(	O
)	O
;	O
res	O
=	O
scm_from_locale_string	function
(	O
c_res	O
)	O
;	O
free	O
(	O
c_res	pointer
)	O
;	O
return	O
res	int
;	O
}	O
void	O
mu_scm_filter_init	function
(	O
void	O
)	O
{	O
}	O