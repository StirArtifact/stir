void	O
ldelf_map_segments	O
(	O
bfd_boolean	O
need_layout	O
)	O
{	O
int	O
tries	int
=	O
10	O
;	O
do	O
{	O
lang_relax_sections	O
(	O
need_layout	O
)	O
;	O
need_layout	O
=	O
FALSE	O
;	O
if	O
(	O
link_info	O
.	O
output_bfd	pointer
->	O
xvec	pointer
->	O
flavour	pointer
==	O
bfd_target_elf_flavour	O
&&	O
!	pointer
bfd_link_relocatable	pointer
(	O
&	pointer
link_info	pointer
)	O
)	O
{	O
bfd_size_type	O
phdr_size	O
;	O
phdr_size	O
=	O
elf_program_header_size	O
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
;	O
if	O
(	O
lang_phdr_list	int
==	O
NULL	O
)	O
elf_seg_map	O
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
=	O
NULL	int
;	O
if	O
(	O
!	O
_bfd_elf_map_sections_to_segments	O
(	O
link_info	pointer
.	O
output_bfd	pointer
,	O
&	pointer
link_info	pointer
)	O
)	O
einfo	O
(	O
_	pointer
(	O
"%F%P: map sections to segments failed: %E\n"	pointer
)	O
)	O
;	O
if	O
(	O
phdr_size	int
!=	O
elf_program_header_size	O
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
)	O
{	O
if	O
(	O
tries	int
>	O
6	int
)	O
need_layout	O
=	O
TRUE	int
;	O
else	O
if	O
(	O
phdr_size	int
<	O
elf_program_header_size	int
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
)	O
need_layout	O
=	O
TRUE	int
;	O
else	O
elf_program_header_size	O
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
=	O
phdr_size	int
;	O
}	O
}	O
}	O
while	O
(	O
need_layout	O
&&	O
--	O
tries	O
)	O
;	O
if	O
(	O
tries	int
==	O
0	O
)	O
einfo	O
(	O
_	pointer
(	O
"%F%P: looping in map_segments"	pointer
)	O
)	O
;	O
}	O
int	O
ldelf_emit_ctf_early	function
(	O
void	O
)	O
{	O
if	O
(	O
bfd_get_flavour	O
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
struct	O
ctf_strsym_iter_cb_arg	struct
{	O
struct	O
elf_sym_strtab	struct
*	O
syms	pointer
;	O
bfd_size_type	O
symcount	O
;	O
struct	O
elf_strtab_hash	struct
*	O
symstrtab	pointer
;	O
size_t	O
next_i	long
;	O
size_t	O
next_idx	long
;	O
}	O
;	O
static	O
const	O
char	O
*	O
ldelf_ctf_strtab_iter_cb	function
(	O
uint32_t	O
*	O
offset	pointer
,	O
void	O
*	O
arg_	pointer
)	O
{	O
bfd_size_type	O
off	O
;	O
const	O
char	O
*	O
ret	pointer
;	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
arg	pointer
=	O
(	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
)	O
arg_	pointer
;	O
if	O
(	O
arg	O
->	O
next_i	pointer
==	O
0	O
)	O
arg	O
->	O
next_i	pointer
=	O
1	O
;	O
if	pointer
(	O
arg	pointer
->	O
next_i	pointer
>=	O
_bfd_elf_strtab_len	int
(	O
arg	pointer
->	O
symstrtab	pointer
)	O
)	O
{	O
arg	O
->	O
next_i	pointer
=	O
0	O
;	O
return	pointer
NULL	int
;	O
}	O
ret	O
=	O
_bfd_elf_strtab_str	O
(	O
arg	pointer
->	O
symstrtab	pointer
,	O
arg	pointer
->	O
next_i	pointer
++	O
,	O
&	O
off	pointer
)	O
;	O
*	O
offset	pointer
=	O
off	O
;	O
if	O
(	O
*	O
offset	pointer
!=	O
off	O
)	O
return	O
NULL	O
;	O
return	O
ret	int
;	O
}	O
static	O
struct	O
ctf_link_sym	struct
*	O
ldelf_ctf_symbols_iter_cb	function
(	O
struct	O
ctf_link_sym	struct
*	O
dest	pointer
,	O
void	O
*	O
arg_	pointer
)	O
{	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
arg	pointer
=	O
(	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
)	O
arg_	pointer
;	O
if	O
(	O
arg	O
->	O
next_i	pointer
>	O
arg	int
->	O
symcount	pointer
)	O
{	O
arg	O
->	O
next_i	pointer
=	O
0	O
;	O
arg	pointer
->	O
next_idx	pointer
=	O
0	O
;	O
return	pointer
NULL	int
;	O
}	O
ASSERT	O
(	O
arg	pointer
->	O
syms	pointer
[	O
arg	int
->	O
next_i	pointer
]	O
.	O
dest_index	pointer
==	O
arg	O
->	O
next_idx	pointer
)	O
;	O
dest	O
->	O
st_name	pointer
=	O
_bfd_elf_strtab_str	O
(	O
arg	pointer
->	O
symstrtab	pointer
,	O
arg	pointer
->	O
next_i	pointer
,	O
NULL	pointer
)	O
;	O
dest	O
->	O
st_shndx	pointer
=	O
arg	O
->	O
syms	pointer
[	O
arg	int
->	O
next_i	pointer
]	O
.	O
sym	pointer
.	O
st_shndx	pointer
;	O
dest	O
->	O
st_type	pointer
=	O
ELF_ST_TYPE	O
(	O
arg	pointer
->	O
syms	pointer
[	O
arg	int
->	O
next_i	pointer
]	O
.	O
sym	pointer
.	O
st_info	pointer
)	O
;	O
dest	O
->	O
st_value	pointer
=	O
arg	O
->	O
syms	pointer
[	O
arg	int
->	O
next_i	pointer
]	O
.	O
sym	pointer
.	O
st_value	pointer
;	O
arg	O
->	O
next_i	pointer
++	O
;	O
return	O
dest	int
;	O
}	O
void	O
ldelf_examine_strtab_for_ctf	function
(	O
struct	O
ctf_file	struct
*	O
ctf_output	pointer
,	O
struct	O
elf_sym_strtab	struct
*	O
syms	pointer
,	O
bfd_size_type	O
symcount	O
,	O
struct	O
elf_strtab_hash	struct
*	O
symstrtab	pointer
)	O
{	O
struct	O
ctf_strsym_iter_cb_arg	struct
args	O
=	O
{	O
syms	O
,	O
symcount	pointer
,	O
symstrtab	pointer
,	O
0	pointer
,	O
0	int
}	O
;	O
if	O
(	O
!	O
ctf_output	pointer
)	O
return	O
;	O
if	O
(	O
bfd_get_flavour	pointer
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	O
&&	O
!	pointer
bfd_link_relocatable	O
(	O
&	pointer
link_info	pointer
)	O
)	O
{	O
if	O
(	O
ctf_link_add_strtab	O
(	O
ctf_output	pointer
,	O
ldelf_ctf_strtab_iter_cb	pointer
,	O
&	pointer
args	pointer
)	O
<	O
0	int
)	O
einfo	O
(	O
_	pointer
(	O
"%F%P: warning: CTF strtab association failed; strings will "	pointer
"not be shared: %s\n"	O
)	O
,	O
ctf_errmsg	pointer
(	O
ctf_errno	pointer
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
if	O
(	O
ctf_link_shuffle_syms	O
(	O
ctf_output	pointer
,	O
ldelf_ctf_symbols_iter_cb	pointer
,	O
&	pointer
args	pointer
)	O
<	O
0	int
)	O
einfo	O
(	O
_	pointer
(	O
"%F%P: warning: CTF symbol shuffling failed; slight space "	pointer
"cost: %s\n"	O
)	O
,	O
ctf_errmsg	pointer
(	O
ctf_errno	pointer
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
}	O
}	O