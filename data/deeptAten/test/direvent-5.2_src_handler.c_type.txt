struct	O
handler	struct
*	O
handler_alloc	pointer
(	O
event_mask	O
ev_mask	O
)	O
{	O
struct	O
handler	struct
*	O
hp	pointer
=	O
ecalloc	O
(	O
1	int
,	O
sizeof	O
(	O
*	O
hp	pointer
)	O
)	O
;	O
hp	O
->	O
refcnt	pointer
=	O
0	O
;	O
hp	O
->	O
ev_mask	pointer
=	O
ev_mask	O
;	O
return	pointer
hp	O
;	O
}	O
void	O
watchpoint_run_handlers	function
(	O
struct	O
watchpoint	struct
*	O
wp	pointer
,	O
int	O
evflags	O
,	O
const	O
char	O
*	O
dirname	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
handler_iterator_t	O
itr	O
;	O
struct	O
handler	struct
*	O
hp	pointer
;	O
event_mask	O
m	O
;	O
for_each_handler	O
(	O
wp	O
,	O
itr	pointer
,	O
hp	int
)	O
{	O
if	O
(	O
handler_matches_event	pointer
(	O
hp	pointer
,	O
sys	pointer
,	O
evflags	pointer
,	O
filename	pointer
)	O
)	O
hp	O
->	O
run	pointer
(	O
wp	pointer
,	O
event_mask_init	pointer
(	O
&	pointer
m	pointer
,	O
evflags	O
,	O
&	O
hp	pointer
->	O
ev_mask	pointer
)	O
,	O
dirname	O
,	O
filename	O
,	O
hp	O
->	O
data	pointer
)	O
;	O
}	O
}	O
static	O
void	O
handler_ref	function
(	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
++	O
hp	O
->	O
refcnt	pointer
;	O
}	O
void	O
handler_free	function
(	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
filpatlist_destroy	O
(	O
&	pointer
hp	pointer
->	O
fnames	pointer
)	O
;	O
if	O
(	O
hp	pointer
->	O
free	pointer
)	O
hp	O
->	O
free	pointer
(	O
hp	pointer
->	O
data	pointer
)	O
;	O
}	O
static	O
void	O
handler_unref	function
(	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
if	O
(	O
hp	pointer
&&	O
--	pointer
hp	O
->	O
refcnt	pointer
)	O
{	O
handler_free	O
(	O
hp	pointer
)	O
;	O
free	O
(	O
hp	pointer
)	O
;	O
}	O
}	O
static	O
void	O
handler_listent_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
struct	O
handler	struct
*	O
hp	pointer
=	O
p	O
;	O
handler_unref	O
(	O
hp	O
)	O
;	O
}	O
struct	O
handler_list	struct
{	O
size_t	O
refcnt	struct
;	O
grecs_list_ptr_t	O
list	O
;	O
struct	O
handler_iterator	struct
*	O
itr_chain	pointer
;	O
}	O
;	O
struct	O
handler_iterator	struct
{	O
struct	O
handler_iterator	struct
*	O
prev	pointer
,	O
*	O
next	pointer
;	O
handler_list_t	O
hlist	O
;	O
struct	O
grecs_list_entry	struct
*	O
ent	pointer
;	O
int	O
advanced	int
;	O
}	O
;	O
static	O
struct	O
handler_iterator	struct
*	O
itr_avail	function
;	O
struct	O
handler	struct
*	O
handler_itr_first	pointer
(	O
struct	O
watchpoint	struct
*	O
wpt	pointer
,	O
handler_iterator_t	O
*	O
ret_itr	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
wpt	pointer
->	O
handler_list	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
itr_avail	pointer
)	O
{	O
itr	O
=	O
itr_avail	function
;	O
itr_avail	O
=	O
itr	O
->	O
next	pointer
;	O
if	O
(	O
itr_avail	pointer
)	O
itr_avail	O
->	O
prev	pointer
=	O
NULL	pointer
;	O
}	pointer
else	O
itr	O
=	O
emalloc	function
(	O
sizeof	O
*	O
itr	pointer
)	O
;	O
itr	O
->	O
prev	pointer
=	O
NULL	pointer
;	O
itr	O
->	O
next	pointer
=	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
;	O
itr	pointer
->	O
hlist	pointer
=	O
wpt	O
->	O
handler_list	pointer
;	O
if	pointer
(	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
)	O
wpt	O
->	O
handler_list	pointer
->	O
itr_chain	pointer
->	O
prev	pointer
=	O
itr	pointer
;	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
=	O
itr	pointer
;	O
itr	pointer
->	O
ent	pointer
=	O
wpt	O
->	O
handler_list	pointer
->	O
list	pointer
->	O
head	pointer
;	O
itr	pointer
->	O
advanced	pointer
=	O
0	O
;	O
*	pointer
ret_itr	pointer
=	O
itr	pointer
;	O
return	O
handler_itr_current	int
(	O
itr	pointer
)	O
;	O
}	O
struct	O
handler	struct
*	O
handler_itr_next	function
(	O
handler_iterator_t	O
*	O
pitr	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
pitr	pointer
||	O
(	O
itr	O
=	O
*	O
pitr	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
itr	pointer
->	O
advanced	pointer
)	O
itr	O
->	O
advanced	int
=	O
0	O
;	O
else	O
itr	O
->	O
ent	pointer
=	O
itr	O
->	O
ent	pointer
->	O
next	pointer
;	O
if	pointer
(	O
!	pointer
itr	O
->	O
ent	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
p	pointer
;	O
if	pointer
(	O
(	pointer
p	O
=	O
itr	O
->	O
prev	int
)	O
!=	O
NULL	O
)	O
p	O
->	O
next	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
else	pointer
itr	O
->	O
hlist	pointer
->	O
itr_chain	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
if	pointer
(	O
(	pointer
p	O
=	O
itr	O
->	O
next	int
)	O
!=	O
NULL	O
)	O
p	O
->	O
prev	pointer
=	O
itr	pointer
->	O
prev	pointer
;	O
if	pointer
(	O
itr_avail	pointer
)	O
itr_avail	O
->	O
prev	pointer
=	O
itr	pointer
;	O
itr	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
itr	pointer
->	O
next	pointer
=	O
itr_avail	O
;	O
itr	pointer
->	O
hlist	pointer
=	O
NULL	O
;	O
itr_avail	pointer
=	O
itr	O
;	O
*	O
pitr	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
return	O
handler_itr_current	O
(	O
itr	pointer
)	O
;	O
}	O
struct	O
handler	struct
*	O
handler_itr_current	function
(	O
handler_iterator_t	O
itr	O
)	O
{	O
if	O
(	O
!	pointer
itr	pointer
)	O
return	O
NULL	O
;	O
return	O
itr	int
->	O
ent	int
?	O
itr	O
->	O
ent	pointer
->	O
data	pointer
:	O
NULL	O
;	O
}	pointer
handler_list_t	O
handler_list_create	O
(	O
void	O
)	O
{	O
handler_list_t	O
hlist	O
=	O
emalloc	pointer
(	O
sizeof	O
(	O
*	O
hlist	pointer
)	O
)	O
;	O
hlist	O
->	O
list	pointer
=	O
grecs_list_create	O
(	O
)	O
;	O
hlist	O
->	O
list	pointer
->	O
free_entry	pointer
=	O
handler_listent_free	O
;	O
hlist	pointer
->	O
refcnt	pointer
=	O
1	int
;	O
hlist	pointer
->	O
itr_chain	pointer
=	O
NULL	O
;	O
return	pointer
hlist	int
;	O
}	O
size_t	O
handler_list_size	O
(	O
handler_list_t	O
hlist	O
)	O
{	O
return	O
grecs_list_size	int
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
}	O
handler_list_t	O
handler_list_copy	O
(	O
handler_list_t	O
orig	O
)	O
{	O
if	O
(	O
!	pointer
orig	pointer
)	O
return	O
handler_list_create	O
(	O
)	pointer
;	O
++	O
orig	O
->	O
refcnt	pointer
;	O
return	O
orig	O
;	O
}	O
void	O
handler_list_unref	function
(	O
handler_list_t	O
hlist	O
)	O
{	O
if	O
(	O
hlist	O
)	O
{	O
if	O
(	O
--	pointer
hlist	O
->	O
refcnt	pointer
==	O
0	int
)	O
{	O
grecs_list_free	O
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
free	O
(	O
hlist	pointer
)	O
;	O
}	O
}	O
}	O
void	O
handler_list_append	function
(	O
handler_list_t	O
hlist	O
,	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
handler_ref	O
(	O
hp	O
)	O
;	O
grecs_list_append	O
(	O
hlist	pointer
->	O
list	pointer
,	O
hp	pointer
)	O
;	O
}	O
size_t	O
handler_list_remove	O
(	O
handler_list_t	O
hlist	O
,	O
struct	pointer
handler	struct
*	O
hp	pointer
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	int
=	O
hlist	pointer
->	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
if	O
(	O
ep	pointer
->	O
data	pointer
==	O
hp	O
)	O
break	O
;	O
if	pointer
(	O
!	pointer
ep	pointer
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
hlist	pointer
->	O
itr_chain	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	O
;	O
for	O
(	O
itr	int
=	O
hlist	int
->	O
itr_chain	pointer
;	O
itr	pointer
;	O
itr	O
=	O
itr	function
->	O
next	int
)	O
if	O
(	O
itr	pointer
->	O
ent	pointer
==	O
ep	O
)	O
{	O
itr	O
->	O
ent	int
=	O
ep	O
->	O
next	pointer
;	O
itr	pointer
->	O
advanced	pointer
=	O
1	int
;	O
}	pointer
}	O
grecs_list_remove_entry	O
(	O
hlist	pointer
->	O
list	pointer
,	O
ep	O
)	O
;	O
return	O
grecs_list_size	int
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
}	O