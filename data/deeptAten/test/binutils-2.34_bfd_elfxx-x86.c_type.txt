bfd_boolean	int
_bfd_x86_elf_mkobject	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
bfd_elf_allocate_object	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
struct	O
elf_x86_obj_tdata	struct
)	O
,	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
target_id	enum
)	O
;	O
}	O
void	O
_bfd_x86_elf_set_tls_module_base	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
bfd_link_hash_entry	struct
*	O
base	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
return	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
;	O
base	int
=	O
htab	struct
->	O
tls_module_base	pointer
;	O
if	O
(	O
base	int
==	O
NULL	O
)	O
return	O
;	O
base	int
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
htab	struct
->	O
elf	struct
.	O
tls_size	long
;	O
}	O
bfd_vma	long
_bfd_x86_elf_dtpoff_base	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
tls_sec	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
return	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
tls_sec	pointer
->	O
vma	long
;	O
}	O
static	O
bfd_boolean	int
elf_x86_allocate_dynrelocs	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
unsigned	O
int	O
plt_entry_size	int
;	O
bfd_boolean	int
resolved_to_zero	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
return	O
TRUE	int
;	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
plt_entry_size	int
=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
resolved_to_zero	int
=	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
eh	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
plt_got	union
!=	O
NULL	O
&&	O
h	pointer
->	O
type	enum
!=	O
STT_GNU_IFUNC	int
&&	O
!	O
h	pointer
->	O
pointer_equality_needed	int
&&	O
h	pointer
->	O
plt	union
.	O
refcount	int
>	O
0	int
&&	O
h	pointer
->	O
got	union
.	O
refcount	int
>	O
0	int
)	O
{	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
eh	pointer
->	O
plt_got	union
.	O
refcount	int
=	O
1	int
;	O
}	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
h	pointer
->	O
def_regular	int
)	O
{	O
if	O
(	O
_bfd_elf_allocate_ifunc_dyn_relocs	function
(	O
info	pointer
,	O
h	pointer
,	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
,	O
&	O
htab	struct
->	O
readonly_dynrelocs_against_ifunc	int
,	O
plt_entry_size	int
,	O
(	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
*	O
plt_entry_size	int
)	O
,	O
htab	struct
->	O
got_entry_size	int
,	O
TRUE	int
)	O
)	O
{	O
asection	struct
*	O
s	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
s	pointer
!=	O
NULL	O
)	O
{	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
=	O
s	pointer
->	O
size	long
;	O
s	pointer
->	O
size	long
+=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
else	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
&&	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
>	O
0	int
||	O
eh	pointer
->	O
plt_got	union
.	O
refcount	int
>	O
0	int
)	O
)	O
{	O
bfd_boolean	int
use_plt_got	int
=	O
eh	pointer
->	O
plt_got	union
.	O
refcount	int
>	O
0	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
!	O
h	pointer
->	O
forced_local	int
&&	O
!	O
resolved_to_zero	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
WILL_CALL_FINISH_DYNAMIC_SYMBOL	O
(	O
1	int
,	O
0	int
,	O
h	pointer
)	O
)	O
{	O
asection	struct
*	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
asection	struct
*	O
second_s	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
asection	struct
*	O
got_s	pointer
=	O
htab	struct
->	O
plt_got	union
;	O
bfd_boolean	int
use_plt	int
;	O
if	O
(	O
s	pointer
->	O
size	long
==	O
0	int
)	O
s	pointer
->	O
size	long
=	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
*	O
plt_entry_size	int
;	O
if	O
(	O
use_plt_got	int
)	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
=	O
got_s	pointer
->	O
size	long
;	O
else	O
{	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
s	pointer
->	O
size	long
;	O
if	O
(	O
second_s	pointer
)	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
=	O
second_s	pointer
->	O
size	long
;	O
}	O
if	O
(	O
h	pointer
->	O
def_regular	int
)	O
use_plt	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
htab	struct
->	O
pcrel_plt	int
)	O
use_plt	int
=	O
!	O
bfd_link_dll	O
(	O
info	pointer
)	O
;	O
else	O
use_plt	int
=	O
bfd_link_pde	O
(	O
info	pointer
)	O
;	O
if	O
(	O
use_plt	int
)	O
{	O
if	O
(	O
use_plt_got	int
)	O
{	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
got_s	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
;	O
}	O
else	O
{	O
if	O
(	O
second_s	pointer
)	O
{	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
second_s	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
s	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
}	O
}	O
if	O
(	O
use_plt_got	int
)	O
got_s	pointer
->	O
size	long
+=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
else	O
{	O
s	pointer
->	O
size	long
+=	O
plt_entry_size	int
;	O
if	O
(	O
second_s	pointer
)	O
second_s	pointer
->	O
size	long
+=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
+=	O
htab	struct
->	O
got_entry_size	int
;	O
if	O
(	O
!	O
resolved_to_zero	int
)	O
{	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
reloc_count	int
++	O
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
&&	O
!	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
asection	struct
*	O
srelplt2	pointer
=	O
htab	struct
->	O
srelplt2	pointer
;	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
plt_entry_size	int
)	O
srelplt2	pointer
->	O
size	long
+=	O
(	O
htab	struct
->	O
sizeof_reloc	int
*	O
2	int
)	O
;	O
srelplt2	pointer
->	O
size	long
+=	O
(	O
htab	struct
->	O
sizeof_reloc	int
*	O
2	int
)	O
;	O
}	O
}	O
else	O
{	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
h	pointer
->	O
needs_plt	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
h	pointer
->	O
needs_plt	int
=	O
0	int
;	O
}	O
eh	pointer
->	O
tlsdesc_got	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
if	O
(	O
h	pointer
->	O
got	union
.	O
refcount	int
>	O
0	int
&&	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
(	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
&	O
GOT_TLS_IE	int
)	O
)	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
else	O
if	O
(	O
h	pointer
->	O
got	union
.	O
refcount	int
>	O
0	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_boolean	int
dyn	int
;	O
int	O
tls_type	char
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
!	O
h	pointer
->	O
forced_local	int
&&	O
!	O
resolved_to_zero	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
{	O
eh	pointer
->	O
tlsdesc_got	long
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
-	O
elf_x86_compute_jump_table_size	O
(	O
htab	struct
)	O
;	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
+=	O
2	int
*	O
htab	struct
->	O
got_entry_size	int
;	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
2	int
;	O
}	O
if	O
(	O
!	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
||	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
)	O
{	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
s	pointer
->	O
size	long
;	O
s	pointer
->	O
size	long
+=	O
htab	struct
->	O
got_entry_size	int
;	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
||	O
tls_type	char
==	O
GOT_TLS_IE_BOTH	int
)	O
s	pointer
->	O
size	long
+=	O
htab	struct
->	O
got_entry_size	int
;	O
}	O
dyn	int
=	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
;	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE_BOTH	int
)	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
->	O
size	long
+=	O
2	int
*	O
htab	struct
->	O
sizeof_reloc	int
;	O
else	O
if	O
(	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
&&	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
)	O
||	O
(	O
tls_type	char
&	O
GOT_TLS_IE	int
)	O
)	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
else	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
)	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
->	O
size	long
+=	O
2	int
*	O
htab	struct
->	O
sizeof_reloc	int
;	O
else	O
if	O
(	O
!	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
&&	O
(	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_DEFAULT	int
&&	O
!	O
resolved_to_zero	int
)	O
||	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
)	O
&&	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
WILL_CALL_FINISH_DYNAMIC_SYMBOL	O
(	O
dyn	int
,	O
0	int
,	O
h	pointer
)	O
)	O
)	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
{	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
if	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
)	O
htab	struct
->	O
tlsdesc_plt	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
}	O
else	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
if	O
(	O
eh	pointer
->	O
dyn_relocs	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
SYMBOL_CALLS_LOCAL	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
pp	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
;	O
)	O
{	O
p	pointer
->	O
count	int
-=	O
p	pointer
->	O
pc_count	long
;	O
p	pointer
->	O
pc_count	long
=	O
0	int
;	O
if	O
(	O
p	pointer
->	O
count	int
==	O
0	int
)	O
*	O
pp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
pp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
pp	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
;	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
sec	pointer
->	O
output_section	pointer
->	O
name	pointer
,	O
".tls_vars"	pointer
)	O
==	O
0	int
)	O
*	O
pp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
pp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
}	O
if	O
(	O
eh	pointer
->	O
dyn_relocs	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_DEFAULT	int
||	O
resolved_to_zero	int
)	O
{	O
if	O
(	O
bed	pointer
->	O
target_id	enum
==	O
I386_ELF_DATA	int
&&	O
h	pointer
->	O
non_got_ref	int
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
pp	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
;	O
)	O
if	O
(	O
p	pointer
->	O
pc_count	long
==	O
0	int
)	O
*	O
pp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
{	O
p	pointer
->	O
count	int
=	O
p	pointer
->	O
pc_count	long
;	O
pp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
eh	pointer
->	O
dyn_relocs	pointer
!=	O
NULL	O
&&	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
eh	pointer
->	O
dyn_relocs	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
!	O
h	pointer
->	O
forced_local	int
&&	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
(	O
h	pointer
->	O
needs_copy	int
||	O
eh	pointer
->	O
needs_copy	int
)	O
&&	O
h	pointer
->	O
def_dynamic	int
&&	O
!	O
h	pointer
->	O
def_regular	int
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
pp	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
;	O
)	O
{	O
if	O
(	O
p	pointer
->	O
pc_count	long
!=	O
0	int
)	O
*	O
pp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
pp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
ELIMINATE_COPY_RELOCS	int
)	O
{	O
if	O
(	O
(	O
!	O
h	pointer
->	O
non_got_ref	int
||	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
!	O
resolved_to_zero	int
)	O
)	O
&&	O
(	O
(	O
h	pointer
->	O
def_dynamic	int
&&	O
!	O
h	pointer
->	O
def_regular	int
)	O
||	O
(	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
&&	O
!	O
h	pointer
->	O
forced_local	int
&&	O
!	O
resolved_to_zero	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
goto	O
keep	O
;	O
}	O
eh	pointer
->	O
dyn_relocs	pointer
=	O
NULL	O
;	O
keep	O
:	O
;	O
}	O
for	O
(	O
p	pointer
=	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
asection	struct
*	O
sreloc	pointer
;	O
sreloc	pointer
=	O
elf_section_data	O
(	O
p	pointer
->	O
sec	pointer
)	O
->	O
sreloc	pointer
;	O
BFD_ASSERT	O
(	O
sreloc	pointer
!=	O
NULL	O
)	O
;	O
sreloc	pointer
->	O
size	long
+=	O
p	pointer
->	O
count	int
*	O
htab	struct
->	O
sizeof_reloc	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
asection	struct
*	O
readonly_dynrelocs	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
dyn_relocs	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
asection	struct
*	O
s	pointer
=	O
p	pointer
->	O
sec	pointer
->	O
output_section	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
)	O
return	O
p	pointer
->	O
sec	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
maybe_set_textrel	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
forced_local	int
&&	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
return	O
TRUE	int
;	O
sec	pointer
=	O
readonly_dynrelocs	function
(	O
h	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
{	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
info	pointer
->	O
flags	int
|=	O
DF_TEXTREL	O
;	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"%pB: dynamic relocation against `%pT' "	pointer
"in read-only section `%pA'\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
(	O
info	pointer
->	O
warn_shared_textrel	int
&&	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
||	O
info	pointer
->	O
error_textrel	int
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P: %pB: warning: relocation against `%s' "	pointer
"in read-only section `%pA'\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
sec	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_allocate_local_dynreloc	function
(	O
void	O
*	O
*	O
slot	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
*	O
slot	pointer
;	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
STT_GNU_IFUNC	int
||	O
!	O
h	pointer
->	O
def_regular	int
||	O
!	O
h	pointer
->	O
ref_regular	int
||	O
!	O
h	pointer
->	O
forced_local	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
)	O
abort	function
(	O
)	O
;	O
return	O
elf_x86_allocate_dynrelocs	function
(	O
h	pointer
,	O
inf	pointer
)	O
;	O
}	O
struct	O
elf_link_hash_entry	struct
*	O
_bfd_elf_x86_get_local_sym_hash	function
(	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
,	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
bfd_boolean	int
create	int
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
e	struct
,	O
*	O
ret	pointer
;	O
asection	struct
*	O
sec	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
hashval_t	int
h	pointer
=	O
ELF_LOCAL_SYMBOL_HASH	O
(	O
sec	pointer
->	O
id	int
,	O
htab	struct
->	O
r_sym	pointer
(	O
rel	pointer
->	O
r_info	array
)	O
)	O
;	O
void	O
*	O
*	O
slot	pointer
;	O
e	struct
.	O
elf	struct
.	O
indx	long
=	O
sec	pointer
->	O
id	int
;	O
e	struct
.	O
elf	struct
.	O
dynstr_index	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
slot	pointer
=	O
htab_find_slot_with_hash	function
(	O
htab	struct
->	O
loc_hash_table	pointer
,	O
&	O
e	struct
,	O
h	pointer
,	O
create	int
?	O
INSERT	int
:	O
NO_INSERT	int
)	O
;	O
if	O
(	O
!	O
slot	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
*	O
slot	pointer
)	O
{	O
ret	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
*	O
slot	pointer
;	O
return	O
&	O
ret	pointer
->	O
elf	struct
;	O
}	O
ret	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
objalloc_alloc	O
(	O
(	O
struct	O
objalloc	struct
*	O
)	O
htab	struct
->	O
loc_hash_memory	pointer
,	O
sizeof	O
(	O
struct	O
elf_x86_link_hash_entry	struct
)	O
)	O
;	O
if	O
(	O
ret	pointer
)	O
{	O
memset	function
(	O
ret	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
ret	pointer
)	O
)	O
;	O
ret	pointer
->	O
elf	struct
.	O
indx	long
=	O
sec	pointer
->	O
id	int
;	O
ret	pointer
->	O
elf	struct
.	O
dynstr_index	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
ret	pointer
->	O
elf	struct
.	O
dynindx	long
=	O
-	O
1	int
;	O
ret	pointer
->	O
plt_got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
*	O
slot	pointer
=	O
ret	pointer
;	O
}	O
return	O
&	O
ret	pointer
->	O
elf	struct
;	O
}	O
struct	O
bfd_hash_entry	struct
*	O
_bfd_x86_elf_link_hash_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
entry	pointer
=	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
elf_x86_link_hash_entry	struct
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
entry	pointer
;	O
}	O
entry	pointer
=	O
_bfd_link_hash_newfunc	function
(	O
entry	pointer
,	O
table	pointer
,	O
string	pointer
)	O
;	O
if	O
(	O
entry	pointer
!=	O
NULL	O
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
entry	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
(	O
struct	O
elf_link_hash_table	struct
*	O
)	O
table	pointer
;	O
memset	function
(	O
&	O
eh	pointer
->	O
elf	struct
.	O
size	long
,	O
0	int
,	O
(	O
sizeof	O
(	O
struct	O
elf_x86_link_hash_entry	struct
)	O
-	O
offsetof	O
(	O
struct	O
elf_link_hash_entry	struct
,	O
size	long
)	O
)	O
)	O
;	O
eh	pointer
->	O
elf	struct
.	O
indx	long
=	O
-	O
1	int
;	O
eh	pointer
->	O
elf	struct
.	O
dynindx	long
=	O
-	O
1	int
;	O
eh	pointer
->	O
elf	struct
.	O
got	union
=	O
htab	struct
->	O
init_got_refcount	union
;	O
eh	pointer
->	O
elf	struct
.	O
plt	union
=	O
htab	struct
->	O
init_plt_refcount	union
;	O
eh	pointer
->	O
elf	struct
.	O
non_elf	int
=	O
1	int
;	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
eh	pointer
->	O
tlsdesc_got	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
eh	pointer
->	O
zero_undefweak	int
=	O
1	int
;	O
}	O
return	O
entry	pointer
;	O
}	O
hashval_t	int
_bfd_x86_elf_local_htab_hash	function
(	O
const	O
void	O
*	O
ptr	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
ptr	pointer
;	O
return	O
ELF_LOCAL_SYMBOL_HASH	O
(	O
h	pointer
->	O
indx	long
,	O
h	pointer
->	O
dynstr_index	long
)	O
;	O
}	O
int	O
_bfd_x86_elf_local_htab_eq	function
(	O
const	O
void	O
*	O
ptr1	pointer
,	O
const	O
void	O
*	O
ptr2	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h1	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
ptr1	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
h2	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
ptr2	pointer
;	O
return	O
h1	pointer
->	O
indx	long
==	O
h2	pointer
->	O
indx	long
&&	O
h1	pointer
->	O
dynstr_index	long
==	O
h2	pointer
->	O
dynstr_index	long
;	O
}	O
static	O
void	O
elf_x86_link_hash_table_free	function
(	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
(	O
struct	O
elf_x86_link_hash_table	struct
*	O
)	O
obfd	pointer
->	O
link	function
.	O
hash	long
;	O
if	O
(	O
htab	struct
->	O
loc_hash_table	pointer
)	O
htab_delete	function
(	O
htab	struct
->	O
loc_hash_table	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
loc_hash_memory	pointer
)	O
objalloc_free	function
(	O
(	O
struct	O
objalloc	struct
*	O
)	O
htab	struct
->	O
loc_hash_memory	pointer
)	O
;	O
_bfd_elf_link_hash_table_free	function
(	O
obfd	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_i386_is_reloc_section	function
(	O
const	O
char	O
*	O
secname	pointer
)	O
{	O
return	O
CONST_STRNEQ	O
(	O
secname	pointer
,	O
".rel"	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_is_reloc_section	function
(	O
const	O
char	O
*	O
secname	pointer
)	O
{	O
return	O
CONST_STRNEQ	O
(	O
secname	pointer
,	O
".rela"	pointer
)	O
;	O
}	O
struct	O
bfd_link_hash_table	struct
*	O
_bfd_x86_elf_link_hash_table_create	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
ret	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
elf_x86_link_hash_table	struct
)	O
;	O
ret	pointer
=	O
(	O
struct	O
elf_x86_link_hash_table	struct
*	O
)	O
bfd_zmalloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_elf_link_hash_table_init	function
(	O
&	O
ret	pointer
->	O
elf	struct
,	O
abfd	pointer
,	O
_bfd_x86_elf_link_hash_newfunc	function
,	O
sizeof	O
(	O
struct	O
elf_x86_link_hash_entry	struct
)	O
,	O
bed	pointer
->	O
target_id	enum
)	O
)	O
{	O
free	function
(	O
ret	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
)	O
{	O
ret	pointer
->	O
is_reloc_section	pointer
=	O
elf_x86_64_is_reloc_section	function
;	O
ret	pointer
->	O
dt_reloc	int
=	O
DT_RELA	int
;	O
ret	pointer
->	O
dt_reloc_sz	int
=	O
DT_RELASZ	int
;	O
ret	pointer
->	O
dt_reloc_ent	int
=	O
DT_RELAENT	int
;	O
ret	pointer
->	O
got_entry_size	int
=	O
8	int
;	O
ret	pointer
->	O
pcrel_plt	int
=	O
TRUE	int
;	O
ret	pointer
->	O
tls_get_addr	int
=	O
"__tls_get_addr"	pointer
;	O
}	O
if	O
(	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
{	O
ret	pointer
->	O
sizeof_reloc	int
=	O
sizeof	O
(	O
Elf64_External_Rela	struct
)	O
;	O
ret	pointer
->	O
pointer_r_type	int
=	O
R_X86_64_64	int
;	O
ret	pointer
->	O
dynamic_interpreter	pointer
=	O
ELF64_DYNAMIC_INTERPRETER	pointer
;	O
ret	pointer
->	O
dynamic_interpreter_size	int
=	O
sizeof	O
ELF64_DYNAMIC_INTERPRETER	pointer
;	O
}	O
else	O
{	O
if	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
)	O
{	O
ret	pointer
->	O
sizeof_reloc	int
=	O
sizeof	O
(	O
Elf32_External_Rela	struct
)	O
;	O
ret	pointer
->	O
pointer_r_type	int
=	O
R_X86_64_32	int
;	O
ret	pointer
->	O
dynamic_interpreter	pointer
=	O
ELFX32_DYNAMIC_INTERPRETER	pointer
;	O
ret	pointer
->	O
dynamic_interpreter_size	int
=	O
sizeof	O
ELFX32_DYNAMIC_INTERPRETER	pointer
;	O
}	O
else	O
{	O
ret	pointer
->	O
is_reloc_section	pointer
=	O
elf_i386_is_reloc_section	function
;	O
ret	pointer
->	O
dt_reloc	int
=	O
DT_REL	int
;	O
ret	pointer
->	O
dt_reloc_sz	int
=	O
DT_RELSZ	int
;	O
ret	pointer
->	O
dt_reloc_ent	int
=	O
DT_RELENT	int
;	O
ret	pointer
->	O
sizeof_reloc	int
=	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
ret	pointer
->	O
got_entry_size	int
=	O
4	int
;	O
ret	pointer
->	O
pcrel_plt	int
=	O
FALSE	int
;	O
ret	pointer
->	O
pointer_r_type	int
=	O
R_386_32	int
;	O
ret	pointer
->	O
dynamic_interpreter	pointer
=	O
ELF32_DYNAMIC_INTERPRETER	pointer
;	O
ret	pointer
->	O
dynamic_interpreter_size	int
=	O
sizeof	O
ELF32_DYNAMIC_INTERPRETER	pointer
;	O
ret	pointer
->	O
tls_get_addr	int
=	O
"___tls_get_addr"	pointer
;	O
}	O
}	O
ret	pointer
->	O
target_id	enum
=	O
bed	pointer
->	O
target_id	enum
;	O
ret	pointer
->	O
target_os	enum
=	O
get_elf_x86_backend_data	O
(	O
abfd	pointer
)	O
->	O
target_os	enum
;	O
ret	pointer
->	O
loc_hash_table	pointer
=	O
htab_try_create	function
(	O
1024	int
,	O
_bfd_x86_elf_local_htab_hash	function
,	O
_bfd_x86_elf_local_htab_eq	function
,	O
NULL	O
)	O
;	O
ret	pointer
->	O
loc_hash_memory	pointer
=	O
objalloc_create	function
(	O
)	O
;	O
if	O
(	O
!	O
ret	pointer
->	O
loc_hash_table	pointer
||	O
!	O
ret	pointer
->	O
loc_hash_memory	pointer
)	O
{	O
elf_x86_link_hash_table_free	function
(	O
abfd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
ret	pointer
->	O
elf	struct
.	O
root	struct
.	O
hash_table_free	pointer
=	O
elf_x86_link_hash_table_free	function
;	O
return	O
&	O
ret	pointer
->	O
elf	struct
.	O
root	struct
;	O
}	O
int	O
_bfd_x86_elf_compare_relocs	function
(	O
const	O
void	O
*	O
ap	pointer
,	O
const	O
void	O
*	O
bp	pointer
)	O
{	O
const	O
arelent	struct
*	O
a	pointer
=	O
*	O
(	O
const	O
arelent	struct
*	O
*	O
)	O
ap	pointer
;	O
const	O
arelent	struct
*	O
b	pointer
=	O
*	O
(	O
const	O
arelent	struct
*	O
*	O
)	O
bp	pointer
;	O
if	O
(	O
a	pointer
->	O
address	long
>	O
b	pointer
->	O
address	long
)	O
return	O
1	int
;	O
else	O
if	O
(	O
a	pointer
->	O
address	long
<	O
b	pointer
->	O
address	long
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
elf_x86_linker_defined	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
||	O
(	O
!	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
)	O
{	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
local_ref	int
=	O
2	int
;	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
linker_def	int
=	O
1	int
;	O
}	O
}	O
static	O
void	O
elf_x86_hide_linker_defined	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_INTERNAL	int
||	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_HIDDEN	int
)	O
_bfd_elf_link_hash_hide_symbol	function
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_link_check_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
htab	struct
->	O
tls_get_addr	int
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_get_addr	int
=	O
1	int
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
)	O
{	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_get_addr	int
=	O
1	int
;	O
}	O
}	O
elf_x86_linker_defined	function
(	O
info	pointer
,	O
"__ehdr_start"	pointer
)	O
;	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
elf_x86_linker_defined	function
(	O
info	pointer
,	O
"__bss_start"	pointer
)	O
;	O
elf_x86_linker_defined	function
(	O
info	pointer
,	O
"_end"	pointer
)	O
;	O
elf_x86_linker_defined	function
(	O
info	pointer
,	O
"_edata"	pointer
)	O
;	O
}	O
else	O
{	O
elf_x86_hide_linker_defined	function
(	O
info	pointer
,	O
"__bss_start"	pointer
)	O
;	O
elf_x86_hide_linker_defined	function
(	O
info	pointer
,	O
"_end"	pointer
)	O
;	O
elf_x86_hide_linker_defined	function
(	O
info	pointer
,	O
"_edata"	pointer
)	O
;	O
}	O
}	O
}	O
return	O
_bfd_elf_link_check_relocs	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_size_dynamic_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
bfd	struct
*	O
dynobj	pointer
;	O
asection	struct
*	O
s	pointer
;	O
bfd_boolean	int
relocs	pointer
;	O
bfd	struct
*	O
ibfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
dynobj	pointer
=	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
;	O
if	O
(	O
dynobj	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
!=	O
NULL	O
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
bfd_signed_vma	long
*	O
local_got	union
;	O
bfd_signed_vma	long
*	O
end_local_got	pointer
;	O
char	O
*	O
local_tls_type	pointer
;	O
bfd_vma	long
*	O
local_tlsdesc_gotent	pointer
;	O
bfd_size_type	long
locsymcount	long
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
asection	struct
*	O
srel	pointer
;	O
if	O
(	O
!	O
is_x86_elf	O
(	O
ibfd	pointer
,	O
htab	struct
)	O
)	O
continue	O
;	O
for	O
(	O
s	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
(	O
(	O
struct	O
elf_dyn_relocs	struct
*	O
)	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
local_dynrel	pointer
)	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
bfd_is_abs_section	function
(	O
p	pointer
->	O
sec	pointer
)	O
&&	O
bfd_is_abs_section	function
(	O
p	pointer
->	O
sec	pointer
->	O
output_section	pointer
)	O
)	O
{	O
}	O
else	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
&&	O
strcmp	function
(	O
p	pointer
->	O
sec	pointer
->	O
output_section	pointer
->	O
name	pointer
,	O
".tls_vars"	pointer
)	O
==	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
p	pointer
->	O
count	int
!=	O
0	int
)	O
{	O
srel	pointer
=	O
elf_section_data	O
(	O
p	pointer
->	O
sec	pointer
)	O
->	O
sreloc	pointer
;	O
srel	pointer
->	O
size	long
+=	O
p	pointer
->	O
count	int
*	O
htab	struct
->	O
sizeof_reloc	int
;	O
if	O
(	O
(	O
p	pointer
->	O
sec	pointer
->	O
output_section	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
&&	O
(	O
info	pointer
->	O
flags	int
&	O
DF_TEXTREL	O
)	O
==	O
0	int
)	O
{	O
info	pointer
->	O
flags	int
|=	O
DF_TEXTREL	O
;	O
if	O
(	O
(	O
info	pointer
->	O
warn_shared_textrel	int
&&	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
||	O
info	pointer
->	O
error_textrel	int
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P: %pB: warning: relocation "	pointer
"in read-only section `%pA'\n"	pointer
)	O
,	O
p	pointer
->	O
sec	pointer
->	O
owner	pointer
,	O
p	pointer
->	O
sec	pointer
)	O
;	O
}	O
}	O
}	O
}	O
local_got	union
=	O
elf_local_got_refcounts	O
(	O
ibfd	pointer
)	O
;	O
if	O
(	O
!	O
local_got	union
)	O
continue	O
;	O
symtab_hdr	struct
=	O
&	O
elf_symtab_hdr	O
(	O
ibfd	pointer
)	O
;	O
locsymcount	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
end_local_got	pointer
=	O
local_got	union
+	O
locsymcount	long
;	O
local_tls_type	pointer
=	O
elf_x86_local_got_tls_type	O
(	O
ibfd	pointer
)	O
;	O
local_tlsdesc_gotent	pointer
=	O
elf_x86_local_tlsdesc_gotent	O
(	O
ibfd	pointer
)	O
;	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
srel	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
for	O
(	O
;	O
local_got	union
<	O
end_local_got	pointer
;	O
++	O
local_got	union
,	O
++	O
local_tls_type	pointer
,	O
++	O
local_tlsdesc_gotent	pointer
)	O
{	O
*	O
local_tlsdesc_gotent	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
if	O
(	O
*	O
local_got	union
>	O
0	int
)	O
{	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
*	O
local_tls_type	pointer
)	O
)	O
{	O
*	O
local_tlsdesc_gotent	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
-	O
elf_x86_compute_jump_table_size	O
(	O
htab	struct
)	O
;	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
+=	O
2	int
*	O
htab	struct
->	O
got_entry_size	int
;	O
*	O
local_got	union
=	O
(	O
bfd_vma	long
)	O
-	O
2	int
;	O
}	O
if	O
(	O
!	O
GOT_TLS_GDESC_P	O
(	O
*	O
local_tls_type	pointer
)	O
||	O
GOT_TLS_GD_P	O
(	O
*	O
local_tls_type	pointer
)	O
)	O
{	O
*	O
local_got	union
=	O
s	pointer
->	O
size	long
;	O
s	pointer
->	O
size	long
+=	O
htab	struct
->	O
got_entry_size	int
;	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
*	O
local_tls_type	pointer
)	O
||	O
*	O
local_tls_type	pointer
==	O
GOT_TLS_IE_BOTH	int
)	O
s	pointer
->	O
size	long
+=	O
htab	struct
->	O
got_entry_size	int
;	O
}	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
GOT_TLS_GD_ANY_P	O
(	O
*	O
local_tls_type	pointer
)	O
||	O
(	O
*	O
local_tls_type	pointer
&	O
GOT_TLS_IE	int
)	O
)	O
{	O
if	O
(	O
*	O
local_tls_type	pointer
==	O
GOT_TLS_IE_BOTH	int
)	O
srel	pointer
->	O
size	long
+=	O
2	int
*	O
htab	struct
->	O
sizeof_reloc	int
;	O
else	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
*	O
local_tls_type	pointer
)	O
||	O
!	O
GOT_TLS_GDESC_P	O
(	O
*	O
local_tls_type	pointer
)	O
)	O
srel	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
*	O
local_tls_type	pointer
)	O
)	O
{	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
if	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
)	O
htab	struct
->	O
tlsdesc_plt	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
}	O
}	O
else	O
*	O
local_got	union
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
refcount	int
>	O
0	int
)	O
{	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
offset	long
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
size	long
;	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
size	long
+=	O
2	int
*	O
htab	struct
->	O
got_entry_size	int
;	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
}	O
else	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
offset	long
=	O
-	O
1	int
;	O
elf_link_hash_traverse	O
(	O
&	O
htab	struct
->	O
elf	struct
,	O
elf_x86_allocate_dynrelocs	function
,	O
info	pointer
)	O
;	O
htab_traverse	function
(	O
htab	struct
->	O
loc_hash_table	pointer
,	O
elf_x86_allocate_local_dynreloc	function
,	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
)	O
{	O
htab	struct
->	O
next_tls_desc_index	long
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
reloc_count	int
;	O
htab	struct
->	O
sgotplt_jump_table_size	long
=	O
elf_x86_compute_jump_table_size	O
(	O
htab	struct
)	O
;	O
htab	struct
->	O
next_irelative_index	long
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
reloc_count	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
)	O
htab	struct
->	O
next_irelative_index	long
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
->	O
reloc_count	int
-	O
1	int
;	O
if	O
(	O
htab	struct
->	O
tlsdesc_plt	long
)	O
{	O
if	O
(	O
(	O
info	pointer
->	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
htab	struct
->	O
tlsdesc_plt	long
=	O
0	int
;	O
else	O
{	O
htab	struct
->	O
tlsdesc_got	long
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
size	long
;	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
size	long
+=	O
htab	struct
->	O
got_entry_size	int
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
==	O
0	int
)	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
htab	struct
->	O
tlsdesc_plt	long
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
;	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
+=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
)	O
{	O
if	O
(	O
(	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
==	O
NULL	O
||	O
!	O
htab	struct
->	O
got_referenced	int
)	O
&&	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
==	O
bed	pointer
->	O
got_header_size	long
)	O
&&	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
==	O
0	int
)	O
&&	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
size	long
==	O
0	int
)	O
&&	O
(	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
->	O
size	long
==	O
0	int
)	O
&&	O
(	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
->	O
size	long
==	O
0	int
)	O
)	O
{	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
=	O
0	int
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
target_os	enum
!=	O
is_solaris	int
)	O
{	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
root	struct
.	O
linker_def	int
=	O
0	int
;	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
ref_regular	int
=	O
0	int
;	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
def_regular	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
_bfd_elf_eh_frame_present	function
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
!=	O
0	int
&&	O
!	O
bfd_is_abs_section	function
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
)	O
)	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
size	long
=	O
htab	struct
->	O
plt	union
.	O
eh_frame_plt_size	int
;	O
if	O
(	O
htab	struct
->	O
plt_got_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got	union
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got	union
->	O
size	long
!=	O
0	int
&&	O
!	O
bfd_is_abs_section	function
(	O
htab	struct
->	O
plt_got	union
->	O
output_section	pointer
)	O
)	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
size	long
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
eh_frame_plt_size	int
;	O
if	O
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second	union
->	O
size	long
!=	O
0	int
&&	O
!	O
bfd_is_abs_section	function
(	O
htab	struct
->	O
plt_second	union
->	O
output_section	pointer
)	O
)	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
size	long
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
eh_frame_plt_size	int
;	O
}	O
relocs	pointer
=	O
FALSE	int
;	O
for	O
(	O
s	pointer
=	O
dynobj	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
bfd_boolean	int
strip_section	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
||	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
)	O
{	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
hplt	pointer
!=	O
NULL	O
)	O
strip_section	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
||	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
||	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
||	O
s	pointer
==	O
htab	struct
->	O
plt_second	union
||	O
s	pointer
==	O
htab	struct
->	O
plt_got	union
||	O
s	pointer
==	O
htab	struct
->	O
plt_eh_frame	pointer
||	O
s	pointer
==	O
htab	struct
->	O
plt_got_eh_frame	pointer
||	O
s	pointer
==	O
htab	struct
->	O
plt_second_eh_frame	pointer
||	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
sdynbss	pointer
||	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
sdynrelro	pointer
)	O
{	O
}	O
else	O
if	O
(	O
htab	struct
->	O
is_reloc_section	pointer
(	O
bfd_section_name	function
(	O
s	pointer
)	O
)	O
)	O
{	O
if	O
(	O
s	pointer
->	O
size	long
!=	O
0	int
&&	O
s	pointer
!=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
&&	O
s	pointer
!=	O
htab	struct
->	O
srelplt2	pointer
)	O
relocs	pointer
=	O
TRUE	int
;	O
if	O
(	O
s	pointer
!=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
)	O
s	pointer
->	O
reloc_count	int
=	O
0	int
;	O
}	O
else	O
{	O
continue	O
;	O
}	O
if	O
(	O
s	pointer
->	O
size	long
==	O
0	int
)	O
{	O
if	O
(	O
strip_section	int
)	O
s	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
s	pointer
==	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
)	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
htab	struct
->	O
plt	union
.	O
iplt_alignment	int
)	O
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
dynobj	pointer
,	O
s	pointer
->	O
size	long
)	O
;	O
if	O
(	O
s	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
contents	pointer
,	O
htab	struct
->	O
plt	union
.	O
eh_frame_plt	pointer
,	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
size	long
)	O
;	O
bfd_put_32	O
(	O
dynobj	pointer
,	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
,	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
contents	pointer
+	O
PLT_FDE_LEN_OFFSET	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_got_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
contents	pointer
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
eh_frame_plt	pointer
,	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
size	long
)	O
;	O
bfd_put_32	O
(	O
dynobj	pointer
,	O
htab	struct
->	O
plt_got	union
->	O
size	long
,	O
(	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
contents	pointer
+	O
PLT_FDE_LEN_OFFSET	O
)	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
contents	pointer
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
eh_frame_plt	pointer
,	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
size	long
)	O
;	O
bfd_put_32	O
(	O
dynobj	pointer
,	O
htab	struct
->	O
plt_second	union
->	O
size	long
,	O
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
contents	pointer
+	O
PLT_FDE_LEN_OFFSET	O
)	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
)	O
{	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
!	O
add_dynamic_entry	O
(	O
DT_DEBUG	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
add_dynamic_entry	O
(	O
DT_PLTGOT	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
add_dynamic_entry	O
(	O
DT_PLTRELSZ	int
,	O
0	int
)	O
||	O
!	O
add_dynamic_entry	O
(	O
DT_PLTREL	int
,	O
htab	struct
->	O
dt_reloc	int
)	O
||	O
!	O
add_dynamic_entry	O
(	O
DT_JMPREL	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
htab	struct
->	O
tlsdesc_plt	long
&&	O
(	O
!	O
add_dynamic_entry	O
(	O
DT_TLSDESC_PLT	int
,	O
0	int
)	O
||	O
!	O
add_dynamic_entry	O
(	O
DT_TLSDESC_GOT	int
,	O
0	int
)	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
relocs	pointer
)	O
{	O
if	O
(	O
!	O
add_dynamic_entry	O
(	O
htab	struct
->	O
dt_reloc	int
,	O
0	int
)	O
||	O
!	O
add_dynamic_entry	O
(	O
htab	struct
->	O
dt_reloc_sz	int
,	O
0	int
)	O
||	O
!	O
add_dynamic_entry	O
(	O
htab	struct
->	O
dt_reloc_ent	int
,	O
htab	struct
->	O
sizeof_reloc	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
info	pointer
->	O
flags	int
&	O
DF_TEXTREL	O
)	O
==	O
0	int
)	O
elf_link_hash_traverse	O
(	O
&	O
htab	struct
->	O
elf	struct
,	O
maybe_set_textrel	function
,	O
info	pointer
)	O
;	O
if	O
(	O
(	O
info	pointer
->	O
flags	int
&	O
DF_TEXTREL	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
htab	struct
->	O
readonly_dynrelocs_against_ifunc	int
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%P%X: read-only segment has dynamic IFUNC relocations;"	pointer
" recompile with %s\n"	pointer
)	O
,	O
bfd_link_dll	O
(	O
info	pointer
)	O
?	O
"-fPIC"	pointer
:	O
"-fPIE"	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
add_dynamic_entry	O
(	O
DT_TEXTREL	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
&&	O
!	O
elf_vxworks_add_dynamic_entries	function
(	O
output_bfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
struct	O
elf_x86_link_hash_table	struct
*	O
_bfd_x86_elf_finish_dynamic_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd	struct
*	O
dynobj	pointer
;	O
asection	struct
*	O
sdyn	pointer
;	O
bfd_byte	char
*	O
dyncon	pointer
,	O
*	O
dynconend	pointer
;	O
bfd_size_type	long
sizeof_dyn	char
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
htab	struct
;	O
dynobj	pointer
=	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
;	O
sdyn	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
&&	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
>	O
0	int
)	O
{	O
bfd_vma	long
dynamic_addr	long
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"discarded output section: `%pA'"	pointer
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
elf_section_data	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
htab	struct
->	O
got_entry_size	int
;	O
dynamic_addr	long
=	O
(	O
sdyn	pointer
==	O
NULL	O
?	O
(	O
bfd_vma	long
)	O
0	int
:	O
sdyn	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sdyn	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
htab	struct
->	O
got_entry_size	int
==	O
8	int
)	O
{	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
dynamic_addr	long
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
)	O
;	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
+	O
8	int
)	O
;	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
+	O
8	int
*	O
2	int
)	O
;	O
}	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
dynamic_addr	long
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
+	O
4	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
+	O
4	int
*	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
)	O
return	O
htab	struct
;	O
if	O
(	O
sdyn	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
sizeof_dyn	char
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
;	O
dyncon	pointer
=	O
sdyn	pointer
->	O
contents	pointer
;	O
dynconend	pointer
=	O
sdyn	pointer
->	O
contents	pointer
+	O
sdyn	pointer
->	O
size	long
;	O
for	O
(	O
;	O
dyncon	pointer
<	O
dynconend	pointer
;	O
dyncon	pointer
+=	O
sizeof_dyn	char
)	O
{	O
Elf_Internal_Dyn	struct
dyn	int
;	O
asection	struct
*	O
s	pointer
;	O
(	O
*	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_in	pointer
)	O
(	O
dynobj	pointer
,	O
dyncon	pointer
,	O
&	O
dyn	int
)	O
;	O
switch	O
(	O
dyn	int
.	O
d_tag	array
)	O
{	O
default	O
:	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
&&	O
elf_vxworks_finish_dynamic_entry	function
(	O
output_bfd	pointer
,	O
&	O
dyn	int
)	O
)	O
break	O
;	O
continue	O
;	O
case	O
DT_PLTGOT	int
:	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
dyn	int
.	O
d_un	union
.	O
d_ptr	array
=	O
s	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
s	pointer
->	O
output_offset	long
;	O
break	O
;	O
case	O
DT_JMPREL	int
:	O
dyn	int
.	O
d_un	union
.	O
d_ptr	array
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
break	O
;	O
case	O
DT_PLTRELSZ	int
:	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
->	O
output_section	pointer
;	O
dyn	int
.	O
d_un	union
.	O
d_val	array
=	O
s	pointer
->	O
size	long
;	O
break	O
;	O
case	O
DT_TLSDESC_PLT	int
:	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
dyn	int
.	O
d_un	union
.	O
d_ptr	array
=	O
s	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
s	pointer
->	O
output_offset	long
+	O
htab	struct
->	O
tlsdesc_plt	long
;	O
break	O
;	O
case	O
DT_TLSDESC_GOT	int
:	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
dyn	int
.	O
d_un	union
.	O
d_ptr	array
=	O
s	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
s	pointer
->	O
output_offset	long
+	O
htab	struct
->	O
tlsdesc_got	long
;	O
break	O
;	O
}	O
(	O
*	O
bed	pointer
->	O
s	pointer
->	O
swap_dyn_out	pointer
)	O
(	O
output_bfd	pointer
,	O
&	O
dyn	int
,	O
dyncon	pointer
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_got	union
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got	union
->	O
size	long
>	O
0	int
)	O
elf_section_data	O
(	O
htab	struct
->	O
plt_got	union
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second	union
->	O
size	long
>	O
0	int
)	O
elf_section_data	O
(	O
htab	struct
->	O
plt_second	union
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
if	O
(	O
htab	struct
->	O
plt_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
!=	O
0	int
&&	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
plt_start	long
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
bfd_vma	long
eh_frame_start	long
=	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
output_offset	long
+	O
PLT_FDE_START_OFFSET	O
;	O
bfd_put_signed_32	O
(	O
dynobj	pointer
,	O
plt_start	long
-	O
eh_frame_start	long
,	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
contents	pointer
+	O
PLT_FDE_START_OFFSET	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_EH_FRAME	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_write_section_eh_frame	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
htab	struct
->	O
plt_eh_frame	pointer
,	O
htab	struct
->	O
plt_eh_frame	pointer
->	O
contents	pointer
)	O
)	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
plt_got_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_got	union
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got	union
->	O
size	long
!=	O
0	int
&&	O
(	O
htab	struct
->	O
plt_got	union
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
htab	struct
->	O
plt_got	union
->	O
output_section	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
plt_start	long
=	O
htab	struct
->	O
plt_got	union
->	O
output_section	pointer
->	O
vma	long
;	O
bfd_vma	long
eh_frame_start	long
=	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
output_offset	long
+	O
PLT_FDE_START_OFFSET	O
;	O
bfd_put_signed_32	O
(	O
dynobj	pointer
,	O
plt_start	long
-	O
eh_frame_start	long
,	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
contents	pointer
+	O
PLT_FDE_START_OFFSET	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_EH_FRAME	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_write_section_eh_frame	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
htab	struct
->	O
plt_got_eh_frame	pointer
,	O
htab	struct
->	O
plt_got_eh_frame	pointer
->	O
contents	pointer
)	O
)	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second	union
->	O
size	long
!=	O
0	int
&&	O
(	O
htab	struct
->	O
plt_second	union
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
htab	struct
->	O
plt_second	union
->	O
output_section	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
plt_start	long
=	O
htab	struct
->	O
plt_second	union
->	O
output_section	pointer
->	O
vma	long
;	O
bfd_vma	long
eh_frame_start	long
=	O
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
output_offset	long
+	O
PLT_FDE_START_OFFSET	O
)	O
;	O
bfd_put_signed_32	O
(	O
dynobj	pointer
,	O
plt_start	long
-	O
eh_frame_start	long
,	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
contents	pointer
+	O
PLT_FDE_START_OFFSET	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_EH_FRAME	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_write_section_eh_frame	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
htab	struct
->	O
plt_second_eh_frame	pointer
,	O
htab	struct
->	O
plt_second_eh_frame	pointer
->	O
contents	pointer
)	O
)	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
&&	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
size	long
>	O
0	int
)	O
elf_section_data	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
htab	struct
->	O
got_entry_size	int
;	O
return	O
htab	struct
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_always_size_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
tls_sec	pointer
=	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
tls_sec	pointer
;	O
if	O
(	O
tls_sec	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
tlsbase	pointer
;	O
tlsbase	pointer
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
info	pointer
)	O
,	O
"_TLS_MODULE_BASE_"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
tlsbase	pointer
&&	O
tlsbase	pointer
->	O
type	enum
==	O
STT_TLS	int
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
=	O
NULL	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
output_bfd	pointer
,	O
"_TLS_MODULE_BASE_"	pointer
,	O
BSF_LOCAL	O
,	O
tls_sec	pointer
,	O
0	int
,	O
NULL	O
,	O
FALSE	int
,	O
bed	pointer
->	O
collect	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
tls_module_base	pointer
=	O
bh	pointer
;	O
tlsbase	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
tlsbase	pointer
->	O
def_regular	int
=	O
1	int
;	O
tlsbase	pointer
->	O
other	int
=	O
STV_HIDDEN	int
;	O
tlsbase	pointer
->	O
root	struct
.	O
linker_def	int
=	O
1	int
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
info	pointer
,	O
tlsbase	pointer
,	O
TRUE	int
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_x86_elf_merge_symbol_attribute	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
Elf_Internal_Sym	struct
*	O
isym	pointer
,	O
bfd_boolean	int
definition	int
,	O
bfd_boolean	int
dynamic	int
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
definition	int
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
eh	pointer
->	O
def_protected	int
=	O
(	O
ELF_ST_VISIBILITY	O
(	O
isym	pointer
->	O
st_other	array
)	O
==	O
STV_PROTECTED	int
)	O
;	O
}	O
}	O
void	O
_bfd_x86_elf_copy_indirect_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
dir	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
ind	pointer
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
edir	pointer
,	O
*	O
eind	pointer
;	O
edir	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
dir	pointer
;	O
eind	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
ind	pointer
;	O
if	O
(	O
eind	pointer
->	O
dyn_relocs	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
edir	pointer
->	O
dyn_relocs	pointer
!=	O
NULL	O
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
pp	pointer
;	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
eind	pointer
->	O
dyn_relocs	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
;	O
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
q	pointer
;	O
for	O
(	O
q	pointer
=	O
edir	pointer
->	O
dyn_relocs	pointer
;	O
q	pointer
!=	O
NULL	O
;	O
q	pointer
=	O
q	pointer
->	O
next	pointer
)	O
if	O
(	O
q	pointer
->	O
sec	pointer
==	O
p	pointer
->	O
sec	pointer
)	O
{	O
q	pointer
->	O
pc_count	long
+=	O
p	pointer
->	O
pc_count	long
;	O
q	pointer
->	O
count	int
+=	O
p	pointer
->	O
count	int
;	O
*	O
pp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
break	O
;	O
}	O
if	O
(	O
q	pointer
==	O
NULL	O
)	O
pp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
*	O
pp	pointer
=	O
edir	pointer
->	O
dyn_relocs	pointer
;	O
}	O
edir	pointer
->	O
dyn_relocs	pointer
=	O
eind	pointer
->	O
dyn_relocs	pointer
;	O
eind	pointer
->	O
dyn_relocs	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
ind	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
&&	O
dir	pointer
->	O
got	union
.	O
refcount	int
<=	O
0	int
)	O
{	O
edir	pointer
->	O
tls_type	char
=	O
eind	pointer
->	O
tls_type	char
;	O
eind	pointer
->	O
tls_type	char
=	O
GOT_UNKNOWN	int
;	O
}	O
edir	pointer
->	O
gotoff_ref	int
|=	O
eind	pointer
->	O
gotoff_ref	int
;	O
edir	pointer
->	O
zero_undefweak	int
|=	O
eind	pointer
->	O
zero_undefweak	int
;	O
if	O
(	O
ELIMINATE_COPY_RELOCS	int
&&	O
ind	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_indirect	int
&&	O
dir	pointer
->	O
dynamic_adjusted	int
)	O
{	O
if	O
(	O
dir	pointer
->	O
versioned	int
!=	O
versioned_hidden	int
)	O
dir	pointer
->	O
ref_dynamic	int
|=	O
ind	pointer
->	O
ref_dynamic	int
;	O
dir	pointer
->	O
ref_regular	int
|=	O
ind	pointer
->	O
ref_regular	int
;	O
dir	pointer
->	O
ref_regular_nonweak	int
|=	O
ind	pointer
->	O
ref_regular_nonweak	int
;	O
dir	pointer
->	O
needs_plt	int
|=	O
ind	pointer
->	O
needs_plt	int
;	O
dir	pointer
->	O
pointer_equality_needed	int
|=	O
ind	pointer
->	O
pointer_equality_needed	int
;	O
}	O
else	O
_bfd_elf_link_hash_copy_indirect	function
(	O
info	pointer
,	O
dir	pointer
,	O
ind	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_fixup_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
)	O
)	O
{	O
h	pointer
->	O
dynindx	long
=	O
-	O
1	int
;	O
_bfd_elf_strtab_delref	function
(	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
dynstr	pointer
,	O
h	pointer
->	O
dynstr_index	long
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_x86_elf_link_fixup_ifunc_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
bfd_link_pde	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
&&	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
h	pointer
->	O
pointer_equality_needed	int
)	O
{	O
asection	struct
*	O
plt_s	pointer
;	O
bfd_vma	long
plt_offset	long
;	O
bfd	struct
*	O
output_bfd	pointer
=	O
info	pointer
->	O
output_bfd	pointer
;	O
if	O
(	O
htab	struct
->	O
plt_second	union
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
plt_s	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
plt_s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
sym	pointer
->	O
st_size	long
=	O
0	int
;	O
sym	pointer
->	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
,	O
STT_FUNC	int
)	O
;	O
sym	pointer
->	O
st_shndx	array
=	O
_bfd_elf_section_from_bfd_section	function
(	O
output_bfd	pointer
,	O
plt_s	pointer
->	O
output_section	pointer
)	O
;	O
sym	pointer
->	O
st_value	array
=	O
(	O
plt_s	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
plt_s	pointer
->	O
output_offset	long
+	O
plt_offset	long
)	O
;	O
}	O
}	O
bfd_boolean	int
_bfd_x86_elf_hash_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
!	O
h	pointer
->	O
pointer_equality_needed	int
)	O
return	O
FALSE	int
;	O
return	O
_bfd_elf_hash_symbol	function
(	O
h	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_adjust_dynamic_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
asection	struct
*	O
s	pointer
,	O
*	O
srel	pointer
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
{	O
if	O
(	O
h	pointer
->	O
ref_regular	int
&&	O
SYMBOL_CALLS_LOCAL	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
bfd_size_type	long
pc_count	long
=	O
0	int
,	O
count	int
=	O
0	int
;	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
pp	pointer
;	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
;	O
)	O
{	O
pc_count	long
+=	O
p	pointer
->	O
pc_count	long
;	O
p	pointer
->	O
count	int
-=	O
p	pointer
->	O
pc_count	long
;	O
p	pointer
->	O
pc_count	long
=	O
0	int
;	O
count	int
+=	O
p	pointer
->	O
count	int
;	O
if	O
(	O
p	pointer
->	O
count	int
==	O
0	int
)	O
*	O
pp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
pp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
pc_count	long
||	O
count	int
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
1	int
;	O
if	O
(	O
pc_count	long
)	O
{	O
h	pointer
->	O
needs_plt	int
=	O
1	int
;	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
<=	O
0	int
)	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
else	O
h	pointer
->	O
plt	union
.	O
refcount	int
+=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
<=	O
0	int
)	O
{	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
h	pointer
->	O
needs_plt	int
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
||	O
h	pointer
->	O
needs_plt	int
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
<=	O
0	int
||	O
SYMBOL_CALLS_LOCAL	O
(	O
info	pointer
,	O
h	pointer
)	O
||	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_DEFAULT	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
)	O
{	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
h	pointer
->	O
needs_plt	int
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
else	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
h	pointer
->	O
is_weakalias	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
def	struct
=	O
weakdef	function
(	O
h	pointer
)	O
;	O
BFD_ASSERT	O
(	O
def	struct
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
def	struct
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
def	struct
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
if	O
(	O
ELIMINATE_COPY_RELOCS	int
||	O
info	pointer
->	O
nocopyreloc	int
||	O
SYMBOL_NO_COPYRELOC	O
(	O
info	pointer
,	O
eh	pointer
)	O
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
def	struct
->	O
non_got_ref	int
;	O
eh	pointer
->	O
needs_copy	int
=	O
def	struct
->	O
needs_copy	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
h	pointer
->	O
non_got_ref	int
&&	O
!	O
eh	pointer
->	O
gotoff_ref	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
info	pointer
->	O
nocopyreloc	int
||	O
SYMBOL_NO_COPYRELOC	O
(	O
info	pointer
,	O
eh	pointer
)	O
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ELIMINATE_COPY_RELOCS	int
&&	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
||	O
(	O
!	O
eh	pointer
->	O
gotoff_ref	int
&&	O
htab	struct
->	O
target_os	enum
!=	O
is_vxworks	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
readonly_dynrelocs	function
(	O
h	pointer
)	O
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
)	O
{	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sdynrelro	pointer
;	O
srel	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sreldynrelro	pointer
;	O
}	O
else	O
{	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sdynbss	pointer
;	O
srel	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelbss	pointer
;	O
}	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
h	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
srel	pointer
->	O
size	long
+=	O
htab	struct
->	O
sizeof_reloc	int
;	O
h	pointer
->	O
needs_copy	int
=	O
1	int
;	O
}	O
return	O
_bfd_elf_adjust_dynamic_copy	function
(	O
info	pointer
,	O
h	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
_bfd_x86_elf_hide_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_boolean	int
force_local	int
)	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
info	pointer
->	O
nointerp	int
&&	O
bfd_link_pie	O
(	O
info	pointer
)	O
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
>	O
0	int
||	O
eh	pointer
->	O
plt_got	union
.	O
refcount	int
>	O
0	int
)	O
return	O
;	O
}	O
_bfd_elf_link_hash_hide_symbol	function
(	O
info	pointer
,	O
h	pointer
,	O
force_local	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_link_symbol_references_local	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
(	O
struct	O
elf_x86_link_hash_table	struct
*	O
)	O
info	pointer
->	O
hash	long
;	O
if	O
(	O
eh	pointer
->	O
local_ref	int
>	O
1	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
eh	pointer
->	O
local_ref	int
==	O
1	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
SYMBOL_REFERENCES_LOCAL	O
(	O
info	pointer
,	O
h	pointer
)	O
||	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_DEFAULT	int
||	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
htab	struct
->	O
interp	pointer
==	O
NULL	O
)	O
||	O
info	pointer
->	O
dynamic_undefined_weak	int
==	O
0	int
)	O
)	O
||	O
(	O
(	O
h	pointer
->	O
def_regular	int
||	O
ELF_COMMON_DEF_P	O
(	O
h	pointer
)	O
)	O
&&	O
info	pointer
->	O
version_info	pointer
!=	O
NULL	O
&&	O
_bfd_elf_link_hide_sym_by_version	function
(	O
info	pointer
,	O
h	pointer
)	O
)	O
)	O
{	O
eh	pointer
->	O
local_ref	int
=	O
2	int
;	O
return	O
TRUE	int
;	O
}	O
eh	pointer
->	O
local_ref	int
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
asection	struct
*	O
_bfd_x86_elf_gc_mark_hook	function
(	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
R_X86_64_GNU_VTINHERIT	int
!=	O
(	O
unsigned	O
int	O
)	O
R_386_GNU_VTINHERIT	int
)	O
||	O
(	O
(	O
unsigned	O
int	O
)	O
R_X86_64_GNU_VTENTRY	int
!=	O
(	O
unsigned	O
int	O
)	O
R_386_GNU_VTENTRY	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
switch	O
(	O
ELF32_R_TYPE	O
(	O
rel	pointer
->	O
r_info	array
)	O
)	O
{	O
case	O
R_X86_64_GNU_VTINHERIT	int
:	O
case	O
R_X86_64_GNU_VTENTRY	int
:	O
return	O
NULL	O
;	O
}	O
return	O
_bfd_elf_gc_mark_hook	function
(	O
sec	pointer
,	O
info	pointer
,	O
rel	pointer
,	O
h	pointer
,	O
sym	pointer
)	O
;	O
}	O
static	O
bfd_vma	long
elf_i386_get_plt_got_vma	function
(	O
struct	O
elf_x86_plt	struct
*	O
plt_p	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
off	long
,	O
bfd_vma	long
offset	long
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
got_addr	long
)	O
{	O
return	O
got_addr	long
+	O
off	long
;	O
}	O
static	O
bfd_vma	long
elf_x86_64_get_plt_got_vma	function
(	O
struct	O
elf_x86_plt	struct
*	O
plt_p	pointer
,	O
bfd_vma	long
off	long
,	O
bfd_vma	long
offset	long
,	O
bfd_vma	long
got_addr	long
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
plt_p	pointer
->	O
sec	pointer
->	O
vma	long
+	O
offset	long
+	O
off	long
+	O
plt_p	pointer
->	O
plt_got_insn_size	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_valid_plt_reloc_p	function
(	O
unsigned	O
int	O
type	enum
)	O
{	O
return	O
(	O
type	enum
==	O
R_386_JUMP_SLOT	int
||	O
type	enum
==	O
R_386_GLOB_DAT	int
||	O
type	enum
==	O
R_386_IRELATIVE	int
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_valid_plt_reloc_p	function
(	O
unsigned	O
int	O
type	enum
)	O
{	O
return	O
(	O
type	enum
==	O
R_X86_64_JUMP_SLOT	int
||	O
type	enum
==	O
R_X86_64_GLOB_DAT	int
||	O
type	enum
==	O
R_X86_64_IRELATIVE	int
)	O
;	O
}	O
long	O
_bfd_x86_elf_get_synthetic_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
long	O
count	int
,	O
long	O
relsize	long
,	O
bfd_vma	long
got_addr	long
,	O
struct	O
elf_x86_plt	struct
plts	array
[	O
]	O
,	O
asymbol	struct
*	O
*	O
dynsyms	pointer
,	O
asymbol	struct
*	O
*	O
ret	pointer
)	O
{	O
long	O
size	long
,	O
i	pointer
,	O
n	long
,	O
len	long
;	O
int	O
j	int
;	O
unsigned	O
int	O
plt_got_offset	int
,	O
plt_entry_size	int
;	O
asymbol	struct
*	O
s	pointer
;	O
bfd_byte	char
*	O
plt_contents	pointer
;	O
long	O
dynrelcount	long
;	O
arelent	struct
*	O
*	O
dynrelbuf	pointer
,	O
*	O
p	pointer
;	O
char	O
*	O
names	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_vma	long
(	O
*	O
get_plt_got_vma	pointer
)	O
(	O
struct	O
elf_x86_plt	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
bfd_boolean	int
(	O
*	O
valid_plt_reloc_p	pointer
)	O
(	O
unsigned	O
int	O
)	O
;	O
dynrelbuf	pointer
=	O
NULL	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
goto	O
bad_return	O
;	O
dynrelbuf	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
relsize	long
)	O
;	O
if	O
(	O
dynrelbuf	pointer
==	O
NULL	O
)	O
goto	O
bad_return	O
;	O
dynrelcount	long
=	O
bfd_canonicalize_dynamic_reloc	O
(	O
abfd	pointer
,	O
dynrelbuf	pointer
,	O
dynsyms	pointer
)	O
;	O
if	O
(	O
dynrelcount	long
<=	O
0	int
)	O
goto	O
bad_return	O
;	O
qsort	function
(	O
dynrelbuf	pointer
,	O
dynrelcount	long
,	O
sizeof	O
(	O
arelent	struct
*	O
)	O
,	O
_bfd_x86_elf_compare_relocs	function
)	O
;	O
size	long
=	O
count	int
*	O
sizeof	O
(	O
asymbol	struct
)	O
;	O
n	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
dynrelcount	long
;	O
i	pointer
++	O
)	O
{	O
p	pointer
=	O
dynrelbuf	pointer
[	O
i	pointer
]	O
;	O
size	long
+=	O
strlen	function
(	O
(	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
name	pointer
)	O
+	O
sizeof	O
(	O
"@plt"	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
addend	long
!=	O
0	int
)	O
size	long
+=	O
sizeof	O
(	O
"+0x"	pointer
)	O
-	O
1	int
+	O
8	int
+	O
8	int
*	O
ABI_64_P	O
(	O
abfd	pointer
)	O
;	O
}	O
s	pointer
=	O
*	O
ret	pointer
=	O
(	O
asymbol	struct
*	O
)	O
bfd_zmalloc	function
(	O
size	long
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
goto	O
bad_return	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
)	O
{	O
get_plt_got_vma	pointer
=	O
elf_x86_64_get_plt_got_vma	function
;	O
valid_plt_reloc_p	pointer
=	O
elf_x86_64_valid_plt_reloc_p	function
;	O
}	O
else	O
{	O
get_plt_got_vma	pointer
=	O
elf_i386_get_plt_got_vma	function
;	O
valid_plt_reloc_p	pointer
=	O
elf_i386_valid_plt_reloc_p	function
;	O
if	O
(	O
got_addr	long
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".got.plt"	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
got_addr	long
=	O
sec	pointer
->	O
vma	long
;	O
else	O
{	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".got"	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
got_addr	long
=	O
sec	pointer
->	O
vma	long
;	O
}	O
if	O
(	O
got_addr	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
bad_return	O
;	O
}	O
}	O
names	pointer
=	O
(	O
char	O
*	O
)	O
(	O
s	pointer
+	O
count	int
)	O
;	O
size	long
=	O
0	int
;	O
n	long
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
plts	array
[	O
j	int
]	O
.	O
name	pointer
!=	O
NULL	O
;	O
j	int
++	O
)	O
if	O
(	O
(	O
plt_contents	pointer
=	O
plts	array
[	O
j	int
]	O
.	O
contents	pointer
)	O
!=	O
NULL	O
)	O
{	O
long	O
k	long
;	O
bfd_vma	long
offset	long
;	O
asection	struct
*	O
plt	union
;	O
struct	O
elf_x86_plt	struct
*	O
plt_p	pointer
=	O
&	O
plts	array
[	O
j	int
]	O
;	O
plt_got_offset	int
=	O
plt_p	pointer
->	O
plt_got_offset	int
;	O
plt_entry_size	int
=	O
plt_p	pointer
->	O
plt_entry_size	int
;	O
plt	union
=	O
plt_p	pointer
->	O
sec	pointer
;	O
if	O
(	O
(	O
plt_p	pointer
->	O
type	enum
&	O
plt_lazy	int
)	O
)	O
{	O
k	long
=	O
1	int
;	O
offset	long
=	O
plt_entry_size	int
;	O
}	O
else	O
{	O
k	long
=	O
0	int
;	O
offset	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
k	long
<	O
plt_p	pointer
->	O
count	int
;	O
k	long
++	O
)	O
{	O
int	O
off	long
;	O
bfd_vma	long
got_vma	long
;	O
long	O
min	long
,	O
max	long
,	O
mid	long
;	O
off	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
(	O
plt_contents	pointer
+	O
offset	long
+	O
plt_got_offset	int
)	O
)	O
;	O
got_vma	long
=	O
get_plt_got_vma	pointer
(	O
plt_p	pointer
,	O
off	long
,	O
offset	long
,	O
got_addr	long
)	O
;	O
p	pointer
=	O
dynrelbuf	pointer
[	O
0	int
]	O
;	O
min	long
=	O
0	int
;	O
max	long
=	O
dynrelcount	long
;	O
while	O
(	O
(	O
min	long
+	O
1	int
)	O
<	O
max	long
)	O
{	O
arelent	struct
*	O
r	pointer
;	O
mid	long
=	O
(	O
min	long
+	O
max	long
)	O
/	O
2	int
;	O
r	pointer
=	O
dynrelbuf	pointer
[	O
mid	long
]	O
;	O
if	O
(	O
got_vma	long
>	O
r	pointer
->	O
address	long
)	O
min	long
=	O
mid	long
;	O
else	O
if	O
(	O
got_vma	long
<	O
r	pointer
->	O
address	long
)	O
max	long
=	O
mid	long
;	O
else	O
{	O
p	pointer
=	O
r	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
got_vma	long
==	O
p	pointer
->	O
address	long
&&	O
p	pointer
->	O
howto	pointer
!=	O
NULL	O
&&	O
valid_plt_reloc_p	pointer
(	O
p	pointer
->	O
howto	pointer
->	O
type	enum
)	O
)	O
{	O
*	O
s	pointer
=	O
*	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
)	O
==	O
0	int
)	O
s	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
s	pointer
->	O
flags	int
|=	O
BSF_SYNTHETIC	O
;	O
s	pointer
->	O
flags	int
&=	O
~	O
BSF_SECTION_SYM	O
;	O
s	pointer
->	O
section	pointer
=	O
plt	union
;	O
s	pointer
->	O
the_bfd	pointer
=	O
plt	union
->	O
owner	pointer
;	O
s	pointer
->	O
value	long
=	O
offset	long
;	O
s	pointer
->	O
udata	union
.	O
p	pointer
=	O
NULL	O
;	O
s	pointer
->	O
name	pointer
=	O
names	pointer
;	O
len	long
=	O
strlen	function
(	O
(	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
name	pointer
)	O
;	O
memcpy	function
(	O
names	pointer
,	O
(	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
name	pointer
,	O
len	long
)	O
;	O
names	pointer
+=	O
len	long
;	O
if	O
(	O
p	pointer
->	O
addend	long
!=	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
30	int
]	O
,	O
*	O
a	pointer
;	O
memcpy	function
(	O
names	pointer
,	O
"+0x"	pointer
,	O
sizeof	O
(	O
"+0x"	pointer
)	O
-	O
1	int
)	O
;	O
names	pointer
+=	O
sizeof	O
(	O
"+0x"	pointer
)	O
-	O
1	int
;	O
bfd_sprintf_vma	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
p	pointer
->	O
addend	long
)	O
;	O
for	O
(	O
a	pointer
=	O
buf	pointer
;	O
*	O
a	pointer
==	O
'0'	O
;	O
++	O
a	pointer
)	O
;	O
size	long
=	O
strlen	function
(	O
a	pointer
)	O
;	O
memcpy	function
(	O
names	pointer
,	O
a	pointer
,	O
size	long
)	O
;	O
names	pointer
+=	O
size	long
;	O
}	O
memcpy	function
(	O
names	pointer
,	O
"@plt"	pointer
,	O
sizeof	O
(	O
"@plt"	pointer
)	O
)	O
;	O
names	pointer
+=	O
sizeof	O
(	O
"@plt"	pointer
)	O
;	O
n	long
++	O
;	O
s	pointer
++	O
;	O
p	pointer
->	O
howto	pointer
=	O
NULL	O
;	O
}	O
offset	long
+=	O
plt_entry_size	int
;	O
}	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
bad_return	O
:	O
count	int
=	O
-	O
1	int
;	O
}	O
else	O
count	int
=	O
n	long
;	O
for	O
(	O
j	int
=	O
0	int
;	O
plts	array
[	O
j	int
]	O
.	O
name	pointer
!=	O
NULL	O
;	O
j	int
++	O
)	O
if	O
(	O
plts	array
[	O
j	int
]	O
.	O
contents	pointer
!=	O
NULL	O
)	O
free	function
(	O
plts	array
[	O
j	int
]	O
.	O
contents	pointer
)	O
;	O
free	function
(	O
dynrelbuf	pointer
)	O
;	O
return	O
count	int
;	O
}	O
enum	O
elf_property_kind	enum
_bfd_x86_elf_parse_gnu_properties	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
type	enum
,	O
bfd_byte	char
*	O
ptr	pointer
,	O
unsigned	O
int	O
datasz	int
)	O
{	O
elf_property	struct
*	O
prop	pointer
;	O
if	O
(	O
type	enum
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_USED	int
||	O
type	enum
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED	int
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_AND_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_AND_HI	int
)	O
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_OR_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_OR_HI	int
)	O
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_OR_AND_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_OR_AND_HI	int
)	O
)	O
{	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"error: %pB: <corrupt x86 property (0x%x) size: 0x%x>"	pointer
)	O
,	O
abfd	pointer
,	O
type	enum
,	O
datasz	int
)	O
;	O
return	O
property_corrupt	int
;	O
}	O
prop	pointer
=	O
_bfd_elf_get_property	function
(	O
abfd	pointer
,	O
type	enum
,	O
datasz	int
)	O
;	O
prop	pointer
->	O
u	union
.	O
number	long
|=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
ptr	pointer
)	O
;	O
prop	pointer
->	O
pr_kind	enum
=	O
property_number	int
;	O
return	O
property_number	int
;	O
}	O
return	O
property_ignored	int
;	O
}	O
bfd_boolean	int
_bfd_x86_elf_merge_gnu_properties	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
bbfd	pointer
ATTRIBUTE_UNUSED	O
,	O
elf_property	struct
*	O
aprop	pointer
,	O
elf_property	struct
*	O
bprop	pointer
)	O
{	O
unsigned	O
int	O
number	long
,	O
features	int
;	O
bfd_boolean	int
updated	int
=	O
FALSE	int
;	O
unsigned	O
int	O
pr_type	int
=	O
aprop	pointer
!=	O
NULL	O
?	O
aprop	pointer
->	O
pr_type	int
:	O
bprop	pointer
->	O
pr_type	int
;	O
if	O
(	O
pr_type	int
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_USED	int
||	O
(	O
pr_type	int
>=	O
GNU_PROPERTY_X86_UINT32_OR_AND_LO	int
&&	O
pr_type	int
<=	O
GNU_PROPERTY_X86_UINT32_OR_AND_HI	int
)	O
)	O
{	O
if	O
(	O
aprop	pointer
==	O
NULL	O
||	O
bprop	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
aprop	pointer
!=	O
NULL	O
)	O
{	O
aprop	pointer
->	O
pr_kind	enum
=	O
property_remove	int
;	O
updated	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
number	long
=	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
aprop	pointer
->	O
u	union
.	O
number	long
=	O
number	long
|	O
bprop	pointer
->	O
u	union
.	O
number	long
;	O
updated	int
=	O
number	long
!=	O
(	O
unsigned	O
int	O
)	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
}	O
return	O
updated	int
;	O
}	O
else	O
if	O
(	O
pr_type	int
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED	int
||	O
(	O
pr_type	int
>=	O
GNU_PROPERTY_X86_UINT32_OR_LO	int
&&	O
pr_type	int
<=	O
GNU_PROPERTY_X86_UINT32_OR_HI	int
)	O
)	O
{	O
if	O
(	O
aprop	pointer
!=	O
NULL	O
&&	O
bprop	pointer
!=	O
NULL	O
)	O
{	O
number	long
=	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
aprop	pointer
->	O
u	union
.	O
number	long
=	O
number	long
|	O
bprop	pointer
->	O
u	union
.	O
number	long
;	O
if	O
(	O
aprop	pointer
->	O
u	union
.	O
number	long
==	O
0	int
)	O
{	O
aprop	pointer
->	O
pr_kind	enum
=	O
property_remove	int
;	O
updated	int
=	O
TRUE	int
;	O
}	O
else	O
updated	int
=	O
number	long
!=	O
(	O
unsigned	O
int	O
)	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
}	O
else	O
{	O
if	O
(	O
aprop	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
aprop	pointer
->	O
u	union
.	O
number	long
==	O
0	int
)	O
{	O
aprop	pointer
->	O
pr_kind	enum
=	O
property_remove	int
;	O
updated	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
updated	int
=	O
bprop	pointer
->	O
u	union
.	O
number	long
!=	O
0	int
;	O
}	O
}	O
return	O
updated	int
;	O
}	O
else	O
if	O
(	O
pr_type	int
>=	O
GNU_PROPERTY_X86_UINT32_AND_LO	int
&&	O
pr_type	int
<=	O
GNU_PROPERTY_X86_UINT32_AND_HI	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
!	O
htab	struct
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
aprop	pointer
!=	O
NULL	O
&&	O
bprop	pointer
!=	O
NULL	O
)	O
{	O
features	int
=	O
0	int
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
ibt	int
)	O
features	int
=	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
shstk	int
)	O
features	int
|=	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
;	O
number	long
=	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
aprop	pointer
->	O
u	union
.	O
number	long
=	O
(	O
number	long
&	O
bprop	pointer
->	O
u	union
.	O
number	long
)	O
|	O
features	int
;	O
updated	int
=	O
number	long
!=	O
(	O
unsigned	O
int	O
)	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
if	O
(	O
aprop	pointer
->	O
u	union
.	O
number	long
==	O
0	int
)	O
aprop	pointer
->	O
pr_kind	enum
=	O
property_remove	int
;	O
}	O
else	O
{	O
features	int
=	O
0	int
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
ibt	int
)	O
features	int
=	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
shstk	int
)	O
features	int
|=	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
;	O
if	O
(	O
features	int
)	O
{	O
if	O
(	O
aprop	pointer
!=	O
NULL	O
)	O
{	O
updated	int
=	O
features	int
!=	O
(	O
unsigned	O
int	O
)	O
aprop	pointer
->	O
u	union
.	O
number	long
;	O
aprop	pointer
->	O
u	union
.	O
number	long
=	O
features	int
;	O
}	O
else	O
{	O
updated	int
=	O
TRUE	int
;	O
bprop	pointer
->	O
u	union
.	O
number	long
=	O
features	int
;	O
}	O
}	O
else	O
if	O
(	O
aprop	pointer
!=	O
NULL	O
)	O
{	O
aprop	pointer
->	O
pr_kind	enum
=	O
property_remove	int
;	O
updated	int
=	O
TRUE	int
;	O
}	O
}	O
return	O
updated	int
;	O
}	O
else	O
{	O
abort	function
(	O
)	O
;	O
}	O
return	O
updated	int
;	O
}	O
bfd	struct
*	O
_bfd_x86_elf_link_setup_gnu_properties	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_x86_init_table	struct
*	O
init_table	pointer
)	O
{	O
bfd_boolean	int
normal_target	int
;	O
bfd_boolean	int
lazy_plt	pointer
;	O
asection	struct
*	O
sec	pointer
,	O
*	O
pltsec	pointer
;	O
bfd	struct
*	O
dynobj	pointer
;	O
bfd_boolean	int
use_ibt_plt	int
;	O
unsigned	O
int	O
plt_alignment	int
,	O
features	int
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
bfd	struct
*	O
pbfd	pointer
;	O
bfd	struct
*	O
ebfd	pointer
=	O
NULL	O
;	O
elf_property	struct
*	O
prop	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
int	O
class_align	int
=	O
ABI_64_P	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
?	O
3	int
:	O
2	int
;	O
unsigned	O
int	O
got_align	int
;	O
for	O
(	O
pbfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
pbfd	pointer
!=	O
NULL	O
;	O
pbfd	pointer
=	O
pbfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
pbfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
bfd_count_sections	function
(	O
pbfd	pointer
)	O
!=	O
0	int
)	O
{	O
ebfd	pointer
=	O
pbfd	pointer
;	O
if	O
(	O
elf_properties	O
(	O
pbfd	pointer
)	O
!=	O
NULL	O
)	O
break	O
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
pbfd	pointer
;	O
features	int
=	O
0	int
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
ibt	int
)	O
{	O
features	int
=	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
;	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
&=	O
~	O
cet_report_ibt	int
;	O
}	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
shstk	int
)	O
{	O
features	int
|=	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
;	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
&=	O
~	O
cet_report_shstk	int
;	O
}	O
if	O
(	O
!	O
(	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
&	O
(	O
cet_report_ibt	int
|	O
cet_report_shstk	int
)	O
)	O
)	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
=	O
cet_report_none	int
;	O
if	O
(	O
ebfd	pointer
!=	O
NULL	O
)	O
{	O
prop	pointer
=	O
NULL	O
;	O
if	O
(	O
features	int
)	O
{	O
prop	pointer
=	O
_bfd_elf_get_property	function
(	O
ebfd	pointer
,	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
,	O
4	int
)	O
;	O
prop	pointer
->	O
u	union
.	O
number	long
|=	O
features	int
;	O
prop	pointer
->	O
pr_kind	enum
=	O
property_number	int
;	O
}	O
if	O
(	O
prop	pointer
!=	O
NULL	O
&&	O
pbfd	pointer
==	O
NULL	O
)	O
{	O
sec	pointer
=	O
bfd_make_section_with_flags	function
(	O
ebfd	pointer
,	O
NOTE_GNU_PROPERTY_SECTION_NAME	pointer
,	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_IN_MEMORY	int
|	O
SEC_READONLY	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_DATA	int
)	O
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create GNU property section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
class_align	int
)	O
)	O
{	O
error_alignment	O
:	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%pA: failed to align section\n"	pointer
)	O
,	O
sec	pointer
)	O
;	O
}	O
elf_section_type	O
(	O
sec	pointer
)	O
=	O
SHT_NOTE	int
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
const	O
char	O
*	O
msg	pointer
;	O
elf_property_list	struct
*	O
p	pointer
;	O
bfd_boolean	int
missing_ibt	int
,	O
missing_shstk	int
;	O
bfd_boolean	int
check_ibt	int
=	O
!	O
!	O
(	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
&	O
cet_report_ibt	int
)	O
;	O
bfd_boolean	int
check_shstk	int
=	O
!	O
!	O
(	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
&	O
cet_report_shstk	int
)	O
;	O
if	O
(	O
(	O
htab	struct
->	O
params	pointer
->	O
cet_report	enum
&	O
cet_report_warning	int
)	O
)	O
msg	pointer
=	O
_	O
(	O
"%P: %pB: warning: missing %s\n"	pointer
)	O
;	O
else	O
msg	pointer
=	O
_	O
(	O
"%X%P: %pB: error: missing %s\n"	pointer
)	O
;	O
for	O
(	O
abfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
!	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
BFD_PLUGIN	int
|	O
BFD_LINKER_CREATED	int
)	O
)	O
&&	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
for	O
(	O
p	pointer
=	O
elf_properties	O
(	O
abfd	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
property	struct
.	O
pr_type	int
==	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
)	O
break	O
;	O
missing_ibt	int
=	O
check_ibt	int
;	O
missing_shstk	int
=	O
check_shstk	int
;	O
if	O
(	O
p	pointer
)	O
{	O
missing_ibt	int
&=	O
!	O
(	O
p	pointer
->	O
property	struct
.	O
u	union
.	O
number	long
&	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
)	O
;	O
missing_shstk	int
&=	O
!	O
(	O
p	pointer
->	O
property	struct
.	O
u	union
.	O
number	long
&	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
)	O
;	O
}	O
if	O
(	O
missing_ibt	int
||	O
missing_shstk	int
)	O
{	O
const	O
char	O
*	O
missing	pointer
;	O
if	O
(	O
missing_ibt	int
&&	O
missing_shstk	int
)	O
missing	pointer
=	O
_	O
(	O
"IBT and SHSTK properties"	pointer
)	O
;	O
else	O
if	O
(	O
missing_ibt	int
)	O
missing	pointer
=	O
_	O
(	O
"IBT property"	pointer
)	O
;	O
else	O
missing	pointer
=	O
_	O
(	O
"SHSTK property"	pointer
)	O
;	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
msg	pointer
,	O
abfd	pointer
,	O
missing	pointer
)	O
;	O
}	O
}	O
}	O
pbfd	pointer
=	O
_bfd_elf_link_setup_gnu_properties	function
(	O
info	pointer
)	O
;	O
htab	struct
->	O
r_info	array
=	O
init_table	pointer
->	O
r_info	array
;	O
htab	struct
->	O
r_sym	pointer
=	O
init_table	pointer
->	O
r_sym	pointer
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
return	O
pbfd	pointer
;	O
htab	struct
->	O
plt0_pad_byte	char
=	O
init_table	pointer
->	O
plt0_pad_byte	char
;	O
use_ibt_plt	int
=	O
htab	struct
->	O
params	pointer
->	O
ibtplt	int
||	O
htab	struct
->	O
params	pointer
->	O
ibt	int
;	O
if	O
(	O
!	O
use_ibt_plt	int
&&	O
pbfd	pointer
!=	O
NULL	O
)	O
{	O
elf_property_list	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
elf_properties	O
(	O
pbfd	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
==	O
p	pointer
->	O
property	struct
.	O
pr_type	int
)	O
{	O
use_ibt_plt	int
=	O
!	O
!	O
(	O
p	pointer
->	O
property	struct
.	O
u	union
.	O
number	long
&	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
<	O
p	pointer
->	O
property	struct
.	O
pr_type	int
)	O
break	O
;	O
}	O
}	O
dynobj	pointer
=	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
;	O
if	O
(	O
dynobj	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
pbfd	pointer
!=	O
NULL	O
)	O
{	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
=	O
pbfd	pointer
;	O
dynobj	pointer
=	O
pbfd	pointer
;	O
}	O
else	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
for	O
(	O
abfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
BFD_LINKER_CREATED	int
|	O
BFD_PLUGIN	int
)	O
)	O
==	O
0	int
&&	O
bed	pointer
->	O
relocs_compatible	pointer
(	O
abfd	pointer
->	O
xvec	pointer
,	O
info	pointer
->	O
output_bfd	pointer
->	O
xvec	pointer
)	O
)	O
{	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
=	O
abfd	pointer
;	O
dynobj	pointer
=	O
abfd	pointer
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
dynobj	pointer
==	O
NULL	O
)	O
return	O
pbfd	pointer
;	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
=	O
1	int
;	O
normal_target	int
=	O
htab	struct
->	O
target_os	enum
==	O
is_normal	int
;	O
if	O
(	O
normal_target	int
)	O
{	O
if	O
(	O
use_ibt_plt	int
)	O
{	O
htab	struct
->	O
lazy_plt	pointer
=	O
init_table	pointer
->	O
lazy_ibt_plt	pointer
;	O
htab	struct
->	O
non_lazy_plt	pointer
=	O
init_table	pointer
->	O
non_lazy_ibt_plt	pointer
;	O
}	O
else	O
{	O
htab	struct
->	O
lazy_plt	pointer
=	O
init_table	pointer
->	O
lazy_plt	pointer
;	O
htab	struct
->	O
non_lazy_plt	pointer
=	O
init_table	pointer
->	O
non_lazy_plt	pointer
;	O
}	O
}	O
else	O
{	O
htab	struct
->	O
lazy_plt	pointer
=	O
init_table	pointer
->	O
lazy_plt	pointer
;	O
htab	struct
->	O
non_lazy_plt	pointer
=	O
NULL	O
;	O
}	O
pltsec	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
if	O
(	O
htab	struct
->	O
non_lazy_plt	pointer
!=	O
NULL	O
&&	O
(	O
!	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
||	O
pltsec	pointer
==	O
NULL	O
)	O
)	O
{	O
lazy_plt	pointer
=	O
FALSE	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
htab	struct
->	O
plt	union
.	O
plt_entry	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
pic_plt_entry	pointer
;	O
else	O
htab	struct
->	O
plt	union
.	O
plt_entry	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
;	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
htab	struct
->	O
plt	union
.	O
plt_got_offset	int
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
;	O
htab	struct
->	O
plt	union
.	O
plt_got_insn_size	int
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_got_insn_size	int
;	O
htab	struct
->	O
plt	union
.	O
eh_frame_plt_size	int
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
eh_frame_plt_size	int
;	O
htab	struct
->	O
plt	union
.	O
eh_frame_plt	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
eh_frame_plt	pointer
;	O
}	O
else	O
{	O
lazy_plt	pointer
=	O
TRUE	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
htab	struct
->	O
plt	union
.	O
plt0_entry	pointer
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
pic_plt0_entry	pointer
;	O
htab	struct
->	O
plt	union
.	O
plt_entry	pointer
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
pic_plt_entry	pointer
;	O
}	O
else	O
{	O
htab	struct
->	O
plt	union
.	O
plt0_entry	pointer
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_entry	pointer
;	O
htab	struct
->	O
plt	union
.	O
plt_entry	pointer
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_entry	pointer
;	O
}	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_entry_size	int
;	O
htab	struct
->	O
plt	union
.	O
plt_got_offset	int
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_got_offset	int
;	O
htab	struct
->	O
plt	union
.	O
plt_got_insn_size	int
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_got_insn_size	int
;	O
htab	struct
->	O
plt	union
.	O
eh_frame_plt_size	int
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
eh_frame_plt_size	int
;	O
htab	struct
->	O
plt	union
.	O
eh_frame_plt	pointer
=	O
htab	struct
->	O
lazy_plt	pointer
->	O
eh_frame_plt	pointer
;	O
}	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
&&	O
!	O
elf_vxworks_create_dynamic_sections	function
(	O
dynobj	pointer
,	O
info	pointer
,	O
&	O
htab	struct
->	O
srelplt2	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create VxWorks dynamic sections\n"	pointer
)	O
)	O
;	O
return	O
pbfd	pointer
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
&&	O
!	O
_bfd_elf_create_got_section	function
(	O
dynobj	pointer
,	O
info	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create GOT sections\n"	pointer
)	O
)	O
;	O
got_align	int
=	O
(	O
bed	pointer
->	O
target_id	enum
==	O
X86_64_ELF_DATA	int
)	O
?	O
3	int
:	O
2	int
;	O
sec	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
got_align	int
)	O
)	O
goto	O
error_alignment	O
;	O
sec	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
got_align	int
)	O
)	O
goto	O
error_alignment	O
;	O
if	O
(	O
!	O
_bfd_elf_create_ifunc_sections	function
(	O
dynobj	pointer
,	O
info	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create ifunc sections\n"	pointer
)	O
)	O
;	O
plt_alignment	int
=	O
bfd_log2	function
(	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
)	O
;	O
if	O
(	O
pltsec	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
!	O
info	pointer
->	O
nointerp	int
)	O
{	O
asection	struct
*	O
s	pointer
=	O
bfd_get_linker_section	function
(	O
dynobj	pointer
,	O
".interp"	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
s	pointer
->	O
size	long
=	O
htab	struct
->	O
dynamic_interpreter_size	int
;	O
s	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
htab	struct
->	O
dynamic_interpreter	pointer
;	O
htab	struct
->	O
interp	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
normal_target	int
)	O
{	O
flagword	int
pltflags	int
=	O
(	O
bed	pointer
->	O
dynamic_sec_flags	int
|	O
SEC_ALLOC	int
|	O
SEC_CODE	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
)	O
;	O
unsigned	O
int	O
non_lazy_plt_alignment	int
=	O
bfd_log2	function
(	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
;	O
sec	pointer
=	O
pltsec	pointer
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
plt_alignment	int
)	O
)	O
goto	O
error_alignment	O
;	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
".plt.got"	pointer
,	O
pltflags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create GOT PLT section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
non_lazy_plt_alignment	int
)	O
)	O
goto	O
error_alignment	O
;	O
htab	struct
->	O
plt_got	union
=	O
sec	pointer
;	O
if	O
(	O
lazy_plt	pointer
)	O
{	O
sec	pointer
=	O
NULL	O
;	O
if	O
(	O
use_ibt_plt	int
)	O
{	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
".plt.sec"	pointer
,	O
pltflags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create IBT-enabled PLT section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
plt_alignment	int
)	O
)	O
goto	O
error_alignment	O
;	O
}	O
else	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
bndplt	int
&&	O
ABI_64_P	O
(	O
dynobj	pointer
)	O
)	O
{	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
".plt.sec"	pointer
,	O
pltflags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create BND PLT section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
non_lazy_plt_alignment	int
)	O
)	O
goto	O
error_alignment	O
;	O
}	O
htab	struct
->	O
plt_second	union
=	O
sec	pointer
;	O
}	O
}	O
if	O
(	O
!	O
info	pointer
->	O
no_ld_generated_unwind_info	int
)	O
{	O
flagword	int
flags	int
=	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_IN_MEMORY	int
|	O
SEC_LINKER_CREATED	int
)	O
;	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
".eh_frame"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create PLT .eh_frame section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
class_align	int
)	O
)	O
goto	O
error_alignment	O
;	O
htab	struct
->	O
plt_eh_frame	pointer
=	O
sec	pointer
;	O
if	O
(	O
htab	struct
->	O
plt_got	union
!=	O
NULL	O
)	O
{	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
".eh_frame"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create GOT PLT .eh_frame section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
class_align	int
)	O
)	O
goto	O
error_alignment	O
;	O
htab	struct
->	O
plt_got_eh_frame	pointer
=	O
sec	pointer
;	O
}	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
".eh_frame"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to create the second PLT .eh_frame section\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
class_align	int
)	O
)	O
goto	O
error_alignment	O
;	O
htab	struct
->	O
plt_second_eh_frame	pointer
=	O
sec	pointer
;	O
}	O
}	O
}	O
sec	pointer
=	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
0	int
)	O
)	O
goto	O
error_alignment	O
;	O
htab	struct
->	O
plt	union
.	O
iplt_alignment	int
=	O
(	O
normal_target	int
?	O
plt_alignment	int
:	O
bed	pointer
->	O
plt_alignment	int
)	O
;	O
}	O
return	O
pbfd	pointer
;	O
}	O
void	O
_bfd_x86_elf_link_fixup_gnu_properties	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
elf_property_list	struct
*	O
*	O
listp	pointer
)	O
{	O
elf_property_list	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
*	O
listp	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
int	O
type	enum
=	O
p	pointer
->	O
property	struct
.	O
pr_type	int
;	O
if	O
(	O
type	enum
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_USED	int
||	O
type	enum
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED	int
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_AND_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_AND_HI	int
)	O
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_OR_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_OR_HI	int
)	O
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_OR_AND_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_OR_AND_HI	int
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
property	struct
.	O
u	union
.	O
number	long
==	O
0	int
&&	O
(	O
type	enum
==	O
GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED	int
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_AND_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_AND_HI	int
)	O
||	O
(	O
type	enum
>=	O
GNU_PROPERTY_X86_UINT32_OR_LO	int
&&	O
type	enum
<=	O
GNU_PROPERTY_X86_UINT32_OR_HI	int
)	O
)	O
)	O
{	O
*	O
listp	pointer
=	O
p	pointer
->	O
next	pointer
;	O
continue	O
;	O
}	O
listp	pointer
=	O
&	O
p	pointer
->	O
next	pointer
;	O
}	O
else	O
if	O
(	O
type	enum
>	O
GNU_PROPERTY_HIPROC	int
)	O
{	O
break	O
;	O
}	O
}	O
}	O
void	O
_bfd_elf_linker_x86_set_options	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_linker_x86_params	struct
*	O
params	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
htab	struct
!=	O
NULL	O
)	O
htab	struct
->	O
params	pointer
=	O
params	pointer
;	O
}	O
