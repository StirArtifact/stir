void	O
CorrectInputToTransition	function
(	O
PEXPERIMENT	pointer
pexp	pointer
,	O
PDOUBLE	pointer
pdTtrans	pointer
)	O
{	O
pexp	pointer
->	O
dTime	double
=	O
*	O
pdTtrans	pointer
;	O
UpdateInputs	function
(	O
&	O
pexp	pointer
->	O
dTime	double
,	O
pdTtrans	pointer
)	O
;	O
}	O
int	O
Euler	function
(	O
long	O
neq	long
,	O
double	O
*	O
y	pointer
,	O
double	O
*	O
t	pointer
,	O
double	O
tout	double
,	O
double	O
dTStep	double
)	O
{	O
static	O
PDOUBLE	pointer
rgdDeriv	pointer
;	O
double	O
dTmp_step	double
;	O
long	O
i	long
;	O
if	O
(	O
!	O
(	O
rgdDeriv	pointer
)	O
)	O
if	O
(	O
!	O
(	O
rgdDeriv	pointer
=	O
InitdVector	function
(	O
neq	long
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"Euler"	pointer
,	O
NULL	O
)	O
;	O
while	O
(	O
*	O
t	pointer
<	O
tout	double
)	O
{	O
CalcDeriv	function
(	O
y	pointer
,	O
rgdDeriv	pointer
,	O
t	pointer
)	O
;	O
*	O
t	pointer
=	O
*	O
t	pointer
+	O
dTStep	double
;	O
if	O
(	O
*	O
t	pointer
>	O
tout	double
)	O
{	O
dTmp_step	double
=	O
tout	double
-	O
(	O
*	O
t	pointer
-	O
dTStep	double
)	O
;	O
*	O
t	pointer
=	O
tout	double
;	O
}	O
else	O
dTmp_step	double
=	O
dTStep	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
neq	long
;	O
i	long
++	O
)	O
y	pointer
[	O
i	long
]	O
=	O
y	pointer
[	O
i	long
]	O
+	O
dTmp_step	double
*	O
rgdDeriv	pointer
[	O
i	long
]	O
;	O
if	O
(	O
bDelays	int
)	O
StoreDelayed	function
(	O
*	O
t	pointer
)	O
;	O
DoStep_by_Step	function
(	O
)	O
;	O
}	O
CalcDeriv	function
(	O
y	pointer
,	O
rgdDeriv	pointer
,	O
t	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
FreeVarMod	function
(	O
PVOID	pointer
pData	pointer
)	O
{	O
PVARMOD	pointer
pvarmod	pointer
=	O
(	O
PVARMOD	pointer
)	O
pData	pointer
;	O
if	O
(	O
IsInput	function
(	O
pvarmod	pointer
->	O
hvar	long
)	O
)	O
if	O
(	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
free	function
(	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
free	function
(	O
pvarmod	pointer
)	O
;	O
}	O
int	O
ModifyOneParm	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pNullInfo	pointer
)	O
{	O
PVARMOD	pointer
pvarmod	pointer
=	O
(	O
PVARMOD	pointer
)	O
pData	pointer
;	O
if	O
(	O
IsInput	function
(	O
pvarmod	pointer
->	O
hvar	long
)	O
)	O
SetInput	function
(	O
pvarmod	pointer
->	O
hvar	long
,	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
else	O
SetVar	function
(	O
pvarmod	pointer
->	O
hvar	long
,	O
pvarmod	pointer
->	O
uvar	union
.	O
dVal	double
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ModifyParms	function
(	O
PLIST	pointer
plistParmMods	pointer
)	O
{	O
assert	O
(	O
plistParmMods	pointer
)	O
;	O
ForAllList	function
(	O
plistParmMods	pointer
,	O
&	O
ModifyOneParm	function
,	O
NULL	O
)	O
;	O
}	O
int	O
DoOneExperiment	function
(	O
PEXPERIMENT	pointer
pexp	pointer
)	O
{	O
double	O
dTout	double
;	O
double	O
dTtrans	double
;	O
double	O
dTup	double
;	O
int	O
iOut	int
;	O
PMODELINFO	pointer
pmod	pointer
;	O
PINTSPEC	pointer
pis	pointer
;	O
if	O
(	O
!	O
pexp	pointer
)	O
return	O
0	int
;	O
pmod	pointer
=	O
pexp	pointer
->	O
pmodelinfo	pointer
;	O
pis	pointer
=	O
&	O
(	O
pexp	pointer
->	O
is	struct
)	O
;	O
if	O
(	O
!	O
InitOutputs	function
(	O
pexp	pointer
,	O
&	O
iOut	int
,	O
&	O
dTout	double
)	O
)	O
return	O
0	int
;	O
if	O
(	O
pexp	pointer
->	O
hT0	long
)	O
pexp	pointer
->	O
dT0	double
=	O
GetVarValue	function
(	O
pexp	pointer
->	O
hT0	long
)	O
;	O
UpdateInputs	function
(	O
&	O
pexp	pointer
->	O
dT0	double
,	O
&	O
dTtrans	double
)	O
;	O
if	O
(	O
bDelays	int
)	O
InitDelays	function
(	O
pexp	pointer
->	O
hT0	long
)	O
;	O
if	O
(	O
pexp	pointer
->	O
dT0	double
>	O
dTtrans	double
)	O
{	O
printf	function
(	O
"\nError: starting time is greater than first discontinuity,"	pointer
"       check your inputs - Exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
pexp	pointer
->	O
dT0	double
>	O
dTout	double
)	O
{	O
printf	function
(	O
"\nError: starting time is greater than first output time,"	pointer
"       check your outputs - Exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
pexp	pointer
->	O
dTime	double
=	O
pexp	pointer
->	O
dT0	double
;	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_LSODES	int
)	O
{	O
pis	pointer
->	O
iDSFlag	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_CVODES	int
)	O
{	O
}	O
}	O
while	O
(	O
pexp	pointer
->	O
dTime	double
<	O
pexp	pointer
->	O
dTfinal	double
)	O
{	O
if	O
(	O
pmod	pointer
->	O
nStates	long
>	O
0	int
)	O
{	O
if	O
(	O
fabs	function
(	O
dTout	double
-	O
dTtrans	double
)	O
<	O
DBL_EPSILON	O
*	O
2.0	int
*	O
mymax	O
(	O
fabs	function
(	O
dTout	double
)	O
,	O
fabs	function
(	O
dTtrans	double
)	O
)	O
)	O
dTtrans	double
=	O
dTout	double
;	O
dTup	double
=	O
(	O
dTout	double
<	O
dTtrans	double
)	O
?	O
dTout	double
:	O
dTtrans	double
;	O
if	O
(	O
fabs	function
(	O
dTup	double
-	O
pexp	pointer
->	O
dTime	double
)	O
<	O
DBL_EPSILON	O
*	O
2.0	int
*	O
mymax	O
(	O
fabs	function
(	O
dTup	double
)	O
,	O
fabs	function
(	O
pexp	pointer
->	O
dTime	double
)	O
)	O
)	O
pexp	pointer
->	O
dTime	double
=	O
dTup	double
;	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_LSODES	int
)	O
{	O
pis	pointer
->	O
rwork	pointer
[	O
0	int
]	O
=	O
dTup	double
;	O
lsodes_	function
(	O
&	O
pmod	pointer
->	O
nStates	long
,	O
pmod	pointer
->	O
pdModelVars	pointer
,	O
&	O
(	O
pexp	pointer
)	O
->	O
dTime	double
,	O
&	O
dTup	double
,	O
&	O
pis	pointer
->	O
itol	long
,	O
&	O
pis	pointer
->	O
dRtol	double
,	O
&	O
pis	pointer
->	O
dAtol	double
,	O
&	O
pis	pointer
->	O
itask	long
,	O
&	O
pis	pointer
->	O
iDSFlag	long
,	O
&	O
pis	pointer
->	O
iopt	long
,	O
pis	pointer
->	O
rwork	pointer
,	O
&	O
pis	pointer
->	O
lrw	long
,	O
pis	pointer
->	O
iwork	pointer
,	O
&	O
pis	pointer
->	O
liw	long
,	O
&	O
pis	pointer
->	O
iMf	long
)	O
;	O
if	O
(	O
pis	pointer
->	O
iDSFlag	long
<	O
0	int
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_CVODES	int
)	O
{	O
}	O
else	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_EULER	int
)	O
{	O
Euler	function
(	O
pmod	pointer
->	O
nStates	long
,	O
pmod	pointer
->	O
pdModelVars	pointer
,	O
&	O
(	O
pexp	pointer
)	O
->	O
dTime	double
,	O
dTup	double
,	O
pis	pointer
->	O
dTStep	double
)	O
;	O
}	O
}	O
}	O
else	O
{	O
pexp	pointer
->	O
dTime	double
=	O
(	O
dTout	double
<	O
dTtrans	double
)	O
?	O
dTout	double
:	O
dTtrans	double
;	O
}	O
if	O
(	O
dTtrans	double
<=	O
dTout	double
)	O
{	O
if	O
(	O
dTtrans	double
<	O
dTout	double
)	O
{	O
if	O
(	O
dTtrans	double
<	O
pexp	pointer
->	O
dTfinal	double
)	O
{	O
CorrectInputToTransition	function
(	O
pexp	pointer
,	O
&	O
dTtrans	double
)	O
;	O
pis	pointer
->	O
iDSFlag	long
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
dTtrans	double
<	O
pexp	pointer
->	O
dTfinal	double
)	O
{	O
CorrectInputToTransition	function
(	O
pexp	pointer
,	O
&	O
dTtrans	double
)	O
;	O
pis	pointer
->	O
iDSFlag	long
=	O
1	int
;	O
}	O
SaveOutputs	function
(	O
pexp	pointer
,	O
&	O
dTout	double
)	O
;	O
NextOutputTime	function
(	O
pexp	pointer
,	O
&	O
dTout	double
,	O
&	O
iOut	int
)	O
;	O
}	O
}	O
else	O
{	O
SaveOutputs	function
(	O
pexp	pointer
,	O
&	O
dTout	double
)	O
;	O
NextOutputTime	function
(	O
pexp	pointer
,	O
&	O
dTout	double
,	O
&	O
iOut	int
)	O
;	O
}	O
}	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_CVODES	int
)	O
{	O
}	O
return	O
1	int
;	O
}	O
int	O
DoOneNormalExp	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PEXPERIMENT	pointer
pexp	pointer
)	O
{	O
printf	function
(	O
" %d"	pointer
,	O
pexp	pointer
->	O
iExp	int
)	O
;	O
InitModel	function
(	O
)	O
;	O
ModifyParms	function
(	O
panal	pointer
->	O
expGlobal	struct
.	O
plistParmMods	pointer
)	O
;	O
ModifyParms	function
(	O
pexp	pointer
->	O
plistParmMods	pointer
)	O
;	O
if	O
(	O
!	O
DoOneExperiment	function
(	O
pexp	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
DoOneMCExp	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PEXPERIMENT	pointer
pexp	pointer
)	O
{	O
register	O
MONTECARLO	struct
*	O
pmc	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
InitModel	function
(	O
)	O
;	O
ModifyParms	function
(	O
panal	pointer
->	O
expGlobal	struct
.	O
plistParmMods	pointer
)	O
;	O
SetParms	function
(	O
pmc	pointer
->	O
nParms	long
,	O
pmc	pointer
->	O
rghvar	pointer
,	O
pmc	pointer
->	O
rgdParms	pointer
)	O
;	O
ModifyParms	function
(	O
pexp	pointer
->	O
plistParmMods	pointer
)	O
;	O
if	O
(	O
!	O
DoOneExperiment	function
(	O
pexp	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
DoNormal	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
int	O
nExps	int
=	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
int	O
i	long
;	O
printf	function
(	O
"\nDoing analysis - %d normal experiment%c\n"	pointer
,	O
nExps	int
,	O
(	O
nExps	int
>	O
1	int
?	O
's'	O
:	O
' '	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nExps	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
DoOneNormalExp	function
(	O
panal	pointer
,	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
)	O
)	O
{	O
WriteNormalOutput	function
(	O
panal	pointer
,	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
)	O
;	O
}	O
else	O
printf	function
(	O
"Warning: Integration failed - No output generated\n"	pointer
)	O
;	O
}	O
}	O
void	O
DoMonteCarlo	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
int	O
nExps	int
=	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
long	O
nRuns	long
=	O
panal	pointer
->	O
mc	struct
.	O
nRuns	long
;	O
MCPREDOUT	struct
mcpredout	struct
;	O
BOOL	int
bOK	int
;	O
long	O
i	long
,	O
j	long
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
{	O
printf	function
(	O
"Doing %ld Monte Carlo simulation%c, %d experiment%c%s\n"	pointer
,	O
nRuns	long
,	O
(	O
nRuns	long
!=	O
1	int
?	O
's'	O
:	O
' '	O
)	O
,	O
nExps	int
,	O
(	O
nExps	int
>	O
1	int
?	O
's'	O
:	O
' '	O
)	O
,	O
(	O
nRuns	long
!=	O
1	int
?	O
" each"	pointer
:	O
"."	pointer
)	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
printf	function
(	O
"Split between %d processors\n"	pointer
,	O
panal	pointer
->	O
size	int
)	O
;	O
}	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
SetParents	function
(	O
&	O
panal	pointer
->	O
mc	struct
,	O
0	int
)	O
;	O
OpenMCFiles	function
(	O
panal	pointer
)	O
;	O
mcpredout	struct
.	O
pred	pointer
=	O
NULL	O
;	O
for	O
(	O
i	long
=	O
panal	pointer
->	O
rank	int
;	O
i	long
<	O
nRuns	long
;	O
i	long
+=	O
panal	pointer
->	O
size	int
)	O
{	O
if	O
(	O
i	long
==	O
0	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
bOutputIter	int
&&	O
(	O
(	O
i	long
+	O
1	int
)	O
%	O
panal	pointer
->	O
nOutputFreq	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
printf	function
(	O
"Processor %d, Iteration %ld\n"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
i	long
+	O
1	int
)	O
;	O
else	O
printf	function
(	O
"Iteration %ld\n"	pointer
,	O
i	long
+	O
1	int
)	O
;	O
}	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
=	O
i	long
;	O
CalcMCParms	function
(	O
&	O
panal	pointer
->	O
mc	struct
,	O
NULL	O
,	O
0	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nExps	int
;	O
j	long
++	O
)	O
{	O
bOK	int
=	O
DoOneMCExp	function
(	O
panal	pointer
,	O
panal	pointer
->	O
rgpExps	array
[	O
j	long
]	O
)	O
;	O
if	O
(	O
!	O
bOK	int
)	O
break	O
;	O
}	O
if	O
(	O
bOK	int
)	O
{	O
TransformPred	function
(	O
panal	pointer
,	O
&	O
mcpredout	struct
)	O
;	O
WriteMCOutput	function
(	O
panal	pointer
,	O
&	O
mcpredout	struct
)	O
;	O
}	O
else	O
printf	function
(	O
"Warning: Integration failed on iteration %ld, experiment %ld:\n"	pointer
"         No output generated\n"	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
}	O
CloseMCFiles	function
(	O
panal	pointer
)	O
;	O
if	O
(	O
mcpredout	struct
.	O
pred	pointer
)	O
free	function
(	O
mcpredout	struct
.	O
pred	pointer
)	O
;	O
}	O
void	O
DoSetPoints	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
int	O
nExps	int
=	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
long	O
nRuns	long
=	O
panal	pointer
->	O
mc	struct
.	O
nRuns	long
;	O
MCPREDOUT	struct
mcpredout	struct
;	O
BOOL	int
bOK	int
=	O
FALSE	int
,	O
bNotDone	int
;	O
int	O
i	long
;	O
mcpredout	struct
.	O
pred	pointer
=	O
NULL	O
;	O
OpenMCFiles	function
(	O
panal	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
{	O
printf	function
(	O
"Doing analysis - %ld SetPoints run%c... %d experiment%c%s\n"	pointer
,	O
nRuns	long
,	O
(	O
nRuns	long
!=	O
1	int
?	O
's'	O
:	O
' '	O
)	O
,	O
nExps	int
,	O
(	O
nExps	int
>	O
1	int
?	O
's'	O
:	O
' '	O
)	O
,	O
(	O
nRuns	long
!=	O
1	int
?	O
" each"	pointer
:	O
" "	pointer
)	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
printf	function
(	O
"Split between %d processors\n"	pointer
,	O
panal	pointer
->	O
size	int
)	O
;	O
}	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
(	O
!	O
nRuns	long
)	O
&&	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
"0 runs specified for SetPoint(). Reading entire file.\n\n"	pointer
)	O
;	O
SetParents	function
(	O
&	O
panal	pointer
->	O
mc	struct
,	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
)	O
;	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
=	O
0	int
;	O
bNotDone	int
=	O
TRUE	int
;	O
while	O
(	O
bNotDone	int
)	O
{	O
bNotDone	int
=	O
GetSPMods	function
(	O
panal	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bNotDone	int
)	O
&&	O
(	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
%	O
panal	pointer
->	O
size	int
==	O
panal	pointer
->	O
rank	int
)	O
)	O
{	O
if	O
(	O
panal	pointer
->	O
bOutputIter	int
&&	O
(	O
(	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
+	O
1	int
)	O
%	O
panal	pointer
->	O
nOutputFreq	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
printf	function
(	O
"Processor %d, Iteration %ld\n"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
+	O
1	int
)	O
;	O
else	O
printf	function
(	O
"Iteration %ld\n"	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
+	O
1	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nExps	int
;	O
i	long
++	O
)	O
{	O
bOK	int
=	O
DoOneMCExp	function
(	O
panal	pointer
,	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
!	O
bOK	int
)	O
break	O
;	O
}	O
if	O
(	O
bOK	int
)	O
{	O
TransformPred	function
(	O
panal	pointer
,	O
&	O
mcpredout	struct
)	O
;	O
WriteMCOutput	function
(	O
panal	pointer
,	O
&	O
mcpredout	struct
)	O
;	O
}	O
else	O
printf	function
(	O
"Warning: Integration failed on iteration %ld, experiment %d:\n"	pointer
"         No output generated\n"	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
+	O
1	int
,	O
i	long
+	O
1	int
)	O
;	O
}	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
++	O
;	O
if	O
(	O
nRuns	long
)	O
bNotDone	int
=	O
(	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
<	O
nRuns	long
)	O
;	O
}	O
CloseMCFiles	function
(	O
panal	pointer
)	O
;	O
if	O
(	O
mcpredout	struct
.	O
pred	pointer
)	O
free	function
(	O
mcpredout	struct
.	O
pred	pointer
)	O
;	O
}	O
void	O
DoAnalysis	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
if	O
(	O
panal	pointer
->	O
size	int
==	O
1	int
)	O
InitRandom	function
(	O
panal	pointer
->	O
rank	int
,	O
panal	pointer
->	O
dSeed	double
,	O
TRUE	int
)	O
;	O
else	O
InitRandom	function
(	O
panal	pointer
->	O
rank	int
,	O
panal	pointer
->	O
dSeed	double
+	O
panal	pointer
->	O
rank	int
,	O
TRUE	int
)	O
;	O
switch	O
(	O
panal	pointer
->	O
iType	int
)	O
{	O
default	O
:	O
case	O
AT_DEFAULTSIM	int
:	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
DoNormal	function
(	O
panal	pointer
)	O
;	O
break	O
;	O
case	O
AT_SETPOINTS	int
:	O
DoSetPoints	function
(	O
panal	pointer
)	O
;	O
break	O
;	O
case	O
AT_MONTECARLO	int
:	O
DoMonteCarlo	function
(	O
panal	pointer
)	O
;	O
break	O
;	O
case	O
AT_MCMC	int
:	O
DoMarkov	function
(	O
panal	pointer
)	O
;	O
break	O
;	O
case	O
AT_OPTDESIGN	int
:	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
DoOptimalDesign	function
(	O
panal	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
panal	pointer
->	O
pfileOut	pointer
)	O
{	O
fclose	function
(	O
panal	pointer
->	O
pfileOut	pointer
)	O
;	O
printf	function
(	O
"Wrote output file \"%s\"\n"	pointer
,	O
panal	pointer
->	O
szOutfilename	pointer
)	O
;	O
}	O
}	O
void	O
FreeMemory	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
int	O
i	long
,	O
j	long
;	O
free	function
(	O
panal	pointer
->	O
modelinfo	struct
.	O
pStateHvar	pointer
)	O
;	O
FreeList	function
(	O
&	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
if	O
(	O
panal	pointer
->	O
mc	struct
.	O
rgdParms	pointer
)	O
{	O
free	function
(	O
panal	pointer
->	O
mc	struct
.	O
rgdParms	pointer
)	O
;	O
free	function
(	O
panal	pointer
->	O
mc	struct
.	O
rghvar	pointer
)	O
;	O
}	O
PINTSPEC	pointer
pis	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
0	int
]	O
->	O
is	struct
;	O
free	function
(	O
pis	pointer
->	O
iwork	pointer
)	O
;	O
free	function
(	O
pis	pointer
->	O
rwork	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
!=	O
NULL	O
)	O
{	O
FreeList	function
(	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
plistParmMods	pointer
,	O
&	O
FreeVarMod	function
,	O
TRUE	int
)	O
;	O
POUTSPEC	pointer
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
free	function
(	O
pos	pointer
->	O
pszOutputNames	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
phvar_out	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
pcOutputTimes	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
piCurrentOut	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
prgdOutputTimes	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
free	function
(	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
j	long
]	O
)	O
;	O
free	function
(	O
pos	pointer
->	O
prgdOutputVals	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
rgdDistinctTimes	pointer
)	O
;	O
ForAllList	function
(	O
pos	pointer
->	O
plistPrintRecs	pointer
,	O
&	O
FreePrintRec	function
,	O
NULL	O
)	O
;	O
FreeList	function
(	O
&	O
pos	pointer
->	O
plistPrintRecs	pointer
,	O
NULL	O
,	O
FALSE	int
)	O
;	O
free	function
(	O
pos	pointer
->	O
plistPrintRecs	pointer
)	O
;	O
ForAllList	function
(	O
pos	pointer
->	O
plistDataRecs	pointer
,	O
&	O
FreeDataRec	function
,	O
NULL	O
)	O
;	O
FreeList	function
(	O
&	O
pos	pointer
->	O
plistDataRecs	pointer
,	O
NULL	O
,	O
FALSE	int
)	O
;	O
free	function
(	O
pos	pointer
->	O
plistDataRecs	pointer
)	O
;	O
free	function
(	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
)	O
;	O
}	O
}	O
if	O
(	O
panal	pointer
->	O
bAllocatedFileName	int
)	O
{	O
if	O
(	O
panal	pointer
->	O
szOutfilename	pointer
)	O
free	function
(	O
panal	pointer
->	O
szOutfilename	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
)	O
free	function
(	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
)	O
free	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
)	O
;	O
}	O
if	O
(	O
panal	pointer
->	O
mc	struct
.	O
szSetPointsFilename	pointer
)	O
free	function
(	O
panal	pointer
->	O
mc	struct
.	O
szSetPointsFilename	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
)	O
free	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
)	O
free	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
)	O
;	O
FreeList	function
(	O
&	O
panal	pointer
->	O
expGlobal	struct
.	O
plistParmMods	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
free	function
(	O
panal	pointer
)	O
;	O
}	O
MCVAR	struct
*	O
*	O
vrgpMCVar	pointer
;	O
int	O
viMCVar	int
;	O
int	O
MCVarListToArray	function
(	O
PVOID	pointer
pv_pMCVar	pointer
,	O
PVOID	pointer
pv_Null	pointer
)	O
{	O
vrgpMCVar	pointer
[	O
viMCVar	int
]	O
=	O
(	O
MCVAR	struct
*	O
)	O
pv_pMCVar	pointer
;	O
viMCVar	int
++	O
;	O
return	O
1	int
;	O
}	O
void	O
PrepAnalysis	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
register	O
MONTECARLO	struct
*	O
pmc	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
register	O
int	O
l	pointer
;	O
pmc	pointer
->	O
nParms	long
=	O
ListLength	O
(	O
pmc	pointer
->	O
plistMCVars	pointer
)	O
;	O
if	O
(	O
pmc	pointer
->	O
nParms	long
==	O
0	int
)	O
return	O
;	O
pmc	pointer
->	O
rgdParms	pointer
=	O
InitdVector	function
(	O
pmc	pointer
->	O
nParms	long
)	O
;	O
pmc	pointer
->	O
rgpMCVar	pointer
=	O
(	O
MCVAR	struct
*	O
*	O
)	O
malloc	function
(	O
(	O
pmc	pointer
->	O
nParms	long
)	O
*	O
sizeof	O
(	O
MCVAR	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
pmc	pointer
->	O
rgdParms	pointer
&&	O
pmc	pointer
->	O
rgpMCVar	pointer
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"PrepAnalysis"	pointer
,	O
NULL	O
)	O
;	O
vrgpMCVar	pointer
=	O
&	O
pmc	pointer
->	O
rgpMCVar	pointer
[	O
0	int
]	O
;	O
viMCVar	int
=	O
0	int
;	O
ForAllList	function
(	O
pmc	pointer
->	O
plistMCVars	pointer
,	O
MCVarListToArray	function
,	O
(	O
PVOID	pointer
)	O
NULL	O
)	O
;	O
FreeList	function
(	O
&	O
pmc	pointer
->	O
plistMCVars	pointer
,	O
NULL	O
,	O
FALSE	int
)	O
;	O
pmc	pointer
->	O
rghvar	pointer
=	O
(	O
HVAR	long
*	O
)	O
malloc	function
(	O
(	O
pmc	pointer
->	O
nParms	long
)	O
*	O
sizeof	O
(	O
HVAR	long
)	O
)	O
;	O
if	O
(	O
pmc	pointer
->	O
rghvar	pointer
)	O
{	O
for	O
(	O
l	pointer
=	O
0	int
;	O
l	pointer
<	O
pmc	pointer
->	O
nParms	long
;	O
l	pointer
++	O
)	O
pmc	pointer
->	O
rghvar	pointer
[	O
l	pointer
]	O
=	O
pmc	pointer
->	O
rgpMCVar	pointer
[	O
l	pointer
]	O
->	O
hvar	long
;	O
}	O
else	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"PrepAnalysis"	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
PromptFilenames	function
(	O
PSTR	pointer
*	O
pszFileIn	pointer
,	O
PSTR	pointer
*	O
pszFileOut	pointer
)	O
{	O
*	O
pszFileIn	pointer
=	O
(	O
PSTR	pointer
)	O
calloc	function
(	O
1	int
,	O
MAX_FILENAMESIZE	int
)	O
;	O
*	O
pszFileOut	pointer
=	O
(	O
PSTR	pointer
)	O
calloc	function
(	O
1	int
,	O
MAX_FILENAMESIZE	int
)	O
;	O
printf	function
(	O
"Input filename? "	pointer
)	O
;	O
if	O
(	O
!	O
fgets	function
(	O
*	O
pszFileIn	pointer
,	O
MAX_FILENAMESIZE	int
,	O
stdin	pointer
)	O
)	O
{	O
ReportError	function
(	O
NULL	O
,	O
RE_READERROR	int
|	O
RE_FATAL	int
,	O
"stdin"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
*	O
pszFileIn	pointer
=	O
strtok	function
(	O
*	O
pszFileIn	pointer
,	O
" \t\n"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
pszFileIn	pointer
)	O
)	O
return	O
;	O
if	O
(	O
(	O
*	O
pszFileIn	pointer
)	O
[	O
0	int
]	O
)	O
{	O
printf	function
(	O
"Output filename? "	pointer
)	O
;	O
if	O
(	O
!	O
fgets	function
(	O
*	O
pszFileOut	pointer
,	O
MAX_FILENAMESIZE	int
,	O
stdin	pointer
)	O
)	O
{	O
ReportError	function
(	O
NULL	O
,	O
RE_READERROR	int
|	O
RE_FATAL	int
,	O
"stdin"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
*	O
pszFileOut	pointer
=	O
strtok	function
(	O
*	O
pszFileOut	pointer
,	O
" \t\n"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
pszFileOut	pointer
)	O
||	O
!	O
(	O
*	O
pszFileOut	pointer
)	O
[	O
0	int
]	O
)	O
{	O
free	function
(	O
*	O
pszFileOut	pointer
)	O
;	O
*	O
pszFileOut	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
*	O
pszFileIn	pointer
=	O
(	O
PSTR	pointer
)	O
realloc	function
(	O
*	O
pszFileIn	pointer
,	O
MyStrlen	O
(	O
*	O
pszFileIn	pointer
)	O
+	O
1	int
)	O
;	O
*	O
pszFileOut	pointer
=	O
(	O
PSTR	pointer
)	O
realloc	function
(	O
*	O
pszFileOut	pointer
,	O
MyStrlen	O
(	O
*	O
pszFileOut	pointer
)	O
+	O
1	int
)	O
;	O
}	O
}	O
static	O
char	O
vszOptions	array
[	O
]	O
=	O
"c::h::H::i:D:"	pointer
;	O
void	O
GetCmdLineArgs	function
(	O
int	O
cArg	int
,	O
char	O
*	O
const	O
*	O
rgszArg	pointer
,	O
PSTR	pointer
*	O
pszFileIn	pointer
,	O
PSTR	pointer
*	O
pszFileOut	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
int	O
c	pointer
;	O
*	O
pszFileIn	pointer
=	O
*	O
pszFileOut	pointer
=	O
(	O
PSTR	pointer
)	O
NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
c	pointer
=	O
_getopt	function
(	O
cArg	int
,	O
rgszArg	pointer
,	O
vszOptions	array
)	O
;	O
if	O
(	O
c	pointer
==	O
EOF	O
)	O
break	O
;	O
switch	O
(	O
c	pointer
)	O
{	O
case	O
'c'	O
:	O
printf	function
(	O
">> MPI parallelization not active: option -c is ignored\n\n"	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
optarg	pointer
++	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"print-hierarchy"	pointer
)	O
)	O
{	O
printf	function
(	O
">> Debug option %s\n\n"	pointer
,	O
optarg	pointer
)	O
;	O
panal	pointer
->	O
bDependents	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
printf	function
(	O
">> A known debugging code must follow -D\nExiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'H'	O
:	O
case	O
'h'	O
:	O
printf	function
(	O
"Usage: %s [options] <input-file> [<output-file>]\n"	pointer
,	O
rgszArg	pointer
[	O
0	int
]	O
)	O
;	O
printf	function
(	O
"Options:\n"	pointer
)	O
;	O
printf	function
(	O
"  -c                   "	pointer
"Display MCMC convergence (if MPI is used)\n"	pointer
)	O
;	O
printf	function
(	O
"  -D=print-hierarchy   "	pointer
"Print out the hierarchy for debugging\n"	pointer
)	O
;	O
printf	function
(	O
"  -h                   "	pointer
"Display this information\n"	pointer
)	O
;	O
printf	function
(	O
"  -H                   "	pointer
"Display this information\n"	pointer
)	O
;	O
printf	function
(	O
"  -i=<arg>             "	pointer
"Print out every <arg> iteration\n"	pointer
)	O
;	O
printf	function
(	O
"\nFor further help on GNU MCSim please see:\n"	pointer
"http://www.gnu.org/software/mcsim.\n\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
optarg	pointer
++	O
;	O
panal	pointer
->	O
nOutputFreq	int
=	O
strtol	function
(	O
optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
panal	pointer
->	O
nOutputFreq	int
>	O
0	int
)	O
{	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
">> Print iteration frequency %d\n\n"	pointer
,	O
panal	pointer
->	O
nOutputFreq	int
)	O
;	O
panal	pointer
->	O
bOutputIter	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
printf	function
(	O
">> An integer print step must follow -i\nExiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
}	O
switch	O
(	O
cArg	int
-	O
optind	int
)	O
{	O
case	O
2	int
:	O
*	O
pszFileOut	pointer
=	O
rgszArg	pointer
[	O
optind	int
+	O
1	int
]	O
;	O
case	O
1	int
:	O
*	O
pszFileIn	pointer
=	O
rgszArg	pointer
[	O
optind	int
]	O
;	O
break	O
;	O
case	O
0	int
:	O
PromptFilenames	function
(	O
pszFileIn	pointer
,	O
pszFileOut	pointer
)	O
;	O
break	O
;	O
default	O
:	O
exit	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
}	O
while	O
(	O
*	O
pszFileIn	pointer
&&	O
(	O
*	O
pszFileIn	pointer
)	O
[	O
0	int
]	O
&&	O
!	O
MyStrcmp	function
(	O
*	O
pszFileIn	pointer
,	O
*	O
pszFileOut	pointer
)	O
)	O
{	O
printf	function
(	O
"\n** Input and output filename must be different.\n"	pointer
)	O
;	O
PromptFilenames	function
(	O
pszFileIn	pointer
,	O
pszFileOut	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
pszFileIn	pointer
&&	O
(	O
*	O
pszFileIn	pointer
)	O
[	O
0	int
]	O
)	O
)	O
{	O
printf	function
(	O
"Error: an input file name must be specified - Exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
}	O
void	O
AnnounceProgram	function
(	O
void	O
)	O
{	O
printf	function
(	O
"\n________________________________________\n"	pointer
)	O
;	O
printf	function
(	O
"\nMCSim "	pointer
VSZ_VERSION	pointer
"\n\n"	pointer
)	O
;	O
printf	function
(	O
VSZ_COPYRIGHT	pointer
"\n\n"	pointer
)	O
;	O
printf	function
(	O
"MCSim comes with ABSOLUTELY NO WARRANTY;\n"	pointer
"This is free software, and you are welcome to redistribute it\n"	pointer
"under certain conditions; see the GNU General Public License.\n\n"	pointer
)	O
;	O
printf	function
(	O
"* Using `%s' model in file \"%s\" created by %s\n\n"	pointer
,	O
szModelDescFilename	array
,	O
szModelSourceFilename	array
,	O
szModelGenAndVersion	array
)	O
;	O
}	O
int	O
main	function
(	O
int	O
nArg	int
,	O
char	O
*	O
*	O
rgszArg	pointer
)	O
{	O
int	O
rank	int
=	O
0	int
;	O
int	O
size	int
=	O
1	int
;	O
PSTR	pointer
szFileIn	pointer
,	O
szFileOut	pointer
;	O
INPUTBUF	struct
ibIn	struct
;	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
ANALYSIS	struct
)	O
)	O
;	O
panal	pointer
->	O
rank	int
=	O
rank	int
;	O
panal	pointer
->	O
size	int
=	O
size	int
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
AnnounceProgram	function
(	O
)	O
;	O
if	O
(	O
!	O
panal	pointer
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ANALYSIS specification too large"	pointer
,	O
NULL	O
)	O
;	O
InitAnalysis	function
(	O
panal	pointer
)	O
;	O
GetCmdLineArgs	function
(	O
nArg	int
,	O
rgszArg	pointer
,	O
&	O
szFileIn	pointer
,	O
&	O
szFileOut	pointer
,	O
panal	pointer
)	O
;	O
panal	pointer
->	O
szOutfilename	pointer
=	O
szFileOut	pointer
;	O
szFileOut	pointer
==	O
NULL	O
?	O
(	O
panal	pointer
->	O
bCommandLineSpec	int
=	O
FALSE	int
)	O
:	O
(	O
panal	pointer
->	O
bCommandLineSpec	int
=	O
TRUE	int
)	O
;	O
if	O
(	O
!	O
InitBuffer	function
(	O
&	O
ibIn	struct
,	O
szFileIn	pointer
)	O
)	O
ReportError	function
(	O
&	O
ibIn	struct
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
"ReadInput"	pointer
,	O
NULL	O
)	O
;	O
ibIn	struct
.	O
pInfo	pointer
=	O
(	O
PVOID	pointer
)	O
panal	pointer
;	O
if	O
(	O
ReadAnalysis	function
(	O
&	O
ibIn	struct
)	O
)	O
{	O
PrepAnalysis	function
(	O
panal	pointer
)	O
;	O
DoAnalysis	function
(	O
panal	pointer
)	O
;	O
}	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
"Done.\n\n"	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_MCMC	int
)	O
FreeLevels	function
(	O
panal	pointer
)	O
;	O
else	O
{	O
FreeMemory	function
(	O
panal	pointer
)	O
;	O
free	function
(	O
ibIn	struct
.	O
pbufOrg	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
