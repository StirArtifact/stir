int	O
gsl_sf_bessel_Inu_scaled_e	O
(	O
double	O
nu	O
,	O
double	O
x	O
,	O
gsl_sf_result	O
*	O
result	pointer
)	O
{	O
if	O
(	O
x	O
<	O
0.0	int
||	O
nu	O
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	O
*	O
x	pointer
<	O
10.0	O
*	O
(	O
nu	O
+	O
1.0	int
)	O
)	O
{	O
gsl_sf_result	O
b	O
;	O
double	O
ex	double
=	O
exp	O
(	O
-	O
x	int
)	O
;	O
int	O
stat	int
=	O
gsl_sf_bessel_IJ_taylor_e	O
(	O
nu	O
,	O
x	O
,	O
1	O
,	O
100	O
,	O
GSL_DBL_EPSILON	O
,	O
&	O
b	pointer
)	O
;	O
result	O
->	O
val	int
=	O
b	int
.	O
val	int
*	O
ex	O
;	O
result	pointer
->	O
err	int
=	O
b	int
.	O
err	int
*	O
ex	O
;	O
result	pointer
->	O
err	int
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	O
(	O
result	pointer
->	O
val	pointer
)	O
;	O
return	O
stat	int
;	O
}	O
else	O
if	O
(	O
0.5	O
/	O
(	O
nu	pointer
*	O
nu	O
+	O
x	int
*	O
x	O
)	O
<	O
GSL_ROOT3_DBL_EPSILON	int
)	O
{	O
return	O
gsl_sf_bessel_Inu_scaled_asymp_unif_e	int
(	O
nu	pointer
,	O
x	O
,	O
result	O
)	O
;	O
}	O
else	O
{	O
int	O
N	int
=	O
(	O
int	O
)	O
(	O
nu	O
+	O
0.5	int
)	O
;	O
double	O
mu	double
=	O
nu	O
-	O
N	int
;	O
double	O
K_mu	double
,	O
K_mup1	O
,	O
Kp_mu	O
;	O
double	O
K_nu	double
,	O
K_nup1	O
,	O
K_num1	O
;	O
double	O
I_nu_ratio	double
;	O
int	O
stat_Irat	int
;	O
int	O
stat_Kmu	int
;	O
int	O
n	int
;	O
if	O
(	O
x	O
<	O
2.0	int
)	O
{	O
stat_Kmu	O
=	O
gsl_sf_bessel_K_scaled_temme	int
(	O
mu	pointer
,	O
x	int
,	O
&	int
K_mu	struct
,	O
&	O
K_mup1	struct
,	O
&	O
Kp_mu	struct
)	O
;	O
}	O
else	O
{	O
stat_Kmu	O
=	O
gsl_sf_bessel_K_scaled_steed_temme_CF2	O
(	O
mu	pointer
,	O
x	int
,	O
&	int
K_mu	struct
,	O
&	O
K_mup1	struct
,	O
&	O
Kp_mu	struct
)	O
;	O
}	O
K_nu	O
=	O
K_mu	O
;	O
K_nup1	O
=	O
K_mup1	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
N	int
;	O
n	O
++	O
)	O
{	O
K_num1	O
=	O
K_nu	O
;	O
K_nu	pointer
=	O
K_nup1	O
;	O
K_nup1	O
=	O
2.0	int
*	O
(	int
mu	O
+	O
n	int
+	O
1	int
)	O
/	O
x	int
*	O
K_nu	O
+	O
K_num1	int
;	O
}	O
stat_Irat	O
=	O
gsl_sf_bessel_I_CF1_ser	O
(	O
nu	pointer
,	O
x	int
,	O
&	pointer
I_nu_ratio	struct
)	O
;	O
result	O
->	O
val	int
=	O
1.0	int
/	O
(	int
x	O
*	O
(	O
K_nup1	O
+	O
I_nu_ratio	int
*	O
K_nu	O
)	O
)	O
;	O
result	O
->	O
err	int
=	O
GSL_DBL_EPSILON	int
*	O
(	O
0.5	O
*	O
N	O
+	O
2.0	int
)	O
*	O
fabs	pointer
(	O
result	pointer
->	O
val	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	int
(	O
stat_Kmu	int
,	O
stat_Irat	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_bessel_Inu_e	function
(	O
double	O
nu	O
,	O
double	O
x	O
,	O
gsl_sf_result	O
*	O
result	pointer
)	O
{	O
gsl_sf_result	O
b	struct
;	O
int	O
stat_I	int
=	O
gsl_sf_bessel_Inu_scaled_e	O
(	O
nu	O
,	O
x	O
,	O
&	O
b	pointer
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	int
(	O
x	O
,	O
fabs	O
(	O
x	pointer
*	O
GSL_DBL_EPSILON	pointer
)	O
,	O
b	O
.	O
val	int
,	O
b	O
.	O
err	int
,	O
result	int
)	O
;	O
return	O
GSL_ERROR_SELECT_2	int
(	O
stat_e	int
,	O
stat_I	int
)	O
;	O
}	O
double	O
gsl_sf_bessel_Inu_scaled	function
(	O
double	O
nu	O
,	O
double	O
x	O
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_bessel_Inu_scaled_e	O
(	O
nu	pointer
,	O
x	O
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_bessel_Inu	function
(	O
double	O
nu	O
,	O
double	O
x	O
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_bessel_Inu_e	O
(	O
nu	pointer
,	O
x	O
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O