static	O
Hash_data	O
white_hash	O
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	O
black_hash	O
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	O
ko_hash	O
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	O
komaster_hash	O
[	O
NUM_KOMASTER_STATES	int
]	O
;	O
static	O
Hash_data	O
kom_pos_hash	O
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	O
goal_hash	O
[	O
BOARDMAX	int
]	O
;	O
static	O
Hashvalue	O
hash_rand	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
Hashvalue	O
h	O
=	O
0	int
;	O
for	int
(	O
i	int
=	O
0	int
;	O
32	int
*	O
i	int
<	O
(	int
int	int
)	O
(	int
CHAR_BIT	O
*	O
sizeof	O
(	O
Hashvalue	O
)	O
)	O
;	O
i	O
++	O
)	O
h	O
|=	O
(	int
Hashvalue	O
)	O
gg_urand	O
(	O
)	O
<<	O
32	int
*	O
i	int
;	O
return	O
h	int
;	O
}	O
void	O
hash_init_zobrist_array	function
(	O
Hash_data	O
*	O
array	pointer
,	O
int	O
size	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_HASHVALUES	int
;	O
j	int
++	O
)	O
array	O
[	O
i	int
]	O
.	O
hashval	int
[	O
j	int
]	O
=	O
hash_rand	int
(	O
)	pointer
;	O
}	O
void	O
hash_init	function
(	O
void	O
)	O
{	O
static	O
int	O
is_initialized	int
=	O
0	O
;	O
if	O
(	O
is_initialized	O
)	O
return	O
;	int
INIT_ZOBRIST_ARRAY	O
(	O
black_hash	O
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
white_hash	O
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
ko_hash	O
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
komaster_hash	O
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
kom_pos_hash	O
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
goal_hash	O
)	O
;	O
is_initialized	O
=	O
1	int
;	O
}	O
void	O
hashdata_recalc	function
(	O
Hash_data	O
*	O
hd	pointer
,	O
Intersection	O
*	O
p	pointer
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
hashdata_clear	O
(	O
hd	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	int
;	O
pos	int
<	O
BOARDMAX	int
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	int
[	O
pos	int
]	O
==	O
WHITE	O
)	O
hashdata_xor	O
(	O
*	pointer
hd	pointer
,	O
white_hash	int
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
p	int
[	O
pos	int
]	O
==	O
BLACK	O
)	O
hashdata_xor	O
(	O
*	pointer
hd	pointer
,	O
black_hash	int
[	O
pos	int
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
0	int
)	O
hashdata_xor	O
(	O
*	int
hd	pointer
,	O
ko_hash	O
[	O
ko_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_clear	function
(	O
Hash_data	O
*	O
hd	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_HASHVALUES	int
;	O
i	int
++	O
)	O
hd	O
->	O
hashval	int
[	O
i	int
]	O
=	O
0	int
;	O
}	int
void	O
hashdata_invert_ko	function
(	O
Hash_data	O
*	O
hd	pointer
,	O
int	O
pos	int
)	O
{	O
hashdata_xor	O
(	O
*	int
hd	pointer
,	O
ko_hash	O
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_stone	function
(	O
Hash_data	O
*	O
hd	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
hashdata_xor	O
(	O
*	int
hd	pointer
,	O
black_hash	O
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
color	int
==	O
WHITE	O
)	O
hashdata_xor	O
(	O
*	pointer
hd	pointer
,	O
white_hash	O
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_komaster	function
(	O
Hash_data	O
*	O
hd	pointer
,	O
int	O
komaster	int
)	O
{	O
hashdata_xor	O
(	O
*	int
hd	pointer
,	O
komaster_hash	O
[	O
komaster	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_kom_pos	function
(	O
Hash_data	O
*	O
hd	pointer
,	O
int	O
kom_pos	int
)	O
{	O
hashdata_xor	O
(	O
*	int
hd	pointer
,	O
kom_pos_hash	O
[	O
kom_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_calc_orientation_invariant	function
(	O
Hash_data	O
*	O
hd	pointer
,	O
Intersection	O
*	O
p	pointer
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
int	O
rot	int
;	O
Hash_data	O
hd_rot	O
;	O
for	O
(	O
rot	int
=	O
0	int
;	O
rot	int
<	O
8	int
;	O
rot	int
++	O
)	O
{	O
hashdata_clear	O
(	O
&	int
hd_rot	struct
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	int
;	O
pos	int
<	O
BOARDMAX	int
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	int
[	O
pos	int
]	O
==	O
WHITE	O
)	O
hashdata_xor	O
(	O
hd_rot	pointer
,	O
white_hash	int
[	O
rotate1	int
(	O
pos	int
,	O
rot	int
)	O
]	O
)	O
;	O
else	O
if	O
(	O
p	int
[	O
pos	int
]	O
==	O
BLACK	O
)	O
hashdata_xor	O
(	O
hd_rot	pointer
,	O
black_hash	int
[	O
rotate1	int
(	O
pos	int
,	O
rot	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
NO_MOVE	int
)	O
hashdata_xor	O
(	O
hd_rot	pointer
,	O
ko_hash	int
[	O
rotate1	int
(	O
ko_pos	int
,	O
rot	int
)	O
]	O
)	O
;	O
if	O
(	O
rot	int
==	O
0	int
||	O
hashdata_is_smaller	int
(	O
hd_rot	int
,	O
*	int
hd	pointer
)	O
)	O
*	O
hd	pointer
=	O
hd_rot	int
;	O
}	O
}	O
Hash_data	O
goal_to_hashvalue	O
(	O
const	O
signed	O
char	O
*	O
goal	pointer
)	O
{	O
int	O
pos	int
;	O
Hash_data	O
return_value	O
;	O
hashdata_clear	O
(	O
&	O
return_value	struct
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	int
;	O
pos	int
<	O
BOARDMAX	int
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	int
(	O
pos	int
)	O
&&	O
goal	O
[	O
pos	int
]	O
)	O
hashdata_xor	O
(	O
return_value	pointer
,	O
goal_hash	int
[	O
pos	int
]	O
)	O
;	O
return	O
return_value	int
;	O
}	O
char	O
*	O
hashdata_to_string	function
(	O
Hash_data	O
*	O
hashdata	pointer
)	O
{	O
static	O
char	O
buffer	O
[	O
BUFFER_SIZE	O
]	O
;	O
int	O
n	int
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
NUM_HASHVALUES	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
n	O
+=	O
sprintf	int
(	O
buffer	pointer
+	O
n	int
,	O
HASHVALUE_PRINT_FORMAT	int
,	O
HASHVALUE_NUM_DIGITS	int
,	O
hashdata	int
->	O
hashval	int
[	O
k	int
]	O
)	O
;	O
gg_assert	O
(	O
n	pointer
<	O
BUFFER_SIZE	int
)	O
;	O
}	O
return	O
buffer	int
;	O
}	O