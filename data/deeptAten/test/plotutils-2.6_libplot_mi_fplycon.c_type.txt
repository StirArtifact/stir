static	O
int	O
GetFPolyYBounds	function
(	O
const	O
SppPoint	O
*	O
pts	pointer
,	O
int	O
n	int
,	O
double	O
yFtrans	O
,	O
int	O
*	int
by	pointer
,	O
int	O
*	int
ty	pointer
)	O
;	O
void	O
miFillSppPoly	function
(	O
miPaintedSet	O
*	O
paintedSet	pointer
,	O
miPixel	O
pixel	O
,	O
int	O
count	int
,	O
const	O
SppPoint	O
*	O
ptsIn	pointer
,	O
int	O
xTrans	int
,	O
int	O
yTrans	int
,	O
double	O
xFtrans	O
,	O
double	O
yFtrans	O
)	O
{	O
double	O
xl	double
=	O
0.0	int
,	O
xr	O
=	O
0.0	int
,	O
ml	O
=	O
0.0	int
,	O
mr	O
=	O
0.0	int
,	O
dy	int
,	O
i	int
;	O
int	O
y	int
,	O
j	int
,	O
imin	int
,	O
ymin	int
,	O
ymax	int
;	O
int	O
left	int
,	O
right	int
,	O
nextleft	int
,	O
nextright	int
;	O
int	int
*	int
Marked	O
;	O
unsigned	O
int	O
*	int
width	O
,	O
*	O
FirstWidth	pointer
;	O
miPoint	O
*	O
ptsOut	pointer
,	O
*	O
FirstPoint	pointer
;	O
imin	O
=	O
GetFPolyYBounds	int
(	O
ptsIn	O
,	O
count	int
,	O
yFtrans	int
,	O
&	int
ymin	pointer
,	O
&	O
ymax	struct
)	O
;	O
y	O
=	O
ymax	int
-	O
ymin	int
+	O
1	int
;	O
if	O
(	O
(	O
count	O
<	O
3	int
)	O
||	O
(	O
y	O
<=	O
0	int
)	O
)	O
return	O
;	int
ptsOut	O
=	O
FirstPoint	O
=	O
(	O
miPoint	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	O
)	O
*	O
y	O
)	O
;	O
width	O
=	O
FirstWidth	int
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
y	O
)	O
;	O
Marked	O
=	O
(	int
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
int	O
)	O
*	O
count	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
count	int
;	O
j	int
++	O
)	O
Marked	O
[	O
j	int
]	O
=	O
0	O
;	O
nextleft	int
=	O
nextright	int
=	O
imin	int
;	O
Marked	int
[	O
imin	int
]	O
=	O
-	int
1	int
;	O
y	O
=	O
ICEIL	int
(	O
ptsIn	int
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
;	O
do	O
{	O
if	O
(	O
(	int
y	O
>	O
(	int
ptsIn	int
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
||	O
ISEQUAL	O
(	O
y	int
,	O
ptsIn	int
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
)	O
&&	O
Marked	O
[	O
nextleft	int
]	O
!=	O
1	O
)	O
{	O
Marked	O
[	O
nextleft	int
]	O
++	O
;	O
left	O
=	O
nextleft	int
++	O
;	O
if	O
(	O
nextleft	int
>=	O
count	int
)	O
nextleft	O
=	O
0	int
;	O
dy	int
=	O
ptsIn	int
[	O
nextleft	int
]	O
.	O
y	int
-	O
ptsIn	int
[	O
left	int
]	O
.	O
y	int
;	O
if	O
(	O
dy	int
!=	O
0.0	int
)	O
{	O
ml	O
=	O
(	int
ptsIn	O
[	O
nextleft	int
]	O
.	O
x	int
-	O
ptsIn	int
[	O
left	int
]	O
.	O
x	int
)	O
/	O
dy	int
;	O
dy	int
=	O
y	int
-	O
(	int
ptsIn	O
[	O
left	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
;	O
xl	O
=	O
(	int
ptsIn	O
[	O
left	int
]	O
.	O
x	int
+	O
xFtrans	int
)	O
+	O
ml	int
*	O
DMAX	int
(	O
dy	int
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
y	O
>	O
ptsIn	int
[	O
nextright	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
||	O
(	O
ISEQUAL	O
(	O
y	int
,	O
ptsIn	int
[	O
nextright	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
&&	O
Marked	O
[	O
nextright	int
]	O
!=	O
1	O
)	O
)	O
{	O
Marked	O
[	O
nextright	int
]	O
++	O
;	O
right	O
=	O
nextright	int
--	O
;	int
if	O
(	O
nextright	int
<	O
0	int
)	O
nextright	int
=	O
count	int
-	O
1	int
;	O
dy	int
=	O
ptsIn	int
[	O
nextright	int
]	O
.	O
y	int
-	O
ptsIn	int
[	O
right	int
]	O
.	O
y	int
;	O
if	O
(	O
dy	int
!=	O
0.0	int
)	O
{	O
mr	O
=	O
(	int
ptsIn	int
[	O
nextright	int
]	O
.	O
x	int
-	O
ptsIn	int
[	O
right	int
]	O
.	O
x	int
)	O
/	O
dy	int
;	O
dy	int
=	O
y	int
-	O
(	int
ptsIn	O
[	O
right	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
;	O
xr	O
=	O
(	int
ptsIn	O
[	O
right	int
]	O
.	O
x	int
+	O
xFtrans	int
)	O
+	O
mr	int
*	O
DMAX	int
(	O
dy	int
,	O
0	int
)	O
;	O
}	O
}	O
i	O
=	O
(	int
DMIN	O
(	O
ptsIn	int
[	O
nextleft	int
]	O
.	O
y	int
,	O
ptsIn	int
[	O
nextright	int
]	O
.	O
y	int
)	O
+	O
yFtrans	int
)	O
-	O
y	int
;	O
if	O
(	O
i	int
<	O
EPSILON	int
)	O
{	O
if	O
(	O
Marked	int
[	O
nextleft	int
]	O
&&	O
Marked	O
[	O
nextright	int
]	O
)	O
{	O
break	O
;	O
}	O
continue	O
;	O
}	O
else	O
{	O
j	O
=	O
(	int
int	O
)	O
i	int
;	O
if	int
(	O
!	int
j	O
)	O
j	O
++	O
;	O
}	O
while	O
(	O
j	int
>	O
0	int
)	O
{	O
int	O
cxl	int
,	O
cxr	int
;	O
ptsOut	O
->	O
y	array
=	O
(	int
y	O
)	O
+	O
yTrans	int
;	O
cxl	int
=	O
ICEIL	int
(	O
xl	int
)	O
;	O
cxr	O
=	O
ICEIL	int
(	O
xr	int
)	O
;	O
if	O
(	O
xl	int
<	O
xr	int
)	O
{	O
*	O
(	pointer
width	O
++	O
)	O
=	O
(	int
unsigned	O
int	O
)	O
(	int
cxr	O
-	O
cxl	int
)	O
;	O
(	O
ptsOut	O
++	O
)	O
->	O
x	struct
=	O
cxl	O
+	O
xTrans	int
;	O
}	int
else	O
{	O
*	O
(	pointer
width	O
++	O
)	O
=	O
(	int
unsigned	O
int	O
)	O
(	int
cxl	O
-	O
cxr	int
)	O
;	O
(	O
ptsOut	O
++	O
)	O
->	O
x	struct
=	O
cxr	O
+	O
xTrans	int
;	O
}	int
y	O
++	O
;	O
xl	O
+=	O
ml	int
;	O
xr	int
+=	O
mr	int
;	O
j	O
--	O
;	O
}	O
}	O
while	O
(	O
y	O
<=	O
ymax	int
)	O
;	O
free	O
(	O
Marked	O
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	int
,	O
pixel	pointer
,	O
ptsOut	int
-	O
FirstPoint	int
,	O
FirstPoint	int
,	O
FirstWidth	int
)	O
}	O
static	O
int	O
GetFPolyYBounds	function
(	O
const	O
SppPoint	O
*	O
pts	pointer
,	O
int	O
n	int
,	O
double	O
yFtrans	O
,	O
int	O
*	int
by	pointer
,	O
int	O
*	int
ty	pointer
)	O
{	O
const	O
SppPoint	O
*	O
ptsStart	pointer
=	O
pts	O
;	O
const	O
SppPoint	O
*	O
ptMin	pointer
;	O
double	O
ymin	O
,	O
ymax	O
;	O
ptMin	O
=	O
pts	pointer
;	O
ymin	O
=	O
ymax	int
=	O
(	int
pts	O
++	O
)	O
->	O
y	struct
;	O
while	O
(	O
--	O
n	O
>	O
0	int
)	O
{	O
if	O
(	O
pts	O
->	O
y	int
<	O
ymin	int
)	O
{	O
ptMin	O
=	O
pts	int
;	O
ymin	O
=	O
pts	int
->	O
y	int
;	O
}	O
if	O
(	O
pts	O
->	O
y	int
>	O
ymax	int
)	O
ymax	O
=	O
pts	int
->	O
y	int
;	O
pts	O
++	O
;	O
}	O
*	O
by	function
=	O
ICEIL	O
(	O
ymin	int
+	O
yFtrans	int
)	O
;	O
*	O
ty	pointer
=	O
ICEIL	int
(	O
ymax	int
+	O
yFtrans	int
-	O
1	int
)	O
;	O
return	O
(	int
ptMin	O
-	O
ptsStart	int
)	O
;	O
}	O