typedef	O
struct	O
NameMap	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
val	array
;	O
}	O
name_map_t	struct
;	O
typedef	O
struct	O
Config	struct
{	O
time_t	long
mtime	long
;	O
GArray	struct
*	O
keymap	pointer
;	O
GArray	struct
*	O
ext_keymap	pointer
;	O
gchar	char
*	O
labels	array
[	O
10	int
]	O
;	O
}	O
config_t	struct
;	O
typedef	O
struct	O
Command	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
config_t	struct
*	O
cfg	pointer
,	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
;	O
}	O
command_t	struct
;	O
static	O
char	O
error_msg	array
[	O
200	int
]	O
=	O
"Nobody see this"	pointer
;	O
static	O
const	O
name_map_t	struct
key_names	array
[	O
]	O
=	O
{	O
{	O
"backspace"	pointer
,	O
KEY_BACKSPACE	int
}	O
,	O
{	O
"end"	pointer
,	O
KEY_END	int
}	O
,	O
{	O
"up"	pointer
,	O
KEY_UP	int
}	O
,	O
{	O
"down"	pointer
,	O
KEY_DOWN	int
}	O
,	O
{	O
"left"	pointer
,	O
KEY_LEFT	int
}	O
,	O
{	O
"right"	pointer
,	O
KEY_RIGHT	int
}	O
,	O
{	O
"home"	pointer
,	O
KEY_HOME	int
}	O
,	O
{	O
"a1"	pointer
,	O
KEY_A1	int
}	O
,	O
{	O
"c1"	pointer
,	O
KEY_C1	int
}	O
,	O
{	O
"npage"	pointer
,	O
KEY_NPAGE	int
}	O
,	O
{	O
"ppage"	pointer
,	O
KEY_PPAGE	int
}	O
,	O
{	O
"ic"	pointer
,	O
KEY_IC	int
}	O
,	O
{	O
"enter"	pointer
,	O
KEY_ENTER	int
}	O
,	O
{	O
"dc"	pointer
,	O
KEY_DC	int
}	O
,	O
{	O
"scancel"	pointer
,	O
KEY_SCANCEL	int
}	O
,	O
{	O
"btab"	pointer
,	O
KEY_BTAB	int
}	O
,	O
{	O
"f11"	pointer
,	O
KEY_F	O
(	O
11	int
)	O
}	O
,	O
{	O
"f12"	pointer
,	O
KEY_F	O
(	O
12	int
)	O
}	O
,	O
{	O
"f13"	pointer
,	O
KEY_F	O
(	O
13	int
)	O
}	O
,	O
{	O
"f14"	pointer
,	O
KEY_F	O
(	O
14	int
)	O
}	O
,	O
{	O
"f15"	pointer
,	O
KEY_F	O
(	O
15	int
)	O
}	O
,	O
{	O
"f16"	pointer
,	O
KEY_F	O
(	O
16	int
)	O
}	O
,	O
{	O
"f17"	pointer
,	O
KEY_F	O
(	O
17	int
)	O
}	O
,	O
{	O
"f18"	pointer
,	O
KEY_F	O
(	O
18	int
)	O
}	O
,	O
{	O
"f19"	pointer
,	O
KEY_F	O
(	O
19	int
)	O
}	O
,	O
{	O
"f20"	pointer
,	O
KEY_F	O
(	O
20	int
)	O
}	O
,	O
{	O
"tab"	pointer
,	O
'\t'	O
}	O
,	O
{	O
"return"	pointer
,	O
'\n'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
const	O
name_map_t	struct
command_names	array
[	O
]	O
=	O
{	O
{	O
"No-Command"	pointer
,	O
CK_Ignore_Key	int
}	O
,	O
{	O
"Ignore-Key"	pointer
,	O
CK_Ignore_Key	int
}	O
,	O
{	O
"BackSpace"	pointer
,	O
CK_BackSpace	int
}	O
,	O
{	O
"Delete"	pointer
,	O
CK_Delete	int
}	O
,	O
{	O
"Enter"	pointer
,	O
CK_Enter	int
}	O
,	O
{	O
"Page-Up"	pointer
,	O
CK_Page_Up	int
}	O
,	O
{	O
"Page-Down"	pointer
,	O
CK_Page_Down	int
}	O
,	O
{	O
"Left"	pointer
,	O
CK_Left	int
}	O
,	O
{	O
"Right"	pointer
,	O
CK_Right	int
}	O
,	O
{	O
"Word-Left"	pointer
,	O
CK_Word_Left	int
}	O
,	O
{	O
"Word-Right"	pointer
,	O
CK_Word_Right	int
}	O
,	O
{	O
"Up"	pointer
,	O
CK_Up	int
}	O
,	O
{	O
"Down"	pointer
,	O
CK_Down	int
}	O
,	O
{	O
"Home"	pointer
,	O
CK_Home	int
}	O
,	O
{	O
"End"	pointer
,	O
CK_End	int
}	O
,	O
{	O
"Tab"	pointer
,	O
CK_Tab	int
}	O
,	O
{	O
"Undo"	pointer
,	O
CK_Undo	int
}	O
,	O
{	O
"Beginning-Of-Text"	pointer
,	O
CK_Beginning_Of_Text	int
}	O
,	O
{	O
"End-Of-Text"	pointer
,	O
CK_End_Of_Text	int
}	O
,	O
{	O
"Scroll-Up"	pointer
,	O
CK_Scroll_Up	int
}	O
,	O
{	O
"Scroll-Down"	pointer
,	O
CK_Scroll_Down	int
}	O
,	O
{	O
"Return"	pointer
,	O
CK_Return	int
}	O
,	O
{	O
"Begin-Page"	pointer
,	O
CK_Begin_Page	int
}	O
,	O
{	O
"End-Page"	pointer
,	O
CK_End_Page	int
}	O
,	O
{	O
"Delete-Word-Left"	pointer
,	O
CK_Delete_Word_Left	int
}	O
,	O
{	O
"Delete-Word-Right"	pointer
,	O
CK_Delete_Word_Right	int
}	O
,	O
{	O
"Paragraph-Up"	pointer
,	O
CK_Paragraph_Up	int
}	O
,	O
{	O
"Paragraph-Down"	pointer
,	O
CK_Paragraph_Down	int
}	O
,	O
{	O
"Save"	pointer
,	O
CK_Save	int
}	O
,	O
{	O
"Load"	pointer
,	O
CK_Load	int
}	O
,	O
{	O
"New"	pointer
,	O
CK_New	int
}	O
,	O
{	O
"Save-as"	pointer
,	O
CK_Save_As	int
}	O
,	O
{	O
"Mark"	pointer
,	O
CK_Mark	int
}	O
,	O
{	O
"Copy"	pointer
,	O
CK_Copy	int
}	O
,	O
{	O
"Move"	pointer
,	O
CK_Move	int
}	O
,	O
{	O
"Remove"	pointer
,	O
CK_Remove	int
}	O
,	O
{	O
"Unmark"	pointer
,	O
CK_Unmark	int
}	O
,	O
{	O
"Save-Block"	pointer
,	O
CK_Save_Block	int
}	O
,	O
{	O
"Column-Mark"	pointer
,	O
CK_Column_Mark	int
}	O
,	O
{	O
"Find"	pointer
,	O
CK_Find	int
}	O
,	O
{	O
"Find-Again"	pointer
,	O
CK_Find_Again	int
}	O
,	O
{	O
"Replace"	pointer
,	O
CK_Replace	int
}	O
,	O
{	O
"Replace-Again"	pointer
,	O
CK_Replace_Again	int
}	O
,	O
{	O
"Complete-Word"	pointer
,	O
CK_Complete_Word	int
}	O
,	O
{	O
"Debug-Start"	pointer
,	O
CK_Debug_Start	int
}	O
,	O
{	O
"Debug-Stop"	pointer
,	O
CK_Debug_Stop	int
}	O
,	O
{	O
"Debug-Toggle-Break"	pointer
,	O
CK_Debug_Toggle_Break	int
}	O
,	O
{	O
"Debug-Clear"	pointer
,	O
CK_Debug_Clear	int
}	O
,	O
{	O
"Debug-Next"	pointer
,	O
CK_Debug_Next	int
}	O
,	O
{	O
"Debug-Step"	pointer
,	O
CK_Debug_Step	int
}	O
,	O
{	O
"Debug-Back-Trace"	pointer
,	O
CK_Debug_Back_Trace	int
}	O
,	O
{	O
"Debug-Continue"	pointer
,	O
CK_Debug_Continue	int
}	O
,	O
{	O
"Debug-Enter-Command"	pointer
,	O
CK_Debug_Enter_Command	int
}	O
,	O
{	O
"Debug-Until-Curser"	pointer
,	O
CK_Debug_Until_Curser	int
}	O
,	O
{	O
"Insert-File"	pointer
,	O
CK_Insert_File	int
}	O
,	O
{	O
"Exit"	pointer
,	O
CK_Exit	int
}	O
,	O
{	O
"Toggle-Insert"	pointer
,	O
CK_Toggle_Insert	int
}	O
,	O
{	O
"Help"	pointer
,	O
CK_Help	int
}	O
,	O
{	O
"Date"	pointer
,	O
CK_Date	int
}	O
,	O
{	O
"Refresh"	pointer
,	O
CK_Refresh	int
}	O
,	O
{	O
"Goto"	pointer
,	O
CK_Goto	int
}	O
,	O
{	O
"Delete-Line"	pointer
,	O
CK_Delete_Line	int
}	O
,	O
{	O
"Delete-To-Line-End"	pointer
,	O
CK_Delete_To_Line_End	int
}	O
,	O
{	O
"Delete-To-Line-Begin"	pointer
,	O
CK_Delete_To_Line_Begin	int
}	O
,	O
{	O
"Man-Page"	pointer
,	O
CK_Man_Page	int
}	O
,	O
{	O
"Sort"	pointer
,	O
CK_Sort	int
}	O
,	O
{	O
"Mail"	pointer
,	O
CK_Mail	int
}	O
,	O
{	O
"Cancel"	pointer
,	O
CK_Cancel	int
}	O
,	O
{	O
"Complete"	pointer
,	O
CK_Complete	int
}	O
,	O
{	O
"Paragraph-Format"	pointer
,	O
CK_Paragraph_Format	int
}	O
,	O
{	O
"Util"	pointer
,	O
CK_Util	int
}	O
,	O
{	O
"Type-Load-Python"	pointer
,	O
CK_Type_Load_Python	int
}	O
,	O
{	O
"Find-File"	pointer
,	O
CK_Find_File	int
}	O
,	O
{	O
"Ctags"	pointer
,	O
CK_Ctags	int
}	O
,	O
{	O
"Match-Bracket"	pointer
,	O
CK_Match_Bracket	int
}	O
,	O
{	O
"Terminal"	pointer
,	O
CK_Terminal	int
}	O
,	O
{	O
"Terminal-App"	pointer
,	O
CK_Terminal_App	int
}	O
,	O
{	O
"ExtCmd"	pointer
,	O
CK_ExtCmd	int
}	O
,	O
{	O
"User-Menu"	pointer
,	O
CK_User_Menu	int
}	O
,	O
{	O
"Save-Desktop"	pointer
,	O
CK_Save_Desktop	int
}	O
,	O
{	O
"New-Window"	pointer
,	O
CK_New_Window	int
}	O
,	O
{	O
"Cycle"	pointer
,	O
CK_Cycle	int
}	O
,	O
{	O
"Menu"	pointer
,	O
CK_Menu	int
}	O
,	O
{	O
"Save-And-Quit"	pointer
,	O
CK_Save_And_Quit	int
}	O
,	O
{	O
"Run-Another"	pointer
,	O
CK_Run_Another	int
}	O
,	O
{	O
"Check-Save-And-Quit"	pointer
,	O
CK_Check_Save_And_Quit	int
}	O
,	O
{	O
"Maximize"	pointer
,	O
CK_Maximize	int
}	O
,	O
{	O
"Begin-Record-Macro"	pointer
,	O
CK_Begin_Record_Macro	int
}	O
,	O
{	O
"End-Record-Macro"	pointer
,	O
CK_End_Record_Macro	int
}	O
,	O
{	O
"Delete-Macro"	pointer
,	O
CK_Delete_Macro	int
}	O
,	O
{	O
"Toggle-Bookmark"	pointer
,	O
CK_Toggle_Bookmark	int
}	O
,	O
{	O
"Flush-Bookmarks"	pointer
,	O
CK_Flush_Bookmarks	int
}	O
,	O
{	O
"Next-Bookmark"	pointer
,	O
CK_Next_Bookmark	int
}	O
,	O
{	O
"Prev-Bookmark"	pointer
,	O
CK_Prev_Bookmark	int
}	O
,	O
{	O
"Page-Up-Highlight"	pointer
,	O
CK_Page_Up_Highlight	int
}	O
,	O
{	O
"Page-Down-Highlight"	pointer
,	O
CK_Page_Down_Highlight	int
}	O
,	O
{	O
"Left-Highlight"	pointer
,	O
CK_Left_Highlight	int
}	O
,	O
{	O
"Right-Highlight"	pointer
,	O
CK_Right_Highlight	int
}	O
,	O
{	O
"Word-Left-Highlight"	pointer
,	O
CK_Word_Left_Highlight	int
}	O
,	O
{	O
"Word-Right-Highlight"	pointer
,	O
CK_Word_Right_Highlight	int
}	O
,	O
{	O
"Up-Highlight"	pointer
,	O
CK_Up_Highlight	int
}	O
,	O
{	O
"Down-Highlight"	pointer
,	O
CK_Down_Highlight	int
}	O
,	O
{	O
"Home-Highlight"	pointer
,	O
CK_Home_Highlight	int
}	O
,	O
{	O
"End-Highlight"	pointer
,	O
CK_End_Highlight	int
}	O
,	O
{	O
"Beginning-Of-Text-Highlight"	pointer
,	O
CK_Beginning_Of_Text_Highlight	int
}	O
,	O
{	O
"End-Of-Text_Highlight"	pointer
,	O
CK_End_Of_Text_Highlight	int
}	O
,	O
{	O
"Begin-Page-Highlight"	pointer
,	O
CK_Begin_Page_Highlight	int
}	O
,	O
{	O
"End-Page-Highlight"	pointer
,	O
CK_End_Page_Highlight	int
}	O
,	O
{	O
"Scroll-Up-Highlight"	pointer
,	O
CK_Scroll_Up_Highlight	int
}	O
,	O
{	O
"Scroll-Down-Highlight"	pointer
,	O
CK_Scroll_Down_Highlight	int
}	O
,	O
{	O
"Paragraph-Up-Highlight"	pointer
,	O
CK_Paragraph_Up_Highlight	int
}	O
,	O
{	O
"Paragraph-Down-Highlight"	pointer
,	O
CK_Paragraph_Down_Highlight	int
}	O
,	O
{	O
"XStore"	pointer
,	O
CK_XStore	int
}	O
,	O
{	O
"XCut"	pointer
,	O
CK_XCut	int
}	O
,	O
{	O
"XPaste"	pointer
,	O
CK_XPaste	int
}	O
,	O
{	O
"Selection-History"	pointer
,	O
CK_Selection_History	int
}	O
,	O
{	O
"Shell"	pointer
,	O
CK_Shell	int
}	O
,	O
{	O
"Select-Codepage"	pointer
,	O
CK_Select_Codepage	int
}	O
,	O
{	O
"Insert-Literal"	pointer
,	O
CK_Insert_Literal	int
}	O
,	O
{	O
"Execute-Macro"	pointer
,	O
CK_Execute_Macro	int
}	O
,	O
{	O
"Begin-or-End-Macro"	pointer
,	O
CK_Begin_End_Macro	int
}	O
,	O
{	O
"Ext-mode"	pointer
,	O
CK_Ext_Mode	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
cfg_free_maps	function
(	O
config_t	struct
*	O
cfg	pointer
)	O
{	O
int	O
i	array
;	O
if	O
(	O
cfg	pointer
->	O
keymap	pointer
)	O
g_array_free	function
(	O
cfg	pointer
->	O
keymap	pointer
,	O
TRUE	O
)	O
;	O
cfg	pointer
->	O
keymap	pointer
=	O
NULL	O
;	O
if	O
(	O
cfg	pointer
->	O
ext_keymap	pointer
)	O
g_array_free	function
(	O
cfg	pointer
->	O
ext_keymap	pointer
,	O
TRUE	O
)	O
;	O
cfg	pointer
->	O
ext_keymap	pointer
=	O
NULL	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
10	int
;	O
i	array
++	O
)	O
g_free	function
(	O
cfg	pointer
->	O
labels	array
[	O
i	array
]	O
)	O
;	O
}	O
static	O
GPtrArray	struct
*	O
split_line	function
(	O
char	O
*	O
str	pointer
)	O
{	O
gboolean	int
inside_quote	int
=	O
FALSE	O
;	O
int	O
move	int
=	O
0	int
;	O
GPtrArray	struct
*	O
args	array
;	O
args	array
=	O
g_ptr_array_new	function
(	O
)	O
;	O
while	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
)	O
)	O
str	pointer
++	O
;	O
g_ptr_array_add	function
(	O
args	array
,	O
str	pointer
)	O
;	O
for	O
(	O
;	O
;	O
str	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
str	pointer
)	O
{	O
case	O
'#'	O
:	O
if	O
(	O
inside_quote	int
)	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
case	O
'\0'	O
:	O
if	O
(	O
str	pointer
==	O
g_ptr_array_index	O
(	O
args	array
,	O
args	array
->	O
len	int
-	O
1	int
)	O
)	O
g_ptr_array_remove_index	function
(	O
args	array
,	O
args	array
->	O
len	int
-	O
1	int
)	O
;	O
else	O
*	O
(	O
str	pointer
-	O
move	int
)	O
=	O
'\0'	O
;	O
return	O
args	array
;	O
case	O
'"'	O
:	O
case	O
'\''	O
:	O
inside_quote	int
=	O
!	O
inside_quote	int
;	O
move	int
++	O
;	O
continue	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
if	O
(	O
inside_quote	int
)	O
break	O
;	O
*	O
(	O
str	pointer
++	O
-	O
move	int
)	O
=	O
'\0'	O
;	O
move	int
=	O
0	int
;	O
while	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
)	O
)	O
str	pointer
++	O
;	O
g_ptr_array_add	function
(	O
args	array
,	O
str	pointer
--	O
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
switch	O
(	O
*	O
(	O
++	O
str	pointer
)	O
)	O
{	O
case	O
'n'	O
:	O
*	O
str	pointer
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
str	pointer
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
str	pointer
=	O
'\t'	O
;	O
break	O
;	O
}	O
move	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
move	int
!=	O
0	int
)	O
*	O
(	O
str	pointer
-	O
move	int
)	O
=	O
*	O
str	pointer
;	O
}	O
}	O
static	O
void	O
keymap_add	function
(	O
GArray	struct
*	O
keymap	pointer
,	O
int	O
key	pointer
,	O
int	O
cmd	pointer
)	O
{	O
edit_key_map_type	struct
new_one	struct
,	O
*	O
map	pointer
;	O
guint	int
i	array
;	O
map	pointer
=	O
&	O
(	O
g_array_index	O
(	O
keymap	pointer
,	O
edit_key_map_type	struct
,	O
0	int
)	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
keymap	pointer
->	O
len	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
map	pointer
[	O
i	array
]	O
.	O
key	pointer
==	O
key	pointer
)	O
{	O
map	pointer
[	O
i	array
]	O
.	O
command	pointer
=	O
cmd	pointer
;	O
return	O
;	O
}	O
}	O
new_one	struct
.	O
key	pointer
=	O
key	pointer
;	O
new_one	struct
.	O
command	pointer
=	O
cmd	pointer
;	O
g_array_append_val	O
(	O
keymap	pointer
,	O
new_one	struct
)	O
;	O
}	O
static	O
gboolean	int
cmd_bind	function
(	O
config_t	struct
*	O
cfg	pointer
,	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
char	O
*	O
keyname	pointer
,	O
*	O
command	pointer
;	O
const	O
name_map_t	struct
*	O
key	pointer
=	O
key_names	array
;	O
const	O
name_map_t	struct
*	O
cmd	pointer
=	O
command_names	array
;	O
int	O
mod	int
=	O
0	int
,	O
k	int
=	O
-	O
1	int
,	O
m	int
=	O
0	int
;	O
if	O
(	O
argc	pointer
!=	O
3	int
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"bind: Wrong argument number, bind <key> <command>"	pointer
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
keyname	pointer
=	O
argv	pointer
[	O
1	int
]	O
;	O
command	pointer
=	O
argv	pointer
[	O
2	int
]	O
;	O
while	O
(	O
*	O
keyname	pointer
)	O
{	O
switch	O
(	O
*	O
keyname	pointer
++	O
)	O
{	O
case	O
'C'	O
:	O
m	int
=	O
KEY_M_CTRL	int
;	O
continue	O
;	O
case	O
'M'	O
:	O
case	O
'A'	O
:	O
m	int
=	O
KEY_M_ALT	int
;	O
continue	O
;	O
case	O
'S'	O
:	O
m	int
=	O
KEY_M_SHIFT	int
;	O
continue	O
;	O
case	O
'-'	O
:	O
if	O
(	O
!	O
m	int
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"bind: Bad key value `%s'"	pointer
)	O
,	O
keyname	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
mod	int
|=	O
m	int
;	O
m	int
=	O
0	int
;	O
continue	O
;	O
}	O
keyname	pointer
--	O
;	O
break	O
;	O
}	O
if	O
(	O
keyname	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"bind: Ehh...no key?"	pointer
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
keyname	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
k	int
=	O
keyname	pointer
[	O
0	int
]	O
;	O
}	O
else	O
{	O
while	O
(	O
key	pointer
->	O
name	pointer
&&	O
strcasecmp	function
(	O
key	pointer
->	O
name	pointer
,	O
keyname	pointer
)	O
!=	O
0	int
)	O
key	pointer
++	O
;	O
}	O
if	O
(	O
k	int
<	O
0	int
&&	O
!	O
key	pointer
->	O
name	pointer
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"bind: Unknown key: `%s'"	pointer
)	O
,	O
keyname	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
while	O
(	O
cmd	pointer
->	O
name	pointer
&&	O
strcasecmp	function
(	O
cmd	pointer
->	O
name	pointer
,	O
command	pointer
)	O
!=	O
0	int
)	O
cmd	pointer
++	O
;	O
if	O
(	O
!	O
cmd	pointer
->	O
name	pointer
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"bind: Unknown command: `%s'"	pointer
)	O
,	O
command	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
mod	int
&	O
KEY_M_CTRL	int
)	O
{	O
if	O
(	O
k	int
<	O
256	int
)	O
k	int
=	O
XCTRL	O
(	O
k	int
)	O
;	O
else	O
k	int
|=	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
mod	int
&	O
KEY_M_ALT	int
)	O
k	int
|=	O
KEY_M_ALT	int
;	O
if	O
(	O
mod	int
&	O
KEY_M_SHIFT	int
)	O
k	int
|=	O
KEY_M_SHIFT	int
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
"bind-ext"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
keymap_add	function
(	O
cfg	pointer
->	O
ext_keymap	pointer
,	O
k	int
,	O
cmd	pointer
->	O
val	array
)	O
;	O
else	O
keymap_add	function
(	O
cfg	pointer
->	O
keymap	pointer
,	O
k	int
,	O
cmd	pointer
->	O
val	array
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
gboolean	int
cmd_label	function
(	O
config_t	struct
*	O
cfg	pointer
,	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
const	O
name_map_t	struct
*	O
cmd	pointer
=	O
command_names	array
;	O
const	O
char	O
*	O
command	pointer
,	O
*	O
label	pointer
;	O
int	O
fn	int
;	O
if	O
(	O
argc	pointer
!=	O
4	int
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"%s: Syntax: %s <n> <command> <label>"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
fn	int
=	O
strtol	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
NULL	O
,	O
0	int
)	O
;	O
command	pointer
=	O
argv	pointer
[	O
2	int
]	O
;	O
label	pointer
=	O
argv	pointer
[	O
3	int
]	O
;	O
while	O
(	O
cmd	pointer
->	O
name	pointer
&&	O
strcasecmp	function
(	O
cmd	pointer
->	O
name	pointer
,	O
command	pointer
)	O
!=	O
0	int
)	O
cmd	pointer
++	O
;	O
if	O
(	O
!	O
cmd	pointer
->	O
name	pointer
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"%s: Unknown command: `%s'"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
command	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
fn	int
<	O
1	int
||	O
fn	int
>	O
10	int
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"%s: fn should be 1-10"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
keymap_add	function
(	O
cfg	pointer
->	O
keymap	pointer
,	O
KEY_F	O
(	O
fn	int
)	O
,	O
cmd	pointer
->	O
val	array
)	O
;	O
cfg	pointer
->	O
labels	array
[	O
fn	int
-	O
1	int
]	O
=	O
g_strdup	function
(	O
label	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
gboolean	int
parse_file	function
(	O
config_t	struct
*	O
cfg	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
const	O
command_t	struct
*	O
cmd	pointer
)	O
{	O
char	O
buf	pointer
[	O
200	int
]	O
;	O
int	O
line	int
=	O
0	int
;	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"%s: fopen(): %s"	pointer
)	O
,	O
file	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
)	O
{	O
const	O
command_t	struct
*	O
c	int
=	O
cmd	pointer
;	O
GPtrArray	struct
*	O
args	array
;	O
char	O
*	O
*	O
argv	pointer
;	O
line	int
++	O
;	O
args	array
=	O
split_line	function
(	O
buf	pointer
)	O
;	O
argv	pointer
=	O
(	O
char	O
*	O
*	O
)	O
args	array
->	O
pdata	pointer
;	O
if	O
(	O
args	array
->	O
len	int
==	O
0	int
)	O
{	O
g_ptr_array_free	function
(	O
args	array
,	O
TRUE	O
)	O
;	O
continue	O
;	O
}	O
while	O
(	O
c	int
->	O
name	pointer
!=	O
NULL	O
&&	O
strcasecmp	function
(	O
c	int
->	O
name	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
!=	O
0	int
)	O
c	int
++	O
;	O
if	O
(	O
c	int
->	O
name	pointer
==	O
NULL	O
)	O
{	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"%s:%d: unknown command `%s'"	pointer
)	O
,	O
file	pointer
,	O
line	int
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
g_ptr_array_free	function
(	O
args	array
,	O
TRUE	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
(	O
c	int
->	O
handler	pointer
(	O
cfg	pointer
,	O
args	array
->	O
len	int
,	O
argv	pointer
)	O
)	O
)	O
{	O
char	O
*	O
ss	pointer
=	O
g_strdup	function
(	O
error_msg	array
)	O
;	O
snprintf	function
(	O
error_msg	array
,	O
sizeof	O
(	O
error_msg	array
)	O
,	O
_	O
(	O
"%s:%d: %s"	pointer
)	O
,	O
file	pointer
,	O
line	int
,	O
ss	pointer
)	O
;	O
g_free	function
(	O
ss	pointer
)	O
;	O
g_ptr_array_free	function
(	O
args	array
,	O
TRUE	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
g_ptr_array_free	function
(	O
args	array
,	O
TRUE	O
)	O
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
gboolean	int
load_user_keymap	function
(	O
config_t	struct
*	O
cfg	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
const	O
command_t	struct
cmd	pointer
[	O
]	O
=	O
{	O
{	O
"bind"	pointer
,	O
cmd_bind	function
}	O
,	O
{	O
"bind-ext"	pointer
,	O
cmd_bind	function
}	O
,	O
{	O
"label"	pointer
,	O
cmd_label	function
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
cfg	pointer
->	O
keymap	pointer
=	O
g_array_new	function
(	O
TRUE	O
,	O
FALSE	O
,	O
sizeof	O
(	O
edit_key_map_type	struct
)	O
)	O
;	O
cfg	pointer
->	O
ext_keymap	pointer
=	O
g_array_new	function
(	O
TRUE	O
,	O
FALSE	O
,	O
sizeof	O
(	O
edit_key_map_type	struct
)	O
)	O
;	O
if	O
(	O
!	O
parse_file	function
(	O
cfg	pointer
,	O
file	pointer
,	O
cmd	pointer
)	O
)	O
{	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
gboolean	int
edit_load_user_map	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
static	O
config_t	struct
cfg	pointer
;	O
config_t	struct
new_cfg	struct
;	O
char	O
*	O
file	pointer
;	O
struct	O
stat	struct
s	pointer
;	O
if	O
(	O
edit_key_emulation	int
!=	O
EDIT_KEY_EMULATION_USER	int
)	O
return	O
TRUE	O
;	O
file	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_USERMAP	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
file	pointer
,	O
&	O
s	pointer
)	O
<	O
0	int
)	O
{	O
char	O
*	O
msg	pointer
=	O
g_strdup_printf	function
(	O
_	O
(	O
"%s not found!"	pointer
)	O
,	O
file	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
msg	pointer
)	O
;	O
g_free	function
(	O
msg	pointer
)	O
;	O
g_free	function
(	O
file	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
s	pointer
.	O
st_mtime	O
!=	O
cfg	pointer
.	O
mtime	long
)	O
{	O
memset	function
(	O
&	O
new_cfg	struct
,	O
0	int
,	O
sizeof	O
(	O
new_cfg	struct
)	O
)	O
;	O
new_cfg	struct
.	O
mtime	long
=	O
s	pointer
.	O
st_mtime	O
;	O
if	O
(	O
!	O
load_user_keymap	function
(	O
&	O
new_cfg	struct
,	O
file	pointer
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
error_msg	array
)	O
;	O
cfg_free_maps	function
(	O
&	O
new_cfg	struct
)	O
;	O
g_free	function
(	O
file	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
cfg_free_maps	function
(	O
&	O
cfg	pointer
)	O
;	O
cfg	pointer
=	O
new_cfg	struct
;	O
}	O
}	O
edit	pointer
->	O
user_map	pointer
=	O
(	O
edit_key_map_type	struct
*	O
)	O
cfg	pointer
.	O
keymap	pointer
->	O
data	pointer
;	O
edit	pointer
->	O
ext_map	pointer
=	O
(	O
edit_key_map_type	struct
*	O
)	O
cfg	pointer
.	O
ext_keymap	pointer
->	O
data	pointer
;	O
memcpy	function
(	O
edit	pointer
->	O
labels	array
,	O
cfg	pointer
.	O
labels	array
,	O
sizeof	O
(	O
edit	pointer
->	O
labels	array
)	O
)	O
;	O
g_free	function
(	O
file	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
