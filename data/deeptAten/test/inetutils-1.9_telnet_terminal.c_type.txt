Ring	O
ttyoring	O
,	O
ttyiring	O
;	O
unsigned	O
char	O
ttyobuf	O
[	O
2	O
*	O
BUFSIZ	pointer
]	O
,	O
ttyibuf	O
[	O
BUFSIZ	int
]	O
;	O
int	O
termdata	int
;	O
cc_t	O
termAytChar	O
;	O
void	O
init_terminal	O
(	O
void	O
)	O
{	O
if	O
(	O
ring_init	int
(	O
&	pointer
ttyoring	pointer
,	O
ttyobuf	O
,	O
sizeof	O
ttyobuf	O
)	O
!=	O
1	O
)	O
{	O
exit	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
ring_init	O
(	O
&	pointer
ttyiring	struct
,	O
ttyibuf	O
,	O
sizeof	O
ttyibuf	O
)	O
!=	O
1	O
)	O
{	O
exit	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
autoflush	O
=	O
TerminalAutoFlush	function
(	O
)	pointer
;	O
}	O
int	O
ttyflush	function
(	O
int	O
drop	int
)	O
{	O
register	O
int	O
n	int
,	O
n0	O
,	O
n1	O
;	O
n0	O
=	O
ring_full_count	O
(	O
&	pointer
ttyoring	struct
)	O
;	O
if	O
(	O
(	int
n1	int
=	O
n	int
=	O
ring_full_consecutive	int
(	O
&	pointer
ttyoring	struct
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
drop	int
)	O
{	O
TerminalFlushOutput	O
(	O
)	pointer
;	O
}	O
else	O
{	O
n	O
=	O
TerminalWrite	O
(	O
(	pointer
char	O
*	O
)	O
ttyoring	pointer
.	O
consume	int
,	O
n	O
)	O
;	O
}	O
}	O
if	O
(	O
n	O
>	O
0	int
)	O
{	O
if	O
(	O
termdata	int
&&	O
n	O
)	O
{	O
Dump	O
(	O
'>'	pointer
,	O
ttyoring	pointer
.	O
consume	int
,	O
n	O
)	O
;	O
}	O
if	O
(	O
n1	int
==	O
n	O
&&	O
n0	int
>	O
n	int
)	O
{	O
n1	O
=	O
n0	int
-	O
n	int
;	O
if	O
(	O
!	int
drop	int
)	O
n1	O
=	O
TerminalWrite	int
(	O
(	pointer
char	O
*	O
)	O
ttyoring	pointer
.	O
bottom	int
,	O
n1	O
)	O
;	O
if	O
(	O
n1	int
>	O
0	int
)	O
n	O
+=	O
n1	int
;	O
}	O
ring_consumed	O
(	O
&	O
ttyoring	struct
,	O
n	O
)	O
;	O
}	O
if	O
(	O
n	O
<	O
0	int
)	O
return	O
-	int
1	int
;	O
if	O
(	O
n	O
==	O
n0	O
)	O
{	O
if	O
(	O
n0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
n0	int
-	O
n	O
+	O
1	int
;	O
}	O
int	O
getconnmode	function
(	O
void	O
)	O
{	O
extern	O
int	O
linemode	int
;	O
int	O
mode	int
=	O
0	int
;	O
extern	O
int	O
kludgelinemode	int
;	O
if	O
(	O
In3270	O
)	O
return	O
(	O
MODE_FLOW	int
)	O
;	O
if	O
(	O
my_want_state_is_dont	int
(	O
TELOPT_ECHO	pointer
)	O
)	O
mode	O
|=	O
MODE_ECHO	int
;	O
if	O
(	O
localflow	O
)	O
mode	O
|=	O
MODE_FLOW	int
;	O
if	O
(	O
my_want_state_is_will	int
(	O
TELOPT_BINARY	pointer
)	O
)	O
mode	O
|=	O
MODE_INBIN	int
;	O
if	O
(	O
his_want_state_is_will	int
(	O
TELOPT_BINARY	pointer
)	O
)	O
mode	O
|=	O
MODE_OUTBIN	int
;	O
if	O
(	O
kludgelinemode	int
)	O
{	O
if	O
(	O
my_want_state_is_dont	int
(	O
TELOPT_SGA	pointer
)	O
)	O
{	O
mode	O
|=	O
(	int
MODE_TRAPSIG	O
|	O
MODE_EDIT	O
)	O
;	O
if	O
(	O
dontlecho	int
&&	O
(	O
clocks	O
.	O
echotoggle	int
>	O
clocks	int
.	O
modenegotiated	int
)	O
)	O
{	O
mode	O
&=	O
~	O
MODE_ECHO	int
;	O
}	O
}	O
return	O
(	int
mode	O
)	O
;	O
}	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_LINEMODE	pointer
)	O
)	O
mode	O
|=	O
linemode	int
;	O
return	O
(	int
mode	int
)	O
;	O
}	O
void	O
setconnmode	function
(	O
int	O
force	int
)	O
{	O
register	O
int	O
newmode	int
;	O
newmode	O
=	O
getconnmode	O
(	O
)	O
|	O
(	O
force	O
?	O
MODE_FORCE	int
:	O
0	O
)	O
;	O
TerminalNewMode	O
(	O
newmode	O
)	O
;	O
}	O
void	O
setcommandmode	function
(	O
void	O
)	O
{	O
TerminalNewMode	O
(	O
-	O
1	int
)	O
;	O
}	O