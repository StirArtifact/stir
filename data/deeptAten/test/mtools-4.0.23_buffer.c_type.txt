typedef	O
struct	O
Buffer_t	struct
{	O
Class_t	struct
*	O
Class	pointer
;	O
int	O
refs	int
;	O
Stream_t	struct
*	O
Next	pointer
;	O
Stream_t	struct
*	O
Buffer	pointer
;	O
size_t	long
size	array
;	O
int	O
dirty	int
;	O
size_t	long
sectorSize	int
;	O
size_t	long
cylinderSize	int
;	O
int	O
ever_dirty	int
;	O
size_t	long
dirty_pos	long
;	O
size_t	long
dirty_end	long
;	O
mt_off_t	long
current	long
;	O
size_t	long
cur_size	long
;	O
char	O
*	O
buf	pointer
;	O
}	O
Buffer_t	struct
;	O
static	O
int	O
_buf_flush	function
(	O
Buffer_t	struct
*	O
Buffer	pointer
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
!	O
Buffer	pointer
->	O
Next	pointer
||	O
!	O
Buffer	pointer
->	O
dirty	int
)	O
return	O
0	int
;	O
if	O
(	O
Buffer	pointer
->	O
current	long
<	O
0L	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Should not happen\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret	int
=	O
force_write	function
(	O
Buffer	pointer
->	O
Next	pointer
,	O
Buffer	pointer
->	O
buf	pointer
+	O
Buffer	pointer
->	O
dirty_pos	long
,	O
Buffer	pointer
->	O
current	long
+	O
Buffer	pointer
->	O
dirty_pos	long
,	O
Buffer	pointer
->	O
dirty_end	long
-	O
Buffer	pointer
->	O
dirty_pos	long
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
signed	O
int	O
)	O
(	O
Buffer	pointer
->	O
dirty_end	long
-	O
Buffer	pointer
->	O
dirty_pos	long
)	O
)	O
{	O
if	O
(	O
ret	int
<	O
0	int
)	O
perror	function
(	O
"buffer_flush: write"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"buffer_flush: short write\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
Buffer	pointer
->	O
dirty	int
=	O
0	int
;	O
Buffer	pointer
->	O
dirty_end	long
=	O
0	int
;	O
Buffer	pointer
->	O
dirty_pos	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
invalidate_buffer	function
(	O
Buffer_t	struct
*	O
Buffer	pointer
,	O
mt_off_t	long
start	array
)	O
{	O
if	O
(	O
_buf_flush	function
(	O
Buffer	pointer
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
Buffer	pointer
->	O
current	long
=	O
ROUND_DOWN	O
(	O
start	array
,	O
Buffer	pointer
->	O
sectorSize	int
)	O
;	O
Buffer	pointer
->	O
cur_size	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
typedef	O
enum	O
position_t	enum
{	O
OUTSIDE	int
,	O
APPEND	int
,	O
INSIDE	int
,	O
ERROR	int
}	O
position_t	enum
;	O
static	O
position_t	enum
isInBuffer	function
(	O
Buffer_t	struct
*	O
This	pointer
,	O
mt_off_t	long
start	array
,	O
size_t	long
*	O
len	long
)	O
{	O
if	O
(	O
start	array
>=	O
This	pointer
->	O
current	long
&&	O
start	array
<	O
This	pointer
->	O
current	long
+	O
(	O
mt_off_t	long
)	O
This	pointer
->	O
cur_size	long
)	O
{	O
maximize	O
(	O
*	O
len	long
,	O
This	pointer
->	O
cur_size	long
-	O
OFFSET	O
)	O
;	O
return	O
INSIDE	int
;	O
}	O
else	O
if	O
(	O
start	array
==	O
This	pointer
->	O
current	long
+	O
(	O
mt_off_t	long
)	O
This	pointer
->	O
cur_size	long
&&	O
This	pointer
->	O
cur_size	long
<	O
This	pointer
->	O
size	array
&&	O
*	O
len	long
>=	O
This	pointer
->	O
sectorSize	int
)	O
{	O
maximize	O
(	O
*	O
len	long
,	O
This	pointer
->	O
size	array
-	O
This	pointer
->	O
cur_size	long
)	O
;	O
*	O
len	long
=	O
ROUND_DOWN	O
(	O
*	O
len	long
,	O
This	pointer
->	O
sectorSize	int
)	O
;	O
return	O
APPEND	int
;	O
}	O
else	O
{	O
if	O
(	O
invalidate_buffer	function
(	O
This	pointer
,	O
start	array
)	O
<	O
0	int
)	O
return	O
ERROR	int
;	O
maximize	O
(	O
*	O
len	long
,	O
This	pointer
->	O
cylinderSize	int
-	O
OFFSET	O
)	O
;	O
maximize	O
(	O
*	O
len	long
,	O
This	pointer
->	O
cylinderSize	int
-	O
This	pointer
->	O
current	long
%	O
This	pointer
->	O
cylinderSize	int
)	O
;	O
return	O
OUTSIDE	int
;	O
}	O
}	O
static	O
int	O
buf_read	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
start	array
,	O
size_t	long
len	long
)	O
{	O
size_t	long
length	int
;	O
mt_off_t	long
offset	long
;	O
char	O
*	O
disk_ptr	pointer
;	O
int	O
ret	int
;	O
DeclareThis	O
(	O
Buffer_t	struct
)	O
;	O
if	O
(	O
!	O
len	long
)	O
return	O
0	int
;	O
switch	O
(	O
isInBuffer	function
(	O
This	pointer
,	O
start	array
,	O
&	O
len	long
)	O
)	O
{	O
case	O
OUTSIDE	int
:	O
case	O
APPEND	int
:	O
length	int
=	O
This	pointer
->	O
cylinderSize	int
-	O
(	O
This	pointer
->	O
current	long
+	O
This	pointer
->	O
cur_size	long
)	O
%	O
This	pointer
->	O
cylinderSize	int
;	O
maximize	O
(	O
length	int
,	O
This	pointer
->	O
size	array
-	O
This	pointer
->	O
cur_size	long
)	O
;	O
ret	int
=	O
READS	O
(	O
This	pointer
->	O
Next	pointer
,	O
This	pointer
->	O
buf	pointer
+	O
This	pointer
->	O
cur_size	long
,	O
This	pointer
->	O
current	long
+	O
This	pointer
->	O
cur_size	long
,	O
length	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
This	pointer
->	O
cur_size	long
+=	O
ret	int
;	O
if	O
(	O
This	pointer
->	O
current	long
+	O
(	O
mt_off_t	long
)	O
This	pointer
->	O
cur_size	long
<	O
start	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Short buffer fill\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
INSIDE	int
:	O
break	O
;	O
case	O
ERROR	int
:	O
return	O
-	O
1	int
;	O
}	O
offset	long
=	O
OFFSET	O
;	O
disk_ptr	pointer
=	O
This	pointer
->	O
buf	pointer
+	O
offset	long
;	O
maximize	O
(	O
len	long
,	O
This	pointer
->	O
cur_size	long
-	O
offset	long
)	O
;	O
memcpy	function
(	O
buf	pointer
,	O
disk_ptr	pointer
,	O
len	long
)	O
;	O
return	O
len	long
;	O
}	O
static	O
int	O
buf_write	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
start	array
,	O
size_t	long
len	long
)	O
{	O
char	O
*	O
disk_ptr	pointer
;	O
DeclareThis	O
(	O
Buffer_t	struct
)	O
;	O
size_t	long
offset	long
=	O
0	int
;	O
if	O
(	O
!	O
len	long
)	O
return	O
0	int
;	O
This	pointer
->	O
ever_dirty	int
=	O
1	int
;	O
switch	O
(	O
isInBuffer	function
(	O
This	pointer
,	O
start	array
,	O
&	O
len	long
)	O
)	O
{	O
case	O
OUTSIDE	int
:	O
if	O
(	O
start	array
%	O
This	pointer
->	O
cylinderSize	int
||	O
len	long
<	O
This	pointer
->	O
sectorSize	int
)	O
{	O
size_t	long
readSize	long
;	O
int	O
ret	int
;	O
readSize	long
=	O
This	pointer
->	O
cylinderSize	int
-	O
This	pointer
->	O
current	long
%	O
This	pointer
->	O
cylinderSize	int
;	O
ret	int
=	O
READS	O
(	O
This	pointer
->	O
Next	pointer
,	O
This	pointer
->	O
buf	pointer
,	O
This	pointer
->	O
current	long
,	O
readSize	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
if	O
(	O
ret	int
%	O
This	pointer
->	O
sectorSize	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Weird: read size (%d) not a multiple of sector size (%d)\n"	pointer
,	O
ret	int
,	O
(	O
int	O
)	O
This	pointer
->	O
sectorSize	int
)	O
;	O
ret	int
-=	O
ret	int
%	O
This	pointer
->	O
sectorSize	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Nothing left\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
This	pointer
->	O
cur_size	long
=	O
ret	int
;	O
if	O
(	O
!	O
This	pointer
->	O
cur_size	long
)	O
{	O
memset	function
(	O
This	pointer
->	O
buf	pointer
,	O
0	int
,	O
readSize	long
)	O
;	O
This	pointer
->	O
cur_size	long
=	O
readSize	long
;	O
}	O
offset	long
=	O
OFFSET	O
;	O
break	O
;	O
}	O
case	O
APPEND	int
:	O
len	long
=	O
ROUND_DOWN	O
(	O
len	long
,	O
This	pointer
->	O
sectorSize	int
)	O
;	O
offset	long
=	O
OFFSET	O
;	O
maximize	O
(	O
len	long
,	O
This	pointer
->	O
size	array
-	O
offset	long
)	O
;	O
This	pointer
->	O
cur_size	long
+=	O
len	long
;	O
if	O
(	O
This	pointer
->	O
Next	pointer
->	O
Class	pointer
->	O
pre_allocate	pointer
)	O
PRE_ALLOCATE	O
(	O
This	pointer
->	O
Next	pointer
,	O
This	pointer
->	O
current	long
+	O
This	pointer
->	O
cur_size	long
)	O
;	O
break	O
;	O
case	O
INSIDE	int
:	O
offset	long
=	O
OFFSET	O
;	O
maximize	O
(	O
len	long
,	O
This	pointer
->	O
cur_size	long
-	O
offset	long
)	O
;	O
break	O
;	O
case	O
ERROR	int
:	O
return	O
-	O
1	int
;	O
}	O
disk_ptr	pointer
=	O
This	pointer
->	O
buf	pointer
+	O
offset	long
;	O
if	O
(	O
offset	long
+	O
len	long
>	O
This	pointer
->	O
cur_size	long
)	O
{	O
len	long
-=	O
(	O
offset	long
+	O
len	long
)	O
%	O
This	pointer
->	O
sectorSize	int
;	O
This	pointer
->	O
cur_size	long
=	O
len	long
+	O
offset	long
;	O
}	O
memcpy	function
(	O
disk_ptr	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
This	pointer
->	O
dirty	int
||	O
offset	long
<	O
This	pointer
->	O
dirty_pos	long
)	O
This	pointer
->	O
dirty_pos	long
=	O
ROUND_DOWN	O
(	O
offset	long
,	O
This	pointer
->	O
sectorSize	int
)	O
;	O
if	O
(	O
!	O
This	pointer
->	O
dirty	int
||	O
offset	long
+	O
len	long
>	O
This	pointer
->	O
dirty_end	long
)	O
This	pointer
->	O
dirty_end	long
=	O
ROUND_UP	O
(	O
offset	long
+	O
len	long
,	O
This	pointer
->	O
sectorSize	int
)	O
;	O
if	O
(	O
This	pointer
->	O
dirty_end	long
>	O
This	pointer
->	O
cur_size	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal error, dirty end too big dirty_end=%x cur_size=%x len=%x offset=%d sectorSize=%x\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
This	pointer
->	O
dirty_end	long
,	O
(	O
unsigned	O
int	O
)	O
This	pointer
->	O
cur_size	long
,	O
(	O
unsigned	O
int	O
)	O
len	long
,	O
(	O
int	O
)	O
offset	long
,	O
(	O
int	O
)	O
This	pointer
->	O
sectorSize	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"offset + len + grain - 1 = %x\n"	pointer
,	O
(	O
int	O
)	O
(	O
offset	long
+	O
len	long
+	O
This	pointer
->	O
sectorSize	int
-	O
1	int
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"ROUNDOWN(offset + len + grain - 1) = %x\n"	pointer
,	O
(	O
int	O
)	O
ROUND_DOWN	O
(	O
offset	long
+	O
len	long
+	O
This	pointer
->	O
sectorSize	int
-	O
1	int
,	O
This	pointer
->	O
sectorSize	int
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"This->dirty = %d\n"	pointer
,	O
This	pointer
->	O
dirty	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
This	pointer
->	O
dirty	int
=	O
1	int
;	O
return	O
len	long
;	O
}	O
static	O
int	O
buf_flush	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
int	O
ret	int
;	O
DeclareThis	O
(	O
Buffer_t	struct
)	O
;	O
if	O
(	O
!	O
This	pointer
->	O
ever_dirty	int
)	O
return	O
0	int
;	O
ret	int
=	O
_buf_flush	function
(	O
This	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
This	pointer
->	O
ever_dirty	int
=	O
0	int
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
buf_free	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
Buffer_t	struct
)	O
;	O
if	O
(	O
This	pointer
->	O
buf	pointer
)	O
free	function
(	O
This	pointer
->	O
buf	pointer
)	O
;	O
This	pointer
->	O
buf	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
Class_t	struct
BufferClass	struct
=	O
{	O
buf_read	function
,	O
buf_write	function
,	O
buf_flush	function
,	O
buf_free	function
,	O
0	int
,	O
get_data_pass_through	function
,	O
0	int
,	O
get_dosConvert_pass_through	function
,	O
0	int
,	O
}	O
;	O
Stream_t	struct
*	O
buf_init	function
(	O
Stream_t	struct
*	O
Next	pointer
,	O
int	O
size	array
,	O
int	O
cylinderSize	int
,	O
int	O
sectorSize	int
)	O
{	O
Buffer_t	struct
*	O
Buffer	pointer
;	O
Stream_t	struct
*	O
Stream	pointer
;	O
if	O
(	O
size	array
%	O
cylinderSize	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"size not multiple of cylinder size\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
cylinderSize	int
%	O
sectorSize	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"cylinder size not multiple of sector size\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
Next	pointer
->	O
Buffer	pointer
)	O
{	O
Next	pointer
->	O
refs	int
--	O
;	O
Next	pointer
->	O
Buffer	pointer
->	O
refs	int
++	O
;	O
return	O
Next	pointer
->	O
Buffer	pointer
;	O
}	O
Stream	pointer
=	O
(	O
Stream_t	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
Buffer_t	struct
)	O
)	O
;	O
if	O
(	O
!	O
Stream	pointer
)	O
return	O
0	int
;	O
Buffer	pointer
=	O
(	O
Buffer_t	struct
*	O
)	O
Stream	pointer
;	O
Buffer	pointer
->	O
buf	pointer
=	O
malloc	function
(	O
size	array
)	O
;	O
if	O
(	O
!	O
Buffer	pointer
->	O
buf	pointer
)	O
{	O
Free	O
(	O
Stream	pointer
)	O
;	O
return	O
0	int
;	O
}	O
Buffer	pointer
->	O
size	array
=	O
size	array
;	O
Buffer	pointer
->	O
dirty	int
=	O
0	int
;	O
Buffer	pointer
->	O
cylinderSize	int
=	O
cylinderSize	int
;	O
Buffer	pointer
->	O
sectorSize	int
=	O
sectorSize	int
;	O
Buffer	pointer
->	O
ever_dirty	int
=	O
0	int
;	O
Buffer	pointer
->	O
dirty_pos	long
=	O
0	int
;	O
Buffer	pointer
->	O
dirty_end	long
=	O
0	int
;	O
Buffer	pointer
->	O
current	long
=	O
0L	int
;	O
Buffer	pointer
->	O
cur_size	long
=	O
0	int
;	O
Buffer	pointer
->	O
Next	pointer
=	O
Next	pointer
;	O
Buffer	pointer
->	O
Class	pointer
=	O
&	O
BufferClass	struct
;	O
Buffer	pointer
->	O
refs	int
=	O
1	int
;	O
Buffer	pointer
->	O
Buffer	pointer
=	O
0	int
;	O
Buffer	pointer
->	O
Next	pointer
->	O
Buffer	pointer
=	O
(	O
Stream_t	struct
*	O
)	O
Buffer	pointer
;	O
return	O
Stream	pointer
;	O
}	O
