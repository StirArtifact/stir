static	O
char	O
*	O
keyword	array
[	O
]	O
=	O
{	O
"@version"	pointer
,	O
"@namespace"	pointer
,	O
"@accessors"	pointer
,	O
"class"	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
kw_version	function
(	O
CIF_CLASS	struct
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
int	O
kw_namespace	function
(	O
CIF_CLASS	struct
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
int	O
kw_accessors	function
(	O
CIF_CLASS	struct
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
int	O
kw_class	function
(	O
CIF_CLASS	struct
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
PROCESS_KW_FUNC	pointer
kw_func	array
[	O
]	O
=	O
{	O
kw_version	function
,	O
kw_namespace	function
,	O
kw_accessors	function
,	O
kw_class	function
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
method_flags	array
[	O
]	O
=	O
{	O
"abstract"	pointer
,	O
"virtual"	pointer
,	O
"static"	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
class	int
=	O
0	int
;	O
void	O
*	O
create_object	function
(	O
int	O
size	int
)	O
{	O
void	O
*	O
temp	pointer
;	O
if	O
(	O
(	O
temp	pointer
=	O
malloc	function
(	O
size	int
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot allocate memory for Object\n"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
memset	function
(	O
temp	pointer
,	O
0	int
,	O
size	int
)	O
;	O
return	O
temp	pointer
;	O
}	O
int	O
add_item	function
(	O
void	O
*	O
*	O
*	O
list	pointer
,	O
int	O
*	O
n	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
(	O
*	O
list	pointer
=	O
realloc	function
(	O
*	O
list	pointer
,	O
(	O
*	O
n	pointer
+	O
1	int
)	O
*	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot allocate memory\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
(	O
*	O
list	pointer
)	O
[	O
(	O
*	O
n	pointer
)	O
]	O
=	O
data	pointer
;	O
(	O
*	O
n	pointer
)	O
++	O
;	O
return	O
0	int
;	O
}	O
void	O
xfree	function
(	O
void	O
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
free	function
(	O
p	pointer
)	O
;	O
}	O
int	O
cidf_free_data	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
xfree	function
(	O
the_class	pointer
->	O
name	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
namespace	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_sc	int
;	O
i	int
++	O
)	O
{	O
xfree	function
(	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
ap	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
xfree	function
(	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
type	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
access	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_met	int
;	O
i	int
++	O
)	O
{	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
rtype	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
n_param	int
;	O
j	int
++	O
)	O
{	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
param	pointer
[	O
j	int
]	O
->	O
name	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
param	pointer
[	O
j	int
]	O
->	O
type	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
param	pointer
[	O
j	int
]	O
)	O
;	O
}	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
param	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
)	O
;	O
}	O
xfree	function
(	O
the_class	pointer
->	O
sc	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
prop	pointer
)	O
;	O
xfree	function
(	O
the_class	pointer
->	O
met	pointer
)	O
;	O
class	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
cidf_dump_class	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
printf	function
(	O
"--------------------------------------------\n"	pointer
)	O
;	O
printf	function
(	O
"Class         : '%s'\n"	pointer
,	O
the_class	pointer
->	O
name	pointer
)	O
;	O
printf	function
(	O
"NameSpace     : '%s'\n"	pointer
,	O
the_class	pointer
->	O
namespace	pointer
)	O
;	O
printf	function
(	O
"Version       : %d.%d\n"	pointer
,	O
the_class	pointer
->	O
major_version	int
,	O
the_class	pointer
->	O
minor_version	int
)	O
;	O
printf	function
(	O
"Super Classes : %d\n"	pointer
,	O
the_class	pointer
->	O
n_sc	int
)	O
;	O
printf	function
(	O
"Properties    : %d\n"	pointer
,	O
the_class	pointer
->	O
n_prop	int
)	O
;	O
printf	function
(	O
"Methods       : %d\n"	pointer
,	O
the_class	pointer
->	O
n_met	int
)	O
;	O
printf	function
(	O
"...........................................................\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_sc	int
;	O
i	int
++	O
)	O
printf	function
(	O
"+ SuperClass %d: '%s' AT '%s' | '%s'\n"	pointer
,	O
i	int
,	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
name	pointer
,	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
ap	pointer
,	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
ap1	pointer
)	O
;	O
printf	function
(	O
"...........................................................\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_prop	int
;	O
i	int
++	O
)	O
printf	function
(	O
"+ Property %d: '%s' '%s' : '%s'\n"	pointer
,	O
i	int
,	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
type	pointer
,	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
name	pointer
,	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
access	pointer
)	O
;	O
printf	function
(	O
"...........................................................\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_met	int
;	O
i	int
++	O
)	O
{	O
printf	function
(	O
"+ Method %d: "	pointer
,	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
flags	array
[	O
j	int
]	O
)	O
printf	function
(	O
" %s "	pointer
,	O
method_flags	array
[	O
j	int
]	O
)	O
;	O
printf	function
(	O
"'%s' '%s' ("	pointer
,	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
rtype	pointer
,	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
n_param	int
;	O
j	int
++	O
)	O
printf	function
(	O
"%s %s |"	pointer
,	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
param	pointer
[	O
j	int
]	O
->	O
type	pointer
,	O
the_class	pointer
->	O
met	pointer
[	O
i	int
]	O
->	O
param	pointer
[	O
j	int
]	O
->	O
name	pointer
)	O
;	O
printf	function
(	O
")\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"--------------------------------------------\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
check_keyword	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
*	O
list	pointer
=	O
keyword	array
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
list	pointer
[	O
i	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strncasecmp	function
(	O
str	pointer
,	O
list	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
list	pointer
[	O
i	int
]	O
)	O
)	O
==	O
0	int
)	O
break	O
;	O
else	O
i	int
++	O
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
check_str	function
(	O
char	O
*	O
*	O
list	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
list	pointer
[	O
i	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strncasecmp	function
(	O
str	pointer
,	O
list	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
str	pointer
)	O
)	O
==	O
0	int
)	O
break	O
;	O
else	O
i	int
++	O
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
skip_spaces	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
aux	pointer
=	O
str	pointer
;	O
while	O
(	O
*	O
aux	pointer
!=	O
0	int
&&	O
isspace	function
(	O
*	O
aux	pointer
)	O
)	O
aux	pointer
++	O
;	O
return	O
aux	pointer
-	O
str	pointer
;	O
}	O
static	O
int	O
trim_str	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
aux	pointer
=	O
str	pointer
;	O
aux	pointer
+=	O
strlen	function
(	O
str	pointer
)	O
-	O
1	int
;	O
while	O
(	O
isspace	function
(	O
*	O
aux	pointer
)	O
&&	O
aux	pointer
>=	O
str	pointer
)	O
aux	pointer
--	O
;	O
*	O
(	O
aux	pointer
+	O
1	int
)	O
=	O
0	int
;	O
return	O
skip_spaces	function
(	O
str	pointer
)	O
;	O
}	O
static	O
int	O
get_id	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
aux	pointer
=	O
str	pointer
;	O
while	O
(	O
!	O
isspace	function
(	O
*	O
aux	pointer
)	O
&&	O
*	O
aux	pointer
!=	O
'('	O
&&	O
*	O
aux	pointer
!=	O
0	int
)	O
aux	pointer
++	O
;	O
return	O
aux	pointer
-	O
str	pointer
;	O
}	O
static	O
int	O
get_id2	function
(	O
char	O
*	O
str	pointer
,	O
char	O
*	O
sep	pointer
)	O
{	O
char	O
*	O
aux	pointer
=	O
str	pointer
;	O
while	O
(	O
!	O
isspace	function
(	O
*	O
aux	pointer
)	O
&&	O
!	O
(	O
strchr	function
(	O
sep	pointer
,	O
*	O
aux	pointer
)	O
)	O
&&	O
*	O
aux	pointer
!=	O
0	int
)	O
aux	pointer
++	O
;	O
return	O
aux	pointer
-	O
str	pointer
;	O
}	O
static	O
int	O
parse_class_header	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
char	O
*	O
temp	pointer
,	O
*	O
aux	pointer
,	O
*	O
aux1	pointer
,	O
*	O
aux2	pointer
,	O
finish	char
,	O
*	O
aux3	pointer
;	O
CIF_SUPERCLASS	struct
*	O
sc	pointer
;	O
temp	pointer
=	O
strdup	function
(	O
pline	pointer
)	O
;	O
aux	pointer
=	O
temp	pointer
;	O
aux	pointer
+=	O
5	int
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
aux1	pointer
=	O
aux	pointer
;	O
aux1	pointer
+=	O
get_id	function
(	O
aux	pointer
)	O
;	O
*	O
aux1	pointer
=	O
0	int
;	O
aux1	pointer
++	O
;	O
the_class	pointer
->	O
name	pointer
=	O
strdup	function
(	O
aux	pointer
)	O
;	O
aux1	pointer
=	O
strchr	function
(	O
aux1	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
aux1	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
aux1	pointer
++	O
;	O
aux1	pointer
+=	O
skip_spaces	function
(	O
aux1	pointer
)	O
;	O
aux	pointer
=	O
aux1	pointer
;	O
finish	char
=	O
0	int
;	O
do	O
{	O
aux1	pointer
+=	O
get_id	function
(	O
aux	pointer
)	O
;	O
if	O
(	O
*	O
aux1	pointer
==	O
0	int
)	O
finish	char
=	O
1	int
;	O
sc	pointer
=	O
create_object	function
(	O
sizeof	O
(	O
CIF_SUPERCLASS	struct
)	O
)	O
;	O
*	O
aux1	pointer
=	O
0	int
;	O
aux1	pointer
++	O
;	O
if	O
(	O
(	O
aux2	pointer
=	O
strchr	function
(	O
aux	pointer
,	O
'@'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
aux2	pointer
=	O
0	int
;	O
aux2	pointer
++	O
;	O
sc	pointer
->	O
name	pointer
=	O
strdup	function
(	O
aux	pointer
)	O
;	O
if	O
(	O
(	O
aux3	pointer
=	O
strchr	function
(	O
aux2	pointer
,	O
'|'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
sc	pointer
->	O
ap	pointer
=	O
strdup	function
(	O
aux2	pointer
)	O
;	O
sc	pointer
->	O
ap1	pointer
=	O
strdup	function
(	O
"INNER"	pointer
)	O
;	O
}	O
else	O
{	O
*	O
aux3	pointer
=	O
0	int
;	O
sc	pointer
->	O
ap	pointer
=	O
strdup	function
(	O
aux2	pointer
)	O
;	O
sc	pointer
->	O
ap1	pointer
=	O
strdup	function
(	O
aux3	pointer
+	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
sc	pointer
->	O
name	pointer
=	O
strdup	function
(	O
aux	pointer
)	O
;	O
sc	pointer
->	O
ap	pointer
=	O
strdup	function
(	O
sc	pointer
->	O
name	pointer
)	O
;	O
sc	pointer
->	O
ap1	pointer
=	O
strdup	function
(	O
the_class	pointer
->	O
name	pointer
)	O
;	O
}	O
add_item	function
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	pointer
->	O
sc	pointer
,	O
&	O
the_class	pointer
->	O
n_sc	int
,	O
sc	pointer
)	O
;	O
aux	pointer
=	O
aux1	pointer
;	O
}	O
while	O
(	O
!	O
finish	char
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_prop	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
char	O
*	O
name	pointer
,	O
*	O
flags	array
,	O
*	O
aux	pointer
,	O
*	O
temp	pointer
;	O
CIF_PROPERTY	struct
*	O
prop	pointer
;	O
temp	pointer
=	O
strdup	function
(	O
pline	pointer
)	O
;	O
aux	pointer
=	O
temp	pointer
;	O
aux	pointer
+=	O
get_id	function
(	O
temp	pointer
)	O
;	O
if	O
(	O
*	O
aux	pointer
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"[%s] Syntax Error in line %d: '%s'\n"	pointer
,	O
__FUNCTION__	O
,	O
line	int
,	O
pline	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
prop	pointer
=	O
create_object	function
(	O
sizeof	O
(	O
CIF_PROPERTY	struct
)	O
)	O
;	O
*	O
aux	pointer
=	O
0	int
;	O
aux	pointer
++	O
;	O
prop	pointer
->	O
type	pointer
=	O
strdup	function
(	O
temp	pointer
)	O
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
name	pointer
=	O
aux	pointer
;	O
aux	pointer
+=	O
get_id2	function
(	O
name	pointer
,	O
":;"	pointer
)	O
;	O
if	O
(	O
*	O
aux	pointer
==	O
0	int
)	O
{	O
if	O
(	O
aux	pointer
==	O
name	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Property Name not found in line %d\n"	pointer
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
aux	pointer
=	O
0	int
;	O
aux	pointer
++	O
;	O
}	O
prop	pointer
->	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
(	O
aux	pointer
=	O
strchr	function
(	O
aux	pointer
,	O
':'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
prop	pointer
->	O
access	pointer
=	O
strdup	function
(	O
"RW"	pointer
)	O
;	O
}	O
else	O
{	O
flags	array
=	O
aux	pointer
+	O
1	int
;	O
flags	array
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
if	O
(	O
(	O
aux	pointer
=	O
strchr	function
(	O
flags	array
,	O
';'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"[%s] Syntax error in line %d. Missing ';': '%s'\n"	pointer
,	O
__FUNCTION__	O
,	O
line	int
,	O
pline	pointer
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
aux	pointer
=	O
0	int
;	O
prop	pointer
->	O
access	pointer
=	O
strdup	function
(	O
flags	array
)	O
;	O
}	O
add_item	function
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	pointer
->	O
prop	pointer
,	O
&	O
the_class	pointer
->	O
n_prop	int
,	O
prop	pointer
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_met	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
,	O
int	O
params	int
)	O
{	O
char	O
*	O
aux	pointer
,	O
*	O
aux1	pointer
,	O
*	O
aux2	pointer
,	O
*	O
temp	pointer
,	O
*	O
aux3	pointer
;	O
int	O
pn	int
,	O
indx	int
,	O
fp	int
,	O
process	int
=	O
1	int
;	O
CIF_METHOD	struct
*	O
met	pointer
;	O
CIF_PARAM	struct
*	O
param	pointer
;	O
temp	pointer
=	O
strdup	function
(	O
pline	pointer
)	O
;	O
aux	pointer
=	O
temp	pointer
;	O
aux	pointer
+=	O
get_id	function
(	O
temp	pointer
)	O
;	O
if	O
(	O
*	O
aux	pointer
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"[%s] Syntax Error in line %d: '%s'\n"	pointer
,	O
__FUNCTION__	O
,	O
line	int
,	O
pline	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
aux	pointer
=	O
0	int
;	O
aux	pointer
++	O
;	O
met	pointer
=	O
create_object	function
(	O
sizeof	O
(	O
CIF_METHOD	struct
)	O
)	O
;	O
met	pointer
->	O
n_param	int
=	O
0	int
;	O
met	pointer
->	O
rtype	pointer
=	O
strdup	function
(	O
temp	pointer
)	O
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
aux1	pointer
=	O
aux	pointer
;	O
while	O
(	O
process	int
)	O
{	O
aux	pointer
+=	O
get_id	function
(	O
aux1	pointer
)	O
;	O
*	O
aux	pointer
=	O
0	int
;	O
aux	pointer
++	O
;	O
if	O
(	O
method_flags	array
[	O
(	O
indx	int
=	O
check_str	function
(	O
method_flags	array
,	O
aux1	pointer
)	O
)	O
]	O
==	O
NULL	O
)	O
{	O
break	O
;	O
}	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
aux1	pointer
=	O
aux	pointer
;	O
met	pointer
->	O
flags	array
[	O
indx	int
]	O
=	O
1	int
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
met	pointer
->	O
name	pointer
=	O
strdup	function
(	O
aux1	pointer
)	O
;	O
process	int
=	O
1	int
;	O
aux2	pointer
=	O
aux1	pointer
=	O
aux	pointer
=	O
pline	pointer
+	O
params	int
+	O
1	int
;	O
aux2	pointer
=	O
strchr	function
(	O
aux	pointer
,	O
')'	O
)	O
;	O
if	O
(	O
aux2	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Missing Parenthesys in line %d\n"	pointer
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
*	O
aux2	pointer
=	O
0	int
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
if	O
(	O
*	O
aux	pointer
==	O
0	int
)	O
{	O
add_item	function
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	pointer
->	O
met	pointer
,	O
&	O
the_class	pointer
->	O
n_met	int
,	O
met	pointer
)	O
;	O
return	O
0	int
;	O
}	O
pn	int
=	O
1	int
;	O
fp	int
=	O
0	int
;	O
while	O
(	O
process	int
)	O
{	O
if	O
(	O
(	O
aux3	pointer
=	O
strchr	function
(	O
aux	pointer
,	O
','	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
aux3	pointer
=	O
0	int
;	O
else	O
fp	int
=	O
1	int
;	O
aux2	pointer
=	O
aux3	pointer
;	O
aux1	pointer
+=	O
get_id	function
(	O
aux	pointer
)	O
;	O
if	O
(	O
*	O
aux1	pointer
==	O
0	int
&&	O
aux1	pointer
!=	O
aux2	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Missing name for parameter %d\n"	pointer
,	O
pn	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
*	O
aux1	pointer
=	O
0	int
;	O
aux1	pointer
++	O
;	O
}	O
param	pointer
=	O
create_object	function
(	O
sizeof	O
(	O
CIF_PARAM	struct
)	O
)	O
;	O
param	pointer
->	O
type	pointer
=	O
strdup	function
(	O
aux	pointer
)	O
;	O
aux1	pointer
+=	O
skip_spaces	function
(	O
aux1	pointer
)	O
;	O
aux2	pointer
+=	O
get_id	function
(	O
aux1	pointer
)	O
;	O
aux2	pointer
++	O
;	O
param	pointer
->	O
name	pointer
=	O
strdup	function
(	O
aux1	pointer
)	O
;	O
add_item	function
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
met	pointer
->	O
param	pointer
,	O
&	O
met	pointer
->	O
n_param	int
,	O
param	pointer
)	O
;	O
if	O
(	O
!	O
fp	int
)	O
{	O
aux	pointer
=	O
aux3	pointer
+	O
1	int
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
}	O
else	O
break	O
;	O
aux1	pointer
=	O
aux	pointer
;	O
pn	int
++	O
;	O
}	O
add_item	function
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	pointer
->	O
met	pointer
,	O
&	O
the_class	pointer
->	O
n_met	int
,	O
met	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_class_line	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
char	O
*	O
params	int
;	O
if	O
(	O
pline	pointer
[	O
0	int
]	O
==	O
'{'	O
||	O
pline	pointer
[	O
0	int
]	O
==	O
'}'	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
params	int
=	O
strchr	function
(	O
pline	pointer
,	O
'('	O
)	O
)	O
==	O
NULL	O
)	O
return	O
parse_prop	function
(	O
the_class	pointer
,	O
line	int
,	O
pline	pointer
)	O
;	O
else	O
return	O
parse_met	function
(	O
the_class	pointer
,	O
line	int
,	O
pline	pointer
,	O
params	int
-	O
pline	pointer
)	O
;	O
}	O
static	O
int	O
kw_version	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
char	O
*	O
aux	pointer
=	O
pline	pointer
;	O
if	O
(	O
(	O
aux	pointer
=	O
strchr	function
(	O
aux	pointer
,	O
':'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Syntax error in line %d. No namespace specified\n"	pointer
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
aux	pointer
++	O
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
sscanf	function
(	O
aux	pointer
,	O
"%d.%d"	pointer
,	O
&	O
the_class	pointer
->	O
major_version	int
,	O
&	O
the_class	pointer
->	O
minor_version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
kw_namespace	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
char	O
*	O
aux	pointer
=	O
pline	pointer
;	O
if	O
(	O
(	O
aux	pointer
=	O
strchr	function
(	O
aux	pointer
,	O
':'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Syntax error in line %d. No namespace specified\n"	pointer
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
aux	pointer
++	O
;	O
aux	pointer
+=	O
skip_spaces	function
(	O
aux	pointer
)	O
;	O
the_class	pointer
->	O
namespace	pointer
=	O
strdup	function
(	O
aux	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
kw_accessors	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
kw_class	function
(	O
CIF_CLASS	struct
*	O
the_class	pointer
,	O
int	O
line	int
,	O
char	O
*	O
pline	pointer
)	O
{	O
printf	function
(	O
"[%s] Unreacheable code\n"	pointer
,	O
__FUNCTION__	O
)	O
;	O
return	O
0	int
;	O
}	O
CIF_CLASS	struct
*	O
cidf_parse	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
line	int
,	O
kw	int
;	O
FILE	struct
*	O
f	pointer
;	O
char	O
buffer	array
[	O
1024	int
]	O
,	O
*	O
aux	pointer
,	O
*	O
pline	pointer
;	O
CIF_CLASS	struct
*	O
the_class	pointer
;	O
if	O
(	O
(	O
f	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot open file '%s'\n"	pointer
,	O
filename	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
the_class	pointer
=	O
create_object	function
(	O
sizeof	O
(	O
CIF_CLASS	struct
)	O
)	O
;	O
the_class	pointer
->	O
n_sc	int
=	O
the_class	pointer
->	O
n_prop	int
=	O
the_class	pointer
->	O
n_met	int
=	O
0	int
;	O
line	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	function
(	O
f	pointer
)	O
)	O
{	O
line	int
++	O
;	O
memset	function
(	O
buffer	array
,	O
0	int
,	O
1024	int
)	O
;	O
fgets	function
(	O
buffer	array
,	O
1024	int
,	O
f	pointer
)	O
;	O
aux	pointer
=	O
strchr	function
(	O
buffer	array
,	O
'\n'	O
)	O
;	O
if	O
(	O
aux	pointer
!=	O
NULL	O
)	O
*	O
aux	pointer
=	O
0	int
;	O
if	O
(	O
(	O
aux	pointer
=	O
strstr	function
(	O
buffer	array
,	O
"//"	pointer
)	O
)	O
!=	O
NULL	O
)	O
*	O
aux	pointer
=	O
0	int
;	O
pline	pointer
=	O
buffer	array
;	O
pline	pointer
+=	O
trim_str	function
(	O
pline	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
pline	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
kw	int
=	O
check_keyword	function
(	O
pline	pointer
)	O
;	O
if	O
(	O
keyword	array
[	O
kw	int
]	O
!=	O
NULL	O
&&	O
kw	int
!=	O
3	int
)	O
{	O
kw_func	array
[	O
kw	int
]	O
(	O
the_class	pointer
,	O
line	int
,	O
pline	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
keyword	array
[	O
kw	int
]	O
==	O
NULL	O
&&	O
class	int
==	O
0	int
)	O
{	O
printf	function
(	O
"ERROR: Syntax error in line %d: '%s'\n"	pointer
,	O
line	int
,	O
pline	pointer
)	O
;	O
cidf_free_data	function
(	O
the_class	pointer
)	O
;	O
class	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
class	int
)	O
if	O
(	O
parse_class_line	function
(	O
the_class	pointer
,	O
line	int
,	O
pline	pointer
)	O
<	O
0	int
)	O
{	O
cidf_free_data	function
(	O
the_class	pointer
)	O
;	O
class	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
kw	int
==	O
3	int
)	O
{	O
if	O
(	O
class	int
==	O
0	int
)	O
{	O
class	int
=	O
1	int
;	O
if	O
(	O
(	O
parse_class_header	function
(	O
the_class	pointer
,	O
line	int
,	O
pline	pointer
)	O
)	O
<	O
0	int
)	O
{	O
cidf_free_data	function
(	O
the_class	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
printf	function
(	O
"ERROR: Cannot declare inner classes in line %d\n"	pointer
,	O
line	int
)	O
;	O
cidf_free_data	function
(	O
the_class	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
class	int
=	O
0	int
;	O
return	O
the_class	pointer
;	O
}	O
