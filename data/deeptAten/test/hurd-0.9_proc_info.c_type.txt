int	O
check_owner	function
(	O
struct	O
proc	pointer
*	O
proc1	pointer
,	O
struct	O
proc	pointer
*	O
proc2	pointer
)	O
{	O
return	O
proc2	pointer
->	O
p_noowner	O
?	O
check_uid	function
(	O
proc1	pointer
,	O
0	int
)	O
||	O
proc1	pointer
->	O
p_login	O
==	O
proc2	pointer
->	O
p_login	O
:	O
check_uid	function
(	O
proc1	pointer
,	O
proc2	pointer
->	O
p_owner	O
)	O
;	O
}	O
kern_return_t	O
S_proc_pid2task	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
task_t	O
*	O
t	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
;	O
if	O
(	O
!	O
callerp	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
p	pointer
=	O
pid_find_allow_zombie	function
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	pointer
->	O
p_dead	O
)	O
{	O
*	O
t	pointer
=	O
MACH_PORT_NULL	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
check_owner	function
(	O
callerp	pointer
,	O
p	pointer
)	O
)	O
return	O
EPERM	O
;	O
assert	function
(	O
MACH_PORT_VALID	function
(	O
p	pointer
->	O
p_task	O
)	O
)	O
;	O
*	O
t	pointer
=	O
p	pointer
->	O
p_task	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_task2pid	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
task_t	O
t	pointer
,	O
pid_t	int
*	O
pid	int
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
=	O
task_find	function
(	O
t	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
*	O
pid	int
=	O
p	pointer
->	O
p_pid	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
t	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_task2proc	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
task_t	O
t	pointer
,	O
mach_port_t	O
*	O
outproc	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
=	O
task_find	function
(	O
t	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
*	O
outproc	pointer
=	O
ports_get_right	function
(	O
p	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
t	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_proc2task	function
(	O
struct	O
proc	pointer
*	O
p	pointer
,	O
task_t	O
*	O
t	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
t	pointer
=	O
p	pointer
->	O
p_task	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_pid2proc	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
mach_port_t	O
*	O
outproc	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
;	O
if	O
(	O
!	O
callerp	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
p	pointer
=	O
pid_find_allow_zombie	function
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	pointer
->	O
p_dead	O
)	O
{	O
*	O
outproc	pointer
=	O
MACH_PORT_NULL	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
check_owner	function
(	O
callerp	pointer
,	O
p	pointer
)	O
)	O
return	O
EPERM	O
;	O
*	O
outproc	pointer
=	O
ports_get_right	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
get_string	function
(	O
task_t	O
t	pointer
,	O
vm_address_t	O
addr	int
,	O
char	O
*	O
*	O
str	pointer
,	O
size_t	long
*	O
len	pointer
)	O
{	O
vm_address_t	O
readaddr	O
;	O
vm_address_t	O
data	O
;	O
size_t	long
readlen	long
;	O
error_t	O
err	O
;	O
char	O
*	O
c	pointer
;	O
readaddr	O
=	O
trunc_page	function
(	O
addr	int
)	O
;	O
err	O
=	O
vm_read	function
(	O
t	pointer
,	O
readaddr	O
,	O
vm_page_size	O
*	O
2	int
,	O
&	O
data	O
,	O
&	O
readlen	long
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_ADDRESS	O
)	O
err	O
=	O
vm_read	function
(	O
t	pointer
,	O
readaddr	O
,	O
vm_page_size	O
,	O
&	O
data	O
,	O
&	O
readlen	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
c	pointer
=	O
memchr	O
(	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
,	O
'\0'	O
,	O
readlen	long
-	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
;	O
if	O
(	O
c	pointer
==	O
NULL	O
)	O
err	O
=	O
KERN_INVALID_ADDRESS	O
;	O
else	O
{	O
c	pointer
++	O
;	O
*	O
len	pointer
=	O
c	pointer
-	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
;	O
*	O
str	pointer
=	O
malloc	O
(	O
*	O
len	pointer
)	O
;	O
if	O
(	O
*	O
str	pointer
==	O
NULL	O
)	O
err	O
=	O
ENOMEM	O
;	O
else	O
memcpy	O
(	O
*	O
str	pointer
,	O
(	O
char	O
*	O
)	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
,	O
*	O
len	pointer
)	O
;	O
}	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
data	O
,	O
readlen	long
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_vector	function
(	O
task_t	O
task	int
,	O
vm_address_t	O
addr	int
,	O
int	O
*	O
*	O
vec	pointer
)	O
{	O
vm_address_t	O
readaddr	O
;	O
vm_size_t	O
readsize	O
;	O
vm_address_t	O
scanned	O
;	O
error_t	O
err	O
;	O
*	O
vec	pointer
=	O
NULL	O
;	O
readaddr	O
=	O
trunc_page	function
(	O
addr	int
)	O
;	O
readsize	O
=	O
0	int
;	O
scanned	O
=	O
addr	int
;	O
do	O
{	O
vm_address_t	O
data	O
;	O
mach_msg_type_number_t	O
readlen	long
=	O
0	int
;	O
vm_address_t	O
*	O
t	pointer
;	O
readsize	O
+=	O
vm_page_size	O
;	O
err	O
=	O
vm_read	function
(	O
task	int
,	O
readaddr	O
,	O
readsize	O
,	O
&	O
data	O
,	O
&	O
readlen	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
for	O
(	O
t	pointer
=	O
(	O
vm_address_t	O
*	O
)	O
(	O
data	O
+	O
(	O
scanned	O
-	O
readaddr	O
)	O
)	O
;	O
t	pointer
<	O
(	O
vm_address_t	O
*	O
)	O
(	O
data	O
+	O
readlen	long
)	O
;	O
++	O
t	pointer
)	O
if	O
(	O
*	O
t	pointer
==	O
0	int
)	O
{	O
++	O
t	pointer
;	O
*	O
vec	pointer
=	O
malloc	O
(	O
(	O
char	O
*	O
)	O
t	pointer
-	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
)	O
;	O
if	O
(	O
*	O
vec	pointer
==	O
NULL	O
)	O
err	O
=	O
ENOMEM	O
;	O
else	O
memcpy	O
(	O
*	O
vec	pointer
,	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
,	O
(	O
char	O
*	O
)	O
t	pointer
-	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
)	O
;	O
break	O
;	O
}	O
scanned	O
=	O
readaddr	O
+	O
readlen	long
;	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
data	O
,	O
readlen	long
)	O
;	O
}	O
while	O
(	O
!	O
err	O
&&	O
*	O
vec	pointer
==	O
NULL	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_string_array	function
(	O
task_t	O
t	pointer
,	O
vm_address_t	O
loc	int
,	O
vm_address_t	O
*	O
buf	pointer
,	O
size_t	long
*	O
buflen	pointer
)	O
{	O
char	O
*	O
bp	pointer
;	O
int	O
*	O
vector	pointer
,	O
*	O
vp	pointer
;	O
error_t	O
err	O
;	O
vm_address_t	O
origbuf	O
=	O
*	O
buf	pointer
;	O
err	O
=	O
get_vector	function
(	O
t	pointer
,	O
loc	int
,	O
&	O
vector	pointer
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
bp	pointer
=	O
(	O
char	O
*	O
)	O
*	O
buf	pointer
;	O
for	O
(	O
vp	pointer
=	O
vector	pointer
;	O
*	O
vp	pointer
;	O
++	O
vp	pointer
)	O
{	O
char	O
*	O
string	pointer
;	O
size_t	long
len	pointer
;	O
err	O
=	O
get_string	function
(	O
t	pointer
,	O
*	O
vp	pointer
,	O
&	O
string	pointer
,	O
&	O
len	pointer
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	function
(	O
vector	pointer
)	O
;	O
if	O
(	O
*	O
buf	pointer
!=	O
origbuf	O
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
*	O
buf	pointer
,	O
*	O
buflen	pointer
)	O
;	O
return	O
err	O
;	O
}	O
if	O
(	O
len	pointer
>	O
(	O
char	O
*	O
)	O
*	O
buf	pointer
+	O
*	O
buflen	pointer
-	O
bp	pointer
)	O
{	O
char	O
*	O
newbuf	pointer
;	O
vm_size_t	O
prev_len	O
=	O
bp	pointer
-	O
(	O
char	O
*	O
)	O
*	O
buf	pointer
;	O
vm_size_t	O
newsize	O
=	O
*	O
buflen	pointer
*	O
2	int
;	O
if	O
(	O
newsize	O
<	O
prev_len	O
+	O
len	pointer
)	O
newsize	O
=	O
round_page	function
(	O
prev_len	O
+	O
len	pointer
)	O
;	O
newbuf	pointer
=	O
mmap	function
(	O
0	int
,	O
newsize	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
newbuf	pointer
==	O
MAP_FAILED	O
)	O
{	O
err	O
=	O
errno	O
;	O
free	function
(	O
string	pointer
)	O
;	O
free	function
(	O
vector	pointer
)	O
;	O
if	O
(	O
*	O
buf	pointer
!=	O
origbuf	O
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
*	O
buf	pointer
,	O
*	O
buflen	pointer
)	O
;	O
return	O
err	O
;	O
}	O
memcpy	O
(	O
newbuf	pointer
,	O
(	O
char	O
*	O
)	O
*	O
buf	pointer
,	O
prev_len	O
)	O
;	O
bp	pointer
=	O
newbuf	pointer
+	O
prev_len	O
;	O
if	O
(	O
*	O
buf	pointer
!=	O
origbuf	O
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
*	O
buf	pointer
,	O
*	O
buflen	pointer
)	O
;	O
*	O
buf	pointer
=	O
(	O
vm_address_t	O
)	O
newbuf	pointer
;	O
*	O
buflen	pointer
=	O
newsize	O
;	O
}	O
memcpy	O
(	O
bp	pointer
,	O
string	pointer
,	O
len	pointer
)	O
;	O
bp	pointer
+=	O
len	pointer
;	O
free	function
(	O
string	pointer
)	O
;	O
}	O
free	function
(	O
vector	pointer
)	O
;	O
*	O
buflen	pointer
=	O
bp	pointer
-	O
(	O
char	O
*	O
)	O
*	O
buf	pointer
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getprocargs	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
char	O
*	O
*	O
buf	pointer
,	O
size_t	long
*	O
buflen	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
return	O
get_string_array	function
(	O
p	pointer
->	O
p_task	O
,	O
p	pointer
->	O
p_argv	O
,	O
(	O
vm_address_t	O
*	O
)	O
buf	pointer
,	O
buflen	pointer
)	O
;	O
}	O
kern_return_t	O
S_proc_getprocenv	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
char	O
*	O
*	O
buf	pointer
,	O
size_t	long
*	O
buflen	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
return	O
get_string_array	function
(	O
p	pointer
->	O
p_task	O
,	O
p	pointer
->	O
p_envp	O
,	O
(	O
vm_address_t	O
*	O
)	O
buf	pointer
,	O
buflen	pointer
)	O
;	O
}	O
kern_return_t	O
S_proc_getprocinfo	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
int	O
*	O
flags	pointer
,	O
int	O
*	O
*	O
piarray	pointer
,	O
size_t	long
*	O
piarraylen	pointer
,	O
char	O
*	O
*	O
waits	pointer
,	O
mach_msg_type_number_t	O
*	O
waits_len	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
struct	O
procinfo	O
*	O
pi	pointer
;	O
size_t	long
nthreads	long
;	O
thread_t	O
*	O
thds	O
;	O
error_t	O
err	O
=	O
0	int
;	O
size_t	long
structsize	long
;	O
int	O
i	int
;	O
int	O
pi_alloced	int
=	O
0	int
,	O
waits_alloced	int
=	O
0	int
;	O
mach_msg_type_number_t	O
waits_used	O
=	O
0	int
;	O
size_t	long
tkcount	long
,	O
thcount	long
;	O
struct	O
proc	pointer
*	O
tp	pointer
;	O
task_t	O
task	int
;	O
mach_port_t	O
msgport	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
task	int
=	O
p	pointer
->	O
p_task	O
;	O
check_msgport_death	function
(	O
p	pointer
)	O
;	O
msgport	O
=	O
p	pointer
->	O
p_msgport	O
;	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREAD_DETAILS	O
)	O
*	O
flags	pointer
|=	O
PI_FETCH_THREADS	O
;	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREADS	O
)	O
{	O
err	O
=	O
task_threads	function
(	O
p	pointer
->	O
p_task	O
,	O
&	O
thds	O
,	O
&	O
nthreads	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
else	O
nthreads	long
=	O
0	int
;	O
structsize	long
=	O
sizeof	O
(	O
struct	O
procinfo	O
)	O
;	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREAD_DETAILS	O
)	O
structsize	long
+=	O
nthreads	long
*	O
sizeof	O
(	O
pi	pointer
->	O
threadinfos	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
structsize	long
/	O
sizeof	O
(	O
int	O
)	O
>	O
*	O
piarraylen	pointer
)	O
{	O
*	O
piarray	pointer
=	O
mmap	function
(	O
0	int
,	O
structsize	long
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
piarray	pointer
==	O
MAP_FAILED	O
)	O
{	O
err	O
=	O
errno	O
;	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREADS	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nthreads	long
;	O
i	int
++	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
thds	O
[	O
i	int
]	O
)	O
;	O
munmap	function
(	O
thds	O
,	O
nthreads	long
*	O
sizeof	O
(	O
thread_t	O
)	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
pi_alloced	int
=	O
1	int
;	O
}	O
*	O
piarraylen	pointer
=	O
structsize	long
/	O
sizeof	O
(	O
int	O
)	O
;	O
pi	pointer
=	O
(	O
struct	O
procinfo	O
*	O
)	O
*	O
piarray	pointer
;	O
pi	pointer
->	O
state	O
=	O
(	O
(	O
p	pointer
->	O
p_stopped	O
?	O
PI_STOPPED	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_exec	O
?	O
PI_EXECED	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_waiting	O
?	O
PI_WAITING	O
:	O
0	int
)	O
|	O
(	O
!	O
p	pointer
->	O
p_pgrp	O
->	O
pg_orphcnt	O
?	O
PI_ORPHAN	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_msgport	O
==	O
MACH_PORT_NULL	O
?	O
PI_NOMSG	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
==	O
p	pointer
->	O
p_pid	O
?	O
PI_SESSLD	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_noowner	O
?	O
PI_NOTOWNED	O
:	O
0	int
)	O
|	O
(	O
!	O
p	pointer
->	O
p_parentset	O
?	O
PI_NOPARENT	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_traced	O
?	O
PI_TRACED	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_msgportwait	O
?	O
PI_GETMSG	O
:	O
0	int
)	O
|	O
(	O
p	pointer
->	O
p_loginleader	O
?	O
PI_LOGINLD	O
:	O
0	int
)	O
)	O
;	O
pi	pointer
->	O
owner	O
=	O
p	pointer
->	O
p_owner	O
;	O
pi	pointer
->	O
ppid	O
=	O
p	pointer
->	O
p_parent	O
->	O
p_pid	O
;	O
pi	pointer
->	O
pgrp	O
=	O
p	pointer
->	O
p_pgrp	O
->	O
pg_pgid	O
;	O
pi	pointer
->	O
session	O
=	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
;	O
for	O
(	O
tp	pointer
=	O
p	pointer
;	O
!	O
tp	pointer
->	O
p_loginleader	O
;	O
tp	pointer
=	O
tp	pointer
->	O
p_parent	O
)	O
assert	function
(	O
tp	pointer
)	O
;	O
pi	pointer
->	O
logincollection	O
=	O
tp	pointer
->	O
p_pid	O
;	O
if	O
(	O
p	pointer
->	O
p_dead	O
||	O
p	pointer
->	O
p_stopped	O
)	O
{	O
pi	pointer
->	O
exitstatus	O
=	O
p	pointer
->	O
p_status	O
;	O
pi	pointer
->	O
sigcode	O
=	O
p	pointer
->	O
p_sigcode	O
;	O
}	O
else	O
pi	pointer
->	O
exitstatus	O
=	O
pi	pointer
->	O
sigcode	O
=	O
0	int
;	O
pi	pointer
->	O
nthreads	long
=	O
nthreads	long
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_TASKINFO	O
)	O
{	O
tkcount	long
=	O
TASK_BASIC_INFO_COUNT	O
;	O
err	O
=	O
task_info	function
(	O
task	int
,	O
TASK_BASIC_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
pi	pointer
->	O
taskinfo	O
,	O
&	O
tkcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
}	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_TASKEVENTS	O
)	O
{	O
tkcount	long
=	O
TASK_EVENTS_INFO_COUNT	O
;	O
err	O
=	O
task_info	function
(	O
task	int
,	O
TASK_EVENTS_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
pi	pointer
->	O
taskevents	O
,	O
&	O
tkcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
{	O
*	O
flags	pointer
&=	O
~	O
PI_FETCH_TASKEVENTS	O
;	O
err	O
=	O
0	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nthreads	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREAD_DETAILS	O
)	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
=	O
0	int
;	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREAD_BASIC	O
)	O
{	O
thcount	long
=	O
THREAD_BASIC_INFO_COUNT	O
;	O
err	O
=	O
thread_info	function
(	O
thds	O
[	O
i	int
]	O
,	O
THREAD_BASIC_INFO	O
,	O
(	O
thread_info_t	O
)	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
,	O
&	O
thcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
=	O
1	int
;	O
err	O
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
err	O
)	O
{	O
*	O
flags	pointer
&=	O
~	O
PI_FETCH_THREAD_BASIC	O
;	O
err	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREAD_SCHED	O
)	O
{	O
thcount	long
=	O
THREAD_SCHED_INFO_COUNT	O
;	O
err	O
=	O
thread_info	function
(	O
thds	O
[	O
i	int
]	O
,	O
THREAD_SCHED_INFO	O
,	O
(	O
thread_info_t	O
)	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_si	O
,	O
&	O
thcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
=	O
1	int
;	O
err	O
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
err	O
)	O
{	O
*	O
flags	pointer
&=	O
~	O
PI_FETCH_THREAD_SCHED	O
;	O
err	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREAD_WAITS	O
)	O
{	O
if	O
(	O
msgport	O
==	O
MACH_PORT_NULL	O
)	O
*	O
flags	pointer
&=	O
~	O
PI_FETCH_THREAD_WAITS	O
;	O
else	O
{	O
string_t	O
desc	O
;	O
size_t	long
desc_len	long
;	O
if	O
(	O
msg_report_wait	function
(	O
msgport	O
,	O
thds	O
[	O
i	int
]	O
,	O
desc	O
,	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
rpc_block	O
)	O
)	O
desc	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
desc_len	long
=	O
strnlen	function
(	O
desc	O
,	O
sizeof	O
desc	O
)	O
;	O
if	O
(	O
waits_used	O
+	O
desc_len	long
+	O
1	int
>	O
*	O
waits_len	pointer
)	O
{	O
char	O
*	O
new_waits	pointer
=	O
0	int
;	O
mach_msg_type_number_t	O
new_len	O
=	O
round_page	function
(	O
waits_used	O
+	O
desc_len	long
+	O
1	int
)	O
;	O
new_waits	pointer
=	O
mmap	function
(	O
0	int
,	O
new_len	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
err	O
=	O
(	O
new_waits	pointer
==	O
MAP_FAILED	O
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
err	O
)	O
*	O
flags	pointer
&=	O
~	O
PI_FETCH_THREAD_WAITS	O
;	O
else	O
{	O
if	O
(	O
waits_used	O
>	O
0	int
)	O
memcpy	O
(	O
new_waits	pointer
,	O
*	O
waits	pointer
,	O
waits_used	O
)	O
;	O
if	O
(	O
*	O
waits_len	pointer
>	O
0	int
&&	O
waits_alloced	int
)	O
munmap	function
(	O
*	O
waits	pointer
,	O
*	O
waits_len	pointer
)	O
;	O
*	O
waits	pointer
=	O
new_waits	pointer
;	O
*	O
waits_len	pointer
=	O
new_len	O
;	O
waits_alloced	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
waits_used	O
+	O
desc_len	long
+	O
1	int
<=	O
*	O
waits_len	pointer
)	O
{	O
memcpy	O
(	O
*	O
waits	pointer
+	O
waits_used	O
,	O
desc	O
,	O
desc_len	long
)	O
;	O
waits_used	O
+=	O
desc_len	long
;	O
(	O
*	O
waits	pointer
)	O
[	O
waits_used	O
++	O
]	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
thds	O
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
*	O
flags	pointer
&	O
PI_FETCH_THREADS	O
)	O
munmap	function
(	O
thds	O
,	O
nthreads	long
*	O
sizeof	O
(	O
thread_t	O
)	O
)	O
;	O
if	O
(	O
err	O
&&	O
pi_alloced	int
)	O
munmap	function
(	O
*	O
piarray	pointer
,	O
structsize	long
)	O
;	O
if	O
(	O
err	O
&&	O
waits_alloced	int
)	O
munmap	function
(	O
*	O
waits	pointer
,	O
*	O
waits_len	pointer
)	O
;	O
else	O
*	O
waits_len	pointer
=	O
waits_used	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	O
)	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_make_login_coll	function
(	O
struct	O
proc	pointer
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
p	pointer
->	O
p_loginleader	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getloginid	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
leader	pointer
)	O
{	O
struct	O
proc	pointer
*	O
proc	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
struct	O
proc	pointer
*	O
p	pointer
;	O
if	O
(	O
!	O
proc	pointer
)	O
return	O
ESRCH	O
;	O
for	O
(	O
p	pointer
=	O
proc	pointer
;	O
!	O
p	pointer
->	O
p_loginleader	O
;	O
p	pointer
=	O
p	pointer
->	O
p_parent	O
)	O
assert	function
(	O
p	pointer
)	O
;	O
*	O
leader	pointer
=	O
p	pointer
->	O
p_pid	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getloginpids	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
id	int
,	O
pid_t	int
*	O
*	O
pids	pointer
,	O
size_t	long
*	O
npids	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
proc	pointer
*	O
l	pointer
=	O
pid_find	function
(	O
id	int
)	O
;	O
struct	O
proc	pointer
*	O
p	pointer
;	O
struct	O
proc	pointer
*	O
*	O
tail	pointer
,	O
*	O
*	O
new	pointer
,	O
*	O
*	O
parray	pointer
;	O
int	O
parraysize	int
;	O
int	O
i	int
;	O
if	O
(	O
!	O
l	pointer
||	O
!	O
l	pointer
->	O
p_loginleader	O
)	O
return	O
ESRCH	O
;	O
parraysize	int
=	O
50	int
;	O
parray	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
proc	pointer
*	O
)	O
*	O
parraysize	int
)	O
;	O
if	O
(	O
!	O
parray	pointer
)	O
return	O
ENOMEM	O
;	O
parray	pointer
[	O
0	int
]	O
=	O
l	pointer
;	O
for	O
(	O
tail	pointer
=	O
parray	pointer
,	O
new	pointer
=	O
&	O
parray	pointer
[	O
1	int
]	O
;	O
tail	pointer
!=	O
new	pointer
;	O
tail	pointer
++	O
)	O
{	O
for	O
(	O
p	pointer
=	O
(	O
*	O
tail	pointer
)	O
->	O
p_ochild	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
p_sib	O
)	O
if	O
(	O
!	O
p	pointer
->	O
p_loginleader	O
)	O
{	O
if	O
(	O
new	pointer
-	O
parray	pointer
>	O
parraysize	int
)	O
{	O
struct	O
proc	pointer
*	O
*	O
newparray	pointer
;	O
newparray	pointer
=	O
realloc	O
(	O
parray	pointer
,	O
(	O
(	O
parraysize	int
*=	O
2	int
)	O
*	O
sizeof	O
(	O
struct	O
proc	pointer
*	O
)	O
)	O
)	O
;	O
if	O
(	O
!	O
newparray	pointer
)	O
{	O
free	function
(	O
parray	pointer
)	O
;	O
return	O
ENOMEM	O
;	O
}	O
tail	pointer
=	O
newparray	pointer
+	O
(	O
tail	pointer
-	O
parray	pointer
)	O
;	O
new	pointer
=	O
newparray	pointer
+	O
(	O
new	pointer
-	O
parray	pointer
)	O
;	O
parray	pointer
=	O
newparray	pointer
;	O
}	O
*	O
new	pointer
++	O
=	O
p	pointer
;	O
}	O
}	O
if	O
(	O
*	O
npids	pointer
<	O
new	pointer
-	O
parray	pointer
)	O
{	O
*	O
pids	pointer
=	O
mmap	function
(	O
0	int
,	O
(	O
new	pointer
-	O
parray	pointer
)	O
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	pointer
==	O
MAP_FAILED	O
)	O
err	O
=	O
errno	O
;	O
}	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
npids	pointer
=	O
new	pointer
-	O
parray	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
npids	pointer
;	O
i	int
++	O
)	O
(	O
*	O
pids	pointer
)	O
[	O
i	int
]	O
=	O
parray	pointer
[	O
i	int
]	O
->	O
p_pid	O
;	O
}	O
free	function
(	O
parray	pointer
)	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_setlogin	function
(	O
struct	O
proc	pointer
*	O
p	pointer
,	O
char	O
*	O
login	pointer
)	O
{	O
struct	O
login	pointer
*	O
l	pointer
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
check_uid	function
(	O
p	pointer
,	O
0	int
)	O
)	O
return	O
EPERM	O
;	O
l	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
login	pointer
)	O
+	O
strlen	O
(	O
login	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
l	pointer
)	O
return	O
ENOMEM	O
;	O
l	pointer
->	O
l_refcnt	O
=	O
1	int
;	O
strcpy	O
(	O
l	pointer
->	O
l_name	O
,	O
login	pointer
)	O
;	O
if	O
(	O
!	O
--	O
p	pointer
->	O
p_login	O
->	O
l_refcnt	O
)	O
free	function
(	O
p	pointer
->	O
p_login	O
)	O
;	O
p	pointer
->	O
p_login	O
=	O
l	pointer
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getlogin	function
(	O
struct	O
proc	pointer
*	O
p	pointer
,	O
char	O
*	O
login	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
strcpy	O
(	O
login	pointer
,	O
p	pointer
->	O
p_login	O
->	O
l_name	O
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_get_tty	function
(	O
struct	O
proc	pointer
*	O
p	pointer
,	O
pid_t	int
pid	int
,	O
mach_port_t	O
*	O
tty	pointer
,	O
mach_msg_type_name_t	O
*	O
tty_type	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
kern_return_t	O
S_proc_getnports	function
(	O
struct	O
proc	pointer
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
mach_msg_type_number_t	O
*	O
nports	pointer
)	O
{	O
struct	O
proc	pointer
*	O
p	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
mach_port_array_t	O
names	O
;	O
mach_msg_type_number_t	O
ncount	O
;	O
mach_port_type_array_t	O
types	O
;	O
mach_msg_type_number_t	O
tcount	O
;	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
err	O
=	O
mach_port_names	function
(	O
p	pointer
->	O
p_task	O
,	O
&	O
names	O
,	O
&	O
ncount	O
,	O
&	O
types	O
,	O
&	O
tcount	O
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_TASK	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
nports	pointer
=	O
ncount	O
;	O
munmap	function
(	O
names	O
,	O
ncount	O
*	O
sizeof	O
(	O
mach_port_t	O
)	O
)	O
;	O
munmap	function
(	O
types	O
,	O
tcount	O
*	O
sizeof	O
(	O
mach_port_type_t	O
)	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
