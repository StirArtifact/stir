static	O
void	O
handle_joseki_patterns	function
(	O
struct	O
pattern_attribute	struct
*	O
attributes	pointer
,	O
unsigned	O
int	O
class	int
,	O
int	O
move	pointer
,	O
int	O
my_dragons	array
[	O
MAX_DRAGONS_PER_PATTERN	int
]	O
,	O
int	O
my_ndragons	int
,	O
int	O
your_dragons	array
[	O
MAX_DRAGONS_PER_PATTERN	int
]	O
,	O
int	O
your_ndragons	int
)	O
{	O
struct	O
pattern_attribute	struct
*	O
attribute	pointer
;	O
if	O
(	O
class	int
&	O
CLASS_J	int
)	O
{	O
TRACE	O
(	O
"...joseki standard move\n"	pointer
)	O
;	O
add_expand_territory_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...expands territory\n"	pointer
)	O
;	O
add_expand_moyo_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...expands moyo\n"	pointer
)	O
;	O
set_minimum_move_value	function
(	O
move	pointer
,	O
J_VALUE	int
)	O
;	O
TRACE	O
(	O
"... minimum move value %f\n"	pointer
,	O
J_VALUE	int
)	O
;	O
}	O
if	O
(	O
class	int
&	O
(	O
CLASS_j	int
|	O
CLASS_t	int
)	O
)	O
{	O
float	O
min_value	float
;	O
float	O
shape_value	float
=	O
0.0	int
;	O
if	O
(	O
class	int
&	O
CLASS_j	int
)	O
{	O
min_value	float
=	O
j_VALUE	int
;	O
TRACE	O
(	O
"...less urgent joseki move\n"	pointer
)	O
;	O
add_expand_territory_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...expands territory\n"	pointer
)	O
;	O
add_expand_moyo_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...expands moyo\n"	pointer
)	O
;	O
}	O
else	O
{	O
min_value	float
=	O
t_VALUE	int
;	O
TRACE	O
(	O
"...minor joseki move\n"	pointer
)	O
;	O
}	O
min_value	float
*=	O
board_size	int
/	O
19.0	int
;	O
for	O
(	O
attribute	pointer
=	O
attributes	pointer
;	O
attribute	pointer
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	pointer
++	O
)	O
{	O
if	O
(	O
attribute	pointer
->	O
type	char
==	O
SHAPE	int
)	O
{	O
shape_value	float
=	O
attribute	pointer
->	O
value	pointer
;	O
min_value	float
*=	O
(	O
1	int
+	O
0.01	int
*	O
shape_value	float
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
board_size	int
>=	O
17	int
)	O
&&	O
(	O
class	int
&	O
CLASS_F	int
)	O
)	O
{	O
min_value	float
*=	O
1.005	int
;	O
set_maximum_move_value	function
(	O
move	pointer
,	O
min_value	float
)	O
;	O
scale_randomness	function
(	O
move	pointer
,	O
5.0	int
)	O
;	O
TRACE	O
(	O
"...move value %f (shape %f)\n"	pointer
,	O
min_value	float
,	O
shape_value	float
)	O
;	O
}	O
else	O
TRACE	O
(	O
"...minimum move value %f (shape %f)\n"	pointer
,	O
min_value	float
,	O
shape_value	float
)	O
;	O
set_minimum_move_value	function
(	O
move	pointer
,	O
min_value	float
)	O
;	O
}	O
if	O
(	O
class	int
&	O
CLASS_U	int
)	O
{	O
int	O
k	int
;	O
TRACE	O
(	O
"...joseki urgent move\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
my_ndragons	int
;	O
k	int
++	O
)	O
{	O
add_strategical_defense_move	function
(	O
move	pointer
,	O
my_dragons	array
[	O
k	int
]	O
)	O
;	O
TRACE	O
(	O
"...strategical defense of %1m\n"	pointer
,	O
my_dragons	array
[	O
k	int
]	O
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
your_ndragons	int
;	O
k	int
++	O
)	O
{	O
add_strategical_attack_move	function
(	O
move	pointer
,	O
your_dragons	array
[	O
k	int
]	O
)	O
;	O
TRACE	O
(	O
"...strategical attack on %1m\n"	pointer
,	O
your_dragons	array
[	O
k	int
]	O
)	O
;	O
}	O
add_shape_value	function
(	O
move	pointer
,	O
15	int
)	O
;	O
TRACE	O
(	O
"...shape value 15\n"	pointer
)	O
;	O
set_minimum_move_value	function
(	O
move	pointer
,	O
U_VALUE	int
)	O
;	O
TRACE	O
(	O
"...(min) move value %f\n"	pointer
,	O
U_VALUE	int
)	O
;	O
}	O
if	O
(	O
class	int
&	O
CLASS_T	int
)	O
{	O
TRACE	O
(	O
"...joseki trick move\n"	pointer
)	O
;	O
add_antisuji_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...antisuji\n"	pointer
)	O
;	O
}	O
for	O
(	O
attribute	pointer
=	O
attributes	pointer
;	O
attribute	pointer
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	pointer
++	O
)	O
{	O
switch	O
(	O
attribute	pointer
->	O
type	char
)	O
{	O
case	O
MIN_VALUE	int
:	O
set_minimum_move_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...(min) move value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
case	O
MAX_VALUE	int
:	O
set_maximum_move_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...max move value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
case	O
MIN_TERRITORY	int
:	O
set_minimum_territorial_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...(min) territorial value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
case	O
MAX_TERRITORY	int
:	O
set_maximum_territorial_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...max territorial value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
case	O
SHAPE	int
:	O
if	O
(	O
!	O
(	O
class	int
&	O
(	O
CLASS_j	int
|	O
CLASS_t	int
)	O
)	O
)	O
{	O
add_shape_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...shape value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
}	O
break	O
;	O
case	O
FOLLOWUP	int
:	O
add_followup_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...followup value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
case	O
REVERSE_FOLLOWUP	int
:	O
add_reverse_followup_value	function
(	O
move	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
TRACE	O
(	O
"...reverse followup value %f\n"	pointer
,	O
attribute	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
shapes_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
,	O
l	int
;	O
int	O
move	pointer
;	O
int	O
my_dragons	array
[	O
MAX_DRAGONS_PER_PATTERN	int
]	O
;	O
int	O
my_ndragons	int
=	O
0	int
;	O
int	O
your_dragons	array
[	O
MAX_DRAGONS_PER_PATTERN	int
]	O
;	O
int	O
your_ndragons	int
=	O
0	int
;	O
int	O
my_strings	array
[	O
MAX_STRINGS_PER_PATTERN	int
]	O
;	O
int	O
my_nstrings	int
=	O
0	int
;	O
int	O
your_strings	array
[	O
MAX_STRINGS_PER_PATTERN	int
]	O
;	O
int	O
your_nstrings	int
=	O
0	int
;	O
unsigned	O
int	O
class	int
=	O
pattern	pointer
->	O
class	int
;	O
if	O
(	O
doing_scoring	int
&&	O
(	O
class	int
&	O
CLASS_F	int
)	O
)	O
return	O
;	O
UNUSED	O
(	O
data	pointer
)	O
;	O
move	pointer
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
(	O
class	int
&	O
(	O
CLASS_B	int
|	O
CLASS_C	int
|	O
CLASS_c	int
|	O
CLASS_a	int
|	O
CLASS_d	int
|	O
CLASS_O	int
|	O
CLASS_J	int
|	O
CLASS_j	int
|	O
CLASS_U	int
|	O
CLASS_T	int
|	O
CLASS_t	int
)	O
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
int	O
pos	int
;	O
int	O
origin	int
;	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_dot	int
)	O
continue	O
;	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
(	O
class	int
&	O
CLASS_O	int
)	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
attack_points	array
[	O
0	int
]	O
!=	O
0	int
&&	O
!	O
does_defend	function
(	O
move	pointer
,	O
pos	int
)	O
)	O
return	O
;	O
origin	int
=	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
my_ndragons	int
<	O
MAX_DRAGONS_PER_PATTERN	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
my_ndragons	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
my_dragons	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
}	O
if	O
(	O
l	int
==	O
my_ndragons	int
)	O
{	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
||	O
does_defend	function
(	O
move	pointer
,	O
pos	int
)	O
)	O
{	O
my_dragons	array
[	O
l	int
]	O
=	O
origin	int
;	O
my_ndragons	int
++	O
;	O
}	O
}	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
your_ndragons	int
<	O
MAX_DRAGONS_PER_PATTERN	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
your_ndragons	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
your_dragons	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
}	O
if	O
(	O
l	int
==	O
your_ndragons	int
)	O
{	O
your_dragons	array
[	O
l	int
]	O
=	O
origin	int
;	O
your_ndragons	int
++	O
;	O
}	O
}	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_O	int
||	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_X	int
)	O
{	O
origin	int
=	O
find_origin	function
(	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
my_nstrings	int
<	O
MAX_STRINGS_PER_PATTERN	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
my_nstrings	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
my_strings	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
}	O
if	O
(	O
l	int
==	O
my_nstrings	int
)	O
{	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
||	O
does_defend	function
(	O
move	pointer
,	O
pos	int
)	O
)	O
{	O
my_strings	array
[	O
l	int
]	O
=	O
origin	int
;	O
my_nstrings	int
++	O
;	O
}	O
}	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
your_nstrings	int
<	O
MAX_STRINGS_PER_PATTERN	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
your_nstrings	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
your_strings	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
}	O
if	O
(	O
l	int
==	O
your_nstrings	int
)	O
{	O
your_strings	array
[	O
l	int
]	O
=	O
origin	int
;	O
your_nstrings	int
++	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
my_nstrings	int
<	O
2	int
)	O
class	int
&=	O
~	O
CLASS_C	int
;	O
if	O
(	O
your_nstrings	int
<	O
2	int
)	O
class	int
&=	O
~	O
CLASS_B	int
;	O
if	O
(	O
!	O
pattern	pointer
->	O
helper	pointer
&&	O
!	O
allpats	int
&&	O
!	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_ACTION	int
)	O
&&	O
!	O
(	O
class	int
&	O
CLASS_MOVE_REASONS	O
)	O
&&	O
pattern	pointer
->	O
attributes	pointer
->	O
type	char
==	O
LAST_ATTRIBUTE	int
)	O
return	O
;	O
if	O
(	O
!	O
(	O
class	int
&	O
CLASS_s	int
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
move	pointer
,	O
color	int
)	O
!=	O
WIN	int
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  move at %1m wasn't safe, discarded\n"	pointer
,	O
move	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
is_ko	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
)	O
&&	O
!	O
is_legal	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  move at %1m wasn't legal, discarded\n"	pointer
,	O
move	pointer
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
class	int
&	O
CLASS_n	int
)	O
{	O
if	O
(	O
safe_move	function
(	O
move	pointer
,	O
other	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  opponent can't play safely at %1m, move discarded\n"	pointer
,	O
move	pointer
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
{	O
if	O
(	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
move	pointer
,	O
color	int
,	O
0	int
)	O
)	O
return	O
;	O
}	O
if	O
(	O
pattern	pointer
->	O
helper	pointer
)	O
{	O
int	O
accepted	int
;	O
DEBUG	O
(	O
DEBUG_HELPER	int
,	O
"  asking helper to consider '%s'+%d at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
move	pointer
)	O
;	O
accepted	int
=	O
pattern	pointer
->	O
helper	pointer
(	O
pattern	pointer
,	O
ll	int
,	O
move	pointer
,	O
color	int
)	O
;	O
if	O
(	O
accepted	int
)	O
{	O
DEBUG	O
(	O
DEBUG_HELPER	int
,	O
"helper likes pattern '%s' at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
move	pointer
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_HELPER	int
,	O
"  helper does not like pattern '%s' at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
move	pointer
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
allpats	int
||	O
verbose	int
)	O
{	O
TRACE	O
(	O
"pattern '%s'+%d matched at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
move	pointer
)	O
;	O
}	O
if	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_ACTION	int
)	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
move	pointer
,	O
color	int
,	O
1	int
)	O
;	O
if	O
(	O
class	int
&	O
CLASS_B	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
your_nstrings	int
;	O
k	int
++	O
)	O
for	O
(	O
l	int
=	O
k	int
+	O
1	int
;	O
l	int
<	O
your_nstrings	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
string_connect	function
(	O
your_strings	array
[	O
k	int
]	O
,	O
your_strings	array
[	O
l	int
]	O
,	O
NULL	O
)	O
&&	O
!	O
play_connect_n	function
(	O
color	int
,	O
1	int
,	O
1	int
,	O
move	pointer
,	O
your_strings	array
[	O
k	int
]	O
,	O
your_strings	array
[	O
l	int
]	O
)	O
)	O
{	O
add_cut_move	function
(	O
move	pointer
,	O
your_strings	array
[	O
k	int
]	O
,	O
your_strings	array
[	O
l	int
]	O
)	O
;	O
TRACE	O
(	O
"...cuts strings %1m, %1m\n"	pointer
,	O
your_strings	array
[	O
k	int
]	O
,	O
your_strings	array
[	O
l	int
]	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
class	int
&	O
CLASS_C	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
my_nstrings	int
;	O
k	int
++	O
)	O
for	O
(	O
l	int
=	O
k	int
+	O
1	int
;	O
l	int
<	O
my_nstrings	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
disconnect	function
(	O
my_strings	array
[	O
k	int
]	O
,	O
my_strings	array
[	O
l	int
]	O
,	O
NULL	O
)	O
&&	O
!	O
play_connect_n	function
(	O
color	int
,	O
0	int
,	O
1	int
,	O
move	pointer
,	O
my_strings	array
[	O
k	int
]	O
,	O
my_strings	array
[	O
l	int
]	O
)	O
)	O
{	O
add_connection_move	function
(	O
move	pointer
,	O
my_strings	array
[	O
k	int
]	O
,	O
my_strings	array
[	O
l	int
]	O
)	O
;	O
TRACE	O
(	O
"...connects strings %1m, %1m\n"	pointer
,	O
my_strings	array
[	O
k	int
]	O
,	O
my_strings	array
[	O
l	int
]	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
class	int
&	O
CLASS_c	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
my_ndragons	int
;	O
k	int
++	O
)	O
{	O
add_strategical_defense_move	function
(	O
move	pointer
,	O
my_dragons	array
[	O
k	int
]	O
)	O
;	O
TRACE	O
(	O
"...strategical defense (weak connection) of %1m\n"	pointer
,	O
my_dragons	array
[	O
k	int
]	O
)	O
;	O
}	O
add_shape_value	function
(	O
move	pointer
,	O
1	int
)	O
;	O
TRACE	O
(	O
"...shape value 1\n"	pointer
)	O
;	O
}	O
gg_assert	O
(	O
!	O
(	O
class	int
&	O
CLASS_b	int
)	O
)	O
;	O
if	O
(	O
class	int
&	O
CLASS_e	int
)	O
{	O
add_expand_territory_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...expands territory\n"	pointer
)	O
;	O
}	O
if	O
(	O
class	int
&	O
CLASS_E	int
)	O
{	O
add_expand_moyo_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...expands moyo\n"	pointer
)	O
;	O
}	O
if	O
(	O
class	int
&	O
CLASS_I	int
)	O
{	O
add_invasion_move	function
(	O
move	pointer
)	O
;	O
TRACE	O
(	O
"...is an invasion\n"	pointer
)	O
;	O
}	O
if	O
(	O
class	int
&	O
CLASS_a	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
your_ndragons	int
;	O
k	int
++	O
)	O
{	O
add_strategical_attack_move	function
(	O
move	pointer
,	O
your_dragons	array
[	O
k	int
]	O
)	O
;	O
TRACE	O
(	O
"...strategical attack on %1m\n"	pointer
,	O
your_dragons	array
[	O
k	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
class	int
&	O
CLASS_d	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
my_ndragons	int
;	O
k	int
++	O
)	O
{	O
add_strategical_defense_move	function
(	O
move	pointer
,	O
my_dragons	array
[	O
k	int
]	O
)	O
;	O
TRACE	O
(	O
"...strategical defense of %1m\n"	pointer
,	O
my_dragons	array
[	O
k	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
class	int
&	O
CLASS_W	int
)	O
{	O
TRACE	O
(	O
"...worthwhile threat move\n"	pointer
)	O
;	O
add_worthwhile_threat_move	function
(	O
move	pointer
)	O
;	O
}	O
handle_joseki_patterns	function
(	O
pattern	pointer
->	O
attributes	pointer
,	O
class	int
,	O
move	pointer
,	O
my_dragons	array
,	O
my_ndragons	int
,	O
your_dragons	array
,	O
your_ndragons	int
)	O
;	O
}	O
static	O
void	O
joseki_callback	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
struct	O
corner_pattern	struct
*	O
pattern	pointer
,	O
int	O
trans	int
,	O
int	O
*	O
stones	pointer
,	O
int	O
num_stones	int
)	O
{	O
int	O
k	int
,	O
l	int
;	O
int	O
class	int
=	O
pattern	pointer
->	O
class	int
;	O
int	O
my_dragons	array
[	O
MAX_DRAGONS_PER_PATTERN	int
]	O
;	O
int	O
my_ndragons	int
=	O
0	int
;	O
int	O
your_dragons	array
[	O
MAX_DRAGONS_PER_PATTERN	int
]	O
;	O
int	O
your_ndragons	int
=	O
0	int
;	O
if	O
(	O
class	int
&	O
CLASS_U	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
stones	pointer
[	O
k	int
]	O
;	O
int	O
origin	int
=	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
my_ndragons	int
<	O
MAX_DRAGONS_PER_PATTERN	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
my_ndragons	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
my_dragons	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
}	O
if	O
(	O
l	int
==	O
my_ndragons	int
)	O
{	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
||	O
does_defend	function
(	O
move	pointer
,	O
pos	int
)	O
)	O
{	O
my_dragons	array
[	O
l	int
]	O
=	O
origin	int
;	O
my_ndragons	int
++	O
;	O
}	O
}	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
&&	O
your_ndragons	int
<	O
MAX_DRAGONS_PER_PATTERN	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
your_ndragons	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
your_dragons	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
}	O
if	O
(	O
l	int
==	O
your_ndragons	int
)	O
{	O
your_dragons	array
[	O
l	int
]	O
=	O
origin	int
;	O
your_ndragons	int
++	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
{	O
if	O
(	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
trans	int
,	O
move	pointer
,	O
color	int
,	O
0	int
)	O
)	O
return	O
;	O
}	O
if	O
(	O
allpats	int
||	O
verbose	int
)	O
TRACE	O
(	O
"pattern '%s'+%d matched at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
trans	int
,	O
move	pointer
)	O
;	O
if	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_ACTION	int
)	O
pattern	pointer
->	O
autohelper	pointer
(	O
trans	int
,	O
move	pointer
,	O
color	int
,	O
1	int
)	O
;	O
if	O
(	O
class	int
&	O
CLASS_N	int
)	O
{	O
TRACE	O
(	O
"...antisuji move\n"	pointer
)	O
;	O
add_antisuji_move	function
(	O
move	pointer
)	O
;	O
}	O
handle_joseki_patterns	function
(	O
pattern	pointer
->	O
attributes	pointer
,	O
class	int
,	O
move	pointer
,	O
my_dragons	array
,	O
my_ndragons	int
,	O
your_dragons	array
,	O
your_ndragons	int
)	O
;	O
}	O
void	O
shapes	function
(	O
int	O
color	int
)	O
{	O
TRACE	O
(	O
"\nPattern matcher is looking for move reasons for %s!\n"	pointer
,	O
color_to_string	function
(	O
color	int
)	O
)	O
;	O
matchpat	function
(	O
shapes_callback	function
,	O
color	int
,	O
&	O
pat_db	struct
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
josekidb	int
&&	O
!	O
doing_scoring	int
)	O
corner_matchpat	function
(	O
joseki_callback	function
,	O
color	int
,	O
&	O
joseki_db	struct
)	O
;	O
if	O
(	O
!	O
disable_fuseki	int
&&	O
!	O
doing_scoring	int
)	O
matchpat	function
(	O
shapes_callback	function
,	O
color	int
,	O
&	O
fusekipat_db	struct
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
endgame_shapes	function
(	O
int	O
color	int
)	O
{	O
TRACE	O
(	O
"\nEndgame pattern matcher is looking for move reasons for %s!\n"	pointer
,	O
color_to_string	function
(	O
color	int
)	O
)	O
;	O
matchpat	function
(	O
shapes_callback	function
,	O
color	int
,	O
&	O
endpat_db	struct
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
