static	O
int	O
WriteMessage	function
__P	O
(	O
(	O
int	O
,	O
struct	O
msg	struct
*	O
)	O
)	O
;	O
static	O
sigret_t	void
AttacherSigInt	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
sigret_t	void
AttacherWinch	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
sigret_t	void
DoLock	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
void	O
LockTerminal	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
sigret_t	void
LockHup	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
void	O
screen_builtin_lck	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
sigret_t	void
AttachSigCont	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
extern	O
int	O
real_uid	int
,	O
real_gid	int
,	O
eff_uid	int
,	O
eff_gid	int
;	O
extern	O
int	O
ServerSocket	int
;	O
extern	O
struct	O
display	struct
*	O
displays	pointer
;	O
extern	O
char	O
*	O
SockName	pointer
,	O
*	O
SockMatch	pointer
,	O
SockPath	array
[	O
]	O
;	O
extern	O
char	O
HostName	array
[	O
]	O
;	O
extern	O
struct	O
passwd	struct
*	O
ppp	pointer
;	O
extern	O
char	O
*	O
attach_tty	pointer
,	O
*	O
attach_term	pointer
,	O
*	O
LoginName	pointer
,	O
*	O
preselect	array
;	O
extern	O
bool	bool
attach_tty_is_in_new_ns	bool
;	O
extern	O
char	O
attach_tty_name_in_ns	array
[	O
]	O
;	O
extern	O
int	O
xflag	int
,	O
dflag	int
,	O
rflag	int
,	O
quietflag	int
,	O
adaptflag	int
;	O
extern	O
struct	O
mode	struct
attach_Mode	struct
;	O
extern	O
struct	O
NewWindow	struct
nwin_options	struct
;	O
extern	O
int	O
MasterPid	int
,	O
attach_fd	int
;	O
extern	O
char	O
*	O
multi	pointer
;	O
extern	O
int	O
multiattach	int
,	O
multi_uid	int
,	O
own_uid	int
;	O
extern	O
int	O
tty_mode	int
,	O
tty_oldmode	int
;	O
static	O
int	O
ContinuePlease	int
;	O
static	O
sigret_t	void
AttachSigCont	function
SIGDEFARG	O
{	O
debug	O
(	O
"SigCont()\n"	pointer
)	O
;	O
ContinuePlease	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
static	O
int	O
QueryResult	int
;	O
static	O
sigret_t	void
QueryResultSuccess	function
SIGDEFARG	O
{	O
QueryResult	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
static	O
sigret_t	void
QueryResultFail	function
SIGDEFARG	O
{	O
QueryResult	int
=	O
2	int
;	O
SIGRETURN	O
;	O
}	O
static	O
int	O
WriteMessage	function
(	O
s	int
,	O
m	union
)	O
int	O
s	int
;	O
struct	O
msg	struct
*	O
m	union
;	O
{	O
int	O
r	int
,	O
l	int
=	O
sizeof	O
(	O
*	O
m	union
)	O
;	O
bool	bool
is_socket	bool
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
is_socket	bool
&&	O
m	union
->	O
type	enum
==	O
MSG_ATTACH	int
)	O
return	O
SendAttachMsg	function
(	O
s	int
,	O
m	union
,	O
attach_fd	int
)	O
;	O
while	O
(	O
l	int
>	O
0	int
)	O
{	O
r	int
=	O
write	pointer
(	O
s	int
,	O
(	O
char	O
*	O
)	O
m	union
+	O
(	O
sizeof	O
(	O
*	O
m	union
)	O
-	O
l	int
)	O
,	O
l	int
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
||	O
r	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
l	int
-=	O
r	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
Attach	function
(	O
how	int
)	O
int	O
how	int
;	O
{	O
int	O
n	int
,	O
lasts	int
;	O
struct	O
msg	struct
m	union
;	O
struct	O
stat	struct
st	struct
;	O
char	O
*	O
s	int
;	O
bool	bool
is_socket	bool
;	O
debug2	O
(	O
"Attach: how=%d, tty=%s\n"	pointer
,	O
how	int
,	O
attach_tty	pointer
)	O
;	O
if	O
(	O
(	O
how	int
==	O
MSG_ATTACH	int
||	O
how	int
==	O
MSG_CONT	int
)	O
&&	O
multiattach	int
)	O
{	O
real_uid	int
=	O
multi_uid	int
;	O
eff_uid	int
=	O
own_uid	int
;	O
if	O
(	O
setresuid	function
(	O
multi_uid	int
,	O
own_uid	int
,	O
multi_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setresuid"	pointer
)	O
;	O
if	O
(	O
chmod	function
(	O
attach_tty	pointer
,	O
0666	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"chmod %s"	pointer
,	O
attach_tty	pointer
)	O
;	O
tty_oldmode	int
=	O
tty_mode	int
;	O
}	O
bzero	function
(	O
(	O
char	O
*	O
)	O
&	O
m	union
,	O
sizeof	O
(	O
m	union
)	O
)	O
;	O
m	union
.	O
type	enum
=	O
how	int
;	O
m	union
.	O
protocol_revision	int
=	O
MSG_REVISION	O
;	O
strncpy	function
(	O
m	union
.	O
m_tty	array
,	O
attach_tty_is_in_new_ns	bool
?	O
attach_tty_name_in_ns	array
:	O
attach_tty	pointer
,	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m_tty	array
[	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
how	int
==	O
MSG_WINCH	int
)	O
{	O
if	O
(	O
(	O
lasts	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
is_socket	bool
)	O
)	O
>=	O
0	int
)	O
{	O
WriteMessage	function
(	O
lasts	int
,	O
&	O
m	union
)	O
;	O
close	pointer
(	O
lasts	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
how	int
==	O
MSG_CONT	int
)	O
{	O
if	O
(	O
(	O
lasts	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
is_socket	bool
)	O
)	O
<	O
0	int
)	O
{	O
Panic	function
(	O
0	int
,	O
"Sorry, cannot contact session \"%s\" again.\r\n"	pointer
,	O
SockName	pointer
)	O
;	O
}	O
}	O
else	O
{	O
n	int
=	O
FindSocket	function
(	O
&	O
lasts	int
,	O
(	O
int	O
*	O
)	O
0	int
,	O
(	O
int	O
*	O
)	O
0	int
,	O
SockMatch	pointer
,	O
&	O
is_socket	bool
)	O
;	O
switch	O
(	O
n	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
rflag	int
&&	O
(	O
rflag	int
&	O
1	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
quietflag	int
)	O
eexit	function
(	O
10	int
)	O
;	O
if	O
(	O
SockMatch	pointer
&&	O
*	O
SockMatch	pointer
)	O
{	O
Panic	function
(	O
0	int
,	O
"There is no screen to be %sed matching %s."	pointer
,	O
xflag	int
?	O
"attach"	pointer
:	O
dflag	int
?	O
"detach"	pointer
:	O
"resum"	pointer
,	O
SockMatch	pointer
)	O
;	O
}	O
else	O
{	O
Panic	function
(	O
0	int
,	O
"There is no screen to be %sed."	pointer
,	O
xflag	int
?	O
"attach"	pointer
:	O
dflag	int
?	O
"detach"	pointer
:	O
"resum"	pointer
)	O
;	O
}	O
case	O
1	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
rflag	int
<	O
3	int
)	O
{	O
if	O
(	O
quietflag	int
)	O
eexit	function
(	O
10	int
+	O
n	int
)	O
;	O
Panic	function
(	O
0	int
,	O
"Type \"screen [-d] -r [pid.]tty.host\" to resume one of them."	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
multiattach	int
)	O
{	O
if	O
(	O
setuid	function
(	O
real_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setuid"	pointer
)	O
;	O
}	O
else	O
{	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
}	O
eff_uid	int
=	O
real_uid	int
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setgid"	pointer
)	O
;	O
eff_gid	int
=	O
real_gid	int
;	O
debug2	O
(	O
"Attach: uid %d euid %d\n"	pointer
,	O
(	O
int	O
)	O
getuid	function
(	O
)	O
,	O
(	O
int	O
)	O
geteuid	function
(	O
)	O
)	O
;	O
MasterPid	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
SockName	pointer
;	O
*	O
s	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
*	O
s	int
>	O
'9'	O
||	O
*	O
s	int
<	O
'0'	O
)	O
break	O
;	O
MasterPid	int
=	O
10	int
*	O
MasterPid	int
+	O
(	O
*	O
s	int
-	O
'0'	O
)	O
;	O
}	O
debug1	O
(	O
"Attach decided, it is '%s'\n"	pointer
,	O
SockPath	array
)	O
;	O
debug1	O
(	O
"Attach found MasterPid == %d\n"	pointer
,	O
MasterPid	int
)	O
;	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
st	struct
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"stat %s"	pointer
,	O
SockPath	array
)	O
;	O
if	O
(	O
(	O
st	struct
.	O
st_mode	int
&	O
0600	int
)	O
!=	O
0600	int
)	O
Panic	function
(	O
0	int
,	O
"Socket is in wrong mode (%03o)"	pointer
,	O
(	O
int	O
)	O
st	struct
.	O
st_mode	int
)	O
;	O
if	O
(	O
(	O
xflag	int
||	O
rflag	int
)	O
&&	O
dflag	int
&&	O
(	O
st	struct
.	O
st_mode	int
&	O
0700	int
)	O
==	O
0600	int
)	O
dflag	int
=	O
0	int
;	O
if	O
(	O
(	O
dflag	int
||	O
!	O
xflag	int
)	O
&&	O
(	O
st	struct
.	O
st_mode	int
&	O
0700	int
)	O
!=	O
(	O
dflag	int
?	O
0700	int
:	O
0600	int
)	O
)	O
Panic	function
(	O
0	int
,	O
"That screen is %sdetached."	pointer
,	O
dflag	int
?	O
"already "	pointer
:	O
"not "	pointer
)	O
;	O
if	O
(	O
dflag	int
&&	O
(	O
how	int
==	O
MSG_DETACH	int
||	O
how	int
==	O
MSG_POW_DETACH	int
)	O
)	O
{	O
m	union
.	O
m	union
.	O
detach	struct
.	O
dpid	int
=	O
getpid	function
(	O
)	O
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
detach	struct
.	O
duser	array
,	O
LoginName	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
detach	struct
.	O
duser	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
detach	struct
.	O
duser	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
detach	struct
.	O
duser	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
dflag	int
==	O
2	int
)	O
m	union
.	O
type	enum
=	O
MSG_POW_DETACH	int
;	O
else	O
m	union
.	O
type	enum
=	O
MSG_DETACH	int
;	O
signal	function
(	O
SIGCONT	int
,	O
AttachSigCont	function
)	O
;	O
if	O
(	O
WriteMessage	function
(	O
lasts	int
,	O
&	O
m	union
)	O
)	O
Panic	function
(	O
errno	O
,	O
"WriteMessage"	pointer
)	O
;	O
close	pointer
(	O
lasts	int
)	O
;	O
while	O
(	O
!	O
ContinuePlease	int
)	O
pause	function
(	O
)	O
;	O
signal	function
(	O
SIGCONT	int
,	O
SIG_DFL	O
)	O
;	O
ContinuePlease	int
=	O
0	int
;	O
if	O
(	O
how	int
!=	O
MSG_ATTACH	int
)	O
return	O
0	int
;	O
sleep	function
(	O
1	int
)	O
;	O
if	O
(	O
(	O
lasts	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
is_socket	bool
)	O
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
0	int
,	O
"Cannot contact screen again. Sigh."	pointer
)	O
;	O
m	union
.	O
type	enum
=	O
how	int
;	O
}	O
ASSERT	O
(	O
how	int
==	O
MSG_ATTACH	int
||	O
how	int
==	O
MSG_CONT	int
)	O
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
envterm	array
,	O
attach_term	pointer
,	O
MAXTERMLEN	int
)	O
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
envterm	array
[	O
MAXTERMLEN	int
]	O
=	O
0	int
;	O
debug1	O
(	O
"attach: sending %d bytes... "	pointer
,	O
(	O
int	O
)	O
sizeof	O
(	O
m	union
)	O
)	O
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
auser	array
,	O
LoginName	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
auser	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
auser	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
auser	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
esc	int
=	O
DefaultEsc	int
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
meta_esc	int
=	O
DefaultMetaEsc	int
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
preselect	array
,	O
preselect	array
?	O
preselect	array
:	O
""	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
preselect	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
preselect	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
preselect	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
apid	int
=	O
getpid	function
(	O
)	O
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
adaptflag	int
=	O
adaptflag	int
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
lines	int
=	O
m	union
.	O
m	union
.	O
attach	struct
.	O
columns	int
=	O
0	int
;	O
if	O
(	O
(	O
s	int
=	O
getenv	function
(	O
"LINES"	pointer
)	O
)	O
)	O
m	union
.	O
m	union
.	O
attach	struct
.	O
lines	int
=	O
atoi	function
(	O
s	int
)	O
;	O
if	O
(	O
(	O
s	int
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
)	O
)	O
m	union
.	O
m	union
.	O
attach	struct
.	O
columns	int
=	O
atoi	function
(	O
s	int
)	O
;	O
m	union
.	O
m	union
.	O
attach	struct
.	O
encoding	int
=	O
nwin_options	struct
.	O
encoding	int
>	O
0	int
?	O
nwin_options	struct
.	O
encoding	int
+	O
1	int
:	O
0	int
;	O
if	O
(	O
dflag	int
==	O
2	int
)	O
m	union
.	O
m	union
.	O
attach	struct
.	O
detachfirst	int
=	O
MSG_POW_DETACH	int
;	O
else	O
if	O
(	O
dflag	int
)	O
m	union
.	O
m	union
.	O
attach	struct
.	O
detachfirst	int
=	O
MSG_DETACH	int
;	O
else	O
m	union
.	O
m	union
.	O
attach	struct
.	O
detachfirst	int
=	O
MSG_ATTACH	int
;	O
if	O
(	O
multi	pointer
&&	O
(	O
how	int
==	O
MSG_ATTACH	int
||	O
how	int
==	O
MSG_CONT	int
)	O
)	O
signal	function
(	O
SIGCONT	int
,	O
AttachSigCont	function
)	O
;	O
if	O
(	O
WriteMessage	function
(	O
lasts	int
,	O
&	O
m	union
)	O
)	O
Panic	function
(	O
errno	O
,	O
"WriteMessage"	pointer
)	O
;	O
close	pointer
(	O
lasts	int
)	O
;	O
debug1	O
(	O
"Attach(%d): sent\n"	pointer
,	O
m	union
.	O
type	enum
)	O
;	O
if	O
(	O
multi	pointer
&&	O
(	O
how	int
==	O
MSG_ATTACH	int
||	O
how	int
==	O
MSG_CONT	int
)	O
)	O
{	O
while	O
(	O
!	O
ContinuePlease	int
)	O
pause	function
(	O
)	O
;	O
signal	function
(	O
SIGCONT	int
,	O
SIG_DFL	O
)	O
;	O
ContinuePlease	int
=	O
0	int
;	O
xseteuid	function
(	O
own_uid	int
)	O
;	O
if	O
(	O
tty_oldmode	int
>=	O
0	int
)	O
if	O
(	O
chmod	function
(	O
attach_tty	pointer
,	O
tty_oldmode	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"chmod %s"	pointer
,	O
attach_tty	pointer
)	O
;	O
tty_oldmode	int
=	O
-	O
1	int
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
}	O
rflag	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
AttacherPanic	int
=	O
0	int
;	O
static	O
sigret_t	void
AttacherSigAlarm	function
SIGDEFARG	O
{	O
SIGRETURN	O
;	O
}	O
static	O
sigret_t	void
AttacherSigInt	function
SIGDEFARG	O
{	O
signal	function
(	O
SIGINT	int
,	O
AttacherSigInt	function
)	O
;	O
Kill	function
(	O
MasterPid	int
,	O
SIGINT	int
)	O
;	O
SIGRETURN	O
;	O
}	O
sigret_t	void
AttacherFinit	function
SIGDEFARG	O
{	O
struct	O
stat	struct
statb	struct
;	O
struct	O
msg	struct
m	union
;	O
int	O
s	int
;	O
bool	bool
is_socket	bool
;	O
debug	O
(	O
"AttacherFinit();\n"	pointer
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
statb	struct
)	O
==	O
0	int
&&	O
(	O
statb	struct
.	O
st_mode	int
&	O
0777	int
)	O
!=	O
0600	int
)	O
{	O
debug	O
(	O
"Detaching backend!\n"	pointer
)	O
;	O
bzero	function
(	O
(	O
char	O
*	O
)	O
&	O
m	union
,	O
sizeof	O
(	O
m	union
)	O
)	O
;	O
strncpy	function
(	O
m	union
.	O
m_tty	array
,	O
attach_tty_is_in_new_ns	bool
?	O
attach_tty_name_in_ns	array
:	O
attach_tty	pointer
,	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m_tty	array
[	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
debug1	O
(	O
"attach_tty is %s\n"	pointer
,	O
attach_tty	pointer
)	O
;	O
m	union
.	O
m	union
.	O
detach	struct
.	O
dpid	int
=	O
getpid	function
(	O
)	O
;	O
m	union
.	O
type	enum
=	O
MSG_HANGUP	int
;	O
m	union
.	O
protocol_revision	int
=	O
MSG_REVISION	O
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
(	O
s	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
is_socket	bool
)	O
)	O
>=	O
0	int
)	O
{	O
WriteMessage	function
(	O
s	int
,	O
&	O
m	union
)	O
;	O
close	pointer
(	O
s	int
)	O
;	O
}	O
}	O
if	O
(	O
tty_oldmode	int
>=	O
0	int
)	O
{	O
if	O
(	O
setuid	function
(	O
own_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setuid"	pointer
)	O
;	O
chmod	function
(	O
attach_tty	pointer
,	O
tty_oldmode	int
)	O
;	O
}	O
exit	function
(	O
0	int
)	O
;	O
SIGRETURN	O
;	O
}	O
static	O
sigret_t	void
AttacherFinitBye	function
SIGDEFARG	O
{	O
int	O
ppid	int
;	O
debug	O
(	O
"AttacherFintBye()\n"	pointer
)	O
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setgid"	pointer
)	O
;	O
if	O
(	O
setuid	function
(	O
own_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setuid"	pointer
)	O
;	O
if	O
(	O
(	O
ppid	int
=	O
getppid	function
(	O
)	O
)	O
>	O
1	int
)	O
Kill	function
(	O
ppid	int
,	O
SIGHUP	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
SIGRETURN	O
;	O
}	O
static	O
int	O
SuspendPlease	int
;	O
static	O
sigret_t	void
SigStop	function
SIGDEFARG	O
{	O
debug	O
(	O
"SigStop()\n"	pointer
)	O
;	O
SuspendPlease	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
static	O
int	O
LockPlease	int
;	O
static	O
sigret_t	void
DoLock	function
SIGDEFARG	O
{	O
debug	O
(	O
"DoLock()\n"	pointer
)	O
;	O
LockPlease	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
static	O
int	O
SigWinchPlease	int
;	O
static	O
sigret_t	void
AttacherWinch	function
SIGDEFARG	O
{	O
debug	O
(	O
"AttacherWinch()\n"	pointer
)	O
;	O
SigWinchPlease	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
void	O
Attacher	function
(	O
)	O
{	O
signal	function
(	O
SIGHUP	int
,	O
AttacherFinit	function
)	O
;	O
signal	function
(	O
SIG_BYE	O
,	O
AttacherFinit	function
)	O
;	O
signal	function
(	O
SIG_POWER_BYE	O
,	O
AttacherFinitBye	function
)	O
;	O
signal	function
(	O
SIG_LOCK	O
,	O
DoLock	function
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
AttacherSigInt	function
)	O
;	O
signal	function
(	O
SIG_STOP	O
,	O
SigStop	function
)	O
;	O
signal	function
(	O
SIGWINCH	int
,	O
AttacherWinch	function
)	O
;	O
debug	O
(	O
"attacher: going for a nap.\n"	pointer
)	O
;	O
dflag	int
=	O
0	int
;	O
xflag	int
=	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
signal	function
(	O
SIGALRM	int
,	O
AttacherSigAlarm	function
)	O
;	O
alarm	function
(	O
15	int
)	O
;	O
pause	function
(	O
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
kill	function
(	O
MasterPid	int
,	O
0	int
)	O
<	O
0	int
&&	O
errno	O
!=	O
EPERM	int
)	O
{	O
debug1	O
(	O
"attacher: Panic! MasterPid %d does not exist.\n"	pointer
,	O
MasterPid	int
)	O
;	O
AttacherPanic	int
++	O
;	O
}	O
if	O
(	O
AttacherPanic	int
)	O
{	O
fcntl	function
(	O
0	int
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
SetTTY	function
(	O
0	int
,	O
&	O
attach_Mode	struct
)	O
;	O
printf	function
(	O
"\nError: Cannot find master process to attach to!\n"	pointer
)	O
;	O
eexit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
SuspendPlease	int
)	O
{	O
SuspendPlease	int
=	O
0	int
;	O
signal	function
(	O
SIGTSTP	int
,	O
SIG_DFL	O
)	O
;	O
debug	O
(	O
"attacher: killing myself SIGTSTP\n"	pointer
)	O
;	O
kill	function
(	O
getpid	function
(	O
)	O
,	O
SIGTSTP	int
)	O
;	O
debug	O
(	O
"attacher: continuing from stop\n"	pointer
)	O
;	O
signal	function
(	O
SIG_STOP	O
,	O
SigStop	function
)	O
;	O
(	O
void	O
)	O
Attach	function
(	O
MSG_CONT	int
)	O
;	O
}	O
if	O
(	O
LockPlease	int
)	O
{	O
LockPlease	int
=	O
0	int
;	O
LockTerminal	function
(	O
)	O
;	O
(	O
void	O
)	O
Attach	function
(	O
MSG_CONT	int
)	O
;	O
}	O
if	O
(	O
SigWinchPlease	int
)	O
{	O
SigWinchPlease	int
=	O
0	int
;	O
(	O
void	O
)	O
Attach	function
(	O
MSG_WINCH	int
)	O
;	O
}	O
}	O
}	O
static	O
char	O
LockEnd	array
[	O
]	O
=	O
"Welcome back to screen !!\n"	pointer
;	O
static	O
sigret_t	void
LockHup	function
SIGDEFARG	O
{	O
int	O
ppid	int
=	O
getppid	function
(	O
)	O
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setgid"	pointer
)	O
;	O
if	O
(	O
setuid	function
(	O
own_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setuid"	pointer
)	O
;	O
if	O
(	O
ppid	int
>	O
1	int
)	O
Kill	function
(	O
ppid	int
,	O
SIGHUP	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
LockTerminal	function
(	O
)	O
{	O
char	O
*	O
prg	pointer
;	O
int	O
sig	int
,	O
pid	int
;	O
sigret_t	void
(	O
*	O
sigs	array
[	O
NSIG	O
]	O
)	O
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
for	O
(	O
sig	int
=	O
1	int
;	O
sig	int
<	O
NSIG	O
;	O
sig	int
++	O
)	O
sigs	array
[	O
sig	int
]	O
=	O
signal	function
(	O
sig	int
,	O
sig	int
==	O
SIGCHLD	int
?	O
SIG_DFL	O
:	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
LockHup	function
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
prg	pointer
=	O
getenv	function
(	O
"LOCKPRG"	pointer
)	O
;	O
if	O
(	O
prg	pointer
&&	O
strcmp	function
(	O
prg	pointer
,	O
"builtin"	pointer
)	O
&&	O
!	O
access	function
(	O
prg	pointer
,	O
X_OK	int
)	O
)	O
{	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
debug1	O
(	O
"lockterminal: '%s' seems executable, execl it!\n"	pointer
,	O
prg	pointer
)	O
;	O
if	O
(	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
==	O
0	int
)	O
{	O
displays	pointer
=	O
0	int
;	O
ServerSocket	int
=	O
-	O
1	int
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setgid"	pointer
)	O
;	O
if	O
(	O
setuid	function
(	O
own_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setuid"	pointer
)	O
;	O
closeallfiles	function
(	O
0	int
)	O
;	O
execl	function
(	O
prg	pointer
,	O
"SCREEN-LOCK"	pointer
,	O
NULL	O
)	O
;	O
exit	function
(	O
errno	O
)	O
;	O
}	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
Msg	function
(	O
errno	O
,	O
"Cannot lock terminal - fork failed"	pointer
)	O
;	O
else	O
{	O
int	O
wstat	int
;	O
int	O
wret	int
;	O
errno	O
=	O
0	int
;	O
while	O
(	O
(	O
(	O
wret	int
=	O
wait	function
(	O
&	O
wstat	int
)	O
)	O
!=	O
pid	int
)	O
||	O
(	O
(	O
wret	int
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
==	O
EINTR	int
)	O
)	O
)	O
errno	O
=	O
0	int
;	O
if	O
(	O
errno	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Lock"	pointer
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
WTERMSIG	O
(	O
wstat	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Lock: %s: Killed by signal: %d%s\n"	pointer
,	O
prg	pointer
,	O
WTERMSIG	O
(	O
wstat	int
)	O
,	O
WIFCORESIG	O
(	O
wstat	int
)	O
?	O
" (Core dumped)"	pointer
:	O
""	pointer
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
WEXITSTATUS	O
(	O
wstat	int
)	O
)	O
{	O
debug2	O
(	O
"Lock: %s: return code %d\n"	pointer
,	O
prg	pointer
,	O
WEXITSTATUS	O
(	O
wstat	int
)	O
)	O
;	O
}	O
else	O
printf	function
(	O
"%s"	pointer
,	O
LockEnd	array
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
prg	pointer
)	O
{	O
debug1	O
(	O
"lockterminal: '%s' seems NOT executable, we use our builtin\n"	pointer
,	O
prg	pointer
)	O
;	O
}	O
else	O
{	O
debug	O
(	O
"lockterminal: using buitin.\n"	pointer
)	O
;	O
}	O
screen_builtin_lck	function
(	O
)	O
;	O
}	O
for	O
(	O
sig	int
=	O
1	int
;	O
sig	int
<	O
NSIG	O
;	O
sig	int
++	O
)	O
{	O
if	O
(	O
sigs	array
[	O
sig	int
]	O
!=	O
(	O
sigret_t	void
(	O
*	O
)	O
__P	O
(	O
SIGPROTOARG	O
)	O
)	O
-	O
1	int
)	O
signal	function
(	O
sig	int
,	O
sigs	array
[	O
sig	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
screen_builtin_lck	function
(	O
)	O
{	O
char	O
fullname	array
[	O
100	int
]	O
,	O
*	O
cp1	pointer
,	O
message	array
[	O
100	int
+	O
100	int
]	O
;	O
char	O
*	O
pass	pointer
=	O
0	int
,	O
mypass	array
[	O
16	int
+	O
1	int
]	O
,	O
salt	array
[	O
3	int
]	O
;	O
int	O
using_pam	int
=	O
1	int
;	O
using_pam	int
=	O
0	int
;	O
pass	pointer
=	O
ppp	pointer
->	O
pw_passwd	pointer
;	O
if	O
(	O
pass	pointer
==	O
0	int
||	O
*	O
pass	pointer
==	O
0	int
)	O
{	O
if	O
(	O
(	O
pass	pointer
=	O
getpass	function
(	O
"Key:   "	pointer
)	O
)	O
)	O
{	O
strncpy	function
(	O
mypass	array
,	O
pass	pointer
,	O
sizeof	O
(	O
mypass	array
)	O
-	O
1	int
)	O
;	O
mypass	array
[	O
sizeof	O
(	O
mypass	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
*	O
mypass	array
==	O
0	int
)	O
return	O
;	O
if	O
(	O
(	O
pass	pointer
=	O
getpass	function
(	O
"Again: "	pointer
)	O
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
mypass	array
,	O
pass	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Passwords don't match.\007\n"	pointer
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
pass	pointer
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Getpass error.\007\n"	pointer
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
return	O
;	O
}	O
salt	array
[	O
0	int
]	O
=	O
'A'	O
+	O
(	O
int	O
)	O
(	O
time	struct
(	O
0	int
)	O
%	O
26	int
)	O
;	O
salt	array
[	O
1	int
]	O
=	O
'A'	O
+	O
(	O
int	O
)	O
(	O
(	O
time	struct
(	O
0	int
)	O
>>	O
6	int
)	O
%	O
26	int
)	O
;	O
salt	array
[	O
2	int
]	O
=	O
0	int
;	O
pass	pointer
=	O
crypt	function
(	O
mypass	array
,	O
salt	array
)	O
;	O
if	O
(	O
!	O
pass	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"crypt() error.\007\n"	pointer
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
return	O
;	O
}	O
pass	pointer
=	O
ppp	pointer
->	O
pw_passwd	pointer
=	O
SaveStr	function
(	O
pass	pointer
)	O
;	O
}	O
debug	O
(	O
"screen_builtin_lck looking in gcos field\n"	pointer
)	O
;	O
strncpy	function
(	O
fullname	array
,	O
ppp	pointer
->	O
pw_gecos	pointer
,	O
sizeof	O
(	O
fullname	array
)	O
-	O
9	int
)	O
;	O
fullname	array
[	O
sizeof	O
(	O
fullname	array
)	O
-	O
9	int
]	O
=	O
0	int
;	O
if	O
(	O
(	O
cp1	pointer
=	O
index	function
(	O
fullname	array
,	O
','	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
cp1	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
cp1	pointer
=	O
index	function
(	O
fullname	array
,	O
'&'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
strncpy	function
(	O
cp1	pointer
,	O
ppp	pointer
->	O
pw_name	pointer
,	O
8	int
)	O
;	O
cp1	pointer
[	O
8	int
]	O
=	O
0	int
;	O
if	O
(	O
*	O
cp1	pointer
>=	O
'a'	O
&&	O
*	O
cp1	pointer
<=	O
'z'	O
)	O
*	O
cp1	pointer
-=	O
'a'	O
-	O
'A'	O
;	O
}	O
sprintf	function
(	O
message	array
,	O
"Screen used by %s%s<%s> on %s.\nPassword:\007"	pointer
,	O
fullname	array
,	O
fullname	array
[	O
0	int
]	O
?	O
" "	pointer
:	O
""	pointer
,	O
ppp	pointer
->	O
pw_name	pointer
,	O
HostName	array
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
debug	O
(	O
"screen_builtin_lck awaiting password\n"	pointer
)	O
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
(	O
cp1	pointer
=	O
getpass	function
(	O
message	array
)	O
)	O
==	O
NULL	O
)	O
{	O
AttacherFinit	function
(	O
SIGARG	int
)	O
;	O
}	O
if	O
(	O
using_pam	int
)	O
{	O
}	O
else	O
{	O
char	O
*	O
buf	pointer
=	O
crypt	function
(	O
cp1	pointer
,	O
pass	pointer
)	O
;	O
if	O
(	O
buf	pointer
&&	O
!	O
strncmp	function
(	O
buf	pointer
,	O
pass	pointer
,	O
strlen	function
(	O
pass	pointer
)	O
)	O
)	O
break	O
;	O
}	O
debug	O
(	O
"screen_builtin_lck: NO!!!!!\n"	pointer
)	O
;	O
bzero	function
(	O
cp1	pointer
,	O
strlen	function
(	O
cp1	pointer
)	O
)	O
;	O
}	O
bzero	function
(	O
cp1	pointer
,	O
strlen	function
(	O
cp1	pointer
)	O
)	O
;	O
debug	O
(	O
"password ok.\n"	pointer
)	O
;	O
}	O
void	O
SendCmdMessage	function
(	O
sty	pointer
,	O
match	pointer
,	O
av	pointer
,	O
query	int
)	O
char	O
*	O
sty	pointer
;	O
char	O
*	O
match	pointer
;	O
char	O
*	O
*	O
av	pointer
;	O
int	O
query	int
;	O
{	O
int	O
i	int
,	O
s	int
;	O
struct	O
msg	struct
m	union
;	O
char	O
*	O
p	pointer
;	O
int	O
len	int
,	O
n	int
;	O
bool	bool
is_socket	bool
;	O
if	O
(	O
sty	pointer
==	O
0	int
)	O
{	O
i	int
=	O
FindSocket	function
(	O
&	O
s	int
,	O
(	O
int	O
*	O
)	O
0	int
,	O
(	O
int	O
*	O
)	O
0	int
,	O
match	pointer
,	O
&	O
is_socket	bool
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"No screen session found."	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
1	int
)	O
Panic	function
(	O
0	int
,	O
"Use -S to specify a session."	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strlen	function
(	O
sty	pointer
)	O
>	O
NAME_MAX	int
)	O
sty	pointer
[	O
NAME_MAX	int
]	O
=	O
0	int
;	O
if	O
(	O
strlen	function
(	O
sty	pointer
)	O
>	O
2	int
*	O
MAXSTR	int
-	O
1	int
)	O
sty	pointer
[	O
2	int
*	O
MAXSTR	int
-	O
1	int
]	O
=	O
0	int
;	O
sprintf	function
(	O
SockPath	array
+	O
strlen	function
(	O
SockPath	array
)	O
,	O
"/%s"	pointer
,	O
sty	pointer
)	O
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
(	O
s	int
=	O
MakeClientSocket	function
(	O
1	int
,	O
is_socket	bool
)	O
)	O
==	O
-	O
1	int
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
bzero	function
(	O
(	O
char	O
*	O
)	O
&	O
m	union
,	O
sizeof	O
(	O
m	union
)	O
)	O
;	O
m	union
.	O
type	enum
=	O
query	int
?	O
MSG_QUERY	int
:	O
MSG_COMMAND	int
;	O
if	O
(	O
attach_tty	pointer
)	O
{	O
strncpy	function
(	O
m	union
.	O
m_tty	array
,	O
attach_tty_is_in_new_ns	bool
?	O
attach_tty_name_in_ns	array
:	O
attach_tty	pointer
,	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m_tty	array
[	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
p	pointer
=	O
m	union
.	O
m	union
.	O
command	struct
.	O
cmd	array
;	O
n	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
av	pointer
&&	O
n	int
<	O
MAXARGS	int
-	O
1	int
;	O
++	O
av	pointer
,	O
++	O
n	int
)	O
{	O
len	int
=	O
strlen	function
(	O
*	O
av	pointer
)	O
+	O
1	int
;	O
if	O
(	O
p	pointer
+	O
len	int
>=	O
m	union
.	O
m	union
.	O
command	struct
.	O
cmd	array
+	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
cmd	array
)	O
-	O
1	int
)	O
break	O
;	O
strcpy	function
(	O
p	pointer
,	O
*	O
av	pointer
)	O
;	O
p	pointer
+=	O
len	int
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
m	union
.	O
m	union
.	O
command	struct
.	O
nargs	int
=	O
n	int
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
auser	array
,	O
LoginName	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
attach	struct
.	O
auser	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
command	struct
.	O
auser	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
auser	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
m	union
.	O
protocol_revision	int
=	O
MSG_REVISION	O
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
preselect	array
,	O
preselect	array
?	O
preselect	array
:	O
""	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
preselect	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
command	struct
.	O
preselect	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
preselect	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
m	union
.	O
m	union
.	O
command	struct
.	O
apid	int
=	O
getpid	function
(	O
)	O
;	O
debug1	O
(	O
"SendCommandMsg writing '%s'\n"	pointer
,	O
m	union
.	O
m	union
.	O
command	struct
.	O
cmd	array
)	O
;	O
if	O
(	O
query	int
)	O
{	O
char	O
*	O
sp	pointer
=	O
SockPath	array
+	O
strlen	function
(	O
SockPath	array
)	O
;	O
char	O
query	int
[	O
]	O
=	O
"-queryX"	pointer
;	O
char	O
c	char
;	O
int	O
r	int
=	O
-	O
1	int
;	O
for	O
(	O
c	char
=	O
'A'	O
;	O
c	char
<=	O
'Z'	O
;	O
c	char
++	O
)	O
{	O
query	int
[	O
6	int
]	O
=	O
c	char
;	O
strcpy	function
(	O
sp	pointer
,	O
query	int
)	O
;	O
if	O
(	O
(	O
r	int
=	O
MakeServerSocket	function
(	O
is_socket	bool
)	O
)	O
>=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
for	O
(	O
c	char
=	O
'0'	O
;	O
c	char
<=	O
'9'	O
;	O
c	char
++	O
)	O
{	O
query	int
[	O
6	int
]	O
=	O
c	char
;	O
strcpy	function
(	O
sp	pointer
,	O
query	int
)	O
;	O
if	O
(	O
(	O
r	int
=	O
MakeServerSocket	function
(	O
is_socket	bool
)	O
)	O
>=	O
0	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
r	int
<	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Could not create a listening socket to read the results."	pointer
)	O
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
writeback	array
,	O
SockPath	array
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
writeback	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
command	struct
.	O
writeback	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
writeback	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
signal	function
(	O
SIGCONT	int
,	O
QueryResultSuccess	function
)	O
;	O
signal	function
(	O
SIG_BYE	O
,	O
QueryResultFail	function
)	O
;	O
if	O
(	O
WriteMessage	function
(	O
s	int
,	O
&	O
m	union
)	O
)	O
Msg	function
(	O
errno	O
,	O
"write"	pointer
)	O
;	O
close	pointer
(	O
s	int
)	O
;	O
while	O
(	O
!	O
QueryResult	int
)	O
pause	function
(	O
)	O
;	O
signal	function
(	O
SIGCONT	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIG_BYE	O
,	O
SIG_DFL	O
)	O
;	O
ReceiveRaw	function
(	O
r	int
)	O
;	O
unlink	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
QueryResult	int
==	O
2	int
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
WriteMessage	function
(	O
s	int
,	O
&	O
m	union
)	O
)	O
Msg	function
(	O
errno	O
,	O
"write"	pointer
)	O
;	O
close	pointer
(	O
s	int
)	O
;	O
}	O
}	O
