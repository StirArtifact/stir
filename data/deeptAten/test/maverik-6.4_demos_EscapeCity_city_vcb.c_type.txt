int	O
space	array
[	O
SPACE_SIZE	int
]	O
[	O
SPACE_SIZE	int
]	O
;	O
int	O
cand	array
[	O
MAX_CAND	int
]	O
[	O
2	int
]	O
;	O
int	O
cells	array
[	O
RUN_LENGTH	int
]	O
[	O
4	int
]	O
;	O
int	O
numCand	int
=	O
0	int
;	O
int	O
numCell	int
=	O
0	int
;	O
int	O
neighList	array
[	O
4	int
]	O
[	O
2	int
]	O
=	O
{	O
{	O
0	int
,	O
1	int
}	O
,	O
{	O
1	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
-	O
1	int
}	O
,	O
{	O
-	O
1	int
,	O
0	int
}	O
}	O
;	O
int	O
weightTable	array
[	O
4	int
]	O
=	O
{	O
ZERO_NEIGH_WEIGHT	int
,	O
ONE_NEIGH_WEIGHT	int
,	O
TWO_NEIGH_WEIGHT	int
,	O
THREE_NEIGH_WEIGHT	int
}	O
;	O
char	O
symbolList	array
[	O
]	O
=	O
". +"	pointer
;	O
static	O
void	O
deleteFromCand	function
(	O
int	O
posX	int
,	O
int	O
posY	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numCand	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
cand	array
[	O
i	int
]	O
[	O
0	int
]	O
==	O
posX	int
)	O
&&	O
(	O
cand	array
[	O
i	int
]	O
[	O
1	int
]	O
==	O
posY	int
)	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
;	O
j	int
<	O
numCand	int
;	O
j	int
++	O
)	O
{	O
cand	array
[	O
j	int
]	O
[	O
0	int
]	O
=	O
cand	array
[	O
j	int
+	O
1	int
]	O
[	O
0	int
]	O
;	O
cand	array
[	O
j	int
]	O
[	O
1	int
]	O
=	O
cand	array
[	O
j	int
+	O
1	int
]	O
[	O
1	int
]	O
;	O
}	O
numCand	int
--	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
addToCandNeighsOf	function
(	O
int	O
posX	int
,	O
int	O
posY	int
)	O
{	O
int	O
i	int
,	O
neighX	int
,	O
neighY	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
neighX	int
=	O
posX	int
+	O
neighList	array
[	O
i	int
]	O
[	O
0	int
]	O
;	O
neighY	int
=	O
posY	int
+	O
neighList	array
[	O
i	int
]	O
[	O
1	int
]	O
;	O
if	O
(	O
(	O
neighX	int
>	O
-	O
1	int
)	O
&&	O
(	O
neighX	int
<	O
SPACE_SIZE	int
)	O
&&	O
(	O
neighY	int
>	O
-	O
1	int
)	O
&&	O
(	O
neighY	int
<	O
SPACE_SIZE	int
)	O
&&	O
(	O
space	array
[	O
neighX	int
]	O
[	O
neighY	int
]	O
==	O
0	int
)	O
)	O
{	O
deleteFromCand	function
(	O
neighX	int
,	O
neighY	int
)	O
;	O
cand	array
[	O
numCand	int
]	O
[	O
0	int
]	O
=	O
neighX	int
;	O
cand	array
[	O
numCand	int
]	O
[	O
1	int
]	O
=	O
neighY	int
;	O
numCand	int
++	O
;	O
if	O
(	O
numCand	int
>	O
MAX_CAND	int
+	O
1	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"Candidate list is out of memory\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
noVertexOnlyJoin	function
(	O
int	O
posX	int
,	O
int	O
posY	int
)	O
{	O
if	O
(	O
(	O
space	array
[	O
posX	int
]	O
[	O
posY	int
+	O
1	int
]	O
>	O
0	int
)	O
||	O
(	O
space	array
[	O
posX	int
+	O
1	int
]	O
[	O
posY	int
]	O
>	O
0	int
)	O
||	O
(	O
space	array
[	O
posX	int
]	O
[	O
posY	int
-	O
1	int
]	O
>	O
0	int
)	O
||	O
(	O
space	array
[	O
posX	int
]	O
[	O
posY	int
-	O
1	int
]	O
>	O
0	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
{	O
if	O
(	O
(	O
space	array
[	O
posX	int
-	O
1	int
]	O
[	O
posY	int
-	O
1	int
]	O
>	O
0	int
)	O
||	O
(	O
space	array
[	O
posX	int
+	O
1	int
]	O
[	O
posY	int
-	O
1	int
]	O
>	O
0	int
)	O
||	O
(	O
space	array
[	O
posX	int
-	O
1	int
]	O
[	O
posY	int
+	O
1	int
]	O
>	O
0	int
)	O
||	O
(	O
space	array
[	O
posX	int
+	O
1	int
]	O
[	O
posY	int
+	O
1	int
]	O
>	O
0	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
selectClosed	function
(	O
int	O
posX	int
,	O
int	O
posY	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
neighX	int
,	O
neighY	int
,	O
numNeighNeigh	int
,	O
s	int
,	O
closedX	int
,	O
closedY	int
;	O
int	O
accum	int
=	O
0	int
;	O
int	O
weight	array
[	O
4	int
]	O
=	O
{	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
}	O
;	O
int	O
weightTotal	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
neighX	int
=	O
posX	int
+	O
neighList	array
[	O
i	int
]	O
[	O
0	int
]	O
;	O
neighY	int
=	O
posY	int
+	O
neighList	array
[	O
i	int
]	O
[	O
1	int
]	O
;	O
if	O
(	O
(	O
neighX	int
>	O
-	O
1	int
)	O
&&	O
(	O
neighX	int
<	O
SPACE_SIZE	int
)	O
&&	O
(	O
neighY	int
>	O
-	O
1	int
)	O
&&	O
(	O
neighY	int
<	O
SPACE_SIZE	int
)	O
&&	O
(	O
space	array
[	O
neighX	int
]	O
[	O
neighY	int
]	O
==	O
0	int
)	O
&&	O
(	O
noVertexOnlyJoin	function
(	O
neighX	int
,	O
neighY	int
)	O
==	O
1	int
)	O
)	O
{	O
numNeighNeigh	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
space	array
[	O
neighX	int
+	O
neighList	array
[	O
j	int
]	O
[	O
0	int
]	O
]	O
[	O
neighY	int
+=	O
neighList	array
[	O
j	int
]	O
[	O
1	int
]	O
]	O
>	O
0	int
)	O
numNeighNeigh	int
++	O
;	O
}	O
weight	array
[	O
i	int
]	O
=	O
weightTable	array
[	O
numNeighNeigh	int
]	O
;	O
weightTotal	int
=	O
weightTotal	int
+	O
weight	array
[	O
i	int
]	O
;	O
}	O
else	O
{	O
weight	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
weightTotal	int
>	O
0	int
)	O
{	O
s	int
=	O
(	O
int	O
)	O
(	O
mav_random	function
(	O
)	O
*	O
weightTotal	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
accum	int
=	O
accum	int
+	O
weight	array
[	O
k	int
]	O
;	O
if	O
(	O
s	int
<	O
accum	int
)	O
break	O
;	O
}	O
closedX	int
=	O
posX	int
+	O
neighList	array
[	O
k	int
]	O
[	O
0	int
]	O
;	O
closedY	int
=	O
posY	int
+	O
neighList	array
[	O
k	int
]	O
[	O
1	int
]	O
;	O
space	array
[	O
closedX	int
]	O
[	O
closedY	int
]	O
=	O
++	O
numCell	int
;	O
cells	array
[	O
numCell	int
]	O
[	O
2	int
]	O
=	O
closedX	int
;	O
cells	array
[	O
numCell	int
]	O
[	O
3	int
]	O
=	O
closedY	int
;	O
deleteFromCand	function
(	O
closedX	int
,	O
closedY	int
)	O
;	O
}	O
return	O
(	O
weightTotal	int
)	O
;	O
}	O
static	O
void	O
selectOpen	function
(	O
void	O
)	O
{	O
int	O
s	int
,	O
openX	int
,	O
openY	int
;	O
do	O
{	O
if	O
(	O
numCand	int
==	O
0	int
)	O
return	O
;	O
else	O
s	int
=	O
(	O
int	O
)	O
(	O
numCand	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
openX	int
=	O
cand	array
[	O
s	int
]	O
[	O
0	int
]	O
;	O
openY	int
=	O
cand	array
[	O
s	int
]	O
[	O
1	int
]	O
;	O
deleteFromCand	function
(	O
openX	int
,	O
openY	int
)	O
;	O
}	O
while	O
(	O
selectClosed	function
(	O
openX	int
,	O
openY	int
)	O
==	O
0	int
)	O
;	O
space	array
[	O
openX	int
]	O
[	O
openY	int
]	O
=	O
-	O
numCell	int
;	O
cells	array
[	O
numCell	int
]	O
[	O
0	int
]	O
=	O
openX	int
;	O
cells	array
[	O
numCell	int
]	O
[	O
1	int
]	O
=	O
openY	int
;	O
deleteFromCand	function
(	O
openX	int
,	O
openY	int
)	O
;	O
addToCandNeighsOf	function
(	O
openX	int
,	O
openY	int
)	O
;	O
}	O
static	O
void	O
initialise	function
(	O
int	O
num_seeds	int
)	O
{	O
int	O
x	int
,	O
y	int
;	O
int	O
i	int
;	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
SPACE_SIZE	int
;	O
x	int
++	O
)	O
{	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
SPACE_SIZE	int
;	O
y	int
++	O
)	O
space	array
[	O
x	int
]	O
[	O
y	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
MAX_CAND	int
;	O
x	int
++	O
)	O
{	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
2	int
;	O
y	int
++	O
)	O
cand	array
[	O
x	int
]	O
[	O
y	int
]	O
=	O
-	O
1	int
;	O
}	O
numCand	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_seeds	int
;	O
i	int
++	O
)	O
{	O
x	int
=	O
(	O
int	O
)	O
(	O
SPACE_SIZE	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
y	int
=	O
(	O
int	O
)	O
(	O
SPACE_SIZE	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
space	array
[	O
x	int
]	O
[	O
y	int
]	O
=	O
-	O
1	int
;	O
cells	array
[	O
i	int
+	O
1	int
]	O
[	O
0	int
]	O
=	O
x	int
;	O
cells	array
[	O
i	int
+	O
1	int
]	O
[	O
1	int
]	O
=	O
y	int
;	O
cand	array
[	O
i	int
]	O
[	O
0	int
]	O
=	O
x	int
;	O
cand	array
[	O
i	int
]	O
[	O
1	int
]	O
=	O
y	int
+	O
1	int
;	O
cand	array
[	O
i	int
+	O
1	int
]	O
[	O
0	int
]	O
=	O
x	int
+	O
1	int
;	O
cand	array
[	O
i	int
+	O
1	int
]	O
[	O
1	int
]	O
=	O
y	int
;	O
cand	array
[	O
i	int
+	O
2	int
]	O
[	O
0	int
]	O
=	O
x	int
;	O
cand	array
[	O
i	int
+	O
2	int
]	O
[	O
1	int
]	O
=	O
y	int
-	O
1	int
;	O
cand	array
[	O
i	int
+	O
3	int
]	O
[	O
0	int
]	O
=	O
x	int
-	O
1	int
;	O
cand	array
[	O
i	int
+	O
3	int
]	O
[	O
1	int
]	O
=	O
y	int
;	O
numCand	int
+=	O
4	int
;	O
selectClosed	function
(	O
x	int
,	O
y	int
)	O
;	O
}	O
}	O
int	O
vcb_main	function
(	O
int	O
num_seeds	int
,	O
int	O
num_cells	int
)	O
{	O
int	O
i	int
;	O
initialise	function
(	O
num_seeds	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
num_cells	int
>	O
0	int
&&	O
(	O
numCand	int
>	O
0	int
)	O
&&	O
(	O
i	int
<	O
RUN_LENGTH	int
)	O
;	O
i	int
++	O
)	O
{	O
selectOpen	function
(	O
)	O
;	O
num_cells	int
--	O
;	O
}	O
fprintf	function
(	O
stdout	pointer
,	O
"Building completed with %d cells filled.\n"	pointer
,	O
numCell	int
)	O
;	O
return	O
(	O
numCell	int
)	O
;	O
}	O
