static	O
mu_assoc_t	pointer
section_tab	pointer
;	O
static	O
void	O
alloc_section_tab	function
(	O
)	O
{	O
if	O
(	O
!	O
section_tab	pointer
)	O
mu_assoc_create	function
(	O
&	O
section_tab	pointer
,	O
MU_ASSOC_COPY_KEY	int
)	O
;	O
}	O
int	O
mu_create_canned_section	function
(	O
char	O
*	O
name	pointer
,	O
struct	O
mu_cfg_section	int
*	O
*	O
psection	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_cfg_cont	struct
*	O
*	O
pcont	pointer
;	O
alloc_section_tab	function
(	O
)	O
;	O
rc	int
=	O
mu_assoc_install_ref	function
(	O
section_tab	pointer
,	O
name	pointer
,	O
&	O
pcont	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_config_create_container	function
(	O
pcont	pointer
,	O
mu_cfg_cont_section	int
)	O
;	O
*	O
psection	pointer
=	O
&	O
(	O
*	O
pcont	pointer
)	O
->	O
v	pointer
.	O
section	struct
;	O
(	O
*	O
psection	pointer
)	O
->	O
ident	pointer
=	O
name	pointer
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
MU_ERR_EXISTS	O
)	O
*	O
psection	pointer
=	O
&	O
(	O
*	O
pcont	pointer
)	O
->	O
v	pointer
.	O
section	struct
;	O
return	O
rc	int
;	O
}	O
int	O
mu_create_canned_param	function
(	O
char	O
*	O
name	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
*	O
pparam	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_cfg_cont	struct
*	O
*	O
pcont	pointer
;	O
alloc_section_tab	function
(	O
)	O
;	O
rc	int
=	O
mu_assoc_install_ref	function
(	O
section_tab	pointer
,	O
name	pointer
,	O
&	O
pcont	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_config_create_container	function
(	O
pcont	pointer
,	O
mu_cfg_cont_param	int
)	O
;	O
*	O
pparam	pointer
=	O
&	O
(	O
*	O
pcont	pointer
)	O
->	O
v	pointer
.	O
param	pointer
;	O
(	O
*	O
pparam	pointer
)	O
->	O
ident	pointer
=	O
name	pointer
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
MU_ERR_EXISTS	O
)	O
*	O
pparam	pointer
=	O
&	O
(	O
*	O
pcont	pointer
)	O
->	O
v	pointer
.	O
param	pointer
;	O
return	O
rc	int
;	O
}	O
struct	O
mu_cfg_cont	struct
*	O
mu_get_canned_container	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
mu_assoc_get	function
(	O
section_tab	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
struct	O
mu_cfg_cont	struct
*	O
root_container	pointer
;	O
int	O
mu_config_create_container	function
(	O
struct	O
mu_cfg_cont	struct
*	O
*	O
pcont	pointer
,	O
enum	O
mu_cfg_cont_type	enum
type	enum
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
;	O
int	O
rc	int
;	O
cont	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
cont	pointer
)	O
)	O
;	O
if	O
(	O
!	O
cont	pointer
)	O
return	O
ENOMEM	int
;	O
rc	int
=	O
mu_refcount_create	function
(	O
&	O
cont	pointer
->	O
refcount	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
free	function
(	O
cont	pointer
)	O
;	O
else	O
{	O
cont	pointer
->	O
type	enum
=	O
type	enum
;	O
*	O
pcont	pointer
=	O
cont	pointer
;	O
}	O
return	O
rc	int
;	O
}	O
struct	O
dup_data	struct
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
;	O
}	O
;	O
static	O
int	O
dup_container	function
(	O
struct	O
mu_cfg_cont	struct
*	O
*	O
pcont	pointer
)	O
;	O
static	O
int	O
_dup_cont_action	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
cbdata	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
item	pointer
;	O
struct	O
dup_data	struct
*	O
pdd	pointer
=	O
cbdata	pointer
;	O
rc	int
=	O
dup_container	function
(	O
&	O
cont	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
!	O
pdd	pointer
->	O
cont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
)	O
{	O
int	O
rc	int
=	O
mu_list_create	function
(	O
&	O
pdd	pointer
->	O
cont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
return	O
mu_list_append	function
(	O
pdd	pointer
->	O
cont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
,	O
cont	pointer
)	O
;	O
}	O
static	O
int	O
dup_container	function
(	O
struct	O
mu_cfg_cont	struct
*	O
*	O
pcont	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_cfg_cont	struct
*	O
newcont	pointer
,	O
*	O
oldcont	pointer
=	O
*	O
pcont	pointer
;	O
struct	O
dup_data	struct
dd	struct
;	O
rc	int
=	O
mu_config_create_container	function
(	O
&	O
newcont	pointer
,	O
oldcont	pointer
->	O
type	enum
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
dd	struct
.	O
cont	pointer
=	O
newcont	pointer
;	O
switch	O
(	O
oldcont	pointer
->	O
type	enum
)	O
{	O
case	O
mu_cfg_cont_section	int
:	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
ident	pointer
=	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
ident	pointer
;	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
label	pointer
=	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
label	pointer
;	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
parser	pointer
=	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
parser	pointer
;	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
data	pointer
=	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
data	pointer
;	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
offset	long
=	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
offset	long
;	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
docstring	pointer
=	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
docstring	pointer
;	O
newcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
=	O
NULL	O
;	O
rc	int
=	O
mu_list_foreach	function
(	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
,	O
_dup_cont_action	function
,	O
&	O
dd	struct
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"_dup_cont_action"	pointer
,	O
oldcont	pointer
->	O
v	pointer
.	O
section	struct
.	O
ident	pointer
,	O
rc	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
mu_cfg_cont_param	int
:	O
newcont	pointer
->	O
v	pointer
.	O
param	pointer
=	O
oldcont	pointer
->	O
v	pointer
.	O
param	pointer
;	O
break	O
;	O
}	O
*	O
pcont	pointer
=	O
newcont	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
destroy_list	function
(	O
mu_list_t	pointer
*	O
plist	pointer
)	O
{	O
mu_list_t	pointer
list	pointer
=	O
*	O
plist	pointer
;	O
mu_iterator_t	pointer
itr	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
list	pointer
)	O
return	O
;	O
mu_list_get_iterator	function
(	O
list	pointer
,	O
&	O
itr	pointer
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
,	O
*	O
p	pointer
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cont	pointer
)	O
;	O
p	pointer
=	O
cont	pointer
;	O
mu_config_destroy_container	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
mu_list_remove	function
(	O
list	pointer
,	O
cont	pointer
)	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
mu_list_is_empty	function
(	O
list	pointer
)	O
)	O
mu_list_destroy	function
(	O
plist	pointer
)	O
;	O
}	O
void	O
mu_config_destroy_container	function
(	O
struct	O
mu_cfg_cont	struct
*	O
*	O
pcont	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
*	O
pcont	pointer
;	O
unsigned	O
refcount	pointer
=	O
mu_refcount_dec	function
(	O
cont	pointer
->	O
refcount	pointer
)	O
;	O
switch	O
(	O
cont	pointer
->	O
type	enum
)	O
{	O
case	O
mu_cfg_cont_section	int
:	O
destroy_list	function
(	O
&	O
cont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
)	O
;	O
break	O
;	O
case	O
mu_cfg_cont_param	int
:	O
break	O
;	O
}	O
if	O
(	O
refcount	pointer
==	O
0	int
)	O
{	O
free	function
(	O
cont	pointer
)	O
;	O
*	O
pcont	pointer
=	O
0	int
;	O
}	O
}	O
int	O
mu_cfg_section_add_container	function
(	O
struct	O
mu_cfg_section	int
*	O
sect	pointer
,	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
)	O
{	O
if	O
(	O
!	O
cont	pointer
)	O
return	O
0	int
;	O
if	O
(	O
!	O
sect	pointer
->	O
children	pointer
)	O
mu_list_create	function
(	O
&	O
sect	pointer
->	O
children	pointer
)	O
;	O
return	O
mu_list_append	function
(	O
sect	pointer
->	O
children	pointer
,	O
cont	pointer
)	O
;	O
}	O
int	O
mu_cfg_section_add_params	function
(	O
struct	O
mu_cfg_section	int
*	O
sect	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
!	O
param	pointer
)	O
return	O
0	int
;	O
for	O
(	O
;	O
param	pointer
->	O
ident	pointer
;	O
param	pointer
++	O
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_cfg_cont	struct
*	O
container	pointer
;	O
if	O
(	O
param	pointer
->	O
type	enum
==	O
mu_cfg_section	int
)	O
{	O
container	pointer
=	O
mu_get_canned_container	function
(	O
param	pointer
->	O
ident	pointer
)	O
;	O
if	O
(	O
!	O
container	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"INTERNAL ERROR: Requested unknown canned "	pointer
"section %s"	pointer
)	O
,	O
param	pointer
->	O
ident	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
param	pointer
->	O
ident	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
mu_iterator_t	pointer
itr	pointer
;	O
mu_list_get_iterator	function
(	O
container	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
,	O
&	O
itr	pointer
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
c	char
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
c	char
)	O
;	O
mu_config_clone_container	function
(	O
c	char
)	O
;	O
if	O
(	O
mu_refcount_value	function
(	O
c	char
->	O
refcount	pointer
)	O
>	O
1	int
)	O
dup_container	function
(	O
&	O
c	char
)	O
;	O
switch	O
(	O
c	char
->	O
type	enum
)	O
{	O
case	O
mu_cfg_cont_section	int
:	O
if	O
(	O
param	pointer
->	O
data	pointer
)	O
{	O
c	char
->	O
v	pointer
.	O
section	struct
.	O
data	pointer
=	O
param	pointer
->	O
data	pointer
;	O
c	char
->	O
v	pointer
.	O
section	struct
.	O
offset	long
=	O
param	pointer
->	O
offset	long
;	O
}	O
else	O
if	O
(	O
c	char
->	O
v	pointer
.	O
section	struct
.	O
data	pointer
)	O
;	O
else	O
c	char
->	O
v	pointer
.	O
section	struct
.	O
offset	long
+=	O
param	pointer
->	O
offset	long
;	O
break	O
;	O
case	O
mu_cfg_cont_param	int
:	O
if	O
(	O
param	pointer
->	O
data	pointer
)	O
{	O
container	pointer
->	O
v	pointer
.	O
param	pointer
.	O
data	pointer
=	O
param	pointer
->	O
data	pointer
;	O
container	pointer
->	O
v	pointer
.	O
param	pointer
.	O
offset	long
=	O
param	pointer
->	O
offset	long
;	O
}	O
else	O
if	O
(	O
container	pointer
->	O
v	pointer
.	O
param	pointer
.	O
data	pointer
)	O
;	O
else	O
container	pointer
->	O
v	pointer
.	O
param	pointer
.	O
offset	long
+=	O
param	pointer
->	O
offset	long
;	O
break	O
;	O
}	O
mu_cfg_section_add_container	function
(	O
sect	pointer
,	O
c	char
)	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
mu_config_clone_container	function
(	O
container	pointer
)	O
;	O
if	O
(	O
mu_refcount_value	function
(	O
container	pointer
->	O
refcount	pointer
)	O
>	O
1	int
)	O
dup_container	function
(	O
&	O
container	pointer
)	O
;	O
container	pointer
->	O
v	pointer
.	O
section	struct
.	O
data	pointer
=	O
param	pointer
->	O
data	pointer
;	O
container	pointer
->	O
v	pointer
.	O
section	struct
.	O
offset	long
=	O
param	pointer
->	O
offset	long
;	O
}	O
}	O
else	O
{	O
rc	int
=	O
mu_config_create_container	function
(	O
&	O
container	pointer
,	O
mu_cfg_cont_param	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
container	pointer
->	O
v	pointer
.	O
param	pointer
=	O
*	O
param	pointer
;	O
}	O
mu_cfg_section_add_container	function
(	O
sect	pointer
,	O
container	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_clone_action	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
cbdata	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
item	pointer
;	O
return	O
mu_config_clone_container	function
(	O
cont	pointer
)	O
;	O
}	O
int	O
mu_config_clone_container	function
(	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
)	O
{	O
if	O
(	O
!	O
cont	pointer
)	O
return	O
0	int
;	O
mu_refcount_inc	function
(	O
cont	pointer
->	O
refcount	pointer
)	O
;	O
switch	O
(	O
cont	pointer
->	O
type	enum
)	O
{	O
case	O
mu_cfg_cont_section	int
:	O
return	O
mu_list_foreach	function
(	O
cont	pointer
->	O
v	pointer
.	O
section	struct
.	O
children	pointer
,	O
_clone_action	function
,	O
NULL	O
)	O
;	O
case	O
mu_cfg_cont_param	int
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_config_container_register_section	function
(	O
struct	O
mu_cfg_cont	struct
*	O
*	O
proot	pointer
,	O
const	O
char	O
*	O
parent_path	pointer
,	O
const	O
char	O
*	O
ident	pointer
,	O
const	O
char	O
*	O
label	pointer
,	O
mu_cfg_section_fp	pointer
parser	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
param	pointer
,	O
struct	O
mu_cfg_section	int
*	O
*	O
psection	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_cfg_section	int
*	O
root_section	pointer
;	O
struct	O
mu_cfg_section	int
*	O
parent	pointer
;	O
if	O
(	O
!	O
*	O
proot	pointer
)	O
{	O
rc	int
=	O
mu_config_create_container	function
(	O
proot	pointer
,	O
mu_cfg_cont_section	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
memset	function
(	O
&	O
(	O
*	O
proot	pointer
)	O
->	O
v	pointer
.	O
section	struct
,	O
0	int
,	O
sizeof	O
(	O
*	O
proot	pointer
)	O
->	O
v	pointer
.	O
section	struct
)	O
;	O
}	O
root_section	pointer
=	O
&	O
(	O
*	O
proot	pointer
)	O
->	O
v	pointer
.	O
section	struct
;	O
if	O
(	O
parent_path	pointer
)	O
{	O
if	O
(	O
mu_cfg_find_section	function
(	O
root_section	pointer
,	O
parent_path	pointer
,	O
&	O
parent	pointer
)	O
)	O
return	O
MU_ERR_NOENT	O
;	O
}	O
else	O
parent	pointer
=	O
root_section	pointer
;	O
if	O
(	O
mu_refcount_value	function
(	O
(	O
*	O
proot	pointer
)	O
->	O
refcount	pointer
)	O
>	O
1	int
)	O
{	O
rc	int
=	O
dup_container	function
(	O
proot	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
root_section	pointer
=	O
&	O
(	O
*	O
proot	pointer
)	O
->	O
v	pointer
.	O
section	struct
;	O
if	O
(	O
parent_path	pointer
)	O
{	O
if	O
(	O
mu_cfg_find_section	function
(	O
root_section	pointer
,	O
parent_path	pointer
,	O
&	O
parent	pointer
)	O
)	O
return	O
MU_ERR_NOENT	O
;	O
}	O
else	O
parent	pointer
=	O
root_section	pointer
;	O
}	O
if	O
(	O
ident	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
container	pointer
;	O
struct	O
mu_cfg_section	int
*	O
s	pointer
;	O
if	O
(	O
!	O
parent	pointer
->	O
children	pointer
)	O
mu_list_create	function
(	O
&	O
parent	pointer
->	O
children	pointer
)	O
;	O
mu_config_create_container	function
(	O
&	O
container	pointer
,	O
mu_cfg_cont_section	int
)	O
;	O
mu_list_append	function
(	O
parent	pointer
->	O
children	pointer
,	O
container	pointer
)	O
;	O
s	pointer
=	O
&	O
container	pointer
->	O
v	pointer
.	O
section	struct
;	O
s	pointer
->	O
ident	pointer
=	O
strdup	function
(	O
ident	pointer
)	O
;	O
s	pointer
->	O
label	pointer
=	O
label	pointer
?	O
strdup	function
(	O
label	pointer
)	O
:	O
NULL	O
;	O
s	pointer
->	O
parser	pointer
=	O
parser	pointer
;	O
s	pointer
->	O
children	pointer
=	O
NULL	O
;	O
mu_cfg_section_add_params	function
(	O
s	pointer
,	O
param	pointer
)	O
;	O
if	O
(	O
psection	pointer
)	O
*	O
psection	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
mu_cfg_section_add_params	function
(	O
parent	pointer
,	O
param	pointer
)	O
;	O
if	O
(	O
!	O
parent	pointer
->	O
parser	pointer
)	O
parent	pointer
->	O
parser	pointer
=	O
parser	pointer
;	O
if	O
(	O
psection	pointer
)	O
*	O
psection	pointer
=	O
parent	pointer
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_config_root_register_section	function
(	O
const	O
char	O
*	O
parent_path	pointer
,	O
const	O
char	O
*	O
ident	pointer
,	O
const	O
char	O
*	O
label	pointer
,	O
mu_cfg_section_fp	pointer
parser	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
param	pointer
)	O
{	O
return	O
mu_config_container_register_section	function
(	O
&	O
root_container	pointer
,	O
parent_path	pointer
,	O
ident	pointer
,	O
label	pointer
,	O
parser	pointer
,	O
param	pointer
,	O
NULL	O
)	O
;	O
}	O
int	O
mu_config_register_plain_section	function
(	O
const	O
char	O
*	O
parent_path	pointer
,	O
const	O
char	O
*	O
ident	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
params	pointer
)	O
{	O
return	O
mu_config_root_register_section	function
(	O
parent_path	pointer
,	O
ident	pointer
,	O
NULL	O
,	O
NULL	O
,	O
params	pointer
)	O
;	O
}	O
struct	O
mu_cfg_cont	struct
*	O
mu_config_clone_root_container	function
(	O
void	O
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
root_container	pointer
;	O
mu_config_clone_container	function
(	O
cont	pointer
)	O
;	O
return	O
cont	pointer
;	O
}	O
static	O
struct	O
mu_cfg_cont	struct
*	O
mu_build_container	function
(	O
struct	O
mu_cfg_param	struct
*	O
param	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
mu_config_clone_root_container	function
(	O
)	O
;	O
mu_config_container_register_section	function
(	O
&	O
cont	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
param	pointer
,	O
NULL	O
)	O
;	O
return	O
cont	pointer
;	O
}	O
int	O
mu_cfg_tree_reduce	function
(	O
mu_cfg_tree_t	struct
*	O
parse_tree	pointer
,	O
struct	O
mu_cfg_parse_hints	struct
*	O
hints	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
progparam	pointer
,	O
void	O
*	O
target_ptr	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
;	O
if	O
(	O
!	O
parse_tree	pointer
)	O
return	O
0	int
;	O
if	O
(	O
hints	pointer
&&	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CF_DUMP	int
)	O
)	O
{	O
int	O
yes	int
=	O
1	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
mu_stdio_stream_create	function
(	O
&	O
stream	pointer
,	O
MU_STDERR_FD	int
,	O
0	int
)	O
;	O
mu_stream_ioctl	function
(	O
stream	pointer
,	O
MU_IOCTL_FD	int
,	O
MU_IOCTL_FD_SET_BORROW	int
,	O
&	O
yes	int
)	O
;	O
mu_cfg_format_parse_tree	function
(	O
stream	pointer
,	O
parse_tree	pointer
,	O
MU_CF_FMT_LOCUS	int
)	O
;	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
}	O
cont	pointer
=	O
mu_build_container	function
(	O
progparam	pointer
)	O
;	O
rc	int
=	O
mu_cfg_scan_tree	function
(	O
parse_tree	pointer
,	O
&	O
cont	pointer
->	O
v	pointer
.	O
section	struct
,	O
target_ptr	pointer
,	O
NULL	O
)	O
;	O
mu_config_destroy_container	function
(	O
&	O
cont	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
mu_format_config_tree	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
progparam	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
mu_build_container	function
(	O
progparam	pointer
)	O
;	O
mu_cfg_format_container	function
(	O
stream	pointer
,	O
cont	pointer
)	O
;	O
mu_config_destroy_container	function
(	O
&	O
cont	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
_first_value_ptr	function
(	O
mu_config_value_t	struct
*	O
val	array
)	O
{	O
switch	O
(	O
val	array
->	O
type	enum
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
return	O
val	array
->	O
v	pointer
.	O
string	pointer
;	O
case	O
MU_CFG_ARRAY	int
:	O
return	O
_first_value_ptr	function
(	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
)	O
;	O
case	O
MU_CFG_LIST	int
:	O
mu_list_get	function
(	O
val	array
->	O
v	pointer
.	O
list	pointer
,	O
0	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array
)	O
;	O
return	O
_first_value_ptr	function
(	O
val	array
)	O
;	O
}	O
return	O
""	pointer
;	O
}	O
int	O
mu_cfg_assert_value_type	function
(	O
mu_config_value_t	struct
*	O
val	array
,	O
int	O
type	enum
)	O
{	O
if	O
(	O
!	O
val	array
)	O
{	O
mu_error	function
(	O
_	O
(	O
"required argument missing"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
type	enum
==	O
MU_CFG_ARRAY	int
)	O
{	O
if	O
(	O
val	array
->	O
type	enum
==	O
MU_CFG_STRING	int
)	O
{	O
mu_config_value_t	struct
*	O
arr	pointer
=	O
mu_calloc	function
(	O
1	int
,	O
sizeof	O
arr	pointer
[	O
0	int
]	O
)	O
;	O
arr	pointer
[	O
0	int
]	O
=	O
*	O
val	array
;	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
c	char
=	O
1	int
;	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
=	O
arr	pointer
;	O
val	array
->	O
type	enum
=	O
MU_CFG_ARRAY	int
;	O
}	O
}	O
if	O
(	O
val	array
->	O
type	enum
!=	O
type	enum
)	O
{	O
mu_error	function
(	O
_	O
(	O
"unexpected value: %s"	pointer
)	O
,	O
_first_value_ptr	function
(	O
val	array
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_string_value_cb	function
(	O
mu_config_value_t	struct
*	O
val	array
,	O
int	O
(	O
*	O
fun	pointer
)	O
(	O
const	O
char	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
switch	O
(	O
val	array
->	O
type	enum
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
return	O
fun	pointer
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
data	pointer
)	O
;	O
break	O
;	O
case	O
MU_CFG_ARRAY	int
:	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
c	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
&	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	int
]	O
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
fun	pointer
(	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	int
]	O
.	O
v	pointer
.	O
string	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
MU_CFG_LIST	int
:	O
{	O
mu_iterator_t	pointer
itr	pointer
;	O
mu_list_get_iterator	function
(	O
val	array
->	O
v	pointer
.	O
list	pointer
,	O
&	O
itr	pointer
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
mu_config_value_t	struct
*	O
pval	pointer
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
(	O
void	O
*	O
)	O
&	O
pval	pointer
)	O
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
pval	pointer
,	O
MU_CFG_STRING	int
)	O
)	O
{	O
rc	int
=	O
1	int
;	O
break	O
;	O
}	O
fun	pointer
(	O
pval	pointer
->	O
v	pointer
.	O
string	pointer
,	O
data	pointer
)	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
struct	O
mapping_closure	struct
{	O
mu_assoc_t	pointer
assoc	pointer
;	O
char	O
*	O
err_term	pointer
;	O
}	O
;	O
static	O
int	O
parse_mapping_str	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mapping_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
char	O
const	O
*	O
str	pointer
=	O
item	pointer
;	O
size_t	long
len	int
;	O
char	O
*	O
key	pointer
,	O
*	O
val	array
;	O
int	O
rc	int
;	O
len	int
=	O
strcspn	function
(	O
str	pointer
,	O
"="	pointer
)	O
;	O
if	O
(	O
str	pointer
[	O
len	int
]	O
==	O
0	int
)	O
{	O
clos	pointer
->	O
err_term	pointer
=	O
mu_strdup	function
(	O
str	pointer
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
key	pointer
=	O
mu_alloc	function
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
key	pointer
,	O
str	pointer
,	O
len	int
)	O
;	O
key	pointer
[	O
len	int
]	O
=	O
0	int
;	O
val	array
=	O
mu_strdup	function
(	O
str	pointer
+	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
val	array
)	O
return	O
ENOMEM	int
;	O
rc	int
=	O
mu_assoc_install	function
(	O
clos	pointer
->	O
assoc	pointer
,	O
key	pointer
,	O
val	array
)	O
;	O
free	function
(	O
key	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
parse_mapping_val	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_config_value	struct
*	O
cval	pointer
=	O
item	pointer
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
cval	pointer
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
MU_ERR_PARSE	O
;	O
return	O
parse_mapping_str	function
(	O
(	O
void	O
*	O
)	O
cval	pointer
->	O
v	pointer
.	O
string	pointer
,	O
data	pointer
)	O
;	O
}	O
int	O
mu_cfg_field_map	function
(	O
struct	O
mu_config_value	struct
const	O
*	O
val	array
,	O
mu_assoc_t	pointer
*	O
passoc	pointer
,	O
char	O
*	O
*	O
err_term	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mapping_closure	struct
clos	pointer
;	O
mu_list_t	pointer
list	pointer
=	O
NULL	O
;	O
rc	int
=	O
mu_assoc_create	function
(	O
&	O
clos	pointer
.	O
assoc	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_assoc_set_destroy_item	function
(	O
clos	pointer
.	O
assoc	pointer
,	O
mu_list_free_item	function
)	O
;	O
clos	pointer
.	O
err_term	pointer
=	O
NULL	O
;	O
switch	O
(	O
val	array
->	O
type	enum
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
mu_list_create	function
(	O
&	O
list	pointer
)	O
;	O
mu_list_set_destroy_item	function
(	O
list	pointer
,	O
mu_list_free_item	function
)	O
;	O
rc	int
=	O
mu_string_split	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
":"	pointer
,	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
rc	int
=	O
mu_list_foreach	function
(	O
list	pointer
,	O
parse_mapping_str	function
,	O
&	O
clos	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
list	pointer
)	O
;	O
break	O
;	O
case	O
MU_CFG_LIST	int
:	O
rc	int
=	O
mu_list_foreach	function
(	O
val	array
->	O
v	pointer
.	O
list	pointer
,	O
parse_mapping_val	function
,	O
&	O
clos	pointer
)	O
;	O
break	O
;	O
case	O
MU_CFG_ARRAY	int
:	O
rc	int
=	O
EINVAL	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
rc	int
==	O
MU_ERR_PARSE	O
)	O
{	O
if	O
(	O
err_term	pointer
)	O
*	O
err_term	pointer
=	O
clos	pointer
.	O
err_term	pointer
;	O
else	O
free	function
(	O
clos	pointer
.	O
err_term	pointer
)	O
;	O
}	O
else	O
mu_error	function
(	O
"%s:%d: %s"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_assoc_destroy	function
(	O
&	O
clos	pointer
.	O
assoc	pointer
)	O
;	O
}	O
else	O
*	O
passoc	pointer
=	O
clos	pointer
.	O
assoc	pointer
;	O
return	O
rc	int
;	O
}	O
