typedef	O
struct	O
hash_entry	struct
{	O
unsigned	O
long	O
used	long
;	O
const	O
void	O
*	O
key	pointer
;	O
size_t	long
keylen	long
;	O
void	O
*	O
data	pointer
;	O
struct	O
hash_entry	struct
*	O
next	pointer
;	O
}	O
hash_entry	struct
;	O
static	O
int	O
is_prime	function
(	O
unsigned	O
long	O
int	O
candidate	long
)	O
{	O
unsigned	O
long	O
int	O
divn	long
=	O
3	int
;	O
unsigned	O
long	O
int	O
sq	long
=	O
divn	long
*	O
divn	long
;	O
while	O
(	O
sq	long
<	O
candidate	long
&&	O
candidate	long
%	O
divn	long
!=	O
0	int
)	O
{	O
++	O
divn	long
;	O
sq	long
+=	O
4	int
*	O
divn	long
;	O
++	O
divn	long
;	O
}	O
return	O
candidate	long
%	O
divn	long
!=	O
0	int
;	O
}	O
unsigned	O
long	O
next_prime	function
(	O
unsigned	O
long	O
int	O
seed	long
)	O
{	O
seed	long
|=	O
1	int
;	O
while	O
(	O
!	O
is_prime	function
(	O
seed	long
)	O
)	O
seed	long
+=	O
2	int
;	O
return	O
seed	long
;	O
}	O
int	O
hash_init	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
unsigned	O
long	O
int	O
init_size	long
)	O
{	O
init_size	long
=	O
next_prime	function
(	O
init_size	long
)	O
;	O
htab	pointer
->	O
size	long
=	O
init_size	long
;	O
htab	pointer
->	O
filled	long
=	O
0	int
;	O
htab	pointer
->	O
first	pointer
=	O
NULL	O
;	O
htab	pointer
->	O
table	pointer
=	O
XCALLOC	O
(	O
init_size	long
+	O
1	int
,	O
hash_entry	struct
)	O
;	O
obstack_init	O
(	O
&	O
htab	pointer
->	O
mem_pool	struct
)	O
;	O
return	O
0	int
;	O
}	O
int	O
hash_destroy	function
(	O
hash_table	struct
*	O
htab	pointer
)	O
{	O
free	function
(	O
htab	pointer
->	O
table	pointer
)	O
;	O
obstack_free	O
(	O
&	O
htab	pointer
->	O
mem_pool	struct
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
unsigned	O
long	O
compute_hashval	function
(	O
const	O
void	O
*	O
key	pointer
,	O
size_t	long
keylen	long
)	O
{	O
size_t	long
cnt	long
;	O
unsigned	O
long	O
int	O
hval	long
;	O
cnt	long
=	O
0	int
;	O
hval	long
=	O
keylen	long
;	O
while	O
(	O
cnt	long
<	O
keylen	long
)	O
{	O
hval	long
=	O
(	O
hval	long
<<	O
9	int
)	O
|	O
(	O
hval	long
>>	O
(	O
sizeof	O
(	O
unsigned	O
long	O
)	O
*	O
CHAR_BIT	O
-	O
9	int
)	O
)	O
;	O
hval	long
+=	O
(	O
unsigned	O
long	O
int	O
)	O
*	O
(	O
(	O
(	O
const	O
char	O
*	O
)	O
key	pointer
)	O
+	O
cnt	long
++	O
)	O
;	O
}	O
return	O
hval	long
!=	O
0	int
?	O
hval	long
:	O
~	O
(	O
(	O
unsigned	O
long	O
)	O
0	int
)	O
;	O
}	O
static	O
size_t	long
lookup	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	long
keylen	long
,	O
unsigned	O
long	O
int	O
hval	long
)	O
{	O
unsigned	O
long	O
int	O
hash	long
;	O
size_t	long
idx	long
;	O
hash_entry	struct
*	O
table	pointer
=	O
htab	pointer
->	O
table	pointer
;	O
hash	long
=	O
1	int
+	O
hval	long
%	O
htab	pointer
->	O
size	long
;	O
idx	long
=	O
hash	long
;	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
)	O
{	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
==	O
hval	long
&&	O
table	pointer
[	O
idx	long
]	O
.	O
keylen	long
==	O
keylen	long
&&	O
memcmp	function
(	O
table	pointer
[	O
idx	long
]	O
.	O
key	pointer
,	O
key	pointer
,	O
keylen	long
)	O
==	O
0	int
)	O
return	O
idx	long
;	O
hash	long
=	O
1	int
+	O
hval	long
%	O
(	O
htab	pointer
->	O
size	long
-	O
2	int
)	O
;	O
do	O
{	O
if	O
(	O
idx	long
<=	O
hash	long
)	O
idx	long
=	O
htab	pointer
->	O
size	long
+	O
idx	long
-	O
hash	long
;	O
else	O
idx	long
-=	O
hash	long
;	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
==	O
hval	long
&&	O
table	pointer
[	O
idx	long
]	O
.	O
keylen	long
==	O
keylen	long
&&	O
memcmp	function
(	O
table	pointer
[	O
idx	long
]	O
.	O
key	pointer
,	O
key	pointer
,	O
keylen	long
)	O
==	O
0	int
)	O
return	O
idx	long
;	O
}	O
while	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
)	O
;	O
}	O
return	O
idx	long
;	O
}	O
int	O
hash_find_entry	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	long
keylen	long
,	O
void	O
*	O
*	O
result	pointer
)	O
{	O
hash_entry	struct
*	O
table	pointer
=	O
htab	pointer
->	O
table	pointer
;	O
size_t	long
idx	long
=	O
lookup	function
(	O
htab	pointer
,	O
key	pointer
,	O
keylen	long
,	O
compute_hashval	function
(	O
key	pointer
,	O
keylen	long
)	O
)	O
;	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
*	O
result	pointer
=	O
table	pointer
[	O
idx	long
]	O
.	O
data	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
insert_entry_2	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	long
keylen	long
,	O
unsigned	O
long	O
int	O
hval	long
,	O
size_t	long
idx	long
,	O
void	O
*	O
data	pointer
)	O
{	O
hash_entry	struct
*	O
table	pointer
=	O
htab	pointer
->	O
table	pointer
;	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
=	O
hval	long
;	O
table	pointer
[	O
idx	long
]	O
.	O
key	pointer
=	O
key	pointer
;	O
table	pointer
[	O
idx	long
]	O
.	O
keylen	long
=	O
keylen	long
;	O
table	pointer
[	O
idx	long
]	O
.	O
data	pointer
=	O
data	pointer
;	O
if	O
(	O
htab	pointer
->	O
first	pointer
==	O
NULL	O
)	O
{	O
table	pointer
[	O
idx	long
]	O
.	O
next	pointer
=	O
&	O
table	pointer
[	O
idx	long
]	O
;	O
htab	pointer
->	O
first	pointer
=	O
&	O
table	pointer
[	O
idx	long
]	O
;	O
}	O
else	O
{	O
table	pointer
[	O
idx	long
]	O
.	O
next	pointer
=	O
htab	pointer
->	O
first	pointer
->	O
next	pointer
;	O
htab	pointer
->	O
first	pointer
->	O
next	pointer
=	O
&	O
table	pointer
[	O
idx	long
]	O
;	O
htab	pointer
->	O
first	pointer
=	O
&	O
table	pointer
[	O
idx	long
]	O
;	O
}	O
++	O
htab	pointer
->	O
filled	long
;	O
}	O
static	O
void	O
resize	function
(	O
hash_table	struct
*	O
htab	pointer
)	O
{	O
unsigned	O
long	O
int	O
old_size	long
=	O
htab	pointer
->	O
size	long
;	O
hash_entry	struct
*	O
table	pointer
=	O
htab	pointer
->	O
table	pointer
;	O
size_t	long
idx	long
;	O
htab	pointer
->	O
size	long
=	O
next_prime	function
(	O
htab	pointer
->	O
size	long
*	O
2	int
)	O
;	O
htab	pointer
->	O
filled	long
=	O
0	int
;	O
htab	pointer
->	O
first	pointer
=	O
NULL	O
;	O
htab	pointer
->	O
table	pointer
=	O
XCALLOC	O
(	O
1	int
+	O
htab	pointer
->	O
size	long
,	O
hash_entry	struct
)	O
;	O
for	O
(	O
idx	long
=	O
1	int
;	O
idx	long
<=	O
old_size	long
;	O
++	O
idx	long
)	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
)	O
insert_entry_2	function
(	O
htab	pointer
,	O
table	pointer
[	O
idx	long
]	O
.	O
key	pointer
,	O
table	pointer
[	O
idx	long
]	O
.	O
keylen	long
,	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
,	O
lookup	function
(	O
htab	pointer
,	O
table	pointer
[	O
idx	long
]	O
.	O
key	pointer
,	O
table	pointer
[	O
idx	long
]	O
.	O
keylen	long
,	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
)	O
,	O
table	pointer
[	O
idx	long
]	O
.	O
data	pointer
)	O
;	O
free	function
(	O
table	pointer
)	O
;	O
}	O
const	O
void	O
*	O
hash_insert_entry	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	long
keylen	long
,	O
void	O
*	O
data	pointer
)	O
{	O
unsigned	O
long	O
int	O
hval	long
=	O
compute_hashval	function
(	O
key	pointer
,	O
keylen	long
)	O
;	O
hash_entry	struct
*	O
table	pointer
=	O
htab	pointer
->	O
table	pointer
;	O
size_t	long
idx	long
=	O
lookup	function
(	O
htab	pointer
,	O
key	pointer
,	O
keylen	long
,	O
hval	long
)	O
;	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
)	O
return	O
NULL	O
;	O
else	O
{	O
void	O
*	O
keycopy	pointer
=	O
obstack_copy	O
(	O
&	O
htab	pointer
->	O
mem_pool	struct
,	O
key	pointer
,	O
keylen	long
)	O
;	O
insert_entry_2	function
(	O
htab	pointer
,	O
keycopy	pointer
,	O
keylen	long
,	O
hval	long
,	O
idx	long
,	O
data	pointer
)	O
;	O
if	O
(	O
100	int
*	O
htab	pointer
->	O
filled	long
>	O
75	int
*	O
htab	pointer
->	O
size	long
)	O
resize	function
(	O
htab	pointer
)	O
;	O
return	O
keycopy	pointer
;	O
}	O
}	O
int	O
hash_set_value	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	long
keylen	long
,	O
void	O
*	O
data	pointer
)	O
{	O
unsigned	O
long	O
int	O
hval	long
=	O
compute_hashval	function
(	O
key	pointer
,	O
keylen	long
)	O
;	O
hash_entry	struct
*	O
table	pointer
=	O
htab	pointer
->	O
table	pointer
;	O
size_t	long
idx	long
=	O
lookup	function
(	O
htab	pointer
,	O
key	pointer
,	O
keylen	long
,	O
hval	long
)	O
;	O
if	O
(	O
table	pointer
[	O
idx	long
]	O
.	O
used	long
)	O
{	O
table	pointer
[	O
idx	long
]	O
.	O
data	pointer
=	O
data	pointer
;	O
return	O
0	int
;	O
}	O
else	O
{	O
void	O
*	O
keycopy	pointer
=	O
obstack_copy	O
(	O
&	O
htab	pointer
->	O
mem_pool	struct
,	O
key	pointer
,	O
keylen	long
)	O
;	O
insert_entry_2	function
(	O
htab	pointer
,	O
keycopy	pointer
,	O
keylen	long
,	O
hval	long
,	O
idx	long
,	O
data	pointer
)	O
;	O
if	O
(	O
100	int
*	O
htab	pointer
->	O
filled	long
>	O
75	int
*	O
htab	pointer
->	O
size	long
)	O
resize	function
(	O
htab	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
int	O
hash_iterate	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
void	O
*	O
*	O
ptr	pointer
,	O
const	O
void	O
*	O
*	O
key	pointer
,	O
size_t	long
*	O
keylen	long
,	O
void	O
*	O
*	O
data	pointer
)	O
{	O
hash_entry	struct
*	O
curr	pointer
;	O
if	O
(	O
*	O
ptr	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
htab	pointer
->	O
first	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
curr	pointer
=	O
htab	pointer
->	O
first	pointer
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr	pointer
==	O
htab	pointer
->	O
first	pointer
)	O
return	O
-	O
1	int
;	O
curr	pointer
=	O
(	O
hash_entry	struct
*	O
)	O
*	O
ptr	pointer
;	O
}	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
*	O
ptr	pointer
=	O
(	O
void	O
*	O
)	O
curr	pointer
;	O
*	O
key	pointer
=	O
curr	pointer
->	O
key	pointer
;	O
*	O
keylen	long
=	O
curr	pointer
->	O
keylen	long
;	O
*	O
data	pointer
=	O
curr	pointer
->	O
data	pointer
;	O
return	O
0	int
;	O
}	O
int	O
hash_iterate_modify	function
(	O
hash_table	struct
*	O
htab	pointer
,	O
void	O
*	O
*	O
ptr	pointer
,	O
const	O
void	O
*	O
*	O
key	pointer
,	O
size_t	long
*	O
keylen	long
,	O
void	O
*	O
*	O
*	O
datap	pointer
)	O
{	O
hash_entry	struct
*	O
curr	pointer
;	O
if	O
(	O
*	O
ptr	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
htab	pointer
->	O
first	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
curr	pointer
=	O
htab	pointer
->	O
first	pointer
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr	pointer
==	O
htab	pointer
->	O
first	pointer
)	O
return	O
-	O
1	int
;	O
curr	pointer
=	O
(	O
hash_entry	struct
*	O
)	O
*	O
ptr	pointer
;	O
}	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
*	O
ptr	pointer
=	O
(	O
void	O
*	O
)	O
curr	pointer
;	O
*	O
key	pointer
=	O
curr	pointer
->	O
key	pointer
;	O
*	O
keylen	long
=	O
curr	pointer
->	O
keylen	long
;	O
*	O
datap	pointer
=	O
&	O
curr	pointer
->	O
data	pointer
;	O
return	O
0	int
;	O
}	O
