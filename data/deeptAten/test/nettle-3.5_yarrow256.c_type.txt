static	O
void	O
yarrow_gate	function
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
)	O
;	O
void	O
yarrow256_init	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
,	O
unsigned	O
n	int
,	O
struct	O
yarrow_source	struct
*	O
s	pointer
)	O
{	O
unsigned	O
i	int
;	O
sha256_init	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
0	int
]	O
)	O
;	O
sha256_init	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
1	int
]	O
)	O
;	O
ctx	pointer
->	O
seeded	int
=	O
0	int
;	O
memset	function
(	O
ctx	pointer
->	O
counter	array
,	O
0	int
,	O
sizeof	O
(	O
ctx	pointer
->	O
counter	array
)	O
)	O
;	O
ctx	pointer
->	O
nsources	int
=	O
n	int
;	O
ctx	pointer
->	O
sources	pointer
=	O
s	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
ctx	pointer
->	O
sources	pointer
[	O
i	int
]	O
.	O
estimate	array
[	O
YARROW_FAST	int
]	O
=	O
0	int
;	O
ctx	pointer
->	O
sources	pointer
[	O
i	int
]	O
.	O
estimate	array
[	O
YARROW_SLOW	int
]	O
=	O
0	int
;	O
ctx	pointer
->	O
sources	pointer
[	O
i	int
]	O
.	O
next	enum
=	O
YARROW_FAST	int
;	O
}	O
}	O
void	O
yarrow256_seed	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
seed_file	pointer
)	O
{	O
assert	O
(	O
length	long
>	O
0	int
)	O
;	O
sha256_update	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
YARROW_FAST	int
]	O
,	O
length	long
,	O
seed_file	pointer
)	O
;	O
yarrow256_fast_reseed	O
(	O
ctx	pointer
)	O
;	O
}	O
static	O
void	O
yarrow_generate_block	function
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
,	O
uint8_t	char
*	O
block	array
)	O
{	O
unsigned	O
i	int
;	O
aes256_encrypt	O
(	O
&	O
ctx	pointer
->	O
key	pointer
,	O
sizeof	O
(	O
ctx	pointer
->	O
counter	array
)	O
,	O
block	array
,	O
ctx	pointer
->	O
counter	array
)	O
;	O
for	O
(	O
i	int
=	O
sizeof	O
(	O
ctx	pointer
->	O
counter	array
)	O
;	O
i	int
--	O
;	O
)	O
{	O
if	O
(	O
++	O
ctx	pointer
->	O
counter	array
[	O
i	int
]	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
yarrow_iterate	function
(	O
uint8_t	char
*	O
digest	pointer
)	O
{	O
uint8_t	char
v0	array
[	O
SHA256_DIGEST_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
memcpy	function
(	O
v0	array
,	O
digest	pointer
,	O
SHA256_DIGEST_SIZE	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
++	O
i	int
<	O
YARROW_RESEED_ITERATIONS	int
;	O
)	O
{	O
uint8_t	char
count	long
[	O
4	int
]	O
;	O
struct	O
sha256_ctx	struct
hash	struct
;	O
sha256_init	O
(	O
&	O
hash	struct
)	O
;	O
WRITE_UINT32	O
(	O
count	long
,	O
i	int
)	O
;	O
sha256_update	O
(	O
&	O
hash	struct
,	O
SHA256_DIGEST_SIZE	int
,	O
digest	pointer
)	O
;	O
sha256_update	O
(	O
&	O
hash	struct
,	O
sizeof	O
(	O
v0	array
)	O
,	O
v0	array
)	O
;	O
sha256_update	O
(	O
&	O
hash	struct
,	O
sizeof	O
(	O
count	long
)	O
,	O
count	long
)	O
;	O
sha256_digest	O
(	O
&	O
hash	struct
,	O
SHA256_DIGEST_SIZE	int
,	O
digest	pointer
)	O
;	O
}	O
}	O
void	O
yarrow256_fast_reseed	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
)	O
{	O
uint8_t	char
digest	pointer
[	O
SHA256_DIGEST_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
if	O
(	O
ctx	pointer
->	O
seeded	int
)	O
{	O
uint8_t	char
blocks	array
[	O
AES_BLOCK_SIZE	int
*	O
2	int
]	O
;	O
yarrow_generate_block	function
(	O
ctx	pointer
,	O
blocks	array
)	O
;	O
yarrow_generate_block	function
(	O
ctx	pointer
,	O
blocks	array
+	O
AES_BLOCK_SIZE	int
)	O
;	O
sha256_update	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
YARROW_FAST	int
]	O
,	O
sizeof	O
(	O
blocks	array
)	O
,	O
blocks	array
)	O
;	O
}	O
sha256_digest	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
YARROW_FAST	int
]	O
,	O
sizeof	O
(	O
digest	pointer
)	O
,	O
digest	pointer
)	O
;	O
yarrow_iterate	function
(	O
digest	pointer
)	O
;	O
aes256_set_encrypt_key	O
(	O
&	O
ctx	pointer
->	O
key	pointer
,	O
digest	pointer
)	O
;	O
ctx	pointer
->	O
seeded	int
=	O
1	int
;	O
memset	function
(	O
ctx	pointer
->	O
counter	array
,	O
0	int
,	O
sizeof	O
(	O
ctx	pointer
->	O
counter	array
)	O
)	O
;	O
aes256_encrypt	O
(	O
&	O
ctx	pointer
->	O
key	pointer
,	O
sizeof	O
(	O
ctx	pointer
->	O
counter	array
)	O
,	O
ctx	pointer
->	O
counter	array
,	O
ctx	pointer
->	O
counter	array
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ctx	pointer
->	O
nsources	int
;	O
i	int
++	O
)	O
ctx	pointer
->	O
sources	pointer
[	O
i	int
]	O
.	O
estimate	array
[	O
YARROW_FAST	int
]	O
=	O
0	int
;	O
}	O
void	O
yarrow256_slow_reseed	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
)	O
{	O
uint8_t	char
digest	pointer
[	O
SHA256_DIGEST_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
sha256_digest	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
YARROW_SLOW	int
]	O
,	O
sizeof	O
(	O
digest	pointer
)	O
,	O
digest	pointer
)	O
;	O
sha256_update	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
YARROW_FAST	int
]	O
,	O
sizeof	O
(	O
digest	pointer
)	O
,	O
digest	pointer
)	O
;	O
yarrow256_fast_reseed	O
(	O
ctx	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ctx	pointer
->	O
nsources	int
;	O
i	int
++	O
)	O
ctx	pointer
->	O
sources	pointer
[	O
i	int
]	O
.	O
estimate	array
[	O
YARROW_SLOW	int
]	O
=	O
0	int
;	O
}	O
int	O
yarrow256_update	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
,	O
unsigned	O
source_index	int
,	O
unsigned	O
entropy	int
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	pointer
)	O
{	O
enum	O
yarrow_pool_id	enum
current	enum
;	O
struct	O
yarrow_source	struct
*	O
source	int
;	O
assert	O
(	O
source_index	int
<	O
ctx	pointer
->	O
nsources	int
)	O
;	O
if	O
(	O
!	O
length	long
)	O
return	O
0	int
;	O
source	int
=	O
&	O
ctx	pointer
->	O
sources	pointer
[	O
source_index	int
]	O
;	O
if	O
(	O
!	O
ctx	pointer
->	O
seeded	int
)	O
current	enum
=	O
YARROW_SLOW	int
;	O
else	O
{	O
current	enum
=	O
source	int
->	O
next	enum
;	O
source	int
->	O
next	enum
=	O
!	O
source	int
->	O
next	enum
;	O
}	O
sha256_update	O
(	O
&	O
ctx	pointer
->	O
pools	array
[	O
current	enum
]	O
,	O
length	long
,	O
data	pointer
)	O
;	O
if	O
(	O
source	int
->	O
estimate	array
[	O
current	enum
]	O
<	O
YARROW_MAX_ENTROPY	int
)	O
{	O
if	O
(	O
entropy	int
>	O
YARROW_MAX_ENTROPY	int
)	O
entropy	int
=	O
YARROW_MAX_ENTROPY	int
;	O
if	O
(	O
(	O
length	long
<	O
(	O
YARROW_MAX_ENTROPY	int
/	O
YARROW_MULTIPLIER	int
)	O
)	O
&&	O
(	O
entropy	int
>	O
YARROW_MULTIPLIER	int
*	O
length	long
)	O
)	O
entropy	int
=	O
YARROW_MULTIPLIER	int
*	O
length	long
;	O
entropy	int
+=	O
source	int
->	O
estimate	array
[	O
current	enum
]	O
;	O
if	O
(	O
entropy	int
>	O
YARROW_MAX_ENTROPY	int
)	O
entropy	int
=	O
YARROW_MAX_ENTROPY	int
;	O
source	int
->	O
estimate	array
[	O
current	enum
]	O
=	O
entropy	int
;	O
}	O
switch	O
(	O
current	enum
)	O
{	O
case	O
YARROW_FAST	int
:	O
if	O
(	O
source	int
->	O
estimate	array
[	O
YARROW_FAST	int
]	O
>=	O
YARROW_FAST_THRESHOLD	int
)	O
{	O
yarrow256_fast_reseed	O
(	O
ctx	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
case	O
YARROW_SLOW	int
:	O
{	O
if	O
(	O
!	O
yarrow256_needed_sources	O
(	O
ctx	pointer
)	O
)	O
{	O
yarrow256_slow_reseed	O
(	O
ctx	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
yarrow_gate	function
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
)	O
{	O
uint8_t	char
key	pointer
[	O
AES256_KEY_SIZE	int
]	O
;	O
unsigned	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
key	pointer
)	O
;	O
i	int
+=	O
AES_BLOCK_SIZE	int
)	O
yarrow_generate_block	function
(	O
ctx	pointer
,	O
key	pointer
+	O
i	int
)	O
;	O
aes256_set_encrypt_key	O
(	O
&	O
ctx	pointer
->	O
key	pointer
,	O
key	pointer
)	O
;	O
}	O
void	O
yarrow256_random	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	pointer
)	O
{	O
assert	O
(	O
ctx	pointer
->	O
seeded	int
)	O
;	O
while	O
(	O
length	long
>=	O
AES_BLOCK_SIZE	int
)	O
{	O
yarrow_generate_block	function
(	O
ctx	pointer
,	O
dst	pointer
)	O
;	O
dst	pointer
+=	O
AES_BLOCK_SIZE	int
;	O
length	long
-=	O
AES_BLOCK_SIZE	int
;	O
}	O
if	O
(	O
length	long
)	O
{	O
uint8_t	char
buffer	array
[	O
AES_BLOCK_SIZE	int
]	O
;	O
assert	O
(	O
length	long
<	O
AES_BLOCK_SIZE	int
)	O
;	O
yarrow_generate_block	function
(	O
ctx	pointer
,	O
buffer	array
)	O
;	O
memcpy	function
(	O
dst	pointer
,	O
buffer	array
,	O
length	long
)	O
;	O
}	O
yarrow_gate	function
(	O
ctx	pointer
)	O
;	O
}	O
int	O
yarrow256_is_seeded	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
)	O
{	O
return	O
ctx	pointer
->	O
seeded	int
;	O
}	O
unsigned	O
yarrow256_needed_sources	O
(	O
struct	O
yarrow256_ctx	struct
*	O
ctx	pointer
)	O
{	O
unsigned	O
k	int
,	O
i	int
;	O
for	O
(	O
i	int
=	O
k	int
=	O
0	int
;	O
i	int
<	O
ctx	pointer
->	O
nsources	int
;	O
i	int
++	O
)	O
if	O
(	O
ctx	pointer
->	O
sources	pointer
[	O
i	int
]	O
.	O
estimate	array
[	O
YARROW_SLOW	int
]	O
>=	O
YARROW_SLOW_THRESHOLD	int
)	O
k	int
++	O
;	O
return	O
(	O
k	int
<	O
YARROW_SLOW_K	int
)	O
?	O
(	O
YARROW_SLOW_K	int
-	O
k	int
)	O
:	O
0	int
;	O
}	O
