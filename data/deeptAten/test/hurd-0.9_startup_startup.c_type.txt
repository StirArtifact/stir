static	O
int	O
crash_flags	int
=	O
RB_AUTOBOOT	O
;	O
static	O
int	O
verbose	int
=	O
0	int
;	O
const	O
char	O
*	O
argp_program_version	pointer
=	O
STANDARD_HURD_VERSION	function
(	O
startup	int
)	O
;	O
static	O
struct	O
argp_option	O
options	int
[	O
]	O
=	O
{	O
{	O
"single-user"	pointer
,	O
's'	O
,	O
0	int
,	O
0	int
,	O
"Startup system in single-user mode"	pointer
}	O
,	O
{	O
"query"	pointer
,	O
'q'	O
,	O
0	int
,	O
0	int
,	O
"Ask for the names of servers to start"	pointer
}	O
,	O
{	O
"init-name"	pointer
,	O
'n'	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"crash-debug"	pointer
,	O
'H'	O
,	O
0	int
,	O
0	int
,	O
"On system crash, go to kernel debugger"	pointer
}	O
,	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"fake-boot"	pointer
,	O
'f'	O
,	O
0	int
,	O
0	int
,	O
"This hurd hasn't been booted on the raw machine"	pointer
}	O
,	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
0	int
,	O
0	int
,	O
"be verbose"	pointer
}	O
,	O
{	O
0	int
,	O
'x'	O
,	O
0	int
,	O
OPTION_HIDDEN	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
char	O
doc	array
[	O
]	O
=	O
"Start and maintain hurd core servers and system run state"	pointer
;	O
static	O
int	O
booted	int
;	O
struct	O
ntfy_task	struct
{	O
mach_port_t	O
notify_port	int
;	O
struct	O
ntfy_task	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
}	O
;	O
struct	O
ess_task	struct
{	O
struct	O
ess_task	struct
*	O
next	pointer
;	O
task_t	O
task_port	int
;	O
char	O
*	O
name	pointer
;	O
}	O
;	O
static	O
struct	O
ess_task	struct
*	O
ess_tasks	pointer
;	O
static	O
struct	O
ntfy_task	struct
*	O
ntfy_tasks	pointer
;	O
static	O
mach_port_t	O
startup	int
;	O
static	O
mach_port_t	O
host_priv	int
,	O
device_master	O
;	O
static	O
int	O
bootstrap_args	int
=	O
0	int
;	O
static	O
mach_port_t	O
procreply	int
,	O
authreply	O
;	O
static	O
mach_msg_type_name_t	O
procreplytype	int
,	O
authreplytype	O
;	O
static	O
mach_port_t	O
authserver	int
;	O
static	O
mach_port_t	O
procserver	int
;	O
static	O
mach_port_t	O
bootport	int
;	O
static	O
int	O
fakeboot	int
;	O
static	O
task_t	O
authtask	int
,	O
proctask	O
,	O
fstask	O
;	O
static	O
mach_port_t	O
default_ports	int
[	O
INIT_PORT_MAX	O
]	O
;	O
static	O
mach_port_t	O
default_dtable	array
[	O
3	int
]	O
;	O
static	O
int	O
default_ints	int
[	O
INIT_INT_MAX	O
]	O
;	O
static	O
char	O
*	O
*	O
global_argv	pointer
;	O
static	O
char	O
*	O
startup_envz	pointer
;	O
static	O
size_t	O
startup_envz_len	int
;	O
void	O
launch_system	function
(	O
void	O
)	O
;	O
void	O
process_signal	function
(	O
int	O
signo	int
)	O
;	O
static	O
int	O
getstring	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	O
bufsize	int
)	O
{	O
if	O
(	O
fgets	function
(	O
buf	pointer
,	O
bufsize	int
,	O
stdin	O
)	O
!=	O
NULL	O
&&	O
buf	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
size_t	O
len	pointer
=	O
strlen	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
buf	pointer
[	O
len	pointer
-	O
1	int
]	O
==	O
'\n'	O
||	O
buf	pointer
[	O
len	pointer
-	O
1	int
]	O
==	O
'\r'	O
)	O
buf	pointer
[	O
len	pointer
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
reboot_mach	function
(	O
int	O
flags	int
)	O
{	O
if	O
(	O
fakeboot	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: Would %s Mach with flags %#x\n"	pointer
,	O
program_invocation_short_name	O
,	O
BOOT	O
(	O
flags	int
)	O
,	O
flags	int
)	O
;	O
exit	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
error_t	O
err	int
;	O
fprintf	function
(	O
stderr	O
,	O
"%s: %sing Mach (flags %#x)...\n"	pointer
,	O
program_invocation_short_name	O
,	O
BOOT	O
(	O
flags	int
)	O
,	O
flags	int
)	O
;	O
sleep	function
(	O
5	int
)	O
;	O
while	O
(	O
(	O
err	int
=	O
host_reboot	function
(	O
host_priv	int
,	O
flags	int
)	O
)	O
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"reboot"	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
;	O
}	O
}	O
void	O
crash_mach	function
(	O
void	O
)	O
{	O
reboot_mach	function
(	O
crash_flags	int
)	O
;	O
}	O
void	O
notify_shutdown	function
(	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
struct	O
ntfy_task	struct
*	O
n	pointer
;	O
for	O
(	O
n	pointer
=	O
ntfy_tasks	pointer
;	O
n	pointer
!=	O
NULL	O
;	O
n	pointer
=	O
n	pointer
->	O
next	pointer
)	O
{	O
error_t	O
err	int
;	O
fprintf	function
(	O
stderr	O
,	O
"%s: notifying %s of %s..."	pointer
,	O
program_invocation_short_name	O
,	O
n	pointer
->	O
name	pointer
,	O
msg	pointer
)	O
;	O
err	int
=	O
startup_dosync	function
(	O
n	pointer
->	O
notify_port	int
,	O
60000	int
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
fprintf	function
(	O
stderr	O
,	O
"(no longer present)\n"	pointer
)	O
;	O
else	O
if	O
(	O
err	int
)	O
fprintf	function
(	O
stderr	O
,	O
"%s\n"	pointer
,	O
strerror	O
(	O
err	int
)	O
)	O
;	O
else	O
fprintf	function
(	O
stderr	O
,	O
"done\n"	pointer
)	O
;	O
}	O
}	O
void	O
reboot_system	function
(	O
int	O
flags	int
)	O
{	O
notify_shutdown	function
(	O
BOOT	O
(	O
flags	int
)	O
)	O
;	O
if	O
(	O
fakeboot	int
)	O
{	O
pid_t	O
*	O
pp	O
;	O
size_t	O
npids	O
=	O
0	int
;	O
error_t	O
err	int
;	O
int	O
ind	int
;	O
err	int
=	O
proc_getallpids	function
(	O
procserver	int
,	O
&	O
pp	O
,	O
&	O
npids	O
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
procbad	O
:	O
error	function
(	O
0	int
,	O
0	int
,	O
"Can't simulate crash; proc has died"	pointer
)	O
;	O
reboot_mach	function
(	O
flags	int
)	O
;	O
}	O
for	O
(	O
ind	int
=	O
0	int
;	O
ind	int
<	O
npids	O
;	O
ind	int
++	O
)	O
{	O
task_t	O
task	int
;	O
err	int
=	O
proc_pid2task	function
(	O
procserver	int
,	O
pp	O
[	O
ind	int
]	O
,	O
&	O
task	int
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
goto	O
procbad	O
;	O
else	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"Getting task for pid %d"	pointer
,	O
pp	O
[	O
ind	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
task	int
!=	O
mach_task_self	function
(	O
)	O
&&	O
task	int
!=	O
proctask	O
)	O
{	O
struct	O
procinfo	O
*	O
pi	pointer
=	O
0	int
;	O
size_t	O
pisize	O
=	O
0	int
;	O
char	O
*	O
noise	pointer
;	O
size_t	O
noise_len	O
=	O
0	int
;	O
int	O
flags	int
;	O
err	int
=	O
proc_getprocinfo	function
(	O
procserver	int
,	O
pp	O
[	O
ind	int
]	O
,	O
&	O
flags	int
,	O
(	O
int	O
*	O
*	O
)	O
&	O
pi	pointer
,	O
&	O
pisize	O
,	O
&	O
noise	pointer
,	O
&	O
noise_len	O
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
goto	O
procbad	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"Getting procinfo for pid %d"	pointer
,	O
pp	O
[	O
ind	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
(	O
pi	pointer
->	O
state	pointer
&	O
PI_NOPARENT	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: Killing pid %d\n"	pointer
,	O
program_invocation_short_name	O
,	O
pp	O
[	O
ind	int
]	O
)	O
;	O
task_terminate	function
(	O
task	int
)	O
;	O
}	O
if	O
(	O
noise_len	O
>	O
0	int
)	O
munmap	function
(	O
noise	pointer
,	O
noise_len	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
stderr	O
,	O
"%s: Killing proc server\n"	pointer
,	O
program_invocation_short_name	O
)	O
;	O
task_terminate	function
(	O
proctask	O
)	O
;	O
fprintf	function
(	O
stderr	O
,	O
"%s: Exiting"	pointer
,	O
program_invocation_short_name	O
)	O
;	O
}	O
reboot_mach	function
(	O
flags	int
)	O
;	O
}	O
void	O
crash_system	function
(	O
void	O
)	O
{	O
reboot_system	function
(	O
crash_flags	int
)	O
;	O
}	O
static	O
void	O
request_dead_name	function
(	O
mach_port_t	O
name	pointer
)	O
{	O
mach_port_t	O
prev	O
;	O
mach_port_request_notification	function
(	O
mach_task_self	function
(	O
)	O
,	O
name	pointer
,	O
MACH_NOTIFY_DEAD_NAME	O
,	O
1	int
,	O
startup	int
,	O
MACH_MSG_TYPE_MAKE_SEND_ONCE	O
,	O
&	O
prev	O
)	O
;	O
if	O
(	O
prev	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
prev	O
)	O
;	O
}	O
static	O
error_t	O
record_essential_task	function
(	O
const	O
char	O
*	O
name	pointer
,	O
task_t	O
task	int
)	O
{	O
struct	O
ess_task	struct
*	O
et	pointer
;	O
et	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
ess_task	struct
)	O
)	O
;	O
if	O
(	O
et	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
et	pointer
->	O
task_port	int
=	O
task	int
;	O
et	pointer
->	O
name	pointer
=	O
strdup	O
(	O
name	pointer
)	O
;	O
if	O
(	O
et	pointer
->	O
name	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
et	pointer
)	O
;	O
return	O
ENOMEM	O
;	O
}	O
et	pointer
->	O
next	pointer
=	O
ess_tasks	pointer
;	O
ess_tasks	pointer
=	O
et	pointer
;	O
request_dead_name	function
(	O
task	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
run	function
(	O
const	O
char	O
*	O
server	pointer
,	O
mach_port_t	O
*	O
ports	pointer
,	O
task_t	O
*	O
task	int
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	O
]	O
;	O
const	O
char	O
*	O
prog	pointer
=	O
server	pointer
;	O
if	O
(	O
bootstrap_args	int
&	O
RB_INITNAME	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Server file name (default %s): "	pointer
,	O
server	pointer
)	O
;	O
if	O
(	O
getstring	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
prog	pointer
=	O
buf	pointer
;	O
}	O
while	O
(	O
1	int
)	O
{	O
file_t	O
file	O
;	O
error_t	O
err	int
;	O
file	O
=	O
file_name_lookup	function
(	O
prog	pointer
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
prog	pointer
)	O
;	O
else	O
{	O
task_create	function
(	O
mach_task_self	function
(	O
)	O
,	O
0	int
,	O
task	int
)	O
;	O
if	O
(	O
bootstrap_args	int
&	O
RB_KDB	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Pausing for %s\n"	pointer
,	O
prog	pointer
)	O
;	O
getchar	function
(	O
)	O
;	O
}	O
err	int
=	O
file_exec	function
(	O
file	O
,	O
*	O
task	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
prog	pointer
,	O
strlen	O
(	O
prog	pointer
)	O
+	O
1	int
,	O
startup_envz	pointer
,	O
startup_envz_len	int
,	O
default_dtable	array
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
3	int
,	O
ports	pointer
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
default_ints	int
,	O
INIT_INT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
break	O
;	O
error	function
(	O
0	int
,	O
err	int
,	O
"%s"	pointer
,	O
prog	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	O
,	O
"File name for server %s (or nothing to reboot): "	pointer
,	O
server	pointer
)	O
;	O
if	O
(	O
getstring	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
prog	pointer
=	O
buf	pointer
;	O
else	O
crash_system	function
(	O
)	O
;	O
}	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"started %s\n"	pointer
,	O
prog	pointer
)	O
;	O
request_dead_name	function
(	O
*	O
task	int
)	O
;	O
}	O
pid_t	O
run_for_real	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
args	pointer
,	O
int	O
arglen	int
,	O
mach_port_t	O
ctty	int
,	O
int	O
setsid	int
)	O
{	O
file_t	O
file	O
;	O
error_t	O
err	int
;	O
task_t	O
task	int
;	O
char	O
*	O
progname	pointer
;	O
int	O
pid	int
;	O
file	O
=	O
file_name_lookup	function
(	O
filename	pointer
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
task_create	function
(	O
mach_task_self	function
(	O
)	O
,	O
0	int
,	O
&	O
task	int
)	O
;	O
proc_child	function
(	O
procserver	int
,	O
task	int
)	O
;	O
proc_task2pid	function
(	O
procserver	int
,	O
task	int
,	O
&	O
pid	int
)	O
;	O
proc_task2proc	function
(	O
procserver	int
,	O
task	int
,	O
&	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
proc_mark_exec	function
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
if	O
(	O
setsid	int
)	O
proc_setsid	function
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
if	O
(	O
ctty	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
term_getctty	function
(	O
ctty	int
,	O
&	O
default_ports	int
[	O
INIT_PORT_CTTYID	O
]	O
)	O
;	O
io_mod_owner	function
(	O
ctty	int
,	O
-	O
pid	int
)	O
;	O
proc_make_login_coll	function
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
}	O
if	O
(	O
bootstrap_args	int
&	O
RB_KDB	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Pausing for %s\n"	pointer
,	O
filename	pointer
)	O
;	O
getchar	function
(	O
)	O
;	O
}	O
progname	pointer
=	O
strrchr	O
(	O
filename	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
progname	pointer
)	O
++	O
progname	pointer
;	O
else	O
progname	pointer
=	O
filename	pointer
;	O
err	int
=	O
file_exec	function
(	O
file	O
,	O
task	int
,	O
0	int
,	O
args	pointer
,	O
arglen	int
,	O
startup_envz	pointer
,	O
startup_envz_len	int
,	O
default_dtable	array
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
3	int
,	O
default_ports	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
default_ints	int
,	O
INIT_INT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
task	int
)	O
;	O
if	O
(	O
ctty	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
default_ports	int
[	O
INIT_PORT_CTTYID	O
]	O
)	O
;	O
default_ports	int
[	O
INIT_PORT_CTTYID	O
]	O
=	O
MACH_PORT_NULL	O
;	O
}	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
file	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"Cannot execute %s"	pointer
,	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
pid	int
;	O
}	O
static	O
void	O
mig_reply_setup	function
(	O
const	O
mach_msg_header_t	O
*	O
in	pointer
,	O
mach_msg_header_t	O
*	O
out	pointer
)	O
{	O
static	O
const	O
mach_msg_type_t	O
RetCodeType	int
=	O
{	O
MACH_MSG_TYPE_INTEGER_32	O
,	O
32	int
,	O
1	int
,	O
TRUE	O
,	O
FALSE	O
,	O
FALSE	O
,	O
0	int
}	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_bits	O
=	O
MACH_MSGH_BITS	function
(	O
MACH_MSGH_BITS_REMOTE	function
(	O
InP	O
->	O
msgh_bits	O
)	O
,	O
0	int
)	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_size	O
=	O
sizeof	O
*	O
OutP	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_remote_port	O
=	O
InP	O
->	O
msgh_remote_port	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_local_port	O
=	O
MACH_PORT_NULL	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_seqno	O
=	O
0	int
;	O
OutP	O
->	O
Head	O
.	O
msgh_id	O
=	O
InP	O
->	O
msgh_id	O
+	O
100	int
;	O
OutP	O
->	O
RetCodeType	int
=	O
RetCodeType	int
;	O
OutP	O
->	O
RetCode	O
=	O
MIG_BAD_ID	O
;	O
}	O
static	O
int	O
demuxer	function
(	O
mach_msg_header_t	O
*	O
inp	pointer
,	O
mach_msg_header_t	O
*	O
outp	pointer
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
verbose	int
>	O
1	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
"%d"	pointer
,	O
inp	pointer
->	O
msgh_id	O
)	O
;	O
mig_reply_setup	function
(	O
inp	pointer
,	O
outp	pointer
)	O
;	O
if	O
(	O
(	O
routine	O
=	O
notify_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
msg_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
fsys_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
fs_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
io_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
startup_server_routine	function
(	O
inp	pointer
)	O
)	O
)	O
{	O
(	O
*	O
routine	O
)	O
(	O
inp	pointer
,	O
outp	pointer
)	O
;	O
if	O
(	O
verbose	int
>	O
1	int
)	O
error	function
(	O
0	int
,	O
(	O
(	O
mig_reply_header_t	O
*	O
)	O
outp	pointer
)	O
->	O
RetCode	O
,	O
"%d"	pointer
,	O
inp	pointer
->	O
msgh_id	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
error_t	O
install_as_translator	function
(	O
void	O
)	O
{	O
error_t	O
err	int
;	O
file_t	O
node	O
;	O
node	O
=	O
file_name_lookup	function
(	O
_SERVERS_STARTUP	O
,	O
O_NOTRANS	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
MACH_PORT_VALID	function
(	O
node	O
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
_SERVERS_STARTUP	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
errno	O
;	O
}	O
err	int
=	O
file_set_translator	function
(	O
node	O
,	O
0	int
,	O
FS_TRANS_SET	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
startup	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
node	O
)	O
;	O
return	O
err	int
;	O
}	O
static	O
int	O
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	O
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'q'	O
:	O
bootstrap_args	int
|=	O
RB_ASKNAME	O
;	O
break	O
;	O
case	O
's'	O
:	O
bootstrap_args	int
|=	O
RB_SINGLE	O
;	O
break	O
;	O
case	O
'd'	O
:	O
bootstrap_args	int
|=	O
RB_KDB	O
;	O
break	O
;	O
case	O
'n'	O
:	O
bootstrap_args	int
|=	O
RB_INITNAME	O
;	O
break	O
;	O
case	O
'f'	O
:	O
fakeboot	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
crash_flags	int
=	O
RB_DEBUGGER	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'x'	O
:	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
envp	pointer
)	O
{	O
volatile	O
int	O
err	int
;	O
int	O
i	int
;	O
int	O
flags	int
;	O
mach_port_t	O
consdev	O
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	int
,	O
parse_opt	function
,	O
0	int
,	O
doc	array
}	O
;	O
flags	int
=	O
ARGP_IN_ORDER	O
;	O
if	O
(	O
getpid	function
(	O
)	O
==	O
0	int
)	O
flags	int
|=	O
ARGP_NO_ERRS	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
flags	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
getpid	function
(	O
)	O
>	O
0	int
)	O
error	function
(	O
2	int
,	O
0	int
,	O
"can only be run by bootstrap filesystem"	pointer
)	O
;	O
global_argv	pointer
=	O
argv	pointer
;	O
if	O
(	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
bootport	int
)	O
||	O
fsys_getpriv	function
(	O
bootport	int
,	O
&	O
host_priv	int
,	O
&	O
device_master	O
,	O
&	O
fstask	O
)	O
||	O
device_open	function
(	O
device_master	O
,	O
D_READ	O
|	O
D_WRITE	O
,	O
"console"	pointer
,	O
&	O
consdev	O
)	O
)	O
crash_mach	function
(	O
)	O
;	O
wire_task_self	function
(	O
)	O
;	O
task_set_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_NULL	O
)	O
;	O
stderr	O
=	O
stdout	O
=	O
mach_open_devstream	function
(	O
consdev	O
,	O
"w"	pointer
)	O
;	O
stdin	O
=	O
mach_open_devstream	function
(	O
consdev	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
stdout	O
==	O
NULL	O
||	O
stdin	O
==	O
NULL	O
)	O
crash_mach	function
(	O
)	O
;	O
setbuf	function
(	O
stdout	O
,	O
NULL	O
)	O
;	O
err	int
=	O
argz_create	function
(	O
envp	pointer
,	O
&	O
startup_envz	pointer
,	O
&	O
startup_envz_len	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
mach_port_allocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
startup	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
mach_port_insert_right	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup	int
,	O
startup	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
request_dead_name	function
(	O
fstask	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	O
;	O
i	int
++	O
)	O
switch	O
(	O
i	int
)	O
{	O
case	O
INIT_PORT_CRDIR	O
:	O
default_ports	int
[	O
i	int
]	O
=	O
getcrdir	function
(	O
)	O
;	O
break	O
;	O
case	O
INIT_PORT_CWDIR	O
:	O
default_ports	int
[	O
i	int
]	O
=	O
getcwdir	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
default_ports	int
[	O
i	int
]	O
=	O
MACH_PORT_NULL	O
;	O
break	O
;	O
}	O
default_dtable	array
[	O
0	int
]	O
=	O
getdport	function
(	O
0	int
)	O
;	O
default_dtable	array
[	O
1	int
]	O
=	O
getdport	function
(	O
1	int
)	O
;	O
default_dtable	array
[	O
2	int
]	O
=	O
getdport	function
(	O
2	int
)	O
;	O
default_ints	int
[	O
INIT_SIGIGN	O
]	O
=	O
(	O
sigmask	function
(	O
SIGTSTP	O
)	O
|	O
sigmask	function
(	O
SIGTTIN	O
)	O
|	O
sigmask	function
(	O
SIGTTOU	O
)	O
)	O
;	O
default_ports	int
[	O
INIT_PORT_BOOTSTRAP	O
]	O
=	O
startup	int
;	O
run	function
(	O
"/hurd/proc"	pointer
,	O
default_ports	int
,	O
&	O
proctask	O
)	O
;	O
if	O
(	O
!	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
" proc"	pointer
)	O
;	O
run	function
(	O
"/hurd/auth"	pointer
,	O
default_ports	int
,	O
&	O
authtask	int
)	O
;	O
if	O
(	O
!	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
" auth"	pointer
)	O
;	O
default_ports	int
[	O
INIT_PORT_BOOTSTRAP	O
]	O
=	O
MACH_PORT_NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
err	int
=	O
mach_msg_server	function
(	O
demuxer	function
,	O
0	int
,	O
startup	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
}	O
}	O
void	O
launch_core_servers	function
(	O
void	O
)	O
{	O
mach_port_t	O
old	O
;	O
mach_port_t	O
authproc	O
,	O
fsproc	O
,	O
procproc	O
;	O
error_t	O
err	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Launching core servers\n"	pointer
)	O
;	O
err	int
=	O
startup_procinit_reply	function
(	O
procreply	int
,	O
procreplytype	int
,	O
0	int
,	O
mach_task_self	function
(	O
)	O
,	O
authserver	int
,	O
host_priv	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
device_master	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
if	O
(	O
!	O
fakeboot	int
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
device_master	O
)	O
;	O
device_master	O
=	O
0	int
;	O
}	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"proc launched\n"	pointer
)	O
;	O
err	int
=	O
proc_mark_important	function
(	O
procserver	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_exec	function
(	O
procserver	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_child	function
(	O
procserver	int
,	O
fstask	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_child	function
(	O
procserver	int
,	O
authtask	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_task2proc	function
(	O
procserver	int
,	O
authtask	int
,	O
&	O
authproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_important	function
(	O
authproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_exec	function
(	O
authproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
install_as_translator	function
(	O
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"Failed to bind to "	pointer
_SERVERS_STARTUP	O
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Installed on /servers/startup\n"	pointer
)	O
;	O
err	int
=	O
startup_authinit_reply	function
(	O
authreply	O
,	O
authreplytype	O
,	O
0	int
,	O
authproc	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
authproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"auth launched\n"	pointer
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_AUTH	O
]	O
,	O
authserver	int
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_PROC	O
]	O
,	O
procserver	int
)	O
;	O
err	int
=	O
proc_set_arg_locations	function
(	O
procserver	int
,	O
(	O
vm_address_t	O
)	O
global_argv	pointer
,	O
(	O
vm_address_t	O
)	O
environ	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
default_ports	int
[	O
INIT_PORT_AUTH	O
]	O
=	O
authserver	int
;	O
err	int
=	O
proc_child	function
(	O
procserver	int
,	O
proctask	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_task2proc	function
(	O
procserver	int
,	O
proctask	O
,	O
&	O
procproc	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
proc_mark_important	function
(	O
procproc	O
)	O
;	O
proc_mark_exec	function
(	O
procproc	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
procproc	O
)	O
;	O
}	O
err	int
=	O
proc_register_version	function
(	O
procserver	int
,	O
host_priv	int
,	O
"init"	pointer
,	O
""	pointer
,	O
HURD_VERSION	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_task2proc	function
(	O
procserver	int
,	O
fstask	O
,	O
&	O
fsproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_important	function
(	O
fsproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_exec	function
(	O
fsproc	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
fprintf	function
(	O
stderr	O
,	O
".\n"	pointer
)	O
;	O
err	int
=	O
proc_setmsgport	function
(	O
procserver	int
,	O
startup	int
,	O
&	O
old	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
if	O
(	O
old	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
old	O
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Message port registered\n"	pointer
)	O
;	O
err	int
=	O
fsys_init	function
(	O
bootport	int
,	O
fsproc	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
authserver	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
fsproc	O
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"fsys_init"	pointer
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Fixed up bootstrap filesystem\n"	pointer
)	O
;	O
}	O
void	O
init_stdarrays	function
(	O
)	O
{	O
auth_t	O
nullauth	O
;	O
mach_port_t	O
pt	O
;	O
mach_port_t	O
ref	O
;	O
mach_port_t	O
*	O
std_port_array	O
;	O
int	O
*	O
std_int_array	pointer
;	O
int	O
i	int
;	O
std_port_array	O
=	O
alloca	O
(	O
sizeof	O
(	O
mach_port_t	O
)	O
*	O
INIT_PORT_MAX	O
)	O
;	O
std_int_array	pointer
=	O
alloca	O
(	O
sizeof	O
(	O
int	O
)	O
*	O
INIT_INT_MAX	O
)	O
;	O
memset	O
(	O
std_port_array	O
,	O
0	int
,	O
sizeof	O
(	O
mach_port_t	O
)	O
*	O
INIT_PORT_MAX	O
)	O
;	O
memset	O
(	O
std_int_array	pointer
,	O
0	int
,	O
sizeof	O
(	O
int	O
)	O
*	O
INIT_INT_MAX	O
)	O
;	O
__USEPORT	function
(	O
AUTH	O
,	O
auth_makeauth	function
(	O
port	pointer
,	O
0	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
nullauth	O
)	O
)	O
;	O
pt	O
=	O
getcwdir	function
(	O
)	O
;	O
ref	O
=	O
mach_reply_port	function
(	O
)	O
;	O
io_reauthenticate	function
(	O
pt	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
auth_user_authenticate	function
(	O
nullauth	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
std_port_array	O
[	O
INIT_PORT_CWDIR	O
]	O
)	O
;	O
mach_port_destroy	function
(	O
mach_task_self	function
(	O
)	O
,	O
ref	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
pt	O
)	O
;	O
pt	O
=	O
getcrdir	function
(	O
)	O
;	O
ref	O
=	O
mach_reply_port	function
(	O
)	O
;	O
io_reauthenticate	function
(	O
pt	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
auth_user_authenticate	function
(	O
nullauth	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
std_port_array	O
[	O
INIT_PORT_CRDIR	O
]	O
)	O
;	O
mach_port_destroy	function
(	O
mach_task_self	function
(	O
)	O
,	O
ref	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
pt	O
)	O
;	O
std_port_array	O
[	O
INIT_PORT_AUTH	O
]	O
=	O
nullauth	O
;	O
std_int_array	pointer
[	O
INIT_UMASK	O
]	O
=	O
CMASK	O
;	O
__USEPORT	function
(	O
PROC	O
,	O
proc_setexecdata	function
(	O
port	pointer
,	O
std_port_array	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
std_int_array	pointer
,	O
INIT_INT_MAX	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	O
;	O
i	int
++	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
std_port_array	O
[	O
i	int
]	O
)	O
;	O
}	O
void	O
dump_processes	function
(	O
void	O
)	O
{	O
pid_t	O
pid	int
;	O
for	O
(	O
pid	int
=	O
1	int
;	O
pid	int
<	O
100	int
;	O
pid	int
++	O
)	O
{	O
char	O
args	pointer
[	O
256	int
]	O
,	O
*	O
buffer	pointer
=	O
args	pointer
;	O
size_t	O
len	pointer
=	O
sizeof	O
args	pointer
;	O
if	O
(	O
proc_getprocargs	function
(	O
procserver	int
,	O
pid	int
,	O
&	O
buffer	pointer
,	O
&	O
len	pointer
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"pid%d\t%s\n"	pointer
,	O
(	O
int	O
)	O
pid	int
,	O
buffer	pointer
)	O
;	O
if	O
(	O
buffer	pointer
!=	O
args	pointer
)	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
vm_offset_t	O
)	O
buffer	pointer
,	O
len	pointer
)	O
;	O
}	O
}	O
}	O
void	O
frob_kernel_process	function
(	O
void	O
)	O
{	O
error_t	O
err	int
;	O
int	O
argc	int
,	O
i	int
;	O
char	O
*	O
argz	pointer
,	O
*	O
entry	pointer
;	O
size_t	O
argzlen	O
;	O
size_t	O
windowsz	O
;	O
vm_address_t	O
mine	O
,	O
his	O
;	O
task_t	O
task	int
;	O
process_t	O
proc	int
,	O
kbs	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Frobbing kernel process\n"	pointer
)	O
;	O
err	int
=	O
proc_pid2task	function
(	O
procserver	int
,	O
HURD_PID_KERNEL	O
,	O
&	O
task	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot get kernel task port"	pointer
)	O
;	O
return	O
;	O
}	O
err	int
=	O
proc_child	function
(	O
procserver	int
,	O
task	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot make the kernel our child"	pointer
)	O
;	O
dump_processes	function
(	O
)	O
;	O
}	O
err	int
=	O
proc_task2proc	function
(	O
procserver	int
,	O
task	int
,	O
&	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot get kernel task's proc server port"	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
task	int
)	O
;	O
return	O
;	O
}	O
err	int
=	O
proc_mark_important	function
(	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot mark the kernel as important"	pointer
)	O
;	O
err	int
=	O
record_essential_task	function
(	O
"kernel"	pointer
,	O
task	int
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
err	int
=	O
task_get_bootstrap_port	function
(	O
task	int
,	O
&	O
kbs	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
if	O
(	O
kbs	O
==	O
MACH_PORT_NULL	O
)	O
{	O
err	int
=	O
task_set_bootstrap_port	function
(	O
task	int
,	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot set kernel task's bootstrap port"	pointer
)	O
;	O
if	O
(	O
fakeboot	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
"warning: --fake-boot specified but I see no other Hurd"	pointer
)	O
;	O
}	O
else	O
{	O
vm_address_t	O
kargv	O
,	O
kenvp	O
;	O
err	int
=	O
proc_get_arg_locations	function
(	O
kbs	O
,	O
&	O
kargv	O
,	O
&	O
kenvp	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
kbs	O
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"kernel task bootstrap port (ignoring)"	pointer
)	O
;	O
else	O
{	O
err	int
=	O
proc_set_arg_locations	function
(	O
proc	int
,	O
kargv	O
,	O
kenvp	O
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot propagate original kernel command line"	pointer
)	O
;	O
else	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
proc	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
task	int
)	O
;	O
if	O
(	O
!	O
fakeboot	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
"warning: "	pointer
"I see another Hurd, but --fake-boot was not given"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
err	int
=	O
argz_create	function
(	O
&	O
global_argv	pointer
[	O
1	int
]	O
,	O
&	O
argz	pointer
,	O
&	O
argzlen	O
)	O
;	O
assert_perror	function
(	O
err	int
)	O
;	O
argc	int
=	O
argz_count	function
(	O
argz	pointer
,	O
argzlen	O
)	O
;	O
windowsz	O
=	O
round_page	function
(	O
(	O
(	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
+	O
argzlen	O
)	O
;	O
mine	O
=	O
(	O
vm_address_t	O
)	O
mmap	O
(	O
0	int
,	O
windowsz	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
assert	function
(	O
mine	O
!=	O
-	O
1	int
)	O
;	O
err	int
=	O
vm_allocate	function
(	O
task	int
,	O
&	O
his	O
,	O
windowsz	O
,	O
1	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot allocate %Zu bytes in kernel task"	pointer
,	O
windowsz	O
)	O
;	O
free	function
(	O
argz	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
proc	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
task	int
)	O
;	O
munmap	function
(	O
(	O
caddr_t	O
)	O
mine	O
,	O
windowsz	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
entry	pointer
=	O
argz	pointer
;	O
entry	pointer
!=	O
NULL	O
;	O
++	O
i	int
,	O
entry	pointer
=	O
argz_next	function
(	O
argz	pointer
,	O
argzlen	O
,	O
entry	pointer
)	O
)	O
(	O
(	O
char	O
*	O
*	O
)	O
mine	O
)	O
[	O
i	int
]	O
=	O
(	O
(	O
char	O
*	O
)	O
&	O
(	O
(	O
char	O
*	O
*	O
)	O
his	O
)	O
[	O
argc	int
+	O
1	int
]	O
+	O
(	O
entry	pointer
-	O
argz	pointer
)	O
)	O
;	O
(	O
(	O
char	O
*	O
*	O
)	O
mine	O
)	O
[	O
argc	int
]	O
=	O
NULL	O
;	O
memcpy	O
(	O
&	O
(	O
(	O
char	O
*	O
*	O
)	O
mine	O
)	O
[	O
argc	int
+	O
1	int
]	O
,	O
argz	pointer
,	O
argzlen	O
)	O
;	O
free	function
(	O
argz	pointer
)	O
;	O
err	int
=	O
vm_write	function
(	O
task	int
,	O
his	O
,	O
mine	O
,	O
windowsz	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
task	int
)	O
;	O
munmap	function
(	O
(	O
caddr_t	O
)	O
mine	O
,	O
windowsz	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"cannot write command line into kernel task"	pointer
)	O
;	O
return	O
;	O
}	O
err	int
=	O
proc_set_arg_locations	function
(	O
proc	int
,	O
his	O
,	O
his	O
+	O
(	O
argc	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"proc_set_arg_locations for kernel task"	pointer
)	O
;	O
}	O
static	O
pid_t	O
child_pid	int
;	O
static	O
task_t	O
child_task	int
;	O
static	O
void	O
launch_something	function
(	O
const	O
char	O
*	O
why	pointer
)	O
;	O
void	O
process_signal	function
(	O
int	O
signo	int
)	O
{	O
if	O
(	O
signo	int
==	O
SIGCHLD	O
)	O
{	O
int	O
status	int
;	O
pid_t	O
pid	int
;	O
while	O
(	O
1	int
)	O
{	O
pid	int
=	O
waitpid	function
(	O
WAIT_ANY	O
,	O
&	O
status	int
,	O
WNOHANG	O
|	O
WUNTRACED	O
)	O
;	O
if	O
(	O
pid	int
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
pid	int
==	O
child_pid	int
)	O
{	O
char	O
*	O
desc	pointer
=	O
0	int
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
child_task	int
)	O
;	O
child_task	int
=	O
MACH_PORT_NULL	O
;	O
child_pid	int
=	O
-	O
1	int
;	O
if	O
(	O
WIFSIGNALED	function
(	O
status	int
)	O
)	O
asprintf	function
(	O
&	O
desc	pointer
,	O
"terminated abnormally (%s)"	pointer
,	O
strsignal	function
(	O
WTERMSIG	function
(	O
status	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
WIFSTOPPED	function
(	O
status	int
)	O
)	O
asprintf	function
(	O
&	O
desc	pointer
,	O
"stopped abnormally (%s)"	pointer
,	O
strsignal	function
(	O
WTERMSIG	function
(	O
status	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
WEXITSTATUS	function
(	O
status	int
)	O
==	O
0	int
)	O
desc	pointer
=	O
strdup	O
(	O
"finished"	pointer
)	O
;	O
else	O
asprintf	function
(	O
&	O
desc	pointer
,	O
"exited with status %d"	pointer
,	O
WEXITSTATUS	function
(	O
status	int
)	O
)	O
;	O
{	O
char	O
buf	pointer
[	O
40	int
]	O
;	O
snprintf	O
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%d"	pointer
,	O
status	int
)	O
;	O
setenv	function
(	O
"STATUS"	pointer
,	O
buf	pointer
,	O
1	int
)	O
;	O
}	O
launch_something	function
(	O
desc	pointer
)	O
;	O
free	function
(	O
desc	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
start_child	function
(	O
const	O
char	O
*	O
prog	pointer
,	O
char	O
*	O
*	O
progargs	pointer
)	O
{	O
file_t	O
file	O
;	O
error_t	O
err	int
;	O
char	O
*	O
args	pointer
;	O
size_t	O
arglen	int
;	O
if	O
(	O
progargs	pointer
==	O
0	int
)	O
{	O
const	O
char	O
*	O
argv	pointer
[	O
]	O
=	O
{	O
"/libexec/console-run"	pointer
,	O
prog	pointer
,	O
0	int
}	O
;	O
err	int
=	O
argz_create	function
(	O
(	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
&	O
args	pointer
,	O
&	O
arglen	int
)	O
;	O
}	O
else	O
{	O
int	O
argc	int
=	O
0	int
;	O
while	O
(	O
progargs	pointer
[	O
argc	int
]	O
!=	O
0	int
)	O
++	O
argc	int
;	O
{	O
const	O
char	O
*	O
argv	pointer
[	O
2	int
+	O
argc	int
+	O
1	int
]	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
"/libexec/console-run"	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
prog	pointer
;	O
argv	pointer
[	O
2	int
+	O
argc	int
]	O
=	O
0	int
;	O
while	O
(	O
argc	int
--	O
>	O
0	int
)	O
argv	pointer
[	O
2	int
+	O
argc	int
]	O
=	O
progargs	pointer
[	O
argc	int
]	O
;	O
err	int
=	O
argz_create	function
(	O
(	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
&	O
args	pointer
,	O
&	O
arglen	int
)	O
;	O
}	O
}	O
assert_perror	function
(	O
err	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Going to execute '%s'\n"	pointer
,	O
args	pointer
)	O
;	O
file	O
=	O
file_name_lookup	function
(	O
args	pointer
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
args	pointer
)	O
;	O
free	function
(	O
args	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
task_create	function
(	O
mach_task_self	function
(	O
)	O
,	O
0	int
,	O
&	O
child_task	int
)	O
;	O
proc_set_init_task	function
(	O
procserver	int
,	O
child_task	int
)	O
;	O
proc_task2pid	function
(	O
procserver	int
,	O
child_task	int
,	O
&	O
child_pid	int
)	O
;	O
proc_task2proc	function
(	O
procserver	int
,	O
child_task	int
,	O
&	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
if	O
(	O
bootstrap_args	int
&	O
RB_KDB	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Pausing for %s\n"	pointer
,	O
args	pointer
)	O
;	O
getchar	function
(	O
)	O
;	O
}	O
err	int
=	O
file_exec	function
(	O
file	O
,	O
child_task	int
,	O
0	int
,	O
args	pointer
,	O
arglen	int
,	O
startup_envz	pointer
,	O
startup_envz_len	int
,	O
NULL	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
0	int
,	O
default_ports	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
default_ints	int
,	O
INIT_INT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
proc_mark_important	function
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
file	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	function
(	O
0	int
,	O
err	int
,	O
"Cannot execute %s"	pointer
,	O
args	pointer
)	O
;	O
free	function
(	O
args	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
free	function
(	O
args	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
launch_something	function
(	O
const	O
char	O
*	O
why	pointer
)	O
{	O
file_t	O
something	O
;	O
static	O
unsigned	O
int	O
try	int
;	O
static	O
const	O
char	O
*	O
const	O
tries	array
[	O
]	O
=	O
{	O
"/libexec/runsystem"	pointer
,	O
_PATH_BSHELL	O
,	O
"/bin/shd"	pointer
,	O
}	O
;	O
if	O
(	O
why	pointer
)	O
error	function
(	O
0	int
,	O
0	int
,	O
"%s %s"	pointer
,	O
tries	array
[	O
try	int
-	O
1	int
]	O
,	O
why	pointer
)	O
;	O
something	O
=	O
file_name_lookup	function
(	O
tries	array
[	O
try	int
]	O
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
something	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
something	O
)	O
;	O
if	O
(	O
try	int
==	O
0	int
&&	O
start_child	function
(	O
tries	array
[	O
try	int
++	O
]	O
,	O
&	O
global_argv	pointer
[	O
1	int
]	O
)	O
==	O
0	int
)	O
return	O
;	O
}	O
else	O
try	int
++	O
;	O
while	O
(	O
try	int
<	O
sizeof	O
tries	array
/	O
sizeof	O
tries	array
[	O
0	int
]	O
)	O
{	O
something	O
=	O
file_name_lookup	function
(	O
tries	array
[	O
try	int
]	O
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
something	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
something	O
)	O
;	O
if	O
(	O
start_child	function
(	O
tries	array
[	O
try	int
++	O
]	O
,	O
NULL	O
)	O
==	O
0	int
)	O
return	O
;	O
}	O
else	O
try	int
++	O
;	O
}	O
crash_system	function
(	O
)	O
;	O
}	O
void	O
launch_system	function
(	O
void	O
)	O
{	O
launch_something	function
(	O
0	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Init has completed\n"	pointer
)	O
;	O
}	O
kern_return_t	O
S_startup_procinit	function
(	O
startup_t	O
server	pointer
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_porttype	int
,	O
process_t	O
proc	int
,	O
mach_port_t	O
*	O
startuptask	pointer
,	O
auth_t	O
*	O
auth	pointer
,	O
mach_port_t	O
*	O
priv	pointer
,	O
mach_msg_type_name_t	O
*	O
hostprivtype	pointer
,	O
mach_port_t	O
*	O
dev	pointer
,	O
mach_msg_type_name_t	O
*	O
devtype	pointer
)	O
{	O
if	O
(	O
procserver	int
)	O
return	O
EPERM	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Received startup message from proc\n"	pointer
)	O
;	O
procserver	int
=	O
proc	int
;	O
procreply	int
=	O
reply	int
;	O
procreplytype	int
=	O
reply_porttype	int
;	O
if	O
(	O
authserver	int
)	O
launch_core_servers	function
(	O
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_startup_authinit	function
(	O
startup_t	O
server	pointer
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_porttype	int
,	O
mach_port_t	O
auth	pointer
,	O
mach_port_t	O
*	O
proc	int
,	O
mach_msg_type_name_t	O
*	O
proctype	pointer
)	O
{	O
if	O
(	O
authserver	int
)	O
return	O
EPERM	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Received startup message from auth\n"	pointer
)	O
;	O
authserver	int
=	O
auth	pointer
;	O
authreply	O
=	O
reply	int
;	O
authreplytype	O
=	O
reply_porttype	int
;	O
if	O
(	O
procserver	int
)	O
launch_core_servers	function
(	O
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_startup_essential_task	function
(	O
mach_port_t	O
server	pointer
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
task_t	O
task	int
,	O
mach_port_t	O
excpt	int
,	O
char	O
*	O
name	pointer
,	O
mach_port_t	O
credential	int
)	O
{	O
static	O
int	O
authinit	int
,	O
procinit	int
,	O
execinit	int
;	O
int	O
fail	int
;	O
if	O
(	O
MACH_PORT_VALID	function
(	O
credential	int
)	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
credential	int
)	O
;	O
if	O
(	O
credential	int
!=	O
host_priv	int
)	O
return	O
EPERM	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Received startup essential message from '%s'\n"	pointer
,	O
name	pointer
)	O
;	O
fail	int
=	O
record_essential_task	function
(	O
name	pointer
,	O
task	int
)	O
;	O
if	O
(	O
fail	int
)	O
return	O
fail	int
;	O
if	O
(	O
!	O
booted	int
)	O
{	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
"auth"	pointer
)	O
)	O
authinit	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
"exec"	pointer
)	O
)	O
{	O
execinit	int
=	O
1	int
;	O
mach_port_t	O
execproc	O
;	O
proc_task2proc	function
(	O
procserver	int
,	O
task	int
,	O
&	O
execproc	O
)	O
;	O
proc_mark_important	function
(	O
execproc	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
"proc"	pointer
)	O
)	O
procinit	int
=	O
1	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
"  still waiting for:"	pointer
)	O
;	O
if	O
(	O
authinit	int
&&	O
execinit	int
&&	O
procinit	int
)	O
{	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	O
,	O
" none!\n"	pointer
)	O
;	O
startup_essential_task_reply	function
(	O
reply	int
,	O
replytype	int
,	O
0	int
)	O
;	O
init_stdarrays	function
(	O
)	O
;	O
frob_kernel_process	function
(	O
)	O
;	O
launch_system	function
(	O
)	O
;	O
booted	int
=	O
1	int
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
!	O
authinit	int
)	O
fprintf	function
(	O
stderr	O
,	O
" auth"	pointer
)	O
;	O
if	O
(	O
!	O
execinit	int
)	O
fprintf	function
(	O
stderr	O
,	O
" exec"	pointer
)	O
;	O
if	O
(	O
!	O
procinit	int
)	O
fprintf	function
(	O
stderr	O
,	O
" proc"	pointer
)	O
;	O
fprintf	function
(	O
stderr	O
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_startup_request_notification	function
(	O
mach_port_t	O
server	pointer
,	O
mach_port_t	O
notify	int
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
ntfy_task	struct
*	O
nt	pointer
;	O
request_dead_name	function
(	O
notify	int
)	O
;	O
nt	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
ntfy_task	struct
)	O
)	O
;	O
nt	pointer
->	O
notify_port	int
=	O
notify	int
;	O
nt	pointer
->	O
next	pointer
=	O
ntfy_tasks	pointer
;	O
ntfy_tasks	pointer
=	O
nt	pointer
;	O
nt	pointer
->	O
name	pointer
=	O
malloc	O
(	O
strlen	O
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	O
(	O
nt	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
do_mach_notify_dead_name	function
(	O
mach_port_t	O
notify	int
,	O
mach_port_t	O
name	pointer
)	O
{	O
struct	O
ntfy_task	struct
*	O
nt	pointer
,	O
*	O
pnt	pointer
;	O
struct	O
ess_task	struct
*	O
et	pointer
;	O
assert	function
(	O
notify	int
==	O
startup	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
name	pointer
)	O
;	O
for	O
(	O
et	pointer
=	O
ess_tasks	pointer
;	O
et	pointer
!=	O
NULL	O
;	O
et	pointer
=	O
et	pointer
->	O
next	pointer
)	O
if	O
(	O
et	pointer
->	O
task_port	int
==	O
name	pointer
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
"Crashing system; essential task %s died"	pointer
,	O
et	pointer
->	O
name	pointer
)	O
;	O
crash_system	function
(	O
)	O
;	O
}	O
for	O
(	O
nt	pointer
=	O
ntfy_tasks	pointer
,	O
pnt	pointer
=	O
NULL	O
;	O
nt	pointer
!=	O
NULL	O
;	O
pnt	pointer
=	O
nt	pointer
,	O
nt	pointer
=	O
nt	pointer
->	O
next	pointer
)	O
if	O
(	O
nt	pointer
->	O
notify_port	int
==	O
name	pointer
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
pnt	pointer
!=	O
NULL	O
)	O
pnt	pointer
->	O
next	pointer
=	O
nt	pointer
->	O
next	pointer
;	O
else	O
ntfy_tasks	pointer
=	O
nt	pointer
->	O
next	pointer
;	O
free	function
(	O
nt	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
booted	int
)	O
{	O
static	O
const	O
struct	O
{	O
task_t	O
*	O
taskp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
}	O
boots	array
[	O
]	O
=	O
{	O
{	O
&	O
fstask	O
,	O
"bootstrap filesystem"	pointer
}	O
,	O
{	O
&	O
authtask	int
,	O
"auth"	pointer
}	O
,	O
{	O
&	O
proctask	O
,	O
"proc"	pointer
}	O
,	O
}	O
;	O
size_t	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
boots	array
/	O
sizeof	O
boots	array
[	O
0	int
]	O
;	O
++	O
i	int
)	O
if	O
(	O
name	pointer
==	O
*	O
boots	array
[	O
i	int
]	O
.	O
taskp	pointer
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
"Crashing system; %s server died during bootstrap"	pointer
,	O
boots	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
crash_mach	function
(	O
)	O
;	O
}	O
error	function
(	O
0	int
,	O
0	int
,	O
"BUG!  Unexpected dead-name notification (name %#lx)"	pointer
,	O
name	pointer
)	O
;	O
crash_mach	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_startup_reboot	function
(	O
mach_port_t	O
server	pointer
,	O
mach_port_t	O
refpt	int
,	O
int	O
code	int
)	O
{	O
if	O
(	O
refpt	int
!=	O
host_priv	int
)	O
return	O
EPERM	O
;	O
reboot_system	function
(	O
code	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
;	O
}	O
kern_return_t	O
S_msg_sig_post_untraced	function
(	O
mach_port_t	O
msgport	int
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
signo	int
,	O
natural_t	O
sigcode	int
,	O
mach_port_t	O
refport	int
)	O
{	O
if	O
(	O
refport	int
!=	O
mach_task_self	function
(	O
)	O
)	O
return	O
EPERM	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
refport	int
)	O
;	O
msg_sig_post_untraced_reply	function
(	O
reply	int
,	O
reply_type	int
,	O
0	int
)	O
;	O
process_signal	function
(	O
signo	int
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_msg_sig_post	function
(	O
mach_port_t	O
msgport	int
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
signo	int
,	O
natural_t	O
sigcode	int
,	O
mach_port_t	O
refport	int
)	O
{	O
if	O
(	O
refport	int
!=	O
mach_task_self	function
(	O
)	O
)	O
return	O
EPERM	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
refport	int
)	O
;	O
msg_sig_post_reply	function
(	O
reply	int
,	O
reply_type	int
,	O
0	int
)	O
;	O
process_signal	function
(	O
signo	int
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_msg_proc_newids	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
task	int
,	O
pid_t	O
ppid	int
,	O
pid_t	O
pgrp	int
,	O
int	O
orphaned	int
)	O
{	O
return	O
_S_msg_proc_newids	function
(	O
process	int
,	O
task	int
,	O
ppid	int
,	O
pgrp	int
,	O
orphaned	int
)	O
;	O
}	O
kern_return_t	O
S_msg_add_auth	function
(	O
mach_port_t	O
process	int
,	O
auth_t	O
auth	pointer
)	O
{	O
return	O
_S_msg_add_auth	function
(	O
process	int
,	O
auth	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_del_auth	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
task	int
,	O
intarray_t	O
uids	int
,	O
mach_msg_type_number_t	O
uidsCnt	int
,	O
intarray_t	O
gids	int
,	O
mach_msg_type_number_t	O
gidsCnt	int
)	O
{	O
return	O
_S_msg_del_auth	function
(	O
process	int
,	O
task	int
,	O
uids	int
,	O
uidsCnt	int
,	O
gids	int
,	O
gidsCnt	int
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_port	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
mach_port_t	O
*	O
port	pointer
,	O
mach_msg_type_name_t	O
*	O
portPoly	pointer
)	O
{	O
return	O
_S_msg_get_init_port	function
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
port	pointer
,	O
portPoly	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_port	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
mach_port_t	O
port	pointer
)	O
{	O
return	O
_S_msg_set_init_port	function
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
port	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_ports	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
*	O
ports	pointer
,	O
mach_msg_type_name_t	O
*	O
portsPoly	pointer
,	O
mach_msg_type_number_t	O
*	O
portsCnt	pointer
)	O
{	O
return	O
_S_msg_get_init_ports	function
(	O
process	int
,	O
refport	int
,	O
ports	pointer
,	O
portsPoly	pointer
,	O
portsCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_ports	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
ports	pointer
,	O
mach_msg_type_number_t	O
portsCnt	pointer
)	O
{	O
return	O
_S_msg_set_init_ports	function
(	O
process	int
,	O
refport	int
,	O
ports	pointer
,	O
portsCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_int	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
int	O
*	O
value	pointer
)	O
{	O
return	O
_S_msg_get_init_int	function
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
value	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_int	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
int	O
value	pointer
)	O
{	O
return	O
_S_msg_set_init_int	function
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
value	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_ints	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
intarray_t	O
*	O
values	pointer
,	O
mach_msg_type_number_t	O
*	O
valuesCnt	pointer
)	O
{	O
return	O
_S_msg_get_init_ints	function
(	O
process	int
,	O
refport	int
,	O
values	pointer
,	O
valuesCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_ints	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
intarray_t	O
values	pointer
,	O
mach_msg_type_number_t	O
valuesCnt	pointer
)	O
{	O
return	O
_S_msg_set_init_ints	function
(	O
process	int
,	O
refport	int
,	O
values	pointer
,	O
valuesCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_dtable	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
*	O
dtable	pointer
,	O
mach_msg_type_name_t	O
*	O
dtablePoly	pointer
,	O
mach_msg_type_number_t	O
*	O
dtableCnt	pointer
)	O
{	O
return	O
_S_msg_get_dtable	function
(	O
process	int
,	O
refport	int
,	O
dtable	pointer
,	O
dtablePoly	pointer
,	O
dtableCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_dtable	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
dtable	pointer
,	O
mach_msg_type_number_t	O
dtableCnt	pointer
)	O
{	O
return	O
_S_msg_set_dtable	function
(	O
process	int
,	O
refport	int
,	O
dtable	pointer
,	O
dtableCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_fd	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
fd	int
,	O
mach_port_t	O
*	O
port	pointer
,	O
mach_msg_type_name_t	O
*	O
portPoly	pointer
)	O
{	O
return	O
_S_msg_get_fd	function
(	O
process	int
,	O
refport	int
,	O
fd	int
,	O
port	pointer
,	O
portPoly	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_fd	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
fd	int
,	O
mach_port_t	O
port	pointer
)	O
{	O
return	O
_S_msg_set_fd	function
(	O
process	int
,	O
refport	int
,	O
fd	int
,	O
port	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_environment	function
(	O
mach_port_t	O
process	int
,	O
data_t	O
*	O
value	pointer
,	O
mach_msg_type_number_t	O
*	O
valueCnt	pointer
)	O
{	O
return	O
_S_msg_get_environment	function
(	O
process	int
,	O
value	pointer
,	O
valueCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_environment	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
data_t	O
value	pointer
,	O
mach_msg_type_number_t	O
valueCnt	pointer
)	O
{	O
return	O
_S_msg_set_environment	function
(	O
process	int
,	O
refport	int
,	O
value	pointer
,	O
valueCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_get_env_variable	function
(	O
mach_port_t	O
process	int
,	O
string_t	O
variable	int
,	O
data_t	O
*	O
value	pointer
,	O
mach_msg_type_number_t	O
*	O
valueCnt	pointer
)	O
{	O
return	O
_S_msg_get_env_variable	function
(	O
process	int
,	O
variable	int
,	O
value	pointer
,	O
valueCnt	pointer
)	O
;	O
}	O
kern_return_t	O
S_msg_set_env_variable	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
string_t	O
variable	int
,	O
string_t	O
value	pointer
,	O
boolean_t	O
replace	int
)	O
{	O
return	O
_S_msg_set_env_variable	function
(	O
process	int
,	O
refport	int
,	O
variable	int
,	O
value	pointer
,	O
replace	int
)	O
;	O
}	O
error_t	O
S_msg_describe_ports	function
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
mach_port_array_t	O
names	int
,	O
mach_msg_type_number_t	O
namesCnt	int
,	O
data_t	O
*	O
descriptions	pointer
,	O
mach_msg_type_number_t	O
*	O
descriptionsCnt	pointer
)	O
{	O
return	O
_S_msg_describe_ports	function
(	O
process	int
,	O
refport	int
,	O
names	int
,	O
namesCnt	int
,	O
descriptions	pointer
,	O
descriptionsCnt	pointer
)	O
;	O
}	O
error_t	O
S_msg_report_wait	function
(	O
mach_port_t	O
process	int
,	O
thread_t	O
thread	int
,	O
string_t	O
desc	pointer
,	O
mach_msg_id_t	O
*	O
rpc	pointer
)	O
{	O
*	O
desc	pointer
=	O
0	int
;	O
*	O
rpc	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_fsys_getroot	function
(	O
mach_port_t	O
fsys_t	int
,	O
mach_port_t	O
dotdotnode	int
,	O
uid_t	O
*	O
uids	int
,	O
size_t	O
nuids	int
,	O
uid_t	O
*	O
gids	int
,	O
size_t	O
ngids	int
,	O
int	O
flags	int
,	O
retry_type	O
*	O
do_retry	pointer
,	O
char	O
*	O
retry_name	pointer
,	O
mach_port_t	O
*	O
ret	pointer
,	O
mach_msg_type_name_t	O
*	O
rettype	pointer
)	O
{	O
int	O
is_root	int
=	O
0	int
;	O
size_t	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nuids	int
;	O
i	int
++	O
)	O
if	O
(	O
uids	int
[	O
i	int
]	O
==	O
0	int
)	O
{	O
is_root	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
is_root	int
)	O
return	O
EPERM	O
;	O
*	O
do_retry	pointer
=	O
FS_RETRY_NORMAL	O
;	O
*	O
retry_name	pointer
=	O
'\0'	O
;	O
*	O
ret	pointer
=	O
startup	int
;	O
*	O
rettype	pointer
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_fsys_get_options	function
(	O
mach_port_t	O
control	int
,	O
char	O
*	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
*	O
len	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_check_access	function
(	O
mach_port_t	O
server	pointer
,	O
int	O
*	O
allowed	pointer
)	O
{	O
if	O
(	O
server	pointer
!=	O
startup	int
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
allowed	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_stat	function
(	O
mach_port_t	O
server	pointer
,	O
struct	O
stat	O
*	O
st	pointer
)	O
{	O
if	O
(	O
server	pointer
!=	O
startup	int
)	O
return	O
EOPNOTSUPP	O
;	O
memset	O
(	O
st	pointer
,	O
0	int
,	O
sizeof	O
*	O
st	pointer
)	O
;	O
st	pointer
->	O
st_fstype	O
=	O
FSTYPE_MISC	O
;	O
st	pointer
->	O
st_fsid	O
=	O
getpid	function
(	O
)	O
;	O
st	pointer
->	O
st_mode	O
=	O
S_IFCHR	O
|	O
S_IROOT	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_restrict_auth	function
(	O
mach_port_t	O
server	pointer
,	O
mach_port_t	O
*	O
newport	pointer
,	O
mach_msg_type_name_t	O
*	O
newporttype	pointer
,	O
uid_t	O
*	O
uids	int
,	O
size_t	O
nuids	int
,	O
uid_t	O
*	O
gids	int
,	O
size_t	O
ngids	int
)	O
{	O
struct	O
idvec	O
user	struct
=	O
{	O
uids	int
,	O
(	O
unsigned	O
)	O
nuids	int
,	O
(	O
unsigned	O
)	O
nuids	int
}	O
;	O
if	O
(	O
server	pointer
!=	O
startup	int
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
idvec_contains	function
(	O
&	O
user	struct
,	O
0	int
)	O
)	O
return	O
EPERM	O
;	O
*	O
newport	pointer
=	O
server	pointer
;	O
*	O
newporttype	pointer
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
return	O
0	int
;	O
}	O
