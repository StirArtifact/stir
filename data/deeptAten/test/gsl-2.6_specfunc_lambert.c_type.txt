static	O
int	O
halley_iteration	function
(	O
double	O
x	O
,	O
double	O
w_initial	O
,	O
unsigned	O
int	O
max_iters	int
,	O
gsl_sf_result	O
*	O
result	pointer
)	O
{	O
double	O
w	array
=	O
w_initial	O
;	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max_iters	int
;	O
i	int
++	O
)	O
{	O
double	O
tol	double
;	O
const	O
double	O
e	double
=	O
exp	O
(	O
w	O
)	O
;	O
const	O
double	O
p	double
=	O
w	O
+	O
1.0	int
;	O
double	O
t	double
=	O
w	int
*	O
e	double
-	O
x	int
;	O
if	O
(	O
w	O
>	O
0	int
)	O
{	O
t	O
=	O
(	int
t	O
/	O
p	int
)	O
/	O
e	int
;	O
}	O
else	O
{	O
t	O
/=	O
e	int
*	O
p	double
-	O
0.5	int
*	O
(	double
p	O
+	O
1.0	int
)	O
*	O
t	pointer
/	O
p	int
;	O
}	O
;	O
w	O
-=	O
t	O
;	O
tol	O
=	O
10	int
*	O
GSL_DBL_EPSILON	double
*	O
GSL_MAX_DBL	O
(	O
fabs	double
(	O
w	pointer
)	O
,	O
1.0	O
/	O
(	int
fabs	O
(	O
p	pointer
)	O
*	O
e	pointer
)	O
)	O
;	O
if	O
(	O
fabs	O
(	O
t	pointer
)	O
<	O
tol	int
)	O
{	O
result	O
->	O
val	double
=	O
w	int
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
tol	int
;	O
return	int
GSL_SUCCESS	int
;	O
}	O
}	O
result	O
->	O
val	double
=	O
w	int
;	O
result	O
->	O
err	double
=	O
fabs	int
(	O
w	pointer
)	O
;	O
return	O
GSL_EMAXITER	int
;	O
}	O
static	O
double	O
series_eval	function
(	O
double	O
r	O
)	O
{	O
static	O
const	O
double	O
c	double
[	O
12	O
]	O
=	O
{	O
-	O
1.0	int
,	O
2.331643981597124203363536062168	O
,	O
-	int
1.812187885639363490240191647568	int
,	O
1.936631114492359755363277457668	O
,	O
-	O
2.353551201881614516821543561516	int
,	O
3.066858901050631912893148922704	O
,	O
-	O
4.175335600258177138854984177460	int
,	O
5.858023729874774148815053846119	O
,	O
-	O
8.401032217523977370984161688514	int
,	O
12.250753501314460424	O
,	O
-	O
18.100697012472442755	int
,	O
27.029044799010561650	O
}	O
;	O
const	O
double	O
t_8	function
=	O
c	O
[	O
8	int
]	O
+	O
r	int
*	O
(	pointer
c	O
[	O
9	int
]	O
+	O
r	int
*	O
(	pointer
c	O
[	O
10	int
]	O
+	O
r	int
*	O
c	pointer
[	O
11	int
]	O
)	O
)	O
;	O
const	O
double	O
t_5	function
=	O
c	O
[	O
5	int
]	O
+	O
r	int
*	O
(	int
c	O
[	O
6	int
]	O
+	O
r	int
*	O
(	int
c	O
[	O
7	int
]	O
+	O
r	int
*	O
t_8	int
)	O
)	O
;	O
const	O
double	O
t_1	function
=	O
c	O
[	O
1	int
]	O
+	O
r	int
*	O
(	int
c	O
[	O
2	int
]	O
+	O
r	int
*	O
(	int
c	O
[	O
3	int
]	O
+	O
r	int
*	O
(	int
c	O
[	O
4	int
]	O
+	O
r	int
*	O
t_5	int
)	O
)	O
)	O
;	O
return	O
c	int
[	O
0	int
]	O
+	O
r	int
*	O
t_1	int
;	O
}	O
int	O
gsl_sf_lambert_W0_e	function
(	O
double	O
x	O
,	O
gsl_sf_result	O
*	O
result	pointer
)	O
{	O
const	O
double	O
one_over_E	double
=	O
1.0	O
/	O
M_E	O
;	O
const	O
double	O
q	double
=	O
x	O
+	O
one_over_E	int
;	O
if	O
(	O
x	O
==	O
0.0	O
)	O
{	O
result	O
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	pointer
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
q	O
<	O
0.0	int
)	O
{	O
result	O
->	O
val	double
=	O
-	int
1.0	int
;	O
result	O
->	O
err	double
=	O
sqrt	int
(	O
-	double
q	int
)	O
;	O
return	O
GSL_EDOM	int
;	O
}	O
else	O
if	O
(	O
q	O
==	O
0.0	int
)	O
{	O
result	O
->	O
val	double
=	O
-	int
1.0	int
;	O
result	O
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
q	O
<	O
1.0e-03	int
)	O
{	O
const	O
double	O
r	double
=	O
sqrt	int
(	O
q	double
)	O
;	O
result	O
->	O
val	double
=	O
series_eval	int
(	O
r	pointer
)	O
;	O
result	O
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	O
(	O
result	double
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
int	O
MAX_ITERS	function
=	O
10	O
;	O
double	O
w	double
;	O
if	O
(	O
x	O
<	O
1.0	int
)	O
{	O
const	O
double	O
p	double
=	O
sqrt	O
(	O
2.0	double
*	O
M_E	int
*	O
q	double
)	O
;	O
w	O
=	O
-	O
1.0	int
+	O
p	int
*	O
(	double
1.0	O
+	O
p	int
*	O
(	double
-	O
1.0	O
/	O
3.0	int
+	O
p	int
*	O
11.0	double
/	O
72.0	int
)	O
)	O
;	O
}	O
else	O
{	O
w	O
=	O
log	O
(	O
x	double
)	O
;	O
if	O
(	O
x	O
>	O
3.0	int
)	O
w	O
-=	O
log	int
(	O
w	double
)	O
;	O
}	O
return	O
halley_iteration	int
(	O
x	O
,	O
w	O
,	O
MAX_ITERS	O
,	O
result	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_lambert_Wm1_e	function
(	O
double	O
x	double
,	O
gsl_sf_result	O
*	O
result	pointer
)	O
{	O
if	O
(	O
x	O
>	O
0.0	int
)	O
{	O
return	O
gsl_sf_lambert_W0_e	int
(	O
x	int
,	O
result	O
)	O
;	O
}	O
else	O
if	O
(	O
x	O
==	O
0.0	O
)	O
{	O
result	O
->	O
val	int
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	pointer
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
int	O
MAX_ITERS	function
=	O
32	O
;	O
const	O
double	O
one_over_E	double
=	O
1.0	O
/	O
M_E	O
;	O
const	O
double	O
q	double
=	O
x	O
+	O
one_over_E	int
;	O
double	O
w	double
;	O
if	O
(	O
q	O
<	O
0.0	int
)	O
{	O
result	O
->	O
val	double
=	O
-	int
1.0	int
;	O
result	O
->	O
err	double
=	O
sqrt	int
(	O
-	double
q	int
)	O
;	O
return	O
GSL_EDOM	int
;	O
}	O
if	O
(	O
x	O
<	O
-	int
1.0e-6	int
)	O
{	O
const	O
double	O
r	double
=	O
-	int
sqrt	int
(	O
q	O
)	O
;	O
w	O
=	O
series_eval	O
(	O
r	double
)	O
;	O
if	O
(	O
q	O
<	O
3.0e-3	int
)	O
{	O
result	O
->	O
val	double
=	O
w	int
;	O
result	pointer
->	O
err	double
=	O
5.0	int
*	O
GSL_DBL_EPSILON	double
*	O
fabs	O
(	O
w	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
{	O
const	O
double	O
L_1	double
=	O
log	O
(	O
-	O
x	int
)	O
;	O
const	O
double	O
L_2	double
=	O
log	O
(	O
-	O
L_1	int
)	O
;	O
w	O
=	O
L_1	O
-	O
L_2	int
+	O
L_2	int
/	O
L_1	int
;	O
}	O
return	O
halley_iteration	int
(	O
x	O
,	O
w	O
,	O
MAX_ITERS	O
,	O
result	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_lambert_W0	function
(	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_lambert_W0_e	O
(	O
x	O
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_lambert_Wm1	function
(	O
double	O
x	O
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_lambert_Wm1_e	O
(	O
x	O
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O