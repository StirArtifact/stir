typedef	O
struct	O
{	O
int	O
lx	int
,	O
rx	double
;	O
int	O
lw	int
,	O
rw	int
;	O
}	O
miArcSpan	struct
;	O
typedef	O
struct	O
{	O
int	O
k	int
;	O
miArcSpan	struct
*	O
spans	pointer
;	O
bool	enum
top	enum
;	O
int	O
count1	int
;	O
int	O
count2	int
;	O
bool	enum
bot	enum
;	O
bool	enum
hole	enum
;	O
}	O
miArcSpanData	struct
;	O
typedef	O
struct	O
{	O
unsigned	O
long	O
lrustamp	long
;	O
unsigned	O
int	O
width	array
,	O
height	int
;	O
unsigned	O
int	O
lw	int
;	O
miArcSpanData	struct
*	O
spdata	pointer
;	O
}	O
cachedEllipse	struct
;	O
struct	O
lib_miEllipseCache	struct
{	O
cachedEllipse	struct
*	O
ellipses	pointer
;	O
int	O
size	double
;	O
cachedEllipse	struct
*	O
lastCacheHit	pointer
;	O
unsigned	O
long	O
lrustamp	long
;	O
}	O
;	O
typedef	O
struct	O
{	O
int	O
arcIndex0	int
,	O
arcIndex1	int
;	O
int	O
paintType0	int
,	O
paintType1	int
;	O
int	O
end0	int
,	O
end1	int
;	O
}	O
miArcJoinStruct	struct
;	O
typedef	O
struct	O
{	O
int	O
arcIndex	int
;	O
int	O
end	int
;	O
}	O
miArcCapStruct	struct
;	O
typedef	O
struct	O
{	O
SppPoint	struct
clock	function
;	O
SppPoint	struct
center	struct
;	O
SppPoint	struct
counterClock	struct
;	O
}	O
miArcFace	struct
;	O
typedef	O
struct	O
{	O
miArc	struct
arc	struct
;	O
bool	enum
render	enum
;	O
int	O
join	int
;	O
int	O
cap	int
;	O
bool	enum
selfJoin	enum
;	O
miArcFace	struct
bounds	array
[	O
2	int
]	O
;	O
double	O
x0	double
,	O
y0	function
;	O
double	O
x1	double
,	O
y1	function
;	O
}	O
miArcData	struct
;	O
typedef	O
struct	O
{	O
miArcData	struct
*	O
arcs	pointer
;	O
int	O
narcs	int
;	O
int	O
arcSize	int
;	O
miArcCapStruct	struct
*	O
caps	pointer
;	O
int	O
ncaps	int
;	O
int	O
capSize	int
;	O
miArcJoinStruct	struct
*	O
joins	pointer
;	O
int	O
njoins	int
;	O
int	O
joinSize	int
;	O
}	O
miPolyArcs	struct
;	O
struct	O
finalSpan	struct
{	O
int	O
min	int
,	O
max	int
;	O
struct	O
finalSpan	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
finalSpanChunk	struct
{	O
struct	O
finalSpan	struct
data	pointer
[	O
SPAN_CHUNK_SIZE	int
]	O
;	O
struct	O
finalSpanChunk	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
{	O
struct	O
finalSpan	struct
*	O
*	O
finalSpans	pointer
;	O
int	O
finalMiny	int
,	O
finalMaxy	int
;	O
int	O
finalSize	int
;	O
int	O
nspans	int
;	O
struct	O
finalSpanChunk	struct
*	O
chunks	pointer
;	O
struct	O
finalSpan	struct
*	O
freeFinalSpans	pointer
;	O
}	O
miAccumSpans	struct
;	O
typedef	O
struct	O
{	O
double	O
map	array
[	O
DASH_MAP_SIZE	int
]	O
;	O
}	O
dashMap	struct
;	O
static	O
void	O
fillSpans	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
;	O
static	O
void	O
miArcCap	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArcFace	struct
*	O
pFace	pointer
,	O
int	O
end	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
;	O
static	O
void	O
miArcJoin	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArcFace	struct
*	O
pLeft	pointer
,	O
const	O
miArcFace	struct
*	O
pRight	pointer
,	O
int	O
xOrgLeft	int
,	O
int	O
yOrgLeft	int
,	O
double	O
xFtransLeft	double
,	O
double	O
yFtransLeft	double
,	O
int	O
xOrgRight	int
,	O
int	O
yOrgRight	int
,	O
double	O
xFtransRight	double
,	O
double	O
yFtransRight	double
)	O
;	O
static	O
void	O
miFillWideEllipse	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
;	O
static	O
void	O
miRoundCap	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
SppPoint	struct
pCenter	struct
,	O
SppPoint	struct
pEnd	struct
,	O
SppPoint	struct
pCorner	struct
,	O
SppPoint	struct
pOtherCorner	struct
,	O
int	O
fLineEnd	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
;	O
static	O
double	O
angleBetween	function
(	O
SppPoint	struct
center	struct
,	O
SppPoint	struct
point1	struct
,	O
SppPoint	struct
point2	struct
)	O
;	O
static	O
double	O
miDasin	function
(	O
double	O
v	pointer
)	O
;	O
static	O
double	O
miDatan2	function
(	O
double	O
dy	int
,	O
double	O
dx	int
)	O
;	O
static	O
double	O
miDcos	function
(	O
double	O
a	double
)	O
;	O
static	O
double	O
miDsin	function
(	O
double	O
a	double
)	O
;	O
static	O
int	O
computeAngleFromPath	function
(	O
int	O
startAngle	int
,	O
int	O
endAngle	int
,	O
const	O
dashMap	struct
*	O
map	array
,	O
int	O
*	O
lenp	pointer
,	O
bool	enum
backwards	enum
)	O
;	O
static	O
int	O
miGetArcPts	function
(	O
const	O
SppArc	struct
*	O
parc	pointer
,	O
int	O
cpt	int
,	O
SppPoint	struct
*	O
*	O
ppPts	pointer
)	O
;	O
static	O
miArcData	struct
*	O
addArc	function
(	O
miPolyArcs	struct
*	O
polyArcs	pointer
,	O
const	O
miArc	struct
*	O
xarc	pointer
)	O
;	O
static	O
miArcSpanData	struct
*	O
miComputeWideEllipse	function
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
bool	enum
*	O
mustFree	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
;	O
static	O
miPolyArcs	struct
*	O
miComputeArcs	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
parcs	pointer
,	O
int	O
narcs	int
)	O
;	O
static	O
void	O
addCap	function
(	O
miPolyArcs	struct
*	O
polyArcs	pointer
,	O
int	O
end	int
,	O
int	O
arcIndex	int
)	O
;	O
static	O
void	O
addJoin	function
(	O
miPolyArcs	struct
*	O
polyArcs	pointer
,	O
int	O
end0	int
,	O
int	O
index0	int
,	O
int	O
paintType0	int
,	O
int	O
end1	int
,	O
int	O
index1	int
,	O
int	O
paintType1	int
)	O
;	O
static	O
void	O
computeDashMap	function
(	O
const	O
miArc	struct
*	O
arcp	pointer
,	O
dashMap	struct
*	O
map	array
)	O
;	O
static	O
void	O
drawArc	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
const	O
miArc	struct
*	O
tarc	pointer
,	O
unsigned	O
int	O
l	int
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
;	O
static	O
void	O
drawZeroArc	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
const	O
miArc	struct
*	O
tarc	pointer
,	O
unsigned	O
int	O
lw	int
,	O
miArcFace	struct
*	O
left	pointer
,	O
miArcFace	struct
*	O
right	pointer
)	O
;	O
static	O
void	O
initAccumSpans	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
;	O
static	O
void	O
miArcSegment	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
miArc	struct
tarc	pointer
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
;	O
static	O
void	O
miComputeCircleSpans	function
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
miArcSpanData	struct
*	O
spdata	pointer
)	O
;	O
static	O
void	O
miComputeEllipseSpans	function
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
miArcSpanData	struct
*	O
spdata	pointer
)	O
;	O
static	O
void	O
miFreeArcs	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miPolyArcs	struct
*	O
arcs	pointer
)	O
;	O
static	O
void	O
translateBounds	function
(	O
miArcFace	struct
*	O
b	pointer
,	O
int	O
x	double
,	O
int	O
y	double
,	O
double	O
fx	double
,	O
double	O
fy	double
)	O
;	O
void	O
miPolyArc_r	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
narcs	int
,	O
const	O
miArc	struct
*	O
parcs	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
int	O
i	int
;	O
const	O
miArc	struct
*	O
parc	pointer
;	O
int	O
width	array
;	O
miPixel	struct
pixel	struct
;	O
miPolyArcs	struct
*	O
polyArcs	pointer
;	O
int	O
*	O
cap	int
,	O
*	O
join	int
;	O
int	O
paintType	int
;	O
miAccumSpans	struct
accumSpans_struct	struct
;	O
if	O
(	O
narcs	int
<=	O
0	int
)	O
return	O
;	O
initAccumSpans	function
(	O
&	O
accumSpans_struct	struct
)	O
;	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
;	O
width	array
=	O
pGC	pointer
->	O
lineWidth	int
;	O
if	O
(	O
width	array
==	O
0	int
&&	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
{	O
for	O
(	O
i	int
=	O
narcs	int
,	O
parc	pointer
=	O
parcs	pointer
;	O
--	O
i	int
>=	O
0	int
;	O
parc	pointer
++	O
)	O
miArcSegment	function
(	O
pGC	pointer
,	O
&	O
accumSpans_struct	struct
,	O
*	O
parc	pointer
,	O
(	O
miArcFace	struct
*	O
)	O
NULL	O
,	O
(	O
miArcFace	struct
*	O
)	O
NULL	O
,	O
ellipseCache	pointer
)	O
;	O
fillSpans	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
&	O
accumSpans_struct	struct
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
&&	O
narcs	int
)	O
{	O
while	O
(	O
parcs	pointer
->	O
width	array
&&	O
parcs	pointer
->	O
height	int
&&	O
(	O
parcs	pointer
->	O
angle2	int
>=	O
FULLCIRCLE	O
||	O
parcs	pointer
->	O
angle2	int
<=	O
-	O
FULLCIRCLE	O
)	O
)	O
{	O
miFillWideEllipse	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
parcs	pointer
,	O
ellipseCache	pointer
)	O
;	O
if	O
(	O
--	O
narcs	int
==	O
0	int
)	O
return	O
;	O
parcs	pointer
++	O
;	O
}	O
}	O
polyArcs	pointer
=	O
miComputeArcs	function
(	O
pGC	pointer
,	O
parcs	pointer
,	O
narcs	int
)	O
;	O
cap	int
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
pGC	pointer
->	O
numPixels	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
join	int
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
pGC	pointer
->	O
numPixels	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pGC	pointer
->	O
numPixels	int
;	O
i	int
++	O
)	O
cap	int
[	O
i	int
]	O
=	O
join	int
[	O
i	int
]	O
=	O
0	int
;	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
pGC	pointer
->	O
numPixels	int
;	O
paintType	int
++	O
)	O
{	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
paintType	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
;	O
i	int
++	O
)	O
{	O
miArcData	struct
*	O
arcData	pointer
;	O
arcData	pointer
=	O
&	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
i	int
]	O
;	O
miArcSegment	function
(	O
pGC	pointer
,	O
&	O
accumSpans_struct	struct
,	O
arcData	pointer
->	O
arc	struct
,	O
&	O
arcData	pointer
->	O
bounds	array
[	O
RIGHT_END	int
]	O
,	O
&	O
arcData	pointer
->	O
bounds	array
[	O
LEFT_END	int
]	O
,	O
ellipseCache	pointer
)	O
;	O
if	O
(	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
i	int
]	O
.	O
render	enum
)	O
{	O
fillSpans	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
&	O
accumSpans_struct	struct
)	O
;	O
if	O
(	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
&&	O
cap	int
[	O
paintType	int
]	O
<	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
i	int
]	O
.	O
cap	int
)	O
cap	int
[	O
paintType	int
]	O
++	O
;	O
while	O
(	O
cap	int
[	O
paintType	int
]	O
<	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
i	int
]	O
.	O
cap	int
)	O
{	O
int	O
arcIndex	int
,	O
end	int
;	O
miArcData	struct
*	O
arcData0	pointer
;	O
arcIndex	int
=	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
caps	pointer
[	O
cap	int
[	O
paintType	int
]	O
]	O
.	O
arcIndex	int
;	O
end	int
=	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
caps	pointer
[	O
cap	int
[	O
paintType	int
]	O
]	O
.	O
end	int
;	O
arcData0	pointer
=	O
&	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
arcIndex	int
]	O
;	O
miArcCap	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
arcData0	pointer
->	O
bounds	array
[	O
end	int
]	O
,	O
end	int
,	O
arcData0	pointer
->	O
arc	struct
.	O
x	double
,	O
arcData0	pointer
->	O
arc	struct
.	O
y	double
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	pointer
->	O
arc	struct
.	O
width	array
)	O
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	pointer
->	O
arc	struct
.	O
height	int
)	O
)	O
;	O
++	O
cap	int
[	O
paintType	int
]	O
;	O
}	O
while	O
(	O
join	int
[	O
paintType	int
]	O
<	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
i	int
]	O
.	O
join	int
)	O
{	O
int	O
arcIndex0	int
,	O
arcIndex1	int
,	O
end0	int
,	O
end1	int
;	O
int	O
paintType0	int
,	O
paintType1	int
;	O
miArcData	struct
*	O
arcData0	pointer
,	O
*	O
arcData1	pointer
;	O
miArcJoinStruct	struct
*	O
joinp	pointer
;	O
joinp	pointer
=	O
&	O
polyArcs	pointer
[	O
paintType	int
]	O
.	O
joins	pointer
[	O
join	int
[	O
paintType	int
]	O
]	O
;	O
arcIndex0	int
=	O
joinp	pointer
->	O
arcIndex0	int
;	O
end0	int
=	O
joinp	pointer
->	O
end0	int
;	O
arcIndex1	int
=	O
joinp	pointer
->	O
arcIndex1	int
;	O
end1	int
=	O
joinp	pointer
->	O
end1	int
;	O
paintType0	int
=	O
joinp	pointer
->	O
paintType0	int
;	O
paintType1	int
=	O
joinp	pointer
->	O
paintType1	int
;	O
arcData0	pointer
=	O
&	O
polyArcs	pointer
[	O
paintType0	int
]	O
.	O
arcs	pointer
[	O
arcIndex0	int
]	O
;	O
arcData1	pointer
=	O
&	O
polyArcs	pointer
[	O
paintType1	int
]	O
.	O
arcs	pointer
[	O
arcIndex1	int
]	O
;	O
miArcJoin	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
arcData0	pointer
->	O
bounds	array
[	O
end0	int
]	O
,	O
&	O
arcData1	pointer
->	O
bounds	array
[	O
end1	int
]	O
,	O
arcData0	pointer
->	O
arc	struct
.	O
x	double
,	O
arcData0	pointer
->	O
arc	struct
.	O
y	double
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	pointer
->	O
arc	struct
.	O
width	array
)	O
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData0	pointer
->	O
arc	struct
.	O
height	int
)	O
,	O
arcData1	pointer
->	O
arc	struct
.	O
x	double
,	O
arcData1	pointer
->	O
arc	struct
.	O
y	double
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData1	pointer
->	O
arc	struct
.	O
width	array
)	O
,	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcData1	pointer
->	O
arc	struct
.	O
height	int
)	O
)	O
;	O
++	O
join	int
[	O
paintType	int
]	O
;	O
}	O
}	O
}	O
}	O
free	function
(	O
cap	int
)	O
;	O
free	function
(	O
join	int
)	O
;	O
miFreeArcs	function
(	O
pGC	pointer
,	O
polyArcs	pointer
)	O
;	O
}	O
}	O
miEllipseCache	struct
*	O
miNewEllipseCache	O
(	O
void	O
)	O
{	O
int	O
k	int
;	O
cachedEllipse	struct
*	O
chead	pointer
,	O
*	O
cent	pointer
;	O
miEllipseCache	struct
*	O
ellipseCache	pointer
;	O
ellipseCache	pointer
=	O
(	O
miEllipseCache	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miEllipseCache	struct
)	O
)	O
;	O
ellipseCache	pointer
->	O
ellipses	pointer
=	O
(	O
cachedEllipse	struct
*	O
)	O
mi_xmalloc	O
(	O
ELLIPSECACHE_SIZE	int
*	O
sizeof	O
(	O
cachedEllipse	struct
)	O
)	O
;	O
ellipseCache	pointer
->	O
size	double
=	O
ELLIPSECACHE_SIZE	int
;	O
ellipseCache	pointer
->	O
lastCacheHit	pointer
=	O
ellipseCache	pointer
->	O
ellipses	pointer
;	O
ellipseCache	pointer
->	O
lrustamp	long
=	O
0	int
;	O
chead	pointer
=	O
ellipseCache	pointer
->	O
ellipses	pointer
;	O
for	O
(	O
k	int
=	O
ELLIPSECACHE_SIZE	int
,	O
cent	pointer
=	O
chead	pointer
;	O
--	O
k	int
>=	O
0	int
;	O
cent	pointer
++	O
)	O
{	O
cent	pointer
->	O
lrustamp	long
=	O
0	int
;	O
cent	pointer
->	O
lw	int
=	O
0	int
;	O
cent	pointer
->	O
width	array
=	O
cent	pointer
->	O
height	int
=	O
0	int
;	O
cent	pointer
->	O
spdata	pointer
=	O
(	O
miArcSpanData	struct
*	O
)	O
NULL	O
;	O
}	O
return	O
ellipseCache	pointer
;	O
}	O
void	O
miDeleteEllipseCache	O
(	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
int	O
k	int
,	O
cache_size	int
;	O
cachedEllipse	struct
*	O
chead	pointer
,	O
*	O
cent	pointer
;	O
chead	pointer
=	O
ellipseCache	pointer
->	O
ellipses	pointer
;	O
cache_size	int
=	O
ellipseCache	pointer
->	O
size	double
;	O
for	O
(	O
k	int
=	O
cache_size	int
,	O
cent	pointer
=	O
chead	pointer
;	O
--	O
k	int
>=	O
0	int
;	O
cent	pointer
++	O
)	O
{	O
miArcSpanData	struct
*	O
spdata	pointer
;	O
spdata	pointer
=	O
cent	pointer
->	O
spdata	pointer
;	O
if	O
(	O
spdata	pointer
)	O
{	O
free	function
(	O
spdata	pointer
->	O
spans	pointer
)	O
;	O
free	function
(	O
spdata	pointer
)	O
;	O
}	O
}	O
free	function
(	O
chead	pointer
)	O
;	O
free	function
(	O
ellipseCache	pointer
)	O
;	O
}	O
static	O
void	O
miArcSegment	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
miArc	struct
tarc	pointer
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
unsigned	O
int	O
l	int
=	O
pGC	pointer
->	O
lineWidth	int
;	O
int	O
a0	int
,	O
a1	int
,	O
startAngle	int
,	O
endAngle	int
;	O
miArcFace	struct
*	O
temp	pointer
;	O
if	O
(	O
l	int
==	O
0	int
)	O
l	int
=	O
1	int
;	O
if	O
(	O
tarc	pointer
.	O
width	array
==	O
0	int
||	O
tarc	pointer
.	O
height	int
==	O
0	int
)	O
{	O
drawZeroArc	function
(	O
accumSpans	pointer
,	O
&	O
tarc	pointer
,	O
l	int
,	O
left	pointer
,	O
right	pointer
)	O
;	O
return	O
;	O
}	O
a0	int
=	O
tarc	pointer
.	O
angle1	int
;	O
a1	int
=	O
tarc	pointer
.	O
angle2	int
;	O
if	O
(	O
a1	int
>	O
FULLCIRCLE	O
)	O
a1	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
a1	int
<	O
-	O
FULLCIRCLE	O
)	O
a1	int
=	O
-	O
FULLCIRCLE	O
;	O
if	O
(	O
a1	int
<	O
0	int
)	O
{	O
startAngle	int
=	O
a0	int
+	O
a1	int
;	O
endAngle	int
=	O
a0	int
;	O
temp	pointer
=	O
right	pointer
;	O
right	pointer
=	O
left	pointer
;	O
left	pointer
=	O
temp	pointer
;	O
}	O
else	O
{	O
startAngle	int
=	O
a0	int
;	O
endAngle	int
=	O
a0	int
+	O
a1	int
;	O
}	O
if	O
(	O
startAngle	int
<	O
0	int
)	O
startAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
startAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
>=	O
FULLCIRCLE	O
)	O
startAngle	int
=	O
startAngle	int
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
<	O
0	int
)	O
endAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
endAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
>	O
FULLCIRCLE	O
)	O
endAngle	int
=	O
(	O
endAngle	int
-	O
1	int
)	O
%	O
FULLCIRCLE	O
+	O
1	int
;	O
if	O
(	O
(	O
startAngle	int
==	O
endAngle	int
)	O
&&	O
a1	int
)	O
{	O
startAngle	int
=	O
0	int
;	O
endAngle	int
=	O
FULLCIRCLE	O
;	O
}	O
drawArc	function
(	O
accumSpans	pointer
,	O
&	O
tarc	pointer
,	O
l	int
,	O
startAngle	int
,	O
endAngle	int
,	O
right	pointer
,	O
left	pointer
,	O
ellipseCache	pointer
)	O
;	O
}	O
static	O
void	O
miFillWideEllipse	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
miArcSpanData	struct
*	O
spdata	pointer
;	O
bool	enum
mustFree	pointer
;	O
miArcSpan	struct
*	O
arcSpan	pointer
,	O
*	O
finalArcSpan	pointer
;	O
int	O
xorg	int
,	O
yorgu	int
,	O
yorgl	int
;	O
int	O
numArcSpans	int
,	O
n	array
;	O
int	O
numSpans_downward	int
,	O
numSpans_upward	int
,	O
numSpans	int
,	O
botSpans	int
;	O
miPoint	struct
*	O
pptInit	pointer
,	O
*	O
ppt_downward	pointer
,	O
*	O
ppt_upward	pointer
;	O
unsigned	O
int	O
*	O
pwidthInit	pointer
,	O
*	O
pwidth_downward	pointer
,	O
*	O
pwidth_upward	pointer
;	O
spdata	pointer
=	O
miComputeWideEllipse	function
(	O
pGC	pointer
->	O
lineWidth	int
,	O
parc	pointer
,	O
&	O
mustFree	pointer
,	O
ellipseCache	pointer
)	O
;	O
if	O
(	O
!	O
spdata	pointer
)	O
return	O
;	O
arcSpan	pointer
=	O
spdata	pointer
->	O
spans	pointer
;	O
xorg	int
=	O
parc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
parc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
yorgu	int
=	O
parc	pointer
->	O
y	double
+	O
(	O
int	O
)	O
(	O
parc	pointer
->	O
height	int
>>	O
1	int
)	O
;	O
yorgl	int
=	O
yorgu	int
+	O
(	O
parc	pointer
->	O
height	int
&	O
1	int
)	O
;	O
yorgu	int
-=	O
spdata	pointer
->	O
k	int
;	O
yorgl	int
+=	O
spdata	pointer
->	O
k	int
;	O
numArcSpans	int
=	O
(	O
(	O
spdata	pointer
->	O
top	enum
?	O
1	int
:	O
0	int
)	O
+	O
spdata	pointer
->	O
count1	int
+	O
spdata	pointer
->	O
count2	int
+	O
(	O
spdata	pointer
->	O
bot	enum
?	O
1	int
:	O
0	int
)	O
)	O
;	O
finalArcSpan	pointer
=	O
&	O
(	O
spdata	pointer
->	O
spans	pointer
[	O
numArcSpans	int
-	O
1	int
]	O
)	O
;	O
botSpans	int
=	O
(	O
finalArcSpan	pointer
->	O
rw	int
<=	O
0	int
?	O
1	int
:	O
2	int
)	O
;	O
numSpans_downward	int
=	O
(	O
(	O
spdata	pointer
->	O
top	enum
?	O
1	int
:	O
0	int
)	O
+	O
spdata	pointer
->	O
count1	int
+	O
2	int
*	O
spdata	pointer
->	O
count2	int
+	O
(	O
spdata	pointer
->	O
bot	enum
?	O
botSpans	int
:	O
0	int
)	O
)	O
;	O
numSpans_upward	int
=	O
(	O
spdata	pointer
->	O
count1	int
+	O
(	O
spdata	pointer
->	O
hole	enum
?	O
1	int
:	O
0	int
)	O
+	O
2	int
*	O
spdata	pointer
->	O
count2	int
)	O
;	O
numSpans	int
=	O
numSpans_downward	int
+	O
numSpans_upward	int
;	O
pptInit	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
numSpans	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
pwidthInit	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
numSpans	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
ppt_downward	pointer
=	O
pptInit	pointer
;	O
pwidth_downward	pointer
=	O
pwidthInit	pointer
;	O
ppt_upward	pointer
=	O
pptInit	pointer
+	O
(	O
numSpans	int
-	O
1	int
)	O
;	O
pwidth_upward	pointer
=	O
pwidthInit	pointer
+	O
(	O
numSpans	int
-	O
1	int
)	O
;	O
if	O
(	O
spdata	pointer
->	O
top	enum
)	O
{	O
ppt_downward	pointer
->	O
x	double
=	O
xorg	int
;	O
ppt_downward	pointer
->	O
y	double
=	O
yorgu	int
-	O
1	int
;	O
ppt_downward	pointer
++	O
;	O
*	O
pwidth_downward	pointer
++	O
=	O
1	int
;	O
arcSpan	pointer
++	O
;	O
}	O
for	O
(	O
n	array
=	O
spdata	pointer
->	O
count1	int
;	O
--	O
n	array
>=	O
0	int
;	O
)	O
{	O
ppt_downward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
lx	int
;	O
ppt_downward	pointer
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	pointer
=	O
arcSpan	pointer
->	O
lw	int
;	O
ppt_downward	pointer
++	O
;	O
pwidth_downward	pointer
++	O
;	O
ppt_upward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
lx	int
;	O
ppt_upward	pointer
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	pointer
=	O
arcSpan	pointer
->	O
lw	int
;	O
ppt_upward	pointer
--	O
;	O
pwidth_upward	pointer
--	O
;	O
yorgu	int
++	O
;	O
yorgl	int
--	O
;	O
arcSpan	pointer
++	O
;	O
}	O
if	O
(	O
spdata	pointer
->	O
hole	enum
)	O
{	O
ppt_upward	pointer
->	O
x	double
=	O
xorg	int
;	O
ppt_upward	pointer
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	pointer
=	O
1	int
;	O
ppt_upward	pointer
--	O
;	O
pwidth_upward	pointer
--	O
;	O
}	O
for	O
(	O
n	array
=	O
spdata	pointer
->	O
count2	int
;	O
--	O
n	array
>=	O
0	int
;	O
)	O
{	O
ppt_downward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
lx	int
;	O
ppt_downward	pointer
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	pointer
=	O
arcSpan	pointer
->	O
lw	int
;	O
ppt_downward	pointer
++	O
;	O
pwidth_downward	pointer
++	O
;	O
ppt_downward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
rx	double
;	O
ppt_downward	pointer
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	pointer
=	O
arcSpan	pointer
->	O
rw	int
;	O
ppt_downward	pointer
++	O
;	O
pwidth_downward	pointer
++	O
;	O
ppt_upward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
lx	int
;	O
ppt_upward	pointer
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	pointer
=	O
arcSpan	pointer
->	O
lw	int
;	O
ppt_upward	pointer
--	O
;	O
pwidth_upward	pointer
--	O
;	O
ppt_upward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
rx	double
;	O
ppt_upward	pointer
->	O
y	double
=	O
yorgl	int
;	O
*	O
pwidth_upward	pointer
=	O
arcSpan	pointer
->	O
rw	int
;	O
ppt_upward	pointer
--	O
;	O
pwidth_upward	pointer
--	O
;	O
yorgu	int
++	O
;	O
yorgl	int
--	O
;	O
arcSpan	pointer
++	O
;	O
}	O
if	O
(	O
spdata	pointer
->	O
bot	enum
)	O
{	O
ppt_downward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
lx	int
;	O
ppt_downward	pointer
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	pointer
=	O
arcSpan	pointer
->	O
lw	int
;	O
ppt_downward	pointer
++	O
;	O
pwidth_downward	pointer
++	O
;	O
if	O
(	O
arcSpan	pointer
->	O
rw	int
>	O
0	int
)	O
{	O
ppt_downward	pointer
->	O
x	double
=	O
xorg	int
+	O
arcSpan	pointer
->	O
rx	double
;	O
ppt_downward	pointer
->	O
y	double
=	O
yorgu	int
;	O
*	O
pwidth_downward	pointer
=	O
arcSpan	pointer
->	O
rw	int
;	O
ppt_downward	pointer
++	O
;	O
pwidth_downward	pointer
++	O
;	O
}	O
}	O
if	O
(	O
mustFree	pointer
)	O
{	O
free	function
(	O
spdata	pointer
->	O
spans	pointer
)	O
;	O
free	function
(	O
spdata	pointer
)	O
;	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
numSpans	int
,	O
pptInit	pointer
,	O
pwidthInit	pointer
)	O
}	O
static	O
miArcSpanData	struct
*	O
miComputeWideEllipse	function
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
bool	enum
*	O
mustFree	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
miArcSpanData	struct
*	O
spdata	pointer
;	O
cachedEllipse	struct
*	O
cent	pointer
,	O
*	O
lruent	pointer
;	O
int	O
k	int
,	O
cache_size	int
;	O
cachedEllipse	struct
fakeent	struct
;	O
if	O
(	O
lw	int
==	O
0	int
)	O
lw	int
=	O
1	int
;	O
if	O
(	O
parc	pointer
->	O
height	int
<=	O
MAX_CACHEABLE_ELLIPSE_HEIGHT	int
)	O
{	O
*	O
mustFree	pointer
=	O
false	int
;	O
cent	pointer
=	O
ellipseCache	pointer
->	O
lastCacheHit	pointer
;	O
if	O
(	O
cent	pointer
->	O
lw	int
==	O
lw	int
&&	O
cent	pointer
->	O
width	array
==	O
parc	pointer
->	O
width	array
&&	O
cent	pointer
->	O
height	int
==	O
parc	pointer
->	O
height	int
)	O
{	O
cent	pointer
->	O
lrustamp	long
=	O
++	O
(	O
ellipseCache	pointer
->	O
lrustamp	long
)	O
;	O
return	O
cent	pointer
->	O
spdata	pointer
;	O
}	O
lruent	pointer
=	O
ellipseCache	pointer
->	O
ellipses	pointer
;	O
cache_size	int
=	O
ellipseCache	pointer
->	O
size	double
;	O
for	O
(	O
k	int
=	O
cache_size	int
,	O
cent	pointer
=	O
lruent	pointer
;	O
--	O
k	int
>=	O
0	int
;	O
cent	pointer
++	O
)	O
{	O
if	O
(	O
cent	pointer
->	O
lw	int
==	O
lw	int
&&	O
cent	pointer
->	O
width	array
==	O
parc	pointer
->	O
width	array
&&	O
cent	pointer
->	O
height	int
==	O
parc	pointer
->	O
height	int
)	O
{	O
cent	pointer
->	O
lrustamp	long
=	O
++	O
(	O
ellipseCache	pointer
->	O
lrustamp	long
)	O
;	O
ellipseCache	pointer
->	O
lastCacheHit	pointer
=	O
cent	pointer
;	O
return	O
cent	pointer
->	O
spdata	pointer
;	O
}	O
if	O
(	O
cent	pointer
->	O
lrustamp	long
<	O
lruent	pointer
->	O
lrustamp	long
)	O
lruent	pointer
=	O
cent	pointer
;	O
}	O
}	O
else	O
{	O
lruent	pointer
=	O
&	O
fakeent	struct
;	O
lruent	pointer
->	O
spdata	pointer
=	O
(	O
miArcSpanData	struct
*	O
)	O
NULL	O
;	O
*	O
mustFree	pointer
=	O
true	int
;	O
}	O
spdata	pointer
=	O
lruent	pointer
->	O
spdata	pointer
;	O
k	int
=	O
(	O
int	O
)	O
(	O
parc	pointer
->	O
height	int
>>	O
1	int
)	O
+	O
(	O
int	O
)	O
(	O
(	O
lw	int
-	O
1	int
)	O
>>	O
1	int
)	O
;	O
if	O
(	O
spdata	pointer
==	O
(	O
miArcSpanData	struct
*	O
)	O
NULL	O
||	O
spdata	pointer
->	O
k	int
!=	O
k	int
)	O
{	O
if	O
(	O
spdata	pointer
)	O
{	O
free	function
(	O
spdata	pointer
->	O
spans	pointer
)	O
;	O
free	function
(	O
spdata	pointer
)	O
;	O
}	O
spdata	pointer
=	O
(	O
miArcSpanData	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miArcSpanData	struct
)	O
)	O
;	O
spdata	pointer
->	O
spans	pointer
=	O
(	O
miArcSpan	struct
*	O
)	O
mi_xmalloc	O
(	O
(	O
k	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
miArcSpan	struct
)	O
)	O
;	O
spdata	pointer
->	O
k	int
=	O
k	int
;	O
lruent	pointer
->	O
spdata	pointer
=	O
spdata	pointer
;	O
}	O
lruent	pointer
->	O
lrustamp	long
=	O
++	O
(	O
ellipseCache	pointer
->	O
lrustamp	long
)	O
;	O
lruent	pointer
->	O
lw	int
=	O
lw	int
;	O
lruent	pointer
->	O
width	array
=	O
parc	pointer
->	O
width	array
;	O
lruent	pointer
->	O
height	int
=	O
parc	pointer
->	O
height	int
;	O
if	O
(	O
lruent	pointer
!=	O
&	O
fakeent	struct
)	O
ellipseCache	pointer
->	O
lastCacheHit	pointer
=	O
lruent	pointer
;	O
if	O
(	O
parc	pointer
->	O
width	array
==	O
parc	pointer
->	O
height	int
)	O
miComputeCircleSpans	function
(	O
lw	int
,	O
parc	pointer
,	O
spdata	pointer
)	O
;	O
else	O
miComputeEllipseSpans	function
(	O
lw	int
,	O
parc	pointer
,	O
spdata	pointer
)	O
;	O
return	O
spdata	pointer
;	O
}	O
static	O
void	O
miComputeCircleSpans	function
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
miArcSpanData	struct
*	O
spdata	pointer
)	O
{	O
miArcSpan	struct
*	O
span	pointer
;	O
int	O
doinner	int
;	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
int	O
xk	int
,	O
yk	int
,	O
xm	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
;	O
int	O
slw	int
,	O
inslw	int
;	O
int	O
inx	int
=	O
0	int
,	O
iny	int
,	O
ine	int
=	O
0	int
;	O
int	O
inxk	int
=	O
0	int
,	O
inyk	int
=	O
0	int
,	O
inxm	int
=	O
0	int
,	O
inym	int
=	O
0	int
;	O
spdata	pointer
->	O
top	enum
=	O
!	O
(	O
lw	int
&	O
1	int
)	O
&&	O
!	O
(	O
parc	pointer
->	O
width	array
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
spdata	pointer
->	O
bot	enum
=	O
!	O
(	O
parc	pointer
->	O
height	int
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
doinner	int
=	O
-	O
(	O
int	O
)	O
lw	int
;	O
slw	int
=	O
(	O
int	O
)	O
parc	pointer
->	O
width	array
-	O
doinner	int
;	O
y	double
=	O
(	O
int	O
)	O
(	O
parc	pointer
->	O
height	int
>>	O
1	int
)	O
;	O
dy	int
=	O
parc	pointer
->	O
height	int
&	O
1	int
;	O
dx	int
=	O
1	int
-	O
dy	int
;	O
MIWIDEARCSETUP	O
(	O
x	double
,	O
y	double
,	O
dy	int
,	O
slw	int
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
)	O
;	O
inslw	int
=	O
(	O
int	O
)	O
parc	pointer
->	O
width	array
+	O
doinner	int
;	O
if	O
(	O
inslw	int
>	O
0	int
)	O
{	O
spdata	pointer
->	O
hole	enum
=	O
spdata	pointer
->	O
top	enum
;	O
MIWIDEARCSETUP	O
(	O
inx	int
,	O
iny	int
,	O
dy	int
,	O
inslw	int
,	O
ine	int
,	O
inxk	int
,	O
inxm	int
,	O
inyk	int
,	O
inym	int
)	O
;	O
}	O
else	O
{	O
spdata	pointer
->	O
hole	enum
=	O
false	int
;	O
doinner	int
=	O
-	O
y	double
;	O
}	O
spdata	pointer
->	O
count1	int
=	O
-	O
doinner	int
-	O
(	O
spdata	pointer
->	O
top	enum
?	O
1	int
:	O
0	int
)	O
;	O
spdata	pointer
->	O
count2	int
=	O
y	double
+	O
doinner	int
;	O
span	pointer
=	O
spdata	pointer
->	O
spans	pointer
;	O
while	O
(	O
y	double
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
span	pointer
->	O
lx	int
=	O
dy	int
-	O
x	double
;	O
if	O
(	O
++	O
doinner	int
<=	O
0	int
)	O
{	O
span	pointer
->	O
lw	int
=	O
slw	int
;	O
span	pointer
->	O
rx	double
=	O
0	int
;	O
span	pointer
->	O
rw	int
=	O
span	pointer
->	O
lx	int
+	O
slw	int
;	O
}	O
else	O
{	O
MIFILLINARCSTEP	O
(	O
inx	int
,	O
iny	int
,	O
ine	int
,	O
inxk	int
,	O
inxm	int
,	O
inyk	int
,	O
inym	int
,	O
dx	int
,	O
inslw	int
)	O
;	O
span	pointer
->	O
lw	int
=	O
x	double
-	O
inx	int
;	O
span	pointer
->	O
rx	double
=	O
dy	int
-	O
inx	int
+	O
inslw	int
;	O
span	pointer
->	O
rw	int
=	O
inx	int
-	O
x	double
+	O
slw	int
-	O
inslw	int
;	O
}	O
span	pointer
++	O
;	O
}	O
if	O
(	O
spdata	pointer
->	O
bot	enum
)	O
{	O
if	O
(	O
spdata	pointer
->	O
count2	int
>	O
0	int
)	O
spdata	pointer
->	O
count2	int
--	O
;	O
else	O
{	O
if	O
(	O
lw	int
>	O
parc	pointer
->	O
height	int
)	O
span	pointer
[	O
-	O
1	int
]	O
.	O
rx	double
=	O
span	pointer
[	O
-	O
1	int
]	O
.	O
rw	int
=	O
-	O
(	O
(	O
(	O
int	O
)	O
lw	int
-	O
(	O
int	O
)	O
parc	pointer
->	O
height	int
)	O
>>	O
1	int
)	O
;	O
else	O
span	pointer
[	O
-	O
1	int
]	O
.	O
rw	int
=	O
0	int
;	O
spdata	pointer
->	O
count1	int
--	O
;	O
}	O
}	O
}	O
static	O
void	O
miComputeEllipseSpans	function
(	O
unsigned	O
int	O
lw	int
,	O
const	O
miArc	struct
*	O
parc	pointer
,	O
miArcSpanData	struct
*	O
spdata	pointer
)	O
{	O
miArcSpan	struct
*	O
span	pointer
;	O
double	O
w	double
,	O
h	double
,	O
r	int
,	O
xorg	int
;	O
double	O
Hs	double
,	O
Hf	double
,	O
WH	double
,	O
K	double
,	O
Vk	double
,	O
Nk	double
,	O
Fk	double
,	O
Vr	double
,	O
N	double
,	O
Nc	double
,	O
Z	double
,	O
rs	double
;	O
double	O
A	double
,	O
T	double
,	O
b	pointer
,	O
d	double
,	O
x	double
,	O
y	double
,	O
t	double
,	O
inx	int
,	O
outx	double
=	O
0	int
,	O
hepp	double
,	O
hepm	double
;	O
int	O
flip	int
;	O
bool	enum
solution	enum
;	O
spdata	pointer
->	O
top	enum
=	O
!	O
(	O
lw	int
&	O
1	int
)	O
&&	O
!	O
(	O
parc	pointer
->	O
width	array
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
spdata	pointer
->	O
bot	enum
=	O
!	O
(	O
parc	pointer
->	O
height	int
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
spdata	pointer
->	O
hole	enum
=	O
(	O
(	O
spdata	pointer
->	O
top	enum
&&	O
parc	pointer
->	O
height	int
*	O
lw	int
<=	O
parc	pointer
->	O
width	array
*	O
parc	pointer
->	O
width	array
&&	O
lw	int
<	O
parc	pointer
->	O
height	int
)	O
?	O
true	int
:	O
false	int
)	O
;	O
w	double
=	O
0.5	int
*	O
parc	pointer
->	O
width	array
;	O
h	double
=	O
0.5	int
*	O
parc	pointer
->	O
height	int
;	O
r	int
=	O
0.5	int
*	O
lw	int
;	O
rs	double
=	O
r	int
*	O
r	int
;	O
Hs	double
=	O
h	double
*	O
h	double
;	O
WH	double
=	O
w	double
*	O
w	double
-	O
Hs	double
;	O
Nk	double
=	O
w	double
*	O
r	int
;	O
Vk	double
=	O
(	O
Nk	double
*	O
Hs	double
)	O
/	O
(	O
WH	double
+	O
WH	double
)	O
;	O
Hf	double
=	O
Hs	double
*	O
Hs	double
;	O
Nk	double
=	O
(	O
Hf	double
-	O
Nk	double
*	O
Nk	double
)	O
/	O
WH	double
;	O
Fk	double
=	O
Hf	double
/	O
WH	double
;	O
hepp	double
=	O
h	double
+	O
EPSILON	int
;	O
hepm	double
=	O
h	double
-	O
EPSILON	int
;	O
K	double
=	O
h	double
+	O
(	O
(	O
lw	int
-	O
1	int
)	O
>>	O
1	int
)	O
;	O
if	O
(	O
parc	pointer
->	O
width	array
&	O
1	int
)	O
xorg	int
=	O
.5	int
;	O
else	O
xorg	int
=	O
0.0	int
;	O
spdata	pointer
->	O
count1	int
=	O
0	int
;	O
spdata	pointer
->	O
count2	int
=	O
0	int
;	O
span	pointer
=	O
spdata	pointer
->	O
spans	pointer
;	O
if	O
(	O
spdata	pointer
->	O
top	enum
)	O
{	O
span	pointer
->	O
lx	int
=	O
0	int
;	O
span	pointer
->	O
lw	int
=	O
1	int
;	O
span	pointer
++	O
;	O
}	O
for	O
(	O
;	O
K	double
>	O
0.0	int
;	O
K	double
-=	O
1.0	int
)	O
{	O
N	double
=	O
(	O
K	double
*	O
K	double
+	O
Nk	double
)	O
/	O
6.0	int
;	O
Nc	double
=	O
N	double
*	O
N	double
*	O
N	double
;	O
Vr	double
=	O
Vk	double
*	O
K	double
;	O
t	double
=	O
Nc	double
+	O
Vr	double
*	O
Vr	double
;	O
d	double
=	O
Nc	double
+	O
t	double
;	O
if	O
(	O
d	double
<	O
0.0	int
)	O
{	O
d	double
=	O
Nc	double
;	O
b	pointer
=	O
N	double
;	O
if	O
(	O
(	O
b	pointer
<	O
0.0	int
)	O
==	O
(	O
t	double
<	O
0.0	int
)	O
)	O
{	O
b	pointer
=	O
-	O
b	pointer
;	O
d	double
=	O
-	O
d	double
;	O
}	O
Z	double
=	O
N	double
-	O
2.0	int
*	O
b	pointer
*	O
cos	function
(	O
acos	function
(	O
-	O
t	double
/	O
d	double
)	O
/	O
3.0	int
)	O
;	O
if	O
(	O
(	O
Z	double
<	O
0.0	int
)	O
==	O
(	O
Vr	double
<	O
0.0	int
)	O
)	O
flip	int
=	O
2	int
;	O
else	O
flip	int
=	O
1	int
;	O
}	O
else	O
{	O
d	double
=	O
Vr	double
*	O
sqrt	function
(	O
d	double
)	O
;	O
Z	double
=	O
N	double
+	O
cbrt	function
(	O
t	double
+	O
d	double
)	O
+	O
cbrt	function
(	O
t	double
-	O
d	double
)	O
;	O
flip	int
=	O
0	int
;	O
}	O
A	double
=	O
sqrt	function
(	O
(	O
Z	double
+	O
Z	double
)	O
-	O
Nk	double
)	O
;	O
T	double
=	O
(	O
Fk	double
-	O
Z	double
)	O
*	O
K	double
/	O
A	double
;	O
inx	int
=	O
0.0	int
;	O
solution	enum
=	O
false	int
;	O
b	pointer
=	O
-	O
A	double
+	O
K	double
;	O
d	double
=	O
b	pointer
*	O
b	pointer
-	O
4	int
*	O
(	O
Z	double
+	O
T	double
)	O
;	O
if	O
(	O
d	double
>=	O
0	int
)	O
{	O
d	double
=	O
sqrt	function
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	pointer
+	O
d	double
)	O
;	O
if	O
(	O
(	O
y	double
>=	O
0.0	int
)	O
&&	O
(	O
y	double
<	O
hepp	double
)	O
)	O
{	O
solution	enum
=	O
true	int
;	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	function
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	function
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
if	O
(	O
flip	int
==	O
2	int
)	O
inx	int
=	O
x	double
-	O
t	double
;	O
else	O
outx	double
=	O
x	double
+	O
t	double
;	O
}	O
}	O
b	pointer
=	O
A	double
+	O
K	double
;	O
d	double
=	O
b	pointer
*	O
b	pointer
-	O
4	int
*	O
(	O
Z	double
-	O
T	double
)	O
;	O
if	O
(	O
d	double
<	O
0	int
&&	O
!	O
solution	enum
)	O
d	double
=	O
0.0	int
;	O
if	O
(	O
d	double
>=	O
0	int
)	O
{	O
d	double
=	O
sqrt	function
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	pointer
+	O
d	double
)	O
;	O
if	O
(	O
y	double
<	O
hepp	double
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	function
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
inx	int
=	O
x	double
-	O
sqrt	function
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
}	O
y	double
=	O
0.5	int
*	O
(	O
b	pointer
-	O
d	double
)	O
;	O
if	O
(	O
y	double
>=	O
0.0	int
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	function
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	function
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
if	O
(	O
flip	int
==	O
1	int
)	O
inx	int
=	O
x	double
-	O
t	double
;	O
else	O
outx	double
=	O
x	double
+	O
t	double
;	O
}	O
}	O
span	pointer
->	O
lx	int
=	O
ICEIL	O
(	O
xorg	int
-	O
outx	double
)	O
;	O
if	O
(	O
inx	int
<=	O
0.0	int
)	O
{	O
spdata	pointer
->	O
count1	int
++	O
;	O
span	pointer
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	pointer
->	O
lx	int
;	O
span	pointer
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	pointer
->	O
rw	int
=	O
-	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
;	O
}	O
else	O
{	O
spdata	pointer
->	O
count2	int
++	O
;	O
span	pointer
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
-	O
span	pointer
->	O
lx	int
;	O
span	pointer
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	pointer
->	O
rw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	pointer
->	O
rx	double
;	O
}	O
span	pointer
++	O
;	O
}	O
if	O
(	O
spdata	pointer
->	O
bot	enum
)	O
{	O
outx	double
=	O
w	double
+	O
r	int
;	O
if	O
(	O
r	int
>=	O
h	double
&&	O
r	int
<=	O
w	double
)	O
inx	int
=	O
0.0	int
;	O
else	O
if	O
(	O
Nk	double
<	O
0.0	int
&&	O
-	O
Nk	double
<	O
Hs	double
)	O
{	O
inx	int
=	O
w	double
*	O
sqrt	function
(	O
1	int
+	O
Nk	double
/	O
Hs	double
)	O
-	O
sqrt	function
(	O
rs	double
+	O
Nk	double
)	O
;	O
if	O
(	O
inx	int
>	O
w	double
-	O
r	int
)	O
inx	int
=	O
w	double
-	O
r	int
;	O
}	O
else	O
inx	int
=	O
w	double
-	O
r	int
;	O
span	pointer
->	O
lx	int
=	O
ICEIL	O
(	O
xorg	int
-	O
outx	double
)	O
;	O
if	O
(	O
inx	int
<=	O
0.0	int
)	O
{	O
span	pointer
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	pointer
->	O
lx	int
;	O
span	pointer
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	pointer
->	O
rw	int
=	O
-	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
;	O
}	O
else	O
{	O
span	pointer
->	O
lw	int
=	O
ICEIL	O
(	O
xorg	int
-	O
inx	int
)	O
-	O
span	pointer
->	O
lx	int
;	O
span	pointer
->	O
rx	double
=	O
ICEIL	O
(	O
xorg	int
+	O
inx	int
)	O
;	O
span	pointer
->	O
rw	int
=	O
ICEIL	O
(	O
xorg	int
+	O
outx	double
)	O
-	O
span	pointer
->	O
rx	double
;	O
}	O
}	O
if	O
(	O
spdata	pointer
->	O
hole	enum
)	O
{	O
span	pointer
=	O
&	O
spdata	pointer
->	O
spans	pointer
[	O
spdata	pointer
->	O
count1	int
]	O
;	O
span	pointer
->	O
lw	int
=	O
-	O
span	pointer
->	O
lx	int
;	O
span	pointer
->	O
rx	double
=	O
1	int
;	O
span	pointer
->	O
rw	int
=	O
span	pointer
->	O
lw	int
;	O
spdata	pointer
->	O
count1	int
--	O
;	O
spdata	pointer
->	O
count2	int
++	O
;	O
}	O
}	O
static	O
miPolyArcs	struct
*	O
miComputeArcs	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
parcs	pointer
,	O
int	O
narcs	int
)	O
{	O
bool	enum
isDashed	enum
,	O
isDoubleDash	enum
;	O
miPolyArcs	struct
*	O
arcs	pointer
;	O
int	O
i	int
,	O
start	int
,	O
k	int
,	O
nextk	int
;	O
miArcData	struct
*	O
data	pointer
;	O
int	O
numPixels	int
;	O
int	O
paintType	int
,	O
paintTypeStart	int
,	O
prevPaintType	int
;	O
int	O
dashNum	int
,	O
dashIndex	int
,	O
dashRemaining	int
;	O
int	O
dashNumStart	int
,	O
dashIndexStart	int
,	O
dashRemainingStart	int
;	O
isDashed	enum
=	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
?	O
false	int
:	O
true	int
)	O
;	O
isDoubleDash	enum
=	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
?	O
true	int
:	O
false	int
)	O
;	O
numPixels	int
=	O
pGC	pointer
->	O
numPixels	int
;	O
arcs	pointer
=	O
(	O
miPolyArcs	struct
*	O
)	O
mi_xmalloc	O
(	O
numPixels	int
*	O
sizeof	O
(	O
miPolyArcs	struct
)	O
)	O
;	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
numPixels	int
;	O
paintType	int
++	O
)	O
{	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
=	O
(	O
miArcData	struct
*	O
)	O
NULL	O
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
=	O
0	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcSize	int
=	O
0	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
caps	pointer
=	O
(	O
miArcCapStruct	struct
*	O
)	O
NULL	O
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
ncaps	int
=	O
0	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
capSize	int
=	O
0	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
joins	pointer
=	O
(	O
miArcJoinStruct	struct
*	O
)	O
NULL	O
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
njoins	int
=	O
0	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
joinSize	int
=	O
0	int
;	O
}	O
data	pointer
=	O
(	O
miArcData	struct
*	O
)	O
mi_xmalloc	O
(	O
narcs	int
*	O
sizeof	O
(	O
miArcData	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narcs	int
;	O
i	int
++	O
)	O
{	O
double	O
a0	int
,	O
a1	int
;	O
int	O
angle2	int
;	O
a0	int
=	O
todeg	O
(	O
parcs	pointer
[	O
i	int
]	O
.	O
angle1	int
)	O
;	O
angle2	int
=	O
parcs	pointer
[	O
i	int
]	O
.	O
angle2	int
;	O
if	O
(	O
angle2	int
>	O
FULLCIRCLE	O
)	O
angle2	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
angle2	int
<	O
-	O
FULLCIRCLE	O
)	O
angle2	int
=	O
-	O
FULLCIRCLE	O
;	O
data	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
=	O
(	O
(	O
angle2	int
==	O
FULLCIRCLE	O
)	O
||	O
(	O
angle2	int
==	O
-	O
FULLCIRCLE	O
)	O
?	O
true	int
:	O
false	int
)	O
;	O
a1	int
=	O
todeg	O
(	O
parcs	pointer
[	O
i	int
]	O
.	O
angle1	int
+	O
angle2	int
)	O
;	O
data	pointer
[	O
i	int
]	O
.	O
x0	double
=	O
parcs	pointer
[	O
i	int
]	O
.	O
x	double
+	O
(	O
double	O
)	O
parcs	pointer
[	O
i	int
]	O
.	O
width	array
/	O
2	int
*	O
(	O
1	int
+	O
miDcos	function
(	O
a0	int
)	O
)	O
;	O
data	pointer
[	O
i	int
]	O
.	O
y0	function
=	O
parcs	pointer
[	O
i	int
]	O
.	O
y	double
+	O
(	O
double	O
)	O
parcs	pointer
[	O
i	int
]	O
.	O
height	int
/	O
2	int
*	O
(	O
1	int
-	O
miDsin	function
(	O
a0	int
)	O
)	O
;	O
data	pointer
[	O
i	int
]	O
.	O
x1	double
=	O
parcs	pointer
[	O
i	int
]	O
.	O
x	double
+	O
(	O
double	O
)	O
parcs	pointer
[	O
i	int
]	O
.	O
width	array
/	O
2	int
*	O
(	O
1	int
+	O
miDcos	function
(	O
a1	int
)	O
)	O
;	O
data	pointer
[	O
i	int
]	O
.	O
y1	function
=	O
parcs	pointer
[	O
i	int
]	O
.	O
y	double
+	O
(	O
double	O
)	O
parcs	pointer
[	O
i	int
]	O
.	O
height	int
/	O
2	int
*	O
(	O
1	int
-	O
miDsin	function
(	O
a1	int
)	O
)	O
;	O
}	O
paintType	int
=	O
1	int
;	O
dashNum	int
=	O
0	int
;	O
dashIndex	int
=	O
0	int
;	O
dashRemaining	int
=	O
0	int
;	O
if	O
(	O
isDashed	enum
)	O
{	O
int	O
dashOffset	int
=	O
0	int
;	O
miStepDash	O
(	O
pGC	pointer
->	O
dashOffset	int
,	O
&	O
dashNum	int
,	O
&	O
dashIndex	int
,	O
pGC	pointer
->	O
dash	pointer
,	O
pGC	pointer
->	O
numInDashList	int
,	O
&	O
dashOffset	int
)	O
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
dashRemaining	int
=	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
dash	pointer
[	O
dashIndex	int
]	O
)	O
-	O
dashOffset	int
;	O
}	O
paintTypeStart	int
=	O
paintType	int
;	O
dashNumStart	int
=	O
dashNum	int
;	O
dashIndexStart	int
=	O
dashIndex	int
;	O
dashRemainingStart	int
=	O
dashRemaining	int
;	O
for	O
(	O
i	int
=	O
narcs	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
int	O
j	int
;	O
j	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
j	int
==	O
narcs	int
)	O
j	int
=	O
0	int
;	O
if	O
(	O
data	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
||	O
i	int
==	O
j	int
||	O
(	O
UNEQUAL	O
(	O
data	pointer
[	O
i	int
]	O
.	O
x1	double
,	O
data	pointer
[	O
j	int
]	O
.	O
x0	double
)	O
||	O
UNEQUAL	O
(	O
data	pointer
[	O
i	int
]	O
.	O
y1	function
,	O
data	pointer
[	O
j	int
]	O
.	O
y0	function
)	O
)	O
)	O
{	O
if	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
addCap	function
(	O
&	O
arcs	pointer
[	O
paintType	int
]	O
,	O
RIGHT_END	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
start	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
start	int
==	O
narcs	int
)	O
start	int
=	O
0	int
;	O
i	int
=	O
start	int
;	O
k	int
=	O
nextk	int
=	O
0	int
;	O
prevPaintType	int
=	O
paintType	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
j	int
,	O
nexti	int
;	O
miArcData	struct
*	O
arc	struct
;	O
bool	enum
arcsJoin	enum
;	O
j	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
j	int
==	O
narcs	int
)	O
j	int
=	O
0	int
;	O
nexti	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
nexti	int
==	O
narcs	int
)	O
nexti	int
=	O
0	int
;	O
if	O
(	O
isDashed	enum
)	O
{	O
int	O
startAngle	int
,	O
spanAngle	int
,	O
endAngle	int
;	O
int	O
dashAngle	int
,	O
prevDashAngle	int
;	O
bool	enum
backwards	enum
,	O
selfJoin	enum
;	O
dashMap	struct
map	array
;	O
miArc	struct
xarc	pointer
;	O
computeDashMap	function
(	O
&	O
parcs	pointer
[	O
i	int
]	O
,	O
&	O
map	array
)	O
;	O
startAngle	int
=	O
parcs	pointer
[	O
i	int
]	O
.	O
angle1	int
;	O
spanAngle	int
=	O
parcs	pointer
[	O
i	int
]	O
.	O
angle2	int
;	O
if	O
(	O
spanAngle	int
>	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
spanAngle	int
<	O
-	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
-	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
<	O
0	int
)	O
startAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
startAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
>=	O
FULLCIRCLE	O
)	O
startAngle	int
=	O
startAngle	int
%	O
FULLCIRCLE	O
;	O
endAngle	int
=	O
startAngle	int
+	O
spanAngle	int
;	O
backwards	enum
=	O
(	O
spanAngle	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
;	O
dashAngle	int
=	O
startAngle	int
;	O
selfJoin	enum
=	O
(	O
data	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
&&	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
?	O
true	int
:	O
false	int
)	O
;	O
arc	struct
=	O
(	O
miArcData	struct
*	O
)	O
NULL	O
;	O
while	O
(	O
dashAngle	int
!=	O
endAngle	int
)	O
{	O
prevDashAngle	int
=	O
dashAngle	int
;	O
dashAngle	int
=	O
computeAngleFromPath	function
(	O
prevDashAngle	int
,	O
endAngle	int
,	O
&	O
map	array
,	O
&	O
dashRemaining	int
,	O
backwards	enum
)	O
;	O
if	O
(	O
dashAngle	int
==	O
prevDashAngle	int
)	O
{	O
if	O
(	O
backwards	enum
)	O
dashAngle	int
--	O
;	O
else	O
dashAngle	int
++	O
;	O
}	O
if	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
{	O
xarc	pointer
=	O
parcs	pointer
[	O
i	int
]	O
;	O
spanAngle	int
=	O
prevDashAngle	int
;	O
if	O
(	O
spanAngle	int
<	O
0	int
)	O
spanAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
spanAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
spanAngle	int
>=	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
spanAngle	int
%	O
FULLCIRCLE	O
;	O
xarc	pointer
.	O
angle1	int
=	O
spanAngle	int
;	O
spanAngle	int
=	O
dashAngle	int
-	O
prevDashAngle	int
;	O
if	O
(	O
backwards	enum
)	O
{	O
if	O
(	O
dashAngle	int
>	O
prevDashAngle	int
)	O
spanAngle	int
=	O
-	O
FULLCIRCLE	O
+	O
spanAngle	int
;	O
}	O
else	O
{	O
if	O
(	O
dashAngle	int
<	O
prevDashAngle	int
)	O
spanAngle	int
=	O
FULLCIRCLE	O
+	O
spanAngle	int
;	O
}	O
if	O
(	O
spanAngle	int
>	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
FULLCIRCLE	O
;	O
if	O
(	O
spanAngle	int
<	O
-	O
FULLCIRCLE	O
)	O
spanAngle	int
=	O
-	O
FULLCIRCLE	O
;	O
xarc	pointer
.	O
angle2	int
=	O
spanAngle	int
;	O
arc	struct
=	O
addArc	function
(	O
&	O
arcs	pointer
[	O
paintType	int
]	O
,	O
&	O
xarc	pointer
)	O
;	O
if	O
(	O
!	O
isDoubleDash	enum
)	O
{	O
if	O
(	O
prevDashAngle	int
!=	O
startAngle	int
)	O
addCap	function
(	O
&	O
arcs	pointer
[	O
paintType	int
]	O
,	O
RIGHT_END	int
,	O
arc	struct
-	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
)	O
;	O
if	O
(	O
dashAngle	int
!=	O
endAngle	int
)	O
addCap	function
(	O
&	O
arcs	pointer
[	O
paintType	int
]	O
,	O
LEFT_END	int
,	O
arc	struct
-	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
)	O
;	O
}	O
arc	struct
->	O
cap	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
ncaps	int
;	O
arc	struct
->	O
join	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
njoins	int
;	O
arc	struct
->	O
render	enum
=	O
false	int
;	O
arc	struct
->	O
selfJoin	enum
=	O
false	int
;	O
if	O
(	O
dashAngle	int
==	O
endAngle	int
)	O
arc	struct
->	O
selfJoin	enum
=	O
selfJoin	enum
;	O
}	O
prevPaintType	int
=	O
paintType	int
;	O
if	O
(	O
dashRemaining	int
<=	O
0	int
)	O
{	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
pGC	pointer
->	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
dashRemaining	int
=	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
dash	pointer
[	O
dashIndex	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
startAngle	int
==	O
endAngle	int
)	O
{	O
prevPaintType	int
=	O
paintType	int
;	O
if	O
(	O
isDoubleDash	enum
==	O
false	int
&&	O
paintType	int
==	O
0	int
)	O
{	O
if	O
(	O
dashNum	int
==	O
0	int
)	O
prevPaintType	int
=	O
numPixels	int
-	O
1	int
;	O
else	O
prevPaintType	int
=	O
(	O
(	O
dashNum	int
-	O
1	int
)	O
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
(	O
dashNum	int
-	O
1	int
)	O
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
}	O
arc	struct
=	O
addArc	function
(	O
&	O
arcs	pointer
[	O
prevPaintType	int
]	O
,	O
&	O
parcs	pointer
[	O
i	int
]	O
)	O
;	O
arc	struct
->	O
join	int
=	O
arcs	pointer
[	O
prevPaintType	int
]	O
.	O
njoins	int
;	O
arc	struct
->	O
cap	int
=	O
arcs	pointer
[	O
prevPaintType	int
]	O
.	O
ncaps	int
;	O
arc	struct
->	O
selfJoin	enum
=	O
data	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
;	O
}	O
}	O
else	O
{	O
arc	struct
=	O
addArc	function
(	O
&	O
arcs	pointer
[	O
paintType	int
]	O
,	O
&	O
parcs	pointer
[	O
i	int
]	O
)	O
;	O
arc	struct
->	O
join	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
njoins	int
;	O
arc	struct
->	O
cap	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
ncaps	int
;	O
arc	struct
->	O
selfJoin	enum
=	O
data	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
;	O
prevPaintType	int
=	O
paintType	int
;	O
}	O
if	O
(	O
prevPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
k	int
=	O
arcs	pointer
[	O
prevPaintType	int
]	O
.	O
narcs	int
-	O
1	int
;	O
if	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
nextk	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
;	O
if	O
(	O
nexti	int
==	O
start	int
)	O
{	O
nextk	int
=	O
0	int
;	O
if	O
(	O
isDashed	enum
)	O
{	O
paintType	int
=	O
paintTypeStart	int
;	O
dashNum	int
=	O
dashNumStart	int
;	O
dashIndex	int
=	O
dashIndexStart	int
;	O
dashRemaining	int
=	O
dashRemainingStart	int
;	O
}	O
}	O
arcsJoin	enum
=	O
(	O
narcs	int
>	O
1	int
&&	O
i	int
!=	O
j	int
&&	O
ISEQUAL	O
(	O
data	pointer
[	O
i	int
]	O
.	O
x1	double
,	O
data	pointer
[	O
j	int
]	O
.	O
x0	double
)	O
&&	O
ISEQUAL	O
(	O
data	pointer
[	O
i	int
]	O
.	O
y1	function
,	O
data	pointer
[	O
j	int
]	O
.	O
y0	function
)	O
&&	O
data	pointer
[	O
i	int
]	O
.	O
selfJoin	enum
==	O
false	int
&&	O
data	pointer
[	O
j	int
]	O
.	O
selfJoin	enum
==	O
false	int
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
arc	struct
!=	O
(	O
miArcData	struct
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
arcsJoin	enum
)	O
arc	struct
->	O
render	enum
=	O
false	int
;	O
else	O
arc	struct
->	O
render	enum
=	O
true	int
;	O
}	O
if	O
(	O
arcsJoin	enum
&&	O
(	O
prevPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
&&	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
)	O
{	O
int	O
joinPaintType	int
;	O
joinPaintType	int
=	O
paintType	int
;	O
if	O
(	O
isDoubleDash	enum
)	O
{	O
if	O
(	O
nexti	int
==	O
start	int
)	O
joinPaintType	int
=	O
paintTypeStart	int
;	O
if	O
(	O
joinPaintType	int
==	O
0	int
)	O
{	O
if	O
(	O
prevPaintType	int
!=	O
0	int
)	O
joinPaintType	int
=	O
prevPaintType	int
;	O
else	O
joinPaintType	int
=	O
(	O
(	O
dashNum	int
+	O
1	int
)	O
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
(	O
dashNum	int
+	O
1	int
)	O
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
joinPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
{	O
addJoin	function
(	O
&	O
arcs	pointer
[	O
joinPaintType	int
]	O
,	O
LEFT_END	int
,	O
k	int
,	O
prevPaintType	int
,	O
RIGHT_END	int
,	O
nextk	int
,	O
paintType	int
)	O
;	O
arc	struct
->	O
join	int
=	O
arcs	pointer
[	O
prevPaintType	int
]	O
.	O
njoins	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
prevPaintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
&&	O
arc	struct
->	O
selfJoin	enum
==	O
false	int
)	O
{	O
addCap	function
(	O
&	O
arcs	pointer
[	O
prevPaintType	int
]	O
,	O
LEFT_END	int
,	O
k	int
)	O
;	O
arc	struct
->	O
cap	int
=	O
arcs	pointer
[	O
prevPaintType	int
]	O
.	O
ncaps	int
;	O
}	O
if	O
(	O
isDashed	enum
&&	O
arcsJoin	enum
==	O
false	int
)	O
{	O
paintType	int
=	O
paintTypeStart	int
;	O
dashNum	int
=	O
dashNumStart	int
;	O
dashIndex	int
=	O
dashIndexStart	int
;	O
dashRemaining	int
=	O
dashRemainingStart	int
;	O
}	O
nextk	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
;	O
if	O
(	O
nexti	int
==	O
start	int
)	O
{	O
nextk	int
=	O
0	int
;	O
paintType	int
=	O
paintTypeStart	int
;	O
dashNum	int
=	O
dashNumStart	int
;	O
dashIndex	int
=	O
dashIndexStart	int
;	O
dashRemaining	int
=	O
dashRemainingStart	int
;	O
}	O
if	O
(	O
(	O
paintType	int
!=	O
0	int
||	O
isDoubleDash	enum
)	O
&&	O
(	O
nexti	int
!=	O
start	int
||	O
(	O
arcsJoin	enum
&&	O
isDashed	enum
)	O
)	O
)	O
addCap	function
(	O
&	O
arcs	pointer
[	O
paintType	int
]	O
,	O
RIGHT_END	int
,	O
nextk	int
)	O
;	O
}	O
i	int
=	O
nexti	int
;	O
if	O
(	O
i	int
==	O
start	int
)	O
break	O
;	O
}	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
numPixels	int
;	O
paintType	int
++	O
)	O
if	O
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
>	O
0	int
)	O
{	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
-	O
1	int
]	O
.	O
render	enum
=	O
true	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
-	O
1	int
]	O
.	O
join	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
njoins	int
;	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
[	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
-	O
1	int
]	O
.	O
cap	int
=	O
arcs	pointer
[	O
paintType	int
]	O
.	O
ncaps	int
;	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
arcs	pointer
;	O
}	O
static	O
void	O
miFreeArcs	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miPolyArcs	struct
*	O
arcs	pointer
)	O
{	O
int	O
paintType	int
;	O
for	O
(	O
paintType	int
=	O
0	int
;	O
paintType	int
<	O
pGC	pointer
->	O
numPixels	int
;	O
paintType	int
++	O
)	O
{	O
if	O
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
narcs	int
>	O
0	int
)	O
free	function
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
arcs	pointer
)	O
;	O
if	O
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
njoins	int
>	O
0	int
)	O
free	function
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
joins	pointer
)	O
;	O
if	O
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
ncaps	int
>	O
0	int
)	O
free	function
(	O
arcs	pointer
[	O
paintType	int
]	O
.	O
caps	pointer
)	O
;	O
}	O
free	function
(	O
arcs	pointer
)	O
;	O
}	O
static	O
void	O
addCap	function
(	O
miPolyArcs	struct
*	O
polyArcs	pointer
,	O
int	O
end	int
,	O
int	O
arcIndex	int
)	O
{	O
miArcCapStruct	struct
*	O
cap	int
;	O
if	O
(	O
polyArcs	pointer
->	O
ncaps	int
==	O
polyArcs	pointer
->	O
capSize	int
)	O
{	O
int	O
newsize	int
=	O
polyArcs	pointer
->	O
capSize	int
+	O
ADD_REALLOC_STEP	int
;	O
miArcCapStruct	struct
*	O
newcaps	pointer
;	O
newcaps	pointer
=	O
(	O
miArcCapStruct	struct
*	O
)	O
mi_xrealloc	O
(	O
polyArcs	pointer
->	O
caps	pointer
,	O
newsize	int
*	O
sizeof	O
(	O
miArcCapStruct	struct
)	O
)	O
;	O
polyArcs	pointer
->	O
caps	pointer
=	O
newcaps	pointer
;	O
polyArcs	pointer
->	O
capSize	int
=	O
newsize	int
;	O
}	O
cap	int
=	O
&	O
(	O
polyArcs	pointer
->	O
caps	pointer
[	O
polyArcs	pointer
->	O
ncaps	int
]	O
)	O
;	O
cap	int
->	O
end	int
=	O
end	int
;	O
cap	int
->	O
arcIndex	int
=	O
arcIndex	int
;	O
++	O
(	O
polyArcs	pointer
->	O
ncaps	int
)	O
;	O
}	O
static	O
void	O
addJoin	function
(	O
miPolyArcs	struct
*	O
polyArcs	pointer
,	O
int	O
end0	int
,	O
int	O
index0	int
,	O
int	O
paintType0	int
,	O
int	O
end1	int
,	O
int	O
index1	int
,	O
int	O
paintType1	int
)	O
{	O
miArcJoinStruct	struct
*	O
join	int
;	O
if	O
(	O
polyArcs	pointer
->	O
njoins	int
==	O
polyArcs	pointer
->	O
joinSize	int
)	O
{	O
int	O
newsize	int
=	O
polyArcs	pointer
->	O
joinSize	int
+	O
ADD_REALLOC_STEP	int
;	O
miArcJoinStruct	struct
*	O
newjoins	pointer
;	O
newjoins	pointer
=	O
(	O
miArcJoinStruct	struct
*	O
)	O
mi_xrealloc	O
(	O
polyArcs	pointer
->	O
joins	pointer
,	O
newsize	int
*	O
sizeof	O
(	O
miArcJoinStruct	struct
)	O
)	O
;	O
polyArcs	pointer
->	O
joins	pointer
=	O
newjoins	pointer
;	O
polyArcs	pointer
->	O
joinSize	int
=	O
newsize	int
;	O
}	O
join	int
=	O
&	O
(	O
polyArcs	pointer
->	O
joins	pointer
[	O
polyArcs	pointer
->	O
njoins	int
]	O
)	O
;	O
join	int
->	O
end0	int
=	O
end0	int
;	O
join	int
->	O
arcIndex0	int
=	O
index0	int
;	O
join	int
->	O
paintType0	int
=	O
paintType0	int
;	O
join	int
->	O
end1	int
=	O
end1	int
;	O
join	int
->	O
arcIndex1	int
=	O
index1	int
;	O
join	int
->	O
paintType1	int
=	O
paintType1	int
;	O
++	O
(	O
polyArcs	pointer
->	O
njoins	int
)	O
;	O
}	O
static	O
miArcData	struct
*	O
addArc	function
(	O
miPolyArcs	struct
*	O
polyArcs	pointer
,	O
const	O
miArc	struct
*	O
xarc	pointer
)	O
{	O
miArcData	struct
*	O
arc	struct
;	O
if	O
(	O
polyArcs	pointer
->	O
narcs	int
==	O
polyArcs	pointer
->	O
arcSize	int
)	O
{	O
int	O
newsize	int
=	O
polyArcs	pointer
->	O
arcSize	int
+	O
ADD_REALLOC_STEP	int
;	O
miArcData	struct
*	O
newarcs	pointer
;	O
newarcs	pointer
=	O
(	O
miArcData	struct
*	O
)	O
mi_xrealloc	O
(	O
polyArcs	pointer
->	O
arcs	pointer
,	O
newsize	int
*	O
sizeof	O
(	O
miArcData	struct
)	O
)	O
;	O
polyArcs	pointer
->	O
arcs	pointer
=	O
newarcs	pointer
;	O
polyArcs	pointer
->	O
arcSize	int
=	O
newsize	int
;	O
}	O
arc	struct
=	O
&	O
(	O
polyArcs	pointer
->	O
arcs	pointer
[	O
polyArcs	pointer
->	O
narcs	int
]	O
)	O
;	O
arc	struct
->	O
arc	struct
=	O
*	O
xarc	pointer
;	O
++	O
(	O
polyArcs	pointer
->	O
narcs	int
)	O
;	O
return	O
arc	struct
;	O
}	O
static	O
void	O
miArcJoin	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArcFace	struct
*	O
pLeft	pointer
,	O
const	O
miArcFace	struct
*	O
pRight	pointer
,	O
int	O
xOrgLeft	int
,	O
int	O
yOrgLeft	int
,	O
double	O
xFtransLeft	double
,	O
double	O
yFtransLeft	double
,	O
int	O
xOrgRight	int
,	O
int	O
yOrgRight	int
,	O
double	O
xFtransRight	double
,	O
double	O
yFtransRight	double
)	O
{	O
SppPoint	struct
center	struct
,	O
corner	struct
,	O
otherCorner	struct
;	O
SppPoint	struct
poly	array
[	O
5	int
]	O
;	O
SppPoint	struct
*	O
pArcPts	pointer
;	O
int	O
cpt	int
;	O
SppArc	struct
arc	struct
;	O
miArcFace	struct
Right	struct
,	O
Left	struct
;	O
int	O
polyLen	int
=	O
0	int
;	O
int	O
xOrg	int
,	O
yOrg	int
;	O
double	O
xFtrans	double
,	O
yFtrans	double
;	O
double	O
a	double
;	O
double	O
width	array
;	O
double	O
halftheta	double
;	O
xOrg	int
=	O
(	O
xOrgRight	int
+	O
xOrgLeft	int
)	O
/	O
2	int
;	O
yOrg	int
=	O
(	O
yOrgRight	int
+	O
yOrgLeft	int
)	O
/	O
2	int
;	O
xFtrans	double
=	O
(	O
xFtransLeft	double
+	O
xFtransRight	double
)	O
/	O
2	int
;	O
yFtrans	double
=	O
(	O
yFtransLeft	double
+	O
yFtransRight	double
)	O
/	O
2	int
;	O
Right	struct
=	O
*	O
pRight	pointer
;	O
translateBounds	function
(	O
&	O
Right	struct
,	O
xOrg	int
-	O
xOrgRight	int
,	O
yOrg	int
-	O
yOrgRight	int
,	O
xFtrans	double
-	O
xFtransRight	double
,	O
yFtrans	double
-	O
yFtransRight	double
)	O
;	O
Left	struct
=	O
*	O
pLeft	pointer
;	O
translateBounds	function
(	O
&	O
Left	struct
,	O
xOrg	int
-	O
xOrgLeft	int
,	O
yOrg	int
-	O
yOrgLeft	int
,	O
xFtrans	double
-	O
xFtransLeft	double
,	O
yFtrans	double
-	O
yFtransLeft	double
)	O
;	O
pRight	pointer
=	O
&	O
Right	struct
;	O
pLeft	pointer
=	O
&	O
Left	struct
;	O
if	O
(	O
pRight	pointer
->	O
clock	function
.	O
x	double
==	O
pLeft	pointer
->	O
counterClock	struct
.	O
x	double
&&	O
pRight	pointer
->	O
clock	function
.	O
y	double
==	O
pLeft	pointer
->	O
counterClock	struct
.	O
y	double
)	O
return	O
;	O
center	struct
=	O
pRight	pointer
->	O
center	struct
;	O
if	O
(	O
0	int
<=	O
(	O
a	double
=	O
angleBetween	function
(	O
center	struct
,	O
pRight	pointer
->	O
clock	function
,	O
pLeft	pointer
->	O
counterClock	struct
)	O
)	O
&&	O
a	double
<=	O
180.0	int
)	O
{	O
corner	struct
=	O
pRight	pointer
->	O
clock	function
;	O
otherCorner	struct
=	O
pLeft	pointer
->	O
counterClock	struct
;	O
}	O
else	O
{	O
a	double
=	O
angleBetween	function
(	O
center	struct
,	O
pLeft	pointer
->	O
clock	function
,	O
pRight	pointer
->	O
counterClock	struct
)	O
;	O
corner	struct
=	O
pLeft	pointer
->	O
clock	function
;	O
otherCorner	struct
=	O
pRight	pointer
->	O
counterClock	struct
;	O
}	O
width	array
=	O
(	O
pGC	pointer
->	O
lineWidth	int
?	O
pGC	pointer
->	O
lineWidth	int
:	O
1	int
)	O
;	O
switch	O
(	O
pGC	pointer
->	O
joinStyle	int
)	O
{	O
case	O
MI_JOIN_MITER	int
:	O
default	O
:	O
if	O
(	O
(	O
halftheta	double
=	O
0.5	int
*	O
(	O
180.0	int
-	O
a	double
)	O
)	O
>	O
0.0	int
&&	O
miDsin	function
(	O
halftheta	double
)	O
*	O
pGC	pointer
->	O
miterLimit	double
>=	O
1.0	int
)	O
{	O
double	O
ae	double
,	O
ac2	double
,	O
ec2	double
,	O
bc2	double
,	O
de	double
;	O
SppPoint	struct
e	int
;	O
poly	array
[	O
0	int
]	O
=	O
corner	struct
;	O
poly	array
[	O
1	int
]	O
=	O
center	struct
;	O
poly	array
[	O
2	int
]	O
=	O
otherCorner	struct
;	O
bc2	double
=	O
(	O
(	O
corner	struct
.	O
x	double
-	O
otherCorner	struct
.	O
x	double
)	O
*	O
(	O
corner	struct
.	O
x	double
-	O
otherCorner	struct
.	O
x	double
)	O
+	O
(	O
corner	struct
.	O
y	double
-	O
otherCorner	struct
.	O
y	double
)	O
*	O
(	O
corner	struct
.	O
y	double
-	O
otherCorner	struct
.	O
y	double
)	O
)	O
;	O
ec2	double
=	O
0.25	int
*	O
bc2	double
;	O
ac2	double
=	O
(	O
(	O
corner	struct
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
*	O
(	O
corner	struct
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
+	O
(	O
corner	struct
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
*	O
(	O
corner	struct
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
)	O
;	O
ae	double
=	O
sqrt	function
(	O
ac2	double
-	O
ec2	double
)	O
;	O
de	double
=	O
ec2	double
/	O
ae	double
;	O
e	int
.	O
x	double
=	O
0.5	int
*	O
(	O
corner	struct
.	O
x	double
+	O
otherCorner	struct
.	O
x	double
)	O
;	O
e	int
.	O
y	double
=	O
0.5	int
*	O
(	O
corner	struct
.	O
y	double
+	O
otherCorner	struct
.	O
y	double
)	O
;	O
poly	array
[	O
3	int
]	O
.	O
x	double
=	O
e	int
.	O
x	double
+	O
de	double
*	O
(	O
e	int
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
/	O
ae	double
;	O
poly	array
[	O
3	int
]	O
.	O
y	double
=	O
e	int
.	O
y	double
+	O
de	double
*	O
(	O
e	int
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
/	O
ae	double
;	O
poly	array
[	O
4	int
]	O
=	O
corner	struct
;	O
polyLen	int
=	O
5	int
;	O
}	O
else	O
{	O
poly	array
[	O
0	int
]	O
=	O
corner	struct
;	O
poly	array
[	O
1	int
]	O
=	O
center	struct
;	O
poly	array
[	O
2	int
]	O
=	O
otherCorner	struct
;	O
poly	array
[	O
3	int
]	O
=	O
corner	struct
;	O
polyLen	int
=	O
4	int
;	O
}	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
polyLen	int
,	O
poly	array
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_JOIN_BEVEL	int
:	O
poly	array
[	O
0	int
]	O
=	O
corner	struct
;	O
poly	array
[	O
1	int
]	O
=	O
center	struct
;	O
poly	array
[	O
2	int
]	O
=	O
otherCorner	struct
;	O
poly	array
[	O
3	int
]	O
=	O
corner	struct
;	O
polyLen	int
=	O
4	int
;	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
polyLen	int
,	O
poly	array
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_JOIN_TRIANGULAR	int
:	O
{	O
double	O
mid2	double
,	O
mid	double
;	O
SppPoint	struct
e	int
;	O
e	int
.	O
x	double
=	O
0.5	int
*	O
(	O
corner	struct
.	O
x	double
+	O
otherCorner	struct
.	O
x	double
)	O
;	O
e	int
.	O
y	double
=	O
0.5	int
*	O
(	O
corner	struct
.	O
y	double
+	O
otherCorner	struct
.	O
y	double
)	O
;	O
mid2	double
=	O
(	O
(	O
e	int
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
*	O
(	O
e	int
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
+	O
(	O
e	int
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
*	O
(	O
e	int
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
)	O
;	O
mid	double
=	O
sqrt	function
(	O
mid2	double
)	O
;	O
poly	array
[	O
0	int
]	O
=	O
corner	struct
;	O
poly	array
[	O
1	int
]	O
=	O
center	struct
;	O
poly	array
[	O
2	int
]	O
=	O
otherCorner	struct
;	O
poly	array
[	O
3	int
]	O
.	O
x	double
=	O
e	int
.	O
x	double
+	O
0.5	int
*	O
width	array
*	O
(	O
e	int
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
/	O
mid	double
;	O
poly	array
[	O
3	int
]	O
.	O
y	double
=	O
e	int
.	O
y	double
+	O
0.5	int
*	O
width	array
*	O
(	O
e	int
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
/	O
mid	double
;	O
poly	array
[	O
4	int
]	O
=	O
corner	struct
;	O
polyLen	int
=	O
5	int
;	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
polyLen	int
,	O
poly	array
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
}	O
break	O
;	O
case	O
MI_JOIN_ROUND	int
:	O
arc	struct
.	O
x	double
=	O
center	struct
.	O
x	double
-	O
width	array
/	O
2	int
;	O
arc	struct
.	O
y	double
=	O
center	struct
.	O
y	double
-	O
width	array
/	O
2	int
;	O
arc	struct
.	O
width	array
=	O
width	array
;	O
arc	struct
.	O
height	int
=	O
width	array
;	O
arc	struct
.	O
angle1	int
=	O
-	O
miDatan2	function
(	O
corner	struct
.	O
y	double
-	O
center	struct
.	O
y	double
,	O
corner	struct
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
;	O
arc	struct
.	O
angle2	int
=	O
a	double
;	O
pArcPts	pointer
=	O
(	O
SppPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
3	int
*	O
sizeof	O
(	O
SppPoint	struct
)	O
)	O
;	O
pArcPts	pointer
[	O
0	int
]	O
=	O
otherCorner	struct
;	O
pArcPts	pointer
[	O
1	int
]	O
=	O
center	struct
;	O
pArcPts	pointer
[	O
2	int
]	O
=	O
corner	struct
;	O
if	O
(	O
(	O
cpt	int
=	O
miGetArcPts	function
(	O
&	O
arc	struct
,	O
3	int
,	O
&	O
pArcPts	pointer
)	O
)	O
)	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
cpt	int
,	O
pArcPts	pointer
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
free	function
(	O
pArcPts	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
double	O
angleBetween	function
(	O
SppPoint	struct
center	struct
,	O
SppPoint	struct
point1	struct
,	O
SppPoint	struct
point2	struct
)	O
{	O
double	O
a1	int
,	O
a2	double
,	O
a	double
;	O
a1	int
=	O
miDatan2	function
(	O
-	O
(	O
point1	struct
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
,	O
point1	struct
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
;	O
a2	double
=	O
miDatan2	function
(	O
-	O
(	O
point2	struct
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
,	O
point2	struct
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
;	O
a	double
=	O
a2	double
-	O
a1	int
;	O
if	O
(	O
a	double
<=	O
-	O
180.0	int
)	O
a	double
+=	O
360.0	int
;	O
else	O
if	O
(	O
a	double
>	O
180.0	int
)	O
a	double
-=	O
360.0	int
;	O
return	O
a	double
;	O
}	O
static	O
void	O
translateBounds	function
(	O
miArcFace	struct
*	O
b	pointer
,	O
int	O
x	double
,	O
int	O
y	double
,	O
double	O
fx	double
,	O
double	O
fy	double
)	O
{	O
fx	double
+=	O
x	double
;	O
fy	double
+=	O
y	double
;	O
b	pointer
->	O
clock	function
.	O
x	double
-=	O
fx	double
;	O
b	pointer
->	O
clock	function
.	O
y	double
-=	O
fy	double
;	O
b	pointer
->	O
center	struct
.	O
x	double
-=	O
fx	double
;	O
b	pointer
->	O
center	struct
.	O
y	double
-=	O
fy	double
;	O
b	pointer
->	O
counterClock	struct
.	O
x	double
-=	O
fx	double
;	O
b	pointer
->	O
counterClock	struct
.	O
y	double
-=	O
fy	double
;	O
}	O
static	O
void	O
miArcCap	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArcFace	struct
*	O
pFace	pointer
,	O
int	O
end	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
{	O
SppPoint	struct
corner	struct
,	O
otherCorner	struct
,	O
center	struct
,	O
endPoint	struct
,	O
poly	array
[	O
5	int
]	O
;	O
corner	struct
=	O
pFace	pointer
->	O
clock	function
;	O
otherCorner	struct
=	O
pFace	pointer
->	O
counterClock	struct
;	O
center	struct
=	O
pFace	pointer
->	O
center	struct
;	O
switch	O
(	O
pGC	pointer
->	O
capStyle	int
)	O
{	O
case	O
MI_CAP_BUTT	int
:	O
case	O
MI_CAP_NOT_LAST	int
:	O
default	O
:	O
break	O
;	O
case	O
MI_CAP_PROJECTING	int
:	O
poly	array
[	O
0	int
]	O
.	O
x	double
=	O
otherCorner	struct
.	O
x	double
;	O
poly	array
[	O
0	int
]	O
.	O
y	double
=	O
otherCorner	struct
.	O
y	double
;	O
poly	array
[	O
1	int
]	O
.	O
x	double
=	O
corner	struct
.	O
x	double
;	O
poly	array
[	O
1	int
]	O
.	O
y	double
=	O
corner	struct
.	O
y	double
;	O
poly	array
[	O
2	int
]	O
.	O
x	double
=	O
corner	struct
.	O
x	double
-	O
(	O
center	struct
.	O
y	double
-	O
corner	struct
.	O
y	double
)	O
;	O
poly	array
[	O
2	int
]	O
.	O
y	double
=	O
corner	struct
.	O
y	double
+	O
(	O
center	struct
.	O
x	double
-	O
corner	struct
.	O
x	double
)	O
;	O
poly	array
[	O
3	int
]	O
.	O
x	double
=	O
otherCorner	struct
.	O
x	double
-	O
(	O
otherCorner	struct
.	O
y	double
-	O
center	struct
.	O
y	double
)	O
;	O
poly	array
[	O
3	int
]	O
.	O
y	double
=	O
otherCorner	struct
.	O
y	double
+	O
(	O
otherCorner	struct
.	O
x	double
-	O
center	struct
.	O
x	double
)	O
;	O
poly	array
[	O
4	int
]	O
.	O
x	double
=	O
otherCorner	struct
.	O
x	double
;	O
poly	array
[	O
4	int
]	O
.	O
y	double
=	O
otherCorner	struct
.	O
y	double
;	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
5	int
,	O
poly	array
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_CAP_TRIANGULAR	int
:	O
poly	array
[	O
0	int
]	O
.	O
x	double
=	O
otherCorner	struct
.	O
x	double
;	O
poly	array
[	O
0	int
]	O
.	O
y	double
=	O
otherCorner	struct
.	O
y	double
;	O
poly	array
[	O
1	int
]	O
.	O
x	double
=	O
corner	struct
.	O
x	double
;	O
poly	array
[	O
1	int
]	O
.	O
y	double
=	O
corner	struct
.	O
y	double
;	O
poly	array
[	O
2	int
]	O
.	O
x	double
=	O
center	struct
.	O
x	double
-	O
0.5	int
*	O
(	O
otherCorner	struct
.	O
y	double
-	O
corner	struct
.	O
y	double
)	O
;	O
poly	array
[	O
2	int
]	O
.	O
y	double
=	O
center	struct
.	O
y	double
+	O
0.5	int
*	O
(	O
otherCorner	struct
.	O
x	double
-	O
corner	struct
.	O
x	double
)	O
;	O
poly	array
[	O
3	int
]	O
.	O
x	double
=	O
otherCorner	struct
.	O
x	double
;	O
poly	array
[	O
3	int
]	O
.	O
y	double
=	O
otherCorner	struct
.	O
y	double
;	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
4	int
,	O
poly	array
,	O
xOrg	int
,	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
case	O
MI_CAP_ROUND	int
:	O
endPoint	struct
=	O
center	struct
;	O
endPoint	struct
.	O
x	double
=	O
endPoint	struct
.	O
x	double
+	O
100	int
;	O
miRoundCap	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
center	struct
,	O
endPoint	struct
,	O
corner	struct
,	O
otherCorner	struct
,	O
0	int
,	O
-	O
xOrg	int
,	O
-	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
miRoundCap	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
SppPoint	struct
pCenter	struct
,	O
SppPoint	struct
pEnd	struct
,	O
SppPoint	struct
pCorner	struct
,	O
SppPoint	struct
pOtherCorner	struct
,	O
int	O
fLineEnd	int
,	O
int	O
xOrg	int
,	O
int	O
yOrg	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
{	O
int	O
cpt	int
;	O
double	O
width	array
;	O
SppArc	struct
arc	struct
;	O
SppPoint	struct
*	O
pArcPts	pointer
;	O
width	array
=	O
(	O
pGC	pointer
->	O
lineWidth	int
?	O
pGC	pointer
->	O
lineWidth	int
:	O
1	int
)	O
;	O
arc	struct
.	O
x	double
=	O
pCenter	struct
.	O
x	double
-	O
width	array
/	O
2	int
;	O
arc	struct
.	O
y	double
=	O
pCenter	struct
.	O
y	double
-	O
width	array
/	O
2	int
;	O
arc	struct
.	O
width	array
=	O
width	array
;	O
arc	struct
.	O
height	int
=	O
width	array
;	O
arc	struct
.	O
angle1	int
=	O
-	O
miDatan2	function
(	O
pCorner	struct
.	O
y	double
-	O
pCenter	struct
.	O
y	double
,	O
pCorner	struct
.	O
x	double
-	O
pCenter	struct
.	O
x	double
)	O
;	O
if	O
(	O
PTISEQUAL	O
(	O
pCenter	struct
,	O
pEnd	struct
)	O
)	O
arc	struct
.	O
angle2	int
=	O
-	O
180.0	int
;	O
else	O
{	O
arc	struct
.	O
angle2	int
=	O
-	O
miDatan2	function
(	O
pOtherCorner	struct
.	O
y	double
-	O
pCenter	struct
.	O
y	double
,	O
pOtherCorner	struct
.	O
x	double
-	O
pCenter	struct
.	O
x	double
)	O
-	O
arc	struct
.	O
angle1	int
;	O
if	O
(	O
arc	struct
.	O
angle2	int
<	O
0	int
)	O
arc	struct
.	O
angle2	int
+=	O
360.0	int
;	O
}	O
pArcPts	pointer
=	O
(	O
SppPoint	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
(	O
cpt	int
=	O
miGetArcPts	function
(	O
&	O
arc	struct
,	O
0	int
,	O
&	O
pArcPts	pointer
)	O
)	O
)	O
miFillSppPoly	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
cpt	int
,	O
pArcPts	pointer
,	O
-	O
xOrg	int
,	O
-	O
yOrg	int
,	O
xFtrans	double
,	O
yFtrans	double
)	O
;	O
free	function
(	O
pArcPts	pointer
)	O
;	O
}	O
static	O
int	O
miGetArcPts	function
(	O
const	O
SppArc	struct
*	O
parc	pointer
,	O
int	O
cpt	int
,	O
SppPoint	struct
*	O
*	O
ppPts	pointer
)	O
{	O
double	O
st	double
;	O
double	O
et	double
;	O
double	O
dt	double
;	O
double	O
cdt	double
;	O
double	O
x0	double
,	O
y0	function
;	O
double	O
x1	double
,	O
y1	function
;	O
double	O
x2	double
,	O
y2	double
;	O
double	O
xc	int
,	O
yc	int
;	O
int	O
count	int
,	O
i	int
;	O
SppPoint	struct
*	O
poly	array
;	O
miPoint	struct
last	struct
;	O
st	double
=	O
-	O
parc	pointer
->	O
angle1	int
;	O
et	double
=	O
-	O
parc	pointer
->	O
angle2	int
;	O
cdt	double
=	O
parc	pointer
->	O
width	array
;	O
if	O
(	O
parc	pointer
->	O
height	int
>	O
cdt	double
)	O
cdt	double
=	O
parc	pointer
->	O
height	int
;	O
cdt	double
*=	O
0.5	int
;	O
if	O
(	O
cdt	double
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
cdt	double
<	O
1.0	int
)	O
cdt	double
=	O
1.0	int
;	O
dt	double
=	O
miDasin	function
(	O
1.0	int
/	O
cdt	double
)	O
;	O
count	int
=	O
(	O
int	O
)	O
(	O
et	double
/	O
dt	double
)	O
;	O
count	int
=	O
abs	function
(	O
count	int
)	O
+	O
1	int
;	O
dt	double
=	O
et	double
/	O
count	int
;	O
count	int
++	O
;	O
cdt	double
=	O
2	int
*	O
miDcos	function
(	O
dt	double
)	O
;	O
poly	array
=	O
(	O
SppPoint	struct
*	O
)	O
mi_xrealloc	O
(	O
*	O
ppPts	pointer
,	O
(	O
cpt	int
+	O
count	int
)	O
*	O
sizeof	O
(	O
SppPoint	struct
)	O
)	O
;	O
*	O
ppPts	pointer
=	O
poly	array
;	O
xc	int
=	O
0.5	int
*	O
parc	pointer
->	O
width	array
;	O
yc	int
=	O
0.5	int
*	O
parc	pointer
->	O
height	int
;	O
x0	double
=	O
xc	int
*	O
miDcos	function
(	O
st	double
)	O
;	O
y0	function
=	O
yc	int
*	O
miDsin	function
(	O
st	double
)	O
;	O
x1	double
=	O
xc	int
*	O
miDcos	function
(	O
st	double
+	O
dt	double
)	O
;	O
y1	function
=	O
yc	int
*	O
miDsin	function
(	O
st	double
+	O
dt	double
)	O
;	O
xc	int
+=	O
parc	pointer
->	O
x	double
;	O
yc	int
+=	O
parc	pointer
->	O
y	double
;	O
poly	array
[	O
cpt	int
]	O
.	O
x	double
=	O
(	O
xc	int
+	O
x0	double
)	O
;	O
poly	array
[	O
cpt	int
]	O
.	O
y	double
=	O
(	O
yc	int
+	O
y0	function
)	O
;	O
poly	array
[	O
cpt	int
+	O
1	int
]	O
.	O
x	double
=	O
(	O
xc	int
+	O
x1	double
)	O
;	O
poly	array
[	O
cpt	int
+	O
1	int
]	O
.	O
y	double
=	O
(	O
yc	int
+	O
y1	function
)	O
;	O
last	struct
.	O
x	double
=	O
IROUND	O
(	O
xc	int
+	O
x1	double
)	O
;	O
last	struct
.	O
y	double
=	O
IROUND	O
(	O
yc	int
+	O
y1	function
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
x2	double
=	O
cdt	double
*	O
x1	double
-	O
x0	double
;	O
y2	double
=	O
cdt	double
*	O
y1	function
-	O
y0	function
;	O
poly	array
[	O
cpt	int
+	O
i	int
]	O
.	O
x	double
=	O
(	O
xc	int
+	O
x2	double
)	O
;	O
poly	array
[	O
cpt	int
+	O
i	int
]	O
.	O
y	double
=	O
(	O
yc	int
+	O
y2	double
)	O
;	O
x0	double
=	O
x1	double
;	O
y0	function
=	O
y1	function
;	O
x1	double
=	O
x2	double
;	O
y1	function
=	O
y2	double
;	O
}	O
if	O
(	O
FABS	O
(	O
parc	pointer
->	O
angle2	int
)	O
>=	O
360.0	int
)	O
poly	array
[	O
cpt	int
+	O
i	int
-	O
1	int
]	O
=	O
poly	array
[	O
0	int
]	O
;	O
else	O
{	O
poly	array
[	O
cpt	int
+	O
i	int
-	O
1	int
]	O
.	O
x	double
=	O
(	O
miDcos	function
(	O
st	double
+	O
et	double
)	O
*	O
0.5	int
*	O
parc	pointer
->	O
width	array
+	O
xc	int
)	O
;	O
poly	array
[	O
cpt	int
+	O
i	int
-	O
1	int
]	O
.	O
y	double
=	O
(	O
miDsin	function
(	O
st	double
+	O
et	double
)	O
*	O
0.5	int
*	O
parc	pointer
->	O
height	int
+	O
yc	int
)	O
;	O
}	O
return	O
count	int
;	O
}	O
static	O
double	O
miDcos	function
(	O
double	O
a	double
)	O
{	O
int	O
i	int
;	O
if	O
(	O
floor	function
(	O
a	double
/	O
90	int
)	O
==	O
a	double
/	O
90	int
)	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
a	double
/	O
90.0	int
)	O
;	O
switch	O
(	O
mod	O
(	O
i	int
,	O
4	int
)	O
)	O
{	O
case	O
0	int
:	O
return	O
1	int
;	O
case	O
1	int
:	O
return	O
0	int
;	O
case	O
2	int
:	O
return	O
-	O
1	int
;	O
case	O
3	int
:	O
return	O
0	int
;	O
}	O
}	O
return	O
cos	function
(	O
a	double
*	O
M_PI	int
/	O
180.0	int
)	O
;	O
}	O
static	O
double	O
miDsin	function
(	O
double	O
a	double
)	O
{	O
int	O
i	int
;	O
if	O
(	O
floor	function
(	O
a	double
/	O
90	int
)	O
==	O
a	double
/	O
90	int
)	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
a	double
/	O
90.0	int
)	O
;	O
switch	O
(	O
mod	O
(	O
i	int
,	O
4	int
)	O
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
1	int
:	O
return	O
1	int
;	O
case	O
2	int
:	O
return	O
0	int
;	O
case	O
3	int
:	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
sin	function
(	O
a	double
*	O
M_PI	int
/	O
180.0	int
)	O
;	O
}	O
static	O
double	O
miDasin	function
(	O
double	O
v	pointer
)	O
{	O
if	O
(	O
v	pointer
==	O
0	int
)	O
return	O
0.0	int
;	O
if	O
(	O
v	pointer
==	O
1.0	int
)	O
return	O
90.0	int
;	O
if	O
(	O
v	pointer
==	O
-	O
1.0	int
)	O
return	O
-	O
90.0	int
;	O
return	O
asin	function
(	O
v	pointer
)	O
*	O
(	O
180.0	int
/	O
M_PI	int
)	O
;	O
}	O
static	O
double	O
miDatan2	function
(	O
double	O
dy	int
,	O
double	O
dx	int
)	O
{	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
if	O
(	O
dx	int
>=	O
0	int
)	O
return	O
0.0	int
;	O
return	O
180.0	int
;	O
}	O
else	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
if	O
(	O
dy	int
>	O
0	int
)	O
return	O
90.0	int
;	O
return	O
-	O
90.0	int
;	O
}	O
else	O
if	O
(	O
FABS	O
(	O
dy	int
)	O
==	O
FABS	O
(	O
dx	int
)	O
)	O
{	O
if	O
(	O
dy	int
>	O
0	int
)	O
{	O
if	O
(	O
dx	int
>	O
0	int
)	O
return	O
45.0	int
;	O
return	O
135.0	int
;	O
}	O
else	O
{	O
if	O
(	O
dx	int
>	O
0	int
)	O
return	O
315.0	int
;	O
return	O
225.0	int
;	O
}	O
}	O
else	O
return	O
atan2	function
(	O
dy	int
,	O
dx	int
)	O
*	O
(	O
180.0	int
/	O
M_PI	int
)	O
;	O
}	O
static	O
double	O
angleToLength	function
(	O
int	O
angle	double
,	O
const	O
dashMap	struct
*	O
map	array
)	O
;	O
static	O
int	O
lengthToAngle	function
(	O
double	O
len	long
,	O
const	O
dashMap	struct
*	O
map	array
)	O
;	O
static	O
void	O
computeDashMap	function
(	O
const	O
miArc	struct
*	O
arcp	pointer
,	O
dashMap	struct
*	O
map	array
)	O
{	O
int	O
di	int
;	O
double	O
a	double
,	O
x	double
,	O
y	double
,	O
prevx	double
=	O
0.0	int
,	O
prevy	double
=	O
0.0	int
,	O
dist	int
;	O
for	O
(	O
di	int
=	O
0	int
;	O
di	int
<	O
DASH_MAP_SIZE	int
;	O
di	int
++	O
)	O
{	O
a	double
=	O
dashIndexToAngle	O
(	O
di	int
)	O
;	O
x	double
=	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcp	pointer
->	O
width	array
)	O
*	O
miDcos	function
(	O
a	double
)	O
;	O
y	double
=	O
(	O
double	O
)	O
(	O
0.5	int
*	O
arcp	pointer
->	O
height	int
)	O
*	O
miDsin	function
(	O
a	double
)	O
;	O
if	O
(	O
di	int
==	O
0	int
)	O
map	array
->	O
map	array
[	O
di	int
]	O
=	O
0.0	int
;	O
else	O
{	O
dist	int
=	O
hypot	function
(	O
x	double
-	O
prevx	double
,	O
y	double
-	O
prevy	double
)	O
;	O
map	array
->	O
map	array
[	O
di	int
]	O
=	O
map	array
->	O
map	array
[	O
di	int
-	O
1	int
]	O
+	O
dist	int
;	O
}	O
prevx	double
=	O
x	double
;	O
prevy	double
=	O
y	double
;	O
}	O
}	O
static	O
double	O
angleToLength	function
(	O
int	O
angle	double
,	O
const	O
dashMap	struct
*	O
map	array
)	O
{	O
double	O
len	long
,	O
excesslen	double
,	O
sidelen	double
=	O
map	array
->	O
map	array
[	O
DASH_MAP_SIZE	int
-	O
1	int
]	O
,	O
totallen	double
;	O
int	O
di	int
;	O
int	O
excess	int
;	O
bool	enum
oddSide	enum
=	O
false	int
;	O
totallen	double
=	O
0	int
;	O
if	O
(	O
angle	double
>=	O
0	int
)	O
{	O
while	O
(	O
angle	double
>=	O
90	int
*	O
64	int
)	O
{	O
angle	double
-=	O
90	int
*	O
64	int
;	O
totallen	double
+=	O
sidelen	double
;	O
oddSide	enum
=	O
(	O
oddSide	enum
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
angle	double
<	O
0	int
)	O
{	O
angle	double
+=	O
90	int
*	O
64	int
;	O
totallen	double
-=	O
sidelen	double
;	O
oddSide	enum
=	O
(	O
oddSide	enum
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
oddSide	enum
)	O
angle	double
=	O
90	int
*	O
64	int
-	O
angle	double
;	O
di	int
=	O
xAngleToDashIndex	O
(	O
angle	double
)	O
;	O
excess	int
=	O
angle	double
-	O
dashIndexToXAngle	O
(	O
di	int
)	O
;	O
len	long
=	O
map	array
->	O
map	array
[	O
di	int
]	O
;	O
if	O
(	O
excess	int
>	O
0	int
)	O
{	O
excesslen	double
=	O
(	O
map	array
->	O
map	array
[	O
di	int
+	O
1	int
]	O
-	O
map	array
->	O
map	array
[	O
di	int
]	O
)	O
*	O
(	O
(	O
double	O
)	O
excess	int
)	O
/	O
dashXAngleStep	O
;	O
len	long
+=	O
excesslen	double
;	O
}	O
if	O
(	O
oddSide	enum
)	O
totallen	double
+=	O
(	O
sidelen	double
-	O
len	long
)	O
;	O
else	O
totallen	double
+=	O
len	long
;	O
return	O
totallen	double
;	O
}	O
static	O
int	O
lengthToAngle	function
(	O
double	O
len	long
,	O
const	O
dashMap	struct
*	O
map	array
)	O
{	O
double	O
sidelen	double
=	O
map	array
->	O
map	array
[	O
DASH_MAP_SIZE	int
-	O
1	int
]	O
;	O
int	O
angle	double
,	O
angleexcess	int
;	O
bool	enum
oddSide	enum
=	O
false	int
;	O
int	O
a0	int
,	O
a1	int
,	O
a	double
;	O
angle	double
=	O
0	int
;	O
if	O
(	O
len	long
>=	O
0	int
)	O
{	O
if	O
(	O
sidelen	double
==	O
0	int
)	O
return	O
2	int
*	O
FULLCIRCLE	O
;	O
while	O
(	O
len	long
>=	O
sidelen	double
)	O
{	O
angle	double
+=	O
90	int
*	O
64	int
;	O
len	long
-=	O
sidelen	double
;	O
oddSide	enum
=	O
(	O
oddSide	enum
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
sidelen	double
==	O
0	int
)	O
return	O
-	O
2	int
*	O
FULLCIRCLE	O
;	O
while	O
(	O
len	long
<	O
0	int
)	O
{	O
angle	double
-=	O
90	int
*	O
64	int
;	O
len	long
+=	O
sidelen	double
;	O
oddSide	enum
=	O
(	O
oddSide	enum
?	O
false	int
:	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
oddSide	enum
)	O
len	long
=	O
sidelen	double
-	O
len	long
;	O
a0	int
=	O
0	int
;	O
a1	int
=	O
DASH_MAP_SIZE	int
-	O
1	int
;	O
while	O
(	O
a1	int
-	O
a0	int
>	O
1	int
)	O
{	O
a	double
=	O
(	O
a0	int
+	O
a1	int
)	O
/	O
2	int
;	O
if	O
(	O
len	long
>	O
map	array
->	O
map	array
[	O
a	double
]	O
)	O
a0	int
=	O
a	double
;	O
else	O
a1	int
=	O
a	double
;	O
}	O
angleexcess	int
=	O
dashIndexToXAngle	O
(	O
a0	int
)	O
;	O
angleexcess	int
+=	O
(	O
int	O
)	O
(	O
(	O
len	long
-	O
map	array
->	O
map	array
[	O
a0	int
]	O
)	O
/	O
(	O
map	array
->	O
map	array
[	O
a0	int
+	O
1	int
]	O
-	O
map	array
->	O
map	array
[	O
a0	int
]	O
)	O
*	O
dashXAngleStep	O
)	O
;	O
if	O
(	O
oddSide	enum
)	O
angle	double
+=	O
(	O
90	int
*	O
64	int
)	O
-	O
angleexcess	int
;	O
else	O
angle	double
+=	O
angleexcess	int
;	O
return	O
angle	double
;	O
}	O
static	O
int	O
computeAngleFromPath	function
(	O
int	O
startAngle	int
,	O
int	O
endAngle	int
,	O
const	O
dashMap	struct
*	O
map	array
,	O
int	O
*	O
lenp	pointer
,	O
bool	enum
backwards	enum
)	O
{	O
int	O
a0	int
,	O
a1	int
,	O
a	double
;	O
double	O
len0	double
;	O
int	O
len	long
;	O
a0	int
=	O
startAngle	int
;	O
a1	int
=	O
endAngle	int
;	O
len	long
=	O
*	O
lenp	pointer
;	O
if	O
(	O
backwards	enum
)	O
{	O
a0	int
=	O
FULLCIRCLE	O
-	O
a0	int
;	O
a1	int
=	O
FULLCIRCLE	O
-	O
a1	int
;	O
}	O
if	O
(	O
a1	int
<	O
a0	int
)	O
a1	int
+=	O
FULLCIRCLE	O
;	O
len0	double
=	O
angleToLength	function
(	O
a0	int
,	O
map	array
)	O
;	O
a	double
=	O
lengthToAngle	function
(	O
len0	double
+	O
len	long
,	O
map	array
)	O
;	O
if	O
(	O
a	double
>	O
a1	int
)	O
{	O
a	double
=	O
a1	int
;	O
len	long
=	O
(	O
int	O
)	O
(	O
len	long
-	O
angleToLength	function
(	O
a1	int
,	O
map	array
)	O
-	O
len0	double
)	O
;	O
}	O
else	O
len	long
=	O
0	int
;	O
if	O
(	O
backwards	enum
)	O
a	double
=	O
FULLCIRCLE	O
-	O
a	double
;	O
*	O
lenp	pointer
=	O
len	long
;	O
return	O
a	double
;	O
}	O
struct	O
arc_def	struct
{	O
double	O
w	double
,	O
h	double
;	O
double	O
l	int
;	O
double	O
a0	int
,	O
a1	int
;	O
}	O
;	O
struct	O
bound	struct
{	O
double	O
min	int
,	O
max	int
;	O
}	O
;	O
struct	O
ibound	struct
{	O
int	O
min	int
,	O
max	int
;	O
}	O
;	O
struct	O
arc_bound	struct
{	O
struct	O
bound	struct
ellipse	struct
;	O
struct	O
bound	struct
inner	struct
,	O
outer	struct
;	O
struct	O
bound	struct
right	pointer
,	O
left	pointer
;	O
struct	O
ibound	struct
inneri	struct
,	O
outeri	struct
;	O
}	O
;	O
struct	O
line	struct
{	O
double	O
m	array
,	O
b	pointer
;	O
bool	enum
valid	enum
;	O
}	O
;	O
struct	O
accelerators	struct
{	O
double	O
tail_y	double
;	O
double	O
h2	double
;	O
double	O
w2	double
;	O
double	O
h4	double
;	O
double	O
w4	double
;	O
double	O
h2mw2	double
;	O
double	O
h2l	double
;	O
double	O
w2l	double
;	O
double	O
fromIntX	double
;	O
double	O
fromIntY	double
;	O
struct	O
line	struct
left	pointer
,	O
right	pointer
;	O
int	O
yorgu	int
;	O
int	O
yorgl	int
;	O
int	O
xorg	int
;	O
}	O
;	O
static	O
double	O
hookEllipseY	function
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_bound	struct
*	O
bound	struct
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
bool	enum
left	pointer
)	O
;	O
static	O
double	O
hookX	function
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bound	struct
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
bool	enum
left	pointer
)	O
;	O
static	O
double	O
innerXfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
double	O
innerYfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
double	O
innerYfromY	function
(	O
double	O
y	double
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
double	O
outerXfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
double	O
outerYfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
double	O
tailX	function
(	O
double	O
K	double
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
void	O
computeAcc	function
(	O
const	O
miArc	struct
*	O
tarc	pointer
,	O
unsigned	O
int	O
lw	int
,	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
void	O
computeBound	function
(	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
arc_bound	struct
*	O
bound	struct
,	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
)	O
;	O
static	O
void	O
computeLine	function
(	O
double	O
x1	double
,	O
double	O
y1	function
,	O
double	O
x2	double
,	O
double	O
y2	double
,	O
struct	O
line	struct
*	O
line	struct
)	O
;	O
static	O
void	O
tailEllipseY	function
(	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
;	O
static	O
double	O
tailX	function
(	O
double	O
K	double
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
double	O
w	double
,	O
h	double
,	O
r	int
;	O
double	O
Hs	double
,	O
Hf	double
,	O
WH	double
,	O
Vk	double
,	O
Nk	double
,	O
Fk	double
,	O
Vr	double
,	O
N	double
,	O
Nc	double
,	O
Z	double
,	O
rs	double
;	O
double	O
A	double
,	O
T	double
,	O
b	pointer
,	O
d	double
,	O
x	double
,	O
y	double
,	O
t	double
,	O
hepp	double
,	O
hepm	double
;	O
int	O
flip	int
,	O
solution	enum
;	O
double	O
xs	array
[	O
2	int
]	O
;	O
double	O
*	O
xp	pointer
;	O
w	double
=	O
def	pointer
->	O
w	double
;	O
h	double
=	O
def	pointer
->	O
h	double
;	O
r	int
=	O
def	pointer
->	O
l	int
;	O
rs	double
=	O
r	int
*	O
r	int
;	O
Hs	double
=	O
acc	pointer
->	O
h2	double
;	O
WH	double
=	O
-	O
acc	pointer
->	O
h2mw2	double
;	O
Nk	double
=	O
def	pointer
->	O
w	double
*	O
r	int
;	O
Vk	double
=	O
(	O
Nk	double
*	O
Hs	double
)	O
/	O
(	O
WH	double
+	O
WH	double
)	O
;	O
Hf	double
=	O
acc	pointer
->	O
h4	double
;	O
Nk	double
=	O
(	O
Hf	double
-	O
Nk	double
*	O
Nk	double
)	O
/	O
WH	double
;	O
if	O
(	O
K	double
==	O
0.0	int
)	O
{	O
if	O
(	O
Nk	double
<	O
0.0	int
&&	O
-	O
Nk	double
<	O
Hs	double
)	O
{	O
xs	array
[	O
0	int
]	O
=	O
w	double
*	O
sqrt	function
(	O
1	int
+	O
Nk	double
/	O
Hs	double
)	O
-	O
sqrt	function
(	O
rs	double
+	O
Nk	double
)	O
;	O
xs	array
[	O
1	int
]	O
=	O
w	double
-	O
r	int
;	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
left	pointer
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
outer	struct
)	O
&&	O
xs	array
[	O
0	int
]	O
>=	O
0.0	int
&&	O
xs	array
[	O
1	int
]	O
>=	O
0.0	int
)	O
return	O
xs	array
[	O
1	int
]	O
;	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
right	pointer
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
inner	struct
)	O
&&	O
xs	array
[	O
0	int
]	O
<=	O
0.0	int
&&	O
xs	array
[	O
1	int
]	O
<=	O
0.0	int
)	O
return	O
xs	array
[	O
1	int
]	O
;	O
return	O
xs	array
[	O
0	int
]	O
;	O
}	O
return	O
w	double
-	O
r	int
;	O
}	O
Fk	double
=	O
Hf	double
/	O
WH	double
;	O
hepp	double
=	O
h	double
+	O
EPSILON	int
;	O
hepm	double
=	O
h	double
-	O
EPSILON	int
;	O
N	double
=	O
(	O
K	double
*	O
K	double
+	O
Nk	double
)	O
/	O
6.0	int
;	O
Nc	double
=	O
N	double
*	O
N	double
*	O
N	double
;	O
Vr	double
=	O
Vk	double
*	O
K	double
;	O
xp	pointer
=	O
xs	array
;	O
xs	array
[	O
0	int
]	O
=	O
0.0	int
;	O
t	double
=	O
Nc	double
+	O
Vr	double
*	O
Vr	double
;	O
d	double
=	O
Nc	double
+	O
t	double
;	O
if	O
(	O
d	double
<	O
0.0	int
)	O
{	O
d	double
=	O
Nc	double
;	O
b	pointer
=	O
N	double
;	O
if	O
(	O
(	O
b	pointer
<	O
0.0	int
)	O
==	O
(	O
t	double
<	O
0.0	int
)	O
)	O
{	O
b	pointer
=	O
-	O
b	pointer
;	O
d	double
=	O
-	O
d	double
;	O
}	O
Z	double
=	O
N	double
-	O
2.0	int
*	O
b	pointer
*	O
cos	function
(	O
acos	function
(	O
-	O
t	double
/	O
d	double
)	O
/	O
3.0	int
)	O
;	O
if	O
(	O
(	O
Z	double
<	O
0.0	int
)	O
==	O
(	O
Vr	double
<	O
0.0	int
)	O
)	O
flip	int
=	O
2	int
;	O
else	O
flip	int
=	O
1	int
;	O
}	O
else	O
{	O
d	double
=	O
Vr	double
*	O
sqrt	function
(	O
d	double
)	O
;	O
Z	double
=	O
N	double
+	O
cbrt	function
(	O
t	double
+	O
d	double
)	O
+	O
cbrt	function
(	O
t	double
-	O
d	double
)	O
;	O
flip	int
=	O
0	int
;	O
}	O
A	double
=	O
sqrt	function
(	O
(	O
Z	double
+	O
Z	double
)	O
-	O
Nk	double
)	O
;	O
T	double
=	O
(	O
Fk	double
-	O
Z	double
)	O
*	O
K	double
/	O
A	double
;	O
solution	enum
=	O
false	int
;	O
b	pointer
=	O
-	O
A	double
+	O
K	double
;	O
d	double
=	O
b	pointer
*	O
b	pointer
-	O
4	int
*	O
(	O
Z	double
+	O
T	double
)	O
;	O
if	O
(	O
d	double
>=	O
0	int
&&	O
flip	int
==	O
2	int
)	O
{	O
d	double
=	O
sqrt	function
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	pointer
+	O
d	double
)	O
;	O
if	O
(	O
(	O
y	double
>=	O
0.0	int
)	O
&&	O
(	O
y	double
<	O
hepp	double
)	O
)	O
{	O
solution	enum
=	O
true	int
;	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	function
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	function
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
*	O
xp	pointer
++	O
=	O
x	double
-	O
t	double
;	O
}	O
}	O
b	pointer
=	O
A	double
+	O
K	double
;	O
d	double
=	O
b	pointer
*	O
b	pointer
-	O
4	int
*	O
(	O
Z	double
-	O
T	double
)	O
;	O
if	O
(	O
d	double
<	O
0	int
&&	O
!	O
solution	enum
)	O
d	double
=	O
0.0	int
;	O
if	O
(	O
d	double
>=	O
0	int
)	O
{	O
d	double
=	O
sqrt	function
(	O
d	double
)	O
;	O
y	double
=	O
0.5	int
*	O
(	O
b	pointer
+	O
d	double
)	O
;	O
if	O
(	O
y	double
<	O
hepp	double
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	function
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
*	O
xp	pointer
++	O
=	O
x	double
-	O
sqrt	function
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
}	O
y	double
=	O
0.5	int
*	O
(	O
b	pointer
-	O
d	double
)	O
;	O
if	O
(	O
y	double
>=	O
0.0	int
&&	O
flip	int
==	O
1	int
)	O
{	O
if	O
(	O
y	double
>	O
hepm	double
)	O
y	double
=	O
h	double
;	O
t	double
=	O
y	double
/	O
h	double
;	O
x	double
=	O
w	double
*	O
sqrt	function
(	O
1	int
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
t	double
=	O
K	double
-	O
y	double
;	O
t	double
=	O
sqrt	function
(	O
rs	double
-	O
(	O
t	double
*	O
t	double
)	O
)	O
;	O
*	O
xp	pointer
++	O
=	O
x	double
-	O
t	double
;	O
}	O
}	O
if	O
(	O
xp	pointer
>	O
&	O
xs	array
[	O
1	int
]	O
)	O
{	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
left	pointer
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
outer	struct
)	O
&&	O
xs	array
[	O
0	int
]	O
>=	O
0.0	int
&&	O
xs	array
[	O
1	int
]	O
>=	O
0.0	int
)	O
return	O
xs	array
[	O
1	int
]	O
;	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
right	pointer
)	O
&&	O
!	O
boundedLe	O
(	O
K	double
,	O
bounds	array
->	O
inner	struct
)	O
&&	O
xs	array
[	O
0	int
]	O
<=	O
0.0	int
&&	O
xs	array
[	O
1	int
]	O
<=	O
0.0	int
)	O
return	O
xs	array
[	O
1	int
]	O
;	O
}	O
return	O
xs	array
[	O
0	int
]	O
;	O
}	O
static	O
void	O
tailEllipseY	function
(	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
double	O
t	double
;	O
acc	pointer
->	O
tail_y	double
=	O
0.0	int
;	O
if	O
(	O
def	pointer
->	O
w	double
==	O
def	pointer
->	O
h	double
)	O
return	O
;	O
t	double
=	O
def	pointer
->	O
l	int
*	O
def	pointer
->	O
w	double
;	O
if	O
(	O
def	pointer
->	O
w	double
>	O
def	pointer
->	O
h	double
)	O
{	O
if	O
(	O
t	double
<	O
acc	pointer
->	O
h2	double
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
t	double
>	O
acc	pointer
->	O
h2	double
)	O
return	O
;	O
}	O
t	double
=	O
2.0	int
*	O
def	pointer
->	O
h	double
*	O
t	double
;	O
t	double
=	O
(	O
CUBE_ROOT_4	int
*	O
acc	pointer
->	O
h2	double
-	O
cbrt	function
(	O
t	double
*	O
t	double
)	O
)	O
/	O
acc	pointer
->	O
h2mw2	double
;	O
if	O
(	O
t	double
>	O
0.0	int
)	O
acc	pointer
->	O
tail_y	double
=	O
def	pointer
->	O
h	double
/	O
CUBE_ROOT_2	int
*	O
sqrt	function
(	O
t	double
)	O
;	O
}	O
static	O
double	O
outerXfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
return	O
x	double
+	O
(	O
x	double
*	O
acc	pointer
->	O
h2l	double
)	O
/	O
sqrt	function
(	O
x	double
*	O
x	double
*	O
acc	pointer
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	pointer
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
outerYfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
return	O
y	double
+	O
(	O
y	double
*	O
acc	pointer
->	O
w2l	double
)	O
/	O
sqrt	function
(	O
x	double
*	O
x	double
*	O
acc	pointer
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	pointer
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
innerXfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
return	O
x	double
-	O
(	O
x	double
*	O
acc	pointer
->	O
h2l	double
)	O
/	O
sqrt	function
(	O
x	double
*	O
x	double
*	O
acc	pointer
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	pointer
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
innerYfromXY	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
return	O
y	double
-	O
(	O
y	double
*	O
acc	pointer
->	O
w2l	double
)	O
/	O
sqrt	function
(	O
x	double
*	O
x	double
*	O
acc	pointer
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	pointer
->	O
w4	double
)	O
;	O
}	O
static	O
double	O
innerYfromY	function
(	O
double	O
y	double
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
double	O
x	double
;	O
x	double
=	O
(	O
def	pointer
->	O
w	double
/	O
def	pointer
->	O
h	double
)	O
*	O
sqrt	function
(	O
acc	pointer
->	O
h2	double
-	O
y	double
*	O
y	double
)	O
;	O
return	O
y	double
-	O
(	O
y	double
*	O
acc	pointer
->	O
w2l	double
)	O
/	O
sqrt	function
(	O
x	double
*	O
x	double
*	O
acc	pointer
->	O
h4	double
+	O
y	double
*	O
y	double
*	O
acc	pointer
->	O
w4	double
)	O
;	O
}	O
static	O
void	O
computeLine	function
(	O
double	O
x1	double
,	O
double	O
y1	function
,	O
double	O
x2	double
,	O
double	O
y2	double
,	O
struct	O
line	struct
*	O
line	struct
)	O
{	O
if	O
(	O
y1	function
==	O
y2	double
)	O
line	struct
->	O
valid	enum
=	O
false	int
;	O
else	O
{	O
line	struct
->	O
m	array
=	O
(	O
x1	double
-	O
x2	double
)	O
/	O
(	O
y1	function
-	O
y2	double
)	O
;	O
line	struct
->	O
b	pointer
=	O
x1	double
-	O
y1	function
*	O
line	struct
->	O
m	array
;	O
line	struct
->	O
valid	enum
=	O
true	int
;	O
}	O
}	O
static	O
void	O
computeAcc	function
(	O
const	O
miArc	struct
*	O
tarc	pointer
,	O
unsigned	O
int	O
lw	int
,	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
accelerators	struct
*	O
acc	pointer
)	O
{	O
def	pointer
->	O
w	double
=	O
0.5	int
*	O
(	O
double	O
)	O
tarc	pointer
->	O
width	array
;	O
def	pointer
->	O
h	double
=	O
0.5	int
*	O
(	O
double	O
)	O
tarc	pointer
->	O
height	int
;	O
def	pointer
->	O
l	int
=	O
0.5	int
*	O
(	O
double	O
)	O
lw	int
;	O
acc	pointer
->	O
h2	double
=	O
def	pointer
->	O
h	double
*	O
def	pointer
->	O
h	double
;	O
acc	pointer
->	O
w2	double
=	O
def	pointer
->	O
w	double
*	O
def	pointer
->	O
w	double
;	O
acc	pointer
->	O
h4	double
=	O
acc	pointer
->	O
h2	double
*	O
acc	pointer
->	O
h2	double
;	O
acc	pointer
->	O
w4	double
=	O
acc	pointer
->	O
w2	double
*	O
acc	pointer
->	O
w2	double
;	O
acc	pointer
->	O
h2l	double
=	O
acc	pointer
->	O
h2	double
*	O
def	pointer
->	O
l	int
;	O
acc	pointer
->	O
w2l	double
=	O
acc	pointer
->	O
w2	double
*	O
def	pointer
->	O
l	int
;	O
acc	pointer
->	O
h2mw2	double
=	O
acc	pointer
->	O
h2	double
-	O
acc	pointer
->	O
w2	double
;	O
acc	pointer
->	O
fromIntX	double
=	O
(	O
tarc	pointer
->	O
width	array
&	O
1	int
)	O
?	O
0.5	int
:	O
0.0	int
;	O
acc	pointer
->	O
fromIntY	double
=	O
(	O
tarc	pointer
->	O
height	int
&	O
1	int
)	O
?	O
0.5	int
:	O
0.0	int
;	O
acc	pointer
->	O
xorg	int
=	O
tarc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
tarc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
acc	pointer
->	O
yorgu	int
=	O
tarc	pointer
->	O
y	double
+	O
(	O
int	O
)	O
(	O
tarc	pointer
->	O
height	int
>>	O
1	int
)	O
;	O
acc	pointer
->	O
yorgl	int
=	O
acc	pointer
->	O
yorgu	int
+	O
(	O
tarc	pointer
->	O
height	int
&	O
1	int
)	O
;	O
tailEllipseY	function
(	O
def	pointer
,	O
acc	pointer
)	O
;	O
}	O
static	O
void	O
computeBound	function
(	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
arc_bound	struct
*	O
bound	struct
,	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
)	O
{	O
double	O
t	double
;	O
double	O
innerTaily	double
;	O
double	O
tail_y	double
;	O
struct	O
bound	struct
innerx	struct
,	O
outerx	struct
;	O
struct	O
bound	struct
ellipsex	struct
;	O
bound	struct
->	O
ellipse	struct
.	O
min	int
=	O
Dsin	O
(	O
def	pointer
->	O
a0	int
)	O
*	O
def	pointer
->	O
h	double
;	O
bound	struct
->	O
ellipse	struct
.	O
max	int
=	O
Dsin	O
(	O
def	pointer
->	O
a1	int
)	O
*	O
def	pointer
->	O
h	double
;	O
if	O
(	O
def	pointer
->	O
a0	int
==	O
45	int
&&	O
def	pointer
->	O
w	double
==	O
def	pointer
->	O
h	double
)	O
ellipsex	struct
.	O
min	int
=	O
bound	struct
->	O
ellipse	struct
.	O
min	int
;	O
else	O
ellipsex	struct
.	O
min	int
=	O
Dcos	O
(	O
def	pointer
->	O
a0	int
)	O
*	O
def	pointer
->	O
w	double
;	O
if	O
(	O
def	pointer
->	O
a1	int
==	O
45	int
&&	O
def	pointer
->	O
w	double
==	O
def	pointer
->	O
h	double
)	O
ellipsex	struct
.	O
max	int
=	O
bound	struct
->	O
ellipse	struct
.	O
max	int
;	O
else	O
ellipsex	struct
.	O
max	int
=	O
Dcos	O
(	O
def	pointer
->	O
a1	int
)	O
*	O
def	pointer
->	O
w	double
;	O
bound	struct
->	O
outer	struct
.	O
min	int
=	O
outerYfromXY	function
(	O
ellipsex	struct
.	O
min	int
,	O
bound	struct
->	O
ellipse	struct
.	O
min	int
,	O
acc	pointer
)	O
;	O
bound	struct
->	O
outer	struct
.	O
max	int
=	O
outerYfromXY	function
(	O
ellipsex	struct
.	O
max	int
,	O
bound	struct
->	O
ellipse	struct
.	O
max	int
,	O
acc	pointer
)	O
;	O
bound	struct
->	O
inner	struct
.	O
min	int
=	O
innerYfromXY	function
(	O
ellipsex	struct
.	O
min	int
,	O
bound	struct
->	O
ellipse	struct
.	O
min	int
,	O
acc	pointer
)	O
;	O
bound	struct
->	O
inner	struct
.	O
max	int
=	O
innerYfromXY	function
(	O
ellipsex	struct
.	O
max	int
,	O
bound	struct
->	O
ellipse	struct
.	O
max	int
,	O
acc	pointer
)	O
;	O
outerx	struct
.	O
min	int
=	O
outerXfromXY	function
(	O
ellipsex	struct
.	O
min	int
,	O
bound	struct
->	O
ellipse	struct
.	O
min	int
,	O
acc	pointer
)	O
;	O
outerx	struct
.	O
max	int
=	O
outerXfromXY	function
(	O
ellipsex	struct
.	O
max	int
,	O
bound	struct
->	O
ellipse	struct
.	O
max	int
,	O
acc	pointer
)	O
;	O
innerx	struct
.	O
min	int
=	O
innerXfromXY	function
(	O
ellipsex	struct
.	O
min	int
,	O
bound	struct
->	O
ellipse	struct
.	O
min	int
,	O
acc	pointer
)	O
;	O
innerx	struct
.	O
max	int
=	O
innerXfromXY	function
(	O
ellipsex	struct
.	O
max	int
,	O
bound	struct
->	O
ellipse	struct
.	O
max	int
,	O
acc	pointer
)	O
;	O
if	O
(	O
right	pointer
)	O
{	O
right	pointer
->	O
counterClock	struct
.	O
y	double
=	O
bound	struct
->	O
outer	struct
.	O
min	int
;	O
right	pointer
->	O
counterClock	struct
.	O
x	double
=	O
outerx	struct
.	O
min	int
;	O
right	pointer
->	O
center	struct
.	O
y	double
=	O
bound	struct
->	O
ellipse	struct
.	O
min	int
;	O
right	pointer
->	O
center	struct
.	O
x	double
=	O
ellipsex	struct
.	O
min	int
;	O
right	pointer
->	O
clock	function
.	O
y	double
=	O
bound	struct
->	O
inner	struct
.	O
min	int
;	O
right	pointer
->	O
clock	function
.	O
x	double
=	O
innerx	struct
.	O
min	int
;	O
}	O
if	O
(	O
left	pointer
)	O
{	O
left	pointer
->	O
clock	function
.	O
y	double
=	O
bound	struct
->	O
outer	struct
.	O
max	int
;	O
left	pointer
->	O
clock	function
.	O
x	double
=	O
outerx	struct
.	O
max	int
;	O
left	pointer
->	O
center	struct
.	O
y	double
=	O
bound	struct
->	O
ellipse	struct
.	O
max	int
;	O
left	pointer
->	O
center	struct
.	O
x	double
=	O
ellipsex	struct
.	O
max	int
;	O
left	pointer
->	O
counterClock	struct
.	O
y	double
=	O
bound	struct
->	O
inner	struct
.	O
max	int
;	O
left	pointer
->	O
counterClock	struct
.	O
x	double
=	O
innerx	struct
.	O
max	int
;	O
}	O
bound	struct
->	O
left	pointer
.	O
min	int
=	O
bound	struct
->	O
inner	struct
.	O
max	int
;	O
bound	struct
->	O
left	pointer
.	O
max	int
=	O
bound	struct
->	O
outer	struct
.	O
max	int
;	O
bound	struct
->	O
right	pointer
.	O
min	int
=	O
bound	struct
->	O
inner	struct
.	O
min	int
;	O
bound	struct
->	O
right	pointer
.	O
max	int
=	O
bound	struct
->	O
outer	struct
.	O
min	int
;	O
computeLine	function
(	O
innerx	struct
.	O
min	int
,	O
bound	struct
->	O
inner	struct
.	O
min	int
,	O
outerx	struct
.	O
min	int
,	O
bound	struct
->	O
outer	struct
.	O
min	int
,	O
&	O
acc	pointer
->	O
right	pointer
)	O
;	O
computeLine	function
(	O
innerx	struct
.	O
max	int
,	O
bound	struct
->	O
inner	struct
.	O
max	int
,	O
outerx	struct
.	O
max	int
,	O
bound	struct
->	O
outer	struct
.	O
max	int
,	O
&	O
acc	pointer
->	O
left	pointer
)	O
;	O
if	O
(	O
bound	struct
->	O
inner	struct
.	O
min	int
>	O
bound	struct
->	O
inner	struct
.	O
max	int
)	O
{	O
t	double
=	O
bound	struct
->	O
inner	struct
.	O
min	int
;	O
bound	struct
->	O
inner	struct
.	O
min	int
=	O
bound	struct
->	O
inner	struct
.	O
max	int
;	O
bound	struct
->	O
inner	struct
.	O
max	int
=	O
t	double
;	O
}	O
tail_y	double
=	O
acc	pointer
->	O
tail_y	double
;	O
if	O
(	O
tail_y	double
>	O
bound	struct
->	O
ellipse	struct
.	O
max	int
)	O
tail_y	double
=	O
bound	struct
->	O
ellipse	struct
.	O
max	int
;	O
else	O
if	O
(	O
tail_y	double
<	O
bound	struct
->	O
ellipse	struct
.	O
min	int
)	O
tail_y	double
=	O
bound	struct
->	O
ellipse	struct
.	O
min	int
;	O
innerTaily	double
=	O
innerYfromY	function
(	O
tail_y	double
,	O
def	pointer
,	O
acc	pointer
)	O
;	O
if	O
(	O
bound	struct
->	O
inner	struct
.	O
min	int
>	O
innerTaily	double
)	O
bound	struct
->	O
inner	struct
.	O
min	int
=	O
innerTaily	double
;	O
if	O
(	O
bound	struct
->	O
inner	struct
.	O
max	int
<	O
innerTaily	double
)	O
bound	struct
->	O
inner	struct
.	O
max	int
=	O
innerTaily	double
;	O
bound	struct
->	O
inneri	struct
.	O
min	int
=	O
ICEIL	O
(	O
bound	struct
->	O
inner	struct
.	O
min	int
-	O
acc	pointer
->	O
fromIntY	double
)	O
;	O
bound	struct
->	O
inneri	struct
.	O
max	int
=	O
IFLOOR	O
(	O
bound	struct
->	O
inner	struct
.	O
max	int
-	O
acc	pointer
->	O
fromIntY	double
)	O
;	O
bound	struct
->	O
outeri	struct
.	O
min	int
=	O
ICEIL	O
(	O
bound	struct
->	O
outer	struct
.	O
min	int
-	O
acc	pointer
->	O
fromIntY	double
)	O
;	O
bound	struct
->	O
outeri	struct
.	O
max	int
=	O
IFLOOR	O
(	O
bound	struct
->	O
outer	struct
.	O
max	int
-	O
acc	pointer
->	O
fromIntY	double
)	O
;	O
}	O
static	O
double	O
hookEllipseY	function
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_bound	struct
*	O
bound	struct
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
bool	enum
left	pointer
)	O
{	O
double	O
ret	double
;	O
if	O
(	O
acc	pointer
->	O
h2mw2	double
==	O
0	int
)	O
{	O
if	O
(	O
(	O
scan_y	double
>	O
0	int
&&	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
)	O
||	O
(	O
scan_y	double
<	O
0	int
&&	O
left	pointer
)	O
)	O
return	O
bound	struct
->	O
ellipse	struct
.	O
min	int
;	O
return	O
bound	struct
->	O
ellipse	struct
.	O
max	int
;	O
}	O
ret	double
=	O
(	O
acc	pointer
->	O
h4	double
*	O
scan_y	double
)	O
/	O
(	O
acc	pointer
->	O
h2mw2	double
)	O
;	O
if	O
(	O
ret	double
>=	O
0	int
)	O
return	O
cbrt	function
(	O
ret	double
)	O
;	O
else	O
return	O
-	O
cbrt	function
(	O
-	O
ret	double
)	O
;	O
}	O
static	O
double	O
hookX	function
(	O
double	O
scan_y	double
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bound	struct
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
bool	enum
left	pointer
)	O
{	O
double	O
ellipse_y	double
,	O
x	double
;	O
double	O
maxMin	double
;	O
if	O
(	O
def	pointer
->	O
w	double
!=	O
def	pointer
->	O
h	double
)	O
{	O
ellipse_y	double
=	O
hookEllipseY	function
(	O
scan_y	double
,	O
bound	struct
,	O
acc	pointer
,	O
left	pointer
)	O
;	O
if	O
(	O
boundedLe	O
(	O
ellipse_y	double
,	O
bound	struct
->	O
ellipse	struct
)	O
)	O
{	O
maxMin	double
=	O
ellipse_y	double
*	O
ellipse_y	double
*	O
ellipse_y	double
*	O
acc	pointer
->	O
h2mw2	double
-	O
acc	pointer
->	O
h2	double
*	O
scan_y	double
*	O
(	O
3	int
*	O
ellipse_y	double
*	O
ellipse_y	double
-	O
2	int
*	O
acc	pointer
->	O
h2	double
)	O
;	O
if	O
(	O
(	O
left	pointer
&&	O
maxMin	double
>	O
0	int
)	O
||	O
(	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
&&	O
maxMin	double
<	O
0	int
)	O
)	O
{	O
if	O
(	O
ellipse_y	double
==	O
0	int
)	O
return	O
def	pointer
->	O
w	double
+	O
left	pointer
?	O
-	O
def	pointer
->	O
l	int
:	O
def	pointer
->	O
l	int
;	O
x	double
=	O
(	O
acc	pointer
->	O
h2	double
*	O
scan_y	double
-	O
ellipse_y	double
*	O
acc	pointer
->	O
h2mw2	double
)	O
*	O
sqrt	function
(	O
acc	pointer
->	O
h2	double
-	O
ellipse_y	double
*	O
ellipse_y	double
)	O
/	O
(	O
def	pointer
->	O
h	double
*	O
def	pointer
->	O
w	double
*	O
ellipse_y	double
)	O
;	O
return	O
x	double
;	O
}	O
}	O
}	O
if	O
(	O
left	pointer
)	O
{	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
scan_y	double
,	O
bound	struct
->	O
left	pointer
)	O
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	pointer
->	O
left	pointer
)	O
;	O
else	O
{	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	pointer
->	O
right	pointer
)	O
;	O
else	O
x	double
=	O
def	pointer
->	O
w	double
-	O
def	pointer
->	O
l	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
scan_y	double
,	O
bound	struct
->	O
right	pointer
)	O
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	pointer
->	O
right	pointer
)	O
;	O
else	O
{	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
)	O
x	double
=	O
intersectLine	O
(	O
scan_y	double
,	O
acc	pointer
->	O
left	pointer
)	O
;	O
else	O
x	double
=	O
def	pointer
->	O
w	double
-	O
def	pointer
->	O
l	int
;	O
}	O
}	O
return	O
x	double
;	O
}	O
static	O
struct	O
finalSpan	struct
*	O
realAllocSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
;	O
static	O
struct	O
finalSpan	struct
*	O
*	O
realFindSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
)	O
;	O
static	O
void	O
disposeFinalSpans	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
;	O
static	O
void	O
newFinalSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
,	O
int	O
xmin	double
,	O
int	O
xmax	double
)	O
;	O
static	O
void	O
initAccumSpans	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
{	O
accumSpans	pointer
->	O
finalSpans	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
*	O
)	O
NULL	O
;	O
accumSpans	pointer
->	O
finalMiny	int
=	O
0	int
;	O
accumSpans	pointer
->	O
finalMaxy	int
=	O
-	O
1	int
;	O
accumSpans	pointer
->	O
finalSize	int
=	O
0	int
;	O
accumSpans	pointer
->	O
nspans	int
=	O
0	int
;	O
accumSpans	pointer
->	O
chunks	pointer
=	O
(	O
struct	O
finalSpanChunk	struct
*	O
)	O
NULL	O
;	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
newFinalSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
,	O
int	O
xmin	double
,	O
int	O
xmax	double
)	O
{	O
struct	O
finalSpan	struct
*	O
x	double
,	O
*	O
oldx	pointer
,	O
*	O
prev	pointer
,	O
*	O
*	O
f	pointer
;	O
if	O
(	O
accumSpans	pointer
->	O
finalMiny	int
<=	O
y	double
&&	O
y	double
<=	O
accumSpans	pointer
->	O
finalMaxy	int
)	O
f	pointer
=	O
&	O
(	O
(	O
accumSpans	pointer
->	O
finalSpans	pointer
)	O
[	O
(	O
y	double
)	O
-	O
(	O
accumSpans	pointer
->	O
finalMiny	int
)	O
]	O
)	O
;	O
else	O
f	pointer
=	O
realFindSpan	function
(	O
accumSpans	pointer
,	O
y	double
)	O
;	O
if	O
(	O
f	pointer
==	O
(	O
struct	O
finalSpan	struct
*	O
*	O
)	O
NULL	O
)	O
return	O
;	O
oldx	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
prev	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
for	O
(	O
x	double
=	O
*	O
f	pointer
;	O
x	double
;	O
x	double
=	O
x	double
->	O
next	pointer
)	O
{	O
if	O
(	O
x	double
==	O
oldx	pointer
)	O
{	O
prev	pointer
=	O
x	double
;	O
continue	O
;	O
}	O
if	O
(	O
x	double
->	O
min	int
<=	O
xmax	double
&&	O
xmin	double
<=	O
x	double
->	O
max	int
)	O
{	O
if	O
(	O
oldx	pointer
)	O
{	O
oldx	pointer
->	O
min	int
=	O
IMIN	O
(	O
x	double
->	O
min	int
,	O
xmin	double
)	O
;	O
oldx	pointer
->	O
max	int
=	O
IMAX	O
(	O
x	double
->	O
max	int
,	O
xmax	double
)	O
;	O
if	O
(	O
prev	pointer
)	O
prev	pointer
->	O
next	pointer
=	O
x	double
->	O
next	pointer
;	O
else	O
*	O
f	pointer
=	O
x	double
->	O
next	pointer
;	O
--	O
(	O
accumSpans	pointer
->	O
nspans	int
)	O
;	O
}	O
else	O
{	O
x	double
->	O
min	int
=	O
IMIN	O
(	O
x	double
->	O
min	int
,	O
xmin	double
)	O
;	O
x	double
->	O
max	int
=	O
IMAX	O
(	O
x	double
->	O
max	int
,	O
xmax	double
)	O
;	O
oldx	pointer
=	O
x	double
;	O
}	O
xmin	double
=	O
oldx	pointer
->	O
min	int
;	O
xmax	double
=	O
oldx	pointer
->	O
max	int
;	O
break	O
;	O
}	O
prev	pointer
=	O
x	double
;	O
}	O
if	O
(	O
!	O
x	double
)	O
break	O
;	O
}	O
if	O
(	O
!	O
oldx	pointer
)	O
{	O
if	O
(	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
!=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
)	O
{	O
x	double
=	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
;	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
=	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
->	O
next	pointer
;	O
x	double
->	O
next	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
}	O
else	O
x	double
=	O
realAllocSpan	function
(	O
accumSpans	pointer
)	O
;	O
if	O
(	O
x	double
)	O
{	O
x	double
->	O
min	int
=	O
xmin	double
;	O
x	double
->	O
max	int
=	O
xmax	double
;	O
x	double
->	O
next	pointer
=	O
*	O
f	pointer
;	O
*	O
f	pointer
=	O
x	double
;	O
++	O
(	O
accumSpans	pointer
->	O
nspans	int
)	O
;	O
}	O
}	O
}	O
static	O
struct	O
finalSpan	struct
*	O
*	O
realFindSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
)	O
{	O
struct	O
finalSpan	struct
*	O
*	O
newSpans	pointer
,	O
*	O
*	O
t	double
;	O
int	O
newSize	int
,	O
newMiny	int
,	O
newMaxy	int
;	O
int	O
change	int
;	O
int	O
i	int
,	O
k	int
;	O
if	O
(	O
y	double
<	O
accumSpans	pointer
->	O
finalMiny	int
||	O
y	double
>	O
accumSpans	pointer
->	O
finalMaxy	int
)	O
{	O
if	O
(	O
accumSpans	pointer
->	O
finalSize	int
==	O
0	int
)	O
{	O
accumSpans	pointer
->	O
finalMiny	int
=	O
y	double
;	O
accumSpans	pointer
->	O
finalMaxy	int
=	O
y	double
-	O
1	int
;	O
}	O
if	O
(	O
y	double
<	O
accumSpans	pointer
->	O
finalMiny	int
)	O
change	int
=	O
accumSpans	pointer
->	O
finalMiny	int
-	O
y	double
;	O
else	O
change	int
=	O
y	double
-	O
accumSpans	pointer
->	O
finalMaxy	int
;	O
if	O
(	O
change	int
>=	O
SPAN_REALLOC	int
)	O
change	int
+=	O
SPAN_REALLOC	int
;	O
else	O
change	int
=	O
SPAN_REALLOC	int
;	O
newSize	int
=	O
accumSpans	pointer
->	O
finalSize	int
+	O
change	int
;	O
newSpans	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
*	O
)	O
mi_xmalloc	O
(	O
newSize	int
*	O
sizeof	O
(	O
struct	O
finalSpan	struct
*	O
)	O
)	O
;	O
newMiny	int
=	O
accumSpans	pointer
->	O
finalMiny	int
;	O
newMaxy	int
=	O
accumSpans	pointer
->	O
finalMaxy	int
;	O
if	O
(	O
y	double
<	O
accumSpans	pointer
->	O
finalMiny	int
)	O
newMiny	int
=	O
accumSpans	pointer
->	O
finalMiny	int
-	O
change	int
;	O
else	O
newMaxy	int
=	O
accumSpans	pointer
->	O
finalMaxy	int
+	O
change	int
;	O
if	O
(	O
accumSpans	pointer
->	O
finalSpans	pointer
)	O
{	O
memmove	function
(	O
(	O
void	O
*	O
)	O
(	O
newSpans	pointer
+	O
(	O
accumSpans	pointer
->	O
finalMiny	int
-	O
newMiny	int
)	O
)	O
,	O
(	O
void	O
*	O
)	O
(	O
accumSpans	pointer
->	O
finalSpans	pointer
)	O
,	O
accumSpans	pointer
->	O
finalSize	int
*	O
sizeof	O
(	O
struct	O
finalSpan	struct
*	O
)	O
)	O
;	O
free	function
(	O
accumSpans	pointer
->	O
finalSpans	pointer
)	O
;	O
}	O
if	O
(	O
(	O
i	int
=	O
accumSpans	pointer
->	O
finalMiny	int
-	O
newMiny	int
)	O
>	O
0	int
)	O
for	O
(	O
k	int
=	O
0	int
,	O
t	double
=	O
newSpans	pointer
;	O
k	int
<	O
i	int
;	O
k	int
++	O
,	O
t	double
++	O
)	O
*	O
t	double
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
(	O
i	int
=	O
newMaxy	int
-	O
accumSpans	pointer
->	O
finalMaxy	int
)	O
>	O
0	int
)	O
for	O
(	O
k	int
=	O
0	int
,	O
t	double
=	O
newSpans	pointer
+	O
newSize	int
-	O
i	int
;	O
k	int
<	O
i	int
;	O
k	int
++	O
,	O
t	double
++	O
)	O
*	O
t	double
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
accumSpans	pointer
->	O
finalSpans	pointer
=	O
newSpans	pointer
;	O
accumSpans	pointer
->	O
finalMaxy	int
=	O
newMaxy	int
;	O
accumSpans	pointer
->	O
finalMiny	int
=	O
newMiny	int
;	O
accumSpans	pointer
->	O
finalSize	int
=	O
newSize	int
;	O
}	O
return	O
&	O
(	O
(	O
accumSpans	pointer
->	O
finalSpans	pointer
)	O
[	O
(	O
y	double
)	O
-	O
(	O
accumSpans	pointer
->	O
finalMiny	int
)	O
]	O
)	O
;	O
}	O
static	O
struct	O
finalSpan	struct
*	O
realAllocSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
{	O
struct	O
finalSpanChunk	struct
*	O
newChunk	pointer
;	O
struct	O
finalSpan	struct
*	O
span	pointer
;	O
int	O
i	int
;	O
newChunk	pointer
=	O
(	O
struct	O
finalSpanChunk	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
struct	O
finalSpanChunk	struct
)	O
)	O
;	O
newChunk	pointer
->	O
next	pointer
=	O
accumSpans	pointer
->	O
chunks	pointer
;	O
accumSpans	pointer
->	O
chunks	pointer
=	O
newChunk	pointer
;	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
=	O
newChunk	pointer
->	O
data	pointer
+	O
1	int
;	O
span	pointer
=	O
newChunk	pointer
->	O
data	pointer
+	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
SPAN_CHUNK_SIZE	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
span	pointer
->	O
next	pointer
=	O
span	pointer
+	O
1	int
;	O
span	pointer
++	O
;	O
}	O
span	pointer
->	O
next	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
span	pointer
=	O
newChunk	pointer
->	O
data	pointer
;	O
span	pointer
->	O
next	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
return	O
span	pointer
;	O
}	O
static	O
void	O
fillSpans	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
{	O
struct	O
finalSpan	struct
*	O
span	pointer
;	O
struct	O
finalSpan	struct
*	O
*	O
f	pointer
;	O
int	O
spany	int
;	O
miPoint	struct
*	O
ppt	pointer
,	O
*	O
pptInit	pointer
;	O
unsigned	O
int	O
*	O
pwidth	pointer
,	O
*	O
pwidthInit	pointer
;	O
if	O
(	O
accumSpans	pointer
->	O
nspans	int
==	O
0	int
)	O
return	O
;	O
ppt	pointer
=	O
pptInit	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
accumSpans	pointer
->	O
nspans	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
pwidth	pointer
=	O
pwidthInit	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
accumSpans	pointer
->	O
nspans	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
spany	int
=	O
accumSpans	pointer
->	O
finalMiny	int
,	O
f	pointer
=	O
accumSpans	pointer
->	O
finalSpans	pointer
;	O
spany	int
<=	O
accumSpans	pointer
->	O
finalMaxy	int
;	O
spany	int
++	O
,	O
f	pointer
++	O
)	O
{	O
for	O
(	O
span	pointer
=	O
*	O
f	pointer
;	O
span	pointer
;	O
span	pointer
=	O
span	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
span	pointer
->	O
max	int
<=	O
span	pointer
->	O
min	int
)	O
continue	O
;	O
ppt	pointer
->	O
x	double
=	O
span	pointer
->	O
min	int
;	O
ppt	pointer
->	O
y	double
=	O
spany	int
;	O
++	O
ppt	pointer
;	O
*	O
pwidth	pointer
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
span	pointer
->	O
max	int
-	O
span	pointer
->	O
min	int
)	O
;	O
}	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
ppt	pointer
-	O
pptInit	pointer
,	O
pptInit	pointer
,	O
pwidthInit	pointer
)	O
disposeFinalSpans	function
(	O
accumSpans	pointer
)	O
;	O
accumSpans	pointer
->	O
finalMiny	int
=	O
0	int
;	O
accumSpans	pointer
->	O
finalMaxy	int
=	O
-	O
1	int
;	O
accumSpans	pointer
->	O
finalSize	int
=	O
0	int
;	O
accumSpans	pointer
->	O
nspans	int
=	O
0	int
;	O
}	O
static	O
void	O
disposeFinalSpans	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
)	O
{	O
struct	O
finalSpanChunk	struct
*	O
chunk	pointer
,	O
*	O
next	pointer
;	O
for	O
(	O
chunk	pointer
=	O
accumSpans	pointer
->	O
chunks	pointer
;	O
chunk	pointer
;	O
chunk	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
chunk	pointer
->	O
next	pointer
;	O
free	function
(	O
chunk	pointer
)	O
;	O
}	O
accumSpans	pointer
->	O
chunks	pointer
=	O
(	O
struct	O
finalSpanChunk	struct
*	O
)	O
NULL	O
;	O
accumSpans	pointer
->	O
freeFinalSpans	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
)	O
NULL	O
;	O
free	function
(	O
accumSpans	pointer
->	O
finalSpans	pointer
)	O
;	O
accumSpans	pointer
->	O
finalSpans	pointer
=	O
(	O
struct	O
finalSpan	struct
*	O
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
arcSpan	pointer
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
unsigned	O
int	O
mask	int
)	O
;	O
static	O
void	O
arcSpan0	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
unsigned	O
int	O
mask	int
)	O
;	O
static	O
void	O
tailSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
,	O
int	O
lw	int
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
unsigned	O
int	O
mask	int
)	O
;	O
static	O
void	O
arcSpan	pointer
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
unsigned	O
int	O
mask	int
)	O
{	O
int	O
linx	int
,	O
loutx	int
,	O
rinx	int
,	O
routx	int
;	O
double	O
x	double
,	O
altx	double
;	O
if	O
(	O
boundedLe	O
(	O
y	double
,	O
bounds	array
->	O
inneri	struct
)	O
)	O
{	O
linx	int
=	O
-	O
(	O
lx	int
+	O
lw	int
)	O
;	O
rinx	int
=	O
rx	double
;	O
}	O
else	O
{	O
x	double
=	O
hookX	function
(	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
,	O
def	pointer
,	O
bounds	array
,	O
acc	pointer
,	O
true	int
)	O
;	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
,	O
bounds	array
->	O
right	pointer
)	O
)	O
{	O
altx	double
=	O
intersectLine	O
(	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
,	O
acc	pointer
->	O
right	pointer
)	O
;	O
if	O
(	O
altx	double
<	O
x	double
)	O
x	double
=	O
altx	double
;	O
}	O
linx	int
=	O
-	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
-	O
x	double
)	O
;	O
rinx	int
=	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
x	double
)	O
;	O
}	O
if	O
(	O
boundedLe	O
(	O
y	double
,	O
bounds	array
->	O
outeri	struct
)	O
)	O
{	O
loutx	int
=	O
-	O
lx	int
;	O
routx	int
=	O
rx	double
+	O
rw	int
;	O
}	O
else	O
{	O
x	double
=	O
hookX	function
(	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
,	O
def	pointer
,	O
bounds	array
,	O
acc	pointer
,	O
false	int
)	O
;	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
,	O
bounds	array
->	O
left	pointer
)	O
)	O
{	O
altx	double
=	O
x	double
;	O
x	double
=	O
intersectLine	O
(	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
,	O
acc	pointer
->	O
left	pointer
)	O
;	O
if	O
(	O
x	double
<	O
altx	double
)	O
x	double
=	O
altx	double
;	O
}	O
loutx	int
=	O
-	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
-	O
x	double
)	O
;	O
routx	int
=	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
x	double
)	O
;	O
}	O
if	O
(	O
routx	int
>	O
rinx	int
)	O
{	O
if	O
(	O
mask	int
&	O
1	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgu	int
-	O
y	double
,	O
acc	pointer
->	O
xorg	int
+	O
rinx	int
,	O
acc	pointer
->	O
xorg	int
+	O
routx	int
)	O
;	O
if	O
(	O
mask	int
&	O
8	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgl	int
+	O
y	double
,	O
acc	pointer
->	O
xorg	int
+	O
rinx	int
,	O
acc	pointer
->	O
xorg	int
+	O
routx	int
)	O
;	O
}	O
if	O
(	O
loutx	int
>	O
linx	int
)	O
{	O
if	O
(	O
mask	int
&	O
2	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgu	int
-	O
y	double
,	O
acc	pointer
->	O
xorg	int
-	O
loutx	int
,	O
acc	pointer
->	O
xorg	int
-	O
linx	int
)	O
;	O
if	O
(	O
mask	int
&	O
4	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgl	int
+	O
y	double
,	O
acc	pointer
->	O
xorg	int
-	O
loutx	int
,	O
acc	pointer
->	O
xorg	int
-	O
linx	int
)	O
;	O
}	O
}	O
static	O
void	O
arcSpan0	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
lx	int
,	O
int	O
lw	int
,	O
int	O
rx	double
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
unsigned	O
int	O
mask	int
)	O
{	O
double	O
x	double
;	O
if	O
(	O
boundedLe	O
(	O
0	int
,	O
bounds	array
->	O
inneri	struct
)	O
&&	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
0	int
,	O
bounds	array
->	O
left	pointer
)	O
&&	O
acc	pointer
->	O
left	pointer
.	O
b	pointer
>	O
0	int
)	O
{	O
x	double
=	O
def	pointer
->	O
w	double
-	O
def	pointer
->	O
l	int
;	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
b	pointer
<	O
x	double
)	O
x	double
=	O
acc	pointer
->	O
left	pointer
.	O
b	pointer
;	O
lw	int
=	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
-	O
x	double
)	O
-	O
lx	int
;	O
rw	int
+=	O
rx	double
;	O
rx	double
=	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
x	double
)	O
;	O
rw	int
-=	O
rx	double
;	O
}	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
0	int
,	O
lx	int
,	O
lw	int
,	O
rx	double
,	O
rw	int
,	O
def	pointer
,	O
bounds	array
,	O
acc	pointer
,	O
mask	int
)	O
;	O
}	O
static	O
void	O
tailSpan	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
int	O
y	double
,	O
int	O
lw	int
,	O
int	O
rw	int
,	O
const	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
const	O
struct	O
arc_bound	struct
*	O
bounds	array
,	O
const	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
unsigned	O
int	O
mask	int
)	O
{	O
double	O
yy	int
,	O
xalt	double
,	O
x	double
,	O
lx	int
,	O
rx	double
;	O
int	O
n	array
;	O
if	O
(	O
boundedLe	O
(	O
y	double
,	O
bounds	array
->	O
outeri	struct
)	O
)	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
y	double
,	O
0	int
,	O
lw	int
,	O
-	O
rw	int
,	O
rw	int
,	O
def	pointer
,	O
bounds	array
,	O
acc	pointer
,	O
mask	int
)	O
;	O
else	O
if	O
(	O
def	pointer
->	O
w	double
!=	O
def	pointer
->	O
h	double
)	O
{	O
yy	int
=	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
;	O
x	double
=	O
tailX	function
(	O
yy	int
,	O
def	pointer
,	O
bounds	array
,	O
acc	pointer
)	O
;	O
if	O
(	O
yy	int
==	O
0.0	int
&&	O
x	double
==	O
-	O
rw	int
-	O
acc	pointer
->	O
fromIntX	double
)	O
return	O
;	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
yy	int
,	O
bounds	array
->	O
right	pointer
)	O
)	O
{	O
rx	double
=	O
x	double
;	O
lx	int
=	O
-	O
x	double
;	O
xalt	double
=	O
intersectLine	O
(	O
yy	int
,	O
acc	pointer
->	O
right	pointer
)	O
;	O
if	O
(	O
xalt	double
>=	O
-	O
rw	int
-	O
acc	pointer
->	O
fromIntX	double
&&	O
xalt	double
<=	O
rx	double
)	O
rx	double
=	O
xalt	double
;	O
n	array
=	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
lx	int
)	O
;	O
if	O
(	O
lw	int
>	O
n	array
)	O
{	O
if	O
(	O
mask	int
&	O
2	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgu	int
-	O
y	double
,	O
acc	pointer
->	O
xorg	int
+	O
n	array
,	O
acc	pointer
->	O
xorg	int
+	O
lw	int
)	O
;	O
if	O
(	O
mask	int
&	O
4	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgl	int
+	O
y	double
,	O
acc	pointer
->	O
xorg	int
+	O
n	array
,	O
acc	pointer
->	O
xorg	int
+	O
lw	int
)	O
;	O
}	O
n	array
=	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
rx	double
)	O
;	O
if	O
(	O
n	array
>	O
-	O
rw	int
)	O
{	O
if	O
(	O
mask	int
&	O
1	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgu	int
-	O
y	double
,	O
acc	pointer
->	O
xorg	int
-	O
rw	int
,	O
acc	pointer
->	O
xorg	int
+	O
n	array
)	O
;	O
if	O
(	O
mask	int
&	O
8	int
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgl	int
+	O
y	double
,	O
acc	pointer
->	O
xorg	int
-	O
rw	int
,	O
acc	pointer
->	O
xorg	int
+	O
n	array
)	O
;	O
}	O
}	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
y	double
,	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
-	O
x	double
)	O
,	O
0	int
,	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
x	double
)	O
,	O
0	int
,	O
def	pointer
,	O
bounds	array
,	O
acc	pointer
,	O
mask	int
)	O
;	O
}	O
}	O
static	O
void	O
drawQuadrant	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
unsigned	O
int	O
mask	int
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
,	O
miArcSpanData	struct
*	O
spdata	pointer
)	O
;	O
static	O
void	O
mirrorSppPoint	function
(	O
int	O
quadrant	int
,	O
SppPoint	struct
*	O
sppPoint	pointer
)	O
;	O
static	O
void	O
drawArc	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
const	O
miArc	struct
*	O
tarc	pointer
,	O
unsigned	O
int	O
l	int
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
struct	O
arc_def	struct
def	pointer
;	O
struct	O
accelerators	struct
acc	pointer
;	O
int	O
startq	int
,	O
endq	int
,	O
curq	int
;	O
int	O
rightq	int
,	O
leftq	int
=	O
0	int
,	O
righta	int
=	O
0	int
,	O
lefta	int
=	O
0	int
;	O
miArcFace	struct
*	O
passRight	pointer
,	O
*	O
passLeft	pointer
;	O
int	O
q0	int
=	O
0	int
,	O
q1	int
=	O
0	int
;	O
unsigned	O
int	O
mask	int
;	O
struct	O
band	struct
{	O
int	O
a0	int
,	O
a1	int
;	O
unsigned	O
int	O
mask	int
;	O
}	O
band	struct
[	O
5	int
]	O
,	O
sweep	array
[	O
20	int
]	O
;	O
int	O
bandno	int
,	O
sweepno	int
;	O
int	O
i	int
,	O
j	int
;	O
bool	enum
flipRight	enum
=	O
false	int
,	O
flipLeft	enum
=	O
false	int
;	O
bool	enum
copyEnd	enum
=	O
false	int
;	O
miArcSpanData	struct
*	O
spdata	pointer
;	O
bool	enum
mustFree	pointer
;	O
spdata	pointer
=	O
miComputeWideEllipse	function
(	O
l	int
,	O
tarc	pointer
,	O
&	O
mustFree	pointer
,	O
ellipseCache	pointer
)	O
;	O
if	O
(	O
!	O
spdata	pointer
)	O
return	O
;	O
if	O
(	O
a1	int
<	O
a0	int
)	O
a1	int
+=	O
360	int
*	O
64	int
;	O
startq	int
=	O
a0	int
/	O
(	O
90	int
*	O
64	int
)	O
;	O
if	O
(	O
a0	int
==	O
a1	int
)	O
endq	int
=	O
startq	int
;	O
else	O
endq	int
=	O
(	O
a1	int
-	O
1	int
)	O
/	O
(	O
90	int
*	O
64	int
)	O
;	O
bandno	int
=	O
0	int
;	O
curq	int
=	O
startq	int
;	O
rightq	int
=	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
curq	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
a0	int
>	O
90	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
a0	int
;	O
if	O
(	O
a1	int
<	O
360	int
*	O
64	int
)	O
q1	int
=	O
IMIN	O
(	O
a1	int
,	O
90	int
*	O
64	int
)	O
;	O
else	O
q1	int
=	O
90	int
*	O
64	int
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
a0	int
==	O
q0	int
&&	O
rightq	int
<	O
0	int
)	O
{	O
righta	int
=	O
q0	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
a1	int
==	O
q1	int
)	O
{	O
lefta	int
=	O
q1	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
a1	int
<	O
90	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
180	int
*	O
64	int
-	O
IMIN	O
(	O
a1	int
,	O
180	int
*	O
64	int
)	O
;	O
if	O
(	O
a0	int
>	O
180	int
*	O
64	int
)	O
q1	int
=	O
90	int
*	O
64	int
;	O
else	O
q1	int
=	O
180	int
*	O
64	int
-	O
IMAX	O
(	O
a0	int
,	O
90	int
*	O
64	int
)	O
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
180	int
*	O
64	int
-	O
a0	int
==	O
q1	int
)	O
{	O
righta	int
=	O
q1	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
180	int
*	O
64	int
-	O
a1	int
==	O
q0	int
)	O
{	O
lefta	int
=	O
q0	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
a0	int
>	O
270	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
IMAX	O
(	O
a0	int
,	O
180	int
*	O
64	int
)	O
-	O
180	int
*	O
64	int
;	O
if	O
(	O
a1	int
<	O
180	int
*	O
64	int
)	O
q1	int
=	O
90	int
*	O
64	int
;	O
else	O
q1	int
=	O
IMIN	O
(	O
a1	int
,	O
270	int
*	O
64	int
)	O
-	O
180	int
*	O
64	int
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
a0	int
-	O
180	int
*	O
64	int
==	O
q0	int
)	O
{	O
righta	int
=	O
q0	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
a1	int
-	O
180	int
*	O
64	int
==	O
q1	int
)	O
{	O
lefta	int
=	O
q1	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
a1	int
<	O
270	int
*	O
64	int
)	O
q0	int
=	O
0	int
;	O
else	O
q0	int
=	O
360	int
*	O
64	int
-	O
IMIN	O
(	O
a1	int
,	O
360	int
*	O
64	int
)	O
;	O
q1	int
=	O
360	int
*	O
64	int
-	O
IMAX	O
(	O
a0	int
,	O
270	int
*	O
64	int
)	O
;	O
if	O
(	O
curq	int
==	O
startq	int
&&	O
360	int
*	O
64	int
-	O
a0	int
==	O
q1	int
)	O
{	O
righta	int
=	O
q1	int
;	O
rightq	int
=	O
curq	int
;	O
}	O
if	O
(	O
curq	int
==	O
endq	int
&&	O
360	int
*	O
64	int
-	O
a1	int
==	O
q0	int
)	O
{	O
lefta	int
=	O
q0	int
;	O
leftq	int
=	O
curq	int
;	O
}	O
break	O
;	O
}	O
band	struct
[	O
bandno	int
]	O
.	O
a0	int
=	O
q0	int
;	O
band	struct
[	O
bandno	int
]	O
.	O
a1	int
=	O
q1	int
;	O
band	struct
[	O
bandno	int
]	O
.	O
mask	int
=	O
1	int
<<	O
curq	int
;	O
bandno	int
++	O
;	O
if	O
(	O
curq	int
==	O
endq	int
)	O
break	O
;	O
curq	int
++	O
;	O
if	O
(	O
curq	int
==	O
4	int
)	O
{	O
a0	int
=	O
0	int
;	O
a1	int
-=	O
360	int
*	O
64	int
;	O
curq	int
=	O
0	int
;	O
endq	int
-=	O
4	int
;	O
}	O
}	O
sweepno	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
q0	int
=	O
90	int
*	O
64	int
;	O
mask	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bandno	int
;	O
i	int
++	O
)	O
if	O
(	O
band	struct
[	O
i	int
]	O
.	O
a0	int
<=	O
q0	int
)	O
{	O
q0	int
=	O
band	struct
[	O
i	int
]	O
.	O
a0	int
;	O
q1	int
=	O
band	struct
[	O
i	int
]	O
.	O
a1	int
;	O
mask	int
=	O
band	struct
[	O
i	int
]	O
.	O
mask	int
;	O
}	O
if	O
(	O
mask	int
==	O
0	int
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bandno	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
(	O
mask	int
&	O
band	struct
[	O
i	int
]	O
.	O
mask	int
)	O
)	O
{	O
if	O
(	O
band	struct
[	O
i	int
]	O
.	O
a0	int
==	O
q0	int
)	O
{	O
if	O
(	O
band	struct
[	O
i	int
]	O
.	O
a1	int
<	O
q1	int
)	O
q1	int
=	O
band	struct
[	O
i	int
]	O
.	O
a1	int
;	O
mask	int
|=	O
band	struct
[	O
i	int
]	O
.	O
mask	int
;	O
}	O
else	O
if	O
(	O
band	struct
[	O
i	int
]	O
.	O
a0	int
<	O
q1	int
)	O
q1	int
=	O
band	struct
[	O
i	int
]	O
.	O
a0	int
;	O
}	O
sweep	array
[	O
sweepno	int
]	O
.	O
a0	int
=	O
q0	int
;	O
sweep	array
[	O
sweepno	int
]	O
.	O
a1	int
=	O
q1	int
;	O
sweep	array
[	O
sweepno	int
]	O
.	O
mask	int
=	O
mask	int
;	O
sweepno	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bandno	int
;	O
i	int
++	O
)	O
if	O
(	O
band	struct
[	O
i	int
]	O
.	O
a0	int
==	O
q0	int
)	O
{	O
band	struct
[	O
i	int
]	O
.	O
a0	int
=	O
q1	int
;	O
if	O
(	O
band	struct
[	O
i	int
]	O
.	O
a0	int
==	O
band	struct
[	O
i	int
]	O
.	O
a1	int
)	O
band	struct
[	O
i	int
]	O
.	O
a1	int
=	O
band	struct
[	O
i	int
]	O
.	O
a0	int
=	O
90	int
*	O
64	int
+	O
1	int
;	O
}	O
}	O
computeAcc	function
(	O
tarc	pointer
,	O
l	int
,	O
&	O
def	pointer
,	O
&	O
acc	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
sweepno	int
;	O
j	int
++	O
)	O
{	O
mask	int
=	O
sweep	array
[	O
j	int
]	O
.	O
mask	int
;	O
passRight	pointer
=	O
passLeft	pointer
=	O
(	O
miArcFace	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
rightq	int
)	O
)	O
{	O
if	O
(	O
sweep	array
[	O
j	int
]	O
.	O
a0	int
==	O
righta	int
)	O
passRight	pointer
=	O
right	pointer
;	O
else	O
if	O
(	O
sweep	array
[	O
j	int
]	O
.	O
a1	int
==	O
righta	int
)	O
{	O
passLeft	pointer
=	O
right	pointer
;	O
flipRight	enum
=	O
true	int
;	O
}	O
}	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
leftq	int
)	O
)	O
{	O
if	O
(	O
sweep	array
[	O
j	int
]	O
.	O
a1	int
==	O
lefta	int
)	O
{	O
if	O
(	O
passLeft	pointer
)	O
copyEnd	enum
=	O
true	int
;	O
passLeft	pointer
=	O
left	pointer
;	O
}	O
else	O
if	O
(	O
sweep	array
[	O
j	int
]	O
.	O
a0	int
==	O
lefta	int
)	O
{	O
if	O
(	O
passRight	pointer
)	O
copyEnd	enum
=	O
true	int
;	O
passRight	pointer
=	O
left	pointer
;	O
flipLeft	enum
=	O
true	int
;	O
}	O
}	O
drawQuadrant	function
(	O
accumSpans	pointer
,	O
&	O
def	pointer
,	O
&	O
acc	pointer
,	O
sweep	array
[	O
j	int
]	O
.	O
a0	int
,	O
sweep	array
[	O
j	int
]	O
.	O
a1	int
,	O
mask	int
,	O
passRight	pointer
,	O
passLeft	pointer
,	O
spdata	pointer
)	O
;	O
}	O
if	O
(	O
copyEnd	enum
)	O
*	O
right	pointer
=	O
*	O
left	pointer
;	O
if	O
(	O
right	pointer
)	O
{	O
mirrorSppPoint	function
(	O
rightq	int
,	O
&	O
right	pointer
->	O
clock	function
)	O
;	O
mirrorSppPoint	function
(	O
rightq	int
,	O
&	O
right	pointer
->	O
center	struct
)	O
;	O
mirrorSppPoint	function
(	O
rightq	int
,	O
&	O
right	pointer
->	O
counterClock	struct
)	O
;	O
if	O
(	O
flipRight	enum
)	O
{	O
SppPoint	struct
temp	pointer
;	O
temp	pointer
=	O
right	pointer
->	O
clock	function
;	O
right	pointer
->	O
clock	function
=	O
right	pointer
->	O
counterClock	struct
;	O
right	pointer
->	O
counterClock	struct
=	O
temp	pointer
;	O
}	O
}	O
if	O
(	O
left	pointer
)	O
{	O
mirrorSppPoint	function
(	O
leftq	int
,	O
&	O
left	pointer
->	O
counterClock	struct
)	O
;	O
mirrorSppPoint	function
(	O
leftq	int
,	O
&	O
left	pointer
->	O
center	struct
)	O
;	O
mirrorSppPoint	function
(	O
leftq	int
,	O
&	O
left	pointer
->	O
clock	function
)	O
;	O
if	O
(	O
flipLeft	enum
)	O
{	O
SppPoint	struct
temp	pointer
;	O
temp	pointer
=	O
left	pointer
->	O
clock	function
;	O
left	pointer
->	O
clock	function
=	O
left	pointer
->	O
counterClock	struct
;	O
left	pointer
->	O
counterClock	struct
=	O
temp	pointer
;	O
}	O
}	O
if	O
(	O
mustFree	pointer
)	O
{	O
free	function
(	O
spdata	pointer
->	O
spans	pointer
)	O
;	O
free	function
(	O
spdata	pointer
)	O
;	O
}	O
}	O
static	O
void	O
drawQuadrant	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
struct	O
arc_def	struct
*	O
def	pointer
,	O
struct	O
accelerators	struct
*	O
acc	pointer
,	O
int	O
a0	int
,	O
int	O
a1	int
,	O
unsigned	O
int	O
mask	int
,	O
miArcFace	struct
*	O
right	pointer
,	O
miArcFace	struct
*	O
left	pointer
,	O
miArcSpanData	struct
*	O
spdata	pointer
)	O
{	O
struct	O
arc_bound	struct
bound	struct
;	O
double	O
yy	int
,	O
x	double
,	O
xalt	double
;	O
int	O
y	double
,	O
miny	int
,	O
maxy	int
;	O
int	O
n	array
;	O
miArcSpan	struct
*	O
span	pointer
;	O
def	pointer
->	O
a0	int
=	O
(	O
(	O
double	O
)	O
a0	int
)	O
/	O
64.0	int
;	O
def	pointer
->	O
a1	int
=	O
(	O
(	O
double	O
)	O
a1	int
)	O
/	O
64.0	int
;	O
computeBound	function
(	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
right	pointer
,	O
left	pointer
)	O
;	O
yy	int
=	O
bound	struct
.	O
inner	struct
.	O
min	int
;	O
if	O
(	O
bound	struct
.	O
outer	struct
.	O
min	int
<	O
yy	int
)	O
yy	int
=	O
bound	struct
.	O
outer	struct
.	O
min	int
;	O
miny	int
=	O
ICEIL	O
(	O
yy	int
-	O
acc	pointer
->	O
fromIntY	double
)	O
;	O
yy	int
=	O
bound	struct
.	O
inner	struct
.	O
max	int
;	O
if	O
(	O
bound	struct
.	O
outer	struct
.	O
max	int
>	O
yy	int
)	O
yy	int
=	O
bound	struct
.	O
outer	struct
.	O
max	int
;	O
maxy	int
=	O
(	O
int	O
)	O
floor	function
(	O
yy	int
-	O
acc	pointer
->	O
fromIntY	double
)	O
;	O
y	double
=	O
spdata	pointer
->	O
k	int
;	O
span	pointer
=	O
spdata	pointer
->	O
spans	pointer
;	O
if	O
(	O
spdata	pointer
->	O
top	enum
)	O
{	O
if	O
(	O
a1	int
==	O
90	int
*	O
64	int
&&	O
(	O
mask	int
&	O
1	int
)	O
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
acc	pointer
->	O
yorgu	int
-	O
y	double
-	O
1	int
,	O
acc	pointer
->	O
xorg	int
,	O
acc	pointer
->	O
xorg	int
+	O
1	int
)	O
;	O
span	pointer
++	O
;	O
}	O
for	O
(	O
n	array
=	O
spdata	pointer
->	O
count1	int
;	O
--	O
n	array
>=	O
0	int
;	O
)	O
{	O
if	O
(	O
y	double
<	O
miny	int
)	O
return	O
;	O
if	O
(	O
y	double
<=	O
maxy	int
)	O
{	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
y	double
,	O
span	pointer
->	O
lx	int
,	O
-	O
span	pointer
->	O
lx	int
,	O
0	int
,	O
span	pointer
->	O
lx	int
+	O
span	pointer
->	O
lw	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
mask	int
)	O
;	O
if	O
(	O
span	pointer
->	O
rw	int
+	O
span	pointer
->	O
rx	double
)	O
tailSpan	function
(	O
accumSpans	pointer
,	O
y	double
,	O
-	O
span	pointer
->	O
rw	int
,	O
-	O
span	pointer
->	O
rx	double
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
mask	int
)	O
;	O
}	O
y	double
--	O
;	O
span	pointer
++	O
;	O
}	O
if	O
(	O
y	double
<	O
miny	int
)	O
return	O
;	O
if	O
(	O
spdata	pointer
->	O
hole	enum
)	O
{	O
if	O
(	O
y	double
<=	O
maxy	int
)	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
y	double
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
mask	int
&	O
0xc	int
)	O
;	O
}	O
for	O
(	O
n	array
=	O
spdata	pointer
->	O
count2	int
;	O
--	O
n	array
>=	O
0	int
;	O
)	O
{	O
if	O
(	O
y	double
<	O
miny	int
)	O
return	O
;	O
if	O
(	O
y	double
<=	O
maxy	int
)	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
y	double
,	O
span	pointer
->	O
lx	int
,	O
span	pointer
->	O
lw	int
,	O
span	pointer
->	O
rx	double
,	O
span	pointer
->	O
rw	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
mask	int
)	O
;	O
y	double
--	O
;	O
span	pointer
++	O
;	O
}	O
if	O
(	O
spdata	pointer
->	O
bot	enum
&&	O
miny	int
<=	O
y	double
&&	O
y	double
<=	O
maxy	int
)	O
{	O
unsigned	O
int	O
m	array
=	O
mask	int
;	O
if	O
(	O
y	double
==	O
miny	int
)	O
m	array
&=	O
0xc	int
;	O
if	O
(	O
span	pointer
->	O
rw	int
<=	O
0	int
)	O
{	O
arcSpan0	function
(	O
accumSpans	pointer
,	O
span	pointer
->	O
lx	int
,	O
-	O
span	pointer
->	O
lx	int
,	O
0	int
,	O
span	pointer
->	O
lx	int
+	O
span	pointer
->	O
lw	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
m	array
)	O
;	O
if	O
(	O
span	pointer
->	O
rw	int
+	O
span	pointer
->	O
rx	double
)	O
tailSpan	function
(	O
accumSpans	pointer
,	O
y	double
,	O
-	O
span	pointer
->	O
rw	int
,	O
-	O
span	pointer
->	O
rx	double
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
m	array
)	O
;	O
}	O
else	O
arcSpan0	function
(	O
accumSpans	pointer
,	O
span	pointer
->	O
lx	int
,	O
span	pointer
->	O
lw	int
,	O
span	pointer
->	O
rx	double
,	O
span	pointer
->	O
rw	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
m	array
)	O
;	O
y	double
--	O
;	O
}	O
while	O
(	O
y	double
>=	O
miny	int
)	O
{	O
yy	int
=	O
y	double
+	O
acc	pointer
->	O
fromIntY	double
;	O
if	O
(	O
def	pointer
->	O
w	double
==	O
def	pointer
->	O
h	double
)	O
{	O
xalt	double
=	O
def	pointer
->	O
w	double
-	O
def	pointer
->	O
l	int
;	O
x	double
=	O
-	O
sqrt	function
(	O
xalt	double
*	O
xalt	double
-	O
yy	int
*	O
yy	int
)	O
;	O
}	O
else	O
{	O
x	double
=	O
tailX	function
(	O
yy	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
)	O
;	O
if	O
(	O
acc	pointer
->	O
left	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
yy	int
,	O
bound	struct
.	O
left	pointer
)	O
)	O
{	O
xalt	double
=	O
intersectLine	O
(	O
yy	int
,	O
acc	pointer
->	O
left	pointer
)	O
;	O
if	O
(	O
xalt	double
<	O
x	double
)	O
x	double
=	O
xalt	double
;	O
}	O
if	O
(	O
acc	pointer
->	O
right	pointer
.	O
valid	enum
&&	O
boundedLe	O
(	O
yy	int
,	O
bound	struct
.	O
right	pointer
)	O
)	O
{	O
xalt	double
=	O
intersectLine	O
(	O
yy	int
,	O
acc	pointer
->	O
right	pointer
)	O
;	O
if	O
(	O
xalt	double
<	O
x	double
)	O
x	double
=	O
xalt	double
;	O
}	O
}	O
arcSpan	pointer
(	O
accumSpans	pointer
,	O
y	double
,	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
-	O
x	double
)	O
,	O
0	int
,	O
ICEIL	O
(	O
acc	pointer
->	O
fromIntX	double
+	O
x	double
)	O
,	O
0	int
,	O
def	pointer
,	O
&	O
bound	struct
,	O
acc	pointer
,	O
mask	int
)	O
;	O
y	double
--	O
;	O
}	O
}	O
static	O
void	O
mirrorSppPoint	function
(	O
int	O
quadrant	int
,	O
SppPoint	struct
*	O
sppPoint	pointer
)	O
{	O
switch	O
(	O
quadrant	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
1	int
:	O
sppPoint	pointer
->	O
x	double
=	O
-	O
sppPoint	pointer
->	O
x	double
;	O
break	O
;	O
case	O
2	int
:	O
sppPoint	pointer
->	O
x	double
=	O
-	O
sppPoint	pointer
->	O
x	double
;	O
sppPoint	pointer
->	O
y	double
=	O
-	O
sppPoint	pointer
->	O
y	double
;	O
break	O
;	O
case	O
3	int
:	O
sppPoint	pointer
->	O
y	double
=	O
-	O
sppPoint	pointer
->	O
y	double
;	O
break	O
;	O
}	O
sppPoint	pointer
->	O
y	double
=	O
-	O
sppPoint	pointer
->	O
y	double
;	O
}	O
static	O
void	O
drawZeroArc	function
(	O
miAccumSpans	struct
*	O
accumSpans	pointer
,	O
const	O
miArc	struct
*	O
tarc	pointer
,	O
unsigned	O
int	O
lw	int
,	O
miArcFace	struct
*	O
left	pointer
,	O
miArcFace	struct
*	O
right	pointer
)	O
{	O
double	O
x0	double
=	O
0.0	int
,	O
y0	function
=	O
0.0	int
,	O
x1	double
=	O
0.0	int
,	O
y1	function
=	O
0.0	int
;	O
double	O
w	double
,	O
h	double
,	O
x	double
,	O
y	double
;	O
double	O
xmax	double
,	O
ymax	double
,	O
xmin	double
,	O
ymin	double
;	O
int	O
a0	int
,	O
a1	int
;	O
double	O
a	double
,	O
startAngle	int
,	O
endAngle	int
;	O
double	O
l	int
,	O
lx	int
,	O
ly	double
;	O
l	int
=	O
0.5	int
*	O
lw	int
;	O
a0	int
=	O
tarc	pointer
->	O
angle1	int
;	O
a1	int
=	O
tarc	pointer
->	O
angle2	int
;	O
if	O
(	O
a1	int
>	O
FULLCIRCLE	O
)	O
a1	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
a1	int
<	O
-	O
FULLCIRCLE	O
)	O
a1	int
=	O
-	O
FULLCIRCLE	O
;	O
w	double
=	O
0.5	int
*	O
tarc	pointer
->	O
width	array
;	O
h	double
=	O
0.5	int
*	O
tarc	pointer
->	O
height	int
;	O
startAngle	int
=	O
-	O
(	O
(	O
double	O
)	O
a0	int
/	O
64.0	int
)	O
;	O
endAngle	int
=	O
-	O
(	O
(	O
double	O
)	O
(	O
a0	int
+	O
a1	int
)	O
/	O
64.0	int
)	O
;	O
xmax	double
=	O
-	O
w	double
;	O
xmin	double
=	O
w	double
;	O
ymax	double
=	O
-	O
h	double
;	O
ymin	double
=	O
h	double
;	O
a	double
=	O
startAngle	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
x	double
=	O
w	double
*	O
miDcos	function
(	O
a	double
)	O
;	O
y	double
=	O
h	double
*	O
miDsin	function
(	O
a	double
)	O
;	O
if	O
(	O
a	double
==	O
startAngle	int
)	O
{	O
x0	double
=	O
x	double
;	O
y0	function
=	O
y	double
;	O
}	O
if	O
(	O
a	double
==	O
endAngle	int
)	O
{	O
x1	double
=	O
x	double
;	O
y1	function
=	O
y	double
;	O
}	O
if	O
(	O
x	double
>	O
xmax	double
)	O
xmax	double
=	O
x	double
;	O
if	O
(	O
x	double
<	O
xmin	double
)	O
xmin	double
=	O
x	double
;	O
if	O
(	O
y	double
>	O
ymax	double
)	O
ymax	double
=	O
y	double
;	O
if	O
(	O
y	double
<	O
ymin	double
)	O
ymin	double
=	O
y	double
;	O
if	O
(	O
a	double
==	O
endAngle	int
)	O
break	O
;	O
if	O
(	O
a1	int
<	O
0	int
)	O
{	O
if	O
(	O
floor	function
(	O
a	double
/	O
90.0	int
)	O
==	O
floor	function
(	O
endAngle	int
/	O
90.0	int
)	O
)	O
a	double
=	O
endAngle	int
;	O
else	O
a	double
=	O
90	int
*	O
(	O
floor	function
(	O
a	double
/	O
90.0	int
)	O
+	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ceil	function
(	O
a	double
/	O
90.0	int
)	O
==	O
ceil	function
(	O
endAngle	int
/	O
90.0	int
)	O
)	O
a	double
=	O
endAngle	int
;	O
else	O
a	double
=	O
90	int
*	O
(	O
ceil	function
(	O
a	double
/	O
90.0	int
)	O
-	O
1	int
)	O
;	O
}	O
}	O
lx	int
=	O
ly	double
=	O
l	int
;	O
if	O
(	O
(	O
x1	double
-	O
x0	double
)	O
+	O
(	O
y1	function
-	O
y0	function
)	O
<	O
0	int
)	O
lx	int
=	O
ly	double
=	O
-	O
l	int
;	O
if	O
(	O
h	double
)	O
ly	double
=	O
0.0	int
;	O
else	O
lx	int
=	O
0.0	int
;	O
if	O
(	O
right	pointer
)	O
{	O
right	pointer
->	O
center	struct
.	O
x	double
=	O
x0	double
;	O
right	pointer
->	O
center	struct
.	O
y	double
=	O
y0	function
;	O
right	pointer
->	O
clock	function
.	O
x	double
=	O
x0	double
-	O
lx	int
;	O
right	pointer
->	O
clock	function
.	O
y	double
=	O
y0	function
-	O
ly	double
;	O
right	pointer
->	O
counterClock	struct
.	O
x	double
=	O
x0	double
+	O
lx	int
;	O
right	pointer
->	O
counterClock	struct
.	O
y	double
=	O
y0	function
+	O
ly	double
;	O
}	O
if	O
(	O
left	pointer
)	O
{	O
left	pointer
->	O
center	struct
.	O
x	double
=	O
x1	double
;	O
left	pointer
->	O
center	struct
.	O
y	double
=	O
y1	function
;	O
left	pointer
->	O
clock	function
.	O
x	double
=	O
x1	double
+	O
lx	int
;	O
left	pointer
->	O
clock	function
.	O
y	double
=	O
y1	function
+	O
ly	double
;	O
left	pointer
->	O
counterClock	struct
.	O
x	double
=	O
x1	double
-	O
lx	int
;	O
left	pointer
->	O
counterClock	struct
.	O
y	double
=	O
y1	function
-	O
ly	double
;	O
}	O
x0	double
=	O
xmin	double
;	O
x1	double
=	O
xmax	double
;	O
y0	function
=	O
ymin	double
;	O
y1	function
=	O
ymax	double
;	O
if	O
(	O
ymin	double
!=	O
y1	function
)	O
{	O
xmin	double
=	O
-	O
l	int
;	O
xmax	double
=	O
l	int
;	O
}	O
else	O
{	O
ymin	double
=	O
-	O
l	int
;	O
ymax	double
=	O
l	int
;	O
}	O
if	O
(	O
xmax	double
!=	O
xmin	double
&&	O
ymax	double
!=	O
ymin	double
)	O
{	O
int	O
minx	int
,	O
maxx	int
,	O
miny	int
,	O
maxy	int
;	O
int	O
xorg	int
,	O
yorg	int
,	O
width	array
,	O
height	int
;	O
minx	int
=	O
ICEIL	O
(	O
xmin	double
+	O
w	double
)	O
+	O
tarc	pointer
->	O
x	double
;	O
maxx	int
=	O
ICEIL	O
(	O
xmax	double
+	O
w	double
)	O
+	O
tarc	pointer
->	O
x	double
;	O
miny	int
=	O
ICEIL	O
(	O
ymin	double
+	O
h	double
)	O
+	O
tarc	pointer
->	O
y	double
;	O
maxy	int
=	O
ICEIL	O
(	O
ymax	double
+	O
h	double
)	O
+	O
tarc	pointer
->	O
y	double
;	O
xorg	int
=	O
minx	int
;	O
yorg	int
=	O
miny	int
;	O
width	array
=	O
maxx	int
-	O
minx	int
;	O
height	int
=	O
maxy	int
-	O
miny	int
;	O
while	O
(	O
height	int
--	O
)	O
newFinalSpan	function
(	O
accumSpans	pointer
,	O
yorg	int
,	O
xorg	int
,	O
xorg	int
+	O
width	array
)	O
;	O
}	O
}	O
