static	O
mp_limb_t	long
mul1	function
(	O
mp_limb_t	long
m	long
)	O
{	O
return	O
m	long
;	O
}	O
static	O
mp_limb_t	long
mul2	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m01	long
=	O
(	O
m	long
|	O
1	int
)	O
*	O
(	O
(	O
m	long
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
return	O
m01	long
;	O
}	O
static	O
mp_limb_t	long
mul3	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m01	long
=	O
(	O
m	long
+	O
0	int
)	O
*	O
(	O
m	long
+	O
1	int
)	O
>>	O
1	int
;	O
mp_limb_t	long
m2	long
=	O
(	O
m	long
+	O
2	int
)	O
;	O
return	O
m01	long
*	O
m2	long
;	O
}	O
static	O
mp_limb_t	long
mul4	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m01	long
=	O
(	O
m	long
+	O
0	int
)	O
*	O
(	O
m	long
+	O
1	int
)	O
>>	O
1	int
;	O
mp_limb_t	long
m23	long
=	O
(	O
m	long
+	O
2	int
)	O
*	O
(	O
m	long
+	O
3	int
)	O
>>	O
1	int
;	O
return	O
m01	long
*	O
m23	long
;	O
}	O
static	O
mp_limb_t	long
mul5	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m012	long
=	O
(	O
m	long
+	O
0	int
)	O
*	O
(	O
m	long
+	O
1	int
)	O
*	O
(	O
m	long
+	O
2	int
)	O
>>	O
1	int
;	O
mp_limb_t	long
m34	long
=	O
(	O
m	long
+	O
3	int
)	O
*	O
(	O
m	long
+	O
4	int
)	O
>>	O
1	int
;	O
return	O
m012	long
*	O
m34	long
;	O
}	O
static	O
mp_limb_t	long
mul6	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m01	long
=	O
(	O
m	long
+	O
0	int
)	O
*	O
(	O
m	long
+	O
1	int
)	O
;	O
mp_limb_t	long
m23	long
=	O
(	O
m	long
+	O
2	int
)	O
*	O
(	O
m	long
+	O
3	int
)	O
;	O
mp_limb_t	long
m45	long
=	O
(	O
m	long
+	O
4	int
)	O
*	O
(	O
m	long
+	O
5	int
)	O
>>	O
1	int
;	O
mp_limb_t	long
m0123	long
=	O
m01	long
*	O
m23	long
>>	O
3	int
;	O
return	O
m0123	long
*	O
m45	long
;	O
}	O
static	O
mp_limb_t	long
mul7	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m01	long
=	O
(	O
m	long
+	O
0	int
)	O
*	O
(	O
m	long
+	O
1	int
)	O
;	O
mp_limb_t	long
m23	long
=	O
(	O
m	long
+	O
2	int
)	O
*	O
(	O
m	long
+	O
3	int
)	O
;	O
mp_limb_t	long
m456	long
=	O
(	O
m	long
+	O
4	int
)	O
*	O
(	O
m	long
+	O
5	int
)	O
*	O
(	O
m	long
+	O
6	int
)	O
>>	O
1	int
;	O
mp_limb_t	long
m0123	long
=	O
m01	long
*	O
m23	long
>>	O
3	int
;	O
return	O
m0123	long
*	O
m456	long
;	O
}	O
static	O
mp_limb_t	long
mul8	function
(	O
mp_limb_t	long
m	long
)	O
{	O
mp_limb_t	long
m01	long
=	O
(	O
m	long
+	O
0	int
)	O
*	O
(	O
m	long
+	O
1	int
)	O
;	O
mp_limb_t	long
m23	long
=	O
(	O
m	long
+	O
2	int
)	O
*	O
(	O
m	long
+	O
3	int
)	O
;	O
mp_limb_t	long
m45	long
=	O
(	O
m	long
+	O
4	int
)	O
*	O
(	O
m	long
+	O
5	int
)	O
;	O
mp_limb_t	long
m67	long
=	O
(	O
m	long
+	O
6	int
)	O
*	O
(	O
m	long
+	O
7	int
)	O
;	O
mp_limb_t	long
m0123	long
=	O
m01	long
*	O
m23	long
>>	O
3	int
;	O
mp_limb_t	long
m4567	long
=	O
m45	long
*	O
m67	long
>>	O
3	int
;	O
return	O
m0123	long
*	O
m4567	long
;	O
}	O
typedef	O
mp_limb_t	long
(	O
*	O
mulfunc_t	pointer
)	O
(	O
mp_limb_t	long
)	O
;	O
static	O
const	O
mulfunc_t	pointer
mulfunc	array
[	O
]	O
=	O
{	O
mul1	function
,	O
mul2	function
,	O
mul3	function
,	O
mul4	function
,	O
mul5	function
,	O
mul6	function
,	O
mul7	function
,	O
mul8	function
}	O
;	O
static	O
const	O
unsigned	O
char	O
tcnttab	array
[	O
]	O
=	O
{	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
4	int
,	O
4	int
,	O
6	int
}	O
;	O
static	O
const	O
mp_limb_t	long
facinv	array
[	O
]	O
=	O
{	O
ONE_LIMB_ODD_FACTORIAL_INVERSES_TABLE	O
}	O
;	O
static	O
void	O
mpz_bdiv_bin_uiui	function
(	O
mpz_ptr	pointer
r	pointer
,	O
unsigned	O
long	O
int	O
n	long
,	O
unsigned	O
long	O
int	O
k	int
)	O
{	O
int	O
nmax	int
,	O
kmax	int
,	O
nmaxnow	int
,	O
numfac	int
;	O
mp_ptr	pointer
np	pointer
,	O
kp	pointer
;	O
mp_size_t	long
nn	long
,	O
kn	long
,	O
alloc	long
;	O
mp_limb_t	long
i	long
,	O
j	long
,	O
t	long
,	O
iii	long
,	O
jjj	long
,	O
cy	long
,	O
dinv	long
;	O
mp_bitcnt_t	long
i2cnt	long
,	O
j2cnt	long
;	O
int	O
cnt	int
;	O
mp_size_t	long
maxn	long
;	O
TMP_DECL	O
;	O
ASSERT	O
(	O
k	int
>	O
ODD_FACTORIAL_TABLE_LIMIT	O
)	O
;	O
TMP_MARK	O
;	O
maxn	long
=	O
1	int
+	O
n	long
/	O
GMP_NUMB_BITS	O
;	O
alloc	long
=	O
SOME_THRESHOLD	int
-	O
1	int
+	O
MAX	O
(	O
3	int
*	O
maxn	long
/	O
2	int
,	O
SOME_THRESHOLD	int
)	O
;	O
alloc	long
=	O
MIN	O
(	O
alloc	long
,	O
k	int
)	O
+	O
1	int
;	O
np	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
alloc	long
)	O
;	O
kp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
SOME_THRESHOLD	int
+	O
1	int
)	O
;	O
MAXFACS	O
(	O
nmax	int
,	O
n	long
)	O
;	O
ASSERT	O
(	O
nmax	int
<=	O
M	O
)	O
;	O
MAXFACS	O
(	O
kmax	int
,	O
k	int
)	O
;	O
ASSERT	O
(	O
kmax	int
<=	O
M	O
)	O
;	O
ASSERT	O
(	O
k	int
>=	O
M	O
)	O
;	O
i	long
=	O
n	long
-	O
k	int
+	O
1	int
;	O
np	pointer
[	O
0	int
]	O
=	O
1	int
;	O
nn	long
=	O
1	int
;	O
i2cnt	long
=	O
0	int
;	O
j2cnt	long
=	O
__gmp_fac2cnt_table	array
[	O
ODD_FACTORIAL_TABLE_LIMIT	O
/	O
2	int
-	O
1	int
]	O
;	O
numfac	int
=	O
1	int
;	O
j	long
=	O
ODD_FACTORIAL_TABLE_LIMIT	O
+	O
1	int
;	O
jjj	long
=	O
ODD_FACTORIAL_TABLE_MAX	O
;	O
ASSERT	O
(	O
__gmp_oddfac_table	array
[	O
ODD_FACTORIAL_TABLE_LIMIT	O
]	O
==	O
ODD_FACTORIAL_TABLE_MAX	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
kp	pointer
[	O
0	int
]	O
=	O
jjj	long
;	O
kn	long
=	O
1	int
;	O
t	long
=	O
k	int
-	O
j	long
+	O
1	int
;	O
kmax	int
=	O
MIN	O
(	O
kmax	int
,	O
t	long
)	O
;	O
while	O
(	O
kmax	int
!=	O
0	int
&&	O
kn	long
<	O
SOME_THRESHOLD	int
)	O
{	O
jjj	long
=	O
mulfunc	array
[	O
kmax	int
-	O
1	int
]	O
(	O
j	long
)	O
;	O
j	long
+=	O
kmax	int
;	O
count_trailing_zeros	O
(	O
cnt	int
,	O
jjj	long
)	O
;	O
jjj	long
>>=	O
cnt	int
;	O
j2cnt	long
+=	O
tcnttab	array
[	O
kmax	int
-	O
1	int
]	O
+	O
cnt	int
;	O
cy	long
=	O
mpn_mul_1	O
(	O
kp	pointer
,	O
kp	pointer
,	O
kn	long
,	O
jjj	long
)	O
;	O
kp	pointer
[	O
kn	long
]	O
=	O
cy	long
;	O
kn	long
+=	O
cy	long
!=	O
0	int
;	O
t	long
=	O
k	int
-	O
j	long
+	O
1	int
;	O
kmax	int
=	O
MIN	O
(	O
kmax	int
,	O
t	long
)	O
;	O
}	O
numfac	int
=	O
j	long
-	O
numfac	int
;	O
while	O
(	O
numfac	int
!=	O
0	int
)	O
{	O
nmaxnow	int
=	O
MIN	O
(	O
nmax	int
,	O
numfac	int
)	O
;	O
iii	long
=	O
mulfunc	array
[	O
nmaxnow	int
-	O
1	int
]	O
(	O
i	long
)	O
;	O
i	long
+=	O
nmaxnow	int
;	O
count_trailing_zeros	O
(	O
cnt	int
,	O
iii	long
)	O
;	O
iii	long
>>=	O
cnt	int
;	O
i2cnt	long
+=	O
tcnttab	array
[	O
nmaxnow	int
-	O
1	int
]	O
+	O
cnt	int
;	O
cy	long
=	O
mpn_mul_1	O
(	O
np	pointer
,	O
np	pointer
,	O
nn	long
,	O
iii	long
)	O
;	O
np	pointer
[	O
nn	long
]	O
=	O
cy	long
;	O
nn	long
+=	O
cy	long
!=	O
0	int
;	O
numfac	int
-=	O
nmaxnow	int
;	O
}	O
ASSERT	O
(	O
nn	long
<	O
alloc	long
)	O
;	O
binvert_limb	O
(	O
dinv	long
,	O
kp	pointer
[	O
0	int
]	O
)	O
;	O
nn	long
+=	O
(	O
np	pointer
[	O
nn	long
-	O
1	int
]	O
>=	O
kp	pointer
[	O
kn	long
-	O
1	int
]	O
)	O
;	O
nn	long
-=	O
kn	long
;	O
mpn_sbpi1_bdiv_q	O
(	O
np	pointer
,	O
np	pointer
,	O
nn	long
,	O
kp	pointer
,	O
MIN	O
(	O
kn	long
,	O
nn	long
)	O
,	O
-	O
dinv	long
)	O
;	O
if	O
(	O
kmax	int
==	O
0	int
)	O
break	O
;	O
numfac	int
=	O
j	long
;	O
jjj	long
=	O
mulfunc	array
[	O
kmax	int
-	O
1	int
]	O
(	O
j	long
)	O
;	O
j	long
+=	O
kmax	int
;	O
count_trailing_zeros	O
(	O
cnt	int
,	O
jjj	long
)	O
;	O
jjj	long
>>=	O
cnt	int
;	O
j2cnt	long
+=	O
tcnttab	array
[	O
kmax	int
-	O
1	int
]	O
+	O
cnt	int
;	O
}	O
cnt	int
=	O
i2cnt	long
-	O
j2cnt	long
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
ASSERT	O
(	O
cnt	int
<	O
GMP_NUMB_BITS	O
)	O
;	O
cy	long
=	O
mpn_lshift	O
(	O
np	pointer
,	O
np	pointer
,	O
nn	long
,	O
cnt	int
)	O
;	O
np	pointer
[	O
nn	long
]	O
=	O
cy	long
;	O
nn	long
+=	O
cy	long
!=	O
0	int
;	O
}	O
nn	long
-=	O
np	pointer
[	O
nn	long
-	O
1	int
]	O
==	O
0	int
;	O
kp	pointer
=	O
MPZ_NEWALLOC	O
(	O
r	pointer
,	O
nn	long
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
nn	long
;	O
MPN_COPY	O
(	O
kp	pointer
,	O
np	pointer
,	O
nn	long
)	O
;	O
TMP_FREE	O
;	O
}	O
static	O
void	O
mpz_smallk_bin_uiui	function
(	O
mpz_ptr	pointer
r	pointer
,	O
unsigned	O
long	O
int	O
n	long
,	O
unsigned	O
long	O
int	O
k	int
)	O
{	O
int	O
nmax	int
,	O
numfac	int
;	O
mp_ptr	pointer
rp	pointer
;	O
mp_size_t	long
rn	long
,	O
alloc	long
;	O
mp_limb_t	long
i	long
,	O
iii	long
,	O
cy	long
;	O
mp_bitcnt_t	long
i2cnt	long
,	O
cnt	int
;	O
count_leading_zeros	O
(	O
cnt	int
,	O
(	O
mp_limb_t	long
)	O
n	long
)	O
;	O
cnt	int
=	O
GMP_LIMB_BITS	int
-	O
cnt	int
;	O
alloc	long
=	O
cnt	int
*	O
k	int
/	O
GMP_NUMB_BITS	O
+	O
3	int
;	O
rp	pointer
=	O
MPZ_NEWALLOC	O
(	O
r	pointer
,	O
alloc	long
)	O
;	O
MAXFACS	O
(	O
nmax	int
,	O
n	long
)	O
;	O
nmax	int
=	O
MIN	O
(	O
nmax	int
,	O
M	O
)	O
;	O
i	long
=	O
n	long
-	O
k	int
+	O
1	int
;	O
nmax	int
=	O
MIN	O
(	O
nmax	int
,	O
k	int
)	O
;	O
rp	pointer
[	O
0	int
]	O
=	O
mulfunc	array
[	O
nmax	int
-	O
1	int
]	O
(	O
i	long
)	O
;	O
rn	long
=	O
1	int
;	O
i	long
+=	O
nmax	int
;	O
i2cnt	long
=	O
tcnttab	array
[	O
nmax	int
-	O
1	int
]	O
;	O
numfac	int
=	O
k	int
-	O
nmax	int
;	O
while	O
(	O
numfac	int
!=	O
0	int
)	O
{	O
nmax	int
=	O
MIN	O
(	O
nmax	int
,	O
numfac	int
)	O
;	O
iii	long
=	O
mulfunc	array
[	O
nmax	int
-	O
1	int
]	O
(	O
i	long
)	O
;	O
i	long
+=	O
nmax	int
;	O
i2cnt	long
+=	O
tcnttab	array
[	O
nmax	int
-	O
1	int
]	O
;	O
cy	long
=	O
mpn_mul_1	O
(	O
rp	pointer
,	O
rp	pointer
,	O
rn	long
,	O
iii	long
)	O
;	O
rp	pointer
[	O
rn	long
]	O
=	O
cy	long
;	O
rn	long
+=	O
cy	long
!=	O
0	int
;	O
numfac	int
-=	O
nmax	int
;	O
}	O
ASSERT	O
(	O
rn	long
<	O
alloc	long
)	O
;	O
mpn_pi1_bdiv_q_1	O
(	O
rp	pointer
,	O
rp	pointer
,	O
rn	long
,	O
__gmp_oddfac_table	array
[	O
k	int
]	O
,	O
facinv	array
[	O
k	int
-	O
2	int
]	O
,	O
__gmp_fac2cnt_table	array
[	O
k	int
/	O
2	int
-	O
1	int
]	O
-	O
i2cnt	long
)	O
;	O
MPN_NORMALIZE_NOT_ZERO	O
(	O
rp	pointer
,	O
rn	long
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
rn	long
;	O
}	O
static	O
mp_limb_t	long
bc_bin_uiui	function
(	O
unsigned	O
int	O
n	long
,	O
unsigned	O
int	O
k	int
)	O
{	O
return	O
(	O
(	O
__gmp_oddfac_table	array
[	O
n	long
]	O
*	O
facinv	array
[	O
k	int
-	O
2	int
]	O
*	O
facinv	array
[	O
n	long
-	O
k	int
-	O
2	int
]	O
)	O
<<	O
(	O
__gmp_fac2cnt_table	array
[	O
n	long
/	O
2	int
-	O
1	int
]	O
-	O
__gmp_fac2cnt_table	array
[	O
k	int
/	O
2	int
-	O
1	int
]	O
-	O
__gmp_fac2cnt_table	array
[	O
(	O
n	long
-	O
k	int
)	O
/	O
2	int
-	O
1	int
]	O
)	O
)	O
&	O
GMP_NUMB_MASK	O
;	O
}	O
static	O
const	O
mp_limb_t	long
bin2kk	array
[	O
]	O
=	O
{	O
ONE_LIMB_ODD_CENTRAL_BINOMIAL_TABLE	O
}	O
;	O
static	O
const	O
mp_limb_t	long
bin2kkinv	array
[	O
]	O
=	O
{	O
ONE_LIMB_ODD_CENTRAL_BINOMIAL_INVERSE_TABLE	O
}	O
;	O
static	O
const	O
unsigned	O
char	O
fac2bin	array
[	O
]	O
=	O
{	O
CENTRAL_BINOMIAL_2FAC_TABLE	O
}	O
;	O
static	O
void	O
mpz_smallkdc_bin_uiui	function
(	O
mpz_ptr	pointer
r	pointer
,	O
unsigned	O
long	O
int	O
n	long
,	O
unsigned	O
long	O
int	O
k	int
)	O
{	O
mp_ptr	pointer
rp	pointer
;	O
mp_size_t	long
rn	long
;	O
unsigned	O
long	O
int	O
hk	long
;	O
hk	long
=	O
k	int
>>	O
1	int
;	O
if	O
(	O
(	O
!	O
BIN_UIUI_RECURSIVE_SMALLDC	O
)	O
||	O
hk	long
<=	O
ODD_FACTORIAL_TABLE_LIMIT	O
)	O
mpz_smallk_bin_uiui	function
(	O
r	pointer
,	O
n	long
,	O
hk	long
)	O
;	O
else	O
mpz_smallkdc_bin_uiui	function
(	O
r	pointer
,	O
n	long
,	O
hk	long
)	O
;	O
k	int
-=	O
hk	long
;	O
n	long
-=	O
hk	long
;	O
if	O
(	O
n	long
<=	O
ODD_FACTORIAL_EXTTABLE_LIMIT	O
)	O
{	O
mp_limb_t	long
cy	long
;	O
rn	long
=	O
SIZ	O
(	O
r	pointer
)	O
;	O
rp	pointer
=	O
MPZ_REALLOC	O
(	O
r	pointer
,	O
rn	long
+	O
1	int
)	O
;	O
cy	long
=	O
mpn_mul_1	O
(	O
rp	pointer
,	O
rp	pointer
,	O
rn	long
,	O
bc_bin_uiui	function
(	O
n	long
,	O
k	int
)	O
)	O
;	O
rp	pointer
[	O
rn	long
]	O
=	O
cy	long
;	O
rn	long
+=	O
cy	long
!=	O
0	int
;	O
}	O
else	O
{	O
mp_limb_t	long
buffer	array
[	O
ODD_CENTRAL_BINOMIAL_TABLE_LIMIT	O
+	O
3	int
]	O
;	O
mpz_t	array
t	long
;	O
ALLOC	O
(	O
t	long
)	O
=	O
ODD_CENTRAL_BINOMIAL_TABLE_LIMIT	O
+	O
3	int
;	O
PTR	O
(	O
t	long
)	O
=	O
buffer	array
;	O
if	O
(	O
(	O
!	O
BIN_UIUI_RECURSIVE_SMALLDC	O
)	O
||	O
k	int
<=	O
ODD_FACTORIAL_TABLE_LIMIT	O
)	O
mpz_smallk_bin_uiui	function
(	O
t	long
,	O
n	long
,	O
k	int
)	O
;	O
else	O
mpz_smallkdc_bin_uiui	function
(	O
t	long
,	O
n	long
,	O
k	int
)	O
;	O
mpz_mul	O
(	O
r	pointer
,	O
r	pointer
,	O
t	long
)	O
;	O
rp	pointer
=	O
PTR	O
(	O
r	pointer
)	O
;	O
rn	long
=	O
SIZ	O
(	O
r	pointer
)	O
;	O
}	O
mpn_pi1_bdiv_q_1	O
(	O
rp	pointer
,	O
rp	pointer
,	O
rn	long
,	O
bin2kk	array
[	O
k	int
-	O
ODD_CENTRAL_BINOMIAL_OFFSET	O
]	O
,	O
bin2kkinv	array
[	O
k	int
-	O
ODD_CENTRAL_BINOMIAL_OFFSET	O
]	O
,	O
fac2bin	array
[	O
k	int
-	O
ODD_CENTRAL_BINOMIAL_OFFSET	O
]	O
-	O
(	O
k	int
!=	O
hk	long
)	O
)	O
;	O
MPN_NORMALIZE_NOT_ZERO	O
(	O
rp	pointer
,	O
rn	long
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
rn	long
;	O
}	O
static	O
mp_limb_t	long
id_to_n	function
(	O
mp_limb_t	long
id	long
)	O
{	O
return	O
id	long
*	O
3	int
+	O
1	int
+	O
(	O
id	long
&	O
1	int
)	O
;	O
}	O
static	O
mp_limb_t	long
n_to_bit	function
(	O
mp_limb_t	long
n	long
)	O
{	O
return	O
(	O
(	O
n	long
-	O
5	int
)	O
|	O
1	int
)	O
/	O
3U	int
;	O
}	O
static	O
mp_size_t	long
primesieve_size	function
(	O
mp_limb_t	long
n	long
)	O
{	O
return	O
n_to_bit	function
(	O
n	long
)	O
/	O
GMP_LIMB_BITS	int
+	O
1	int
;	O
}	O
static	O
mp_limb_t	long
limb_apprsqrt	function
(	O
mp_limb_t	long
x	long
)	O
{	O
int	O
s	array
;	O
ASSERT	O
(	O
x	long
>	O
2	int
)	O
;	O
count_leading_zeros	O
(	O
s	array
,	O
x	long
-	O
1	int
)	O
;	O
s	array
=	O
GMP_LIMB_BITS	int
-	O
1	int
-	O
s	array
;	O
return	O
(	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
s	array
>>	O
1	int
)	O
)	O
+	O
(	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
(	O
s	array
-	O
1	int
)	O
>>	O
1	int
)	O
)	O
;	O
}	O
static	O
void	O
mpz_goetgheluck_bin_uiui	function
(	O
mpz_ptr	pointer
r	pointer
,	O
unsigned	O
long	O
int	O
n	long
,	O
unsigned	O
long	O
int	O
k	int
)	O
{	O
mp_limb_t	long
*	O
sieve	pointer
,	O
*	O
factors	pointer
,	O
count	long
;	O
mp_limb_t	long
prod	long
,	O
max_prod	long
,	O
j	long
;	O
TMP_DECL	O
;	O
ASSERT	O
(	O
BIN_GOETGHELUCK_THRESHOLD	int
>=	O
13	int
)	O
;	O
ASSERT	O
(	O
n	long
>=	O
25	int
)	O
;	O
TMP_MARK	O
;	O
sieve	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
primesieve_size	function
(	O
n	long
)	O
)	O
;	O
count	long
=	O
gmp_primesieve	O
(	O
sieve	pointer
,	O
n	long
)	O
+	O
1	int
;	O
factors	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
count	long
/	O
log_n_max	function
(	O
n	long
)	O
+	O
1	int
)	O
;	O
max_prod	long
=	O
GMP_NUMB_MAX	O
/	O
n	long
;	O
popc_limb	O
(	O
count	long
,	O
n	long
-	O
k	int
)	O
;	O
popc_limb	O
(	O
j	long
,	O
k	int
)	O
;	O
count	long
+=	O
j	long
;	O
popc_limb	O
(	O
j	long
,	O
n	long
)	O
;	O
count	long
-=	O
j	long
;	O
prod	long
=	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
count	long
;	O
j	long
=	O
0	int
;	O
COUNT_A_PRIME	O
(	O
3	int
,	O
n	long
,	O
k	int
,	O
prod	long
,	O
max_prod	long
,	O
factors	pointer
,	O
j	long
)	O
;	O
{	O
mp_limb_t	long
s	array
;	O
{	O
mp_limb_t	long
prime	long
;	O
s	array
=	O
limb_apprsqrt	function
(	O
n	long
)	O
;	O
s	array
=	O
n_to_bit	function
(	O
s	array
)	O
;	O
LOOP_ON_SIEVE_BEGIN	O
(	O
prime	long
,	O
n_to_bit	function
(	O
5	int
)	O
,	O
s	array
,	O
0	int
,	O
sieve	pointer
)	O
;	O
COUNT_A_PRIME	O
(	O
prime	long
,	O
n	long
,	O
k	int
,	O
prod	long
,	O
max_prod	long
,	O
factors	pointer
,	O
j	long
)	O
;	O
LOOP_ON_SIEVE_END	O
;	O
s	array
++	O
;	O
}	O
ASSERT	O
(	O
max_prod	long
<=	O
GMP_NUMB_MAX	O
/	O
2	int
)	O
;	O
max_prod	long
<<=	O
1	int
;	O
ASSERT	O
(	O
bit_to_n	O
(	O
s	array
)	O
*	O
bit_to_n	O
(	O
s	array
)	O
>	O
n	long
)	O
;	O
ASSERT	O
(	O
s	array
<=	O
n_to_bit	function
(	O
n	long
>>	O
1	int
)	O
)	O
;	O
{	O
mp_limb_t	long
prime	long
;	O
LOOP_ON_SIEVE_BEGIN	O
(	O
prime	long
,	O
s	array
,	O
n_to_bit	function
(	O
n	long
>>	O
1	int
)	O
,	O
0	int
,	O
sieve	pointer
)	O
;	O
SH_COUNT_A_PRIME	O
(	O
prime	long
,	O
n	long
,	O
k	int
,	O
prod	long
,	O
max_prod	long
,	O
factors	pointer
,	O
j	long
)	O
;	O
LOOP_ON_SIEVE_END	O
;	O
}	O
max_prod	long
>>=	O
1	int
;	O
}	O
ASSERT	O
(	O
n_to_bit	function
(	O
n	long
-	O
k	int
)	O
<	O
n_to_bit	function
(	O
n	long
)	O
)	O
;	O
{	O
mp_limb_t	long
prime	long
;	O
LOOP_ON_SIEVE_BEGIN	O
(	O
prime	long
,	O
n_to_bit	function
(	O
n	long
-	O
k	int
)	O
+	O
1	int
,	O
n_to_bit	function
(	O
n	long
)	O
,	O
0	int
,	O
sieve	pointer
)	O
;	O
FACTOR_LIST_STORE	O
(	O
prime	long
,	O
prod	long
,	O
max_prod	long
,	O
factors	pointer
,	O
j	long
)	O
;	O
LOOP_ON_SIEVE_END	O
;	O
}	O
if	O
(	O
LIKELY	O
(	O
j	long
!=	O
0	int
)	O
)	O
{	O
factors	pointer
[	O
j	long
++	O
]	O
=	O
prod	long
;	O
mpz_prodlimbs	O
(	O
r	pointer
,	O
factors	pointer
,	O
j	long
)	O
;	O
}	O
else	O
{	O
PTR	O
(	O
r	pointer
)	O
[	O
0	int
]	O
=	O
prod	long
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
1	int
;	O
}	O
TMP_FREE	O
;	O
}	O
void	O
mpz_bin_uiui	O
(	O
mpz_ptr	pointer
r	pointer
,	O
unsigned	O
long	O
int	O
n	long
,	O
unsigned	O
long	O
int	O
k	int
)	O
{	O
if	O
(	O
UNLIKELY	O
(	O
n	long
<	O
k	int
)	O
)	O
{	O
SIZ	O
(	O
r	pointer
)	O
=	O
0	int
;	O
}	O
else	O
{	O
ASSERT	O
(	O
n	long
<=	O
GMP_NUMB_MAX	O
)	O
;	O
k	int
=	O
MIN	O
(	O
k	int
,	O
n	long
-	O
k	int
)	O
;	O
if	O
(	O
k	int
<	O
2	int
)	O
{	O
PTR	O
(	O
r	pointer
)	O
[	O
0	int
]	O
=	O
k	int
?	O
n	long
:	O
1	int
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
n	long
<=	O
ODD_FACTORIAL_EXTTABLE_LIMIT	O
)	O
{	O
PTR	O
(	O
r	pointer
)	O
[	O
0	int
]	O
=	O
bc_bin_uiui	function
(	O
n	long
,	O
k	int
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
k	int
<=	O
ODD_FACTORIAL_TABLE_LIMIT	O
)	O
mpz_smallk_bin_uiui	function
(	O
r	pointer
,	O
n	long
,	O
k	int
)	O
;	O
else	O
if	O
(	O
BIN_UIUI_ENABLE_SMALLDC	int
&&	O
k	int
<=	O
(	O
BIN_UIUI_RECURSIVE_SMALLDC	O
?	O
ODD_CENTRAL_BINOMIAL_TABLE_LIMIT	O
:	O
ODD_FACTORIAL_TABLE_LIMIT	O
)	O
*	O
2	int
)	O
mpz_smallkdc_bin_uiui	function
(	O
r	pointer
,	O
n	long
,	O
k	int
)	O
;	O
else	O
if	O
(	O
ABOVE_THRESHOLD	O
(	O
k	int
,	O
BIN_GOETGHELUCK_THRESHOLD	int
)	O
&&	O
k	int
>	O
(	O
n	long
>>	O
4	int
)	O
)	O
mpz_goetgheluck_bin_uiui	function
(	O
r	pointer
,	O
n	long
,	O
k	int
)	O
;	O
else	O
mpz_bdiv_bin_uiui	function
(	O
r	pointer
,	O
n	long
,	O
k	int
)	O
;	O
}	O
}	O
