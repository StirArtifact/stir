struct	O
cie_info	struct
{	O
unsigned	O
code_alignment	int
;	O
int	O
z_augmentation	int
;	O
}	O
;	O
static	O
int	O
get_cie_info	function
(	O
struct	O
cie_info	struct
*	O
)	O
;	O
static	O
int	O
get_cie_info	function
(	O
struct	O
cie_info	struct
*	O
info	pointer
)	O
{	O
fragS	struct
*	O
f	pointer
;	O
fixS	struct
*	O
fix	struct
;	O
unsigned	O
int	O
offset	long
;	O
char	O
CIE_id	char
;	O
char	O
augmentation	array
[	O
10	int
]	O
;	O
int	O
iaug	int
;	O
int	O
code_alignment	int
=	O
0	int
;	O
f	pointer
=	O
seg_info	O
(	O
now_seg	pointer
)	O
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
fix	struct
=	O
seg_info	O
(	O
now_seg	pointer
)	O
->	O
frchainP	pointer
->	O
fix_root	pointer
;	O
if	O
(	O
strncmp	function
(	O
segment_name	O
(	O
now_seg	pointer
)	O
,	O
".debug_frame"	pointer
,	O
12	int
)	O
==	O
0	int
)	O
CIE_id	char
=	O
(	O
char	O
)	O
0xff	int
;	O
else	O
CIE_id	char
=	O
0	int
;	O
offset	long
=	O
4	int
;	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
offset	long
>=	O
f	pointer
->	O
fr_fix	long
)	O
{	O
offset	long
-=	O
f	pointer
->	O
fr_fix	long
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
;	O
}	O
if	O
(	O
f	pointer
==	O
NULL	O
||	O
f	pointer
->	O
fr_fix	long
-	O
offset	long
<	O
4	int
||	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
]	O
!=	O
CIE_id	char
||	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
+	O
1	int
]	O
!=	O
CIE_id	char
||	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
+	O
2	int
]	O
!=	O
CIE_id	char
||	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
+	O
3	int
]	O
!=	O
CIE_id	char
)	O
return	O
0	int
;	O
offset	long
+=	O
4	int
;	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
offset	long
>=	O
f	pointer
->	O
fr_fix	long
)	O
{	O
offset	long
-=	O
f	pointer
->	O
fr_fix	long
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
;	O
}	O
if	O
(	O
f	pointer
==	O
NULL	O
||	O
f	pointer
->	O
fr_fix	long
-	O
offset	long
<	O
1	int
||	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
]	O
!=	O
1	int
)	O
return	O
0	int
;	O
iaug	int
=	O
0	int
;	O
++	O
offset	long
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
offset	long
>=	O
f	pointer
->	O
fr_fix	long
)	O
{	O
offset	long
-=	O
f	pointer
->	O
fr_fix	long
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
;	O
}	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
while	O
(	O
offset	long
<	O
f	pointer
->	O
fr_fix	long
&&	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
size_t	long
)	O
iaug	int
<	O
(	O
sizeof	O
augmentation	array
)	O
-	O
1	int
)	O
{	O
augmentation	array
[	O
iaug	int
]	O
=	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
]	O
;	O
++	O
iaug	int
;	O
}	O
++	O
offset	long
;	O
}	O
if	O
(	O
offset	long
<	O
f	pointer
->	O
fr_fix	long
)	O
break	O
;	O
}	O
++	O
offset	long
;	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
offset	long
>=	O
f	pointer
->	O
fr_fix	long
)	O
{	O
offset	long
-=	O
f	pointer
->	O
fr_fix	long
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
;	O
}	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
augmentation	array
[	O
iaug	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
augmentation	array
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
augmentation	array
,	O
"eh"	pointer
)	O
==	O
0	int
)	O
{	O
while	O
(	O
fix	struct
!=	O
NULL	O
&&	O
(	O
fix	struct
->	O
fx_frag	pointer
!=	O
f	pointer
||	O
fix	struct
->	O
fx_where	long
!=	O
offset	long
)	O
)	O
fix	struct
=	O
fix	struct
->	O
fx_next	pointer
;	O
if	O
(	O
fix	struct
==	O
NULL	O
)	O
offset	long
+=	O
4	int
;	O
else	O
offset	long
+=	O
fix	struct
->	O
fx_size	int
;	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
offset	long
>=	O
f	pointer
->	O
fr_fix	long
)	O
{	O
offset	long
-=	O
f	pointer
->	O
fr_fix	long
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
;	O
}	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
augmentation	array
[	O
0	int
]	O
!=	O
'z'	O
)	O
return	O
0	int
;	O
code_alignment	int
=	O
f	pointer
->	O
fr_literal	array
[	O
offset	long
]	O
&	O
0xff	int
;	O
if	O
(	O
(	O
code_alignment	int
&	O
0x80	int
)	O
!=	O
0	int
)	O
code_alignment	int
=	O
0	int
;	O
info	pointer
->	O
code_alignment	int
=	O
code_alignment	int
;	O
info	pointer
->	O
z_augmentation	int
=	O
(	O
augmentation	array
[	O
0	int
]	O
==	O
'z'	O
)	O
;	O
return	O
1	int
;	O
}	O
enum	O
frame_state	enum
{	O
state_idle	int
,	O
state_saw_size	int
,	O
state_saw_cie_offset	int
,	O
state_saw_pc_begin	int
,	O
state_seeing_aug_size	int
,	O
state_skipping_aug	int
,	O
state_wait_loc4	int
,	O
state_saw_loc4	int
,	O
state_error	int
,	O
}	O
;	O
int	O
check_eh_frame	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
unsigned	O
int	O
*	O
pnbytes	pointer
)	O
{	O
struct	O
frame_data	struct
{	O
enum	O
frame_state	enum
state	pointer
;	O
int	O
cie_info_ok	int
;	O
struct	O
cie_info	struct
cie_info	struct
;	O
symbolS	struct
*	O
size_end_sym	pointer
;	O
fragS	struct
*	O
loc4_frag	pointer
;	O
int	O
loc4_fix	int
;	O
int	O
aug_size	int
;	O
int	O
aug_shift	int
;	O
}	O
;	O
static	O
struct	O
frame_data	struct
eh_frame_data	struct
;	O
static	O
struct	O
frame_data	struct
debug_frame_data	struct
;	O
struct	O
frame_data	struct
*	O
d	int
;	O
if	O
(	O
flag_traditional_format	int
)	O
return	O
0	int
;	O
if	O
(	O
strncmp	function
(	O
segment_name	O
(	O
now_seg	pointer
)	O
,	O
".eh_frame"	pointer
,	O
9	int
)	O
==	O
0	int
&&	O
segment_name	O
(	O
now_seg	pointer
)	O
[	O
9	int
]	O
!=	O
'_'	O
)	O
d	int
=	O
&	O
eh_frame_data	struct
;	O
else	O
if	O
(	O
strncmp	function
(	O
segment_name	O
(	O
now_seg	pointer
)	O
,	O
".debug_frame"	pointer
,	O
12	int
)	O
==	O
0	int
)	O
d	int
=	O
&	O
debug_frame_data	struct
;	O
else	O
return	O
0	int
;	O
if	O
(	O
d	int
->	O
state	pointer
>=	O
state_saw_size	int
&&	O
S_IS_DEFINED	function
(	O
d	int
->	O
size_end_sym	pointer
)	O
)	O
{	O
d	int
->	O
state	pointer
=	O
state_idle	int
;	O
}	O
switch	O
(	O
d	int
->	O
state	pointer
)	O
{	O
case	O
state_idle	int
:	O
if	O
(	O
*	O
pnbytes	pointer
==	O
4	int
)	O
{	O
if	O
(	O
(	O
exp	pointer
->	O
X_op	enum
==	O
O_symbol	int
||	O
exp	pointer
->	O
X_op	enum
==	O
O_subtract	int
)	O
&&	O
!	O
S_IS_DEFINED	function
(	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
)	O
{	O
d	int
->	O
state	pointer
=	O
state_saw_size	int
;	O
d	int
->	O
size_end_sym	pointer
=	O
exp	pointer
->	O
X_add_symbol	pointer
;	O
}	O
}	O
break	O
;	O
case	O
state_saw_size	int
:	O
case	O
state_saw_cie_offset	int
:	O
d	int
->	O
state	pointer
=	O
(	O
enum	O
frame_state	enum
)	O
(	O
d	int
->	O
state	pointer
+	O
1	int
)	O
;	O
break	O
;	O
case	O
state_saw_pc_begin	int
:	O
if	O
(	O
!	O
d	int
->	O
cie_info_ok	int
&&	O
!	O
(	O
d	int
->	O
cie_info_ok	int
=	O
get_cie_info	function
(	O
&	O
d	int
->	O
cie_info	struct
)	O
)	O
)	O
d	int
->	O
state	pointer
=	O
state_error	int
;	O
else	O
if	O
(	O
d	int
->	O
cie_info	struct
.	O
z_augmentation	int
)	O
{	O
d	int
->	O
state	pointer
=	O
state_seeing_aug_size	int
;	O
d	int
->	O
aug_size	int
=	O
0	int
;	O
d	int
->	O
aug_shift	int
=	O
0	int
;	O
}	O
else	O
d	int
->	O
state	pointer
=	O
state_wait_loc4	int
;	O
break	O
;	O
case	O
state_seeing_aug_size	int
:	O
if	O
(	O
(	O
int	O
)	O
*	O
pnbytes	pointer
==	O
-	O
1	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
{	O
d	int
->	O
aug_size	int
=	O
exp	pointer
->	O
X_add_number	long
;	O
d	int
->	O
state	pointer
=	O
state_skipping_aug	int
;	O
}	O
else	O
if	O
(	O
*	O
pnbytes	pointer
==	O
1	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
{	O
unsigned	O
char	O
byte	int
=	O
exp	pointer
->	O
X_add_number	long
;	O
d	int
->	O
aug_size	int
|=	O
(	O
byte	int
&	O
0x7f	int
)	O
<<	O
d	int
->	O
aug_shift	int
;	O
d	int
->	O
aug_shift	int
+=	O
7	int
;	O
if	O
(	O
(	O
byte	int
&	O
0x80	int
)	O
==	O
0	int
)	O
d	int
->	O
state	pointer
=	O
state_skipping_aug	int
;	O
}	O
else	O
d	int
->	O
state	pointer
=	O
state_error	int
;	O
if	O
(	O
d	int
->	O
state	pointer
==	O
state_skipping_aug	int
&&	O
d	int
->	O
aug_size	int
==	O
0	int
)	O
d	int
->	O
state	pointer
=	O
state_wait_loc4	int
;	O
break	O
;	O
case	O
state_skipping_aug	int
:	O
if	O
(	O
(	O
int	O
)	O
*	O
pnbytes	pointer
<	O
0	int
)	O
d	int
->	O
state	pointer
=	O
state_error	int
;	O
else	O
{	O
int	O
left	int
=	O
(	O
d	int
->	O
aug_size	int
-=	O
*	O
pnbytes	pointer
)	O
;	O
if	O
(	O
left	int
==	O
0	int
)	O
d	int
->	O
state	pointer
=	O
state_wait_loc4	int
;	O
else	O
if	O
(	O
left	int
<	O
0	int
)	O
d	int
->	O
state	pointer
=	O
state_error	int
;	O
}	O
break	O
;	O
case	O
state_wait_loc4	int
:	O
if	O
(	O
*	O
pnbytes	pointer
==	O
1	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
exp	pointer
->	O
X_add_number	long
==	O
DW_CFA_advance_loc4	int
)	O
{	O
frag_grow	function
(	O
1	int
)	O
;	O
d	int
->	O
state	pointer
=	O
state_saw_loc4	int
;	O
d	int
->	O
loc4_frag	pointer
=	O
frag_now	pointer
;	O
d	int
->	O
loc4_fix	int
=	O
frag_now_fix	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
state_saw_loc4	int
:	O
d	int
->	O
state	pointer
=	O
state_wait_loc4	int
;	O
if	O
(	O
*	O
pnbytes	pointer
!=	O
4	int
)	O
break	O
;	O
if	O
(	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
{	O
if	O
(	O
exp	pointer
->	O
X_add_number	long
<	O
0x40	int
)	O
{	O
d	int
->	O
loc4_frag	pointer
->	O
fr_literal	array
[	O
d	int
->	O
loc4_fix	int
]	O
=	O
DW_CFA_advance_loc	int
|	O
exp	pointer
->	O
X_add_number	long
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
exp	pointer
->	O
X_add_number	long
<	O
0x100	int
)	O
{	O
d	int
->	O
loc4_frag	pointer
->	O
fr_literal	array
[	O
d	int
->	O
loc4_fix	int
]	O
=	O
DW_CFA_advance_loc1	int
;	O
*	O
pnbytes	pointer
=	O
1	int
;	O
}	O
else	O
if	O
(	O
exp	pointer
->	O
X_add_number	long
<	O
0x10000	int
)	O
{	O
d	int
->	O
loc4_frag	pointer
->	O
fr_literal	array
[	O
d	int
->	O
loc4_fix	int
]	O
=	O
DW_CFA_advance_loc2	int
;	O
*	O
pnbytes	pointer
=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
exp	pointer
->	O
X_op	enum
==	O
O_subtract	int
&&	O
d	int
->	O
cie_info	struct
.	O
code_alignment	int
==	O
1	int
)	O
{	O
frag_var	function
(	O
rs_cfa	int
,	O
4	int
,	O
0	int
,	O
1	int
<<	O
3	int
,	O
make_expr_symbol	function
(	O
exp	pointer
)	O
,	O
d	int
->	O
loc4_fix	int
,	O
(	O
char	O
*	O
)	O
d	int
->	O
loc4_frag	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
exp	pointer
->	O
X_op	enum
==	O
O_divide	int
||	O
exp	pointer
->	O
X_op	enum
==	O
O_right_shift	int
)	O
&&	O
d	int
->	O
cie_info	struct
.	O
code_alignment	int
>	O
1	int
)	O
{	O
if	O
(	O
symbol_symbolS	function
(	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
&&	O
symbol_constant_p	function
(	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
&&	O
S_GET_SEGMENT	function
(	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
==	O
absolute_section	O
&&	O
(	O
(	O
exp	pointer
->	O
X_op	enum
==	O
O_divide	int
?	O
*	O
symbol_X_add_number	function
(	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
:	O
(	O
offsetT	long
)	O
1	int
<<	O
*	O
symbol_X_add_number	function
(	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
)	O
==	O
(	O
offsetT	long
)	O
d	int
->	O
cie_info	struct
.	O
code_alignment	int
)	O
)	O
{	O
expressionS	struct
*	O
symval	pointer
;	O
symval	pointer
=	O
symbol_get_value_expression	function
(	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
if	O
(	O
symval	pointer
->	O
X_op	enum
==	O
O_subtract	int
)	O
{	O
frag_var	function
(	O
rs_cfa	int
,	O
4	int
,	O
0	int
,	O
d	int
->	O
cie_info	struct
.	O
code_alignment	int
<<	O
3	int
,	O
make_expr_symbol	function
(	O
symval	pointer
)	O
,	O
d	int
->	O
loc4_fix	int
,	O
(	O
char	O
*	O
)	O
d	int
->	O
loc4_frag	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
break	O
;	O
case	O
state_error	int
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
eh_frame_estimate_size_before_relax	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
offsetT	long
diff	long
;	O
int	O
ca	int
=	O
frag	struct
->	O
fr_subtype	int
>>	O
3	int
;	O
int	O
ret	pointer
;	O
diff	long
=	O
resolve_symbol_value	function
(	O
frag	struct
->	O
fr_symbol	pointer
)	O
;	O
gas_assert	O
(	O
ca	int
>	O
0	int
)	O
;	O
diff	long
/=	O
ca	int
;	O
if	O
(	O
diff	long
==	O
0	int
)	O
ret	pointer
=	O
-	O
1	int
;	O
else	O
if	O
(	O
diff	long
<	O
0x40	int
)	O
ret	pointer
=	O
0	int
;	O
else	O
if	O
(	O
diff	long
<	O
0x100	int
)	O
ret	pointer
=	O
1	int
;	O
else	O
if	O
(	O
diff	long
<	O
0x10000	int
)	O
ret	pointer
=	O
2	int
;	O
else	O
ret	pointer
=	O
4	int
;	O
frag	struct
->	O
fr_subtype	int
=	O
(	O
frag	struct
->	O
fr_subtype	int
&	O
~	O
7	int
)	O
|	O
(	O
ret	pointer
&	O
7	int
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
eh_frame_relax_frag	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
int	O
oldsize	int
,	O
newsize	int
;	O
oldsize	int
=	O
frag	struct
->	O
fr_subtype	int
&	O
7	int
;	O
if	O
(	O
oldsize	int
==	O
7	int
)	O
oldsize	int
=	O
-	O
1	int
;	O
newsize	int
=	O
eh_frame_estimate_size_before_relax	function
(	O
frag	struct
)	O
;	O
return	O
newsize	int
-	O
oldsize	int
;	O
}	O
void	O
eh_frame_convert_frag	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
offsetT	long
diff	long
;	O
fragS	struct
*	O
loc4_frag	pointer
;	O
int	O
loc4_fix	int
,	O
ca	int
;	O
loc4_frag	pointer
=	O
(	O
fragS	struct
*	O
)	O
frag	struct
->	O
fr_opcode	pointer
;	O
loc4_fix	int
=	O
(	O
int	O
)	O
frag	struct
->	O
fr_offset	long
;	O
diff	long
=	O
resolve_symbol_value	function
(	O
frag	struct
->	O
fr_symbol	pointer
)	O
;	O
ca	int
=	O
frag	struct
->	O
fr_subtype	int
>>	O
3	int
;	O
gas_assert	O
(	O
ca	int
>	O
0	int
)	O
;	O
diff	long
/=	O
ca	int
;	O
switch	O
(	O
frag	struct
->	O
fr_subtype	int
&	O
7	int
)	O
{	O
case	O
0	int
:	O
gas_assert	O
(	O
diff	long
<	O
0x40	int
)	O
;	O
loc4_frag	pointer
->	O
fr_literal	array
[	O
loc4_fix	int
]	O
=	O
DW_CFA_advance_loc	int
|	O
diff	long
;	O
break	O
;	O
case	O
1	int
:	O
gas_assert	O
(	O
diff	long
<	O
0x100	int
)	O
;	O
loc4_frag	pointer
->	O
fr_literal	array
[	O
loc4_fix	int
]	O
=	O
DW_CFA_advance_loc1	int
;	O
frag	struct
->	O
fr_literal	array
[	O
frag	struct
->	O
fr_fix	long
]	O
=	O
diff	long
;	O
break	O
;	O
case	O
2	int
:	O
gas_assert	O
(	O
diff	long
<	O
0x10000	int
)	O
;	O
loc4_frag	pointer
->	O
fr_literal	array
[	O
loc4_fix	int
]	O
=	O
DW_CFA_advance_loc2	int
;	O
md_number_to_chars	O
(	O
frag	struct
->	O
fr_literal	array
+	O
frag	struct
->	O
fr_fix	long
,	O
diff	long
,	O
2	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
md_number_to_chars	O
(	O
frag	struct
->	O
fr_literal	array
+	O
frag	struct
->	O
fr_fix	long
,	O
diff	long
,	O
4	int
)	O
;	O
break	O
;	O
case	O
7	int
:	O
gas_assert	O
(	O
diff	long
==	O
0	int
)	O
;	O
frag	struct
->	O
fr_fix	long
-=	O
8	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
frag	struct
->	O
fr_fix	long
+=	O
frag	struct
->	O
fr_subtype	int
&	O
7	int
;	O
frag	struct
->	O
fr_type	enum
=	O
rs_fill	int
;	O
frag	struct
->	O
fr_subtype	int
=	O
0	int
;	O
frag	struct
->	O
fr_offset	long
=	O
0	int
;	O
}	O
