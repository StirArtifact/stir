static	O
char	O
*	O
determine_control_directory	function
(	O
SWHEADER	struct
*	O
swheader	pointer
)	O
{	O
char	O
*	O
value	long
;	O
value	long
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_control_directory	pointer
)	O
;	O
if	O
(	O
!	O
value	long
)	O
value	long
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_tag	pointer
)	O
;	O
return	O
value	long
;	O
}	O
static	O
char	O
*	O
search_object_for_directory	function
(	O
char	O
*	O
i_next_line	pointer
,	O
SWHEADER	struct
*	O
swheader	pointer
,	O
char	O
*	O
key_dir	pointer
,	O
char	O
*	O
object_name	pointer
,	O
int	O
level	int
)	O
{	O
char	O
*	O
control_directory	pointer
;	O
char	O
*	O
next_line	pointer
=	O
i_next_line	pointer
;	O
char	O
*	O
keyword	pointer
;	O
while	O
(	O
next_line	pointer
)	O
{	O
keyword	pointer
=	O
swheaderline_get_keyword	function
(	O
next_line	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
keyword	pointer
,	O
object_name	pointer
)	O
==	O
0	int
)	O
{	O
control_directory	pointer
=	O
determine_control_directory	function
(	O
swheader	pointer
)	O
;	O
if	O
(	O
control_directory	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
key_dir	pointer
,	O
control_directory	pointer
)	O
==	O
0	int
)	O
{	O
return	O
next_line	pointer
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
swheader	pointer
,	O
level	int
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
search_for_fileset	function
(	O
char	O
*	O
i_next_line	pointer
,	O
SWHEADER	struct
*	O
swheader	pointer
,	O
char	O
*	O
key_dir	pointer
)	O
{	O
char	O
*	O
ret	pointer
;	O
int	O
level	int
;	O
int	O
type	enum
;	O
level	int
=	O
swheaderline_get_level	function
(	O
i_next_line	pointer
)	O
;	O
type	enum
=	O
swheaderline_get_type	function
(	O
i_next_line	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
SWPARSE_MD_TYPE_OBJ	char
)	O
{	O
level	int
++	O
;	O
}	O
ret	pointer
=	O
search_object_for_directory	function
(	O
i_next_line	pointer
,	O
swheader	pointer
,	O
key_dir	pointer
,	O
SW_A_fileset	pointer
,	O
level	int
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
char	O
*	O
search_for_product	function
(	O
char	O
*	O
i_next_line	pointer
,	O
SWHEADER	struct
*	O
swheader	pointer
,	O
char	O
*	O
key_dir	pointer
)	O
{	O
char	O
*	O
ret	pointer
;	O
int	O
level	int
;	O
level	int
=	O
swheaderline_get_level	function
(	O
i_next_line	pointer
)	O
;	O
ret	pointer
=	O
search_object_for_directory	function
(	O
i_next_line	pointer
,	O
swheader	pointer
,	O
key_dir	pointer
,	O
SW_A_product	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
determine_object	function
(	O
STROB	struct
*	O
object_keyword	pointer
,	O
STRAR	struct
*	O
control_dir_list	pointer
,	O
SWPATH_EX	struct
*	O
swpath_ex	pointer
)	O
{	O
if	O
(	O
(	O
swpath_ex	pointer
->	O
is_minimal_layoutM	int
==	O
0	int
&&	O
strlen	function
(	O
swpath_ex	pointer
->	O
product_control_dir	pointer
)	O
&&	O
!	O
strlen	function
(	O
swpath_ex	pointer
->	O
fileset_control_dir	pointer
)	O
&&	O
1	int
)	O
||	O
(	O
swpath_ex	pointer
->	O
is_minimal_layoutM	int
==	O
1	int
&&	O
strlen	function
(	O
swpath_ex	pointer
->	O
pfiles	pointer
)	O
&&	O
(	O
!	O
strlen	function
(	O
swpath_ex	pointer
->	O
fileset_control_dir	pointer
)	O
)	O
&&	O
1	int
)	O
)	O
{	O
strar_add	function
(	O
control_dir_list	pointer
,	O
SW_A_product	pointer
)	O
;	O
strar_add	function
(	O
control_dir_list	pointer
,	O
swpath_ex	pointer
->	O
product_control_dir	pointer
)	O
;	O
strob_strcpy	function
(	O
object_keyword	pointer
,	O
SW_A_product	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
swpath_ex	pointer
->	O
is_minimal_layoutM	int
==	O
0	int
&&	O
strlen	function
(	O
swpath_ex	pointer
->	O
product_control_dir	pointer
)	O
&&	O
strlen	function
(	O
swpath_ex	pointer
->	O
fileset_control_dir	pointer
)	O
&&	O
1	int
)	O
||	O
(	O
swpath_ex	pointer
->	O
is_minimal_layoutM	int
==	O
1	int
&&	O
!	O
strlen	function
(	O
swpath_ex	pointer
->	O
product_control_dir	pointer
)	O
&&	O
!	O
strlen	function
(	O
swpath_ex	pointer
->	O
fileset_control_dir	pointer
)	O
&&	O
strcmp	function
(	O
swpath_ex	pointer
->	O
basename	function
,	O
SW_A_INFO	pointer
)	O
==	O
0	int
&&	O
1	int
)	O
)	O
{	O
strar_add	function
(	O
control_dir_list	pointer
,	O
SW_A_product	pointer
)	O
;	O
strar_add	function
(	O
control_dir_list	pointer
,	O
swpath_ex	pointer
->	O
product_control_dir	pointer
)	O
;	O
strar_add	function
(	O
control_dir_list	pointer
,	O
SW_A_fileset	pointer
)	O
;	O
strar_add	function
(	O
control_dir_list	pointer
,	O
swpath_ex	pointer
->	O
fileset_control_dir	pointer
)	O
;	O
strob_strcpy	function
(	O
object_keyword	pointer
,	O
SW_A_fileset	pointer
)	O
;	O
}	O
else	O
{	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swinstall: Uh-Oh WARNING IN "	pointer
__FILE__	O
" %d\n"	pointer
,	O
__LINE__	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
swpath_ex_print	function
(	O
swpath_ex	pointer
,	O
tmp	pointer
,	O
"glbindex.c "	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
strob_strcpy	function
(	O
object_keyword	pointer
,	O
SW_A_distribution	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
glbindex_find_by_swpath_ex	function
(	O
SWHEADER	struct
*	O
global_index	pointer
,	O
SWPATH_EX	struct
*	O
swpath_ex	pointer
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
char	O
*	O
next_line	pointer
;	O
SWHEADER	struct
*	O
swheader	pointer
;	O
STRAR	struct
*	O
control_dir_list	pointer
;	O
STROB	struct
*	O
object_keyword	pointer
;	O
swheader	pointer
=	O
global_index	pointer
;	O
swheader_store_state	function
(	O
swheader	pointer
,	O
NULL	O
)	O
;	O
swheader_set_current_offset	function
(	O
swheader	pointer
,	O
0	int
)	O
;	O
control_dir_list	pointer
=	O
strar_open	function
(	O
)	O
;	O
object_keyword	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
determine_object	function
(	O
object_keyword	pointer
,	O
control_dir_list	pointer
,	O
swpath_ex	pointer
)	O
;	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
swheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
strar_num_elements	function
(	O
control_dir_list	pointer
)	O
>	O
3	int
)	O
{	O
next_line	pointer
=	O
search_for_product	function
(	O
next_line	pointer
,	O
swheader	pointer
,	O
strar_get	function
(	O
control_dir_list	pointer
,	O
1	int
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	pointer
!=	O
NULL	O
)	O
;	O
next_line	pointer
=	O
search_for_fileset	function
(	O
next_line	pointer
,	O
swheader	pointer
,	O
strar_get	function
(	O
control_dir_list	pointer
,	O
3	int
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	pointer
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
next_line	pointer
=	O
search_for_product	function
(	O
next_line	pointer
,	O
swheader	pointer
,	O
strar_get	function
(	O
control_dir_list	pointer
,	O
1	int
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
next_line	pointer
!=	O
NULL	O
)	O
;	O
}	O
ret	pointer
=	O
swheader_get_current_offset	function
(	O
swheader	pointer
)	O
;	O
strar_close	function
(	O
control_dir_list	pointer
)	O
;	O
strob_close	function
(	O
object_keyword	pointer
)	O
;	O
swheader_restore_state	function
(	O
swheader	pointer
,	O
NULL	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
