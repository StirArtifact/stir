error_t	int
netfs_attempt_readlink	function
(	O
struct	O
iouser	O
*	O
user	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
assert	function
(	O
node	pointer
->	O
nn	pointer
->	O
name	pointer
)	O
;	O
memcpy	function
(	O
buf	pointer
,	O
node	pointer
->	O
nn	pointer
->	O
trans	pointer
,	O
node	pointer
->	O
nn	pointer
->	O
trans_len	long
)	O
;	O
fshelp_touch	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
,	O
usermux_maptime	pointer
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_get_translator	function
(	O
struct	O
node	pointer
*	O
node	pointer
,	O
char	O
*	O
*	O
trans	pointer
,	O
size_t	long
*	O
trans_len	long
)	O
{	O
if	O
(	O
!	O
node	pointer
->	O
nn	pointer
->	O
name	pointer
)	O
return	O
EINVAL	int
;	O
else	O
{	O
fshelp_touch	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
,	O
usermux_maptime	pointer
)	O
;	O
*	O
trans	pointer
=	O
0	int
;	O
*	O
trans_len	long
=	O
0	int
;	O
if	O
(	O
S_ISLNK	function
(	O
node	pointer
->	O
nn_stat	O
.	O
st_mode	O
)	O
)	O
argz_add	function
(	O
trans	pointer
,	O
trans_len	long
,	O
_HURD_SYMLINK	O
)	O
;	O
return	O
argz_append	function
(	O
trans	pointer
,	O
trans_len	long
,	O
node	pointer
->	O
nn	pointer
->	O
trans	pointer
,	O
node	pointer
->	O
nn	pointer
->	O
trans_len	long
)	O
;	O
}	O
}	O
error_t	int
create_user_node	function
(	O
struct	O
usermux	struct
*	O
mux	pointer
,	O
struct	O
usermux_name	struct
*	O
name	pointer
,	O
struct	O
passwd	struct
*	O
pw	pointer
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
{	O
error_t	int
err	int
;	O
struct	O
node	pointer
*	O
new	pointer
;	O
struct	O
netnode	struct
*	O
nn	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
netnode	struct
)	O
)	O
;	O
if	O
(	O
!	O
nn	pointer
)	O
return	O
ENOMEM	int
;	O
nn	pointer
->	O
mux	pointer
=	O
mux	pointer
;	O
nn	pointer
->	O
name	pointer
=	O
name	pointer
;	O
new	pointer
=	O
netfs_make_node	function
(	O
nn	pointer
)	O
;	O
if	O
(	O
!	O
new	pointer
)	O
{	O
free	function
(	O
nn	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
new	pointer
->	O
nn_stat	O
=	O
mux	pointer
->	O
stat_template	struct
;	O
new	pointer
->	O
nn_stat	O
.	O
st_ino	O
=	O
pw	pointer
->	O
pw_uid	int
+	O
USERMUX_FILENO_UID_OFFSET	int
;	O
if	O
(	O
strcmp	function
(	O
mux	pointer
->	O
trans_template	pointer
,	O
_HURD_SYMLINK	O
)	O
==	O
0	int
&&	O
mux	pointer
->	O
trans_template_len	long
==	O
sizeof	O
_HURD_SYMLINK	O
)	O
{	O
err	int
=	O
argz_create_sep	function
(	O
pw	pointer
->	O
pw_dir	pointer
,	O
0	int
,	O
&	O
nn	pointer
->	O
trans	pointer
,	O
&	O
nn	pointer
->	O
trans_len	long
)	O
;	O
new	pointer
->	O
nn_stat	O
.	O
st_mode	O
=	O
(	O
S_IFLNK	O
|	O
0666	int
)	O
;	O
new	pointer
->	O
nn_stat	O
.	O
st_size	O
=	O
nn	pointer
->	O
trans_len	long
;	O
}	O
else	O
{	O
unsigned	O
replace_count	int
=	O
0	int
;	O
nn	pointer
->	O
trans	pointer
=	O
0	int
;	O
nn	pointer
->	O
trans_len	long
=	O
0	int
;	O
err	int
=	O
argz_append	function
(	O
&	O
nn	pointer
->	O
trans	pointer
,	O
&	O
nn	pointer
->	O
trans_len	long
,	O
mux	pointer
->	O
trans_template	pointer
,	O
mux	pointer
->	O
trans_template_len	long
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
mux	pointer
->	O
user_pat	pointer
&&	O
*	O
mux	pointer
->	O
user_pat	pointer
)	O
err	int
=	O
argz_replace	function
(	O
&	O
nn	pointer
->	O
trans	pointer
,	O
&	O
nn	pointer
->	O
trans_len	long
,	O
mux	pointer
->	O
user_pat	pointer
,	O
pw	pointer
->	O
pw_name	pointer
,	O
&	O
replace_count	int
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
mux	pointer
->	O
home_pat	pointer
&&	O
*	O
mux	pointer
->	O
home_pat	pointer
)	O
err	int
=	O
argz_replace	function
(	O
&	O
nn	pointer
->	O
trans	pointer
,	O
&	O
nn	pointer
->	O
trans_len	long
,	O
mux	pointer
->	O
home_pat	pointer
,	O
pw	pointer
->	O
pw_dir	pointer
,	O
&	O
replace_count	int
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
mux	pointer
->	O
uid_pat	pointer
&&	O
*	O
mux	pointer
->	O
uid_pat	pointer
)	O
{	O
char	O
uid_buf	array
[	O
10	int
]	O
;	O
snprintf	function
(	O
uid_buf	array
,	O
sizeof	O
uid_buf	array
,	O
"%d"	pointer
,	O
pw	pointer
->	O
pw_uid	int
)	O
;	O
err	int
=	O
argz_replace	function
(	O
&	O
nn	pointer
->	O
trans	pointer
,	O
&	O
nn	pointer
->	O
trans_len	long
,	O
mux	pointer
->	O
uid_pat	pointer
,	O
uid_buf	array
,	O
&	O
replace_count	int
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
replace_count	int
==	O
0	int
)	O
err	int
=	O
argz_add	function
(	O
&	O
nn	pointer
->	O
trans	pointer
,	O
&	O
nn	pointer
->	O
trans_len	long
,	O
pw	pointer
->	O
pw_dir	pointer
)	O
;	O
if	O
(	O
err	int
&&	O
nn	pointer
->	O
trans_len	long
>	O
0	int
)	O
free	function
(	O
nn	pointer
->	O
trans	pointer
)	O
;	O
new	pointer
->	O
nn_stat	O
.	O
st_mode	O
=	O
(	O
S_IFREG	O
|	O
S_IPTRANS	O
|	O
0666	int
)	O
;	O
new	pointer
->	O
nn_stat	O
.	O
st_size	O
=	O
0	int
;	O
}	O
new	pointer
->	O
nn_translated	O
=	O
new	pointer
->	O
nn_stat	O
.	O
st_mode	O
;	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
nn	pointer
)	O
;	O
free	function
(	O
new	pointer
)	O
;	O
return	O
err	int
;	O
}	O
fshelp_touch	function
(	O
&	O
new	pointer
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
|	O
TOUCH_MTIME	O
|	O
TOUCH_CTIME	O
,	O
usermux_maptime	pointer
)	O
;	O
name	pointer
->	O
node	pointer
=	O
new	pointer
;	O
*	O
node	pointer
=	O
new	pointer
;	O
return	O
0	int
;	O
}	O
