int	O
number_compare	function
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
int	O
i	int
;	O
double	O
dx	double
,	O
dy	double
=	O
0.0	int
;	O
vs_mark	O
;	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
switch	O
(	O
type_of	function
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
fix	function
(	O
x	int
)	O
<	O
fix	function
(	O
y	int
)	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
fix	function
(	O
x	int
)	O
==	O
fix	function
(	O
y	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
case	O
t_bignum	O
:	O
i	int
=	O
big_sign	function
(	O
y	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
case	O
t_ratio	O
:	O
x	int
=	O
number_times	function
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
y	int
=	O
y	int
->	O
rat	O
.	O
rat_num	O
;	O
vs_push	function
(	O
x	int
)	O
;	O
i	int
=	O
number_compare	function
(	O
x	int
,	O
y	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
i	int
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	function
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	function
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
fix	function
(	O
x	int
)	O
)	O
;	O
dy	double
=	O
lf	function
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
Y_COMPLEX	O
;	O
default	O
:	O
wrong_type_argument	function
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_bignum	O
:	O
switch	O
(	O
type_of	function
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
i	int
=	O
big_sign	function
(	O
x	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
case	O
t_bignum	O
:	O
return	O
cmpii	function
(	O
MP	function
(	O
x	int
)	O
,	O
MP	function
(	O
y	int
)	O
)	O
;	O
case	O
t_ratio	O
:	O
x	int
=	O
number_times	function
(	O
x	int
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
y	int
=	O
y	int
->	O
rat	O
.	O
rat_num	O
;	O
vs_push	function
(	O
x	int
)	O
;	O
i	int
=	O
number_compare	function
(	O
x	int
,	O
y	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
i	int
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	function
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	function
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	function
(	O
x	int
)	O
;	O
dy	double
=	O
lf	function
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
Y_COMPLEX	O
;	O
default	O
:	O
wrong_type_argument	function
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_ratio	O
:	O
switch	O
(	O
type_of	function
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
y	int
=	O
number_times	function
(	O
y	int
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
;	O
x	int
=	O
x	int
->	O
rat	O
.	O
rat_num	O
;	O
vs_push	function
(	O
y	int
)	O
;	O
i	int
=	O
number_compare	function
(	O
x	int
,	O
y	int
)	O
;	O
vs_reset	O
;	O
return	O
(	O
i	int
)	O
;	O
case	O
t_ratio	O
:	O
vs_push	function
(	O
number_times	function
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
)	O
;	O
vs_push	function
(	O
number_times	function
(	O
y	int
->	O
rat	O
.	O
rat_num	O
,	O
x	int
->	O
rat	O
.	O
rat_den	O
)	O
)	O
;	O
i	int
=	O
number_compare	function
(	O
vs_top	O
[	O
-	O
2	int
]	O
,	O
vs_top	O
[	O
-	O
1	int
]	O
)	O
;	O
vs_reset	O
;	O
return	O
(	O
i	int
)	O
;	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
number_to_double	function
(	O
x	int
)	O
;	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	function
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
number_to_double	function
(	O
x	int
)	O
;	O
dy	double
=	O
lf	function
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
Y_COMPLEX	O
;	O
default	O
:	O
wrong_type_argument	function
(	O
sLnumber	O
,	O
y	int
)	O
;	O
}	O
case	O
t_shortfloat	O
:	O
dx	double
=	O
(	O
double	O
)	O
(	O
sf	function
(	O
x	int
)	O
)	O
;	O
goto	O
LONGFLOAT0	O
;	O
case	O
t_longfloat	O
:	O
dx	double
=	O
lf	function
(	O
x	int
)	O
;	O
LONGFLOAT0	O
:	O
switch	O
(	O
type_of	function
(	O
y	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
fix	function
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
dy	double
=	O
number_to_double	function
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_shortfloat	O
:	O
dy	double
=	O
(	O
double	O
)	O
(	O
sf	function
(	O
y	int
)	O
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_longfloat	O
:	O
dy	double
=	O
lf	function
(	O
y	int
)	O
;	O
goto	O
LONGFLOAT	O
;	O
case	O
t_complex	O
:	O
goto	O
Y_COMPLEX	O
;	O
default	O
:	O
break	O
;	O
}	O
LONGFLOAT	O
:	O
if	O
(	O
dx	double
==	O
dy	double
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
dx	double
<	O
dy	double
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
Y_COMPLEX	O
:	O
if	O
(	O
number_zerop	function
(	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
if	O
(	O
number_compare	function
(	O
x	int
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
case	O
t_complex	O
:	O
if	O
(	O
type_of	function
(	O
y	int
)	O
!=	O
t_complex	O
)	O
{	O
if	O
(	O
number_zerop	function
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
if	O
(	O
number_compare	function
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
)	O
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
number_compare	function
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
,	O
y	int
->	O
cmp	O
.	O
cmp_real	O
)	O
==	O
0	int
&&	O
number_compare	function
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
,	O
y	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
default	O
:	O
FEwrong_type_argument	function
(	O
sLnumber	O
,	O
x	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
LFD	function
(	O
Lall_the_same	int
)	O
(	O
void	O
)	O
{	O
int	O
narg	int
,	O
i	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
==	O
0	int
)	O
too_few_arguments	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
check_type_number	function
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
if	O
(	O
number_compare	function
(	O
vs_base	O
[	O
i	int
-	O
1	int
]	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
{	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
return	O
;	O
}	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
}	O
LFD	function
(	O
Lall_different	int
)	O
(	O
void	O
)	O
{	O
int	O
narg	int
,	O
i	int
,	O
j	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
==	O
0	int
)	O
too_few_arguments	function
(	O
)	O
;	O
else	O
if	O
(	O
narg	int
==	O
1	int
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
check_type_number	function
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
if	O
(	O
number_compare	function
(	O
vs_base	O
[	O
j	int
]	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
==	O
0	int
)	O
{	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
return	O
;	O
}	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
}	O
static	O
void	O
Lnumber_compare	function
(	O
int	O
s	int
,	O
int	O
t	int
)	O
{	O
int	O
narg	int
,	O
i	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
==	O
0	int
)	O
too_few_arguments	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
check_type_or_rational_float	function
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
if	O
(	O
s	int
*	O
number_compare	function
(	O
vs_base	O
[	O
i	int
]	O
,	O
vs_base	O
[	O
i	int
-	O
1	int
]	O
)	O
<	O
t	int
)	O
{	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
return	O
;	O
}	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Ct	O
;	O
}	O
LFD	function
(	O
Lmonotonically_increasing	int
)	O
(	O
void	O
)	O
{	O
Lnumber_compare	function
(	O
1	int
,	O
1	int
)	O
;	O
}	O
LFD	function
(	O
Lmonotonically_decreasing	int
)	O
(	O
void	O
)	O
{	O
Lnumber_compare	function
(	O
-	O
1	int
,	O
1	int
)	O
;	O
}	O
LFD	function
(	O
Lmonotonically_nondecreasing	int
)	O
(	O
void	O
)	O
{	O
Lnumber_compare	function
(	O
1	int
,	O
0	int
)	O
;	O
}	O
LFD	function
(	O
Lmonotonically_nonincreasing	int
)	O
(	O
void	O
)	O
{	O
Lnumber_compare	function
(	O
-	O
1	int
,	O
0	int
)	O
;	O
}	O
LFD	function
(	O
Lmax	int
)	O
(	O
void	O
)	O
{	O
object	O
max	O
;	O
int	O
narg	int
,	O
i	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
==	O
0	int
)	O
too_few_arguments	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
check_type_or_rational_float	function
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
,	O
max	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
if	O
(	O
number_compare	function
(	O
max	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
<	O
0	int
)	O
max	O
=	O
vs_base	O
[	O
i	int
]	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
max	O
;	O
}	O
LFD	function
(	O
Lmin	int
)	O
(	O
void	O
)	O
{	O
object	O
min	O
;	O
int	O
narg	int
,	O
i	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
==	O
0	int
)	O
too_few_arguments	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
check_type_or_rational_float	function
(	O
&	O
vs_base	O
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
,	O
min	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
i	int
<	O
narg	int
;	O
i	int
++	O
)	O
if	O
(	O
number_compare	function
(	O
min	O
,	O
vs_base	O
[	O
i	int
]	O
)	O
>	O
0	int
)	O
min	O
=	O
vs_base	O
[	O
i	int
]	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
min	O
;	O
}	O
void	O
gcl_init_num_comp	function
(	O
void	O
)	O
{	O
make_function	function
(	O
"="	pointer
,	O
Lall_the_same	int
)	O
;	O
make_function	function
(	O
"/="	pointer
,	O
Lall_different	int
)	O
;	O
make_function	function
(	O
"<"	pointer
,	O
Lmonotonically_increasing	int
)	O
;	O
make_function	function
(	O
">"	pointer
,	O
Lmonotonically_decreasing	int
)	O
;	O
make_function	function
(	O
"<="	pointer
,	O
Lmonotonically_nondecreasing	int
)	O
;	O
make_function	function
(	O
">="	pointer
,	O
Lmonotonically_nonincreasing	int
)	O
;	O
make_function	function
(	O
"MAX"	pointer
,	O
Lmax	int
)	O
;	O
make_function	function
(	O
"MIN"	pointer
,	O
Lmin	int
)	O
;	O
}	O
