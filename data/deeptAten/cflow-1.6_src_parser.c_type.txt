typedef	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
int	O
type_end	int
;	O
int	O
parmcnt	int
;	O
int	O
line	int
;	O
enum	O
storage	enum
storage	enum
;	O
}	O
Ident	struct
;	O
void	O
parse_declaration	function
(	O
Ident	struct
*	O
,	O
int	O
)	O
;	O
void	O
parse_variable_declaration	function
(	O
Ident	struct
*	O
,	O
int	O
)	O
;	O
void	O
parse_function_declaration	function
(	O
Ident	struct
*	O
,	O
int	O
)	O
;	O
void	O
parse_dcl	function
(	O
Ident	struct
*	O
,	O
int	O
maybe_knr	int
)	O
;	O
void	O
parse_knr_dcl	function
(	O
Ident	struct
*	O
)	O
;	O
void	O
parse_typedef	function
(	O
)	O
;	O
void	O
expression	function
(	O
)	O
;	O
void	O
initializer_list	function
(	O
)	O
;	O
void	O
func_body	function
(	O
)	O
;	O
void	O
declare	function
(	O
Ident	struct
*	O
,	O
int	O
maybe_knr	int
)	O
;	O
void	O
declare_type	function
(	O
Ident	struct
*	O
)	O
;	O
int	O
dcl	function
(	O
Ident	struct
*	O
)	O
;	O
int	O
parmdcl	function
(	O
Ident	struct
*	O
)	O
;	O
int	O
dirdcl	function
(	O
Ident	struct
*	O
)	O
;	O
void	O
skip_struct	function
(	O
)	O
;	O
Symbol	struct
*	O
get_symbol	function
(	O
char	O
*	O
name	pointer
)	O
;	O
void	O
maybe_parm_list	function
(	O
int	O
*	O
parm_cnt_return	pointer
)	O
;	O
void	O
call	function
(	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
reference	function
(	O
char	O
*	O
,	O
int	O
)	O
;	O
int	O
level	int
;	O
Symbol	struct
*	O
caller	pointer
;	O
struct	O
obstack	struct
text_stk	struct
;	O
int	O
parm_level	int
;	O
typedef	O
struct	O
{	O
int	O
type	enum
;	O
char	O
*	O
token	pointer
;	O
int	O
line	int
;	O
}	O
TOKSTK	struct
;	O
typedef	O
int	O
Stackpos	array
[	O
1	int
]	O
;	O
TOKSTK	struct
tok	struct
;	O
TOKSTK	struct
*	O
token_stack	pointer
;	O
int	O
tos	int
;	O
int	O
curs	int
;	O
int	O
token_stack_length	int
=	O
64	int
;	O
int	O
token_stack_increase	int
=	O
32	int
;	O
static	O
int	O
need_space	int
;	O
void	O
mark	function
(	O
Stackpos	array
)	O
;	O
void	O
restore	function
(	O
Stackpos	array
)	O
;	O
void	O
tokpush	function
(	O
int	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
void	O
save_token	function
(	O
TOKSTK	struct
*	O
)	O
;	O
static	O
void	O
print_token	function
(	O
TOKSTK	struct
*	O
tokptr	pointer
)	O
{	O
switch	O
(	O
tokptr	pointer
->	O
type	enum
)	O
{	O
case	O
IDENTIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
WORD	int
:	O
case	O
MODIFIER	int
:	O
case	O
STRUCT	int
:	O
case	O
PARM_WRAPPER	int
:	O
case	O
QUALIFIER	int
:	O
case	O
OP	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`%s'"	pointer
,	O
tokptr	pointer
->	O
token	pointer
)	O
;	O
break	O
;	O
case	O
LBRACE0	int
:	O
case	O
LBRACE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`{'"	pointer
)	O
;	O
break	O
;	O
case	O
RBRACE0	int
:	O
case	O
RBRACE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`}'"	pointer
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`extern'"	pointer
)	O
;	O
break	O
;	O
case	O
STATIC	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`static'"	pointer
)	O
;	O
break	O
;	O
case	O
TYPEDEF	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`typedef'"	pointer
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"\"%s\""	pointer
,	O
tokptr	pointer
->	O
token	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"`%c'"	pointer
,	O
tokptr	pointer
->	O
type	enum
)	O
;	O
}	O
}	O
static	O
char	O
*	O
token_type_str	function
(	O
int	O
t	int
)	O
{	O
static	O
char	O
buf	array
[	O
80	int
]	O
;	O
switch	O
(	O
t	int
)	O
{	O
case	O
0	int
:	O
return	O
"EOF"	pointer
;	O
case	O
WORD	int
:	O
return	O
"WORD"	pointer
;	O
case	O
LBRACE0	int
:	O
return	O
"'{'"	pointer
;	O
case	O
RBRACE0	int
:	O
return	O
"'}'"	pointer
;	O
case	O
IDENTIFIER	int
:	O
return	O
"IDENTIFIER"	pointer
;	O
case	O
EXTERN	int
:	O
return	O
"EXTERN"	pointer
;	O
case	O
STATIC	int
:	O
return	O
"STATIC"	pointer
;	O
case	O
TYPEDEF	int
:	O
return	O
"TYPEDEF"	pointer
;	O
case	O
STRUCT	int
:	O
return	O
"STRUCT"	pointer
;	O
case	O
MODIFIER	int
:	O
return	O
"MODIFIER"	pointer
;	O
case	O
OP	int
:	O
return	O
"OP"	pointer
;	O
case	O
UNION	int
:	O
return	O
"UNION"	pointer
;	O
case	O
ENUM	int
:	O
return	O
"ENUM"	pointer
;	O
case	O
LBRACE	int
:	O
return	O
"' {'"	pointer
;	O
case	O
RBRACE	int
:	O
return	O
"' }'"	pointer
;	O
case	O
MEMBER_OF	int
:	O
return	O
"MEMBER_OF"	pointer
;	O
case	O
TYPE	int
:	O
return	O
"TYPE"	pointer
;	O
case	O
STRING	int
:	O
return	O
"STRING"	pointer
;	O
case	O
PARM_WRAPPER	int
:	O
return	O
"PARM_WRAPPER"	pointer
;	O
case	O
QUALIFIER	int
:	O
return	O
"QUALIFIER"	pointer
;	O
}	O
if	O
(	O
isprint	function
(	O
t	int
)	O
)	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
"'%c'(%d)"	pointer
,	O
t	int
,	O
t	int
)	O
;	O
else	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
"%d"	pointer
,	O
t	int
)	O
;	O
return	O
buf	array
;	O
}	O
static	O
void	O
dbgtok	function
(	O
TOKSTK	struct
*	O
t	int
,	O
int	O
delim	int
)	O
{	O
if	O
(	O
delim	int
)	O
fputc	function
(	O
delim	int
,	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"{ %s "	pointer
,	O
token_type_str	function
(	O
t	int
->	O
type	enum
)	O
)	O
;	O
if	O
(	O
t	int
->	O
type	enum
)	O
fprintf	function
(	O
stderr	pointer
,	O
", %s, %d "	pointer
,	O
t	int
->	O
token	pointer
?	O
t	int
->	O
token	pointer
:	O
"NULL"	pointer
,	O
t	int
->	O
line	int
)	O
;	O
fputc	function
(	O
'}'	O
,	O
stderr	pointer
)	O
;	O
}	O
static	O
void	O
debugtoken	function
(	O
TOKSTK	struct
*	O
t	int
,	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
debug	int
>	O
1	int
)	O
{	O
va_list	array
ap	array
;	O
int	O
i	long
;	O
if	O
(	O
fmt	pointer
)	O
{	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
": "	pointer
)	O
;	O
}	O
if	O
(	O
t	int
)	O
{	O
dbgtok	function
(	O
t	int
,	O
0	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"; "	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"%d: {"	pointer
,	O
curs	int
)	O
;	O
for	O
(	O
i	long
=	O
curs	int
;	O
i	long
<	O
tos	int
;	O
i	long
++	O
)	O
dbgtok	function
(	O
token_stack	pointer
+	O
i	long
,	O
i	long
==	O
curs	int
?	O
0	int
:	O
','	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"}\n"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
file_error	function
(	O
char	O
*	O
msg	pointer
,	O
TOKSTK	struct
*	O
tokptr	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: %s"	pointer
,	O
filename	pointer
,	O
tok	struct
.	O
line	int
,	O
msg	pointer
)	O
;	O
if	O
(	O
tokptr	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
" near "	pointer
)	O
)	O
;	O
print_token	function
(	O
tokptr	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
mark	function
(	O
Stackpos	array
pos	array
)	O
{	O
pos	array
[	O
0	int
]	O
=	O
curs	int
;	O
if	O
(	O
debug	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"marking stack at %d\n"	pointer
,	O
curs	int
)	O
;	O
}	O
void	O
restore	function
(	O
Stackpos	array
pos	array
)	O
{	O
curs	int
=	O
pos	array
[	O
0	int
]	O
;	O
if	O
(	O
curs	int
)	O
{	O
tok	struct
=	O
token_stack	pointer
[	O
curs	int
-	O
1	int
]	O
;	O
debugtoken	function
(	O
&	O
tok	struct
,	O
"restored stack"	pointer
)	O
;	O
}	O
}	O
void	O
tokdel	function
(	O
int	O
beg	int
,	O
int	O
end	int
)	O
{	O
if	O
(	O
end	int
>=	O
beg	int
)	O
{	O
if	O
(	O
end	int
<	O
tos	int
)	O
memmove	function
(	O
token_stack	pointer
+	O
beg	int
,	O
token_stack	pointer
+	O
end	int
+	O
1	int
,	O
(	O
tos	int
-	O
end	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
token_stack	pointer
[	O
0	int
]	O
)	O
)	O
;	O
tos	int
-=	O
(	O
end	int
-	O
beg	int
+	O
1	int
)	O
;	O
}	O
}	O
void	O
tokins	function
(	O
int	O
pos	array
,	O
int	O
type	enum
,	O
int	O
line	int
,	O
char	O
*	O
token	pointer
)	O
{	O
if	O
(	O
++	O
tos	int
==	O
token_stack_length	int
)	O
{	O
token_stack_length	int
+=	O
token_stack_increase	int
;	O
token_stack	pointer
=	O
xrealloc	function
(	O
token_stack	pointer
,	O
token_stack_length	int
*	O
sizeof	O
(	O
*	O
token_stack	pointer
)	O
)	O
;	O
}	O
memmove	function
(	O
token_stack	pointer
+	O
pos	array
+	O
1	int
,	O
token_stack	pointer
+	O
pos	array
,	O
(	O
tos	int
-	O
pos	array
-	O
1	int
)	O
*	O
sizeof	O
(	O
token_stack	pointer
[	O
0	int
]	O
)	O
)	O
;	O
token_stack	pointer
[	O
pos	array
]	O
.	O
type	enum
=	O
type	enum
;	O
token_stack	pointer
[	O
pos	array
]	O
.	O
token	pointer
=	O
token	pointer
;	O
token_stack	pointer
[	O
pos	array
]	O
.	O
line	int
=	O
line	int
;	O
debugtoken	function
(	O
&	O
token_stack	pointer
[	O
pos	array
]	O
,	O
"insert at %d"	pointer
,	O
pos	array
)	O
;	O
}	O
void	O
tokpush	function
(	O
int	O
type	enum
,	O
int	O
line	int
,	O
char	O
*	O
token	pointer
)	O
{	O
token_stack	pointer
[	O
tos	int
]	O
.	O
type	enum
=	O
type	enum
;	O
token_stack	pointer
[	O
tos	int
]	O
.	O
token	pointer
=	O
token	pointer
;	O
token_stack	pointer
[	O
tos	int
]	O
.	O
line	int
=	O
line	int
;	O
if	O
(	O
++	O
tos	int
==	O
token_stack_length	int
)	O
{	O
token_stack_length	int
+=	O
token_stack_increase	int
;	O
token_stack	pointer
=	O
xrealloc	function
(	O
token_stack	pointer
,	O
token_stack_length	int
*	O
sizeof	O
(	O
*	O
token_stack	pointer
)	O
)	O
;	O
}	O
}	O
void	O
cleanup_stack	function
(	O
)	O
{	O
int	O
delta	int
=	O
tos	int
-	O
curs	int
;	O
if	O
(	O
delta	int
>	O
0	int
)	O
memmove	function
(	O
token_stack	pointer
,	O
token_stack	pointer
+	O
curs	int
,	O
delta	int
*	O
sizeof	O
(	O
token_stack	pointer
[	O
0	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
delta	int
<	O
0	int
)	O
delta	int
=	O
0	int
;	O
tos	int
=	O
delta	int
;	O
curs	int
=	O
0	int
;	O
}	O
void	O
clearstack	function
(	O
)	O
{	O
tos	int
=	O
curs	int
=	O
0	int
;	O
}	O
int	O
nexttoken	function
(	O
)	O
{	O
int	O
type	enum
;	O
if	O
(	O
curs	int
==	O
tos	int
)	O
{	O
type	enum
=	O
get_token	function
(	O
)	O
;	O
tokpush	function
(	O
type	enum
,	O
line_num	int
,	O
yylval	struct
.	O
str	pointer
)	O
;	O
yylval	struct
.	O
str	pointer
=	O
NULL	O
;	O
}	O
tok	struct
=	O
token_stack	pointer
[	O
curs	int
]	O
;	O
curs	int
++	O
;	O
debugtoken	function
(	O
&	O
tok	struct
,	O
"next token"	pointer
)	O
;	O
return	O
tok	struct
.	O
type	enum
;	O
}	O
int	O
putback	function
(	O
)	O
{	O
if	O
(	O
curs	int
==	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"INTERNAL ERROR: cannot return token to stream"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
curs	int
--	O
;	O
if	O
(	O
curs	int
>	O
0	int
)	O
{	O
tok	struct
=	O
token_stack	pointer
[	O
curs	int
-	O
1	int
]	O
;	O
}	O
else	O
tok	struct
.	O
type	enum
=	O
0	int
;	O
debugtoken	function
(	O
&	O
tok	struct
,	O
"putback"	pointer
)	O
;	O
return	O
tok	struct
.	O
type	enum
;	O
}	O
void	O
init_parse	function
(	O
)	O
{	O
obstack_init	O
(	O
&	O
text_stk	struct
)	O
;	O
token_stack	pointer
=	O
xmalloc	function
(	O
token_stack_length	int
*	O
sizeof	O
(	O
*	O
token_stack	pointer
)	O
)	O
;	O
clearstack	function
(	O
)	O
;	O
}	O
void	O
save_token	function
(	O
TOKSTK	struct
*	O
tokptr	pointer
)	O
{	O
int	O
len	int
;	O
switch	O
(	O
tokptr	pointer
->	O
type	enum
)	O
{	O
case	O
IDENTIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
STRUCT	int
:	O
case	O
PARM_WRAPPER	int
:	O
case	O
WORD	int
:	O
case	O
QUALIFIER	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
' '	O
)	O
;	O
len	int
=	O
strlen	function
(	O
tokptr	pointer
->	O
token	pointer
)	O
;	O
obstack_grow	O
(	O
&	O
text_stk	struct
,	O
tokptr	pointer
->	O
token	pointer
,	O
len	int
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
MODIFIER	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
' '	O
)	O
;	O
if	O
(	O
tokptr	pointer
->	O
token	pointer
[	O
0	int
]	O
==	O
'*'	O
)	O
need_space	int
=	O
0	int
;	O
else	O
need_space	int
=	O
1	int
;	O
len	int
=	O
strlen	function
(	O
tokptr	pointer
->	O
token	pointer
)	O
;	O
obstack_grow	O
(	O
&	O
text_stk	struct
,	O
tokptr	pointer
->	O
token	pointer
,	O
len	int
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
case	O
STATIC	int
:	O
break	O
;	O
case	O
','	O
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
','	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
' '	O
)	O
;	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
tokptr	pointer
->	O
type	enum
)	O
;	O
need_space	int
=	O
0	int
;	O
break	O
;	O
case	O
')'	O
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
tokptr	pointer
->	O
type	enum
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
'['	O
:	O
case	O
']'	O
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
tokptr	pointer
->	O
type	enum
)	O
;	O
need_space	int
=	O
0	int
;	O
break	O
;	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
' '	O
)	O
;	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
'{'	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
RBRACE	int
:	O
case	O
RBRACE0	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
' '	O
)	O
;	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
'}'	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
OP	int
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
' '	O
)	O
;	O
obstack_grow	O
(	O
&	O
text_stk	struct
,	O
tokptr	pointer
->	O
token	pointer
,	O
strlen	function
(	O
tokptr	pointer
->	O
token	pointer
)	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unrecognized definition"	pointer
)	O
,	O
tokptr	pointer
)	O
;	O
}	O
}	O
static	O
Stackpos	array
start_pos	array
;	O
static	O
int	O
save_end	int
;	O
void	O
save_stack	function
(	O
)	O
{	O
mark	function
(	O
start_pos	array
)	O
;	O
save_end	int
=	O
curs	int
-	O
1	int
;	O
}	O
void	O
undo_save_stack	function
(	O
)	O
{	O
save_end	int
=	O
-	O
1	int
;	O
}	O
int	O
save_stack_is_empty	function
(	O
)	O
{	O
return	O
save_end	int
<=	O
0	int
;	O
}	O
char	O
*	O
finish_save_stack	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	long
;	O
int	O
level	int
=	O
0	int
;	O
int	O
found_ident	int
=	O
!	O
omit_symbol_names_option	int
;	O
need_space	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
save_end	int
;	O
i	long
++	O
)	O
{	O
switch	O
(	O
token_stack	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
{	O
case	O
'('	O
:	O
if	O
(	O
omit_arguments_option	int
)	O
{	O
if	O
(	O
level	int
==	O
0	int
)	O
{	O
save_token	function
(	O
token_stack	pointer
+	O
i	long
)	O
;	O
}	O
level	int
++	O
;	O
}	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
omit_arguments_option	int
)	O
level	int
--	O
;	O
break	O
;	O
case	O
IDENTIFIER	int
:	O
if	O
(	O
!	O
found_ident	int
&&	O
strcmp	function
(	O
name	pointer
,	O
token_stack	pointer
[	O
i	long
]	O
.	O
token	pointer
)	O
==	O
0	int
)	O
{	O
need_space	int
=	O
1	int
;	O
found_ident	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
level	int
==	O
0	int
)	O
save_token	function
(	O
token_stack	pointer
+	O
i	long
)	O
;	O
}	O
obstack_1grow	O
(	O
&	O
text_stk	struct
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
text_stk	struct
)	O
;	O
}	O
void	O
skip_to	function
(	O
int	O
c	int
)	O
{	O
while	O
(	O
nexttoken	function
(	O
)	O
)	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
c	int
)	O
break	O
;	O
}	O
}	O
int	O
skip_balanced	function
(	O
int	O
open_tok	int
,	O
int	O
close_tok	int
,	O
int	O
level	int
)	O
{	O
if	O
(	O
level	int
==	O
0	int
)	O
{	O
if	O
(	O
nexttoken	function
(	O
)	O
!=	O
open_tok	int
)	O
{	O
return	O
1	int
;	O
}	O
level	int
++	O
;	O
}	O
while	O
(	O
nexttoken	function
(	O
)	O
)	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
LBRACE0	int
&&	O
open_tok	int
==	O
'{'	O
)	O
tok	struct
.	O
type	enum
=	O
'{'	O
;	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
RBRACE0	int
&&	O
close_tok	int
==	O
'}'	O
)	O
tok	struct
.	O
type	enum
=	O
'}'	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
open_tok	int
)	O
level	int
++	O
;	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
close_tok	int
)	O
{	O
if	O
(	O
--	O
level	int
==	O
0	int
)	O
{	O
nexttoken	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
yyparse	function
(	O
)	O
{	O
Ident	struct
identifier	struct
;	O
level	int
=	O
0	int
;	O
caller	pointer
=	O
NULL	O
;	O
clearstack	function
(	O
)	O
;	O
while	O
(	O
nexttoken	function
(	O
)	O
)	O
{	O
identifier	struct
.	O
storage	enum
=	O
ExternStorage	int
;	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
QUALIFIER	int
:	O
continue	O
;	O
case	O
TYPEDEF	int
:	O
parse_typedef	function
(	O
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
identifier	struct
.	O
storage	enum
=	O
ExplicitExternStorage	int
;	O
parse_declaration	function
(	O
&	O
identifier	struct
,	O
0	int
)	O
;	O
break	O
;	O
case	O
STATIC	int
:	O
identifier	struct
.	O
storage	enum
=	O
StaticStorage	int
;	O
nexttoken	function
(	O
)	O
;	O
default	O
:	O
parse_declaration	function
(	O
&	O
identifier	struct
,	O
0	int
)	O
;	O
break	O
;	O
}	O
cleanup_stack	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
is_function	function
(	O
)	O
{	O
Stackpos	array
sp	pointer
;	O
int	O
res	int
=	O
0	int
;	O
mark	function
(	O
sp	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
QUALIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
IDENTIFIER	int
:	O
case	O
MODIFIER	int
:	O
case	O
STATIC	int
:	O
case	O
EXTERN	int
:	O
case	O
STRUCT	int
:	O
case	O
UNION	int
:	O
case	O
ENUM	int
:	O
nexttoken	function
(	O
)	O
;	O
continue	O
;	O
case	O
PARM_WRAPPER	int
:	O
if	O
(	O
skip_balanced	function
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in declaration"	pointer
)	O
,	O
NULL	O
)	O
;	O
continue	O
;	O
case	O
'('	O
:	O
res	int
=	O
nexttoken	function
(	O
)	O
!=	O
MODIFIER	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
restore	function
(	O
sp	pointer
)	O
;	O
return	O
res	int
;	O
}	O
void	O
parse_declaration	function
(	O
Ident	struct
*	O
ident	pointer
,	O
int	O
parm	int
)	O
{	O
if	O
(	O
is_function	function
(	O
)	O
)	O
parse_function_declaration	function
(	O
ident	pointer
,	O
parm	int
)	O
;	O
else	O
parse_variable_declaration	function
(	O
ident	pointer
,	O
parm	int
)	O
;	O
delete_parms	function
(	O
parm_level	int
)	O
;	O
}	O
void	O
expression	function
(	O
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
line	int
;	O
int	O
parens_lev	int
;	O
parens_lev	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
';'	O
:	O
return	O
;	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
case	O
RBRACE	int
:	O
case	O
RBRACE0	int
:	O
putback	function
(	O
)	O
;	O
return	O
;	O
case	O
','	O
:	O
if	O
(	O
parens_lev	int
==	O
0	int
)	O
return	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in expression"	pointer
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
case	O
IDENTIFIER	int
:	O
name	pointer
=	O
tok	struct
.	O
token	pointer
;	O
line	int
=	O
tok	struct
.	O
line	int
;	O
nexttoken	function
(	O
)	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
'('	O
)	O
{	O
call	function
(	O
name	pointer
,	O
line	int
)	O
;	O
parens_lev	int
++	O
;	O
}	O
else	O
{	O
reference	function
(	O
name	pointer
,	O
line	int
)	O
;	O
while	O
(	O
parens_lev	int
>	O
0	int
&&	O
tok	struct
.	O
type	enum
==	O
')'	O
)	O
{	O
parens_lev	int
--	O
;	O
nexttoken	function
(	O
)	O
;	O
}	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
MEMBER_OF	int
)	O
{	O
nexttoken	function
(	O
)	O
;	O
}	O
else	O
{	O
putback	function
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
nexttoken	function
(	O
)	O
==	O
TYPE	int
||	O
tok	struct
.	O
type	enum
==	O
STRUCT	int
)	O
skip_to	function
(	O
')'	O
)	O
;	O
else	O
{	O
putback	function
(	O
)	O
;	O
parens_lev	int
++	O
;	O
}	O
break	O
;	O
case	O
')'	O
:	O
parens_lev	int
--	O
;	O
break	O
;	O
case	O
MEMBER_OF	int
:	O
nexttoken	function
(	O
)	O
;	O
break	O
;	O
}	O
nexttoken	function
(	O
)	O
;	O
}	O
}	O
void	O
parse_function_declaration	function
(	O
Ident	struct
*	O
ident	pointer
,	O
int	O
parm	int
)	O
{	O
int	O
error_recovery	int
=	O
0	int
;	O
ident	pointer
->	O
type_end	int
=	O
-	O
1	int
;	O
parse_knr_dcl	function
(	O
ident	pointer
)	O
;	O
restart	O
:	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
')'	O
:	O
if	O
(	O
parm	int
)	O
break	O
;	O
default	O
:	O
if	O
(	O
error_recovery	int
)	O
nexttoken	function
(	O
)	O
;	O
else	O
{	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"expected `;'"	pointer
)	O
,	O
&	O
tok	struct
)	O
;	O
error_recovery	int
=	O
1	int
;	O
}	O
goto	O
restart	O
;	O
case	O
';'	O
:	O
case	O
','	O
:	O
break	O
;	O
case	O
LBRACE0	int
:	O
case	O
LBRACE	int
:	O
if	O
(	O
ident	pointer
->	O
name	pointer
)	O
{	O
caller	pointer
=	O
lookup	function
(	O
ident	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
caller	pointer
&&	O
caller	pointer
->	O
storage	enum
==	O
AutoStorage	int
)	O
caller	pointer
=	O
NULL	O
;	O
func_body	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in declaration"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
}	O
int	O
fake_struct	function
(	O
Ident	struct
*	O
ident	pointer
)	O
{	O
ident	pointer
->	O
type_end	int
=	O
-	O
1	int
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
STRUCT	int
)	O
{	O
if	O
(	O
nexttoken	function
(	O
)	O
==	O
IDENTIFIER	int
)	O
{	O
ident	pointer
->	O
type_end	int
=	O
curs	int
;	O
}	O
putback	function
(	O
)	O
;	O
skip_struct	function
(	O
)	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
||	O
tok	struct
.	O
type	enum
==	O
MODIFIER	int
||	O
tok	struct
.	O
type	enum
==	O
QUALIFIER	int
)	O
{	O
putback	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
'('	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
!=	O
';'	O
)	O
file_error	function
(	O
_	O
(	O
"missing `;' after struct declaration"	pointer
)	O
,	O
&	O
tok	struct
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
parse_variable_declaration	function
(	O
Ident	struct
*	O
ident	pointer
,	O
int	O
parm	int
)	O
{	O
Stackpos	array
sp	pointer
;	O
mark	function
(	O
sp	pointer
)	O
;	O
ident	pointer
->	O
type_end	int
=	O
-	O
1	int
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
STRUCT	int
||	O
tok	struct
.	O
type	enum
==	O
UNION	int
)	O
{	O
if	O
(	O
nexttoken	function
(	O
)	O
==	O
IDENTIFIER	int
)	O
{	O
ident	pointer
->	O
type_end	int
=	O
curs	int
;	O
}	O
putback	function
(	O
)	O
;	O
skip_struct	function
(	O
)	O
;	O
while	O
(	O
tok	struct
.	O
type	enum
==	O
MODIFIER	int
||	O
tok	struct
.	O
type	enum
==	O
QUALIFIER	int
)	O
nexttoken	function
(	O
)	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
)	O
{	O
if	O
(	O
ident	pointer
->	O
type_end	int
==	O
-	O
1	int
)	O
{	O
int	O
pos	array
=	O
curs	int
-	O
1	int
;	O
restore	function
(	O
sp	pointer
)	O
;	O
tokdel	function
(	O
curs	int
,	O
pos	array
-	O
1	int
)	O
;	O
tokins	function
(	O
curs	int
,	O
IDENTIFIER	int
,	O
tok	struct
.	O
line	int
,	O
"{ ... }"	pointer
)	O
;	O
debugtoken	function
(	O
&	O
tok	struct
,	O
"modified stack"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
';'	O
)	O
return	O
;	O
restore	function
(	O
sp	pointer
)	O
;	O
}	O
}	O
again	O
:	O
parse_dcl	function
(	O
ident	pointer
,	O
0	int
)	O
;	O
select	function
:	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
')'	O
:	O
if	O
(	O
parm	int
)	O
break	O
;	O
default	O
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"expected `;'"	pointer
)	O
,	O
&	O
tok	struct
)	O
;	O
case	O
';'	O
:	O
break	O
;	O
case	O
','	O
:	O
if	O
(	O
parm	int
)	O
break	O
;	O
tos	int
=	O
ident	pointer
->	O
type_end	int
;	O
restore	function
(	O
sp	pointer
)	O
;	O
goto	O
again	O
;	O
case	O
'='	O
:	O
nexttoken	function
(	O
)	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
LBRACE	int
||	O
tok	struct
.	O
type	enum
==	O
LBRACE0	int
)	O
initializer_list	function
(	O
)	O
;	O
else	O
expression	function
(	O
)	O
;	O
goto	O
select	function
;	O
case	O
LBRACE0	int
:	O
case	O
LBRACE	int
:	O
func_body	function
(	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in declaration"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
}	O
void	O
initializer_list	function
(	O
)	O
{	O
int	O
lev	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
lev	int
++	O
;	O
break	O
;	O
case	O
RBRACE	int
:	O
case	O
RBRACE0	int
:	O
if	O
(	O
--	O
lev	int
<=	O
0	int
)	O
{	O
nexttoken	function
(	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in initializer list"	pointer
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
case	O
','	O
:	O
break	O
;	O
default	O
:	O
expression	function
(	O
)	O
;	O
break	O
;	O
}	O
nexttoken	function
(	O
)	O
;	O
}	O
}	O
void	O
parse_knr_dcl	function
(	O
Ident	struct
*	O
ident	pointer
)	O
{	O
ident	pointer
->	O
type_end	int
=	O
-	O
1	int
;	O
parse_dcl	function
(	O
ident	pointer
,	O
!	O
strict_ansi	int
)	O
;	O
}	O
void	O
skip_struct	function
(	O
)	O
{	O
if	O
(	O
nexttoken	function
(	O
)	O
==	O
IDENTIFIER	int
)	O
{	O
nexttoken	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
';'	O
)	O
return	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
LBRACE	int
||	O
tok	struct
.	O
type	enum
==	O
LBRACE0	int
)	O
{	O
if	O
(	O
skip_balanced	function
(	O
'{'	O
,	O
'}'	O
,	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in struct"	pointer
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
tok	struct
.	O
type	enum
==	O
PARM_WRAPPER	int
)	O
{	O
if	O
(	O
skip_balanced	function
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
{	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in struct"	pointer
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
void	O
parse_typedef	function
(	O
)	O
{	O
Ident	struct
ident	pointer
;	O
ident	pointer
.	O
name	pointer
=	O
NULL	O
;	O
ident	pointer
.	O
type_end	int
=	O
-	O
1	int
;	O
ident	pointer
.	O
parmcnt	int
=	O
-	O
1	int
;	O
ident	pointer
.	O
line	int
=	O
-	O
1	int
;	O
ident	pointer
.	O
storage	enum
=	O
AnyStorage	int
;	O
nexttoken	function
(	O
)	O
;	O
if	O
(	O
!	O
fake_struct	function
(	O
&	O
ident	pointer
)	O
)	O
putback	function
(	O
)	O
;	O
dcl	function
(	O
&	O
ident	pointer
)	O
;	O
if	O
(	O
ident	pointer
.	O
name	pointer
)	O
declare_type	function
(	O
&	O
ident	pointer
)	O
;	O
}	O
void	O
parse_dcl	function
(	O
Ident	struct
*	O
ident	pointer
,	O
int	O
maybe_knr	int
)	O
{	O
ident	pointer
->	O
parmcnt	int
=	O
-	O
1	int
;	O
ident	pointer
->	O
name	pointer
=	O
NULL	O
;	O
putback	function
(	O
)	O
;	O
dcl	function
(	O
ident	pointer
)	O
;	O
save_stack	function
(	O
)	O
;	O
if	O
(	O
ident	pointer
->	O
name	pointer
)	O
declare	function
(	O
ident	pointer
,	O
maybe_knr	int
)	O
;	O
else	O
undo_save_stack	function
(	O
)	O
;	O
}	O
int	O
dcl	function
(	O
Ident	struct
*	O
idptr	pointer
)	O
{	O
while	O
(	O
nexttoken	function
(	O
)	O
!=	O
0	int
&&	O
tok	struct
.	O
type	enum
!=	O
'('	O
)	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
MODIFIER	int
)	O
{	O
if	O
(	O
idptr	pointer
&&	O
idptr	pointer
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	pointer
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
PARM_WRAPPER	int
)	O
{	O
if	O
(	O
skip_balanced	function
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
{	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in function declaration"	pointer
)	O
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
)	O
{	O
int	O
type	enum
;	O
while	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
)	O
nexttoken	function
(	O
)	O
;	O
type	enum
=	O
tok	struct
.	O
type	enum
;	O
putback	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
type	enum
==	O
TYPE	int
||	O
type	enum
==	O
MODIFIER	int
||	O
type	enum
==	O
QUALIFIER	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
')'	O
||	O
tok	struct
.	O
type	enum
==	O
';'	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
idptr	pointer
&&	O
idptr	pointer
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	pointer
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
return	O
dirdcl	function
(	O
idptr	pointer
)	O
;	O
}	O
int	O
dirdcl	function
(	O
Ident	struct
*	O
idptr	pointer
)	O
{	O
int	O
wrapper	int
=	O
0	int
;	O
int	O
*	O
parm_ptr	pointer
=	O
NULL	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
'('	O
)	O
{	O
dcl	function
(	O
idptr	pointer
)	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
!=	O
')'	O
&&	O
verbose	int
)	O
{	O
file_error	function
(	O
_	O
(	O
"expected `)'"	pointer
)	O
,	O
&	O
tok	struct
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
)	O
{	O
if	O
(	O
idptr	pointer
)	O
{	O
idptr	pointer
->	O
name	pointer
=	O
tok	struct
.	O
token	pointer
;	O
idptr	pointer
->	O
line	int
=	O
tok	struct
.	O
line	int
;	O
parm_ptr	pointer
=	O
&	O
idptr	pointer
->	O
parmcnt	int
;	O
}	O
}	O
if	O
(	O
nexttoken	function
(	O
)	O
==	O
PARM_WRAPPER	int
)	O
{	O
wrapper	int
=	O
1	int
;	O
nexttoken	function
(	O
)	O
;	O
}	O
else	O
putback	function
(	O
)	O
;	O
while	O
(	O
nexttoken	function
(	O
)	O
==	O
'['	O
||	O
tok	struct
.	O
type	enum
==	O
'('	O
)	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
'['	O
)	O
skip_to	function
(	O
']'	O
)	O
;	O
else	O
{	O
maybe_parm_list	function
(	O
parm_ptr	pointer
)	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
!=	O
')'	O
&&	O
verbose	int
)	O
{	O
file_error	function
(	O
_	O
(	O
"expected `)'"	pointer
)	O
,	O
&	O
tok	struct
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
wrapper	int
)	O
nexttoken	function
(	O
)	O
;	O
while	O
(	O
tok	struct
.	O
type	enum
==	O
PARM_WRAPPER	int
)	O
{	O
if	O
(	O
skip_balanced	function
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in function declaration"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
parmdcl	function
(	O
Ident	struct
*	O
idptr	pointer
)	O
{	O
int	O
type	enum
;	O
while	O
(	O
nexttoken	function
(	O
)	O
!=	O
0	int
&&	O
tok	struct
.	O
type	enum
!=	O
'('	O
)	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
MODIFIER	int
)	O
{	O
if	O
(	O
idptr	pointer
&&	O
idptr	pointer
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	pointer
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
)	O
{	O
while	O
(	O
tok	struct
.	O
type	enum
==	O
IDENTIFIER	int
)	O
nexttoken	function
(	O
)	O
;	O
type	enum
=	O
tok	struct
.	O
type	enum
;	O
putback	function
(	O
)	O
;	O
if	O
(	O
type	enum
!=	O
MODIFIER	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
')'	O
||	O
tok	struct
.	O
type	enum
==	O
','	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
idptr	pointer
&&	O
idptr	pointer
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	pointer
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
return	O
dirdcl	function
(	O
idptr	pointer
)	O
;	O
}	O
void	O
maybe_parm_list	function
(	O
int	O
*	O
parm_cnt_return	pointer
)	O
{	O
int	O
parmcnt	int
=	O
0	int
;	O
Ident	struct
ident	pointer
;	O
int	O
level	int
;	O
parm_level	int
++	O
;	O
while	O
(	O
nexttoken	function
(	O
)	O
)	O
{	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
')'	O
:	O
if	O
(	O
parm_cnt_return	pointer
)	O
*	O
parm_cnt_return	pointer
=	O
parmcnt	int
;	O
parm_level	int
--	O
;	O
return	O
;	O
case	O
','	O
:	O
break	O
;	O
case	O
QUALIFIER	int
:	O
case	O
IDENTIFIER	int
:	O
case	O
MODIFIER	int
:	O
case	O
STRUCT	int
:	O
case	O
UNION	int
:	O
case	O
TYPE	int
:	O
parmcnt	int
++	O
;	O
ident	pointer
.	O
storage	enum
=	O
AutoStorage	int
;	O
parse_declaration	function
(	O
&	O
ident	pointer
,	O
1	int
)	O
;	O
putback	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected token in parameter list"	pointer
)	O
,	O
&	O
tok	struct
)	O
;	O
level	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
'('	O
)	O
level	int
++	O
;	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
')'	O
)	O
{	O
if	O
(	O
level	int
--	O
==	O
0	int
)	O
break	O
;	O
}	O
}	O
while	O
(	O
nexttoken	function
(	O
)	O
)	O
;	O
;	O
putback	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in parameter list"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
void	O
func_body	function
(	O
)	O
{	O
Ident	struct
ident	pointer
;	O
level	int
++	O
;	O
move_parms	function
(	O
level	int
)	O
;	O
while	O
(	O
level	int
)	O
{	O
cleanup_stack	function
(	O
)	O
;	O
nexttoken	function
(	O
)	O
;	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
default	O
:	O
expression	function
(	O
)	O
;	O
break	O
;	O
case	O
STATIC	int
:	O
ident	pointer
.	O
storage	enum
=	O
StaticStorage	int
;	O
nexttoken	function
(	O
)	O
;	O
parse_variable_declaration	function
(	O
&	O
ident	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
TYPE	int
:	O
case	O
STRUCT	int
:	O
ident	pointer
.	O
storage	enum
=	O
AutoStorage	int
;	O
parse_variable_declaration	function
(	O
&	O
ident	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
ident	pointer
.	O
storage	enum
=	O
ExplicitExternStorage	int
;	O
parse_declaration	function
(	O
&	O
ident	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
LBRACE0	int
:	O
case	O
'{'	O
:	O
level	int
++	O
;	O
break	O
;	O
case	O
RBRACE0	int
:	O
if	O
(	O
use_indentation	int
)	O
{	O
if	O
(	O
verbose	int
&&	O
level	int
!=	O
1	int
)	O
file_error	function
(	O
_	O
(	O
"forced function body close"	pointer
)	O
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
level	int
;	O
level	int
--	O
)	O
{	O
delete_autos	function
(	O
level	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
'}'	O
:	O
delete_autos	function
(	O
level	int
)	O
;	O
level	int
--	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	function
(	O
_	O
(	O
"unexpected end of file in function body"	pointer
)	O
,	O
NULL	O
)	O
;	O
caller	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
}	O
caller	pointer
=	O
NULL	O
;	O
}	O
int	O
get_knr_args	function
(	O
Ident	struct
*	O
ident	pointer
)	O
{	O
int	O
parmcnt	int
,	O
stop	int
;	O
Stackpos	array
sp	pointer
,	O
new_sp	array
;	O
Ident	struct
id	struct
;	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
IDENTIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
STRUCT	int
:	O
mark	function
(	O
sp	pointer
)	O
;	O
parmcnt	int
=	O
0	int
;	O
for	O
(	O
stop	int
=	O
0	int
;	O
!	O
stop	int
&&	O
parmcnt	int
<	O
ident	pointer
->	O
parmcnt	int
;	O
nexttoken	function
(	O
)	O
)	O
{	O
id	struct
.	O
type_end	int
=	O
-	O
1	int
;	O
switch	O
(	O
tok	struct
.	O
type	enum
)	O
{	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
putback	function
(	O
)	O
;	O
stop	int
=	O
1	int
;	O
break	O
;	O
case	O
TYPE	int
:	O
case	O
IDENTIFIER	int
:	O
case	O
STRUCT	int
:	O
putback	function
(	O
)	O
;	O
mark	function
(	O
new_sp	array
)	O
;	O
if	O
(	O
dcl	function
(	O
&	O
id	struct
)	O
==	O
0	int
)	O
{	O
parmcnt	int
++	O
;	O
if	O
(	O
tok	struct
.	O
type	enum
==	O
','	O
)	O
{	O
do	O
{	O
tos	int
=	O
id	struct
.	O
type_end	int
;	O
restore	function
(	O
new_sp	array
)	O
;	O
dcl	function
(	O
&	O
id	struct
)	O
;	O
}	O
while	O
(	O
tok	struct
.	O
type	enum
==	O
','	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	struct
.	O
type	enum
!=	O
';'	O
)	O
putback	function
(	O
)	O
;	O
break	O
;	O
}	O
default	O
:	O
restore	function
(	O
sp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
declare	function
(	O
Ident	struct
*	O
ident	pointer
,	O
int	O
maybe_knr	int
)	O
{	O
Symbol	struct
*	O
sp	pointer
;	O
if	O
(	O
ident	pointer
->	O
storage	enum
==	O
AutoStorage	int
)	O
{	O
undo_save_stack	function
(	O
)	O
;	O
sp	pointer
=	O
install_ident	function
(	O
ident	pointer
->	O
name	pointer
,	O
ident	pointer
->	O
storage	enum
)	O
;	O
if	O
(	O
parm_level	int
)	O
{	O
sp	pointer
->	O
level	int
=	O
parm_level	int
;	O
sp	pointer
->	O
flag	pointer
=	O
symbol_parm	int
;	O
}	O
else	O
sp	pointer
->	O
level	int
=	O
level	int
;	O
sp	pointer
->	O
arity	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
ident	pointer
->	O
parmcnt	int
>=	O
0	int
&&	O
(	O
!	O
maybe_knr	int
||	O
get_knr_args	function
(	O
ident	pointer
)	O
==	O
0	int
)	O
&&	O
!	O
(	O
tok	struct
.	O
type	enum
==	O
LBRACE	int
||	O
tok	struct
.	O
type	enum
==	O
LBRACE0	int
||	O
tok	struct
.	O
type	enum
==	O
TYPE	int
||	O
tok	struct
.	O
type	enum
==	O
PARM_WRAPPER	int
)	O
)	O
||	O
(	O
ident	pointer
->	O
parmcnt	int
<	O
0	int
&&	O
ident	pointer
->	O
storage	enum
==	O
ExplicitExternStorage	int
)	O
||	O
save_stack_is_empty	function
(	O
)	O
)	O
{	O
undo_save_stack	function
(	O
)	O
;	O
return	O
;	O
}	O
sp	pointer
=	O
get_symbol	function
(	O
ident	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
sp	pointer
->	O
source	pointer
)	O
{	O
if	O
(	O
ident	pointer
->	O
storage	enum
==	O
StaticStorage	int
&&	O
(	O
sp	pointer
->	O
storage	enum
!=	O
StaticStorage	int
||	O
level	int
>	O
0	int
)	O
)	O
{	O
sp	pointer
=	O
install_ident	function
(	O
ident	pointer
->	O
name	pointer
,	O
ident	pointer
->	O
storage	enum
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sp	pointer
->	O
arity	int
>=	O
0	int
)	O
error_at_line	function
(	O
0	int
,	O
0	int
,	O
filename	pointer
,	O
ident	pointer
->	O
line	int
,	O
_	O
(	O
"%s/%d redefined"	pointer
)	O
,	O
ident	pointer
->	O
name	pointer
,	O
sp	pointer
->	O
arity	int
)	O
;	O
else	O
error_at_line	function
(	O
0	int
,	O
0	int
,	O
filename	pointer
,	O
ident	pointer
->	O
line	int
,	O
_	O
(	O
"%s redefined"	pointer
)	O
,	O
ident	pointer
->	O
name	pointer
)	O
;	O
error_at_line	function
(	O
0	int
,	O
0	int
,	O
sp	pointer
->	O
source	pointer
,	O
sp	pointer
->	O
def_line	int
,	O
_	O
(	O
"this is the place of previous definition"	pointer
)	O
)	O
;	O
}	O
}	O
sp	pointer
->	O
type	enum
=	O
SymIdentifier	int
;	O
sp	pointer
->	O
arity	int
=	O
ident	pointer
->	O
parmcnt	int
;	O
ident_change_storage	function
(	O
sp	pointer
,	O
(	O
ident	pointer
->	O
storage	enum
==	O
ExplicitExternStorage	int
)	O
?	O
ExternStorage	int
:	O
ident	pointer
->	O
storage	enum
)	O
;	O
sp	pointer
->	O
decl	pointer
=	O
finish_save_stack	function
(	O
ident	pointer
->	O
name	pointer
)	O
;	O
sp	pointer
->	O
source	pointer
=	O
filename	pointer
;	O
sp	pointer
->	O
def_line	int
=	O
ident	pointer
->	O
line	int
;	O
sp	pointer
->	O
level	int
=	O
level	int
;	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s/%d defined to %s\n"	pointer
)	O
,	O
filename	pointer
,	O
line_num	int
,	O
ident	pointer
->	O
name	pointer
,	O
ident	pointer
->	O
parmcnt	int
,	O
sp	pointer
->	O
decl	pointer
)	O
;	O
}	O
void	O
declare_type	function
(	O
Ident	struct
*	O
ident	pointer
)	O
{	O
Symbol	struct
*	O
sp	pointer
;	O
undo_save_stack	function
(	O
)	O
;	O
sp	pointer
=	O
lookup	function
(	O
ident	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
;	O
sp	pointer
;	O
sp	pointer
=	O
sp	pointer
->	O
next	pointer
)	O
if	O
(	O
sp	pointer
->	O
type	enum
==	O
SymToken	int
&&	O
sp	pointer
->	O
token_type	int
==	O
TYPE	int
)	O
break	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
sp	pointer
=	O
install	function
(	O
ident	pointer
->	O
name	pointer
,	O
INSTALL_UNIT_LOCAL	int
)	O
;	O
sp	pointer
->	O
type	enum
=	O
SymToken	int
;	O
sp	pointer
->	O
token_type	int
=	O
TYPE	int
;	O
sp	pointer
->	O
source	pointer
=	O
filename	pointer
;	O
sp	pointer
->	O
def_line	int
=	O
ident	pointer
->	O
line	int
;	O
sp	pointer
->	O
ref_line	pointer
=	O
NULL	O
;	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: type %s\n"	pointer
)	O
,	O
filename	pointer
,	O
line_num	int
,	O
ident	pointer
->	O
name	pointer
)	O
;	O
}	O
Symbol	struct
*	O
get_symbol	function
(	O
char	O
*	O
name	pointer
)	O
{	O
Symbol	struct
*	O
sp	pointer
=	O
lookup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
sp	pointer
)	O
{	O
for	O
(	O
;	O
sp	pointer
;	O
sp	pointer
=	O
sp	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
sp	pointer
->	O
type	enum
==	O
SymIdentifier	int
&&	O
strcmp	function
(	O
sp	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
sp	pointer
)	O
return	O
sp	pointer
;	O
}	O
return	O
install_ident	function
(	O
name	pointer
,	O
ExternStorage	int
)	O
;	O
}	O
Symbol	struct
*	O
add_reference	function
(	O
char	O
*	O
name	pointer
,	O
int	O
line	int
)	O
{	O
Symbol	struct
*	O
sp	pointer
=	O
get_symbol	function
(	O
name	pointer
)	O
;	O
Ref	struct
*	O
refptr	pointer
;	O
if	O
(	O
sp	pointer
->	O
storage	enum
==	O
AutoStorage	int
||	O
(	O
sp	pointer
->	O
storage	enum
==	O
StaticStorage	int
&&	O
globals_only	function
(	O
)	O
)	O
)	O
return	O
NULL	O
;	O
refptr	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
refptr	pointer
)	O
)	O
;	O
refptr	pointer
->	O
source	pointer
=	O
filename	pointer
;	O
refptr	pointer
->	O
line	int
=	O
line	int
;	O
if	O
(	O
!	O
sp	pointer
->	O
ref_line	pointer
)	O
sp	pointer
->	O
ref_line	pointer
=	O
linked_list_create	function
(	O
free	function
)	O
;	O
linked_list_append	function
(	O
&	O
sp	pointer
->	O
ref_line	pointer
,	O
refptr	pointer
)	O
;	O
return	O
sp	pointer
;	O
}	O
void	O
call	function
(	O
char	O
*	O
name	pointer
,	O
int	O
line	int
)	O
{	O
Symbol	struct
*	O
sp	pointer
;	O
sp	pointer
=	O
add_reference	function
(	O
name	pointer
,	O
line	int
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
return	O
;	O
if	O
(	O
sp	pointer
->	O
arity	int
<	O
0	int
)	O
sp	pointer
->	O
arity	int
=	O
0	int
;	O
if	O
(	O
caller	pointer
)	O
{	O
if	O
(	O
!	O
data_in_list	function
(	O
caller	pointer
,	O
sp	pointer
->	O
caller	pointer
)	O
)	O
linked_list_append	function
(	O
&	O
sp	pointer
->	O
caller	pointer
,	O
caller	pointer
)	O
;	O
if	O
(	O
!	O
data_in_list	function
(	O
sp	pointer
,	O
caller	pointer
->	O
callee	pointer
)	O
)	O
linked_list_append	function
(	O
&	O
caller	pointer
->	O
callee	pointer
,	O
sp	pointer
)	O
;	O
}	O
}	O
void	O
reference	function
(	O
char	O
*	O
name	pointer
,	O
int	O
line	int
)	O
{	O
Symbol	struct
*	O
sp	pointer
=	O
add_reference	function
(	O
name	pointer
,	O
line	int
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
return	O
;	O
if	O
(	O
caller	pointer
)	O
{	O
if	O
(	O
!	O
data_in_list	function
(	O
caller	pointer
,	O
sp	pointer
->	O
caller	pointer
)	O
)	O
linked_list_append	function
(	O
&	O
sp	pointer
->	O
caller	pointer
,	O
caller	pointer
)	O
;	O
if	O
(	O
!	O
data_in_list	function
(	O
sp	pointer
,	O
caller	pointer
->	O
callee	pointer
)	O
)	O
linked_list_append	function
(	O
&	O
caller	pointer
->	O
callee	pointer
,	O
sp	pointer
)	O
;	O
}	O
}	O
