char	O
*	O
proc_stat_state_tags	pointer
=	O
"TZRHDSIN<u+slfmpoxwg"	pointer
;	O
typedef	O
typeof	O
(	O
(	O
(	O
struct	O
procinfo	O
*	O
)	O
0	int
)	O
->	O
threadinfos	O
[	O
0	int
]	O
)	O
threadinfo_data_t	int
;	O
typedef	O
threadinfo_data_t	int
*	O
threadinfo_t	pointer
;	O
static	O
int	O
thread_state	function
(	O
thread_basic_info_t	O
bi	int
)	O
{	O
int	O
state	int
=	O
0	int
;	O
switch	O
(	O
bi	int
->	O
run_state	O
)	O
{	O
case	O
TH_STATE_RUNNING	O
:	O
state	int
|=	O
PSTAT_STATE_T_RUN	O
;	O
break	O
;	O
case	O
TH_STATE_UNINTERRUPTIBLE	O
:	O
state	int
|=	O
PSTAT_STATE_T_WAIT	O
;	O
break	O
;	O
case	O
TH_STATE_HALTED	O
:	O
state	int
|=	O
PSTAT_STATE_T_HALT	O
;	O
break	O
;	O
case	O
TH_STATE_STOPPED	O
:	O
state	int
|=	O
PSTAT_STATE_T_HALT	O
|	O
PSTAT_STATE_T_UNCLEAN	O
;	O
break	O
;	O
case	O
TH_STATE_WAITING	O
:	O
state	int
|=	O
bi	int
->	O
sleep_time	O
<	O
20	int
?	O
PSTAT_STATE_T_SLEEP	O
:	O
PSTAT_STATE_T_IDLE	O
;	O
break	O
;	O
}	O
if	O
(	O
bi	int
->	O
base_priority	O
<	O
25	int
)	O
state	int
|=	O
PSTAT_STATE_T_NASTY	O
;	O
else	O
if	O
(	O
bi	int
->	O
base_priority	O
>	O
25	int
)	O
state	int
|=	O
PSTAT_STATE_T_NICE	O
;	O
return	O
state	int
;	O
}	O
static	O
error_t	O
fetch_procinfo	function
(	O
process_t	O
server	int
,	O
pid_t	O
pid	int
,	O
ps_flags_t	O
need	int
,	O
ps_flags_t	O
*	O
have	pointer
,	O
struct	O
procinfo	O
*	O
*	O
pi	pointer
,	O
size_t	long
*	O
pi_size	pointer
,	O
char	O
*	O
*	O
waits	pointer
,	O
size_t	long
*	O
waits_len	pointer
)	O
{	O
static	O
const	O
struct	O
{	O
ps_flags_t	O
ps_flag	int
;	O
int	O
pi_flags	int
;	O
}	O
map	array
[	O
]	O
=	O
{	O
{	O
PSTAT_TASK_BASIC	O
,	O
PI_FETCH_TASKINFO	O
}	O
,	O
{	O
PSTAT_TASK_EVENTS	O
,	O
PI_FETCH_TASKEVENTS	O
}	O
,	O
{	O
PSTAT_NUM_THREADS	O
,	O
PI_FETCH_THREADS	O
}	O
,	O
{	O
PSTAT_THREAD_BASIC	O
,	O
PI_FETCH_THREAD_BASIC	O
|	O
PI_FETCH_THREADS	O
}	O
,	O
{	O
PSTAT_THREAD_SCHED	O
,	O
PI_FETCH_THREAD_SCHED	O
|	O
PI_FETCH_THREADS	O
}	O
,	O
{	O
PSTAT_THREAD_WAITS	O
,	O
PI_FETCH_THREAD_WAITS	O
|	O
PI_FETCH_THREADS	O
}	O
,	O
{	O
0	int
,	O
}	O
}	O
;	O
int	O
pi_flags	int
=	O
0	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
map	array
[	O
i	int
]	O
.	O
ps_flag	int
;	O
i	int
++	O
)	O
if	O
(	O
(	O
need	int
&	O
map	array
[	O
i	int
]	O
.	O
ps_flag	int
)	O
&&	O
!	O
(	O
*	O
have	pointer
&	O
map	array
[	O
i	int
]	O
.	O
ps_flag	int
)	O
)	O
pi_flags	int
|=	O
map	array
[	O
i	int
]	O
.	O
pi_flags	int
;	O
if	O
(	O
pi_flags	int
||	O
(	O
(	O
need	int
&	O
PSTAT_PROC_INFO	O
)	O
&&	O
!	O
(	O
*	O
have	pointer
&	O
PSTAT_PROC_INFO	O
)	O
)	O
)	O
{	O
error_t	O
err	O
;	O
*	O
pi_size	pointer
/=	O
sizeof	O
(	O
int	O
)	O
;	O
err	O
=	O
proc_getprocinfo	function
(	O
server	int
,	O
pid	int
,	O
&	O
pi_flags	int
,	O
(	O
procinfo_t	O
*	O
)	O
pi	pointer
,	O
pi_size	pointer
,	O
waits	pointer
,	O
waits_len	pointer
)	O
;	O
*	O
pi_size	pointer
*=	O
sizeof	O
(	O
int	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
have	pointer
|=	O
PSTAT_PROC_INFO	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
map	array
[	O
i	int
]	O
.	O
ps_flag	int
;	O
i	int
++	O
)	O
if	O
(	O
(	O
pi_flags	int
&	O
map	array
[	O
i	int
]	O
.	O
pi_flags	int
)	O
==	O
map	array
[	O
i	int
]	O
.	O
pi_flags	int
)	O
*	O
have	pointer
|=	O
map	array
[	O
i	int
]	O
.	O
ps_flag	int
;	O
}	O
return	O
err	O
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
ps_flags_t	O
merge_procinfo	function
(	O
struct	O
proc_stat	O
*	O
ps	pointer
,	O
ps_flags_t	O
need	int
,	O
ps_flags_t	O
have	pointer
)	O
{	O
error_t	O
err	O
;	O
struct	O
procinfo	O
*	O
new_pi	pointer
,	O
old_pi_hdr	struct
;	O
size_t	long
new_pi_size	long
;	O
char	O
*	O
new_waits	pointer
=	O
0	int
;	O
size_t	long
new_waits_len	long
=	O
0	int
;	O
ps_flags_t	O
really_need	O
=	O
need	int
|	O
(	O
have	pointer
&	O
PSTAT_PROCINFO_REFETCH	O
)	O
;	O
ps_flags_t	O
really_have	O
=	O
have	pointer
&	O
~	O
PSTAT_PROCINFO_REFETCH	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_PROCINFO	O
)	O
old_pi_hdr	struct
=	O
*	O
ps	pointer
->	O
proc_info	O
;	O
else	O
{	O
ps	pointer
->	O
proc_info	O
=	O
malloc	O
(	O
PROCINFO_MALLOC_SIZE	O
)	O
;	O
ps	pointer
->	O
proc_info_size	O
=	O
PROCINFO_MALLOC_SIZE	O
;	O
ps	pointer
->	O
proc_info_vm_alloced	O
=	O
0	int
;	O
if	O
(	O
!	O
ps	pointer
->	O
proc_info	O
)	O
return	O
ENOMEM	O
;	O
}	O
new_pi	pointer
=	O
ps	pointer
->	O
proc_info	O
;	O
new_pi_size	long
=	O
ps	pointer
->	O
proc_info_size	O
;	O
if	O
(	O
really_need	O
&	O
PSTAT_THREAD_WAITS	O
)	O
{	O
if	O
(	O
!	O
(	O
have	pointer
&	O
PSTAT_THREAD_WAITS	O
)	O
)	O
{	O
ps	pointer
->	O
thread_waits	O
=	O
malloc	O
(	O
WAITS_MALLOC_SIZE	int
)	O
;	O
ps	pointer
->	O
thread_waits_len	O
=	O
WAITS_MALLOC_SIZE	int
;	O
ps	pointer
->	O
thread_waits_vm_alloced	O
=	O
0	int
;	O
}	O
new_waits	pointer
=	O
ps	pointer
->	O
thread_waits	O
;	O
new_waits_len	long
=	O
ps	pointer
->	O
thread_waits_len	O
;	O
}	O
err	O
=	O
fetch_procinfo	function
(	O
ps	pointer
->	O
context	pointer
->	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
really_need	O
,	O
&	O
really_have	O
,	O
&	O
new_pi	pointer
,	O
&	O
new_pi_size	long
,	O
&	O
new_waits	pointer
,	O
&	O
new_waits_len	long
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
!	O
(	O
have	pointer
&	O
PSTAT_PROCINFO	O
)	O
)	O
free	function
(	O
new_pi	pointer
)	O
;	O
if	O
(	O
(	O
really_need	O
&	O
PSTAT_THREAD_WAITS	O
)	O
&&	O
!	O
(	O
have	pointer
&	O
PSTAT_THREAD_WAITS	O
)	O
)	O
free	function
(	O
new_waits	pointer
)	O
;	O
return	O
have	pointer
;	O
}	O
if	O
(	O
have	pointer
&	O
PSTAT_TASK_BASIC	O
)	O
bcopy	function
(	O
&	O
old_pi_hdr	struct
.	O
taskinfo	O
,	O
&	O
new_pi	pointer
->	O
taskinfo	O
,	O
sizeof	O
(	O
struct	O
task_basic_info	O
)	O
)	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_TASK_EVENTS	O
)	O
bcopy	function
(	O
&	O
old_pi_hdr	struct
.	O
taskevents	O
,	O
&	O
new_pi	pointer
->	O
taskevents	O
,	O
sizeof	O
(	O
struct	O
task_events_info	O
)	O
)	O
;	O
if	O
(	O
new_pi	pointer
!=	O
ps	pointer
->	O
proc_info	O
)	O
{	O
if	O
(	O
ps	pointer
->	O
proc_info_vm_alloced	O
)	O
munmap	function
(	O
ps	pointer
->	O
proc_info	O
,	O
ps	pointer
->	O
proc_info_size	O
)	O
;	O
else	O
free	function
(	O
ps	pointer
->	O
proc_info	O
)	O
;	O
ps	pointer
->	O
proc_info	O
=	O
new_pi	pointer
;	O
ps	pointer
->	O
proc_info_size	O
=	O
new_pi_size	long
;	O
ps	pointer
->	O
proc_info_vm_alloced	O
=	O
1	int
;	O
}	O
if	O
(	O
really_need	O
&	O
PSTAT_THREAD_WAITS	O
)	O
{	O
if	O
(	O
!	O
(	O
really_have	O
&	O
PSTAT_THREAD_WAITS	O
)	O
)	O
new_waits	pointer
=	O
0	int
;	O
if	O
(	O
new_waits	pointer
!=	O
ps	pointer
->	O
thread_waits	O
)	O
{	O
if	O
(	O
ps	pointer
->	O
thread_waits_vm_alloced	O
)	O
munmap	function
(	O
ps	pointer
->	O
thread_waits	O
,	O
ps	pointer
->	O
thread_waits_len	O
)	O
;	O
else	O
free	function
(	O
ps	pointer
->	O
thread_waits	O
)	O
;	O
ps	pointer
->	O
thread_waits	O
=	O
new_waits	pointer
;	O
ps	pointer
->	O
thread_waits_len	O
=	O
new_waits_len	long
;	O
ps	pointer
->	O
thread_waits_vm_alloced	O
=	O
1	int
;	O
}	O
}	O
return	O
really_have	O
;	O
}	O
static	O
ps_flags_t	O
add_preconditions	function
(	O
ps_flags_t	O
flags	int
,	O
struct	O
ps_context	O
*	O
context	pointer
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
PSTAT_USER_MASK	O
)	O
&&	O
context	pointer
->	O
user_hooks	O
&&	O
context	pointer
->	O
user_hooks	O
->	O
dependencies	O
)	O
flags	int
|=	O
(	O
*	O
context	pointer
->	O
user_hooks	O
->	O
dependencies	O
)	O
(	O
flags	int
&	O
PSTAT_USER_MASK	O
)	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_TTY	O
)	O
flags	int
|=	O
PSTAT_CTTYID	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_STATE	O
)	O
flags	int
|=	O
PSTAT_PROC_INFO	O
|	O
PSTAT_THREAD_BASIC	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_OWNER	O
)	O
flags	int
|=	O
PSTAT_OWNER_UID	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_OWNER_UID	O
)	O
flags	int
|=	O
PSTAT_PROC_INFO	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_SUSPEND_COUNT	O
)	O
flags	int
|=	O
PSTAT_TASK_BASIC	O
|	O
PSTAT_THREAD_BASIC	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_TIMES	O
)	O
flags	int
|=	O
PSTAT_TASK_BASIC	O
|	O
PSTAT_THREAD_BASIC	O
;	O
if	O
(	O
flags	int
&	O
(	O
PSTAT_CTTYID	O
|	O
PSTAT_CWDIR	O
|	O
PSTAT_AUTH	O
|	O
PSTAT_UMASK	O
)	O
&&	O
!	O
(	O
flags	int
&	O
PSTAT_NO_MSGPORT	O
)	O
)	O
{	O
flags	int
|=	O
PSTAT_MSGPORT	O
;	O
flags	int
|=	O
PSTAT_TASK	O
;	O
}	O
return	O
flags	int
;	O
}	O
static	O
int	O
should_suppress_msgport	function
(	O
struct	O
proc_stat	O
*	O
ps	pointer
)	O
{	O
ps_flags_t	O
have	pointer
=	O
ps	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
have	pointer
&	O
PSTAT_SUSPEND_COUNT	O
)	O
&&	O
ps	pointer
->	O
suspend_count	O
!=	O
0	int
)	O
return	O
TRUE	O
;	O
if	O
(	O
(	O
have	pointer
&	O
PSTAT_THREAD_BASIC	O
)	O
&&	O
ps	pointer
->	O
thread_basic_info	O
->	O
suspend_count	O
!=	O
0	int
)	O
return	O
TRUE	O
;	O
if	O
(	O
(	O
have	pointer
&	O
PSTAT_NUM_THREADS	O
)	O
&&	O
ps	pointer
->	O
num_threads	int
==	O
0	int
)	O
return	O
TRUE	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
struct	O
thread_basic_info	O
*	O
summarize_thread_basic_info	function
(	O
struct	O
procinfo	O
*	O
pi	pointer
,	O
ps_flags_t	O
have	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
num_threads	int
=	O
0	int
,	O
num_run_threads	int
=	O
0	int
;	O
thread_basic_info_t	O
tbi	O
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
thread_basic_info	O
)	O
)	O
;	O
int	O
run_base_priority	int
=	O
0	int
,	O
run_cur_priority	int
=	O
0	int
;	O
int	O
total_base_priority	int
=	O
0	int
,	O
total_cur_priority	int
=	O
0	int
;	O
if	O
(	O
!	O
tbi	O
)	O
return	O
0	int
;	O
memset	O
(	O
tbi	O
,	O
0	int
,	O
sizeof	O
*	O
tbi	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pi	pointer
->	O
nthreads	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
&&	O
!	O
(	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
.	O
flags	int
&	O
TH_FLAGS_IDLE	O
)	O
)	O
{	O
thread_basic_info_t	O
bi	int
=	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
;	O
int	O
thread_run_state	int
=	O
bi	int
->	O
run_state	O
;	O
if	O
(	O
tbi	O
->	O
run_state	O
==	O
0	int
)	O
tbi	O
->	O
run_state	O
=	O
thread_run_state	int
;	O
else	O
if	O
(	O
tbi	O
->	O
run_state	O
==	O
TH_STATE_RUNNING	O
||	O
thread_run_state	int
==	O
TH_STATE_RUNNING	O
)	O
tbi	O
->	O
run_state	O
=	O
TH_STATE_RUNNING	O
;	O
else	O
if	O
(	O
tbi	O
->	O
run_state	O
!=	O
bi	int
->	O
run_state	O
)	O
tbi	O
->	O
run_state	O
=	O
-	O
1	int
;	O
tbi	O
->	O
cpu_usage	O
+=	O
bi	int
->	O
cpu_usage	O
;	O
tbi	O
->	O
sleep_time	O
+=	O
bi	int
->	O
sleep_time	O
;	O
if	O
(	O
i	int
==	O
0	int
||	O
tbi	O
->	O
suspend_count	O
>	O
bi	int
->	O
suspend_count	O
)	O
tbi	O
->	O
suspend_count	O
=	O
bi	int
->	O
suspend_count	O
;	O
tbi	O
->	O
user_time	O
.	O
seconds	O
+=	O
bi	int
->	O
user_time	O
.	O
seconds	O
;	O
tbi	O
->	O
user_time	O
.	O
microseconds	O
+=	O
bi	int
->	O
user_time	O
.	O
microseconds	O
;	O
tbi	O
->	O
system_time	O
.	O
seconds	O
+=	O
bi	int
->	O
system_time	O
.	O
seconds	O
;	O
tbi	O
->	O
system_time	O
.	O
microseconds	O
+=	O
bi	int
->	O
system_time	O
.	O
microseconds	O
;	O
if	O
(	O
tbi	O
->	O
run_state	O
==	O
TH_STATE_RUNNING	O
)	O
{	O
run_base_priority	int
+=	O
bi	int
->	O
base_priority	O
;	O
run_cur_priority	int
+=	O
bi	int
->	O
base_priority	O
;	O
num_run_threads	int
++	O
;	O
}	O
else	O
{	O
total_base_priority	int
+=	O
bi	int
->	O
base_priority	O
;	O
total_cur_priority	int
+=	O
bi	int
->	O
base_priority	O
;	O
}	O
num_threads	int
++	O
;	O
}	O
if	O
(	O
num_threads	int
>	O
0	int
)	O
{	O
tbi	O
->	O
sleep_time	O
/=	O
num_threads	int
;	O
if	O
(	O
num_run_threads	int
>	O
0	int
)	O
{	O
tbi	O
->	O
base_priority	O
=	O
run_base_priority	int
/	O
num_run_threads	int
;	O
tbi	O
->	O
cur_priority	O
=	O
run_cur_priority	int
/	O
num_run_threads	int
;	O
}	O
else	O
{	O
tbi	O
->	O
base_priority	O
=	O
total_base_priority	int
/	O
num_threads	int
;	O
tbi	O
->	O
cur_priority	O
=	O
total_cur_priority	int
/	O
num_threads	int
;	O
}	O
}	O
if	O
(	O
have	pointer
&	O
PSTAT_TASK_BASIC	O
)	O
{	O
tbi	O
->	O
user_time	O
.	O
seconds	O
+=	O
pi	pointer
->	O
taskinfo	O
.	O
user_time	O
.	O
seconds	O
;	O
tbi	O
->	O
user_time	O
.	O
microseconds	O
+=	O
pi	pointer
->	O
taskinfo	O
.	O
user_time	O
.	O
microseconds	O
;	O
tbi	O
->	O
system_time	O
.	O
seconds	O
+=	O
pi	pointer
->	O
taskinfo	O
.	O
system_time	O
.	O
seconds	O
;	O
tbi	O
->	O
system_time	O
.	O
microseconds	O
+=	O
pi	pointer
->	O
taskinfo	O
.	O
system_time	O
.	O
microseconds	O
;	O
}	O
tbi	O
->	O
user_time	O
.	O
seconds	O
+=	O
tbi	O
->	O
user_time	O
.	O
microseconds	O
/	O
1000000	int
;	O
tbi	O
->	O
user_time	O
.	O
microseconds	O
%=	O
1000000	int
;	O
tbi	O
->	O
system_time	O
.	O
seconds	O
+=	O
tbi	O
->	O
system_time	O
.	O
microseconds	O
/	O
1000000	int
;	O
tbi	O
->	O
system_time	O
.	O
microseconds	O
%=	O
1000000	int
;	O
return	O
tbi	O
;	O
}	O
static	O
struct	O
thread_sched_info	O
*	O
summarize_thread_sched_info	function
(	O
struct	O
procinfo	O
*	O
pi	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
num_threads	int
=	O
0	int
;	O
thread_sched_info_t	O
tsi	O
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
thread_sched_info	O
)	O
)	O
;	O
if	O
(	O
!	O
tsi	O
)	O
return	O
0	int
;	O
memset	O
(	O
tsi	O
,	O
0	int
,	O
sizeof	O
*	O
tsi	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pi	pointer
->	O
nthreads	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
&&	O
!	O
(	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
.	O
flags	int
&	O
TH_FLAGS_IDLE	O
)	O
)	O
{	O
thread_sched_info_t	O
si	O
=	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_si	O
;	O
tsi	O
->	O
base_priority	O
+=	O
si	O
->	O
base_priority	O
;	O
tsi	O
->	O
cur_priority	O
+=	O
si	O
->	O
cur_priority	O
;	O
tsi	O
->	O
max_priority	O
+=	O
si	O
->	O
max_priority	O
;	O
tsi	O
->	O
depress_priority	O
+=	O
si	O
->	O
depress_priority	O
;	O
num_threads	int
++	O
;	O
}	O
if	O
(	O
num_threads	int
>	O
0	int
)	O
{	O
tsi	O
->	O
base_priority	O
/=	O
num_threads	int
;	O
tsi	O
->	O
cur_priority	O
/=	O
num_threads	int
;	O
tsi	O
->	O
max_priority	O
/=	O
num_threads	int
;	O
tsi	O
->	O
depress_priority	O
/=	O
num_threads	int
;	O
}	O
return	O
tsi	O
;	O
}	O
static	O
int	O
summarize_thread_states	function
(	O
struct	O
procinfo	O
*	O
pi	pointer
)	O
{	O
int	O
i	int
;	O
int	O
state	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pi	pointer
->	O
nthreads	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
&&	O
!	O
(	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
.	O
flags	int
&	O
TH_FLAGS_IDLE	O
)	O
)	O
state	int
|=	O
thread_state	function
(	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
)	O
;	O
return	O
state	int
;	O
}	O
static	O
void	O
summarize_thread_waits	function
(	O
struct	O
procinfo	O
*	O
pi	pointer
,	O
char	O
*	O
waits	pointer
,	O
size_t	long
waits_len	pointer
,	O
char	O
*	O
*	O
wait	pointer
,	O
mach_msg_id_t	O
*	O
rpc	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
next_wait	pointer
=	O
waits	pointer
;	O
*	O
wait	pointer
=	O
0	int
;	O
*	O
rpc	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pi	pointer
->	O
nthreads	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
)	O
{	O
if	O
(	O
next_wait	pointer
>	O
waits	pointer
+	O
waits_len	pointer
)	O
break	O
;	O
else	O
{	O
int	O
left	int
=	O
waits	pointer
+	O
waits_len	pointer
-	O
next_wait	pointer
;	O
if	O
(	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
.	O
flags	int
&	O
TH_FLAGS_IDLE	O
)	O
;	O
else	O
if	O
(	O
strncmp	O
(	O
next_wait	pointer
,	O
"msgport"	pointer
,	O
left	int
)	O
==	O
0	int
||	O
strncmp	O
(	O
next_wait	pointer
,	O
"itimer"	pointer
,	O
left	int
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
*	O
wait	pointer
)	O
{	O
*	O
wait	pointer
=	O
"*"	pointer
;	O
*	O
rpc	pointer
=	O
0	int
;	O
break	O
;	O
}	O
else	O
{	O
*	O
wait	pointer
=	O
next_wait	pointer
;	O
*	O
rpc	pointer
=	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
rpc_block	O
;	O
}	O
next_wait	pointer
+=	O
strnlen	function
(	O
next_wait	pointer
,	O
left	int
)	O
+	O
1	int
;	O
}	O
}	O
}	O
static	O
unsigned	O
count_threads	function
(	O
struct	O
procinfo	O
*	O
pi	pointer
,	O
ps_flags_t	O
have	pointer
)	O
{	O
if	O
(	O
have	pointer
&	O
(	O
PSTAT_PROCINFO_TASK_THREAD_DEP	O
&	O
~	O
PSTAT_NUM_THREADS	O
)	O
)	O
{	O
int	O
i	int
;	O
unsigned	O
num_threads	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pi	pointer
->	O
nthreads	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
)	O
num_threads	int
++	O
;	O
return	O
num_threads	int
;	O
}	O
else	O
return	O
pi	pointer
->	O
nthreads	O
;	O
}	O
threadinfo_t	pointer
get_thread_info	function
(	O
struct	O
procinfo	O
*	O
pi	pointer
,	O
unsigned	O
index	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pi	pointer
->	O
nthreads	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
&&	O
index	int
--	O
==	O
0	int
)	O
return	O
&	O
pi	pointer
->	O
threadinfos	O
[	O
i	int
]	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
get_thread_wait	function
(	O
char	O
*	O
waits	pointer
,	O
size_t	long
waits_len	pointer
,	O
unsigned	O
n	int
)	O
{	O
char	O
*	O
wait	pointer
=	O
waits	pointer
;	O
while	O
(	O
n	int
--	O
&&	O
wait	pointer
)	O
if	O
(	O
wait	pointer
>=	O
waits	pointer
+	O
waits_len	pointer
)	O
wait	pointer
=	O
0	int
;	O
else	O
wait	pointer
+=	O
strnlen	function
(	O
wait	pointer
,	O
waits	pointer
+	O
waits_len	pointer
-	O
wait	pointer
)	O
+	O
1	int
;	O
return	O
wait	pointer
;	O
}	O
static	O
void	O
*	O
clone	function
(	O
void	O
*	O
src	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
dst	pointer
=	O
malloc	O
(	O
size	long
)	O
;	O
if	O
(	O
dst	pointer
)	O
bcopy	function
(	O
src	pointer
,	O
dst	pointer
,	O
size	long
)	O
;	O
return	O
dst	pointer
;	O
}	O
static	O
ps_flags_t	O
set_procinfo_flags	function
(	O
struct	O
proc_stat	O
*	O
ps	pointer
,	O
ps_flags_t	O
need	int
,	O
ps_flags_t	O
have	pointer
)	O
{	O
if	O
(	O
have	pointer
&	O
PSTAT_PID	O
)	O
{	O
struct	O
procinfo	O
*	O
pi	pointer
;	O
ps_flags_t	O
had	O
=	O
have	pointer
;	O
if	O
(	O
!	O
(	O
have	pointer
&	O
PSTAT_PROCINFO	O
)	O
)	O
{	O
ps	pointer
->	O
proc_info	O
=	O
0	int
;	O
ps	pointer
->	O
proc_info_size	O
=	O
0	int
;	O
ps	pointer
->	O
thread_waits	O
=	O
0	int
;	O
ps	pointer
->	O
thread_waits_len	O
=	O
0	int
;	O
}	O
if	O
(	O
(	O
need	int
&	O
PSTAT_THREAD_WAIT	O
)	O
&&	O
!	O
(	O
need	int
&	O
PSTAT_THREAD_WAITS	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
have	pointer
&	O
PSTAT_NUM_THREADS	O
)	O
)	O
{	O
have	pointer
=	O
merge_procinfo	function
(	O
ps	pointer
,	O
PSTAT_NUM_THREADS	O
,	O
have	pointer
)	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_NUM_THREADS	O
)	O
ps	pointer
->	O
num_threads	int
=	O
count_threads	function
(	O
ps	pointer
->	O
proc_info	O
,	O
have	pointer
)	O
;	O
}	O
if	O
(	O
(	O
have	pointer
&	O
PSTAT_NUM_THREADS	O
)	O
&&	O
ps	pointer
->	O
num_threads	int
<=	O
3	int
)	O
need	int
|=	O
PSTAT_THREAD_WAITS	O
;	O
}	O
have	pointer
=	O
merge_procinfo	function
(	O
ps	pointer
,	O
need	int
,	O
have	pointer
)	O
;	O
pi	pointer
=	O
ps	pointer
->	O
proc_info	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_TASK_BASIC	O
)	O
ps	pointer
->	O
task_basic_info	O
=	O
&	O
pi	pointer
->	O
taskinfo	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_TASK_EVENTS	O
)	O
ps	pointer
->	O
task_events_info	O
=	O
&	O
pi	pointer
->	O
taskevents	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_NUM_THREADS	O
)	O
ps	pointer
->	O
num_threads	int
=	O
count_threads	function
(	O
pi	pointer
,	O
have	pointer
)	O
;	O
if	O
(	O
had	O
&	O
PSTAT_THREAD_BASIC	O
)	O
free	function
(	O
ps	pointer
->	O
thread_basic_info	O
)	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_THREAD_BASIC	O
)	O
ps	pointer
->	O
thread_basic_info	O
=	O
summarize_thread_basic_info	function
(	O
pi	pointer
,	O
have	pointer
)	O
;	O
if	O
(	O
had	O
&	O
PSTAT_THREAD_SCHED	O
)	O
free	function
(	O
ps	pointer
->	O
thread_sched_info	O
)	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_THREAD_SCHED	O
)	O
ps	pointer
->	O
thread_sched_info	O
=	O
summarize_thread_sched_info	function
(	O
pi	pointer
)	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_THREAD_WAITS	O
)	O
{	O
summarize_thread_waits	function
(	O
pi	pointer
,	O
ps	pointer
->	O
thread_waits	O
,	O
ps	pointer
->	O
thread_waits_len	O
,	O
&	O
ps	pointer
->	O
thread_wait	O
,	O
&	O
ps	pointer
->	O
thread_rpc	O
)	O
;	O
have	pointer
|=	O
PSTAT_THREAD_WAIT	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
have	pointer
&	O
PSTAT_NO_MSGPORT	O
)	O
&&	O
(	O
have	pointer
&	O
PSTAT_NUM_THREADS	O
)	O
&&	O
ps	pointer
->	O
num_threads	int
>	O
3	int
)	O
{	O
ps	pointer
->	O
thread_wait	O
=	O
"*"	pointer
;	O
ps	pointer
->	O
thread_rpc	O
=	O
0	int
;	O
have	pointer
|=	O
PSTAT_THREAD_WAIT	O
;	O
}	O
}	O
else	O
{	O
struct	O
proc_stat	O
*	O
origin	pointer
=	O
ps	pointer
->	O
thread_origin	O
;	O
ps_flags_t	O
oflags	O
=	O
(	O
need	int
&	O
PSTAT_PROCINFO_THREAD	O
)	O
|	O
(	O
(	O
need	int
&	O
PSTAT_THREAD_WAIT	O
)	O
?	O
PSTAT_THREAD_WAITS	O
:	O
0	int
)	O
;	O
proc_stat_set_flags	function
(	O
origin	pointer
,	O
oflags	O
)	O
;	O
oflags	O
=	O
origin	pointer
->	O
flags	int
;	O
if	O
(	O
oflags	O
&	O
PSTAT_PROCINFO_THREAD	O
)	O
{	O
threadinfo_t	pointer
ti	pointer
=	O
get_thread_info	function
(	O
origin	pointer
->	O
proc_info	O
,	O
ps	pointer
->	O
thread_index	O
)	O
;	O
need	int
&=	O
~	O
have	pointer
;	O
if	O
(	O
(	O
need	int
&	O
PSTAT_THREAD_BASIC	O
)	O
&&	O
(	O
oflags	O
&	O
PSTAT_THREAD_BASIC	O
)	O
&&	O
(	O
ps	pointer
->	O
thread_basic_info	O
=	O
clone	function
(	O
&	O
ti	pointer
->	O
pis_bi	O
,	O
sizeof	O
(	O
struct	O
thread_basic_info	O
)	O
)	O
)	O
)	O
have	pointer
|=	O
PSTAT_THREAD_BASIC	O
;	O
if	O
(	O
(	O
need	int
&	O
PSTAT_THREAD_SCHED	O
)	O
&&	O
(	O
oflags	O
&	O
PSTAT_THREAD_SCHED	O
)	O
&&	O
(	O
ps	pointer
->	O
thread_sched_info	O
=	O
clone	function
(	O
&	O
ti	pointer
->	O
pis_si	O
,	O
sizeof	O
(	O
struct	O
thread_sched_info	O
)	O
)	O
)	O
)	O
have	pointer
|=	O
PSTAT_THREAD_SCHED	O
;	O
if	O
(	O
(	O
need	int
&	O
PSTAT_THREAD_WAIT	O
)	O
&&	O
(	O
oflags	O
&	O
PSTAT_THREAD_WAITS	O
)	O
)	O
{	O
ps	pointer
->	O
thread_wait	O
=	O
get_thread_wait	function
(	O
origin	pointer
->	O
thread_waits	O
,	O
origin	pointer
->	O
thread_waits_len	O
,	O
ps	pointer
->	O
thread_index	O
)	O
;	O
if	O
(	O
ps	pointer
->	O
thread_wait	O
)	O
{	O
ps	pointer
->	O
thread_rpc	O
=	O
ti	pointer
->	O
rpc_block	O
;	O
have	pointer
|=	O
PSTAT_THREAD_WAIT	O
;	O
}	O
}	O
}	O
ps	pointer
->	O
inapp	O
|=	O
need	int
&	O
~	O
have	pointer
&	O
PSTAT_PROCINFO	O
&	O
~	O
PSTAT_PROCINFO_THREAD	O
;	O
}	O
return	O
have	pointer
;	O
}	O
error_t	O
proc_stat_set_flags	function
(	O
struct	O
proc_stat	O
*	O
ps	pointer
,	O
ps_flags_t	O
flags	int
)	O
{	O
ps_flags_t	O
have	pointer
=	O
ps	pointer
->	O
flags	int
;	O
ps_flags_t	O
need	int
;	O
ps_flags_t	O
no_msgport_flags	O
;	O
ps_flags_t	O
test_msgport_flags	O
;	O
process_t	O
server	int
=	O
ps_context_server	O
(	O
ps	pointer
->	O
context	pointer
)	O
;	O
void	O
suppress_msgport	function
(	O
)	O
{	O
need	int
&=	O
~	O
(	O
flags	int
&	O
~	O
no_msgport_flags	O
)	O
;	O
have	pointer
=	O
SUPPRESS_MSGPORT_FLAGS	O
(	O
have	pointer
)	O
;	O
}	O
flags	int
&=	O
~	O
ps	pointer
->	O
failed	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_NO_MSGPORT	O
)	O
have	pointer
=	O
SUPPRESS_MSGPORT_FLAGS	O
(	O
have	pointer
)	O
;	O
if	O
(	O
have	pointer
&	O
PSTAT_NO_MSGPORT	O
)	O
flags	int
=	O
SUPPRESS_MSGPORT_FLAGS	O
(	O
flags	int
)	O
;	O
no_msgport_flags	O
=	O
add_preconditions	function
(	O
SUPPRESS_MSGPORT_FLAGS	O
(	O
flags	int
)	O
,	O
ps	pointer
->	O
context	pointer
)	O
;	O
flags	int
=	O
add_preconditions	function
(	O
flags	int
,	O
ps	pointer
->	O
context	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
PSTAT_USES_MSGPORT	O
)	O
{	O
test_msgport_flags	O
=	O
add_preconditions	function
(	O
PSTAT_TEST_MSGPORT	O
,	O
ps	pointer
->	O
context	pointer
)	O
;	O
flags	int
|=	O
test_msgport_flags	O
;	O
}	O
else	O
test_msgport_flags	O
=	O
0	int
;	O
need	int
=	O
flags	int
&	O
~	O
have	pointer
&	O
~	O
ps	pointer
->	O
failed	O
;	O
if	O
(	O
need	int
&	O
~	O
have	pointer
&	O
test_msgport_flags	O
&	O
PSTAT_PROCINFO	O
)	O
have	pointer
=	O
set_procinfo_flags	function
(	O
ps	pointer
,	O
need	int
&	O
~	O
have	pointer
&	O
test_msgport_flags	O
,	O
have	pointer
)	O
;	O
if	O
(	O
NEED	O
(	O
PSTAT_SUSPEND_COUNT	O
,	O
(	O
(	O
have	pointer
&	O
PSTAT_PID	O
)	O
?	O
PSTAT_TASK_BASIC	O
:	O
PSTAT_THREAD_BASIC	O
)	O
)	O
)	O
{	O
if	O
(	O
have	pointer
&	O
PSTAT_PID	O
)	O
ps	pointer
->	O
suspend_count	O
=	O
ps	pointer
->	O
task_basic_info	O
->	O
suspend_count	O
;	O
else	O
ps	pointer
->	O
suspend_count	O
=	O
ps	pointer
->	O
thread_basic_info	O
->	O
suspend_count	O
;	O
have	pointer
|=	O
PSTAT_SUSPEND_COUNT	O
;	O
}	O
ps	pointer
->	O
flags	int
=	O
have	pointer
;	O
if	O
(	O
should_suppress_msgport	function
(	O
ps	pointer
)	O
)	O
suppress_msgport	function
(	O
)	O
;	O
if	O
(	O
need	int
&	O
~	O
have	pointer
&	O
PSTAT_PROCINFO	O
)	O
have	pointer
=	O
set_procinfo_flags	function
(	O
ps	pointer
,	O
need	int
,	O
have	pointer
)	O
;	O
MGET	O
(	O
PSTAT_MSGPORT	O
,	O
PSTAT_PID	O
,	O
proc_getmsgport	function
(	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
&	O
ps	pointer
->	O
msgport	O
)	O
)	O
;	O
MGET	O
(	O
PSTAT_PROCESS	O
,	O
PSTAT_PID	O
,	O
proc_pid2proc	function
(	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
&	O
ps	pointer
->	O
process	O
)	O
)	O
;	O
MGET	O
(	O
PSTAT_TASK	O
,	O
PSTAT_PID	O
,	O
proc_pid2task	function
(	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
&	O
ps	pointer
->	O
task	O
)	O
)	O
;	O
if	O
(	O
(	O
need	int
&	O
PSTAT_STATE	O
)	O
&&	O
(	O
have	pointer
&	O
(	O
PSTAT_PROC_INFO	O
|	O
PSTAT_THREAD_BASIC	O
)	O
)	O
)	O
{	O
ps	pointer
->	O
state	int
=	O
0	int
;	O
if	O
(	O
have	pointer
&	O
PSTAT_THREAD_BASIC	O
)	O
{	O
if	O
(	O
have	pointer
&	O
PSTAT_THREAD	O
)	O
ps	pointer
->	O
state	int
|=	O
thread_state	function
(	O
ps	pointer
->	O
thread_basic_info	O
)	O
;	O
else	O
ps	pointer
->	O
state	int
|=	O
summarize_thread_states	function
(	O
ps	pointer
->	O
proc_info	O
)	O
;	O
}	O
if	O
(	O
have	pointer
&	O
PSTAT_PROC_INFO	O
)	O
{	O
int	O
pi_flags	int
=	O
ps	pointer
->	O
proc_info	O
->	O
state	int
;	O
if	O
(	O
pi_flags	int
&	O
PI_STOPPED	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_STOP	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_ZOMBIE	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_ZOMBIE	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_SESSLD	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_SESSLDR	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_LOGINLD	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_LOGINLDR	O
;	O
if	O
(	O
!	O
(	O
pi_flags	int
&	O
PI_EXECED	O
)	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_FORKED	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_NOMSG	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_NOMSG	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_NOPARENT	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_NOPARENT	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_ORPHAN	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_ORPHAN	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_TRACED	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_TRACE	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_WAITING	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_WAIT	O
;	O
if	O
(	O
pi_flags	int
&	O
PI_GETMSG	O
)	O
ps	pointer
->	O
state	int
|=	O
PSTAT_STATE_P_GETMSG	O
;	O
}	O
have	pointer
|=	O
PSTAT_STATE	O
;	O
}	O
if	O
(	O
NEED	O
(	O
PSTAT_ARGS	O
,	O
PSTAT_PID	O
)	O
)	O
{	O
char	O
*	O
buf	pointer
=	O
malloc	O
(	O
100	int
)	O
;	O
ps	pointer
->	O
args_len	O
=	O
100	int
;	O
ps	pointer
->	O
args	O
=	O
buf	pointer
;	O
if	O
(	O
ps	pointer
->	O
args	O
)	O
{	O
if	O
(	O
proc_getprocargs	function
(	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
&	O
ps	pointer
->	O
args	O
,	O
&	O
ps	pointer
->	O
args_len	O
)	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
else	O
{	O
have	pointer
|=	O
PSTAT_ARGS	O
;	O
ps	pointer
->	O
args_vm_alloced	O
=	O
(	O
ps	pointer
->	O
args	O
!=	O
buf	pointer
)	O
;	O
if	O
(	O
ps	pointer
->	O
args_vm_alloced	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
NEED	O
(	O
PSTAT_ENV	O
,	O
PSTAT_PID	O
)	O
)	O
{	O
char	O
*	O
buf	pointer
=	O
malloc	O
(	O
100	int
)	O
;	O
ps	pointer
->	O
env_len	O
=	O
100	int
;	O
ps	pointer
->	O
env	O
=	O
buf	pointer
;	O
if	O
(	O
ps	pointer
->	O
env	O
)	O
{	O
if	O
(	O
proc_getprocenv	function
(	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
&	O
ps	pointer
->	O
env	O
,	O
&	O
ps	pointer
->	O
env_len	O
)	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
else	O
{	O
have	pointer
|=	O
PSTAT_ENV	O
;	O
ps	pointer
->	O
env_vm_alloced	O
=	O
(	O
ps	pointer
->	O
env	O
!=	O
buf	pointer
)	O
;	O
if	O
(	O
ps	pointer
->	O
env_vm_alloced	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
MP_MGET	O
(	O
PSTAT_CTTYID	O
,	O
PSTAT_TASK	O
,	O
ps_msg_get_init_port	O
(	O
ps	pointer
->	O
msgport	O
,	O
ps	pointer
->	O
task	O
,	O
INIT_PORT_CTTYID	O
,	O
&	O
ps	pointer
->	O
cttyid	O
)	O
)	O
;	O
MP_MGET	O
(	O
PSTAT_CWDIR	O
,	O
PSTAT_TASK	O
,	O
ps_msg_get_init_port	O
(	O
ps	pointer
->	O
msgport	O
,	O
ps	pointer
->	O
task	O
,	O
INIT_PORT_CWDIR	O
,	O
&	O
ps	pointer
->	O
cwdir	O
)	O
)	O
;	O
MP_MGET	O
(	O
PSTAT_AUTH	O
,	O
PSTAT_TASK	O
,	O
ps_msg_get_init_port	O
(	O
ps	pointer
->	O
msgport	O
,	O
ps	pointer
->	O
task	O
,	O
INIT_PORT_AUTH	O
,	O
&	O
ps	pointer
->	O
auth	O
)	O
)	O
;	O
MP_MGET	O
(	O
PSTAT_UMASK	O
,	O
PSTAT_TASK	O
,	O
ps_msg_get_init_int	O
(	O
ps	pointer
->	O
msgport	O
,	O
ps	pointer
->	O
task	O
,	O
INIT_UMASK	O
,	O
(	O
int	O
*	O
)	O
&	O
ps	pointer
->	O
umask	O
)	O
)	O
;	O
if	O
(	O
NEED	O
(	O
PSTAT_OWNER_UID	O
,	O
PSTAT_PROC_INFO	O
)	O
)	O
{	O
if	O
(	O
ps	pointer
->	O
proc_info	O
->	O
state	int
&	O
PI_NOTOWNED	O
)	O
ps	pointer
->	O
owner_uid	O
=	O
-	O
1	int
;	O
else	O
ps	pointer
->	O
owner_uid	O
=	O
ps	pointer
->	O
proc_info	O
->	O
owner	O
;	O
have	pointer
|=	O
PSTAT_OWNER_UID	O
;	O
}	O
if	O
(	O
NEED	O
(	O
PSTAT_OWNER	O
,	O
PSTAT_OWNER_UID	O
)	O
)	O
{	O
if	O
(	O
ps	pointer
->	O
owner_uid	O
<	O
0	int
)	O
{	O
ps	pointer
->	O
owner	O
=	O
0	int
;	O
have	pointer
|=	O
PSTAT_OWNER	O
;	O
}	O
else	O
if	O
(	O
!	O
ps_context_find_user	function
(	O
ps	pointer
->	O
context	pointer
,	O
ps	pointer
->	O
owner_uid	O
,	O
&	O
ps	pointer
->	O
owner	O
)	O
)	O
have	pointer
|=	O
PSTAT_OWNER	O
;	O
}	O
if	O
(	O
NEED	O
(	O
PSTAT_TTY	O
,	O
PSTAT_CTTYID	O
)	O
)	O
if	O
(	O
ps_context_find_tty_by_cttyid	function
(	O
ps	pointer
->	O
context	pointer
,	O
ps	pointer
->	O
cttyid	O
,	O
&	O
ps	pointer
->	O
tty	O
)	O
==	O
0	int
)	O
have	pointer
|=	O
PSTAT_TTY	O
;	O
MGET	O
(	O
PSTAT_NUM_PORTS	O
,	O
PSTAT_PID	O
,	O
proc_getnports	function
(	O
server	int
,	O
ps	pointer
->	O
pid	int
,	O
&	O
ps	pointer
->	O
num_ports	O
)	O
)	O
;	O
if	O
(	O
(	O
need	int
&	O
PSTAT_TIMES	O
)	O
&&	O
(	O
have	pointer
&	O
(	O
PSTAT_TASK_BASIC	O
|	O
PSTAT_THREAD_BASIC	O
)	O
)	O
)	O
have	pointer
|=	O
PSTAT_TIMES	O
;	O
ps	pointer
->	O
failed	O
|=	O
(	O
need	int
&	O
~	O
PSTAT_USER_MASK	O
)	O
&	O
~	O
have	pointer
;	O
ps	pointer
->	O
flags	int
=	O
have	pointer
;	O
need	int
&=	O
~	O
have	pointer
;	O
if	O
(	O
need	int
&&	O
ps	pointer
->	O
context	pointer
->	O
user_hooks	O
&&	O
ps	pointer
->	O
context	pointer
->	O
user_hooks	O
->	O
fetch	O
)	O
{	O
have	pointer
|=	O
(	O
*	O
ps	pointer
->	O
context	pointer
->	O
user_hooks	O
->	O
fetch	O
)	O
(	O
ps	pointer
,	O
need	int
,	O
have	pointer
)	O
;	O
ps	pointer
->	O
failed	O
=	O
(	O
ps	pointer
->	O
failed	O
|	O
need	int
)	O
&	O
~	O
have	pointer
;	O
ps	pointer
->	O
flags	int
=	O
have	pointer
;	O
}	O
return	O
0	int
;	O
}	O
void	O
_proc_stat_free	function
(	O
ps	pointer
)	O
struct	O
proc_stat	O
*	O
ps	pointer
;	O
{	O
if	O
(	O
ps	pointer
->	O
context	pointer
->	O
user_hooks	O
&&	O
ps	pointer
->	O
context	pointer
->	O
user_hooks	O
->	O
cleanup	O
)	O
(	O
*	O
ps	pointer
->	O
context	pointer
->	O
user_hooks	O
->	O
cleanup	O
)	O
(	O
ps	pointer
)	O
;	O
MFREEPORT	O
(	O
PSTAT_PROCESS	O
,	O
process	O
)	O
;	O
MFREEPORT	O
(	O
PSTAT_TASK	O
,	O
task	O
)	O
;	O
MFREEPORT	O
(	O
PSTAT_MSGPORT	O
,	O
msgport	O
)	O
;	O
MFREEPORT	O
(	O
PSTAT_CTTYID	O
,	O
cttyid	O
)	O
;	O
MFREEPORT	O
(	O
PSTAT_CWDIR	O
,	O
cwdir	O
)	O
;	O
MFREEPORT	O
(	O
PSTAT_AUTH	O
,	O
auth	O
)	O
;	O
MFREEMEM	O
(	O
PSTAT_PROC_INFO	O
,	O
proc_info	O
,	O
ps	pointer
->	O
proc_info_size	O
,	O
ps	pointer
->	O
proc_info_vm_alloced	O
,	O
0	int
,	O
char	O
)	O
;	O
MFREEMEM	O
(	O
PSTAT_THREAD_BASIC	O
,	O
thread_basic_info	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
MFREEMEM	O
(	O
PSTAT_THREAD_SCHED	O
,	O
thread_sched_info	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
MFREEMEM	O
(	O
PSTAT_ARGS	O
,	O
args	O
,	O
ps	pointer
->	O
args_len	O
,	O
ps	pointer
->	O
args_vm_alloced	O
,	O
0	int
,	O
char	O
)	O
;	O
MFREEMEM	O
(	O
PSTAT_ENV	O
,	O
env	O
,	O
ps	pointer
->	O
env_len	O
,	O
ps	pointer
->	O
env_vm_alloced	O
,	O
0	int
,	O
char	O
)	O
;	O
MFREEMEM	O
(	O
PSTAT_TASK_EVENTS	O
,	O
task_events_info	O
,	O
ps	pointer
->	O
task_events_info_size	O
,	O
0	int
,	O
&	O
ps	pointer
->	O
task_events_info_buf	O
,	O
char	O
)	O
;	O
MFREEMEM	O
(	O
PSTAT_THREAD_WAITS	O
,	O
thread_waits	O
,	O
ps	pointer
->	O
thread_waits_len	O
,	O
ps	pointer
->	O
thread_waits_vm_alloced	O
,	O
0	int
,	O
char	O
)	O
;	O
FREE	function
(	O
ps	pointer
)	O
;	O
}	O
error_t	O
_proc_stat_create	function
(	O
pid_t	O
pid	int
,	O
struct	O
ps_context	O
*	O
context	pointer
,	O
struct	O
proc_stat	O
*	O
*	O
ps	pointer
)	O
{	O
*	O
ps	pointer
=	O
NEW	function
(	O
struct	O
proc_stat	O
)	O
;	O
if	O
(	O
*	O
ps	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
(	O
*	O
ps	pointer
)	O
->	O
pid	int
=	O
pid	int
;	O
(	O
*	O
ps	pointer
)	O
->	O
flags	int
=	O
PSTAT_PID	O
;	O
(	O
*	O
ps	pointer
)	O
->	O
failed	O
=	O
0	int
;	O
(	O
*	O
ps	pointer
)	O
->	O
inapp	O
=	O
PSTAT_THREAD	O
;	O
(	O
*	O
ps	pointer
)	O
->	O
context	pointer
=	O
context	pointer
;	O
(	O
*	O
ps	pointer
)	O
->	O
hook	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	O
proc_stat_thread_create	function
(	O
struct	O
proc_stat	O
*	O
ps	pointer
,	O
unsigned	O
index	int
,	O
struct	O
proc_stat	O
*	O
*	O
thread_ps	pointer
)	O
{	O
error_t	O
err	O
=	O
proc_stat_set_flags	function
(	O
ps	pointer
,	O
PSTAT_NUM_THREADS	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
else	O
if	O
(	O
index	int
>=	O
ps	pointer
->	O
num_threads	int
)	O
return	O
EINVAL	O
;	O
else	O
{	O
struct	O
proc_stat	O
*	O
tps	pointer
=	O
NEW	function
(	O
struct	O
proc_stat	O
)	O
;	O
if	O
(	O
tps	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
tps	pointer
->	O
pid	int
=	O
-	O
1	int
;	O
tps	pointer
->	O
flags	int
=	O
PSTAT_THREAD	O
;	O
tps	pointer
->	O
failed	O
=	O
0	int
;	O
tps	pointer
->	O
inapp	O
=	O
PSTAT_PID	O
;	O
tps	pointer
->	O
thread_origin	O
=	O
ps	pointer
;	O
tps	pointer
->	O
thread_index	O
=	O
index	int
;	O
tps	pointer
->	O
context	pointer
=	O
ps	pointer
->	O
context	pointer
;	O
*	O
thread_ps	pointer
=	O
tps	pointer
;	O
return	O
0	int
;	O
}	O
}	O
