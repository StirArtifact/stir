static	O
int	O
rl_change_case	function
PARAMS	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_char_search	function
PARAMS	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_insert_next_callback	function
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct
*	O
)	O
)	O
;	O
static	O
int	O
_rl_char_search_callback	function
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct
*	O
)	O
)	O
;	O
int	O
_rl_optimize_typeahead	int
=	O
1	int
;	O
int	O
rl_insert_text	function
(	O
string	pointer
)	O
const	O
char	O
*	O
string	pointer
;	O
{	O
register	O
int	O
i	int
,	O
l	int
;	O
l	int
=	O
(	O
string	pointer
&&	O
*	O
string	pointer
)	O
?	O
strlen	function
(	O
string	pointer
)	O
:	O
0	int
;	O
if	O
(	O
l	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
rl_end	int
+	O
l	int
>=	O
rl_line_buffer_len	int
)	O
rl_extend_line_buffer	function
(	O
rl_end	int
+	O
l	int
)	O
;	O
for	O
(	O
i	int
=	O
rl_end	int
;	O
i	int
>=	O
rl_point	int
;	O
i	int
--	O
)	O
rl_line_buffer	pointer
[	O
i	int
+	O
l	int
]	O
=	O
rl_line_buffer	pointer
[	O
i	int
]	O
;	O
strncpy	function
(	O
rl_line_buffer	pointer
+	O
rl_point	int
,	O
string	pointer
,	O
l	int
)	O
;	O
if	O
(	O
_rl_doing_an_undo	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
l	int
==	O
1	int
)	O
&&	O
rl_undo_list	pointer
&&	O
(	O
rl_undo_list	pointer
->	O
what	enum
==	O
UNDO_INSERT	int
)	O
&&	O
(	O
rl_undo_list	pointer
->	O
end	int
==	O
rl_point	int
)	O
&&	O
(	O
rl_undo_list	pointer
->	O
end	int
-	O
rl_undo_list	pointer
->	O
start	int
<	O
20	int
)	O
)	O
rl_undo_list	pointer
->	O
end	int
++	O
;	O
else	O
rl_add_undo	function
(	O
UNDO_INSERT	int
,	O
rl_point	int
,	O
rl_point	int
+	O
l	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
rl_point	int
+=	O
l	int
;	O
rl_end	int
+=	O
l	int
;	O
rl_line_buffer	pointer
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
return	O
l	int
;	O
}	O
int	O
rl_delete_text	function
(	O
from	int
,	O
to	int
)	O
int	O
from	int
,	O
to	int
;	O
{	O
register	O
char	O
*	O
text	pointer
;	O
register	O
int	O
diff	int
,	O
i	int
;	O
if	O
(	O
from	int
>	O
to	int
)	O
SWAP	O
(	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
to	int
>	O
rl_end	int
)	O
{	O
to	int
=	O
rl_end	int
;	O
if	O
(	O
from	int
>	O
to	int
)	O
from	int
=	O
to	int
;	O
}	O
if	O
(	O
from	int
<	O
0	int
)	O
from	int
=	O
0	int
;	O
text	pointer
=	O
rl_copy_text	function
(	O
from	int
,	O
to	int
)	O
;	O
diff	int
=	O
to	int
-	O
from	int
;	O
for	O
(	O
i	int
=	O
from	int
;	O
i	int
<	O
rl_end	int
-	O
diff	int
;	O
i	int
++	O
)	O
rl_line_buffer	pointer
[	O
i	int
]	O
=	O
rl_line_buffer	pointer
[	O
i	int
+	O
diff	int
]	O
;	O
if	O
(	O
_rl_doing_an_undo	int
==	O
0	int
)	O
rl_add_undo	function
(	O
UNDO_DELETE	int
,	O
from	int
,	O
to	int
,	O
text	pointer
)	O
;	O
else	O
xfree	function
(	O
text	pointer
)	O
;	O
rl_end	int
-=	O
diff	int
;	O
rl_line_buffer	pointer
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
diff	int
)	O
;	O
}	O
void	O
_rl_fix_point	function
(	O
fix_mark_too	int
)	O
int	O
fix_mark_too	int
;	O
{	O
_RL_FIX_POINT	O
(	O
rl_point	int
)	O
;	O
if	O
(	O
fix_mark_too	int
)	O
_RL_FIX_POINT	O
(	O
rl_mark	int
)	O
;	O
}	O
int	O
_rl_replace_text	function
(	O
text	pointer
,	O
start	int
,	O
end	int
)	O
const	O
char	O
*	O
text	pointer
;	O
int	O
start	int
,	O
end	int
;	O
{	O
int	O
n	int
;	O
n	int
=	O
0	int
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
if	O
(	O
start	int
<=	O
end	int
)	O
rl_delete_text	function
(	O
start	int
,	O
end	int
+	O
1	int
)	O
;	O
rl_point	int
=	O
start	int
;	O
if	O
(	O
*	O
text	pointer
)	O
n	int
=	O
rl_insert_text	function
(	O
text	pointer
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
return	O
n	int
;	O
}	O
void	O
rl_replace_line	function
(	O
text	pointer
,	O
clear_undo	int
)	O
const	O
char	O
*	O
text	pointer
;	O
int	O
clear_undo	int
;	O
{	O
int	O
len	int
;	O
len	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
if	O
(	O
len	int
>=	O
rl_line_buffer_len	int
)	O
rl_extend_line_buffer	function
(	O
len	int
)	O
;	O
strcpy	function
(	O
rl_line_buffer	pointer
,	O
text	pointer
)	O
;	O
rl_end	int
=	O
len	int
;	O
if	O
(	O
clear_undo	int
)	O
rl_free_undo_list	function
(	O
)	O
;	O
_rl_fix_point	function
(	O
1	int
)	O
;	O
}	O
int	O
rl_forward_byte	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_backward_byte	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
int	O
end	int
,	O
lend	int
;	O
end	int
=	O
rl_point	int
+	O
count	int
;	O
lend	int
=	O
rl_end	int
>	O
0	int
?	O
rl_end	int
-	O
(	O
VI_COMMAND_MODE	O
(	O
)	O
)	O
:	O
rl_end	int
;	O
if	O
(	O
end	int
>	O
lend	int
)	O
{	O
rl_point	int
=	O
lend	int
;	O
rl_ding	function
(	O
)	O
;	O
}	O
else	O
rl_point	int
=	O
end	int
;	O
}	O
if	O
(	O
rl_end	int
<	O
0	int
)	O
rl_end	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
_rl_forward_char_internal	function
(	O
count	int
)	O
int	O
count	int
;	O
{	O
int	O
point	int
;	O
point	int
=	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
count	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
if	O
(	O
point	int
>=	O
rl_end	int
&&	O
VI_COMMAND_MODE	O
(	O
)	O
)	O
point	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_end	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
if	O
(	O
rl_end	int
<	O
0	int
)	O
rl_end	int
=	O
0	int
;	O
return	O
(	O
point	int
)	O
;	O
}	O
int	O
rl_forward_char	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
point	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
return	O
(	O
rl_forward_byte	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_backward_char	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
EMACS_MODE	O
(	O
)	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
point	int
=	O
_rl_forward_char_internal	function
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
==	O
point	int
)	O
rl_ding	function
(	O
)	O
;	O
rl_point	int
=	O
point	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_forward	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_forward_char	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_backward_byte	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_forward_byte	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
if	O
(	O
rl_point	int
<	O
count	int
)	O
{	O
rl_point	int
=	O
0	int
;	O
rl_ding	function
(	O
)	O
;	O
}	O
else	O
rl_point	int
-=	O
count	int
;	O
}	O
if	O
(	O
rl_point	int
<	O
0	int
)	O
rl_point	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_backward_char	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
point	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
return	O
(	O
rl_backward_byte	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_forward_char	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
point	int
=	O
rl_point	int
;	O
while	O
(	O
count	int
>	O
0	int
&&	O
point	int
>	O
0	int
)	O
{	O
point	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
count	int
--	O
;	O
}	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
rl_point	int
=	O
0	int
;	O
rl_ding	function
(	O
)	O
;	O
}	O
else	O
rl_point	int
=	O
point	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_backward	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_backward_char	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_beg_of_line	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_point	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_end_of_line	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_point	int
=	O
rl_end	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_forward_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_backward_word	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
return	O
0	int
;	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
==	O
0	int
)	O
{	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
)	O
break	O
;	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
}	O
}	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
return	O
0	int
;	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
==	O
0	int
)	O
break	O
;	O
rl_point	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
}	O
--	O
count	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_backward_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
p	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_forward_word	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
return	O
0	int
;	O
p	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
p	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
==	O
0	int
)	O
{	O
rl_point	int
=	O
p	int
;	O
while	O
(	O
rl_point	int
>	O
0	int
)	O
{	O
p	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
p	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
)	O
break	O
;	O
rl_point	int
=	O
p	int
;	O
}	O
}	O
while	O
(	O
rl_point	int
)	O
{	O
p	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
p	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
==	O
0	int
)	O
break	O
;	O
else	O
rl_point	int
=	O
p	int
;	O
}	O
--	O
count	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_refresh_line	function
(	O
ignore1	int
,	O
ignore2	int
)	O
int	O
ignore1	int
,	O
ignore2	int
;	O
{	O
int	O
curr_line	int
;	O
curr_line	int
=	O
_rl_current_display_line	function
(	O
)	O
;	O
_rl_move_vert	function
(	O
curr_line	int
)	O
;	O
_rl_move_cursor_relative	function
(	O
0	int
,	O
rl_line_buffer	pointer
)	O
;	O
_rl_clear_to_eol	function
(	O
0	int
)	O
;	O
rl_redraw_prompt_last_line	function
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_clear_screen	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
)	O
{	O
rl_refresh_line	function
(	O
count	int
,	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
_rl_clear_screen	function
(	O
)	O
;	O
rl_forced_update_display	function
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_skip_csi_sequence	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
do	O
ch	int
=	O
rl_read_key	function
(	O
)	O
;	O
while	O
(	O
ch	int
>=	O
0x20	int
&&	O
ch	int
<	O
0x40	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
return	O
(	O
ch	int
<	O
0	int
)	O
;	O
}	O
int	O
rl_arrow_keys	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
ch	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
ch	int
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
switch	O
(	O
_rl_to_upper	function
(	O
ch	int
)	O
)	O
{	O
case	O
'A'	O
:	O
rl_get_previous_history	function
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
rl_get_next_history	function
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_forward_char	function
(	O
count	int
,	O
ch	int
)	O
;	O
else	O
rl_forward_byte	function
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_backward_char	function
(	O
count	int
,	O
ch	int
)	O
;	O
else	O
rl_backward_byte	function
(	O
count	int
,	O
ch	int
)	O
;	O
break	O
;	O
default	O
:	O
rl_ding	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
pending_bytes	array
[	O
MB_LEN_MAX	int
]	O
;	O
static	O
int	O
pending_bytes_length	int
=	O
0	int
;	O
static	O
mbstate_t	struct
ps	struct
=	O
{	O
0	int
}	O
;	O
int	O
_rl_insert_char	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
string	pointer
;	O
int	O
string_size	int
;	O
char	O
incoming	array
[	O
MB_LEN_MAX	int
+	O
1	int
]	O
;	O
int	O
incoming_length	int
=	O
0	int
;	O
mbstate_t	struct
ps_back	struct
;	O
static	O
int	O
stored_count	int
=	O
0	int
;	O
if	O
(	O
count	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
{	O
incoming	array
[	O
0	int
]	O
=	O
c	int
;	O
incoming	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
1	int
;	O
}	O
else	O
{	O
wchar_t	int
wc	int
;	O
size_t	long
ret	long
;	O
if	O
(	O
stored_count	int
<=	O
0	int
)	O
stored_count	int
=	O
count	int
;	O
else	O
count	int
=	O
stored_count	int
;	O
ps_back	struct
=	O
ps	struct
;	O
pending_bytes	array
[	O
pending_bytes_length	int
++	O
]	O
=	O
c	int
;	O
ret	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
pending_bytes	array
,	O
pending_bytes_length	int
,	O
&	O
ps	struct
)	O
;	O
if	O
(	O
ret	long
==	O
(	O
size_t	long
)	O
-	O
2	int
)	O
{	O
ps	struct
=	O
ps_back	struct
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
ret	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
incoming	array
[	O
0	int
]	O
=	O
pending_bytes	array
[	O
0	int
]	O
;	O
incoming	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
1	int
;	O
pending_bytes_length	int
--	O
;	O
memmove	function
(	O
pending_bytes	array
,	O
pending_bytes	array
+	O
1	int
,	O
pending_bytes_length	int
)	O
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ret	long
==	O
(	O
size_t	long
)	O
0	int
)	O
{	O
incoming	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
0	int
;	O
pending_bytes_length	int
--	O
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
incoming	array
,	O
pending_bytes	array
,	O
pending_bytes_length	int
)	O
;	O
incoming	array
[	O
pending_bytes_length	int
]	O
=	O
'\0'	O
;	O
incoming_length	int
=	O
pending_bytes_length	int
;	O
pending_bytes_length	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
count	int
>	O
1	int
&&	O
count	int
<=	O
TEXT_COUNT_MAX	int
)	O
{	O
string_size	int
=	O
count	int
*	O
incoming_length	int
;	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
string_size	int
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
string_size	int
)	O
{	O
strncpy	function
(	O
string	pointer
+	O
i	int
,	O
incoming	array
,	O
incoming_length	int
)	O
;	O
i	int
+=	O
incoming_length	int
;	O
}	O
incoming_length	int
=	O
0	int
;	O
stored_count	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
rl_insert_text	function
(	O
string	pointer
)	O
;	O
xfree	function
(	O
string	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
count	int
>	O
TEXT_COUNT_MAX	int
)	O
{	O
int	O
decreaser	int
;	O
string_size	int
=	O
incoming_length	int
*	O
TEXT_COUNT_MAX	int
;	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
string_size	int
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
string_size	int
)	O
{	O
strncpy	function
(	O
string	pointer
+	O
i	int
,	O
incoming	array
,	O
incoming_length	int
)	O
;	O
i	int
+=	O
incoming_length	int
;	O
}	O
while	O
(	O
count	int
)	O
{	O
decreaser	int
=	O
(	O
count	int
>	O
TEXT_COUNT_MAX	int
)	O
?	O
TEXT_COUNT_MAX	int
:	O
count	int
;	O
string	pointer
[	O
decreaser	int
*	O
incoming_length	int
]	O
=	O
'\0'	O
;	O
rl_insert_text	function
(	O
string	pointer
)	O
;	O
count	int
-=	O
decreaser	int
;	O
}	O
xfree	function
(	O
string	pointer
)	O
;	O
incoming_length	int
=	O
0	int
;	O
stored_count	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
{	O
if	O
(	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
==	O
0	int
)	O
&&	O
_rl_pushed_input_available	function
(	O
)	O
)	O
_rl_insert_typein	function
(	O
c	int
)	O
;	O
else	O
{	O
char	O
str	array
[	O
2	int
]	O
;	O
str	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
str	array
[	O
0	int
]	O
=	O
c	int
;	O
rl_insert_text	function
(	O
str	array
)	O
;	O
}	O
}	O
else	O
{	O
rl_insert_text	function
(	O
incoming	array
)	O
;	O
stored_count	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_rl_overwrite_char	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
i	int
;	O
char	O
mbkey	array
[	O
MB_LEN_MAX	int
]	O
;	O
int	O
k	int
;	O
if	O
(	O
count	int
>	O
0	int
&&	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
k	int
=	O
_rl_read_mbstring	function
(	O
c	int
,	O
mbkey	array
,	O
MB_LEN_MAX	int
)	O
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_insert_text	function
(	O
mbkey	array
)	O
;	O
else	O
_rl_insert_char	function
(	O
1	int
,	O
c	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
rl_delete	function
(	O
1	int
,	O
c	int
)	O
;	O
}	O
rl_end_undo_group	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_insert	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
r	int
,	O
n	int
,	O
x	int
;	O
r	int
=	O
(	O
rl_insert_mode	int
==	O
RL_IM_INSERT	int
)	O
?	O
_rl_insert_char	function
(	O
count	int
,	O
c	int
)	O
:	O
_rl_overwrite_char	function
(	O
count	int
,	O
c	int
)	O
;	O
x	int
=	O
0	int
;	O
n	int
=	O
(	O
unsigned	O
short	O
)	O
-	O
2	int
;	O
while	O
(	O
_rl_optimize_typeahead	int
&&	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_INPUTPENDING	int
|	O
RL_STATE_MACROINPUT	int
)	O
==	O
0	int
)	O
&&	O
_rl_pushed_input_available	function
(	O
)	O
==	O
0	int
&&	O
_rl_input_queued	function
(	O
0	int
)	O
&&	O
(	O
n	int
=	O
rl_read_key	function
(	O
)	O
)	O
>	O
0	int
&&	O
_rl_keymap	pointer
[	O
(	O
unsigned	O
char	O
)	O
n	int
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
_rl_keymap	pointer
[	O
(	O
unsigned	O
char	O
)	O
n	int
]	O
.	O
function	pointer
==	O
rl_insert	function
)	O
{	O
r	int
=	O
(	O
rl_insert_mode	int
==	O
RL_IM_INSERT	int
)	O
?	O
_rl_insert_char	function
(	O
1	int
,	O
n	int
)	O
:	O
_rl_overwrite_char	function
(	O
1	int
,	O
n	int
)	O
;	O
n	int
=	O
(	O
unsigned	O
short	O
)	O
-	O
2	int
;	O
x	int
++	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
continue	O
;	O
if	O
(	O
rl_done	int
||	O
r	int
!=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
n	int
!=	O
(	O
unsigned	O
short	O
)	O
-	O
2	int
)	O
{	O
rl_last_func	pointer
=	O
rl_insert	function
;	O
_rl_reset_argument	function
(	O
)	O
;	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
r	int
=	O
rl_execute_next	function
(	O
n	int
)	O
;	O
}	O
return	O
r	int
;	O
}	O
static	O
int	O
_rl_insert_next	function
(	O
count	int
)	O
int	O
count	int
;	O
{	O
int	O
c	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
)	O
_rl_add_macro_char	function
(	O
c	int
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
==	O
0	int
)	O
_rl_restore_tty_signals	function
(	O
)	O
;	O
return	O
(	O
_rl_insert_char	function
(	O
count	int
,	O
c	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_insert_next_callback	function
(	O
data	pointer
)	O
_rl_callback_generic_arg	struct
*	O
data	pointer
;	O
{	O
int	O
count	int
;	O
count	int
=	O
data	pointer
->	O
count	int
;	O
_rl_callback_func	pointer
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
_rl_insert_next	function
(	O
count	int
)	O
;	O
}	O
int	O
rl_quoted_insert	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
==	O
0	int
)	O
_rl_disable_tty_signals	function
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
_rl_callback_data_alloc	function
(	O
count	int
)	O
;	O
_rl_callback_func	pointer
=	O
_rl_insert_next_callback	function
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
_rl_insert_next	function
(	O
count	int
)	O
;	O
}	O
int	O
rl_tab_insert	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
_rl_insert_char	function
(	O
count	int
,	O
'\t'	O
)	O
)	O
;	O
}	O
int	O
rl_newline	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_done	int
=	O
1	int
;	O
if	O
(	O
_rl_history_preserve_point	int
)	O
_rl_history_saved_point	int
=	O
(	O
rl_point	int
==	O
rl_end	int
)	O
?	O
-	O
1	int
:	O
rl_point	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_DONE	int
)	O
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
{	O
_rl_vi_done_inserting	function
(	O
)	O
;	O
if	O
(	O
_rl_vi_textmod_command	function
(	O
_rl_vi_last_command	int
)	O
==	O
0	int
)	O
_rl_vi_reset_last	function
(	O
)	O
;	O
}	O
if	O
(	O
rl_erase_empty_line	int
&&	O
rl_point	int
==	O
0	int
&&	O
rl_end	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
_rl_echoing_p	int
)	O
_rl_update_final	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_do_lowercase_version	function
(	O
ignore1	int
,	O
ignore2	int
)	O
int	O
ignore1	int
,	O
ignore2	int
;	O
{	O
return	O
0	int
;	O
}	O
int	O
_rl_overwrite_rubout	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
opoint	int
;	O
int	O
i	int
,	O
l	int
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
opoint	int
=	O
rl_point	int
;	O
for	O
(	O
i	int
=	O
l	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
rl_backward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
l	int
+=	O
rl_character_len	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
,	O
rl_point	int
)	O
;	O
}	O
rl_begin_undo_group	function
(	O
)	O
;	O
if	O
(	O
count	int
>	O
1	int
||	O
rl_explicit_arg	int
)	O
rl_kill_text	function
(	O
opoint	int
,	O
rl_point	int
)	O
;	O
else	O
rl_delete_text	function
(	O
opoint	int
,	O
rl_point	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
opoint	int
=	O
rl_point	int
;	O
_rl_insert_char	function
(	O
l	int
,	O
' '	O
)	O
;	O
rl_point	int
=	O
opoint	int
;	O
}	O
rl_end_undo_group	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_rubout	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_delete	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
!	O
rl_point	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
rl_insert_mode	int
==	O
RL_IM_OVERWRITE	int
)	O
return	O
(	O
_rl_overwrite_rubout	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
return	O
(	O
_rl_rubout_char	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
_rl_rubout_char	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
orig_point	int
;	O
unsigned	O
char	O
c	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_delete	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
orig_point	int
=	O
rl_point	int
;	O
if	O
(	O
count	int
>	O
1	int
||	O
rl_explicit_arg	int
)	O
{	O
rl_backward_char	function
(	O
count	int
,	O
key	int
)	O
;	O
rl_kill_text	function
(	O
orig_point	int
,	O
rl_point	int
)	O
;	O
}	O
else	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
{	O
c	int
=	O
rl_line_buffer	pointer
[	O
--	O
rl_point	int
]	O
;	O
rl_delete_text	function
(	O
rl_point	int
,	O
orig_point	int
)	O
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
ISPRINT	O
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
&&	O
_rl_last_c_pos	int
)	O
{	O
int	O
l	int
;	O
l	int
=	O
rl_character_len	function
(	O
c	int
,	O
rl_point	int
)	O
;	O
_rl_erase_at_end_of_line	function
(	O
l	int
)	O
;	O
}	O
}	O
else	O
{	O
rl_point	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
rl_delete_text	function
(	O
rl_point	int
,	O
orig_point	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_delete	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
xpoint	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
_rl_rubout_char	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
count	int
>	O
1	int
||	O
rl_explicit_arg	int
)	O
{	O
xpoint	int
=	O
rl_point	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_forward_char	function
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_forward_byte	function
(	O
count	int
,	O
key	int
)	O
;	O
rl_kill_text	function
(	O
xpoint	int
,	O
rl_point	int
)	O
;	O
rl_point	int
=	O
xpoint	int
;	O
}	O
else	O
{	O
xpoint	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
rl_delete_text	function
(	O
rl_point	int
,	O
xpoint	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_rubout_or_delete	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_end	int
!=	O
0	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
return	O
(	O
_rl_rubout_char	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
else	O
return	O
(	O
rl_delete	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_delete_horizontal_space	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
int	O
start	int
;	O
while	O
(	O
rl_point	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
start	int
=	O
rl_point	int
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
if	O
(	O
start	int
!=	O
rl_point	int
)	O
{	O
rl_delete_text	function
(	O
start	int
,	O
rl_point	int
)	O
;	O
rl_point	int
=	O
start	int
;	O
}	O
if	O
(	O
rl_point	int
<	O
0	int
)	O
rl_point	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_delete_or_show_completions	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_end	int
!=	O
0	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
return	O
(	O
rl_possible_completions	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
else	O
return	O
(	O
rl_delete	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_insert_comment	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
char	O
*	O
rl_comment_text	pointer
;	O
int	O
rl_comment_len	int
;	O
rl_beg_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
rl_comment_text	pointer
=	O
_rl_comment_begin	pointer
?	O
_rl_comment_begin	pointer
:	O
RL_COMMENT_BEGIN_DEFAULT	pointer
;	O
if	O
(	O
rl_explicit_arg	int
==	O
0	int
)	O
rl_insert_text	function
(	O
rl_comment_text	pointer
)	O
;	O
else	O
{	O
rl_comment_len	int
=	O
strlen	function
(	O
rl_comment_text	pointer
)	O
;	O
if	O
(	O
STREQN	O
(	O
rl_comment_text	pointer
,	O
rl_line_buffer	pointer
,	O
rl_comment_len	int
)	O
)	O
rl_delete_text	function
(	O
rl_point	int
,	O
rl_point	int
+	O
rl_comment_len	int
)	O
;	O
else	O
rl_insert_text	function
(	O
rl_comment_text	pointer
)	O
;	O
}	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
rl_newline	function
(	O
1	int
,	O
'\n'	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_upcase_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_change_case	function
(	O
count	int
,	O
UpCase	int
)	O
)	O
;	O
}	O
int	O
rl_downcase_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_change_case	function
(	O
count	int
,	O
DownCase	int
)	O
)	O
;	O
}	O
int	O
rl_capitalize_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_change_case	function
(	O
count	int
,	O
CapCase	int
)	O
)	O
;	O
}	O
static	O
int	O
rl_change_case	function
(	O
count	int
,	O
op	int
)	O
int	O
count	int
,	O
op	int
;	O
{	O
int	O
start	int
,	O
next	pointer
,	O
end	int
;	O
int	O
inword	int
,	O
c	int
,	O
nc	int
,	O
nop	int
;	O
wchar_t	int
wc	int
,	O
nwc	int
;	O
char	O
mb	array
[	O
MB_LEN_MAX	int
+	O
1	int
]	O
;	O
int	O
mlen	int
;	O
size_t	long
m	long
;	O
mbstate_t	struct
mps	struct
;	O
start	int
=	O
rl_point	int
;	O
rl_forward_word	function
(	O
count	int
,	O
0	int
)	O
;	O
end	int
=	O
rl_point	int
;	O
if	O
(	O
op	int
!=	O
UpCase	int
&&	O
op	int
!=	O
DownCase	int
&&	O
op	int
!=	O
CapCase	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
count	int
<	O
0	int
)	O
SWAP	O
(	O
start	int
,	O
end	int
)	O
;	O
memset	function
(	O
&	O
mps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
rl_modifying	function
(	O
start	int
,	O
end	int
)	O
;	O
inword	int
=	O
0	int
;	O
while	O
(	O
start	int
<	O
end	int
)	O
{	O
c	int
=	O
_rl_char_value	function
(	O
rl_line_buffer	pointer
,	O
start	int
)	O
;	O
next	pointer
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
start	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
if	O
(	O
_rl_walphabetic	function
(	O
c	int
)	O
==	O
0	int
)	O
{	O
inword	int
=	O
0	int
;	O
start	int
=	O
next	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
op	int
==	O
CapCase	int
)	O
{	O
nop	int
=	O
inword	int
?	O
DownCase	int
:	O
UpCase	int
;	O
inword	int
=	O
1	int
;	O
}	O
else	O
nop	int
=	O
op	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
||	O
isascii	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
{	O
nc	int
=	O
(	O
nop	int
==	O
UpCase	int
)	O
?	O
_rl_to_upper	function
(	O
c	int
)	O
:	O
_rl_to_lower	function
(	O
c	int
)	O
;	O
rl_line_buffer	pointer
[	O
start	int
]	O
=	O
nc	int
;	O
}	O
else	O
{	O
m	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
rl_line_buffer	pointer
+	O
start	int
,	O
end	int
-	O
start	int
,	O
&	O
mps	struct
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
(	O
wchar_t	int
)	O
rl_line_buffer	pointer
[	O
start	int
]	O
;	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
L'\0'	O
;	O
nwc	int
=	O
(	O
nop	int
==	O
UpCase	int
)	O
?	O
_rl_to_wupper	O
(	O
wc	int
)	O
:	O
_rl_to_wlower	O
(	O
wc	int
)	O
;	O
if	O
(	O
nwc	int
!=	O
wc	int
)	O
{	O
mlen	int
=	O
wcrtomb	function
(	O
mb	array
,	O
nwc	int
,	O
&	O
mps	struct
)	O
;	O
if	O
(	O
mlen	int
>	O
0	int
)	O
mb	array
[	O
mlen	int
]	O
=	O
'\0'	O
;	O
strncpy	function
(	O
rl_line_buffer	pointer
+	O
start	int
,	O
mb	array
,	O
mlen	int
)	O
;	O
}	O
}	O
start	int
=	O
next	pointer
;	O
}	O
rl_point	int
=	O
end	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_transpose_words	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
char	O
*	O
word1	pointer
,	O
*	O
word2	pointer
;	O
int	O
w1_beg	int
,	O
w1_end	int
,	O
w2_beg	int
,	O
w2_end	int
;	O
int	O
orig_point	int
=	O
rl_point	int
;	O
if	O
(	O
!	O
count	int
)	O
return	O
0	int
;	O
rl_forward_word	function
(	O
count	int
,	O
key	int
)	O
;	O
w2_end	int
=	O
rl_point	int
;	O
rl_backward_word	function
(	O
1	int
,	O
key	int
)	O
;	O
w2_beg	int
=	O
rl_point	int
;	O
rl_backward_word	function
(	O
count	int
,	O
key	int
)	O
;	O
w1_beg	int
=	O
rl_point	int
;	O
rl_forward_word	function
(	O
1	int
,	O
key	int
)	O
;	O
w1_end	int
=	O
rl_point	int
;	O
if	O
(	O
(	O
w1_beg	int
==	O
w2_beg	int
)	O
||	O
(	O
w2_beg	int
<	O
w1_end	int
)	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
rl_point	int
=	O
orig_point	int
;	O
return	O
1	int
;	O
}	O
word1	pointer
=	O
rl_copy_text	function
(	O
w1_beg	int
,	O
w1_end	int
)	O
;	O
word2	pointer
=	O
rl_copy_text	function
(	O
w2_beg	int
,	O
w2_end	int
)	O
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_point	int
=	O
w2_beg	int
;	O
rl_delete_text	function
(	O
w2_beg	int
,	O
w2_end	int
)	O
;	O
rl_insert_text	function
(	O
word1	pointer
)	O
;	O
rl_point	int
=	O
w1_beg	int
;	O
rl_delete_text	function
(	O
w1_beg	int
,	O
w1_end	int
)	O
;	O
rl_insert_text	function
(	O
word2	pointer
)	O
;	O
rl_point	int
=	O
w2_end	int
;	O
rl_end_undo_group	function
(	O
)	O
;	O
xfree	function
(	O
word1	pointer
)	O
;	O
xfree	function
(	O
word2	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_transpose_chars	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
char	O
*	O
dummy	pointer
;	O
int	O
i	int
;	O
int	O
char_length	int
,	O
prev_point	int
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
rl_point	int
||	O
rl_end	int
<	O
2	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
rl_begin_undo_group	function
(	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
)	O
{	O
rl_point	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
count	int
=	O
1	int
;	O
}	O
prev_point	int
=	O
rl_point	int
;	O
rl_point	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
char_length	int
=	O
prev_point	int
-	O
rl_point	int
;	O
dummy	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
char_length	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
char_length	int
;	O
i	int
++	O
)	O
dummy	pointer
[	O
i	int
]	O
=	O
rl_line_buffer	pointer
[	O
rl_point	int
+	O
i	int
]	O
;	O
dummy	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
rl_delete_text	function
(	O
rl_point	int
,	O
rl_point	int
+	O
char_length	int
)	O
;	O
rl_point	int
=	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
count	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
_rl_fix_point	function
(	O
0	int
)	O
;	O
rl_insert_text	function
(	O
dummy	pointer
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
xfree	function
(	O
dummy	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
_rl_char_search_internal	function
(	O
count	int
,	O
dir	int
,	O
smbchar	pointer
,	O
len	int
)	O
int	O
count	int
,	O
dir	int
;	O
char	O
*	O
smbchar	pointer
;	O
int	O
len	int
;	O
{	O
int	O
pos	int
,	O
inc	int
;	O
int	O
prepos	int
;	O
if	O
(	O
dir	int
==	O
0	int
)	O
return	O
1	int
;	O
pos	int
=	O
rl_point	int
;	O
inc	int
=	O
(	O
dir	int
<	O
0	int
)	O
?	O
-	O
1	int
:	O
1	int
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
(	O
dir	int
<	O
0	int
&&	O
pos	int
<=	O
0	int
)	O
||	O
(	O
dir	int
>	O
0	int
&&	O
pos	int
>=	O
rl_end	int
)	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
pos	int
=	O
(	O
inc	int
>	O
0	int
)	O
?	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
:	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
;	O
do	O
{	O
if	O
(	O
_rl_is_mbchar_matched	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
rl_end	int
,	O
smbchar	pointer
,	O
len	int
)	O
)	O
{	O
count	int
--	O
;	O
if	O
(	O
dir	int
<	O
0	int
)	O
rl_point	int
=	O
(	O
dir	int
==	O
BTO	O
)	O
?	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
:	O
pos	int
;	O
else	O
rl_point	int
=	O
(	O
dir	int
==	O
FTO	int
)	O
?	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
:	O
pos	int
;	O
break	O
;	O
}	O
prepos	int
=	O
pos	int
;	O
}	O
while	O
(	O
(	O
dir	int
<	O
0	int
)	O
?	O
(	O
pos	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
)	O
!=	O
prepos	int
:	O
(	O
pos	int
=	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
)	O
!=	O
prepos	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_char_search	function
(	O
count	int
,	O
fdir	int
,	O
bdir	int
)	O
int	O
count	int
,	O
fdir	int
,	O
bdir	int
;	O
{	O
char	O
mbchar	array
[	O
MB_LEN_MAX	int
]	O
;	O
int	O
mb_len	int
;	O
mb_len	int
=	O
_rl_read_mbchar	function
(	O
mbchar	array
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
mb_len	int
<=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
_rl_char_search_internal	function
(	O
-	O
count	int
,	O
bdir	int
,	O
mbchar	array
,	O
mb_len	int
)	O
)	O
;	O
else	O
return	O
(	O
_rl_char_search_internal	function
(	O
count	int
,	O
fdir	int
,	O
mbchar	array
,	O
mb_len	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_char_search_callback	function
(	O
data	pointer
)	O
_rl_callback_generic_arg	struct
*	O
data	pointer
;	O
{	O
_rl_callback_func	pointer
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_char_search	function
(	O
data	pointer
->	O
count	int
,	O
data	pointer
->	O
i1	int
,	O
data	pointer
->	O
i2	int
)	O
)	O
;	O
}	O
int	O
rl_char_search	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
_rl_callback_data_alloc	function
(	O
count	int
)	O
;	O
_rl_callback_data	pointer
->	O
i1	int
=	O
FFIND	int
;	O
_rl_callback_data	pointer
->	O
i2	int
=	O
BFIND	O
;	O
_rl_callback_func	pointer
=	O
_rl_char_search_callback	function
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_char_search	function
(	O
count	int
,	O
FFIND	int
,	O
BFIND	O
)	O
)	O
;	O
}	O
int	O
rl_backward_char_search	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
_rl_callback_data_alloc	function
(	O
count	int
)	O
;	O
_rl_callback_data	pointer
->	O
i1	int
=	O
BFIND	O
;	O
_rl_callback_data	pointer
->	O
i2	int
=	O
FFIND	int
;	O
_rl_callback_func	pointer
=	O
_rl_char_search_callback	function
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_char_search	function
(	O
count	int
,	O
BFIND	O
,	O
FFIND	int
)	O
)	O
;	O
}	O
int	O
_rl_set_mark_at_pos	function
(	O
position	int
)	O
int	O
position	int
;	O
{	O
if	O
(	O
position	int
>	O
rl_end	int
)	O
return	O
1	int
;	O
rl_mark	int
=	O
position	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_set_mark	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
_rl_set_mark_at_pos	function
(	O
rl_explicit_arg	int
?	O
count	int
:	O
rl_point	int
)	O
)	O
;	O
}	O
int	O
rl_exchange_point_and_mark	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_mark	int
>	O
rl_end	int
)	O
rl_mark	int
=	O
-	O
1	int
;	O
if	O
(	O
rl_mark	int
==	O
-	O
1	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
SWAP	O
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
return	O
0	int
;	O
}	O
