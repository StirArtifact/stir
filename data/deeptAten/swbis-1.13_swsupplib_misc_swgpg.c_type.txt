static	O
char	O
*	O
g_swgpg_dirname	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
g_swgpg_fifopath	pointer
=	O
NULL	O
;	O
static	O
int	O
swgpg_passfd	int
;	O
static	O
int	O
get_stderr_fd	function
(	O
void	O
)	O
{	O
return	O
STDERR_FILENO	int
;	O
}	O
static	O
void	O
close_passfd	function
(	O
void	O
)	O
{	O
if	O
(	O
swgpg_passfd	int
>=	O
0	int
)	O
{	O
if	O
(	O
close	pointer
(	O
swgpg_passfd	int
)	O
<	O
0	int
)	O
{	O
;	O
}	O
}	O
}	O
static	O
char	O
*	O
make_dir	function
(	O
char	O
*	O
*	O
ma	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
template	pointer
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
sret	pointer
;	O
mode_t	int
um	int
;	O
int	O
try	int
;	O
const	O
int	O
max_tries	int
=	O
10	int
;	O
E_DEBUG	O
(	O
"begin using mkdtemp"	pointer
)	O
;	O
template	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
SWGPG_FIFO_DIR	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
SWGPG_FIFO_PFX	pointer
)	O
+	O
8	int
)	O
;	O
if	O
(	O
!	O
template	pointer
)	O
return	O
NULL	O
;	O
*	O
ma	pointer
=	O
template	pointer
;	O
strcpy	function
(	O
template	pointer
,	O
SWGPG_FIFO_DIR	pointer
)	O
;	O
strcat	function
(	O
template	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
template	pointer
,	O
SWGPG_FIFO_PFX	pointer
)	O
;	O
strcat	function
(	O
template	pointer
,	O
"XXXXXX"	pointer
)	O
;	O
filename	pointer
=	O
mkdtemp	function
(	O
template	pointer
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: mkdtemp error for template [%s]: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
template	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
E_DEBUG2	O
(	O
"end using mkdtemp: filename=[%s]"	pointer
,	O
filename	pointer
)	O
;	O
return	O
filename	pointer
;	O
}	O
static	O
SHCMD	struct
*	O
gpg_fifo_command	function
(	O
char	O
*	O
fifofilename	pointer
,	O
char	O
*	O
gpg_prog	pointer
,	O
int	O
uverbose	int
,	O
int	O
logger_fd	int
)	O
{	O
char	O
*	O
absname	pointer
;	O
SHCMD	struct
*	O
cmd	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
cmd	int
=	O
shcmd_open	function
(	O
)	O
;	O
absname	pointer
=	O
shcmd_find_in_path	function
(	O
getenv	function
(	O
"PATH"	pointer
)	O
,	O
gpg_prog	pointer
)	O
;	O
if	O
(	O
!	O
absname	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: %s: Not found in current path\n"	pointer
,	O
gpg_prog	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
uverbose	int
>=	O
3	int
)	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: using GNU Privacy Guard : %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
absname	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
shcmd_add_arg	function
(	O
cmd	int
,	O
absname	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
,	O
"--status-fd=1"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
logger_fd	int
!=	O
STDERR_FILENO	int
)	O
{	O
STROB	struct
*	O
x	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_sprintf	function
(	O
x	pointer
,	O
0	int
,	O
"--logger-fd=%d"	pointer
,	O
logger_fd	int
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
,	O
strob_str	function
(	O
x	pointer
)	O
)	O
;	O
strob_close	function
(	O
x	pointer
)	O
;	O
}	O
shcmd_add_arg	function
(	O
cmd	int
,	O
"--verify"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
,	O
fifofilename	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
,	O
"-"	pointer
)	O
;	O
if	O
(	O
uverbose	int
<	O
SWC_VERBOSE_2	int
)	O
{	O
shcmd_set_errfile	function
(	O
cmd	int
,	O
"/dev/null"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
cmd	int
;	O
}	O
static	O
int	O
get_number_of_blobs	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
)	O
{	O
int	O
n	int
=	O
0	int
;	O
while	O
(	O
strar_get	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
,	O
n	int
)	O
!=	O
NULL	O
)	O
{	O
n	int
++	O
;	O
}	O
return	O
n	int
;	O
}	O
static	O
int	O
make_pgp_env	function
(	O
char	O
*	O
env	array
[	O
]	O
,	O
int	O
len	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
valu	pointer
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
2	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
env	array
[	O
i	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
env	array
[	O
0	int
]	O
=	O
strdup	function
(	O
"PGPPASSFD=3"	pointer
)	O
;	O
valu	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
valu	pointer
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"HOME=%s"	pointer
,	O
valu	pointer
)	O
;	O
env	array
[	O
1	int
]	O
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
valu	pointer
=	O
getenv	function
(	O
"MYNAME"	pointer
)	O
;	O
if	O
(	O
valu	pointer
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"MYNAME=%s"	pointer
,	O
valu	pointer
)	O
;	O
env	array
[	O
2	int
]	O
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_does_use_gpg_agent	function
(	O
SHCMD	struct
*	O
cmd	int
)	O
{	O
char	O
*	O
*	O
args	pointer
;	O
char	O
*	O
arg	pointer
;	O
args	pointer
=	O
shcmd_get_argvector	function
(	O
cmd	int
)	O
;	O
arg	pointer
=	O
*	O
args	pointer
;	O
while	O
(	O
arg	pointer
)	O
{	O
if	O
(	O
strstr	function
(	O
arg	pointer
,	O
"--use-agent"	pointer
)	O
)	O
return	O
1	int
;	O
arg	pointer
=	O
*	O
(	O
++	O
args	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
swgpg_init_passphrase_fd	function
(	O
void	O
)	O
{	O
swgpg_set_passphrase_fd	function
(	O
-	O
1	int
)	O
;	O
}	O
void	O
swgpg_set_passphrase_fd	function
(	O
int	O
fd	int
)	O
{	O
swgpg_passfd	int
=	O
fd	int
;	O
}	O
int	O
swgpg_get_passphrase_fd	function
(	O
void	O
)	O
{	O
return	O
swgpg_passfd	int
;	O
}	O
SWGPG_VALIDATE	struct
*	O
swgpg_create	function
(	O
void	O
)	O
{	O
SWGPG_VALIDATE	struct
*	O
w	pointer
=	O
(	O
SWGPG_VALIDATE	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWGPG_VALIDATE	struct
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
w	pointer
)	O
return	O
NULL	O
;	O
w	pointer
->	O
gpg_prognameM	pointer
=	O
swlib_strdup	function
(	O
SWGPG_GPG_BIN	pointer
)	O
;	O
w	pointer
->	O
list_of_sigsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
w	pointer
->	O
list_of_sig_namesM	pointer
=	O
strar_open	function
(	O
)	O
;	O
w	pointer
->	O
list_of_status_blobsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
w	pointer
->	O
list_of_logger_blobsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
w	pointer
->	O
status_arrayM	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
return	O
w	pointer
;	O
}	O
void	O
swgpg_delete	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
free	function
(	O
w	pointer
->	O
gpg_prognameM	pointer
)	O
;	O
strar_close	function
(	O
w	pointer
->	O
list_of_sigsM	pointer
)	O
;	O
strar_close	function
(	O
w	pointer
->	O
list_of_sig_namesM	pointer
)	O
;	O
strar_close	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
)	O
;	O
strar_close	function
(	O
w	pointer
->	O
list_of_logger_blobsM	pointer
)	O
;	O
strob_close	function
(	O
w	pointer
->	O
status_arrayM	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
}	O
int	O
swgpg_show_all_signatures	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
n	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
n	int
=	O
0	int
;	O
while	O
(	O
strar_get	function
(	O
w	pointer
->	O
list_of_sigsM	pointer
,	O
n	int
)	O
!=	O
NULL	O
)	O
{	O
swlib_writef	function
(	O
fd	int
,	O
tmp	pointer
,	O
"%s%s"	pointer
,	O
strar_get	function
(	O
w	pointer
->	O
list_of_logger_blobsM	pointer
,	O
n	int
)	O
,	O
strar_get	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
,	O
n	int
)	O
)	O
;	O
n	int
++	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swgpg_show	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
,	O
int	O
index	function
,	O
int	O
sig_fd	int
,	O
int	O
status_fd	int
,	O
int	O
logger_fd	int
)	O
{	O
int	O
n	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
num	int
;	O
char	O
*	O
s	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
num	int
=	O
get_number_of_blobs	function
(	O
w	pointer
)	O
;	O
E_DEBUG2	O
(	O
"index is %d"	pointer
,	O
index	function
)	O
;	O
E_DEBUG2	O
(	O
"number of sigs is %d"	pointer
,	O
num	int
)	O
;	O
if	O
(	O
index	function
<	O
0	int
||	O
index	function
>=	O
num	int
)	O
return	O
-	O
1	int
;	O
n	int
=	O
index	function
;	O
s	pointer
=	O
strar_get	function
(	O
w	pointer
->	O
list_of_logger_blobsM	pointer
,	O
n	int
)	O
;	O
if	O
(	O
logger_fd	int
>	O
0	int
&&	O
s	pointer
)	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
s	pointer
=	O
strar_get	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
,	O
n	int
)	O
;	O
if	O
(	O
status_fd	int
>	O
0	int
)	O
swlib_writef	function
(	O
status_fd	int
,	O
tmp	pointer
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
s	pointer
=	O
strar_get	function
(	O
w	pointer
->	O
list_of_sigsM	pointer
,	O
n	int
)	O
;	O
if	O
(	O
sig_fd	int
>	O
0	int
)	O
swlib_writef	function
(	O
sig_fd	int
,	O
tmp	pointer
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
swgpg_reset	function
(	O
SWGPG_VALIDATE	struct
*	O
swgpg	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strar_reset	function
(	O
swgpg	pointer
->	O
list_of_sigsM	pointer
)	O
;	O
strar_reset	function
(	O
swgpg	pointer
->	O
list_of_sig_namesM	pointer
)	O
;	O
strar_reset	function
(	O
swgpg	pointer
->	O
list_of_status_blobsM	pointer
)	O
;	O
strar_reset	function
(	O
swgpg	pointer
->	O
list_of_logger_blobsM	pointer
)	O
;	O
strob_strcpy	function
(	O
swgpg	pointer
->	O
status_arrayM	pointer
,	O
""	pointer
)	O
;	O
}	O
int	O
swgpg_get_status	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
,	O
int	O
index	function
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
strob_get_char	function
(	O
w	pointer
->	O
status_arrayM	pointer
,	O
index	function
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swgpg_get_number_of_sigs	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
)	O
{	O
int	O
n	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
strar_get	function
(	O
w	pointer
->	O
list_of_sigsM	pointer
,	O
n	int
)	O
!=	O
NULL	O
)	O
{	O
n	int
++	O
;	O
}	O
return	O
n	int
;	O
}	O
void	O
swgpg_set_status	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
,	O
int	O
index	function
,	O
int	O
value	int
)	O
{	O
strob_set_length	function
(	O
w	pointer
->	O
status_arrayM	pointer
,	O
index	function
+	O
1	int
)	O
;	O
*	O
(	O
strob_str	function
(	O
w	pointer
->	O
status_arrayM	pointer
)	O
+	O
index	function
)	O
=	O
(	O
unsigned	O
char	O
)	O
value	int
;	O
}	O
void	O
swgpg_set_status_array	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
)	O
{	O
char	O
*	O
sig	pointer
;	O
int	O
i	int
;	O
int	O
ret	int
;	O
strob_strcpy	function
(	O
w	pointer
->	O
status_arrayM	pointer
,	O
""	pointer
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
sig	pointer
=	O
strar_get	function
(	O
w	pointer
->	O
list_of_sigsM	pointer
,	O
i	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
ret	int
=	O
swgpg_determine_signature_status	function
(	O
strar_get	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
,	O
i	int
)	O
,	O
-	O
1	int
)	O
;	O
swgpg_set_status	function
(	O
w	pointer
,	O
i	int
,	O
ret	int
)	O
;	O
i	int
++	O
;	O
}	O
}	O
int	O
swgpg_disentangle_status_lines	function
(	O
SWGPG_VALIDATE	struct
*	O
w	pointer
,	O
char	O
*	O
gpg_output_lines	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
status_lines	pointer
;	O
STROB	struct
*	O
stderr_lines	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
status_lines	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
stderr_lines	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
gpg_output_lines	pointer
,	O
"\n\r"	pointer
)	O
;	O
while	O
(	O
line	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_PREFIX	pointer
)	O
==	O
line	pointer
)	O
{	O
strob_sprintf	function
(	O
status_lines	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
,	O
line	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
stderr_lines	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
,	O
line	pointer
)	O
;	O
}	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"\n\r"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strar_add	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
,	O
strob_str	function
(	O
status_lines	pointer
)	O
)	O
;	O
strar_add	function
(	O
w	pointer
->	O
list_of_logger_blobsM	pointer
,	O
strob_str	function
(	O
stderr_lines	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
status_lines	pointer
)	O
;	O
strob_close	function
(	O
stderr_lines	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
swgpg_create_fifo	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
dirname	pointer
;	O
char	O
*	O
freeit	pointer
=	O
NULL	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
g_swgpg_dirname	pointer
!=	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
g_swgpg_fifopath	pointer
!=	O
NULL	O
)	O
return	O
NULL	O
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
dirname	pointer
=	O
make_dir	function
(	O
&	O
freeit	pointer
)	O
;	O
if	O
(	O
!	O
dirname	pointer
)	O
return	O
NULL	O
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
dirname	pointer
)	O
;	O
g_swgpg_dirname	pointer
=	O
strdup	function
(	O
dirname	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
buf	pointer
,	O
SWGPG_FIFO_NAME	pointer
)	O
;	O
g_swgpg_fifopath	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
filename	pointer
=	O
g_swgpg_fifopath	pointer
;	O
if	O
(	O
filename	pointer
)	O
{	O
ret	int
=	O
mkfifo	function
(	O
filename	pointer
,	O
(	O
mode_t	int
)	O
(	O
0600	int
)	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
freeit	pointer
)	O
free	function
(	O
freeit	pointer
)	O
;	O
return	O
strob_str	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
swgpg_remove_fifo	function
(	O
void	O
)	O
{	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
g_swgpg_dirname	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
g_swgpg_fifopath	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
ret	int
=	O
unlink	function
(	O
g_swgpg_fifopath	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
free	function
(	O
g_swgpg_fifopath	pointer
)	O
;	O
g_swgpg_fifopath	pointer
=	O
NULL	O
;	O
ret	int
=	O
rmdir	function
(	O
g_swgpg_dirname	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
free	function
(	O
g_swgpg_dirname	pointer
)	O
;	O
g_swgpg_dirname	pointer
=	O
NULL	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swgpg_determine_signature_status	function
(	O
char	O
*	O
gpg_status_lines	pointer
,	O
int	O
which_sig	int
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
line	pointer
;	O
int	O
good_count	int
;	O
int	O
bad_count	int
;	O
int	O
nodata	int
;	O
int	O
nokey	int
;	O
E_DEBUG	O
(	O
"----------------------------------"	pointer
)	O
;	O
E_DEBUG	O
(	O
"----------------------------------"	pointer
)	O
;	O
E_DEBUG2	O
(	O
"%s"	pointer
,	O
gpg_status_lines	pointer
)	O
;	O
E_DEBUG	O
(	O
"----------------------------------"	pointer
)	O
;	O
E_DEBUG	O
(	O
"----------------------------------"	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
good_count	int
=	O
0	int
;	O
nodata	int
=	O
0	int
;	O
nokey	int
=	O
0	int
;	O
bad_count	int
=	O
0	int
;	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
gpg_status_lines	pointer
,	O
"\n\r"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
line	pointer
)	O
{	O
E_DEBUG2	O
(	O
"LINE=[%s]"	pointer
,	O
line	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_PREFIX	pointer
)	O
==	O
line	pointer
)	O
{	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_PREFIX	pointer
GPG_STATUS_GOODSIG	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"good_count++"	pointer
)	O
;	O
good_count	int
++	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_BADSIG	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"bad_count++"	pointer
)	O
;	O
bad_count	int
++	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_NO_PUBKEY	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"nokey++"	pointer
)	O
;	O
nokey	int
++	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_EXPSIG	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"bad_count++"	pointer
)	O
;	O
bad_count	int
++	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
GPG_STATUS_NODATA	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"no_data++"	pointer
)	O
;	O
nodata	int
++	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
{	O
;	O
E_DEBUG	O
(	O
"do_nothing"	pointer
)	O
;	O
}	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"\n\r"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
(	O
which_sig	int
<	O
0	int
&&	O
good_count	int
>=	O
1	int
&&	O
bad_count	int
==	O
0	int
&&	O
nokey	int
==	O
0	int
&&	O
nodata	int
==	O
0	int
)	O
||	O
(	O
which_sig	int
>=	O
0	int
&&	O
good_count	int
==	O
1	int
&&	O
bad_count	int
==	O
0	int
&&	O
nokey	int
==	O
0	int
&&	O
nodata	int
==	O
0	int
)	O
)	O
{	O
E_DEBUG	O
(	O
"return SWGPG_SIG_VALID"	pointer
)	O
;	O
return	O
SWGPG_SIG_VALID	int
;	O
}	O
else	O
if	O
(	O
good_count	int
==	O
0	int
&&	O
bad_count	int
==	O
0	int
&&	O
nokey	int
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"return SWGPG_SIG_NO_PUBKEY"	pointer
)	O
;	O
return	O
SWGPG_SIG_NO_PUBKEY	int
;	O
}	O
else	O
if	O
(	O
good_count	int
==	O
0	int
&&	O
bad_count	int
==	O
0	int
&&	O
nodata	int
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"return SWGPG_SIG_NODATA"	pointer
)	O
;	O
return	O
SWGPG_SIG_NODATA	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"return SWGPG_SIG_NOT_VALID"	pointer
)	O
;	O
return	O
SWGPG_SIG_NOT_VALID	int
;	O
}	O
E_DEBUG	O
(	O
"return SWGPG_SIG_ERROR"	pointer
)	O
;	O
return	O
SWGPG_SIG_ERROR	int
;	O
}	O
int	O
swgpg_run_checksig2	function
(	O
char	O
*	O
sigfilename	pointer
,	O
char	O
*	O
thisprog	pointer
,	O
char	O
*	O
filearg	pointer
,	O
char	O
*	O
gpg_prog	pointer
,	O
int	O
uverbose	int
,	O
char	O
*	O
which_sig_arg	pointer
)	O
{	O
pid_t	int
pid	int
;	O
int	O
ret	int
;	O
int	O
retval	int
;	O
int	O
sbfd	array
[	O
2	int
]	O
;	O
int	O
logger_fd	int
;	O
int	O
status_fd	int
;	O
int	O
status	int
;	O
SWGPG_VALIDATE	struct
*	O
w	pointer
;	O
SHCMD	struct
*	O
cmd	int
[	O
3	int
]	O
;	O
int	O
u_verbose	int
=	O
uverbose	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
30	int
)	O
;	O
int	O
atoiret	int
=	O
1	int
;	O
int	O
which_sig	int
;	O
if	O
(	O
which_sig_arg	pointer
)	O
{	O
which_sig	int
=	O
swlib_atoi	function
(	O
which_sig_arg	pointer
,	O
&	O
atoiret	int
)	O
;	O
if	O
(	O
atoiret	int
)	O
return	O
-	O
3	int
;	O
}	O
else	O
{	O
which_sig	int
=	O
-	O
1	int
;	O
}	O
cmd	int
[	O
0	int
]	O
=	O
shcmd_open	function
(	O
)	O
;	O
cmd	int
[	O
1	int
]	O
=	O
shcmd_open	function
(	O
)	O
;	O
cmd	int
[	O
2	int
]	O
=	O
NULL	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
1	int
;	O
pipe	function
(	O
sbfd	array
)	O
;	O
pid	int
=	O
swfork	O
(	O
NULL	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
sbfd	array
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swgp_signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR1	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR2	int
,	O
SIG_DFL	O
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
thisprog	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"--util-name=%s"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
"-G"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
sigfilename	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
"-n"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
which_sig_arg	pointer
)	O
;	O
while	O
(	O
u_verbose	int
>	O
1	int
)	O
{	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
"-v"	pointer
)	O
;	O
u_verbose	int
--	O
;	O
}	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
"--sleep"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
"1"	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"--signed-bytes-fd=%d"	pointer
,	O
sbfd	array
[	O
1	int
]	O
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"--logger-fd=%d"	pointer
,	O
STDOUT_FILENO	int
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
shcmd_add_arg	function
(	O
cmd	int
[	O
0	int
]	O
,	O
filearg	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
shcmd_unix_exec	function
(	O
cmd	int
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"exec error in swgp_run_checksig\n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
1	int
;	O
close	pointer
(	O
sbfd	array
[	O
1	int
]	O
)	O
;	O
goto	O
out	O
;	O
}	O
close	pointer
(	O
sbfd	array
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
cmd	int
[	O
1	int
]	O
=	O
gpg_fifo_command	function
(	O
sigfilename	pointer
,	O
gpg_prog	pointer
,	O
uverbose	int
,	O
STDOUT_FILENO	int
)	O
;	O
if	O
(	O
cmd	int
[	O
1	int
]	O
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
1	int
;	O
kill	function
(	O
pid	int
,	O
SIGTERM	int
)	O
;	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
goto	O
out	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
""	pointer
)	O
;	O
swlib_exec_filter	function
(	O
cmd	int
+	O
1	int
,	O
sbfd	array
[	O
0	int
]	O
,	O
tmp	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
swgpg_determine_signature_status	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
which_sig	int
)	O
;	O
retval	int
=	O
ret	int
;	O
E_DEBUG2	O
(	O
"signature status is %d"	pointer
,	O
ret	int
)	O
;	O
E_DEBUG2	O
(	O
"status line: %s"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
w	pointer
=	O
swgpg_create	function
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swgpg_disentangle_status_lines	function
(	O
w	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
logger_fd	int
=	O
-	O
1	int
;	O
status_fd	int
=	O
-	O
1	int
;	O
if	O
(	O
retval	int
)	O
{	O
status_fd	int
=	O
STDERR_FILENO	int
;	O
logger_fd	int
=	O
STDERR_FILENO	int
;	O
}	O
else	O
{	O
if	O
(	O
uverbose	int
>=	O
SWC_VERBOSE_2	int
)	O
{	O
logger_fd	int
=	O
STDOUT_FILENO	int
;	O
}	O
if	O
(	O
uverbose	int
>=	O
SWC_VERBOSE_3	int
)	O
{	O
logger_fd	int
=	O
STDOUT_FILENO	int
;	O
status_fd	int
=	O
STDOUT_FILENO	int
;	O
}	O
}	O
E_DEBUG3	O
(	O
"show: status_fd=%d, logger_fd=%d"	pointer
,	O
status_fd	int
,	O
logger_fd	int
)	O
;	O
swgpg_show	function
(	O
w	pointer
,	O
0	int
,	O
-	O
1	int
,	O
status_fd	int
,	O
logger_fd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swgpg_delete	function
(	O
w	pointer
)	O
;	O
out	O
:	O
if	O
(	O
cmd	int
[	O
0	int
]	O
)	O
shcmd_close	function
(	O
cmd	int
[	O
0	int
]	O
)	O
;	O
if	O
(	O
cmd	int
[	O
1	int
]	O
)	O
shcmd_close	function
(	O
cmd	int
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
sbfd	array
[	O
0	int
]	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
E_DEBUG2	O
(	O
"retval=%d"	pointer
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swgpg_run_gpg_verify	function
(	O
SWGPG_VALIDATE	struct
*	O
swgpg	pointer
,	O
int	O
signed_bytes_fd	int
,	O
char	O
*	O
signature	pointer
,	O
int	O
uverbose	int
,	O
STROB	struct
*	O
gpg_status	pointer
)	O
{	O
SHCMD	struct
*	O
gpg_cmd	pointer
;	O
SHCMD	struct
*	O
cmdvec	pointer
[	O
2	int
]	O
;	O
STROB	struct
*	O
fifo	pointer
;	O
STROB	struct
*	O
output	pointer
;	O
char	O
*	O
fifo_path	pointer
;	O
int	O
ret	int
;	O
int	O
ret1	int
;	O
int	O
ret2	int
;	O
int	O
ret3	int
;	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"signed_bytes_fd = %d"	pointer
,	O
signed_bytes_fd	int
)	O
;	O
fifo	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
if	O
(	O
gpg_status	pointer
==	O
NULL	O
)	O
output	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
else	O
output	pointer
=	O
gpg_status	pointer
;	O
cmdvec	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
cmdvec	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fifo_path	pointer
=	O
swgpg_create_fifo	function
(	O
fifo	pointer
)	O
;	O
if	O
(	O
fifo_path	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
gpg_cmd	pointer
=	O
gpg_fifo_command	function
(	O
fifo_path	pointer
,	O
swgpg	pointer
->	O
gpg_prognameM	pointer
,	O
uverbose	int
,	O
STDOUT_FILENO	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
gpg_cmd	pointer
==	O
NULL	O
)	O
{	O
swgpg_remove_fifo	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
cmdvec	pointer
[	O
0	int
]	O
=	O
gpg_cmd	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
int	O
ffd	int
;	O
close	pointer
(	O
0	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
ffd	int
=	O
open	function
(	O
fifo_path	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
ffd	int
<	O
0	int
)	O
_exit	function
(	O
1	int
)	O
;	O
ret	int
=	O
uxfio_unix_safe_write	function
(	O
ffd	int
,	O
signature	pointer
,	O
strlen	function
(	O
signature	pointer
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strlen	function
(	O
signature	pointer
)	O
)	O
_exit	function
(	O
2	int
)	O
;	O
close	pointer
(	O
ffd	int
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
output	pointer
,	O
""	pointer
)	O
;	O
ret1	int
=	O
swlib_exec_filter	function
(	O
cmdvec	pointer
,	O
signed_bytes_fd	int
,	O
output	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret1	int
==	O
SHCMD_UNSET_EXITVAL	int
)	O
{	O
E_DEBUG2	O
(	O
"swlib_exec_filter ret=%d"	pointer
,	O
ret1	int
)	O
;	O
ret1	int
=	O
0	int
;	O
}	O
E_DEBUG2	O
(	O
"swlib_exec_filter ret1=%d"	pointer
,	O
ret1	int
)	O
;	O
ret2	int
=	O
swgpg_determine_signature_status	function
(	O
strob_str	function
(	O
output	pointer
)	O
,	O
-	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"swgpg_determine_signature_status ret2=%d"	pointer
,	O
ret2	int
)	O
;	O
ret3	int
=	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
ret3	int
<	O
0	int
)	O
{	O
;	O
}	O
else	O
if	O
(	O
ret3	int
==	O
0	int
)	O
{	O
ret3	int
=	O
2	int
;	O
}	O
else	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
ret3	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
E_DEBUG2	O
(	O
"exit value = %d"	pointer
,	O
ret3	int
)	O
;	O
}	O
else	O
{	O
ret3	int
=	O
1	int
;	O
}	O
}	O
swgpg_remove_fifo	function
(	O
)	O
;	O
strob_close	function
(	O
fifo	pointer
)	O
;	O
if	O
(	O
gpg_status	pointer
==	O
NULL	O
)	O
strob_close	function
(	O
output	pointer
)	O
;	O
E_DEBUG2	O
(	O
"RESULT ret1 = %d"	pointer
,	O
ret1	int
)	O
;	O
E_DEBUG2	O
(	O
"RESULT ret2 = %d"	pointer
,	O
ret2	int
)	O
;	O
E_DEBUG2	O
(	O
"RESULT ret3 = %d"	pointer
,	O
ret3	int
)	O
;	O
if	O
(	O
ret1	int
==	O
0	int
&&	O
ret2	int
==	O
0	int
&&	O
ret3	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"RETURNING returning 0"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"RETURNING returning 1"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
SHCMD	struct
*	O
swgpg_get_package_signature_command	function
(	O
char	O
*	O
signer	pointer
,	O
char	O
*	O
gpg_name	pointer
,	O
char	O
*	O
gpg_path	pointer
,	O
char	O
*	O
passphrase_fd	pointer
)	O
{	O
static	O
char	O
*	O
env	array
[	O
10	int
]	O
;	O
SHCMD	struct
*	O
sigcmd	pointer
;	O
char	O
*	O
envpath	pointer
;	O
char	O
*	O
signerpath	pointer
;	O
sigcmd	pointer
=	O
shcmd_open	function
(	O
)	O
;	O
env	array
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
envpath	pointer
=	O
getenv	function
(	O
"PATH"	pointer
)	O
;	O
if	O
(	O
strcasecmp	function
(	O
signer	pointer
,	O
"GPG"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
signer	pointer
,	O
"GPG2"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
signer	pointer
,	O
"GPG2"	pointer
)	O
==	O
0	int
)	O
{	O
signerpath	pointer
=	O
shcmd_find_in_path	function
(	O
envpath	pointer
,	O
SWGPG_GPG2_BIN	pointer
)	O
;	O
}	O
else	O
{	O
signerpath	pointer
=	O
shcmd_find_in_path	function
(	O
envpath	pointer
,	O
SWGPG_GPG_BIN	pointer
)	O
;	O
}	O
if	O
(	O
signerpath	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
signerpath	pointer
)	O
;	O
if	O
(	O
gpg_name	pointer
&&	O
strlen	function
(	O
gpg_name	pointer
)	O
)	O
{	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-u"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
gpg_name	pointer
)	O
;	O
}	O
if	O
(	O
gpg_path	pointer
&&	O
strlen	function
(	O
gpg_path	pointer
)	O
)	O
{	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"--homedir"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
gpg_path	pointer
)	O
;	O
}	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"--no-tty"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"--no-secmem-warning"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"--armor"	pointer
)	O
;	O
if	O
(	O
passphrase_fd	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_AGENT	pointer
)	O
==	O
0	int
)	O
{	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"--use-agent"	pointer
)	O
;	O
}	O
else	O
{	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"--passphrase-fd"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"3"	pointer
)	O
;	O
}	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-sb"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-o"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
signer	pointer
,	O
"PGP2.6"	pointer
)	O
==	O
0	int
)	O
{	O
make_pgp_env	function
(	O
env	array
,	O
sizeof	O
(	O
env	array
)	O
/	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
shcmd_set_envp	function
(	O
sigcmd	pointer
,	O
env	array
)	O
;	O
signerpath	pointer
=	O
shcmd_find_in_path	function
(	O
envpath	pointer
,	O
SWGPG_PGP26_BIN	pointer
)	O
;	O
if	O
(	O
signerpath	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
signerpath	pointer
)	O
;	O
if	O
(	O
gpg_name	pointer
&&	O
strlen	function
(	O
gpg_name	pointer
)	O
)	O
{	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-u"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
gpg_name	pointer
)	O
;	O
}	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"+armor=on"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-sb"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-o"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
signer	pointer
,	O
"PGP5"	pointer
)	O
==	O
0	int
)	O
{	O
make_pgp_env	function
(	O
env	array
,	O
sizeof	O
(	O
env	array
)	O
/	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
shcmd_set_envp	function
(	O
sigcmd	pointer
,	O
env	array
)	O
;	O
signerpath	pointer
=	O
shcmd_find_in_path	function
(	O
envpath	pointer
,	O
SWGPG_PGP5_BIN	pointer
)	O
;	O
if	O
(	O
signerpath	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
signerpath	pointer
)	O
;	O
if	O
(	O
gpg_name	pointer
&&	O
strlen	function
(	O
gpg_name	pointer
)	O
)	O
{	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-u"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
gpg_name	pointer
)	O
;	O
}	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-ab"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-o"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
sigcmd	pointer
,	O
"-"	pointer
)	O
;	O
}	O
else	O
{	O
shcmd_close	function
(	O
sigcmd	pointer
)	O
;	O
sigcmd	pointer
=	O
NULL	O
;	O
}	O
return	O
sigcmd	pointer
;	O
}	O
char	O
*	O
swgpg_get_package_signature	function
(	O
SHCMD	struct
*	O
sigcmd	pointer
,	O
int	O
*	O
statusp	pointer
,	O
char	O
*	O
wopt_passphrase_fd	pointer
,	O
char	O
*	O
passfile	pointer
,	O
int	O
pkg_fd	int
,	O
int	O
do_dummy_sign	int
,	O
char	O
*	O
g_passphrase	pointer
)	O
{	O
SHCMD	struct
*	O
cmd	int
[	O
2	int
]	O
;	O
int	O
verboseG	int
=	O
1	int
;	O
char	O
*	O
sig	pointer
;	O
int	O
does_use_agent	int
;	O
int	O
ret	int
;	O
int	O
atoiret	int
;	O
int	O
opt_passphrase_fd	int
;	O
pid_t	int
pid	int
[	O
6	int
]	O
;	O
int	O
status	int
[	O
6	int
]	O
;	O
int	O
passphrase	array
[	O
2	int
]	O
;	O
int	O
input	array
[	O
2	int
]	O
;	O
int	O
output	pointer
[	O
2	int
]	O
;	O
int	O
filter	array
[	O
2	int
]	O
;	O
int	O
sigfd	int
;	O
char	O
*	O
fdmem	pointer
;	O
char	O
nullbyte	array
[	O
2	int
]	O
;	O
*	O
statusp	pointer
=	O
255	int
;	O
cmd	int
[	O
1	int
]	O
=	O
(	O
SHCMD	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
nullbyte	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
do_dummy_sign	int
)	O
{	O
sig	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
ARMORED_SIGLEN	int
)	O
;	O
memset	function
(	O
sig	pointer
,	O
'\0'	O
,	O
ARMORED_SIGLEN	int
)	O
;	O
strcat	function
(	O
sig	pointer
,	O
"-----BEGIN DUMMY SIGNATURE-----\n"	pointer
"Version: swpackage (swbis) "	pointer
SWPACKAGE_VERSION	pointer
"\n"	pointer
"dummy signature made using the --dummy-sign option of\n"	pointer
"the swpackage(8) utility.  Not intended for verification.\n"	pointer
"-----END DUMMY SIGNATURE-----\n"	pointer
)	O
;	O
return	O
sig	pointer
;	O
}	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWPACKAGE_VERBOSE_V1	O
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"Generating package signature ....\n"	pointer
)	O
;	O
if	O
(	O
sigcmd	pointer
==	O
NULL	O
)	O
{	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
cmd	int
[	O
0	int
]	O
=	O
sigcmd	pointer
;	O
}	O
if	O
(	O
pipe	function
(	O
input	array
)	O
)	O
exit	function
(	O
4	int
)	O
;	O
if	O
(	O
pipe	function
(	O
output	pointer
)	O
)	O
exit	function
(	O
4	int
)	O
;	O
if	O
(	O
pipe	function
(	O
passphrase	array
)	O
)	O
exit	function
(	O
4	int
)	O
;	O
pipe	function
(	O
filter	array
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
does_use_agent	int
=	O
get_does_use_gpg_agent	function
(	O
cmd	int
[	O
0	int
]	O
)	O
;	O
pid	int
[	O
0	int
]	O
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
[	O
0	int
]	O
<	O
0	int
)	O
exit	function
(	O
5	int
)	O
;	O
if	O
(	O
pid	int
[	O
0	int
]	O
==	O
0	int
)	O
{	O
close_passfd	function
(	O
)	O
;	O
close	pointer
(	O
filter	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
output	pointer
[	O
0	int
]	O
)	O
;	O
shcmd_set_srcfd	function
(	O
cmd	int
[	O
0	int
]	O
,	O
filter	array
[	O
0	int
]	O
)	O
;	O
shcmd_set_dstfd	function
(	O
cmd	int
[	O
0	int
]	O
,	O
output	pointer
[	O
1	int
]	O
)	O
;	O
shcmd_set_errfile	function
(	O
cmd	int
[	O
0	int
]	O
,	O
"/dev/null"	pointer
)	O
;	O
shcmd_apply_redirection	function
(	O
cmd	int
[	O
0	int
]	O
)	O
;	O
if	O
(	O
does_use_agent	int
==	O
0	int
)	O
dup2	function
(	O
passphrase	array
[	O
0	int
]	O
,	O
3	int
)	O
;	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
passphrase	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
does_use_agent	int
==	O
0	int
)	O
swgp_close_all_fd	function
(	O
4	int
)	O
;	O
else	O
swgp_close_all_fd	function
(	O
3	int
)	O
;	O
shcmd_unix_exec	function
(	O
cmd	int
[	O
0	int
]	O
)	O
;	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"%s not run.\n"	pointer
,	O
cmd	int
[	O
0	int
]	O
->	O
argv_	pointer
[	O
0	int
]	O
)	O
;	O
_exit	function
(	O
2	int
)	O
;	O
}	O
close	pointer
(	O
output	pointer
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
filter	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
passphrase	array
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pid	int
[	O
1	int
]	O
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
[	O
1	int
]	O
<	O
0	int
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
pid	int
[	O
1	int
]	O
==	O
0	int
)	O
{	O
close	pointer
(	O
input	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
output	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
does_use_agent	int
==	O
0	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
"-1"	pointer
)	O
==	O
0	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_ENV	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_AGENT	pointer
)	O
!=	O
0	int
&&	O
passfile	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
char	O
pbuf	pointer
[	O
SWGPG_PASSPHRASE_LENGTH	int
]	O
;	O
char	O
*	O
pass	pointer
;	O
pass	pointer
=	O
fm_getpassphrase	function
(	O
"Enter Password: "	pointer
,	O
pbuf	pointer
,	O
sizeof	O
(	O
pbuf	pointer
)	O
)	O
;	O
if	O
(	O
pass	pointer
)	O
{	O
pbuf	pointer
[	O
sizeof	O
(	O
pbuf	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
write	pointer
(	O
passphrase	array
[	O
1	int
]	O
,	O
pass	pointer
,	O
strlen	function
(	O
pass	pointer
)	O
)	O
;	O
}	O
else	O
{	O
write	pointer
(	O
passphrase	array
[	O
1	int
]	O
,	O
"\n\n"	pointer
,	O
2	int
)	O
;	O
}	O
memset	function
(	O
pbuf	pointer
,	O
'\x00'	O
,	O
sizeof	O
(	O
pbuf	pointer
)	O
)	O
;	O
memset	function
(	O
pbuf	pointer
,	O
'\xff'	O
,	O
sizeof	O
(	O
pbuf	pointer
)	O
)	O
;	O
if	O
(	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"swpackage: close: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
does_use_agent	int
==	O
0	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_AGENT	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_ENV	pointer
)	O
!=	O
0	int
)	O
{	O
int	O
did_open	int
=	O
0	int
;	O
int	O
buf	pointer
[	O
512	int
]	O
;	O
if	O
(	O
passfile	pointer
&&	O
strcmp	function
(	O
passfile	pointer
,	O
"-"	pointer
)	O
)	O
{	O
opt_passphrase_fd	int
=	O
open	function
(	O
passfile	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
opt_passphrase_fd	int
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"passphrase file not found\n"	pointer
)	O
;	O
}	O
did_open	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
passfile	pointer
&&	O
strcmp	function
(	O
passfile	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"warning: unsafe use of stdin\n"	pointer
"warning: use --passphrase-fd=0 instead\n"	pointer
)	O
;	O
opt_passphrase_fd	int
=	O
STDIN_FILENO	int
;	O
}	O
else	O
{	O
opt_passphrase_fd	int
=	O
swlib_atoi	function
(	O
wopt_passphrase_fd	pointer
,	O
&	O
atoiret	int
)	O
;	O
if	O
(	O
atoiret	int
)	O
return	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
opt_passphrase_fd	int
>=	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"reading opt_passphrase_fd=%d"	pointer
,	O
opt_passphrase_fd	int
)	O
;	O
ret	int
=	O
read	pointer
(	O
opt_passphrase_fd	int
,	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"read of passphrase ret=%d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
ret	int
>=	O
511	int
)	O
{	O
memset	function
(	O
buf	pointer
,	O
'\0'	O
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
memset	function
(	O
buf	pointer
,	O
'\xff'	O
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"read (loc=p): %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
opt_passphrase_fd	int
)	O
;	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
did_open	int
)	O
close	pointer
(	O
opt_passphrase_fd	int
)	O
;	O
buf	pointer
[	O
ret	int
]	O
=	O
'\0'	O
;	O
write	pointer
(	O
passphrase	array
[	O
1	int
]	O
,	O
buf	pointer
,	O
ret	int
)	O
;	O
memset	function
(	O
buf	pointer
,	O
'\0'	O
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
memset	function
(	O
buf	pointer
,	O
'\xff'	O
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
}	O
if	O
(	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"close error: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
does_use_agent	int
==	O
1	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_AGENT	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"close error: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
does_use_agent	int
==	O
0	int
&&	O
strcmp	function
(	O
wopt_passphrase_fd	pointer
,	O
SWGPG_SWP_PASS_ENV	pointer
)	O
==	O
0	int
&&	O
g_passphrase	pointer
)	O
{	O
write	pointer
(	O
passphrase	array
[	O
1	int
]	O
,	O
g_passphrase	pointer
,	O
strlen	function
(	O
g_passphrase	pointer
)	O
)	O
;	O
write	pointer
(	O
passphrase	array
[	O
1	int
]	O
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"close error: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"internal error get_package_signature\n"	pointer
)	O
;	O
if	O
(	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"close error: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
_exit	function
(	O
0	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
close_passfd	function
(	O
)	O
;	O
close	pointer
(	O
passphrase	array
[	O
1	int
]	O
)	O
;	O
pid	int
[	O
2	int
]	O
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
[	O
2	int
]	O
<	O
0	int
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
pid	int
[	O
2	int
]	O
==	O
0	int
)	O
{	O
close_passfd	function
(	O
)	O
;	O
close	pointer
(	O
input	array
[	O
1	int
]	O
)	O
;	O
swlib_pipe_pump	function
(	O
filter	array
[	O
1	int
]	O
,	O
input	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
input	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
filter	array
[	O
1	int
]	O
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
close	pointer
(	O
input	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
filter	array
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pid	int
[	O
3	int
]	O
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
[	O
3	int
]	O
<	O
0	int
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
pid	int
[	O
3	int
]	O
==	O
0	int
)	O
{	O
int	O
ofd1	int
;	O
close_passfd	function
(	O
)	O
;	O
close	pointer
(	O
input	array
[	O
0	int
]	O
)	O
;	O
ofd1	int
=	O
uxfio_opendup	function
(	O
input	array
[	O
1	int
]	O
,	O
UXFIO_BUFTYPE_NOBUF	int
)	O
;	O
uxfio_fcntl	function
(	O
ofd1	int
,	O
UXFIO_F_SET_OUTPUT_BLOCK_SIZE	O
,	O
PIPE_BUF	int
)	O
;	O
swlib_pipe_pump	function
(	O
ofd1	int
,	O
pkg_fd	int
)	O
;	O
uxfio_close	function
(	O
ofd1	int
)	O
;	O
close	pointer
(	O
output	pointer
[	O
0	int
]	O
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
close	pointer
(	O
input	array
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
sigfd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
ret	int
=	O
swlib_pump_amount	function
(	O
sigfd	int
,	O
output	pointer
[	O
0	int
]	O
,	O
1024	int
)	O
;	O
close	pointer
(	O
output	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
ret	int
>	O
1000	int
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
uxfio_write	function
(	O
sigfd	int
,	O
(	O
void	O
*	O
)	O
nullbyte	array
,	O
1	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swlib_wait_on_all_pids	function
(	O
pid	int
,	O
4	int
,	O
status	int
,	O
WNOHANG	int
,	O
verboseG	int
-	O
2	int
)	O
<	O
0	int
)	O
{	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
pid	int
[	O
0	int
]	O
<	O
0	int
)	O
{	O
ret	int
=	O
WEXITSTATUS	O
(	O
status	int
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
100	int
;	O
}	O
*	O
statusp	pointer
=	O
ret	int
;	O
if	O
(	O
ret	int
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_get_dynamic_buffer	function
(	O
sigfd	int
,	O
&	O
fdmem	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
sig	pointer
=	O
strdup	function
(	O
fdmem	pointer
)	O
;	O
uxfio_close	function
(	O
sigfd	int
)	O
;	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWPACKAGE_VERBOSE_V1	O
,	O
NULL	O
,	O
get_stderr_fd	function
(	O
)	O
,	O
"Generating package signature .... Done.\n"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
sig	pointer
;	O
}	O
