static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: hash.c,v 1.6 2014/04/17 20:27:28 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__ham_c_close	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_pgno_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__ham_c_del	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ham_c_destroy	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ham_c_get	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__ham_c_put	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__ham_c_writelock	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ham_del_dups	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ham_delete	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_dup_return	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_expand_table	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ham_init_htab	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
const	O
char	O
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_lookup	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
const	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_lockmode_t	enum
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__ham_overwrite	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___ham_metachk	function
(	O
dbp	pointer
,	O
name	pointer
,	O
hashm	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
HMETA	struct
*	O
hashm	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
vers	int
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
vers	int
=	O
hashm	pointer
->	O
dbmeta	struct
.	O
version	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
)	O
M_32_SWAP	O
(	O
vers	int
)	O
;	O
switch	O
(	O
vers	int
)	O
{	O
case	O
4	int
:	O
case	O
5	int
:	O
case	O
6	int
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: hash version %lu requires a version upgrade"	pointer
,	O
name	pointer
,	O
(	O
u_long	long
)	O
vers	int
)	O
;	O
return	O
(	O
DB_OLD_VERSION	O
)	O
;	O
case	O
7	int
:	O
break	O
;	O
default	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: unsupported hash version: %lu"	pointer
,	O
name	pointer
,	O
(	O
u_long	long
)	O
vers	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
&&	O
(	O
ret	int
=	O
CDB___ham_mswap	function
(	O
(	O
PAGE	struct
*	O
)	O
hashm	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
dbp	pointer
->	O
type	enum
!=	O
DB_HASH	int
&&	O
dbp	pointer
->	O
type	enum
!=	O
DB_UNKNOWN	int
)	O
return	O
(	O
EINVAL	int
)	O
;	O
dbp	pointer
->	O
type	enum
=	O
DB_HASH	int
;	O
DB_ILLEGAL_METHOD	O
(	O
dbp	pointer
,	O
DB_OK_HASH	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DB->open"	pointer
,	O
hashm	pointer
->	O
dbmeta	struct
.	O
flags	int
,	O
DB_HASH_DUP	int
|	O
DB_HASH_SUBDB	int
|	O
DB_HASH_DUPSORT	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
hashm	pointer
->	O
dbmeta	struct
,	O
DB_HASH_DUP	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
;	O
else	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: DB_DUP specified to open method but not set in database"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
hashm	pointer
->	O
dbmeta	struct
,	O
DB_HASH_SUBDB	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
;	O
else	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: multiple databases specified but not supported in file"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
hashm	pointer
->	O
dbmeta	struct
,	O
DB_HASH_DUPSORT	int
)	O
)	O
{	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
dbp	pointer
->	O
dup_compare	pointer
=	O
CDB___bam_defcmp	function
;	O
}	O
else	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: duplicate sort function specified but not set in database"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
dbp	pointer
->	O
pgsize	int
=	O
hashm	pointer
->	O
dbmeta	struct
.	O
pagesize	long
;	O
memcpy	function
(	O
dbp	pointer
->	O
fileid	array
,	O
hashm	pointer
->	O
dbmeta	struct
.	O
uid	array
,	O
DB_FILE_ID_LEN	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
base_pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
db_pgno_t	int
base_pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
HASH	struct
*	O
hashp	pointer
;	O
int	O
need_sync	int
,	O
ret	int
,	O
t_ret	int
;	O
dbc	pointer
=	O
NULL	O
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
need_sync	int
=	O
0	int
;	O
dbp	pointer
->	O
del	pointer
=	O
__ham_delete	function
;	O
dbp	pointer
->	O
stat	pointer
=	O
CDB___ham_stat	function
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
dbc	pointer
,	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
&&	O
LOCKING	O
(	O
dbenv	pointer
)	O
?	O
DB_WRITECURSOR	int
:	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
hashp	pointer
->	O
meta_pgno	int
=	O
base_pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
magic	int
==	O
DB_HASHMAGIC	int
)	O
{	O
if	O
(	O
hashp	pointer
->	O
h_hash	pointer
==	O
NULL	O
)	O
hashp	pointer
->	O
h_hash	pointer
=	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
version	int
<	O
5	int
?	O
CDB___ham_func4	function
:	O
CDB___ham_func5	function
;	O
if	O
(	O
hashp	pointer
->	O
h_hash	pointer
(	O
CHARKEY	pointer
,	O
sizeof	O
(	O
CHARKEY	pointer
)	O
)	O
!=	O
hcp	pointer
->	O
hdr	struct
->	O
h_charkey	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"hash: incompatible hash function"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err2	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
,	O
DB_HASH_DUP	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
,	O
DB_HASH_DUPSORT	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_DUPSORT	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
,	O
DB_HASH_SUBDB	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
)	O
{	O
dbc	pointer
->	O
lock	struct
.	O
pgno	int
=	O
base_pgno	int
;	O
if	O
(	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
&&	O
(	O
(	O
ret	int
=	O
CDB_lock_put	function
(	O
dbenv	pointer
,	O
&	O
hcp	pointer
->	O
hlock	struct
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB_lock_get	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
locker	int
,	O
DB_NONBLOCK	O
(	O
dbc	pointer
)	O
?	O
DB_LOCK_NOWAIT	int
:	O
0	int
,	O
&	O
dbc	pointer
->	O
lock_dbt	struct
,	O
DB_LOCK_WRITE	int
,	O
&	O
hcp	pointer
->	O
hlock	struct
)	O
)	O
!=	O
0	int
)	O
)	O
goto	O
err2	O
;	O
else	O
if	O
(	O
LOCKING	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
{	O
DB_ASSERT	O
(	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_lock_get	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
locker	int
,	O
DB_LOCK_UPGRADE	int
,	O
&	O
dbc	pointer
->	O
lock_dbt	struct
,	O
DB_LOCK_WRITE	int
,	O
&	O
dbc	pointer
->	O
mylock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__ham_init_htab	function
(	O
dbc	pointer
,	O
name	pointer
,	O
base_pgno	int
,	O
hashp	pointer
->	O
h_nelem	int
,	O
hashp	pointer
->	O
h_ffactor	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
need_sync	int
=	O
1	int
;	O
}	O
err2	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
err1	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
need_sync	int
)	O
ret	int
=	O
dbp	pointer
->	O
sync	pointer
(	O
dbp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
(	O
void	O
)	O
CDB___ham_db_close	function
(	O
dbp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_init_htab	function
(	O
dbc	pointer
,	O
name	pointer
,	O
pgno	int
,	O
nelem	int
,	O
ffactor	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
nelem	int
,	O
ffactor	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
metalock	struct
;	O
DB_LSN	struct
orig_lsn	struct
;	O
DBMETA	struct
*	O
mmeta	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
HASH	struct
*	O
hashp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
mpgno	int
;	O
int32_t	int
l2	int
,	O
nbuckets	int
;	O
int	O
dirty_mmeta	int
,	O
i	int
,	O
ret	int
,	O
t_ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
mmeta	pointer
=	O
NULL	O
;	O
dirty_mmeta	int
=	O
0	int
;	O
metalock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
hashp	pointer
->	O
h_hash	pointer
==	O
NULL	O
)	O
hashp	pointer
->	O
h_hash	pointer
=	O
DB_HASHVERSION	int
<	O
5	int
?	O
CDB___ham_func4	function
:	O
CDB___ham_func5	function
;	O
if	O
(	O
nelem	int
!=	O
0	int
&&	O
ffactor	int
!=	O
0	int
)	O
{	O
nelem	int
=	O
(	O
nelem	int
-	O
1	int
)	O
/	O
ffactor	int
+	O
1	int
;	O
l2	int
=	O
CDB___db_log2	function
(	O
nelem	int
>	O
2	int
?	O
nelem	int
:	O
2	int
)	O
;	O
}	O
else	O
l2	int
=	O
1	int
;	O
nbuckets	int
=	O
1	int
<<	O
l2	int
;	O
orig_lsn	struct
=	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
lsn	struct
;	O
memset	function
(	O
hcp	pointer
->	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
HMETA	struct
)	O
)	O
;	O
ZERO_LSN	O
(	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
lsn	struct
)	O
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
pgno	int
=	O
pgno	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
magic	int
=	O
DB_HASHMAGIC	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
version	int
=	O
DB_HASHVERSION	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
pagesize	long
=	O
dbp	pointer
->	O
pgsize	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
type	enum
=	O
P_HASHMETA	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
free	function
=	O
PGNO_INVALID	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
=	O
hcp	pointer
->	O
hdr	struct
->	O
high_mask	int
=	O
nbuckets	int
-	O
1	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
low_mask	int
=	O
(	O
nbuckets	int
>>	O
1	int
)	O
-	O
1	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
ffactor	int
=	O
ffactor	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
h_charkey	int
=	O
hashp	pointer
->	O
h_hash	pointer
(	O
CHARKEY	pointer
,	O
sizeof	O
(	O
CHARKEY	pointer
)	O
)	O
;	O
memcpy	function
(	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
uid	array
,	O
dbp	pointer
->	O
fileid	array
,	O
DB_FILE_ID_LEN	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
)	O
F_SET	O
(	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
,	O
DB_HASH_DUP	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
)	O
F_SET	O
(	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
,	O
DB_HASH_SUBDB	int
)	O
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
F_SET	O
(	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
,	O
DB_HASH_DUPSORT	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
(	O
PAGE	struct
*	O
)	O
hcp	pointer
->	O
hdr	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
0	int
]	O
=	O
nbuckets	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
0	int
]	O
,	O
DB_MPOOL_NEW_GROUP	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
P_INIT	O
(	O
h	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
0	int
]	O
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
P_HASH	int
,	O
0	int
)	O
;	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
0	int
]	O
-=	O
(	O
nbuckets	int
-	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
l2	int
;	O
i	int
++	O
)	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
i	int
]	O
=	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
0	int
]	O
;	O
for	O
(	O
;	O
i	int
<	O
NCACHED	int
;	O
i	int
++	O
)	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
i	int
]	O
=	O
PGNO_INVALID	int
;	O
ret	int
=	O
CDB___db_log_page	function
(	O
dbp	pointer
,	O
name	pointer
,	O
&	O
orig_lsn	struct
,	O
pgno	int
,	O
(	O
PAGE	struct
*	O
)	O
hcp	pointer
->	O
hdr	struct
)	O
;	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
)	O
{	O
mmeta	pointer
=	O
(	O
DBMETA	struct
*	O
)	O
hcp	pointer
->	O
hdr	struct
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
)	O
{	O
mpgno	int
=	O
PGNO_BASE_MD	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
mpgno	int
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
mpgno	int
,	O
0	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
mmeta	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_groupalloc_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
LSN	O
(	O
mmeta	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
LSN	O
(	O
mmeta	pointer
)	O
,	O
&	O
mmeta	pointer
->	O
alloc_lsn	struct
,	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
0	int
]	O
,	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
+	O
1	int
,	O
mmeta	pointer
->	O
free	function
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
mmeta	pointer
->	O
alloc_lsn	struct
=	O
LSN	O
(	O
mmeta	pointer
)	O
;	O
dirty_mmeta	int
=	O
1	int
;	O
}	O
}	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_POSTLOG	O
,	O
ret	int
,	O
name	pointer
)	O
;	O
DB_TEST_RECOVERY_LABEL	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
err	pointer
:	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
&&	O
mmeta	pointer
!=	O
NULL	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
mmeta	pointer
,	O
dirty_mmeta	int
?	O
DB_MPOOL_DIRTY	int
:	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
metalock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_delete	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	struct
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
DBC	struct
*	O
dbc	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
DB_ILLEGAL_BEFORE_OPEN	O
(	O
dbp	pointer
,	O
"DB->del"	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_delchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
txn	pointer
,	O
&	O
dbc	pointer
,	O
DB_WRITELOCK	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc	pointer
,	O
txn	pointer
,	O
"ham_delete"	pointer
,	O
key	struct
,	O
NULL	O
,	O
flags	int
)	O
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
pgno	int
=	O
PGNO_INVALID	int
;	O
if	O
(	O
(	O
ret	int
=	O
__ham_lookup	function
(	O
dbc	pointer
,	O
key	struct
,	O
0	int
,	O
DB_LOCK_WRITE	int
,	O
&	O
pgno	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
)	O
{	O
if	O
(	O
pgno	int
==	O
PGNO_INVALID	int
)	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
1	int
)	O
;	O
else	O
{	O
ret	int
=	O
__ham_del_dups	function
(	O
dbc	pointer
,	O
key	struct
)	O
;	O
}	O
}	O
else	O
ret	int
=	O
DB_NOTFOUND	O
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
out	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_c_init	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
HASH_CURSOR	struct
*	O
new_curs	pointer
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
struct	O
cursor_t	struct
)	O
,	O
&	O
new_curs	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
new_curs	pointer
->	O
split_buf	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_free	function
(	O
new_curs	pointer
,	O
sizeof	O
(	O
*	O
new_curs	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
dbc	pointer
->	O
internal	pointer
=	O
(	O
DBC_INTERNAL	struct
*	O
)	O
new_curs	pointer
;	O
dbc	pointer
->	O
c_close	pointer
=	O
CDB___db_c_close	function
;	O
dbc	pointer
->	O
c_count	pointer
=	O
CDB___db_c_count	function
;	O
dbc	pointer
->	O
c_del	pointer
=	O
CDB___db_c_del	function
;	O
dbc	pointer
->	O
c_dup	pointer
=	O
CDB___db_c_dup	function
;	O
dbc	pointer
->	O
c_get	pointer
=	O
CDB___db_c_get	function
;	O
dbc	pointer
->	O
c_put	pointer
=	O
CDB___db_c_put	function
;	O
dbc	pointer
->	O
c_am_close	pointer
=	O
__ham_c_close	function
;	O
dbc	pointer
->	O
c_am_del	pointer
=	O
__ham_c_del	function
;	O
dbc	pointer
->	O
c_am_destroy	pointer
=	O
__ham_c_destroy	function
;	O
dbc	pointer
->	O
c_am_get	pointer
=	O
__ham_c_get	function
;	O
dbc	pointer
->	O
c_am_put	pointer
=	O
__ham_c_put	function
;	O
dbc	pointer
->	O
c_am_writelock	pointer
=	O
__ham_c_writelock	function
;	O
CDB___ham_item_init	function
(	O
dbc	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_c_close	function
(	O
dbc	pointer
,	O
root_pgno	int
,	O
rmroot	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
*	O
rmroot	pointer
;	O
{	O
if	O
(	O
rmroot	pointer
)	O
{	O
}	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
HKEYDATA	struct
*	O
dp	pointer
;	O
int	O
dirty	int
,	O
doroot	int
,	O
gotmeta	int
,	O
ret	int
,	O
t_ret	int
;	O
COMPQUIET	O
(	O
rmroot	pointer
,	O
0	int
)	O
;	O
dirty	int
=	O
doroot	int
=	O
gotmeta	int
=	O
ret	int
=	O
0	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
dbc	pointer
->	O
internal	pointer
->	O
opd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
gotmeta	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
DB_LOCK_READ	int
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
dp	pointer
=	O
(	O
HKEYDATA	struct
*	O
)	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
DB_ASSERT	O
(	O
HPAGE_PTYPE	O
(	O
dp	pointer
)	O
==	O
H_OFFDUP	int
)	O
;	O
memcpy	function
(	O
&	O
root_pgno	int
,	O
HOFFPAGE_PGNO	O
(	O
dp	pointer
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
if	O
(	O
LOCKING	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
CDB___db_cdb_cdup	function
(	O
dbc	pointer
,	O
hcp	pointer
->	O
opd	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
hcp	pointer
->	O
opd	pointer
->	O
c_am_close	pointer
(	O
hcp	pointer
->	O
opd	pointer
,	O
root_pgno	int
,	O
&	O
doroot	int
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
if	O
(	O
doroot	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
dirty	int
=	O
1	int
;	O
}	O
}	O
out	O
:	O
if	O
(	O
hcp	pointer
->	O
page	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbc	pointer
->	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
dirty	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
gotmeta	int
!=	O
0	int
&&	O
(	O
t_ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
done	O
:	O
CDB___ham_item_init	function
(	O
dbc	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_c_destroy	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
hcp	pointer
->	O
split_buf	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
hcp	pointer
->	O
split_buf	pointer
,	O
dbc	pointer
->	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
CDB___os_free	function
(	O
hcp	pointer
,	O
sizeof	O
(	O
HASH_CURSOR	struct
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_c_count	function
(	O
dbc	pointer
,	O
recnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_indx_t	short
len	short
;	O
db_recno_t	int
recno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
u_int8_t	char
*	O
p	pointer
,	O
*	O
pend	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
recno	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
DB_LOCK_READ	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
HPAGE_PTYPE	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
)	O
{	O
case	O
H_KEYDATA	int
:	O
case	O
H_OFFPAGE	int
:	O
recno	int
=	O
1	int
;	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
p	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
pend	pointer
=	O
p	pointer
+	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
for	O
(	O
;	O
p	pointer
<	O
pend	pointer
;	O
recno	int
++	O
)	O
{	O
memcpy	function
(	O
&	O
len	short
,	O
p	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
p	pointer
+=	O
2	int
*	O
sizeof	O
(	O
db_indx_t	short
)	O
+	O
len	short
;	O
}	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___ham_c_count"	pointer
,	O
HPAGE_PTYPE	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
*	O
recnop	pointer
=	O
recno	int
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbc	pointer
->	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_c_del	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
repldbt	struct
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
DB_LOCK_WRITE	int
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
if	O
(	O
HPAGE_TYPE	O
(	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
==	O
H_OFFDUP	int
)	O
goto	O
out	O
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
)	O
{	O
if	O
(	O
hcp	pointer
->	O
dup_off	short
==	O
0	int
&&	O
(	O
unsigned	O
int	O
)	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
==	O
(	O
unsigned	O
int	O
)	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
pagesize	long
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
1	int
)	O
;	O
else	O
{	O
repldbt	struct
.	O
flags	int
=	O
0	int
;	O
F_SET	O
(	O
&	O
repldbt	struct
,	O
DB_DBT_PARTIAL	int
)	O
;	O
repldbt	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_off	short
;	O
repldbt	struct
.	O
dlen	int
=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
repldbt	struct
.	O
size	int
=	O
0	int
;	O
repldbt	struct
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
ret	int
=	O
CDB___ham_replpair	function
(	O
dbc	pointer
,	O
&	O
repldbt	struct
,	O
0	int
)	O
;	O
hcp	pointer
->	O
dup_tlen	short
-=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
;	O
CDB___ham_c_update	function
(	O
dbc	pointer
,	O
hcp	pointer
->	O
pgno	int
,	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
,	O
0	int
,	O
1	int
)	O
;	O
}	O
}	O
else	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
1	int
)	O
;	O
out	O
:	O
if	O
(	O
ret	int
==	O
0	int
&&	O
hcp	pointer
->	O
page	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_c_dup	function
(	O
orig_dbc	pointer
,	O
new_dbc	pointer
)	O
DBC	struct
*	O
orig_dbc	pointer
,	O
*	O
new_dbc	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
orig	struct
,	O
*	O
new	pointer
;	O
orig	struct
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
orig_dbc	pointer
->	O
internal	pointer
;	O
new	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
new_dbc	pointer
->	O
internal	pointer
;	O
new	pointer
->	O
bucket	int
=	O
orig	struct
->	O
bucket	int
;	O
new	pointer
->	O
lbucket	int
=	O
orig	struct
->	O
lbucket	int
;	O
new	pointer
->	O
dup_off	short
=	O
orig	struct
->	O
dup_off	short
;	O
new	pointer
->	O
dup_len	short
=	O
orig	struct
->	O
dup_len	short
;	O
new	pointer
->	O
dup_tlen	short
=	O
orig	struct
->	O
dup_tlen	short
;	O
if	O
(	O
F_ISSET	O
(	O
orig	struct
,	O
H_DELETED	int
)	O
)	O
F_SET	O
(	O
new	pointer
,	O
H_DELETED	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
orig	struct
,	O
H_ISDUP	int
)	O
)	O
F_SET	O
(	O
new	pointer
,	O
H_ISDUP	int
)	O
;	O
if	O
(	O
orig	struct
->	O
lock	struct
.	O
off	long
==	O
LOCK_INVALID	O
||	O
orig_dbc	pointer
->	O
txn	pointer
!=	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
CDB___ham_lock_bucket	function
(	O
new_dbc	pointer
,	O
DB_LOCK_READ	int
)	O
)	O
;	O
}	O
static	O
int	O
__ham_c_get	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_lockmode_t	enum
lock_type	enum
;	O
int	O
get_key	int
,	O
ret	int
,	O
t_ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
)	O
lock_type	enum
=	O
DB_LOCK_WRITE	int
;	O
else	O
lock_type	enum
=	O
DB_LOCK_READ	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
seek_size	int
=	O
0	int
;	O
ret	int
=	O
0	int
;	O
get_key	int
=	O
1	int
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_PREV_NODUP	int
:	O
F_SET	O
(	O
hcp	pointer
,	O
H_NEXT_NODUP	int
)	O
;	O
case	O
DB_PREV	int
:	O
if	O
(	O
hcp	pointer
->	O
bucket	int
!=	O
BUCKET_INVALID	int
)	O
{	O
ret	int
=	O
CDB___ham_item_prev	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
}	O
case	O
DB_LAST	int
:	O
ret	int
=	O
CDB___ham_item_last	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
case	O
DB_NEXT_NODUP	int
:	O
F_SET	O
(	O
hcp	pointer
,	O
H_NEXT_NODUP	int
)	O
;	O
case	O
DB_NEXT	int
:	O
if	O
(	O
hcp	pointer
->	O
bucket	int
!=	O
BUCKET_INVALID	int
)	O
{	O
ret	int
=	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
}	O
case	O
DB_FIRST	int
:	O
ret	int
=	O
CDB___ham_item_first	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
case	O
DB_NEXT_DUP	int
:	O
F_SET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
;	O
ret	int
=	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RANGE	int
:	O
case	O
DB_GET_BOTH	int
:	O
ret	int
=	O
__ham_lookup	function
(	O
dbc	pointer
,	O
key	struct
,	O
0	int
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
get_key	int
=	O
0	int
;	O
break	O
;	O
case	O
DB_GET_BOTHC	int
:	O
F_SET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
;	O
ret	int
=	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
get_key	int
=	O
0	int
;	O
break	O
;	O
case	O
DB_CURRENT	int
:	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
)	O
{	O
ret	int
=	O
DB_KEYEMPTY	O
;	O
goto	O
err	pointer
;	O
}	O
ret	int
=	O
CDB___ham_item	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
ret	int
!=	O
0	int
&&	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
goto	O
err	pointer
;	O
else	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
)	O
{	O
if	O
(	O
*	O
pgnop	pointer
==	O
PGNO_INVALID	int
)	O
ret	int
=	O
__ham_dup_return	function
(	O
dbc	pointer
,	O
data	pointer
,	O
flags	int
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"H_NOMORE returned to __ham_c_get"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_LAST	int
:	O
case	O
DB_PREV	int
:	O
case	O
DB_PREV_NODUP	int
:	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
if	O
(	O
hcp	pointer
->	O
bucket	int
==	O
0	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO_INVALID	int
;	O
goto	O
err	pointer
;	O
}	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
bucket	int
--	O
;	O
hcp	pointer
->	O
indx	short
=	O
NDX_INVALID	int
;	O
hcp	pointer
->	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___ham_item_prev	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
case	O
DB_FIRST	int
:	O
case	O
DB_NEXT	int
:	O
case	O
DB_NEXT_NODUP	int
:	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
hcp	pointer
->	O
indx	short
=	O
NDX_INVALID	int
;	O
hcp	pointer
->	O
bucket	int
++	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
if	O
(	O
hcp	pointer
->	O
bucket	int
>	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO_INVALID	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
lock_type	enum
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
case	O
DB_GET_BOTH	int
:	O
case	O
DB_GET_BOTHC	int
:	O
case	O
DB_NEXT_DUP	int
:	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RANGE	int
:	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
case	O
DB_CURRENT	int
:	O
ret	int
=	O
DB_KEYEMPTY	O
;	O
goto	O
err	pointer
;	O
default	O
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
get_key	int
==	O
0	int
)	O
F_SET	O
(	O
key	struct
,	O
DB_DBT_ISSET	int
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_NEXT_NODUP	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_c_put	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
tmp_val	struct
,	O
*	O
myval	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
u_int32_t	int
nbytes	long
;	O
int	O
ret	int
,	O
t_ret	int
;	O
COMPQUIET	O
(	O
myval	pointer
,	O
NULL	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
&&	O
flags	int
!=	O
DB_KEYFIRST	int
&&	O
flags	int
!=	O
DB_KEYLAST	int
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_KEYLAST	int
:	O
case	O
DB_KEYFIRST	int
:	O
case	O
DB_NODUPDATA	int
:	O
nbytes	long
=	O
(	O
ISBIG	O
(	O
hcp	pointer
,	O
key	struct
->	O
size	int
)	O
?	O
HOFFPAGE_PSIZE	O
:	O
HKEYDATA_PSIZE	O
(	O
key	struct
->	O
size	int
)	O
)	O
+	O
(	O
ISBIG	O
(	O
hcp	pointer
,	O
data	pointer
->	O
size	int
)	O
?	O
HOFFPAGE_PSIZE	O
:	O
HKEYDATA_PSIZE	O
(	O
data	pointer
->	O
size	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__ham_lookup	function
(	O
dbc	pointer
,	O
key	struct
,	O
nbytes	long
,	O
DB_LOCK_WRITE	int
,	O
pgnop	pointer
)	O
)	O
==	O
DB_NOTFOUND	O
)	O
{	O
ret	int
=	O
0	int
;	O
if	O
(	O
hcp	pointer
->	O
seek_found_page	int
!=	O
PGNO_INVALID	int
&&	O
hcp	pointer
->	O
seek_found_page	int
!=	O
hcp	pointer
->	O
pgno	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
hcp	pointer
->	O
pgno	int
=	O
hcp	pointer
->	O
seek_found_page	int
;	O
hcp	pointer
->	O
indx	short
=	O
NDX_INVALID	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
&&	O
data	pointer
->	O
doff	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_init_dbt	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
tmp_val	struct
,	O
data	pointer
->	O
size	int
+	O
data	pointer
->	O
doff	int
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
==	O
0	int
)	O
{	O
memset	function
(	O
tmp_val	struct
.	O
data	pointer
,	O
0	int
,	O
data	pointer
->	O
doff	int
)	O
;	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
tmp_val	struct
.	O
data	pointer
+	O
data	pointer
->	O
doff	int
,	O
data	pointer
->	O
data	pointer
,	O
data	pointer
->	O
size	int
)	O
;	O
myval	pointer
=	O
&	O
tmp_val	struct
;	O
}	O
}	O
else	O
myval	pointer
=	O
(	O
DBT	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___ham_add_el	function
(	O
dbc	pointer
,	O
key	struct
,	O
myval	pointer
,	O
H_KEYDATA	int
)	O
;	O
goto	O
done	O
;	O
}	O
break	O
;	O
case	O
DB_BEFORE	int
:	O
case	O
DB_AFTER	int
:	O
case	O
DB_CURRENT	int
:	O
ret	int
=	O
CDB___ham_item	function
(	O
dbc	pointer
,	O
DB_LOCK_WRITE	int
,	O
pgnop	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
pgnop	pointer
==	O
PGNO_INVALID	int
&&	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
flags	int
==	O
DB_CURRENT	int
||	O
(	O
(	O
flags	int
==	O
DB_KEYFIRST	int
||	O
flags	int
==	O
DB_KEYLAST	int
||	O
flags	int
==	O
DB_NODUPDATA	int
)	O
&&	O
!	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
||	O
F_ISSET	O
(	O
key	struct
,	O
DB_DBT_DUPOK	int
)	O
)	O
)	O
)	O
ret	int
=	O
__ham_overwrite	function
(	O
dbc	pointer
,	O
data	pointer
,	O
flags	int
)	O
;	O
else	O
ret	int
=	O
CDB___ham_add_dup	function
(	O
dbc	pointer
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
;	O
}	O
done	O
:	O
if	O
(	O
ret	int
==	O
0	int
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_EXPAND	int
)	O
)	O
{	O
ret	int
=	O
__ham_expand_table	function
(	O
dbc	pointer
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_EXPAND	int
)	O
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
&&	O
(	O
t_ret	int
=	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
err2	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
err1	O
:	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_expand_table	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
old_bucket	int
,	O
new_bucket	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_dirty_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
==	O
hcp	pointer
->	O
hdr	struct
->	O
high_mask	int
)	O
{	O
pgno	int
=	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
+	O
1	int
;	O
if	O
(	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
CDB___db_log2	function
(	O
pgno	int
)	O
+	O
1	int
]	O
==	O
PGNO_INVALID	int
)	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
DB_MPOOL_NEW_GROUP	int
,	O
&	O
h	pointer
)	O
;	O
else	O
{	O
pgno	int
=	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
CDB___db_log2	function
(	O
pgno	int
)	O
+	O
1	int
]	O
+	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
+	O
1	int
;	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
DB_MPOOL_CREATE	int
,	O
&	O
h	pointer
)	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
P_INIT	O
(	O
h	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
pgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
P_HASH	int
,	O
0	int
)	O
;	O
pgno	int
-=	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
;	O
}	O
else	O
{	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
+	O
1	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
DB_MPOOL_CREATE	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_metagroup_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
h	pointer
->	O
lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
,	O
pgno	int
,	O
&	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
lsn	struct
,	O
&	O
h	pointer
->	O
lsn	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
lsn	struct
=	O
h	pointer
->	O
lsn	struct
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
new_bucket	int
=	O
++	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
;	O
old_bucket	int
=	O
(	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
&	O
hcp	pointer
->	O
hdr	struct
->	O
low_mask	int
)	O
;	O
if	O
(	O
new_bucket	int
>	O
hcp	pointer
->	O
hdr	struct
->	O
high_mask	int
)	O
{	O
hcp	pointer
->	O
hdr	struct
->	O
low_mask	int
=	O
hcp	pointer
->	O
hdr	struct
->	O
high_mask	int
;	O
hcp	pointer
->	O
hdr	struct
->	O
high_mask	int
=	O
new_bucket	int
|	O
hcp	pointer
->	O
hdr	struct
->	O
low_mask	int
;	O
if	O
(	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
CDB___db_log2	function
(	O
new_bucket	int
)	O
+	O
1	int
]	O
==	O
PGNO_INVALID	int
)	O
hcp	pointer
->	O
hdr	struct
->	O
spares	array
[	O
CDB___db_log2	function
(	O
new_bucket	int
)	O
+	O
1	int
]	O
=	O
pgno	int
-	O
new_bucket	int
;	O
}	O
return	O
(	O
CDB___ham_split_page	function
(	O
dbc	pointer
,	O
old_bucket	int
,	O
new_bucket	int
)	O
)	O
;	O
}	O
u_int32_t	int
CDB___ham_call_hash	function
(	O
dbc	pointer
,	O
k	pointer
,	O
len	short
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int8_t	char
*	O
k	pointer
;	O
int32_t	int
len	short
;	O
{	O
u_int32_t	int
n	int
,	O
bucket	int
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
HASH	struct
*	O
hashp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
hashp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
->	O
h_internal	pointer
;	O
n	int
=	O
(	O
u_int32_t	int
)	O
(	O
hashp	pointer
->	O
h_hash	pointer
(	O
k	pointer
,	O
len	short
)	O
)	O
;	O
bucket	int
=	O
n	int
&	O
hcp	pointer
->	O
hdr	struct
->	O
high_mask	int
;	O
if	O
(	O
bucket	int
>	O
hcp	pointer
->	O
hdr	struct
->	O
max_bucket	int
)	O
bucket	int
=	O
bucket	int
&	O
hcp	pointer
->	O
hdr	struct
->	O
low_mask	int
;	O
return	O
(	O
bucket	int
)	O
;	O
}	O
static	O
int	O
__ham_dup_return	function
(	O
dbc	pointer
,	O
val	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
val	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
PAGE	struct
*	O
pp	pointer
;	O
DBT	struct
*	O
myval	pointer
,	O
tmp_val	struct
;	O
db_indx_t	short
ndx	int
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
off	long
,	O
tlen	int
;	O
u_int8_t	char
*	O
hk	pointer
,	O
type	enum
;	O
int	O
cmp	int
,	O
ret	int
;	O
db_indx_t	short
len	short
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ndx	int
=	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
;	O
type	enum
=	O
HPAGE_TYPE	O
(	O
hcp	pointer
->	O
page	pointer
,	O
ndx	int
)	O
;	O
pp	pointer
=	O
hcp	pointer
->	O
page	pointer
;	O
myval	pointer
=	O
val	pointer
;	O
DB_ASSERT	O
(	O
type	enum
!=	O
H_OFFDUP	int
)	O
;	O
if	O
(	O
type	enum
!=	O
H_DUPLICATE	int
&&	O
flags	int
!=	O
DB_GET_BOTH	int
&&	O
flags	int
!=	O
DB_GET_BOTHC	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
&&	O
type	enum
==	O
H_DUPLICATE	int
)	O
{	O
F_SET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
dup_tlen	short
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
pagesize	long
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
flags	int
==	O
DB_LAST	int
||	O
flags	int
==	O
DB_PREV	int
||	O
flags	int
==	O
DB_PREV_NODUP	int
)	O
{	O
hcp	pointer
->	O
dup_off	short
=	O
0	int
;	O
do	O
{	O
memcpy	function
(	O
&	O
len	short
,	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
+	O
hcp	pointer
->	O
dup_off	short
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
hcp	pointer
->	O
dup_off	short
+=	O
DUP_SIZE	O
(	O
len	short
)	O
;	O
}	O
while	O
(	O
hcp	pointer
->	O
dup_off	short
<	O
hcp	pointer
->	O
dup_tlen	short
)	O
;	O
hcp	pointer
->	O
dup_off	short
-=	O
DUP_SIZE	O
(	O
len	short
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
&	O
len	short
,	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
hcp	pointer
->	O
dup_off	short
=	O
0	int
;	O
}	O
hcp	pointer
->	O
dup_len	short
=	O
len	short
;	O
}	O
if	O
(	O
flags	int
==	O
DB_GET_BOTH	int
||	O
flags	int
==	O
DB_GET_BOTHC	int
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
)	O
{	O
if	O
(	O
flags	int
==	O
DB_GET_BOTHC	int
)	O
F_SET	O
(	O
hcp	pointer
,	O
H_CONTINUE	int
)	O
;	O
CDB___ham_dsearch	function
(	O
dbc	pointer
,	O
val	pointer
,	O
&	O
off	long
,	O
&	O
cmp	int
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_CONTINUE	int
)	O
;	O
hcp	pointer
->	O
dup_off	short
=	O
off	long
;	O
}	O
else	O
{	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
(	O
(	O
HKEYDATA	struct
*	O
)	O
hk	pointer
)	O
->	O
type	enum
==	O
H_OFFPAGE	int
)	O
{	O
memcpy	function
(	O
&	O
tlen	int
,	O
HOFFPAGE_TLEN	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
;	O
memcpy	function
(	O
&	O
pgno	int
,	O
HOFFPAGE_PGNO	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_moff	function
(	O
dbp	pointer
,	O
val	pointer
,	O
pgno	int
,	O
tlen	int
,	O
dbp	pointer
->	O
dup_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
tmp_val	struct
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
;	O
tmp_val	struct
.	O
size	int
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
cmp	int
=	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
CDB___bam_defcmp	function
(	O
&	O
tmp_val	struct
,	O
val	pointer
)	O
:	O
dbp	pointer
->	O
dup_compare	pointer
(	O
&	O
tmp_val	struct
,	O
val	pointer
)	O
;	O
}	O
}	O
if	O
(	O
cmp	int
!=	O
0	int
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
)	O
{	O
memcpy	function
(	O
&	O
tmp_val	struct
,	O
val	pointer
,	O
sizeof	O
(	O
*	O
val	pointer
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
tmp_val	struct
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
if	O
(	O
tmp_val	struct
.	O
doff	int
+	O
hcp	pointer
->	O
dup_off	short
>	O
hcp	pointer
->	O
dup_len	short
)	O
tmp_val	struct
.	O
dlen	int
=	O
0	int
;	O
else	O
if	O
(	O
tmp_val	struct
.	O
dlen	int
+	O
tmp_val	struct
.	O
doff	int
>	O
hcp	pointer
->	O
dup_len	short
)	O
tmp_val	struct
.	O
dlen	int
=	O
hcp	pointer
->	O
dup_len	short
-	O
tmp_val	struct
.	O
doff	int
;	O
tmp_val	struct
.	O
doff	int
+=	O
hcp	pointer
->	O
dup_off	short
;	O
}	O
else	O
{	O
F_SET	O
(	O
&	O
tmp_val	struct
,	O
DB_DBT_PARTIAL	int
)	O
;	O
tmp_val	struct
.	O
dlen	int
=	O
hcp	pointer
->	O
dup_len	short
;	O
tmp_val	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_off	short
+	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
}	O
myval	pointer
=	O
&	O
tmp_val	struct
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
pp	pointer
,	O
ndx	int
,	O
myval	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
val	pointer
->	O
data	pointer
=	O
myval	pointer
->	O
data	pointer
;	O
val	pointer
->	O
size	int
=	O
myval	pointer
->	O
size	int
;	O
F_SET	O
(	O
val	pointer
,	O
DB_DBT_ISSET	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_overwrite	function
(	O
dbc	pointer
,	O
nval	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
nval	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DBT	struct
*	O
myval	pointer
,	O
tmp_val	struct
,	O
tmp_val2	struct
;	O
void	O
*	O
newrec	pointer
;	O
u_int8_t	char
*	O
hk	pointer
,	O
*	O
p	pointer
;	O
u_int32_t	int
len	short
,	O
nondup_size	int
;	O
db_indx_t	short
newsize	short
;	O
int	O
ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
)	O
{	O
DB_ASSERT	O
(	O
hcp	pointer
->	O
opd	pointer
==	O
NULL	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
nval	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
memset	function
(	O
&	O
tmp_val	struct
,	O
0	int
,	O
sizeof	O
(	O
tmp_val	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__ham_dup_return	function
(	O
dbc	pointer
,	O
&	O
tmp_val	struct
,	O
DB_CURRENT	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
nondup_size	int
=	O
tmp_val	struct
.	O
size	int
;	O
newsize	short
=	O
nondup_size	int
;	O
if	O
(	O
nval	pointer
->	O
doff	int
>	O
nondup_size	int
)	O
newsize	short
+=	O
(	O
nval	pointer
->	O
doff	int
-	O
nondup_size	int
+	O
nval	pointer
->	O
size	int
)	O
;	O
else	O
if	O
(	O
nval	pointer
->	O
doff	int
+	O
nval	pointer
->	O
dlen	int
>	O
nondup_size	int
)	O
newsize	short
+=	O
nval	pointer
->	O
size	int
-	O
(	O
nondup_size	int
-	O
nval	pointer
->	O
doff	int
)	O
;	O
else	O
newsize	short
+=	O
nval	pointer
->	O
size	int
-	O
nval	pointer
->	O
dlen	int
;	O
if	O
(	O
ISBIG	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
dup_tlen	short
-	O
nondup_size	int
+	O
newsize	short
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_dup_convert	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
hcp	pointer
->	O
opd	pointer
->	O
c_am_put	pointer
(	O
hcp	pointer
->	O
opd	pointer
,	O
NULL	O
,	O
nval	pointer
,	O
flags	int
,	O
NULL	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
,	O
DUP_SIZE	O
(	O
newsize	short
)	O
,	O
NULL	O
,	O
&	O
newrec	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memset	function
(	O
&	O
tmp_val2	struct
,	O
0	int
,	O
sizeof	O
(	O
tmp_val2	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
tmp_val2	struct
,	O
DB_DBT_PARTIAL	int
)	O
;	O
p	pointer
=	O
newrec	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
newsize	short
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
len	short
=	O
nval	pointer
->	O
doff	int
>	O
tmp_val	struct
.	O
size	int
?	O
tmp_val	struct
.	O
size	int
:	O
nval	pointer
->	O
doff	int
;	O
memcpy	function
(	O
p	pointer
,	O
tmp_val	struct
.	O
data	pointer
,	O
len	short
)	O
;	O
p	pointer
+=	O
len	short
;	O
if	O
(	O
nval	pointer
->	O
doff	int
>	O
tmp_val	struct
.	O
size	int
)	O
{	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
nval	pointer
->	O
doff	int
-	O
tmp_val	struct
.	O
size	int
)	O
;	O
p	pointer
+=	O
nval	pointer
->	O
doff	int
-	O
tmp_val	struct
.	O
size	int
;	O
}	O
memcpy	function
(	O
p	pointer
,	O
nval	pointer
->	O
data	pointer
,	O
nval	pointer
->	O
size	int
)	O
;	O
p	pointer
+=	O
nval	pointer
->	O
size	int
;	O
if	O
(	O
nval	pointer
->	O
doff	int
+	O
nval	pointer
->	O
dlen	int
<	O
tmp_val	struct
.	O
size	int
)	O
{	O
len	short
=	O
tmp_val	struct
.	O
size	int
-	O
nval	pointer
->	O
doff	int
-	O
nval	pointer
->	O
dlen	int
;	O
memcpy	function
(	O
p	pointer
,	O
(	O
u_int8_t	char
*	O
)	O
tmp_val	struct
.	O
data	pointer
+	O
nval	pointer
->	O
doff	int
+	O
nval	pointer
->	O
dlen	int
,	O
len	short
)	O
;	O
p	pointer
+=	O
len	short
;	O
}	O
memcpy	function
(	O
p	pointer
,	O
&	O
newsize	short
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
if	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
{	O
tmp_val2	struct
.	O
data	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
newrec	pointer
+	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
tmp_val2	struct
.	O
size	int
=	O
newsize	short
;	O
if	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dup_compare	pointer
(	O
&	O
tmp_val	struct
,	O
&	O
tmp_val2	struct
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___os_free	function
(	O
newrec	pointer
,	O
DUP_SIZE	O
(	O
newsize	short
)	O
)	O
;	O
return	O
(	O
CDB___db_duperr	function
(	O
dbc	pointer
->	O
dbp	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
}	O
tmp_val2	struct
.	O
data	pointer
=	O
newrec	pointer
;	O
tmp_val2	struct
.	O
size	int
=	O
DUP_SIZE	O
(	O
newsize	short
)	O
;	O
tmp_val2	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_off	short
;	O
tmp_val2	struct
.	O
dlen	int
=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
ret	int
=	O
CDB___ham_replpair	function
(	O
dbc	pointer
,	O
&	O
tmp_val2	struct
,	O
0	int
)	O
;	O
(	O
void	O
)	O
CDB___os_free	function
(	O
newrec	pointer
,	O
DUP_SIZE	O
(	O
newsize	short
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
newsize	short
>	O
nondup_size	int
)	O
hcp	pointer
->	O
dup_tlen	short
+=	O
(	O
newsize	short
-	O
nondup_size	int
)	O
;	O
else	O
hcp	pointer
->	O
dup_tlen	short
-=	O
(	O
nondup_size	int
-	O
newsize	short
)	O
;	O
hcp	pointer
->	O
dup_len	short
=	O
DUP_SIZE	O
(	O
newsize	short
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ISBIG	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
dup_tlen	short
-	O
hcp	pointer
->	O
dup_len	short
+	O
nval	pointer
->	O
size	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_dup_convert	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
hcp	pointer
->	O
opd	pointer
->	O
c_am_put	pointer
(	O
hcp	pointer
->	O
opd	pointer
,	O
NULL	O
,	O
nval	pointer
,	O
flags	int
,	O
NULL	O
)	O
)	O
;	O
}	O
if	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
{	O
tmp_val2	struct
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
+	O
hcp	pointer
->	O
dup_off	short
+	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
tmp_val2	struct
.	O
size	int
=	O
hcp	pointer
->	O
dup_len	short
;	O
if	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dup_compare	pointer
(	O
nval	pointer
,	O
&	O
tmp_val2	struct
)	O
!=	O
0	int
)	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_make_dup	function
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
,	O
nval	pointer
,	O
&	O
tmp_val	struct
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
tmp_val	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_off	short
;	O
tmp_val	struct
.	O
dlen	int
=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
if	O
(	O
nval	pointer
->	O
size	int
>	O
hcp	pointer
->	O
dup_len	short
)	O
hcp	pointer
->	O
dup_tlen	short
+=	O
(	O
nval	pointer
->	O
size	int
-	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
else	O
hcp	pointer
->	O
dup_tlen	short
-=	O
(	O
hcp	pointer
->	O
dup_len	short
-	O
nval	pointer
->	O
size	int
)	O
;	O
hcp	pointer
->	O
dup_len	short
=	O
DUP_SIZE	O
(	O
nval	pointer
->	O
size	int
)	O
;	O
}	O
myval	pointer
=	O
&	O
tmp_val	struct
;	O
}	O
else	O
if	O
(	O
!	O
F_ISSET	O
(	O
nval	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
memcpy	function
(	O
&	O
tmp_val	struct
,	O
nval	pointer
,	O
sizeof	O
(	O
*	O
nval	pointer
)	O
)	O
;	O
F_SET	O
(	O
&	O
tmp_val	struct
,	O
DB_DBT_PARTIAL	int
)	O
;	O
tmp_val	struct
.	O
doff	int
=	O
0	int
;	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFPAGE	int
)	O
memcpy	function
(	O
&	O
tmp_val	struct
.	O
dlen	int
,	O
HOFFPAGE_TLEN	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
;	O
else	O
tmp_val	struct
.	O
dlen	int
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
hdr	struct
->	O
dbmeta	struct
.	O
pagesize	long
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
myval	pointer
=	O
&	O
tmp_val	struct
;	O
}	O
else	O
myval	pointer
=	O
nval	pointer
;	O
return	O
(	O
CDB___ham_replpair	function
(	O
dbc	pointer
,	O
myval	pointer
,	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
__ham_lookup	function
(	O
dbc	pointer
,	O
key	struct
,	O
sought	int
,	O
mode	enum
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
sought	int
;	O
db_lockmode_t	enum
mode	enum
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
tlen	int
;	O
int	O
match	int
,	O
ret	int
;	O
u_int8_t	char
*	O
hk	pointer
,	O
*	O
dk	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_item_reset	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
seek_size	int
=	O
sought	int
;	O
hcp	pointer
->	O
bucket	int
=	O
CDB___ham_call_hash	function
(	O
dbc	pointer
,	O
(	O
u_int8_t	char
*	O
)	O
key	struct
->	O
data	pointer
,	O
key	struct
->	O
size	int
)	O
;	O
hcp	pointer
->	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
*	O
pgnop	pointer
=	O
PGNO_INVALID	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
)	O
break	O
;	O
hk	pointer
=	O
H_PAIRKEY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
switch	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
)	O
{	O
case	O
H_OFFPAGE	int
:	O
memcpy	function
(	O
&	O
tlen	int
,	O
HOFFPAGE_TLEN	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
;	O
if	O
(	O
tlen	int
==	O
key	struct
->	O
size	int
)	O
{	O
memcpy	function
(	O
&	O
pgno	int
,	O
HOFFPAGE_PGNO	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_moff	function
(	O
dbp	pointer
,	O
key	struct
,	O
pgno	int
,	O
tlen	int
,	O
NULL	O
,	O
&	O
match	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
match	int
==	O
0	int
)	O
goto	O
found_key	O
;	O
}	O
break	O
;	O
case	O
H_KEYDATA	int
:	O
if	O
(	O
key	struct
->	O
size	int
==	O
LEN_HKEY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
&&	O
memcmp	function
(	O
key	struct
->	O
data	pointer
,	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
,	O
key	struct
->	O
size	int
)	O
==	O
0	int
)	O
{	O
found_key	O
:	O
F_SET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
dk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
dk	pointer
)	O
==	O
H_OFFDUP	int
)	O
memcpy	function
(	O
pgnop	pointer
,	O
HOFFDUP_PGNO	O
(	O
dk	pointer
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
case	O
H_OFFDUP	int
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
sought	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_init_dbt	function
(	O
dbenv	pointer
,	O
dbt	struct
,	O
size	int
,	O
bufp	pointer
,	O
sizep	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBT	struct
*	O
dbt	struct
;	O
u_int32_t	int
size	int
;	O
void	O
*	O
*	O
bufp	pointer
;	O
u_int32_t	int
*	O
sizep	pointer
;	O
{	O
int	O
ret	int
;	O
memset	function
(	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
*	O
dbt	struct
)	O
)	O
;	O
if	O
(	O
*	O
sizep	pointer
<	O
size	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbenv	pointer
,	O
size	int
,	O
NULL	O
,	O
bufp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
sizep	pointer
=	O
0	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
*	O
sizep	pointer
=	O
size	int
;	O
}	O
dbt	struct
->	O
data	pointer
=	O
*	O
bufp	pointer
;	O
dbt	struct
->	O
size	int
=	O
size	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
CDB___ham_c_update	function
(	O
dbc	pointer
,	O
chg_pgno	int
,	O
len	short
,	O
add	int
,	O
is_dup	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
chg_pgno	int
;	O
u_int32_t	int
len	short
;	O
int	O
add	int
,	O
is_dup	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
cp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
,	O
*	O
lcp	pointer
;	O
int	O
page_deleted	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
!	O
is_dup	int
&&	O
add	int
)	O
return	O
;	O
page_deleted	int
=	O
chg_pgno	int
!=	O
PGNO_INVALID	int
&&	O
chg_pgno	int
!=	O
hcp	pointer
->	O
pgno	int
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
;	O
cp	pointer
!=	O
NULL	O
;	O
cp	pointer
=	O
TAILQ_NEXT	O
(	O
cp	pointer
,	O
links	struct
)	O
)	O
{	O
if	O
(	O
cp	pointer
==	O
dbc	pointer
)	O
continue	O
;	O
lcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
cp	pointer
->	O
internal	pointer
;	O
if	O
(	O
lcp	pointer
->	O
pgno	int
!=	O
chg_pgno	int
)	O
continue	O
;	O
if	O
(	O
is_dup	int
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
&&	O
lcp	pointer
->	O
pgno	int
!=	O
chg_pgno	int
)	O
continue	O
;	O
if	O
(	O
page_deleted	int
)	O
{	O
lcp	pointer
->	O
pgno	int
=	O
hcp	pointer
->	O
pgno	int
;	O
lcp	pointer
->	O
indx	short
=	O
hcp	pointer
->	O
indx	short
;	O
lcp	pointer
->	O
bucket	int
=	O
hcp	pointer
->	O
bucket	int
;	O
F_CLR	O
(	O
lcp	pointer
,	O
H_ISDUP	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
lcp	pointer
->	O
indx	short
==	O
NDX_INVALID	int
)	O
continue	O
;	O
if	O
(	O
!	O
is_dup	int
&&	O
lcp	pointer
->	O
indx	short
>	O
hcp	pointer
->	O
indx	short
)	O
lcp	pointer
->	O
indx	short
-=	O
2	int
;	O
else	O
if	O
(	O
!	O
is_dup	int
&&	O
lcp	pointer
->	O
indx	short
==	O
hcp	pointer
->	O
indx	short
)	O
{	O
if	O
(	O
add	int
)	O
lcp	pointer
->	O
indx	short
+=	O
2	int
;	O
else	O
F_SET	O
(	O
lcp	pointer
,	O
H_DELETED	int
)	O
;	O
}	O
else	O
if	O
(	O
is_dup	int
&&	O
lcp	pointer
->	O
pgno	int
==	O
chg_pgno	int
&&	O
lcp	pointer
->	O
indx	short
==	O
hcp	pointer
->	O
indx	short
)	O
{	O
if	O
(	O
add	int
)	O
{	O
lcp	pointer
->	O
dup_tlen	short
+=	O
len	short
;	O
if	O
(	O
lcp	pointer
->	O
dup_off	short
>=	O
hcp	pointer
->	O
dup_off	short
)	O
lcp	pointer
->	O
dup_off	short
+=	O
len	short
;	O
}	O
else	O
{	O
lcp	pointer
->	O
dup_tlen	short
-=	O
len	short
;	O
if	O
(	O
lcp	pointer
->	O
dup_off	short
>	O
hcp	pointer
->	O
dup_off	short
)	O
lcp	pointer
->	O
dup_off	short
-=	O
len	short
;	O
else	O
if	O
(	O
lcp	pointer
->	O
dup_off	short
==	O
hcp	pointer
->	O
dup_off	short
)	O
F_SET	O
(	O
lcp	pointer
,	O
H_DELETED	int
)	O
;	O
}	O
}	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
}	O
int	O
CDB___ham_get_clist	function
(	O
dbp	pointer
,	O
bucket	int
,	O
indx	short
,	O
listp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
db_pgno_t	int
bucket	int
;	O
u_int32_t	int
indx	short
;	O
DBC	struct
*	O
*	O
*	O
listp	pointer
;	O
{	O
DBC	struct
*	O
cp	pointer
;	O
int	O
nalloc	int
,	O
nused	int
,	O
ret	int
;	O
nalloc	int
=	O
nused	int
=	O
0	int
;	O
*	O
listp	pointer
=	O
NULL	O
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
;	O
cp	pointer
!=	O
NULL	O
;	O
cp	pointer
=	O
TAILQ_NEXT	O
(	O
cp	pointer
,	O
links	struct
)	O
)	O
if	O
(	O
cp	pointer
->	O
dbtype	enum
==	O
DB_HASH	int
&&	O
(	O
(	O
indx	short
==	O
NDX_INVALID	int
&&	O
(	O
(	O
HASH_CURSOR	struct
*	O
)	O
(	O
cp	pointer
->	O
internal	pointer
)	O
)	O
->	O
bucket	int
==	O
bucket	int
)	O
||	O
(	O
indx	short
!=	O
NDX_INVALID	int
&&	O
cp	pointer
->	O
internal	pointer
->	O
pgno	int
==	O
bucket	int
&&	O
cp	pointer
->	O
internal	pointer
->	O
indx	short
==	O
indx	short
)	O
)	O
)	O
{	O
if	O
(	O
nused	int
>=	O
nalloc	int
)	O
{	O
nalloc	int
+=	O
10	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
nalloc	int
*	O
sizeof	O
(	O
HASH_CURSOR	struct
*	O
)	O
,	O
NULL	O
,	O
listp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
(	O
*	O
listp	pointer
)	O
[	O
nused	int
++	O
]	O
=	O
cp	pointer
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
listp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
nused	int
>=	O
nalloc	int
)	O
{	O
nalloc	int
++	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
nalloc	int
*	O
sizeof	O
(	O
HASH_CURSOR	struct
*	O
)	O
,	O
NULL	O
,	O
listp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
(	O
*	O
listp	pointer
)	O
[	O
nused	int
]	O
=	O
NULL	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_del_dups	function
(	O
orig_dbc	pointer
,	O
key	struct
)	O
DBC	struct
*	O
orig_dbc	pointer
;	O
DBT	struct
*	O
key	struct
;	O
{	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
data	pointer
,	O
lkey	struct
;	O
int	O
ret	int
,	O
t_ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
orig_dbc	pointer
->	O
c_dup	pointer
(	O
orig_dbc	pointer
,	O
&	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memset	function
(	O
&	O
lkey	struct
,	O
0	int
,	O
sizeof	O
(	O
lkey	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
lkey	struct
,	O
DB_DBT_USERMEM	int
|	O
DB_DBT_PARTIAL	int
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
F_SET	O
(	O
&	O
data	pointer
,	O
DB_DBT_USERMEM	int
|	O
DB_DBT_PARTIAL	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_get	pointer
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
data	pointer
,	O
DB_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_NOTFOUND	O
)	O
ret	int
=	O
0	int
;	O
goto	O
err	pointer
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_del	pointer
(	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_get	pointer
(	O
dbc	pointer
,	O
&	O
lkey	struct
,	O
&	O
data	pointer
,	O
DB_NEXT_DUP	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_NOTFOUND	O
)	O
{	O
ret	int
=	O
0	int
;	O
break	O
;	O
}	O
goto	O
err	pointer
;	O
}	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_c_writelock	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DB_LOCK	struct
tmp_lock	struct
;	O
int	O
ret	int
;	O
if	O
(	O
!	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
)	O
return	O
(	O
0	int
)	O
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
hcp	pointer
->	O
lock	struct
.	O
off	long
==	O
LOCK_INVALID	O
||	O
hcp	pointer
->	O
lock_mode	enum
==	O
DB_LOCK_READ	int
)	O
)	O
{	O
tmp_lock	struct
=	O
hcp	pointer
->	O
lock	struct
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_lock_bucket	function
(	O
dbc	pointer
,	O
DB_LOCK_WRITE	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
tmp_lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
&&	O
(	O
ret	int
=	O
CDB_lock_put	function
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
tmp_lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
CDB___ham_c_chgpg	function
(	O
dbc	pointer
,	O
old_pgno	int
,	O
old_index	int
,	O
new_pgno	int
,	O
new_index	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
old_pgno	int
,	O
new_pgno	int
;	O
u_int32_t	int
old_index	int
,	O
new_index	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
cp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
;	O
cp	pointer
!=	O
NULL	O
;	O
cp	pointer
=	O
TAILQ_NEXT	O
(	O
cp	pointer
,	O
links	struct
)	O
)	O
{	O
if	O
(	O
cp	pointer
==	O
dbc	pointer
)	O
continue	O
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
cp	pointer
->	O
internal	pointer
;	O
if	O
(	O
hcp	pointer
->	O
pgno	int
==	O
old_pgno	int
)	O
{	O
if	O
(	O
old_index	int
==	O
NDX_INVALID	int
)	O
hcp	pointer
->	O
pgno	int
=	O
new_pgno	int
;	O
else	O
if	O
(	O
hcp	pointer
->	O
indx	short
==	O
old_index	int
)	O
{	O
hcp	pointer
->	O
pgno	int
=	O
new_pgno	int
;	O
hcp	pointer
->	O
indx	short
=	O
new_index	int
;	O
}	O
}	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
}	O
