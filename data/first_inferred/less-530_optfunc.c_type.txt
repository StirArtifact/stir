extern	O
int	O
nbufs	int
;	O
extern	O
int	O
bufspace	int
;	O
extern	O
int	O
pr_type	int
;	O
extern	O
int	O
plusoption	int
;	O
extern	O
int	O
swindow	int
;	O
extern	O
int	O
sc_width	int
;	O
extern	O
int	O
sc_height	int
;	O
extern	O
int	O
secure	int
;	O
extern	O
int	O
dohelp	int
;	O
extern	O
int	O
any_display	int
;	O
extern	O
char	O
openquote	char
;	O
extern	O
char	O
closequote	char
;	O
extern	O
char	O
*	O
prproto	array
[	O
]	O
;	O
extern	O
char	O
*	O
eqproto	pointer
;	O
extern	O
char	O
*	O
hproto	pointer
;	O
extern	O
char	O
*	O
wproto	pointer
;	O
extern	O
char	O
*	O
every_first_cmd	pointer
;	O
extern	O
IFILE	O
curr_ifile	pointer
;	O
extern	O
char	O
version	array
[	O
]	O
;	O
extern	O
int	O
jump_sline	int
;	O
extern	O
long	O
jump_sline_fraction	long
;	O
extern	O
int	O
shift_count	int
;	O
extern	O
long	O
shift_count_fraction	long
;	O
extern	O
LWCHAR	long
rscroll_char	long
;	O
extern	O
int	O
rscroll_attr	int
;	O
extern	O
int	O
less_is_more	int
;	O
extern	O
char	O
*	O
namelogfile	pointer
;	O
extern	O
int	O
force_logfile	int
;	O
extern	O
int	O
logfile	int
;	O
public	O
char	O
*	O
tagoption	pointer
=	O
NULL	O
;	O
extern	O
char	O
*	O
tags	pointer
;	O
extern	O
char	O
ztags	array
[	O
]	O
;	O
public	O
void	O
opt_o	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
PARG	union
parg	union
;	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
secure	int
)	O
{	O
error	function
(	O
"log file support is not available"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
namelogfile	pointer
=	O
save	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
TOGGLE	int
:	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_CANSEEK	int
)	O
{	O
error	function
(	O
"Input is not a pipe"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
logfile	int
>=	O
0	int
)	O
{	O
error	function
(	O
"Log file is already in use"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
s	pointer
=	O
skipsp	function
(	O
s	pointer
)	O
;	O
if	O
(	O
namelogfile	pointer
!=	O
NULL	O
)	O
free	function
(	O
namelogfile	pointer
)	O
;	O
filename	pointer
=	O
lglob	function
(	O
s	pointer
)	O
;	O
namelogfile	pointer
=	O
shell_unquote	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
use_logfile	function
(	O
namelogfile	pointer
)	O
;	O
sync_logfile	function
(	O
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
if	O
(	O
logfile	int
<	O
0	int
)	O
error	function
(	O
"No log file"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
{	O
parg	union
.	O
p_string	pointer
=	O
namelogfile	pointer
;	O
error	function
(	O
"Log file \"%s\""	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__O	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
force_logfile	int
=	O
TRUE	int
;	O
opt_o	function
(	O
type	int
,	O
s	pointer
)	O
;	O
}	O
public	O
void	O
opt_j	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
PARG	union
parg	union
;	O
char	O
buf	pointer
[	O
16	int
]	O
;	O
int	O
len	int
;	O
int	O
err	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
)	O
{	O
s	pointer
++	O
;	O
jump_sline_fraction	long
=	O
getfraction	function
(	O
&	O
s	pointer
,	O
"j"	pointer
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
"Invalid line fraction"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
calc_jump_sline	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
sline	int
=	O
getnum	function
(	O
&	O
s	pointer
,	O
"j"	pointer
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
"Invalid line number"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
{	O
jump_sline	int
=	O
sline	int
;	O
jump_sline_fraction	long
=	O
-	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
QUERY	int
:	O
if	O
(	O
jump_sline_fraction	long
<	O
0	int
)	O
{	O
parg	union
.	O
p_int	int
=	O
jump_sline	int
;	O
error	function
(	O
"Position target at screen line %d"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
buf	pointer
,	O
".%06ld"	pointer
,	O
jump_sline_fraction	long
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
len	int
>	O
2	int
&&	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'0'	O
)	O
len	int
--	O
;	O
buf	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
parg	union
.	O
p_string	pointer
=	O
buf	pointer
;	O
error	function
(	O
"Position target at screen position %s"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
calc_jump_sline	function
(	O
)	O
{	O
if	O
(	O
jump_sline_fraction	long
<	O
0	int
)	O
return	O
;	O
jump_sline	int
=	O
sc_height	int
*	O
jump_sline_fraction	long
/	O
NUM_FRAC_DENOM	int
;	O
}	O
public	O
void	O
opt_shift	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
PARG	union
parg	union
;	O
char	O
buf	pointer
[	O
16	int
]	O
;	O
int	O
len	int
;	O
int	O
err	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
)	O
{	O
s	pointer
++	O
;	O
shift_count_fraction	long
=	O
getfraction	function
(	O
&	O
s	pointer
,	O
"#"	pointer
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
"Invalid column fraction"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
calc_shift_count	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
hs	int
=	O
getnum	function
(	O
&	O
s	pointer
,	O
"#"	pointer
,	O
&	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
"Invalid column number"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
{	O
shift_count	int
=	O
hs	int
;	O
shift_count_fraction	long
=	O
-	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
QUERY	int
:	O
if	O
(	O
shift_count_fraction	long
<	O
0	int
)	O
{	O
parg	union
.	O
p_int	int
=	O
shift_count	int
;	O
error	function
(	O
"Horizontal shift %d columns"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
buf	pointer
,	O
".%06ld"	pointer
,	O
shift_count_fraction	long
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
len	int
>	O
2	int
&&	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'0'	O
)	O
len	int
--	O
;	O
buf	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
parg	union
.	O
p_string	pointer
=	O
buf	pointer
;	O
error	function
(	O
"Horizontal shift %s of screen width"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
calc_shift_count	function
(	O
)	O
{	O
if	O
(	O
shift_count_fraction	long
<	O
0	int
)	O
return	O
;	O
shift_count	int
=	O
sc_width	int
*	O
shift_count_fraction	long
/	O
NUM_FRAC_DENOM	int
;	O
}	O
public	O
void	O
opt_k	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
PARG	union
parg	union
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
if	O
(	O
lesskey	function
(	O
s	pointer
,	O
0	int
)	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
s	pointer
;	O
error	function
(	O
"Cannot use lesskey file \"%s\""	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_t	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
IFILE	O
save_ifile	pointer
;	O
POSITION	long
pos	long
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
tagoption	pointer
=	O
save	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
TOGGLE	int
:	O
if	O
(	O
secure	int
)	O
{	O
error	function
(	O
"tags support is not available"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
findtag	function
(	O
skipsp	function
(	O
s	pointer
)	O
)	O
;	O
save_ifile	pointer
=	O
save_curr_ifile	function
(	O
)	O
;	O
if	O
(	O
edit_tagfile	function
(	O
)	O
||	O
(	O
pos	long
=	O
tagsearch	function
(	O
)	O
)	O
==	O
NULL_POSITION	O
)	O
{	O
reedit_ifile	function
(	O
save_ifile	pointer
)	O
;	O
break	O
;	O
}	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
jump_loc	function
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__T	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
PARG	union
parg	union
;	O
char	O
*	O
filename	pointer
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
tags	pointer
=	O
save	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
TOGGLE	int
:	O
s	pointer
=	O
skipsp	function
(	O
s	pointer
)	O
;	O
if	O
(	O
tags	pointer
!=	O
NULL	O
&&	O
tags	pointer
!=	O
ztags	array
)	O
free	function
(	O
tags	pointer
)	O
;	O
filename	pointer
=	O
lglob	function
(	O
s	pointer
)	O
;	O
tags	pointer
=	O
shell_unquote	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
parg	union
.	O
p_string	pointer
=	O
tags	pointer
;	O
error	function
(	O
"Tags file \"%s\""	pointer
,	O
&	O
parg	union
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_p	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
if	O
(	O
less_is_more	int
)	O
{	O
every_first_cmd	pointer
=	O
save	function
(	O
s	pointer
)	O
;	O
}	O
else	O
{	O
plusoption	int
=	O
TRUE	int
;	O
ungetcc	function
(	O
CHAR_END_COMMAND	int
)	O
;	O
ungetsc	function
(	O
s	pointer
)	O
;	O
ungetsc	function
(	O
"/"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__P	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
char	O
*	O
*	O
proto	pointer
;	O
PARG	union
parg	union
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
's'	O
:	O
proto	pointer
=	O
&	O
prproto	array
[	O
PR_SHORT	int
]	O
;	O
s	pointer
++	O
;	O
break	O
;	O
case	O
'm'	O
:	O
proto	pointer
=	O
&	O
prproto	array
[	O
PR_MEDIUM	int
]	O
;	O
s	pointer
++	O
;	O
break	O
;	O
case	O
'M'	O
:	O
proto	pointer
=	O
&	O
prproto	array
[	O
PR_LONG	int
]	O
;	O
s	pointer
++	O
;	O
break	O
;	O
case	O
'='	O
:	O
proto	pointer
=	O
&	O
eqproto	pointer
;	O
s	pointer
++	O
;	O
break	O
;	O
case	O
'h'	O
:	O
proto	pointer
=	O
&	O
hproto	pointer
;	O
s	pointer
++	O
;	O
break	O
;	O
case	O
'w'	O
:	O
proto	pointer
=	O
&	O
wproto	pointer
;	O
s	pointer
++	O
;	O
break	O
;	O
default	O
:	O
proto	pointer
=	O
&	O
prproto	array
[	O
PR_SHORT	int
]	O
;	O
break	O
;	O
}	O
free	function
(	O
*	O
proto	pointer
)	O
;	O
*	O
proto	pointer
=	O
save	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
parg	union
.	O
p_string	pointer
=	O
prproto	array
[	O
pr_type	int
]	O
;	O
error	function
(	O
"%s"	pointer
,	O
&	O
parg	union
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_b	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
ch_setbufspace	function
(	O
bufspace	int
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_i	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
TOGGLE	int
:	O
chg_caseless	function
(	O
)	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
case	O
INIT	int
:	O
break	O
;	O
}	O
}	O
public	O
void	O
opt__V	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
TOGGLE	int
:	O
case	O
QUERY	int
:	O
dispversion	function
(	O
)	O
;	O
break	O
;	O
case	O
INIT	int
:	O
any_display	int
=	O
1	int
;	O
putstr	function
(	O
"less "	pointer
)	O
;	O
putstr	function
(	O
version	array
)	O
;	O
putstr	function
(	O
" ("	pointer
)	O
;	O
putstr	function
(	O
"POSIX "	pointer
)	O
;	O
putstr	function
(	O
"regular expressions)\n"	pointer
)	O
;	O
putstr	function
(	O
"Copyright (C) 1984-2017  Mark Nudelman\n\n"	pointer
)	O
;	O
putstr	function
(	O
"less comes with NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
;	O
putstr	function
(	O
"For information about the terms of redistribution,\n"	pointer
)	O
;	O
putstr	function
(	O
"see the file named README in the less distribution.\n"	pointer
)	O
;	O
putstr	function
(	O
"Homepage: http://www.greenwoodsoftware.com/less\n"	pointer
)	O
;	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_x	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
extern	O
int	O
tabstops	array
[	O
]	O
;	O
extern	O
int	O
ntabstops	int
;	O
extern	O
int	O
tabdefault	int
;	O
char	O
msg	array
[	O
60	int
+	O
(	O
4	int
*	O
TABSTOP_MAX	int
)	O
]	O
;	O
int	O
i	int
;	O
PARG	union
p	pointer
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
TABSTOP_MAX	int
;	O
)	O
{	O
int	O
n	int
=	O
0	int
;	O
s	pointer
=	O
skipsp	function
(	O
s	pointer
)	O
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
n	int
=	O
(	O
10	int
*	O
n	int
)	O
+	O
(	O
*	O
s	pointer
++	O
-	O
'0'	O
)	O
;	O
if	O
(	O
n	int
>	O
tabstops	array
[	O
i	int
-	O
1	int
]	O
)	O
tabstops	array
[	O
i	int
++	O
]	O
=	O
n	int
;	O
s	pointer
=	O
skipsp	function
(	O
s	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
++	O
!=	O
','	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
<	O
2	int
)	O
return	O
;	O
ntabstops	int
=	O
i	int
;	O
tabdefault	int
=	O
tabstops	array
[	O
ntabstops	int
-	O
1	int
]	O
-	O
tabstops	array
[	O
ntabstops	int
-	O
2	int
]	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
strcpy	function
(	O
msg	array
,	O
"Tab stops "	pointer
)	O
;	O
if	O
(	O
ntabstops	int
>	O
2	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
ntabstops	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
strcat	function
(	O
msg	array
,	O
","	pointer
)	O
;	O
sprintf	function
(	O
msg	array
+	O
strlen	function
(	O
msg	array
)	O
,	O
"%d"	pointer
,	O
tabstops	array
[	O
i	int
]	O
)	O
;	O
}	O
sprintf	function
(	O
msg	array
+	O
strlen	function
(	O
msg	array
)	O
,	O
" and then "	pointer
)	O
;	O
}	O
sprintf	function
(	O
msg	array
+	O
strlen	function
(	O
msg	array
)	O
,	O
"every %d spaces"	pointer
,	O
tabdefault	int
)	O
;	O
p	pointer
.	O
p_string	pointer
=	O
msg	array
;	O
error	function
(	O
"%s"	pointer
,	O
&	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_quote	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
char	O
buf	pointer
[	O
3	int
]	O
;	O
PARG	union
parg	union
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
if	O
(	O
s	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
openquote	char
=	O
closequote	char
=	O
'\0'	O
;	O
break	O
;	O
}	O
if	O
(	O
s	pointer
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
s	pointer
[	O
2	int
]	O
!=	O
'\0'	O
)	O
{	O
error	function
(	O
"-\" must be followed by 1 or 2 chars"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
openquote	char
=	O
s	pointer
[	O
0	int
]	O
;	O
if	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
closequote	char
=	O
openquote	char
;	O
else	O
closequote	char
=	O
s	pointer
[	O
1	int
]	O
;	O
break	O
;	O
case	O
QUERY	int
:	O
buf	pointer
[	O
0	int
]	O
=	O
openquote	char
;	O
buf	pointer
[	O
1	int
]	O
=	O
closequote	char
;	O
buf	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
parg	union
.	O
p_string	pointer
=	O
buf	pointer
;	O
error	function
(	O
"quotes %s"	pointer
,	O
&	O
parg	union
)	O
;	O
break	O
;	O
}	O
}	O
public	O
void	O
opt_rscroll	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
PARG	union
p	pointer
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
INIT	int
:	O
case	O
TOGGLE	int
:	O
{	O
char	O
*	O
fmt	pointer
;	O
int	O
attr	int
=	O
AT_STANDOUT	O
;	O
setfmt	function
(	O
s	pointer
,	O
&	O
fmt	pointer
,	O
&	O
attr	int
,	O
"*s>"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
fmt	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
rscroll_char	long
=	O
0	int
;	O
}	O
else	O
{	O
rscroll_char	long
=	O
*	O
fmt	pointer
?	O
*	O
fmt	pointer
:	O
'>'	O
;	O
rscroll_attr	int
=	O
attr	int
;	O
}	O
break	O
;	O
}	O
case	O
QUERY	int
:	O
{	O
p	pointer
.	O
p_string	pointer
=	O
rscroll_char	long
?	O
prchar	function
(	O
rscroll_char	long
)	O
:	O
"-"	pointer
;	O
error	function
(	O
"rscroll char is %s"	pointer
,	O
&	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
public	O
void	O
opt_query	function
(	O
type	int
,	O
s	pointer
)	O
int	O
type	int
;	O
char	O
*	O
s	pointer
;	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
QUERY	int
:	O
case	O
TOGGLE	int
:	O
error	function
(	O
"Use \"h\" for help"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
INIT	int
:	O
dohelp	int
=	O
1	int
;	O
}	O
}	O
public	O
int	O
get_swindow	function
(	O
)	O
{	O
if	O
(	O
swindow	int
>	O
0	int
)	O
return	O
(	O
swindow	int
)	O
;	O
return	O
(	O
sc_height	int
+	O
swindow	int
)	O
;	O
}	O
