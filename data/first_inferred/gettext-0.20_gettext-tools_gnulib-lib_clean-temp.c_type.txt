struct	O
tempdir	struct
{	O
char	O
*	O
volatile	O
dirname	pointer
;	O
bool	bool
cleanup_verbose	bool
;	O
gl_list_t	pointer
volatile	O
subdirs	pointer
;	O
gl_list_t	pointer
volatile	O
files	pointer
;	O
}	O
;	O
static	O
struct	O
{	O
struct	O
tempdir	struct
*	O
volatile	O
*	O
volatile	O
tempdir_list	pointer
;	O
size_t	long
volatile	O
tempdir_count	long
;	O
size_t	long
tempdir_allocated	long
;	O
}	O
cleanup_list	struct
;	O
static	O
gl_list_t	pointer
volatile	O
descriptors	pointer
;	O
static	O
bool	bool
string_equals	function
(	O
const	O
void	O
*	O
x1	pointer
,	O
const	O
void	O
*	O
x2	pointer
)	O
{	O
const	O
char	O
*	O
s1	pointer
=	O
(	O
const	O
char	O
*	O
)	O
x1	pointer
;	O
const	O
char	O
*	O
s2	pointer
=	O
(	O
const	O
char	O
*	O
)	O
x2	pointer
;	O
return	O
strcmp	function
(	O
s1	pointer
,	O
s2	pointer
)	O
==	O
0	int
;	O
}	O
static	O
size_t	long
string_hash	function
(	O
const	O
void	O
*	O
x	pointer
)	O
{	O
const	O
char	O
*	O
s	long
=	O
(	O
const	O
char	O
*	O
)	O
x	pointer
;	O
size_t	long
h	long
=	O
0	int
;	O
for	O
(	O
;	O
*	O
s	long
;	O
s	long
++	O
)	O
h	long
=	O
*	O
s	long
+	O
(	O
(	O
h	long
<<	O
9	int
)	O
|	O
(	O
h	long
>>	O
(	O
SIZE_BITS	O
-	O
9	int
)	O
)	O
)	O
;	O
return	O
h	long
;	O
}	O
static	O
_GL_ASYNC_SAFE	O
void	O
cleanup_action	function
(	O
int	O
sig	int
_GL_UNUSED	O
)	O
{	O
size_t	long
i	long
;	O
{	O
gl_list_t	pointer
fds	pointer
=	O
descriptors	pointer
;	O
if	O
(	O
fds	pointer
!=	O
NULL	O
)	O
{	O
gl_list_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
element	pointer
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
fds	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
element	pointer
,	O
NULL	O
)	O
)	O
{	O
int	O
fd	int
=	O
(	O
int	O
)	O
(	O
uintptr_t	long
)	O
element	pointer
;	O
close	pointer
(	O
fd	int
)	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cleanup_list	struct
.	O
tempdir_count	long
;	O
i	long
++	O
)	O
{	O
struct	O
tempdir	struct
*	O
dir	pointer
=	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
i	long
]	O
;	O
if	O
(	O
dir	pointer
!=	O
NULL	O
)	O
{	O
gl_list_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
element	pointer
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
dir	pointer
->	O
files	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
element	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
file	pointer
=	O
(	O
const	O
char	O
*	O
)	O
element	pointer
;	O
unlink	function
(	O
file	pointer
)	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
dir	pointer
->	O
subdirs	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
element	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
subdir	pointer
=	O
(	O
const	O
char	O
*	O
)	O
element	pointer
;	O
rmdir	function
(	O
subdir	pointer
)	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
rmdir	function
(	O
dir	pointer
->	O
dirname	pointer
)	O
;	O
}	O
}	O
}	O
struct	O
temp_dir	struct
*	O
create_temp_dir	function
(	O
const	O
char	O
*	O
prefix	pointer
,	O
const	O
char	O
*	O
parentdir	pointer
,	O
bool	bool
cleanup_verbose	bool
)	O
{	O
struct	O
tempdir	struct
*	O
volatile	O
*	O
tmpdirp	pointer
=	O
NULL	O
;	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
;	O
size_t	long
i	long
;	O
char	O
*	O
xtemplate	pointer
;	O
char	O
*	O
tmpdirname	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cleanup_list	struct
.	O
tempdir_count	long
;	O
i	long
++	O
)	O
if	O
(	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
i	long
]	O
==	O
NULL	O
)	O
{	O
tmpdirp	pointer
=	O
&	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
i	long
]	O
;	O
break	O
;	O
}	O
if	O
(	O
tmpdirp	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
cleanup_list	struct
.	O
tempdir_count	long
==	O
cleanup_list	struct
.	O
tempdir_allocated	long
)	O
{	O
struct	O
tempdir	struct
*	O
volatile	O
*	O
old_array	pointer
=	O
cleanup_list	struct
.	O
tempdir_list	pointer
;	O
size_t	long
old_allocated	long
=	O
cleanup_list	struct
.	O
tempdir_allocated	long
;	O
size_t	long
new_allocated	long
=	O
2	int
*	O
cleanup_list	struct
.	O
tempdir_allocated	long
+	O
1	int
;	O
struct	O
tempdir	struct
*	O
volatile	O
*	O
new_array	pointer
=	O
XNMALLOC	O
(	O
new_allocated	long
,	O
struct	O
tempdir	struct
*	O
volatile	O
)	O
;	O
if	O
(	O
old_allocated	long
==	O
0	int
)	O
at_fatal_signal	function
(	O
&	O
cleanup_action	function
)	O
;	O
else	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
old_allocated	long
;	O
k	long
++	O
)	O
new_array	pointer
[	O
k	long
]	O
=	O
old_array	pointer
[	O
k	long
]	O
;	O
}	O
cleanup_list	struct
.	O
tempdir_list	pointer
=	O
new_array	pointer
;	O
cleanup_list	struct
.	O
tempdir_allocated	long
=	O
new_allocated	long
;	O
if	O
(	O
old_array	pointer
!=	O
NULL	O
)	O
free	function
(	O
(	O
struct	O
tempdir	struct
*	O
*	O
)	O
old_array	pointer
)	O
;	O
}	O
tmpdirp	pointer
=	O
&	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
cleanup_list	struct
.	O
tempdir_count	long
]	O
;	O
*	O
tmpdirp	pointer
=	O
NULL	O
;	O
cleanup_list	struct
.	O
tempdir_count	long
++	O
;	O
}	O
tmpdir	pointer
=	O
XMALLOC	O
(	O
struct	O
tempdir	struct
)	O
;	O
tmpdir	pointer
->	O
dirname	pointer
=	O
NULL	O
;	O
tmpdir	pointer
->	O
cleanup_verbose	bool
=	O
cleanup_verbose	bool
;	O
tmpdir	pointer
->	O
subdirs	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKEDHASH_LIST	O
,	O
string_equals	function
,	O
string_hash	function
,	O
NULL	O
,	O
false	int
)	O
;	O
tmpdir	pointer
->	O
files	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKEDHASH_LIST	O
,	O
string_equals	function
,	O
string_hash	function
,	O
NULL	O
,	O
false	int
)	O
;	O
xtemplate	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
path_search	function
(	O
xtemplate	pointer
,	O
PATH_MAX	int
,	O
parentdir	pointer
,	O
prefix	pointer
,	O
parentdir	pointer
==	O
NULL	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot find a temporary directory, try setting $TMPDIR"	pointer
)	O
)	O
;	O
goto	O
quit	O
;	O
}	O
block_fatal_signals	function
(	O
)	O
;	O
tmpdirname	pointer
=	O
mkdtemp	function
(	O
xtemplate	pointer
)	O
;	O
if	O
(	O
tmpdirname	pointer
!=	O
NULL	O
)	O
{	O
tmpdir	pointer
->	O
dirname	pointer
=	O
tmpdirname	pointer
;	O
*	O
tmpdirp	pointer
=	O
tmpdir	pointer
;	O
}	O
unblock_fatal_signals	function
(	O
)	O
;	O
if	O
(	O
tmpdirname	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot create a temporary directory using template \"%s\""	pointer
)	O
,	O
xtemplate	pointer
)	O
;	O
goto	O
quit	O
;	O
}	O
tmpdir	pointer
->	O
dirname	pointer
=	O
xstrdup	function
(	O
tmpdirname	pointer
)	O
;	O
freea	function
(	O
xtemplate	pointer
)	O
;	O
return	O
(	O
struct	O
temp_dir	struct
*	O
)	O
tmpdir	pointer
;	O
quit	O
:	O
freea	function
(	O
xtemplate	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
register_temp_file	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_file_name	pointer
)	O
{	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
=	O
(	O
struct	O
tempdir	struct
*	O
)	O
dir	pointer
;	O
if	O
(	O
gl_list_search	function
(	O
tmpdir	pointer
->	O
files	pointer
,	O
absolute_file_name	pointer
)	O
==	O
NULL	O
)	O
gl_list_add_first	function
(	O
tmpdir	pointer
->	O
files	pointer
,	O
xstrdup	function
(	O
absolute_file_name	pointer
)	O
)	O
;	O
}	O
void	O
unregister_temp_file	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_file_name	pointer
)	O
{	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
=	O
(	O
struct	O
tempdir	struct
*	O
)	O
dir	pointer
;	O
gl_list_t	pointer
list	pointer
=	O
tmpdir	pointer
->	O
files	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
node	pointer
=	O
gl_list_search	function
(	O
list	pointer
,	O
absolute_file_name	pointer
)	O
;	O
if	O
(	O
node	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
old_string	pointer
=	O
(	O
char	O
*	O
)	O
gl_list_node_value	function
(	O
list	pointer
,	O
node	pointer
)	O
;	O
gl_list_remove_node	function
(	O
list	pointer
,	O
node	pointer
)	O
;	O
free	function
(	O
old_string	pointer
)	O
;	O
}	O
}	O
void	O
register_temp_subdir	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_dir_name	pointer
)	O
{	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
=	O
(	O
struct	O
tempdir	struct
*	O
)	O
dir	pointer
;	O
if	O
(	O
gl_list_search	function
(	O
tmpdir	pointer
->	O
subdirs	pointer
,	O
absolute_dir_name	pointer
)	O
==	O
NULL	O
)	O
gl_list_add_first	function
(	O
tmpdir	pointer
->	O
subdirs	pointer
,	O
xstrdup	function
(	O
absolute_dir_name	pointer
)	O
)	O
;	O
}	O
void	O
unregister_temp_subdir	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_dir_name	pointer
)	O
{	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
=	O
(	O
struct	O
tempdir	struct
*	O
)	O
dir	pointer
;	O
gl_list_t	pointer
list	pointer
=	O
tmpdir	pointer
->	O
subdirs	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
node	pointer
=	O
gl_list_search	function
(	O
list	pointer
,	O
absolute_dir_name	pointer
)	O
;	O
if	O
(	O
node	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
old_string	pointer
=	O
(	O
char	O
*	O
)	O
gl_list_node_value	function
(	O
list	pointer
,	O
node	pointer
)	O
;	O
gl_list_remove_node	function
(	O
list	pointer
,	O
node	pointer
)	O
;	O
free	function
(	O
old_string	pointer
)	O
;	O
}	O
}	O
static	O
int	O
do_unlink	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_file_name	pointer
)	O
{	O
if	O
(	O
unlink	function
(	O
absolute_file_name	pointer
)	O
<	O
0	int
&&	O
dir	pointer
->	O
cleanup_verbose	bool
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot remove temporary file %s"	pointer
)	O
,	O
absolute_file_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
do_rmdir	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_dir_name	pointer
)	O
{	O
if	O
(	O
rmdir	function
(	O
absolute_dir_name	pointer
)	O
<	O
0	int
&&	O
dir	pointer
->	O
cleanup_verbose	bool
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot remove temporary directory %s"	pointer
)	O
,	O
absolute_dir_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
cleanup_temp_file	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_file_name	pointer
)	O
{	O
int	O
err	int
;	O
err	int
=	O
do_unlink	function
(	O
dir	pointer
,	O
absolute_file_name	pointer
)	O
;	O
unregister_temp_file	function
(	O
dir	pointer
,	O
absolute_file_name	pointer
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cleanup_temp_subdir	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
,	O
const	O
char	O
*	O
absolute_dir_name	pointer
)	O
{	O
int	O
err	int
;	O
err	int
=	O
do_rmdir	function
(	O
dir	pointer
,	O
absolute_dir_name	pointer
)	O
;	O
unregister_temp_subdir	function
(	O
dir	pointer
,	O
absolute_dir_name	pointer
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cleanup_temp_dir_contents	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
)	O
{	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
=	O
(	O
struct	O
tempdir	struct
*	O
)	O
dir	pointer
;	O
int	O
err	int
=	O
0	int
;	O
gl_list_t	pointer
list	pointer
;	O
gl_list_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
element	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
list	pointer
=	O
tmpdir	pointer
->	O
files	pointer
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
list	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
element	pointer
,	O
&	O
node	pointer
)	O
)	O
{	O
char	O
*	O
file	pointer
=	O
(	O
char	O
*	O
)	O
element	pointer
;	O
err	int
|=	O
do_unlink	function
(	O
dir	pointer
,	O
file	pointer
)	O
;	O
gl_list_remove_node	function
(	O
list	pointer
,	O
node	pointer
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
list	pointer
=	O
tmpdir	pointer
->	O
subdirs	pointer
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
list	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
element	pointer
,	O
&	O
node	pointer
)	O
)	O
{	O
char	O
*	O
subdir	pointer
=	O
(	O
char	O
*	O
)	O
element	pointer
;	O
err	int
|=	O
do_rmdir	function
(	O
dir	pointer
,	O
subdir	pointer
)	O
;	O
gl_list_remove_node	function
(	O
list	pointer
,	O
node	pointer
)	O
;	O
free	function
(	O
subdir	pointer
)	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cleanup_temp_dir	function
(	O
struct	O
temp_dir	struct
*	O
dir	pointer
)	O
{	O
struct	O
tempdir	struct
*	O
tmpdir	pointer
=	O
(	O
struct	O
tempdir	struct
*	O
)	O
dir	pointer
;	O
int	O
err	int
=	O
0	int
;	O
size_t	long
i	long
;	O
err	int
|=	O
cleanup_temp_dir_contents	function
(	O
dir	pointer
)	O
;	O
err	int
|=	O
do_rmdir	function
(	O
dir	pointer
,	O
tmpdir	pointer
->	O
dirname	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cleanup_list	struct
.	O
tempdir_count	long
;	O
i	long
++	O
)	O
if	O
(	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
i	long
]	O
==	O
tmpdir	pointer
)	O
{	O
if	O
(	O
i	long
+	O
1	int
==	O
cleanup_list	struct
.	O
tempdir_count	long
)	O
{	O
while	O
(	O
i	long
>	O
0	int
&&	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
i	long
-	O
1	int
]	O
==	O
NULL	O
)	O
i	long
--	O
;	O
cleanup_list	struct
.	O
tempdir_count	long
=	O
i	long
;	O
}	O
else	O
cleanup_list	struct
.	O
tempdir_list	pointer
[	O
i	long
]	O
=	O
NULL	O
;	O
gl_list_free	function
(	O
tmpdir	pointer
->	O
files	pointer
)	O
;	O
gl_list_free	function
(	O
tmpdir	pointer
->	O
subdirs	pointer
)	O
;	O
free	function
(	O
tmpdir	pointer
->	O
dirname	pointer
)	O
;	O
free	function
(	O
tmpdir	pointer
)	O
;	O
return	O
err	int
;	O
}	O
abort	function
(	O
)	O
;	O
}	O
static	O
void	O
register_fd	function
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
descriptors	pointer
==	O
NULL	O
)	O
descriptors	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKEDHASH_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
false	int
)	O
;	O
gl_list_add_first	function
(	O
descriptors	pointer
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
fd	int
)	O
;	O
}	O
static	O
void	O
unregister_fd	function
(	O
int	O
fd	int
)	O
{	O
gl_list_t	pointer
fds	pointer
=	O
descriptors	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
if	O
(	O
fds	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
node	pointer
=	O
gl_list_search	function
(	O
fds	pointer
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
fd	int
)	O
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
gl_list_remove_node	function
(	O
fds	pointer
,	O
node	pointer
)	O
;	O
}	O
int	O
open_temp	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
int	O
fd	int
;	O
int	O
saved_errno	int
;	O
block_fatal_signals	function
(	O
)	O
;	O
fd	int
=	O
open	function
(	O
file_name	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
register_fd	function
(	O
fd	int
)	O
;	O
unblock_fatal_signals	function
(	O
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
fd	int
;	O
}	O
FILE	struct
*	O
fopen_temp	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
const	O
char	O
*	O
mode	int
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
int	O
saved_errno	int
;	O
block_fatal_signals	function
(	O
)	O
;	O
{	O
fp	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
mode	int
)	O
;	O
saved_errno	int
=	O
errno	O
;	O
}	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
{	O
int	O
fd	int
=	O
fileno	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
!	O
(	O
fd	int
>=	O
0	int
)	O
)	O
abort	function
(	O
)	O
;	O
register_fd	function
(	O
fd	int
)	O
;	O
}	O
unblock_fatal_signals	function
(	O
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
fp	pointer
;	O
}	O
int	O
close_temp	function
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
int	O
result	pointer
=	O
close	pointer
(	O
fd	int
)	O
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
unregister_fd	function
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
result	pointer
;	O
}	O
else	O
return	O
close	pointer
(	O
fd	int
)	O
;	O
}	O
int	O
fclose_temp	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
fd	int
=	O
fileno	function
(	O
fp	pointer
)	O
;	O
int	O
result	pointer
=	O
fclose	function
(	O
fp	pointer
)	O
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
unregister_fd	function
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
result	pointer
;	O
}	O
int	O
fwriteerror_temp	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
fd	int
=	O
fileno	function
(	O
fp	pointer
)	O
;	O
int	O
result	pointer
=	O
fwriteerror	function
(	O
fp	pointer
)	O
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
unregister_fd	function
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
result	pointer
;	O
}	O
