static	O
void	O
gldelf_l1om_before_parse	function
(	O
void	O
)	O
;	O
static	O
void	O
gldelf_l1om_after_open	function
(	O
void	O
)	O
;	O
static	O
void	O
gldelf_l1om_before_allocation	function
(	O
void	O
)	O
;	O
static	O
void	O
gldelf_l1om_after_allocation	function
(	O
void	O
)	O
;	O
static	O
struct	O
elf_linker_x86_params	struct
params	struct
;	O
static	O
void	O
elf_x86_create_output_section_statements	function
(	O
void	O
)	O
{	O
_bfd_elf_linker_x86_set_options	function
(	O
&	O
link_info	struct
,	O
&	O
params	struct
)	O
;	O
}	O
static	O
void	O
elf_x86_before_parse	function
(	O
void	O
)	O
{	O
params	struct
.	O
call_nop_byte	char
=	O
0x67	int
;	O
gldelf_l1om_before_parse	function
(	O
)	O
;	O
}	O
static	O
void	O
gldelf_l1om_before_parse	function
(	O
void	O
)	O
{	O
ldfile_set_output_arch	function
(	O
"l1om"	pointer
,	O
bfd_arch_l1om	int
)	O
;	O
input_flags	struct
.	O
dynamic	int
=	O
TRUE	int
;	O
config	struct
.	O
has_shared	int
=	O
TRUE	int
;	O
config	struct
.	O
separate_code	int
=	O
FALSE	int
;	O
link_info	struct
.	O
check_relocs_after_open_input	int
=	O
TRUE	int
;	O
link_info	struct
.	O
relro	int
=	O
DEFAULT_LD_Z_RELRO	int
;	O
link_info	struct
.	O
separate_code	int
=	O
DEFAULT_LD_Z_SEPARATE_CODE	int
;	O
}	O
static	O
char	O
*	O
audit	pointer
;	O
static	O
char	O
*	O
depaudit	pointer
;	O
static	O
void	O
gldelf_l1om_after_open	function
(	O
void	O
)	O
{	O
ldelf_after_open	function
(	O
TRUE	int
,	O
TRUE	int
,	O
TRUE	int
,	O
FALSE	int
,	O
64	int
,	O
"/usr/local"	pointer
)	O
;	O
}	O
static	O
void	O
gldelf_l1om_before_allocation	function
(	O
void	O
)	O
{	O
ldelf_before_allocation	function
(	O
audit	pointer
,	O
depaudit	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
gldelf_l1om_after_allocation	function
(	O
void	O
)	O
{	O
int	O
need_layout	int
=	O
bfd_elf_discard_info	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
if	O
(	O
need_layout	int
<	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: .eh_frame/.stab edit: %E\n"	pointer
)	O
)	O
;	O
else	O
ldelf_map_segments	function
(	O
need_layout	int
)	O
;	O
}	O
static	O
char	O
*	O
gldelf_l1om_get_script	function
(	O
int	O
*	O
isfile	pointer
)	O
{	O
*	O
isfile	pointer
=	O
0	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
config	struct
.	O
build_constructors	int
)	O
return	O
"/* Script for -Ur */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\n /* For some reason, the Solaris linker makes bad executables\n  if gld -r is used and the intermediate file has sections starting\n  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n  bug.  But for now assigning the zero vmas works.  */\nSECTIONS\n{\n  .interp       0 : { *(.interp) }\n  .note.gnu.build-id 0: { *(.note.gnu.build-id) }\n  .hash         0 : { *(.hash) }\n  .gnu.hash     0 : { *(.gnu.hash) }\n  .dynsym       0 : { *(.dynsym) }\n  .dynstr       0 : { *(.dynstr) }\n  .gnu.version  0 : { *(.gnu.version) }\n  .gnu.version_d 0: { *(.gnu.version_d) }\n  .gnu.version_r 0: { *(.gnu.version_r) }\n  .rela.init    0 : { *(.rela.init) }\n  .rela.text    0 : { *(.rela.text) }\n"	pointer
"  .rela.fini    0 : { *(.rela.fini) }\n  .rela.rodata  0 : { *(.rela.rodata) }\n  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n  .rela.data    0 : { *(.rela.data) }\n  .rela.tdata	0 : { *(.rela.tdata) }\n  .rela.tbss	0 : { *(.rela.tbss) }\n  .rela.ctors   0 : { *(.rela.ctors) }\n  .rela.dtors   0 : { *(.rela.dtors) }\n  .rela.got     0 : { *(.rela.got) }\n  .rela.bss     0 : { *(.rela.bss) }\n  .rela.ldata   0 : { *(.rela.ldata) }\n  .rela.lbss    0 : { *(.rela.lbss) }\n  .rela.lrodata 0 : { *(.rela.lrodata) }\n  .rela.ifunc   0 : { *(.rela.ifunc) }\n  .rela.plt     0 :\n    {\n      *(.rela.plt)\n    }\n  .init         0 :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt          0 : { *(.plt) }\n  .text         0 :\n  {\n"	pointer
"    *(.text .stub)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini         0 :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  .rodata       0 : { *(.rodata) }\n  .rodata1      0 : { *(.rodata1) }\n  .eh_frame_hdr 0 : { *(.eh_frame_hdr) }\n  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table) }\n  .gnu_extab 0 : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges 0 : ONLY_IF_RO { *(.exception_ranges) }\n  /* Exception handling  */\n  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n  .gnu_extab    0 : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table) }\n  .exception_ranges 0 : ONLY_IF_RW { *(.exception_ranges) }\n  /* Thread Local Storage sections  */\n  .tdata	0 :\n   {\n     *(.tdata)\n"	pointer
"   }\n  .tbss		0 : { *(.tbss) }\n  .jcr          0 : { KEEP (*(.jcr)) }\n  .dynamic      0 : { *(.dynamic) }\n  .got          0 : { *(.got) }\n  .got.plt      0 : { *(.got.plt) }\n  .data         0 :\n  {\n    *(.data)\n    SORT(CONSTRUCTORS)\n  }\n  .data1        0 : { *(.data1) }\n  .bss          0 :\n  {\n   *(.bss)\n  }\n  .lbss 0 :\n  {\n    *(.lbss)\n  }\n  .lrodata 0  :\n  {\n    *(.lrodata)\n  }\n  .ldata 0  :\n"	pointer
"  {\n    *(.ldata)\n  }\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
return	O
"/* Script for -r */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\n /* For some reason, the Solaris linker makes bad executables\n  if gld -r is used and the intermediate file has sections starting\n  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n  bug.  But for now assigning the zero vmas works.  */\nSECTIONS\n{\n  .interp       0 : { *(.interp) }\n  .note.gnu.build-id 0: { *(.note.gnu.build-id) }\n  .hash         0 : { *(.hash) }\n  .gnu.hash     0 : { *(.gnu.hash) }\n  .dynsym       0 : { *(.dynsym) }\n  .dynstr       0 : { *(.dynstr) }\n  .gnu.version  0 : { *(.gnu.version) }\n  .gnu.version_d 0: { *(.gnu.version_d) }\n  .gnu.version_r 0: { *(.gnu.version_r) }\n  .rela.init    0 : { *(.rela.init) }\n  .rela.text    0 : { *(.rela.text) }\n"	pointer
"  .rela.fini    0 : { *(.rela.fini) }\n  .rela.rodata  0 : { *(.rela.rodata) }\n  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n  .rela.data    0 : { *(.rela.data) }\n  .rela.tdata	0 : { *(.rela.tdata) }\n  .rela.tbss	0 : { *(.rela.tbss) }\n  .rela.ctors   0 : { *(.rela.ctors) }\n  .rela.dtors   0 : { *(.rela.dtors) }\n  .rela.got     0 : { *(.rela.got) }\n  .rela.bss     0 : { *(.rela.bss) }\n  .rela.ldata   0 : { *(.rela.ldata) }\n  .rela.lbss    0 : { *(.rela.lbss) }\n  .rela.lrodata 0 : { *(.rela.lrodata) }\n  .rela.ifunc   0 : { *(.rela.ifunc) }\n  .rela.plt     0 :\n    {\n      *(.rela.plt)\n    }\n  .init         0 :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt          0 : { *(.plt) }\n  .text         0 :\n  {\n"	pointer
"    *(.text .stub)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini         0 :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  .rodata       0 : { *(.rodata) }\n  .rodata1      0 : { *(.rodata1) }\n  .eh_frame_hdr 0 : { *(.eh_frame_hdr) }\n  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table) }\n  .gnu_extab 0 : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges 0 : ONLY_IF_RO { *(.exception_ranges) }\n  /* Exception handling  */\n  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n  .gnu_extab    0 : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table) }\n  .exception_ranges 0 : ONLY_IF_RW { *(.exception_ranges) }\n  /* Thread Local Storage sections  */\n  .tdata	0 :\n   {\n     *(.tdata)\n"	pointer
"   }\n  .tbss		0 : { *(.tbss) }\n  .jcr          0 : { KEEP (*(.jcr)) }\n  .dynamic      0 : { *(.dynamic) }\n  .got          0 : { *(.got) }\n  .got.plt      0 : { *(.got.plt) }\n  .data         0 :\n  {\n    *(.data)\n  }\n  .data1        0 : { *(.data1) }\n  .bss          0 :\n  {\n   *(.bss)\n  }\n  .lbss 0 :\n  {\n    *(.lbss)\n  }\n  .lrodata 0  :\n  {\n    *(.lrodata)\n  }\n  .ldata 0  :\n  {\n"	pointer
"    *(.ldata)\n  }\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
!	O
config	struct
.	O
text_read_only	int
)	O
return	O
"/* Script for -N */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"	pointer
"  .rela.fini      : { *(.rela.fini) }\n  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"	pointer
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = .;\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
!	O
config	struct
.	O
magic_demand_paged	int
)	O
return	O
"/* Script for -n */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"	pointer
"  .rela.fini      : { *(.rela.fini) }\n  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"	pointer
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
separate_code	int
&&	O
(	O
link_info	struct
.	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
return	O
"/* Script for -pie -z combreloc -z separate-code -z relro -z now */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n"	pointer
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n"	pointer
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n"	pointer
"    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
relro	int
&&	O
(	O
link_info	struct
.	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
return	O
"/* Script for -pie -z combreloc -z relro -z now */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n"	pointer
"      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"	pointer
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
separate_code	int
&&	O
link_info	struct
.	O
combreloc	int
)	O
return	O
"/* Script for -pie -z combreloc -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n"	pointer
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n"	pointer
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n"	pointer
"    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
)	O
return	O
"/* Script for -pie -z combreloc */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n"	pointer
"      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"	pointer
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
separate_code	int
)	O
return	O
"/* Script for -pie -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n  .rela.fini      : { *(.rela.fini) }\n"	pointer
"  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n"	pointer
"  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"	pointer
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n"	pointer
"  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
)	O
return	O
"/* Script for -pie */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"	pointer
"  .rela.fini      : { *(.rela.fini) }\n  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n"	pointer
"  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n"	pointer
"  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n"	pointer
"    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
separate_code	int
&&	O
(	O
link_info	struct
.	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
return	O
"/* Script for -shared -z combreloc -z separate-code -z relro -z now */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"	pointer
"      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n"	pointer
"  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n"	pointer
"  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    KEEP (*(.preinit_array))\n  }\n  .init_array    :\n  {\n"	pointer
"    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n  }\n  .fini_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  PROVIDE (_edata = .); PROVIDE (edata = .);\n  . = .;\n  PROVIDE (__bss_start = .);\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  PROVIDE (_end = .); PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
relro	int
&&	O
(	O
link_info	struct
.	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
return	O
"/* Script for -shared -z combreloc -z relro -z now */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n"	pointer
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n"	pointer
"  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n"	pointer
"  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    KEEP (*(.preinit_array))\n  }\n  .init_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n  }\n  .fini_array    :\n"	pointer
"  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  PROVIDE (_edata = .); PROVIDE (edata = .);\n  . = .;\n  PROVIDE (__bss_start = .);\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  PROVIDE (_end = .); PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
separate_code	int
)	O
return	O
"/* Script for -shared -z combreloc -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"	pointer
"      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n"	pointer
"  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n"	pointer
"  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    KEEP (*(.preinit_array))\n  }\n  .init_array    :\n  {\n"	pointer
"    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n  }\n  .fini_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  PROVIDE (_edata = .); PROVIDE (edata = .);\n  . = .;\n  PROVIDE (__bss_start = .);\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  PROVIDE (_end = .); PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
)	O
return	O
"/* Script for -shared -z combreloc */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n"	pointer
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n"	pointer
"  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n"	pointer
"  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    KEEP (*(.preinit_array))\n  }\n  .init_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n  }\n  .fini_array    :\n"	pointer
"  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  PROVIDE (_edata = .); PROVIDE (edata = .);\n  . = .;\n  PROVIDE (__bss_start = .);\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  PROVIDE (_end = .); PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
separate_code	int
)	O
return	O
"/* Script for -shared -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n  .rela.fini      : { *(.rela.fini) }\n  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n"	pointer
"  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n"	pointer
"    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n"	pointer
"  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    KEEP (*(.preinit_array))\n  }\n  .init_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n"	pointer
"  }\n  .fini_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  PROVIDE (_edata = .); PROVIDE (edata = .);\n  . = .;\n  PROVIDE (__bss_start = .);\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  PROVIDE (_end = .); PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
)	O
return	O
"/* Script for -shared */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n  .rela.fini      : { *(.rela.fini) }\n"	pointer
"  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      *(.rela.iplt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n"	pointer
"    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n"	pointer
"     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    KEEP (*(.preinit_array))\n  }\n  .init_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n  }\n  .fini_array    :\n  {\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n"	pointer
"    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  PROVIDE (_edata = .); PROVIDE (edata = .);\n  . = .;\n  PROVIDE (__bss_start = .);\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  PROVIDE (_end = .); PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
separate_code	int
&&	O
(	O
link_info	struct
.	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
return	O
"/* Script for -z combreloc -z separate-code -z relro -z now */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n"	pointer
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n"	pointer
"    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n"	pointer
"  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
relro	int
&&	O
(	O
link_info	struct
.	O
flags	int
&	O
DF_BIND_NOW	O
)	O
)	O
return	O
"/* Script for -z combreloc -z relro -z now */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n"	pointer
"      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  .init           :\n  {\n"	pointer
"    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"	pointer
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n"	pointer
"  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
link_info	struct
.	O
combreloc	int
&&	O
link_info	struct
.	O
separate_code	int
)	O
return	O
"/* Script for -z combreloc -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n"	pointer
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n"	pointer
"    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n"	pointer
"  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
link_info	struct
.	O
combreloc	int
)	O
return	O
"/* Script for -z combreloc */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n"	pointer
"      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)\n      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)\n      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)\n      *(.rela.ifunc)\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  .init           :\n  {\n"	pointer
"    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"	pointer
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n"	pointer
"  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
if	O
(	O
link_info	struct
.	O
separate_code	int
)	O
return	O
"/* Script for -z separate-code */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n  .rela.fini      : { *(.rela.fini) }\n"	pointer
"  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  . = ALIGN(CONSTANT (MAXPAGESIZE));\n  /* Adjust the address for the rodata segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n"	pointer
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n"	pointer
"    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
else	O
return	O
"/* Default linker script, for normal executables */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-l1om\", \"elf64-l1om\",\n	      \"elf64-l1om\")\nOUTPUT_ARCH(l1om)\nENTRY(_start)\nSEARCH_DIR(\"/usr/local/x86_64-pc-linux-gnu/lib\"); SEARCH_DIR(\"/usr/local/lib\"); SEARCH_DIR(\"/lib\"); SEARCH_DIR(\"/usr/lib\");\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.init      : { *(.rela.init) }\n  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"	pointer
"  .rela.fini      : { *(.rela.fini) }\n  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n  .rela.ctors     : { *(.rela.ctors) }\n  .rela.dtors     : { *(.rela.dtors) }\n  .rela.got       : { *(.rela.got) }\n  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n  .rela.ldata     : { *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) }\n  .rela.lbss      : { *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) }\n  .rela.lrodata   : { *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) }\n  .rela.ifunc     : { *(.rela.ifunc) }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n"	pointer
"  .plt            : { *(.plt) *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"	pointer
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata	  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n"	pointer
"    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  .got            : { *(.got) *(.igot) }\n  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);\n  .got.plt        : { *(.got.plt) *(.igot.plt) }\n  .data           :\n  {\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  .lbss   :\n  {\n    *(.dynlbss)\n    *(.lbss .lbss.* .gnu.linkonce.lb.*)\n    *(LARGE_COMMON)\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)\n  }\n  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :\n  {\n    *(.ldata .ldata.* .gnu.linkonce.l.*)\n    . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n\n"	pointer
;	O
}	O
enum	O
elf_options	enum
{	O
OPTION_DISABLE_NEW_DTAGS	int
=	O
400	int
,	O
OPTION_ENABLE_NEW_DTAGS	int
,	O
OPTION_GROUP	int
,	O
OPTION_EH_FRAME_HDR	int
,	O
OPTION_NO_EH_FRAME_HDR	int
,	O
OPTION_EXCLUDE_LIBS	int
,	O
OPTION_HASH_STYLE	int
,	O
OPTION_BUILD_ID	int
,	O
OPTION_AUDIT	int
,	O
OPTION_COMPRESS_DEBUG	int
}	O
;	O
static	O
void	O
gldelf_l1om_add_options	function
(	O
int	O
ns	int
,	O
char	O
*	O
*	O
shortopts	pointer
,	O
int	O
nl	int
,	O
struct	O
option	struct
*	O
*	O
longopts	pointer
,	O
int	O
nrl	int
ATTRIBUTE_UNUSED	O
,	O
struct	O
option	struct
*	O
*	O
really_longopts	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
static	O
const	O
char	O
xtra_short	array
[	O
]	O
=	O
"z:P:"	pointer
;	O
static	O
const	O
struct	O
option	struct
xtra_long	array
[	O
]	O
=	O
{	O
{	O
"audit"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_AUDIT	int
}	O
,	O
{	O
"Bgroup"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_GROUP	int
}	O
,	O
{	O
"build-id"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_BUILD_ID	int
}	O
,	O
{	O
"compress-debug-sections"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_COMPRESS_DEBUG	int
}	O
,	O
{	O
"depaudit"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"disable-new-dtags"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DISABLE_NEW_DTAGS	int
}	O
,	O
{	O
"enable-new-dtags"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ENABLE_NEW_DTAGS	int
}	O
,	O
{	O
"eh-frame-hdr"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_EH_FRAME_HDR	int
}	O
,	O
{	O
"no-eh-frame-hdr"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_EH_FRAME_HDR	int
}	O
,	O
{	O
"exclude-libs"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_EXCLUDE_LIBS	int
}	O
,	O
{	O
"hash-style"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_HASH_STYLE	int
}	O
,	O
{	O
"ld-generated-unwind-info"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_LD_GENERATED_UNWIND_INFO	int
}	O
,	O
{	O
"no-ld-generated-unwind-info"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_LD_GENERATED_UNWIND_INFO	int
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
*	O
shortopts	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
*	O
shortopts	pointer
,	O
ns	int
+	O
sizeof	O
(	O
xtra_short	array
)	O
)	O
;	O
memcpy	function
(	O
*	O
shortopts	pointer
+	O
ns	int
,	O
&	O
xtra_short	array
,	O
sizeof	O
(	O
xtra_short	array
)	O
)	O
;	O
*	O
longopts	pointer
=	O
(	O
struct	O
option	struct
*	O
)	O
xrealloc	function
(	O
*	O
longopts	pointer
,	O
nl	int
*	O
sizeof	O
(	O
struct	O
option	struct
)	O
+	O
sizeof	O
(	O
xtra_long	array
)	O
)	O
;	O
memcpy	function
(	O
*	O
longopts	pointer
+	O
nl	int
,	O
&	O
xtra_long	array
,	O
sizeof	O
(	O
xtra_long	array
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
gldelf_l1om_handle_option	function
(	O
int	O
optc	int
)	O
{	O
switch	O
(	O
optc	int
)	O
{	O
default	O
:	O
return	O
FALSE	int
;	O
case	O
OPTION_BUILD_ID	int
:	O
if	O
(	O
ldelf_emit_note_gnu_build_id	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
ldelf_emit_note_gnu_build_id	pointer
)	O
;	O
ldelf_emit_note_gnu_build_id	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
optarg	pointer
==	O
NULL	O
)	O
optarg	pointer
=	O
DEFAULT_BUILD_ID_STYLE	pointer
;	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"none"	pointer
)	O
)	O
ldelf_emit_note_gnu_build_id	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_COMPRESS_DEBUG	int
:	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
compress_debug	enum
=	O
COMPRESS_DEBUG_NONE	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"zlib"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
compress_debug	enum
=	O
COMPRESS_DEBUG_GABI_ZLIB	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"zlib-gnu"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
compress_debug	enum
=	O
COMPRESS_DEBUG_GNU_ZLIB	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"zlib-gabi"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
compress_debug	enum
=	O
COMPRESS_DEBUG_GABI_ZLIB	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid --compress-debug-sections option: `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_AUDIT	int
:	O
ldelf_append_to_separated_string	function
(	O
&	O
audit	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
ldelf_append_to_separated_string	function
(	O
&	O
depaudit	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_DISABLE_NEW_DTAGS	int
:	O
link_info	struct
.	O
new_dtags	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_ENABLE_NEW_DTAGS	int
:	O
link_info	struct
.	O
new_dtags	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_EH_FRAME_HDR	int
:	O
link_info	struct
.	O
eh_frame_hdr_type	int
=	O
DWARF2_EH_HDR	int
;	O
break	O
;	O
case	O
OPTION_NO_EH_FRAME_HDR	int
:	O
link_info	struct
.	O
eh_frame_hdr_type	int
=	O
0	int
;	O
break	O
;	O
case	O
OPTION_GROUP	int
:	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_GROUP	int
;	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_GENERATE_ERROR	int
;	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_GENERATE_ERROR	int
;	O
break	O
;	O
case	O
OPTION_EXCLUDE_LIBS	int
:	O
add_excluded_libs	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_HASH_STYLE	int
:	O
link_info	struct
.	O
emit_hash	int
=	O
FALSE	int
;	O
link_info	struct
.	O
emit_gnu_hash	int
=	O
FALSE	int
;	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"sysv"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
emit_hash	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"gnu"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
emit_gnu_hash	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"both"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
emit_hash	int
=	O
TRUE	int
;	O
link_info	struct
.	O
emit_gnu_hash	int
=	O
TRUE	int
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid hash style `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"defs"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_GENERATE_ERROR	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"undefs"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_IGNORE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"muldefs"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
allow_multiple_definition	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
optarg	pointer
,	O
"max-page-size="	pointer
)	O
)	O
{	O
char	O
*	O
end	pointer
;	O
config	struct
.	O
maxpagesize	long
=	O
strtoul	function
(	O
optarg	pointer
+	O
14	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
||	O
(	O
config	struct
.	O
maxpagesize	long
&	O
(	O
config	struct
.	O
maxpagesize	long
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid maximum page size `%s'\n"	pointer
)	O
,	O
optarg	pointer
+	O
14	int
)	O
;	O
}	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
optarg	pointer
,	O
"common-page-size="	pointer
)	O
)	O
{	O
char	O
*	O
end	pointer
;	O
config	struct
.	O
commonpagesize	long
=	O
strtoul	function
(	O
optarg	pointer
+	O
17	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
||	O
(	O
config	struct
.	O
commonpagesize	long
&	O
(	O
config	struct
.	O
commonpagesize	long
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid common page size `%s'\n"	pointer
)	O
,	O
optarg	pointer
+	O
17	int
)	O
;	O
}	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
optarg	pointer
,	O
"stack-size="	pointer
)	O
)	O
{	O
char	O
*	O
end	pointer
;	O
link_info	struct
.	O
stacksize	long
=	O
strtoul	function
(	O
optarg	pointer
+	O
11	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
||	O
link_info	struct
.	O
stacksize	long
<	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid stack size `%s'\n"	pointer
)	O
,	O
optarg	pointer
+	O
11	int
)	O
;	O
if	O
(	O
!	O
link_info	struct
.	O
stacksize	long
)	O
link_info	struct
.	O
stacksize	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"execstack"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
execstack	int
=	O
TRUE	int
;	O
link_info	struct
.	O
noexecstack	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"noexecstack"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
noexecstack	int
=	O
TRUE	int
;	O
link_info	struct
.	O
execstack	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"globalaudit"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
flags_1	long
|=	O
DF_1_GLOBAUDIT	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"global"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_GLOBAL	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"initfirst"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_INITFIRST	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"interpose"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_INTERPOSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"loadfltr"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_LOADFLTR	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nodefaultlib"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_NODEFLIB	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nodelete"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_NODELETE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nodlopen"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_NOOPEN	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nodump"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_NODUMP	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"now"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
flags	int
|=	O
(	O
bfd_vma	long
)	O
DF_BIND_NOW	O
;	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_NOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"lazy"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
flags	int
&=	O
~	O
(	O
bfd_vma	long
)	O
DF_BIND_NOW	O
;	O
link_info	struct
.	O
flags_1	long
&=	O
~	O
(	O
bfd_vma	long
)	O
DF_1_NOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"origin"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
flags	int
|=	O
(	O
bfd_vma	long
)	O
DF_ORIGIN	O
;	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_ORIGIN	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"combreloc"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
combreloc	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nocombreloc"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
combreloc	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nocopyreloc"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
nocopyreloc	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"relro"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
relro	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"norelro"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
relro	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"separate-code"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
separate_code	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"noseparate-code"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
separate_code	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"common"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
elf_stt_common	int
=	O
elf_stt_common	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nocommon"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
elf_stt_common	int
=	O
no_elf_stt_common	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"text"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
error_textrel	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"notext"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
error_textrel	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"textoff"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
error_textrel	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"noextern-protected-data"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
extern_protected_data	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"dynamic-undefined-weak"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
dynamic_undefined_weak	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nodynamic-undefined-weak"	pointer
)	O
==	O
0	int
)	O
link_info	struct
.	O
dynamic_undefined_weak	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
optarg	pointer
,	O
"call-nop="	pointer
,	O
9	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
+	O
9	int
,	O
"prefix-addr"	pointer
)	O
==	O
0	int
)	O
{	O
params	struct
.	O
call_nop_as_suffix	int
=	O
FALSE	int
;	O
params	struct
.	O
call_nop_byte	char
=	O
0x67	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
+	O
9	int
,	O
"suffix-nop"	pointer
)	O
==	O
0	int
)	O
{	O
params	struct
.	O
call_nop_as_suffix	int
=	O
TRUE	int
;	O
params	struct
.	O
call_nop_byte	char
=	O
0x90	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
optarg	pointer
+	O
9	int
,	O
"prefix-"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
end	pointer
;	O
params	struct
.	O
call_nop_byte	char
=	O
strtoul	function
(	O
optarg	pointer
+	O
16	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid number for -z call-nop=prefix-: %s\n"	pointer
)	O
,	O
optarg	pointer
+	O
16	int
)	O
;	O
params	struct
.	O
call_nop_as_suffix	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
optarg	pointer
+	O
9	int
,	O
"suffix-"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
end	pointer
;	O
params	struct
.	O
call_nop_byte	char
=	O
strtoul	function
(	O
optarg	pointer
+	O
16	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid number for -z call-nop=suffix-: %s\n"	pointer
)	O
,	O
optarg	pointer
+	O
16	int
)	O
;	O
params	struct
.	O
call_nop_as_suffix	int
=	O
TRUE	int
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unsupported option: -z %s\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: -z %s ignored\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_LD_GENERATED_UNWIND_INFO	int
:	O
link_info	struct
.	O
no_ld_generated_unwind_info	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_LD_GENERATED_UNWIND_INFO	int
:	O
link_info	struct
.	O
no_ld_generated_unwind_info	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
gldelf_l1om_list_options	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z noextern-protected-data  Do not treat protected data symbol as external\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z dynamic-undefined-weak   Make undefined weak symbols dynamic\n  -z nodynamic-undefined-weak Do not make undefined weak symbols dynamic\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z call-nop=PADDING         Use PADDING as 1-byte NOP for branch\n"	pointer
)	O
)	O
;	O
}	O
struct	O
ld_emulation_xfer_struct	struct
ld_elf_l1om_emulation	struct
=	O
{	O
elf_x86_before_parse	function
,	O
syslib_default	function
,	O
hll_default	function
,	O
ldelf_after_parse	function
,	O
gldelf_l1om_after_open	function
,	O
after_check_relocs_default	function
,	O
gldelf_l1om_after_allocation	function
,	O
set_output_arch_default	function
,	O
ldemul_default_target	function
,	O
gldelf_l1om_before_allocation	function
,	O
gldelf_l1om_get_script	function
,	O
"elf_l1om"	pointer
,	O
"elf64-l1om"	pointer
,	O
finish_default	function
,	O
elf_x86_create_output_section_statements	function
,	O
ldelf_open_dynamic_archive	function
,	O
ldelf_place_orphan	function
,	O
NULL	O
,	O
NULL	O
,	O
gldelf_l1om_add_options	function
,	O
gldelf_l1om_handle_option	function
,	O
NULL	O
,	O
gldelf_l1om_list_options	function
,	O
ldelf_load_symbols	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
ldelf_emit_ctf_early	function
,	O
ldelf_examine_strtab_for_ctf	function
}	O
;	O
