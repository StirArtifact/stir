void	O
DISEulerToMatrix	function
(	O
dis_euler_angles	struct
*	O
ea	pointer
,	O
VMatrix	struct
*	O
m	array
)	O
{	O
double	O
sinPhi	double
,	O
cosPhi	double
,	O
sinTheta	double
,	O
cosTheta	double
,	O
sinPsi	double
,	O
cosPsi	double
;	O
sinPhi	double
=	O
sin	function
(	O
ea	pointer
->	O
phi	float
)	O
;	O
cosPhi	double
=	O
cos	function
(	O
ea	pointer
->	O
phi	float
)	O
;	O
sinTheta	double
=	O
sin	function
(	O
ea	pointer
->	O
theta	float
)	O
;	O
cosTheta	double
=	O
cos	function
(	O
ea	pointer
->	O
theta	float
)	O
;	O
sinPsi	double
=	O
sin	function
(	O
ea	pointer
->	O
psi	float
)	O
;	O
cosPsi	double
=	O
cos	function
(	O
ea	pointer
->	O
psi	float
)	O
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
cosTheta	double
*	O
cosPsi	double
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
sinPhi	double
*	O
sinTheta	double
*	O
cosPsi	double
-	O
cosPhi	double
*	O
sinPsi	double
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
cosPhi	double
*	O
sinTheta	double
*	O
cosPsi	double
+	O
sinPhi	double
*	O
sinPsi	double
;	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
cosTheta	double
*	O
sinPsi	double
;	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
sinPhi	double
*	O
sinTheta	double
*	O
sinPsi	double
+	O
cosPhi	double
*	O
cosPsi	double
;	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
2	int
]	O
=	O
cosPhi	double
*	O
sinTheta	double
*	O
sinPsi	double
-	O
sinPhi	double
*	O
cosPsi	double
;	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
0	int
]	O
=	O
-	O
sinTheta	double
;	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
1	int
]	O
=	O
sinPhi	double
*	O
cosTheta	double
;	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
cosPhi	double
*	O
cosTheta	double
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
3	int
]	O
=	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
3	int
]	O
=	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
0	int
]	O
=	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
1	int
]	O
=	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
3	int
]	O
=	O
1.0	int
;	O
}	O
void	O
DISProcessNewDRParameters	function
(	O
dis_entity_state_pdu	struct
*	O
pdu	struct
,	O
dis_dr_parameters	struct
*	O
dr	pointer
)	O
{	O
switch	O
(	O
pdu	struct
->	O
dr_parm	struct
.	O
algorithm	char
)	O
{	O
case	O
DISDRMethodRPB	int
:	O
case	O
DISDRMethodRVB	int
:	O
case	O
DISDRMethodRPW	int
:	O
case	O
DISDRMethodRVW	int
:	O
DISGenerateDRParameters	function
(	O
pdu	struct
,	O
dr	pointer
)	O
;	O
break	O
;	O
case	O
DISDRMethodStatic	int
:	O
case	O
DISDRMethodFPW	int
:	O
case	O
DISDRMethodFVW	int
:	O
case	O
DISDRMethodFPB	int
:	O
case	O
DISDRMethodFVB	int
:	O
break	O
;	O
case	O
DISDRMethodOther	int
:	O
default	O
:	O
break	O
;	O
}	O
dr	pointer
->	O
pdu	struct
=	O
*	O
pdu	struct
;	O
DISEulerToMatrix	function
(	O
&	O
pdu	struct
->	O
orientation	struct
,	O
&	O
dr	pointer
->	O
R0	struct
)	O
;	O
}	O
void	O
DISGenerateDRParameters	function
(	O
dis_entity_state_pdu	struct
*	O
pdu	struct
,	O
dis_dr_parameters	struct
*	O
dr	pointer
)	O
{	O
double	O
ox	double
,	O
oy	double
,	O
oz	double
;	O
double	O
ax	double
=	O
0.0	int
,	O
ay	double
=	O
0.0	int
,	O
az	double
=	O
0.0	int
;	O
double	O
omega	double
;	O
ox	double
=	O
pdu	struct
->	O
dr_parm	struct
.	O
angular_vel	struct
.	O
x	float
;	O
oy	double
=	O
pdu	struct
->	O
dr_parm	struct
.	O
angular_vel	struct
.	O
y	float
;	O
oz	double
=	O
pdu	struct
->	O
dr_parm	struct
.	O
angular_vel	struct
.	O
z	float
;	O
omega	double
=	O
sqrt	function
(	O
ox	double
*	O
ox	double
+	O
oy	double
*	O
oy	double
+	O
oz	double
*	O
oz	double
)	O
;	O
if	O
(	O
omega	double
>	O
0.0	int
)	O
{	O
ax	double
=	O
ox	double
/	O
omega	double
;	O
ay	double
=	O
oy	double
/	O
omega	double
;	O
az	double
=	O
oz	double
/	O
omega	double
;	O
}	O
dr	pointer
->	O
omega	double
=	O
omega	double
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
-	O
az	double
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
az	double
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
2	int
]	O
[	O
0	int
]	O
=	O
ay	double
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
-	O
ay	double
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
2	int
]	O
[	O
1	int
]	O
=	O
-	O
ax	double
;	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
1	int
]	O
[	O
2	int
]	O
=	O
ax	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
ax	double
*	O
ax	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
ax	double
*	O
ay	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
2	int
]	O
[	O
0	int
]	O
=	O
ax	double
*	O
az	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
ay	double
*	O
ax	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
ay	double
*	O
ay	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
2	int
]	O
[	O
1	int
]	O
=	O
ay	double
*	O
az	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
az	double
*	O
ax	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
1	int
]	O
[	O
2	int
]	O
=	O
az	double
*	O
ay	double
;	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
az	double
*	O
az	double
;	O
}	O
void	O
DISComputeDRPosition	function
(	O
dis_dr_parameters	struct
*	O
dr	pointer
,	O
double	O
dT	double
,	O
dis_world_coordinates	struct
*	O
pos	struct
,	O
dis_linear_vel_vector	struct
*	O
vel	struct
,	O
VMatrix	struct
*	O
orientation	struct
)	O
{	O
VMatrix	struct
DR	struct
;	O
double	O
hDTSqr	double
;	O
dis_entity_state_pdu	struct
*	O
pdu	struct
=	O
&	O
dr	pointer
->	O
pdu	struct
;	O
*	O
vel	struct
=	O
pdu	struct
->	O
vel	struct
;	O
switch	O
(	O
dr	pointer
->	O
pdu	struct
.	O
dr_parm	struct
.	O
algorithm	char
)	O
{	O
case	O
DISDRMethodRPB	int
:	O
case	O
DISDRMethodRVB	int
:	O
break	O
;	O
case	O
DISDRMethodFPB	int
:	O
case	O
DISDRMethodFVB	int
:	O
*	O
orientation	struct
=	O
dr	pointer
->	O
R0	struct
;	O
break	O
;	O
case	O
DISDRMethodRPW	int
:	O
pos	struct
->	O
x	float
=	O
pdu	struct
->	O
pos	struct
.	O
x	float
+	O
pdu	struct
->	O
vel	struct
.	O
x	float
*	O
dT	double
;	O
pos	struct
->	O
y	float
=	O
pdu	struct
->	O
pos	struct
.	O
y	float
+	O
pdu	struct
->	O
vel	struct
.	O
y	float
*	O
dT	double
;	O
pos	struct
->	O
z	float
=	O
pdu	struct
->	O
pos	struct
.	O
z	float
+	O
pdu	struct
->	O
vel	struct
.	O
z	float
*	O
dT	double
;	O
DISComputeDRMatrix	function
(	O
dr	pointer
,	O
dT	double
,	O
&	O
DR	struct
)	O
;	O
DISMatrixMultByRank	function
(	O
&	O
DR	struct
,	O
&	O
dr	pointer
->	O
R0	struct
,	O
orientation	struct
,	O
3	int
)	O
;	O
break	O
;	O
case	O
DISDRMethodRVW	int
:	O
hDTSqr	double
=	O
0.5	int
*	O
dT	double
*	O
dT	double
;	O
pos	struct
->	O
x	float
=	O
pdu	struct
->	O
pos	struct
.	O
x	float
+	O
pdu	struct
->	O
vel	struct
.	O
x	float
*	O
dT	double
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
x	float
*	O
hDTSqr	double
;	O
pos	struct
->	O
y	float
=	O
pdu	struct
->	O
pos	struct
.	O
y	float
+	O
pdu	struct
->	O
vel	struct
.	O
y	float
*	O
dT	double
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
y	float
*	O
hDTSqr	double
;	O
pos	struct
->	O
z	float
=	O
pdu	struct
->	O
pos	struct
.	O
z	float
+	O
pdu	struct
->	O
vel	struct
.	O
z	float
*	O
dT	double
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
z	float
*	O
hDTSqr	double
;	O
vel	struct
->	O
x	float
=	O
(	O
float	O
)	O
(	O
pdu	struct
->	O
vel	struct
.	O
x	float
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
x	float
*	O
dT	double
)	O
;	O
vel	struct
->	O
y	float
=	O
(	O
float	O
)	O
(	O
pdu	struct
->	O
vel	struct
.	O
y	float
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
y	float
*	O
dT	double
)	O
;	O
vel	struct
->	O
z	float
=	O
(	O
float	O
)	O
(	O
pdu	struct
->	O
vel	struct
.	O
z	float
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
z	float
*	O
dT	double
)	O
;	O
DISComputeDRMatrix	function
(	O
dr	pointer
,	O
dT	double
,	O
&	O
DR	struct
)	O
;	O
DISMatrixMultByRank	function
(	O
&	O
DR	struct
,	O
&	O
dr	pointer
->	O
R0	struct
,	O
orientation	struct
,	O
3	int
)	O
;	O
break	O
;	O
case	O
DISDRMethodStatic	int
:	O
*	O
pos	struct
=	O
pdu	struct
->	O
pos	struct
;	O
*	O
orientation	struct
=	O
dr	pointer
->	O
R0	struct
;	O
break	O
;	O
case	O
DISDRMethodFPW	int
:	O
pos	struct
->	O
x	float
=	O
pdu	struct
->	O
pos	struct
.	O
x	float
+	O
pdu	struct
->	O
vel	struct
.	O
x	float
*	O
dT	double
;	O
pos	struct
->	O
y	float
=	O
pdu	struct
->	O
pos	struct
.	O
y	float
+	O
pdu	struct
->	O
vel	struct
.	O
y	float
*	O
dT	double
;	O
pos	struct
->	O
z	float
=	O
pdu	struct
->	O
pos	struct
.	O
z	float
+	O
pdu	struct
->	O
vel	struct
.	O
z	float
*	O
dT	double
;	O
*	O
orientation	struct
=	O
dr	pointer
->	O
R0	struct
;	O
break	O
;	O
case	O
DISDRMethodFVW	int
:	O
hDTSqr	double
=	O
0.5	int
*	O
dT	double
*	O
dT	double
;	O
pos	struct
->	O
x	float
=	O
pdu	struct
->	O
pos	struct
.	O
x	float
+	O
pdu	struct
->	O
vel	struct
.	O
x	float
*	O
dT	double
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
x	float
*	O
hDTSqr	double
;	O
pos	struct
->	O
y	float
=	O
pdu	struct
->	O
pos	struct
.	O
y	float
+	O
pdu	struct
->	O
vel	struct
.	O
y	float
*	O
dT	double
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
y	float
*	O
hDTSqr	double
;	O
pos	struct
->	O
z	float
=	O
pdu	struct
->	O
pos	struct
.	O
z	float
+	O
pdu	struct
->	O
vel	struct
.	O
z	float
*	O
dT	double
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
z	float
*	O
hDTSqr	double
;	O
vel	struct
->	O
x	float
=	O
(	O
float	O
)	O
(	O
pdu	struct
->	O
vel	struct
.	O
x	float
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
x	float
*	O
dT	double
)	O
;	O
vel	struct
->	O
y	float
=	O
(	O
float	O
)	O
(	O
pdu	struct
->	O
vel	struct
.	O
y	float
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
y	float
*	O
dT	double
)	O
;	O
vel	struct
->	O
z	float
=	O
(	O
float	O
)	O
(	O
pdu	struct
->	O
vel	struct
.	O
z	float
+	O
pdu	struct
->	O
dr_parm	struct
.	O
linear_acc	struct
.	O
z	float
*	O
dT	double
)	O
;	O
*	O
orientation	struct
=	O
dr	pointer
->	O
R0	struct
;	O
break	O
;	O
case	O
DISDRMethodOther	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
DISComputeDRMatrix	function
(	O
dis_dr_parameters	struct
*	O
dr	pointer
,	O
double	O
dT	double
,	O
VMatrix	struct
*	O
m	array
)	O
{	O
double	O
theta	float
=	O
dr	pointer
->	O
omega	double
*	O
dT	double
;	O
double	O
cosTheta	double
=	O
cos	function
(	O
theta	float
)	O
;	O
double	O
sinTheta	double
=	O
sin	function
(	O
theta	float
)	O
;	O
double	O
Icos	double
,	O
x	float
=	O
(	O
1.0	int
-	O
cosTheta	double
)	O
;	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
i	int
==	O
j	int
)	O
{	O
Icos	double
=	O
cosTheta	double
;	O
}	O
else	O
{	O
Icos	double
=	O
0.0	int
;	O
}	O
m	array
->	O
m	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
Icos	double
-	O
dr	pointer
->	O
skew	struct
.	O
m	array
[	O
i	int
]	O
[	O
j	int
]	O
*	O
sinTheta	double
+	O
dr	pointer
->	O
aat	struct
.	O
m	array
[	O
i	int
]	O
[	O
j	int
]	O
*	O
x	float
;	O
}	O
}	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
3	int
]	O
=	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
3	int
]	O
=	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
0	int
]	O
=	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
1	int
]	O
=	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
m	array
->	O
m	array
[	O
3	int
]	O
[	O
3	int
]	O
=	O
1.0	int
;	O
}	O
void	O
DISGetDRThresholds	function
(	O
dis_dr_parameters	struct
*	O
dr	pointer
,	O
double	O
*	O
time	int
,	O
double	O
*	O
location	struct
,	O
double	O
*	O
orientation	struct
)	O
{	O
*	O
time	int
=	O
dr	pointer
->	O
timeThreshold	double
;	O
*	O
location	struct
=	O
dr	pointer
->	O
locationThreshold	double
;	O
*	O
orientation	struct
=	O
dr	pointer
->	O
orientationThreshold	double
;	O
}	O
void	O
DISSetDRThresholds	function
(	O
dis_dr_parameters	struct
*	O
dr	pointer
,	O
double	O
time	int
,	O
double	O
location	struct
,	O
double	O
orientation	struct
)	O
{	O
dr	pointer
->	O
timeThreshold	double
=	O
time	int
;	O
dr	pointer
->	O
locationThreshold	double
=	O
location	struct
;	O
dr	pointer
->	O
orientationThreshold	double
=	O
orientation	struct
;	O
}	O
int	O
DISTestDRThresholds	function
(	O
dis_dr_parameters	struct
*	O
dr	pointer
,	O
double	O
delta	double
,	O
dis_world_coordinates	struct
*	O
loc	struct
,	O
dis_euler_angles	struct
*	O
current_orientation_ea	pointer
)	O
{	O
int	O
result	char
=	O
0	int
;	O
dis_world_coordinates	struct
dr_loc	struct
,	O
d_loc	struct
;	O
dis_linear_vel_vector	struct
dr_vel	struct
;	O
double	O
d_squared	double
,	O
d1	double
,	O
d2	double
,	O
d3	double
,	O
orientation_error_squared	double
;	O
VMatrix	struct
dr_orientation	struct
,	O
cur_orientation	struct
;	O
if	O
(	O
delta	double
>	O
dr	pointer
->	O
timeThreshold	double
)	O
{	O
result	char
|=	O
DR_TIME	int
;	O
}	O
else	O
{	O
DISComputeDRPosition	function
(	O
dr	pointer
,	O
delta	double
,	O
&	O
dr_loc	struct
,	O
&	O
dr_vel	struct
,	O
&	O
dr_orientation	struct
)	O
;	O
d_loc	struct
.	O
x	float
=	O
loc	struct
->	O
x	float
-	O
dr_loc	struct
.	O
x	float
;	O
d_loc	struct
.	O
y	float
=	O
loc	struct
->	O
y	float
-	O
dr_loc	struct
.	O
y	float
;	O
d_loc	struct
.	O
z	float
=	O
loc	struct
->	O
z	float
-	O
dr_loc	struct
.	O
z	float
;	O
d_squared	double
=	O
d_loc	struct
.	O
x	float
*	O
d_loc	struct
.	O
x	float
+	O
d_loc	struct
.	O
y	float
*	O
d_loc	struct
.	O
y	float
+	O
d_loc	struct
.	O
z	float
*	O
d_loc	struct
.	O
z	float
;	O
if	O
(	O
d_squared	double
>	O
dr	pointer
->	O
locationThreshold	double
*	O
dr	pointer
->	O
locationThreshold	double
)	O
{	O
result	char
|=	O
DR_LOCATION	int
;	O
}	O
DISEulerToMatrix	function
(	O
current_orientation_ea	pointer
,	O
&	O
cur_orientation	struct
)	O
;	O
d1	double
=	O
dr_orientation	struct
.	O
m	array
[	O
0	int
]	O
[	O
0	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
0	int
]	O
[	O
0	int
]	O
+	O
dr_orientation	struct
.	O
m	array
[	O
0	int
]	O
[	O
1	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
0	int
]	O
[	O
1	int
]	O
+	O
dr_orientation	struct
.	O
m	array
[	O
0	int
]	O
[	O
2	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
0	int
]	O
[	O
2	int
]	O
;	O
d2	double
=	O
dr_orientation	struct
.	O
m	array
[	O
1	int
]	O
[	O
0	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
1	int
]	O
[	O
0	int
]	O
+	O
dr_orientation	struct
.	O
m	array
[	O
1	int
]	O
[	O
1	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
1	int
]	O
[	O
1	int
]	O
+	O
dr_orientation	struct
.	O
m	array
[	O
1	int
]	O
[	O
2	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
1	int
]	O
[	O
2	int
]	O
;	O
d3	double
=	O
dr_orientation	struct
.	O
m	array
[	O
2	int
]	O
[	O
0	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
2	int
]	O
[	O
0	int
]	O
+	O
dr_orientation	struct
.	O
m	array
[	O
2	int
]	O
[	O
1	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
2	int
]	O
[	O
1	int
]	O
+	O
dr_orientation	struct
.	O
m	array
[	O
2	int
]	O
[	O
2	int
]	O
*	O
cur_orientation	struct
.	O
m	array
[	O
2	int
]	O
[	O
2	int
]	O
;	O
d1	double
=	O
1.0	int
-	O
d1	double
*	O
d1	double
;	O
d2	double
=	O
1.0	int
-	O
d2	double
*	O
d2	double
;	O
d3	double
=	O
1.0	int
-	O
d3	double
*	O
d3	double
;	O
orientation_error_squared	double
=	O
d1	double
*	O
d1	double
+	O
d2	double
*	O
d2	double
+	O
d3	double
*	O
d3	double
;	O
if	O
(	O
orientation_error_squared	double
>	O
dr	pointer
->	O
orientationThreshold	double
*	O
dr	pointer
->	O
orientationThreshold	double
)	O
{	O
result	char
|=	O
DR_ORIENTATION	int
;	O
}	O
}	O
return	O
result	char
;	O
}	O
