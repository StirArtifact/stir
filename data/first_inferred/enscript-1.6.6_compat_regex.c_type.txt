static	O
char	O
re_syntax_table	array
[	O
CHAR_SET_SIZE	int
]	O
;	O
static	O
void	O
init_syntax_once	function
(	O
)	O
{	O
register	O
int	O
c	int
;	O
static	O
int	O
done	int
=	O
0	int
;	O
if	O
(	O
done	int
)	O
return	O
;	O
bzero	function
(	O
re_syntax_table	array
,	O
sizeof	O
re_syntax_table	array
)	O
;	O
for	O
(	O
c	int
=	O
'a'	O
;	O
c	int
<=	O
'z'	O
;	O
c	int
++	O
)	O
re_syntax_table	array
[	O
c	int
]	O
=	O
Sword	int
;	O
for	O
(	O
c	int
=	O
'A'	O
;	O
c	int
<=	O
'Z'	O
;	O
c	int
++	O
)	O
re_syntax_table	array
[	O
c	int
]	O
=	O
Sword	int
;	O
for	O
(	O
c	int
=	O
'0'	O
;	O
c	int
<=	O
'9'	O
;	O
c	int
++	O
)	O
re_syntax_table	array
[	O
c	int
]	O
=	O
Sword	int
;	O
re_syntax_table	array
[	O
'_'	O
]	O
=	O
Sword	int
;	O
done	int
=	O
1	int
;	O
}	O
typedef	O
char	O
boolean	char
;	O
static	O
int	O
re_match_2_internal	function
(	O
)	O
;	O
typedef	O
enum	O
{	O
no_op	int
=	O
0	int
,	O
succeed	int
,	O
exactn	int
,	O
anychar	int
,	O
charset	int
,	O
charset_not	int
,	O
start_memory	int
,	O
stop_memory	int
,	O
duplicate	int
,	O
begline	int
,	O
endline	int
,	O
begbuf	int
,	O
endbuf	int
,	O
jump	int
,	O
jump_past_alt	int
,	O
on_failure_jump	int
,	O
on_failure_keep_string_jump	int
,	O
pop_failure_jump	int
,	O
maybe_pop_jump	int
,	O
dummy_failure_jump	int
,	O
push_dummy_failure	int
,	O
succeed_n	int
,	O
jump_n	int
,	O
set_number_at	int
,	O
wordchar	int
,	O
notwordchar	int
,	O
wordbeg	int
,	O
wordend	int
,	O
wordbound	int
,	O
notwordbound	int
}	O
re_opcode_t	enum
;	O
reg_syntax_t	long
re_syntax_options	long
;	O
reg_syntax_t	long
re_set_syntax	function
(	O
syntax	long
)	O
reg_syntax_t	long
syntax	long
;	O
{	O
reg_syntax_t	long
ret	long
=	O
re_syntax_options	long
;	O
re_syntax_options	long
=	O
syntax	long
;	O
return	O
ret	long
;	O
}	O
void	O
re_set_character_syntax	function
(	O
unsigned	O
char	O
ch	char
,	O
char	O
syntax	long
)	O
{	O
init_syntax_once	function
(	O
)	O
;	O
switch	O
(	O
syntax	long
)	O
{	O
case	O
'w'	O
:	O
SYNTAX	O
(	O
ch	char
)	O
=	O
Sword	int
;	O
break	O
;	O
case	O
' '	O
:	O
SYNTAX	O
(	O
ch	char
)	O
=	O
0	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
re_error_msgid	array
[	O
]	O
=	O
{	O
gettext_noop	O
(	O
"Success"	pointer
)	O
,	O
gettext_noop	O
(	O
"No match"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid regular expression"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid collation character"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid character class name"	pointer
)	O
,	O
gettext_noop	O
(	O
"Trailing backslash"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid back reference"	pointer
)	O
,	O
gettext_noop	O
(	O
"Unmatched [ or [^"	pointer
)	O
,	O
gettext_noop	O
(	O
"Unmatched ( or \\("	pointer
)	O
,	O
gettext_noop	O
(	O
"Unmatched \\{"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid content of \\{\\}"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid range end"	pointer
)	O
,	O
gettext_noop	O
(	O
"Memory exhausted"	pointer
)	O
,	O
gettext_noop	O
(	O
"Invalid preceding regular expression"	pointer
)	O
,	O
gettext_noop	O
(	O
"Premature end of regular expression"	pointer
)	O
,	O
gettext_noop	O
(	O
"Regular expression too big"	pointer
)	O
,	O
gettext_noop	O
(	O
"Unmatched ) or \\)"	pointer
)	O
,	O
}	O
;	O
int	O
re_max_failures	int
=	O
20000	int
;	O
union	O
fail_stack_elt	union
{	O
unsigned	O
char	O
*	O
pointer	pointer
;	O
int	O
integer	int
;	O
}	O
;	O
typedef	O
union	O
fail_stack_elt	union
fail_stack_elt_t	union
;	O
typedef	O
struct	O
{	O
fail_stack_elt_t	union
*	O
stack	pointer
;	O
unsigned	O
size	int
;	O
unsigned	O
avail	int
;	O
}	O
fail_stack_type	struct
;	O
typedef	O
union	O
{	O
fail_stack_elt_t	union
word	union
;	O
struct	O
{	O
unsigned	O
match_null_string_p	int
:	O
2	int
;	O
unsigned	O
is_active	int
:	O
1	int
;	O
unsigned	O
matched_something	int
:	O
1	int
;	O
unsigned	O
ever_matched_something	int
:	O
1	int
;	O
}	O
bits	struct
;	O
}	O
register_info_type	union
;	O
static	O
char	O
reg_unset_dummy	char
;	O
static	O
reg_errcode_t	enum
regex_compile	function
_RE_ARGS	O
(	O
(	O
const	O
char	O
*	O
pattern	pointer
,	O
size_t	long
size	int
,	O
reg_syntax_t	long
syntax	long
,	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
)	O
)	O
;	O
static	O
void	O
store_op1	function
_RE_ARGS	O
(	O
(	O
re_opcode_t	enum
op	enum
,	O
unsigned	O
char	O
*	O
loc	pointer
,	O
int	O
arg	int
)	O
)	O
;	O
static	O
void	O
store_op2	function
_RE_ARGS	O
(	O
(	O
re_opcode_t	enum
op	enum
,	O
unsigned	O
char	O
*	O
loc	pointer
,	O
int	O
arg1	int
,	O
int	O
arg2	int
)	O
)	O
;	O
static	O
void	O
insert_op1	function
_RE_ARGS	O
(	O
(	O
re_opcode_t	enum
op	enum
,	O
unsigned	O
char	O
*	O
loc	pointer
,	O
int	O
arg	int
,	O
unsigned	O
char	O
*	O
end	pointer
)	O
)	O
;	O
static	O
void	O
insert_op2	function
_RE_ARGS	O
(	O
(	O
re_opcode_t	enum
op	enum
,	O
unsigned	O
char	O
*	O
loc	pointer
,	O
int	O
arg1	int
,	O
int	O
arg2	int
,	O
unsigned	O
char	O
*	O
end	pointer
)	O
)	O
;	O
static	O
boolean	char
at_begline_loc_p	function
_RE_ARGS	O
(	O
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
p	pointer
,	O
reg_syntax_t	long
syntax	long
)	O
)	O
;	O
static	O
boolean	char
at_endline_loc_p	function
_RE_ARGS	O
(	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
pend	pointer
,	O
reg_syntax_t	long
syntax	long
)	O
)	O
;	O
static	O
reg_errcode_t	enum
compile_range	function
_RE_ARGS	O
(	O
(	O
const	O
char	O
*	O
*	O
p_ptr	pointer
,	O
const	O
char	O
*	O
pend	pointer
,	O
char	O
*	O
translate	pointer
,	O
reg_syntax_t	long
syntax	long
,	O
unsigned	O
char	O
*	O
b	pointer
)	O
)	O
;	O
typedef	O
unsigned	O
regnum_t	int
;	O
typedef	O
long	O
pattern_offset_t	long
;	O
typedef	O
struct	O
{	O
pattern_offset_t	long
begalt_offset	long
;	O
pattern_offset_t	long
fixup_alt_jump	long
;	O
pattern_offset_t	long
inner_group_offset	long
;	O
pattern_offset_t	long
laststart_offset	long
;	O
regnum_t	int
regnum	int
;	O
}	O
compile_stack_elt_t	struct
;	O
typedef	O
struct	O
{	O
compile_stack_elt_t	struct
*	O
stack	pointer
;	O
unsigned	O
size	int
;	O
unsigned	O
avail	int
;	O
}	O
compile_stack_type	struct
;	O
static	O
boolean	char
group_in_compile_stack	function
_RE_ARGS	O
(	O
(	O
compile_stack_type	struct
compile_stack	struct
,	O
regnum_t	int
regnum	int
)	O
)	O
;	O
static	O
reg_errcode_t	enum
regex_compile	function
(	O
pattern	pointer
,	O
size	int
,	O
syntax	long
,	O
bufp	pointer
)	O
const	O
char	O
*	O
pattern	pointer
;	O
size_t	long
size	int
;	O
reg_syntax_t	long
syntax	long
;	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
{	O
register	O
unsigned	O
char	O
c	int
,	O
c1	char
;	O
const	O
char	O
*	O
p1	pointer
;	O
register	O
unsigned	O
char	O
*	O
b	pointer
;	O
compile_stack_type	struct
compile_stack	struct
;	O
const	O
char	O
*	O
p	pointer
=	O
pattern	pointer
;	O
const	O
char	O
*	O
pend	pointer
=	O
pattern	pointer
+	O
size	int
;	O
RE_TRANSLATE_TYPE	O
translate	pointer
=	O
bufp	pointer
->	O
translate	pointer
;	O
unsigned	O
char	O
*	O
pending_exact	pointer
=	O
0	int
;	O
unsigned	O
char	O
*	O
laststart	pointer
=	O
0	int
;	O
unsigned	O
char	O
*	O
begalt	pointer
;	O
const	O
char	O
*	O
beg_interval	pointer
;	O
unsigned	O
char	O
*	O
fixup_alt_jump	long
=	O
0	int
;	O
regnum_t	int
regnum	int
=	O
0	int
;	O
compile_stack	struct
.	O
stack	pointer
=	O
TALLOC	O
(	O
INIT_COMPILE_STACK_SIZE	int
,	O
compile_stack_elt_t	struct
)	O
;	O
if	O
(	O
compile_stack	struct
.	O
stack	pointer
==	O
NULL	O
)	O
return	O
REG_ESPACE	int
;	O
compile_stack	struct
.	O
size	int
=	O
INIT_COMPILE_STACK_SIZE	int
;	O
compile_stack	struct
.	O
avail	int
=	O
0	int
;	O
bufp	pointer
->	O
syntax	long
=	O
syntax	long
;	O
bufp	pointer
->	O
fastmap_accurate	int
=	O
0	int
;	O
bufp	pointer
->	O
not_bol	int
=	O
bufp	pointer
->	O
not_eol	int
=	O
0	int
;	O
bufp	pointer
->	O
used	long
=	O
0	int
;	O
bufp	pointer
->	O
re_nsub	long
=	O
0	int
;	O
init_syntax_once	function
(	O
)	O
;	O
if	O
(	O
bufp	pointer
->	O
allocated	long
==	O
0	int
)	O
{	O
if	O
(	O
bufp	pointer
->	O
buffer	pointer
)	O
{	O
RETALLOC	O
(	O
bufp	pointer
->	O
buffer	pointer
,	O
INIT_BUF_SIZE	int
,	O
unsigned	O
char	O
)	O
;	O
}	O
else	O
{	O
bufp	pointer
->	O
buffer	pointer
=	O
TALLOC	O
(	O
INIT_BUF_SIZE	int
,	O
unsigned	O
char	O
)	O
;	O
}	O
if	O
(	O
!	O
bufp	pointer
->	O
buffer	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_ESPACE	int
)	O
;	O
bufp	pointer
->	O
allocated	long
=	O
INIT_BUF_SIZE	int
;	O
}	O
begalt	pointer
=	O
b	pointer
=	O
bufp	pointer
->	O
buffer	pointer
;	O
while	O
(	O
p	pointer
!=	O
pend	pointer
)	O
{	O
PATFETCH	O
(	O
c	int
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'^'	O
:	O
{	O
if	O
(	O
p	pointer
==	O
pattern	pointer
+	O
1	int
||	O
syntax	long
&	O
RE_CONTEXT_INDEP_ANCHORS	O
||	O
at_begline_loc_p	function
(	O
pattern	pointer
,	O
p	pointer
,	O
syntax	long
)	O
)	O
BUF_PUSH	O
(	O
begline	int
)	O
;	O
else	O
goto	O
normal_char	O
;	O
}	O
break	O
;	O
case	O
'$'	O
:	O
{	O
if	O
(	O
p	pointer
==	O
pend	pointer
||	O
syntax	long
&	O
RE_CONTEXT_INDEP_ANCHORS	O
||	O
at_endline_loc_p	function
(	O
p	pointer
,	O
pend	pointer
,	O
syntax	long
)	O
)	O
BUF_PUSH	O
(	O
endline	int
)	O
;	O
else	O
goto	O
normal_char	O
;	O
}	O
break	O
;	O
case	O
'+'	O
:	O
case	O
'?'	O
:	O
if	O
(	O
(	O
syntax	long
&	O
RE_BK_PLUS_QM	O
)	O
||	O
(	O
syntax	long
&	O
RE_LIMITED_OPS	O
)	O
)	O
goto	O
normal_char	O
;	O
handle_plus	O
:	O
case	O
'*'	O
:	O
if	O
(	O
!	O
laststart	pointer
)	O
{	O
if	O
(	O
syntax	long
&	O
RE_CONTEXT_INVALID_OPS	O
)	O
FREE_STACK_RETURN	O
(	O
REG_BADRPT	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
syntax	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
)	O
goto	O
normal_char	O
;	O
}	O
{	O
boolean	char
keep_string_p	char
=	O
false	int
;	O
char	O
zero_times_ok	char
=	O
0	int
,	O
many_times_ok	char
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
zero_times_ok	char
|=	O
c	int
!=	O
'+'	O
;	O
many_times_ok	char
|=	O
c	int
!=	O
'?'	O
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
break	O
;	O
PATFETCH	O
(	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'*'	O
||	O
(	O
!	O
(	O
syntax	long
&	O
RE_BK_PLUS_QM	O
)	O
&&	O
(	O
c	int
==	O
'+'	O
||	O
c	int
==	O
'?'	O
)	O
)	O
)	O
;	O
else	O
if	O
(	O
syntax	long
&	O
RE_BK_PLUS_QM	O
&&	O
c	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EESCAPE	int
)	O
;	O
PATFETCH	O
(	O
c1	char
)	O
;	O
if	O
(	O
!	O
(	O
c1	char
==	O
'+'	O
||	O
c1	char
==	O
'?'	O
)	O
)	O
{	O
PATUNFETCH	O
;	O
PATUNFETCH	O
;	O
break	O
;	O
}	O
c	int
=	O
c1	char
;	O
}	O
else	O
{	O
PATUNFETCH	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
laststart	pointer
)	O
break	O
;	O
if	O
(	O
many_times_ok	char
)	O
{	O
assert	O
(	O
p	pointer
-	O
1	int
>	O
pattern	pointer
)	O
;	O
GET_BUFFER_SPACE	O
(	O
3	int
)	O
;	O
if	O
(	O
TRANSLATE	O
(	O
*	O
(	O
p	pointer
-	O
2	int
)	O
)	O
==	O
TRANSLATE	O
(	O
'.'	O
)	O
&&	O
zero_times_ok	char
&&	O
p	pointer
<	O
pend	pointer
&&	O
TRANSLATE	O
(	O
*	O
p	pointer
)	O
==	O
TRANSLATE	O
(	O
'\n'	O
)	O
&&	O
!	O
(	O
syntax	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
{	O
STORE_JUMP	O
(	O
jump	int
,	O
b	pointer
,	O
laststart	pointer
)	O
;	O
keep_string_p	char
=	O
true	int
;	O
}	O
else	O
STORE_JUMP	O
(	O
maybe_pop_jump	int
,	O
b	pointer
,	O
laststart	pointer
-	O
3	int
)	O
;	O
b	pointer
+=	O
3	int
;	O
}	O
GET_BUFFER_SPACE	O
(	O
3	int
)	O
;	O
INSERT_JUMP	O
(	O
keep_string_p	char
?	O
on_failure_keep_string_jump	int
:	O
on_failure_jump	int
,	O
laststart	pointer
,	O
b	pointer
+	O
3	int
)	O
;	O
pending_exact	pointer
=	O
0	int
;	O
b	pointer
+=	O
3	int
;	O
if	O
(	O
!	O
zero_times_ok	char
)	O
{	O
GET_BUFFER_SPACE	O
(	O
3	int
)	O
;	O
INSERT_JUMP	O
(	O
dummy_failure_jump	int
,	O
laststart	pointer
,	O
laststart	pointer
+	O
6	int
)	O
;	O
b	pointer
+=	O
3	int
;	O
}	O
}	O
break	O
;	O
case	O
'.'	O
:	O
laststart	pointer
=	O
b	pointer
;	O
BUF_PUSH	O
(	O
anychar	int
)	O
;	O
break	O
;	O
case	O
'['	O
:	O
{	O
boolean	char
had_char_class	char
=	O
false	int
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EBRACK	int
)	O
;	O
GET_BUFFER_SPACE	O
(	O
34	int
)	O
;	O
laststart	pointer
=	O
b	pointer
;	O
BUF_PUSH	O
(	O
*	O
p	pointer
==	O
'^'	O
?	O
charset_not	int
:	O
charset	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'^'	O
)	O
p	pointer
++	O
;	O
p1	pointer
=	O
p	pointer
;	O
BUF_PUSH	O
(	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
/	O
BYTEWIDTH	int
)	O
;	O
bzero	function
(	O
b	pointer
,	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
/	O
BYTEWIDTH	int
)	O
;	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
b	pointer
[	O
-	O
2	int
]	O
==	O
charset_not	int
&&	O
(	O
syntax	long
&	O
RE_HAT_LISTS_NOT_NEWLINE	O
)	O
)	O
SET_LIST_BIT	O
(	O
'\n'	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EBRACK	int
)	O
;	O
PATFETCH	O
(	O
c	int
)	O
;	O
if	O
(	O
(	O
syntax	long
&	O
RE_BACKSLASH_ESCAPE_IN_LISTS	O
)	O
&&	O
c	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EESCAPE	int
)	O
;	O
PATFETCH	O
(	O
c1	char
)	O
;	O
SET_LIST_BIT	O
(	O
c1	char
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
']'	O
&&	O
p	pointer
!=	O
p1	pointer
+	O
1	int
)	O
break	O
;	O
if	O
(	O
had_char_class	char
&&	O
c	int
==	O
'-'	O
&&	O
*	O
p	pointer
!=	O
']'	O
)	O
FREE_STACK_RETURN	O
(	O
REG_ERANGE	int
)	O
;	O
if	O
(	O
c	int
==	O
'-'	O
&&	O
!	O
(	O
p	pointer
-	O
2	int
>=	O
pattern	pointer
&&	O
p	pointer
[	O
-	O
2	int
]	O
==	O
'['	O
)	O
&&	O
!	O
(	O
p	pointer
-	O
3	int
>=	O
pattern	pointer
&&	O
p	pointer
[	O
-	O
3	int
]	O
==	O
'['	O
&&	O
p	pointer
[	O
-	O
2	int
]	O
==	O
'^'	O
)	O
&&	O
*	O
p	pointer
!=	O
']'	O
)	O
{	O
reg_errcode_t	enum
ret	long
=	O
compile_range	function
(	O
&	O
p	pointer
,	O
pend	pointer
,	O
translate	pointer
,	O
syntax	long
,	O
b	pointer
)	O
;	O
if	O
(	O
ret	long
!=	O
REG_NOERROR	int
)	O
FREE_STACK_RETURN	O
(	O
ret	long
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'-'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
']'	O
)	O
{	O
reg_errcode_t	enum
ret	long
;	O
PATFETCH	O
(	O
c1	char
)	O
;	O
ret	long
=	O
compile_range	function
(	O
&	O
p	pointer
,	O
pend	pointer
,	O
translate	pointer
,	O
syntax	long
,	O
b	pointer
)	O
;	O
if	O
(	O
ret	long
!=	O
REG_NOERROR	int
)	O
FREE_STACK_RETURN	O
(	O
ret	long
)	O
;	O
}	O
else	O
if	O
(	O
syntax	long
&	O
RE_CHAR_CLASSES	O
&&	O
c	int
==	O
'['	O
&&	O
*	O
p	pointer
==	O
':'	O
)	O
{	O
char	O
str	array
[	O
CHAR_CLASS_MAX_LENGTH	int
+	O
1	int
]	O
;	O
PATFETCH	O
(	O
c	int
)	O
;	O
c1	char
=	O
0	int
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EBRACK	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
PATFETCH	O
(	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
':'	O
||	O
c	int
==	O
']'	O
||	O
p	pointer
==	O
pend	pointer
||	O
c1	char
==	O
CHAR_CLASS_MAX_LENGTH	int
)	O
break	O
;	O
str	array
[	O
c1	char
++	O
]	O
=	O
c	int
;	O
}	O
str	array
[	O
c1	char
]	O
=	O
'\0'	O
;	O
if	O
(	O
c	int
==	O
':'	O
&&	O
*	O
p	pointer
==	O
']'	O
)	O
{	O
int	O
ch	char
;	O
boolean	char
is_alnum	char
=	O
STREQ	O
(	O
str	array
,	O
"alnum"	pointer
)	O
;	O
boolean	char
is_alpha	char
=	O
STREQ	O
(	O
str	array
,	O
"alpha"	pointer
)	O
;	O
boolean	char
is_blank	char
=	O
STREQ	O
(	O
str	array
,	O
"blank"	pointer
)	O
;	O
boolean	char
is_cntrl	char
=	O
STREQ	O
(	O
str	array
,	O
"cntrl"	pointer
)	O
;	O
boolean	char
is_digit	char
=	O
STREQ	O
(	O
str	array
,	O
"digit"	pointer
)	O
;	O
boolean	char
is_graph	char
=	O
STREQ	O
(	O
str	array
,	O
"graph"	pointer
)	O
;	O
boolean	char
is_lower	char
=	O
STREQ	O
(	O
str	array
,	O
"lower"	pointer
)	O
;	O
boolean	char
is_print	char
=	O
STREQ	O
(	O
str	array
,	O
"print"	pointer
)	O
;	O
boolean	char
is_punct	char
=	O
STREQ	O
(	O
str	array
,	O
"punct"	pointer
)	O
;	O
boolean	char
is_space	char
=	O
STREQ	O
(	O
str	array
,	O
"space"	pointer
)	O
;	O
boolean	char
is_upper	char
=	O
STREQ	O
(	O
str	array
,	O
"upper"	pointer
)	O
;	O
boolean	char
is_xdigit	char
=	O
STREQ	O
(	O
str	array
,	O
"xdigit"	pointer
)	O
;	O
if	O
(	O
!	O
IS_CHAR_CLASS	O
(	O
str	array
)	O
)	O
FREE_STACK_RETURN	O
(	O
REG_ECTYPE	int
)	O
;	O
PATFETCH	O
(	O
c	int
)	O
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EBRACK	int
)	O
;	O
for	O
(	O
ch	char
=	O
0	int
;	O
ch	char
<	O
1	int
<<	O
BYTEWIDTH	int
;	O
ch	char
++	O
)	O
{	O
if	O
(	O
(	O
is_alnum	char
&&	O
ISALNUM	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_alpha	char
&&	O
ISALPHA	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_blank	char
&&	O
ISBLANK	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_cntrl	char
&&	O
ISCNTRL	O
(	O
ch	char
)	O
)	O
)	O
SET_LIST_BIT	O
(	O
ch	char
)	O
;	O
if	O
(	O
(	O
is_digit	char
&&	O
ISDIGIT	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_graph	char
&&	O
ISGRAPH	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_lower	char
&&	O
ISLOWER	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_print	char
&&	O
ISPRINT	O
(	O
ch	char
)	O
)	O
)	O
SET_LIST_BIT	O
(	O
ch	char
)	O
;	O
if	O
(	O
(	O
is_punct	char
&&	O
ISPUNCT	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_space	char
&&	O
ISSPACE	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_upper	char
&&	O
ISUPPER	O
(	O
ch	char
)	O
)	O
||	O
(	O
is_xdigit	char
&&	O
ISXDIGIT	O
(	O
ch	char
)	O
)	O
)	O
SET_LIST_BIT	O
(	O
ch	char
)	O
;	O
if	O
(	O
translate	pointer
&&	O
(	O
is_upper	char
||	O
is_lower	char
)	O
&&	O
(	O
ISUPPER	O
(	O
ch	char
)	O
||	O
ISLOWER	O
(	O
ch	char
)	O
)	O
)	O
SET_LIST_BIT	O
(	O
ch	char
)	O
;	O
}	O
had_char_class	char
=	O
true	int
;	O
}	O
else	O
{	O
c1	char
++	O
;	O
while	O
(	O
c1	char
--	O
)	O
PATUNFETCH	O
;	O
SET_LIST_BIT	O
(	O
'['	O
)	O
;	O
SET_LIST_BIT	O
(	O
':'	O
)	O
;	O
had_char_class	char
=	O
false	int
;	O
}	O
}	O
else	O
{	O
had_char_class	char
=	O
false	int
;	O
SET_LIST_BIT	O
(	O
c	int
)	O
;	O
}	O
}	O
while	O
(	O
(	O
int	O
)	O
b	pointer
[	O
-	O
1	int
]	O
>	O
0	int
&&	O
b	pointer
[	O
b	pointer
[	O
-	O
1	int
]	O
-	O
1	int
]	O
==	O
0	int
)	O
b	pointer
[	O
-	O
1	int
]	O
--	O
;	O
b	pointer
+=	O
b	pointer
[	O
-	O
1	int
]	O
;	O
}	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_PARENS	O
)	O
goto	O
handle_open	O
;	O
else	O
goto	O
normal_char	O
;	O
case	O
')'	O
:	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_PARENS	O
)	O
goto	O
handle_close	O
;	O
else	O
goto	O
normal_char	O
;	O
case	O
'\n'	O
:	O
if	O
(	O
syntax	long
&	O
RE_NEWLINE_ALT	O
)	O
goto	O
handle_alt	O
;	O
else	O
goto	O
normal_char	O
;	O
case	O
'|'	O
:	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_VBAR	O
)	O
goto	O
handle_alt	O
;	O
else	O
goto	O
normal_char	O
;	O
case	O
'{'	O
:	O
if	O
(	O
syntax	long
&	O
RE_INTERVALS	O
&&	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
goto	O
handle_interval	O
;	O
else	O
goto	O
normal_char	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
FREE_STACK_RETURN	O
(	O
REG_EESCAPE	int
)	O
;	O
PATFETCH_RAW	O
(	O
c	int
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'('	O
:	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_PARENS	O
)	O
goto	O
normal_backslash	O
;	O
handle_open	O
:	O
bufp	pointer
->	O
re_nsub	long
++	O
;	O
regnum	int
++	O
;	O
if	O
(	O
COMPILE_STACK_FULL	O
)	O
{	O
RETALLOC	O
(	O
compile_stack	struct
.	O
stack	pointer
,	O
compile_stack	struct
.	O
size	int
<<	O
1	int
,	O
compile_stack_elt_t	struct
)	O
;	O
if	O
(	O
compile_stack	struct
.	O
stack	pointer
==	O
NULL	O
)	O
return	O
REG_ESPACE	int
;	O
compile_stack	struct
.	O
size	int
<<=	O
1	int
;	O
}	O
COMPILE_STACK_TOP	O
.	O
begalt_offset	long
=	O
begalt	pointer
-	O
bufp	pointer
->	O
buffer	pointer
;	O
COMPILE_STACK_TOP	O
.	O
fixup_alt_jump	long
=	O
fixup_alt_jump	long
?	O
fixup_alt_jump	long
-	O
bufp	pointer
->	O
buffer	pointer
+	O
1	int
:	O
0	int
;	O
COMPILE_STACK_TOP	O
.	O
laststart_offset	long
=	O
b	pointer
-	O
bufp	pointer
->	O
buffer	pointer
;	O
COMPILE_STACK_TOP	O
.	O
regnum	int
=	O
regnum	int
;	O
if	O
(	O
regnum	int
<=	O
MAX_REGNUM	int
)	O
{	O
COMPILE_STACK_TOP	O
.	O
inner_group_offset	long
=	O
b	pointer
-	O
bufp	pointer
->	O
buffer	pointer
+	O
2	int
;	O
BUF_PUSH_3	O
(	O
start_memory	int
,	O
regnum	int
,	O
0	int
)	O
;	O
}	O
compile_stack	struct
.	O
avail	int
++	O
;	O
fixup_alt_jump	long
=	O
0	int
;	O
laststart	pointer
=	O
0	int
;	O
begalt	pointer
=	O
b	pointer
;	O
pending_exact	pointer
=	O
0	int
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_PARENS	O
)	O
goto	O
normal_backslash	O
;	O
if	O
(	O
COMPILE_STACK_EMPTY	O
)	O
if	O
(	O
syntax	long
&	O
RE_UNMATCHED_RIGHT_PAREN_ORD	O
)	O
goto	O
normal_backslash	O
;	O
else	O
FREE_STACK_RETURN	O
(	O
REG_ERPAREN	int
)	O
;	O
handle_close	O
:	O
if	O
(	O
fixup_alt_jump	long
)	O
{	O
BUF_PUSH	O
(	O
push_dummy_failure	int
)	O
;	O
STORE_JUMP	O
(	O
jump_past_alt	int
,	O
fixup_alt_jump	long
,	O
b	pointer
-	O
1	int
)	O
;	O
}	O
if	O
(	O
COMPILE_STACK_EMPTY	O
)	O
if	O
(	O
syntax	long
&	O
RE_UNMATCHED_RIGHT_PAREN_ORD	O
)	O
goto	O
normal_char	O
;	O
else	O
FREE_STACK_RETURN	O
(	O
REG_ERPAREN	int
)	O
;	O
assert	O
(	O
compile_stack	struct
.	O
avail	int
!=	O
0	int
)	O
;	O
{	O
regnum_t	int
this_group_regnum	int
;	O
compile_stack	struct
.	O
avail	int
--	O
;	O
begalt	pointer
=	O
bufp	pointer
->	O
buffer	pointer
+	O
COMPILE_STACK_TOP	O
.	O
begalt_offset	long
;	O
fixup_alt_jump	long
=	O
COMPILE_STACK_TOP	O
.	O
fixup_alt_jump	long
?	O
bufp	pointer
->	O
buffer	pointer
+	O
COMPILE_STACK_TOP	O
.	O
fixup_alt_jump	long
-	O
1	int
:	O
0	int
;	O
laststart	pointer
=	O
bufp	pointer
->	O
buffer	pointer
+	O
COMPILE_STACK_TOP	O
.	O
laststart_offset	long
;	O
this_group_regnum	int
=	O
COMPILE_STACK_TOP	O
.	O
regnum	int
;	O
pending_exact	pointer
=	O
0	int
;	O
if	O
(	O
this_group_regnum	int
<=	O
MAX_REGNUM	int
)	O
{	O
unsigned	O
char	O
*	O
inner_group_loc	pointer
=	O
bufp	pointer
->	O
buffer	pointer
+	O
COMPILE_STACK_TOP	O
.	O
inner_group_offset	long
;	O
*	O
inner_group_loc	pointer
=	O
regnum	int
-	O
this_group_regnum	int
;	O
BUF_PUSH_3	O
(	O
stop_memory	int
,	O
this_group_regnum	int
,	O
regnum	int
-	O
this_group_regnum	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'|'	O
:	O
if	O
(	O
syntax	long
&	O
RE_LIMITED_OPS	O
||	O
syntax	long
&	O
RE_NO_BK_VBAR	O
)	O
goto	O
normal_backslash	O
;	O
handle_alt	O
:	O
if	O
(	O
syntax	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
GET_BUFFER_SPACE	O
(	O
3	int
)	O
;	O
INSERT_JUMP	O
(	O
on_failure_jump	int
,	O
begalt	pointer
,	O
b	pointer
+	O
6	int
)	O
;	O
pending_exact	pointer
=	O
0	int
;	O
b	pointer
+=	O
3	int
;	O
if	O
(	O
fixup_alt_jump	long
)	O
STORE_JUMP	O
(	O
jump_past_alt	int
,	O
fixup_alt_jump	long
,	O
b	pointer
)	O
;	O
fixup_alt_jump	long
=	O
b	pointer
;	O
GET_BUFFER_SPACE	O
(	O
3	int
)	O
;	O
b	pointer
+=	O
3	int
;	O
laststart	pointer
=	O
0	int
;	O
begalt	pointer
=	O
b	pointer
;	O
break	O
;	O
case	O
'{'	O
:	O
if	O
(	O
!	O
(	O
syntax	long
&	O
RE_INTERVALS	O
)	O
||	O
(	O
(	O
syntax	long
&	O
RE_INTERVALS	O
)	O
&&	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
)	O
||	O
(	O
p	pointer
-	O
2	int
==	O
pattern	pointer
&&	O
p	pointer
==	O
pend	pointer
)	O
)	O
goto	O
normal_backslash	O
;	O
handle_interval	O
:	O
{	O
int	O
lower_bound	int
=	O
-	O
1	int
,	O
upper_bound	int
=	O
-	O
1	int
;	O
beg_interval	pointer
=	O
p	pointer
-	O
1	int
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
{	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
goto	O
unfetch_interval	O
;	O
else	O
FREE_STACK_RETURN	O
(	O
REG_EBRACE	int
)	O
;	O
}	O
GET_UNSIGNED_NUMBER	O
(	O
lower_bound	int
)	O
;	O
if	O
(	O
c	int
==	O
','	O
)	O
{	O
GET_UNSIGNED_NUMBER	O
(	O
upper_bound	int
)	O
;	O
if	O
(	O
upper_bound	int
<	O
0	int
)	O
upper_bound	int
=	O
RE_DUP_MAX	O
;	O
}	O
else	O
upper_bound	int
=	O
lower_bound	int
;	O
if	O
(	O
lower_bound	int
<	O
0	int
||	O
upper_bound	int
>	O
RE_DUP_MAX	O
||	O
lower_bound	int
>	O
upper_bound	int
)	O
{	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
goto	O
unfetch_interval	O
;	O
else	O
FREE_STACK_RETURN	O
(	O
REG_BADBR	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
)	O
{	O
if	O
(	O
c	int
!=	O
'\\'	O
)	O
FREE_STACK_RETURN	O
(	O
REG_EBRACE	int
)	O
;	O
PATFETCH	O
(	O
c	int
)	O
;	O
}	O
if	O
(	O
c	int
!=	O
'}'	O
)	O
{	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
goto	O
unfetch_interval	O
;	O
else	O
FREE_STACK_RETURN	O
(	O
REG_BADBR	int
)	O
;	O
}	O
if	O
(	O
!	O
laststart	pointer
)	O
{	O
if	O
(	O
syntax	long
&	O
RE_CONTEXT_INVALID_OPS	O
)	O
FREE_STACK_RETURN	O
(	O
REG_BADRPT	int
)	O
;	O
else	O
if	O
(	O
syntax	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
laststart	pointer
=	O
b	pointer
;	O
else	O
goto	O
unfetch_interval	O
;	O
}	O
if	O
(	O
upper_bound	int
==	O
0	int
)	O
{	O
GET_BUFFER_SPACE	O
(	O
3	int
)	O
;	O
INSERT_JUMP	O
(	O
jump	int
,	O
laststart	pointer
,	O
b	pointer
+	O
3	int
)	O
;	O
b	pointer
+=	O
3	int
;	O
}	O
else	O
{	O
unsigned	O
nbytes	int
=	O
10	int
+	O
(	O
upper_bound	int
>	O
1	int
)	O
*	O
10	int
;	O
GET_BUFFER_SPACE	O
(	O
nbytes	int
)	O
;	O
INSERT_JUMP2	O
(	O
succeed_n	int
,	O
laststart	pointer
,	O
b	pointer
+	O
5	int
+	O
(	O
upper_bound	int
>	O
1	int
)	O
*	O
5	int
,	O
lower_bound	int
)	O
;	O
b	pointer
+=	O
5	int
;	O
insert_op2	function
(	O
set_number_at	int
,	O
laststart	pointer
,	O
5	int
,	O
lower_bound	int
,	O
b	pointer
)	O
;	O
b	pointer
+=	O
5	int
;	O
if	O
(	O
upper_bound	int
>	O
1	int
)	O
{	O
STORE_JUMP2	O
(	O
jump_n	int
,	O
b	pointer
,	O
laststart	pointer
+	O
5	int
,	O
upper_bound	int
-	O
1	int
)	O
;	O
b	pointer
+=	O
5	int
;	O
insert_op2	function
(	O
set_number_at	int
,	O
laststart	pointer
,	O
b	pointer
-	O
laststart	pointer
,	O
upper_bound	int
-	O
1	int
,	O
b	pointer
)	O
;	O
b	pointer
+=	O
5	int
;	O
}	O
}	O
pending_exact	pointer
=	O
0	int
;	O
beg_interval	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
unfetch_interval	O
:	O
assert	O
(	O
beg_interval	pointer
)	O
;	O
p	pointer
=	O
beg_interval	pointer
;	O
beg_interval	pointer
=	O
NULL	O
;	O
PATFETCH	O
(	O
c	int
)	O
;	O
if	O
(	O
!	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
)	O
{	O
if	O
(	O
p	pointer
>	O
pattern	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
goto	O
normal_backslash	O
;	O
}	O
goto	O
normal_char	O
;	O
case	O
'w'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
laststart	pointer
=	O
b	pointer
;	O
BUF_PUSH	O
(	O
wordchar	int
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
laststart	pointer
=	O
b	pointer
;	O
BUF_PUSH	O
(	O
notwordchar	int
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
BUF_PUSH	O
(	O
wordbeg	int
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
BUF_PUSH	O
(	O
wordend	int
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
BUF_PUSH	O
(	O
wordbound	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
BUF_PUSH	O
(	O
notwordbound	int
)	O
;	O
break	O
;	O
case	O
'`'	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
BUF_PUSH	O
(	O
begbuf	int
)	O
;	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
re_syntax_options	long
&	O
RE_NO_GNU_OPS	O
)	O
goto	O
normal_char	O
;	O
BUF_PUSH	O
(	O
endbuf	int
)	O
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
syntax	long
&	O
RE_NO_BK_REFS	O
)	O
goto	O
normal_char	O
;	O
c1	char
=	O
c	int
-	O
'0'	O
;	O
if	O
(	O
c1	char
>	O
regnum	int
)	O
FREE_STACK_RETURN	O
(	O
REG_ESUBREG	int
)	O
;	O
if	O
(	O
group_in_compile_stack	function
(	O
compile_stack	struct
,	O
(	O
regnum_t	int
)	O
c1	char
)	O
)	O
goto	O
normal_char	O
;	O
laststart	pointer
=	O
b	pointer
;	O
BUF_PUSH_2	O
(	O
duplicate	int
,	O
c1	char
)	O
;	O
break	O
;	O
case	O
'+'	O
:	O
case	O
'?'	O
:	O
if	O
(	O
syntax	long
&	O
RE_BK_PLUS_QM	O
)	O
goto	O
handle_plus	O
;	O
else	O
goto	O
normal_backslash	O
;	O
default	O
:	O
normal_backslash	O
:	O
c	int
=	O
TRANSLATE	O
(	O
c	int
)	O
;	O
goto	O
normal_char	O
;	O
}	O
break	O
;	O
default	O
:	O
normal_char	O
:	O
if	O
(	O
!	O
pending_exact	pointer
||	O
pending_exact	pointer
+	O
*	O
pending_exact	pointer
+	O
1	int
!=	O
b	pointer
||	O
*	O
pending_exact	pointer
==	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
-	O
1	int
||	O
*	O
p	pointer
==	O
'*'	O
||	O
*	O
p	pointer
==	O
'^'	O
||	O
(	O
(	O
syntax	long
&	O
RE_BK_PLUS_QM	O
)	O
?	O
*	O
p	pointer
==	O
'\\'	O
&&	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'+'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'?'	O
)	O
:	O
(	O
*	O
p	pointer
==	O
'+'	O
||	O
*	O
p	pointer
==	O
'?'	O
)	O
)	O
||	O
(	O
(	O
syntax	long
&	O
RE_INTERVALS	O
)	O
&&	O
(	O
(	O
syntax	long
&	O
RE_NO_BK_BRACES	O
)	O
?	O
*	O
p	pointer
==	O
'{'	O
:	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'\\'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'{'	O
)	O
)	O
)	O
)	O
{	O
laststart	pointer
=	O
b	pointer
;	O
BUF_PUSH_2	O
(	O
exactn	int
,	O
0	int
)	O
;	O
pending_exact	pointer
=	O
b	pointer
-	O
1	int
;	O
}	O
BUF_PUSH	O
(	O
c	int
)	O
;	O
(	O
*	O
pending_exact	pointer
)	O
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
fixup_alt_jump	long
)	O
STORE_JUMP	O
(	O
jump_past_alt	int
,	O
fixup_alt_jump	long
,	O
b	pointer
)	O
;	O
if	O
(	O
!	O
COMPILE_STACK_EMPTY	O
)	O
FREE_STACK_RETURN	O
(	O
REG_EPAREN	int
)	O
;	O
if	O
(	O
syntax	long
&	O
RE_NO_POSIX_BACKTRACKING	O
)	O
BUF_PUSH	O
(	O
succeed	int
)	O
;	O
free	function
(	O
compile_stack	struct
.	O
stack	pointer
)	O
;	O
bufp	pointer
->	O
used	long
=	O
b	pointer
-	O
bufp	pointer
->	O
buffer	pointer
;	O
return	O
REG_NOERROR	int
;	O
}	O
static	O
void	O
store_op1	function
(	O
op	enum
,	O
loc	pointer
,	O
arg	int
)	O
re_opcode_t	enum
op	enum
;	O
unsigned	O
char	O
*	O
loc	pointer
;	O
int	O
arg	int
;	O
{	O
*	O
loc	pointer
=	O
(	O
unsigned	O
char	O
)	O
op	enum
;	O
STORE_NUMBER	O
(	O
loc	pointer
+	O
1	int
,	O
arg	int
)	O
;	O
}	O
static	O
void	O
store_op2	function
(	O
op	enum
,	O
loc	pointer
,	O
arg1	int
,	O
arg2	int
)	O
re_opcode_t	enum
op	enum
;	O
unsigned	O
char	O
*	O
loc	pointer
;	O
int	O
arg1	int
,	O
arg2	int
;	O
{	O
*	O
loc	pointer
=	O
(	O
unsigned	O
char	O
)	O
op	enum
;	O
STORE_NUMBER	O
(	O
loc	pointer
+	O
1	int
,	O
arg1	int
)	O
;	O
STORE_NUMBER	O
(	O
loc	pointer
+	O
3	int
,	O
arg2	int
)	O
;	O
}	O
static	O
void	O
insert_op1	function
(	O
op	enum
,	O
loc	pointer
,	O
arg	int
,	O
end	pointer
)	O
re_opcode_t	enum
op	enum
;	O
unsigned	O
char	O
*	O
loc	pointer
;	O
int	O
arg	int
;	O
unsigned	O
char	O
*	O
end	pointer
;	O
{	O
register	O
unsigned	O
char	O
*	O
pfrom	pointer
=	O
end	pointer
;	O
register	O
unsigned	O
char	O
*	O
pto	pointer
=	O
end	pointer
+	O
3	int
;	O
while	O
(	O
pfrom	pointer
!=	O
loc	pointer
)	O
*	O
--	O
pto	pointer
=	O
*	O
--	O
pfrom	pointer
;	O
store_op1	function
(	O
op	enum
,	O
loc	pointer
,	O
arg	int
)	O
;	O
}	O
static	O
void	O
insert_op2	function
(	O
op	enum
,	O
loc	pointer
,	O
arg1	int
,	O
arg2	int
,	O
end	pointer
)	O
re_opcode_t	enum
op	enum
;	O
unsigned	O
char	O
*	O
loc	pointer
;	O
int	O
arg1	int
,	O
arg2	int
;	O
unsigned	O
char	O
*	O
end	pointer
;	O
{	O
register	O
unsigned	O
char	O
*	O
pfrom	pointer
=	O
end	pointer
;	O
register	O
unsigned	O
char	O
*	O
pto	pointer
=	O
end	pointer
+	O
5	int
;	O
while	O
(	O
pfrom	pointer
!=	O
loc	pointer
)	O
*	O
--	O
pto	pointer
=	O
*	O
--	O
pfrom	pointer
;	O
store_op2	function
(	O
op	enum
,	O
loc	pointer
,	O
arg1	int
,	O
arg2	int
)	O
;	O
}	O
static	O
boolean	char
at_begline_loc_p	function
(	O
pattern	pointer
,	O
p	pointer
,	O
syntax	long
)	O
const	O
char	O
*	O
pattern	pointer
,	O
*	O
p	pointer
;	O
reg_syntax_t	long
syntax	long
;	O
{	O
const	O
char	O
*	O
prev	pointer
=	O
p	pointer
-	O
2	int
;	O
boolean	char
prev_prev_backslash	char
=	O
prev	pointer
>	O
pattern	pointer
&&	O
prev	pointer
[	O
-	O
1	int
]	O
==	O
'\\'	O
;	O
return	O
(	O
*	O
prev	pointer
==	O
'('	O
&&	O
(	O
syntax	long
&	O
RE_NO_BK_PARENS	O
||	O
prev_prev_backslash	char
)	O
)	O
||	O
(	O
*	O
prev	pointer
==	O
'|'	O
&&	O
(	O
syntax	long
&	O
RE_NO_BK_VBAR	O
||	O
prev_prev_backslash	char
)	O
)	O
;	O
}	O
static	O
boolean	char
at_endline_loc_p	function
(	O
p	pointer
,	O
pend	pointer
,	O
syntax	long
)	O
const	O
char	O
*	O
p	pointer
,	O
*	O
pend	pointer
;	O
reg_syntax_t	long
syntax	long
;	O
{	O
const	O
char	O
*	O
next	pointer
=	O
p	pointer
;	O
boolean	char
next_backslash	char
=	O
*	O
next	pointer
==	O
'\\'	O
;	O
const	O
char	O
*	O
next_next	pointer
=	O
p	pointer
+	O
1	int
<	O
pend	pointer
?	O
p	pointer
+	O
1	int
:	O
0	int
;	O
return	O
(	O
syntax	long
&	O
RE_NO_BK_PARENS	O
?	O
*	O
next	pointer
==	O
')'	O
:	O
next_backslash	char
&&	O
next_next	pointer
&&	O
*	O
next_next	pointer
==	O
')'	O
)	O
||	O
(	O
syntax	long
&	O
RE_NO_BK_VBAR	O
?	O
*	O
next	pointer
==	O
'|'	O
:	O
next_backslash	char
&&	O
next_next	pointer
&&	O
*	O
next_next	pointer
==	O
'|'	O
)	O
;	O
}	O
static	O
boolean	char
group_in_compile_stack	function
(	O
compile_stack	struct
,	O
regnum	int
)	O
compile_stack_type	struct
compile_stack	struct
;	O
regnum_t	int
regnum	int
;	O
{	O
int	O
this_element	int
;	O
for	O
(	O
this_element	int
=	O
compile_stack	struct
.	O
avail	int
-	O
1	int
;	O
this_element	int
>=	O
0	int
;	O
this_element	int
--	O
)	O
if	O
(	O
compile_stack	struct
.	O
stack	pointer
[	O
this_element	int
]	O
.	O
regnum	int
==	O
regnum	int
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
static	O
reg_errcode_t	enum
compile_range	function
(	O
p_ptr	pointer
,	O
pend	pointer
,	O
translate	pointer
,	O
syntax	long
,	O
b	pointer
)	O
const	O
char	O
*	O
*	O
p_ptr	pointer
,	O
*	O
pend	pointer
;	O
RE_TRANSLATE_TYPE	O
translate	pointer
;	O
reg_syntax_t	long
syntax	long
;	O
unsigned	O
char	O
*	O
b	pointer
;	O
{	O
unsigned	O
this_char	int
;	O
const	O
char	O
*	O
p	pointer
=	O
*	O
p_ptr	pointer
;	O
unsigned	O
int	O
range_start	int
,	O
range_end	int
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
return	O
REG_ERANGE	int
;	O
range_start	int
=	O
(	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
p	pointer
)	O
[	O
-	O
2	int
]	O
;	O
range_end	int
=	O
(	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
p	pointer
)	O
[	O
0	int
]	O
;	O
(	O
*	O
p_ptr	pointer
)	O
++	O
;	O
if	O
(	O
range_start	int
>	O
range_end	int
)	O
return	O
syntax	long
&	O
RE_NO_EMPTY_RANGES	O
?	O
REG_ERANGE	int
:	O
REG_NOERROR	int
;	O
for	O
(	O
this_char	int
=	O
range_start	int
;	O
this_char	int
<=	O
range_end	int
;	O
this_char	int
++	O
)	O
{	O
SET_LIST_BIT	O
(	O
TRANSLATE	O
(	O
this_char	int
)	O
)	O
;	O
}	O
return	O
REG_NOERROR	int
;	O
}	O
int	O
re_compile_fastmap	function
(	O
bufp	pointer
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
{	O
int	O
j	int
,	O
k	int
;	O
fail_stack_type	struct
fail_stack	struct
;	O
char	O
*	O
destination	pointer
;	O
unsigned	O
num_regs	int
=	O
0	int
;	O
register	O
char	O
*	O
fastmap	pointer
=	O
bufp	pointer
->	O
fastmap	pointer
;	O
unsigned	O
char	O
*	O
pattern	pointer
=	O
bufp	pointer
->	O
buffer	pointer
;	O
unsigned	O
char	O
*	O
p	pointer
=	O
pattern	pointer
;	O
register	O
unsigned	O
char	O
*	O
pend	pointer
=	O
pattern	pointer
+	O
bufp	pointer
->	O
used	long
;	O
boolean	char
path_can_be_null	char
=	O
true	int
;	O
boolean	char
succeed_n_p	char
=	O
false	int
;	O
assert	O
(	O
fastmap	pointer
!=	O
NULL	O
&&	O
p	pointer
!=	O
NULL	O
)	O
;	O
INIT_FAIL_STACK	O
(	O
)	O
;	O
bzero	function
(	O
fastmap	pointer
,	O
1	int
<<	O
BYTEWIDTH	int
)	O
;	O
bufp	pointer
->	O
fastmap_accurate	int
=	O
1	int
;	O
bufp	pointer
->	O
can_be_null	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
p	pointer
==	O
pend	pointer
||	O
*	O
p	pointer
==	O
succeed	int
)	O
{	O
if	O
(	O
!	O
FAIL_STACK_EMPTY	O
(	O
)	O
)	O
{	O
bufp	pointer
->	O
can_be_null	int
|=	O
path_can_be_null	char
;	O
path_can_be_null	char
=	O
true	int
;	O
p	pointer
=	O
fail_stack	struct
.	O
stack	pointer
[	O
--	O
fail_stack	struct
.	O
avail	int
]	O
.	O
pointer	pointer
;	O
continue	O
;	O
}	O
else	O
break	O
;	O
}	O
assert	O
(	O
p	pointer
<	O
pend	pointer
)	O
;	O
switch	O
(	O
SWITCH_ENUM_CAST	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p	pointer
++	O
)	O
)	O
{	O
case	O
duplicate	int
:	O
bufp	pointer
->	O
can_be_null	int
=	O
1	int
;	O
goto	O
done	int
;	O
case	O
exactn	int
:	O
fastmap	pointer
[	O
p	pointer
[	O
1	int
]	O
]	O
=	O
1	int
;	O
break	O
;	O
case	O
charset	int
:	O
for	O
(	O
j	int
=	O
*	O
p	pointer
++	O
*	O
BYTEWIDTH	int
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
if	O
(	O
p	pointer
[	O
j	int
/	O
BYTEWIDTH	int
]	O
&	O
(	O
1	int
<<	O
(	O
j	int
%	O
BYTEWIDTH	int
)	O
)	O
)	O
fastmap	pointer
[	O
j	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
charset_not	int
:	O
for	O
(	O
j	int
=	O
*	O
p	pointer
*	O
BYTEWIDTH	int
;	O
j	int
<	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
;	O
j	int
++	O
)	O
fastmap	pointer
[	O
j	int
]	O
=	O
1	int
;	O
for	O
(	O
j	int
=	O
*	O
p	pointer
++	O
*	O
BYTEWIDTH	int
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
if	O
(	O
!	O
(	O
p	pointer
[	O
j	int
/	O
BYTEWIDTH	int
]	O
&	O
(	O
1	int
<<	O
(	O
j	int
%	O
BYTEWIDTH	int
)	O
)	O
)	O
)	O
fastmap	pointer
[	O
j	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
wordchar	int
:	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
;	O
j	int
++	O
)	O
if	O
(	O
SYNTAX	O
(	O
j	int
)	O
==	O
Sword	int
)	O
fastmap	pointer
[	O
j	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
notwordchar	int
:	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
;	O
j	int
++	O
)	O
if	O
(	O
SYNTAX	O
(	O
j	int
)	O
!=	O
Sword	int
)	O
fastmap	pointer
[	O
j	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
anychar	int
:	O
{	O
int	O
fastmap_newline	int
=	O
fastmap	pointer
[	O
'\n'	O
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
1	int
<<	O
BYTEWIDTH	int
)	O
;	O
j	int
++	O
)	O
fastmap	pointer
[	O
j	int
]	O
=	O
1	int
;	O
if	O
(	O
!	O
(	O
bufp	pointer
->	O
syntax	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
fastmap	pointer
[	O
'\n'	O
]	O
=	O
fastmap_newline	int
;	O
else	O
if	O
(	O
bufp	pointer
->	O
can_be_null	int
)	O
goto	O
done	int
;	O
break	O
;	O
}	O
case	O
no_op	int
:	O
case	O
begline	int
:	O
case	O
endline	int
:	O
case	O
begbuf	int
:	O
case	O
endbuf	int
:	O
case	O
wordbound	int
:	O
case	O
notwordbound	int
:	O
case	O
wordbeg	int
:	O
case	O
wordend	int
:	O
case	O
push_dummy_failure	int
:	O
continue	O
;	O
case	O
jump_n	int
:	O
case	O
pop_failure_jump	int
:	O
case	O
maybe_pop_jump	int
:	O
case	O
jump	int
:	O
case	O
jump_past_alt	int
:	O
case	O
dummy_failure_jump	int
:	O
EXTRACT_NUMBER_AND_INCR	O
(	O
j	int
,	O
p	pointer
)	O
;	O
p	pointer
+=	O
j	int
;	O
if	O
(	O
j	int
>	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p	pointer
!=	O
on_failure_jump	int
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p	pointer
!=	O
succeed_n	int
)	O
continue	O
;	O
p	pointer
++	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
j	int
,	O
p	pointer
)	O
;	O
p	pointer
+=	O
j	int
;	O
if	O
(	O
!	O
FAIL_STACK_EMPTY	O
(	O
)	O
&&	O
fail_stack	struct
.	O
stack	pointer
[	O
fail_stack	struct
.	O
avail	int
-	O
1	int
]	O
.	O
pointer	pointer
==	O
p	pointer
)	O
fail_stack	struct
.	O
avail	int
--	O
;	O
continue	O
;	O
case	O
on_failure_jump	int
:	O
case	O
on_failure_keep_string_jump	int
:	O
handle_on_failure_jump	O
:	O
EXTRACT_NUMBER_AND_INCR	O
(	O
j	int
,	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
+	O
j	int
<	O
pend	pointer
)	O
{	O
if	O
(	O
!	O
PUSH_PATTERN_OP	O
(	O
p	pointer
+	O
j	int
,	O
fail_stack	struct
)	O
)	O
{	O
RESET_FAIL_STACK	O
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
else	O
bufp	pointer
->	O
can_be_null	int
=	O
1	int
;	O
if	O
(	O
succeed_n_p	char
)	O
{	O
EXTRACT_NUMBER_AND_INCR	O
(	O
k	int
,	O
p	pointer
)	O
;	O
succeed_n_p	char
=	O
false	int
;	O
}	O
continue	O
;	O
case	O
succeed_n	int
:	O
p	pointer
+=	O
2	int
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
k	int
,	O
p	pointer
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
{	O
p	pointer
-=	O
4	int
;	O
succeed_n_p	char
=	O
true	int
;	O
goto	O
handle_on_failure_jump	O
;	O
}	O
continue	O
;	O
case	O
set_number_at	int
:	O
p	pointer
+=	O
4	int
;	O
continue	O
;	O
case	O
start_memory	int
:	O
case	O
stop_memory	int
:	O
p	pointer
+=	O
2	int
;	O
continue	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
path_can_be_null	char
=	O
false	int
;	O
p	pointer
=	O
pend	pointer
;	O
}	O
bufp	pointer
->	O
can_be_null	int
|=	O
path_can_be_null	char
;	O
done	int
:	O
RESET_FAIL_STACK	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
re_set_registers	function
(	O
bufp	pointer
,	O
regs	pointer
,	O
num_regs	int
,	O
starts	pointer
,	O
ends	pointer
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
struct	O
re_registers	struct
*	O
regs	pointer
;	O
unsigned	O
num_regs	int
;	O
regoff_t	int
*	O
starts	pointer
,	O
*	O
ends	pointer
;	O
{	O
if	O
(	O
num_regs	int
)	O
{	O
bufp	pointer
->	O
regs_allocated	int
=	O
REGS_REALLOCATE	int
;	O
regs	pointer
->	O
num_regs	int
=	O
num_regs	int
;	O
regs	pointer
->	O
start	pointer
=	O
starts	pointer
;	O
regs	pointer
->	O
end	pointer
=	O
ends	pointer
;	O
}	O
else	O
{	O
bufp	pointer
->	O
regs_allocated	int
=	O
REGS_UNALLOCATED	int
;	O
regs	pointer
->	O
num_regs	int
=	O
0	int
;	O
regs	pointer
->	O
start	pointer
=	O
regs	pointer
->	O
end	pointer
=	O
(	O
regoff_t	int
*	O
)	O
0	int
;	O
}	O
}	O
int	O
re_search	function
(	O
bufp	pointer
,	O
string	pointer
,	O
size	int
,	O
startpos	int
,	O
range	int
,	O
regs	pointer
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
const	O
char	O
*	O
string	pointer
;	O
int	O
size	int
,	O
startpos	int
,	O
range	int
;	O
struct	O
re_registers	struct
*	O
regs	pointer
;	O
{	O
return	O
re_search_2	function
(	O
bufp	pointer
,	O
NULL	O
,	O
0	int
,	O
string	pointer
,	O
size	int
,	O
startpos	int
,	O
range	int
,	O
regs	pointer
,	O
size	int
)	O
;	O
}	O
int	O
re_search_2	function
(	O
bufp	pointer
,	O
string1	pointer
,	O
size1	int
,	O
string2	pointer
,	O
size2	int
,	O
startpos	int
,	O
range	int
,	O
regs	pointer
,	O
stop	int
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
const	O
char	O
*	O
string1	pointer
,	O
*	O
string2	pointer
;	O
int	O
size1	int
,	O
size2	int
;	O
int	O
startpos	int
;	O
int	O
range	int
;	O
struct	O
re_registers	struct
*	O
regs	pointer
;	O
int	O
stop	int
;	O
{	O
int	O
val	int
;	O
register	O
char	O
*	O
fastmap	pointer
=	O
bufp	pointer
->	O
fastmap	pointer
;	O
register	O
RE_TRANSLATE_TYPE	O
translate	pointer
=	O
bufp	pointer
->	O
translate	pointer
;	O
int	O
total_size	int
=	O
size1	int
+	O
size2	int
;	O
int	O
endpos	int
=	O
startpos	int
+	O
range	int
;	O
if	O
(	O
startpos	int
<	O
0	int
||	O
startpos	int
>	O
total_size	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
endpos	int
<	O
0	int
)	O
range	int
=	O
0	int
-	O
startpos	int
;	O
else	O
if	O
(	O
endpos	int
>	O
total_size	int
)	O
range	int
=	O
total_size	int
-	O
startpos	int
;	O
if	O
(	O
bufp	pointer
->	O
used	long
>	O
0	int
&&	O
(	O
re_opcode_t	enum
)	O
bufp	pointer
->	O
buffer	pointer
[	O
0	int
]	O
==	O
begbuf	int
&&	O
range	int
>	O
0	int
)	O
{	O
if	O
(	O
startpos	int
>	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
range	int
=	O
1	int
;	O
}	O
if	O
(	O
fastmap	pointer
&&	O
!	O
bufp	pointer
->	O
fastmap_accurate	int
)	O
if	O
(	O
re_compile_fastmap	function
(	O
bufp	pointer
)	O
==	O
-	O
2	int
)	O
return	O
-	O
2	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
fastmap	pointer
&&	O
startpos	int
<	O
total_size	int
&&	O
!	O
bufp	pointer
->	O
can_be_null	int
)	O
{	O
if	O
(	O
range	int
>	O
0	int
)	O
{	O
register	O
const	O
char	O
*	O
d	pointer
;	O
register	O
int	O
lim	int
=	O
0	int
;	O
int	O
irange	int
=	O
range	int
;	O
if	O
(	O
startpos	int
<	O
size1	int
&&	O
startpos	int
+	O
range	int
>=	O
size1	int
)	O
lim	int
=	O
range	int
-	O
(	O
size1	int
-	O
startpos	int
)	O
;	O
d	pointer
=	O
(	O
startpos	int
>=	O
size1	int
?	O
string2	pointer
-	O
size1	int
:	O
string1	pointer
)	O
+	O
startpos	int
;	O
if	O
(	O
translate	pointer
)	O
while	O
(	O
range	int
>	O
lim	int
&&	O
!	O
fastmap	pointer
[	O
(	O
unsigned	O
char	O
)	O
translate	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
d	pointer
++	O
]	O
]	O
)	O
range	int
--	O
;	O
else	O
while	O
(	O
range	int
>	O
lim	int
&&	O
!	O
fastmap	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
d	pointer
++	O
]	O
)	O
range	int
--	O
;	O
startpos	int
+=	O
irange	int
-	O
range	int
;	O
}	O
else	O
{	O
register	O
char	O
c	int
=	O
(	O
size1	int
==	O
0	int
||	O
startpos	int
>=	O
size1	int
?	O
string2	pointer
[	O
startpos	int
-	O
size1	int
]	O
:	O
string1	pointer
[	O
startpos	int
]	O
)	O
;	O
if	O
(	O
!	O
fastmap	pointer
[	O
(	O
unsigned	O
char	O
)	O
TRANSLATE	O
(	O
c	int
)	O
]	O
)	O
goto	O
advance	O
;	O
}	O
}	O
if	O
(	O
range	int
>=	O
0	int
&&	O
startpos	int
==	O
total_size	int
&&	O
fastmap	pointer
&&	O
!	O
bufp	pointer
->	O
can_be_null	int
)	O
return	O
-	O
1	int
;	O
val	int
=	O
re_match_2_internal	function
(	O
bufp	pointer
,	O
string1	pointer
,	O
size1	int
,	O
string2	pointer
,	O
size2	int
,	O
startpos	int
,	O
regs	pointer
,	O
stop	int
)	O
;	O
if	O
(	O
val	int
>=	O
0	int
)	O
return	O
startpos	int
;	O
if	O
(	O
val	int
==	O
-	O
2	int
)	O
return	O
-	O
2	int
;	O
advance	O
:	O
if	O
(	O
!	O
range	int
)	O
break	O
;	O
else	O
if	O
(	O
range	int
>	O
0	int
)	O
{	O
range	int
--	O
;	O
startpos	int
++	O
;	O
}	O
else	O
{	O
range	int
++	O
;	O
startpos	int
--	O
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
re_match	function
(	O
bufp	pointer
,	O
string	pointer
,	O
size	int
,	O
pos	int
,	O
regs	pointer
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
const	O
char	O
*	O
string	pointer
;	O
int	O
size	int
,	O
pos	int
;	O
struct	O
re_registers	struct
*	O
regs	pointer
;	O
{	O
int	O
result	int
=	O
re_match_2_internal	function
(	O
bufp	pointer
,	O
NULL	O
,	O
0	int
,	O
string	pointer
,	O
size	int
,	O
pos	int
,	O
regs	pointer
,	O
size	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
boolean	char
group_match_null_string_p	function
_RE_ARGS	O
(	O
(	O
unsigned	O
char	O
*	O
*	O
p	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
register_info_type	union
*	O
reg_info	pointer
)	O
)	O
;	O
static	O
boolean	char
alt_match_null_string_p	function
_RE_ARGS	O
(	O
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
register_info_type	union
*	O
reg_info	pointer
)	O
)	O
;	O
static	O
boolean	char
common_op_match_null_string_p	function
_RE_ARGS	O
(	O
(	O
unsigned	O
char	O
*	O
*	O
p	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
register_info_type	union
*	O
reg_info	pointer
)	O
)	O
;	O
static	O
int	O
bcmp_translate	function
_RE_ARGS	O
(	O
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
int	O
len	int
,	O
char	O
*	O
translate	pointer
)	O
)	O
;	O
int	O
re_match_2	function
(	O
bufp	pointer
,	O
string1	pointer
,	O
size1	int
,	O
string2	pointer
,	O
size2	int
,	O
pos	int
,	O
regs	pointer
,	O
stop	int
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
const	O
char	O
*	O
string1	pointer
,	O
*	O
string2	pointer
;	O
int	O
size1	int
,	O
size2	int
;	O
int	O
pos	int
;	O
struct	O
re_registers	struct
*	O
regs	pointer
;	O
int	O
stop	int
;	O
{	O
int	O
result	int
=	O
re_match_2_internal	function
(	O
bufp	pointer
,	O
string1	pointer
,	O
size1	int
,	O
string2	pointer
,	O
size2	int
,	O
pos	int
,	O
regs	pointer
,	O
stop	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
re_match_2_internal	function
(	O
bufp	pointer
,	O
string1	pointer
,	O
size1	int
,	O
string2	pointer
,	O
size2	int
,	O
pos	int
,	O
regs	pointer
,	O
stop	int
)	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
const	O
char	O
*	O
string1	pointer
,	O
*	O
string2	pointer
;	O
int	O
size1	int
,	O
size2	int
;	O
int	O
pos	int
;	O
struct	O
re_registers	struct
*	O
regs	pointer
;	O
int	O
stop	int
;	O
{	O
int	O
mcnt	int
;	O
unsigned	O
char	O
*	O
p1	pointer
;	O
const	O
char	O
*	O
end1	pointer
,	O
*	O
end2	pointer
;	O
const	O
char	O
*	O
end_match_1	pointer
,	O
*	O
end_match_2	pointer
;	O
const	O
char	O
*	O
d	pointer
,	O
*	O
dend	pointer
;	O
unsigned	O
char	O
*	O
p	pointer
=	O
bufp	pointer
->	O
buffer	pointer
;	O
register	O
unsigned	O
char	O
*	O
pend	pointer
=	O
p	pointer
+	O
bufp	pointer
->	O
used	long
;	O
unsigned	O
char	O
*	O
just_past_start_mem	pointer
=	O
0	int
;	O
RE_TRANSLATE_TYPE	O
translate	pointer
=	O
bufp	pointer
->	O
translate	pointer
;	O
fail_stack_type	struct
fail_stack	struct
;	O
size_t	long
num_regs	int
=	O
bufp	pointer
->	O
re_nsub	long
+	O
1	int
;	O
active_reg_t	long
lowest_active_reg	long
=	O
NO_LOWEST_ACTIVE_REG	O
;	O
active_reg_t	long
highest_active_reg	long
=	O
NO_HIGHEST_ACTIVE_REG	O
;	O
const	O
char	O
*	O
*	O
regstart	pointer
,	O
*	O
*	O
regend	pointer
;	O
const	O
char	O
*	O
*	O
old_regstart	pointer
,	O
*	O
*	O
old_regend	pointer
;	O
register_info_type	union
*	O
reg_info	pointer
;	O
unsigned	O
best_regs_set	int
=	O
false	int
;	O
const	O
char	O
*	O
*	O
best_regstart	pointer
,	O
*	O
*	O
best_regend	pointer
;	O
const	O
char	O
*	O
match_end	pointer
=	O
NULL	O
;	O
int	O
set_regs_matched_done	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
reg_dummy	pointer
;	O
register_info_type	union
*	O
reg_info_dummy	pointer
;	O
DEBUG_PRINT1	O
(	O
"\n\nEntering re_match_2.\n"	pointer
)	O
;	O
INIT_FAIL_STACK	O
(	O
)	O
;	O
if	O
(	O
bufp	pointer
->	O
re_nsub	long
)	O
{	O
regstart	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
regend	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
old_regstart	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
old_regend	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
best_regstart	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
best_regend	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
reg_info	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
register_info_type	union
)	O
;	O
reg_dummy	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
const	O
char	O
*	O
)	O
;	O
reg_info_dummy	pointer
=	O
REGEX_TALLOC	O
(	O
num_regs	int
,	O
register_info_type	union
)	O
;	O
if	O
(	O
!	O
(	O
regstart	pointer
&&	O
regend	pointer
&&	O
old_regstart	pointer
&&	O
old_regend	pointer
&&	O
reg_info	pointer
&&	O
best_regstart	pointer
&&	O
best_regend	pointer
&&	O
reg_dummy	pointer
&&	O
reg_info_dummy	pointer
)	O
)	O
{	O
FREE_VARIABLES	O
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
regstart	pointer
=	O
regend	pointer
=	O
old_regstart	pointer
=	O
old_regend	pointer
=	O
best_regstart	pointer
=	O
best_regend	pointer
=	O
reg_dummy	pointer
=	O
NULL	O
;	O
reg_info	pointer
=	O
reg_info_dummy	pointer
=	O
(	O
register_info_type	union
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
pos	int
<	O
0	int
||	O
pos	int
>	O
size1	int
+	O
size2	int
)	O
{	O
FREE_VARIABLES	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
mcnt	int
=	O
1	int
;	O
(	O
unsigned	O
)	O
mcnt	int
<	O
num_regs	int
;	O
mcnt	int
++	O
)	O
{	O
regstart	pointer
[	O
mcnt	int
]	O
=	O
regend	pointer
[	O
mcnt	int
]	O
=	O
old_regstart	pointer
[	O
mcnt	int
]	O
=	O
old_regend	pointer
[	O
mcnt	int
]	O
=	O
REG_UNSET_VALUE	O
;	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
mcnt	int
]	O
)	O
=	O
MATCH_NULL_UNSET_VALUE	int
;	O
IS_ACTIVE	O
(	O
reg_info	pointer
[	O
mcnt	int
]	O
)	O
=	O
0	int
;	O
MATCHED_SOMETHING	O
(	O
reg_info	pointer
[	O
mcnt	int
]	O
)	O
=	O
0	int
;	O
EVER_MATCHED_SOMETHING	O
(	O
reg_info	pointer
[	O
mcnt	int
]	O
)	O
=	O
0	int
;	O
}	O
if	O
(	O
size2	int
==	O
0	int
&&	O
string1	pointer
!=	O
NULL	O
)	O
{	O
string2	pointer
=	O
string1	pointer
;	O
size2	int
=	O
size1	int
;	O
string1	pointer
=	O
0	int
;	O
size1	int
=	O
0	int
;	O
}	O
end1	pointer
=	O
string1	pointer
+	O
size1	int
;	O
end2	pointer
=	O
string2	pointer
+	O
size2	int
;	O
if	O
(	O
stop	int
<=	O
size1	int
)	O
{	O
end_match_1	pointer
=	O
string1	pointer
+	O
stop	int
;	O
end_match_2	pointer
=	O
string2	pointer
;	O
}	O
else	O
{	O
end_match_1	pointer
=	O
end1	pointer
;	O
end_match_2	pointer
=	O
string2	pointer
+	O
stop	int
-	O
size1	int
;	O
}	O
if	O
(	O
size1	int
>	O
0	int
&&	O
pos	int
<=	O
size1	int
)	O
{	O
d	pointer
=	O
string1	pointer
+	O
pos	int
;	O
dend	pointer
=	O
end_match_1	pointer
;	O
}	O
else	O
{	O
d	pointer
=	O
string2	pointer
+	O
pos	int
-	O
size1	int
;	O
dend	pointer
=	O
end_match_2	pointer
;	O
}	O
DEBUG_PRINT1	O
(	O
"The compiled pattern is:\n"	pointer
)	O
;	O
DEBUG_PRINT_COMPILED_PATTERN	O
(	O
bufp	pointer
,	O
p	pointer
,	O
pend	pointer
)	O
;	O
DEBUG_PRINT1	O
(	O
"The string to match is: `"	pointer
)	O
;	O
DEBUG_PRINT_DOUBLE_STRING	O
(	O
d	pointer
,	O
string1	pointer
,	O
size1	int
,	O
string2	pointer
,	O
size2	int
)	O
;	O
DEBUG_PRINT1	O
(	O
"'\n"	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
DEBUG_PRINT2	O
(	O
"\n0x%x: "	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
pend	pointer
)	O
{	O
DEBUG_PRINT1	O
(	O
"end of pattern ... "	pointer
)	O
;	O
if	O
(	O
d	pointer
!=	O
end_match_2	pointer
)	O
{	O
boolean	char
same_str_p	char
=	O
(	O
FIRST_STRING_P	O
(	O
match_end	pointer
)	O
==	O
MATCHING_IN_FIRST_STRING	O
)	O
;	O
boolean	char
best_match_p	char
;	O
if	O
(	O
same_str_p	char
)	O
best_match_p	char
=	O
d	pointer
>	O
match_end	pointer
;	O
else	O
best_match_p	char
=	O
!	O
MATCHING_IN_FIRST_STRING	O
;	O
DEBUG_PRINT1	O
(	O
"backtracking.\n"	pointer
)	O
;	O
if	O
(	O
!	O
FAIL_STACK_EMPTY	O
(	O
)	O
)	O
{	O
if	O
(	O
!	O
best_regs_set	int
||	O
best_match_p	char
)	O
{	O
best_regs_set	int
=	O
true	int
;	O
match_end	pointer
=	O
d	pointer
;	O
DEBUG_PRINT1	O
(	O
"\nSAVING match as best so far.\n"	pointer
)	O
;	O
for	O
(	O
mcnt	int
=	O
1	int
;	O
(	O
unsigned	O
)	O
mcnt	int
<	O
num_regs	int
;	O
mcnt	int
++	O
)	O
{	O
best_regstart	pointer
[	O
mcnt	int
]	O
=	O
regstart	pointer
[	O
mcnt	int
]	O
;	O
best_regend	pointer
[	O
mcnt	int
]	O
=	O
regend	pointer
[	O
mcnt	int
]	O
;	O
}	O
}	O
goto	O
fail	O
;	O
}	O
else	O
if	O
(	O
best_regs_set	int
&&	O
!	O
best_match_p	char
)	O
{	O
restore_best_regs	O
:	O
DEBUG_PRINT1	O
(	O
"Restoring best registers.\n"	pointer
)	O
;	O
d	pointer
=	O
match_end	pointer
;	O
dend	pointer
=	O
(	O
(	O
d	pointer
>=	O
string1	pointer
&&	O
d	pointer
<=	O
end1	pointer
)	O
?	O
end_match_1	pointer
:	O
end_match_2	pointer
)	O
;	O
for	O
(	O
mcnt	int
=	O
1	int
;	O
(	O
unsigned	O
)	O
mcnt	int
<	O
num_regs	int
;	O
mcnt	int
++	O
)	O
{	O
regstart	pointer
[	O
mcnt	int
]	O
=	O
best_regstart	pointer
[	O
mcnt	int
]	O
;	O
regend	pointer
[	O
mcnt	int
]	O
=	O
best_regend	pointer
[	O
mcnt	int
]	O
;	O
}	O
}	O
}	O
succeed_label	O
:	O
DEBUG_PRINT1	O
(	O
"Accepting match.\n"	pointer
)	O
;	O
if	O
(	O
regs	pointer
&&	O
!	O
bufp	pointer
->	O
no_sub	int
)	O
{	O
if	O
(	O
bufp	pointer
->	O
regs_allocated	int
==	O
REGS_UNALLOCATED	int
)	O
{	O
regs	pointer
->	O
num_regs	int
=	O
MAX	O
(	O
RE_NREGS	int
,	O
num_regs	int
+	O
1	int
)	O
;	O
regs	pointer
->	O
start	pointer
=	O
TALLOC	O
(	O
regs	pointer
->	O
num_regs	int
,	O
regoff_t	int
)	O
;	O
regs	pointer
->	O
end	pointer
=	O
TALLOC	O
(	O
regs	pointer
->	O
num_regs	int
,	O
regoff_t	int
)	O
;	O
if	O
(	O
regs	pointer
->	O
start	pointer
==	O
NULL	O
||	O
regs	pointer
->	O
end	pointer
==	O
NULL	O
)	O
{	O
FREE_VARIABLES	O
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
bufp	pointer
->	O
regs_allocated	int
=	O
REGS_REALLOCATE	int
;	O
}	O
else	O
if	O
(	O
bufp	pointer
->	O
regs_allocated	int
==	O
REGS_REALLOCATE	int
)	O
{	O
if	O
(	O
regs	pointer
->	O
num_regs	int
<	O
num_regs	int
+	O
1	int
)	O
{	O
regs	pointer
->	O
num_regs	int
=	O
num_regs	int
+	O
1	int
;	O
RETALLOC	O
(	O
regs	pointer
->	O
start	pointer
,	O
regs	pointer
->	O
num_regs	int
,	O
regoff_t	int
)	O
;	O
RETALLOC	O
(	O
regs	pointer
->	O
end	pointer
,	O
regs	pointer
->	O
num_regs	int
,	O
regoff_t	int
)	O
;	O
if	O
(	O
regs	pointer
->	O
start	pointer
==	O
NULL	O
||	O
regs	pointer
->	O
end	pointer
==	O
NULL	O
)	O
{	O
FREE_VARIABLES	O
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
}	O
else	O
{	O
assert	O
(	O
bufp	pointer
->	O
regs_allocated	int
==	O
REGS_FIXED	int
)	O
;	O
}	O
if	O
(	O
regs	pointer
->	O
num_regs	int
>	O
0	int
)	O
{	O
regs	pointer
->	O
start	pointer
[	O
0	int
]	O
=	O
pos	int
;	O
regs	pointer
->	O
end	pointer
[	O
0	int
]	O
=	O
(	O
MATCHING_IN_FIRST_STRING	O
?	O
(	O
(	O
regoff_t	int
)	O
(	O
d	pointer
-	O
string1	pointer
)	O
)	O
:	O
(	O
(	O
regoff_t	int
)	O
(	O
d	pointer
-	O
string2	pointer
+	O
size1	int
)	O
)	O
)	O
;	O
}	O
for	O
(	O
mcnt	int
=	O
1	int
;	O
(	O
unsigned	O
)	O
mcnt	int
<	O
MIN	O
(	O
num_regs	int
,	O
regs	pointer
->	O
num_regs	int
)	O
;	O
mcnt	int
++	O
)	O
{	O
if	O
(	O
REG_UNSET	O
(	O
regstart	pointer
[	O
mcnt	int
]	O
)	O
||	O
REG_UNSET	O
(	O
regend	pointer
[	O
mcnt	int
]	O
)	O
)	O
regs	pointer
->	O
start	pointer
[	O
mcnt	int
]	O
=	O
regs	pointer
->	O
end	pointer
[	O
mcnt	int
]	O
=	O
-	O
1	int
;	O
else	O
{	O
regs	pointer
->	O
start	pointer
[	O
mcnt	int
]	O
=	O
(	O
regoff_t	int
)	O
POINTER_TO_OFFSET	O
(	O
regstart	pointer
[	O
mcnt	int
]	O
)	O
;	O
regs	pointer
->	O
end	pointer
[	O
mcnt	int
]	O
=	O
(	O
regoff_t	int
)	O
POINTER_TO_OFFSET	O
(	O
regend	pointer
[	O
mcnt	int
]	O
)	O
;	O
}	O
}	O
for	O
(	O
mcnt	int
=	O
num_regs	int
;	O
(	O
unsigned	O
)	O
mcnt	int
<	O
regs	pointer
->	O
num_regs	int
;	O
mcnt	int
++	O
)	O
regs	pointer
->	O
start	pointer
[	O
mcnt	int
]	O
=	O
regs	pointer
->	O
end	pointer
[	O
mcnt	int
]	O
=	O
-	O
1	int
;	O
}	O
DEBUG_PRINT4	O
(	O
"%u failure points pushed, %u popped (%u remain).\n"	pointer
,	O
nfailure_points_pushed	O
,	O
nfailure_points_popped	O
,	O
nfailure_points_pushed	O
-	O
nfailure_points_popped	O
)	O
;	O
DEBUG_PRINT2	O
(	O
"%u registers pushed.\n"	pointer
,	O
num_regs_pushed	O
)	O
;	O
mcnt	int
=	O
d	pointer
-	O
pos	int
-	O
(	O
MATCHING_IN_FIRST_STRING	O
?	O
string1	pointer
:	O
string2	pointer
-	O
size1	int
)	O
;	O
DEBUG_PRINT2	O
(	O
"Returning %d from re_match_2.\n"	pointer
,	O
mcnt	int
)	O
;	O
FREE_VARIABLES	O
(	O
)	O
;	O
return	O
mcnt	int
;	O
}	O
switch	O
(	O
SWITCH_ENUM_CAST	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p	pointer
++	O
)	O
)	O
{	O
case	O
no_op	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING no_op.\n"	pointer
)	O
;	O
break	O
;	O
case	O
succeed	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING succeed.\n"	pointer
)	O
;	O
goto	O
succeed_label	O
;	O
case	O
exactn	int
:	O
mcnt	int
=	O
*	O
p	pointer
++	O
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING exactn %d.\n"	pointer
,	O
mcnt	int
)	O
;	O
if	O
(	O
translate	pointer
)	O
{	O
do	O
{	O
PREFETCH	O
(	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
translate	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
d	pointer
++	O
]	O
!=	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
++	O
)	O
goto	O
fail	O
;	O
}	O
while	O
(	O
--	O
mcnt	int
)	O
;	O
}	O
else	O
{	O
do	O
{	O
PREFETCH	O
(	O
)	O
;	O
if	O
(	O
*	O
d	pointer
++	O
!=	O
(	O
char	O
)	O
*	O
p	pointer
++	O
)	O
goto	O
fail	O
;	O
}	O
while	O
(	O
--	O
mcnt	int
)	O
;	O
}	O
SET_REGS_MATCHED	O
(	O
)	O
;	O
break	O
;	O
case	O
anychar	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING anychar.\n"	pointer
)	O
;	O
PREFETCH	O
(	O
)	O
;	O
if	O
(	O
(	O
!	O
(	O
bufp	pointer
->	O
syntax	long
&	O
RE_DOT_NEWLINE	O
)	O
&&	O
TRANSLATE	O
(	O
*	O
d	pointer
)	O
==	O
'\n'	O
)	O
||	O
(	O
bufp	pointer
->	O
syntax	long
&	O
RE_DOT_NOT_NULL	O
&&	O
TRANSLATE	O
(	O
*	O
d	pointer
)	O
==	O
'\000'	O
)	O
)	O
goto	O
fail	O
;	O
SET_REGS_MATCHED	O
(	O
)	O
;	O
DEBUG_PRINT2	O
(	O
"  Matched `%d'.\n"	pointer
,	O
*	O
d	pointer
)	O
;	O
d	pointer
++	O
;	O
break	O
;	O
case	O
charset	int
:	O
case	O
charset_not	int
:	O
{	O
register	O
unsigned	O
char	O
c	int
;	O
boolean	char
not	char
=	O
(	O
re_opcode_t	enum
)	O
*	O
(	O
p	pointer
-	O
1	int
)	O
==	O
charset_not	int
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING charset%s.\n"	pointer
,	O
not	char
?	O
"_not"	pointer
:	O
""	pointer
)	O
;	O
PREFETCH	O
(	O
)	O
;	O
c	int
=	O
TRANSLATE	O
(	O
*	O
d	pointer
)	O
;	O
if	O
(	O
c	int
<	O
(	O
unsigned	O
)	O
(	O
*	O
p	pointer
*	O
BYTEWIDTH	int
)	O
&&	O
p	pointer
[	O
1	int
+	O
c	int
/	O
BYTEWIDTH	int
]	O
&	O
(	O
1	int
<<	O
(	O
c	int
%	O
BYTEWIDTH	int
)	O
)	O
)	O
not	char
=	O
!	O
not	char
;	O
p	pointer
+=	O
1	int
+	O
*	O
p	pointer
;	O
if	O
(	O
!	O
not	char
)	O
goto	O
fail	O
;	O
SET_REGS_MATCHED	O
(	O
)	O
;	O
d	pointer
++	O
;	O
break	O
;	O
}	O
case	O
start_memory	int
:	O
DEBUG_PRINT3	O
(	O
"EXECUTING start_memory %d (%d):\n"	pointer
,	O
*	O
p	pointer
,	O
p	pointer
[	O
1	int
]	O
)	O
;	O
p1	pointer
=	O
p	pointer
;	O
if	O
(	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
==	O
MATCH_NULL_UNSET_VALUE	int
)	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
=	O
group_match_null_string_p	function
(	O
&	O
p1	pointer
,	O
pend	pointer
,	O
reg_info	pointer
)	O
;	O
old_regstart	pointer
[	O
*	O
p	pointer
]	O
=	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
?	O
REG_UNSET	O
(	O
regstart	pointer
[	O
*	O
p	pointer
]	O
)	O
?	O
d	pointer
:	O
regstart	pointer
[	O
*	O
p	pointer
]	O
:	O
regstart	pointer
[	O
*	O
p	pointer
]	O
;	O
DEBUG_PRINT2	O
(	O
"  old_regstart: %d\n"	pointer
,	O
POINTER_TO_OFFSET	O
(	O
old_regstart	pointer
[	O
*	O
p	pointer
]	O
)	O
)	O
;	O
regstart	pointer
[	O
*	O
p	pointer
]	O
=	O
d	pointer
;	O
DEBUG_PRINT2	O
(	O
"  regstart: %d\n"	pointer
,	O
POINTER_TO_OFFSET	O
(	O
regstart	pointer
[	O
*	O
p	pointer
]	O
)	O
)	O
;	O
IS_ACTIVE	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
=	O
1	int
;	O
MATCHED_SOMETHING	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
=	O
0	int
;	O
set_regs_matched_done	int
=	O
0	int
;	O
highest_active_reg	long
=	O
*	O
p	pointer
;	O
if	O
(	O
lowest_active_reg	long
==	O
NO_LOWEST_ACTIVE_REG	O
)	O
lowest_active_reg	long
=	O
*	O
p	pointer
;	O
p	pointer
+=	O
2	int
;	O
just_past_start_mem	pointer
=	O
p	pointer
;	O
break	O
;	O
case	O
stop_memory	int
:	O
DEBUG_PRINT3	O
(	O
"EXECUTING stop_memory %d (%d):\n"	pointer
,	O
*	O
p	pointer
,	O
p	pointer
[	O
1	int
]	O
)	O
;	O
old_regend	pointer
[	O
*	O
p	pointer
]	O
=	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
?	O
REG_UNSET	O
(	O
regend	pointer
[	O
*	O
p	pointer
]	O
)	O
?	O
d	pointer
:	O
regend	pointer
[	O
*	O
p	pointer
]	O
:	O
regend	pointer
[	O
*	O
p	pointer
]	O
;	O
DEBUG_PRINT2	O
(	O
"      old_regend: %d\n"	pointer
,	O
POINTER_TO_OFFSET	O
(	O
old_regend	pointer
[	O
*	O
p	pointer
]	O
)	O
)	O
;	O
regend	pointer
[	O
*	O
p	pointer
]	O
=	O
d	pointer
;	O
DEBUG_PRINT2	O
(	O
"      regend: %d\n"	pointer
,	O
POINTER_TO_OFFSET	O
(	O
regend	pointer
[	O
*	O
p	pointer
]	O
)	O
)	O
;	O
IS_ACTIVE	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
=	O
0	int
;	O
set_regs_matched_done	int
=	O
0	int
;	O
if	O
(	O
lowest_active_reg	long
==	O
highest_active_reg	long
)	O
{	O
lowest_active_reg	long
=	O
NO_LOWEST_ACTIVE_REG	O
;	O
highest_active_reg	long
=	O
NO_HIGHEST_ACTIVE_REG	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
r	long
=	O
*	O
p	pointer
-	O
1	int
;	O
while	O
(	O
r	long
>	O
0	int
&&	O
!	O
IS_ACTIVE	O
(	O
reg_info	pointer
[	O
r	long
]	O
)	O
)	O
r	long
--	O
;	O
if	O
(	O
r	long
==	O
0	int
)	O
{	O
lowest_active_reg	long
=	O
NO_LOWEST_ACTIVE_REG	O
;	O
highest_active_reg	long
=	O
NO_HIGHEST_ACTIVE_REG	O
;	O
}	O
else	O
highest_active_reg	long
=	O
r	long
;	O
}	O
if	O
(	O
(	O
!	O
MATCHED_SOMETHING	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
||	O
just_past_start_mem	pointer
==	O
p	pointer
-	O
1	int
)	O
&&	O
(	O
p	pointer
+	O
2	int
)	O
<	O
pend	pointer
)	O
{	O
boolean	char
is_a_jump_n	char
=	O
false	int
;	O
p1	pointer
=	O
p	pointer
+	O
2	int
;	O
mcnt	int
=	O
0	int
;	O
switch	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
++	O
)	O
{	O
case	O
jump_n	int
:	O
is_a_jump_n	char
=	O
true	int
;	O
case	O
pop_failure_jump	int
:	O
case	O
maybe_pop_jump	int
:	O
case	O
jump	int
:	O
case	O
dummy_failure_jump	int
:	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
if	O
(	O
is_a_jump_n	char
)	O
p1	pointer
+=	O
2	int
;	O
break	O
;	O
default	O
:	O
;	O
}	O
p1	pointer
+=	O
mcnt	int
;	O
if	O
(	O
mcnt	int
<	O
0	int
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
==	O
on_failure_jump	int
&&	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
start_memory	int
&&	O
p1	pointer
[	O
4	int
]	O
==	O
*	O
p	pointer
)	O
{	O
if	O
(	O
EVER_MATCHED_SOMETHING	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
)	O
{	O
unsigned	O
r	long
;	O
EVER_MATCHED_SOMETHING	O
(	O
reg_info	pointer
[	O
*	O
p	pointer
]	O
)	O
=	O
0	int
;	O
for	O
(	O
r	long
=	O
*	O
p	pointer
;	O
r	long
<	O
(	O
unsigned	O
)	O
*	O
p	pointer
+	O
(	O
unsigned	O
)	O
*	O
(	O
p	pointer
+	O
1	int
)	O
;	O
r	long
++	O
)	O
{	O
regstart	pointer
[	O
r	long
]	O
=	O
old_regstart	pointer
[	O
r	long
]	O
;	O
if	O
(	O
old_regend	pointer
[	O
r	long
]	O
>=	O
regstart	pointer
[	O
r	long
]	O
)	O
regend	pointer
[	O
r	long
]	O
=	O
old_regend	pointer
[	O
r	long
]	O
;	O
}	O
}	O
p1	pointer
++	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
PUSH_FAILURE_POINT	O
(	O
p1	pointer
+	O
mcnt	int
,	O
d	pointer
,	O
-	O
2	int
)	O
;	O
goto	O
fail	O
;	O
}	O
}	O
p	pointer
+=	O
2	int
;	O
break	O
;	O
case	O
duplicate	int
:	O
{	O
register	O
const	O
char	O
*	O
d2	pointer
,	O
*	O
dend2	pointer
;	O
int	O
regno	int
=	O
*	O
p	pointer
++	O
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING duplicate %d.\n"	pointer
,	O
regno	int
)	O
;	O
if	O
(	O
REG_UNSET	O
(	O
regstart	pointer
[	O
regno	int
]	O
)	O
||	O
REG_UNSET	O
(	O
regend	pointer
[	O
regno	int
]	O
)	O
)	O
goto	O
fail	O
;	O
d2	pointer
=	O
regstart	pointer
[	O
regno	int
]	O
;	O
dend2	pointer
=	O
(	O
(	O
FIRST_STRING_P	O
(	O
regstart	pointer
[	O
regno	int
]	O
)	O
==	O
FIRST_STRING_P	O
(	O
regend	pointer
[	O
regno	int
]	O
)	O
)	O
?	O
regend	pointer
[	O
regno	int
]	O
:	O
end_match_1	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
d2	pointer
==	O
dend2	pointer
)	O
{	O
if	O
(	O
dend2	pointer
==	O
end_match_2	pointer
)	O
break	O
;	O
if	O
(	O
dend2	pointer
==	O
regend	pointer
[	O
regno	int
]	O
)	O
break	O
;	O
d2	pointer
=	O
string2	pointer
;	O
dend2	pointer
=	O
regend	pointer
[	O
regno	int
]	O
;	O
}	O
if	O
(	O
d2	pointer
==	O
dend2	pointer
)	O
break	O
;	O
PREFETCH	O
(	O
)	O
;	O
mcnt	int
=	O
dend	pointer
-	O
d	pointer
;	O
if	O
(	O
mcnt	int
>	O
dend2	pointer
-	O
d2	pointer
)	O
mcnt	int
=	O
dend2	pointer
-	O
d2	pointer
;	O
if	O
(	O
translate	pointer
?	O
bcmp_translate	function
(	O
d	pointer
,	O
d2	pointer
,	O
mcnt	int
,	O
translate	pointer
)	O
:	O
bcmp	function
(	O
d	pointer
,	O
d2	pointer
,	O
mcnt	int
)	O
)	O
goto	O
fail	O
;	O
d	pointer
+=	O
mcnt	int
,	O
d2	pointer
+=	O
mcnt	int
;	O
SET_REGS_MATCHED	O
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
begline	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING begline.\n"	pointer
)	O
;	O
if	O
(	O
AT_STRINGS_BEG	O
(	O
d	pointer
)	O
)	O
{	O
if	O
(	O
!	O
bufp	pointer
->	O
not_bol	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
d	pointer
[	O
-	O
1	int
]	O
==	O
'\n'	O
&&	O
bufp	pointer
->	O
newline_anchor	int
)	O
{	O
break	O
;	O
}	O
goto	O
fail	O
;	O
case	O
endline	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING endline.\n"	pointer
)	O
;	O
if	O
(	O
AT_STRINGS_END	O
(	O
d	pointer
)	O
)	O
{	O
if	O
(	O
!	O
bufp	pointer
->	O
not_eol	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
d	pointer
==	O
end1	pointer
?	O
*	O
string2	pointer
:	O
*	O
d	pointer
)	O
==	O
'\n'	O
&&	O
bufp	pointer
->	O
newline_anchor	int
)	O
{	O
break	O
;	O
}	O
goto	O
fail	O
;	O
case	O
begbuf	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING begbuf.\n"	pointer
)	O
;	O
if	O
(	O
AT_STRINGS_BEG	O
(	O
d	pointer
)	O
)	O
break	O
;	O
goto	O
fail	O
;	O
case	O
endbuf	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING endbuf.\n"	pointer
)	O
;	O
if	O
(	O
AT_STRINGS_END	O
(	O
d	pointer
)	O
)	O
break	O
;	O
goto	O
fail	O
;	O
case	O
on_failure_keep_string_jump	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING on_failure_keep_string_jump"	pointer
)	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p	pointer
)	O
;	O
DEBUG_PRINT3	O
(	O
" %d (to 0x%x):\n"	pointer
,	O
mcnt	int
,	O
p	pointer
+	O
mcnt	int
)	O
;	O
PUSH_FAILURE_POINT	O
(	O
p	pointer
+	O
mcnt	int
,	O
NULL	O
,	O
-	O
2	int
)	O
;	O
break	O
;	O
case	O
on_failure_jump	int
:	O
on_failure	O
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING on_failure_jump"	pointer
)	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p	pointer
)	O
;	O
DEBUG_PRINT3	O
(	O
" %d (to 0x%x)"	pointer
,	O
mcnt	int
,	O
p	pointer
+	O
mcnt	int
)	O
;	O
p1	pointer
=	O
p	pointer
;	O
while	O
(	O
p1	pointer
<	O
pend	pointer
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
==	O
no_op	int
)	O
p1	pointer
++	O
;	O
if	O
(	O
p1	pointer
<	O
pend	pointer
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
==	O
start_memory	int
)	O
{	O
highest_active_reg	long
=	O
*	O
(	O
p1	pointer
+	O
1	int
)	O
+	O
*	O
(	O
p1	pointer
+	O
2	int
)	O
;	O
if	O
(	O
lowest_active_reg	long
==	O
NO_LOWEST_ACTIVE_REG	O
)	O
lowest_active_reg	long
=	O
*	O
(	O
p1	pointer
+	O
1	int
)	O
;	O
}	O
DEBUG_PRINT1	O
(	O
":\n"	pointer
)	O
;	O
PUSH_FAILURE_POINT	O
(	O
p	pointer
+	O
mcnt	int
,	O
d	pointer
,	O
-	O
2	int
)	O
;	O
break	O
;	O
case	O
maybe_pop_jump	int
:	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p	pointer
)	O
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING maybe_pop_jump %d.\n"	pointer
,	O
mcnt	int
)	O
;	O
{	O
register	O
unsigned	O
char	O
*	O
p2	pointer
=	O
p	pointer
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
p2	pointer
+	O
2	int
<	O
pend	pointer
&&	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p2	pointer
==	O
stop_memory	int
||	O
(	O
re_opcode_t	enum
)	O
*	O
p2	pointer
==	O
start_memory	int
)	O
)	O
p2	pointer
+=	O
3	int
;	O
else	O
if	O
(	O
p2	pointer
+	O
6	int
<	O
pend	pointer
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p2	pointer
==	O
dummy_failure_jump	int
)	O
p2	pointer
+=	O
6	int
;	O
else	O
break	O
;	O
}	O
p1	pointer
=	O
p	pointer
+	O
mcnt	int
;	O
if	O
(	O
p2	pointer
==	O
pend	pointer
)	O
{	O
p	pointer
[	O
-	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
pop_failure_jump	int
;	O
DEBUG_PRINT1	O
(	O
"  End of pattern: change to `pop_failure_jump'.\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p2	pointer
==	O
exactn	int
||	O
(	O
bufp	pointer
->	O
newline_anchor	int
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p2	pointer
==	O
endline	int
)	O
)	O
{	O
register	O
unsigned	O
char	O
c	int
=	O
*	O
p2	pointer
==	O
(	O
unsigned	O
char	O
)	O
endline	int
?	O
'\n'	O
:	O
p2	pointer
[	O
2	int
]	O
;	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
exactn	int
&&	O
p1	pointer
[	O
5	int
]	O
!=	O
c	int
)	O
{	O
p	pointer
[	O
-	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
pop_failure_jump	int
;	O
DEBUG_PRINT3	O
(	O
"  %c != %c => pop_failure_jump.\n"	pointer
,	O
c	int
,	O
p1	pointer
[	O
5	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
charset	int
||	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
charset_not	int
)	O
{	O
int	O
not	char
=	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
charset_not	int
;	O
if	O
(	O
c	int
<	O
(	O
unsigned	O
char	O
)	O
(	O
p1	pointer
[	O
4	int
]	O
*	O
BYTEWIDTH	int
)	O
&&	O
p1	pointer
[	O
5	int
+	O
c	int
/	O
BYTEWIDTH	int
]	O
&	O
(	O
1	int
<<	O
(	O
c	int
%	O
BYTEWIDTH	int
)	O
)	O
)	O
not	char
=	O
!	O
not	char
;	O
if	O
(	O
!	O
not	char
)	O
{	O
p	pointer
[	O
-	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
pop_failure_jump	int
;	O
DEBUG_PRINT1	O
(	O
"  No match => pop_failure_jump.\n"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p2	pointer
==	O
charset	int
)	O
{	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
exactn	int
&&	O
!	O
(	O
(	O
int	O
)	O
p2	pointer
[	O
1	int
]	O
*	O
BYTEWIDTH	int
>	O
(	O
int	O
)	O
p1	pointer
[	O
4	int
]	O
&&	O
(	O
p2	pointer
[	O
2	int
+	O
p1	pointer
[	O
4	int
]	O
/	O
BYTEWIDTH	int
]	O
&	O
(	O
1	int
<<	O
(	O
p1	pointer
[	O
4	int
]	O
%	O
BYTEWIDTH	int
)	O
)	O
)	O
)	O
)	O
{	O
p	pointer
[	O
-	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
pop_failure_jump	int
;	O
DEBUG_PRINT3	O
(	O
"  %c != %c => pop_failure_jump.\n"	pointer
,	O
c	int
,	O
p1	pointer
[	O
5	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
charset_not	int
)	O
{	O
int	O
idx	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
(	O
int	O
)	O
p2	pointer
[	O
1	int
]	O
;	O
idx	int
++	O
)	O
if	O
(	O
!	O
(	O
p2	pointer
[	O
2	int
+	O
idx	int
]	O
==	O
0	int
||	O
(	O
idx	int
<	O
(	O
int	O
)	O
p1	pointer
[	O
4	int
]	O
&&	O
(	O
(	O
p2	pointer
[	O
2	int
+	O
idx	int
]	O
&	O
~	O
p1	pointer
[	O
5	int
+	O
idx	int
]	O
)	O
==	O
0	int
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
idx	int
==	O
p2	pointer
[	O
1	int
]	O
)	O
{	O
p	pointer
[	O
-	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
pop_failure_jump	int
;	O
DEBUG_PRINT1	O
(	O
"  No match => pop_failure_jump.\n"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
3	int
]	O
==	O
charset	int
)	O
{	O
int	O
idx	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
(	O
int	O
)	O
p2	pointer
[	O
1	int
]	O
&&	O
idx	int
<	O
(	O
int	O
)	O
p1	pointer
[	O
4	int
]	O
;	O
idx	int
++	O
)	O
if	O
(	O
(	O
p2	pointer
[	O
2	int
+	O
idx	int
]	O
&	O
p1	pointer
[	O
5	int
+	O
idx	int
]	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
idx	int
==	O
p2	pointer
[	O
1	int
]	O
||	O
idx	int
==	O
p1	pointer
[	O
4	int
]	O
)	O
{	O
p	pointer
[	O
-	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
pop_failure_jump	int
;	O
DEBUG_PRINT1	O
(	O
"  No match => pop_failure_jump.\n"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
p	pointer
-=	O
2	int
;	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p	pointer
[	O
-	O
1	int
]	O
!=	O
pop_failure_jump	int
)	O
{	O
p	pointer
[	O
-	O
1	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
jump	int
;	O
DEBUG_PRINT1	O
(	O
"  Match => jump.\n"	pointer
)	O
;	O
goto	O
unconditional_jump	O
;	O
}	O
case	O
pop_failure_jump	int
:	O
{	O
active_reg_t	long
dummy_low_reg	long
,	O
dummy_high_reg	long
;	O
unsigned	O
char	O
*	O
pdummy	pointer
;	O
const	O
char	O
*	O
sdummy	pointer
;	O
DEBUG_PRINT1	O
(	O
"EXECUTING pop_failure_jump.\n"	pointer
)	O
;	O
POP_FAILURE_POINT	O
(	O
sdummy	pointer
,	O
pdummy	pointer
,	O
dummy_low_reg	long
,	O
dummy_high_reg	long
,	O
reg_dummy	pointer
,	O
reg_dummy	pointer
,	O
reg_info_dummy	pointer
)	O
;	O
}	O
unconditional_jump	O
:	O
DEBUG_PRINT2	O
(	O
"\n0x%x: "	pointer
,	O
p	pointer
)	O
;	O
case	O
jump	int
:	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p	pointer
)	O
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING jump %d "	pointer
,	O
mcnt	int
)	O
;	O
p	pointer
+=	O
mcnt	int
;	O
DEBUG_PRINT2	O
(	O
"(to 0x%x).\n"	pointer
,	O
p	pointer
)	O
;	O
break	O
;	O
case	O
jump_past_alt	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING jump_past_alt.\n"	pointer
)	O
;	O
goto	O
unconditional_jump	O
;	O
case	O
dummy_failure_jump	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING dummy_failure_jump.\n"	pointer
)	O
;	O
PUSH_FAILURE_POINT	O
(	O
0	int
,	O
0	int
,	O
-	O
2	int
)	O
;	O
goto	O
unconditional_jump	O
;	O
case	O
push_dummy_failure	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING push_dummy_failure.\n"	pointer
)	O
;	O
PUSH_FAILURE_POINT	O
(	O
0	int
,	O
0	int
,	O
-	O
2	int
)	O
;	O
break	O
;	O
case	O
succeed_n	int
:	O
EXTRACT_NUMBER	O
(	O
mcnt	int
,	O
p	pointer
+	O
2	int
)	O
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING succeed_n %d.\n"	pointer
,	O
mcnt	int
)	O
;	O
assert	O
(	O
mcnt	int
>=	O
0	int
)	O
;	O
if	O
(	O
mcnt	int
>	O
0	int
)	O
{	O
mcnt	int
--	O
;	O
p	pointer
+=	O
2	int
;	O
STORE_NUMBER_AND_INCR	O
(	O
p	pointer
,	O
mcnt	int
)	O
;	O
DEBUG_PRINT3	O
(	O
"  Setting 0x%x to %d.\n"	pointer
,	O
p	pointer
-	O
2	int
,	O
mcnt	int
)	O
;	O
}	O
else	O
if	O
(	O
mcnt	int
==	O
0	int
)	O
{	O
DEBUG_PRINT2	O
(	O
"  Setting two bytes from 0x%x to no_op.\n"	pointer
,	O
p	pointer
+	O
2	int
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
no_op	int
;	O
p	pointer
[	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
no_op	int
;	O
goto	O
on_failure	O
;	O
}	O
break	O
;	O
case	O
jump_n	int
:	O
EXTRACT_NUMBER	O
(	O
mcnt	int
,	O
p	pointer
+	O
2	int
)	O
;	O
DEBUG_PRINT2	O
(	O
"EXECUTING jump_n %d.\n"	pointer
,	O
mcnt	int
)	O
;	O
if	O
(	O
mcnt	int
)	O
{	O
mcnt	int
--	O
;	O
STORE_NUMBER	O
(	O
p	pointer
+	O
2	int
,	O
mcnt	int
)	O
;	O
DEBUG_PRINT3	O
(	O
"  Setting 0x%x to %d.\n"	pointer
,	O
p	pointer
+	O
2	int
,	O
mcnt	int
)	O
;	O
goto	O
unconditional_jump	O
;	O
}	O
else	O
p	pointer
+=	O
4	int
;	O
break	O
;	O
case	O
set_number_at	int
:	O
{	O
DEBUG_PRINT1	O
(	O
"EXECUTING set_number_at.\n"	pointer
)	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p	pointer
)	O
;	O
p1	pointer
=	O
p	pointer
+	O
mcnt	int
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p	pointer
)	O
;	O
DEBUG_PRINT3	O
(	O
"  Setting 0x%x to %d.\n"	pointer
,	O
p1	pointer
,	O
mcnt	int
)	O
;	O
STORE_NUMBER	O
(	O
p1	pointer
,	O
mcnt	int
)	O
;	O
break	O
;	O
}	O
case	O
wordbound	int
:	O
{	O
boolean	char
prevchar	char
,	O
thischar	char
;	O
DEBUG_PRINT1	O
(	O
"EXECUTING wordbound.\n"	pointer
)	O
;	O
if	O
(	O
AT_STRINGS_BEG	O
(	O
d	pointer
)	O
||	O
AT_STRINGS_END	O
(	O
d	pointer
)	O
)	O
break	O
;	O
prevchar	char
=	O
WORDCHAR_P	O
(	O
d	pointer
-	O
1	int
)	O
;	O
thischar	char
=	O
WORDCHAR_P	O
(	O
d	pointer
)	O
;	O
if	O
(	O
prevchar	char
!=	O
thischar	char
)	O
break	O
;	O
goto	O
fail	O
;	O
}	O
case	O
notwordbound	int
:	O
{	O
boolean	char
prevchar	char
,	O
thischar	char
;	O
DEBUG_PRINT1	O
(	O
"EXECUTING notwordbound.\n"	pointer
)	O
;	O
if	O
(	O
AT_STRINGS_BEG	O
(	O
d	pointer
)	O
||	O
AT_STRINGS_END	O
(	O
d	pointer
)	O
)	O
goto	O
fail	O
;	O
prevchar	char
=	O
WORDCHAR_P	O
(	O
d	pointer
-	O
1	int
)	O
;	O
thischar	char
=	O
WORDCHAR_P	O
(	O
d	pointer
)	O
;	O
if	O
(	O
prevchar	char
!=	O
thischar	char
)	O
goto	O
fail	O
;	O
break	O
;	O
}	O
case	O
wordbeg	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING wordbeg.\n"	pointer
)	O
;	O
if	O
(	O
WORDCHAR_P	O
(	O
d	pointer
)	O
&&	O
(	O
AT_STRINGS_BEG	O
(	O
d	pointer
)	O
||	O
!	O
WORDCHAR_P	O
(	O
d	pointer
-	O
1	int
)	O
)	O
)	O
break	O
;	O
goto	O
fail	O
;	O
case	O
wordend	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING wordend.\n"	pointer
)	O
;	O
if	O
(	O
!	O
AT_STRINGS_BEG	O
(	O
d	pointer
)	O
&&	O
WORDCHAR_P	O
(	O
d	pointer
-	O
1	int
)	O
&&	O
(	O
!	O
WORDCHAR_P	O
(	O
d	pointer
)	O
||	O
AT_STRINGS_END	O
(	O
d	pointer
)	O
)	O
)	O
break	O
;	O
goto	O
fail	O
;	O
case	O
wordchar	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING non-Emacs wordchar.\n"	pointer
)	O
;	O
PREFETCH	O
(	O
)	O
;	O
if	O
(	O
!	O
WORDCHAR_P	O
(	O
d	pointer
)	O
)	O
goto	O
fail	O
;	O
SET_REGS_MATCHED	O
(	O
)	O
;	O
d	pointer
++	O
;	O
break	O
;	O
case	O
notwordchar	int
:	O
DEBUG_PRINT1	O
(	O
"EXECUTING non-Emacs notwordchar.\n"	pointer
)	O
;	O
PREFETCH	O
(	O
)	O
;	O
if	O
(	O
WORDCHAR_P	O
(	O
d	pointer
)	O
)	O
goto	O
fail	O
;	O
SET_REGS_MATCHED	O
(	O
)	O
;	O
d	pointer
++	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
continue	O
;	O
fail	O
:	O
if	O
(	O
!	O
FAIL_STACK_EMPTY	O
(	O
)	O
)	O
{	O
DEBUG_PRINT1	O
(	O
"\nFAIL:\n"	pointer
)	O
;	O
POP_FAILURE_POINT	O
(	O
d	pointer
,	O
p	pointer
,	O
lowest_active_reg	long
,	O
highest_active_reg	long
,	O
regstart	pointer
,	O
regend	pointer
,	O
reg_info	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
goto	O
fail	O
;	O
assert	O
(	O
p	pointer
<=	O
pend	pointer
)	O
;	O
if	O
(	O
p	pointer
<	O
pend	pointer
)	O
{	O
boolean	char
is_a_jump_n	char
=	O
false	int
;	O
switch	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p	pointer
)	O
{	O
case	O
jump_n	int
:	O
is_a_jump_n	char
=	O
true	int
;	O
case	O
maybe_pop_jump	int
:	O
case	O
pop_failure_jump	int
:	O
case	O
jump	int
:	O
p1	pointer
=	O
p	pointer
+	O
1	int
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
p1	pointer
+=	O
mcnt	int
;	O
if	O
(	O
(	O
is_a_jump_n	char
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
==	O
succeed_n	int
)	O
||	O
(	O
!	O
is_a_jump_n	char
&&	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
==	O
on_failure_jump	int
)	O
)	O
goto	O
fail	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
}	O
if	O
(	O
d	pointer
>=	O
string1	pointer
&&	O
d	pointer
<=	O
end1	pointer
)	O
dend	pointer
=	O
end_match_1	pointer
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
best_regs_set	int
)	O
goto	O
restore_best_regs	O
;	O
FREE_VARIABLES	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
boolean	char
group_match_null_string_p	function
(	O
p	pointer
,	O
end	pointer
,	O
reg_info	pointer
)	O
unsigned	O
char	O
*	O
*	O
p	pointer
,	O
*	O
end	pointer
;	O
register_info_type	union
*	O
reg_info	pointer
;	O
{	O
int	O
mcnt	int
;	O
unsigned	O
char	O
*	O
p1	pointer
=	O
*	O
p	pointer
+	O
2	int
;	O
while	O
(	O
p1	pointer
<	O
end	pointer
)	O
{	O
switch	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
)	O
{	O
case	O
on_failure_jump	int
:	O
p1	pointer
++	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
if	O
(	O
mcnt	int
>=	O
0	int
)	O
{	O
while	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
mcnt	int
-	O
3	int
]	O
==	O
jump_past_alt	int
)	O
{	O
if	O
(	O
!	O
alt_match_null_string_p	function
(	O
p1	pointer
,	O
p1	pointer
+	O
mcnt	int
-	O
3	int
,	O
reg_info	pointer
)	O
)	O
return	O
false	int
;	O
p1	pointer
+=	O
mcnt	int
;	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
!=	O
on_failure_jump	int
)	O
break	O
;	O
p1	pointer
++	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
if	O
(	O
(	O
re_opcode_t	enum
)	O
p1	pointer
[	O
mcnt	int
-	O
3	int
]	O
!=	O
jump_past_alt	int
)	O
{	O
p1	pointer
-=	O
3	int
;	O
break	O
;	O
}	O
}	O
EXTRACT_NUMBER	O
(	O
mcnt	int
,	O
p1	pointer
-	O
2	int
)	O
;	O
if	O
(	O
!	O
alt_match_null_string_p	function
(	O
p1	pointer
,	O
p1	pointer
+	O
mcnt	int
,	O
reg_info	pointer
)	O
)	O
return	O
false	int
;	O
p1	pointer
+=	O
mcnt	int
;	O
}	O
break	O
;	O
case	O
stop_memory	int
:	O
assert	O
(	O
p1	pointer
[	O
1	int
]	O
==	O
*	O
*	O
p	pointer
)	O
;	O
*	O
p	pointer
=	O
p1	pointer
+	O
2	int
;	O
return	O
true	int
;	O
default	O
:	O
if	O
(	O
!	O
common_op_match_null_string_p	function
(	O
&	O
p1	pointer
,	O
end	pointer
,	O
reg_info	pointer
)	O
)	O
return	O
false	int
;	O
}	O
}	O
return	O
false	int
;	O
}	O
static	O
boolean	char
alt_match_null_string_p	function
(	O
p	pointer
,	O
end	pointer
,	O
reg_info	pointer
)	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
end	pointer
;	O
register_info_type	union
*	O
reg_info	pointer
;	O
{	O
int	O
mcnt	int
;	O
unsigned	O
char	O
*	O
p1	pointer
=	O
p	pointer
;	O
while	O
(	O
p1	pointer
<	O
end	pointer
)	O
{	O
switch	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
)	O
{	O
case	O
on_failure_jump	int
:	O
p1	pointer
++	O
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
p1	pointer
+=	O
mcnt	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
common_op_match_null_string_p	function
(	O
&	O
p1	pointer
,	O
end	pointer
,	O
reg_info	pointer
)	O
)	O
return	O
false	int
;	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
boolean	char
common_op_match_null_string_p	function
(	O
p	pointer
,	O
end	pointer
,	O
reg_info	pointer
)	O
unsigned	O
char	O
*	O
*	O
p	pointer
,	O
*	O
end	pointer
;	O
register_info_type	union
*	O
reg_info	pointer
;	O
{	O
int	O
mcnt	int
;	O
boolean	char
ret	long
;	O
int	O
reg_no	int
;	O
unsigned	O
char	O
*	O
p1	pointer
=	O
*	O
p	pointer
;	O
switch	O
(	O
(	O
re_opcode_t	enum
)	O
*	O
p1	pointer
++	O
)	O
{	O
case	O
no_op	int
:	O
case	O
begline	int
:	O
case	O
endline	int
:	O
case	O
begbuf	int
:	O
case	O
endbuf	int
:	O
case	O
wordbeg	int
:	O
case	O
wordend	int
:	O
case	O
wordbound	int
:	O
case	O
notwordbound	int
:	O
break	O
;	O
case	O
start_memory	int
:	O
reg_no	int
=	O
*	O
p1	pointer
;	O
assert	O
(	O
reg_no	int
>	O
0	int
&&	O
reg_no	int
<=	O
MAX_REGNUM	int
)	O
;	O
ret	long
=	O
group_match_null_string_p	function
(	O
&	O
p1	pointer
,	O
end	pointer
,	O
reg_info	pointer
)	O
;	O
if	O
(	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
reg_no	int
]	O
)	O
==	O
MATCH_NULL_UNSET_VALUE	int
)	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
reg_no	int
]	O
)	O
=	O
ret	long
;	O
if	O
(	O
!	O
ret	long
)	O
return	O
false	int
;	O
break	O
;	O
case	O
jump	int
:	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
if	O
(	O
mcnt	int
>=	O
0	int
)	O
p1	pointer
+=	O
mcnt	int
;	O
else	O
return	O
false	int
;	O
break	O
;	O
case	O
succeed_n	int
:	O
p1	pointer
+=	O
2	int
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
if	O
(	O
mcnt	int
==	O
0	int
)	O
{	O
p1	pointer
-=	O
4	int
;	O
EXTRACT_NUMBER_AND_INCR	O
(	O
mcnt	int
,	O
p1	pointer
)	O
;	O
p1	pointer
+=	O
mcnt	int
;	O
}	O
else	O
return	O
false	int
;	O
break	O
;	O
case	O
duplicate	int
:	O
if	O
(	O
!	O
REG_MATCH_NULL_STRING_P	O
(	O
reg_info	pointer
[	O
*	O
p1	pointer
]	O
)	O
)	O
return	O
false	int
;	O
break	O
;	O
case	O
set_number_at	int
:	O
p1	pointer
+=	O
4	int
;	O
default	O
:	O
return	O
false	int
;	O
}	O
*	O
p	pointer
=	O
p1	pointer
;	O
return	O
true	int
;	O
}	O
static	O
int	O
bcmp_translate	function
(	O
s1	pointer
,	O
s2	pointer
,	O
len	int
,	O
translate	pointer
)	O
const	O
char	O
*	O
s1	pointer
,	O
*	O
s2	pointer
;	O
register	O
int	O
len	int
;	O
RE_TRANSLATE_TYPE	O
translate	pointer
;	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
while	O
(	O
len	int
)	O
{	O
if	O
(	O
translate	pointer
[	O
*	O
p1	pointer
++	O
]	O
!=	O
translate	pointer
[	O
*	O
p2	pointer
++	O
]	O
)	O
return	O
1	int
;	O
len	int
--	O
;	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
re_compile_pattern	function
(	O
pattern	pointer
,	O
length	long
,	O
bufp	pointer
)	O
const	O
char	O
*	O
pattern	pointer
;	O
size_t	long
length	long
;	O
struct	O
re_pattern_buffer	struct
*	O
bufp	pointer
;	O
{	O
reg_errcode_t	enum
ret	long
;	O
bufp	pointer
->	O
regs_allocated	int
=	O
REGS_UNALLOCATED	int
;	O
bufp	pointer
->	O
no_sub	int
=	O
0	int
;	O
bufp	pointer
->	O
newline_anchor	int
=	O
1	int
;	O
ret	long
=	O
regex_compile	function
(	O
pattern	pointer
,	O
length	long
,	O
re_syntax_options	long
,	O
bufp	pointer
)	O
;	O
if	O
(	O
!	O
ret	long
)	O
return	O
NULL	O
;	O
return	O
gettext	O
(	O
re_error_msgid	array
[	O
(	O
int	O
)	O
ret	long
]	O
)	O
;	O
}	O
int	O
regcomp	function
(	O
preg	pointer
,	O
pattern	pointer
,	O
cflags	int
)	O
regex_t	struct
*	O
preg	pointer
;	O
const	O
char	O
*	O
pattern	pointer
;	O
int	O
cflags	int
;	O
{	O
reg_errcode_t	enum
ret	long
;	O
reg_syntax_t	long
syntax	long
=	O
(	O
cflags	int
&	O
REG_EXTENDED	int
)	O
?	O
RE_SYNTAX_POSIX_EXTENDED	O
:	O
RE_SYNTAX_POSIX_BASIC	O
;	O
preg	pointer
->	O
buffer	pointer
=	O
0	int
;	O
preg	pointer
->	O
allocated	long
=	O
0	int
;	O
preg	pointer
->	O
used	long
=	O
0	int
;	O
preg	pointer
->	O
fastmap	pointer
=	O
0	int
;	O
if	O
(	O
cflags	int
&	O
REG_ICASE	O
)	O
{	O
unsigned	O
i	int
;	O
preg	pointer
->	O
translate	pointer
=	O
(	O
RE_TRANSLATE_TYPE	O
)	O
malloc	function
(	O
CHAR_SET_SIZE	int
*	O
sizeof	O
(	O
*	O
(	O
RE_TRANSLATE_TYPE	O
)	O
0	int
)	O
)	O
;	O
if	O
(	O
preg	pointer
->	O
translate	pointer
==	O
NULL	O
)	O
return	O
(	O
int	O
)	O
REG_ESPACE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CHAR_SET_SIZE	int
;	O
i	int
++	O
)	O
preg	pointer
->	O
translate	pointer
[	O
i	int
]	O
=	O
ISUPPER	O
(	O
i	int
)	O
?	O
tolower	function
(	O
i	int
)	O
:	O
i	int
;	O
}	O
else	O
preg	pointer
->	O
translate	pointer
=	O
NULL	O
;	O
if	O
(	O
cflags	int
&	O
REG_NEWLINE	O
)	O
{	O
syntax	long
&=	O
~	O
RE_DOT_NEWLINE	O
;	O
syntax	long
|=	O
RE_HAT_LISTS_NOT_NEWLINE	O
;	O
preg	pointer
->	O
newline_anchor	int
=	O
1	int
;	O
}	O
else	O
preg	pointer
->	O
newline_anchor	int
=	O
0	int
;	O
preg	pointer
->	O
no_sub	int
=	O
!	O
!	O
(	O
cflags	int
&	O
REG_NOSUB	O
)	O
;	O
ret	long
=	O
regex_compile	function
(	O
pattern	pointer
,	O
strlen	function
(	O
pattern	pointer
)	O
,	O
syntax	long
,	O
preg	pointer
)	O
;	O
if	O
(	O
ret	long
==	O
REG_ERPAREN	int
)	O
ret	long
=	O
REG_EPAREN	int
;	O
return	O
(	O
int	O
)	O
ret	long
;	O
}	O
int	O
regexec	function
(	O
preg	pointer
,	O
string	pointer
,	O
nmatch	long
,	O
pmatch	array
,	O
eflags	int
)	O
const	O
regex_t	struct
*	O
preg	pointer
;	O
const	O
char	O
*	O
string	pointer
;	O
size_t	long
nmatch	long
;	O
regmatch_t	struct
pmatch	array
[	O
]	O
;	O
int	O
eflags	int
;	O
{	O
int	O
ret	long
;	O
struct	O
re_registers	struct
regs	pointer
;	O
regex_t	struct
private_preg	struct
;	O
int	O
len	int
=	O
strlen	function
(	O
string	pointer
)	O
;	O
boolean	char
want_reg_info	char
=	O
!	O
preg	pointer
->	O
no_sub	int
&&	O
nmatch	long
>	O
0	int
;	O
private_preg	struct
=	O
*	O
preg	pointer
;	O
private_preg	struct
.	O
not_bol	int
=	O
!	O
!	O
(	O
eflags	int
&	O
REG_NOTBOL	int
)	O
;	O
private_preg	struct
.	O
not_eol	int
=	O
!	O
!	O
(	O
eflags	int
&	O
REG_NOTEOL	O
)	O
;	O
private_preg	struct
.	O
regs_allocated	int
=	O
REGS_FIXED	int
;	O
if	O
(	O
want_reg_info	char
)	O
{	O
regs	pointer
.	O
num_regs	int
=	O
nmatch	long
;	O
regs	pointer
.	O
start	pointer
=	O
TALLOC	O
(	O
nmatch	long
,	O
regoff_t	int
)	O
;	O
regs	pointer
.	O
end	pointer
=	O
TALLOC	O
(	O
nmatch	long
,	O
regoff_t	int
)	O
;	O
if	O
(	O
regs	pointer
.	O
start	pointer
==	O
NULL	O
||	O
regs	pointer
.	O
end	pointer
==	O
NULL	O
)	O
return	O
(	O
int	O
)	O
REG_NOMATCH	int
;	O
}	O
ret	long
=	O
re_search	function
(	O
&	O
private_preg	struct
,	O
string	pointer
,	O
len	int
,	O
0	int
,	O
len	int
,	O
want_reg_info	char
?	O
&	O
regs	pointer
:	O
(	O
struct	O
re_registers	struct
*	O
)	O
0	int
)	O
;	O
if	O
(	O
want_reg_info	char
)	O
{	O
if	O
(	O
ret	long
>=	O
0	int
)	O
{	O
unsigned	O
r	long
;	O
for	O
(	O
r	long
=	O
0	int
;	O
r	long
<	O
nmatch	long
;	O
r	long
++	O
)	O
{	O
pmatch	array
[	O
r	long
]	O
.	O
rm_so	int
=	O
regs	pointer
.	O
start	pointer
[	O
r	long
]	O
;	O
pmatch	array
[	O
r	long
]	O
.	O
rm_eo	int
=	O
regs	pointer
.	O
end	pointer
[	O
r	long
]	O
;	O
}	O
}	O
free	function
(	O
regs	pointer
.	O
start	pointer
)	O
;	O
free	function
(	O
regs	pointer
.	O
end	pointer
)	O
;	O
}	O
return	O
ret	long
>=	O
0	int
?	O
(	O
int	O
)	O
REG_NOERROR	int
:	O
(	O
int	O
)	O
REG_NOMATCH	int
;	O
}	O
size_t	long
regerror	function
(	O
errcode	int
,	O
preg	pointer
,	O
errbuf	pointer
,	O
errbuf_size	long
)	O
int	O
errcode	int
;	O
const	O
regex_t	struct
*	O
preg	pointer
;	O
char	O
*	O
errbuf	pointer
;	O
size_t	long
errbuf_size	long
;	O
{	O
const	O
char	O
*	O
msg	pointer
;	O
size_t	long
msg_size	long
;	O
if	O
(	O
errcode	int
<	O
0	int
||	O
errcode	int
>=	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
re_error_msgid	array
)	O
/	O
sizeof	O
(	O
re_error_msgid	array
[	O
0	int
]	O
)	O
)	O
)	O
abort	function
(	O
)	O
;	O
msg	pointer
=	O
gettext	O
(	O
re_error_msgid	array
[	O
errcode	int
]	O
)	O
;	O
msg_size	long
=	O
strlen	function
(	O
msg	pointer
)	O
+	O
1	int
;	O
if	O
(	O
errbuf_size	long
!=	O
0	int
)	O
{	O
if	O
(	O
msg_size	long
>	O
errbuf_size	long
)	O
{	O
strncpy	function
(	O
errbuf	pointer
,	O
msg	pointer
,	O
errbuf_size	long
-	O
1	int
)	O
;	O
errbuf	pointer
[	O
errbuf_size	long
-	O
1	int
]	O
=	O
0	int
;	O
}	O
else	O
strcpy	function
(	O
errbuf	pointer
,	O
msg	pointer
)	O
;	O
}	O
return	O
msg_size	long
;	O
}	O
void	O
regfree	function
(	O
preg	pointer
)	O
regex_t	struct
*	O
preg	pointer
;	O
{	O
if	O
(	O
preg	pointer
->	O
buffer	pointer
!=	O
NULL	O
)	O
free	function
(	O
preg	pointer
->	O
buffer	pointer
)	O
;	O
preg	pointer
->	O
buffer	pointer
=	O
NULL	O
;	O
preg	pointer
->	O
allocated	long
=	O
0	int
;	O
preg	pointer
->	O
used	long
=	O
0	int
;	O
if	O
(	O
preg	pointer
->	O
fastmap	pointer
!=	O
NULL	O
)	O
free	function
(	O
preg	pointer
->	O
fastmap	pointer
)	O
;	O
preg	pointer
->	O
fastmap	pointer
=	O
NULL	O
;	O
preg	pointer
->	O
fastmap_accurate	int
=	O
0	int
;	O
if	O
(	O
preg	pointer
->	O
translate	pointer
!=	O
NULL	O
)	O
free	function
(	O
preg	pointer
->	O
translate	pointer
)	O
;	O
preg	pointer
->	O
translate	pointer
=	O
NULL	O
;	O
}	O
