static	O
char	O
lex	array
[	O
256	int
]	O
;	O
static	O
const	O
char	O
symbol_chars	array
[	O
]	O
=	O
"$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"	pointer
;	O
static	O
int	O
process_escape	function
(	O
int	O
)	O
;	O
void	O
do_scrub_begin	function
(	O
int	O
m68k_mri	int
ATTRIBUTE_UNUSED	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
c	struct
;	O
lex	array
[	O
' '	O
]	O
=	O
LEX_IS_WHITESPACE	int
;	O
lex	array
[	O
'\t'	O
]	O
=	O
LEX_IS_WHITESPACE	int
;	O
lex	array
[	O
'\r'	O
]	O
=	O
LEX_IS_WHITESPACE	int
;	O
lex	array
[	O
'\n'	O
]	O
=	O
LEX_IS_NEWLINE	int
;	O
lex	array
[	O
':'	O
]	O
=	O
LEX_IS_COLON	int
;	O
{	O
lex	array
[	O
'"'	O
]	O
=	O
LEX_IS_STRINGQUOTE	int
;	O
lex	array
[	O
'\''	O
]	O
=	O
LEX_IS_ONECHAR_QUOTE	int
;	O
}	O
for	O
(	O
p	pointer
=	O
symbol_chars	array
;	O
*	O
p	pointer
;	O
++	O
p	pointer
)	O
lex	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
=	O
LEX_IS_SYMBOL_COMPONENT	int
;	O
for	O
(	O
c	struct
=	O
128	int
;	O
c	struct
<	O
256	int
;	O
++	O
c	struct
)	O
lex	array
[	O
c	struct
]	O
=	O
LEX_IS_SYMBOL_COMPONENT	int
;	O
for	O
(	O
p	pointer
=	O
tc_symbol_chars	O
;	O
*	O
p	pointer
;	O
++	O
p	pointer
)	O
lex	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
=	O
LEX_IS_SYMBOL_COMPONENT	int
;	O
for	O
(	O
p	pointer
=	O
tc_comment_chars	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
lex	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
=	O
LEX_IS_COMMENT_START	int
;	O
for	O
(	O
p	pointer
=	O
line_comment_chars	array
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
lex	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
=	O
LEX_IS_LINE_COMMENT_START	int
;	O
for	O
(	O
p	pointer
=	O
tc_line_separator_chars	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
lex	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
=	O
LEX_IS_LINE_SEPARATOR	int
;	O
if	O
(	O
lex	array
[	O
'/'	O
]	O
==	O
0	int
)	O
lex	array
[	O
'/'	O
]	O
=	O
LEX_IS_TWOCHAR_COMMENT_1ST	int
;	O
}	O
static	O
int	O
state	pointer
;	O
static	O
int	O
old_state	int
;	O
static	O
const	O
char	O
*	O
out_string	pointer
;	O
static	O
char	O
out_buf	array
[	O
20	int
]	O
;	O
static	O
int	O
add_newlines	int
;	O
static	O
char	O
*	O
saved_input	pointer
;	O
static	O
size_t	long
saved_input_len	long
;	O
static	O
char	O
input_buffer	array
[	O
32	int
*	O
1024	int
]	O
;	O
static	O
const	O
char	O
*	O
mri_state	pointer
;	O
static	O
char	O
mri_last_ch	char
;	O
struct	O
app_save	struct
{	O
int	O
state	pointer
;	O
int	O
old_state	int
;	O
const	O
char	O
*	O
out_string	pointer
;	O
char	O
out_buf	array
[	O
sizeof	O
(	O
out_buf	array
)	O
]	O
;	O
int	O
add_newlines	int
;	O
char	O
*	O
saved_input	pointer
;	O
size_t	long
saved_input_len	long
;	O
const	O
char	O
*	O
mri_state	pointer
;	O
char	O
mri_last_ch	char
;	O
}	O
;	O
char	O
*	O
app_push	function
(	O
void	O
)	O
{	O
struct	O
app_save	struct
*	O
saved	pointer
;	O
saved	pointer
=	O
XNEW	O
(	O
struct	O
app_save	struct
)	O
;	O
saved	pointer
->	O
state	pointer
=	O
state	pointer
;	O
saved	pointer
->	O
old_state	int
=	O
old_state	int
;	O
saved	pointer
->	O
out_string	pointer
=	O
out_string	pointer
;	O
memcpy	function
(	O
saved	pointer
->	O
out_buf	array
,	O
out_buf	array
,	O
sizeof	O
(	O
out_buf	array
)	O
)	O
;	O
saved	pointer
->	O
add_newlines	int
=	O
add_newlines	int
;	O
if	O
(	O
saved_input	pointer
==	O
NULL	O
)	O
saved	pointer
->	O
saved_input	pointer
=	O
NULL	O
;	O
else	O
{	O
saved	pointer
->	O
saved_input	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
saved_input_len	long
)	O
;	O
memcpy	function
(	O
saved	pointer
->	O
saved_input	pointer
,	O
saved_input	pointer
,	O
saved_input_len	long
)	O
;	O
saved	pointer
->	O
saved_input_len	long
=	O
saved_input_len	long
;	O
}	O
saved	pointer
->	O
mri_state	pointer
=	O
mri_state	pointer
;	O
saved	pointer
->	O
mri_last_ch	char
=	O
mri_last_ch	char
;	O
state	pointer
=	O
0	int
;	O
saved_input	pointer
=	O
NULL	O
;	O
add_newlines	int
=	O
0	int
;	O
return	O
(	O
char	O
*	O
)	O
saved	pointer
;	O
}	O
void	O
app_pop	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
struct	O
app_save	struct
*	O
saved	pointer
=	O
(	O
struct	O
app_save	struct
*	O
)	O
arg	pointer
;	O
state	pointer
=	O
saved	pointer
->	O
state	pointer
;	O
old_state	int
=	O
saved	pointer
->	O
old_state	int
;	O
out_string	pointer
=	O
saved	pointer
->	O
out_string	pointer
;	O
memcpy	function
(	O
out_buf	array
,	O
saved	pointer
->	O
out_buf	array
,	O
sizeof	O
(	O
out_buf	array
)	O
)	O
;	O
add_newlines	int
=	O
saved	pointer
->	O
add_newlines	int
;	O
if	O
(	O
saved	pointer
->	O
saved_input	pointer
==	O
NULL	O
)	O
saved_input	pointer
=	O
NULL	O
;	O
else	O
{	O
gas_assert	O
(	O
saved	pointer
->	O
saved_input_len	long
<=	O
sizeof	O
(	O
input_buffer	array
)	O
)	O
;	O
memcpy	function
(	O
input_buffer	array
,	O
saved	pointer
->	O
saved_input	pointer
,	O
saved	pointer
->	O
saved_input_len	long
)	O
;	O
saved_input	pointer
=	O
input_buffer	array
;	O
saved_input_len	long
=	O
saved	pointer
->	O
saved_input_len	long
;	O
free	function
(	O
saved	pointer
->	O
saved_input	pointer
)	O
;	O
}	O
mri_state	pointer
=	O
saved	pointer
->	O
mri_state	pointer
;	O
mri_last_ch	char
=	O
saved	pointer
->	O
mri_last_ch	char
;	O
free	function
(	O
arg	pointer
)	O
;	O
}	O
static	O
int	O
process_escape	function
(	O
int	O
ch	int
)	O
{	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'\''	O
:	O
return	O
'\''	O
;	O
case	O
'"'	O
:	O
return	O
'\"'	O
;	O
default	O
:	O
return	O
ch	int
;	O
}	O
}	O
size_t	long
do_scrub_chars	function
(	O
size_t	long
(	O
*	O
get	pointer
)	O
(	O
char	O
*	O
,	O
size_t	long
)	O
,	O
char	O
*	O
tostart	pointer
,	O
size_t	long
tolen	long
)	O
{	O
char	O
*	O
to	pointer
=	O
tostart	pointer
;	O
char	O
*	O
toend	pointer
=	O
tostart	pointer
+	O
tolen	long
;	O
char	O
*	O
from	pointer
;	O
char	O
*	O
fromend	pointer
;	O
size_t	long
fromlen	long
;	O
int	O
ch	int
,	O
ch2	int
=	O
0	int
;	O
static	O
char	O
quotechar	char
;	O
if	O
(	O
saved_input	pointer
!=	O
NULL	O
)	O
{	O
from	pointer
=	O
saved_input	pointer
;	O
fromend	pointer
=	O
from	pointer
+	O
saved_input_len	long
;	O
}	O
else	O
{	O
fromlen	long
=	O
(	O
*	O
get	pointer
)	O
(	O
input_buffer	array
,	O
sizeof	O
input_buffer	array
)	O
;	O
if	O
(	O
fromlen	long
==	O
0	int
)	O
return	O
0	int
;	O
from	pointer
=	O
input_buffer	array
;	O
fromend	pointer
=	O
from	pointer
+	O
fromlen	long
;	O
}	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
-	O
1	int
:	O
ch	int
=	O
*	O
out_string	pointer
++	O
;	O
if	O
(	O
*	O
out_string	pointer
==	O
'\0'	O
)	O
{	O
state	pointer
=	O
old_state	int
;	O
old_state	int
=	O
3	int
;	O
}	O
PUT	O
(	O
ch	int
)	O
;	O
continue	O
;	O
case	O
-	O
2	int
:	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file in comment"	pointer
)	O
)	O
;	O
goto	O
fromeof	O
;	O
}	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
PUT	O
(	O
'\n'	O
)	O
;	O
}	O
while	O
(	O
ch	int
!=	O
'*'	O
)	O
;	O
while	O
(	O
(	O
ch	int
=	O
GET	O
(	O
)	O
)	O
==	O
'*'	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file in comment"	pointer
)	O
)	O
;	O
goto	O
fromeof	O
;	O
}	O
if	O
(	O
ch	int
==	O
'/'	O
)	O
break	O
;	O
UNGET	O
(	O
ch	int
)	O
;	O
}	O
state	pointer
=	O
old_state	int
;	O
UNGET	O
(	O
' '	O
)	O
;	O
continue	O
;	O
case	O
4	int
:	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
goto	O
fromeof	O
;	O
else	O
if	O
(	O
ch	int
>=	O
'0'	O
&&	O
ch	int
<=	O
'9'	O
)	O
PUT	O
(	O
ch	int
)	O
;	O
else	O
{	O
while	O
(	O
ch	int
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
ch	int
)	O
)	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
'"'	O
)	O
{	O
quotechar	char
=	O
ch	int
;	O
state	pointer
=	O
5	int
;	O
old_state	int
=	O
3	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
}	O
else	O
{	O
while	O
(	O
ch	int
!=	O
EOF	O
&&	O
ch	int
!=	O
'\n'	O
)	O
ch	int
=	O
GET	O
(	O
)	O
;	O
state	pointer
=	O
0	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
}	O
}	O
continue	O
;	O
case	O
5	int
:	O
{	O
char	O
*	O
s	pointer
;	O
ptrdiff_t	long
len	long
;	O
for	O
(	O
s	pointer
=	O
from	pointer
;	O
s	pointer
<	O
fromend	pointer
;	O
s	pointer
++	O
)	O
{	O
ch	int
=	O
*	O
s	pointer
;	O
if	O
(	O
ch	int
==	O
'\\'	O
||	O
ch	int
==	O
quotechar	char
||	O
ch	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
len	long
=	O
s	pointer
-	O
from	pointer
;	O
if	O
(	O
len	long
>	O
toend	pointer
-	O
to	pointer
)	O
len	long
=	O
toend	pointer
-	O
to	pointer
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
memcpy	function
(	O
to	pointer
,	O
from	pointer
,	O
len	long
)	O
;	O
to	pointer
+=	O
len	long
;	O
from	pointer
+=	O
len	long
;	O
if	O
(	O
to	pointer
>=	O
toend	pointer
)	O
goto	O
tofull	O
;	O
}	O
}	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
static	O
char	O
one_char_buf	array
[	O
1	int
]	O
;	O
as_warn	function
(	O
_	O
(	O
"end of file in string; '%c' inserted"	pointer
)	O
,	O
quotechar	char
)	O
;	O
state	pointer
=	O
old_state	int
;	O
from	pointer
=	O
fromend	pointer
=	O
one_char_buf	array
+	O
1	int
;	O
fromlen	long
=	O
1	int
;	O
UNGET	O
(	O
'\n'	O
)	O
;	O
PUT	O
(	O
quotechar	char
)	O
;	O
}	O
else	O
if	O
(	O
ch	int
==	O
quotechar	char
)	O
{	O
state	pointer
=	O
old_state	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
}	O
else	O
if	O
(	O
TC_STRING_ESCAPES	int
&&	O
ch	int
==	O
'\\'	O
)	O
{	O
state	pointer
=	O
6	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
}	O
else	O
if	O
(	O
scrub_m68k_mri	int
&&	O
ch	int
==	O
'\n'	O
)	O
{	O
state	pointer
=	O
old_state	int
;	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
'\''	O
)	O
;	O
}	O
else	O
{	O
PUT	O
(	O
ch	int
)	O
;	O
}	O
continue	O
;	O
case	O
6	int
:	O
state	pointer
=	O
5	int
;	O
ch	int
=	O
GET	O
(	O
)	O
;	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'\n'	O
:	O
UNGET	O
(	O
'n'	O
)	O
;	O
add_newlines	int
++	O
;	O
PUT	O
(	O
'\\'	O
)	O
;	O
continue	O
;	O
case	O
EOF	O
:	O
as_warn	function
(	O
_	O
(	O
"end of file in string; '%c' inserted"	pointer
)	O
,	O
quotechar	char
)	O
;	O
PUT	O
(	O
quotechar	char
)	O
;	O
continue	O
;	O
case	O
'"'	O
:	O
case	O
'\\'	O
:	O
case	O
'b'	O
:	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
'r'	O
:	O
case	O
't'	O
:	O
case	O
'v'	O
:	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
PUT	O
(	O
ch	int
)	O
;	O
continue	O
;	O
}	O
ch	int
=	O
GET	O
(	O
)	O
;	O
recycle	O
:	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
if	O
(	O
state	pointer
!=	O
0	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file not at end of a line; newline inserted"	pointer
)	O
)	O
;	O
state	pointer
=	O
0	int
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
}	O
goto	O
fromeof	O
;	O
}	O
switch	O
(	O
lex	array
[	O
ch	int
]	O
)	O
{	O
case	O
LEX_IS_WHITESPACE	int
:	O
do	O
{	O
ch	int
=	O
GET	O
(	O
)	O
;	O
}	O
while	O
(	O
ch	int
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
ch	int
)	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
goto	O
fromeof	O
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
state	pointer
=	O
1	int
;	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
IS_COMMENT	O
(	O
ch	int
)	O
||	O
ch	int
==	O
'/'	O
||	O
IS_LINE_SEPARATOR	O
(	O
ch	int
)	O
||	O
IS_PARALLEL_SEPARATOR	O
(	O
ch	int
)	O
)	O
{	O
if	O
(	O
scrub_m68k_mri	int
)	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
goto	O
recycle	O
;	O
}	O
if	O
(	O
(	O
state	pointer
==	O
2	int
||	O
state	pointer
==	O
11	int
)	O
&&	O
lex	array
[	O
ch	int
]	O
==	O
LEX_IS_COLON	int
&&	O
!	O
scrub_m68k_mri	int
)	O
{	O
state	pointer
=	O
1	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
1	int
:	O
goto	O
recycle	O
;	O
case	O
2	int
:	O
state	pointer
=	O
3	int
;	O
if	O
(	O
to	pointer
+	O
1	int
<	O
toend	pointer
)	O
{	O
PUT	O
(	O
' '	O
)	O
;	O
goto	O
recycle	O
;	O
}	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
scrub_m68k_mri	int
)	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
goto	O
recycle	O
;	O
case	O
9	int
:	O
case	O
10	int
:	O
if	O
(	O
scrub_m68k_mri	int
)	O
{	O
state	pointer
=	O
3	int
;	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
state	pointer
=	O
10	int
;	O
goto	O
recycle	O
;	O
case	O
11	int
:	O
if	O
(	O
LABELS_WITHOUT_COLONS	int
||	O
flag_m68k_mri	int
)	O
state	pointer
=	O
1	int
;	O
else	O
{	O
state	pointer
=	O
3	int
;	O
}	O
UNGET	O
(	O
ch	int
)	O
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
default	O
:	O
BAD_CASE	O
(	O
state	pointer
)	O
;	O
}	O
break	O
;	O
case	O
LEX_IS_TWOCHAR_COMMENT_1ST	int
:	O
ch2	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	int
==	O
'*'	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
ch2	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	int
!=	O
EOF	O
&&	O
IS_NEWLINE	O
(	O
ch2	int
)	O
)	O
add_newlines	int
++	O
;	O
}	O
while	O
(	O
ch2	int
!=	O
EOF	O
&&	O
ch2	int
!=	O
'*'	O
)	O
;	O
while	O
(	O
ch2	int
==	O
'*'	O
)	O
ch2	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	int
==	O
EOF	O
||	O
ch2	int
==	O
'/'	O
)	O
break	O
;	O
UNGET	O
(	O
ch2	int
)	O
;	O
}	O
if	O
(	O
ch2	int
==	O
EOF	O
)	O
as_warn	function
(	O
_	O
(	O
"end of file in multiline comment"	pointer
)	O
)	O
;	O
ch	int
=	O
' '	O
;	O
goto	O
recycle	O
;	O
}	O
else	O
{	O
if	O
(	O
ch2	int
!=	O
EOF	O
)	O
UNGET	O
(	O
ch2	int
)	O
;	O
if	O
(	O
state	pointer
==	O
9	int
||	O
state	pointer
==	O
10	int
)	O
state	pointer
=	O
3	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
}	O
break	O
;	O
case	O
LEX_IS_STRINGQUOTE	int
:	O
quotechar	char
=	O
ch	int
;	O
if	O
(	O
state	pointer
==	O
10	int
)	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
state	pointer
=	O
3	int
;	O
PUT	O
(	O
' '	O
)	O
;	O
ch	int
=	O
GET	O
(	O
)	O
;	O
old_state	int
=	O
3	int
;	O
}	O
else	O
if	O
(	O
state	pointer
==	O
9	int
)	O
old_state	int
=	O
3	int
;	O
else	O
old_state	int
=	O
state	pointer
;	O
state	pointer
=	O
5	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
break	O
;	O
case	O
LEX_IS_ONECHAR_QUOTE	int
:	O
if	O
(	O
state	pointer
==	O
10	int
)	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
state	pointer
=	O
3	int
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file after a one-character quote; \\0 inserted"	pointer
)	O
)	O
;	O
ch	int
=	O
0	int
;	O
}	O
if	O
(	O
ch	int
==	O
'\\'	O
)	O
{	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file in escape character"	pointer
)	O
)	O
;	O
ch	int
=	O
'\\'	O
;	O
}	O
else	O
ch	int
=	O
process_escape	function
(	O
ch	int
)	O
;	O
}	O
sprintf	function
(	O
out_buf	array
,	O
"%d"	pointer
,	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
)	O
;	O
if	O
(	O
(	O
ch	int
=	O
GET	O
(	O
)	O
)	O
!=	O
'\''	O
)	O
{	O
if	O
(	O
ch	int
!=	O
EOF	O
)	O
UNGET	O
(	O
ch	int
)	O
;	O
}	O
if	O
(	O
strlen	function
(	O
out_buf	array
)	O
==	O
1	int
)	O
{	O
PUT	O
(	O
out_buf	array
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
state	pointer
==	O
9	int
)	O
old_state	int
=	O
3	int
;	O
else	O
old_state	int
=	O
state	pointer
;	O
state	pointer
=	O
-	O
1	int
;	O
out_string	pointer
=	O
out_buf	array
;	O
PUT	O
(	O
*	O
out_string	pointer
++	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_COLON	int
:	O
if	O
(	O
state	pointer
==	O
9	int
||	O
state	pointer
==	O
10	int
)	O
state	pointer
=	O
3	int
;	O
else	O
if	O
(	O
state	pointer
!=	O
3	int
)	O
state	pointer
=	O
1	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
break	O
;	O
case	O
LEX_IS_NEWLINE	int
:	O
if	O
(	O
add_newlines	int
)	O
{	O
--	O
add_newlines	int
;	O
UNGET	O
(	O
ch	int
)	O
;	O
}	O
case	O
LEX_IS_LINE_SEPARATOR	int
:	O
state	pointer
=	O
0	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
break	O
;	O
case	O
LEX_IS_PARALLEL_SEPARATOR	int
:	O
state	pointer
=	O
1	int
;	O
PUT	O
(	O
ch	int
)	O
;	O
break	O
;	O
case	O
LEX_IS_LINE_COMMENT_START	int
:	O
if	O
(	O
ch	int
==	O
'/'	O
)	O
{	O
ch2	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch2	int
==	O
'*'	O
)	O
{	O
old_state	int
=	O
3	int
;	O
state	pointer
=	O
-	O
2	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ch2	int
!=	O
EOF	O
)	O
{	O
UNGET	O
(	O
ch2	int
)	O
;	O
}	O
}	O
if	O
(	O
state	pointer
==	O
0	int
||	O
state	pointer
==	O
1	int
)	O
{	O
int	O
startch	int
;	O
startch	int
=	O
ch	int
;	O
do	O
{	O
ch	int
=	O
GET	O
(	O
)	O
;	O
}	O
while	O
(	O
ch	int
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
ch	int
)	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file in comment; newline inserted"	pointer
)	O
)	O
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ch	int
<	O
'0'	O
||	O
ch	int
>	O
'9'	O
||	O
state	pointer
!=	O
0	int
||	O
startch	int
!=	O
'#'	O
)	O
{	O
while	O
(	O
ch	int
!=	O
EOF	O
&&	O
!	O
IS_NEWLINE	O
(	O
ch	int
)	O
)	O
ch	int
=	O
GET	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"end of file in comment; newline inserted"	pointer
)	O
)	O
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
}	O
else	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
}	O
state	pointer
=	O
0	int
;	O
break	O
;	O
}	O
UNGET	O
(	O
ch	int
)	O
;	O
old_state	int
=	O
4	int
;	O
state	pointer
=	O
-	O
1	int
;	O
if	O
(	O
scrub_m68k_mri	int
)	O
out_string	pointer
=	O
"\tlinefile "	pointer
;	O
else	O
out_string	pointer
=	O
"\t.linefile "	pointer
;	O
PUT	O
(	O
*	O
out_string	pointer
++	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
strchr	function
(	O
tc_comment_chars	O
,	O
ch	int
)	O
==	O
NULL	O
&&	O
(	O
!	O
scrub_m68k_mri	int
||	O
(	O
ch	int
!=	O
'!'	O
&&	O
ch	int
!=	O
'*'	O
)	O
)	O
)	O
goto	O
de_fault	O
;	O
if	O
(	O
scrub_m68k_mri	int
&&	O
(	O
ch	int
==	O
'!'	O
||	O
ch	int
==	O
'*'	O
||	O
ch	int
==	O
'#'	O
)	O
&&	O
state	pointer
!=	O
1	int
&&	O
state	pointer
!=	O
10	int
)	O
goto	O
de_fault	O
;	O
case	O
LEX_IS_COMMENT_START	int
:	O
do	O
{	O
ch	int
=	O
GET	O
(	O
)	O
;	O
}	O
while	O
(	O
ch	int
!=	O
EOF	O
&&	O
!	O
IS_NEWLINE	O
(	O
ch	int
)	O
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
as_warn	function
(	O
_	O
(	O
"end of file in comment; newline inserted"	pointer
)	O
)	O
;	O
state	pointer
=	O
0	int
;	O
PUT	O
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
LEX_IS_SYMBOL_COMPONENT	int
:	O
if	O
(	O
state	pointer
==	O
10	int
)	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
state	pointer
=	O
3	int
;	O
PUT	O
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
state	pointer
==	O
3	int
)	O
state	pointer
=	O
9	int
;	O
if	O
(	O
to	pointer
+	O
1	int
<	O
toend	pointer
&&	O
mri_state	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
s	pointer
;	O
ptrdiff_t	long
len	long
;	O
for	O
(	O
s	pointer
=	O
from	pointer
;	O
s	pointer
<	O
fromend	pointer
;	O
s	pointer
++	O
)	O
{	O
int	O
type	char
;	O
ch2	int
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	pointer
;	O
type	char
=	O
lex	array
[	O
ch2	int
]	O
;	O
if	O
(	O
type	char
!=	O
0	int
&&	O
type	char
!=	O
LEX_IS_SYMBOL_COMPONENT	int
)	O
break	O
;	O
}	O
if	O
(	O
s	pointer
>	O
from	pointer
)	O
--	O
s	pointer
;	O
len	long
=	O
s	pointer
-	O
from	pointer
;	O
if	O
(	O
len	long
>	O
(	O
toend	pointer
-	O
to	pointer
)	O
-	O
1	int
)	O
len	long
=	O
(	O
toend	pointer
-	O
to	pointer
)	O
-	O
1	int
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
PUT	O
(	O
ch	int
)	O
;	O
memcpy	function
(	O
to	pointer
,	O
from	pointer
,	O
len	long
)	O
;	O
to	pointer
+=	O
len	long
;	O
from	pointer
+=	O
len	long
;	O
if	O
(	O
to	pointer
>=	O
toend	pointer
)	O
goto	O
tofull	O
;	O
ch	int
=	O
GET	O
(	O
)	O
;	O
}	O
}	O
default	O
:	O
de_fault	O
:	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
state	pointer
=	O
11	int
;	O
}	O
else	O
if	O
(	O
state	pointer
==	O
1	int
)	O
{	O
state	pointer
=	O
2	int
;	O
}	O
else	O
if	O
(	O
state	pointer
==	O
9	int
)	O
{	O
if	O
(	O
!	O
IS_SYMBOL_COMPONENT	O
(	O
ch	int
)	O
)	O
state	pointer
=	O
3	int
;	O
}	O
else	O
if	O
(	O
state	pointer
==	O
10	int
)	O
{	O
if	O
(	O
ch	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
to	pointer
+	O
1	int
>=	O
toend	pointer
)	O
{	O
UNGET	O
(	O
ch	int
)	O
;	O
goto	O
tofull	O
;	O
}	O
*	O
to	pointer
++	O
=	O
' '	O
;	O
}	O
state	pointer
=	O
3	int
;	O
}	O
PUT	O
(	O
ch	int
)	O
;	O
break	O
;	O
}	O
}	O
fromeof	O
:	O
return	O
to	pointer
-	O
tostart	pointer
;	O
tofull	O
:	O
if	O
(	O
fromend	pointer
>	O
from	pointer
)	O
{	O
saved_input	pointer
=	O
from	pointer
;	O
saved_input_len	long
=	O
fromend	pointer
-	O
from	pointer
;	O
}	O
else	O
saved_input	pointer
=	O
NULL	O
;	O
return	O
to	pointer
-	O
tostart	pointer
;	O
}	O
