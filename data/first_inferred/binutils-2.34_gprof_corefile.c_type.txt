bfd	struct
*	O
core_bfd	pointer
;	O
static	O
int	O
core_num_syms	int
;	O
static	O
asymbol	struct
*	O
*	O
core_syms	pointer
;	O
asection	struct
*	O
core_text_sect	pointer
;	O
void	O
*	O
core_text_space	pointer
;	O
static	O
int	O
min_insn_size	int
;	O
int	O
offset_to_code	int
;	O
struct	O
function_map	struct
*	O
symbol_map	pointer
;	O
unsigned	O
int	O
symbol_map_count	int
;	O
static	O
void	O
read_function_mappings	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
int	O
core_sym_class	function
(	O
asymbol	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
get_src_info	function
(	O
bfd_vma	long
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
;	O
extern	O
void	O
i386_find_call	function
(	O
Sym	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
extern	O
void	O
alpha_find_call	function
(	O
Sym	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
extern	O
void	O
vax_find_call	function
(	O
Sym	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
extern	O
void	O
sparc_find_call	function
(	O
Sym	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
extern	O
void	O
mips_find_call	function
(	O
Sym	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
extern	O
void	O
aarch64_find_call	function
(	O
Sym	struct
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
static	O
void	O
parse_error	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unable to parse mapping file %s.\n"	pointer
)	O
,	O
whoami	pointer
,	O
filename	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
static	O
int	O
cmp_symbol_map	function
(	O
const	O
void	O
*	O
l	pointer
,	O
const	O
void	O
*	O
r	pointer
)	O
{	O
return	O
strcmp	function
(	O
(	O
(	O
struct	O
function_map	struct
*	O
)	O
l	pointer
)	O
->	O
function_name	pointer
,	O
(	O
(	O
struct	O
function_map	struct
*	O
)	O
r	pointer
)	O
->	O
function_name	pointer
)	O
;	O
}	O
static	O
void	O
read_function_mappings	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
char	O
dummy	array
[	O
BUFSIZE	O
]	O
;	O
int	O
count	int
=	O
0	int
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: could not open %s.\n"	pointer
)	O
,	O
whoami	pointer
,	O
filename	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
int	O
matches	int
;	O
matches	int
=	O
fscanf	function
(	O
file	pointer
,	O
"%"	pointer
STR_BUFSIZE	pointer
"[^\n:]"	pointer
,	O
dummy	array
)	O
;	O
if	O
(	O
!	O
matches	int
)	O
parse_error	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
dummy	array
,	O
"No symbols in "	pointer
,	O
14	int
)	O
)	O
{	O
matches	int
=	O
fscanf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
matches	int
==	O
EOF	O
)	O
parse_error	function
(	O
filename	pointer
)	O
;	O
continue	O
;	O
}	O
matches	int
=	O
fscanf	function
(	O
file	pointer
,	O
"%"	pointer
STR_BUFSIZE	pointer
"[^\n]\n"	pointer
,	O
dummy	array
)	O
;	O
if	O
(	O
!	O
matches	int
)	O
parse_error	function
(	O
filename	pointer
)	O
;	O
count	int
++	O
;	O
}	O
symbol_map	pointer
=	O
(	O
(	O
struct	O
function_map	struct
*	O
)	O
xmalloc	function
(	O
count	int
*	O
sizeof	O
(	O
struct	O
function_map	struct
)	O
)	O
)	O
;	O
rewind	function
(	O
file	pointer
)	O
;	O
count	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
int	O
matches	int
;	O
char	O
*	O
tmp	pointer
;	O
matches	int
=	O
fscanf	function
(	O
file	pointer
,	O
"%"	pointer
STR_BUFSIZE	pointer
"[^\n:]"	pointer
,	O
dummy	array
)	O
;	O
if	O
(	O
!	O
matches	int
)	O
parse_error	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
dummy	array
,	O
"No symbols in "	pointer
,	O
14	int
)	O
)	O
{	O
matches	int
=	O
fscanf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
matches	int
==	O
EOF	O
)	O
parse_error	function
(	O
filename	pointer
)	O
;	O
continue	O
;	O
}	O
symbol_map	pointer
[	O
count	int
]	O
.	O
file_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
dummy	array
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
symbol_map	pointer
[	O
count	int
]	O
.	O
file_name	pointer
,	O
dummy	array
)	O
;	O
matches	int
=	O
fscanf	function
(	O
file	pointer
,	O
"%"	pointer
STR_BUFSIZE	pointer
"[^\n]\n"	pointer
,	O
dummy	array
)	O
;	O
if	O
(	O
!	O
matches	int
)	O
parse_error	function
(	O
filename	pointer
)	O
;	O
tmp	pointer
=	O
strrchr	function
(	O
dummy	array
,	O
' '	O
)	O
+	O
1	int
;	O
symbol_map	pointer
[	O
count	int
]	O
.	O
function_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
tmp	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
symbol_map	pointer
[	O
count	int
]	O
.	O
function_name	pointer
,	O
tmp	pointer
)	O
;	O
count	int
++	O
;	O
}	O
symbol_map_count	int
=	O
count	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symbol_map_count	int
;	O
++	O
i	pointer
)	O
if	O
(	O
i	pointer
==	O
0	int
||	O
filename_cmp	function
(	O
symbol_map	pointer
[	O
i	pointer
]	O
.	O
file_name	pointer
,	O
symbol_map	pointer
[	O
i	pointer
-	O
1	int
]	O
.	O
file_name	pointer
)	O
)	O
symbol_map	pointer
[	O
i	pointer
]	O
.	O
is_first	int
=	O
1	int
;	O
qsort	function
(	O
symbol_map	pointer
,	O
symbol_map_count	int
,	O
sizeof	O
(	O
struct	O
function_map	struct
)	O
,	O
cmp_symbol_map	function
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
void	O
core_init	function
(	O
const	O
char	O
*	O
aout_name	pointer
)	O
{	O
int	O
core_sym_bytes	int
;	O
asymbol	struct
*	O
synthsyms	pointer
;	O
long	O
synth_count	long
;	O
core_bfd	pointer
=	O
bfd_openr	function
(	O
aout_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
core_bfd	pointer
)	O
{	O
perror	function
(	O
aout_name	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
core_bfd	pointer
->	O
flags	int
|=	O
BFD_DECOMPRESS	int
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
core_bfd	pointer
,	O
bfd_object	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: %s: not in executable format\n"	pointer
)	O
,	O
whoami	pointer
,	O
aout_name	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
core_text_sect	pointer
=	O
bfd_get_section_by_name	function
(	O
core_bfd	pointer
,	O
".text"	pointer
)	O
;	O
if	O
(	O
!	O
core_text_sect	pointer
)	O
{	O
core_text_sect	pointer
=	O
bfd_get_section_by_name	function
(	O
core_bfd	pointer
,	O
"$CODE$"	pointer
)	O
;	O
if	O
(	O
!	O
core_text_sect	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: can't find .text section in %s\n"	pointer
)	O
,	O
whoami	pointer
,	O
aout_name	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
}	O
core_sym_bytes	int
=	O
bfd_get_symtab_upper_bound	O
(	O
core_bfd	pointer
)	O
;	O
if	O
(	O
core_sym_bytes	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: %s\n"	pointer
,	O
whoami	pointer
,	O
aout_name	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
core_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xmalloc	function
(	O
core_sym_bytes	int
)	O
;	O
core_num_syms	int
=	O
bfd_canonicalize_symtab	O
(	O
core_bfd	pointer
,	O
core_syms	pointer
)	O
;	O
if	O
(	O
core_num_syms	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: %s\n"	pointer
,	O
whoami	pointer
,	O
aout_name	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
synth_count	long
=	O
bfd_get_synthetic_symtab	O
(	O
core_bfd	pointer
,	O
core_num_syms	int
,	O
core_syms	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
synthsyms	pointer
)	O
;	O
if	O
(	O
synth_count	long
>	O
0	int
)	O
{	O
asymbol	struct
*	O
*	O
symp	pointer
;	O
long	O
new_size	long
;	O
long	O
i	pointer
;	O
new_size	long
=	O
(	O
core_num_syms	int
+	O
synth_count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
core_syms	pointer
)	O
;	O
core_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xrealloc	function
(	O
core_syms	pointer
,	O
new_size	long
)	O
;	O
symp	pointer
=	O
core_syms	pointer
+	O
core_num_syms	int
;	O
core_num_syms	int
+=	O
synth_count	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
synth_count	long
;	O
i	pointer
++	O
)	O
*	O
symp	pointer
++	O
=	O
synthsyms	pointer
+	O
i	pointer
;	O
*	O
symp	pointer
=	O
0	int
;	O
}	O
min_insn_size	int
=	O
1	int
;	O
offset_to_code	int
=	O
0	int
;	O
switch	O
(	O
bfd_get_arch	function
(	O
core_bfd	pointer
)	O
)	O
{	O
case	O
bfd_arch_vax	int
:	O
offset_to_code	int
=	O
2	int
;	O
break	O
;	O
case	O
bfd_arch_alpha	int
:	O
min_insn_size	int
=	O
4	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
function_mapping_file	pointer
)	O
read_function_mappings	function
(	O
function_mapping_file	pointer
)	O
;	O
}	O
void	O
core_get_text_space	function
(	O
bfd	struct
*	O
cbfd	pointer
)	O
{	O
core_text_space	pointer
=	O
malloc	function
(	O
bfd_section_size	function
(	O
core_text_sect	pointer
)	O
)	O
;	O
if	O
(	O
!	O
core_text_space	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: ran out room for %lu bytes of text space\n"	pointer
)	O
,	O
whoami	pointer
,	O
(	O
unsigned	O
long	O
)	O
bfd_section_size	function
(	O
core_text_sect	pointer
)	O
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
cbfd	pointer
,	O
core_text_sect	pointer
,	O
core_text_space	pointer
,	O
0	int
,	O
bfd_section_size	function
(	O
core_text_sect	pointer
)	O
)	O
)	O
{	O
bfd_perror	function
(	O
"bfd_get_section_contents"	pointer
)	O
;	O
free	function
(	O
core_text_space	pointer
)	O
;	O
core_text_space	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
core_text_space	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: can't do -c\n"	pointer
)	O
,	O
whoami	pointer
)	O
;	O
}	O
void	O
find_call	function
(	O
Sym	struct
*	O
parent	pointer
,	O
bfd_vma	long
p_lowpc	pointer
,	O
bfd_vma	long
p_highpc	pointer
)	O
{	O
if	O
(	O
core_text_space	pointer
==	O
0	int
)	O
return	O
;	O
hist_clip_symbol_address	function
(	O
&	O
p_lowpc	pointer
,	O
&	O
p_highpc	pointer
)	O
;	O
switch	O
(	O
bfd_get_arch	function
(	O
core_bfd	pointer
)	O
)	O
{	O
case	O
bfd_arch_i386	int
:	O
i386_find_call	function
(	O
parent	pointer
,	O
p_lowpc	pointer
,	O
p_highpc	pointer
)	O
;	O
break	O
;	O
case	O
bfd_arch_alpha	int
:	O
alpha_find_call	function
(	O
parent	pointer
,	O
p_lowpc	pointer
,	O
p_highpc	pointer
)	O
;	O
break	O
;	O
case	O
bfd_arch_vax	int
:	O
vax_find_call	function
(	O
parent	pointer
,	O
p_lowpc	pointer
,	O
p_highpc	pointer
)	O
;	O
break	O
;	O
case	O
bfd_arch_sparc	int
:	O
sparc_find_call	function
(	O
parent	pointer
,	O
p_lowpc	pointer
,	O
p_highpc	pointer
)	O
;	O
break	O
;	O
case	O
bfd_arch_mips	int
:	O
mips_find_call	function
(	O
parent	pointer
,	O
p_lowpc	pointer
,	O
p_highpc	pointer
)	O
;	O
break	O
;	O
case	O
bfd_arch_aarch64	int
:	O
aarch64_find_call	function
(	O
parent	pointer
,	O
p_lowpc	pointer
,	O
p_highpc	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: -c not supported on architecture %s\n"	pointer
)	O
,	O
whoami	pointer
,	O
bfd_printable_name	function
(	O
core_bfd	pointer
)	O
)	O
;	O
ignore_direct_calls	int
=	O
FALSE	int
;	O
}	O
}	O
static	O
int	O
core_sym_class	function
(	O
asymbol	struct
*	O
sym	pointer
)	O
{	O
symbol_info	struct
syminfo	struct
;	O
const	O
char	O
*	O
name	pointer
;	O
char	O
sym_prefix	char
;	O
int	O
i	pointer
;	O
if	O
(	O
sym	pointer
->	O
section	pointer
==	O
NULL	O
||	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
ignore_static_funcs	int
&&	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
)	O
)	O
{	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[core_sym_class] %s: not a function\n"	pointer
,	O
sym	pointer
->	O
name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
bfd_get_symbol_info	O
(	O
core_bfd	pointer
,	O
sym	pointer
,	O
&	O
syminfo	struct
)	O
;	O
i	pointer
=	O
syminfo	struct
.	O
type	enum
;	O
if	O
(	O
i	pointer
==	O
'T'	O
)	O
return	O
i	pointer
;	O
if	O
(	O
i	pointer
==	O
'W'	O
)	O
return	O
'T'	O
;	O
if	O
(	O
i	pointer
!=	O
't'	O
)	O
{	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[core_sym_class] %s is of class %c\n"	pointer
,	O
sym	pointer
->	O
name	pointer
,	O
i	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
ignore_static_funcs	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
sym	pointer
->	O
name	pointer
||	O
sym	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
0	int
;	O
for	O
(	O
name	pointer
=	O
sym	pointer
->	O
name	pointer
;	O
*	O
name	pointer
;	O
++	O
name	pointer
)	O
{	O
if	O
(	O
*	O
name	pointer
==	O
'$'	O
)	O
return	O
0	int
;	O
while	O
(	O
*	O
name	pointer
==	O
'.'	O
)	O
{	O
int	O
digit_seen	int
=	O
0	int
;	O
if	O
(	O
strlen	function
(	O
name	pointer
)	O
>	O
CLONE_NAME_LEN	O
&&	O
strncmp	function
(	O
name	pointer
,	O
CLONE_NAME	pointer
,	O
CLONE_NAME_LEN	O
)	O
==	O
0	int
)	O
name	pointer
+=	O
CLONE_NAME_LEN	O
-	O
1	int
;	O
else	O
if	O
(	O
strlen	function
(	O
name	pointer
)	O
>	O
CONSTPROP_NAME_LEN	O
&&	O
strncmp	function
(	O
name	pointer
,	O
CONSTPROP_NAME	pointer
,	O
CONSTPROP_NAME_LEN	O
)	O
==	O
0	int
)	O
name	pointer
+=	O
CONSTPROP_NAME_LEN	O
-	O
1	int
;	O
for	O
(	O
name	pointer
++	O
;	O
*	O
name	pointer
;	O
name	pointer
++	O
)	O
if	O
(	O
digit_seen	int
&&	O
*	O
name	pointer
==	O
'.'	O
)	O
break	O
;	O
else	O
if	O
(	O
ISDIGIT	O
(	O
*	O
name	pointer
)	O
)	O
digit_seen	int
=	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
}	O
sym_prefix	char
=	O
bfd_get_symbol_leading_char	function
(	O
core_bfd	pointer
)	O
;	O
if	O
(	O
(	O
sym_prefix	char
&&	O
sym_prefix	char
!=	O
sym	pointer
->	O
name	pointer
[	O
0	int
]	O
)	O
||	O
!	O
strncmp	function
(	O
sym	pointer
->	O
name	pointer
,	O
"__gnu_compiled"	pointer
,	O
14	int
)	O
||	O
!	O
strncmp	function
(	O
sym	pointer
->	O
name	pointer
,	O
"___gnu_compiled"	pointer
,	O
15	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
ignore_non_functions	int
&&	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_FUNCTION	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
't'	O
;	O
}	O
static	O
bfd_boolean	int
get_src_info	function
(	O
bfd_vma	long
addr	pointer
,	O
const	O
char	O
*	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
*	O
name	pointer
,	O
int	O
*	O
line_num	int
)	O
{	O
const	O
char	O
*	O
fname	pointer
=	O
0	int
,	O
*	O
func_name	pointer
=	O
0	int
;	O
int	O
l	pointer
=	O
0	int
;	O
if	O
(	O
bfd_find_nearest_line	O
(	O
core_bfd	pointer
,	O
core_text_sect	pointer
,	O
core_syms	pointer
,	O
addr	pointer
-	O
core_text_sect	pointer
->	O
vma	long
,	O
&	O
fname	pointer
,	O
&	O
func_name	pointer
,	O
(	O
unsigned	O
int	O
*	O
)	O
&	O
l	pointer
)	O
&&	O
fname	pointer
&&	O
func_name	pointer
&&	O
l	pointer
)	O
{	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[get_src_info] 0x%lx -> %s:%d (%s)\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
,	O
fname	pointer
,	O
l	pointer
,	O
func_name	pointer
)	O
)	O
;	O
*	O
filename	pointer
=	O
fname	pointer
;	O
*	O
name	pointer
=	O
func_name	pointer
;	O
*	O
line_num	int
=	O
l	pointer
;	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[get_src_info] no info for 0x%lx (%s:%d,%s)\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
,	O
fname	pointer
?	O
fname	pointer
:	O
"<unknown>"	pointer
,	O
l	pointer
,	O
func_name	pointer
?	O
func_name	pointer
:	O
"<unknown>"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
char	O
buf	pointer
[	O
BUFSIZE	O
]	O
;	O
static	O
char	O
address	long
[	O
BUFSIZE	O
]	O
;	O
static	O
char	O
name	pointer
[	O
BUFSIZE	O
]	O
;	O
static	O
unsigned	O
int	O
num_of_syms_in	function
(	O
FILE	struct
*	O
f	pointer
)	O
{	O
char	O
type	enum
;	O
unsigned	O
int	O
num	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	function
(	O
f	pointer
)	O
&&	O
fgets	function
(	O
buf	pointer
,	O
BUFSIZE	O
-	O
1	int
,	O
f	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
buf	pointer
,	O
"%"	pointer
STR_BUFSIZE	pointer
"s %c %"	pointer
STR_BUFSIZE	pointer
"s"	pointer
,	O
address	long
,	O
&	O
type	enum
,	O
name	pointer
)	O
==	O
3	int
)	O
if	O
(	O
type	enum
==	O
't'	O
||	O
type	enum
==	O
'T'	O
)	O
{	O
if	O
(	O
++	O
num	int
>=	O
UINT_MAX	O
/	O
sizeof	O
(	O
Sym	struct
)	O
)	O
return	O
-	O
1U	int
;	O
}	O
}	O
return	O
num	int
;	O
}	O
void	O
core_create_syms_from	function
(	O
const	O
char	O
*	O
sym_table_file	pointer
)	O
{	O
char	O
type	enum
;	O
bfd_vma	long
min_vma	long
=	O
~	O
(	O
bfd_vma	long
)	O
0	int
;	O
bfd_vma	long
max_vma	long
=	O
0	int
;	O
FILE	struct
*	O
f	pointer
;	O
f	pointer
=	O
fopen	function
(	O
sym_table_file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: could not open %s.\n"	pointer
)	O
,	O
whoami	pointer
,	O
sym_table_file	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
symtab	struct
.	O
len	long
=	O
num_of_syms_in	function
(	O
f	pointer
)	O
;	O
if	O
(	O
symtab	struct
.	O
len	long
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: file `%s' has no symbols\n"	pointer
)	O
,	O
whoami	pointer
,	O
sym_table_file	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
symtab	struct
.	O
len	long
==	O
-	O
1U	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: file `%s' has too many symbols\n"	pointer
)	O
,	O
whoami	pointer
,	O
sym_table_file	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
symtab	struct
.	O
base	int
=	O
(	O
Sym	struct
*	O
)	O
xmalloc	function
(	O
symtab	struct
.	O
len	long
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
symtab	struct
.	O
limit	pointer
=	O
symtab	struct
.	O
base	int
;	O
if	O
(	O
fseek	function
(	O
f	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
perror	function
(	O
sym_table_file	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
!	O
feof	function
(	O
f	pointer
)	O
&&	O
fgets	function
(	O
buf	pointer
,	O
BUFSIZE	O
-	O
1	int
,	O
f	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
buf	pointer
,	O
"%"	pointer
STR_BUFSIZE	pointer
"s %c %"	pointer
STR_BUFSIZE	pointer
"s"	pointer
,	O
address	long
,	O
&	O
type	enum
,	O
name	pointer
)	O
!=	O
3	int
)	O
continue	O
;	O
if	O
(	O
type	enum
!=	O
't'	O
&&	O
type	enum
!=	O
'T'	O
)	O
continue	O
;	O
sym_init	function
(	O
symtab	struct
.	O
limit	pointer
)	O
;	O
sscanf	function
(	O
address	long
,	O
"%"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
&	O
(	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
)	O
)	O
;	O
symtab	struct
.	O
limit	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
symtab	struct
.	O
limit	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
symtab	struct
.	O
limit	pointer
->	O
mapped	int
=	O
0	int
;	O
symtab	struct
.	O
limit	pointer
->	O
is_func	int
=	O
TRUE	int
;	O
symtab	struct
.	O
limit	pointer
->	O
is_bb_head	int
=	O
TRUE	int
;	O
symtab	struct
.	O
limit	pointer
->	O
is_static	int
=	O
(	O
type	enum
==	O
't'	O
)	O
;	O
min_vma	long
=	O
MIN	O
(	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
,	O
min_vma	long
)	O
;	O
max_vma	long
=	O
MAX	O
(	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
,	O
max_vma	long
)	O
;	O
++	O
symtab	struct
.	O
limit	pointer
;	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
symtab	struct
.	O
len	long
=	O
symtab	struct
.	O
limit	pointer
-	O
symtab	struct
.	O
base	int
;	O
symtab_finalize	function
(	O
&	O
symtab	struct
)	O
;	O
}	O
static	O
int	O
search_mapped_symbol	function
(	O
const	O
void	O
*	O
l	pointer
,	O
const	O
void	O
*	O
r	pointer
)	O
{	O
return	O
strcmp	function
(	O
(	O
const	O
char	O
*	O
)	O
l	pointer
,	O
(	O
(	O
const	O
struct	O
function_map	struct
*	O
)	O
r	pointer
)	O
->	O
function_name	pointer
)	O
;	O
}	O
void	O
core_create_function_syms	function
(	O
void	O
)	O
{	O
bfd_vma	long
min_vma	long
=	O
~	O
(	O
bfd_vma	long
)	O
0	int
;	O
bfd_vma	long
max_vma	long
=	O
0	int
;	O
int	O
cxxclass	int
;	O
long	O
i	pointer
;	O
struct	O
function_map	struct
*	O
found	pointer
=	O
NULL	O
;	O
int	O
core_has_func_syms	int
=	O
0	int
;	O
switch	O
(	O
core_bfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
)	O
{	O
default	O
:	O
break	O
;	O
case	O
bfd_target_coff_flavour	int
:	O
case	O
bfd_target_ecoff_flavour	int
:	O
case	O
bfd_target_xcoff_flavour	int
:	O
case	O
bfd_target_elf_flavour	int
:	O
case	O
bfd_target_som_flavour	int
:	O
core_has_func_syms	int
=	O
1	int
;	O
}	O
symtab	struct
.	O
len	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
core_num_syms	int
;	O
++	O
i	pointer
)	O
{	O
if	O
(	O
!	O
core_sym_class	function
(	O
core_syms	pointer
[	O
i	pointer
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
symbol_map_count	int
!=	O
0	int
)	O
{	O
found	pointer
=	O
(	O
struct	O
function_map	struct
*	O
)	O
bsearch	function
(	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
name	pointer
,	O
symbol_map	pointer
,	O
symbol_map_count	int
,	O
sizeof	O
(	O
struct	O
function_map	struct
)	O
,	O
search_mapped_symbol	function
)	O
;	O
}	O
if	O
(	O
found	pointer
==	O
NULL	O
||	O
found	pointer
->	O
is_first	int
)	O
++	O
symtab	struct
.	O
len	long
;	O
}	O
if	O
(	O
symtab	struct
.	O
len	long
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: file `%s' has no symbols\n"	pointer
)	O
,	O
whoami	pointer
,	O
a_out_name	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
symtab	struct
.	O
base	int
=	O
(	O
Sym	struct
*	O
)	O
xmalloc	function
(	O
symtab	struct
.	O
len	long
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
symtab	struct
.	O
limit	pointer
=	O
symtab	struct
.	O
base	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
core_num_syms	int
;	O
++	O
i	pointer
)	O
{	O
asection	struct
*	O
sym_sec	pointer
;	O
cxxclass	int
=	O
core_sym_class	function
(	O
core_syms	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
!	O
cxxclass	int
)	O
{	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[core_create_function_syms] rejecting: 0x%lx %s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
value	long
,	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
name	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
symbol_map_count	int
!=	O
0	int
)	O
{	O
found	pointer
=	O
(	O
struct	O
function_map	struct
*	O
)	O
bsearch	function
(	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
name	pointer
,	O
symbol_map	pointer
,	O
symbol_map_count	int
,	O
sizeof	O
(	O
struct	O
function_map	struct
)	O
,	O
search_mapped_symbol	function
)	O
;	O
}	O
if	O
(	O
found	pointer
&&	O
!	O
found	pointer
->	O
is_first	int
)	O
continue	O
;	O
sym_init	function
(	O
symtab	struct
.	O
limit	pointer
)	O
;	O
sym_sec	pointer
=	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
section	pointer
;	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
=	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
value	long
;	O
if	O
(	O
sym_sec	pointer
)	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
+=	O
bfd_section_vma	function
(	O
sym_sec	pointer
)	O
;	O
if	O
(	O
found	pointer
)	O
{	O
symtab	struct
.	O
limit	pointer
->	O
name	pointer
=	O
found	pointer
->	O
file_name	pointer
;	O
symtab	struct
.	O
limit	pointer
->	O
mapped	int
=	O
1	int
;	O
}	O
else	O
{	O
symtab	struct
.	O
limit	pointer
->	O
name	pointer
=	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
name	pointer
;	O
symtab	struct
.	O
limit	pointer
->	O
mapped	int
=	O
0	int
;	O
}	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
char	O
*	O
func_name	pointer
;	O
if	O
(	O
get_src_info	function
(	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
,	O
&	O
filename	pointer
,	O
&	O
func_name	pointer
,	O
&	O
symtab	struct
.	O
limit	pointer
->	O
line_num	int
)	O
)	O
{	O
symtab	struct
.	O
limit	pointer
->	O
file	pointer
=	O
source_file_lookup_path	function
(	O
filename	pointer
)	O
;	O
}	O
}	O
symtab	struct
.	O
limit	pointer
->	O
is_func	int
=	O
(	O
!	O
core_has_func_syms	int
||	O
(	O
core_syms	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
BSF_FUNCTION	O
)	O
!=	O
0	int
)	O
;	O
symtab	struct
.	O
limit	pointer
->	O
is_bb_head	int
=	O
TRUE	int
;	O
if	O
(	O
cxxclass	int
==	O
't'	O
)	O
symtab	struct
.	O
limit	pointer
->	O
is_static	int
=	O
TRUE	int
;	O
min_vma	long
=	O
MIN	O
(	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
,	O
min_vma	long
)	O
;	O
if	O
(	O
sym_sec	pointer
)	O
max_vma	long
=	O
MAX	O
(	O
bfd_section_vma	function
(	O
sym_sec	pointer
)	O
+	O
bfd_section_size	function
(	O
sym_sec	pointer
)	O
-	O
1	int
,	O
max_vma	long
)	O
;	O
else	O
max_vma	long
=	O
MAX	O
(	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
,	O
max_vma	long
)	O
;	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[core_create_function_syms] %ld %s 0x%lx\n"	pointer
,	O
(	O
long	O
)	O
(	O
symtab	struct
.	O
limit	pointer
-	O
symtab	struct
.	O
base	int
)	O
,	O
symtab	struct
.	O
limit	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
symtab	struct
.	O
limit	pointer
->	O
addr	pointer
)	O
)	O
;	O
++	O
symtab	struct
.	O
limit	pointer
;	O
}	O
symtab	struct
.	O
len	long
=	O
symtab	struct
.	O
limit	pointer
-	O
symtab	struct
.	O
base	int
;	O
symtab_finalize	function
(	O
&	O
symtab	struct
)	O
;	O
}	O
void	O
core_create_line_syms	function
(	O
void	O
)	O
{	O
char	O
*	O
prev_name	pointer
,	O
*	O
prev_filename	pointer
;	O
unsigned	O
int	O
prev_name_len	int
,	O
prev_filename_len	int
;	O
bfd_vma	long
vma	long
,	O
min_vma	long
=	O
~	O
(	O
bfd_vma	long
)	O
0	int
,	O
max_vma	long
=	O
0	int
;	O
Sym	struct
*	O
prev	pointer
,	O
dummy	array
,	O
*	O
sym	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
prev_line_num	int
;	O
Sym_Table	struct
ltab	struct
;	O
bfd_vma	long
vma_high	long
;	O
core_create_function_syms	function
(	O
)	O
;	O
prev_name_len	int
=	O
PATH_MAX	int
;	O
prev_filename_len	int
=	O
PATH_MAX	int
;	O
prev_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
prev_name_len	int
)	O
;	O
prev_filename	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
prev_filename_len	int
)	O
;	O
ltab	struct
.	O
len	long
=	O
0	int
;	O
prev_line_num	int
=	O
0	int
;	O
vma_high	long
=	O
core_text_sect	pointer
->	O
vma	long
+	O
bfd_section_size	function
(	O
core_text_sect	pointer
)	O
;	O
for	O
(	O
vma	long
=	O
core_text_sect	pointer
->	O
vma	long
;	O
vma	long
<	O
vma_high	long
;	O
vma	long
+=	O
min_insn_size	int
)	O
{	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
!	O
get_src_info	function
(	O
vma	long
,	O
&	O
filename	pointer
,	O
&	O
dummy	array
.	O
name	pointer
,	O
&	O
dummy	array
.	O
line_num	int
)	O
||	O
(	O
prev_line_num	int
==	O
dummy	array
.	O
line_num	int
&&	O
prev_name	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
prev_name	pointer
,	O
dummy	array
.	O
name	pointer
)	O
==	O
0	int
&&	O
filename_cmp	function
(	O
prev_filename	pointer
,	O
filename	pointer
)	O
==	O
0	int
)	O
)	O
continue	O
;	O
++	O
ltab	struct
.	O
len	long
;	O
prev_line_num	int
=	O
dummy	array
.	O
line_num	int
;	O
len	long
=	O
strlen	function
(	O
dummy	array
.	O
name	pointer
)	O
;	O
if	O
(	O
len	long
>=	O
prev_name_len	int
)	O
{	O
prev_name_len	int
=	O
len	long
+	O
1024	int
;	O
free	function
(	O
prev_name	pointer
)	O
;	O
prev_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
prev_name_len	int
)	O
;	O
}	O
strcpy	function
(	O
prev_name	pointer
,	O
dummy	array
.	O
name	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
len	long
>=	O
prev_filename_len	int
)	O
{	O
prev_filename_len	int
=	O
len	long
+	O
1024	int
;	O
free	function
(	O
prev_filename	pointer
)	O
;	O
prev_filename	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
prev_filename_len	int
)	O
;	O
}	O
strcpy	function
(	O
prev_filename	pointer
,	O
filename	pointer
)	O
;	O
min_vma	long
=	O
MIN	O
(	O
vma	long
,	O
min_vma	long
)	O
;	O
max_vma	long
=	O
MAX	O
(	O
vma	long
,	O
max_vma	long
)	O
;	O
}	O
free	function
(	O
prev_name	pointer
)	O
;	O
free	function
(	O
prev_filename	pointer
)	O
;	O
ltab	struct
.	O
len	long
+=	O
symtab	struct
.	O
len	long
;	O
ltab	struct
.	O
base	int
=	O
(	O
Sym	struct
*	O
)	O
xmalloc	function
(	O
ltab	struct
.	O
len	long
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
ltab	struct
.	O
limit	pointer
=	O
ltab	struct
.	O
base	int
;	O
prev	pointer
=	O
0	int
;	O
for	O
(	O
vma	long
=	O
core_text_sect	pointer
->	O
vma	long
;	O
vma	long
<	O
vma_high	long
;	O
vma	long
+=	O
min_insn_size	int
)	O
{	O
sym_init	function
(	O
ltab	struct
.	O
limit	pointer
)	O
;	O
if	O
(	O
!	O
get_src_info	function
(	O
vma	long
,	O
&	O
filename	pointer
,	O
&	O
ltab	struct
.	O
limit	pointer
->	O
name	pointer
,	O
&	O
ltab	struct
.	O
limit	pointer
->	O
line_num	int
)	O
||	O
(	O
prev	pointer
&&	O
prev	pointer
->	O
line_num	int
==	O
ltab	struct
.	O
limit	pointer
->	O
line_num	int
&&	O
strcmp	function
(	O
prev	pointer
->	O
name	pointer
,	O
ltab	struct
.	O
limit	pointer
->	O
name	pointer
)	O
==	O
0	int
&&	O
filename_cmp	function
(	O
prev	pointer
->	O
file	pointer
->	O
name	pointer
,	O
filename	pointer
)	O
==	O
0	int
)	O
)	O
continue	O
;	O
ltab	struct
.	O
limit	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
ltab	struct
.	O
limit	pointer
->	O
name	pointer
)	O
;	O
ltab	struct
.	O
limit	pointer
->	O
file	pointer
=	O
source_file_lookup_path	function
(	O
filename	pointer
)	O
;	O
ltab	struct
.	O
limit	pointer
->	O
addr	pointer
=	O
vma	long
;	O
if	O
(	O
prev	pointer
&&	O
ltab	struct
.	O
limit	pointer
->	O
file	pointer
==	O
prev	pointer
->	O
file	pointer
&&	O
strcmp	function
(	O
ltab	struct
.	O
limit	pointer
->	O
name	pointer
,	O
prev	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
ltab	struct
.	O
limit	pointer
->	O
is_static	int
=	O
prev	pointer
->	O
is_static	int
;	O
}	O
else	O
{	O
sym	pointer
=	O
sym_lookup	function
(	O
&	O
symtab	struct
,	O
ltab	struct
.	O
limit	pointer
->	O
addr	pointer
)	O
;	O
if	O
(	O
sym	pointer
)	O
ltab	struct
.	O
limit	pointer
->	O
is_static	int
=	O
sym	pointer
->	O
is_static	int
;	O
}	O
prev	pointer
=	O
ltab	struct
.	O
limit	pointer
;	O
DBG	O
(	O
AOUTDEBUG	O
,	O
printf	function
(	O
"[core_create_line_syms] %lu %s 0x%lx\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
ltab	struct
.	O
limit	pointer
-	O
ltab	struct
.	O
base	int
)	O
,	O
ltab	struct
.	O
limit	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
ltab	struct
.	O
limit	pointer
->	O
addr	pointer
)	O
)	O
;	O
++	O
ltab	struct
.	O
limit	pointer
;	O
}	O
memcpy	function
(	O
ltab	struct
.	O
limit	pointer
,	O
symtab	struct
.	O
base	int
,	O
symtab	struct
.	O
len	long
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
ltab	struct
.	O
limit	pointer
+=	O
symtab	struct
.	O
len	long
;	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
ltab	struct
.	O
limit	pointer
-	O
ltab	struct
.	O
base	int
)	O
!=	O
ltab	struct
.	O
len	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: somebody miscounted: ltab.len=%d instead of %ld\n"	pointer
)	O
,	O
whoami	pointer
,	O
ltab	struct
.	O
len	long
,	O
(	O
long	O
)	O
(	O
ltab	struct
.	O
limit	pointer
-	O
ltab	struct
.	O
base	int
)	O
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
symtab_finalize	function
(	O
&	O
ltab	struct
)	O
;	O
free	function
(	O
symtab	struct
.	O
base	int
)	O
;	O
symtab	struct
=	O
ltab	struct
;	O
}	O
