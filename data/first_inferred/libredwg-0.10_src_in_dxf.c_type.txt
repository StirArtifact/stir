Dwg_Object	struct
*	O
dwg_obj_generic_to_object	function
(	O
const	O
void	O
*	O
restrict	O
obj	pointer
,	O
int	O
*	O
restrict	O
error	int
)	O
;	O
static	O
unsigned	O
int	O
loglevel	int
;	O
BITCODE_H	pointer
dwg_find_tablehandle_silent	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
const	O
char	O
*	O
restrict	O
table	pointer
)	O
;	O
static	O
unsigned	O
int	O
cur_ver	int
=	O
0	int
;	O
static	O
char	O
buf	array
[	O
4096	int
]	O
;	O
static	O
long	O
start	struct
,	O
end	struct
;	O
static	O
array_hdls	struct
*	O
header_hdls	pointer
=	O
NULL	O
;	O
static	O
array_hdls	struct
*	O
eed_hdls	pointer
=	O
NULL	O
;	O
static	O
array_hdls	struct
*	O
obj_hdls	pointer
=	O
NULL	O
;	O
static	O
long	O
num_dxf_objs	long
;	O
static	O
long	O
size_dxf_objs	long
;	O
static	O
Dxf_Objs	struct
*	O
dxf_objs	pointer
;	O
static	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	pointer
)	O
{	O
void	O
*	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"ERROR: Out of memory with calloc %ld * %ld\n"	pointer
,	O
(	O
long	O
)	O
n	long
,	O
(	O
long	O
)	O
s	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
inline	O
void	O
dxf_skip_ws	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
is_binary	int
)	O
return	O
;	O
for	O
(	O
;	O
(	O
!	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
||	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
' '	O
||	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\t'	O
||	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\r'	O
)	O
;	O
dat	pointer
->	O
byte	char
++	O
)	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
dat	pointer
->	O
size	char
)	O
return	O
;	O
}	O
static	O
BITCODE_RS	short
dxf_read_rs	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
is_binary	int
)	O
{	O
return	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
endptr	pointer
;	O
long	O
num	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
(	O
BITCODE_RS	short
)	O
-	O
1	int
;	O
num	long
=	O
strtol	function
(	O
(	O
char	O
*	O
)	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endptr	pointer
)	O
dat	pointer
->	O
byte	char
+=	O
(	O
unsigned	O
char	O
*	O
)	O
endptr	pointer
-	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
return	O
(	O
BITCODE_RS	short
)	O
num	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
1	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
(	O
BITCODE_RS	short
)	O
num	long
;	O
if	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\r'	O
)	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\n'	O
)	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
num	long
>	O
65534	int
)	O
LOG_ERROR	O
(	O
"%s: RS overflow %ld (at %lu)"	pointer
,	O
__FUNCTION__	O
,	O
num	long
,	O
dat	pointer
->	O
byte	char
)	O
;	O
return	O
(	O
BITCODE_RS	short
)	O
num	long
;	O
}	O
}	O
static	O
BITCODE_RL	int
dxf_read_rl	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
is_binary	int
)	O
{	O
return	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
endptr	pointer
;	O
long	O
num	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
(	O
BITCODE_RL	int
)	O
-	O
1	int
;	O
num	long
=	O
strtol	function
(	O
(	O
char	O
*	O
)	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endptr	pointer
)	O
dat	pointer
->	O
byte	char
+=	O
(	O
unsigned	O
char	O
*	O
)	O
endptr	pointer
-	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
return	O
(	O
BITCODE_RL	int
)	O
num	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
1	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
0	int
;	O
if	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\r'	O
)	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\n'	O
)	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
num	long
>	O
INT_MAX	O
)	O
LOG_ERROR	O
(	O
"%s: RL overflow %ld (at %lu)"	pointer
,	O
__FUNCTION__	O
,	O
num	long
,	O
dat	pointer
->	O
byte	char
)	O
;	O
return	O
(	O
BITCODE_RL	int
)	O
num	long
;	O
}	O
}	O
static	O
BITCODE_RLL	long
dxf_read_rll	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
is_binary	int
)	O
{	O
return	O
bit_read_RLL	function
(	O
dat	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
endptr	pointer
;	O
BITCODE_RLL	long
num	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
(	O
BITCODE_RLL	long
)	O
-	O
1	int
;	O
num	long
=	O
strtol	function
(	O
(	O
char	O
*	O
)	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endptr	pointer
)	O
dat	pointer
->	O
byte	char
+=	O
(	O
unsigned	O
char	O
*	O
)	O
endptr	pointer
-	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
return	O
(	O
BITCODE_RLL	long
)	O
num	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
1	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
0L	int
;	O
if	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\r'	O
)	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
==	O
'\n'	O
)	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
num	long
>	O
LONG_MAX	O
)	O
LOG_ERROR	O
(	O
"%s: long overflow %ld (at %lu)"	pointer
,	O
__FUNCTION__	O
,	O
(	O
long	O
)	O
num	long
,	O
dat	pointer
->	O
byte	char
)	O
;	O
return	O
num	long
;	O
}	O
}	O
static	O
BITCODE_RD	double
dxf_read_rd	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
is_binary	int
)	O
{	O
return	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
str	struct
,	O
*	O
endptr	pointer
;	O
BITCODE_RD	double
num	long
;	O
dxf_skip_ws	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
>=	O
dat	pointer
->	O
size	char
)	O
return	O
NAN	O
;	O
str	struct
=	O
(	O
char	O
*	O
)	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
;	O
num	long
=	O
strtod	function
(	O
str	struct
,	O
&	O
endptr	pointer
)	O
;	O
if	O
(	O
endptr	pointer
)	O
dat	pointer
->	O
byte	char
+=	O
endptr	pointer
-	O
str	struct
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
return	O
NAN	O
;	O
return	O
num	long
;	O
}	O
}	O
static	O
void	O
dxf_read_string	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
char	O
*	O
*	O
string	array
)	O
{	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
is_binary	int
)	O
{	O
int	O
len	long
=	O
dxf_read_rs	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
len	long
>=	O
dat	pointer
->	O
size	char
)	O
return	O
;	O
if	O
(	O
!	O
string	array
)	O
{	O
if	O
(	O
len	long
>	O
4096	int
)	O
return	O
;	O
memcpy	function
(	O
buf	array
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
len	long
)	O
;	O
buf	array
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
*	O
string	array
)	O
*	O
string	array
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
else	O
*	O
string	array
=	O
realloc	function
(	O
*	O
string	array
,	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
*	O
string	array
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
len	long
)	O
;	O
}	O
else	O
{	O
int	O
i	int
;	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
dat	pointer
->	O
size	char
)	O
return	O
;	O
dxf_skip_ws	function
(	O
dat	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
dat	pointer
->	O
byte	char
<	O
dat	pointer
->	O
size	char
&&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
!=	O
'\n'	O
&&	O
i	int
<	O
4096	int
;	O
dat	pointer
->	O
byte	char
++	O
)	O
{	O
buf	array
[	O
i	int
++	O
]	O
=	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
;	O
}	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
dat	pointer
->	O
size	char
||	O
i	int
>=	O
4096	int
)	O
return	O
;	O
if	O
(	O
i	int
&&	O
buf	array
[	O
i	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
buf	array
[	O
i	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
else	O
buf	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
dat	pointer
->	O
byte	char
++	O
;	O
if	O
(	O
!	O
string	array
)	O
return	O
;	O
if	O
(	O
!	O
*	O
string	array
)	O
*	O
string	array
=	O
malloc	function
(	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
;	O
else	O
*	O
string	array
=	O
realloc	function
(	O
*	O
string	array
,	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
*	O
string	array
,	O
buf	array
)	O
;	O
}	O
}	O
static	O
void	O
dxf_free_pair	function
(	O
Dxf_Pair	struct
*	O
pair	pointer
)	O
{	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
;	O
if	O
(	O
pair	pointer
->	O
type	short
==	O
VT_STRING	int
||	O
pair	pointer
->	O
type	short
==	O
VT_BINARY	int
)	O
{	O
free	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
pair	pointer
->	O
value	double
.	O
s	pointer
=	O
NULL	O
;	O
}	O
free	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
NULL	O
;	O
}	O
static	O
Dxf_Pair	struct
*	O
ATTRIBUTE_MALLOC	O
dxf_read_pair	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dxf_Pair	struct
)	O
)	O
;	O
const	O
int	O
is_binary	int
=	O
dat	pointer
->	O
opts	int
&	O
DWG_OPTS_DXFB	int
;	O
if	O
(	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
<	O
6	int
)	O
{	O
err	O
:	O
LOG_ERROR	O
(	O
"Unexpected DXF end-of-file"	pointer
)	O
;	O
free	function
(	O
pair	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
pair	pointer
->	O
code	char
=	O
(	O
short	O
)	O
dxf_read_rs	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
<	O
4	int
)	O
goto	O
err	O
;	O
pair	pointer
->	O
type	short
=	O
get_base_value_type	function
(	O
pair	pointer
->	O
code	char
)	O
;	O
switch	O
(	O
pair	pointer
->	O
type	short
)	O
{	O
case	O
VT_STRING	int
:	O
dxf_read_string	function
(	O
dat	pointer
,	O
&	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"  dxf (%d, \"%s\")\n"	pointer
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
break	O
;	O
case	O
VT_BOOL	int
:	O
case	O
VT_INT8	int
:	O
case	O
VT_INT16	int
:	O
pair	pointer
->	O
value	double
.	O
i	int
=	O
dxf_read_rs	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"  dxf (%d, %d)\n"	pointer
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
break	O
;	O
case	O
VT_INT32	int
:	O
pair	pointer
->	O
value	double
.	O
l	long
=	O
dxf_read_rl	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"  dxf (%d, %ld)\n"	pointer
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
break	O
;	O
case	O
VT_INT64	int
:	O
pair	pointer
->	O
value	double
.	O
bll	long
=	O
dxf_read_rll	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"  dxf (%d, "	pointer
FORMAT_BLL	O
")\n"	pointer
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
bll	long
)	O
;	O
break	O
;	O
case	O
VT_REAL	int
:	O
case	O
VT_POINT3D	int
:	O
dxf_skip_ws	function
(	O
dat	pointer
)	O
;	O
pair	pointer
->	O
value	double
.	O
d	double
=	O
dxf_read_rd	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"  dxf (%d, %f)\n"	pointer
,	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
VT_BINARY	int
:	O
dxf_read_string	function
(	O
dat	pointer
,	O
&	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"  dxf (%d, %s)\n"	pointer
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
break	O
;	O
case	O
VT_HANDLE	int
:	O
case	O
VT_OBJECTID	int
:	O
if	O
(	O
is_binary	int
)	O
{	O
pair	pointer
->	O
value	double
.	O
u	union
=	O
dxf_read_rl	function
(	O
dat	pointer
)	O
;	O
}	O
else	O
{	O
dxf_read_string	function
(	O
dat	pointer
,	O
NULL	O
)	O
;	O
sscanf	function
(	O
buf	array
,	O
"%X"	pointer
,	O
&	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
}	O
LOG_TRACE	O
(	O
"  dxf (%d, %X)\n"	pointer
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
break	O
;	O
case	O
VT_INVALID	int
:	O
default	O
:	O
LOG_ERROR	O
(	O
"Invalid DXF group code: %d"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
dxf_skip_comment	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
pair	pointer
)	O
{	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
999	int
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_RETURN_EOF	O
(	O
pair	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
array_hdls	struct
*	O
array_push	function
(	O
array_hdls	struct
*	O
restrict	O
hdls	pointer
,	O
const	O
char	O
*	O
restrict	O
field	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
const	O
int	O
code	char
)	O
{	O
uint32_t	int
i	int
=	O
hdls	pointer
->	O
nitems	int
;	O
if	O
(	O
i	int
>=	O
hdls	pointer
->	O
size	char
)	O
{	O
hdls	pointer
->	O
size	char
+=	O
16	int
;	O
hdls	pointer
=	O
realloc	function
(	O
hdls	pointer
,	O
8	int
+	O
(	O
hdls	pointer
->	O
size	char
*	O
sizeof	O
(	O
struct	O
array_hdl	struct
)	O
)	O
)	O
;	O
}	O
hdls	pointer
->	O
nitems	int
=	O
i	int
+	O
1	int
;	O
hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
field	pointer
=	O
strdup	function
(	O
field	pointer
)	O
;	O
hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
code	char
=	O
code	char
;	O
return	O
hdls	pointer
;	O
}	O
array_hdls	struct
*	O
new_array_hdls	function
(	O
int	O
size	char
)	O
{	O
array_hdls	struct
*	O
hdls	pointer
=	O
xcalloc	function
(	O
1	int
,	O
8	int
+	O
size	char
*	O
sizeof	O
(	O
struct	O
array_hdl	struct
)	O
)	O
;	O
hdls	pointer
->	O
size	char
=	O
size	char
;	O
return	O
hdls	pointer
;	O
}	O
void	O
free_array_hdls	function
(	O
array_hdls	struct
*	O
hdls	pointer
)	O
{	O
for	O
(	O
uint32_t	int
i	int
=	O
0	int
;	O
i	int
<	O
hdls	pointer
->	O
nitems	int
;	O
i	int
++	O
)	O
{	O
free	function
(	O
hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
field	pointer
)	O
;	O
free	function
(	O
hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
}	O
free	function
(	O
hdls	pointer
)	O
;	O
}	O
static	O
Dxf_Pair	struct
*	O
dxf_expect_code	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
,	O
int	O
code	char
)	O
{	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
code	char
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
dxf_skip_comment	function
(	O
dat	pointer
,	O
pair	pointer
)	O
;	O
DXF_RETURN_EOF	O
(	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
&&	O
pair	pointer
->	O
code	char
!=	O
code	char
)	O
{	O
LOG_ERROR	O
(	O
"Expecting DXF code %d, got %d (at %lu)"	pointer
,	O
code	char
,	O
pair	pointer
->	O
code	char
,	O
dat	pointer
->	O
byte	char
)	O
;	O
}	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
int	O
matches_type	function
(	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
,	O
const	O
Dwg_DYNAPI_field	struct
*	O
restrict	O
f	pointer
)	O
{	O
switch	O
(	O
pair	pointer
->	O
type	short
)	O
{	O
case	O
VT_STRING	int
:	O
if	O
(	O
f	pointer
->	O
is_string	short
)	O
return	O
1	int
;	O
if	O
(	O
f	pointer
->	O
type	short
[	O
0	int
]	O
==	O
'H'	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
VT_INT64	int
:	O
if	O
(	O
f	pointer
->	O
size	char
==	O
8	int
&&	O
f	pointer
->	O
type	short
[	O
1	int
]	O
==	O
'L'	O
&&	O
f	pointer
->	O
type	short
[	O
2	int
]	O
==	O
'L'	O
)	O
return	O
1	int
;	O
case	O
VT_INT32	int
:	O
if	O
(	O
f	pointer
->	O
size	char
==	O
4	int
&&	O
f	pointer
->	O
type	short
[	O
1	int
]	O
==	O
'L'	O
)	O
return	O
1	int
;	O
case	O
VT_INT16	int
:	O
if	O
(	O
f	pointer
->	O
size	char
==	O
2	int
&&	O
f	pointer
->	O
type	short
[	O
1	int
]	O
==	O
'S'	O
)	O
return	O
1	int
;	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"CMC"	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"BSd"	pointer
)	O
)	O
return	O
1	int
;	O
case	O
VT_INT8	int
:	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"RC"	pointer
)	O
)	O
return	O
1	int
;	O
case	O
VT_BOOL	int
:	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"B"	pointer
)	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
VT_REAL	int
:	O
if	O
(	O
f	pointer
->	O
size	char
==	O
8	int
&&	O
f	pointer
->	O
type	short
[	O
1	int
]	O
==	O
'D'	O
)	O
return	O
1	int
;	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"TIMEBLL"	pointer
)	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
VT_POINT3D	int
:	O
if	O
(	O
f	pointer
->	O
size	char
==	O
24	int
&&	O
(	O
f	pointer
->	O
type	short
[	O
0	int
]	O
==	O
'3'	O
||	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"BE"	pointer
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
f	pointer
->	O
size	char
==	O
16	int
&&	O
f	pointer
->	O
type	short
[	O
0	int
]	O
==	O
'2'	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
VT_BINARY	int
:	O
if	O
(	O
f	pointer
->	O
is_string	short
)	O
return	O
1	int
;	O
break	O
;	O
case	O
VT_HANDLE	int
:	O
case	O
VT_OBJECTID	int
:	O
if	O
(	O
f	pointer
->	O
type	short
[	O
0	int
]	O
==	O
'H'	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
VT_INVALID	int
:	O
default	O
:	O
LOG_ERROR	O
(	O
"Invalid DXF group code: %d"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
return	O
0	int
;	O
}	O
BITCODE_RC	char
dxf_find_lweight	function
(	O
const	O
int	O
lw	int
)	O
{	O
const	O
int	O
lweights	array
[	O
]	O
=	O
{	O
0	int
,	O
5	int
,	O
9	int
,	O
13	int
,	O
15	int
,	O
18	int
,	O
20	int
,	O
25	int
,	O
30	int
,	O
35	int
,	O
40	int
,	O
50	int
,	O
53	int
,	O
60	int
,	O
70	int
,	O
80	int
,	O
90	int
,	O
100	int
,	O
106	int
,	O
120	int
,	O
140	int
,	O
158	int
,	O
200	int
,	O
211	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
-	O
1	int
,	O
-	O
2	int
,	O
-	O
3	int
}	O
;	O
for	O
(	O
int	O
i	int
=	O
0	int
;	O
i	int
<	O
32	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
lweights	array
[	O
i	int
]	O
==	O
lw	int
)	O
return	O
i	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dxf_header_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Header_Variables	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
int	O
is_utf	int
=	O
1	int
;	O
int	O
i	int
=	O
0	int
;	O
Dxf_Pair	struct
*	O
pair	pointer
;	O
_obj	pointer
->	O
ISOLINES	short
=	O
4	int
;	O
_obj	pointer
->	O
TEXTQLTY	short
=	O
50	int
;	O
_obj	pointer
->	O
FACETRES	double
=	O
0.5	int
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
9	int
)	O
{	O
char	O
field	pointer
[	O
80	int
]	O
;	O
strncpy	function
(	O
field	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
79	int
)	O
;	O
field	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
i	int
=	O
0	int
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
1	int
;	O
}	O
DXF_BREAK_ENDSEC	O
;	O
next_hdrvalue	O
:	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
1	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"$ACADVER"	pointer
)	O
&&	O
pair	pointer
->	O
value	double
.	O
s	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
version	short
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
for	O
(	O
Dwg_Version_Type	enum
v	enum
=	O
0	int
;	O
v	enum
<=	O
R_AFTER	int
;	O
v	enum
++	O
)	O
{	O
if	O
(	O
strEQ	O
(	O
version	short
,	O
version_codes	array
[	O
v	enum
]	O
)	O
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
version	short
=	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
=	O
v	enum
;	O
dat	pointer
->	O
version	short
=	O
dat	pointer
->	O
from_version	enum
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
is_utf	int
=	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
;	O
LOG_TRACE	O
(	O
"HEADER.version = dat->version = %s\n"	pointer
,	O
version	short
)	O
;	O
if	O
(	O
is_utf	int
&&	O
dwg	pointer
->	O
num_objects	int
&&	O
dwg	pointer
->	O
object	pointer
[	O
0	int
]	O
.	O
fixedtype	enum
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_o	pointer
=	O
dwg	pointer
->	O
object	pointer
[	O
0	int
]	O
.	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
free	function
(	O
_o	pointer
->	O
name	pointer
)	O
;	O
_o	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bit_utf8_to_TU	function
(	O
(	O
char	O
*	O
)	O
"*Model_Space"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
v	enum
==	O
R_AFTER	int
)	O
LOG_ERROR	O
(	O
"Invalid HEADER: 9 %s, 1 %s"	pointer
,	O
field	pointer
,	O
version	short
)	O
}	O
}	O
else	O
if	O
(	O
field	pointer
[	O
0	int
]	O
==	O
'$'	O
)	O
{	O
const	O
Dwg_DYNAPI_field	struct
*	O
f	pointer
=	O
dwg_dynapi_header_field	function
(	O
&	O
field	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
40	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"$3DDWFPREC"	pointer
)	O
)	O
{	O
LOG_TRACE	O
(	O
"HEADER.%s [%s %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
"BD"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg	pointer
->	O
header_vars	struct
.	O
_3DDWFPREC	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
SUMMARY_T	O
(	O
TITLE	pointer
)	O
else	O
if	O
SUMMARY_T	O
(	O
AUTHOR	pointer
)	O
else	O
if	O
SUMMARY_T	O
(	O
SUBJECT	pointer
)	O
else	O
if	O
SUMMARY_T	O
(	O
KEYWORDS	pointer
)	O
else	O
if	O
SUMMARY_T	O
(	O
COMMENTS	pointer
)	O
else	O
if	O
SUMMARY_T	O
(	O
LASTSAVEDBY	pointer
)	O
else	O
LOG_ERROR	O
(	O
"skipping HEADER: 9 %s, unknown field with code %d"	pointer
,	O
field	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
!	O
matches_type	function
(	O
pair	pointer
,	O
f	pointer
)	O
&&	O
strNE	O
(	O
field	pointer
,	O
"$XCLIPFRAME"	pointer
)	O
&&	O
strNE	O
(	O
field	pointer
,	O
"$TIMEZONE"	pointer
)	O
)	O
{	O
LOG_ERROR	O
(	O
"skipping HEADER: 9 %s, wrong type code %d <=> field %s"	pointer
,	O
field	pointer
,	O
pair	pointer
->	O
code	char
,	O
f	pointer
->	O
type	short
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
type	short
==	O
VT_POINT3D	int
)	O
{	O
BITCODE_3BD	struct
pt	array
=	O
{	O
0.0	int
,	O
0.0	int
,	O
0.0	int
}	O
;	O
if	O
(	O
i	int
)	O
dwg_dynapi_header_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
pt	array
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
pt	array
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
i	int
==	O
1	int
)	O
pt	array
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
i	int
==	O
2	int
)	O
pt	array
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
LOG_ERROR	O
(	O
"skipping HEADER: 9 %s, too many point elements"	pointer
,	O
field	pointer
)	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"HEADER.%s [%s %d][%d] = %f\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
pt	array
,	O
1	int
)	O
;	O
i	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
type	short
==	O
VT_STRING	int
&&	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"H"	pointer
)	O
)	O
{	O
char	O
*	O
key	pointer
,	O
*	O
str	struct
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
&&	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
)	O
{	O
LOG_TRACE	O
(	O
"HEADER.%s %s [%s %d] later\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
f	pointer
->	O
type	short
,	O
(	O
int	O
)	O
pair	pointer
->	O
code	char
)	O
;	O
header_hdls	pointer
=	O
array_push	function
(	O
header_hdls	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
BITCODE_H	pointer
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
0	int
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s NULL 5 [H %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
hdl	array
,	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"H"	pointer
)	O
)	O
{	O
BITCODE_H	pointer
hdl	array
;	O
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s %X [H %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
hdl	array
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"CMC"	pointer
)	O
)	O
{	O
static	O
BITCODE_CMC	struct
color	short
=	O
{	O
0	int
}	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
<=	O
70	int
)	O
{	O
LOG_TRACE	O
(	O
"HEADER.%s.index %d [CMC %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
color	short
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
type	short
==	O
VT_REAL	int
&&	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"TIMEBLL"	pointer
)	O
)	O
{	O
static	O
BITCODE_TIMEBLL	struct
date	struct
=	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
unsigned	O
long	O
j	long
=	O
1	int
;	O
double	O
ms	int
;	O
date	struct
.	O
value	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
date	struct
.	O
days	int
=	O
(	O
BITCODE_BL	int
)	O
trunc	function
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
ms	int
=	O
date	struct
.	O
value	double
;	O
while	O
(	O
ms	int
>	O
1.0	int
)	O
{	O
j	long
*=	O
10	int
;	O
ms	int
/=	O
10.0	int
;	O
}	O
date	struct
.	O
ms	int
=	O
(	O
BITCODE_BL	int
)	O
(	O
j	long
/	O
10	int
*	O
(	O
date	struct
.	O
value	double
-	O
date	struct
.	O
days	int
)	O
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s %f (%u, %u) [TIMEBLL %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
date	struct
.	O
value	double
,	O
date	struct
.	O
days	int
,	O
date	struct
.	O
ms	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
date	struct
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
type	short
==	O
VT_STRING	int
)	O
{	O
LOG_TRACE	O
(	O
"HEADER.%s [%s %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"HEADER.%s [%s %d]\n"	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
&	O
field	pointer
[	O
1	int
]	O
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"skipping HEADER: 9 %s, missing the $"	pointer
,	O
field	pointer
)	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
1	int
;	O
}	O
DXF_BREAK_ENDSEC	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
!=	O
9	int
)	O
goto	O
next_hdrvalue	O
;	O
}	O
SINCE	O
(	O
R_2000	int
)	O
{	O
_obj	pointer
->	O
CELWEIGHT	short
=	O
dxf_revcvt_lweight	function
(	O
_obj	pointer
->	O
CELWEIGHT	short
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s => %d\n"	pointer
,	O
"CELWEIGHT"	pointer
,	O
_obj	pointer
->	O
CELWEIGHT	short
)	O
;	O
_obj	pointer
->	O
FLAGS	int
=	O
(	O
_obj	pointer
->	O
CELWEIGHT	short
&	O
0x1f	int
)	O
|	O
(	O
_obj	pointer
->	O
ENDCAPS	char
?	O
0x60	int
:	O
0	int
)	O
|	O
(	O
_obj	pointer
->	O
JOINSTYLE	char
?	O
0x180	int
:	O
0	int
)	O
|	O
(	O
_obj	pointer
->	O
LWDISPLAY	char
?	O
0	int
:	O
0x200	int
)	O
|	O
(	O
_obj	pointer
->	O
XEDIT	char
?	O
0	int
:	O
0x400	int
)	O
|	O
(	O
_obj	pointer
->	O
EXTNAMES	char
?	O
0x800	int
:	O
0	int
)	O
|	O
(	O
_obj	pointer
->	O
PSTYLEMODE	char
?	O
0x2000	int
:	O
0	int
)	O
|	O
(	O
_obj	pointer
->	O
OLESTARTUP	char
?	O
0x4000	int
:	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s => 0x%x\n"	pointer
,	O
"FLAGS"	pointer
,	O
(	O
unsigned	O
)	O
_obj	pointer
->	O
FLAGS	int
)	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
dxf_fixup_header	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
Dwg_Header_Variables	struct
*	O
vars	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
struct	O
Dwg_Header	struct
*	O
hdr	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
;	O
LOG_TRACE	O
(	O
"dxf_fixup_header\n"	pointer
)	O
;	O
if	O
(	O
vars	pointer
->	O
HANDSEED	pointer
)	O
vars	pointer
->	O
HANDSEED	pointer
->	O
handleref	struct
.	O
code	char
=	O
0	int
;	O
if	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
)	O
{	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1252"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
30	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"UTF-8"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
30	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"US_ASCII"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
1	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-1"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
2	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-2"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
3	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-3"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
4	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-4"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
5	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-5"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
6	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-6"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
7	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-7"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
8	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-8"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
9	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ISO-8859-9"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
10	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP437"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
11	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP850"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
12	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP852"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
13	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP855"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
14	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP857"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
15	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP860"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
16	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP861"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
17	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP863"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
18	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP864"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
19	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP865"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
20	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP869"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
21	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP932"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
22	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"MACINTOSH"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
23	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"BIG5"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
24	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP949"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
25	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"JOHAB"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
27	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"CP866"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
27	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1250"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
28	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1251"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
29	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"GB2312"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
31	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1253"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
32	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1254"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
33	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1255"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
34	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1256"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
35	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1257"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
36	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_874"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
37	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_932"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
38	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_936"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
39	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_949"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
40	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_950"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
41	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1258"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
44	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1361"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
42	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"UTF-16"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
43	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
vars	pointer
->	O
DWGCODEPAGE	pointer
,	O
"ANSI_1258"	pointer
)	O
)	O
hdr	pointer
->	O
codepage	int
=	O
44	int
;	O
else	O
hdr	pointer
->	O
codepage	int
=	O
0	int
;	O
}	O
LOG_TRACE	O
(	O
"HEADER.codepage = %d [%s]\n"	pointer
,	O
hdr	pointer
->	O
codepage	int
,	O
vars	pointer
->	O
DWGCODEPAGE	pointer
)	O
;	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_14	int
)	O
hdr	pointer
->	O
is_maint	char
=	O
0x0	int
;	O
else	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_2000	int
)	O
{	O
hdr	pointer
->	O
is_maint	char
=	O
0xf	int
;	O
hdr	pointer
->	O
zero_one_or_three	char
=	O
1	int
;	O
hdr	pointer
->	O
thumbnail_address	int
=	O
220	int
;	O
hdr	pointer
->	O
dwg_version	int
=	O
0x21	int
;	O
hdr	pointer
->	O
maint_version	int
=	O
0x8	int
;	O
}	O
else	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_2004	int
)	O
hdr	pointer
->	O
is_maint	char
=	O
0x68	int
;	O
else	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_2007	int
)	O
hdr	pointer
->	O
is_maint	char
=	O
0x32	int
;	O
else	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_2010	int
)	O
hdr	pointer
->	O
is_maint	char
=	O
0x6d	int
;	O
else	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_2013	int
)	O
hdr	pointer
->	O
is_maint	char
=	O
0x7d	int
;	O
else	O
if	O
(	O
hdr	pointer
->	O
version	short
<=	O
R_2018	int
)	O
hdr	pointer
->	O
is_maint	char
=	O
0x4	int
;	O
if	O
(	O
!	O
vars	pointer
->	O
FINGERPRINTGUID	pointer
)	O
vars	pointer
->	O
FINGERPRINTGUID	pointer
=	O
strdup	function
(	O
"{00000000-0000-0000-0000-000000000000}"	pointer
)	O
;	O
if	O
(	O
!	O
vars	pointer
->	O
VERSIONGUID	pointer
)	O
vars	pointer
->	O
VERSIONGUID	pointer
=	O
strdup	function
(	O
"{DE6A95C3-2D01-4A77-AC28-3C42FCFFF657}"	pointer
)	O
;	O
}	O
static	O
int	O
dxf_classes_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_BL	int
i	int
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
Dwg_Class	struct
*	O
klass	pointer
;	O
while	O
(	O
pair	pointer
)	O
{	O
i	int
=	O
dwg	pointer
->	O
num_classes	short
;	O
if	O
(	O
i	int
==	O
0	int
)	O
dwg	pointer
->	O
dwg_class	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
else	O
dwg	pointer
->	O
dwg_class	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
dwg_class	pointer
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dwg_class	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
restart	O
:	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
memset	function
(	O
klass	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
if	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
&&	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CLASS"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
1	int
;	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"2 CLASSES must be followed by 0 CLASS"	pointer
)	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
klass	pointer
->	O
number	short
=	O
500	int
+	O
i	int
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
1	int
:	O
{	O
const	O
char	O
*	O
n	long
=	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ACDBDATATABLE"	pointer
)	O
?	O
"DATATABLE"	pointer
:	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
if	O
(	O
klass	pointer
->	O
dxfname	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Group 1 for CLASS %s already read"	pointer
,	O
klass	pointer
->	O
dxfname	pointer
)	O
;	O
break	O
;	O
}	O
STRADD	O
(	O
klass	pointer
->	O
dxfname	pointer
,	O
n	long
)	O
;	O
LOG_TRACE	O
(	O
"CLASS[%d].dxfname = %s [TV 1]\n"	pointer
,	O
i	int
,	O
n	long
)	O
;	O
break	O
;	O
}	O
case	O
2	int
:	O
if	O
(	O
klass	pointer
->	O
cppname	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Group 2 for CLASS %s already read"	pointer
,	O
klass	pointer
->	O
dxfname	pointer
)	O
;	O
break	O
;	O
}	O
STRADD	O
(	O
klass	pointer
->	O
cppname	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"CLASS[%d].cppname = %s [TV 2]\n"	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
klass	pointer
->	O
appname	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Group 3 for CLASS %s already read"	pointer
,	O
klass	pointer
->	O
dxfname	pointer
)	O
;	O
break	O
;	O
}	O
STRADD	O
(	O
klass	pointer
->	O
appname	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"CLASS[%d].appname = %s [TV 3]\n"	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
break	O
;	O
case	O
90	int
:	O
klass	pointer
->	O
proxyflag	short
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"CLASS[%d].proxyflag = %ld [BS 90]\n"	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
break	O
;	O
case	O
91	int
:	O
klass	pointer
->	O
num_instances	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"CLASS[%d].num_instances = %ld [BL 91]\n"	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
break	O
;	O
case	O
280	int
:	O
klass	pointer
->	O
is_zombie	char
=	O
(	O
BITCODE_B	char
)	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"CLASS[%d].is_zombie = %d [B 280]\n"	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
break	O
;	O
case	O
281	int
:	O
klass	pointer
->	O
item_class_id	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
?	O
0x1f2	int
:	O
0x1f3	int
;	O
LOG_TRACE	O
(	O
"CLASS[%d].item_class_id = 0x%x [BSx 281] (%s)\n"	pointer
,	O
i	int
,	O
klass	pointer
->	O
item_class_id	short
,	O
pair	pointer
->	O
value	double
.	O
i	int
?	O
"is_entity"	pointer
:	O
"is_object"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unknown DXF code for class[%d].%d"	pointer
,	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
klass	pointer
->	O
dxfname	pointer
&&	O
klass	pointer
->	O
cppname	pointer
&&	O
klass	pointer
->	O
appname	pointer
&&	O
klass	pointer
->	O
item_class_id	short
)	O
{	O
dwg	pointer
->	O
num_classes	short
++	O
;	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
}	O
else	O
{	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
;	O
goto	O
restart	O
;	O
}	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
add_eed	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
int	O
code	char
,	O
size	char
,	O
j	long
;	O
int	O
i	int
,	O
prev	int
=	O
0	int
;	O
Dwg_Eed	struct
*	O
eed	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
i	int
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
num_eed	int
;	O
eed	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
eed	pointer
;	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
1020	int
||	O
pair	pointer
->	O
code	char
>	O
1035	int
)	O
{	O
if	O
(	O
i	int
||	O
eed	pointer
)	O
{	O
eed	pointer
=	O
(	O
Dwg_Eed	struct
*	O
)	O
realloc	function
(	O
eed	pointer
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
if	O
(	O
i	int
)	O
memset	function
(	O
&	O
eed	pointer
[	O
i	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
}	O
else	O
{	O
eed	pointer
=	O
(	O
Dwg_Eed	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
}	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
eed	pointer
=	O
eed	pointer
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
num_eed	int
++	O
;	O
}	O
else	O
i	int
--	O
;	O
for	O
(	O
j	long
=	O
i	int
;	O
j	long
>=	O
0	int
;	O
j	long
--	O
)	O
if	O
(	O
eed	pointer
[	O
j	long
]	O
.	O
handle	pointer
.	O
code	char
)	O
prev	int
=	O
j	long
;	O
assert	O
(	O
prev	int
>=	O
0	int
&&	O
prev	int
<=	O
i	int
)	O
;	O
code	char
=	O
pair	pointer
->	O
code	char
-	O
1000	int
;	O
assert	O
(	O
code	char
>=	O
0	int
&&	O
code	char
<	O
100	int
)	O
;	O
LOG_TRACE	O
(	O
"EED[%d] code: %d "	pointer
,	O
i	int
,	O
code	char
)	O
;	O
switch	O
(	O
code	char
)	O
{	O
case	O
0	int
:	O
{	O
int	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
<	O
R_2007	int
)	O
{	O
size	char
=	O
1	int
+	O
1	int
+	O
2	int
+	O
len	long
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
+	O
1	int
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
=	O
len	long
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
codepage	int
=	O
dwg	pointer
->	O
header	struct
.	O
codepage	int
;	O
if	O
(	O
len	long
&&	O
len	long
<	O
256	int
)	O
{	O
LOG_TRACE	O
(	O
"string: \"%s\" [TV %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
size	char
-	O
1	int
)	O
;	O
memcpy	function
(	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
len	long
+	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
size	char
=	O
1	int
+	O
2	int
+	O
(	O
len	long
*	O
2	int
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
+	O
2	int
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
length	double
=	O
len	long
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
codepage	int
=	O
obj	pointer
->	O
parent	pointer
->	O
header	struct
.	O
codepage	int
;	O
if	O
(	O
len	long
&&	O
len	long
<	O
32767	int
)	O
{	O
BITCODE_TU	pointer
tu	pointer
=	O
bit_utf8_to_TU	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"wstring: \"%s\" [TU %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
size	char
-	O
1	int
)	O
;	O
memcpy	function
(	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
string	array
,	O
tu	pointer
,	O
2	int
*	O
(	O
len	long
+	O
1	int
)	O
)	O
;	O
free	function
(	O
tu	pointer
)	O
;	O
}	O
}	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
}	O
break	O
;	O
case	O
1	int
:	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
num_eed	int
--	O
;	O
prev	int
=	O
i	int
;	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ACAD"	pointer
)	O
)	O
{	O
dwg_add_handle	function
(	O
&	O
eed	pointer
[	O
i	int
]	O
.	O
handle	pointer
,	O
5	int
,	O
0x12	int
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"handle: 5.1.12 [H] for APPID.%s\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
{	O
BITCODE_H	pointer
hdl	array
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"APPID"	pointer
)	O
;	O
if	O
(	O
hdl	array
)	O
{	O
memcpy	function
(	O
&	O
eed	pointer
[	O
i	int
]	O
.	O
handle	pointer
,	O
&	O
hdl	array
->	O
handleref	struct
,	O
sizeof	O
(	O
Dwg_Handle	struct
)	O
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
handle	pointer
.	O
code	char
=	O
5	int
;	O
LOG_TRACE	O
(	O
"handle: %lX [H] for APPID.%s\n"	pointer
,	O
hdl	array
->	O
absolute_ref	long
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
{	O
char	O
idx	pointer
[	O
12	int
]	O
;	O
snprintf	function
(	O
idx	pointer
,	O
12	int
,	O
"%d"	pointer
,	O
obj	pointer
->	O
index	short
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
handle	pointer
.	O
code	char
=	O
5	int
;	O
eed_hdls	pointer
=	O
array_push	function
(	O
eed_hdls	pointer
,	O
idx	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
i	int
)	O
;	O
LOG_TRACE	O
(	O
"handle: ? [H} for APPID.%s later\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
2	int
:	O
size	char
=	O
1	int
+	O
1	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_2	struct
.	O
byte	char
=	O
(	O
BITCODE_RC	char
)	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"byte: %d\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
break	O
;	O
case	O
4	int
:	O
{	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
int	O
len	long
=	O
strlen	function
(	O
pos	pointer
)	O
;	O
size	char
=	O
1	int
+	O
len	long
/	O
2	int
+	O
1	int
+	O
1	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
length	double
=	O
len	long
/	O
2	int
;	O
LOG_TRACE	O
(	O
"binary[%d]: "	pointer
,	O
len	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
len	long
/	O
2	int
;	O
j	long
++	O
)	O
{	O
sscanf	function
(	O
pos	pointer
,	O
"%2hhX"	pointer
,	O
&	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
data	pointer
[	O
j	long
]	O
)	O
;	O
LOG_TRACE	O
(	O
"%02X"	pointer
,	O
(	O
unsigned	O
char	O
)	O
*	O
pos	pointer
)	O
;	O
pos	pointer
+=	O
2	int
;	O
}	O
LOG_TRACE	O
(	O
" [TF]\n"	pointer
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
}	O
break	O
;	O
case	O
10	int
:	O
case	O
11	int
:	O
case	O
12	int
:	O
case	O
13	int
:	O
case	O
14	int
:	O
case	O
15	int
:	O
size	char
=	O
1	int
+	O
3	int
*	O
8	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
break	O
;	O
case	O
20	int
:	O
case	O
21	int
:	O
case	O
22	int
:	O
case	O
23	int
:	O
case	O
24	int
:	O
case	O
25	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
||	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
!=	O
code	char
-	O
10	int
)	O
{	O
LOG_ERROR	O
(	O
"Wrong EED DXF code %d, expected %d"	pointer
,	O
code	char
+	O
1000	int
,	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
?	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
+	O
1010	int
:	O
1020	int
)	O
return	O
;	O
}	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
30	int
:	O
case	O
31	int
:	O
case	O
32	int
:	O
case	O
33	int
:	O
case	O
34	int
:	O
case	O
35	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
||	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
!=	O
code	char
-	O
20	int
)	O
{	O
LOG_ERROR	O
(	O
"Wrong EED DXF code %d, expected %d"	pointer
,	O
code	char
+	O
1000	int
,	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
?	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
+	O
1020	int
:	O
1030	int
)	O
return	O
;	O
}	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"3dpoint: (%f,%f,%f)\n"	pointer
,	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
x	double
,	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
y	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
40	int
:	O
case	O
41	int
:	O
case	O
42	int
:	O
size	char
=	O
1	int
+	O
8	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_40	struct
.	O
real	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"real: %f\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
break	O
;	O
case	O
70	int
:	O
size	char
=	O
1	int
+	O
2	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_70	struct
.	O
rs	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"short: %d\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
break	O
;	O
case	O
71	int
:	O
size	char
=	O
1	int
+	O
4	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_71	struct
.	O
rl	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"long: %ld\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
break	O
;	O
case	O
5	int
:	O
{	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
unsigned	O
long	O
l	long
=	O
0	int
;	O
size	char
=	O
1	int
+	O
8	int
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
size	char
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
code	char
=	O
code	char
;	O
sscanf	function
(	O
pos	pointer
,	O
"%lX"	pointer
,	O
&	O
l	long
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
data	pointer
->	O
u	union
.	O
eed_5	struct
.	O
entity	long
=	O
(	O
BITCODE_RLL	long
)	O
l	long
;	O
LOG_TRACE	O
(	O
"entity: %lX [RLL]\n"	pointer
,	O
l	long
)	O
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
+=	O
size	char
;	O
break	O
;	O
}	O
default	O
:	O
LOG_ERROR	O
(	O
"Not yet implemented EED[%d] code %d"	pointer
,	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
if	O
(	O
!	O
eed	pointer
[	O
i	int
]	O
.	O
handle	pointer
.	O
code	char
)	O
{	O
if	O
(	O
i	int
!=	O
prev	int
)	O
{	O
eed	pointer
[	O
prev	int
]	O
.	O
size	char
+=	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
;	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
=	O
0	int
;	O
}	O
LOG_TRACE	O
(	O
"EED[%d] size: %d\n"	pointer
,	O
prev	int
,	O
eed	pointer
[	O
prev	int
]	O
.	O
size	char
)	O
;	O
}	O
else	O
if	O
(	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
)	O
LOG_TRACE	O
(	O
"EED[%d] size: %d\n"	pointer
,	O
i	int
,	O
eed	pointer
[	O
i	int
]	O
.	O
size	char
)	O
;	O
return	O
;	O
}	O
int	O
is_table_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
strEQc	O
(	O
name	pointer
,	O
"LTYPE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"VPORT"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"VPORT"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"APPID"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"LAYER"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"DIMSTYLE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"STYLE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"VIEW"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"VPORT_ENTITY"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"UCS"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK_RECORD"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK_HEADER"	pointer
)	O
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_LTYPE_dashes	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_LTYPE	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
int	O
num_dashes	char
=	O
(	O
int	O
)	O
_o	pointer
->	O
num_dashes	char
;	O
_o	pointer
->	O
dashes	pointer
=	O
xcalloc	function
(	O
_o	pointer
->	O
num_dashes	char
,	O
sizeof	O
(	O
Dwg_LTYPE_dash	struct
)	O
)	O
;	O
for	O
(	O
int	O
j	long
=	O
-	O
1	int
;	O
j	long
<	O
num_dashes	char
;	O
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
49	int
)	O
{	O
j	long
++	O
;	O
assert	O
(	O
j	long
<	O
num_dashes	char
)	O
;	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
length	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].length = %f [BD 49]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
74	int
)	O
{	O
if	O
(	O
j	long
<	O
0	int
)	O
j	long
++	O
;	O
assert	O
(	O
j	long
<	O
num_dashes	char
)	O
;	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
complex_shapecode	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].complex_shapecode = %d [RS 74]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
75	int
)	O
{	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
shape_flag	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].shape_flag = %d [RS 75]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
if	O
(	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
shape_flag	short
&	O
0x2	int
)	O
_o	pointer
->	O
text_area_is_present	char
=	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
44	int
)	O
{	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
x_offset	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].x_offset = %f [BD 44]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
45	int
)	O
{	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
y_offset	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].y_offset = %f [BD 45]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
46	int
)	O
{	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
scale	struct
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].scale = %f [BD 46]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
50	int
)	O
{	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
rotation	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
LOG_TRACE	O
(	O
"LTYPE.dashes[%d].rotation = %f [BD 50]\n"	pointer
,	O
j	long
,	O
_o	pointer
->	O
dashes	pointer
[	O
j	long
]	O
.	O
rotation	double
)	O
;	O
}	O
else	O
break	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_MLINESTYLE_lines	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
int	O
num_lines	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
Dwg_Object_MLINESTYLE	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
MLINESTYLE	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
_o	pointer
->	O
num_lines	char
=	O
num_lines	char
;	O
LOG_TRACE	O
(	O
"MLINESTYLE.num_lines = %d [RC 71]\n"	pointer
,	O
num_lines	char
)	O
;	O
_o	pointer
->	O
lines	pointer
=	O
xcalloc	function
(	O
num_lines	char
,	O
sizeof	O
(	O
Dwg_MLINESTYLE_line	struct
)	O
)	O
;	O
for	O
(	O
int	O
j	long
=	O
-	O
1	int
;	O
j	long
<	O
(	O
int	O
)	O
num_lines	char
;	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
49	int
)	O
{	O
j	long
++	O
;	O
assert	O
(	O
j	long
<	O
num_lines	char
)	O
;	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
offset	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLINESTYLE.lines[%d].offset = %f [BD 49]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
62	int
)	O
{	O
if	O
(	O
j	long
<	O
0	int
)	O
j	long
++	O
;	O
assert	O
(	O
j	long
<	O
num_lines	char
)	O
;	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"MLINESTYLE.lines[%d].color.index = %d [CMC 62]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
420	int
)	O
{	O
if	O
(	O
j	long
<	O
0	int
)	O
j	long
++	O
;	O
assert	O
(	O
j	long
<	O
num_lines	char
)	O
;	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
color	short
.	O
rgb	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MLINESTYLE.lines[%d].color.rgb = %06X [CMC 420]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
6	int
)	O
{	O
if	O
(	O
j	long
<	O
0	int
)	O
j	long
++	O
;	O
assert	O
(	O
j	long
<	O
num_lines	char
)	O
;	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BYLAYER"	pointer
)	O
||	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ByLayer"	pointer
)	O
)	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
index	short
=	O
32767	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BYBLOCK"	pointer
)	O
||	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ByBlock"	pointer
)	O
)	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
index	short
=	O
32766	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CONTINUOUS"	pointer
)	O
||	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"Continuous"	pointer
)	O
)	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
index	short
=	O
0	int
;	O
else	O
{	O
BITCODE_H	pointer
hdl	array
;	O
if	O
(	O
(	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LTYPE"	pointer
)	O
)	O
)	O
{	O
hdl	array
->	O
handleref	struct
.	O
code	char
=	O
5	int
;	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
ltype	pointer
=	O
hdl	array
;	O
LOG_TRACE	O
(	O
"MLINESTYLE.lines[%d].lt.ltype %s => "	pointer
FORMAT_REF	pointer
" [H 6]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
ARGS_REF	O
(	O
hdl	array
)	O
)	O
;	O
}	O
}	O
if	O
(	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
index	short
>=	O
-	O
2	int
&&	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
index	short
<=	O
0	int
)	O
LOG_TRACE	O
(	O
"MLINESTYLE.lines[%d].lt.index = %d [BSd 6]\n"	pointer
,	O
j	long
,	O
_o	pointer
->	O
lines	pointer
[	O
j	long
]	O
.	O
lt	union
.	O
index	short
)	O
;	O
}	O
else	O
break	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
new_LWPOLYLINE	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
BITCODE_BL	int
num_points	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
Dwg_Entity_LWPOLYLINE	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
LWPOLYLINE	pointer
;	O
int	O
j	long
=	O
-	O
1	int
;	O
_o	pointer
->	O
num_points	int
=	O
num_points	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.num_points = %u [BS 90]\n"	pointer
,	O
num_points	int
)	O
;	O
_o	pointer
->	O
points	pointer
=	O
xcalloc	function
(	O
num_points	int
,	O
sizeof	O
(	O
BITCODE_2RD	struct
)	O
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
pair	pointer
==	O
NULL	O
||	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
{	O
LOG_TRACE	O
(	O
"LWPOLYLINE.flag = %d [BS 70]\n"	pointer
,	O
_o	pointer
->	O
flag	short
)	O
;	O
return	O
pair	pointer
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
43	int
)	O
{	O
_o	pointer
->	O
const_width	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
!=	O
0.0	int
)	O
_o	pointer
->	O
flag	short
|=	O
4	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.const_width = %f [BD 43]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
70	int
)	O
{	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
i	int
&	O
1	int
)	O
_o	pointer
->	O
flag	short
|=	O
512	int
;	O
else	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
i	int
&	O
128	int
)	O
_o	pointer
->	O
flag	short
|=	O
128	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.flag = %d [BS 70]\n"	pointer
,	O
_o	pointer
->	O
flag	short
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
38	int
)	O
{	O
_o	pointer
->	O
elevation	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
!=	O
0.0	int
)	O
_o	pointer
->	O
flag	short
|=	O
8	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.elevation = %f [38 BD]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
39	int
)	O
{	O
_o	pointer
->	O
thickness	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
!=	O
0.0	int
)	O
_o	pointer
->	O
flag	short
|=	O
2	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.thickness = %f [BD 39]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
210	int
)	O
{	O
_o	pointer
->	O
extrusion	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
220	int
)	O
{	O
_o	pointer
->	O
extrusion	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
230	int
)	O
{	O
_o	pointer
->	O
extrusion	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
if	O
(	O
_o	pointer
->	O
extrusion	struct
.	O
x	double
!=	O
0.0	int
||	O
_o	pointer
->	O
extrusion	struct
.	O
y	double
!=	O
0.0	int
||	O
_o	pointer
->	O
extrusion	struct
.	O
z	double
!=	O
1.0	int
)	O
_o	pointer
->	O
flag	short
|=	O
1	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.extrusion = (%f, %f, %f) [BE 210]\n"	pointer
,	O
_o	pointer
->	O
extrusion	struct
.	O
x	double
,	O
_o	pointer
->	O
extrusion	struct
.	O
y	double
,	O
_o	pointer
->	O
extrusion	struct
.	O
z	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
)	O
{	O
j	long
++	O
;	O
assert	O
(	O
_o	pointer
->	O
num_points	int
>	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
_o	pointer
->	O
num_points	int
)	O
;	O
_o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
_o	pointer
->	O
num_points	int
>	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
_o	pointer
->	O
num_points	int
)	O
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.points[%d] = (%f, %f) [2RD 10]\n"	pointer
,	O
j	long
,	O
_o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
_o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
42	int
)	O
{	O
if	O
(	O
!	O
j	long
)	O
{	O
_o	pointer
->	O
bulges	pointer
=	O
xcalloc	function
(	O
num_points	int
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
_o	pointer
->	O
num_bulges	int
=	O
num_points	int
;	O
}	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
_o	pointer
->	O
num_bulges	int
>	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
_o	pointer
->	O
num_bulges	int
)	O
;	O
_o	pointer
->	O
bulges	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.bulges[%d] = %f [BD 42]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
91	int
)	O
{	O
if	O
(	O
!	O
j	long
)	O
{	O
_o	pointer
->	O
vertexids	pointer
=	O
xcalloc	function
(	O
num_points	int
,	O
sizeof	O
(	O
BITCODE_BL	int
)	O
)	O
;	O
_o	pointer
->	O
num_vertexids	int
=	O
num_points	int
;	O
}	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
_o	pointer
->	O
num_vertexids	int
>	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
_o	pointer
->	O
num_vertexids	int
)	O
;	O
_o	pointer
->	O
vertexids	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.vertexids[%d] = %d [BL 91]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
40	int
)	O
{	O
if	O
(	O
!	O
j	long
)	O
{	O
_o	pointer
->	O
flag	short
|=	O
4	int
;	O
_o	pointer
->	O
widths	pointer
=	O
xcalloc	function
(	O
num_points	int
,	O
sizeof	O
(	O
Dwg_LWPOLYLINE_width	struct
)	O
)	O
;	O
_o	pointer
->	O
num_widths	int
=	O
num_points	int
;	O
}	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
_o	pointer
->	O
num_widths	int
>	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
_o	pointer
->	O
num_widths	int
)	O
;	O
_o	pointer
->	O
widths	pointer
[	O
j	long
]	O
.	O
start	struct
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.widths[%d].start = %f [BD 40]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
41	int
&&	O
(	O
_o	pointer
->	O
flag	short
&	O
4	int
)	O
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
_o	pointer
->	O
num_widths	int
>	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
_o	pointer
->	O
num_widths	int
)	O
;	O
_o	pointer
->	O
widths	pointer
[	O
j	long
]	O
.	O
end	struct
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LWPOLYLINE.widths[%d].end = %f [BD 41]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
1000	int
&&	O
pair	pointer
->	O
code	char
<	O
1999	int
)	O
{	O
add_eed	function
(	O
obj	pointer
,	O
"LWPOLYLINE"	pointer
,	O
pair	pointer
)	O
;	O
}	O
else	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"LWPOLYLINE"	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_3DSOLID_encr	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Entity_3DSOLID	O
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
_3DSOLID	pointer
;	O
int	O
i	int
=	O
0	int
,	O
total	int
=	O
0	int
;	O
o	pointer
->	O
num_blocks	int
=	O
1	int
;	O
o	pointer
->	O
encr_sat_data	pointer
=	O
xcalloc	function
(	O
2	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
o	pointer
->	O
block_size	pointer
=	O
xcalloc	function
(	O
2	int
,	O
sizeof	O
(	O
BITCODE_BL	int
)	O
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
1	int
)	O
{	O
int	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
+	O
1	int
;	O
if	O
(	O
!	O
total	int
)	O
{	O
total	int
=	O
len	long
;	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
=	O
malloc	function
(	O
total	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
{	O
total	int
+=	O
len	long
;	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
=	O
realloc	function
(	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
,	O
total	int
+	O
1	int
)	O
;	O
strcat	function
(	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
strcat	function
(	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
,	O
"\n"	pointer
)	O
;	O
i	int
++	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
LOG_TRACE	O
(	O
"%s.block_size[0]: %d\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
total	int
)	O
;	O
if	O
(	O
o	pointer
->	O
version	short
==	O
1	int
)	O
{	O
int	O
idx	pointer
=	O
0	int
;	O
o	pointer
->	O
unknown	char
=	O
1	int
;	O
o	pointer
->	O
acis_data	pointer
=	O
xcalloc	function
(	O
1	int
,	O
total	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
total	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
[	O
i	int
]	O
==	O
'^'	O
&&	O
i	int
<=	O
total	int
&&	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
[	O
i	int
+	O
1	int
]	O
==	O
' '	O
)	O
{	O
o	pointer
->	O
acis_data	pointer
[	O
idx	pointer
++	O
]	O
=	O
'A'	O
;	O
i	int
++	O
;	O
}	O
else	O
if	O
(	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
[	O
i	int
]	O
<=	O
32	int
)	O
o	pointer
->	O
acis_data	pointer
[	O
idx	pointer
++	O
]	O
=	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
[	O
i	int
]	O
;	O
else	O
o	pointer
->	O
acis_data	pointer
[	O
idx	pointer
++	O
]	O
=	O
159	int
-	O
o	pointer
->	O
encr_sat_data	pointer
[	O
0	int
]	O
[	O
i	int
]	O
;	O
}	O
o	pointer
->	O
acis_data	pointer
[	O
idx	pointer
]	O
=	O
'\0'	O
;	O
o	pointer
->	O
block_size	pointer
[	O
0	int
]	O
=	O
idx	pointer
;	O
LOG_TRACE	O
(	O
"%s.acis_data:\n%s\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
o	pointer
->	O
acis_data	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_MESH	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Entity_MESH	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MESH	pointer
;	O
BITCODE_BL	int
j	long
=	O
0	int
;	O
int	O
vector	struct
=	O
0	int
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
91	int
)	O
{	O
vector	struct
=	O
pair	pointer
->	O
code	char
;	O
o	pointer
->	O
num_subdiv_vertex	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.num_subdiv_vertex = %u [BL 91]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
subdiv_vertex	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_subdiv_vertex	int
,	O
sizeof	O
(	O
BITCODE_3BD	struct
)	O
)	O
;	O
}	O
}	O
while	O
(	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
92	int
)	O
{	O
j	long
=	O
0	int
;	O
vector	struct
=	O
pair	pointer
->	O
code	char
;	O
o	pointer
->	O
num_vertex	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.num_vertex = %u [BL 92]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
vertex	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_vertex	int
,	O
sizeof	O
(	O
BITCODE_3BD	struct
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
93	int
)	O
{	O
j	long
=	O
0	int
;	O
vector	struct
=	O
pair	pointer
->	O
code	char
;	O
o	pointer
->	O
num_faces	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.num_faces = %u [BL %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
faces	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_faces	int
,	O
sizeof	O
(	O
BITCODE_BL	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
94	int
)	O
{	O
j	long
=	O
0	int
;	O
vector	struct
=	O
pair	pointer
->	O
code	char
;	O
o	pointer
->	O
num_edges	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.num_edges = %u [BL %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
edges	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_edges	int
,	O
sizeof	O
(	O
Dwg_MESH_edge	struct
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
95	int
)	O
{	O
j	long
=	O
0	int
;	O
vector	struct
=	O
pair	pointer
->	O
code	char
;	O
o	pointer
->	O
num_crease	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.num_crease = %u [BL %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
crease	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_crease	int
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
)	O
{	O
if	O
(	O
vector	struct
==	O
91	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_subdiv_vertex	int
)	O
;	O
o	pointer
->	O
subdiv_vertex	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
vector	struct
==	O
92	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_vertex	int
)	O
;	O
o	pointer
->	O
vertex	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
goto	O
mesh_error	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
{	O
if	O
(	O
vector	struct
==	O
91	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_subdiv_vertex	int
)	O
;	O
o	pointer
->	O
subdiv_vertex	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
vector	struct
==	O
92	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_vertex	int
)	O
;	O
o	pointer
->	O
vertex	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
goto	O
mesh_error	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
30	int
)	O
{	O
if	O
(	O
vector	struct
==	O
91	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_subdiv_vertex	int
)	O
;	O
o	pointer
->	O
subdiv_vertex	pointer
[	O
j	long
]	O
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MESH.subdiv_vertex[%d] = (%f, %f, %f) [3BD 10]\n"	pointer
,	O
j	long
,	O
o	pointer
->	O
subdiv_vertex	pointer
[	O
j	long
]	O
.	O
x	double
,	O
o	pointer
->	O
subdiv_vertex	pointer
[	O
j	long
]	O
.	O
y	double
,	O
o	pointer
->	O
subdiv_vertex	pointer
[	O
j	long
]	O
.	O
z	double
)	O
;	O
j	long
++	O
;	O
}	O
else	O
if	O
(	O
vector	struct
==	O
92	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_vertex	int
)	O
;	O
o	pointer
->	O
vertex	pointer
[	O
j	long
]	O
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MESH.vertex[%d] = (%f, %f, %f) [3BD 10]\n"	pointer
,	O
j	long
,	O
o	pointer
->	O
vertex	pointer
[	O
j	long
]	O
.	O
x	double
,	O
o	pointer
->	O
vertex	pointer
[	O
j	long
]	O
.	O
y	double
,	O
o	pointer
->	O
vertex	pointer
[	O
j	long
]	O
.	O
z	double
)	O
;	O
j	long
++	O
;	O
}	O
else	O
goto	O
mesh_error	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
90	int
)	O
{	O
if	O
(	O
vector	struct
==	O
93	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_faces	int
)	O
;	O
o	pointer
->	O
faces	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.faces[%d] = %u [BL %d]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
j	long
++	O
;	O
}	O
else	O
if	O
(	O
vector	struct
==	O
94	int
)	O
{	O
int	O
i	int
=	O
j	long
/	O
2	int
;	O
assert	O
(	O
j	long
<	O
2	int
*	O
o	pointer
->	O
num_edges	int
)	O
;	O
if	O
(	O
j	long
%	O
2	int
==	O
0	int
)	O
{	O
o	pointer
->	O
edges	pointer
[	O
i	int
]	O
.	O
from	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
}	O
else	O
{	O
o	pointer
->	O
edges	pointer
[	O
i	int
]	O
.	O
to	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.edges[%d] = (%u, %u) [2BL %d]\n"	pointer
,	O
i	int
,	O
o	pointer
->	O
edges	pointer
[	O
i	int
]	O
.	O
from	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
j	long
++	O
;	O
}	O
else	O
if	O
(	O
vector	struct
==	O
95	int
)	O
{	O
o	pointer
->	O
class_version	char
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.class_version = %u [BL %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
goto	O
mesh_error	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
140	int
)	O
{	O
if	O
(	O
vector	struct
==	O
95	int
)	O
{	O
assert	O
(	O
j	long
<	O
o	pointer
->	O
num_crease	int
)	O
;	O
o	pointer
->	O
crease	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"MESH.crease[%d] = %u [BD %d]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
j	long
++	O
;	O
}	O
else	O
goto	O
mesh_error	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
1000	int
&&	O
pair	pointer
->	O
code	char
<	O
1999	int
)	O
{	O
add_eed	function
(	O
obj	pointer
,	O
"MESH"	pointer
,	O
pair	pointer
)	O
;	O
}	O
else	O
{	O
mesh_error	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"MESH"	pointer
)	O
;	O
}	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_HATCH	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
BITCODE_BL	int
num_paths	int
;	O
Dwg_Entity_HATCH	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
HATCH	pointer
;	O
int	O
is_plpath	int
=	O
0	int
;	O
int	O
j	long
=	O
-	O
1	int
;	O
int	O
k	int
=	O
-	O
1	int
;	O
int	O
l	long
=	O
-	O
1	int
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
91	int
)	O
{	O
o	pointer
->	O
num_paths	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.num_paths = %u [BS 91]\n"	pointer
,	O
o	pointer
->	O
num_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_paths	int
,	O
sizeof	O
(	O
Dwg_HATCH_Path	struct
)	O
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
78	int
)	O
{	O
o	pointer
->	O
num_deflines	short
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.num_deflines = %ld [BS 78]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
o	pointer
->	O
deflines	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
sizeof	O
(	O
Dwg_HATCH_DefLine	struct
)	O
)	O
;	O
}	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
453	int
)	O
{	O
o	pointer
->	O
num_colors	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.num_colors = %ld [BL 453]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
o	pointer
->	O
colors	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
sizeof	O
(	O
Dwg_HATCH_Color	struct
)	O
)	O
;	O
}	O
while	O
(	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
pair	pointer
==	O
NULL	O
||	O
pair	pointer
->	O
code	char
==	O
0	int
||	O
pair	pointer
->	O
code	char
==	O
75	int
)	O
return	O
pair	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
92	int
)	O
{	O
j	long
++	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
flag	short
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].flag = %u [BL 92]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
is_plpath	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
&	O
2	int
;	O
o	pointer
->	O
has_derived	char
=	O
pair	pointer
->	O
value	double
.	O
u	union
&	O
4	int
;	O
LOG_TRACE	O
(	O
"HATCH.has_derived = %d [B 0]\n"	pointer
,	O
o	pointer
->	O
has_derived	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
93	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].num_segs_or_paths = %u [BL 93]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
k	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
is_plpath	int
)	O
{	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
sizeof	O
(	O
Dwg_HATCH_PathSeg	struct
)	O
)	O
;	O
}	O
else	O
{	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
polyline_paths	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
sizeof	O
(	O
Dwg_HATCH_PolylinePath	struct
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
72	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
if	O
(	O
!	O
is_plpath	int
)	O
{	O
k	int
++	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
if	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
&&	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
{	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].type_status = %d [RC 72]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
}	O
else	O
{	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
bulges_present	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].bulges_present = %d [RC 72]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
73	int
&&	O
is_plpath	int
&&	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
closed	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].closed = %d [RC 73]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
94	int
&&	O
!	O
is_plpath	int
&&	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
degree	short
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].degree = %ld [BL 94]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
74	int
&&	O
!	O
is_plpath	int
&&	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
is_periodic	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].is_periodic = %d [B 74]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
95	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_knots	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].num_knots = %ld [BL 95]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
knots	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
l	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
96	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_control_points	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].num_control_points = %ld [BL 96]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
control_points	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
sizeof	O
(	O
Dwg_HATCH_ControlPoint	struct
)	O
)	O
;	O
l	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
&&	O
!	O
is_plpath	int
&&	O
!	O
o	pointer
->	O
num_seeds	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
1	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
first_endpoint	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
center	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
4	int
:	O
l	long
++	O
;	O
assert	O
(	O
l	long
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_control_points	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
control_points	pointer
[	O
l	long
]	O
.	O
point	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
11	int
&&	O
!	O
is_plpath	int
&&	O
!	O
o	pointer
->	O
num_seeds	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
1	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
second_endpoint	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
endpoint	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
4	int
:	O
l	long
++	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
l	long
>=	O
0	int
)	O
;	O
assert	O
(	O
l	long
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_fitpts	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
fitpts	pointer
[	O
l	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
&&	O
!	O
is_plpath	int
&&	O
!	O
o	pointer
->	O
num_seeds	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
1	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
first_endpoint	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].first_endpoint = (%f, %f) "	pointer
"[2RD 10]\n"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
first_endpoint	struct
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
center	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].center = (%f, %f) [2RD 10]\n"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
center	struct
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
4	int
:	O
assert	O
(	O
l	long
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_control_points	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
control_points	pointer
[	O
l	long
]	O
.	O
point	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].control_points[%d].point = "	pointer
"(%f, %f) [2RD 10]\n"	pointer
,	O
j	long
,	O
k	int
,	O
l	long
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
control_points	pointer
[	O
l	long
]	O
.	O
point	struct
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
21	int
&&	O
!	O
is_plpath	int
&&	O
!	O
o	pointer
->	O
num_seeds	int
&&	O
pair	pointer
->	O
value	double
.	O
d	double
!=	O
0.0	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
1	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
second_endpoint	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].second_endpoint = (%f, %f) "	pointer
"[2RD 11]\n"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
second_endpoint	struct
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
endpoint	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].endpoint = (%f, %f) [2RD 11]\n"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
endpoint	struct
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
4	int
:	O
assert	O
(	O
l	long
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_fitpts	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
fitpts	pointer
[	O
l	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].fitpts[%d].y = (%f, %f) "	pointer
"[2RD 11]\n"	pointer
,	O
j	long
,	O
k	int
,	O
l	long
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
fitpts	pointer
[	O
l	long
]	O
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
40	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
2	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
radius	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].radius = %f [BD 40]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
minor_major_ratio	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].minor_major_ratio = %f [BD 40]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
l	long
>=	O
0	int
&&	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
is_rational	char
)	O
{	O
assert	O
(	O
l	long
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_control_points	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
control_points	pointer
[	O
l	long
]	O
.	O
weight	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].control_points[%d]."	pointer
"weight = %f [BD 40]\n"	pointer
,	O
j	long
,	O
k	int
,	O
l	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
{	O
l	long
++	O
;	O
assert	O
(	O
l	long
>=	O
0	int
)	O
;	O
assert	O
(	O
l	long
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_knots	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
knots	pointer
[	O
l	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].knots[%d] = %f [BD 40]\n"	pointer
,	O
j	long
,	O
k	int
,	O
l	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
50	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
2	int
:	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
start_angle	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].start_angle = %f [BD 50]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
51	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
2	int
:	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
end_angle	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].end_angle = %f [BD 51]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Unhandled HATCH.paths[%d].segs[%d].type_status %d "	pointer
"for DXF %d"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
73	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
switch	O
(	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
)	O
{	O
case	O
2	int
:	O
case	O
3	int
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
is_ccw	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].is_ccw = %d [B 73]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
break	O
;	O
default	O
:	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
is_rational	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].is_rational = %d [B 73]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
&&	O
is_plpath	int
&&	O
!	O
o	pointer
->	O
num_seeds	int
)	O
{	O
k	int
++	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
polyline_paths	pointer
[	O
k	int
]	O
.	O
point	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
&&	O
is_plpath	int
&&	O
!	O
o	pointer
->	O
num_seeds	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
polyline_paths	pointer
[	O
k	int
]	O
.	O
point	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].polyline_paths[%d].point = (%f, %f) [2RD 10]\n"	pointer
,	O
j	long
,	O
k	int
,	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
polyline_paths	pointer
[	O
k	int
]	O
.	O
point	struct
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
42	int
&&	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
polyline_paths	pointer
[	O
k	int
]	O
.	O
bulge	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].polyline_paths[%d].bulge = %f [BD 42]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
97	int
&&	O
!	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_segs_or_paths	int
)	O
;	O
if	O
(	O
k	int
<	O
0	int
||	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
type_status	char
!=	O
4	int
)	O
{	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_boundary_handles	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
o	pointer
->	O
num_boundary_handles	int
+=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].num_boundary_handles = %ld [BL 97]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
k	int
=	O
0	int
;	O
}	O
else	O
{	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
segs	pointer
[	O
k	int
]	O
.	O
num_fitpts	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].segs[%d].num_fitpts  = %ld [BL 97]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
97	int
&&	O
is_plpath	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_paths	int
)	O
;	O
o	pointer
->	O
paths	pointer
[	O
j	long
]	O
.	O
num_boundary_handles	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
o	pointer
->	O
num_boundary_handles	int
+=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.paths[%d].num_boundary_handles = %ld [BL 97]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
k	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
78	int
)	O
{	O
o	pointer
->	O
num_deflines	short
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"HATCH.num_deflines = %ld [BS 78]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
o	pointer
->	O
deflines	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
sizeof	O
(	O
Dwg_HATCH_DefLine	struct
)	O
)	O
;	O
j	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
53	int
&&	O
o	pointer
->	O
num_deflines	short
)	O
{	O
j	long
++	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
angle	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].angle = %f [BD 53]\n"	pointer
,	O
j	long
,	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
angle	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
43	int
&&	O
o	pointer
->	O
num_deflines	short
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
pt0	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].pt0.x = %f [BD 43]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
44	int
&&	O
o	pointer
->	O
num_deflines	short
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
pt0	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].pt0.y = %f [BD 44]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
45	int
&&	O
o	pointer
->	O
num_deflines	short
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
offset	double
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].offset.x = %f [BD 45]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
46	int
&&	O
o	pointer
->	O
num_deflines	short
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
offset	double
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].offset.y = %f [BD 46]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
79	int
&&	O
o	pointer
->	O
num_deflines	short
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
num_dashes	char
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].num_dashes = %u [BS 79]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
dashes	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
}	O
k	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
49	int
&&	O
o	pointer
->	O
num_deflines	short
&&	O
j	long
>=	O
0	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_deflines	short
)	O
;	O
if	O
(	O
!	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
dashes	pointer
)	O
{	O
LOG_ERROR	O
(	O
"DXF 79 num_dashes missing for HATCH.dashes 49"	pointer
)	O
goto	O
unknown_HATCH	O
;	O
}	O
k	int
++	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
num_dashes	char
)	O
;	O
o	pointer
->	O
deflines	pointer
[	O
j	long
]	O
.	O
dashes	pointer
[	O
k	int
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.deflines[%d].dashes[%d] = %f [BD 49]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
47	int
)	O
{	O
o	pointer
->	O
pixel_size	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.pixel_size = %f [BD 47]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
98	int
)	O
{	O
o	pointer
->	O
num_seeds	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.num_seeds = %u [BL 98]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
seeds	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
sizeof	O
(	O
BITCODE_2RD	struct
)	O
)	O
;	O
}	O
k	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
&&	O
o	pointer
->	O
num_seeds	int
)	O
{	O
k	int
++	O
;	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
num_seeds	int
)	O
;	O
o	pointer
->	O
seeds	pointer
[	O
k	int
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
&&	O
o	pointer
->	O
num_seeds	int
)	O
{	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
assert	O
(	O
k	int
<	O
(	O
int	O
)	O
o	pointer
->	O
num_seeds	int
)	O
;	O
o	pointer
->	O
seeds	pointer
[	O
k	int
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.seeds[%d] = (%f, %f) [2RD 10]\n"	pointer
,	O
k	int
,	O
o	pointer
->	O
seeds	pointer
[	O
k	int
]	O
.	O
x	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
330	int
&&	O
o	pointer
->	O
num_boundary_handles	int
)	O
{	O
BITCODE_H	pointer
ref	pointer
=	O
dwg_add_handleref	function
(	O
obj	pointer
->	O
parent	pointer
,	O
3	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"HATCH.boundary_handles[%d] = "	pointer
FORMAT_REF	pointer
" [H 330]\n"	pointer
,	O
k	int
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
453	int
)	O
{	O
o	pointer
->	O
num_colors	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.num_colors = %u [BL 453]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
o	pointer
->	O
colors	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
sizeof	O
(	O
Dwg_HATCH_Color	struct
)	O
)	O
;	O
}	O
j	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
463	int
&&	O
o	pointer
->	O
num_colors	int
)	O
{	O
j	long
++	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_colors	int
)	O
;	O
o	pointer
->	O
colors	pointer
[	O
j	long
]	O
.	O
shift_value	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.colors[%d].shift_value = %f [BD 463]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
63	int
&&	O
o	pointer
->	O
num_colors	int
)	O
{	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_colors	int
)	O
;	O
o	pointer
->	O
colors	pointer
[	O
j	long
]	O
.	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"HATCH.colors[%d].color.index = %u [CMC 63]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
421	int
&&	O
o	pointer
->	O
num_colors	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_colors	int
)	O
;	O
o	pointer
->	O
colors	pointer
[	O
j	long
]	O
.	O
color	short
.	O
rgb	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.colors[%d].color.rgb = %06X [CMC 421]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
431	int
&&	O
o	pointer
->	O
num_colors	int
)	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_colors	int
)	O
;	O
o	pointer
->	O
colors	pointer
[	O
j	long
]	O
.	O
color	short
.	O
name	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"HATCH.colors[%d].color.name = %s [CMC 431]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
470	int
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
o	pointer
,	O
"HATCH"	pointer
,	O
"gradient_name"	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"HATCH.gradient_name = %s [T 470]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
462	int
)	O
{	O
o	pointer
->	O
gradient_tint	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"HATCH.gradient_tint = %f [BD 462]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
452	int
)	O
{	O
o	pointer
->	O
single_color_gradient	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"HATCH.single_color_gradient = %u [BL 452]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
1000	int
&&	O
pair	pointer
->	O
code	char
<	O
1999	int
)	O
{	O
add_eed	function
(	O
obj	pointer
,	O
"HATCH"	pointer
,	O
pair	pointer
)	O
;	O
}	O
else	O
{	O
unknown_HATCH	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"HATCH"	pointer
)	O
;	O
}	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_MULTILEADER_lines	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
,	O
Dwg_LEADER_Node	struct
*	O
lnode	pointer
)	O
{	O
Dwg_Entity_MULTILEADER	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MULTILEADER	pointer
;	O
if	O
(	O
!	O
lnode	pointer
)	O
return	O
NULL	O
;	O
lnode	pointer
->	O
num_lines	char
=	O
0	int
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
304	int
&&	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LEADER_LINE{"	pointer
)	O
)	O
{	O
int	O
i	int
=	O
-	O
1	int
,	O
j	long
=	O
-	O
1	int
,	O
k	int
=	O
-	O
1	int
;	O
Dwg_MLEADER_AnnotContext	struct
*	O
ctx	struct
=	O
&	O
o	pointer
->	O
ctx	struct
;	O
lnode	pointer
->	O
lines	pointer
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_LEADER_Line	struct
)	O
)	O
;	O
while	O
(	O
pair	pointer
->	O
code	char
!=	O
305	int
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
Dwg_LEADER_Line	struct
*	O
lline	pointer
=	O
&	O
lnode	pointer
->	O
lines	pointer
[	O
0	int
]	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
NULL	O
;	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
10	int
:	O
i	int
++	O
;	O
lnode	pointer
->	O
num_lines	char
=	O
i	int
+	O
1	int
;	O
LOG_TRACE	O
(	O
"%s.leaders[].num_lines = %d\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
+	O
1	int
)	O
;	O
if	O
(	O
i	int
>	O
0	int
)	O
lnode	pointer
->	O
lines	pointer
=	O
realloc	function
(	O
lnode	pointer
->	O
lines	pointer
,	O
lnode	pointer
->	O
num_lines	char
*	O
sizeof	O
(	O
Dwg_LEADER_Line	struct
)	O
)	O
;	O
lline	pointer
=	O
&	O
lnode	pointer
->	O
lines	pointer
[	O
i	int
]	O
;	O
memset	function
(	O
lline	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_LEADER_Line	struct
)	O
)	O
;	O
lline	pointer
->	O
num_breaks	int
=	O
0	int
;	O
j	long
++	O
;	O
lline	pointer
->	O
num_points	int
=	O
j	long
+	O
1	int
;	O
lline	pointer
->	O
points	pointer
=	O
realloc	function
(	O
lline	pointer
->	O
points	pointer
,	O
(	O
j	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_3BD	struct
)	O
)	O
;	O
memset	function
(	O
&	O
lline	pointer
->	O
points	pointer
[	O
j	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
BITCODE_3BD	struct
)	O
)	O
;	O
lline	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].points[%d].x = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
20	int
:	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lline	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].points[%d].y = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
30	int
:	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lline	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].points[%d].z = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
11	int
:	O
k	int
++	O
;	O
lline	pointer
->	O
num_breaks	int
=	O
k	int
+	O
1	int
;	O
lline	pointer
->	O
breaks	pointer
=	O
realloc	function
(	O
lline	pointer
->	O
breaks	pointer
,	O
(	O
k	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Dwg_LEADER_Break	struct
)	O
)	O
;	O
memset	function
(	O
&	O
ctx	struct
->	O
leaders	pointer
[	O
k	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
Dwg_LEADER_Break	struct
)	O
)	O
;	O
lline	pointer
->	O
breaks	pointer
[	O
k	int
]	O
.	O
start	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].breaks[%d].start.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
21	int
:	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
lline	pointer
->	O
breaks	pointer
[	O
k	int
]	O
.	O
start	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].breaks[%d].start.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
31	int
:	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
lline	pointer
->	O
breaks	pointer
[	O
k	int
]	O
.	O
start	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].breaks[%d].start.z = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
12	int
:	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
lline	pointer
->	O
breaks	pointer
[	O
k	int
]	O
.	O
end	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].breaks[%d].end.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
22	int
:	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
lline	pointer
->	O
breaks	pointer
[	O
k	int
]	O
.	O
end	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].breaks[%d].end.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
32	int
:	O
assert	O
(	O
k	int
>=	O
0	int
)	O
;	O
lline	pointer
->	O
breaks	pointer
[	O
k	int
]	O
.	O
end	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].breaks[%d].end.z = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
91	int
:	O
lline	pointer
->	O
line_index	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].line_index = %u [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
170	int
:	O
lline	pointer
->	O
type	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].line_index = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
92	int
:	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
>	O
256	int
)	O
{	O
lline	pointer
->	O
color	short
.	O
index	short
=	O
256	int
;	O
lline	pointer
->	O
color	short
.	O
rgb	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
&	O
0xFFFFFF	int
;	O
lline	pointer
->	O
color	short
.	O
alpha	char
=	O
pair	pointer
->	O
value	double
.	O
u	union
&	O
0xFF000000	int
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].color.rgb = %06X [CMC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
lline	pointer
->	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].color.index = %d [CMC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
break	O
;	O
case	O
171	int
:	O
lline	pointer
->	O
linewt	char
=	O
dxf_find_lweight	function
(	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].linewt = %d [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
lline	pointer
->	O
linewt	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
40	int
:	O
lline	pointer
->	O
arrow_size	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].arrow_size = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
93	int
:	O
lline	pointer
->	O
flags	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.leaders[].lines[%d].line_index = %d [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
305	int
:	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for MULTILEADER.leaders[].lines[%d]"	pointer
,	O
pair	pointer
->	O
code	char
,	O
i	int
)	O
;	O
return	O
pair	pointer
;	O
}	O
}	O
}	O
if	O
(	O
!	O
lnode	pointer
->	O
num_lines	char
)	O
{	O
free	function
(	O
lnode	pointer
->	O
lines	pointer
)	O
;	O
lnode	pointer
->	O
lines	pointer
=	O
NULL	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_MULTILEADER_leaders	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Entity_MULTILEADER	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MULTILEADER	pointer
;	O
if	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
302	int
&&	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LEADER{"	pointer
)	O
)	O
{	O
int	O
i	int
=	O
-	O
1	int
,	O
j	long
=	O
-	O
1	int
;	O
Dwg_MLEADER_AnnotContext	struct
*	O
ctx	struct
=	O
&	O
o	pointer
->	O
ctx	struct
;	O
ctx	struct
->	O
num_leaders	int
=	O
0	int
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
303	int
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
Dwg_LEADER_Node	struct
*	O
lnode	pointer
=	O
i	int
>=	O
0	int
?	O
&	O
ctx	struct
->	O
leaders	pointer
[	O
i	int
]	O
:	O
NULL	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
lnode	pointer
&&	O
pair	pointer
->	O
code	char
!=	O
290	int
&&	O
pair	pointer
->	O
code	char
!=	O
304	int
&&	O
pair	pointer
->	O
code	char
!=	O
303	int
)	O
{	O
LOG_ERROR	O
(	O
"Missing MULTILEADER.LEADER{ 290 start"	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
if	O
(	O
lnode	pointer
)	O
lnode	pointer
->	O
num_breaks	int
=	O
0	int
;	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
290	int
:	O
i	int
++	O
;	O
ctx	struct
->	O
num_leaders	int
=	O
i	int
+	O
1	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.num_leaders = %d\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
+	O
1	int
)	O
;	O
ctx	struct
->	O
leaders	pointer
=	O
realloc	function
(	O
ctx	struct
->	O
leaders	pointer
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Dwg_LEADER_Node	struct
)	O
)	O
;	O
memset	function
(	O
&	O
ctx	struct
->	O
leaders	pointer
[	O
i	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
Dwg_LEADER_Node	struct
)	O
)	O
;	O
ctx	struct
->	O
leaders	pointer
[	O
i	int
]	O
.	O
has_lastleaderlinepoint	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].has_lastleaderlinepoint = %d [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
291	int
:	O
lnode	pointer
->	O
has_dogleg	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].has_dogleg = %d [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
90	int
:	O
lnode	pointer
->	O
branch_index	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].branch_index = %u [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
271	int
:	O
lnode	pointer
->	O
attach_dir	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].branch_index = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
40	int
:	O
lnode	pointer
->	O
dogleg_length	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].dogleg_length = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
10	int
:	O
lnode	pointer
->	O
lastleaderlinepoint	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].lastleaderlinepoint.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
20	int
:	O
lnode	pointer
->	O
lastleaderlinepoint	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].lastleaderlinepoint.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
30	int
:	O
lnode	pointer
->	O
lastleaderlinepoint	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].lastleaderlinepoint.z = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
11	int
:	O
if	O
(	O
lnode	pointer
->	O
has_dogleg	char
)	O
{	O
lnode	pointer
->	O
dogleg_vector	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].dogleg_vector.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
j	long
++	O
;	O
lnode	pointer
->	O
num_breaks	int
=	O
j	long
+	O
1	int
;	O
LOG_TRACE	O
(	O
"%s.leaders[%d].num_breaks = %d\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
+	O
1	int
)	O
;	O
lnode	pointer
->	O
breaks	pointer
=	O
realloc	function
(	O
lnode	pointer
->	O
breaks	pointer
,	O
(	O
j	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
Dwg_LEADER_Break	struct
)	O
)	O
;	O
lnode	pointer
->	O
breaks	pointer
[	O
j	long
]	O
.	O
start	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].breaks[%d].start.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
break	O
;	O
case	O
21	int
:	O
if	O
(	O
lnode	pointer
->	O
has_dogleg	char
)	O
{	O
lnode	pointer
->	O
dogleg_vector	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].dogleg_vector.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lnode	pointer
->	O
breaks	pointer
[	O
j	long
]	O
.	O
start	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].breaks[%d].start.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
break	O
;	O
case	O
31	int
:	O
if	O
(	O
lnode	pointer
->	O
has_dogleg	char
)	O
{	O
lnode	pointer
->	O
dogleg_vector	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].dogleg_vector.z = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lnode	pointer
->	O
breaks	pointer
[	O
j	long
]	O
.	O
start	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].breaks[%d].start.z = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
break	O
;	O
case	O
12	int
:	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lnode	pointer
->	O
breaks	pointer
[	O
j	long
]	O
.	O
end	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].breaks[%d].end.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
22	int
:	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lnode	pointer
->	O
breaks	pointer
[	O
j	long
]	O
.	O
end	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].breaks[%d].end.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
32	int
:	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
lnode	pointer
->	O
breaks	pointer
[	O
j	long
]	O
.	O
end	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.leaders[%d].breaks[%d].end.z = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
304	int
:	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LEADER_LINE{"	pointer
)	O
)	O
pair	pointer
=	O
add_MULTILEADER_lines	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
,	O
lnode	pointer
)	O
;	O
break	O
;	O
case	O
303	int
:	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for MULTILEADER.leaders[]"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
return	O
pair	pointer
;	O
}	O
}	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_MULTILEADER	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Entity_MULTILEADER	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MULTILEADER	pointer
;	O
int	O
i	int
=	O
-	O
1	int
,	O
j	long
=	O
-	O
1	int
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
300	int
&&	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CONTEXT_DATA{"	pointer
)	O
)	O
{	O
Dwg_MLEADER_AnnotContext	struct
*	O
ctx	struct
=	O
&	O
o	pointer
->	O
ctx	struct
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
301	int
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
300	int
:	O
break	O
;	O
case	O
40	int
:	O
ctx	struct
->	O
scale	struct
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.scale = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
10	int
:	O
ctx	struct
->	O
content_base	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
20	int
:	O
ctx	struct
->	O
content_base	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
30	int
:	O
ctx	struct
->	O
content_base	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content_base = (%f, %f, %f) [10 3BD]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content_base	struct
.	O
x	double
,	O
ctx	struct
->	O
content_base	struct
.	O
y	double
,	O
ctx	struct
->	O
content_base	struct
.	O
z	double
)	O
;	O
break	O
;	O
case	O
41	int
:	O
ctx	struct
->	O
text_height	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.text_height = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
140	int
:	O
ctx	struct
->	O
arrow_size	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.arrow_size = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
145	int
:	O
ctx	struct
->	O
landing_gap	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.landing_gap = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
174	int
:	O
ctx	struct
->	O
text_left	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.text_left = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
175	int
:	O
ctx	struct
->	O
text_right	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.text_right = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
176	int
:	O
ctx	struct
->	O
text_alignment	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.text_alignment = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
177	int
:	O
ctx	struct
->	O
attach_type	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.attach_type = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
290	int
:	O
if	O
(	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
has_content_txt	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.has_content_txt = %d [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
302	int
:	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LEADER{"	pointer
)	O
)	O
pair	pointer
=	O
add_MULTILEADER_leaders	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
break	O
;	O
case	O
304	int
:	O
if	O
(	O
ctx	struct
->	O
has_content_txt	char
)	O
{	O
if	O
(	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
default_text	pointer
=	O
(	O
char	O
*	O
)	O
bit_utf8_to_TU	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
else	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
default_text	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.default_text = %s [%d T]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
break	O
;	O
case	O
340	int
:	O
if	O
(	O
ctx	struct
->	O
has_content_txt	char
)	O
{	O
if	O
(	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
style	pointer
=	O
dwg_add_handleref	function
(	O
obj	pointer
->	O
parent	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.style = "	pointer
FORMAT_REF	pointer
" [%d H]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
style	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
break	O
;	O
case	O
11	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
normal	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
21	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
normal	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
31	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
normal	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.normal = (%f, %f, %f) [11 3BD]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
normal	struct
.	O
x	double
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
normal	struct
.	O
y	double
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
normal	struct
.	O
z	double
)	O
;	O
break	O
;	O
case	O
12	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
location	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
22	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
location	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
32	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
location	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.location = (%f, %f, %f) [12 3BD]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
location	struct
.	O
x	double
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
location	struct
.	O
y	double
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
location	struct
.	O
z	double
)	O
;	O
break	O
;	O
case	O
13	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
direction	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
23	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
direction	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
33	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
direction	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.direction = (%f, %f, %f) [13 3BD]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
direction	struct
.	O
x	double
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
direction	struct
.	O
y	double
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
direction	struct
.	O
z	double
)	O
;	O
break	O
;	O
case	O
42	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
rotation	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.rotation = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
rotation	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
43	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
width	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.width = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
44	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
height	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.height = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
45	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
line_spacing_factor	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.line_spacing_factor = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
170	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
line_spacing_style	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.line_spacing_style = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
171	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
alignment	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.alignment = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
172	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
break	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
flow	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.flow = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
90	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.color.index = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
91	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
bg_color	struct
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.bg_color.index = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
141	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
bg_scale	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.bg_scale = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
142	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
col_width	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.col_width = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
143	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
col_gutter	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.col_gutter = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
92	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
bg_transparency	int
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.bg_transparency = %u [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
291	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
is_bg_fill	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.is_bg_fill = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
292	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
is_bg_mask_fill	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.is_bg_mask_fill = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
293	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
is_height_auto	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.is_height_auto = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
294	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
is_col_flow_reversed	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.is_col_flow_reversed = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
295	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
word_break	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.word_break = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
173	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
col_type	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.col_type = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
144	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
i	int
++	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
num_col_sizes	int
=	O
i	int
+	O
1	int
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
col_sizes	pointer
=	O
realloc	function
(	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
col_sizes	pointer
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
ctx	struct
->	O
content	union
.	O
txt	struct
.	O
col_sizes	pointer
[	O
i	int
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.txt.col_sizes[%d] = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
296	int
:	O
if	O
(	O
ctx	struct
->	O
has_content_txt	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
has_content_blk	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.has_content_blk = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
14	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
normal	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.normal.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
24	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
normal	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.normal.y = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
34	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
normal	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.normal.z = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
341	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
block_table	pointer
=	O
dwg_add_handleref	function
(	O
obj	pointer
->	O
parent	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.block_table = "	pointer
FORMAT_REF	pointer
" [%d H]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
block_table	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
15	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
normal	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.normal.x = %f [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
25	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
location	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
35	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
location	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.location = (%f, %f, %f) [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
location	struct
.	O
x	double
,	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
location	struct
.	O
y	double
,	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
location	struct
.	O
z	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
16	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
scale	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
26	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
scale	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
36	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
scale	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.scale = (%f, %f, %f) [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
scale	struct
.	O
x	double
,	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
scale	struct
.	O
y	double
,	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
scale	struct
.	O
z	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
46	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
rotation	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.rotation = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
93	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.color.index = %d [CMC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
47	int
:	O
if	O
(	O
!	O
ctx	struct
->	O
has_content_blk	char
)	O
goto	O
unknown_mleader	O
;	O
j	long
++	O
;	O
if	O
(	O
!	O
j	long
)	O
{	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
transform	pointer
=	O
xcalloc	function
(	O
16	int
,	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
}	O
ctx	struct
->	O
content	union
.	O
blk	struct
.	O
transform	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.content.blk.transform[%d] = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
110	int
:	O
ctx	struct
->	O
base	int
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
120	int
:	O
ctx	struct
->	O
base	int
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
130	int
:	O
ctx	struct
->	O
base	int
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.base = (%f, %f, %f) [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
base	int
.	O
x	double
,	O
ctx	struct
->	O
base	int
.	O
y	double
,	O
ctx	struct
->	O
base	int
.	O
z	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
111	int
:	O
ctx	struct
->	O
base_dir	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
121	int
:	O
ctx	struct
->	O
base_dir	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
131	int
:	O
ctx	struct
->	O
base_dir	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.base = (%f, %f, %f) [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
base_dir	struct
.	O
x	double
,	O
ctx	struct
->	O
base_dir	struct
.	O
y	double
,	O
ctx	struct
->	O
base_dir	struct
.	O
z	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
112	int
:	O
ctx	struct
->	O
base_vert	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
122	int
:	O
ctx	struct
->	O
base_vert	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
132	int
:	O
ctx	struct
->	O
base_vert	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ctx.base = (%f, %f, %f) [3BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ctx	struct
->	O
base_vert	struct
.	O
x	double
,	O
ctx	struct
->	O
base_vert	struct
.	O
y	double
,	O
ctx	struct
->	O
base_vert	struct
.	O
z	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
297	int
:	O
ctx	struct
->	O
is_normal_reversed	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.is_normal_reversed = %i [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
273	int
:	O
ctx	struct
->	O
text_top	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.text_top = %i [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
272	int
:	O
ctx	struct
->	O
text_bottom	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ctx.text_bottom = %i [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
301	int
:	O
return	O
pair	pointer
;	O
default	O
:	O
unknown_mleader	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"MULTILEADER"	pointer
)	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_TABLESTYLE	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
Dwg_Object_TABLESTYLE	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
TABLESTYLE	pointer
;	O
BITCODE_H	pointer
hdl	array
;	O
int	O
i	int
=	O
-	O
1	int
,	O
j	long
=	O
-	O
1	int
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
7	int
:	O
i	int
++	O
;	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
hdl	array
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
pair	pointer
)	O
;	O
assert	O
(	O
hdl	array
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
text_style	pointer
=	O
hdl	array
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].text_style = "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
ARGS_REF	O
(	O
hdl	array
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
140	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
text_height	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].text_height = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
170	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
text_alignment	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].text_alignment = "	pointer
FORMAT_BS	O
" [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
text_alignment	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
62	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
text_color	struct
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].text_color.index = %d [CMC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
63	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
fill_color	struct
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].fill_color.index = %d [CMC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
283	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
has_bgcolor	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].has_bgcolor = %d [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
90	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
data_type	int
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].data_type = %d [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
91	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
unit_type	int
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].unit_type = %d [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
1	int
:	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
format_string	pointer
=	O
bit_utf8_to_TU	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].format_string = %s [TU %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
274	int
:	O
case	O
275	int
:	O
case	O
276	int
:	O
case	O
277	int
:	O
case	O
278	int
:	O
case	O
279	int
:	O
j	long
=	O
pair	pointer
->	O
code	char
-	O
274	int
;	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
j	long
>=	O
0	int
&&	O
j	long
<=	O
6	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
if	O
(	O
!	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
borders	pointer
)	O
{	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
borders	pointer
=	O
xcalloc	function
(	O
6	int
,	O
sizeof	O
(	O
Dwg_TABLESTYLE_border	struct
)	O
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
num_borders	int
=	O
6	int
;	O
}	O
assert	O
(	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
num_borders	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
borders	pointer
[	O
j	long
]	O
.	O
linewt	char
=	O
dxf_find_lweight	function
(	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].borders[%d].linewt = %d [BSd %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
borders	pointer
[	O
j	long
]	O
.	O
linewt	char
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
284	int
:	O
case	O
285	int
:	O
case	O
286	int
:	O
case	O
287	int
:	O
case	O
288	int
:	O
case	O
289	int
:	O
j	long
=	O
pair	pointer
->	O
code	char
-	O
284	int
;	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
j	long
>=	O
0	int
&&	O
j	long
<=	O
6	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
borders	pointer
[	O
j	long
]	O
.	O
visible	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].borders[%d].visible = %d [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
64	int
:	O
case	O
65	int
:	O
case	O
66	int
:	O
case	O
67	int
:	O
case	O
68	int
:	O
case	O
69	int
:	O
j	long
=	O
pair	pointer
->	O
code	char
-	O
64	int
;	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
3	int
)	O
;	O
assert	O
(	O
j	long
>=	O
0	int
&&	O
j	long
<=	O
6	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
num_rowstyles	int
)	O
;	O
o	pointer
->	O
rowstyles	pointer
[	O
i	int
]	O
.	O
borders	pointer
[	O
j	long
]	O
.	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.rowstyles[%d].borders[%d].color.index = %d [CMC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"TABLESTYLE"	pointer
)	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_DIMASSOC	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_DIMASSOC	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DIMASSOC	char
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
have_rotated_type	int
=	O
0	int
;	O
o	pointer
->	O
ref	pointer
=	O
xcalloc	function
(	O
4	int
,	O
sizeof	O
(	O
Dwg_DIMASSOC_Ref	struct
)	O
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
71	int
:	O
i	int
++	O
;	O
while	O
(	O
!	O
(	O
o	pointer
->	O
associativity	int
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
&&	O
i	int
<	O
4	int
)	O
i	int
++	O
;	O
if	O
(	O
!	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<=	O
3	int
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid DIMASSOC_Ref index %d"	pointer
,	O
i	int
)	O
return	O
pair	pointer
;	O
}	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
rotated_type	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
have_rotated_type	int
=	O
1	int
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].rotated_type = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
strNE	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"AcDbOsnapPointRef"	pointer
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid DIMASSOC subclass %s"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
if	O
(	O
!	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<=	O
3	int
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid DIMASSOC_Ref index %d"	pointer
,	O
i	int
)	O
return	O
pair	pointer
;	O
}	O
if	O
(	O
!	O
have_rotated_type	int
)	O
{	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
rotated_type	short
=	O
1	int
;	O
i	int
++	O
;	O
while	O
(	O
!	O
(	O
o	pointer
->	O
associativity	int
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
&&	O
i	int
<	O
4	int
)	O
i	int
++	O
;	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<=	O
3	int
)	O
;	O
}	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
classname	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].classname = %s [TV %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
have_rotated_type	int
=	O
0	int
;	O
break	O
;	O
case	O
72	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_type	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].osnap_type = %d [RC %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
331	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
mainobj	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].mainobj = "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
ARGS_REF	O
(	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
mainobj	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
332	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
intsectobj	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].intsectobj = "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
ARGS_REF	O
(	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
intsectobj	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
73	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
main_subent_type	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].main_subent_type = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
74	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
intsect_subent_type	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].intsect_subent_type = %d [BS %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
75	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
has_lastpt_ref	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].has_lastpt_ref = %d [B %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
91	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
main_gsmarker	int
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].main_gsmarker = %d [BL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
40	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_dist	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].osnap_dist = %f [BD %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
case	O
10	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_pt	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
20	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_pt	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
break	O
;	O
case	O
30	int
:	O
if	O
(	O
i	int
<	O
0	int
)	O
break	O
;	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_pt	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.ref[%d].osnap_pt = (%f, %f, %f) [3BD 10]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
i	int
,	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_pt	struct
.	O
x	double
,	O
o	pointer
->	O
ref	pointer
[	O
i	int
]	O
.	O
osnap_pt	struct
.	O
y	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"DIMASSOC"	pointer
)	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_ASSOCACTION	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_ASSOCACTION	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
ASSOCACTION	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
EXPECT_INT_DXF	O
(	O
"solution_status"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"geometry_status"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_H_DXF	O
(	O
"readdep"	pointer
,	O
5	int
,	O
330	int
,	O
H	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_H_DXF	O
(	O
"writedep"	pointer
,	O
5	int
,	O
360	int
,	O
H	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"constraint_status"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"dof"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"is_body_a_proxy"	pointer
,	O
90	int
,	O
B	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_PERSSUBENTMANAGER	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_PERSSUBENTMANAGER	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
PERSSUBENTMANAGER	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
EXPECT_INT_DXF	O
(	O
"class_version"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_bl1"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_bl2"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_bl3"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_bl4"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_bl5"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_bl6"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_ASSOCDEPENDENCY	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_ASSOCDEPENDENCY	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
ASSOCDEPENDENCY	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
EXPECT_INT_DXF	O
(	O
"class_version"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"status"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"isread_dep"	pointer
,	O
290	int
,	O
B	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"iswrite_dep"	pointer
,	O
290	int
,	O
B	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"isobjectstate_dep"	pointer
,	O
290	int
,	O
B	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_b4"	pointer
,	O
290	int
,	O
B	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"order"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_H_DXF	O
(	O
"readdep"	pointer
,	O
5	int
,	O
330	int
,	O
H	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"unknown_b5"	pointer
,	O
290	int
,	O
B	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"depbodyid"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_H_DXF	O
(	O
"readdep"	pointer
,	O
5	int
,	O
330	int
,	O
H	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_H_DXF	O
(	O
"node"	pointer
,	O
5	int
,	O
330	int
,	O
H	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_H_DXF	O
(	O
"writedep"	pointer
,	O
5	int
,	O
360	int
,	O
H	O
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
EXPECT_INT_DXF	O
(	O
"depbodyid"	pointer
,	O
90	int
,	O
BL	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
Dwg_Object	struct
*	O
find_prev_entity	function
(	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
if	O
(	O
obj	pointer
->	O
supertype	enum
!=	O
DWG_SUPERTYPE_ENTITY	int
)	O
return	O
NULL	O
;	O
for	O
(	O
BITCODE_BL	int
i	int
=	O
obj	pointer
->	O
index	short
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
{	O
Dwg_Object	struct
*	O
prev	int
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
if	O
(	O
prev	int
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
&&	O
prev	int
->	O
tio	union
.	O
entity	long
->	O
entmode	char
==	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
entmode	char
)	O
{	O
if	O
(	O
prev	int
->	O
fixedtype	enum
==	O
DWG_TYPE_SEQEND	int
||	O
prev	int
->	O
fixedtype	enum
==	O
DWG_TYPE_ENDBLK	int
)	O
return	O
NULL	O
;	O
else	O
return	O
prev	int
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
is_obj_absref	function
(	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
if	O
(	O
obj	pointer
->	O
type	short
<	O
DWG_TYPE_GROUP	int
&&	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_DICTIONARY	int
&&	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_XRECORD	int
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
Dxf_Pair	struct
*	O
new_table_control	function
(	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
NULL	O
;	O
Dwg_Object_LTYPE_CONTROL	struct
*	O
_obj	pointer
=	O
NULL	O
;	O
int	O
j	long
=	O
0	int
;	O
int	O
is_utf	int
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
?	O
1	int
:	O
0	int
;	O
char	O
*	O
fieldname	pointer
;	O
char	O
ctrlname	array
[	O
80	int
]	O
;	O
char	O
*	O
dxfname	pointer
;	O
BITCODE_B	char
xrefref	char
;	O
NEW_OBJECT	O
(	O
dwg	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK_RECORD"	pointer
)	O
)	O
strcpy	function
(	O
ctrlname	array
,	O
"BLOCK_CONTROL"	pointer
)	O
;	O
else	O
{	O
strncpy	function
(	O
ctrlname	array
,	O
name	pointer
,	O
70	int
)	O
;	O
ctrlname	array
[	O
69	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
ctrlname	array
,	O
"_CONTROL"	pointer
)	O
;	O
}	O
LOG_TRACE	O
(	O
"add %s\n"	pointer
,	O
ctrlname	array
)	O
;	O
dxfname	pointer
=	O
strdup	function
(	O
ctrlname	array
)	O
;	O
ADD_TABLE_IF	O
(	O
LTYPE	pointer
,	O
LTYPE_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
VPORT	pointer
,	O
VPORT_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
APPID	pointer
,	O
APPID_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
BLOCK_RECORD	O
,	O
BLOCK_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
DIMSTYLE	pointer
,	O
DIMSTYLE_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
LAYER	pointer
,	O
LAYER_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
STYLE	pointer
,	O
STYLE_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
UCS	pointer
,	O
UCS_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
VIEW	pointer
,	O
VIEW_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
VPORT_ENTITY	O
,	O
VPORT_ENTITY_CONTROL	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
BLOCK_RECORD	O
,	O
BLOCK_CONTROL	pointer
)	O
else	O
{	O
LOG_ERROR	O
(	O
"Unknown DXF TABLE %s nor %s_CONTROL"	pointer
,	O
name	pointer
,	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
if	O
(	O
!	O
_obj	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Empty _obj at DXF TABLE %s nor %s_CONTROL"	pointer
,	O
name	pointer
,	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"objid"	pointer
,	O
&	O
obj	pointer
->	O
index	short
,	O
1	int
)	O
;	O
xrefref	char
=	O
1	int
;	O
if	O
(	O
dwg_dynapi_entity_field	function
(	O
obj	pointer
->	O
name	pointer
,	O
"xrefref"	pointer
)	O
)	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"xrefref"	pointer
,	O
&	O
xrefref	char
,	O
1	int
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
1	int
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
goto	O
do_return	O
;	O
case	O
5	int
:	O
case	O
105	int
:	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
;	O
char	O
ctrlobj	array
[	O
80	int
]	O
;	O
dwg_add_handle	function
(	O
&	O
obj	pointer
->	O
handle	pointer
,	O
0	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
ref	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.handle = "	pointer
FORMAT_H	pointer
" [H %d]\n"	pointer
,	O
ctrlname	array
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
strncpy	function
(	O
ctrlobj	array
,	O
ctrlname	array
,	O
70	int
)	O
;	O
ctrlobj	array
[	O
69	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
ctrlobj	array
,	O
"_OBJECT"	pointer
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
ctrlobj	array
,	O
&	O
ref	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s = "	pointer
FORMAT_REF	pointer
" [H 0]\n"	pointer
,	O
ctrlobj	array
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
100	int
:	O
break	O
;	O
case	O
102	int
:	O
break	O
;	O
case	O
330	int
:	O
{	O
BITCODE_H	pointer
owh	pointer
;	O
if	O
(	O
is_obj_absref	function
(	O
obj	pointer
)	O
)	O
owh	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
else	O
owh	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
=	O
owh	pointer
;	O
LOG_TRACE	O
(	O
"%s.ownerhandle = "	pointer
FORMAT_REF	pointer
" [H 330]\n"	pointer
,	O
ctrlname	array
,	O
ARGS_REF	O
(	O
owh	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
340	int
:	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
&&	O
strEQc	O
(	O
ctrlname	array
,	O
"DIMSTYLE_CONTROL"	pointer
)	O
)	O
{	O
Dwg_Object_DIMSTYLE_CONTROL	struct
*	O
_o	pointer
=	O
(	O
Dwg_Object_DIMSTYLE_CONTROL	struct
*	O
)	O
_obj	pointer
;	O
if	O
(	O
!	O
_o	pointer
->	O
num_morehandles	char
||	O
j	long
<	O
0	int
||	O
j	long
>=	O
_o	pointer
->	O
num_morehandles	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid DIMSTYLE_CONTROL.num_morehandles %d or index %d"	pointer
,	O
_o	pointer
->	O
num_morehandles	char
,	O
j	long
)	O
break	O
;	O
}	O
assert	O
(	O
_o	pointer
->	O
morehandles	pointer
)	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
_o	pointer
->	O
num_morehandles	char
)	O
;	O
_o	pointer
->	O
morehandles	pointer
[	O
j	long
]	O
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.morehandles[%d] = "	pointer
FORMAT_REF	pointer
" [H 330]\n"	pointer
,	O
ctrlname	array
,	O
j	long
,	O
ARGS_REF	O
(	O
_o	pointer
->	O
morehandles	pointer
[	O
j	long
]	O
)	O
)	O
;	O
j	long
++	O
;	O
}	O
break	O
;	O
case	O
360	int
:	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
0	int
;	O
LOG_TRACE	O
(	O
"%s.xdicobjhandle = "	pointer
FORMAT_REF	pointer
" [H 360]\n"	pointer
,	O
ctrlname	array
,	O
ARGS_REF	O
(	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
)	O
)	O
;	O
break	O
;	O
case	O
70	int
:	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
BITCODE_H	pointer
*	O
hdls	pointer
;	O
BITCODE_BL	int
num_entries	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
<	O
0	int
?	O
0	int
:	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_entries"	pointer
,	O
&	O
num_entries	short
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.num_entries = %u [BL 70]\n"	pointer
,	O
ctrlname	array
,	O
num_entries	short
)	O
;	O
hdls	pointer
=	O
xcalloc	function
(	O
num_entries	short
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"entries"	pointer
,	O
&	O
hdls	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"Add %d %s.%s\n"	pointer
,	O
num_entries	short
,	O
ctrlname	array
,	O
"entries"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
71	int
:	O
if	O
(	O
strEQc	O
(	O
ctrlname	array
,	O
"DIMSTYLE_CONTROL"	pointer
)	O
)	O
{	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
BITCODE_H	pointer
*	O
hdls	pointer
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_morehandles"	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
is_utf	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.num_morehandles = %u [BL 71]\n"	pointer
,	O
ctrlname	array
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
hdls	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"morehandles"	pointer
,	O
&	O
hdls	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"Add %s.morehandles[%d]\n"	pointer
,	O
ctrlname	array
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"%s.num_morehandles = %u [BL 71]\n"	pointer
,	O
ctrlname	array
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
}	O
break	O
;	O
}	O
default	O
:	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
1000	int
&&	O
pair	pointer
->	O
code	char
<	O
1999	int
)	O
{	O
add_eed	function
(	O
obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
)	O
;	O
}	O
else	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
ctrlname	array
)	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
do_return	O
:	O
if	O
(	O
!	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
1	int
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<	O
R_2004	int
)	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
0	int
,	O
obj	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
BITCODE_H	pointer
find_tablehandle	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
BITCODE_H	pointer
ref	pointer
=	O
NULL	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
8	int
)	O
ref	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LAYER"	pointer
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
1	int
)	O
ref	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BLOCK"	pointer
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
2	int
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
3	int
)	O
ref	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"DIMSTYLE"	pointer
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
6	int
)	O
ref	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"LTYPE"	pointer
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
7	int
)	O
ref	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"STYLE"	pointer
)	O
;	O
if	O
(	O
ref	pointer
)	O
return	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
ref	pointer
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
ref	pointer
&&	O
pair	pointer
->	O
code	char
>	O
300	int
)	O
{	O
for	O
(	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_object_refs	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
refi	pointer
=	O
dwg	pointer
->	O
object_ref	pointer
[	O
i	int
]	O
;	O
if	O
(	O
refi	pointer
->	O
absolute_ref	long
==	O
(	O
BITCODE_BL	int
)	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
{	O
ref	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
ref	pointer
)	O
{	O
ref	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
}	O
}	O
return	O
ref	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_xdata	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
BITCODE_BL	int
num_xdata	int
,	O
num_databytes	int
;	O
Dwg_Resbuf	struct
*	O
rbuf	pointer
;	O
Dwg_Object_XRECORD	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
XRECORD	pointer
;	O
num_xdata	int
=	O
_obj	pointer
->	O
num_xdata	int
;	O
num_databytes	int
=	O
_obj	pointer
->	O
num_databytes	int
;	O
rbuf	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Resbuf	struct
)	O
)	O
;	O
if	O
(	O
!	O
rbuf	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
num_xdata	int
&&	O
_obj	pointer
->	O
xdata	pointer
)	O
{	O
Dwg_Resbuf	struct
*	O
xdata	pointer
,	O
*	O
prev	int
;	O
prev	int
=	O
xdata	pointer
=	O
_obj	pointer
->	O
xdata	pointer
;	O
while	O
(	O
xdata	pointer
)	O
{	O
prev	int
=	O
xdata	pointer
;	O
xdata	pointer
=	O
xdata	pointer
->	O
next	pointer
;	O
}	O
prev	int
->	O
next	pointer
=	O
rbuf	pointer
;	O
xdata	pointer
=	O
_obj	pointer
->	O
xdata	pointer
;	O
}	O
else	O
_obj	pointer
->	O
xdata	pointer
=	O
rbuf	pointer
;	O
num_databytes	int
+=	O
2	int
;	O
rbuf	pointer
->	O
type	short
=	O
pair	pointer
->	O
code	char
;	O
switch	O
(	O
get_base_value_type	function
(	O
rbuf	pointer
->	O
type	short
)	O
)	O
{	O
case	O
VT_STRING	int
:	O
PRE	O
(	O
R_2007	int
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
codepage	int
=	O
dwg	pointer
->	O
header	struct
.	O
codepage	int
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%d]: \"%s\" [%d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
num_databytes	int
+=	O
3	int
+	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
;	O
}	O
LATER_VERSIONS	O
{	O
int	O
length	double
=	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
if	O
(	O
length	double
>	O
0	int
)	O
{	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
=	O
bit_utf8_to_TU	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
num_databytes	int
+=	O
2	int
+	O
2	int
*	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
;	O
}	O
break	O
;	O
case	O
VT_REAL	int
:	O
rbuf	pointer
->	O
value	double
.	O
dbl	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"xdata[%d]: %f [%d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
dbl	double
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
num_databytes	int
+=	O
8	int
;	O
break	O
;	O
case	O
VT_BOOL	int
:	O
case	O
VT_INT8	int
:	O
rbuf	pointer
->	O
value	double
.	O
i8	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"xdata[%d]: %d [%d]\n"	pointer
,	O
num_xdata	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i8	char
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
num_databytes	int
+=	O
1	int
;	O
break	O
;	O
case	O
VT_INT16	int
:	O
rbuf	pointer
->	O
value	double
.	O
i16	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"xdata[%d]: %d [%d]\n"	pointer
,	O
num_xdata	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i16	short
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
num_databytes	int
+=	O
2	int
;	O
break	O
;	O
case	O
VT_INT32	int
:	O
rbuf	pointer
->	O
value	double
.	O
i32	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"xdata[%d]: %ld [%d]\n"	pointer
,	O
num_xdata	int
,	O
(	O
long	O
)	O
rbuf	pointer
->	O
value	double
.	O
i32	int
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
num_databytes	int
+=	O
4	int
;	O
break	O
;	O
case	O
VT_INT64	int
:	O
rbuf	pointer
->	O
value	double
.	O
i64	long
=	O
(	O
BITCODE_BLL	long
)	O
pair	pointer
->	O
value	double
.	O
bll	long
;	O
LOG_TRACE	O
(	O
"xdata[%d]: "	pointer
FORMAT_BLL	O
" [%d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
i64	long
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
num_databytes	int
+=	O
8	int
;	O
break	O
;	O
case	O
VT_POINT3D	int
:	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
NULL	O
;	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
num_databytes	int
+=	O
24	int
;	O
{	O
long	O
pos	pointer
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
get_base_value_type	function
(	O
pair	pointer
->	O
code	char
)	O
==	O
VT_POINT3D	int
)	O
{	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"xdata[%d]: (%f,%f,%f) [%d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
}	O
else	O
{	O
bit_set_position	function
(	O
dat	pointer
,	O
pos	pointer
)	O
;	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
=	O
0	int
;	O
LOG_TRACE	O
(	O
"xdata[%d]: (%f,%f) [%d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
VT_BINARY	int
:	O
{	O
int	O
i	int
;	O
int	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
int	O
blen	int
=	O
len	long
/	O
2	int
;	O
char	O
*	O
s	pointer
=	O
malloc	function
(	O
blen	int
)	O
;	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
=	O
s	pointer
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
blen	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
blen	int
;	O
i	int
++	O
)	O
{	O
sscanf	function
(	O
pos	pointer
,	O
"%2hhX"	pointer
,	O
&	O
s	pointer
[	O
i	int
]	O
)	O
;	O
pos	pointer
+=	O
2	int
;	O
}	O
num_databytes	int
+=	O
1	int
+	O
len	long
;	O
LOG_TRACE	O
(	O
"xdata[%d]: "	pointer
,	O
num_xdata	int
)	O
;	O
}	O
break	O
;	O
case	O
VT_HANDLE	int
:	O
case	O
VT_OBJECTID	int
:	O
num_databytes	int
+=	O
8	int
;	O
dwg_add_handle	function
(	O
&	O
rbuf	pointer
->	O
value	double
.	O
h	struct
,	O
0	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%d]: "	pointer
FORMAT_H	pointer
" [H %d]\n"	pointer
,	O
num_xdata	int
,	O
ARGS_H	O
(	O
rbuf	pointer
->	O
value	double
.	O
h	struct
)	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INVALID	int
:	O
default	O
:	O
LOG_ERROR	O
(	O
"Invalid group code in rbuf: %d"	pointer
,	O
rbuf	pointer
->	O
type	short
)	O
}	O
num_xdata	int
++	O
;	O
_obj	pointer
->	O
num_xdata	int
=	O
num_xdata	int
;	O
_obj	pointer
->	O
num_databytes	int
=	O
num_databytes	int
;	O
return	O
pair	pointer
;	O
}	O
static	O
void	O
add_dictionary_itemhandles	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
,	O
char	O
*	O
restrict	O
text	pointer
)	O
{	O
Dwg_Object_DICTIONARY	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DICTIONARY	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
BITCODE_BL	int
num	long
;	O
BITCODE_H	pointer
hdl	array
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
360	int
)	O
_obj	pointer
->	O
hard_owner	char
=	O
1	int
;	O
num	long
=	O
_obj	pointer
->	O
numitems	int
;	O
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
2	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.itemhandles[%d] = "	pointer
FORMAT_REF	pointer
" [H* %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
num	long
,	O
ARGS_REF	O
(	O
hdl	array
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
_obj	pointer
->	O
itemhandles	pointer
=	O
realloc	function
(	O
_obj	pointer
->	O
itemhandles	pointer
,	O
(	O
num	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
_obj	pointer
->	O
itemhandles	pointer
[	O
num	long
]	O
=	O
hdl	array
;	O
_obj	pointer
->	O
texts	pointer
=	O
realloc	function
(	O
_obj	pointer
->	O
texts	pointer
,	O
(	O
num	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_TV	pointer
)	O
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
_obj	pointer
->	O
texts	pointer
[	O
num	long
]	O
=	O
(	O
char	O
*	O
)	O
bit_utf8_to_TU	function
(	O
text	pointer
)	O
;	O
else	O
_obj	pointer
->	O
texts	pointer
[	O
num	long
]	O
=	O
strdup	function
(	O
text	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.texts[%d] = %s [T* 3]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
num	long
,	O
text	pointer
)	O
;	O
_obj	pointer
->	O
numitems	int
=	O
num	long
+	O
1	int
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_ent_preview	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
unsigned	O
written	int
=	O
0	int
;	O
if	O
(	O
obj	pointer
->	O
supertype	enum
!=	O
DWG_SUPERTYPE_ENTITY	int
)	O
{	O
LOG_ERROR	O
(	O
"%s is no entity for a preview"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
ent	pointer
->	O
preview_size	int
=	O
pair	pointer
->	O
code	char
==	O
160	int
?	O
pair	pointer
->	O
value	double
.	O
bll	long
:	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
if	O
(	O
!	O
ent	pointer
->	O
preview_size	int
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
ent	pointer
->	O
preview	pointer
=	O
calloc	function
(	O
ent	pointer
->	O
preview_size	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
ent	pointer
->	O
preview	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
LOG_TRACE	O
(	O
"%s.preview_size = "	pointer
FORMAT_BLL	O
" [BLL %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ent	pointer
->	O
preview_size	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
ent	pointer
->	O
preview_exists	char
=	O
1	int
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
310	int
)	O
{	O
unsigned	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
unsigned	O
blen	int
=	O
len	long
/	O
2	int
;	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
char	O
*	O
s	pointer
=	O
&	O
ent	pointer
->	O
preview	pointer
[	O
written	int
]	O
;	O
if	O
(	O
blen	int
+	O
written	int
>	O
ent	pointer
->	O
preview_size	int
)	O
{	O
LOG_ERROR	O
(	O
"%s.preview overflow: %u + written %u > size: "	pointer
FORMAT_BLL	O
,	O
obj	pointer
->	O
name	pointer
,	O
blen	int
,	O
written	int
,	O
ent	pointer
->	O
preview_size	int
)	O
;	O
return	O
pair	pointer
;	O
}	O
for	O
(	O
unsigned	O
i	int
=	O
0	int
;	O
i	int
<	O
blen	int
;	O
i	int
++	O
)	O
{	O
sscanf	function
(	O
pos	pointer
,	O
"%2hhX"	pointer
,	O
&	O
s	pointer
[	O
i	int
]	O
)	O
;	O
pos	pointer
+=	O
2	int
;	O
}	O
written	int
+=	O
blen	int
;	O
LOG_TRACE	O
(	O
"%s.preview += %u (%u/"	pointer
FORMAT_BLL	O
")\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
blen	int
,	O
written	int
,	O
ent	pointer
->	O
preview_size	int
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
Dxf_Pair	struct
*	O
add_block_preview	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
unsigned	O
written	int
=	O
0	int
;	O
if	O
(	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
LOG_ERROR	O
(	O
"%s is no BLOCK_HEADER for a preview"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
if	O
(	O
pair	pointer
->	O
code	char
!=	O
310	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid %s.preview code %d, need 310"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
return	O
pair	pointer
;	O
}	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
310	int
)	O
{	O
unsigned	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
unsigned	O
blen	int
=	O
len	long
/	O
2	int
;	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
char	O
*	O
s	pointer
;	O
_obj	pointer
->	O
preview	pointer
=	O
realloc	function
(	O
_obj	pointer
->	O
preview	pointer
,	O
written	int
+	O
blen	int
)	O
;	O
s	pointer
=	O
&	O
_obj	pointer
->	O
preview	pointer
[	O
written	int
]	O
;	O
for	O
(	O
unsigned	O
i	int
=	O
0	int
;	O
i	int
<	O
blen	int
;	O
i	int
++	O
)	O
{	O
sscanf	function
(	O
pos	pointer
,	O
"%2hhX"	pointer
,	O
&	O
s	pointer
[	O
i	int
]	O
)	O
;	O
pos	pointer
+=	O
2	int
;	O
}	O
written	int
+=	O
blen	int
;	O
LOG_TRACE	O
(	O
"BLOCK_HEADER.preview += %u (%u)\n"	pointer
,	O
blen	int
,	O
written	int
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
}	O
_obj	pointer
->	O
preview_size	int
=	O
written	int
;	O
LOG_TRACE	O
(	O
"BLOCK_HEADER.preview_size = %u [BL 0]\n"	pointer
,	O
written	int
)	O
;	O
return	O
pair	pointer
;	O
}	O
static	O
int	O
add_SPLINE	function
(	O
Dwg_Entity_SPLINE	struct
*	O
restrict	O
_o	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
,	O
int	O
*	O
restrict	O
jp	pointer
,	O
BITCODE_RS	short
*	O
restrict	O
flagp	pointer
)	O
{	O
int	O
j	long
=	O
*	O
jp	pointer
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
210	int
||	O
pair	pointer
->	O
code	char
==	O
220	int
||	O
pair	pointer
->	O
code	char
==	O
230	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
70	int
)	O
{	O
BITCODE_RS	short
flag	short
=	O
*	O
flagp	pointer
;	O
*	O
flagp	pointer
=	O
flag	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
_o	pointer
->	O
flag	short
=	O
flag	short
;	O
LOG_TRACE	O
(	O
"SPLINE.flag = %d [RS 70]\n"	pointer
,	O
flag	short
)	O
;	O
if	O
(	O
flag	short
&	O
1	int
)	O
{	O
_o	pointer
->	O
closed_b	char
=	O
1	int
;	O
LOG_TRACE	O
(	O
"SPLINE.closed_b = 1 [B 0] (1st bit)\n"	pointer
)	O
;	O
}	O
if	O
(	O
flag	short
&	O
2	int
)	O
{	O
_o	pointer
->	O
periodic	char
=	O
1	int
;	O
LOG_TRACE	O
(	O
"SPLINE.periodic = 1 [B 0] (2nd bit)\n"	pointer
)	O
;	O
}	O
if	O
(	O
flag	short
&	O
4	int
)	O
{	O
_o	pointer
->	O
rational	char
=	O
1	int
;	O
LOG_TRACE	O
(	O
"SPLINE.rational = 1 [B 0] (3rd bit)\n"	pointer
)	O
;	O
}	O
if	O
(	O
flag	short
&	O
8	int
)	O
{	O
_o	pointer
->	O
weighted	char
=	O
1	int
;	O
LOG_TRACE	O
(	O
"SPLINE.weighted = 1 [B 0] (4th bit)\n"	pointer
)	O
;	O
}	O
if	O
(	O
flag	short
&	O
1024	int
)	O
{	O
_o	pointer
->	O
scenario	short
=	O
2	int
;	O
LOG_TRACE	O
(	O
"SPLINE.scenario = 2 [B 0] (bezier)\n"	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
72	int
)	O
{	O
_o	pointer
->	O
num_knots	int
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
*	O
jp	pointer
=	O
0	int
;	O
_o	pointer
->	O
knots	pointer
=	O
xcalloc	function
(	O
_o	pointer
->	O
num_knots	int
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
LOG_TRACE	O
(	O
"SPLINE.num_knots = %d [BS 72]\n"	pointer
,	O
_o	pointer
->	O
num_knots	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
73	int
)	O
{	O
_o	pointer
->	O
num_ctrl_pts	int
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
*	O
jp	pointer
=	O
0	int
;	O
_o	pointer
->	O
ctrl_pts	pointer
=	O
xcalloc	function
(	O
_o	pointer
->	O
num_ctrl_pts	int
,	O
sizeof	O
(	O
Dwg_SPLINE_control_point	struct
)	O
)	O
;	O
LOG_TRACE	O
(	O
"SPLINE.num_ctrl_pts = %d [BS 73]\n"	pointer
,	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
74	int
)	O
{	O
_o	pointer
->	O
num_fit_pts	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
*	O
jp	pointer
=	O
0	int
;	O
_o	pointer
->	O
fit_pts	pointer
=	O
xcalloc	function
(	O
_o	pointer
->	O
num_fit_pts	short
,	O
sizeof	O
(	O
Dwg_SPLINE_point	struct
)	O
)	O
;	O
_o	pointer
->	O
scenario	short
=	O
2	int
;	O
_o	pointer
->	O
flag	short
|=	O
1024	int
;	O
LOG_TRACE	O
(	O
"SPLINE.num_fit_pts = %d [BS 74]\n"	pointer
,	O
_o	pointer
->	O
num_fit_pts	short
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
40	int
)	O
{	O
if	O
(	O
*	O
jp	pointer
>=	O
(	O
int	O
)	O
_o	pointer
->	O
num_knots	int
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.knots[%d] overflow, max %d"	pointer
,	O
*	O
jp	pointer
,	O
_o	pointer
->	O
num_knots	int
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
knots	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"SPLINE.knots[%d] = %f [BD* 40]\n"	pointer
,	O
*	O
jp	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
j	long
++	O
;	O
*	O
jp	pointer
=	O
j	long
;	O
if	O
(	O
j	long
==	O
(	O
int	O
)	O
_o	pointer
->	O
num_knots	int
)	O
*	O
jp	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
)	O
{	O
if	O
(	O
*	O
jp	pointer
>=	O
(	O
int	O
)	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.ctrl_pts[%d] overflow, max %d"	pointer
,	O
*	O
jp	pointer
,	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
parent	pointer
=	O
_o	pointer
;	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
{	O
if	O
(	O
j	long
>=	O
(	O
int	O
)	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.ctrl_pts[%d] overflow, max %d"	pointer
,	O
j	long
,	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
30	int
)	O
{	O
if	O
(	O
j	long
>=	O
(	O
int	O
)	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.ctrl_pts[%d] overflow, max %d"	pointer
,	O
j	long
,	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"SPLINE.ctrl_pts[%d] = (%f, %f, %f) [3BD* 10]\n"	pointer
,	O
*	O
jp	pointer
,	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
x	double
,	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
y	double
,	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
z	double
)	O
;	O
j	long
++	O
;	O
*	O
jp	pointer
=	O
j	long
;	O
if	O
(	O
j	long
==	O
(	O
int	O
)	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
*	O
jp	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
41	int
)	O
{	O
if	O
(	O
j	long
>=	O
(	O
int	O
)	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.ctrl_pts[%d] overflow, max %d"	pointer
,	O
j	long
,	O
_o	pointer
->	O
num_ctrl_pts	int
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
w	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"SPLINE.ctrl_pts[%d].w = %f [BD* 41]\n"	pointer
,	O
*	O
jp	pointer
,	O
_o	pointer
->	O
ctrl_pts	pointer
[	O
j	long
]	O
.	O
w	double
)	O
;	O
j	long
++	O
;	O
*	O
jp	pointer
=	O
j	long
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
11	int
)	O
{	O
if	O
(	O
j	long
>=	O
_o	pointer
->	O
num_fit_pts	short
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.fit_pts[%d] overflow, max %d"	pointer
,	O
j	long
,	O
_o	pointer
->	O
num_fit_pts	short
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
parent	pointer
=	O
_o	pointer
;	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
21	int
)	O
{	O
if	O
(	O
j	long
>=	O
_o	pointer
->	O
num_fit_pts	short
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.fit_pts[%d] overflow, max %d"	pointer
,	O
j	long
,	O
_o	pointer
->	O
num_fit_pts	short
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
31	int
)	O
{	O
if	O
(	O
j	long
>=	O
_o	pointer
->	O
num_fit_pts	short
)	O
{	O
LOG_ERROR	O
(	O
"SPLINE.fit_pts[%d] overflow, max %d"	pointer
,	O
j	long
,	O
_o	pointer
->	O
num_fit_pts	short
)	O
;	O
return	O
1	int
;	O
}	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"SPLINE.fit_pts[%d] = (%f, %f, %f) [3BD* 11]\n"	pointer
,	O
*	O
jp	pointer
,	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
x	double
,	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
y	double
,	O
_o	pointer
->	O
fit_pts	pointer
[	O
j	long
]	O
.	O
z	double
)	O
;	O
j	long
++	O
;	O
*	O
jp	pointer
=	O
j	long
;	O
if	O
(	O
j	long
==	O
(	O
int	O
)	O
_o	pointer
->	O
num_fit_pts	short
)	O
*	O
jp	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
add_MLINE	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dxf_Pair	struct
*	O
restrict	O
pair	pointer
,	O
int	O
*	O
restrict	O
jp	pointer
,	O
int	O
*	O
restrict	O
kp	pointer
,	O
int	O
*	O
restrict	O
lp	pointer
)	O
{	O
Dwg_Entity_MLINE	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MLINE	pointer
;	O
int	O
found	int
=	O
1	int
;	O
int	O
j	long
=	O
*	O
jp	pointer
;	O
int	O
k	int
=	O
*	O
kp	pointer
;	O
int	O
l	long
=	O
*	O
lp	pointer
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
72	int
)	O
{	O
_o	pointer
->	O
num_verts	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
_o	pointer
->	O
parent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
_o	pointer
->	O
verts	pointer
=	O
xcalloc	function
(	O
_o	pointer
->	O
num_verts	short
,	O
sizeof	O
(	O
Dwg_MLINE_vertex	struct
)	O
)	O
;	O
LOG_TRACE	O
(	O
"MLINE.num_verts = %d [BS 72]\n"	pointer
,	O
_o	pointer
->	O
num_verts	short
)	O
;	O
*	O
jp	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
73	int
)	O
{	O
_o	pointer
->	O
num_lines	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
for	O
(	O
int	O
_j	int
=	O
0	int
;	O
_j	int
<	O
_o	pointer
->	O
num_verts	short
;	O
_j	int
++	O
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
_j	int
]	O
.	O
lines	pointer
=	O
xcalloc	function
(	O
_o	pointer
->	O
num_lines	char
,	O
sizeof	O
(	O
Dwg_MLINE_line	struct
)	O
)	O
;	O
}	O
LOG_TRACE	O
(	O
"MLINE.num_lines = %d [BS 73]\n"	pointer
,	O
_o	pointer
->	O
num_lines	char
)	O
;	O
*	O
kp	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
11	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
parent	pointer
=	O
_o	pointer
;	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex	pointer
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
21	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex	pointer
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
31	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex	pointer
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLINE.verts[%d] = (%f, %f, %f) [3BD* 11]\n"	pointer
,	O
j	long
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex	pointer
.	O
x	double
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex	pointer
.	O
y	double
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex	pointer
.	O
z	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
12	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex_direction	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
22	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex_direction	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
32	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex_direction	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLINE.vertex_direction[%d] = (%f, %f, %f) [3BD* 12]\n"	pointer
,	O
j	long
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex_direction	struct
.	O
x	double
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex_direction	struct
.	O
y	double
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
vertex_direction	struct
.	O
z	double
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
13	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
miter_direction	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
23	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
miter_direction	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
33	int
&&	O
_o	pointer
->	O
num_verts	short
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
miter_direction	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLINE.miter_direction[%d] = (%f, %f, %f) [3BD* 13]\n"	pointer
,	O
j	long
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
miter_direction	struct
.	O
x	double
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
miter_direction	struct
.	O
y	double
,	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
miter_direction	struct
.	O
z	double
)	O
;	O
*	O
kp	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
74	int
&&	O
_o	pointer
->	O
num_lines	char
)	O
{	O
if	O
(	O
j	long
>=	O
_o	pointer
->	O
num_verts	short
||	O
k	int
>=	O
_o	pointer
->	O
num_lines	char
)	O
{	O
LOG_ERROR	O
(	O
"MLINE overflow %d, %d"	pointer
,	O
j	long
,	O
k	int
)	O
;	O
return	O
2	int
;	O
}	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
parent	pointer
=	O
&	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
;	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
num_segparms	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
segparms	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
LOG_TRACE	O
(	O
"MLINE.v[%d].l[%d].num_segparms = %d [BS 74]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
*	O
lp	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
41	int
&&	O
_o	pointer
->	O
num_lines	char
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
segparms	pointer
[	O
l	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLINE.v[%d].l[%d].segparms[%d] = %f [BD 41]\n"	pointer
,	O
j	long
,	O
k	int
,	O
l	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
l	long
++	O
;	O
*	O
lp	pointer
=	O
l	long
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
75	int
&&	O
_o	pointer
->	O
num_lines	char
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
num_areafillparms	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"MLINE.v[%d].l[%d].num_areafillparms = %d [BS 75]\n"	pointer
,	O
j	long
,	O
k	int
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
if	O
(	O
!	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
_o	pointer
->	O
num_lines	char
)	O
{	O
j	long
++	O
;	O
*	O
jp	pointer
=	O
j	long
;	O
k	int
=	O
0	int
;	O
}	O
*	O
kp	pointer
=	O
k	int
;	O
}	O
*	O
lp	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
42	int
&&	O
_o	pointer
->	O
num_lines	char
)	O
{	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
areafillparms	pointer
[	O
l	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLINE.v[%d].l[%d].areafillparms[%d] = %f [BD 42]\n"	pointer
,	O
j	long
,	O
k	int
,	O
l	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
l	long
++	O
;	O
*	O
lp	pointer
=	O
l	long
;	O
if	O
(	O
l	long
==	O
_o	pointer
->	O
verts	pointer
[	O
j	long
]	O
.	O
lines	pointer
[	O
k	int
]	O
.	O
num_areafillparms	short
)	O
{	O
l	long
=	O
0	int
;	O
*	O
lp	pointer
=	O
l	long
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
_o	pointer
->	O
num_lines	char
)	O
{	O
j	long
++	O
;	O
*	O
jp	pointer
=	O
j	long
;	O
k	int
=	O
0	int
;	O
}	O
*	O
kp	pointer
=	O
k	int
;	O
}	O
}	O
else	O
found	int
=	O
0	int
;	O
return	O
found	int
;	O
}	O
static	O
void	O
postprocess_SEQEND	function
(	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
Dwg_Entity_SEQEND	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
SEQEND	pointer
;	O
Dwg_Object	struct
*	O
owner	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
)	O
;	O
Dwg_Entity_POLYLINE_2D	struct
*	O
ow	pointer
;	O
BITCODE_BL	int
i	int
,	O
j	long
,	O
num_owned	int
=	O
0	int
;	O
BITCODE_H	pointer
seqend	pointer
;	O
BITCODE_H	pointer
*	O
owned	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
owhdls	pointer
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
<	O
R_13	int
&&	O
!	O
owner	pointer
&&	O
!	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
)	O
{	O
for	O
(	O
i	int
=	O
obj	pointer
->	O
index	short
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
{	O
Dwg_Object	struct
*	O
_o	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
if	O
(	O
_o	pointer
->	O
type	short
==	O
DWG_TYPE_INSERT	int
||	O
_o	pointer
->	O
type	short
==	O
DWG_TYPE_MINSERT	int
||	O
_o	pointer
->	O
type	short
==	O
DWG_TYPE_POLYLINE_2D	int
||	O
_o	pointer
->	O
type	short
==	O
DWG_TYPE_POLYLINE_3D	int
||	O
_o	pointer
->	O
type	short
==	O
DWG_TYPE_POLYLINE_PFACE	int
||	O
_o	pointer
->	O
type	short
==	O
DWG_TYPE_POLYLINE_MESH	int
)	O
{	O
owner	pointer
=	O
_o	pointer
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
_o	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"SEQEND.owner = "	pointer
FORMAT_H	pointer
" (%s) [H* 0]\n"	pointer
,	O
ARGS_H	O
(	O
_o	pointer
->	O
handle	pointer
)	O
,	O
_o	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
owner	pointer
)	O
{	O
if	O
(	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
)	O
LOG_WARN	O
(	O
"Missing owner from "	pointer
FORMAT_REF	pointer
" [H 330]"	pointer
,	O
ARGS_REF	O
(	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
)	O
)	O
else	O
LOG_WARN	O
(	O
"Missing owner"	pointer
)	O
return	O
;	O
}	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
owhdls	pointer
=	O
memBEGINc	O
(	O
owner	pointer
->	O
name	pointer
,	O
"POLYLINE_"	pointer
)	O
?	O
"vertex"	pointer
:	O
"attrib_handles"	pointer
;	O
ow	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POLYLINE_2D	pointer
;	O
seqend	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
owner	pointer
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
ow	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
"seqend"	pointer
,	O
&	O
seqend	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.seqend = "	pointer
FORMAT_REF	pointer
" [H 0]\n"	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
seqend	pointer
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
,	O
i	int
=	O
owner	pointer
->	O
index	short
+	O
1	int
;	O
i	int
<	O
obj	pointer
->	O
index	short
;	O
i	int
++	O
,	O
j	long
++	O
)	O
{	O
Dwg_Object	struct
*	O
_o	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
num_owned	int
=	O
j	long
+	O
1	int
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
)	O
{	O
owned	pointer
=	O
realloc	function
(	O
owned	pointer
,	O
num_owned	int
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
owned	pointer
[	O
j	long
]	O
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
_o	pointer
->	O
handle	pointer
.	O
value	double
,	O
owner	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s[%d] = "	pointer
FORMAT_REF	pointer
" [H* 0]\n"	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
owhdls	pointer
,	O
j	long
,	O
ARGS_REF	O
(	O
owned	pointer
[	O
j	long
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
num_owned	int
)	O
return	O
;	O
dwg_dynapi_entity_set_value	function
(	O
ow	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
"num_owned"	pointer
,	O
&	O
num_owned	int
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.num_owned = "	pointer
FORMAT_BL	O
" [BL 0]\n"	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
num_owned	int
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2000	int
)	O
{	O
const	O
char	O
*	O
firstfield	pointer
;	O
const	O
char	O
*	O
lastfield	pointer
;	O
if	O
(	O
memBEGINc	O
(	O
owner	pointer
->	O
name	pointer
,	O
"POLYLINE_"	pointer
)	O
)	O
{	O
firstfield	pointer
=	O
"first_vertex"	pointer
;	O
lastfield	pointer
=	O
"last_vertex"	pointer
;	O
}	O
else	O
{	O
firstfield	pointer
=	O
"first_attrib"	pointer
;	O
lastfield	pointer
=	O
"last_attrib"	pointer
;	O
}	O
dwg_dynapi_entity_set_value	function
(	O
ow	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
firstfield	pointer
,	O
&	O
owned	pointer
[	O
0	int
]	O
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
"[H 0]\n"	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
firstfield	pointer
,	O
ARGS_REF	O
(	O
owned	pointer
[	O
0	int
]	O
)	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
ow	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
lastfield	pointer
,	O
&	O
owned	pointer
[	O
num_owned	int
-	O
1	int
]	O
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s] = "	pointer
FORMAT_REF	pointer
"[H 0]\n"	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
lastfield	pointer
,	O
ARGS_REF	O
(	O
owned	pointer
[	O
num_owned	int
-	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
ow	pointer
,	O
owner	pointer
->	O
name	pointer
,	O
owhdls	pointer
,	O
&	O
owned	pointer
,	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
move_out_BLOCK_CONTROL	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
restrict	O
_ctrl	pointer
,	O
const	O
char	O
*	O
f	pointer
)	O
{	O
for	O
(	O
BITCODE_BL	int
j	long
=	O
0	int
;	O
j	long
<	O
_ctrl	pointer
->	O
num_entries	short
;	O
j	long
++	O
)	O
{	O
if	O
(	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
&&	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
->	O
absolute_ref	long
==	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
{	O
LOG_TRACE	O
(	O
"remove %s from entries[%d]: "	pointer
FORMAT_H	pointer
"\n"	pointer
,	O
f	pointer
,	O
j	long
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
;	O
_ctrl	pointer
->	O
num_entries	short
--	O
;	O
LOG_TRACE	O
(	O
"BLOCK_CONTROL.num_entries = "	pointer
FORMAT_BL	O
"\n"	pointer
,	O
_ctrl	pointer
->	O
num_entries	short
)	O
;	O
if	O
(	O
j	long
<	O
_ctrl	pointer
->	O
num_entries	short
)	O
memmove	function
(	O
&	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
,	O
&	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
+	O
1	int
]	O
,	O
(	O
_ctrl	pointer
->	O
num_entries	short
-	O
j	long
-	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
_ctrl	pointer
->	O
entries	pointer
=	O
realloc	function
(	O
_ctrl	pointer
->	O
entries	pointer
,	O
_ctrl	pointer
->	O
num_entries	short
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
move_out_LTYPE_CONTROL	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Object_LTYPE_CONTROL	struct
*	O
restrict	O
_ctrl	pointer
,	O
const	O
char	O
*	O
f	pointer
)	O
{	O
for	O
(	O
BITCODE_BL	int
j	long
=	O
0	int
;	O
j	long
<	O
_ctrl	pointer
->	O
num_entries	short
;	O
j	long
++	O
)	O
{	O
if	O
(	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
&&	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
->	O
absolute_ref	long
==	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
{	O
LOG_TRACE	O
(	O
"remove %s from entries[%d]: "	pointer
FORMAT_H	pointer
"\n"	pointer
,	O
f	pointer
,	O
j	long
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
;	O
_ctrl	pointer
->	O
num_entries	short
--	O
;	O
LOG_TRACE	O
(	O
"LTYPE_CONTROL.num_entries = "	pointer
FORMAT_BL	O
"\n"	pointer
,	O
_ctrl	pointer
->	O
num_entries	short
)	O
;	O
if	O
(	O
j	long
<	O
_ctrl	pointer
->	O
num_entries	short
)	O
memmove	function
(	O
&	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
,	O
&	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
+	O
1	int
]	O
,	O
(	O
_ctrl	pointer
->	O
num_entries	short
-	O
j	long
-	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
_ctrl	pointer
->	O
entries	pointer
=	O
realloc	function
(	O
_ctrl	pointer
->	O
entries	pointer
,	O
_ctrl	pointer
->	O
num_entries	short
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
postprocess_TEXTlike	function
(	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
BITCODE_RC	char
dataflags	char
;	O
BITCODE_2RD	struct
alignment_pt	struct
;	O
BITCODE_RD	double
oblique_ang	double
,	O
rotation	double
,	O
width_factor	double
;	O
BITCODE_BS	short
generation	short
,	O
horiz_alignment	short
,	O
vert_alignment	short
;	O
BITCODE_H	pointer
style	pointer
;	O
Dwg_Entity_TEXT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
TEXT	pointer
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"dataflags"	pointer
,	O
&	O
dataflags	char
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"alignment_pt"	pointer
,	O
&	O
alignment_pt	struct
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"oblique_ang"	pointer
,	O
&	O
oblique_ang	double
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"rotation"	pointer
,	O
&	O
rotation	double
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"width_factor"	pointer
,	O
&	O
width_factor	double
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"generation"	pointer
,	O
&	O
generation	short
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"horiz_alignment"	pointer
,	O
&	O
horiz_alignment	short
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"vert_alignment"	pointer
,	O
&	O
vert_alignment	short
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"style"	pointer
,	O
&	O
style	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
alignment_pt	struct
.	O
x	double
==	O
0.0	int
&&	O
alignment_pt	struct
.	O
y	double
==	O
0.0	int
)	O
dataflags	char
|=	O
2	int
;	O
if	O
(	O
oblique_ang	double
==	O
0.0	int
)	O
dataflags	char
|=	O
4	int
;	O
if	O
(	O
rotation	double
==	O
0.0	int
)	O
dataflags	char
|=	O
8	int
;	O
if	O
(	O
width_factor	double
==	O
0.0	int
)	O
dataflags	char
|=	O
0x10	int
;	O
if	O
(	O
generation	short
==	O
0	int
)	O
dataflags	char
|=	O
0x20	int
;	O
if	O
(	O
horiz_alignment	short
==	O
0	int
)	O
dataflags	char
|=	O
0x40	int
;	O
if	O
(	O
vert_alignment	short
==	O
0	int
)	O
dataflags	char
|=	O
0x80	int
;	O
if	O
(	O
!	O
style	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
style	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
"Standard"	pointer
,	O
"STYLE"	pointer
)	O
;	O
if	O
(	O
style	pointer
)	O
{	O
if	O
(	O
style	pointer
->	O
handleref	struct
.	O
code	char
!=	O
5	int
)	O
style	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
style	pointer
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"style"	pointer
,	O
&	O
style	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.style = "	pointer
FORMAT_REF	pointer
"\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
style	pointer
)	O
)	O
;	O
}	O
}	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"dataflags"	pointer
,	O
&	O
dataflags	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.dataflags = 0x%x\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
dataflags	char
)	O
;	O
}	O
int	O
is_textlike	function
(	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
return	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_TEXT	int
||	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_ATTDEF	int
||	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_ATTRIB	int
;	O
}	O
static	O
Dxf_Pair	struct
*	O
new_object	function
(	O
char	O
*	O
restrict	O
name	pointer
,	O
char	O
*	O
restrict	O
dxfname	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
BITCODE_BL	int
ctrl_id	int
,	O
BITCODE_BL	int
i	int
)	O
{	O
const	O
int	O
is_utf	int
=	O
1	int
;	O
Dwg_Object	struct
*	O
obj	pointer
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
Dwg_Object_APPID	struct
*	O
_obj	pointer
=	O
NULL	O
;	O
char	O
ctrlname	array
[	O
80	int
]	O
;	O
char	O
subclass	array
[	O
80	int
]	O
;	O
char	O
text	pointer
[	O
256	int
]	O
;	O
int	O
in_xdict	int
=	O
0	int
;	O
int	O
in_reactors	int
=	O
0	int
;	O
int	O
in_blkrefs	int
=	O
0	int
;	O
int	O
is_entity	int
=	O
is_dwg_entity	function
(	O
name	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"DIMENSION"	pointer
)	O
;	O
int	O
j	long
=	O
0	int
,	O
k	int
=	O
0	int
,	O
l	long
=	O
0	int
,	O
error	int
=	O
0	int
;	O
unsigned	O
written	int
=	O
0	int
;	O
BITCODE_RL	int
curr_inserts	int
=	O
0	int
;	O
BITCODE_RS	short
flag	short
=	O
0	int
;	O
BITCODE_BB	char
scale_flag	char
;	O
BITCODE_3BD	struct
pt	array
;	O
Dwg_Object	struct
*	O
ctrl	pointer
;	O
subclass	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
ctrl_id	int
||	O
i	int
)	O
{	O
LOG_TRACE	O
(	O
"add %s [%d]\n"	pointer
,	O
name	pointer
,	O
i	int
)	O
}	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
dxfname	pointer
)	O
!=	O
0	int
)	O
LOG_TRACE	O
(	O
"add %s (%s)\n"	pointer
,	O
name	pointer
,	O
dxfname	pointer
)	O
else	O
LOG_TRACE	O
(	O
"add %s\n"	pointer
,	O
name	pointer
)	O
}	O
if	O
(	O
is_entity	int
)	O
{	O
NEW_ENTITY	O
(	O
dwg	pointer
,	O
obj	pointer
)	O
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
xdic_missing_flag	char
=	O
1	int
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
color	short
.	O
index	short
=	O
256	int
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ltype_scale	double
=	O
1.0	int
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
linewt	char
=	O
0x1d	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'3'	O
)	O
{	O
memmove	function
(	O
&	O
name	pointer
[	O
1	int
]	O
,	O
&	O
name	pointer
[	O
0	int
]	O
,	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
*	O
name	pointer
=	O
'_'	O
;	O
}	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"DIMENSION"	pointer
)	O
)	O
{	O
ADD_ENTITY	O
(	O
DIMENSION_ANG2LN	pointer
)	O
;	O
}	O
else	O
{	O
LOG_WARN	O
(	O
"Unknown object %s"	pointer
,	O
name	pointer
)	O
;	O
found_ent	O
:	O
;	O
}	O
}	O
else	O
{	O
NEW_OBJECT	O
(	O
dwg	pointer
,	O
obj	pointer
)	O
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
1	int
;	O
if	O
(	O
!	O
ctrl_id	int
)	O
{	O
found_obj	O
:	O
;	O
}	O
else	O
{	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK_RECORD"	pointer
)	O
)	O
{	O
strcpy	function
(	O
ctrlname	array
,	O
"BLOCK_CONTROL"	pointer
)	O
;	O
}	O
else	O
{	O
strncpy	function
(	O
ctrlname	array
,	O
name	pointer
,	O
70	int
)	O
;	O
ctrlname	array
[	O
69	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
ctrlname	array
,	O
"_CONTROL"	pointer
)	O
;	O
}	O
ADD_TABLE_IF	O
(	O
LTYPE	pointer
,	O
LTYPE	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
VPORT	pointer
,	O
VPORT	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
APPID	pointer
,	O
APPID	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
DIMSTYLE	pointer
,	O
DIMSTYLE	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
LAYER	pointer
,	O
LAYER	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
STYLE	pointer
,	O
STYLE	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
UCS	pointer
,	O
UCS	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
VIEW	pointer
,	O
VIEW	pointer
)	O
else	O
ADD_TABLE_IF	O
(	O
BLOCK_RECORD	O
,	O
BLOCK_HEADER	pointer
)	O
else	O
{	O
dwg	pointer
->	O
num_objects	int
--	O
;	O
LOG_ERROR	O
(	O
"Unknown DXF AcDbSymbolTableRecord %s, skipping"	pointer
,	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
}	O
}	O
if	O
(	O
!	O
_obj	pointer
)	O
{	O
dwg	pointer
->	O
num_objects	int
--	O
;	O
LOG_ERROR	O
(	O
"Empty _obj at DXF AcDbSymbolTableRecord %s, skipping"	pointer
,	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
ctrl	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
ctrl_id	int
]	O
;	O
{	O
BITCODE_B	char
xrefref	char
=	O
1	int
;	O
if	O
(	O
dwg_dynapi_entity_field	function
(	O
obj	pointer
->	O
name	pointer
,	O
"xrefref"	pointer
)	O
)	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"xrefref"	pointer
,	O
&	O
xrefref	char
,	O
0	int
)	O
;	O
if	O
(	O
dwg_dynapi_entity_field	function
(	O
obj	pointer
->	O
name	pointer
,	O
"scale_flag"	pointer
)	O
)	O
{	O
scale_flag	char
=	O
3	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"scale_flag"	pointer
,	O
&	O
scale_flag	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.scale_flag = 3 (default)\n"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
}	O
if	O
(	O
dwg_dynapi_entity_field	function
(	O
obj	pointer
->	O
name	pointer
,	O
"scale"	pointer
)	O
)	O
{	O
pt	array
.	O
x	double
=	O
pt	array
.	O
y	double
=	O
pt	array
.	O
z	double
=	O
1.0	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"scale"	pointer
,	O
&	O
pt	array
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.scale = (1,1,1) (default)\n"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
pt	array
.	O
x	double
=	O
pt	array
.	O
y	double
=	O
pt	array
.	O
z	double
=	O
0.0	int
;	O
}	O
if	O
(	O
dwg_dynapi_entity_field	function
(	O
obj	pointer
->	O
name	pointer
,	O
"extrusion"	pointer
)	O
)	O
{	O
pt	array
.	O
x	double
=	O
pt	array
.	O
y	double
=	O
0.0	int
;	O
pt	array
.	O
z	double
=	O
1.0	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"extrusion"	pointer
,	O
&	O
pt	array
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.extrusion = (0,0,1) (default)\n"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
pt	array
.	O
z	double
=	O
0.0	int
;	O
}	O
}	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYOUT	int
)	O
{	O
Dwg_Object_LAYOUT	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYOUT	pointer
;	O
_o	pointer
->	O
real_world_units	double
=	O
1.0	int
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DIMSTYLE	int
)	O
{	O
Dwg_Object_DIMSTYLE	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DIMSTYLE	pointer
;	O
_o	pointer
->	O
DIMSCALE	double
=	O
_o	pointer
->	O
DIMLFAC	double
=	O
_o	pointer
->	O
DIMTFAC	double
=	O
1.0	int
;	O
_o	pointer
->	O
DIMALTU	short
=	O
_o	pointer
->	O
DIMLUNIT	short
=	O
2	int
;	O
_o	pointer
->	O
DIMFIT	short
=	O
3	int
;	O
_o	pointer
->	O
DIMLWD	short
=	O
_o	pointer
->	O
DIMLWE	short
=	O
-	O
2	int
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_TABLESTYLE	int
)	O
{	O
Dwg_Object_TABLESTYLE	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
TABLESTYLE	pointer
;	O
_o	pointer
->	O
num_rowstyles	int
=	O
3	int
;	O
_o	pointer
->	O
rowstyles	pointer
=	O
xcalloc	function
(	O
3	int
,	O
sizeof	O
(	O
Dwg_TABLESTYLE_rowstyles	struct
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
3	int
;	O
j	long
++	O
)	O
{	O
_o	pointer
->	O
rowstyles	pointer
[	O
j	long
]	O
.	O
borders	pointer
=	O
xcalloc	function
(	O
6	int
,	O
sizeof	O
(	O
Dwg_TABLESTYLE_border	struct
)	O
)	O
;	O
_o	pointer
->	O
rowstyles	pointer
[	O
j	long
]	O
.	O
num_borders	int
=	O
6	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
_o	pointer
->	O
rowstyles	pointer
[	O
j	long
]	O
.	O
borders	pointer
[	O
k	int
]	O
.	O
visible	char
=	O
1	int
;	O
_o	pointer
->	O
rowstyles	pointer
[	O
j	long
]	O
.	O
borders	pointer
[	O
k	int
]	O
.	O
linewt	char
=	O
29	int
;	O
_o	pointer
->	O
rowstyles	pointer
[	O
j	long
]	O
.	O
borders	pointer
[	O
k	int
]	O
.	O
color	short
.	O
index	short
=	O
256	int
;	O
}	O
}	O
k	int
=	O
0	int
;	O
j	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MTEXT	int
)	O
{	O
BITCODE_H	pointer
style	pointer
;	O
Dwg_Entity_MTEXT	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MTEXT	pointer
;	O
_o	pointer
->	O
x_axis_dir	struct
.	O
x	double
=	O
1.0	int
;	O
style	pointer
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
"Standard"	pointer
,	O
"STYLE"	pointer
)	O
;	O
if	O
(	O
style	pointer
)	O
{	O
if	O
(	O
style	pointer
->	O
handleref	struct
.	O
code	char
!=	O
5	int
)	O
style	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
style	pointer
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
_o	pointer
->	O
style	pointer
=	O
style	pointer
;	O
}	O
}	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
!=	O
0	int
)	O
{	O
start_loop	O
:	O
if	O
(	O
pair	pointer
==	O
NULL	O
)	O
{	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_RETURN_EOF	O
(	O
pair	pointer
)	O
;	O
}	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"SEQEND"	pointer
)	O
)	O
postprocess_SEQEND	function
(	O
obj	pointer
)	O
;	O
return	O
pair	pointer
;	O
case	O
105	int
:	O
if	O
(	O
strNE	O
(	O
name	pointer
,	O
"DIMSTYLE"	pointer
)	O
)	O
goto	O
object_default	O
;	O
case	O
5	int
:	O
{	O
obj	pointer
->	O
handle	pointer
.	O
value	double
=	O
pair	pointer
->	O
value	double
.	O
u	union
;	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_BLOCK_HEADER	int
&&	O
dwg	pointer
->	O
object	pointer
[	O
0	int
]	O
.	O
handle	pointer
.	O
value	double
==	O
pair	pointer
->	O
value	double
.	O
u	union
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
!=	O
dwg	pointer
->	O
object	pointer
[	O
0	int
]	O
.	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
&&	O
dwg	pointer
->	O
num_objects	int
)	O
{	O
dwg	pointer
->	O
num_objects	int
--	O
;	O
free	function
(	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
)	O
;	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
0	int
]	O
;	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID	pointer
;	O
LOG_TRACE	O
(	O
"Reuse existing BLOCK_HEADER.*Model_Space %X [0]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
)	O
}	O
dwg_add_handle	function
(	O
&	O
obj	pointer
->	O
handle	pointer
,	O
0	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.handle = "	pointer
FORMAT_H	pointer
" [H 5]\n"	pointer
,	O
name	pointer
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
;	O
if	O
(	O
ctrl_id	int
)	O
{	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
_ctrl	pointer
=	O
dwg	pointer
->	O
object	pointer
[	O
ctrl_id	int
]	O
.	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
;	O
BITCODE_H	pointer
*	O
hdls	pointer
=	O
NULL	O
;	O
BITCODE_BL	int
num_entries	short
=	O
0	int
;	O
if	O
(	O
(	O
int	O
)	O
i	int
<	O
0	int
)	O
i	int
=	O
0	int
;	O
dwg_dynapi_entity_value	function
(	O
_ctrl	pointer
,	O
ctrlname	array
,	O
"num_entries"	pointer
,	O
&	O
num_entries	short
,	O
NULL	O
)	O
;	O
if	O
(	O
num_entries	short
!=	O
i	int
+	O
1	int
)	O
{	O
LOG_WARN	O
(	O
"Misleading %s.num_entries %d for %dth entry"	pointer
,	O
ctrlname	array
,	O
num_entries	short
,	O
i	int
)	O
;	O
i	int
=	O
num_entries	short
;	O
num_entries	short
++	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_ctrl	pointer
,	O
ctrlname	array
,	O
"num_entries"	pointer
,	O
&	O
num_entries	short
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.num_entries = %d [BL 70]\n"	pointer
,	O
ctrlname	array
,	O
num_entries	short
)	O
;	O
}	O
dwg_dynapi_entity_value	function
(	O
_ctrl	pointer
,	O
ctrlname	array
,	O
"entries"	pointer
,	O
&	O
hdls	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
hdls	pointer
)	O
{	O
hdls	pointer
=	O
xcalloc	function
(	O
num_entries	short
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
)	O
;	O
}	O
else	O
{	O
hdls	pointer
=	O
realloc	function
(	O
hdls	pointer
,	O
num_entries	short
*	O
sizeof	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
)	O
;	O
}	O
hdls	pointer
[	O
i	int
]	O
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
2	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_ctrl	pointer
,	O
ctrlname	array
,	O
"entries"	pointer
,	O
&	O
hdls	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s[%d] = "	pointer
FORMAT_REF	pointer
" [H* 0]\n"	pointer
,	O
ctrlname	array
,	O
"entries"	pointer
,	O
i	int
,	O
ARGS_REF	O
(	O
hdls	pointer
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
8	int
:	O
if	O
(	O
is_entity	int
)	O
{	O
BITCODE_H	pointer
handle	pointer
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
handle	pointer
)	O
{	O
obj_hdls	pointer
=	O
array_push	function
(	O
obj_hdls	pointer
,	O
"layer"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
objid	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.layer: name %s -> H later\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
}	O
else	O
{	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
"layer"	pointer
,	O
&	O
handle	pointer
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.layer = %s "	pointer
FORMAT_REF	pointer
" [H 8]\n"	pointer
,	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
ARGS_REF	O
(	O
handle	pointer
)	O
)	O
;	O
}	O
break	O
;	O
}	O
case	O
100	int
:	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
100	int
)	O
{	O
strncpy	function
(	O
subclass	array
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
79	int
)	O
;	O
subclass	array
[	O
79	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strEQc	O
(	O
obj	pointer
->	O
name	pointer
,	O
"DIMENSION_ANG2LN"	pointer
)	O
||	O
strEQc	O
(	O
obj	pointer
->	O
name	pointer
,	O
"DIMENSION"	pointer
)	O
)	O
{	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbRotatedDimension"	pointer
)	O
)	O
{	O
obj	pointer
->	O
type	short
=	O
obj	pointer
->	O
fixedtype	enum
=	O
DWG_TYPE_DIMENSION_LINEAR	int
;	O
obj	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
"DIMENSION_LINEAR"	pointer
;	O
obj	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
obj	pointer
->	O
name	pointer
)	O
;	O
strcpy	function
(	O
name	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
LOG_TRACE	O
(	O
"change type to %s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbAlignedDimension"	pointer
)	O
)	O
{	O
obj	pointer
->	O
type	short
=	O
obj	pointer
->	O
fixedtype	enum
=	O
DWG_TYPE_DIMENSION_ALIGNED	int
;	O
obj	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
"DIMENSION_ALIGNED"	pointer
;	O
obj	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
obj	pointer
->	O
name	pointer
)	O
;	O
strcpy	function
(	O
name	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
LOG_TRACE	O
(	O
"change type to %s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbOrdinateDimension"	pointer
)	O
)	O
{	O
obj	pointer
->	O
type	short
=	O
obj	pointer
->	O
fixedtype	enum
=	O
DWG_TYPE_DIMENSION_ORDINATE	int
;	O
obj	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
"DIMENSION_ORDINATE"	pointer
;	O
obj	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
obj	pointer
->	O
name	pointer
)	O
;	O
strcpy	function
(	O
name	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
LOG_TRACE	O
(	O
"change type to %s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbDiametricDimension"	pointer
)	O
)	O
{	O
obj	pointer
->	O
type	short
=	O
obj	pointer
->	O
fixedtype	enum
=	O
DWG_TYPE_DIMENSION_DIAMETER	int
;	O
obj	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
"DIMENSION_DIAMETER"	pointer
;	O
obj	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
obj	pointer
->	O
name	pointer
)	O
;	O
strcpy	function
(	O
name	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
LOG_TRACE	O
(	O
"change type to %s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbRadialDimension"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
DIMENSION_ANG2LN	pointer
,	O
DIMENSION_RADIUS	pointer
)	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDb3PointAngularDimension"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
DIMENSION_ANG2LN	pointer
,	O
DIMENSION_ANG3PT	pointer
)	O
}	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
obj	pointer
->	O
name	pointer
,	O
"POLYLINE_2D"	pointer
)	O
)	O
{	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDb3dPolyline"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
POLYLINE_2D	pointer
,	O
POLYLINE_3D	pointer
)	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbPolyFaceMesh"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
POLYLINE_2D	pointer
,	O
POLYLINE_PFACE	pointer
)	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbPolygonMesh"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
POLYLINE_2D	pointer
,	O
POLYLINE_MESH	pointer
)	O
}	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
obj	pointer
->	O
name	pointer
,	O
"VERTEX_2D"	pointer
)	O
)	O
{	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDb3dPolylineVertex"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
VERTEX_2D	pointer
,	O
VERTEX_3D	pointer
)	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbPolyFaceMeshVertex"	pointer
)	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
owner	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
;	O
Dwg_Object	struct
*	O
parent	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
owner	pointer
)	O
;	O
if	O
(	O
parent	pointer
&&	O
parent	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_POLYLINE_PFACE	int
)	O
{	O
UPGRADE_ENTITY	O
(	O
VERTEX_2D	pointer
,	O
VERTEX_PFACE	pointer
)	O
}	O
else	O
{	O
UPGRADE_ENTITY	O
(	O
VERTEX_2D	pointer
,	O
VERTEX_MESH	pointer
)	O
}	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbFaceRecord"	pointer
)	O
)	O
{	O
UPGRADE_ENTITY	O
(	O
VERTEX_2D	pointer
,	O
VERTEX_PFACE_FACE	pointer
)	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_PERSSUBENTMANAGER	int
&&	O
strEQc	O
(	O
subclass	array
,	O
"AcDbPersSubentManager"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
add_PERSSUBENTMANAGER	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
goto	O
next_pair	O
;	O
else	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
obj	pointer
->	O
name	pointer
,	O
"ASSOC"	pointer
)	O
&&	O
strstr	function
(	O
obj	pointer
->	O
name	pointer
,	O
"DEPENDENCY"	pointer
)	O
&&	O
strEQc	O
(	O
subclass	array
,	O
"AcDbAssocDependency"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
add_ASSOCDEPENDENCY	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
goto	O
next_pair	O
;	O
else	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
obj	pointer
->	O
name	pointer
,	O
"ASSOC"	pointer
)	O
&&	O
strEQc	O
(	O
subclass	array
,	O
"AcDbAssocAction"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
add_ASSOCACTION	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOC2DCONSTRAINTGROUP"	pointer
)	O
)	O
return	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
else	O
goto	O
next_pair	O
;	O
}	O
else	O
goto	O
start_loop	O
;	O
}	O
}	O
break	O
;	O
case	O
102	int
:	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"{ACAD_XDICTIONARY"	pointer
)	O
)	O
in_xdict	int
=	O
1	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"{ACAD_REACTORS"	pointer
)	O
)	O
in_reactors	int
=	O
1	int
;	O
else	O
if	O
(	O
ctrl_id	int
&&	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"{BLKREFS"	pointer
)	O
)	O
in_blkrefs	int
=	O
1	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"}"	pointer
)	O
)	O
in_reactors	int
=	O
in_xdict	int
=	O
in_blkrefs	int
=	O
0	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"XRECORD"	pointer
)	O
)	O
pair	pointer
=	O
add_xdata	function
(	O
dat	pointer
,	O
obj	pointer
,	O
pair	pointer
)	O
;	O
else	O
LOG_WARN	O
(	O
"Unknown DXF code 102 %s in %s"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
name	pointer
)	O
break	O
;	O
case	O
331	int
:	O
if	O
(	O
ctrl_id	int
&&	O
in_blkrefs	int
)	O
{	O
BITCODE_H	pointer
*	O
inserts	pointer
=	O
NULL	O
;	O
BITCODE_H	pointer
hdl	array
;	O
BITCODE_RL	int
num_inserts	int
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_inserts"	pointer
,	O
&	O
num_inserts	int
,	O
0	int
)	O
;	O
if	O
(	O
curr_inserts	int
)	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"inserts"	pointer
,	O
&	O
inserts	pointer
,	O
0	int
)	O
;	O
if	O
(	O
curr_inserts	int
+	O
1	int
>	O
num_inserts	int
)	O
{	O
LOG_HANDLE	O
(	O
"  extending %s.num_inserts %d < %d\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
num_inserts	int
,	O
curr_inserts	int
+	O
1	int
)	O
;	O
num_inserts	int
=	O
curr_inserts	int
+	O
1	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_inserts"	pointer
,	O
&	O
num_inserts	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
inserts	pointer
)	O
inserts	pointer
=	O
realloc	function
(	O
inserts	pointer
,	O
num_inserts	int
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
else	O
inserts	pointer
=	O
xcalloc	function
(	O
num_inserts	int
,	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"inserts"	pointer
,	O
&	O
inserts	pointer
,	O
0	int
)	O
;	O
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.inserts[%d] = "	pointer
FORMAT_REF	pointer
" [H* 331]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
curr_inserts	int
,	O
ARGS_REF	O
(	O
hdl	array
)	O
)	O
;	O
inserts	pointer
[	O
curr_inserts	int
++	O
]	O
=	O
hdl	array
;	O
break	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
331	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYOUT	int
)	O
{	O
Dwg_Object_LAYOUT	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYOUT	pointer
;	O
_o	pointer
->	O
active_viewport	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.active_viewport = "	pointer
FORMAT_REF	pointer
" [H 331]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
_o	pointer
->	O
active_viewport	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
330	int
:	O
if	O
(	O
in_reactors	int
)	O
{	O
BITCODE_BL	int
num	long
=	O
is_entity	int
?	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
num_reactors	int
:	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
num_reactors	int
;	O
BITCODE_H	pointer
reactor	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.reactors[%d] = "	pointer
FORMAT_REF	pointer
" [H* 330]\n"	pointer
,	O
name	pointer
,	O
num	long
,	O
ARGS_REF	O
(	O
reactor	pointer
)	O
)	O
;	O
if	O
(	O
is_entity	int
)	O
{	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
reactors	pointer
=	O
realloc	function
(	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
reactors	pointer
,	O
(	O
num	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
reactors	pointer
[	O
num	long
]	O
=	O
reactor	pointer
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
num_reactors	int
++	O
;	O
}	O
else	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
reactors	pointer
=	O
realloc	function
(	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
reactors	pointer
,	O
(	O
num	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
reactors	pointer
[	O
num	long
]	O
=	O
reactor	pointer
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
num_reactors	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
330	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYOUT	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
)	O
{	O
Dwg_Object_LAYOUT	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYOUT	pointer
;	O
_o	pointer
->	O
block_header	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.block_header = "	pointer
FORMAT_REF	pointer
" [H 330]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
_o	pointer
->	O
block_header	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
330	int
&&	O
(	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_XRECORD	int
||	O
!	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
)	O
)	O
{	O
BITCODE_H	pointer
owh	pointer
;	O
if	O
(	O
is_obj_absref	function
(	O
obj	pointer
)	O
)	O
owh	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
NULL	O
)	O
;	O
else	O
owh	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
if	O
(	O
is_entity	int
)	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
=	O
owh	pointer
;	O
else	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
=	O
owh	pointer
;	O
LOG_TRACE	O
(	O
"%s.ownerhandle = "	pointer
FORMAT_REF	pointer
" [H 330]\n"	pointer
,	O
name	pointer
,	O
ARGS_REF	O
(	O
owh	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
350	int
:	O
case	O
360	int
:	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
360	int
&&	O
in_xdict	int
)	O
{	O
BITCODE_H	pointer
xdic	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
if	O
(	O
is_entity	int
)	O
{	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
xdicobjhandle	pointer
=	O
xdic	pointer
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
xdic_missing_flag	char
=	O
0	int
;	O
}	O
else	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
=	O
xdic	pointer
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
0	int
;	O
}	O
LOG_TRACE	O
(	O
"%s.xdicobjhandle = "	pointer
FORMAT_REF	pointer
" [H 360]\n"	pointer
,	O
name	pointer
,	O
ARGS_REF	O
(	O
xdic	pointer
)	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
memBEGINc	O
(	O
name	pointer
,	O
"DICTIONARY"	pointer
)	O
&&	O
strNE	O
(	O
name	pointer
,	O
"DICTIONARYVAR"	pointer
)	O
)	O
{	O
add_dictionary_itemhandles	function
(	O
obj	pointer
,	O
pair	pointer
,	O
text	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
360	int
&&	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_IMAGE	int
||	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_WIPEOUT	int
)	O
)	O
{	O
BITCODE_H	pointer
ref	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"imagedefreactor"	pointer
,	O
ref	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.imagedefreactor = "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
name	pointer
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
break	O
;	O
}	O
case	O
340	int
:	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
340	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"GROUP"	pointer
)	O
)	O
{	O
Dwg_Object_GROUP	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
GROUP	pointer
;	O
BITCODE_H	pointer
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"GROUP.groups[%d] = "	pointer
FORMAT_REF	pointer
" [H* 340]\n"	pointer
,	O
_o	pointer
->	O
num_groups	int
,	O
ARGS_REF	O
(	O
hdl	array
)	O
)	O
;	O
_o	pointer
->	O
groups	pointer
=	O
realloc	function
(	O
_o	pointer
->	O
groups	pointer
,	O
(	O
_o	pointer
->	O
num_groups	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
_o	pointer
->	O
groups	pointer
[	O
_o	pointer
->	O
num_groups	int
]	O
=	O
hdl	array
;	O
_o	pointer
->	O
num_groups	int
++	O
;	O
break	O
;	O
}	O
case	O
2	int
:	O
if	O
(	O
ctrl_id	int
&&	O
pair	pointer
->	O
code	char
==	O
2	int
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"name"	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.name = %s [T 2]\n"	pointer
,	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK_RECORD"	pointer
)	O
)	O
{	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
_ctrl	pointer
=	O
ctrl	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"*Paper_Space"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
f	pointer
=	O
"paper_space"	pointer
;	O
_ctrl	pointer
->	O
paper_space	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
" [H 0]\n"	pointer
,	O
ctrlname	array
,	O
f	pointer
,	O
ARGS_REF	O
(	O
_ctrl	pointer
->	O
paper_space	pointer
)	O
)	O
;	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
move_out_BLOCK_CONTROL	function
(	O
obj	pointer
,	O
_ctrl	pointer
,	O
f	pointer
)	O
;	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"*Model_Space"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
f	pointer
=	O
"model_space"	pointer
;	O
_ctrl	pointer
->	O
model_space	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
" [H 0]\n"	pointer
,	O
ctrlname	array
,	O
f	pointer
,	O
ARGS_REF	O
(	O
_ctrl	pointer
->	O
model_space	pointer
)	O
)	O
;	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
move_out_BLOCK_CONTROL	function
(	O
obj	pointer
,	O
_ctrl	pointer
,	O
f	pointer
)	O
;	O
i	int
--	O
;	O
}	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"LTYPE"	pointer
)	O
)	O
{	O
Dwg_Object_LTYPE_CONTROL	struct
*	O
_ctrl	pointer
=	O
ctrl	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE_CONTROL	pointer
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ByLayer"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
f	pointer
=	O
"bylayer"	pointer
;	O
_ctrl	pointer
->	O
bylayer	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
" [H 0]\n"	pointer
,	O
ctrlname	array
,	O
f	pointer
,	O
ARGS_REF	O
(	O
_ctrl	pointer
->	O
bylayer	pointer
)	O
)	O
;	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_BYLAYER	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
move_out_LTYPE_CONTROL	function
(	O
obj	pointer
,	O
_ctrl	pointer
,	O
f	pointer
)	O
;	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ByBlock"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
f	pointer
=	O
"byblock"	pointer
;	O
_ctrl	pointer
->	O
byblock	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
" [H 0]\n"	pointer
,	O
ctrlname	array
,	O
f	pointer
,	O
ARGS_REF	O
(	O
_ctrl	pointer
->	O
byblock	pointer
)	O
)	O
;	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_BYBLOCK	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
move_out_LTYPE_CONTROL	function
(	O
obj	pointer
,	O
_ctrl	pointer
,	O
f	pointer
)	O
;	O
i	int
--	O
;	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
2	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"MLINE"	pointer
)	O
)	O
{	O
break	O
;	O
}	O
case	O
70	int
:	O
if	O
(	O
ctrl_id	int
&&	O
pair	pointer
->	O
code	char
==	O
70	int
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"flag"	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.flag = %d [RC 70]\n"	pointer
,	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
70	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYOUT	int
)	O
{	O
Dwg_Object_LAYOUT	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYOUT	pointer
;	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbPlotSettings"	pointer
)	O
)	O
{	O
_o	pointer
->	O
plot_layout_flags	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"LAYOUT.plot_layout_flags = %d [BS 70]"	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbLayout"	pointer
)	O
)	O
{	O
_o	pointer
->	O
flag	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"LAYOUT.flag = %d [BS 70]"	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
else	O
{	O
LOG_WARN	O
(	O
"Unhandled LAYOUT.70 in subclass %s"	pointer
,	O
subclass	array
)	O
;	O
_o	pointer
->	O
flag	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"LAYOUT.flag = %d [BS 70]"	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
420	int
:	O
case	O
421	int
:	O
case	O
422	int
:	O
case	O
423	int
:	O
case	O
424	int
:	O
case	O
425	int
:	O
case	O
426	int
:	O
case	O
427	int
:	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
420	int
&&	O
pair	pointer
->	O
code	char
<=	O
427	int
)	O
{	O
const	O
char	O
*	O
fname	pointer
=	O
NULL	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
421	int
&&	O
(	O
strEQc	O
(	O
name	pointer
,	O
"VPORT"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"VIEWPORT"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"VIEW"	pointer
)	O
)	O
)	O
fname	pointer
=	O
"ambient_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
421	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"MTEXT"	pointer
)	O
)	O
fname	pointer
=	O
"bg_fill_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
420	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"MLINESTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"fill_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
420	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
421	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"face_mono_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
422	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"edge_intersection_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
423	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"edge_obscured_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
424	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"edge_color"	pointer
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
425	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
fname	pointer
=	O
"edge_silhouette_color"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"TABLE"	pointer
)	O
)	O
{	O
BITCODE_BL	int
table_flag	int
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
TABLE	pointer
->	O
table_flag_override	int
;	O
BITCODE_BL	int
border_color	int
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
TABLE	pointer
->	O
border_color_overrides_flag	int
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
421	int
)	O
{	O
if	O
(	O
table_flag	int
&	O
0x0800	int
)	O
fname	pointer
=	O
"title_row_fill_color"	pointer
;	O
else	O
if	O
(	O
table_flag	int
&	O
0x01000	int
)	O
fname	pointer
=	O
"header_row_fill_color"	pointer
;	O
else	O
if	O
(	O
table_flag	int
&	O
0x02000	int
)	O
fname	pointer
=	O
"data_row_fill_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0008	int
)	O
fname	pointer
=	O
"title_vert_left_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0200	int
)	O
fname	pointer
=	O
"header_vert_left_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x8000	int
)	O
fname	pointer
=	O
"data_vert_left_color"	pointer
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
422	int
)	O
{	O
if	O
(	O
table_flag	int
&	O
0x0020	int
)	O
fname	pointer
=	O
"title_row_color"	pointer
;	O
else	O
if	O
(	O
table_flag	int
&	O
0x0040	int
)	O
fname	pointer
=	O
"header_row_color"	pointer
;	O
else	O
if	O
(	O
table_flag	int
&	O
0x0080	int
)	O
fname	pointer
=	O
"data_row_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0001	int
)	O
fname	pointer
=	O
"title_horiz_top_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0040	int
)	O
fname	pointer
=	O
"header_horiz_top_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x1000	int
)	O
fname	pointer
=	O
"data_horiz_top_color"	pointer
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
423	int
)	O
{	O
if	O
(	O
border_color	int
&	O
0x0002	int
)	O
fname	pointer
=	O
"title_horiz_ins_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0080	int
)	O
fname	pointer
=	O
"header_horiz_ins_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x2000	int
)	O
fname	pointer
=	O
"data_horiz_ins_color"	pointer
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
424	int
)	O
{	O
if	O
(	O
border_color	int
&	O
0x0004	int
)	O
fname	pointer
=	O
"title_horiz_bottom_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0100	int
)	O
fname	pointer
=	O
"header_horiz_bottom_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x4000	int
)	O
fname	pointer
=	O
"data_horiz_bottom_color"	pointer
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
426	int
)	O
{	O
if	O
(	O
border_color	int
&	O
0x0010	int
)	O
fname	pointer
=	O
"title_vert_ins_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0400	int
)	O
fname	pointer
=	O
"header_vert_ins_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x10000	int
)	O
fname	pointer
=	O
"data_vert_ins_color"	pointer
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
427	int
)	O
{	O
if	O
(	O
border_color	int
&	O
0x0020	int
)	O
fname	pointer
=	O
"title_vert_right_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x0800	int
)	O
fname	pointer
=	O
"header_vert_right_color"	pointer
;	O
else	O
if	O
(	O
border_color	int
&	O
0x20000	int
)	O
fname	pointer
=	O
"data_vert_right_color"	pointer
;	O
}	O
}	O
if	O
(	O
fname	pointer
)	O
{	O
BITCODE_CMC	struct
color	short
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
fname	pointer
,	O
&	O
color	short
,	O
NULL	O
)	O
;	O
color	short
.	O
rgb	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
LOG_TRACE	O
(	O
"%s.%s.rgb = %06X [CMC %d]\n"	pointer
,	O
name	pointer
,	O
fname	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
fname	pointer
,	O
&	O
color	short
,	O
is_utf	int
)	O
;	O
break	O
;	O
}	O
}	O
default	O
:	O
object_default	O
:	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
1000	int
&&	O
pair	pointer
->	O
code	char
<	O
1999	int
)	O
add_eed	function
(	O
obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
!=	O
280	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"XRECORD"	pointer
)	O
)	O
pair	pointer
=	O
add_xdata	function
(	O
dat	pointer
,	O
obj	pointer
,	O
pair	pointer
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
310	int
&&	O
strEQc	O
(	O
obj	pointer
->	O
name	pointer
,	O
"BLOCK_HEADER"	pointer
)	O
)	O
{	O
pair	pointer
=	O
add_block_preview	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
90	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_OLE2FRAME	int
)	O
{	O
Dwg_Entity_OLE2FRAME	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
OLE2FRAME	pointer
;	O
_o	pointer
->	O
data_length	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
_o	pointer
->	O
data	pointer
=	O
xcalloc	function
(	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"OLE2FRAME.data_length = %ld [BL 90]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
90	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_PERSSUBENTMANAGER	int
)	O
{	O
pair	pointer
=	O
add_PERSSUBENTMANAGER	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
goto	O
next_pair	O
;	O
else	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
(	O
pair	pointer
->	O
code	char
==	O
71	int
||	O
pair	pointer
->	O
code	char
==	O
75	int
||	O
pair	pointer
->	O
code	char
==	O
1	int
)	O
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DIMASSOC	int
)	O
{	O
pair	pointer
=	O
add_DIMASSOC	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
goto	O
start_loop	O
;	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
310	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_OLE2FRAME	int
)	O
{	O
Dwg_Entity_OLE2FRAME	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
OLE2FRAME	pointer
;	O
unsigned	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
unsigned	O
blen	int
=	O
len	long
/	O
2	int
;	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
unsigned	O
char	O
*	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
_o	pointer
->	O
data	pointer
[	O
written	int
]	O
;	O
assert	O
(	O
_o	pointer
->	O
data	pointer
)	O
;	O
if	O
(	O
blen	int
+	O
written	int
>	O
_o	pointer
->	O
data_length	int
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
LOG_ERROR	O
(	O
"OLE2FRAME.data overflow: %u + written %u > "	pointer
"data_length: %u"	pointer
,	O
blen	int
,	O
written	int
,	O
_o	pointer
->	O
data_length	int
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
unsigned	O
_i	int
=	O
0	int
;	O
_i	int
<	O
blen	int
;	O
_i	int
++	O
)	O
{	O
sscanf	function
(	O
pos	pointer
,	O
"%2hhX"	pointer
,	O
&	O
s	pointer
[	O
_i	int
]	O
)	O
;	O
pos	pointer
+=	O
2	int
;	O
}	O
written	int
+=	O
blen	int
;	O
LOG_TRACE	O
(	O
"OLE2FRAME.data += %u (%u/%u) [TF 310]\n"	pointer
,	O
blen	int
,	O
written	int
,	O
_o	pointer
->	O
data_length	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
1	int
&&	O
(	O
strEQc	O
(	O
name	pointer
,	O
"_3DSOLID"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"BODY"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"REGION"	pointer
)	O
||	O
strEQc	O
(	O
subclass	array
,	O
"AcDbModelerGeometry"	pointer
)	O
)	O
)	O
{	O
j	long
=	O
0	int
;	O
k	int
=	O
0	int
;	O
pair	pointer
=	O
add_3DSOLID_encr	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
1	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYOUT	int
)	O
{	O
Dwg_Object_LAYOUT	struct
*	O
_o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYOUT	pointer
;	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbPlotSettings"	pointer
)	O
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"page_setup_name"	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.page_setup_name = %s [T 1]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbLayout"	pointer
)	O
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"layout_name"	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.layout_name = %s [T 1]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
}	O
else	O
LOG_WARN	O
(	O
"Unhandled LAYOUT.1 in subclass %s"	pointer
,	O
subclass	array
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
370	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYER	int
)	O
{	O
Dwg_Object_LAYER	struct
*	O
layer	int
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER	pointer
;	O
layer	int
->	O
linewt	char
=	O
dxf_find_lweight	function
(	O
pair	pointer
->	O
value	double
.	O
i	int
)	O
;	O
LOG_TRACE	O
(	O
"LAYER.linewt = %d\n"	pointer
,	O
layer	int
->	O
linewt	char
)	O
;	O
layer	int
->	O
flag	short
|=	O
layer	int
->	O
linewt	char
<<	O
5	int
;	O
LOG_TRACE	O
(	O
"LAYER.flag = 0x%x [BS 70]\n"	pointer
,	O
layer	int
->	O
flag	short
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
49	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LTYPE	int
)	O
{	O
pair	pointer
=	O
add_LTYPE_dashes	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
71	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MLINESTYLE	int
&&	O
pair	pointer
->	O
value	double
.	O
i	int
!=	O
0	int
)	O
{	O
pair	pointer
=	O
add_MLINESTYLE_lines	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
65	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_VPORT	int
)	O
{	O
Dwg_Object_VPORT	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT	pointer
;	O
o	pointer
->	O
UCSVP	char
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
o	pointer
->	O
UCSFOLLOW	char
=	O
o	pointer
->	O
VIEWMODE	char
&	O
4	int
?	O
1	int
:	O
0	int
;	O
o	pointer
->	O
VIEWMODE	char
|=	O
o	pointer
->	O
UCSVP	char
;	O
LOG_TRACE	O
(	O
"VPORT.UCSVP = %d [B 65]\n"	pointer
,	O
o	pointer
->	O
UCSVP	char
)	O
LOG_TRACE	O
(	O
"VPORT.UCSFOLLOW => %d [B 0] (calc)\n"	pointer
,	O
o	pointer
->	O
UCSFOLLOW	char
)	O
LOG_TRACE	O
(	O
"VPORT.VIEWMODE => %d [4BITS 71] (calc)\n"	pointer
,	O
o	pointer
->	O
VIEWMODE	char
)	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
90	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LWPOLYLINE	int
)	O
{	O
pair	pointer
=	O
new_LWPOLYLINE	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
350	int
&&	O
strEQc	O
(	O
subclass	array
,	O
"AcDb3dSolid"	pointer
)	O
)	O
{	O
Dwg_Entity__3DSOLID	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
_3DSOLID	pointer
;	O
BITCODE_H	pointer
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.history_id = "	pointer
FORMAT_REF	pointer
" [H 350]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
hdl	array
)	O
)	O
;	O
o	pointer
->	O
history_id	pointer
=	O
hdl	array
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MLINE	int
)	O
{	O
int	O
status	char
=	O
add_MLINE	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
,	O
&	O
j	long
,	O
&	O
k	int
,	O
&	O
l	long
)	O
;	O
if	O
(	O
status	char
==	O
0	int
)	O
goto	O
search_field	O
;	O
else	O
if	O
(	O
status	char
==	O
2	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"VERTEX_PFACE_FACE"	pointer
)	O
&&	O
pair	pointer
->	O
code	char
>=	O
71	int
&&	O
pair	pointer
->	O
code	char
<=	O
74	int
)	O
{	O
Dwg_Entity_VERTEX_PFACE_FACE	struct
*	O
_o	pointer
=	O
(	O
Dwg_Entity_VERTEX_PFACE_FACE	struct
*	O
)	O
_obj	pointer
;	O
j	long
=	O
pair	pointer
->	O
code	char
-	O
71	int
;	O
_o	pointer
->	O
vertind	array
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"VERTEX_PFACE_FACE.vertind[%d] = %d [BS %d]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_SPLINE	int
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
210	int
||	O
pair	pointer
->	O
code	char
==	O
220	int
||	O
pair	pointer
->	O
code	char
==	O
230	int
)	O
break	O
;	O
if	O
(	O
add_SPLINE	function
(	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
SPLINE	pointer
,	O
dat	pointer
,	O
pair	pointer
,	O
&	O
j	long
,	O
&	O
flag	short
)	O
)	O
goto	O
next_pair	O
;	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_HATCH	int
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
||	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
break	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
91	int
||	O
pair	pointer
->	O
code	char
==	O
78	int
||	O
pair	pointer
->	O
code	char
==	O
453	int
)	O
{	O
pair	pointer
=	O
add_HATCH	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
||	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
goto	O
search_field	O
;	O
}	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
is_textlike	function
(	O
obj	pointer
)	O
)	O
{	O
BITCODE_RC	char
dataflags	char
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
||	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
goto	O
search_field	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
30	int
&&	O
pair	pointer
->	O
value	double
.	O
d	double
==	O
0.0	int
)	O
{	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"dataflags"	pointer
,	O
&	O
dataflags	char
,	O
NULL	O
)	O
;	O
dataflags	char
|=	O
1	int
;	O
LOG_TRACE	O
(	O
"%s.elevation 0.0 => dataflags = 0x%x\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
dataflags	char
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"dataflags"	pointer
,	O
&	O
dataflags	char
,	O
0	int
)	O
;	O
}	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MESH	int
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
91	int
)	O
{	O
pair	pointer
=	O
add_MESH	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
||	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
return	O
pair	pointer
;	O
goto	O
search_field	O
;	O
}	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DBCOLOR	int
)	O
{	O
Dwg_Object_DBCOLOR	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DBCOLOR	pointer
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
62	int
)	O
{	O
o	pointer
->	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"DBCOLOR.color.index = %d [CMC %d]\n"	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
pair	pointer
->	O
code	char
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
430	int
)	O
{	O
char	O
*	O
x	double
;	O
o	pointer
->	O
catalog	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
x	double
=	O
strchr	function
(	O
o	pointer
->	O
catalog	pointer
,	O
'$'	O
)	O
;	O
if	O
(	O
!	O
x	double
)	O
goto	O
search_field	O
;	O
o	pointer
->	O
name	pointer
=	O
strdup	function
(	O
x	double
+	O
1	int
)	O
;	O
x	double
[	O
0	int
]	O
=	O
'\0'	O
;	O
LOG_TRACE	O
(	O
"DBCOLOR.catalog = %s [CMC %d]\n"	pointer
,	O
o	pointer
->	O
catalog	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
LOG_TRACE	O
(	O
"DBCOLOR.name = %s [CMC %d]\n"	pointer
,	O
o	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MLEADERSTYLE	int
)	O
{	O
Dwg_Object_MLEADERSTYLE	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
MLEADERSTYLE	pointer
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
47	int
)	O
o	pointer
->	O
block_scale	struct
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
49	int
)	O
o	pointer
->	O
block_scale	struct
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
140	int
)	O
{	O
o	pointer
->	O
block_scale	struct
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MLEADERSTYLE.block_scale = (%f, %f, %f) [3BD 47]\n"	pointer
,	O
o	pointer
->	O
block_scale	struct
.	O
x	double
,	O
o	pointer
->	O
block_scale	struct
.	O
y	double
,	O
o	pointer
->	O
block_scale	struct
.	O
z	double
)	O
;	O
}	O
else	O
goto	O
search_field	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MTEXT	int
&&	O
pair	pointer
->	O
code	char
==	O
50	int
)	O
{	O
Dwg_Entity_MTEXT	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MTEXT	pointer
;	O
if	O
(	O
!	O
o	pointer
->	O
num_column_heights	int
)	O
o	pointer
->	O
num_column_heights	int
=	O
1	int
;	O
if	O
(	O
!	O
j	long
)	O
o	pointer
->	O
column_heights	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_column_heights	int
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_column_heights	int
)	O
;	O
o	pointer
->	O
column_heights	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"MTEXT.column_heights[%d] = %f [BD* 50]\n"	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_VPORT	int
&&	O
pair	pointer
->	O
code	char
==	O
41	int
)	O
{	O
Dwg_Object_VPORT	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT	pointer
;	O
o	pointer
->	O
aspect_ratio	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
o	pointer
->	O
viewwidth	double
=	O
o	pointer
->	O
aspect_ratio	double
*	O
o	pointer
->	O
VIEWSIZE	double
;	O
LOG_TRACE	O
(	O
"VPORT.aspect_ratio = %f [BD 41]\n"	pointer
,	O
o	pointer
->	O
aspect_ratio	double
)	O
;	O
LOG_TRACE	O
(	O
"VPORT.viewwidth = %f [BD 0]\n"	pointer
,	O
o	pointer
->	O
viewwidth	double
)	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LEADER	int
&&	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
||	O
pair	pointer
->	O
code	char
==	O
20	int
||	O
pair	pointer
->	O
code	char
==	O
30	int
)	O
)	O
{	O
Dwg_Entity_LEADER	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
LEADER	pointer
;	O
if	O
(	O
!	O
j	long
&&	O
pair	pointer
->	O
code	char
==	O
10	int
)	O
o	pointer
->	O
points	pointer
=	O
xcalloc	function
(	O
o	pointer
->	O
num_points	int
,	O
sizeof	O
(	O
BITCODE_3BD	struct
)	O
)	O
;	O
assert	O
(	O
j	long
>=	O
0	int
)	O
;	O
assert	O
(	O
j	long
<	O
(	O
int	O
)	O
o	pointer
->	O
num_points	int
)	O
;	O
assert	O
(	O
o	pointer
->	O
points	pointer
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
)	O
o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
30	int
)	O
{	O
o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"LEADER.points[%d] = (%f, %f, %f) [3BD* 10]\n"	pointer
,	O
j	long
,	O
o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
x	double
,	O
o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
y	double
,	O
o	pointer
->	O
points	pointer
[	O
j	long
]	O
.	O
z	double
)	O
;	O
j	long
++	O
;	O
}	O
}	O
else	O
search_field	O
:	O
{	O
const	O
Dwg_DYNAPI_field	struct
*	O
f	pointer
;	O
const	O
Dwg_DYNAPI_field	struct
*	O
fields	pointer
=	O
dwg_dynapi_entity_fields	function
(	O
obj	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
break	O
;	O
if	O
(	O
!	O
fields	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Illegal object name %s, no dynapi fields"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
f	pointer
=	O
&	O
fields	pointer
[	O
0	int
]	O
;	O
f	pointer
->	O
name	pointer
;	O
f	pointer
++	O
)	O
{	O
LOG_INSANE	O
(	O
"-%s.%s [%d %s] vs %d\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
f	pointer
->	O
dxf	short
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
if	O
(	O
pair	pointer
->	O
code	char
!=	O
3	int
&&	O
f	pointer
->	O
is_malloc	short
&&	O
!	O
f	pointer
->	O
is_string	short
&&	O
strNE	O
(	O
f	pointer
->	O
name	pointer
,	O
"parent"	pointer
)	O
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
10	int
&&	O
pair	pointer
->	O
code	char
<=	O
24	int
&&	O
strEQc	O
(	O
f	pointer
->	O
name	pointer
,	O
"clip_verts"	pointer
)	O
)	O
{	O
BITCODE_BL	int
num_clip_verts	int
=	O
0	int
;	O
BITCODE_2RD	struct
*	O
clip_verts	pointer
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
14	int
||	O
pair	pointer
->	O
code	char
==	O
24	int
)	O
{	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_clip_verts"	pointer
,	O
&	O
num_clip_verts	int
,	O
NULL	O
)	O
;	O
LOG_INSANE	O
(	O
"%s.num_clip_verts = %d, j = %d\n"	pointer
,	O
name	pointer
,	O
num_clip_verts	int
,	O
j	long
)	O
;	O
}	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"clip_verts"	pointer
,	O
&	O
clip_verts	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
20	int
)	O
{	O
if	O
(	O
!	O
j	long
&&	O
pair	pointer
->	O
code	char
==	O
14	int
)	O
{	O
clip_verts	pointer
=	O
xcalloc	function
(	O
num_clip_verts	int
,	O
sizeof	O
(	O
BITCODE_2RD	struct
)	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
clip_verts	pointer
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
11	int
)	O
{	O
clip_verts	pointer
=	O
realloc	function
(	O
clip_verts	pointer
,	O
(	O
j	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
BITCODE_2RD	struct
)	O
)	O
;	O
memset	function
(	O
&	O
clip_verts	pointer
[	O
j	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
BITCODE_2RD	struct
)	O
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
clip_verts	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
j	long
>=	O
0	int
&&	O
j	long
<	O
(	O
int	O
)	O
num_clip_verts	int
&&	O
clip_verts	pointer
)	O
clip_verts	pointer
[	O
j	long
]	O
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
30	int
)	O
{	O
if	O
(	O
j	long
>=	O
0	int
&&	O
j	long
<	O
(	O
int	O
)	O
num_clip_verts	int
&&	O
clip_verts	pointer
)	O
{	O
clip_verts	pointer
[	O
j	long
]	O
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
LOG_TRACE	O
(	O
"%s.%s[%d] = (%f, %f) [2RD* %d]\n"	pointer
,	O
name	pointer
,	O
"clip_verts"	pointer
,	O
j	long
,	O
clip_verts	pointer
[	O
j	long
]	O
.	O
x	double
,	O
clip_verts	pointer
[	O
j	long
]	O
.	O
y	double
,	O
pair	pointer
->	O
code	char
-	O
10	int
)	O
;	O
j	long
++	O
;	O
}	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
21	int
)	O
{	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_clip_verts"	pointer
,	O
&	O
j	long
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.num_clip_verts = %d\n"	pointer
,	O
name	pointer
,	O
j	long
)	O
;	O
}	O
}	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
f	pointer
->	O
dxf	short
==	O
pair	pointer
->	O
code	char
)	O
LOG_TRACE	O
(	O
"Warning: Ignore %s.%s VECTOR [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
f	pointer
->	O
dxf	short
==	O
pair	pointer
->	O
code	char
)	O
{	O
if	O
(	O
(	O
pair	pointer
->	O
code	char
==	O
92	int
)	O
&&	O
is_entity	int
&&	O
obj	pointer
->	O
fixedtype	enum
>	O
DWG_TYPE_LAYOUT	int
&&	O
strEQc	O
(	O
subclass	array
,	O
"AcDbEntity"	pointer
)	O
)	O
{	O
pair	pointer
=	O
add_ent_preview	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
3	int
&&	O
memBEGINc	O
(	O
obj	pointer
->	O
name	pointer
,	O
"DICTIONARY"	pointer
)	O
&&	O
strNE	O
(	O
obj	pointer
->	O
name	pointer
,	O
"DICTIONARYVAR"	pointer
)	O
)	O
{	O
strncpy	function
(	O
text	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
254	int
)	O
;	O
text	pointer
[	O
255	int
]	O
=	O
'\0'	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
>=	O
50	int
&&	O
pair	pointer
->	O
code	char
<=	O
55	int
)	O
{	O
BITCODE_BD	double
ang	double
;	O
if	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
==	O
0.0	int
)	O
goto	O
next_pair	O
;	O
ang	double
=	O
deg2rad	O
(	O
pair	pointer
->	O
value	double
.	O
d	double
)	O
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
ang	double
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = %f (from DEG %f°) [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
ang	double
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"H"	pointer
)	O
)	O
{	O
BITCODE_H	pointer
ref	pointer
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
ref	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
>	O
300	int
)	O
{	O
ref	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
obj_hdls	pointer
=	O
array_push	function
(	O
obj_hdls	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
objid	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s: name %s -> H for code "	pointer
"%d later\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
}	O
else	O
{	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
ref	pointer
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s = "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
f	pointer
->	O
size	char
>	O
8	int
&&	O
(	O
strchr	function
(	O
f	pointer
->	O
type	short
,	O
'2'	O
)	O
||	O
strchr	function
(	O
f	pointer
->	O
type	short
,	O
'3'	O
)	O
||	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"BE"	pointer
)	O
)	O
)	O
{	O
pt	array
.	O
x	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pt	array
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s.x = %f [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
f	pointer
->	O
size	char
>	O
8	int
&&	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"CMC"	pointer
)	O
)	O
{	O
BITCODE_CMC	struct
color	short
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
color	short
,	O
NULL	O
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
100	int
)	O
{	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"%s.%s.index = %d [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
430	int
)	O
{	O
color	short
.	O
rgb	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
&	O
0x00FFFFFF	int
;	O
color	short
.	O
alpha	char
=	O
(	O
pair	pointer
->	O
value	double
.	O
l	long
&	O
0xFF000000	int
)	O
>>	O
24	int
;	O
if	O
(	O
color	short
.	O
alpha	char
)	O
color	short
.	O
alpha_type	char
=	O
3	int
;	O
LOG_TRACE	O
(	O
"%s.%s.rgb = %08X [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
440	int
)	O
{	O
color	short
.	O
flag	short
|=	O
0x10	int
;	O
color	short
.	O
name	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s.name = %s [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
<	O
450	int
)	O
{	O
color	short
.	O
alpha	char
=	O
(	O
pair	pointer
->	O
value	double
.	O
l	long
&	O
0xFF000000	int
)	O
>>	O
24	int
;	O
if	O
(	O
color	short
.	O
alpha	char
)	O
color	short
.	O
alpha_type	char
=	O
3	int
;	O
LOG_TRACE	O
(	O
"%s.%s.alpha = %08X [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
color	short
,	O
1	int
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
if	O
(	O
f	pointer
->	O
is_string	short
)	O
{	O
LOG_TRACE	O
(	O
"%s.%s = %s [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
&	O
f	pointer
->	O
type	short
[	O
1	int
]	O
,	O
'D'	O
)	O
)	O
{	O
LOG_TRACE	O
(	O
"%s.%s = %f [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"%s.%s = %ld [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
f	pointer
->	O
type	short
==	O
'3'	O
||	O
*	O
f	pointer
->	O
type	short
==	O
'2'	O
||	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"BE"	pointer
)	O
)	O
&&	O
(	O
strstr	function
(	O
f	pointer
->	O
type	short
,	O
"_1"	pointer
)	O
?	O
f	pointer
->	O
dxf	short
+	O
1	int
==	O
pair	pointer
->	O
code	char
:	O
f	pointer
->	O
dxf	short
+	O
10	int
==	O
pair	pointer
->	O
code	char
)	O
)	O
{	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pt	array
,	O
NULL	O
)	O
;	O
pt	array
.	O
y	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pt	array
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s.y = %f [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
f	pointer
->	O
type	short
==	O
'3'	O
||	O
*	O
f	pointer
->	O
type	short
==	O
'2'	O
||	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"BE"	pointer
)	O
)	O
&&	O
(	O
strstr	function
(	O
f	pointer
->	O
type	short
,	O
"_1"	pointer
)	O
?	O
f	pointer
->	O
dxf	short
+	O
2	int
==	O
pair	pointer
->	O
code	char
:	O
f	pointer
->	O
dxf	short
+	O
20	int
==	O
pair	pointer
->	O
code	char
)	O
)	O
{	O
pt	array
.	O
z	double
=	O
0.0	int
;	O
if	O
(	O
strNE	O
(	O
name	pointer
,	O
"_3DFACE"	pointer
)	O
&&	O
strNE	O
(	O
f	pointer
->	O
name	pointer
,	O
"scale"	pointer
)	O
&&	O
*	O
f	pointer
->	O
type	short
==	O
'2'	O
)	O
goto	O
next_pair	O
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pt	array
,	O
NULL	O
)	O
;	O
pt	array
.	O
z	double
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pt	array
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s.z = %f [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
name	pointer
,	O
"scale"	pointer
)	O
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
&&	O
dwg_dynapi_entity_field	function
(	O
obj	pointer
->	O
name	pointer
,	O
"scale_flag"	pointer
)	O
&&	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"scale_flag"	pointer
,	O
&	O
scale_flag	char
,	O
NULL	O
)	O
)	O
{	O
scale_flag	char
=	O
0	int
;	O
if	O
(	O
pt	array
.	O
x	double
==	O
1.0	int
&&	O
pt	array
.	O
y	double
==	O
1.0	int
&&	O
pt	array
.	O
z	double
==	O
1.0	int
)	O
scale_flag	char
=	O
3	int
;	O
else	O
if	O
(	O
pt	array
.	O
x	double
==	O
1.0	int
)	O
scale_flag	char
=	O
1	int
;	O
else	O
if	O
(	O
pt	array
.	O
x	double
==	O
pt	array
.	O
y	double
&&	O
pt	array
.	O
x	double
==	O
pt	array
.	O
z	double
)	O
scale_flag	char
=	O
2	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"scale_flag"	pointer
,	O
&	O
scale_flag	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.scale_flag = %d [BB 0]\n"	pointer
,	O
name	pointer
,	O
scale_flag	char
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"_3DFACE"	pointer
)	O
&&	O
strEQc	O
(	O
f	pointer
->	O
name	pointer
,	O
"corner1"	pointer
)	O
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
&&	O
pt	array
.	O
z	double
==	O
0.0	int
)	O
{	O
BITCODE_B	char
z_is_zero	char
=	O
1	int
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"z_is_zero"	pointer
,	O
&	O
z_is_zero	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.z_is_zero = 1 [B 0]\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"BD*"	pointer
)	O
&&	O
(	O
strEQc	O
(	O
name	pointer
,	O
"EXTRUDEDSURFACE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"LOFTEDSURFACE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"SWEPTSURFACE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"REVOLVEDSURFACE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"MATERIAL"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"SPATIAL_FILTER"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"ACSH_SWEEP_CLASS"	pointer
)	O
)	O
&&	O
(	O
(	O
pair	pointer
->	O
code	char
>=	O
40	int
&&	O
pair	pointer
->	O
code	char
<=	O
49	int
)	O
||	O
(	O
pair	pointer
->	O
code	char
<=	O
142	int
&&	O
pair	pointer
->	O
code	char
<=	O
147	int
)	O
)	O
)	O
{	O
BITCODE_BD	double
*	O
matrix	pointer
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
matrix	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
matrix	pointer
)	O
{	O
matrix	pointer
=	O
xcalloc	function
(	O
16	int
,	O
sizeof	O
(	O
BITCODE_BD	double
)	O
)	O
;	O
j	long
=	O
0	int
;	O
}	O
assert	O
(	O
j	long
>=	O
0	int
&&	O
j	long
<	O
16	int
)	O
;	O
matrix	pointer
[	O
j	long
]	O
=	O
pair	pointer
->	O
value	double
.	O
d	double
;	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
matrix	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s[%d] = %f [%s %d]\n"	pointer
,	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
j	long
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
;	O
j	long
++	O
;	O
goto	O
next_pair	O
;	O
}	O
}	O
LOG_INSANE	O
(	O
"----\n"	pointer
)	O
fields	pointer
=	O
is_entity	int
?	O
dwg_dynapi_common_entity_fields	function
(	O
)	O
:	O
dwg_dynapi_common_object_fields	function
(	O
)	O
;	O
for	O
(	O
f	pointer
=	O
&	O
fields	pointer
[	O
0	int
]	O
;	O
f	pointer
->	O
name	pointer
;	O
f	pointer
++	O
)	O
{	O
LOG_INSANE	O
(	O
"-%s.%s [%d %s] vs %d\n"	pointer
,	O
is_entity	int
?	O
"ENTITY"	pointer
:	O
"OBJECT"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
f	pointer
->	O
dxf	short
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
if	O
(	O
(	O
pair	pointer
->	O
code	char
==	O
62	int
||	O
pair	pointer
->	O
code	char
==	O
420	int
||	O
pair	pointer
->	O
code	char
==	O
430	int
||	O
pair	pointer
->	O
code	char
==	O
440	int
)	O
&&	O
(	O
f	pointer
->	O
size	char
>	O
8	int
&&	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"CMC"	pointer
)	O
)	O
)	O
{	O
BITCODE_CMC	struct
color	short
;	O
dwg_dynapi_common_value	function
(	O
_obj	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
color	short
,	O
NULL	O
)	O
;	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
62	int
)	O
{	O
color	short
.	O
index	short
=	O
pair	pointer
->	O
value	double
.	O
i	int
;	O
LOG_TRACE	O
(	O
"COMMON.%s.index = %d [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
i	int
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
420	int
)	O
{	O
color	short
.	O
rgb	int
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
color	short
.	O
alpha	char
=	O
(	O
pair	pointer
->	O
value	double
.	O
l	long
&	O
0xFF000000	int
)	O
>>	O
24	int
;	O
if	O
(	O
color	short
.	O
alpha	char
)	O
color	short
.	O
alpha_type	char
=	O
3	int
;	O
LOG_TRACE	O
(	O
"COMMON.%s.rgb = %08X [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
440	int
)	O
{	O
color	short
.	O
flag	short
|=	O
0x20	int
;	O
color	short
.	O
alpha	char
=	O
(	O
pair	pointer
->	O
value	double
.	O
l	long
&	O
0xFF000000	int
)	O
>>	O
24	int
;	O
color	short
.	O
alpha_type	char
=	O
pair	pointer
->	O
value	double
.	O
u	union
>>	O
8	int
;	O
if	O
(	O
color	short
.	O
alpha	char
&&	O
!	O
color	short
.	O
alpha_type	char
)	O
color	short
.	O
alpha_type	char
=	O
3	int
;	O
LOG_TRACE	O
(	O
"COMMON.%s.alpha = %08X [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
430	int
)	O
{	O
color	short
.	O
flag	short
|=	O
0x10	int
;	O
color	short
.	O
name	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
LOG_TRACE	O
(	O
"COMMON.%s.name = %s [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CMC"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
}	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
color	short
,	O
is_utf	int
)	O
;	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
f	pointer
->	O
dxf	short
==	O
pair	pointer
->	O
code	char
)	O
{	O
if	O
(	O
strEQc	O
(	O
f	pointer
->	O
type	short
,	O
"H"	pointer
)	O
)	O
{	O
BITCODE_H	pointer
handle	pointer
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
!	O
handle	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
>	O
300	int
)	O
{	O
handle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
obj	pointer
)	O
;	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
handle	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"COMMON.%s = %X [H %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
u	union
,	O
pair	pointer
->	O
code	char
)	O
}	O
else	O
{	O
LOG_WARN	O
(	O
"TODO resolve common handle name %s %s"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
}	O
}	O
else	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
>	O
300	int
)	O
LOG_TRACE	O
(	O
"COMMON.%s = %lX [H %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
pair	pointer
->	O
code	char
)	O
else	O
LOG_TRACE	O
(	O
"COMMON.%s = %s [H %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
pair	pointer
->	O
code	char
)	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
handle	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
is_entity	int
&&	O
pair	pointer
->	O
code	char
==	O
6	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
)	O
{	O
BITCODE_BB	char
flags	char
=	O
3	int
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BYLAYER"	pointer
)	O
)	O
flags	char
=	O
0	int
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BYBLOCK"	pointer
)	O
)	O
flags	char
=	O
1	int
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CONTINUOUS"	pointer
)	O
)	O
flags	char
=	O
2	int
;	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
"ltype_flags"	pointer
,	O
&	O
flags	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"COMMON.%s = %d [BB 0]\n"	pointer
,	O
"ltype_flags"	pointer
,	O
flags	char
)	O
;	O
}	O
if	O
(	O
is_entity	int
&&	O
pair	pointer
->	O
code	char
==	O
390	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
)	O
{	O
BITCODE_BB	char
flags	char
=	O
3	int
;	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
"plotstyle_flags"	pointer
,	O
&	O
flags	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"COMMON.%s = %d [BB 0]\n"	pointer
,	O
"plotstyle_flags"	pointer
,	O
flags	char
)	O
;	O
}	O
if	O
(	O
is_entity	int
&&	O
pair	pointer
->	O
code	char
==	O
347	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
{	O
BITCODE_BB	char
flags	char
=	O
3	int
;	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
"material_flags"	pointer
,	O
&	O
flags	char
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"COMMON.%s = %d [BB 0]\n"	pointer
,	O
"material_flags"	pointer
,	O
flags	char
)	O
;	O
}	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
310	int
&&	O
is_entity	int
&&	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
preview_size	int
&&	O
obj	pointer
->	O
fixedtype	enum
>	O
DWG_TYPE_LAYOUT	int
&&	O
strEQc	O
(	O
subclass	array
,	O
"AcDbEntity"	pointer
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Skip duplicate/interrupted %s.preview"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
goto	O
next_pair	O
;	O
}	O
else	O
{	O
if	O
(	O
f	pointer
->	O
is_malloc	short
||	O
f	pointer
->	O
is_string	short
)	O
{	O
char	O
*	O
ptr	pointer
=	O
NULL	O
;	O
if	O
(	O
dwg_dynapi_common_value	function
(	O
_obj	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
ptr	pointer
,	O
NULL	O
)	O
&&	O
ptr	pointer
!=	O
NULL	O
)	O
{	O
LOG_ERROR	O
(	O
"Skip duplicate %s.%s [%s %d]"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
f	pointer
->	O
name	pointer
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
goto	O
next_pair	O
;	O
}	O
}	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
f	pointer
->	O
name	pointer
,	O
&	O
pair	pointer
->	O
value	double
,	O
1	int
)	O
;	O
if	O
(	O
f	pointer
->	O
is_string	short
)	O
{	O
LOG_TRACE	O
(	O
"COMMON.%s = %s [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
}	O
else	O
{	O
if	O
(	O
is_entity	int
&&	O
pair	pointer
->	O
code	char
==	O
160	int
)	O
{	O
pair	pointer
=	O
add_ent_preview	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
goto	O
start_loop	O
;	O
}	O
if	O
(	O
strchr	function
(	O
f	pointer
->	O
type	short
,	O
'D'	O
)	O
)	O
LOG_TRACE	O
(	O
"COMMON.%s = %f [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
d	double
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
else	O
LOG_TRACE	O
(	O
"COMMON.%s = %ld [%s %d]\n"	pointer
,	O
f	pointer
->	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
l	long
,	O
f	pointer
->	O
type	short
,	O
pair	pointer
->	O
code	char
)	O
}	O
goto	O
next_pair	O
;	O
}	O
}	O
}	O
LOG_INSANE	O
(	O
"----\n"	pointer
)	O
if	O
(	O
(	O
pair	pointer
->	O
code	char
==	O
92	int
)	O
&&	O
is_entity	int
&&	O
obj	pointer
->	O
fixedtype	enum
>	O
DWG_TYPE_LAYOUT	int
&&	O
(	O
strEQc	O
(	O
subclass	array
,	O
"AcDbEntity"	pointer
)	O
||	O
strEQc	O
(	O
subclass	array
,	O
"AcDbProxyEntity"	pointer
)	O
||	O
strstr	function
(	O
subclass	array
,	O
"Surface"	pointer
)	O
)	O
)	O
{	O
pair	pointer
=	O
add_ent_preview	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"MULTILEADER"	pointer
)	O
)	O
{	O
pair	pointer
=	O
add_MULTILEADER	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
&&	O
pair	pointer
->	O
code	char
==	O
301	int
)	O
goto	O
next_pair	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_TABLESTYLE	int
)	O
{	O
pair	pointer
=	O
add_TABLESTYLE	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
if	O
(	O
pair	pointer
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
goto	O
start_loop	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"BLOCK"	pointer
)	O
&&	O
(	O
pair	pointer
->	O
code	char
==	O
70	int
||	O
pair	pointer
->	O
code	char
==	O
10	int
||	O
pair	pointer
->	O
code	char
==	O
20	int
||	O
pair	pointer
->	O
code	char
==	O
30	int
||	O
pair	pointer
->	O
code	char
==	O
3	int
||	O
pair	pointer
->	O
code	char
==	O
1	int
)	O
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"DIMENSION"	pointer
)	O
&&	O
(	O
pair	pointer
->	O
code	char
==	O
2	int
||	O
pair	pointer
->	O
code	char
==	O
210	int
||	O
pair	pointer
->	O
code	char
==	O
220	int
||	O
pair	pointer
->	O
code	char
==	O
230	int
)	O
)	O
;	O
else	O
if	O
(	O
(	O
strEQc	O
(	O
name	pointer
,	O
"POLYLINE_2D"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"POLYLINE_3D"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"HATCH"	pointer
)	O
)	O
&&	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
||	O
pair	pointer
->	O
code	char
==	O
20	int
)	O
)	O
;	O
else	O
if	O
(	O
(	O
strEQc	O
(	O
name	pointer
,	O
"VERTEX_PFACE_FACE"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"POLYLINE_PFACE"	pointer
)	O
)	O
&&	O
(	O
pair	pointer
->	O
code	char
==	O
10	int
||	O
pair	pointer
->	O
code	char
==	O
20	int
||	O
pair	pointer
->	O
code	char
==	O
30	int
)	O
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
70	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"POLYLINE_PFACE"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
30	int
&&	O
strEQc	O
(	O
name	pointer
,	O
"POLYLINE_3D"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_PROXY_ENTITY	int
&&	O
pair	pointer
->	O
code	char
==	O
92	int
)	O
{	O
pair	pointer
=	O
add_ent_preview	function
(	O
obj	pointer
,	O
dat	pointer
,	O
pair	pointer
)	O
;	O
goto	O
start_loop	O
;	O
}	O
else	O
LOG_WARN	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
name	pointer
)	O
;	O
}	O
}	O
next_pair	O
:	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_RETURN_EOF	O
(	O
pair	pointer
)	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_SEQEND	int
)	O
postprocess_SEQEND	function
(	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE__3DFACE	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
)	O
{	O
Dwg_Entity__3DFACE	struct
*	O
o	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
_3DFACE	pointer
;	O
o	pointer
->	O
has_no_flags	char
=	O
1	int
;	O
LOG_TRACE	O
(	O
"_3DFACE.has_no_flags = 1 [B]\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_textlike	function
(	O
obj	pointer
)	O
)	O
postprocess_TEXTlike	function
(	O
obj	pointer
)	O
;	O
if	O
(	O
is_entity	int
?	O
!	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
xdicobjhandle	pointer
:	O
!	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
{	O
if	O
(	O
is_entity	int
)	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
xdic_missing_flag	char
=	O
1	int
;	O
else	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
1	int
;	O
}	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
!	O
is_entity	int
)	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
0	int
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
is_entity	int
)	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
xdicobjhandle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
0	int
,	O
obj	pointer
)	O
;	O
}	O
if	O
(	O
is_entity	int
)	O
{	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_14	int
)	O
{	O
if	O
(	O
ent	pointer
->	O
ltype_flags	char
<	O
3	int
)	O
ent	pointer
->	O
isbylayerlt	char
=	O
1	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2000	int
&&	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_SEQEND	int
&&	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_ENDBLK	int
)	O
{	O
Dwg_Object	struct
*	O
prev	int
=	O
find_prev_entity	function
(	O
obj	pointer
)	O
;	O
ent	pointer
->	O
next_entity	pointer
=	O
NULL	O
;	O
if	O
(	O
prev	int
)	O
{	O
if	O
(	O
prev	int
->	O
tio	union
.	O
entity	long
->	O
prev_entity	pointer
)	O
prev	int
->	O
tio	union
.	O
entity	long
->	O
nolinks	char
=	O
0	int
;	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK	int
||	O
(	O
prev	int
->	O
type	short
!=	O
DWG_TYPE_SEQEND	int
&&	O
prev	int
->	O
type	short
!=	O
DWG_TYPE_ENDBLK	int
)	O
)	O
{	O
prev	int
->	O
tio	union
.	O
entity	long
->	O
nolinks	char
=	O
0	int
;	O
prev	int
->	O
tio	union
.	O
entity	long
->	O
next_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
prev	int
)	O
;	O
LOG_TRACE	O
(	O
"prev %s(%lX).next_entity = "	pointer
FORMAT_REF	pointer
"\n"	pointer
,	O
prev	int
->	O
name	pointer
,	O
prev	int
->	O
handle	pointer
.	O
value	double
,	O
ARGS_REF	O
(	O
prev	int
->	O
tio	union
.	O
entity	long
->	O
next_entity	pointer
)	O
)	O
;	O
ent	pointer
->	O
nolinks	char
=	O
0	int
;	O
ent	pointer
->	O
prev_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
prev	int
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
)	O
;	O
LOG_TRACE	O
(	O
"%s.prev_entity = "	pointer
FORMAT_REF	pointer
"\n"	pointer
,	O
name	pointer
,	O
ARGS_REF	O
(	O
ent	pointer
->	O
prev_entity	pointer
)	O
)	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"%s.prev_entity = NULL HANDLE 4\n"	pointer
,	O
name	pointer
)	O
;	O
ent	pointer
->	O
prev_entity	pointer
=	O
NULL	O
;	O
ent	pointer
->	O
nolinks	char
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK	int
)	O
{	O
ent	pointer
->	O
nolinks	char
=	O
0	int
;	O
ent	pointer
->	O
prev_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
0	int
,	O
NULL	O
)	O
;	O
ent	pointer
->	O
next_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
0	int
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.prev_entity = next_entity = "	pointer
FORMAT_REF	pointer
"\n"	pointer
,	O
name	pointer
,	O
ARGS_REF	O
(	O
ent	pointer
->	O
prev_entity	pointer
)	O
)	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"%s.prev_entity = NULL HANDLE 4\n"	pointer
,	O
name	pointer
)	O
;	O
ent	pointer
->	O
prev_entity	pointer
=	O
NULL	O
;	O
ent	pointer
->	O
nolinks	char
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_SEQEND	int
&&	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_ENDBLK	int
)	O
ent	pointer
->	O
nolinks	char
=	O
1	int
;	O
}	O
return	O
pair	pointer
;	O
}	O
static	O
int	O
dxf_tables_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
char	O
table	pointer
[	O
80	int
]	O
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
table	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
pair	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
0	int
&&	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
{	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"TABLE"	pointer
)	O
)	O
table	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BLOCK_RECORD"	pointer
)	O
)	O
{	O
strncpy	function
(	O
table	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
79	int
)	O
;	O
table	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ENDTAB"	pointer
)	O
)	O
table	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ENDSEC"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Unknown 0 %s (%s)"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"tables"	pointer
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
code	char
==	O
2	int
&&	O
pair	pointer
->	O
value	double
.	O
s	pointer
&&	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
<	O
80	int
&&	O
is_table_name	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
)	O
{	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
BITCODE_BL	int
ctrl_id	int
;	O
strncpy	function
(	O
table	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
79	int
)	O
;	O
table	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
pair	pointer
=	O
new_table_control	function
(	O
table	pointer
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
ctrl_id	int
=	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
;	O
while	O
(	O
pair	pointer
&&	O
pair	pointer
->	O
code	char
==	O
0	int
&&	O
strEQ	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
table	pointer
)	O
)	O
{	O
char	O
*	O
dxfname	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
new_object	function
(	O
table	pointer
,	O
dxfname	pointer
,	O
dat	pointer
,	O
dwg	pointer
,	O
ctrl_id	int
,	O
i	int
++	O
)	O
;	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"BLOCK_RECORD"	pointer
)	O
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
;	O
Dwg_Object	struct
*	O
ctrl	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
ctrl_id	int
]	O
;	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
_ctrl	pointer
=	O
ctrl	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
;	O
if	O
(	O
_ctrl	pointer
->	O
model_space	pointer
&&	O
obj	pointer
->	O
handle	pointer
.	O
value	double
==	O
_ctrl	pointer
->	O
model_space	pointer
->	O
absolute_ref	long
)	O
i	int
--	O
;	O
else	O
if	O
(	O
_ctrl	pointer
->	O
paper_space	pointer
&&	O
obj	pointer
->	O
handle	pointer
.	O
value	double
==	O
_ctrl	pointer
->	O
paper_space	pointer
->	O
absolute_ref	long
)	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"LTYPE"	pointer
)	O
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
;	O
Dwg_Object_LTYPE	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE	pointer
;	O
Dwg_Object	struct
*	O
ctrl	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
ctrl_id	int
]	O
;	O
Dwg_Object_LTYPE_CONTROL	struct
*	O
_ctrl	pointer
=	O
ctrl	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE_CONTROL	pointer
;	O
if	O
(	O
_ctrl	pointer
->	O
bylayer	pointer
&&	O
obj	pointer
->	O
handle	pointer
.	O
value	double
==	O
_ctrl	pointer
->	O
bylayer	pointer
->	O
absolute_ref	long
)	O
i	int
--	O
;	O
else	O
if	O
(	O
_ctrl	pointer
->	O
byblock	pointer
&&	O
obj	pointer
->	O
handle	pointer
.	O
value	double
==	O
_ctrl	pointer
->	O
byblock	pointer
->	O
absolute_ref	long
)	O
i	int
--	O
;	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>	O
R_2004	int
&&	O
_obj	pointer
->	O
name	pointer
&&	O
strNE	O
(	O
_obj	pointer
->	O
name	pointer
,	O
"Continuous"	pointer
)	O
)	O
{	O
_obj	pointer
->	O
text_area_is_present	char
=	O
0	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2004	int
)	O
_obj	pointer
->	O
strings_area	pointer
=	O
xcalloc	function
(	O
256	int
,	O
1	int
)	O
;	O
}	O
}	O
{	O
Dwg_Object	struct
*	O
ctrl	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
ctrl_id	int
]	O
;	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
_ctrl	pointer
=	O
ctrl	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
;	O
int	O
at_end	int
=	O
1	int
;	O
if	O
(	O
_ctrl	pointer
)	O
{	O
for	O
(	O
int	O
j	long
=	O
_ctrl	pointer
->	O
num_entries	short
-	O
1	int
;	O
j	long
>=	O
0	int
;	O
j	long
--	O
)	O
{	O
BITCODE_H	pointer
ref	pointer
=	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
ref	pointer
)	O
{	O
if	O
(	O
at_end	int
)	O
{	O
_ctrl	pointer
->	O
num_entries	short
--	O
;	O
_ctrl	pointer
->	O
entries	pointer
=	O
realloc	function
(	O
_ctrl	pointer
->	O
entries	pointer
,	O
_ctrl	pointer
->	O
num_entries	short
*	O
sizeof	O
(	O
BITCODE_H	pointer
)	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.num_entries-- => %d\n"	pointer
,	O
ctrl	pointer
->	O
name	pointer
,	O
_ctrl	pointer
->	O
num_entries	short
)	O
;	O
}	O
else	O
{	O
_ctrl	pointer
->	O
entries	pointer
[	O
j	long
]	O
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
2	int
,	O
0	int
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.entries[%d] = (2.0.0)\n"	pointer
,	O
ctrl	pointer
->	O
name	pointer
,	O
j	long
)	O
;	O
}	O
}	O
else	O
at_end	int
=	O
0	int
;	O
}	O
if	O
(	O
_ctrl	pointer
->	O
num_entries	short
==	O
1	int
&&	O
!	O
_ctrl	pointer
->	O
entries	pointer
[	O
0	int
]	O
)	O
{	O
_ctrl	pointer
->	O
entries	pointer
[	O
0	int
]	O
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
2	int
,	O
0	int
,	O
NULL	O
)	O
;	O
LOG_TRACE	O
(	O
"%s.entries[0] = (2.0.0)\n"	pointer
,	O
ctrl	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
}	O
}	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_CHECK_EOF	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dxf_blocks_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
char	O
name	pointer
[	O
80	int
]	O
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
name	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
{	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
BITCODE_BB	char
entmode	char
=	O
0	int
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
&&	O
strNE	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ENDSEC"	pointer
)	O
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
,	O
*	O
blkhdr	pointer
=	O
NULL	O
;	O
BITCODE_BL	int
idx	pointer
=	O
dwg	pointer
->	O
num_objects	int
;	O
char	O
*	O
dxfname	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
strncpy	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
79	int
)	O
;	O
name	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
entity_alias	function
(	O
name	pointer
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
new_object	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
dat	pointer
,	O
dwg	pointer
,	O
0	int
,	O
i	int
++	O
)	O
;	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
idx	pointer
]	O
;	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK	int
)	O
{	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
Dwg_Entity_BLOCK	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
BLOCK	pointer
;	O
i	int
=	O
0	int
;	O
if	O
(	O
ent	pointer
->	O
ownerhandle	pointer
&&	O
(	O
blkhdr	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
ent	pointer
->	O
ownerhandle	pointer
)	O
)	O
)	O
{	O
if	O
(	O
blkhdr	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
blkhdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
ent	pointer
->	O
ownerhandle	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
_hdr	pointer
->	O
block_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
blkhdr	pointer
)	O
;	O
LOG_TRACE	O
(	O
"BLOCK_HEADER.block_entity = "	pointer
FORMAT_REF	pointer
" [H] (blocks)\n"	pointer
,	O
ARGS_REF	O
(	O
_hdr	pointer
->	O
block_entity	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
blkhdr	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_BLOCK_CONTROL	int
)	O
{	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
_ctrl	pointer
=	O
blkhdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
;	O
ent	pointer
->	O
ownerhandle	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
_ctrl	pointer
->	O
model_space	pointer
&&	O
_obj	pointer
->	O
name	pointer
&&	O
strEQc	O
(	O
_obj	pointer
->	O
name	pointer
,	O
"*Model_Space"	pointer
)	O
)	O
{	O
_ctrl	pointer
->	O
model_space	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
blkhdr	pointer
)	O
;	O
LOG_TRACE	O
(	O
"BLOCK_CONTROL.model_space = "	pointer
FORMAT_REF	pointer
" [H] (blocks)\n"	pointer
,	O
ARGS_REF	O
(	O
_ctrl	pointer
->	O
model_space	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
_ctrl	pointer
->	O
paper_space	pointer
&&	O
_obj	pointer
->	O
name	pointer
&&	O
strEQc	O
(	O
_obj	pointer
->	O
name	pointer
,	O
"*Paper_Space"	pointer
)	O
)	O
{	O
_ctrl	pointer
->	O
paper_space	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
blkhdr	pointer
)	O
;	O
LOG_TRACE	O
(	O
"BLOCK_CONTROL.paper_space = "	pointer
FORMAT_REF	pointer
" [H] (blocks)\n"	pointer
,	O
ARGS_REF	O
(	O
_ctrl	pointer
->	O
paper_space	pointer
)	O
)	O
;	O
}	O
}	O
}	O
else	O
blkhdr	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
_obj	pointer
||	O
!	O
_obj	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
_obj	pointer
->	O
name	pointer
,	O
"*Model_Space"	pointer
)	O
)	O
entmode	char
=	O
ent	pointer
->	O
entmode	char
=	O
2	int
;	O
else	O
if	O
(	O
strEQc	O
(	O
_obj	pointer
->	O
name	pointer
,	O
"*Paper_Space"	pointer
)	O
)	O
entmode	char
=	O
ent	pointer
->	O
entmode	char
=	O
1	int
;	O
else	O
entmode	char
=	O
0	int
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ENDBLK	int
)	O
{	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
Dwg_Entity_BLOCK	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
BLOCK	pointer
;	O
ent	pointer
->	O
entmode	char
=	O
entmode	char
;	O
LOG_TRACE	O
(	O
"%s.entmode = %d [BB] (blocks)\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
entmode	char
)	O
;	O
entmode	char
=	O
0	int
;	O
if	O
(	O
(	O
blkhdr	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
ent	pointer
->	O
ownerhandle	pointer
)	O
)	O
&&	O
blkhdr	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
blkhdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
ent	pointer
->	O
ownerhandle	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
_hdr	pointer
->	O
endblk_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
blkhdr	pointer
)	O
;	O
LOG_TRACE	O
(	O
"BLOCK_HEADER.endblk_entity = "	pointer
FORMAT_REF	pointer
" [H] (blocks)\n"	pointer
,	O
ARGS_REF	O
(	O
_hdr	pointer
->	O
endblk_entity	pointer
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
{	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
entmode	char
=	O
entmode	char
;	O
LOG_TRACE	O
(	O
"%s.entmode = %d [BB] (blocks)\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
entmode	char
)	O
;	O
if	O
(	O
blkhdr	pointer
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<	O
R_2004	int
&&	O
blkhdr	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
blkhdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
_hdr	pointer
->	O
first_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
blkhdr	pointer
)	O
;	O
LOG_TRACE	O
(	O
"BLOCK_HEADER.first_entity = "	pointer
FORMAT_REF	pointer
" [H] (blocks)\n"	pointer
,	O
ARGS_REF	O
(	O
_hdr	pointer
->	O
first_entity	pointer
)	O
)	O
;	O
}	O
else	O
{	O
_hdr	pointer
->	O
last_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
blkhdr	pointer
)	O
;	O
LOG_TRACE	O
(	O
"BLOCK_HEADER.last_entity = "	pointer
FORMAT_REF	pointer
" [H] (blocks)\n"	pointer
,	O
ARGS_REF	O
(	O
_hdr	pointer
->	O
last_entity	pointer
)	O
)	O
;	O
}	O
}	O
}	O
}	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_CHECK_EOF	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
entity_alias	function
(	O
char	O
*	O
name	pointer
)	O
{	O
const	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACAD_TABLE"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"TABLE"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACAD_PROXY_ENTITY"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"PROXY_ENTITY"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDBPLACEHOLDER"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"PLACEHOLDER"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"POLYLINE"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"POLYLINE_2D"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"VERTEX"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"VERTEX_2D"	pointer
)	O
;	O
else	O
if	O
(	O
len	long
==	O
strlen	function
(	O
"PDFUNDERLAY"	pointer
)	O
&&	O
strEQc	O
(	O
&	O
name	pointer
[	O
3	int
]	O
,	O
"UNDERLAY"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"UNDERLAY"	pointer
)	O
;	O
else	O
if	O
(	O
memBEGINc	O
(	O
name	pointer
,	O
"ACAD_"	pointer
)	O
&&	O
is_dwg_entity	function
(	O
&	O
name	pointer
[	O
5	int
]	O
)	O
)	O
memmove	function
(	O
name	pointer
,	O
&	O
name	pointer
[	O
5	int
]	O
,	O
len	long
-	O
4	int
)	O
;	O
else	O
if	O
(	O
memBEGINc	O
(	O
name	pointer
,	O
"ACDB"	pointer
)	O
&&	O
is_dwg_entity	function
(	O
&	O
name	pointer
[	O
4	int
]	O
)	O
)	O
memmove	function
(	O
name	pointer
,	O
&	O
name	pointer
[	O
4	int
]	O
,	O
len	long
-	O
3	int
)	O
;	O
}	O
static	O
void	O
postprocess_BLOCK_HEADER	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ownerhandle	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_ctrl	pointer
;	O
Dwg_Object	struct
*	O
ctrl	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
ownerhandle	pointer
)	O
;	O
if	O
(	O
!	O
ctrl	pointer
||	O
ctrl	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
return	O
;	O
_ctrl	pointer
=	O
ctrl	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ENDBLK	int
)	O
{	O
if	O
(	O
!	O
_ctrl	pointer
->	O
endblk_entity	pointer
)	O
_ctrl	pointer
->	O
endblk_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
ctrl	pointer
)	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK	int
)	O
{	O
if	O
(	O
!	O
_ctrl	pointer
->	O
block_entity	pointer
)	O
_ctrl	pointer
->	O
block_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
ctrl	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
_ctrl	pointer
->	O
first_entity	pointer
)	O
_ctrl	pointer
->	O
first_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
NULL	O
)	O
;	O
else	O
_ctrl	pointer
->	O
last_entity	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
dxf_entities_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
char	O
name	pointer
[	O
80	int
]	O
;	O
unsigned	O
long	O
mspace	long
=	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
?	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
->	O
absolute_ref	long
:	O
0x1F	int
;	O
unsigned	O
long	O
pspace	long
=	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
?	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
->	O
absolute_ref	long
:	O
0UL	int
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
{	O
strncpy	function
(	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
79	int
)	O
;	O
name	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
entity_alias	function
(	O
name	pointer
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
&&	O
(	O
is_dwg_entity	function
(	O
name	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"DIMENSION"	pointer
)	O
)	O
)	O
{	O
char	O
*	O
dxfname	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
new_object	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
dat	pointer
,	O
dwg	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
;	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
if	O
(	O
ent	pointer
->	O
ownerhandle	pointer
)	O
{	O
if	O
(	O
ent	pointer
->	O
ownerhandle	pointer
->	O
absolute_ref	long
==	O
mspace	long
)	O
ent	pointer
->	O
entmode	char
=	O
2	int
;	O
else	O
if	O
(	O
pspace	long
&&	O
ent	pointer
->	O
ownerhandle	pointer
->	O
absolute_ref	long
==	O
pspace	long
)	O
ent	pointer
->	O
entmode	char
=	O
1	int
;	O
postprocess_BLOCK_HEADER	function
(	O
obj	pointer
,	O
ent	pointer
->	O
ownerhandle	pointer
)	O
;	O
}	O
else	O
ent	pointer
->	O
entmode	char
=	O
2	int
;	O
strncpy	function
(	O
name	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
79	int
)	O
;	O
name	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
entity_alias	function
(	O
name	pointer
)	O
;	O
}	O
}	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
else	O
LOG_WARN	O
(	O
"Unhandled 0 %s (%s)"	pointer
,	O
name	pointer
,	O
"entities"	pointer
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_CHECK_EOF	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
object_alias	function
(	O
char	O
*	O
name	pointer
)	O
{	O
const	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
len	long
==	O
strlen	function
(	O
"PDFDEFINITION"	pointer
)	O
&&	O
strEQc	O
(	O
&	O
name	pointer
[	O
3	int
]	O
,	O
"DEFINITION"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"UNDERLAYDEFINITION"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_DYNAMICBLOCKPURGEPREVENTER_VERSION"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"DYNAMICBLOCKPURGEPREVENTER"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"PROXY"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"PROXY_OBJECT"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"CSACDOCUMENTOPTIONS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"DOCUMENTOPTIONS"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_LEADEROBJECTCONTEXTDATA_CLASS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"ANNOTSCALEOBJECTCONTEXTDATA"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_MLEADEROBJECTCONTEXTDATA_CLASS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"ANNOTSCALEOBJECTCONTEXTDATA"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_MTEXTOBJECTCONTEXTDATA_CLASS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"ANNOTSCALEOBJECTCONTEXTDATA"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_MTEXTATTRIBUTEOBJECTCONTEXTDATA_CLASS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"ANNOTSCALEOBJECTCONTEXTDATA"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_BLKREFOBJECTCONTEXTDATA_CLASS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"ANNOTSCALEOBJECTCONTEXTDATA"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ACDB_ALDIMOBJECTCONTEXTDATA_CLASS"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"ANNOTSCALEOBJECTCONTEXTDATA"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"EXACXREFPANELOBJECT"	pointer
)	O
)	O
strcpy	function
(	O
name	pointer
,	O
"XREFPANELOBJECT"	pointer
)	O
;	O
else	O
if	O
(	O
memBEGINc	O
(	O
name	pointer
,	O
"ACAD_"	pointer
)	O
&&	O
is_dwg_object	function
(	O
&	O
name	pointer
[	O
5	int
]	O
)	O
)	O
memmove	function
(	O
name	pointer
,	O
&	O
name	pointer
[	O
5	int
]	O
,	O
len	long
-	O
4	int
)	O
;	O
else	O
if	O
(	O
memBEGINc	O
(	O
name	pointer
,	O
"ACDB"	pointer
)	O
&&	O
is_dwg_object	function
(	O
&	O
name	pointer
[	O
4	int
]	O
)	O
)	O
memmove	function
(	O
name	pointer
,	O
&	O
name	pointer
[	O
4	int
]	O
,	O
len	long
-	O
3	int
)	O
;	O
}	O
static	O
int	O
dxf_objects_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
char	O
name	pointer
[	O
80	int
]	O
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
while	O
(	O
pair	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
pair	pointer
!=	O
NULL	O
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
{	O
char	O
*	O
dxfname	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
strncpy	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
79	int
)	O
;	O
name	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
object_alias	function
(	O
name	pointer
)	O
;	O
if	O
(	O
is_dwg_object	function
(	O
name	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
new_object	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
dat	pointer
,	O
dwg	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
else	O
{	O
LOG_WARN	O
(	O
"Unhandled 0 %s (%s)"	pointer
,	O
name	pointer
,	O
"objects"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_CHECK_EOF	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dxf_unknownsection_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
char	O
name	pointer
[	O
80	int
]	O
;	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
pair	pointer
&&	O
pair	pointer
->	O
code	char
==	O
0	int
)	O
{	O
char	O
*	O
dxfname	pointer
=	O
strdup	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
strncpy	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
79	int
)	O
;	O
name	pointer
[	O
79	int
]	O
=	O
'\0'	O
;	O
object_alias	function
(	O
name	pointer
)	O
;	O
if	O
(	O
is_dwg_object	function
(	O
name	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
new_object	function
(	O
name	pointer
,	O
dxfname	pointer
,	O
dat	pointer
,	O
dwg	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
DXF_RETURN_ENDSEC	O
(	O
0	int
)	O
else	O
{	O
LOG_WARN	O
(	O
"Unhandled 0 %s (%s)"	pointer
,	O
name	pointer
,	O
"unknownsection"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
DXF_CHECK_EOF	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dxf_thumbnail_read	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dxf_Pair	struct
*	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
unsigned	O
written	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
case	O
90	int
:	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
=	O
pair	pointer
->	O
value	double
.	O
l	long
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
=	O
calloc	function
(	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
,	O
1	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
LOG_TRACE	O
(	O
"PREVIEW.size = %ld\n"	pointer
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
;	O
break	O
;	O
case	O
310	int
:	O
{	O
unsigned	O
len	long
=	O
strlen	function
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
unsigned	O
blen	int
=	O
len	long
/	O
2	int
;	O
const	O
char	O
*	O
pos	pointer
=	O
pair	pointer
->	O
value	double
.	O
s	pointer
;	O
unsigned	O
char	O
*	O
s	pointer
=	O
&	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
[	O
written	int
]	O
;	O
if	O
(	O
blen	int
+	O
written	int
>	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
LOG_ERROR	O
(	O
"PREVIEW.size overflow: %u + written %u > "	pointer
"size: %lu"	pointer
,	O
blen	int
,	O
written	int
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
unsigned	O
i	int
=	O
0	int
;	O
i	int
<	O
blen	int
;	O
i	int
++	O
)	O
{	O
sscanf	function
(	O
pos	pointer
,	O
"%2hhX"	pointer
,	O
&	O
s	pointer
[	O
i	int
]	O
)	O
;	O
pos	pointer
+=	O
2	int
;	O
}	O
written	int
+=	O
blen	int
;	O
LOG_TRACE	O
(	O
"PREVIEW.chain += %u (%u/%lu)\n"	pointer
,	O
blen	int
,	O
written	int
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Unknown DXF code %d for %s"	pointer
,	O
pair	pointer
->	O
code	char
,	O
"THUMBNAILIMAGE"	pointer
)	O
;	O
break	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
break	O
;	O
}	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
resolve_postponed_header_refs	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Header_Variables	struct
*	O
vars	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
uint32_t	int
i	int
;	O
LOG_TRACE	O
(	O
"resolve %d postponed header ref names:\n"	pointer
,	O
header_hdls	pointer
->	O
nitems	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
header_hdls	pointer
->	O
nitems	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
field	pointer
=	O
header_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
field	pointer
;	O
Dxf_Pair	struct
p	pointer
=	O
{	O
0	int
,	O
VT_STRING	int
}	O
;	O
BITCODE_H	pointer
hdl	array
=	O
NULL	O
;	O
p	pointer
.	O
value	double
.	O
s	pointer
=	O
header_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
name	pointer
;	O
if	O
(	O
!	O
p	pointer
.	O
value	double
.	O
s	pointer
||	O
!	O
*	O
p	pointer
.	O
value	double
.	O
s	pointer
)	O
{	O
LOG_WARN	O
(	O
"HEADER.%s empty dxf:%d"	pointer
,	O
field	pointer
,	O
(	O
int	O
)	O
p	pointer
.	O
code	char
)	O
;	O
continue	O
;	O
}	O
p	pointer
.	O
code	char
=	O
header_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
code	char
;	O
if	O
(	O
strEQc	O
(	O
field	pointer
,	O
"DIMSTYLE"	pointer
)	O
)	O
p	pointer
.	O
code	char
=	O
3	int
;	O
else	O
if	O
(	O
strstr	function
(	O
field	pointer
,	O
"UCS"	pointer
)	O
)	O
p	pointer
.	O
code	char
=	O
345	int
;	O
hdl	array
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
hdl	array
)	O
{	O
if	O
(	O
hdl	array
->	O
handleref	struct
.	O
code	char
!=	O
5	int
)	O
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
field	pointer
,	O
&	O
hdl	array
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s %s => "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
field	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
ARGS_REF	O
(	O
hdl	array
)	O
,	O
(	O
int	O
)	O
p	pointer
.	O
code	char
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
field	pointer
,	O
"CMLSTYLE"	pointer
)	O
)	O
{	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"MLINESTYLE"	pointer
)	O
;	O
if	O
(	O
hdl	array
)	O
{	O
if	O
(	O
hdl	array
->	O
handleref	struct
.	O
code	char
!=	O
5	int
)	O
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
dwg_dynapi_header_set_value	function
(	O
dwg	pointer
,	O
field	pointer
,	O
&	O
hdl	array
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.%s %s => "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
field	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
ARGS_REF	O
(	O
hdl	array
)	O
,	O
(	O
int	O
)	O
p	pointer
.	O
code	char
)	O
}	O
else	O
LOG_WARN	O
(	O
"Unknown HEADER.%s %s dxf:%d"	pointer
,	O
field	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
(	O
int	O
)	O
p	pointer
.	O
code	char
)	O
}	O
else	O
LOG_WARN	O
(	O
"Unknown HEADER.%s %s dxf:%d"	pointer
,	O
field	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
(	O
int	O
)	O
p	pointer
.	O
code	char
)	O
}	O
}	O
static	O
void	O
resolve_postponed_object_refs	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
uint32_t	int
i	int
;	O
LOG_TRACE	O
(	O
"resolve %d postponed object ref names:\n"	pointer
,	O
obj_hdls	pointer
->	O
nitems	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obj_hdls	pointer
->	O
nitems	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
field	pointer
=	O
obj_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
field	pointer
;	O
Dxf_Pair	struct
p	pointer
=	O
{	O
0	int
,	O
VT_STRING	int
}	O
;	O
BITCODE_H	pointer
hdl	array
=	O
NULL	O
;	O
int	O
objid	int
=	O
obj_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
code	char
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
objid	int
]	O
;	O
int	O
is_entity	int
=	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
;	O
p	pointer
.	O
value	double
.	O
s	pointer
=	O
obj_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
name	pointer
;	O
if	O
(	O
!	O
p	pointer
.	O
value	double
.	O
s	pointer
||	O
!	O
*	O
p	pointer
.	O
value	double
.	O
s	pointer
)	O
{	O
LOG_WARN	O
(	O
"%s.%s empty"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
field	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strEQc	O
(	O
field	pointer
,	O
"block_header"	pointer
)	O
)	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"BLOCK"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
field	pointer
,	O
"style"	pointer
)	O
)	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"STYLE"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
field	pointer
,	O
"dimstyle"	pointer
)	O
)	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"DIMSTYLE"	pointer
)	O
;	O
else	O
if	O
(	O
strEQc	O
(	O
field	pointer
,	O
"block_header"	pointer
)	O
)	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"BLOCK"	pointer
)	O
;	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"layer"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
8	int
;	O
hdl	array
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
&	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"ltype"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
6	int
;	O
hdl	array
=	O
find_tablehandle	function
(	O
dwg	pointer
,	O
&	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"material"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
347	int
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"MATERIAL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"shadow"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
361	int
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"SHADOW"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"plotstyle"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
390	int
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"PLOTSTYLENAME"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"full_visualstyle"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
348	int
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"VISUALSTYLE"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"face_visualstyle"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
348	int
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"VISUALSTYLE"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_entity	int
&&	O
strEQc	O
(	O
field	pointer
,	O
"edge_visualstyle"	pointer
)	O
)	O
{	O
p	pointer
.	O
code	char
=	O
348	int
;	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
"VISUALSTYLE"	pointer
)	O
;	O
}	O
else	O
LOG_WARN	O
(	O
"missing code for %s"	pointer
,	O
field	pointer
)	O
if	O
(	O
hdl	array
)	O
{	O
Dwg_Object_APPID	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID	pointer
;	O
if	O
(	O
hdl	array
->	O
handleref	struct
.	O
code	char
!=	O
5	int
)	O
hdl	array
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
if	O
(	O
p	pointer
.	O
code	char
>	O
0	int
)	O
dwg_dynapi_common_set_value	function
(	O
_obj	pointer
,	O
field	pointer
,	O
&	O
hdl	array
,	O
0	int
)	O
;	O
else	O
dwg_dynapi_entity_set_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
field	pointer
,	O
&	O
hdl	array
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"%s.%s %s => "	pointer
FORMAT_REF	pointer
" [H %d]\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
field	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
,	O
ARGS_REF	O
(	O
hdl	array
)	O
,	O
(	O
int	O
)	O
p	pointer
.	O
code	char
)	O
;	O
}	O
else	O
LOG_WARN	O
(	O
"Unknown %s.%s %s"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
field	pointer
,	O
p	pointer
.	O
value	double
.	O
s	pointer
)	O
}	O
}	O
static	O
void	O
resolve_header_dicts	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Header_Variables	struct
*	O
vars	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
if	O
(	O
!	O
vars	pointer
->	O
DICTIONARY_NAMED_OBJECT	pointer
)	O
vars	pointer
->	O
DICTIONARY_NAMED_OBJECT	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
0xC	int
,	O
NULL	O
)	O
;	O
CHECK_DICTIONARY_HDR	O
(	O
ACAD_GROUP	O
)	O
CHECK_DICTIONARY_HDR	O
(	O
ACAD_MLINESTYLE	O
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
)	O
{	O
CHECK_DICTIONARY_HDR	O
(	O
LAYOUT	pointer
)	O
CHECK_DICTIONARY_HDR	O
(	O
PLOTSETTINGS	pointer
)	O
CHECK_DICTIONARY_HDR	O
(	O
PLOTSTYLENAME	O
)	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
{	O
CHECK_DICTIONARY_HDR	O
(	O
MATERIAL	pointer
)	O
CHECK_DICTIONARY_HDR	O
(	O
COLOR	O
)	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
{	O
CHECK_DICTIONARY_HDR	O
(	O
VISUALSTYLE	pointer
)	O
}	O
}	O
static	O
void	O
resolve_postponed_eed_refs	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
LOG_TRACE	O
(	O
"resolve %d postponed eed APPID refs\n"	pointer
,	O
eed_hdls	pointer
->	O
nitems	int
)	O
;	O
for	O
(	O
uint32_t	int
i	int
=	O
0	int
;	O
i	int
<	O
eed_hdls	pointer
->	O
nitems	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
name	pointer
=	O
eed_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
name	pointer
;	O
BITCODE_H	pointer
ref	pointer
=	O
dwg_find_tablehandle	function
(	O
dwg	pointer
,	O
eed_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
name	pointer
,	O
"APPID"	pointer
)	O
;	O
if	O
(	O
ref	pointer
)	O
{	O
BITCODE_RL	int
objid	int
;	O
Dwg_Eed	struct
*	O
eed	pointer
;	O
int	O
j	long
=	O
(	O
int	O
)	O
eed_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
code	char
;	O
sscanf	function
(	O
eed_hdls	pointer
->	O
items	array
[	O
i	int
]	O
.	O
field	pointer
,	O
"%d"	pointer
,	O
&	O
objid	int
)	O
;	O
eed	pointer
=	O
dwg	pointer
->	O
object	pointer
[	O
objid	int
]	O
.	O
tio	union
.	O
object	pointer
->	O
eed	pointer
;	O
memcpy	function
(	O
&	O
eed	pointer
[	O
j	long
]	O
.	O
handle	pointer
,	O
&	O
ref	pointer
->	O
handleref	struct
,	O
sizeof	O
(	O
Dwg_Handle	struct
)	O
)	O
;	O
eed	pointer
[	O
j	long
]	O
.	O
handle	pointer
.	O
code	char
=	O
5	int
;	O
LOG_TRACE	O
(	O
"postponed eed[%d].handle for APPID.%s => "	pointer
FORMAT_H	pointer
" [H]\n"	pointer
,	O
j	long
,	O
name	pointer
,	O
ARGS_H	O
(	O
eed	pointer
[	O
j	long
]	O
.	O
handle	pointer
)	O
)	O
;	O
}	O
else	O
LOG_WARN	O
(	O
"Unknown eed[].handle for APPID.%s"	pointer
,	O
name	pointer
)	O
}	O
}	O
int	O
dwg_read_dxf	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dxf_Pair	struct
*	O
pair	pointer
;	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
num_dxf_objs	long
=	O
0	int
;	O
size_dxf_objs	long
=	O
1000	int
;	O
dxf_objs	pointer
=	O
malloc	function
(	O
1000	int
*	O
sizeof	O
(	O
Dxf_Objs	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
object_map	pointer
)	O
dwg	pointer
->	O
object_map	pointer
=	O
hash_new	function
(	O
dat	pointer
->	O
size	char
/	O
1000	int
)	O
;	O
dwg	pointer
->	O
dirty_refs	int
=	O
1	int
;	O
header_hdls	pointer
=	O
new_array_hdls	function
(	O
16	int
)	O
;	O
eed_hdls	pointer
=	O
new_array_hdls	function
(	O
16	int
)	O
;	O
obj_hdls	pointer
=	O
new_array_hdls	function
(	O
16	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
num_objects	int
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
;	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_obj	pointer
;	O
char	O
*	O
dxfname	pointer
=	O
strdup	function
(	O
(	O
char	O
*	O
)	O
"BLOCK_HEADER"	pointer
)	O
;	O
NEW_OBJECT	O
(	O
dwg	pointer
,	O
obj	pointer
)	O
;	O
ADD_OBJECT	O
(	O
BLOCK_HEADER	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
_obj	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bit_utf8_to_TU	function
(	O
(	O
char	O
*	O
)	O
"*Model_Space"	pointer
)	O
;	O
else	O
_obj	pointer
->	O
name	pointer
=	O
strdup	function
(	O
(	O
char	O
*	O
)	O
"*Model_Space"	pointer
)	O
;	O
_obj	pointer
->	O
xrefref	char
=	O
1	int
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdic_missing_flag	char
=	O
1	int
;	O
dwg_add_handle	function
(	O
&	O
obj	pointer
->	O
handle	pointer
,	O
0	int
,	O
0x1F	int
,	O
obj	pointer
)	O
;	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
4	int
,	O
1	int
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
dat	pointer
->	O
byte	char
<	O
dat	pointer
->	O
size	char
)	O
{	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
dxf_expect_code	function
(	O
dat	pointer
,	O
pair	pointer
,	O
0	int
)	O
;	O
DXF_BREAK_EOF	O
;	O
if	O
(	O
pair	pointer
->	O
type	short
==	O
VT_STRING	int
&&	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"SECTION"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
pair	pointer
=	O
dxf_read_pair	function
(	O
dat	pointer
)	O
;	O
pair	pointer
=	O
dxf_expect_code	function
(	O
dat	pointer
,	O
pair	pointer
,	O
2	int
)	O
;	O
DXF_BREAK_EOF	O
;	O
if	O
(	O
!	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Expected SECTION string code 2, got code %d"	pointer
,	O
pair	pointer
->	O
code	char
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"HEADER"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_header_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
dxf_fixup_header	function
(	O
dwg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"CLASSES"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_classes_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"TABLES"	pointer
)	O
)	O
{	O
BITCODE_H	pointer
hdl	array
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_tables_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
resolve_postponed_header_refs	function
(	O
dwg	pointer
)	O
;	O
resolve_postponed_eed_refs	function
(	O
dwg	pointer
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_BYLAYER	pointer
&&	O
(	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
(	O
char	O
*	O
)	O
"ByLayer"	pointer
,	O
"LTYPE"	pointer
)	O
)	O
)	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_BYLAYER	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
handleref	struct
.	O
value	double
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_BYBLOCK	pointer
&&	O
(	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
(	O
char	O
*	O
)	O
"ByBlock"	pointer
,	O
"LTYPE"	pointer
)	O
)	O
)	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_BYBLOCK	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
handleref	struct
.	O
value	double
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_CONTINUOUS	pointer
&&	O
(	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
(	O
char	O
*	O
)	O
"Continuous"	pointer
,	O
"LTYPE"	pointer
)	O
)	O
)	O
dwg	pointer
->	O
header_vars	struct
.	O
LTYPE_CONTINUOUS	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
handleref	struct
.	O
value	double
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"BLOCKS"	pointer
)	O
)	O
{	O
BITCODE_H	pointer
hdl	array
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_blocks_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
&&	O
(	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
(	O
char	O
*	O
)	O
"*Paper_Space"	pointer
,	O
"BLOCK"	pointer
)	O
)	O
)	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
handleref	struct
.	O
value	double
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
&&	O
(	O
hdl	array
=	O
dwg_find_tablehandle_silent	function
(	O
dwg	pointer
,	O
(	O
char	O
*	O
)	O
"*Model_Space"	pointer
,	O
"BLOCK"	pointer
)	O
)	O
)	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
hdl	array
->	O
handleref	struct
.	O
value	double
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"ENTITIES"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_entities_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"OBJECTS"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_objects_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
resolve_header_dicts	function
(	O
dwg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
pair	pointer
->	O
value	double
.	O
s	pointer
,	O
"THUMBNAILIMAGE"	pointer
)	O
)	O
{	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_thumbnail_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
else	O
{	O
LOG_WARN	O
(	O
"SECTION %s ignored for now"	pointer
,	O
pair	pointer
->	O
value	double
.	O
s	pointer
)	O
;	O
dxf_free_pair	function
(	O
pair	pointer
)	O
;	O
dxf_unknownsection_read	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
}	O
}	O
resolve_postponed_header_refs	function
(	O
dwg	pointer
)	O
;	O
resolve_postponed_object_refs	function
(	O
dwg	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"Resolving pointers from ObjectRef vector:\n"	pointer
)	O
;	O
dwg_resolve_objectrefs_silent	function
(	O
dwg	pointer
)	O
;	O
dwg	pointer
->	O
dirty_refs	int
=	O
0	int
;	O
free_array_hdls	function
(	O
header_hdls	pointer
)	O
;	O
free_array_hdls	function
(	O
eed_hdls	pointer
)	O
;	O
free_array_hdls	function
(	O
obj_hdls	pointer
)	O
;	O
LOG_TRACE	O
(	O
"import from DXF\n"	pointer
)	O
;	O
return	O
dwg	pointer
->	O
num_objects	int
?	O
1	int
:	O
0	int
;	O
}	O
int	O
dwg_read_dxfb	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
dwg	pointer
->	O
opts	int
|=	O
DWG_OPTS_DXFB	int
;	O
dat	pointer
->	O
opts	int
|=	O
DWG_OPTS_DXFB	int
;	O
return	O
dwg_read_dxf	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
