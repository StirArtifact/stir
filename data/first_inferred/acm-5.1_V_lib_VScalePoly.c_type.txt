void	O
ComputeRotationMatrix	function
(	O
double	O
r	pointer
,	O
VPoint	struct
*	O
e	pointer
,	O
VMatrix	struct
*	O
m	array
)	O
;	O
VPolygon	struct
*	O
ScalePolygon	function
(	O
VPolygon	struct
*	O
in	pointer
,	O
VPoint	struct
*	O
offset	pointer
,	O
VPoint	struct
*	O
scale	int
,	O
VPoint	struct
*	O
e	pointer
,	O
double	O
r	pointer
)	O
{	O
int	O
numVtces	short
=	O
in	pointer
->	O
numVtces	short
,	O
i	int
;	O
VPoint	struct
*	O
vert	pointer
;	O
VPolygon	struct
*	O
p	pointer
;	O
VPoint	struct
a	pointer
,	O
b	pointer
,	O
tmp	struct
,	O
offset1	struct
;	O
VMatrix	struct
m	array
;	O
p	pointer
=	O
(	O
VPolygon	struct
*	O
)	O
Vmalloc	function
(	O
sizeof	O
(	O
VPolygon	struct
)	O
)	O
;	O
*	O
p	pointer
=	O
*	O
in	pointer
;	O
p	pointer
->	O
numVtces	short
=	O
numVtces	short
;	O
vert	pointer
=	O
p	pointer
->	O
vertex	pointer
=	O
(	O
VPoint	struct
*	O
)	O
Vmalloc	function
(	O
sizeof	O
(	O
VPoint	struct
)	O
*	O
numVtces	short
)	O
;	O
ComputeRotationMatrix	function
(	O
r	pointer
,	O
e	pointer
,	O
&	O
m	array
)	O
;	O
VTransform_	function
(	O
offset	pointer
,	O
&	O
m	array
,	O
&	O
offset1	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numVtces	short
;	O
++	O
i	int
)	O
{	O
p	pointer
->	O
vertex	pointer
[	O
i	int
]	O
=	O
in	pointer
->	O
vertex	pointer
[	O
i	int
]	O
;	O
VTransform_	function
(	O
&	O
p	pointer
->	O
vertex	pointer
[	O
i	int
]	O
,	O
&	O
m	array
,	O
&	O
tmp	struct
)	O
;	O
p	pointer
->	O
vertex	pointer
[	O
i	int
]	O
.	O
x	double
=	O
tmp	struct
.	O
x	double
*	O
scale	int
->	O
x	double
;	O
p	pointer
->	O
vertex	pointer
[	O
i	int
]	O
.	O
y	double
=	O
tmp	struct
.	O
y	double
*	O
scale	int
->	O
y	double
;	O
p	pointer
->	O
vertex	pointer
[	O
i	int
]	O
.	O
z	double
=	O
tmp	struct
.	O
z	double
*	O
scale	int
->	O
z	double
;	O
}	O
if	O
(	O
(	O
p	pointer
->	O
flags	short
&	O
PolyNormalValid	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
p	pointer
->	O
flags	short
&	O
PolyClipBackface	int
)	O
!=	O
0	int
||	O
p	pointer
->	O
backColor	pointer
!=	O
(	O
VColor	struct
*	O
)	O
NULL	O
)	O
{	O
a	pointer
.	O
x	double
=	O
vert	pointer
[	O
0	int
]	O
.	O
x	double
-	O
vert	pointer
[	O
1	int
]	O
.	O
x	double
;	O
a	pointer
.	O
y	double
=	O
vert	pointer
[	O
0	int
]	O
.	O
y	double
-	O
vert	pointer
[	O
1	int
]	O
.	O
y	double
;	O
a	pointer
.	O
z	double
=	O
vert	pointer
[	O
0	int
]	O
.	O
z	double
-	O
vert	pointer
[	O
1	int
]	O
.	O
z	double
;	O
b	pointer
.	O
x	double
=	O
vert	pointer
[	O
2	int
]	O
.	O
x	double
-	O
vert	pointer
[	O
1	int
]	O
.	O
x	double
;	O
b	pointer
.	O
y	double
=	O
vert	pointer
[	O
2	int
]	O
.	O
y	double
-	O
vert	pointer
[	O
1	int
]	O
.	O
y	double
;	O
b	pointer
.	O
z	double
=	O
vert	pointer
[	O
2	int
]	O
.	O
z	double
-	O
vert	pointer
[	O
1	int
]	O
.	O
z	double
;	O
VCrossProd	function
(	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
&	O
p	pointer
->	O
normal	struct
)	O
;	O
p	pointer
->	O
flags	short
|=	O
PolyNormalValid	int
;	O
}	O
}	O
return	O
p	pointer
;	O
}	O
void	O
ComputeRotationMatrix	function
(	O
double	O
r	pointer
,	O
VPoint	struct
*	O
e	pointer
,	O
VMatrix	struct
*	O
m	array
)	O
{	O
double	O
one64th	double
=	O
1.0	int
/	O
64.0	int
,	O
ma	double
;	O
VPoint	struct
Ax	struct
,	O
Ay	struct
,	O
Wy	struct
=	O
{	O
0	int
,	O
1	int
,	O
0	int
}	O
,	O
Wz	struct
=	O
{	O
0	int
,	O
0	int
,	O
1	int
}	O
;	O
VMatrix	struct
tm	struct
,	O
tm1	struct
;	O
VIdentMatrix	function
(	O
&	O
tm	struct
)	O
;	O
if	O
(	O
r	pointer
!=	O
0.0	int
)	O
{	O
VRotate	function
(	O
&	O
tm	struct
,	O
ZRotation	int
,	O
r	pointer
*	O
M_PI	int
/	O
180.0	int
)	O
;	O
}	O
if	O
(	O
fabs	function
(	O
e	pointer
->	O
x	double
)	O
<	O
one64th	double
&&	O
fabs	function
(	O
e	pointer
->	O
y	double
)	O
<	O
one64th	double
)	O
{	O
VCrossProd	function
(	O
&	O
Wy	struct
,	O
e	pointer
,	O
&	O
Ax	struct
)	O
;	O
}	O
else	O
{	O
VCrossProd	function
(	O
&	O
Wz	struct
,	O
e	pointer
,	O
&	O
Ax	struct
)	O
;	O
}	O
ma	double
=	O
sqrt	function
(	O
Ax	struct
.	O
x	double
*	O
Ax	struct
.	O
x	double
+	O
Ax	struct
.	O
y	double
*	O
Ax	struct
.	O
y	double
+	O
Ax	struct
.	O
z	double
*	O
Ax	struct
.	O
z	double
)	O
;	O
Ax	struct
.	O
x	double
/=	O
ma	double
;	O
Ax	struct
.	O
y	double
/=	O
ma	double
;	O
Ax	struct
.	O
z	double
/=	O
ma	double
;	O
VCrossProd	function
(	O
e	pointer
,	O
&	O
Ax	struct
,	O
&	O
Ay	struct
)	O
;	O
ma	double
=	O
sqrt	function
(	O
Ay	struct
.	O
x	double
*	O
Ay	struct
.	O
x	double
+	O
Ay	struct
.	O
y	double
*	O
Ay	struct
.	O
y	double
+	O
Ay	struct
.	O
z	double
*	O
Ay	struct
.	O
z	double
)	O
;	O
Ay	struct
.	O
x	double
/=	O
ma	double
;	O
Ay	struct
.	O
y	double
/=	O
ma	double
;	O
Ay	struct
.	O
z	double
/=	O
ma	double
;	O
VIdentMatrix	function
(	O
m	array
)	O
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
Ax	struct
.	O
x	double
;	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
Ax	struct
.	O
y	double
;	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
0	int
]	O
=	O
Ax	struct
.	O
z	double
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
Ay	struct
.	O
x	double
;	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
Ay	struct
.	O
y	double
;	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
1	int
]	O
=	O
Ay	struct
.	O
z	double
;	O
m	array
->	O
m	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
e	pointer
->	O
x	double
;	O
m	array
->	O
m	array
[	O
1	int
]	O
[	O
2	int
]	O
=	O
e	pointer
->	O
y	double
;	O
m	array
->	O
m	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
e	pointer
->	O
z	double
;	O
VMatrixMultByRank	function
(	O
&	O
tm	struct
,	O
m	array
,	O
&	O
tm1	struct
,	O
3	int
)	O
;	O
*	O
m	array
=	O
tm1	struct
;	O
}	O
