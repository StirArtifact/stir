typedef	O
char	O
*	O
CompletionFunction	function
(	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
int	O
ignore_filenames	int
=	O
0	int
;	O
static	O
int	O
look_for_executables	int
=	O
0	int
;	O
static	O
char	O
*	O
filename_completion_function	function
(	O
char	O
*	O
text	pointer
,	O
int	O
state	pointer
)	O
{	O
static	O
DIR	struct
*	O
directory	enum
;	O
static	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
dirname	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
users_dirname	pointer
=	O
NULL	O
;	O
static	O
size_t	long
filename_len	long
;	O
int	O
isdir	int
=	O
1	int
,	O
isexec	int
=	O
0	int
;	O
struct	O
dirent	struct
*	O
entry	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
state	pointer
)	O
{	O
const	O
char	O
*	O
temp	pointer
;	O
g_free	function
(	O
dirname	pointer
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
g_free	function
(	O
users_dirname	pointer
)	O
;	O
if	O
(	O
(	O
*	O
text	pointer
)	O
&&	O
(	O
temp	pointer
=	O
strrchr	function
(	O
text	pointer
,	O
PATH_SEP	char
)	O
)	O
)	O
{	O
filename	pointer
=	O
g_strdup	function
(	O
++	O
temp	pointer
)	O
;	O
dirname	pointer
=	O
g_strndup	function
(	O
text	pointer
,	O
temp	pointer
-	O
text	pointer
)	O
;	O
}	O
else	O
{	O
dirname	pointer
=	O
g_strdup	function
(	O
"."	pointer
)	O
;	O
filename	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
}	O
users_dirname	pointer
=	O
dirname	pointer
;	O
{	O
dirname	pointer
=	O
tilde_expand	function
(	O
dirname	pointer
)	O
;	O
canonicalize_pathname	function
(	O
dirname	pointer
)	O
;	O
}	O
directory	enum
=	O
mc_opendir	function
(	O
dirname	pointer
)	O
;	O
filename_len	long
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
}	O
while	O
(	O
directory	enum
&&	O
(	O
entry	pointer
=	O
mc_readdir	function
(	O
directory	enum
)	O
)	O
)	O
{	O
if	O
(	O
!	O
filename_len	long
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
entry	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
||	O
!	O
strcmp	function
(	O
entry	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
entry	pointer
->	O
d_name	array
[	O
0	int
]	O
!=	O
filename	pointer
[	O
0	int
]	O
)	O
||	O
(	O
(	O
NLENGTH	O
(	O
entry	pointer
)	O
)	O
<	O
filename_len	long
)	O
||	O
strncmp	function
(	O
filename	pointer
,	O
entry	pointer
->	O
d_name	array
,	O
filename_len	long
)	O
)	O
continue	O
;	O
}	O
isdir	int
=	O
1	int
;	O
isexec	int
=	O
0	int
;	O
{	O
char	O
*	O
tmp	pointer
=	O
g_malloc	function
(	O
3	int
+	O
strlen	function
(	O
dirname	pointer
)	O
+	O
NLENGTH	O
(	O
entry	pointer
)	O
)	O
;	O
struct	O
stat	struct
tempstat	struct
;	O
strcpy	function
(	O
tmp	pointer
,	O
dirname	pointer
)	O
;	O
strcat	function
(	O
tmp	pointer
,	O
PATH_SEP_STR	pointer
)	O
;	O
strcat	function
(	O
tmp	pointer
,	O
entry	pointer
->	O
d_name	array
)	O
;	O
canonicalize_pathname	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
!	O
mc_stat	function
(	O
tmp	pointer
,	O
&	O
tempstat	struct
)	O
)	O
{	O
uid_t	int
my_uid	int
=	O
getuid	function
(	O
)	O
;	O
gid_t	int
my_gid	int
=	O
getgid	function
(	O
)	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
tempstat	struct
.	O
st_mode	int
)	O
)	O
{	O
isdir	int
=	O
0	int
;	O
if	O
(	O
(	O
!	O
my_uid	int
&&	O
(	O
tempstat	struct
.	O
st_mode	int
&	O
0111	int
)	O
)	O
||	O
(	O
my_uid	int
==	O
tempstat	struct
.	O
st_uid	int
&&	O
(	O
tempstat	struct
.	O
st_mode	int
&	O
0100	int
)	O
)	O
||	O
(	O
my_gid	int
==	O
tempstat	struct
.	O
st_gid	int
&&	O
(	O
tempstat	struct
.	O
st_mode	int
&	O
0010	int
)	O
)	O
||	O
(	O
tempstat	struct
.	O
st_mode	int
&	O
0001	int
)	O
)	O
isexec	int
=	O
1	int
;	O
}	O
}	O
g_free	function
(	O
tmp	pointer
)	O
;	O
}	O
switch	O
(	O
look_for_executables	int
)	O
{	O
case	O
2	int
:	O
if	O
(	O
!	O
isexec	int
)	O
continue	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
!	O
isexec	int
&&	O
!	O
isdir	int
)	O
continue	O
;	O
break	O
;	O
}	O
if	O
(	O
ignore_filenames	int
&&	O
!	O
isdir	int
)	O
continue	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
if	O
(	O
directory	enum
)	O
{	O
mc_closedir	function
(	O
directory	enum
)	O
;	O
directory	enum
=	O
NULL	O
;	O
}	O
g_free	function
(	O
dirname	pointer
)	O
;	O
dirname	pointer
=	O
NULL	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
NULL	O
;	O
g_free	function
(	O
users_dirname	pointer
)	O
;	O
users_dirname	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
temp	pointer
;	O
if	O
(	O
users_dirname	pointer
&&	O
(	O
users_dirname	pointer
[	O
0	int
]	O
!=	O
'.'	O
||	O
users_dirname	pointer
[	O
1	int
]	O
)	O
)	O
{	O
int	O
dirlen	int
=	O
strlen	function
(	O
users_dirname	pointer
)	O
;	O
temp	pointer
=	O
g_malloc	function
(	O
3	int
+	O
dirlen	int
+	O
NLENGTH	O
(	O
entry	pointer
)	O
)	O
;	O
strcpy	function
(	O
temp	pointer
,	O
users_dirname	pointer
)	O
;	O
if	O
(	O
users_dirname	pointer
[	O
dirlen	int
-	O
1	int
]	O
!=	O
PATH_SEP	char
)	O
{	O
temp	pointer
[	O
dirlen	int
]	O
=	O
PATH_SEP	char
;	O
temp	pointer
[	O
dirlen	int
+	O
1	int
]	O
=	O
0	int
;	O
}	O
strcat	function
(	O
temp	pointer
,	O
entry	pointer
->	O
d_name	array
)	O
;	O
}	O
else	O
{	O
temp	pointer
=	O
g_malloc	function
(	O
2	int
+	O
NLENGTH	O
(	O
entry	pointer
)	O
)	O
;	O
strcpy	function
(	O
temp	pointer
,	O
entry	pointer
->	O
d_name	array
)	O
;	O
}	O
if	O
(	O
isdir	int
)	O
strcat	function
(	O
temp	pointer
,	O
PATH_SEP_STR	pointer
)	O
;	O
return	O
temp	pointer
;	O
}	O
}	O
static	O
char	O
*	O
username_completion_function	function
(	O
char	O
*	O
text	pointer
,	O
int	O
state	pointer
)	O
{	O
static	O
struct	O
passwd	struct
*	O
entry	pointer
;	O
static	O
int	O
userlen	int
;	O
if	O
(	O
!	O
state	pointer
)	O
{	O
setpwent	function
(	O
)	O
;	O
userlen	int
=	O
strlen	function
(	O
text	pointer
+	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
entry	pointer
=	O
getpwent	function
(	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
userlen	int
)	O
break	O
;	O
else	O
if	O
(	O
text	pointer
[	O
1	int
]	O
==	O
entry	pointer
->	O
pw_name	pointer
[	O
0	int
]	O
&&	O
!	O
strncmp	function
(	O
text	pointer
+	O
1	int
,	O
entry	pointer
->	O
pw_name	pointer
,	O
userlen	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
endpwent	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
temp	pointer
=	O
g_malloc	function
(	O
3	int
+	O
strlen	function
(	O
entry	pointer
->	O
pw_name	pointer
)	O
)	O
;	O
*	O
temp	pointer
=	O
'~'	O
;	O
strcpy	function
(	O
temp	pointer
+	O
1	int
,	O
entry	pointer
->	O
pw_name	pointer
)	O
;	O
strcat	function
(	O
temp	pointer
,	O
PATH_SEP_STR	pointer
)	O
;	O
return	O
temp	pointer
;	O
}	O
}	O
static	O
char	O
*	O
variable_completion_function	function
(	O
char	O
*	O
text	pointer
,	O
int	O
state	pointer
)	O
{	O
static	O
char	O
*	O
*	O
env_p	pointer
;	O
static	O
int	O
varlen	int
,	O
isbrace	int
;	O
const	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
state	pointer
)	O
{	O
isbrace	int
=	O
(	O
text	pointer
[	O
1	int
]	O
==	O
'{'	O
)	O
;	O
varlen	int
=	O
strlen	function
(	O
text	pointer
+	O
1	int
+	O
isbrace	int
)	O
;	O
env_p	pointer
=	O
environ	pointer
;	O
}	O
while	O
(	O
*	O
env_p	pointer
)	O
{	O
p	pointer
=	O
strchr	function
(	O
*	O
env_p	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
&&	O
p	pointer
-	O
*	O
env_p	pointer
>=	O
varlen	int
&&	O
!	O
strncmp	function
(	O
text	pointer
+	O
1	int
+	O
isbrace	int
,	O
*	O
env_p	pointer
,	O
varlen	int
)	O
)	O
break	O
;	O
env_p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
*	O
env_p	pointer
)	O
return	O
NULL	O
;	O
else	O
{	O
char	O
*	O
temp	pointer
=	O
g_malloc	function
(	O
2	int
+	O
2	int
*	O
isbrace	int
+	O
p	pointer
-	O
*	O
env_p	pointer
)	O
;	O
*	O
temp	pointer
=	O
'$'	O
;	O
if	O
(	O
isbrace	int
)	O
temp	pointer
[	O
1	int
]	O
=	O
'{'	O
;	O
memcpy	function
(	O
temp	pointer
+	O
1	int
+	O
isbrace	int
,	O
*	O
env_p	pointer
,	O
p	pointer
-	O
*	O
env_p	pointer
)	O
;	O
if	O
(	O
isbrace	int
)	O
strcpy	function
(	O
temp	pointer
+	O
2	int
+	O
(	O
p	pointer
-	O
*	O
env_p	pointer
)	O
,	O
"}"	pointer
)	O
;	O
else	O
temp	pointer
[	O
1	int
+	O
p	pointer
-	O
*	O
env_p	pointer
]	O
=	O
0	int
;	O
env_p	pointer
++	O
;	O
return	O
temp	pointer
;	O
}	O
}	O
static	O
char	O
*	O
*	O
hosts	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
*	O
hosts_p	pointer
=	O
NULL	O
;	O
static	O
int	O
hosts_alloclen	int
=	O
0	int
;	O
static	O
void	O
fetch_hosts	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
char	O
buffer	pointer
[	O
256	int
]	O
,	O
*	O
name	pointer
;	O
register	O
int	O
i	array
,	O
start	pointer
;	O
if	O
(	O
!	O
file	pointer
)	O
return	O
;	O
while	O
(	O
fgets	function
(	O
buffer	pointer
,	O
255	int
,	O
file	pointer
)	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
buffer	pointer
[	O
i	array
]	O
&&	O
cr_whitespace	O
(	O
buffer	pointer
[	O
i	array
]	O
)	O
;	O
i	array
++	O
)	O
;	O
if	O
(	O
buffer	pointer
[	O
i	array
]	O
==	O
'#'	O
)	O
continue	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
buffer	pointer
+	O
i	array
,	O
"$include "	pointer
,	O
9	int
)	O
)	O
{	O
char	O
*	O
includefile	pointer
=	O
buffer	pointer
+	O
i	array
+	O
9	int
;	O
char	O
*	O
t	long
;	O
while	O
(	O
*	O
includefile	pointer
&&	O
whitespace	O
(	O
*	O
includefile	pointer
)	O
)	O
includefile	pointer
++	O
;	O
t	long
=	O
includefile	pointer
;	O
while	O
(	O
*	O
t	long
&&	O
!	O
cr_whitespace	O
(	O
*	O
t	long
)	O
)	O
t	long
++	O
;	O
*	O
t	long
=	O
'\0'	O
;	O
fetch_hosts	function
(	O
includefile	pointer
)	O
;	O
continue	O
;	O
}	O
while	O
(	O
buffer	pointer
[	O
i	array
]	O
&&	O
!	O
cr_whitespace	O
(	O
buffer	pointer
[	O
i	array
]	O
)	O
)	O
i	array
++	O
;	O
while	O
(	O
buffer	pointer
[	O
i	array
]	O
&&	O
buffer	pointer
[	O
i	array
]	O
!=	O
'#'	O
)	O
{	O
while	O
(	O
buffer	pointer
[	O
i	array
]	O
&&	O
cr_whitespace	O
(	O
buffer	pointer
[	O
i	array
]	O
)	O
)	O
i	array
++	O
;	O
if	O
(	O
buffer	pointer
[	O
i	array
]	O
==	O
'#'	O
)	O
continue	O
;	O
for	O
(	O
start	pointer
=	O
i	array
;	O
buffer	pointer
[	O
i	array
]	O
&&	O
!	O
cr_whitespace	O
(	O
buffer	pointer
[	O
i	array
]	O
)	O
;	O
i	array
++	O
)	O
;	O
if	O
(	O
i	array
-	O
start	pointer
==	O
0	int
)	O
continue	O
;	O
name	pointer
=	O
g_strndup	function
(	O
buffer	pointer
+	O
start	pointer
,	O
i	array
-	O
start	pointer
)	O
;	O
{	O
char	O
*	O
*	O
host_p	pointer
;	O
if	O
(	O
hosts_p	pointer
-	O
hosts	pointer
>=	O
hosts_alloclen	int
)	O
{	O
int	O
j	int
=	O
hosts_p	pointer
-	O
hosts	pointer
;	O
hosts	pointer
=	O
g_realloc	function
(	O
(	O
void	O
*	O
)	O
hosts	pointer
,	O
(	O
(	O
hosts_alloclen	int
+=	O
30	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
hosts_p	pointer
=	O
hosts	pointer
+	O
j	int
;	O
}	O
for	O
(	O
host_p	pointer
=	O
hosts	pointer
;	O
host_p	pointer
<	O
hosts_p	pointer
;	O
host_p	pointer
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
name	pointer
,	O
*	O
host_p	pointer
)	O
)	O
break	O
;	O
if	O
(	O
host_p	pointer
==	O
hosts_p	pointer
)	O
{	O
*	O
(	O
hosts_p	pointer
++	O
)	O
=	O
name	pointer
;	O
*	O
hosts_p	pointer
=	O
NULL	O
;	O
}	O
else	O
g_free	function
(	O
name	pointer
)	O
;	O
}	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
static	O
char	O
*	O
hostname_completion_function	function
(	O
char	O
*	O
text	pointer
,	O
int	O
state	pointer
)	O
{	O
static	O
char	O
*	O
*	O
host_p	pointer
;	O
static	O
int	O
textstart	int
,	O
textlen	int
;	O
if	O
(	O
!	O
state	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
hosts	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
host_p	pointer
=	O
hosts	pointer
;	O
*	O
host_p	pointer
;	O
host_p	pointer
++	O
)	O
g_free	function
(	O
*	O
host_p	pointer
)	O
;	O
g_free	function
(	O
hosts	pointer
)	O
;	O
}	O
hosts	pointer
=	O
g_new	O
(	O
char	O
*	O
,	O
(	O
hosts_alloclen	int
=	O
30	int
)	O
+	O
1	int
)	O
;	O
*	O
hosts	pointer
=	O
NULL	O
;	O
hosts_p	pointer
=	O
hosts	pointer
;	O
fetch_hosts	function
(	O
(	O
p	pointer
=	O
getenv	function
(	O
"HOSTFILE"	pointer
)	O
)	O
?	O
p	pointer
:	O
"/etc/hosts"	pointer
)	O
;	O
host_p	pointer
=	O
hosts	pointer
;	O
textstart	int
=	O
(	O
*	O
text	pointer
==	O
'@'	O
)	O
?	O
1	int
:	O
0	int
;	O
textlen	int
=	O
strlen	function
(	O
text	pointer
+	O
textstart	int
)	O
;	O
}	O
while	O
(	O
*	O
host_p	pointer
)	O
{	O
if	O
(	O
!	O
textlen	int
)	O
break	O
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
text	pointer
+	O
textstart	int
,	O
*	O
host_p	pointer
,	O
textlen	int
)	O
)	O
break	O
;	O
host_p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
*	O
host_p	pointer
)	O
{	O
for	O
(	O
host_p	pointer
=	O
hosts	pointer
;	O
*	O
host_p	pointer
;	O
host_p	pointer
++	O
)	O
g_free	function
(	O
*	O
host_p	pointer
)	O
;	O
g_free	function
(	O
hosts	pointer
)	O
;	O
hosts	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
temp	pointer
=	O
g_malloc	function
(	O
2	int
+	O
strlen	function
(	O
*	O
host_p	pointer
)	O
)	O
;	O
if	O
(	O
textstart	int
)	O
*	O
temp	pointer
=	O
'@'	O
;	O
strcpy	function
(	O
temp	pointer
+	O
textstart	int
,	O
*	O
host_p	pointer
)	O
;	O
host_p	pointer
++	O
;	O
return	O
temp	pointer
;	O
}	O
}	O
static	O
char	O
*	O
command_completion_function	function
(	O
char	O
*	O
text	pointer
,	O
int	O
state	pointer
)	O
{	O
static	O
const	O
char	O
*	O
path_end	pointer
;	O
static	O
int	O
isabsolute	int
;	O
static	O
int	O
phase	int
;	O
static	O
int	O
text_len	long
;	O
static	O
const	O
char	O
*	O
const	O
*	O
words	pointer
;	O
static	O
char	O
*	O
path	pointer
;	O
static	O
char	O
*	O
cur_path	pointer
;	O
static	O
char	O
*	O
cur_word	pointer
;	O
static	O
int	O
init_state	int
;	O
static	O
const	O
char	O
*	O
const	O
bash_reserved	array
[	O
]	O
=	O
{	O
"if"	pointer
,	O
"then"	pointer
,	O
"else"	pointer
,	O
"elif"	pointer
,	O
"fi"	pointer
,	O
"case"	pointer
,	O
"esac"	pointer
,	O
"for"	pointer
,	O
"select"	pointer
,	O
"while"	pointer
,	O
"until"	pointer
,	O
"do"	pointer
,	O
"done"	pointer
,	O
"in"	pointer
,	O
"function"	pointer
,	O
0	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
bash_builtins	array
[	O
]	O
=	O
{	O
"alias"	pointer
,	O
"bg"	pointer
,	O
"bind"	pointer
,	O
"break"	pointer
,	O
"builtin"	pointer
,	O
"cd"	pointer
,	O
"command"	pointer
,	O
"continue"	pointer
,	O
"declare"	pointer
,	O
"dirs"	pointer
,	O
"echo"	pointer
,	O
"enable"	pointer
,	O
"eval"	pointer
,	O
"exec"	pointer
,	O
"exit"	pointer
,	O
"export"	pointer
,	O
"fc"	pointer
,	O
"fg"	pointer
,	O
"getopts"	pointer
,	O
"hash"	pointer
,	O
"help"	pointer
,	O
"history"	pointer
,	O
"jobs"	pointer
,	O
"kill"	pointer
,	O
"let"	pointer
,	O
"local"	pointer
,	O
"logout"	pointer
,	O
"popd"	pointer
,	O
"pushd"	pointer
,	O
"pwd"	pointer
,	O
"read"	pointer
,	O
"readonly"	pointer
,	O
"return"	pointer
,	O
"set"	pointer
,	O
"shift"	pointer
,	O
"source"	pointer
,	O
"suspend"	pointer
,	O
"test"	pointer
,	O
"times"	pointer
,	O
"trap"	pointer
,	O
"type"	pointer
,	O
"typeset"	pointer
,	O
"ulimit"	pointer
,	O
"umask"	pointer
,	O
"unalias"	pointer
,	O
"unset"	pointer
,	O
"wait"	pointer
,	O
0	int
}	O
;	O
char	O
*	O
p	pointer
,	O
*	O
found	pointer
;	O
if	O
(	O
!	O
state	pointer
)	O
{	O
isabsolute	int
=	O
strchr	function
(	O
text	pointer
,	O
PATH_SEP	char
)	O
!=	O
0	int
;	O
look_for_executables	int
=	O
isabsolute	int
?	O
1	int
:	O
2	int
;	O
if	O
(	O
!	O
isabsolute	int
)	O
{	O
words	pointer
=	O
bash_reserved	array
;	O
phase	int
=	O
0	int
;	O
text_len	long
=	O
strlen	function
(	O
text	pointer
)	O
;	O
if	O
(	O
!	O
path	pointer
&&	O
(	O
path	pointer
=	O
g_strdup	function
(	O
getenv	function
(	O
"PATH"	pointer
)	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
p	pointer
=	O
path	pointer
;	O
path_end	pointer
=	O
strchr	function
(	O
p	pointer
,	O
0	int
)	O
;	O
while	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
PATH_ENV_SEP	char
)	O
)	O
)	O
{	O
*	O
p	pointer
++	O
=	O
0	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
isabsolute	int
)	O
{	O
p	pointer
=	O
filename_completion_function	function
(	O
text	pointer
,	O
state	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
look_for_executables	int
=	O
0	int
;	O
return	O
p	pointer
;	O
}	O
found	pointer
=	O
NULL	O
;	O
switch	O
(	O
phase	int
)	O
{	O
case	O
0	int
:	O
while	O
(	O
*	O
words	pointer
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
*	O
words	pointer
,	O
text	pointer
,	O
text_len	long
)	O
)	O
return	O
g_strdup	function
(	O
*	O
(	O
words	pointer
++	O
)	O
)	O
;	O
words	pointer
++	O
;	O
}	O
phase	int
++	O
;	O
words	pointer
=	O
bash_builtins	array
;	O
case	O
1	int
:	O
while	O
(	O
*	O
words	pointer
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
*	O
words	pointer
,	O
text	pointer
,	O
text_len	long
)	O
)	O
return	O
g_strdup	function
(	O
*	O
(	O
words	pointer
++	O
)	O
)	O
;	O
words	pointer
++	O
;	O
}	O
phase	int
++	O
;	O
if	O
(	O
!	O
path	pointer
)	O
break	O
;	O
cur_path	pointer
=	O
path	pointer
;	O
cur_word	pointer
=	O
NULL	O
;	O
case	O
2	int
:	O
while	O
(	O
!	O
found	pointer
)	O
{	O
if	O
(	O
!	O
cur_word	pointer
)	O
{	O
char	O
*	O
expanded	pointer
;	O
if	O
(	O
cur_path	pointer
>=	O
path_end	pointer
)	O
break	O
;	O
expanded	pointer
=	O
tilde_expand	function
(	O
*	O
cur_path	pointer
?	O
cur_path	pointer
:	O
"."	pointer
)	O
;	O
cur_word	pointer
=	O
concat_dir_and_file	function
(	O
expanded	pointer
,	O
text	pointer
)	O
;	O
g_free	function
(	O
expanded	pointer
)	O
;	O
canonicalize_pathname	function
(	O
cur_word	pointer
)	O
;	O
cur_path	pointer
=	O
strchr	function
(	O
cur_path	pointer
,	O
0	int
)	O
+	O
1	int
;	O
init_state	int
=	O
state	pointer
;	O
}	O
found	pointer
=	O
filename_completion_function	function
(	O
cur_word	pointer
,	O
state	pointer
-	O
init_state	int
)	O
;	O
if	O
(	O
!	O
found	pointer
)	O
{	O
g_free	function
(	O
cur_word	pointer
)	O
;	O
cur_word	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found	pointer
)	O
{	O
look_for_executables	int
=	O
0	int
;	O
g_free	function
(	O
path	pointer
)	O
;	O
path	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
found	pointer
,	O
PATH_SEP	char
)	O
)	O
!=	O
NULL	O
)	O
{	O
p	pointer
++	O
;	O
p	pointer
=	O
g_strdup	function
(	O
p	pointer
)	O
;	O
g_free	function
(	O
found	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
return	O
found	pointer
;	O
}	O
static	O
int	O
match_compare	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
return	O
strcmp	function
(	O
*	O
(	O
char	O
*	O
*	O
)	O
a	pointer
,	O
*	O
(	O
char	O
*	O
*	O
)	O
b	pointer
)	O
;	O
}	O
static	O
char	O
*	O
*	O
completion_matches	function
(	O
char	O
*	O
text	pointer
,	O
CompletionFunction	function
entry_function	function
)	O
{	O
int	O
match_list_size	int
;	O
char	O
*	O
*	O
match_list	pointer
=	O
g_new	O
(	O
char	O
*	O
,	O
(	O
match_list_size	int
=	O
30	int
)	O
+	O
1	int
)	O
;	O
int	O
matches	int
=	O
0	int
;	O
char	O
*	O
string	pointer
;	O
match_list	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
while	O
(	O
(	O
string	pointer
=	O
(	O
*	O
entry_function	function
)	O
(	O
text	pointer
,	O
matches	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
matches	int
+	O
1	int
==	O
match_list_size	int
)	O
match_list	pointer
=	O
(	O
char	O
*	O
*	O
)	O
g_realloc	function
(	O
match_list	pointer
,	O
(	O
(	O
match_list_size	int
+=	O
30	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
match_list	pointer
[	O
++	O
matches	int
]	O
=	O
string	pointer
;	O
match_list	pointer
[	O
matches	int
+	O
1	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
matches	int
)	O
{	O
register	O
int	O
i	array
=	O
1	int
;	O
int	O
low	int
=	O
4096	int
;	O
if	O
(	O
matches	int
==	O
1	int
)	O
{	O
match_list	pointer
[	O
0	int
]	O
=	O
match_list	pointer
[	O
1	int
]	O
;	O
match_list	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
}	O
else	O
{	O
int	O
j	int
;	O
qsort	function
(	O
match_list	pointer
+	O
1	int
,	O
matches	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
match_compare	function
)	O
;	O
j	int
=	O
i	array
+	O
1	int
;	O
while	O
(	O
j	int
<	O
matches	int
+	O
1	int
)	O
{	O
register	O
int	O
c1	int
,	O
c2	int
,	O
si	int
;	O
for	O
(	O
si	int
=	O
0	int
;	O
(	O
c1	int
=	O
match_list	pointer
[	O
i	array
]	O
[	O
si	int
]	O
)	O
&&	O
(	O
c2	int
=	O
match_list	pointer
[	O
j	int
]	O
[	O
si	int
]	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
if	O
(	O
!	O
c1	int
&&	O
!	O
match_list	pointer
[	O
j	int
]	O
[	O
si	int
]	O
)	O
{	O
g_free	function
(	O
match_list	pointer
[	O
j	int
]	O
)	O
;	O
j	int
++	O
;	O
if	O
(	O
j	int
>	O
matches	int
)	O
break	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
low	int
>	O
si	int
)	O
low	int
=	O
si	int
;	O
if	O
(	O
i	array
+	O
1	int
!=	O
j	int
)	O
match_list	pointer
[	O
i	array
+	O
1	int
]	O
=	O
match_list	pointer
[	O
j	int
]	O
;	O
i	array
++	O
;	O
j	int
++	O
;	O
}	O
matches	int
=	O
i	array
;	O
match_list	pointer
[	O
matches	int
+	O
1	int
]	O
=	O
NULL	O
;	O
match_list	pointer
[	O
0	int
]	O
=	O
g_strndup	function
(	O
match_list	pointer
[	O
1	int
]	O
,	O
low	int
)	O
;	O
}	O
}	O
else	O
{	O
g_free	function
(	O
match_list	pointer
)	O
;	O
match_list	pointer
=	O
NULL	O
;	O
}	O
return	O
match_list	pointer
;	O
}	O
static	O
int	O
check_is_cd	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
start	pointer
,	O
int	O
flags	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
flags	enum
&	O
INPUT_COMPLETE_CD	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
(	O
flags	enum
&	O
INPUT_COMPLETE_COMMANDS	int
)	O
)	O
return	O
0	int
;	O
p	pointer
=	O
text	pointer
;	O
q	pointer
=	O
text	pointer
+	O
start	pointer
;	O
while	O
(	O
p	pointer
<	O
q	pointer
&&	O
*	O
p	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'c'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'd'	O
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
p	pointer
[	O
2	int
]	O
)	O
&&	O
(	O
p	pointer
+	O
2	int
<	O
q	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
*	O
try_complete	function
(	O
char	O
*	O
text	pointer
,	O
int	O
*	O
start	pointer
,	O
int	O
*	O
end	pointer
,	O
int	O
flags	enum
)	O
{	O
int	O
in_command_position	int
=	O
0	int
,	O
i	array
;	O
char	O
*	O
word	pointer
,	O
c	int
;	O
char	O
*	O
*	O
matches	int
=	O
NULL	O
;	O
const	O
char	O
*	O
command_separator_chars	pointer
=	O
";|&{(`"	pointer
;	O
char	O
*	O
p	pointer
=	O
NULL	O
,	O
*	O
q	pointer
=	O
NULL	O
,	O
*	O
r	pointer
=	O
NULL	O
;	O
int	O
is_cd	int
=	O
check_is_cd	function
(	O
text	pointer
,	O
*	O
start	pointer
,	O
flags	enum
)	O
;	O
ignore_filenames	int
=	O
0	int
;	O
c	int
=	O
text	pointer
[	O
*	O
end	pointer
]	O
;	O
text	pointer
[	O
*	O
end	pointer
]	O
=	O
0	int
;	O
word	pointer
=	O
g_strdup	function
(	O
text	pointer
+	O
*	O
start	pointer
)	O
;	O
text	pointer
[	O
*	O
end	pointer
]	O
=	O
c	int
;	O
if	O
(	O
!	O
is_cd	int
&&	O
(	O
flags	enum
&	O
INPUT_COMPLETE_COMMANDS	int
)	O
)	O
{	O
i	array
=	O
*	O
start	pointer
-	O
1	int
;	O
while	O
(	O
i	array
>	O
-	O
1	int
&&	O
(	O
text	pointer
[	O
i	array
]	O
==	O
' '	O
||	O
text	pointer
[	O
i	array
]	O
==	O
'\t'	O
)	O
)	O
i	array
--	O
;	O
if	O
(	O
i	array
<	O
0	int
)	O
in_command_position	int
++	O
;	O
else	O
if	O
(	O
strchr	function
(	O
command_separator_chars	pointer
,	O
text	pointer
[	O
i	array
]	O
)	O
)	O
{	O
register	O
int	O
this_char	int
,	O
prev_char	int
;	O
in_command_position	int
++	O
;	O
if	O
(	O
i	array
)	O
{	O
this_char	int
=	O
text	pointer
[	O
i	array
]	O
;	O
prev_char	int
=	O
text	pointer
[	O
i	array
-	O
1	int
]	O
;	O
if	O
(	O
(	O
this_char	int
==	O
'&'	O
&&	O
(	O
prev_char	int
==	O
'<'	O
||	O
prev_char	int
==	O
'>'	O
)	O
)	O
||	O
(	O
this_char	int
==	O
'|'	O
&&	O
prev_char	int
==	O
'>'	O
)	O
)	O
in_command_position	int
=	O
0	int
;	O
else	O
if	O
(	O
i	array
>	O
0	int
&&	O
text	pointer
[	O
i	array
-	O
1	int
]	O
==	O
'\\'	O
)	O
in_command_position	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
flags	enum
&	O
INPUT_COMPLETE_COMMANDS	int
)	O
p	pointer
=	O
strrchr	function
(	O
word	pointer
,	O
'`'	O
)	O
;	O
if	O
(	O
flags	enum
&	O
(	O
INPUT_COMPLETE_COMMANDS	int
|	O
INPUT_COMPLETE_VARIABLES	int
)	O
)	O
q	pointer
=	O
strrchr	function
(	O
word	pointer
,	O
'$'	O
)	O
;	O
if	O
(	O
flags	enum
&	O
INPUT_COMPLETE_HOSTNAMES	int
)	O
r	pointer
=	O
strrchr	function
(	O
word	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
q	pointer
&&	O
q	pointer
[	O
1	int
]	O
==	O
'('	O
&&	O
INPUT_COMPLETE_COMMANDS	int
)	O
{	O
if	O
(	O
q	pointer
>	O
p	pointer
)	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
q	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
p	pointer
>	O
q	pointer
&&	O
p	pointer
>	O
r	pointer
)	O
{	O
matches	int
=	O
completion_matches	function
(	O
p	pointer
+	O
1	int
,	O
command_completion_function	function
)	O
;	O
if	O
(	O
matches	int
)	O
*	O
start	pointer
+=	O
p	pointer
+	O
1	int
-	O
word	pointer
;	O
}	O
else	O
if	O
(	O
q	pointer
>	O
p	pointer
&&	O
q	pointer
>	O
r	pointer
)	O
{	O
matches	int
=	O
completion_matches	function
(	O
q	pointer
,	O
variable_completion_function	function
)	O
;	O
if	O
(	O
matches	int
)	O
*	O
start	pointer
+=	O
q	pointer
-	O
word	pointer
;	O
}	O
else	O
if	O
(	O
r	pointer
>	O
p	pointer
&&	O
r	pointer
>	O
q	pointer
)	O
{	O
matches	int
=	O
completion_matches	function
(	O
r	pointer
,	O
hostname_completion_function	function
)	O
;	O
if	O
(	O
matches	int
)	O
*	O
start	pointer
+=	O
r	pointer
-	O
word	pointer
;	O
}	O
if	O
(	O
!	O
matches	int
&&	O
*	O
word	pointer
==	O
'~'	O
&&	O
(	O
flags	enum
&	O
INPUT_COMPLETE_USERNAMES	int
)	O
&&	O
!	O
strchr	function
(	O
word	pointer
,	O
PATH_SEP	char
)	O
)	O
matches	int
=	O
completion_matches	function
(	O
word	pointer
,	O
username_completion_function	function
)	O
;	O
if	O
(	O
!	O
matches	int
&&	O
in_command_position	int
)	O
matches	int
=	O
completion_matches	function
(	O
word	pointer
,	O
command_completion_function	function
)	O
;	O
else	O
if	O
(	O
!	O
matches	int
&&	O
(	O
flags	enum
&	O
INPUT_COMPLETE_FILENAMES	int
)	O
)	O
{	O
if	O
(	O
is_cd	int
)	O
ignore_filenames	int
=	O
1	int
;	O
matches	int
=	O
completion_matches	function
(	O
word	pointer
,	O
filename_completion_function	function
)	O
;	O
ignore_filenames	int
=	O
0	int
;	O
if	O
(	O
!	O
matches	int
&&	O
is_cd	int
&&	O
*	O
word	pointer
!=	O
PATH_SEP	char
&&	O
*	O
word	pointer
!=	O
'~'	O
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
=	O
text	pointer
+	O
*	O
start	pointer
;	O
for	O
(	O
p	pointer
=	O
text	pointer
;	O
*	O
p	pointer
&&	O
p	pointer
<	O
q	pointer
&&	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
p	pointer
,	O
"cd"	pointer
,	O
2	int
)	O
)	O
for	O
(	O
p	pointer
+=	O
2	int
;	O
*	O
p	pointer
&&	O
p	pointer
<	O
q	pointer
&&	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
p	pointer
==	O
q	pointer
)	O
{	O
char	O
*	O
const	O
cdpath_ref	pointer
=	O
g_strdup	function
(	O
getenv	function
(	O
"CDPATH"	pointer
)	O
)	O
;	O
char	O
*	O
cdpath	pointer
=	O
cdpath_ref	pointer
;	O
char	O
c	int
,	O
*	O
s	pointer
,	O
*	O
r	pointer
;	O
if	O
(	O
cdpath	pointer
==	O
NULL	O
)	O
c	int
=	O
0	int
;	O
else	O
c	int
=	O
':'	O
;	O
while	O
(	O
!	O
matches	int
&&	O
c	int
==	O
':'	O
)	O
{	O
s	pointer
=	O
strchr	function
(	O
cdpath	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
strchr	function
(	O
cdpath	pointer
,	O
0	int
)	O
;	O
c	int
=	O
*	O
s	pointer
;	O
*	O
s	pointer
=	O
0	int
;	O
if	O
(	O
*	O
cdpath	pointer
)	O
{	O
r	pointer
=	O
concat_dir_and_file	function
(	O
cdpath	pointer
,	O
word	pointer
)	O
;	O
ignore_filenames	int
=	O
1	int
;	O
matches	int
=	O
completion_matches	function
(	O
r	pointer
,	O
filename_completion_function	function
)	O
;	O
ignore_filenames	int
=	O
0	int
;	O
g_free	function
(	O
r	pointer
)	O
;	O
}	O
*	O
s	pointer
=	O
c	int
;	O
cdpath	pointer
=	O
s	pointer
+	O
1	int
;	O
}	O
g_free	function
(	O
cdpath_ref	pointer
)	O
;	O
}	O
}	O
}	O
g_free	function
(	O
word	pointer
)	O
;	O
return	O
matches	int
;	O
}	O
void	O
free_completions	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
if	O
(	O
!	O
in	pointer
->	O
completions	pointer
)	O
return	O
;	O
for	O
(	O
p	pointer
=	O
in	pointer
->	O
completions	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
g_free	function
(	O
*	O
p	pointer
)	O
;	O
g_free	function
(	O
in	pointer
->	O
completions	pointer
)	O
;	O
in	pointer
->	O
completions	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
query_height	int
,	O
query_width	int
;	O
static	O
WInput	struct
*	O
input	pointer
;	O
static	O
int	O
min_end	int
;	O
static	O
int	O
start	pointer
,	O
end	pointer
;	O
static	O
int	O
insert_text	function
(	O
WInput	struct
*	O
in	pointer
,	O
char	O
*	O
text	pointer
,	O
ssize_t	long
len	int
)	O
{	O
len	int
=	O
min	long
(	O
len	int
,	O
(	O
ssize_t	long
)	O
strlen	function
(	O
text	pointer
)	O
)	O
+	O
start	pointer
-	O
end	pointer
;	O
if	O
(	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
+	O
len	int
>=	O
(	O
size_t	long
)	O
in	pointer
->	O
current_max_len	int
)	O
{	O
char	O
*	O
narea	pointer
=	O
g_realloc	function
(	O
in	pointer
->	O
buffer	pointer
,	O
in	pointer
->	O
current_max_len	int
+	O
len	int
+	O
in	pointer
->	O
field_len	int
)	O
;	O
if	O
(	O
narea	pointer
)	O
{	O
in	pointer
->	O
buffer	pointer
=	O
narea	pointer
;	O
in	pointer
->	O
current_max_len	int
+=	O
len	int
+	O
in	pointer
->	O
field_len	int
;	O
}	O
}	O
if	O
(	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
+	O
1	int
<	O
(	O
size_t	long
)	O
in	pointer
->	O
current_max_len	int
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
int	O
i	array
=	O
strlen	function
(	O
&	O
in	pointer
->	O
buffer	pointer
[	O
end	pointer
]	O
)	O
;	O
for	O
(	O
;	O
i	array
>=	O
0	int
;	O
i	array
--	O
)	O
in	pointer
->	O
buffer	pointer
[	O
end	pointer
+	O
len	int
+	O
i	array
]	O
=	O
in	pointer
->	O
buffer	pointer
[	O
end	pointer
+	O
i	array
]	O
;	O
}	O
else	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
char	O
*	O
p	pointer
=	O
in	pointer
->	O
buffer	pointer
+	O
end	pointer
+	O
len	int
,	O
*	O
q	pointer
=	O
in	pointer
->	O
buffer	pointer
+	O
end	pointer
;	O
while	O
(	O
*	O
q	pointer
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
*	O
(	O
q	pointer
++	O
)	O
;	O
*	O
p	pointer
=	O
0	int
;	O
}	O
memcpy	function
(	O
in	pointer
->	O
buffer	pointer
+	O
start	pointer
,	O
text	pointer
,	O
len	int
-	O
start	pointer
+	O
end	pointer
)	O
;	O
in	pointer
->	O
point	int
+=	O
len	int
;	O
update_input	function
(	O
in	pointer
,	O
1	int
)	O
;	O
end	pointer
+=	O
len	int
;	O
}	O
return	O
len	int
!=	O
0	int
;	O
}	O
static	O
cb_ret_t	enum
query_callback	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_KEY	int
:	O
switch	O
(	O
parm	int
)	O
{	O
case	O
KEY_LEFT	int
:	O
case	O
KEY_RIGHT	int
:	O
h	pointer
->	O
ret_value	int
=	O
0	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_BACKSPACE	int
:	O
if	O
(	O
end	pointer
==	O
min_end	int
)	O
{	O
h	pointer
->	O
ret_value	int
=	O
0	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
else	O
{	O
WLEntry	struct
*	O
e	pointer
,	O
*	O
e1	pointer
;	O
e1	pointer
=	O
e	pointer
=	O
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	pointer
->	O
current	pointer
)	O
)	O
->	O
list	pointer
;	O
do	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
input	pointer
->	O
buffer	pointer
+	O
start	pointer
,	O
e1	pointer
->	O
text	pointer
,	O
end	pointer
-	O
start	pointer
-	O
1	int
)	O
)	O
{	O
listbox_select_entry	function
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	pointer
->	O
current	pointer
)	O
,	O
e1	pointer
)	O
;	O
handle_char	function
(	O
input	pointer
,	O
parm	int
)	O
;	O
end	pointer
--	O
;	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
e1	pointer
=	O
e1	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
e	pointer
!=	O
e1	pointer
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
if	O
(	O
parm	int
>	O
0xff	int
||	O
!	O
is_printable	function
(	O
parm	int
)	O
)	O
{	O
if	O
(	O
is_in_input_map	function
(	O
input	pointer
,	O
parm	int
)	O
==	O
2	int
)	O
{	O
if	O
(	O
end	pointer
==	O
min_end	int
)	O
return	O
MSG_HANDLED	int
;	O
h	pointer
->	O
ret_value	int
=	O
B_USER	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
else	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
else	O
{	O
WLEntry	struct
*	O
e	pointer
,	O
*	O
e1	pointer
;	O
int	O
need_redraw	int
=	O
0	int
;	O
int	O
low	int
=	O
4096	int
;	O
char	O
*	O
last_text	pointer
=	O
NULL	O
;	O
e1	pointer
=	O
e	pointer
=	O
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	pointer
->	O
current	pointer
)	O
)	O
->	O
list	pointer
;	O
do	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
input	pointer
->	O
buffer	pointer
+	O
start	pointer
,	O
e1	pointer
->	O
text	pointer
,	O
end	pointer
-	O
start	pointer
)	O
)	O
{	O
if	O
(	O
e1	pointer
->	O
text	pointer
[	O
end	pointer
-	O
start	pointer
]	O
==	O
parm	int
)	O
{	O
if	O
(	O
need_redraw	int
)	O
{	O
register	O
int	O
c1	int
,	O
c2	int
,	O
si	int
;	O
for	O
(	O
si	int
=	O
end	pointer
-	O
start	pointer
+	O
1	int
;	O
(	O
c1	int
=	O
last_text	pointer
[	O
si	int
]	O
)	O
&&	O
(	O
c2	int
=	O
e1	pointer
->	O
text	pointer
[	O
si	int
]	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
if	O
(	O
low	int
>	O
si	int
)	O
low	int
=	O
si	int
;	O
last_text	pointer
=	O
e1	pointer
->	O
text	pointer
;	O
need_redraw	int
=	O
2	int
;	O
}	O
else	O
{	O
need_redraw	int
=	O
1	int
;	O
listbox_select_entry	function
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	pointer
->	O
current	pointer
)	O
,	O
e1	pointer
)	O
;	O
last_text	pointer
=	O
e1	pointer
->	O
text	pointer
;	O
}	O
}	O
}	O
e1	pointer
=	O
e1	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
e	pointer
!=	O
e1	pointer
)	O
;	O
if	O
(	O
need_redraw	int
==	O
2	int
)	O
{	O
insert_text	function
(	O
input	pointer
,	O
last_text	pointer
,	O
low	int
)	O
;	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
need_redraw	int
==	O
1	int
)	O
{	O
h	pointer
->	O
ret_value	int
=	O
B_ENTER	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
}	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
break	O
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
complete_engine	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
what_to_do	int
)	O
{	O
if	O
(	O
in	pointer
->	O
completions	pointer
&&	O
in	pointer
->	O
point	int
!=	O
end	pointer
)	O
free_completions	function
(	O
in	pointer
)	O
;	O
if	O
(	O
!	O
in	pointer
->	O
completions	pointer
)	O
{	O
end	pointer
=	O
in	pointer
->	O
point	int
;	O
for	O
(	O
start	pointer
=	O
end	pointer
?	O
end	pointer
-	O
1	int
:	O
0	int
;	O
start	pointer
>	O
-	O
1	int
;	O
start	pointer
--	O
)	O
if	O
(	O
strchr	function
(	O
" \t;|<>"	pointer
,	O
in	pointer
->	O
buffer	pointer
[	O
start	pointer
]	O
)	O
)	O
break	O
;	O
if	O
(	O
start	pointer
<	O
end	pointer
)	O
start	pointer
++	O
;	O
in	pointer
->	O
completions	pointer
=	O
try_complete	function
(	O
in	pointer
->	O
buffer	pointer
,	O
&	O
start	pointer
,	O
&	O
end	pointer
,	O
in	pointer
->	O
completion_flags	int
)	O
;	O
}	O
if	O
(	O
in	pointer
->	O
completions	pointer
)	O
{	O
if	O
(	O
what_to_do	int
&	O
DO_INSERTION	int
||	O
(	O
(	O
what_to_do	int
&	O
DO_QUERY	int
)	O
&&	O
!	O
in	pointer
->	O
completions	pointer
[	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
insert_text	function
(	O
in	pointer
,	O
in	pointer
->	O
completions	pointer
[	O
0	int
]	O
,	O
strlen	function
(	O
in	pointer
->	O
completions	pointer
[	O
0	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
in	pointer
->	O
completions	pointer
[	O
1	int
]	O
)	O
beep	O
(	O
)	O
;	O
else	O
free_completions	function
(	O
in	pointer
)	O
;	O
}	O
else	O
beep	O
(	O
)	O
;	O
}	O
if	O
(	O
(	O
what_to_do	int
&	O
DO_QUERY	int
)	O
&&	O
in	pointer
->	O
completions	pointer
&&	O
in	pointer
->	O
completions	pointer
[	O
1	int
]	O
)	O
{	O
int	O
maxlen	int
=	O
0	int
,	O
i	array
,	O
count	int
=	O
0	int
;	O
int	O
x	array
,	O
y	short
,	O
w	pointer
,	O
h	pointer
;	O
int	O
start_x	int
,	O
start_y	int
;	O
char	O
*	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
Dlg_head	struct
*	O
query_dlg	pointer
;	O
WListbox	struct
*	O
query_list	pointer
;	O
for	O
(	O
p	pointer
=	O
in	pointer
->	O
completions	pointer
+	O
1	int
;	O
*	O
p	pointer
;	O
count	int
++	O
,	O
p	pointer
++	O
)	O
if	O
(	O
(	O
i	array
=	O
strlen	function
(	O
*	O
p	pointer
)	O
)	O
>	O
maxlen	int
)	O
maxlen	int
=	O
i	array
;	O
start_x	int
=	O
in	pointer
->	O
widget	pointer
.	O
x	array
;	O
start_y	int
=	O
in	pointer
->	O
widget	pointer
.	O
y	short
;	O
if	O
(	O
start_y	int
-	O
2	int
>=	O
count	int
)	O
{	O
y	short
=	O
start_y	int
-	O
2	int
-	O
count	int
;	O
h	pointer
=	O
2	int
+	O
count	int
;	O
}	O
else	O
{	O
if	O
(	O
start_y	int
>=	O
LINES	O
-	O
start_y	int
-	O
1	int
)	O
{	O
y	short
=	O
0	int
;	O
h	pointer
=	O
start_y	int
;	O
}	O
else	O
{	O
y	short
=	O
start_y	int
+	O
1	int
;	O
h	pointer
=	O
LINES	O
-	O
start_y	int
-	O
1	int
;	O
}	O
}	O
x	array
=	O
start	pointer
-	O
in	pointer
->	O
first_shown	int
-	O
2	int
+	O
start_x	int
;	O
w	pointer
=	O
maxlen	int
+	O
4	int
;	O
if	O
(	O
x	array
+	O
w	pointer
>	O
COLS	O
)	O
x	array
=	O
COLS	O
-	O
w	pointer
;	O
if	O
(	O
x	array
<	O
0	int
)	O
x	array
=	O
0	int
;	O
if	O
(	O
x	array
+	O
w	pointer
>	O
COLS	O
)	O
w	pointer
=	O
COLS	O
;	O
input	pointer
=	O
in	pointer
;	O
min_end	int
=	O
end	pointer
;	O
query_height	int
=	O
h	pointer
;	O
query_width	int
=	O
w	pointer
;	O
query_dlg	pointer
=	O
create_dlg	function
(	O
y	short
,	O
x	array
,	O
query_height	int
,	O
query_width	int
,	O
dialog_colors	array
,	O
query_callback	function
,	O
"[Completion]"	pointer
,	O
NULL	O
,	O
DLG_COMPACT	O
)	O
;	O
query_list	pointer
=	O
listbox_new	function
(	O
1	int
,	O
1	int
,	O
w	pointer
-	O
2	int
,	O
h	pointer
-	O
2	int
,	O
NULL	O
)	O
;	O
add_widget	function
(	O
query_dlg	pointer
,	O
query_list	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
in	pointer
->	O
completions	pointer
+	O
1	int
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
listbox_add_item	function
(	O
query_list	pointer
,	O
0	int
,	O
0	int
,	O
*	O
p	pointer
,	O
NULL	O
)	O
;	O
run_dlg	function
(	O
query_dlg	pointer
)	O
;	O
q	pointer
=	O
NULL	O
;	O
if	O
(	O
query_dlg	pointer
->	O
ret_value	int
==	O
B_ENTER	int
)	O
{	O
listbox_get_current	function
(	O
query_list	pointer
,	O
&	O
q	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
q	pointer
)	O
insert_text	function
(	O
in	pointer
,	O
q	pointer
,	O
strlen	function
(	O
q	pointer
)	O
)	O
;	O
}	O
if	O
(	O
q	pointer
||	O
end	pointer
!=	O
min_end	int
)	O
free_completions	function
(	O
in	pointer
)	O
;	O
i	array
=	O
query_dlg	pointer
->	O
ret_value	int
;	O
destroy_dlg	function
(	O
query_dlg	pointer
)	O
;	O
if	O
(	O
i	array
==	O
B_USER	int
)	O
return	O
1	int
;	O
}	O
}	O
else	O
beep	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
complete	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
int	O
engine_flags	int
;	O
if	O
(	O
in	pointer
->	O
completions	pointer
)	O
engine_flags	int
=	O
DO_QUERY	int
;	O
else	O
{	O
engine_flags	int
=	O
DO_INSERTION	int
;	O
if	O
(	O
show_all_if_ambiguous	int
)	O
engine_flags	int
|=	O
DO_QUERY	int
;	O
}	O
while	O
(	O
complete_engine	function
(	O
in	pointer
,	O
engine_flags	int
)	O
)	O
;	O
}	O
