const	O
char	O
*	O
simple_backup_suffix	pointer
=	O
"~"	pointer
;	O
static	O
int	O
max_backup_version	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
int	O
version_number	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
size_t	long
)	O
;	O
char	O
*	O
find_backup_file_name	function
(	O
const	O
char	O
*	O
file	pointer
,	O
enum	O
backup_type	enum
backup_type	enum
)	O
{	O
size_t	long
backup_suffix_size_max	long
;	O
size_t	long
file_len	long
=	O
strlen	function
(	O
file	pointer
)	O
;	O
size_t	long
numbered_suffix_size_max	long
=	O
INT_STRLEN_BOUND	O
(	O
int	O
)	O
+	O
4	int
;	O
char	O
*	O
s	pointer
;	O
const	O
char	O
*	O
suffix	pointer
=	O
simple_backup_suffix	pointer
;	O
backup_suffix_size_max	long
=	O
strlen	function
(	O
simple_backup_suffix	pointer
)	O
+	O
1	int
;	O
if	O
(	O
HAVE_DIR	int
&&	O
backup_suffix_size_max	long
<	O
numbered_suffix_size_max	long
)	O
backup_suffix_size_max	long
=	O
numbered_suffix_size_max	long
;	O
s	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
file_len	long
+	O
backup_suffix_size_max	long
+	O
numbered_suffix_size_max	long
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
strcpy	function
(	O
s	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
backup_type	enum
!=	O
simple	int
)	O
{	O
int	O
highest_backup	int
;	O
size_t	long
dir_len	long
=	O
basename	function
(	O
s	pointer
)	O
-	O
s	pointer
;	O
strcpy	function
(	O
s	pointer
+	O
dir_len	long
,	O
"."	pointer
)	O
;	O
highest_backup	int
=	O
max_backup_version	function
(	O
file	pointer
+	O
dir_len	long
,	O
s	pointer
)	O
;	O
if	O
(	O
!	O
(	O
backup_type	enum
==	O
numbered_existing	int
&&	O
highest_backup	int
==	O
0	int
)	O
)	O
{	O
char	O
*	O
numbered_suffix	pointer
=	O
s	pointer
+	O
(	O
file_len	long
+	O
backup_suffix_size_max	long
)	O
;	O
sprintf	function
(	O
numbered_suffix	pointer
,	O
".~%d~"	pointer
,	O
highest_backup	int
+	O
1	int
)	O
;	O
suffix	pointer
=	O
numbered_suffix	pointer
;	O
}	O
strcpy	function
(	O
s	pointer
,	O
file	pointer
)	O
;	O
}	O
addext	function
(	O
s	pointer
,	O
suffix	pointer
,	O
'~'	O
)	O
;	O
}	O
return	O
s	pointer
;	O
}	O
static	O
int	O
max_backup_version	function
(	O
const	O
char	O
*	O
file	pointer
,	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
int	O
highest_version	int
;	O
int	O
this_version	int
;	O
size_t	long
file_name_length	long
;	O
dirp	pointer
=	O
opendir	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
!	O
dirp	pointer
)	O
return	O
0	int
;	O
highest_version	int
=	O
0	int
;	O
file_name_length	long
=	O
strlen	function
(	O
file	pointer
)	O
;	O
while	O
(	O
(	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
REAL_DIR_ENTRY	int
(	O
dp	pointer
)	O
||	O
strlen	function
(	O
dp	pointer
->	O
d_name	array
)	O
<	O
file_name_length	long
+	O
4	int
)	O
continue	O
;	O
this_version	int
=	O
version_number	function
(	O
file	pointer
,	O
dp	pointer
->	O
d_name	array
,	O
file_name_length	long
)	O
;	O
if	O
(	O
this_version	int
>	O
highest_version	int
)	O
highest_version	int
=	O
this_version	int
;	O
}	O
if	O
(	O
closedir	function
(	O
dirp	pointer
)	O
)	O
return	O
0	int
;	O
return	O
highest_version	int
;	O
}	O
static	O
int	O
version_number	function
(	O
const	O
char	O
*	O
base	pointer
,	O
const	O
char	O
*	O
backup	pointer
,	O
size_t	long
base_length	long
)	O
{	O
int	O
version	int
;	O
const	O
char	O
*	O
p	pointer
;	O
version	int
=	O
0	int
;	O
if	O
(	O
strncmp	function
(	O
base	pointer
,	O
backup	pointer
,	O
base_length	long
)	O
==	O
0	int
&&	O
backup	pointer
[	O
base_length	long
]	O
==	O
'.'	O
&&	O
backup	pointer
[	O
base_length	long
+	O
1	int
]	O
==	O
'~'	O
)	O
{	O
for	O
(	O
p	pointer
=	O
&	O
backup	pointer
[	O
base_length	long
+	O
2	int
]	O
;	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
;	O
++	O
p	pointer
)	O
version	int
=	O
version	int
*	O
10	int
+	O
*	O
p	pointer
-	O
'0'	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
!=	O
'~'	O
||	O
p	pointer
[	O
1	int
]	O
)	O
version	int
=	O
0	int
;	O
}	O
return	O
version	int
;	O
}	O
static	O
const	O
char	O
*	O
const	O
backup_args	array
[	O
]	O
=	O
{	O
"none"	pointer
,	O
"off"	pointer
,	O
"simple"	pointer
,	O
"never"	pointer
,	O
"existing"	pointer
,	O
"nil"	pointer
,	O
"numbered"	pointer
,	O
"t"	pointer
,	O
0	int
}	O
;	O
static	O
const	O
enum	O
backup_type	enum
backup_types	array
[	O
]	O
=	O
{	O
none	int
,	O
none	int
,	O
simple	int
,	O
simple	int
,	O
numbered_existing	int
,	O
numbered_existing	int
,	O
numbered	int
,	O
numbered	int
}	O
;	O
enum	O
backup_type	enum
get_version	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
version	int
)	O
{	O
if	O
(	O
version	int
==	O
0	int
||	O
*	O
version	int
==	O
0	int
)	O
return	O
numbered_existing	int
;	O
else	O
return	O
XARGMATCH	O
(	O
context	pointer
,	O
version	int
,	O
backup_args	array
,	O
backup_types	array
)	O
;	O
}	O
enum	O
backup_type	enum
xget_version	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
version	int
)	O
{	O
if	O
(	O
version	int
&&	O
*	O
version	int
)	O
return	O
get_version	function
(	O
context	pointer
,	O
version	int
)	O
;	O
else	O
return	O
get_version	function
(	O
"$VERSION_CONTROL"	pointer
,	O
getenv	function
(	O
"VERSION_CONTROL"	pointer
)	O
)	O
;	O
}	O
