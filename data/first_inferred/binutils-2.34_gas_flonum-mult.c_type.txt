void	O
flonum_multip	function
(	O
const	O
FLONUM_TYPE	struct
*	O
a	pointer
,	O
const	O
FLONUM_TYPE	struct
*	O
b	pointer
,	O
FLONUM_TYPE	struct
*	O
product	pointer
)	O
{	O
int	O
size_of_a	int
;	O
int	O
size_of_b	int
;	O
int	O
size_of_product	int
;	O
int	O
size_of_sum	int
;	O
int	O
extra_product_positions	int
;	O
unsigned	O
long	O
work	long
;	O
unsigned	O
long	O
carry	long
;	O
long	O
exponent	long
;	O
LITTLENUM_TYPE	short
*	O
q	pointer
;	O
long	O
significant	long
;	O
int	O
P	int
;	O
int	O
N	int
;	O
int	O
A	int
;	O
int	O
B	int
;	O
if	O
(	O
(	O
a	pointer
->	O
sign	char
!=	O
'-'	O
&&	O
a	pointer
->	O
sign	char
!=	O
'+'	O
)	O
||	O
(	O
b	pointer
->	O
sign	char
!=	O
'-'	O
&&	O
b	pointer
->	O
sign	char
!=	O
'+'	O
)	O
)	O
{	O
product	pointer
->	O
sign	char
=	O
0	int
;	O
return	O
;	O
}	O
product	pointer
->	O
sign	char
=	O
(	O
a	pointer
->	O
sign	char
==	O
b	pointer
->	O
sign	char
)	O
?	O
'+'	O
:	O
'-'	O
;	O
size_of_a	int
=	O
a	pointer
->	O
leader	pointer
-	O
a	pointer
->	O
low	pointer
;	O
size_of_b	int
=	O
b	pointer
->	O
leader	pointer
-	O
b	pointer
->	O
low	pointer
;	O
exponent	long
=	O
a	pointer
->	O
exponent	long
+	O
b	pointer
->	O
exponent	long
;	O
size_of_product	int
=	O
product	pointer
->	O
high	pointer
-	O
product	pointer
->	O
low	pointer
;	O
size_of_sum	int
=	O
size_of_a	int
+	O
size_of_b	int
;	O
extra_product_positions	int
=	O
size_of_product	int
-	O
size_of_sum	int
;	O
if	O
(	O
extra_product_positions	int
<	O
0	int
)	O
{	O
P	int
=	O
extra_product_positions	int
;	O
exponent	long
-=	O
extra_product_positions	int
;	O
}	O
else	O
{	O
P	int
=	O
0	int
;	O
}	O
carry	long
=	O
0	int
;	O
significant	long
=	O
0	int
;	O
for	O
(	O
N	int
=	O
0	int
;	O
N	int
<=	O
size_of_sum	int
;	O
N	int
++	O
)	O
{	O
work	long
=	O
carry	long
;	O
carry	long
=	O
0	int
;	O
for	O
(	O
A	int
=	O
0	int
;	O
A	int
<=	O
N	int
;	O
A	int
++	O
)	O
{	O
B	int
=	O
N	int
-	O
A	int
;	O
if	O
(	O
A	int
<=	O
size_of_a	int
&&	O
B	int
<=	O
size_of_b	int
&&	O
B	int
>=	O
0	int
)	O
{	O
work	long
+=	O
(	O
unsigned	O
long	O
)	O
a	pointer
->	O
low	pointer
[	O
A	int
]	O
*	O
(	O
unsigned	O
long	O
)	O
b	pointer
->	O
low	pointer
[	O
B	int
]	O
;	O
carry	long
+=	O
work	long
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
work	long
&=	O
LITTLENUM_MASK	O
;	O
}	O
}	O
significant	long
|=	O
work	long
;	O
if	O
(	O
significant	long
||	O
P	int
<	O
0	int
)	O
{	O
if	O
(	O
P	int
>=	O
0	int
)	O
{	O
product	pointer
->	O
low	pointer
[	O
P	int
]	O
=	O
work	long
;	O
}	O
P	int
++	O
;	O
}	O
else	O
{	O
extra_product_positions	int
++	O
;	O
exponent	long
++	O
;	O
}	O
}	O
if	O
(	O
carry	long
)	O
{	O
if	O
(	O
extra_product_positions	int
>	O
0	int
)	O
product	pointer
->	O
low	pointer
[	O
P	int
]	O
=	O
carry	long
;	O
else	O
{	O
exponent	long
++	O
;	O
P	int
--	O
;	O
for	O
(	O
q	pointer
=	O
product	pointer
->	O
low	pointer
+	O
P	int
;	O
q	pointer
>=	O
product	pointer
->	O
low	pointer
;	O
q	pointer
--	O
)	O
{	O
work	long
=	O
*	O
q	pointer
;	O
*	O
q	pointer
=	O
carry	long
;	O
carry	long
=	O
work	long
;	O
}	O
}	O
}	O
else	O
P	int
--	O
;	O
product	pointer
->	O
leader	pointer
=	O
product	pointer
->	O
low	pointer
+	O
P	int
;	O
product	pointer
->	O
exponent	long
=	O
exponent	long
;	O
}	O
