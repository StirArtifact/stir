struct	O
ar_cache	struct
{	O
file_ptr	long
ptr	pointer
;	O
bfd	struct
*	O
arbfd	pointer
;	O
}	O
;	O
void	O
_bfd_ar_spacepad	function
(	O
char	O
*	O
p	pointer
,	O
size_t	long
n	long
,	O
const	O
char	O
*	O
fmt	pointer
,	O
long	O
val	array
)	O
{	O
static	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
size_t	long
len	long
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fmt	pointer
,	O
val	array
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
len	long
<	O
n	long
)	O
{	O
memcpy	function
(	O
p	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
memset	function
(	O
p	pointer
+	O
len	long
,	O
' '	O
,	O
n	long
-	O
len	long
)	O
;	O
}	O
else	O
memcpy	function
(	O
p	pointer
,	O
buf	pointer
,	O
n	long
)	O
;	O
}	O
bfd_boolean	int
_bfd_ar_sizepad	function
(	O
char	O
*	O
p	pointer
,	O
size_t	long
n	long
,	O
bfd_size_type	long
size	long
)	O
{	O
static	O
char	O
buf	pointer
[	O
21	int
]	O
;	O
size_t	long
len	long
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%-10"	pointer
BFD_VMA_FMT	pointer
"u"	pointer
,	O
size	long
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
len	long
>	O
n	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_too_big	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
len	long
<	O
n	long
)	O
{	O
memcpy	function
(	O
p	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
memset	function
(	O
p	pointer
+	O
len	long
,	O
' '	O
,	O
n	long
-	O
len	long
)	O
;	O
}	O
else	O
memcpy	function
(	O
p	pointer
,	O
buf	pointer
,	O
n	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_mkarchive	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
artdata	struct
)	O
;	O
abfd	pointer
->	O
tdata	union
.	O
aout_ar_data	pointer
=	O
(	O
struct	O
artdata	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
symindex	long
bfd_get_next_mapent	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
symindex	long
prev	pointer
,	O
carsym	struct
*	O
*	O
entry	pointer
)	O
{	O
if	O
(	O
!	O
bfd_has_map	function
(	O
abfd	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
BFD_NO_MORE_SYMBOLS	O
;	O
}	O
if	O
(	O
prev	pointer
==	O
BFD_NO_MORE_SYMBOLS	O
)	O
prev	pointer
=	O
0	int
;	O
else	O
++	O
prev	pointer
;	O
if	O
(	O
prev	pointer
>=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdef_count	long
)	O
return	O
BFD_NO_MORE_SYMBOLS	O
;	O
*	O
entry	pointer
=	O
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdefs	pointer
+	O
prev	pointer
)	O
;	O
return	O
prev	pointer
;	O
}	O
bfd	struct
*	O
_bfd_create_empty_archive_element_shell	function
(	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
return	O
_bfd_new_bfd_contained_in	function
(	O
obfd	pointer
)	O
;	O
}	O
bfd_boolean	int
bfd_set_archive_head	function
(	O
bfd	struct
*	O
output_archive	pointer
,	O
bfd	struct
*	O
new_head	pointer
)	O
{	O
output_archive	pointer
->	O
archive_head	pointer
=	O
new_head	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd	struct
*	O
_bfd_look_for_bfd_in_cache	function
(	O
bfd	struct
*	O
arch_bfd	pointer
,	O
file_ptr	long
filepos	long
)	O
{	O
htab_t	pointer
hash_table	pointer
=	O
bfd_ardata	O
(	O
arch_bfd	pointer
)	O
->	O
cache	pointer
;	O
struct	O
ar_cache	struct
m	struct
;	O
m	struct
.	O
ptr	pointer
=	O
filepos	long
;	O
if	O
(	O
hash_table	pointer
)	O
{	O
struct	O
ar_cache	struct
*	O
entry	pointer
=	O
(	O
struct	O
ar_cache	struct
*	O
)	O
htab_find	function
(	O
hash_table	pointer
,	O
&	O
m	struct
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
return	O
NULL	O
;	O
entry	pointer
->	O
arbfd	pointer
->	O
no_export	int
=	O
arch_bfd	pointer
->	O
no_export	int
;	O
return	O
entry	pointer
->	O
arbfd	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
static	O
hashval_t	int
hash_file_ptr	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
return	O
(	O
hashval_t	int
)	O
(	O
(	O
(	O
struct	O
ar_cache	struct
*	O
)	O
p	pointer
)	O
->	O
ptr	pointer
)	O
;	O
}	O
static	O
int	O
eq_file_ptr	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
struct	O
ar_cache	struct
*	O
arc1	pointer
=	O
(	O
struct	O
ar_cache	struct
*	O
)	O
p1	pointer
;	O
struct	O
ar_cache	struct
*	O
arc2	pointer
=	O
(	O
struct	O
ar_cache	struct
*	O
)	O
p2	pointer
;	O
return	O
arc1	pointer
->	O
ptr	pointer
==	O
arc2	pointer
->	O
ptr	pointer
;	O
}	O
static	O
void	O
*	O
_bfd_calloc_wrapper	function
(	O
size_t	long
a	pointer
,	O
size_t	long
b	pointer
)	O
{	O
return	O
calloc	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_add_bfd_to_archive_cache	function
(	O
bfd	struct
*	O
arch_bfd	pointer
,	O
file_ptr	long
filepos	long
,	O
bfd	struct
*	O
new_elt	pointer
)	O
{	O
struct	O
ar_cache	struct
*	O
cache	pointer
;	O
htab_t	pointer
hash_table	pointer
=	O
bfd_ardata	O
(	O
arch_bfd	pointer
)	O
->	O
cache	pointer
;	O
if	O
(	O
hash_table	pointer
==	O
NULL	O
)	O
{	O
hash_table	pointer
=	O
htab_create_alloc	function
(	O
16	int
,	O
hash_file_ptr	function
,	O
eq_file_ptr	function
,	O
NULL	O
,	O
_bfd_calloc_wrapper	function
,	O
free	function
)	O
;	O
if	O
(	O
hash_table	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
bfd_ardata	O
(	O
arch_bfd	pointer
)	O
->	O
cache	pointer
=	O
hash_table	pointer
;	O
}	O
cache	pointer
=	O
(	O
struct	O
ar_cache	struct
*	O
)	O
bfd_zalloc	function
(	O
arch_bfd	pointer
,	O
sizeof	O
(	O
struct	O
ar_cache	struct
)	O
)	O
;	O
cache	pointer
->	O
ptr	pointer
=	O
filepos	long
;	O
cache	pointer
->	O
arbfd	pointer
=	O
new_elt	pointer
;	O
*	O
htab_find_slot	function
(	O
hash_table	pointer
,	O
(	O
const	O
void	O
*	O
)	O
cache	pointer
,	O
INSERT	int
)	O
=	O
cache	pointer
;	O
arch_eltdata	O
(	O
new_elt	pointer
)	O
->	O
parent_cache	pointer
=	O
hash_table	pointer
;	O
arch_eltdata	O
(	O
new_elt	pointer
)	O
->	O
key	long
=	O
filepos	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd	struct
*	O
open_nested_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
bfd	struct
*	O
archive	pointer
)	O
{	O
const	O
char	O
*	O
target	pointer
;	O
bfd	struct
*	O
n_bfd	pointer
;	O
target	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
archive	pointer
->	O
target_defaulted	int
)	O
target	pointer
=	O
archive	pointer
->	O
xvec	pointer
->	O
name	pointer
;	O
n_bfd	pointer
=	O
bfd_openr	function
(	O
filename	pointer
,	O
target	pointer
)	O
;	O
if	O
(	O
n_bfd	pointer
!=	O
NULL	O
)	O
{	O
n_bfd	pointer
->	O
lto_output	int
=	O
archive	pointer
->	O
lto_output	int
;	O
n_bfd	pointer
->	O
no_export	int
=	O
archive	pointer
->	O
no_export	int
;	O
n_bfd	pointer
->	O
my_archive	pointer
=	O
archive	pointer
;	O
}	O
return	O
n_bfd	pointer
;	O
}	O
static	O
bfd	struct
*	O
find_nested_archive	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
bfd	struct
*	O
arch_bfd	pointer
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
if	O
(	O
filename_cmp	function
(	O
filename	pointer
,	O
arch_bfd	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
abfd	pointer
=	O
arch_bfd	pointer
->	O
nested_archives	pointer
;	O
abfd	pointer
!=	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
archive_next	pointer
)	O
{	O
if	O
(	O
filename_cmp	function
(	O
filename	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
return	O
abfd	pointer
;	O
}	O
abfd	pointer
=	O
open_nested_file	function
(	O
filename	pointer
,	O
arch_bfd	pointer
)	O
;	O
if	O
(	O
abfd	pointer
)	O
{	O
abfd	pointer
->	O
archive_next	pointer
=	O
arch_bfd	pointer
->	O
nested_archives	pointer
;	O
arch_bfd	pointer
->	O
nested_archives	pointer
=	O
abfd	pointer
;	O
}	O
return	O
abfd	pointer
;	O
}	O
static	O
char	O
*	O
get_extended_arelt_filename	function
(	O
bfd	struct
*	O
arch	enum
,	O
const	O
char	O
*	O
name	pointer
,	O
file_ptr	long
*	O
originp	pointer
)	O
{	O
unsigned	O
long	O
table_index	long
=	O
0	int
;	O
const	O
char	O
*	O
endp	pointer
;	O
errno	O
=	O
0	int
;	O
table_index	long
=	O
strtol	function
(	O
name	pointer
+	O
1	int
,	O
(	O
char	O
*	O
*	O
)	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
!=	O
0	int
||	O
table_index	long
>=	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
extended_names_size	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
&&	O
endp	pointer
!=	O
NULL	O
&&	O
*	O
endp	pointer
==	O
':'	O
)	O
{	O
file_ptr	long
origin	long
=	O
strtol	function
(	O
endp	pointer
+	O
1	int
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
NULL	O
;	O
}	O
*	O
originp	pointer
=	O
origin	long
;	O
}	O
else	O
*	O
originp	pointer
=	O
0	int
;	O
return	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
extended_names	pointer
+	O
table_index	long
;	O
}	O
void	O
*	O
_bfd_generic_read_ar_hdr	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
_bfd_generic_read_ar_hdr_mag	function
(	O
abfd	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
*	O
_bfd_generic_read_ar_hdr_mag	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
mag	pointer
)	O
{	O
struct	O
ar_hdr	struct
hdr	struct
;	O
char	O
*	O
hdrp	pointer
=	O
(	O
char	O
*	O
)	O
&	O
hdr	struct
;	O
bfd_size_type	long
parsed_size	long
;	O
struct	O
areltdata	struct
*	O
ared	pointer
;	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
bfd_size_type	long
namelen	long
=	O
0	int
;	O
bfd_size_type	long
allocsize	long
=	O
sizeof	O
(	O
struct	O
areltdata	struct
)	O
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
;	O
char	O
*	O
allocptr	pointer
=	O
0	int
;	O
file_ptr	long
origin	long
=	O
0	int
;	O
unsigned	O
int	O
extra_size	long
=	O
0	int
;	O
char	O
fmag_save	char
;	O
int	O
scan	pointer
;	O
if	O
(	O
bfd_bread	function
(	O
hdrp	pointer
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
,	O
abfd	pointer
)	O
!=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_no_more_archived_files	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
hdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
!=	O
0	int
&&	O
(	O
mag	pointer
==	O
NULL	O
||	O
strncmp	function
(	O
hdr	struct
.	O
ar_fmag	array
,	O
mag	pointer
,	O
2	int
)	O
!=	O
0	int
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
NULL	O
;	O
}	O
errno	O
=	O
0	int
;	O
fmag_save	char
=	O
hdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
;	O
hdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
0	int
;	O
scan	pointer
=	O
sscanf	function
(	O
hdr	struct
.	O
ar_size	array
,	O
"%"	pointer
BFD_VMA_FMT	pointer
"u"	pointer
,	O
&	O
parsed_size	long
)	O
;	O
hdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
fmag_save	char
;	O
if	O
(	O
scan	pointer
!=	O
1	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
hdr	struct
.	O
ar_name	array
[	O
0	int
]	O
==	O
'/'	O
||	O
(	O
hdr	struct
.	O
ar_name	array
[	O
0	int
]	O
==	O
' '	O
&&	O
memchr	function
(	O
hdr	struct
.	O
ar_name	array
,	O
'/'	O
,	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
)	O
==	O
NULL	O
)	O
)	O
&&	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
!=	O
NULL	O
)	O
{	O
filename	pointer
=	O
get_extended_arelt_filename	function
(	O
abfd	pointer
,	O
hdr	struct
.	O
ar_name	array
,	O
&	O
origin	long
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
is_bsd44_extended_name	O
(	O
hdr	struct
.	O
ar_name	array
)	O
)	O
{	O
namelen	long
=	O
atoi	function
(	O
&	O
hdr	struct
.	O
ar_name	array
[	O
3	int
]	O
)	O
;	O
allocsize	long
+=	O
namelen	long
+	O
1	int
;	O
parsed_size	long
-=	O
namelen	long
;	O
extra_size	long
=	O
namelen	long
;	O
allocptr	pointer
=	O
(	O
char	O
*	O
)	O
bfd_zmalloc	function
(	O
allocsize	long
)	O
;	O
if	O
(	O
allocptr	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
filename	pointer
=	O
(	O
allocptr	pointer
+	O
sizeof	O
(	O
struct	O
areltdata	struct
)	O
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
if	O
(	O
bfd_bread	function
(	O
filename	pointer
,	O
namelen	long
,	O
abfd	pointer
)	O
!=	O
namelen	long
)	O
{	O
free	function
(	O
allocptr	pointer
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_no_more_archived_files	int
)	O
;	O
return	O
NULL	O
;	O
}	O
filename	pointer
[	O
namelen	long
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
char	O
*	O
e	pointer
;	O
e	pointer
=	O
(	O
char	O
*	O
)	O
memchr	function
(	O
hdr	struct
.	O
ar_name	array
,	O
'\0'	O
,	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
{	O
e	pointer
=	O
(	O
char	O
*	O
)	O
memchr	function
(	O
hdr	struct
.	O
ar_name	array
,	O
'/'	O
,	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
e	pointer
=	O
(	O
char	O
*	O
)	O
memchr	function
(	O
hdr	struct
.	O
ar_name	array
,	O
' '	O
,	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
)	O
;	O
}	O
if	O
(	O
e	pointer
!=	O
NULL	O
)	O
namelen	long
=	O
e	pointer
-	O
hdr	struct
.	O
ar_name	array
;	O
else	O
{	O
namelen	long
=	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
;	O
}	O
allocsize	long
+=	O
namelen	long
+	O
1	int
;	O
}	O
if	O
(	O
!	O
allocptr	pointer
)	O
{	O
allocptr	pointer
=	O
(	O
char	O
*	O
)	O
bfd_zmalloc	function
(	O
allocsize	long
)	O
;	O
if	O
(	O
allocptr	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
ared	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
allocptr	pointer
;	O
ared	pointer
->	O
arch_header	pointer
=	O
allocptr	pointer
+	O
sizeof	O
(	O
struct	O
areltdata	struct
)	O
;	O
memcpy	function
(	O
ared	pointer
->	O
arch_header	pointer
,	O
&	O
hdr	struct
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
ared	pointer
->	O
parsed_size	long
=	O
parsed_size	long
;	O
ared	pointer
->	O
extra_size	long
=	O
extra_size	long
;	O
ared	pointer
->	O
origin	long
=	O
origin	long
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
)	O
ared	pointer
->	O
filename	pointer
=	O
filename	pointer
;	O
else	O
{	O
ared	pointer
->	O
filename	pointer
=	O
allocptr	pointer
+	O
(	O
sizeof	O
(	O
struct	O
areltdata	struct
)	O
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
if	O
(	O
namelen	long
)	O
memcpy	function
(	O
ared	pointer
->	O
filename	pointer
,	O
hdr	struct
.	O
ar_name	array
,	O
namelen	long
)	O
;	O
ared	pointer
->	O
filename	pointer
[	O
namelen	long
]	O
=	O
'\0'	O
;	O
}	O
return	O
ared	pointer
;	O
}	O
char	O
*	O
_bfd_append_relative_path	function
(	O
bfd	struct
*	O
arch	enum
,	O
char	O
*	O
elt_name	pointer
)	O
{	O
const	O
char	O
*	O
arch_name	pointer
=	O
arch	enum
->	O
filename	pointer
;	O
const	O
char	O
*	O
base_name	pointer
=	O
lbasename	function
(	O
arch_name	pointer
)	O
;	O
size_t	long
prefix_len	long
;	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
base_name	pointer
==	O
arch_name	pointer
)	O
return	O
elt_name	pointer
;	O
prefix_len	long
=	O
base_name	pointer
-	O
arch_name	pointer
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
arch	enum
,	O
prefix_len	long
+	O
strlen	function
(	O
elt_name	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
strncpy	function
(	O
filename	pointer
,	O
arch_name	pointer
,	O
prefix_len	long
)	O
;	O
strcpy	function
(	O
filename	pointer
+	O
prefix_len	long
,	O
elt_name	pointer
)	O
;	O
return	O
filename	pointer
;	O
}	O
bfd	struct
*	O
_bfd_get_elt_at_filepos	function
(	O
bfd	struct
*	O
archive	pointer
,	O
file_ptr	long
filepos	long
)	O
{	O
struct	O
areltdata	struct
*	O
new_areldata	pointer
;	O
bfd	struct
*	O
n_bfd	pointer
;	O
char	O
*	O
filename	pointer
;	O
n_bfd	pointer
=	O
_bfd_look_for_bfd_in_cache	function
(	O
archive	pointer
,	O
filepos	long
)	O
;	O
if	O
(	O
n_bfd	pointer
)	O
return	O
n_bfd	pointer
;	O
if	O
(	O
0	int
>	O
bfd_seek	function
(	O
archive	pointer
,	O
filepos	long
,	O
SEEK_SET	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
new_areldata	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
_bfd_read_ar_hdr	O
(	O
archive	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
filename	pointer
=	O
new_areldata	pointer
->	O
filename	pointer
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
archive	pointer
)	O
)	O
{	O
if	O
(	O
!	O
IS_ABSOLUTE_PATH	O
(	O
filename	pointer
)	O
)	O
{	O
filename	pointer
=	O
_bfd_append_relative_path	function
(	O
archive	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
new_areldata	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
new_areldata	pointer
->	O
origin	long
>	O
0	int
)	O
{	O
bfd	struct
*	O
ext_arch	pointer
=	O
find_nested_archive	function
(	O
filename	pointer
,	O
archive	pointer
)	O
;	O
if	O
(	O
ext_arch	pointer
==	O
NULL	O
||	O
!	O
bfd_check_format	function
(	O
ext_arch	pointer
,	O
bfd_archive	int
)	O
)	O
{	O
free	function
(	O
new_areldata	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
n_bfd	pointer
=	O
_bfd_get_elt_at_filepos	function
(	O
ext_arch	pointer
,	O
new_areldata	pointer
->	O
origin	long
)	O
;	O
if	O
(	O
n_bfd	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
new_areldata	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
n_bfd	pointer
->	O
proxy_origin	long
=	O
bfd_tell	function
(	O
archive	pointer
)	O
;	O
n_bfd	pointer
->	O
flags	int
|=	O
archive	pointer
->	O
flags	int
&	O
(	O
BFD_COMPRESS	int
|	O
BFD_DECOMPRESS	int
|	O
BFD_COMPRESS_GABI	int
)	O
;	O
return	O
n_bfd	pointer
;	O
}	O
n_bfd	pointer
=	O
open_nested_file	function
(	O
filename	pointer
,	O
archive	pointer
)	O
;	O
if	O
(	O
n_bfd	pointer
==	O
NULL	O
)	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
}	O
else	O
{	O
n_bfd	pointer
=	O
_bfd_create_empty_archive_element_shell	function
(	O
archive	pointer
)	O
;	O
}	O
if	O
(	O
n_bfd	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
new_areldata	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
n_bfd	pointer
->	O
proxy_origin	long
=	O
bfd_tell	function
(	O
archive	pointer
)	O
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
archive	pointer
)	O
)	O
{	O
n_bfd	pointer
->	O
origin	long
=	O
0	int
;	O
}	O
else	O
{	O
n_bfd	pointer
->	O
origin	long
=	O
n_bfd	pointer
->	O
proxy_origin	long
;	O
n_bfd	pointer
->	O
filename	pointer
=	O
bfd_strdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
n_bfd	pointer
->	O
filename	pointer
==	O
NULL	O
)	O
goto	O
out	O
;	O
}	O
n_bfd	pointer
->	O
arelt_data	pointer
=	O
new_areldata	pointer
;	O
n_bfd	pointer
->	O
flags	int
|=	O
archive	pointer
->	O
flags	int
&	O
(	O
BFD_COMPRESS	int
|	O
BFD_DECOMPRESS	int
|	O
BFD_COMPRESS_GABI	int
)	O
;	O
n_bfd	pointer
->	O
is_linker_input	int
=	O
archive	pointer
->	O
is_linker_input	int
;	O
if	O
(	O
archive	pointer
->	O
no_element_cache	int
||	O
_bfd_add_bfd_to_archive_cache	function
(	O
archive	pointer
,	O
filepos	long
,	O
n_bfd	pointer
)	O
)	O
return	O
n_bfd	pointer
;	O
out	O
:	O
free	function
(	O
new_areldata	pointer
)	O
;	O
n_bfd	pointer
->	O
arelt_data	pointer
=	O
NULL	O
;	O
bfd_close	function
(	O
n_bfd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
bfd	struct
*	O
_bfd_generic_get_elt_at_index	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
symindex	long
sym_index	long
)	O
{	O
carsym	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdefs	pointer
+	O
sym_index	long
;	O
return	O
_bfd_get_elt_at_filepos	function
(	O
abfd	pointer
,	O
entry	pointer
->	O
file_offset	long
)	O
;	O
}	O
bfd	struct
*	O
_bfd_noarchive_get_elt_at_index	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
symindex	long
sym_index	long
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
(	O
bfd	struct
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd	struct
*	O
bfd_openr_next_archived_file	function
(	O
bfd	struct
*	O
archive	pointer
,	O
bfd	struct
*	O
last_file	pointer
)	O
{	O
if	O
(	O
(	O
bfd_get_format	function
(	O
archive	pointer
)	O
!=	O
bfd_archive	int
)	O
||	O
(	O
archive	pointer
->	O
direction	enum
==	O
write_direction	int
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
BFD_SEND	O
(	O
archive	pointer
,	O
openr_next_archived_file	pointer
,	O
(	O
archive	pointer
,	O
last_file	pointer
)	O
)	O
;	O
}	O
bfd	struct
*	O
bfd_generic_openr_next_archived_file	function
(	O
bfd	struct
*	O
archive	pointer
,	O
bfd	struct
*	O
last_file	pointer
)	O
{	O
ufile_ptr	long
filestart	long
;	O
if	O
(	O
!	O
last_file	pointer
)	O
filestart	long
=	O
bfd_ardata	O
(	O
archive	pointer
)	O
->	O
first_file_filepos	long
;	O
else	O
{	O
filestart	long
=	O
last_file	pointer
->	O
proxy_origin	long
;	O
if	O
(	O
!	O
bfd_is_thin_archive	function
(	O
archive	pointer
)	O
)	O
{	O
bfd_size_type	long
size	long
=	O
arelt_size	O
(	O
last_file	pointer
)	O
;	O
filestart	long
+=	O
size	long
;	O
filestart	long
+=	O
filestart	long
%	O
2	int
;	O
if	O
(	O
filestart	long
<	O
last_file	pointer
->	O
proxy_origin	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
return	O
_bfd_get_elt_at_filepos	function
(	O
archive	pointer
,	O
filestart	long
)	O
;	O
}	O
bfd	struct
*	O
_bfd_noarchive_openr_next_archived_file	function
(	O
bfd	struct
*	O
archive	pointer
,	O
bfd	struct
*	O
last_file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
(	O
bfd	struct
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
archive	pointer
)	O
;	O
}	O
const	O
bfd_target	struct
*	O
bfd_generic_archive_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
artdata	struct
*	O
tdata_hold	pointer
;	O
char	O
armag	array
[	O
SARMAG	int
+	O
1	int
]	O
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
bfd_bread	function
(	O
armag	array
,	O
SARMAG	int
,	O
abfd	pointer
)	O
!=	O
SARMAG	int
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
NULL	O
;	O
}	O
bfd_set_thin_archive	function
(	O
abfd	pointer
,	O
strncmp	function
(	O
armag	array
,	O
ARMAGT	pointer
,	O
SARMAG	int
)	O
==	O
0	int
)	O
;	O
if	O
(	O
strncmp	function
(	O
armag	array
,	O
ARMAG	pointer
,	O
SARMAG	int
)	O
!=	O
0	int
&&	O
!	O
bfd_is_thin_archive	function
(	O
abfd	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
NULL	O
;	O
}	O
tdata_hold	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
artdata	struct
)	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
=	O
(	O
struct	O
artdata	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
==	O
NULL	O
)	O
{	O
bfd_ardata	O
(	O
abfd	pointer
)	O
=	O
tdata_hold	pointer
;	O
return	O
NULL	O
;	O
}	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
first_file_filepos	long
=	O
SARMAG	int
;	O
if	O
(	O
!	O
BFD_SEND	O
(	O
abfd	pointer
,	O
_bfd_slurp_armap	pointer
,	O
(	O
abfd	pointer
)	O
)	O
||	O
!	O
BFD_SEND	O
(	O
abfd	pointer
,	O
_bfd_slurp_extended_name_table	pointer
,	O
(	O
abfd	pointer
)	O
)	O
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
bfd_ardata	O
(	O
abfd	pointer
)	O
)	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
=	O
tdata_hold	pointer
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
abfd	pointer
->	O
target_defaulted	int
&&	O
bfd_has_map	function
(	O
abfd	pointer
)	O
)	O
{	O
bfd	struct
*	O
first	pointer
;	O
unsigned	O
int	O
save	int
;	O
save	int
=	O
abfd	pointer
->	O
no_element_cache	int
;	O
abfd	pointer
->	O
no_element_cache	int
=	O
1	int
;	O
first	pointer
=	O
bfd_openr_next_archived_file	function
(	O
abfd	pointer
,	O
NULL	O
)	O
;	O
abfd	pointer
->	O
no_element_cache	int
=	O
save	int
;	O
if	O
(	O
first	pointer
!=	O
NULL	O
)	O
{	O
first	pointer
->	O
target_defaulted	int
=	O
FALSE	int
;	O
if	O
(	O
bfd_check_format	function
(	O
first	pointer
,	O
bfd_object	int
)	O
&&	O
first	pointer
->	O
xvec	pointer
!=	O
abfd	pointer
->	O
xvec	pointer
)	O
bfd_set_error	function
(	O
bfd_error_wrong_object_format	int
)	O
;	O
bfd_close	function
(	O
first	pointer
)	O
;	O
}	O
}	O
return	O
abfd	pointer
->	O
xvec	pointer
;	O
}	O
static	O
bfd_boolean	int
do_slurp_bsd_armap	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
areltdata	struct
*	O
mapdata	pointer
;	O
unsigned	O
int	O
counter	int
;	O
bfd_byte	char
*	O
raw_armap	pointer
,	O
*	O
rbase	pointer
;	O
struct	O
artdata	struct
*	O
ardata	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
;	O
char	O
*	O
stringbase	pointer
;	O
bfd_size_type	long
parsed_size	long
,	O
amt	long
;	O
carsym	struct
*	O
set	pointer
;	O
mapdata	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
_bfd_read_ar_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
mapdata	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
parsed_size	long
=	O
mapdata	pointer
->	O
parsed_size	long
;	O
free	function
(	O
mapdata	pointer
)	O
;	O
if	O
(	O
parsed_size	long
<	O
4	int
)	O
return	O
FALSE	int
;	O
raw_armap	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
parsed_size	long
)	O
;	O
if	O
(	O
raw_armap	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bread	function
(	O
raw_armap	pointer
,	O
parsed_size	long
,	O
abfd	pointer
)	O
!=	O
parsed_size	long
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
byebye	O
:	O
bfd_release	function
(	O
abfd	pointer
,	O
raw_armap	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
ardata	pointer
->	O
symdef_count	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
raw_armap	pointer
)	O
/	O
BSD_SYMDEF_SIZE	int
;	O
if	O
(	O
ardata	pointer
->	O
symdef_count	long
*	O
BSD_SYMDEF_SIZE	int
>	O
parsed_size	long
-	O
BSD_SYMDEF_COUNT_SIZE	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
goto	O
byebye	O
;	O
}	O
rbase	pointer
=	O
raw_armap	pointer
+	O
BSD_SYMDEF_COUNT_SIZE	int
;	O
stringbase	pointer
=	O
(	O
(	O
char	O
*	O
)	O
rbase	pointer
+	O
ardata	pointer
->	O
symdef_count	long
*	O
BSD_SYMDEF_SIZE	int
+	O
BSD_STRING_COUNT_SIZE	int
)	O
;	O
amt	long
=	O
ardata	pointer
->	O
symdef_count	long
*	O
sizeof	O
(	O
carsym	struct
)	O
;	O
ardata	pointer
->	O
symdefs	pointer
=	O
(	O
struct	O
carsym	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
!	O
ardata	pointer
->	O
symdefs	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
counter	int
=	O
0	int
,	O
set	pointer
=	O
ardata	pointer
->	O
symdefs	pointer
;	O
counter	int
<	O
ardata	pointer
->	O
symdef_count	long
;	O
counter	int
++	O
,	O
set	pointer
++	O
,	O
rbase	pointer
+=	O
BSD_SYMDEF_SIZE	int
)	O
{	O
set	pointer
->	O
name	pointer
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
rbase	pointer
)	O
+	O
stringbase	pointer
;	O
set	pointer
->	O
file_offset	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
rbase	pointer
+	O
BSD_SYMDEF_OFFSET_SIZE	int
)	O
;	O
}	O
ardata	pointer
->	O
first_file_filepos	long
=	O
bfd_tell	function
(	O
abfd	pointer
)	O
;	O
ardata	pointer
->	O
first_file_filepos	long
+=	O
(	O
ardata	pointer
->	O
first_file_filepos	long
)	O
%	O
2	int
;	O
abfd	pointer
->	O
has_armap	int
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
do_slurp_coff_armap	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
areltdata	struct
*	O
mapdata	pointer
;	O
int	O
*	O
raw_armap	pointer
,	O
*	O
rawptr	pointer
;	O
struct	O
artdata	struct
*	O
ardata	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
;	O
char	O
*	O
stringbase	pointer
;	O
char	O
*	O
stringend	pointer
;	O
bfd_size_type	long
stringsize	long
;	O
bfd_size_type	long
parsed_size	long
;	O
carsym	struct
*	O
carsyms	pointer
;	O
bfd_size_type	long
nsymz	long
;	O
bfd_vma	long
(	O
*	O
swap	pointer
)	O
(	O
const	O
void	O
*	O
)	O
;	O
char	O
int_buf	array
[	O
sizeof	O
(	O
long	O
)	O
]	O
;	O
bfd_size_type	long
carsym_size	long
,	O
ptrsize	long
;	O
unsigned	O
int	O
i	pointer
;	O
mapdata	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
_bfd_read_ar_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
mapdata	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
parsed_size	long
=	O
mapdata	pointer
->	O
parsed_size	long
;	O
free	function
(	O
mapdata	pointer
)	O
;	O
if	O
(	O
bfd_bread	function
(	O
int_buf	array
,	O
4	int
,	O
abfd	pointer
)	O
!=	O
4	int
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
swap	pointer
=	O
bfd_getb32	function
;	O
nsymz	long
=	O
bfd_getb32	function
(	O
int_buf	array
)	O
;	O
stringsize	long
=	O
parsed_size	long
-	O
(	O
4	int
*	O
nsymz	long
)	O
-	O
4	int
;	O
if	O
(	O
nsymz	long
>	O
~	O
(	O
bfd_size_type	long
)	O
0	int
/	O
sizeof	O
(	O
carsym	struct
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_memory	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
carsym_size	long
=	O
(	O
nsymz	long
*	O
sizeof	O
(	O
carsym	struct
)	O
)	O
;	O
ptrsize	long
=	O
(	O
4	int
*	O
nsymz	long
)	O
;	O
if	O
(	O
carsym_size	long
+	O
stringsize	long
+	O
1	int
<=	O
carsym_size	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_memory	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
ardata	pointer
->	O
symdefs	pointer
=	O
(	O
struct	O
carsym	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
carsym_size	long
+	O
stringsize	long
+	O
1	int
)	O
;	O
if	O
(	O
ardata	pointer
->	O
symdefs	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
carsyms	pointer
=	O
ardata	pointer
->	O
symdefs	pointer
;	O
stringbase	pointer
=	O
(	O
(	O
char	O
*	O
)	O
ardata	pointer
->	O
symdefs	pointer
)	O
+	O
carsym_size	long
;	O
raw_armap	pointer
=	O
(	O
int	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
ptrsize	long
)	O
;	O
if	O
(	O
raw_armap	pointer
==	O
NULL	O
)	O
goto	O
release_symdefs	O
;	O
if	O
(	O
bfd_bread	function
(	O
raw_armap	pointer
,	O
ptrsize	long
,	O
abfd	pointer
)	O
!=	O
ptrsize	long
||	O
(	O
bfd_bread	function
(	O
stringbase	pointer
,	O
stringsize	long
,	O
abfd	pointer
)	O
!=	O
stringsize	long
)	O
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
goto	O
release_symdefs	O
;	O
}	O
stringend	pointer
=	O
stringbase	pointer
+	O
stringsize	long
;	O
*	O
stringend	pointer
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nsymz	long
;	O
i	pointer
++	O
)	O
{	O
rawptr	pointer
=	O
raw_armap	pointer
+	O
i	pointer
;	O
carsyms	pointer
->	O
file_offset	long
=	O
swap	pointer
(	O
(	O
bfd_byte	char
*	O
)	O
rawptr	pointer
)	O
;	O
carsyms	pointer
->	O
name	pointer
=	O
stringbase	pointer
;	O
stringbase	pointer
+=	O
strlen	function
(	O
stringbase	pointer
)	O
;	O
if	O
(	O
stringbase	pointer
!=	O
stringend	pointer
)	O
++	O
stringbase	pointer
;	O
carsyms	pointer
++	O
;	O
}	O
ardata	pointer
->	O
symdef_count	long
=	O
nsymz	long
;	O
ardata	pointer
->	O
first_file_filepos	long
=	O
bfd_tell	function
(	O
abfd	pointer
)	O
;	O
ardata	pointer
->	O
first_file_filepos	long
+=	O
(	O
ardata	pointer
->	O
first_file_filepos	long
)	O
%	O
2	int
;	O
abfd	pointer
->	O
has_armap	int
=	O
TRUE	int
;	O
bfd_release	function
(	O
abfd	pointer
,	O
raw_armap	pointer
)	O
;	O
{	O
struct	O
areltdata	struct
*	O
tmp	pointer
;	O
bfd_seek	function
(	O
abfd	pointer
,	O
ardata	pointer
->	O
first_file_filepos	long
,	O
SEEK_SET	int
)	O
;	O
tmp	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
_bfd_read_ar_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
tmp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
tmp	pointer
->	O
arch_header	pointer
[	O
0	int
]	O
==	O
'/'	O
&&	O
tmp	pointer
->	O
arch_header	pointer
[	O
1	int
]	O
==	O
' '	O
)	O
{	O
ardata	pointer
->	O
first_file_filepos	long
+=	O
(	O
tmp	pointer
->	O
parsed_size	long
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
+	O
1	int
)	O
&	O
~	O
(	O
unsigned	O
)	O
1	int
;	O
}	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
release_symdefs	O
:	O
bfd_release	function
(	O
abfd	pointer
,	O
(	O
ardata	pointer
)	O
->	O
symdefs	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
bfd_slurp_armap	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
char	O
nextname	array
[	O
17	int
]	O
;	O
int	O
i	pointer
=	O
bfd_bread	function
(	O
nextname	array
,	O
16	int
,	O
abfd	pointer
)	O
;	O
if	O
(	O
i	pointer
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
i	pointer
!=	O
16	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
-	O
16	int
,	O
SEEK_CUR	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"__.SYMDEF       "	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"__.SYMDEF/      "	pointer
)	O
)	O
return	O
do_slurp_bsd_armap	function
(	O
abfd	pointer
)	O
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"/               "	pointer
)	O
)	O
return	O
do_slurp_coff_armap	function
(	O
abfd	pointer
)	O
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"/SYM64/         "	pointer
)	O
)	O
{	O
return	O
_bfd_archive_64_bit_slurp_armap	function
(	O
abfd	pointer
)	O
;	O
}	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"#1/20           "	pointer
)	O
)	O
{	O
struct	O
ar_hdr	struct
hdr	struct
;	O
char	O
extname	array
[	O
21	int
]	O
;	O
if	O
(	O
bfd_bread	function
(	O
&	O
hdr	struct
,	O
sizeof	O
(	O
hdr	struct
)	O
,	O
abfd	pointer
)	O
!=	O
sizeof	O
(	O
hdr	struct
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bread	function
(	O
extname	array
,	O
20	int
,	O
abfd	pointer
)	O
!=	O
20	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
-	O
(	O
file_ptr	long
)	O
(	O
sizeof	O
(	O
hdr	struct
)	O
+	O
20	int
)	O
,	O
SEEK_CUR	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
extname	array
[	O
20	int
]	O
=	O
0	int
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
extname	array
,	O
"__.SYMDEF SORTED"	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
extname	array
,	O
"__.SYMDEF"	pointer
)	O
)	O
return	O
do_slurp_bsd_armap	function
(	O
abfd	pointer
)	O
;	O
}	O
abfd	pointer
->	O
has_armap	int
=	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_slurp_extended_name_table	pointer
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
char	O
nextname	array
[	O
17	int
]	O
;	O
struct	O
areltdata	struct
*	O
namedata	pointer
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
first_file_filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bread	function
(	O
nextname	array
,	O
16	int
,	O
abfd	pointer
)	O
==	O
16	int
)	O
{	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
-	O
16	int
,	O
SEEK_CUR	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"ARFILENAMES/    "	pointer
)	O
&&	O
!	O
CONST_STRNEQ	O
(	O
nextname	array
,	O
"//              "	pointer
)	O
)	O
{	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
=	O
NULL	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names_size	long
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
namedata	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
_bfd_read_ar_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
namedata	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
amt	long
=	O
namedata	pointer
->	O
parsed_size	long
;	O
if	O
(	O
amt	long
+	O
1	int
==	O
0	int
)	O
goto	O
byebye	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names_size	long
=	O
amt	long
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
+	O
1	int
)	O
;	O
if	O
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
==	O
NULL	O
)	O
{	O
byebye	O
:	O
free	function
(	O
namedata	pointer
)	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
=	O
NULL	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names_size	long
=	O
0	int
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_bread	function
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
,	O
amt	long
,	O
abfd	pointer
)	O
!=	O
amt	long
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_malformed_archive	int
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
)	O
)	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
=	O
NULL	O
;	O
goto	O
byebye	O
;	O
}	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
[	O
amt	long
]	O
=	O
0	int
;	O
{	O
char	O
*	O
ext_names	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
extended_names	pointer
;	O
char	O
*	O
temp	pointer
=	O
ext_names	pointer
;	O
char	O
*	O
limit	pointer
=	O
temp	pointer
+	O
namedata	pointer
->	O
parsed_size	long
;	O
for	O
(	O
;	O
temp	pointer
<	O
limit	pointer
;	O
++	O
temp	pointer
)	O
{	O
if	O
(	O
*	O
temp	pointer
==	O
ARFMAG	pointer
[	O
1	int
]	O
)	O
temp	pointer
[	O
temp	pointer
>	O
ext_names	pointer
&&	O
temp	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
?	O
-	O
1	int
:	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
temp	pointer
==	O
'\\'	O
)	O
*	O
temp	pointer
=	O
'/'	O
;	O
}	O
*	O
limit	pointer
=	O
'\0'	O
;	O
}	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
first_file_filepos	long
=	O
bfd_tell	function
(	O
abfd	pointer
)	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
first_file_filepos	long
+=	O
(	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
first_file_filepos	long
)	O
%	O
2	int
;	O
free	function
(	O
namedata	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
normalize	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_ARCHIVE_FULL_PATH	int
)	O
return	O
file	pointer
;	O
return	O
lbasename	function
(	O
file	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
adjust_relative_path	function
(	O
const	O
char	O
*	O
path	pointer
,	O
const	O
char	O
*	O
ref_path	pointer
)	O
{	O
static	O
char	O
*	O
pathbuf	pointer
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
pathbuf_len	int
=	O
0	int
;	O
const	O
char	O
*	O
pathp	pointer
;	O
const	O
char	O
*	O
refp	pointer
;	O
char	O
*	O
lpath	pointer
;	O
char	O
*	O
rpath	pointer
;	O
unsigned	O
int	O
len	long
;	O
unsigned	O
int	O
dir_up	int
=	O
0	int
;	O
unsigned	O
int	O
dir_down	int
=	O
0	int
;	O
char	O
*	O
newp	pointer
;	O
char	O
*	O
pwd	pointer
=	O
getpwd	function
(	O
)	O
;	O
const	O
char	O
*	O
down	pointer
;	O
lpath	pointer
=	O
lrealpath	function
(	O
path	pointer
)	O
;	O
pathp	pointer
=	O
lpath	pointer
==	O
NULL	O
?	O
path	pointer
:	O
lpath	pointer
;	O
rpath	pointer
=	O
lrealpath	function
(	O
ref_path	pointer
)	O
;	O
refp	pointer
=	O
rpath	pointer
==	O
NULL	O
?	O
ref_path	pointer
:	O
rpath	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
const	O
char	O
*	O
e1	pointer
=	O
pathp	pointer
;	O
const	O
char	O
*	O
e2	pointer
=	O
refp	pointer
;	O
while	O
(	O
*	O
e1	pointer
&&	O
!	O
IS_DIR_SEPARATOR	O
(	O
*	O
e1	pointer
)	O
)	O
++	O
e1	pointer
;	O
while	O
(	O
*	O
e2	pointer
&&	O
!	O
IS_DIR_SEPARATOR	O
(	O
*	O
e2	pointer
)	O
)	O
++	O
e2	pointer
;	O
if	O
(	O
*	O
e1	pointer
==	O
'\0'	O
||	O
*	O
e2	pointer
==	O
'\0'	O
||	O
e1	pointer
-	O
pathp	pointer
!=	O
e2	pointer
-	O
refp	pointer
||	O
filename_ncmp	function
(	O
pathp	pointer
,	O
refp	pointer
,	O
e1	pointer
-	O
pathp	pointer
)	O
!=	O
0	int
)	O
break	O
;	O
pathp	pointer
=	O
e1	pointer
+	O
1	int
;	O
refp	pointer
=	O
e2	pointer
+	O
1	int
;	O
}	O
len	long
=	O
strlen	function
(	O
pathp	pointer
)	O
+	O
1	int
;	O
for	O
(	O
;	O
*	O
refp	pointer
;	O
++	O
refp	pointer
)	O
if	O
(	O
IS_DIR_SEPARATOR	O
(	O
*	O
refp	pointer
)	O
)	O
{	O
if	O
(	O
refp	pointer
>	O
ref_path	pointer
+	O
1	int
&&	O
refp	pointer
[	O
-	O
1	int
]	O
==	O
'.'	O
&&	O
refp	pointer
[	O
-	O
2	int
]	O
==	O
'.'	O
)	O
dir_down	int
++	O
;	O
else	O
dir_up	int
++	O
;	O
}	O
len	long
+=	O
3	int
*	O
dir_up	int
;	O
if	O
(	O
dir_down	int
)	O
{	O
down	pointer
=	O
pwd	pointer
+	O
strlen	function
(	O
pwd	pointer
)	O
-	O
1	int
;	O
while	O
(	O
dir_down	int
&&	O
down	pointer
>	O
pwd	pointer
)	O
{	O
if	O
(	O
IS_DIR_SEPARATOR	O
(	O
*	O
down	pointer
)	O
)	O
--	O
dir_down	int
;	O
}	O
BFD_ASSERT	O
(	O
dir_down	int
==	O
0	int
)	O
;	O
len	long
+=	O
strlen	function
(	O
down	pointer
)	O
+	O
1	int
;	O
}	O
else	O
down	pointer
=	O
NULL	O
;	O
if	O
(	O
len	long
>	O
pathbuf_len	int
)	O
{	O
if	O
(	O
pathbuf	pointer
!=	O
NULL	O
)	O
free	function
(	O
pathbuf	pointer
)	O
;	O
pathbuf_len	int
=	O
0	int
;	O
pathbuf	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
pathbuf	pointer
==	O
NULL	O
)	O
goto	O
out	O
;	O
pathbuf_len	int
=	O
len	long
;	O
}	O
newp	pointer
=	O
pathbuf	pointer
;	O
while	O
(	O
dir_up	int
--	O
>	O
0	int
)	O
{	O
strcpy	function
(	O
newp	pointer
,	O
"../"	pointer
)	O
;	O
newp	pointer
+=	O
3	int
;	O
}	O
if	O
(	O
down	pointer
)	O
sprintf	function
(	O
newp	pointer
,	O
"%s/%s"	pointer
,	O
down	pointer
,	O
pathp	pointer
)	O
;	O
else	O
strcpy	function
(	O
newp	pointer
,	O
pathp	pointer
)	O
;	O
out	O
:	O
free	function
(	O
lpath	pointer
)	O
;	O
free	function
(	O
rpath	pointer
)	O
;	O
return	O
pathbuf	pointer
;	O
}	O
bfd_boolean	int
_bfd_archive_bsd_construct_extended_name_table	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
*	O
tabloc	pointer
,	O
bfd_size_type	long
*	O
tablen	pointer
,	O
const	O
char	O
*	O
*	O
name	pointer
)	O
{	O
*	O
name	pointer
=	O
"ARFILENAMES/"	pointer
;	O
return	O
_bfd_construct_extended_name_table	pointer
(	O
abfd	pointer
,	O
FALSE	int
,	O
tabloc	pointer
,	O
tablen	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_archive_coff_construct_extended_name_table	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
*	O
tabloc	pointer
,	O
bfd_size_type	long
*	O
tablen	pointer
,	O
const	O
char	O
*	O
*	O
name	pointer
)	O
{	O
*	O
name	pointer
=	O
"//"	pointer
;	O
return	O
_bfd_construct_extended_name_table	pointer
(	O
abfd	pointer
,	O
TRUE	int
,	O
tabloc	pointer
,	O
tablen	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_noarchive_construct_extended_name_table	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
*	O
tabloc	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_size_type	long
*	O
len	long
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_construct_extended_name_table	pointer
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
trailing_slash	int
,	O
char	O
*	O
*	O
tabloc	pointer
,	O
bfd_size_type	long
*	O
tablen	pointer
)	O
{	O
unsigned	O
int	O
maxname	int
=	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
;	O
bfd_size_type	long
total_namelen	long
=	O
0	int
;	O
bfd	struct
*	O
current	pointer
;	O
char	O
*	O
strptr	pointer
;	O
const	O
char	O
*	O
last_filename	pointer
;	O
long	O
last_stroff	long
;	O
*	O
tablen	pointer
=	O
0	int
;	O
last_filename	pointer
=	O
NULL	O
;	O
for	O
(	O
current	pointer
=	O
abfd	pointer
->	O
archive_head	pointer
;	O
current	pointer
!=	O
NULL	O
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
)	O
{	O
const	O
char	O
*	O
normal	pointer
;	O
unsigned	O
int	O
thislen	int
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
abfd	pointer
)	O
)	O
{	O
const	O
char	O
*	O
filename	pointer
=	O
current	pointer
->	O
filename	pointer
;	O
if	O
(	O
current	pointer
->	O
my_archive	pointer
&&	O
!	O
bfd_is_thin_archive	function
(	O
current	pointer
->	O
my_archive	pointer
)	O
)	O
filename	pointer
=	O
current	pointer
->	O
my_archive	pointer
->	O
filename	pointer
;	O
if	O
(	O
last_filename	pointer
&&	O
filename_cmp	function
(	O
last_filename	pointer
,	O
filename	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
last_filename	pointer
=	O
filename	pointer
;	O
if	O
(	O
!	O
IS_ABSOLUTE_PATH	O
(	O
filename	pointer
)	O
&&	O
!	O
IS_ABSOLUTE_PATH	O
(	O
abfd	pointer
->	O
filename	pointer
)	O
)	O
normal	pointer
=	O
adjust_relative_path	function
(	O
filename	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
else	O
normal	pointer
=	O
filename	pointer
;	O
total_namelen	long
+=	O
strlen	function
(	O
normal	pointer
)	O
+	O
1	int
;	O
if	O
(	O
trailing_slash	int
)	O
++	O
total_namelen	long
;	O
continue	O
;	O
}	O
normal	pointer
=	O
normalize	function
(	O
abfd	pointer
,	O
current	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
normal	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
thislen	int
=	O
strlen	function
(	O
normal	pointer
)	O
;	O
if	O
(	O
thislen	int
>	O
maxname	int
&&	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
BFD_TRADITIONAL_FORMAT	int
)	O
!=	O
0	int
)	O
thislen	int
=	O
maxname	int
;	O
if	O
(	O
thislen	int
>	O
maxname	int
)	O
{	O
total_namelen	long
+=	O
thislen	int
+	O
1	int
;	O
if	O
(	O
trailing_slash	int
)	O
{	O
++	O
total_namelen	long
;	O
}	O
}	O
else	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
arch_hdr	O
(	O
current	pointer
)	O
;	O
if	O
(	O
filename_ncmp	function
(	O
normal	pointer
,	O
hdr	struct
->	O
ar_name	array
,	O
thislen	int
)	O
!=	O
0	int
||	O
(	O
thislen	int
<	O
sizeof	O
hdr	struct
->	O
ar_name	array
&&	O
hdr	struct
->	O
ar_name	array
[	O
thislen	int
]	O
!=	O
ar_padchar	O
(	O
current	pointer
)	O
)	O
)	O
{	O
memcpy	function
(	O
hdr	struct
->	O
ar_name	array
,	O
normal	pointer
,	O
thislen	int
)	O
;	O
if	O
(	O
thislen	int
<	O
maxname	int
||	O
(	O
thislen	int
==	O
maxname	int
&&	O
thislen	int
<	O
sizeof	O
hdr	struct
->	O
ar_name	array
)	O
)	O
hdr	struct
->	O
ar_name	array
[	O
thislen	int
]	O
=	O
ar_padchar	O
(	O
current	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
total_namelen	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
*	O
tabloc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
total_namelen	long
)	O
;	O
if	O
(	O
*	O
tabloc	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
*	O
tablen	pointer
=	O
total_namelen	long
;	O
strptr	pointer
=	O
*	O
tabloc	pointer
;	O
last_filename	pointer
=	O
NULL	O
;	O
last_stroff	long
=	O
0	int
;	O
for	O
(	O
current	pointer
=	O
abfd	pointer
->	O
archive_head	pointer
;	O
current	pointer
!=	O
NULL	O
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
)	O
{	O
const	O
char	O
*	O
normal	pointer
;	O
unsigned	O
int	O
thislen	int
;	O
long	O
stroff	long
;	O
const	O
char	O
*	O
filename	pointer
=	O
current	pointer
->	O
filename	pointer
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
current	pointer
->	O
my_archive	pointer
&&	O
!	O
bfd_is_thin_archive	function
(	O
current	pointer
->	O
my_archive	pointer
)	O
)	O
filename	pointer
=	O
current	pointer
->	O
my_archive	pointer
->	O
filename	pointer
;	O
if	O
(	O
last_filename	pointer
&&	O
filename_cmp	function
(	O
last_filename	pointer
,	O
filename	pointer
)	O
==	O
0	int
)	O
normal	pointer
=	O
last_filename	pointer
;	O
else	O
if	O
(	O
!	O
IS_ABSOLUTE_PATH	O
(	O
filename	pointer
)	O
&&	O
!	O
IS_ABSOLUTE_PATH	O
(	O
abfd	pointer
->	O
filename	pointer
)	O
)	O
normal	pointer
=	O
adjust_relative_path	function
(	O
filename	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
else	O
normal	pointer
=	O
filename	pointer
;	O
}	O
else	O
{	O
normal	pointer
=	O
normalize	function
(	O
abfd	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
normal	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
thislen	int
=	O
strlen	function
(	O
normal	pointer
)	O
;	O
if	O
(	O
thislen	int
>	O
maxname	int
||	O
bfd_is_thin_archive	function
(	O
abfd	pointer
)	O
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
arch_hdr	O
(	O
current	pointer
)	O
;	O
if	O
(	O
normal	pointer
==	O
last_filename	pointer
)	O
stroff	long
=	O
last_stroff	long
;	O
else	O
{	O
last_filename	pointer
=	O
filename	pointer
;	O
stroff	long
=	O
strptr	pointer
-	O
*	O
tabloc	pointer
;	O
last_stroff	long
=	O
stroff	long
;	O
memcpy	function
(	O
strptr	pointer
,	O
normal	pointer
,	O
thislen	int
)	O
;	O
strptr	pointer
+=	O
thislen	int
;	O
if	O
(	O
trailing_slash	int
)	O
*	O
strptr	pointer
++	O
=	O
'/'	O
;	O
*	O
strptr	pointer
++	O
=	O
ARFMAG	pointer
[	O
1	int
]	O
;	O
}	O
hdr	struct
->	O
ar_name	array
[	O
0	int
]	O
=	O
ar_padchar	O
(	O
current	pointer
)	O
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
abfd	pointer
)	O
&&	O
current	pointer
->	O
origin	long
>	O
0	int
)	O
{	O
int	O
len	long
=	O
snprintf	function
(	O
hdr	struct
->	O
ar_name	array
+	O
1	int
,	O
maxname	int
-	O
1	int
,	O
"%-ld:"	pointer
,	O
stroff	long
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_name	array
+	O
1	int
+	O
len	long
,	O
maxname	int
-	O
1	int
-	O
len	long
,	O
"%-ld"	pointer
,	O
current	pointer
->	O
origin	long
-	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
}	O
else	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_name	array
+	O
1	int
,	O
maxname	int
-	O
1	int
,	O
"%-ld"	pointer
,	O
stroff	long
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_archive_bsd44_construct_extended_name_table	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
*	O
tabloc	pointer
,	O
bfd_size_type	long
*	O
tablen	pointer
,	O
const	O
char	O
*	O
*	O
name	pointer
)	O
{	O
unsigned	O
int	O
maxname	int
=	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
;	O
bfd	struct
*	O
current	pointer
;	O
*	O
tablen	pointer
=	O
0	int
;	O
*	O
tabloc	pointer
=	O
NULL	O
;	O
*	O
name	pointer
=	O
NULL	O
;	O
for	O
(	O
current	pointer
=	O
abfd	pointer
->	O
archive_head	pointer
;	O
current	pointer
!=	O
NULL	O
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
)	O
{	O
const	O
char	O
*	O
normal	pointer
=	O
normalize	function
(	O
abfd	pointer
,	O
current	pointer
->	O
filename	pointer
)	O
;	O
int	O
has_space	int
=	O
0	int
;	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
normal	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
len	long
=	O
0	int
;	O
normal	pointer
[	O
len	long
]	O
;	O
len	long
++	O
)	O
if	O
(	O
normal	pointer
[	O
len	long
]	O
==	O
' '	O
)	O
has_space	int
=	O
1	int
;	O
if	O
(	O
len	long
>	O
maxname	int
||	O
has_space	int
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
arch_hdr	O
(	O
current	pointer
)	O
;	O
len	long
=	O
(	O
len	long
+	O
3	int
)	O
&	O
~	O
3	int
;	O
arch_eltdata	O
(	O
current	pointer
)	O
->	O
extra_size	long
=	O
len	long
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_name	array
,	O
maxname	int
,	O
"#1/%lu"	pointer
,	O
len	long
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_write_ar_hdr	function
(	O
bfd	struct
*	O
archive	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
arch_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
hdr	struct
,	O
sizeof	O
(	O
*	O
hdr	struct
)	O
,	O
archive	pointer
)	O
!=	O
sizeof	O
(	O
*	O
hdr	struct
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_bsd44_write_ar_hdr	function
(	O
bfd	struct
*	O
archive	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
arch_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
is_bsd44_extended_name	O
(	O
hdr	struct
->	O
ar_name	array
)	O
)	O
{	O
const	O
char	O
*	O
fullname	pointer
=	O
normalize	function
(	O
abfd	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
fullname	pointer
)	O
;	O
unsigned	O
int	O
padded_len	int
=	O
(	O
len	long
+	O
3	int
)	O
&	O
~	O
3	int
;	O
BFD_ASSERT	O
(	O
padded_len	int
==	O
arch_eltdata	O
(	O
abfd	pointer
)	O
->	O
extra_size	long
)	O
;	O
if	O
(	O
!	O
_bfd_ar_sizepad	function
(	O
hdr	struct
->	O
ar_size	array
,	O
sizeof	O
(	O
hdr	struct
->	O
ar_size	array
)	O
,	O
arch_eltdata	O
(	O
abfd	pointer
)	O
->	O
parsed_size	long
+	O
padded_len	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bwrite	function
(	O
hdr	struct
,	O
sizeof	O
(	O
*	O
hdr	struct
)	O
,	O
archive	pointer
)	O
!=	O
sizeof	O
(	O
*	O
hdr	struct
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bwrite	function
(	O
fullname	pointer
,	O
len	long
,	O
archive	pointer
)	O
!=	O
len	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
len	long
&	O
3	int
)	O
{	O
static	O
const	O
char	O
pad	array
[	O
3	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
len	long
=	O
4	int
-	O
(	O
len	long
&	O
3	int
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
pad	array
,	O
len	long
,	O
archive	pointer
)	O
!=	O
len	long
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
hdr	struct
,	O
sizeof	O
(	O
*	O
hdr	struct
)	O
,	O
archive	pointer
)	O
!=	O
sizeof	O
(	O
*	O
hdr	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_noarchive_write_ar_hdr	function
(	O
bfd	struct
*	O
archive	pointer
,	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
archive	pointer
)	O
;	O
}	O
static	O
struct	O
areltdata	struct
*	O
bfd_ar_hdr_from_filesystem	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
bfd	struct
*	O
member	pointer
)	O
{	O
struct	O
stat	struct
status	int
;	O
struct	O
areltdata	struct
*	O
ared	pointer
;	O
struct	O
ar_hdr	struct
*	O
hdr	struct
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
member	pointer
&&	O
(	O
member	pointer
->	O
flags	int
&	O
BFD_IN_MEMORY	int
)	O
!=	O
0	int
)	O
{	O
struct	O
bfd_in_memory	struct
*	O
bim	pointer
=	O
(	O
struct	O
bfd_in_memory	struct
*	O
)	O
member	pointer
->	O
iostream	pointer
;	O
time	struct
(	O
&	O
status	int
.	O
st_mtime	O
)	O
;	O
status	int
.	O
st_uid	int
=	O
getuid	function
(	O
)	O
;	O
status	int
.	O
st_gid	int
=	O
getgid	function
(	O
)	O
;	O
status	int
.	O
st_mode	int
=	O
0644	int
;	O
status	int
.	O
st_size	long
=	O
bim	pointer
->	O
size	long
;	O
}	O
else	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
status	int
)	O
!=	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_system_call	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_DETERMINISTIC_OUTPUT	int
)	O
!=	O
0	int
)	O
{	O
status	int
.	O
st_mtime	O
=	O
0	int
;	O
status	int
.	O
st_uid	int
=	O
0	int
;	O
status	int
.	O
st_gid	int
=	O
0	int
;	O
status	int
.	O
st_mode	int
=	O
0644	int
;	O
}	O
amt	long
=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
+	O
sizeof	O
(	O
struct	O
areltdata	struct
)	O
;	O
ared	pointer
=	O
(	O
struct	O
areltdata	struct
*	O
)	O
bfd_zmalloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
ared	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
hdr	struct
=	O
(	O
struct	O
ar_hdr	struct
*	O
)	O
(	O
(	O
(	O
char	O
*	O
)	O
ared	pointer
)	O
+	O
sizeof	O
(	O
struct	O
areltdata	struct
)	O
)	O
;	O
memset	function
(	O
hdr	struct
,	O
' '	O
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_date	array
,	O
sizeof	O
(	O
hdr	struct
->	O
ar_date	array
)	O
,	O
"%-12ld"	pointer
,	O
status	int
.	O
st_mtime	O
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_uid	array
,	O
sizeof	O
(	O
hdr	struct
->	O
ar_uid	array
)	O
,	O
"%ld"	pointer
,	O
status	int
.	O
st_uid	int
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_gid	array
,	O
sizeof	O
(	O
hdr	struct
->	O
ar_gid	array
)	O
,	O
"%ld"	pointer
,	O
status	int
.	O
st_gid	int
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
->	O
ar_mode	array
,	O
sizeof	O
(	O
hdr	struct
->	O
ar_mode	array
)	O
,	O
"%-8lo"	pointer
,	O
status	int
.	O
st_mode	int
)	O
;	O
if	O
(	O
status	int
.	O
st_size	long
-	O
(	O
bfd_size_type	long
)	O
status	int
.	O
st_size	long
!=	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_too_big	int
)	O
;	O
free	function
(	O
ared	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
_bfd_ar_sizepad	function
(	O
hdr	struct
->	O
ar_size	array
,	O
sizeof	O
(	O
hdr	struct
->	O
ar_size	array
)	O
,	O
status	int
.	O
st_size	long
)	O
)	O
{	O
free	function
(	O
ared	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	function
(	O
hdr	struct
->	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
;	O
ared	pointer
->	O
parsed_size	long
=	O
status	int
.	O
st_size	long
;	O
ared	pointer
->	O
arch_header	pointer
=	O
(	O
char	O
*	O
)	O
hdr	struct
;	O
return	O
ared	pointer
;	O
}	O
int	O
bfd_generic_stat_arch_elt	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
stat	struct
*	O
buf	pointer
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
;	O
char	O
*	O
aloser	pointer
;	O
if	O
(	O
abfd	pointer
->	O
arelt_data	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
hdr	struct
=	O
arch_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
hdr	struct
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
foo	O
(	O
ar_date	array
,	O
st_mtime	O
,	O
10	int
)	O
;	O
foo2	O
(	O
ar_uid	array
,	O
st_uid	int
,	O
10	int
)	O
;	O
foo2	O
(	O
ar_gid	array
,	O
st_gid	int
,	O
10	int
)	O
;	O
foo	O
(	O
ar_mode	array
,	O
st_mode	int
,	O
8	int
)	O
;	O
buf	pointer
->	O
st_size	long
=	O
arch_eltdata	O
(	O
abfd	pointer
)	O
->	O
parsed_size	long
;	O
return	O
0	int
;	O
}	O
void	O
bfd_dont_truncate_arname	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
pathname	pointer
,	O
char	O
*	O
arhdr	pointer
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
(	O
struct	O
ar_hdr	struct
*	O
)	O
arhdr	pointer
;	O
size_t	long
length	long
;	O
const	O
char	O
*	O
filename	pointer
;	O
size_t	long
maxlen	long
=	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
BFD_TRADITIONAL_FORMAT	int
)	O
!=	O
0	int
)	O
{	O
bfd_bsd_truncate_arname	function
(	O
abfd	pointer
,	O
pathname	pointer
,	O
arhdr	pointer
)	O
;	O
return	O
;	O
}	O
filename	pointer
=	O
normalize	function
(	O
abfd	pointer
,	O
pathname	pointer
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
length	long
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
length	long
<=	O
maxlen	long
)	O
memcpy	function
(	O
hdr	struct
->	O
ar_name	array
,	O
filename	pointer
,	O
length	long
)	O
;	O
if	O
(	O
length	long
<	O
maxlen	long
||	O
(	O
length	long
==	O
maxlen	long
&&	O
length	long
<	O
sizeof	O
hdr	struct
->	O
ar_name	array
)	O
)	O
(	O
hdr	struct
->	O
ar_name	array
)	O
[	O
length	long
]	O
=	O
ar_padchar	O
(	O
abfd	pointer
)	O
;	O
}	O
void	O
bfd_bsd_truncate_arname	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
pathname	pointer
,	O
char	O
*	O
arhdr	pointer
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
(	O
struct	O
ar_hdr	struct
*	O
)	O
arhdr	pointer
;	O
size_t	long
length	long
;	O
const	O
char	O
*	O
filename	pointer
=	O
lbasename	function
(	O
pathname	pointer
)	O
;	O
size_t	long
maxlen	long
=	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
;	O
length	long
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
length	long
<=	O
maxlen	long
)	O
memcpy	function
(	O
hdr	struct
->	O
ar_name	array
,	O
filename	pointer
,	O
length	long
)	O
;	O
else	O
{	O
memcpy	function
(	O
hdr	struct
->	O
ar_name	array
,	O
filename	pointer
,	O
maxlen	long
)	O
;	O
length	long
=	O
maxlen	long
;	O
}	O
if	O
(	O
length	long
<	O
maxlen	long
)	O
(	O
hdr	struct
->	O
ar_name	array
)	O
[	O
length	long
]	O
=	O
ar_padchar	O
(	O
abfd	pointer
)	O
;	O
}	O
void	O
bfd_gnu_truncate_arname	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
pathname	pointer
,	O
char	O
*	O
arhdr	pointer
)	O
{	O
struct	O
ar_hdr	struct
*	O
hdr	struct
=	O
(	O
struct	O
ar_hdr	struct
*	O
)	O
arhdr	pointer
;	O
size_t	long
length	long
;	O
const	O
char	O
*	O
filename	pointer
=	O
lbasename	function
(	O
pathname	pointer
)	O
;	O
size_t	long
maxlen	long
=	O
ar_maxnamelen	O
(	O
abfd	pointer
)	O
;	O
length	long
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
length	long
<=	O
maxlen	long
)	O
memcpy	function
(	O
hdr	struct
->	O
ar_name	array
,	O
filename	pointer
,	O
length	long
)	O
;	O
else	O
{	O
memcpy	function
(	O
hdr	struct
->	O
ar_name	array
,	O
filename	pointer
,	O
maxlen	long
)	O
;	O
if	O
(	O
(	O
filename	pointer
[	O
length	long
-	O
2	int
]	O
==	O
'.'	O
)	O
&&	O
(	O
filename	pointer
[	O
length	long
-	O
1	int
]	O
==	O
'o'	O
)	O
)	O
{	O
hdr	struct
->	O
ar_name	array
[	O
maxlen	long
-	O
2	int
]	O
=	O
'.'	O
;	O
hdr	struct
->	O
ar_name	array
[	O
maxlen	long
-	O
1	int
]	O
=	O
'o'	O
;	O
}	O
length	long
=	O
maxlen	long
;	O
}	O
if	O
(	O
length	long
<	O
16	int
)	O
(	O
hdr	struct
->	O
ar_name	array
)	O
[	O
length	long
]	O
=	O
ar_padchar	O
(	O
abfd	pointer
)	O
;	O
}	O
void	O
_bfd_noarchive_truncate_arname	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
pathname	pointer
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
arhdr	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
bfd_boolean	int
_bfd_write_archive_contents	function
(	O
bfd	struct
*	O
arch	enum
)	O
{	O
bfd	struct
*	O
current	pointer
;	O
char	O
*	O
etable	pointer
=	O
NULL	O
;	O
bfd_size_type	long
elength	long
=	O
0	int
;	O
const	O
char	O
*	O
ename	pointer
=	O
NULL	O
;	O
bfd_boolean	int
makemap	int
=	O
bfd_has_map	function
(	O
arch	enum
)	O
;	O
bfd_boolean	int
hasobjects	int
=	O
FALSE	int
;	O
bfd_size_type	long
wrote	long
;	O
int	O
tries	int
;	O
char	O
*	O
armag	array
;	O
for	O
(	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
current	pointer
!=	O
NULL	O
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
)	O
{	O
if	O
(	O
bfd_write_p	O
(	O
current	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
goto	O
input_err	O
;	O
}	O
if	O
(	O
!	O
current	pointer
->	O
arelt_data	pointer
)	O
{	O
current	pointer
->	O
arelt_data	pointer
=	O
bfd_ar_hdr_from_filesystem	function
(	O
arch	enum
,	O
current	pointer
->	O
filename	pointer
,	O
current	pointer
)	O
;	O
if	O
(	O
!	O
current	pointer
->	O
arelt_data	pointer
)	O
goto	O
input_err	O
;	O
BFD_SEND	O
(	O
arch	enum
,	O
_bfd_truncate_arname	pointer
,	O
(	O
arch	enum
,	O
current	pointer
->	O
filename	pointer
,	O
(	O
char	O
*	O
)	O
arch_hdr	O
(	O
current	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
makemap	int
&&	O
!	O
hasobjects	int
)	O
{	O
if	O
(	O
(	O
bfd_check_format	function
(	O
current	pointer
,	O
bfd_object	int
)	O
)	O
)	O
hasobjects	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
BFD_SEND	O
(	O
arch	enum
,	O
_bfd_construct_extended_name_table	pointer
,	O
(	O
arch	enum
,	O
&	O
etable	pointer
,	O
&	O
elength	long
,	O
&	O
ename	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_seek	function
(	O
arch	enum
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
armag	array
=	O
ARMAG	pointer
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
armag	array
=	O
ARMAGT	pointer
;	O
wrote	long
=	O
bfd_bwrite	function
(	O
armag	array
,	O
SARMAG	int
,	O
arch	enum
)	O
;	O
if	O
(	O
wrote	long
!=	O
SARMAG	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
makemap	int
&&	O
hasobjects	int
)	O
{	O
if	O
(	O
!	O
_bfd_compute_and_write_armap	function
(	O
arch	enum
,	O
(	O
unsigned	O
int	O
)	O
elength	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
elength	long
!=	O
0	int
)	O
{	O
struct	O
ar_hdr	struct
hdr	struct
;	O
memset	function
(	O
&	O
hdr	struct
,	O
' '	O
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
memcpy	function
(	O
hdr	struct
.	O
ar_name	array
,	O
ename	pointer
,	O
strlen	function
(	O
ename	pointer
)	O
)	O
;	O
if	O
(	O
!	O
_bfd_ar_sizepad	function
(	O
hdr	struct
.	O
ar_size	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_size	array
)	O
,	O
(	O
elength	long
+	O
1	int
)	O
&	O
~	O
(	O
bfd_size_type	long
)	O
1	int
)	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
hdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
;	O
if	O
(	O
(	O
bfd_bwrite	function
(	O
&	O
hdr	struct
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
,	O
arch	enum
)	O
!=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
||	O
bfd_bwrite	function
(	O
etable	pointer
,	O
elength	long
,	O
arch	enum
)	O
!=	O
elength	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
elength	long
%	O
2	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
&	O
ARFMAG	pointer
[	O
1	int
]	O
,	O
1	int
,	O
arch	enum
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
}	O
for	O
(	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
current	pointer
!=	O
NULL	O
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
)	O
{	O
char	O
buffer	pointer
[	O
DEFAULT_BUFFERSIZE	int
]	O
;	O
bfd_size_type	long
remaining	pointer
=	O
arelt_size	O
(	O
current	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_write_ar_hdr	O
(	O
arch	enum
,	O
current	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
continue	O
;	O
if	O
(	O
bfd_seek	function
(	O
current	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
goto	O
input_err	O
;	O
while	O
(	O
remaining	pointer
)	O
{	O
unsigned	O
int	O
amt	long
=	O
DEFAULT_BUFFERSIZE	int
;	O
if	O
(	O
amt	long
>	O
remaining	pointer
)	O
amt	long
=	O
remaining	pointer
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
bfd_bread	function
(	O
buffer	pointer
,	O
amt	long
,	O
current	pointer
)	O
!=	O
amt	long
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
goto	O
input_err	O
;	O
}	O
if	O
(	O
bfd_bwrite	function
(	O
buffer	pointer
,	O
amt	long
,	O
arch	enum
)	O
!=	O
amt	long
)	O
return	O
FALSE	int
;	O
remaining	pointer
-=	O
amt	long
;	O
}	O
if	O
(	O
(	O
arelt_size	O
(	O
current	pointer
)	O
%	O
2	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
&	O
ARFMAG	pointer
[	O
1	int
]	O
,	O
1	int
,	O
arch	enum
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
makemap	int
&&	O
hasobjects	int
)	O
{	O
tries	int
=	O
1	int
;	O
do	O
{	O
if	O
(	O
bfd_update_armap_timestamp	O
(	O
arch	enum
)	O
)	O
break	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: writing archive was slow: rewriting timestamp"	pointer
)	O
)	O
;	O
}	O
while	O
(	O
++	O
tries	int
<	O
6	int
)	O
;	O
}	O
return	O
TRUE	int
;	O
input_err	O
:	O
bfd_set_input_error	function
(	O
current	pointer
,	O
bfd_get_error	function
(	O
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_compute_and_write_armap	function
(	O
bfd	struct
*	O
arch	enum
,	O
unsigned	O
int	O
elength	long
)	O
{	O
char	O
*	O
first_name	pointer
=	O
NULL	O
;	O
bfd	struct
*	O
current	pointer
;	O
file_ptr	long
elt_no	long
=	O
0	int
;	O
struct	O
orl	struct
*	O
map	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
orl_max	int
=	O
1024	int
;	O
unsigned	O
int	O
orl_count	int
=	O
0	int
;	O
int	O
stridx	int
=	O
0	int
;	O
asymbol	struct
*	O
*	O
syms	pointer
=	O
NULL	O
;	O
long	O
syms_max	long
=	O
0	int
;	O
bfd_boolean	int
ret	pointer
;	O
bfd_size_type	long
amt	long
;	O
static	O
bfd_boolean	int
report_plugin_err	int
=	O
TRUE	int
;	O
if	O
(	O
elength	long
!=	O
0	int
)	O
elength	long
+=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
;	O
elength	long
+=	O
elength	long
%	O
2	int
;	O
amt	long
=	O
orl_max	int
*	O
sizeof	O
(	O
struct	O
orl	struct
)	O
;	O
map	pointer
=	O
(	O
struct	O
orl	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
map	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
first_name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
arch	enum
,	O
1	int
)	O
;	O
if	O
(	O
first_name	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
while	O
(	O
arch	enum
->	O
archive_head	pointer
&&	O
strcmp	function
(	O
arch	enum
->	O
archive_head	pointer
->	O
filename	pointer
,	O
"__.SYMDEF"	pointer
)	O
==	O
0	int
)	O
arch	enum
->	O
archive_head	pointer
=	O
arch	enum
->	O
archive_head	pointer
->	O
archive_next	pointer
;	O
for	O
(	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
current	pointer
!=	O
NULL	O
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
,	O
elt_no	long
++	O
)	O
{	O
if	O
(	O
bfd_check_format	function
(	O
current	pointer
,	O
bfd_object	int
)	O
&&	O
(	O
bfd_get_file_flags	function
(	O
current	pointer
)	O
&	O
HAS_SYMS	int
)	O
!=	O
0	int
)	O
{	O
long	O
storage	long
;	O
long	O
symcount	int
;	O
long	O
src_count	long
;	O
if	O
(	O
current	pointer
->	O
lto_slim_object	int
&&	O
report_plugin_err	int
)	O
{	O
report_plugin_err	int
=	O
FALSE	int
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: plugin needed to handle lto object"	pointer
)	O
,	O
current	pointer
)	O
;	O
}	O
storage	long
=	O
bfd_get_symtab_upper_bound	O
(	O
current	pointer
)	O
;	O
if	O
(	O
storage	long
<	O
0	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
storage	long
!=	O
0	int
)	O
{	O
if	O
(	O
storage	long
>	O
syms_max	long
)	O
{	O
if	O
(	O
syms_max	long
>	O
0	int
)	O
free	function
(	O
syms	pointer
)	O
;	O
syms_max	long
=	O
storage	long
;	O
syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
syms_max	long
)	O
;	O
if	O
(	O
syms	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
current	pointer
,	O
syms	pointer
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
goto	O
error_return	O
;	O
for	O
(	O
src_count	long
=	O
0	int
;	O
src_count	long
<	O
symcount	int
;	O
src_count	long
++	O
)	O
{	O
flagword	int
flags	int
=	O
(	O
syms	pointer
[	O
src_count	long
]	O
)	O
->	O
flags	int
;	O
asection	struct
*	O
sec	pointer
=	O
syms	pointer
[	O
src_count	long
]	O
->	O
section	pointer
;	O
if	O
(	O
(	O
(	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
|	O
BSF_INDIRECT	O
|	O
BSF_GNU_UNIQUE	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
)	O
&&	O
!	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
)	O
{	O
bfd_size_type	long
namelen	long
;	O
struct	O
orl	struct
*	O
new_map	pointer
;	O
if	O
(	O
orl_count	int
==	O
orl_max	int
)	O
{	O
orl_max	int
*=	O
2	int
;	O
amt	long
=	O
orl_max	int
*	O
sizeof	O
(	O
struct	O
orl	struct
)	O
;	O
new_map	pointer
=	O
(	O
struct	O
orl	struct
*	O
)	O
bfd_realloc	function
(	O
map	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
new_map	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
map	pointer
=	O
new_map	pointer
;	O
}	O
if	O
(	O
syms	pointer
[	O
src_count	long
]	O
->	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
syms	pointer
[	O
src_count	long
]	O
->	O
name	pointer
[	O
1	int
]	O
==	O
'_'	O
&&	O
strcmp	function
(	O
syms	pointer
[	O
src_count	long
]	O
->	O
name	pointer
+	O
(	O
syms	pointer
[	O
src_count	long
]	O
->	O
name	pointer
[	O
2	int
]	O
==	O
'_'	O
)	O
,	O
"__gnu_lto_slim"	pointer
)	O
==	O
0	int
&&	O
report_plugin_err	int
)	O
{	O
report_plugin_err	int
=	O
FALSE	int
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: plugin needed to handle lto object"	pointer
)	O
,	O
current	pointer
)	O
;	O
}	O
namelen	long
=	O
strlen	function
(	O
syms	pointer
[	O
src_count	long
]	O
->	O
name	pointer
)	O
;	O
amt	long
=	O
sizeof	O
(	O
char	O
*	O
)	O
;	O
map	pointer
[	O
orl_count	int
]	O
.	O
name	pointer
=	O
(	O
char	O
*	O
*	O
)	O
bfd_alloc	function
(	O
arch	enum
,	O
amt	long
)	O
;	O
if	O
(	O
map	pointer
[	O
orl_count	int
]	O
.	O
name	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
*	O
(	O
map	pointer
[	O
orl_count	int
]	O
.	O
name	pointer
)	O
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
arch	enum
,	O
namelen	long
+	O
1	int
)	O
;	O
if	O
(	O
*	O
(	O
map	pointer
[	O
orl_count	int
]	O
.	O
name	pointer
)	O
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
strcpy	function
(	O
*	O
(	O
map	pointer
[	O
orl_count	int
]	O
.	O
name	pointer
)	O
,	O
syms	pointer
[	O
src_count	long
]	O
->	O
name	pointer
)	O
;	O
map	pointer
[	O
orl_count	int
]	O
.	O
u	union
.	O
abfd	pointer
=	O
current	pointer
;	O
map	pointer
[	O
orl_count	int
]	O
.	O
namidx	int
=	O
stridx	int
;	O
stridx	int
+=	O
namelen	long
+	O
1	int
;	O
++	O
orl_count	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
bfd_free_cached_info	O
(	O
current	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
}	O
ret	pointer
=	O
BFD_SEND	O
(	O
arch	enum
,	O
write_armap	pointer
,	O
(	O
arch	enum
,	O
elength	long
,	O
map	pointer
,	O
orl_count	int
,	O
stridx	int
)	O
)	O
;	O
if	O
(	O
syms_max	long
>	O
0	int
)	O
free	function
(	O
syms	pointer
)	O
;	O
if	O
(	O
map	pointer
!=	O
NULL	O
)	O
free	function
(	O
map	pointer
)	O
;	O
if	O
(	O
first_name	pointer
!=	O
NULL	O
)	O
bfd_release	function
(	O
arch	enum
,	O
first_name	pointer
)	O
;	O
return	O
ret	pointer
;	O
error_return	O
:	O
if	O
(	O
syms_max	long
>	O
0	int
)	O
free	function
(	O
syms	pointer
)	O
;	O
if	O
(	O
map	pointer
!=	O
NULL	O
)	O
free	function
(	O
map	pointer
)	O
;	O
if	O
(	O
first_name	pointer
!=	O
NULL	O
)	O
bfd_release	function
(	O
arch	enum
,	O
first_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_bsd_write_armap	function
(	O
bfd	struct
*	O
arch	enum
,	O
unsigned	O
int	O
elength	long
,	O
struct	O
orl	struct
*	O
map	pointer
,	O
unsigned	O
int	O
orl_count	int
,	O
int	O
stridx	int
)	O
{	O
int	O
padit	int
=	O
stridx	int
&	O
1	int
;	O
unsigned	O
int	O
ranlibsize	int
=	O
orl_count	int
*	O
BSD_SYMDEF_SIZE	int
;	O
unsigned	O
int	O
stringsize	long
=	O
stridx	int
+	O
padit	int
;	O
unsigned	O
int	O
mapsize	int
=	O
ranlibsize	int
+	O
stringsize	long
+	O
8	int
;	O
file_ptr	long
firstreal	long
,	O
first	pointer
;	O
bfd	struct
*	O
current	pointer
;	O
bfd	struct
*	O
last_elt	pointer
;	O
bfd_byte	char
temp	pointer
[	O
4	int
]	O
;	O
unsigned	O
int	O
count	int
;	O
struct	O
ar_hdr	struct
hdr	struct
;	O
long	O
uid	long
,	O
gid	long
;	O
first	pointer
=	O
mapsize	int
+	O
elength	long
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
+	O
SARMAG	int
;	O
firstreal	long
=	O
first	pointer
;	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
last_elt	pointer
=	O
current	pointer
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
orl_count	int
;	O
count	int
++	O
)	O
{	O
unsigned	O
int	O
offset	long
;	O
if	O
(	O
map	pointer
[	O
count	int
]	O
.	O
u	union
.	O
abfd	pointer
!=	O
last_elt	pointer
)	O
{	O
do	O
{	O
struct	O
areltdata	struct
*	O
ared	pointer
=	O
arch_eltdata	O
(	O
current	pointer
)	O
;	O
firstreal	long
+=	O
(	O
ared	pointer
->	O
parsed_size	long
+	O
ared	pointer
->	O
extra_size	long
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
firstreal	long
+=	O
firstreal	long
%	O
2	int
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
;	O
}	O
while	O
(	O
current	pointer
!=	O
map	pointer
[	O
count	int
]	O
.	O
u	union
.	O
abfd	pointer
)	O
;	O
}	O
offset	long
=	O
(	O
unsigned	O
int	O
)	O
firstreal	long
;	O
if	O
(	O
firstreal	long
!=	O
(	O
file_ptr	long
)	O
offset	long
)	O
return	O
_bfd_archive_64_bit_write_armap	function
(	O
arch	enum
,	O
elength	long
,	O
map	pointer
,	O
orl_count	int
,	O
stridx	int
)	O
;	O
last_elt	pointer
=	O
current	pointer
;	O
}	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_timestamp	long
=	O
0	int
;	O
uid	long
=	O
0	int
;	O
gid	long
=	O
0	int
;	O
if	O
(	O
(	O
arch	enum
->	O
flags	int
&	O
BFD_DETERMINISTIC_OUTPUT	int
)	O
==	O
0	int
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
if	O
(	O
stat	struct
(	O
arch	enum
->	O
filename	pointer
,	O
&	O
statbuf	struct
)	O
==	O
0	int
)	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_timestamp	long
=	O
(	O
statbuf	struct
.	O
st_mtime	O
+	O
ARMAP_TIME_OFFSET	int
)	O
;	O
uid	long
=	O
getuid	function
(	O
)	O
;	O
gid	long
=	O
getgid	function
(	O
)	O
;	O
}	O
memset	function
(	O
&	O
hdr	struct
,	O
' '	O
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
memcpy	function
(	O
hdr	struct
.	O
ar_name	array
,	O
RANLIBMAG	pointer
,	O
strlen	function
(	O
RANLIBMAG	pointer
)	O
)	O
;	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_datepos	long
=	O
(	O
SARMAG	int
+	O
offsetof	O
(	O
struct	O
ar_hdr	struct
,	O
ar_date	array
[	O
0	int
]	O
)	O
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_date	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_date	array
)	O
,	O
"%ld"	pointer
,	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_timestamp	long
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_uid	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_uid	array
)	O
,	O
"%ld"	pointer
,	O
uid	long
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_gid	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_gid	array
)	O
,	O
"%ld"	pointer
,	O
gid	long
)	O
;	O
if	O
(	O
!	O
_bfd_ar_sizepad	function
(	O
hdr	struct
.	O
ar_size	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_size	array
)	O
,	O
mapsize	int
)	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
hdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
&	O
hdr	struct
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
,	O
arch	enum
)	O
!=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
return	O
FALSE	int
;	O
H_PUT_32	O
(	O
arch	enum
,	O
ranlibsize	int
,	O
temp	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
temp	pointer
,	O
sizeof	O
(	O
temp	pointer
)	O
,	O
arch	enum
)	O
!=	O
sizeof	O
(	O
temp	pointer
)	O
)	O
return	O
FALSE	int
;	O
firstreal	long
=	O
first	pointer
;	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
last_elt	pointer
=	O
current	pointer
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
orl_count	int
;	O
count	int
++	O
)	O
{	O
unsigned	O
int	O
offset	long
;	O
bfd_byte	char
buf	pointer
[	O
BSD_SYMDEF_SIZE	int
]	O
;	O
if	O
(	O
map	pointer
[	O
count	int
]	O
.	O
u	union
.	O
abfd	pointer
!=	O
last_elt	pointer
)	O
{	O
do	O
{	O
struct	O
areltdata	struct
*	O
ared	pointer
=	O
arch_eltdata	O
(	O
current	pointer
)	O
;	O
firstreal	long
+=	O
(	O
ared	pointer
->	O
parsed_size	long
+	O
ared	pointer
->	O
extra_size	long
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
firstreal	long
+=	O
firstreal	long
%	O
2	int
;	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
;	O
}	O
while	O
(	O
current	pointer
!=	O
map	pointer
[	O
count	int
]	O
.	O
u	union
.	O
abfd	pointer
)	O
;	O
}	O
offset	long
=	O
(	O
unsigned	O
int	O
)	O
firstreal	long
;	O
if	O
(	O
firstreal	long
!=	O
(	O
file_ptr	long
)	O
offset	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
last_elt	pointer
=	O
current	pointer
;	O
H_PUT_32	O
(	O
arch	enum
,	O
map	pointer
[	O
count	int
]	O
.	O
namidx	int
,	O
buf	pointer
)	O
;	O
H_PUT_32	O
(	O
arch	enum
,	O
firstreal	long
,	O
buf	pointer
+	O
BSD_SYMDEF_OFFSET_SIZE	int
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
buf	pointer
,	O
BSD_SYMDEF_SIZE	int
,	O
arch	enum
)	O
!=	O
BSD_SYMDEF_SIZE	int
)	O
return	O
FALSE	int
;	O
}	O
H_PUT_32	O
(	O
arch	enum
,	O
stringsize	long
,	O
temp	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
temp	pointer
,	O
sizeof	O
(	O
temp	pointer
)	O
,	O
arch	enum
)	O
!=	O
sizeof	O
(	O
temp	pointer
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
orl_count	int
;	O
count	int
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
*	O
map	pointer
[	O
count	int
]	O
.	O
name	pointer
)	O
+	O
1	int
;	O
if	O
(	O
bfd_bwrite	function
(	O
*	O
map	pointer
[	O
count	int
]	O
.	O
name	pointer
,	O
len	long
,	O
arch	enum
)	O
!=	O
len	long
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
padit	int
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
""	pointer
,	O
1	int
,	O
arch	enum
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_archive_bsd_update_armap_timestamp	function
(	O
bfd	struct
*	O
arch	enum
)	O
{	O
struct	O
stat	struct
archstat	struct
;	O
struct	O
ar_hdr	struct
hdr	struct
;	O
if	O
(	O
(	O
arch	enum
->	O
flags	int
&	O
BFD_DETERMINISTIC_OUTPUT	int
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
bfd_flush	function
(	O
arch	enum
)	O
;	O
if	O
(	O
bfd_stat	function
(	O
arch	enum
,	O
&	O
archstat	struct
)	O
==	O
-	O
1	int
)	O
{	O
bfd_perror	function
(	O
_	O
(	O
"Reading archive file mod timestamp"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
(	O
(	O
long	O
)	O
archstat	struct
.	O
st_mtime	O
)	O
<=	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_timestamp	long
)	O
return	O
TRUE	int
;	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_timestamp	long
=	O
archstat	struct
.	O
st_mtime	O
+	O
ARMAP_TIME_OFFSET	int
;	O
memset	function
(	O
hdr	struct
.	O
ar_date	array
,	O
' '	O
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_date	array
)	O
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_date	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_date	array
)	O
,	O
"%ld"	pointer
,	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_timestamp	long
)	O
;	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_datepos	long
=	O
(	O
SARMAG	int
+	O
offsetof	O
(	O
struct	O
ar_hdr	struct
,	O
ar_date	array
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
arch	enum
,	O
bfd_ardata	O
(	O
arch	enum
)	O
->	O
armap_datepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
(	O
bfd_bwrite	function
(	O
hdr	struct
.	O
ar_date	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_date	array
)	O
,	O
arch	enum
)	O
!=	O
sizeof	O
(	O
hdr	struct
.	O
ar_date	array
)	O
)	O
)	O
{	O
bfd_perror	function
(	O
_	O
(	O
"Writing updated armap timestamp"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_coff_write_armap	function
(	O
bfd	struct
*	O
arch	enum
,	O
unsigned	O
int	O
elength	long
,	O
struct	O
orl	struct
*	O
map	pointer
,	O
unsigned	O
int	O
symbol_count	int
,	O
int	O
stridx	int
)	O
{	O
unsigned	O
int	O
ranlibsize	int
=	O
(	O
symbol_count	int
*	O
4	int
)	O
+	O
4	int
;	O
unsigned	O
int	O
stringsize	long
=	O
stridx	int
;	O
unsigned	O
int	O
mapsize	int
=	O
stringsize	long
+	O
ranlibsize	int
;	O
file_ptr	long
archive_member_file_ptr	long
;	O
file_ptr	long
first_archive_member_file_ptr	long
;	O
bfd	struct
*	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
unsigned	O
int	O
count	int
;	O
struct	O
ar_hdr	struct
hdr	struct
;	O
int	O
padit	int
=	O
mapsize	int
&	O
1	int
;	O
if	O
(	O
padit	int
)	O
mapsize	int
++	O
;	O
first_archive_member_file_ptr	long
=	O
(	O
mapsize	int
+	O
elength	long
+	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
+	O
SARMAG	int
)	O
;	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
count	int
=	O
0	int
;	O
archive_member_file_ptr	long
=	O
first_archive_member_file_ptr	long
;	O
while	O
(	O
current	pointer
!=	O
NULL	O
&&	O
count	int
<	O
symbol_count	int
)	O
{	O
while	O
(	O
count	int
<	O
symbol_count	int
&&	O
map	pointer
[	O
count	int
]	O
.	O
u	union
.	O
abfd	pointer
==	O
current	pointer
)	O
{	O
unsigned	O
int	O
offset	long
=	O
(	O
unsigned	O
int	O
)	O
archive_member_file_ptr	long
;	O
if	O
(	O
archive_member_file_ptr	long
!=	O
(	O
file_ptr	long
)	O
offset	long
)	O
return	O
_bfd_archive_64_bit_write_armap	function
(	O
arch	enum
,	O
elength	long
,	O
map	pointer
,	O
symbol_count	int
,	O
stridx	int
)	O
;	O
count	int
++	O
;	O
}	O
archive_member_file_ptr	long
+=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
;	O
if	O
(	O
!	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
{	O
archive_member_file_ptr	long
+=	O
arelt_size	O
(	O
current	pointer
)	O
;	O
archive_member_file_ptr	long
+=	O
archive_member_file_ptr	long
%	O
2	int
;	O
}	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
;	O
}	O
memset	function
(	O
&	O
hdr	struct
,	O
' '	O
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
ar_name	array
[	O
0	int
]	O
=	O
'/'	O
;	O
if	O
(	O
!	O
_bfd_ar_sizepad	function
(	O
hdr	struct
.	O
ar_size	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_size	array
)	O
,	O
mapsize	int
)	O
)	O
return	O
FALSE	int
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_date	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_date	array
)	O
,	O
"%ld"	pointer
,	O
(	O
(	O
arch	enum
->	O
flags	int
&	O
BFD_DETERMINISTIC_OUTPUT	int
)	O
==	O
0	int
?	O
time	struct
(	O
NULL	O
)	O
:	O
0	int
)	O
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_uid	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_uid	array
)	O
,	O
"%ld"	pointer
,	O
0	int
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_gid	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_gid	array
)	O
,	O
"%ld"	pointer
,	O
0	int
)	O
;	O
_bfd_ar_spacepad	function
(	O
hdr	struct
.	O
ar_mode	array
,	O
sizeof	O
(	O
hdr	struct
.	O
ar_mode	array
)	O
,	O
"%-7lo"	pointer
,	O
0	int
)	O
;	O
memcpy	function
(	O
hdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
&	O
hdr	struct
,	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
,	O
arch	enum
)	O
!=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
bfd_write_bigendian_4byte_int	function
(	O
arch	enum
,	O
symbol_count	int
)	O
)	O
return	O
FALSE	int
;	O
current	pointer
=	O
arch	enum
->	O
archive_head	pointer
;	O
count	int
=	O
0	int
;	O
archive_member_file_ptr	long
=	O
first_archive_member_file_ptr	long
;	O
while	O
(	O
current	pointer
!=	O
NULL	O
&&	O
count	int
<	O
symbol_count	int
)	O
{	O
while	O
(	O
count	int
<	O
symbol_count	int
&&	O
map	pointer
[	O
count	int
]	O
.	O
u	union
.	O
abfd	pointer
==	O
current	pointer
)	O
{	O
unsigned	O
int	O
offset	long
=	O
(	O
unsigned	O
int	O
)	O
archive_member_file_ptr	long
;	O
if	O
(	O
archive_member_file_ptr	long
!=	O
(	O
file_ptr	long
)	O
offset	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
bfd_write_bigendian_4byte_int	function
(	O
arch	enum
,	O
offset	long
)	O
)	O
return	O
FALSE	int
;	O
count	int
++	O
;	O
}	O
archive_member_file_ptr	long
+=	O
sizeof	O
(	O
struct	O
ar_hdr	struct
)	O
;	O
if	O
(	O
!	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
{	O
archive_member_file_ptr	long
+=	O
arelt_size	O
(	O
current	pointer
)	O
;	O
archive_member_file_ptr	long
+=	O
archive_member_file_ptr	long
%	O
2	int
;	O
}	O
current	pointer
=	O
current	pointer
->	O
archive_next	pointer
;	O
}	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
symbol_count	int
;	O
count	int
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
*	O
map	pointer
[	O
count	int
]	O
.	O
name	pointer
)	O
+	O
1	int
;	O
if	O
(	O
bfd_bwrite	function
(	O
*	O
map	pointer
[	O
count	int
]	O
.	O
name	pointer
,	O
len	long
,	O
arch	enum
)	O
!=	O
len	long
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
padit	int
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
""	pointer
,	O
1	int
,	O
arch	enum
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_noarchive_write_armap	function
(	O
bfd	struct
*	O
arch	enum
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
int	O
elength	long
ATTRIBUTE_UNUSED	O
,	O
struct	O
orl	struct
*	O
map	pointer
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
int	O
orl_count	int
ATTRIBUTE_UNUSED	O
,	O
int	O
stridx	int
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
archive_close_worker	function
(	O
void	O
*	O
*	O
slot	pointer
,	O
void	O
*	O
inf	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
ar_cache	struct
*	O
ent	pointer
=	O
(	O
struct	O
ar_cache	struct
*	O
)	O
*	O
slot	pointer
;	O
bfd_close_all_done	function
(	O
ent	pointer
->	O
arbfd	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
_bfd_unlink_from_archive_parent	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
arch_eltdata	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
{	O
struct	O
areltdata	struct
*	O
ared	pointer
=	O
arch_eltdata	O
(	O
abfd	pointer
)	O
;	O
htab_t	pointer
htab	struct
=	O
(	O
htab_t	pointer
)	O
ared	pointer
->	O
parent_cache	pointer
;	O
if	O
(	O
htab	struct
)	O
{	O
struct	O
ar_cache	struct
ent	pointer
;	O
void	O
*	O
*	O
slot	pointer
;	O
ent	pointer
.	O
ptr	pointer
=	O
ared	pointer
->	O
key	long
;	O
slot	pointer
=	O
htab_find_slot	function
(	O
htab	struct
,	O
&	O
ent	pointer
,	O
NO_INSERT	int
)	O
;	O
if	O
(	O
slot	pointer
!=	O
NULL	O
)	O
{	O
BFD_ASSERT	O
(	O
(	O
(	O
struct	O
ar_cache	struct
*	O
)	O
*	O
slot	pointer
)	O
->	O
arbfd	pointer
==	O
abfd	pointer
)	O
;	O
htab_clear_slot	function
(	O
htab	struct
,	O
slot	pointer
)	O
;	O
}	O
}	O
}	O
}	O
bfd_boolean	int
_bfd_archive_close_and_cleanup	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
bfd_read_p	O
(	O
abfd	pointer
)	O
&&	O
abfd	pointer
->	O
format	enum
==	O
bfd_archive	int
)	O
{	O
bfd	struct
*	O
nbfd	pointer
;	O
bfd	struct
*	O
next	pointer
;	O
htab_t	pointer
htab	struct
;	O
for	O
(	O
nbfd	pointer
=	O
abfd	pointer
->	O
nested_archives	pointer
;	O
nbfd	pointer
;	O
nbfd	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
nbfd	pointer
->	O
archive_next	pointer
;	O
bfd_close	function
(	O
nbfd	pointer
)	O
;	O
}	O
htab	struct
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
cache	pointer
;	O
if	O
(	O
htab	struct
)	O
{	O
htab_traverse_noresize	function
(	O
htab	struct
,	O
archive_close_worker	function
,	O
NULL	O
)	O
;	O
htab_delete	function
(	O
htab	struct
)	O
;	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
cache	pointer
=	O
NULL	O
;	O
}	O
}	O
_bfd_unlink_from_archive_parent	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
abfd	pointer
->	O
is_linker_output	int
)	O
(	O
*	O
abfd	pointer
->	O
link	function
.	O
hash	long
->	O
hash_table_free	pointer
)	O
(	O
abfd	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
