MAV_class	O
*	O
mav_class_lcity	pointer
;	O
int	O
apply_lod	int
=	O
1	int
;	O
GLfloat	O
fogColour	array
[	O
4	int
]	O
=	O
{	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
}	O
;	O
int	O
white_index	int
;	O
int	O
current_feature	int
=	O
-	O
1	int
;	O
MAV_surfaceParams	O
*	O
sky	pointer
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
lcfloor	pointer
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
tranny	pointer
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
map_white	pointer
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
grass	pointer
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
canal	pointer
=	O
NULL	O
;	O
MAV_surfaceParams	O
*	O
stone	pointer
=	O
NULL	O
;	O
float	O
map_scale	float
=	O
0.11	int
;	O
int	O
drawMap	int
=	O
1	int
;	O
MAV_class	O
*	O
mav_class_character	pointer
;	O
MAV_class	O
*	O
mav_class_feature	pointer
;	O
MAV_class	O
*	O
mav_class_vector	pointer
;	O
MAV_BB	O
city_bb	int
;	O
MAV_SMS	O
*	O
city_build	pointer
;	O
MAV_SMS	O
*	O
city_sms	pointer
;	O
MAV_SMS	O
*	O
city_map	pointer
;	O
Alphabet	O
alphabet	array
[	O
255	int
]	O
;	O
static	O
int	O
citycount	int
;	O
static	O
float	O
comx	array
[	O
3	int
]	O
,	O
comy	array
[	O
3	int
]	O
;	O
static	O
char	O
basefilename	array
[	O
3	int
]	O
[	O
80	int
]	O
=	O
{	O
"manhattan"	pointer
,	O
"amsterdam"	pointer
,	O
"karlsruhe"	pointer
}	O
;	O
static	O
float	O
cityangle	array
[	O
3	int
]	O
=	O
{	O
0.0	int
,	O
-	O
90.0	int
,	O
-	O
200.0	int
}	O
;	O
static	O
float	O
angle	float
,	O
cangle	float
,	O
sangle	float
;	O
static	O
int	O
num_polygons	int
;	O
static	O
int	O
ascii	array
[	O
NUM_LETTERS	int
]	O
=	O
{	O
33	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
61	int
,	O
63	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
69	int
,	O
70	int
,	O
71	int
,	O
72	int
,	O
73	int
,	O
74	int
,	O
75	int
,	O
76	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
81	int
,	O
82	int
,	O
83	int
,	O
84	int
,	O
85	int
,	O
86	int
,	O
87	int
,	O
88	int
,	O
89	int
,	O
90	int
,	O
96	int
,	O
128	int
,	O
130	int
,	O
131	int
,	O
133	int
,	O
136	int
,	O
138	int
,	O
140	int
,	O
141	int
,	O
142	int
,	O
147	int
,	O
149	int
,	O
150	int
,	O
151	int
,	O
153	int
,	O
154	int
,	O
225	int
}	O
;	O
static	O
float	O
letter_widths	array
[	O
NUM_LETTERS	int
+	O
1	int
]	O
[	O
2	int
]	O
=	O
{	O
{	O
32.0	int
,	O
0.8	int
}	O
,	O
{	O
33.0	int
,	O
0.3277	int
}	O
,	O
{	O
38.0	int
,	O
1.0217	int
}	O
,	O
{	O
39.0	int
,	O
0.2121	int
}	O
,	O
{	O
40.0	int
,	O
0.3374	int
}	O
,	O
{	O
41.0	int
,	O
0.3374	int
}	O
,	O
{	O
44.0	int
,	O
0.2313	int
}	O
,	O
{	O
45.0	int
,	O
0.6169	int
}	O
,	O
{	O
46.0	int
,	O
0.2313	int
}	O
,	O
{	O
47.0	int
,	O
0.7615	int
}	O
,	O
{	O
48.0	int
,	O
0.7615	int
}	O
,	O
{	O
49.0	int
,	O
0.5783	int
}	O
,	O
{	O
50.0	int
,	O
0.7615	int
}	O
,	O
{	O
51.0	int
,	O
0.6458	int
}	O
,	O
{	O
52.0	int
,	O
0.9350	int
}	O
,	O
{	O
53.0	int
,	O
0.7711	int
}	O
,	O
{	O
54.0	int
,	O
0.7615	int
}	O
,	O
{	O
55.0	int
,	O
0.6651	int
}	O
,	O
{	O
56.0	int
,	O
0.7615	int
}	O
,	O
{	O
57.0	int
,	O
0.7615	int
}	O
,	O
{	O
58.0	int
,	O
0.2313	int
}	O
,	O
{	O
61.0	int
,	O
0.6169	int
}	O
,	O
{	O
63.0	int
,	O
0.7615	int
}	O
,	O
{	O
65.0	int
,	O
0.8000	int
}	O
,	O
{	O
66.0	int
,	O
0.7615	int
}	O
,	O
{	O
67.0	int
,	O
0.7615	int
}	O
,	O
{	O
68.0	int
,	O
0.7615	int
}	O
,	O
{	O
69.0	int
,	O
0.6169	int
}	O
,	O
{	O
70.0	int
,	O
0.5783	int
}	O
,	O
{	O
71.0	int
,	O
0.7615	int
}	O
,	O
{	O
72.0	int
,	O
0.7615	int
}	O
,	O
{	O
73.0	int
,	O
0.2410	int
}	O
,	O
{	O
74.0	int
,	O
0.7615	int
}	O
,	O
{	O
75.0	int
,	O
0.8000	int
}	O
,	O
{	O
76.0	int
,	O
0.5494	int
}	O
,	O
{	O
77.0	int
,	O
1.0217	int
}	O
,	O
{	O
78.0	int
,	O
0.8000	int
}	O
,	O
{	O
79.0	int
,	O
0.7615	int
}	O
,	O
{	O
80.0	int
,	O
0.7615	int
}	O
,	O
{	O
81.0	int
,	O
0.8771	int
}	O
,	O
{	O
82.0	int
,	O
0.7615	int
}	O
,	O
{	O
83.0	int
,	O
0.7615	int
}	O
,	O
{	O
84.0	int
,	O
0.8675	int
}	O
,	O
{	O
85.0	int
,	O
0.7615	int
}	O
,	O
{	O
86.0	int
,	O
0.8000	int
}	O
,	O
{	O
87.0	int
,	O
1.3302	int
}	O
,	O
{	O
88.0	int
,	O
0.8964	int
}	O
,	O
{	O
89.0	int
,	O
0.7904	int
}	O
,	O
{	O
90.0	int
,	O
0.6651	int
}	O
,	O
{	O
96.0	int
,	O
0.2121	int
}	O
,	O
{	O
128.0	int
,	O
0.7615	int
}	O
,	O
{	O
130.0	int
,	O
0.6169	int
}	O
,	O
{	O
131.0	int
,	O
0.8000	int
}	O
,	O
{	O
133.0	int
,	O
0.8000	int
}	O
,	O
{	O
136.0	int
,	O
0.6169	int
}	O
,	O
{	O
138.0	int
,	O
0.6169	int
}	O
,	O
{	O
140.0	int
,	O
0.6169	int
}	O
,	O
{	O
141.0	int
,	O
0.2410	int
}	O
,	O
{	O
142.0	int
,	O
0.8000	int
}	O
,	O
{	O
147.0	int
,	O
0.7615	int
}	O
,	O
{	O
149.0	int
,	O
0.7615	int
}	O
,	O
{	O
150.0	int
,	O
0.7615	int
}	O
,	O
{	O
151.0	int
,	O
0.7615	int
}	O
,	O
{	O
153.0	int
,	O
0.7615	int
}	O
,	O
{	O
154.0	int
,	O
0.7615	int
}	O
,	O
{	O
225.0	int
,	O
0.7615	int
}	O
}	O
;	O
int	O
pnpoly	function
(	O
int	O
npol	int
,	O
float	O
*	O
xp	pointer
,	O
float	O
*	O
yp	pointer
,	O
float	O
x	float
,	O
float	O
y	float
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
yp	pointer
[	O
i	int
]	O
<=	O
y	float
)	O
&&	O
(	O
y	float
<	O
yp	pointer
[	O
j	int
]	O
)	O
)	O
||	O
(	O
(	O
yp	pointer
[	O
j	int
]	O
<=	O
y	float
)	O
&&	O
(	O
y	float
<	O
yp	pointer
[	O
i	int
]	O
)	O
)	O
)	O
&&	O
(	O
x	float
<	O
(	O
xp	pointer
[	O
j	int
]	O
-	O
xp	pointer
[	O
i	int
]	O
)	O
*	O
(	O
y	float
-	O
yp	pointer
[	O
i	int
]	O
)	O
/	O
(	O
yp	pointer
[	O
j	int
]	O
-	O
yp	pointer
[	O
i	int
]	O
)	O
+	O
xp	pointer
[	O
i	int
]	O
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
int	O
testpoly_xy	function
(	O
int	O
npol	int
,	O
MAV_vector	O
*	O
polyverts	pointer
,	O
MAV_vector	O
testpoint	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
polyverts	pointer
[	O
i	int
]	O
.	O
y	float
<=	O
testpoint	int
.	O
y	float
)	O
&&	O
(	O
testpoint	int
.	O
y	float
<	O
polyverts	pointer
[	O
j	int
]	O
.	O
y	float
)	O
)	O
||	O
(	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
y	float
<=	O
testpoint	int
.	O
y	float
)	O
&&	O
(	O
testpoint	int
.	O
y	float
<	O
polyverts	pointer
[	O
i	int
]	O
.	O
y	float
)	O
)	O
)	O
&&	O
(	O
testpoint	int
.	O
x	float
<	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
x	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
x	float
)	O
*	O
(	O
testpoint	int
.	O
y	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
y	float
)	O
/	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
y	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
y	float
)	O
+	O
polyverts	pointer
[	O
i	int
]	O
.	O
x	float
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
int	O
testpoly_xz	function
(	O
int	O
npol	int
,	O
MAV_vector	O
*	O
polyverts	pointer
,	O
MAV_vector	O
testpoint	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	pointer
[	O
j	int
]	O
.	O
z	float
)	O
)	O
||	O
(	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
)	O
)	O
)	O
&&	O
(	O
testpoint	int
.	O
x	float
<	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
x	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
x	float
)	O
*	O
(	O
testpoint	int
.	O
z	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
)	O
/	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
z	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
)	O
+	O
polyverts	pointer
[	O
i	int
]	O
.	O
x	float
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
int	O
testpoly_yz	function
(	O
int	O
npol	int
,	O
MAV_vector	O
*	O
polyverts	pointer
,	O
MAV_vector	O
testpoint	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
npol	int
-	O
1	int
;	O
i	int
<	O
npol	int
;	O
j	int
=	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
(	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	pointer
[	O
j	int
]	O
.	O
z	float
)	O
)	O
||	O
(	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
z	float
<=	O
testpoint	int
.	O
z	float
)	O
&&	O
(	O
testpoint	int
.	O
z	float
<	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
)	O
)	O
)	O
&&	O
(	O
testpoint	int
.	O
y	float
<	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
y	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
y	float
)	O
*	O
(	O
testpoint	int
.	O
z	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
)	O
/	O
(	O
polyverts	pointer
[	O
j	int
]	O
.	O
z	float
-	O
polyverts	pointer
[	O
i	int
]	O
.	O
z	float
)	O
+	O
polyverts	pointer
[	O
i	int
]	O
.	O
y	float
)	O
)	O
{	O
c	int
=	O
!	O
c	int
;	O
}	O
}	O
return	O
c	int
;	O
}	O
void	O
LineCircleIntersect	function
(	O
float	O
xp	pointer
,	O
float	O
yp	pointer
,	O
float	O
xc	float
,	O
float	O
yc	float
,	O
float	O
r	float
,	O
float	O
*	O
x	float
,	O
float	O
*	O
y	float
)	O
{	O
float	O
angle	float
;	O
angle	float
=	O
atan2	O
(	O
(	O
yp	pointer
-	O
yc	float
)	O
,	O
(	O
xp	pointer
-	O
xc	float
)	O
)	O
;	O
*	O
x	float
=	O
xc	float
+	O
r	float
*	O
cos	O
(	O
angle	float
)	O
;	O
*	O
y	float
=	O
yc	float
+	O
r	float
*	O
sin	O
(	O
angle	float
)	O
;	O
}	O
int	O
keep_inside_bounds	function
(	O
MAV_vector	O
*	O
location	pointer
)	O
{	O
float	O
dx	float
,	O
dz	float
;	O
float	O
radius	float
;	O
float	O
x	float
,	O
z	float
,	O
newx	float
=	O
0	int
,	O
newz	float
=	O
0	int
,	O
d	float
,	O
dmin	float
;	O
dx	float
=	O
location	pointer
->	O
x	float
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
;	O
radius	float
=	O
RIM	int
*	O
global_city_mre	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
centx	O
[	O
0	int
]	O
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
centy	O
[	O
0	int
]	O
;	O
radius	float
=	O
RIM	int
*	O
city_mre	O
[	O
0	int
]	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
centx	O
[	O
1	int
]	O
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
centy	O
[	O
1	int
]	O
;	O
radius	float
=	O
RIM	int
*	O
city_mre	O
[	O
1	int
]	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
centx	O
[	O
2	int
]	O
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
centy	O
[	O
2	int
]	O
;	O
radius	float
=	O
RIM	int
*	O
city_mre	O
[	O
2	int
]	O
;	O
if	O
(	O
(	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
)	O
<	O
(	O
radius	float
*	O
radius	float
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
dmin	float
=	O
1.0e20	int
;	O
LineCircleIntersect	function
(	O
location	pointer
->	O
x	float
,	O
-	O
location	pointer
->	O
z	float
,	O
0.0	int
,	O
0.0	int
,	O
global_city_mre	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
dmin	float
=	O
d	float
;	O
}	O
LineCircleIntersect	function
(	O
location	pointer
->	O
x	float
,	O
-	O
location	pointer
->	O
z	float
,	O
centx	O
[	O
0	int
]	O
,	O
centy	O
[	O
0	int
]	O
,	O
city_mre	O
[	O
0	int
]	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
dmin	float
=	O
d	float
;	O
}	O
LineCircleIntersect	function
(	O
location	pointer
->	O
x	float
,	O
-	O
location	pointer
->	O
z	float
,	O
centx	O
[	O
1	int
]	O
,	O
centy	O
[	O
1	int
]	O
,	O
city_mre	O
[	O
1	int
]	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
dmin	float
=	O
d	float
;	O
}	O
LineCircleIntersect	function
(	O
location	pointer
->	O
x	float
,	O
-	O
location	pointer
->	O
z	float
,	O
centx	O
[	O
2	int
]	O
,	O
centy	O
[	O
2	int
]	O
,	O
city_mre	O
[	O
2	int
]	O
,	O
&	O
x	float
,	O
&	O
z	float
)	O
;	O
dx	float
=	O
location	pointer
->	O
x	float
-	O
x	float
;	O
dz	float
=	O
-	O
location	pointer
->	O
z	float
-	O
z	float
;	O
d	float
=	O
dx	float
*	O
dx	float
+	O
dz	float
*	O
dz	float
;	O
if	O
(	O
d	float
<	O
dmin	float
)	O
{	O
newx	float
=	O
x	float
;	O
newz	float
=	O
z	float
;	O
}	O
location	pointer
->	O
x	float
=	O
newx	float
;	O
location	pointer
->	O
z	float
=	O
-	O
newz	float
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
mav_characterDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
{	O
Character	O
*	O
c	int
=	O
(	O
Character	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
MAV_vector	O
dr	O
;	O
float	O
dist	float
;	O
int	O
i	int
,	O
j	int
;	O
dr	O
=	O
mav_vectorSub	function
(	O
c	int
->	O
centre	O
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
)	O
;	O
dist	float
=	O
sqrt	O
(	O
mav_vectorDotProduct	function
(	O
dr	O
,	O
dr	O
)	O
)	O
;	O
if	O
(	O
apply_lod	int
)	O
{	O
if	O
(	O
dist	float
<	O
fog_distance	int
)	O
{	O
mav_surfaceParamsUse	function
(	O
c	int
->	O
sp	pointer
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
c	int
->	O
matrix	O
)	O
;	O
if	O
(	O
dist	float
<	O
box_distance	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
c	int
->	O
character	O
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
mav_gfxPolygonBegin	function
(	O
)	O
;	O
mav_gfxNormal	function
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
normal	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
;	O
j	int
++	O
)	O
mav_gfxVertex	function
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
)	O
;	O
mav_gfxPolygonEnd	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
mav_BBDrawWithSurfaceParams	function
(	O
mav_win_current	O
,	O
c	int
->	O
character	O
->	O
bb	pointer
,	O
c	int
->	O
sp	pointer
)	O
;	O
}	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
mav_surfaceParamsUse	function
(	O
c	int
->	O
sp	pointer
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
c	int
->	O
matrix	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
c	int
->	O
character	O
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
mav_gfxPolygonBegin	function
(	O
)	O
;	O
mav_gfxNormal	function
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
normal	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
;	O
j	int
++	O
)	O
mav_gfxVertex	function
(	O
c	int
->	O
character	O
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
)	O
;	O
mav_gfxPolygonEnd	function
(	O
)	O
;	O
}	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
mav_characterBBox	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_BB	O
*	O
bb	pointer
)	O
{	O
Character	O
*	O
c	int
=	O
(	O
Character	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
mav_BBAlign	function
(	O
c	int
->	O
character	O
->	O
bb	pointer
,	O
c	int
->	O
matrix	O
,	O
bb	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mav_subdivideDraw	function
(	O
MAV_vector	O
a	int
,	O
MAV_vector	O
b	int
,	O
MAV_vector	O
c	int
)	O
{	O
float	O
l1	float
,	O
l2	float
,	O
l3	float
;	O
l1	float
=	O
fabs	O
(	O
mav_vectorDotProduct	function
(	O
mav_vectorSub	function
(	O
b	int
,	O
a	int
)	O
,	O
mav_vectorSub	function
(	O
b	int
,	O
a	int
)	O
)	O
)	O
;	O
l2	float
=	O
fabs	O
(	O
mav_vectorDotProduct	function
(	O
mav_vectorSub	function
(	O
c	int
,	O
a	int
)	O
,	O
mav_vectorSub	function
(	O
c	int
,	O
a	int
)	O
)	O
)	O
;	O
l3	float
=	O
fabs	O
(	O
mav_vectorDotProduct	function
(	O
mav_vectorSub	function
(	O
b	int
,	O
c	int
)	O
,	O
mav_vectorSub	function
(	O
b	int
,	O
c	int
)	O
)	O
)	O
;	O
if	O
(	O
l1	float
>	O
SQUARE_THING	int
||	O
l2	float
>	O
SQUARE_THING	int
||	O
l3	float
>	O
SQUARE_THING	int
)	O
{	O
MAV_vector	O
ab	O
=	O
mav_vectorScalar	function
(	O
mav_vectorAdd	function
(	O
a	int
,	O
b	int
)	O
,	O
0.5	int
)	O
;	O
MAV_vector	O
ac	O
=	O
mav_vectorScalar	function
(	O
mav_vectorAdd	function
(	O
a	int
,	O
c	int
)	O
,	O
0.5	int
)	O
;	O
MAV_vector	O
bc	O
=	O
mav_vectorScalar	function
(	O
mav_vectorAdd	function
(	O
b	int
,	O
c	int
)	O
,	O
0.5	int
)	O
;	O
mav_subdivideDraw	function
(	O
a	int
,	O
ab	O
,	O
ac	O
)	O
;	O
mav_subdivideDraw	function
(	O
ab	O
,	O
bc	O
,	O
ac	O
)	O
;	O
mav_subdivideDraw	function
(	O
ab	O
,	O
b	int
,	O
bc	O
)	O
;	O
mav_subdivideDraw	function
(	O
ac	O
,	O
bc	O
,	O
c	int
)	O
;	O
}	O
else	O
{	O
MAV_texCoord	O
t	O
;	O
t	O
.	O
s	O
=	O
a	int
.	O
x	float
/	O
TEX_GRID_SCALE	int
;	O
t	O
.	O
t	O
=	O
a	int
.	O
z	float
/	O
TEX_GRID_SCALE	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
mav_gfxVertex	function
(	O
a	int
)	O
;	O
t	O
.	O
s	O
=	O
b	int
.	O
x	float
/	O
TEX_GRID_SCALE	int
;	O
t	O
.	O
t	O
=	O
b	int
.	O
z	float
/	O
TEX_GRID_SCALE	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
mav_gfxVertex	function
(	O
b	int
)	O
;	O
t	O
.	O
s	O
=	O
c	int
.	O
x	float
/	O
TEX_GRID_SCALE	int
;	O
t	O
.	O
t	O
=	O
c	int
.	O
z	float
/	O
TEX_GRID_SCALE	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
mav_gfxVertex	function
(	O
c	int
)	O
;	O
}	O
}	O
int	O
mav_featureDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
{	O
Feature	O
*	O
f	int
=	O
(	O
Feature	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
int	O
i	int
;	O
MAV_vector	O
dr	O
;	O
float	O
dist	float
;	O
dr	O
=	O
mav_vectorSub	function
(	O
f	int
->	O
center	O
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
)	O
;	O
dist	float
=	O
sqrt	O
(	O
mav_vectorDotProduct	function
(	O
dr	O
,	O
dr	O
)	O
)	O
-	O
f	int
->	O
radius	float
;	O
if	O
(	O
dist	float
<	O
fog_distance	int
)	O
{	O
if	O
(	O
testpoly_xz	function
(	O
f	int
->	O
npoints	O
,	O
f	int
->	O
verts	O
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
)	O
)	O
{	O
current_feature	int
=	O
f	int
->	O
type	int
;	O
}	O
mav_surfaceParamsUse	function
(	O
f	int
->	O
sp	pointer
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
f	int
->	O
matrix	O
)	O
;	O
glBegin	function
(	O
GL_TRIANGLES	O
)	O
;	O
glNormal3f	function
(	O
0	int
,	O
1	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
f	int
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
mav_subdivideDraw	function
(	O
f	int
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
0	int
]	O
,	O
f	int
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
1	int
]	O
,	O
f	int
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
2	int
]	O
)	O
;	O
}	O
glEnd	function
(	O
)	O
;	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
mav_featureBBox	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_BB	O
*	O
bb	pointer
)	O
{	O
Feature	O
*	O
f	int
=	O
(	O
Feature	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
mav_BBAlign	function
(	O
f	int
->	O
bb	pointer
,	O
f	int
->	O
matrix	O
,	O
bb	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_vectorDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
{	O
Vector	O
*	O
v	pointer
=	O
(	O
Vector	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
if	O
(	O
drawMap	int
)	O
{	O
mav_surfaceParamsUse	function
(	O
map_white	pointer
)	O
;	O
}	O
else	O
{	O
mav_surfaceParamsUse	function
(	O
v	pointer
->	O
sp	pointer
)	O
;	O
}	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
v	pointer
->	O
matrix	O
)	O
;	O
mav_gfxLineBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
v	pointer
->	O
start	O
)	O
;	O
mav_gfxVertex	function
(	O
v	pointer
->	O
end	O
)	O
;	O
mav_gfxLineEnd	function
(	O
)	O
;	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_vectorBBox	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_BB	O
*	O
bb	pointer
)	O
{	O
Vector	O
*	O
v	pointer
=	O
(	O
Vector	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
mav_BBAlign	function
(	O
v	pointer
->	O
bb	pointer
,	O
v	pointer
->	O
matrix	O
,	O
bb	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
Make_Font	function
(	O
void	O
)	O
{	O
MAV_vector	O
r0	O
,	O
r1	O
,	O
*	O
verts	O
;	O
FILE	struct
*	O
file	pointer
;	O
char	O
filename	array
[	O
100	int
]	O
;	O
int	O
i	int
,	O
j	int
,	O
l	int
,	O
c	int
,	O
num_verts	int
,	O
index	array
[	O
100	int
]	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
NUM_LETTERS	int
+	O
1	int
;	O
l	int
++	O
)	O
alphabet	array
[	O
(	O
int	O
)	O
(	O
letter_widths	array
[	O
l	int
]	O
[	O
0	int
]	O
)	O
]	O
.	O
letter_width	float
=	O
letter_widths	array
[	O
l	int
]	O
[	O
1	int
]	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
NUM_LETTERS	int
;	O
l	int
++	O
)	O
{	O
c	int
=	O
ascii	array
[	O
l	int
]	O
;	O
sprintf	function
(	O
filename	array
,	O
"./data/font/%d.cdat"	pointer
,	O
c	int
)	O
;	O
file	pointer
=	O
fopen	function
(	O
filename	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to open font file %s\n"	pointer
,	O
filename	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
num_verts	int
)	O
;	O
verts	O
=	O
mav_malloc	function
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_verts	int
;	O
j	int
++	O
)	O
fscanf	function
(	O
file	pointer
,	O
"%g %g %g"	pointer
,	O
&	O
verts	O
[	O
j	int
]	O
.	O
x	float
,	O
&	O
verts	O
[	O
j	int
]	O
.	O
y	float
,	O
&	O
verts	O
[	O
j	int
]	O
.	O
z	float
)	O
;	O
mav_BBCompInit	function
(	O
&	O
alphabet	array
[	O
c	int
]	O
.	O
bb	pointer
)	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
alphabet	array
[	O
c	int
]	O
.	O
num_polys	O
)	O
;	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
=	O
mav_malloc	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
num_polys	O
*	O
sizeof	O
(	O
LC_Polygon	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
alphabet	array
[	O
c	int
]	O
.	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
num_verts	int
=	O
0	int
;	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
index	array
[	O
num_verts	int
]	O
)	O
;	O
while	O
(	O
index	array
[	O
num_verts	int
]	O
!=	O
-	O
1	int
)	O
{	O
num_verts	int
++	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
index	array
[	O
num_verts	int
]	O
)	O
;	O
}	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
=	O
num_verts	int
;	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
=	O
mav_malloc	function
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_verts	int
;	O
j	int
++	O
)	O
{	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
=	O
verts	O
[	O
index	array
[	O
j	int
]	O
]	O
;	O
mav_BBCompPt	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
j	int
]	O
,	O
&	O
alphabet	array
[	O
c	int
]	O
.	O
bb	pointer
)	O
;	O
}	O
r0	O
=	O
mav_vectorNormalize	function
(	O
mav_vectorSub	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
2	int
]	O
,	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
1	int
]	O
)	O
)	O
;	O
r1	O
=	O
mav_vectorNormalize	function
(	O
mav_vectorSub	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
0	int
]	O
,	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
verts	O
[	O
1	int
]	O
)	O
)	O
;	O
alphabet	array
[	O
c	int
]	O
.	O
polys	O
[	O
i	int
]	O
.	O
normal	O
=	O
mav_vectorNormalize	function
(	O
mav_vectorCrossProduct	function
(	O
r0	O
,	O
r1	O
)	O
)	O
;	O
}	O
mav_free	function
(	O
verts	O
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
}	O
Feature	O
*	O
feature	pointer
;	O
int	O
feature_vertices	int
;	O
typedef	O
void	O
(	O
CALLBACK	O
*	O
MAVLIB_GLUCB	pointer
)	O
(	O
)	O
;	O
void	O
CALLBACK	O
my_begin	function
(	O
GLenum	O
mode	int
)	O
{	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
num_verts	int
=	O
3	int
;	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
verts	O
=	O
mav_malloc	function
(	O
3	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
num_verts	int
=	O
0	int
;	O
}	O
void	O
CALLBACK	O
my_error	function
(	O
GLenum	O
en	int
)	O
{	O
printf	function
(	O
"GLU error: %i\n"	pointer
,	O
en	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
CALLBACK	O
my_vertex	function
(	O
void	O
*	O
v	pointer
)	O
{	O
MAV_vector	O
r0	O
,	O
r1	O
;	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
verts	O
[	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
num_verts	int
]	O
=	O
*	O
(	O
(	O
MAV_vector	O
*	O
)	O
v	pointer
)	O
;	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
num_verts	int
++	O
;	O
if	O
(	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
num_verts	int
==	O
3	int
)	O
{	O
r0	O
=	O
mav_vectorSub	function
(	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
verts	O
[	O
1	int
]	O
,	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
verts	O
[	O
0	int
]	O
)	O
;	O
r1	O
=	O
mav_vectorSub	function
(	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
verts	O
[	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
num_verts	int
-	O
1	int
]	O
,	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
verts	O
[	O
0	int
]	O
)	O
;	O
feature	pointer
->	O
polys	O
[	O
feature	pointer
->	O
num_polys	O
]	O
.	O
normal	O
=	O
mav_vectorNormalize	function
(	O
mav_vectorCrossProduct	function
(	O
r0	O
,	O
r1	O
)	O
)	O
;	O
feature	pointer
->	O
num_polys	O
++	O
;	O
}	O
}	O
void	O
CALLBACK	O
dummyedge	function
(	O
GLboolean	O
f	int
)	O
{	O
}	O
void	O
CALLBACK	O
count_polygons	function
(	O
void	O
*	O
ignored	pointer
)	O
{	O
feature_vertices	int
++	O
;	O
if	O
(	O
feature_vertices	int
==	O
3	int
)	O
{	O
feature	pointer
->	O
num_polys	O
++	O
;	O
feature_vertices	int
=	O
0	int
;	O
}	O
}	O
void	O
CALLBACK	O
dummybegin	function
(	O
GLenum	O
mode	int
)	O
{	O
}	O
void	O
CALLBACK	O
dummyend	function
(	O
void	O
)	O
{	O
}	O
void	O
Build_Feature	function
(	O
float	O
*	O
xp	pointer
,	O
float	O
*	O
yp	pointer
,	O
float	O
*	O
zp	pointer
,	O
int	O
num_verts	int
,	O
int	O
type	int
)	O
{	O
GLdouble	O
data	O
[	O
3	int
]	O
;	O
GLUtesselator	O
*	O
tobj	O
;	O
int	O
i	int
;	O
float	O
x1	float
,	O
y1	float
,	O
x1p	float
,	O
y1p	float
,	O
z1	float
;	O
float	O
dx	float
,	O
dy	float
,	O
dz	float
;	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
cityangle	array
[	O
citycount	int
]	O
;	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
feature	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Feature	O
)	O
)	O
;	O
feature	pointer
->	O
npoints	O
=	O
num_verts	int
;	O
feature	pointer
->	O
type	int
=	O
type	int
;	O
feature	pointer
->	O
verts	O
=	O
mav_malloc	function
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
mav_BBCompInit	function
(	O
&	O
feature	pointer
->	O
bb	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
x1	float
=	O
xp	pointer
[	O
i	int
]	O
;	O
y1	float
=	O
yp	pointer
[	O
i	int
]	O
;	O
z1	float
=	O
zp	pointer
[	O
i	int
]	O
;	O
if	O
(	O
(	O
type	int
==	O
CANAL	O
)	O
||	O
(	O
type	int
==	O
GRASS	O
)	O
||	O
(	O
type	int
==	O
PAVEMENT	O
)	O
)	O
{	O
x1	float
-=	O
comx	array
[	O
citycount	int
]	O
;	O
y1	float
-=	O
comy	array
[	O
citycount	int
]	O
;	O
x1p	float
=	O
x1	float
*	O
cangle	float
-	O
y1	float
*	O
sangle	float
;	O
y1p	float
=	O
x1	float
*	O
sangle	float
+	O
y1	float
*	O
cangle	float
;	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
=	O
-	O
(	O
x1p	float
-	O
centx	O
[	O
citycount	int
]	O
)	O
;	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
=	O
z1	float
;	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
=	O
(	O
y1p	float
-	O
centy	O
[	O
citycount	int
]	O
)	O
;	O
}	O
else	O
{	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
=	O
x1	float
;	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
=	O
z1	float
;	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
=	O
y1	float
;	O
}	O
mav_BBCompPt	function
(	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
,	O
&	O
feature	pointer
->	O
bb	pointer
)	O
;	O
}	O
feature	pointer
->	O
center	O
.	O
x	float
=	O
(	O
feature	pointer
->	O
bb	pointer
.	O
min	O
.	O
x	float
+	O
feature	pointer
->	O
bb	pointer
.	O
max	O
.	O
x	float
)	O
*	O
0.5	int
;	O
feature	pointer
->	O
center	O
.	O
y	float
=	O
(	O
feature	pointer
->	O
bb	pointer
.	O
min	O
.	O
y	float
+	O
feature	pointer
->	O
bb	pointer
.	O
max	O
.	O
y	float
)	O
*	O
0.5	int
;	O
feature	pointer
->	O
center	O
.	O
z	float
=	O
(	O
feature	pointer
->	O
bb	pointer
.	O
min	O
.	O
z	float
+	O
feature	pointer
->	O
bb	pointer
.	O
max	O
.	O
z	float
)	O
*	O
0.5	int
;	O
dx	float
=	O
feature	pointer
->	O
bb	pointer
.	O
min	O
.	O
x	float
-	O
feature	pointer
->	O
center	O
.	O
x	float
;	O
dy	float
=	O
feature	pointer
->	O
bb	pointer
.	O
min	O
.	O
y	float
-	O
feature	pointer
->	O
center	O
.	O
y	float
;	O
dz	float
=	O
feature	pointer
->	O
bb	pointer
.	O
min	O
.	O
z	float
-	O
feature	pointer
->	O
center	O
.	O
z	float
;	O
feature	pointer
->	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
+	O
dz	float
*	O
dz	float
)	O
;	O
tobj	O
=	O
gluNewTess	function
(	O
)	O
;	O
if	O
(	O
!	O
tobj	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to allocate GLUtesselator\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
feature	pointer
->	O
num_polys	O
=	O
0	int
;	O
feature_vertices	int
=	O
0	int
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_BEGIN	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
dummybegin	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_END	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
dummyend	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_ERROR	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_error	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_VERTEX	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
count_polygons	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_EDGE_FLAG	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
dummyedge	function
)	O
;	O
gluTessBeginPolygon	O
(	O
tobj	O
,	O
NULL	O
)	O
;	O
gluTessBeginContour	O
(	O
tobj	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
data	O
[	O
0	int
]	O
=	O
(	O
GLdouble	O
)	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
;	O
data	O
[	O
1	int
]	O
=	O
(	O
GLdouble	O
)	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
;	O
data	O
[	O
2	int
]	O
=	O
(	O
GLdouble	O
)	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
;	O
gluTessVertex	function
(	O
tobj	O
,	O
data	O
,	O
(	O
GLvoid	O
*	O
)	O
&	O
(	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
gluTessEndContour	O
(	O
tobj	O
)	O
;	O
gluTessEndPolygon	O
(	O
tobj	O
)	O
;	O
gluDeleteTess	function
(	O
tobj	O
)	O
;	O
feature	pointer
->	O
polys	O
=	O
mav_malloc	function
(	O
feature	pointer
->	O
num_polys	O
*	O
sizeof	O
(	O
LC_Polygon	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
feature	pointer
->	O
num_polys	O
;	O
i	int
++	O
)	O
{	O
feature	pointer
->	O
polys	O
[	O
i	int
]	O
.	O
verts	O
=	O
mav_malloc	function
(	O
3	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
feature	pointer
->	O
polys	O
[	O
i	int
]	O
.	O
num_verts	int
=	O
0	int
;	O
}	O
num_polygons	int
+=	O
feature	pointer
->	O
num_polys	O
;	O
tobj	O
=	O
gluNewTess	function
(	O
)	O
;	O
if	O
(	O
!	O
tobj	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to allocate GLUtesselator\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
feature	pointer
->	O
num_polys	O
=	O
0	int
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_BEGIN	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_begin	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_END	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
dummyend	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_ERROR	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_error	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_VERTEX	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_vertex	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_EDGE_FLAG	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
dummyedge	function
)	O
;	O
gluTessBeginPolygon	O
(	O
tobj	O
,	O
NULL	O
)	O
;	O
gluTessBeginContour	O
(	O
tobj	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
data	O
[	O
0	int
]	O
=	O
(	O
double	O
)	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
x	float
;	O
data	O
[	O
1	int
]	O
=	O
(	O
double	O
)	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
y	float
;	O
data	O
[	O
2	int
]	O
=	O
(	O
double	O
)	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
.	O
z	float
;	O
gluTessVertex	function
(	O
tobj	O
,	O
data	O
,	O
(	O
void	O
*	O
)	O
&	O
(	O
feature	pointer
->	O
verts	O
[	O
i	int
]	O
)	O
)	O
;	O
}	O
gluTessEndContour	O
(	O
tobj	O
)	O
;	O
gluTessEndPolygon	O
(	O
tobj	O
)	O
;	O
gluDeleteTess	function
(	O
tobj	O
)	O
;	O
feature	pointer
->	O
matrix	O
=	O
MAV_ID_MATRIX	O
;	O
feature	pointer
->	O
sp	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_COLOUR	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
CANAL	O
:	O
feature	pointer
->	O
sp	pointer
=	O
canal	pointer
;	O
break	O
;	O
case	O
PAVEMENT	O
:	O
feature	pointer
->	O
sp	pointer
=	O
stone	pointer
;	O
break	O
;	O
case	O
GRASS	O
:	O
feature	pointer
->	O
sp	pointer
=	O
grass	pointer
;	O
break	O
;	O
default	O
:	O
feature	pointer
->	O
sp	pointer
=	O
grass	pointer
;	O
break	O
;	O
}	O
mav_SMSCallbackObjectAddExec	function
(	O
city_build	pointer
,	O
mav_objectNew	function
(	O
mav_class_feature	pointer
,	O
feature	pointer
)	O
)	O
;	O
}	O
static	O
Vector	O
*	O
vector_list	pointer
=	O
NULL	O
;	O
static	O
int	O
vectorcount	int
;	O
Vector	O
*	O
Find_Vector	function
(	O
char	O
*	O
name	pointer
)	O
{	O
Vector	O
*	O
v	pointer
;	O
v	pointer
=	O
vector_list	pointer
;	O
while	O
(	O
v	pointer
)	O
{	O
if	O
(	O
strcmp	O
(	O
v	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
AddNewVector	function
(	O
char	O
*	O
vectorname	pointer
,	O
float	O
x1	float
,	O
float	O
y1	float
,	O
float	O
x2	float
,	O
float	O
y2	float
,	O
int	O
ColorCode	int
)	O
{	O
Vector	O
*	O
v	pointer
,	O
*	O
newv	O
;	O
MAV_object	O
*	O
obj	pointer
;	O
vectorcount	int
++	O
;	O
v	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Vector	O
)	O
)	O
;	O
strcpy	O
(	O
v	pointer
->	O
name	pointer
,	O
vectorname	pointer
)	O
;	O
v	pointer
->	O
start	O
.	O
x	float
=	O
x1	float
;	O
v	pointer
->	O
start	O
.	O
y	float
=	O
0.0	int
;	O
v	pointer
->	O
start	O
.	O
z	float
=	O
y1	float
;	O
v	pointer
->	O
end	O
.	O
x	float
=	O
x2	float
;	O
v	pointer
->	O
end	O
.	O
y	float
=	O
0.0	int
;	O
v	pointer
->	O
end	O
.	O
z	float
=	O
y2	float
;	O
v	pointer
->	O
sp	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_COLOUR	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
v	pointer
->	O
sp	pointer
->	O
colour	O
=	O
ColorCode	int
;	O
v	pointer
->	O
phrase_length	O
=	O
0.0	int
;	O
v	pointer
->	O
num_characters	O
=	O
0	int
;	O
v	pointer
->	O
bb	pointer
.	O
min	O
.	O
x	float
=	O
(	O
v	pointer
->	O
start	O
.	O
x	float
<	O
v	pointer
->	O
end	O
.	O
x	float
)	O
?	O
v	pointer
->	O
start	O
.	O
x	float
:	O
v	pointer
->	O
end	O
.	O
x	float
;	O
v	pointer
->	O
bb	pointer
.	O
min	O
.	O
y	float
=	O
0.0	int
;	O
v	pointer
->	O
bb	pointer
.	O
min	O
.	O
z	float
=	O
(	O
v	pointer
->	O
start	O
.	O
z	float
<	O
v	pointer
->	O
end	O
.	O
z	float
)	O
?	O
v	pointer
->	O
start	O
.	O
z	float
:	O
v	pointer
->	O
end	O
.	O
z	float
;	O
v	pointer
->	O
bb	pointer
.	O
max	O
.	O
x	float
=	O
(	O
v	pointer
->	O
start	O
.	O
x	float
>	O
v	pointer
->	O
end	O
.	O
x	float
)	O
?	O
v	pointer
->	O
start	O
.	O
x	float
:	O
v	pointer
->	O
end	O
.	O
x	float
;	O
v	pointer
->	O
bb	pointer
.	O
max	O
.	O
y	float
=	O
0.0	int
;	O
v	pointer
->	O
bb	pointer
.	O
max	O
.	O
z	float
=	O
(	O
v	pointer
->	O
start	O
.	O
z	float
>	O
v	pointer
->	O
end	O
.	O
z	float
)	O
?	O
v	pointer
->	O
start	O
.	O
z	float
:	O
v	pointer
->	O
end	O
.	O
z	float
;	O
mav_BBCompBB	function
(	O
v	pointer
->	O
bb	pointer
,	O
&	O
city_bb	int
)	O
;	O
v	pointer
->	O
matrix	O
=	O
MAV_ID_MATRIX	O
;	O
;	O
v	pointer
->	O
next	O
=	O
vector_list	pointer
;	O
vector_list	pointer
=	O
v	pointer
;	O
newv	O
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Vector	O
)	O
)	O
;	O
memcpy	O
(	O
newv	O
,	O
v	pointer
,	O
sizeof	O
(	O
Vector	O
)	O
)	O
;	O
newv	O
->	O
start	O
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
newv	O
->	O
end	O
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
newv	O
->	O
start	O
=	O
mav_vectorScalar	function
(	O
newv	O
->	O
start	O
,	O
map_scale	float
)	O
;	O
newv	O
->	O
end	O
=	O
mav_vectorScalar	function
(	O
newv	O
->	O
end	O
,	O
map_scale	float
)	O
;	O
obj	pointer
=	O
mav_objectNew	function
(	O
mav_class_vector	pointer
,	O
newv	O
)	O
;	O
mav_SMSCallbackObjectAddExec	function
(	O
city_map	pointer
,	O
obj	pointer
)	O
;	O
}	O
void	O
MakeAllStreets	function
(	O
)	O
{	O
int	O
i	int
;	O
FILE	struct
*	O
file	pointer
;	O
char	O
strfile	array
[	O
LINE_LEN	int
]	O
;	O
char	O
lstfile	array
[	O
LINE_LEN	int
]	O
;	O
char	O
aline	array
[	O
LINE_LEN	int
]	O
;	O
float	O
x1	float
,	O
y1	float
,	O
x2	float
,	O
y2	float
,	O
x1p	float
,	O
y1p	float
,	O
x2p	float
,	O
y2p	float
;	O
float	O
conradius	array
[	O
3	int
]	O
[	O
6	int
]	O
;	O
int	O
count	int
,	O
numpoints	int
;	O
int	O
coordinatecount	int
=	O
0	int
;	O
float	O
xsum	float
=	O
0	int
,	O
ysum	float
=	O
0	int
;	O
float	O
xorigin	float
,	O
yorigin	float
,	O
dx	float
=	O
0	int
,	O
dy	float
=	O
0	int
;	O
float	O
radius	float
,	O
maxradius	float
=	O
0	int
;	O
char	O
streetname	array
[	O
LINE_LEN	int
]	O
;	O
char	O
longstreetname	array
[	O
LINE_LEN	int
]	O
;	O
int	O
ColorCode	int
;	O
MAV_BB	O
bb	pointer
;	O
MAV_vector	O
newdr	O
;	O
Alphabet	O
*	O
letter	O
;	O
Character	O
*	O
character	O
;	O
Vector	O
*	O
v	pointer
,	O
*	O
current_vector	O
=	O
NULL	O
;	O
float	O
width	float
,	O
height	float
,	O
depth	float
,	O
spacing	float
,	O
letter_width	float
;	O
float	O
current_spacing_x	float
=	O
0	int
,	O
current_spacing_y	float
=	O
0	int
;	O
float	O
vx1	float
=	O
0	int
,	O
vy1	float
=	O
0	int
,	O
vx2	float
,	O
vy2	float
,	O
dlen	float
,	O
dir	float
=	O
0	int
,	O
newx	float
,	O
newy	float
;	O
float	O
xp	pointer
[	O
MAX_FEATURE_POINTS	int
]	O
,	O
yp	pointer
[	O
MAX_FEATURE_POINTS	int
]	O
,	O
zp	pointer
[	O
MAX_FEATURE_POINTS	int
]	O
;	O
num_polygons	int
=	O
0	int
;	O
global_city_mre	O
=	O
0.0	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
sprintf	function
(	O
strfile	array
,	O
"./data/"	pointer
)	O
;	O
strcat	O
(	O
strfile	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
strfile	array
,	O
".str"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
file	pointer
=	O
fopen	function
(	O
strfile	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to open street file %s\n"	pointer
,	O
strfile	array
)	O
;	O
}	O
else	O
{	O
coordinatecount	int
=	O
0	int
;	O
xsum	float
=	O
0.0	int
;	O
ysum	float
=	O
0.0	int
;	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
aline	array
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"grass"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"canal"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"pavem"	pointer
,	O
5	int
)	O
)	O
)	O
{	O
sscanf	function
(	O
aline	array
,	O
"%*s %i"	pointer
,	O
&	O
numpoints	int
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
numpoints	int
;	O
count	int
++	O
)	O
{	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
sscanf	function
(	O
aline	array
,	O
"%*c %f %*c %f %*c %*f %*c"	pointer
,	O
&	O
x1	float
,	O
&	O
y1	float
)	O
;	O
xsum	float
+=	O
x1	float
;	O
ysum	float
+=	O
y1	float
;	O
coordinatecount	int
++	O
;	O
}	O
}	O
else	O
{	O
sscanf	function
(	O
aline	array
,	O
"%*s %f %f %*f %f %f %*i"	pointer
,	O
&	O
x1	float
,	O
&	O
y1	float
,	O
&	O
x2	float
,	O
&	O
y2	float
)	O
;	O
xsum	float
+=	O
x1	float
;	O
xsum	float
+=	O
x2	float
;	O
ysum	float
+=	O
y1	float
;	O
ysum	float
+=	O
y2	float
;	O
coordinatecount	int
+=	O
2	int
;	O
}	O
}	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
comx	array
[	O
citycount	int
]	O
=	O
xsum	float
/	O
(	O
float	O
)	O
coordinatecount	int
;	O
comy	array
[	O
citycount	int
]	O
=	O
ysum	float
/	O
(	O
float	O
)	O
coordinatecount	int
;	O
printf	function
(	O
"Center of mass of %s = (%8.2f,%8.2f)\n"	pointer
,	O
basefilename	array
[	O
citycount	int
]	O
,	O
comx	array
[	O
citycount	int
]	O
,	O
comy	array
[	O
citycount	int
]	O
)	O
;	O
}	O
global_city_mre	O
=	O
0.0	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
sprintf	function
(	O
strfile	array
,	O
"./data/"	pointer
)	O
;	O
strcat	O
(	O
strfile	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
strfile	array
,	O
".str"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
file	pointer
=	O
fopen	function
(	O
strfile	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to open street file %s\n"	pointer
,	O
strfile	array
)	O
;	O
}	O
else	O
{	O
maxradius	float
=	O
0.0	int
;	O
xorigin	float
=	O
comx	array
[	O
citycount	int
]	O
;	O
yorigin	float
=	O
comy	array
[	O
citycount	int
]	O
;	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
aline	array
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"grass"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"canal"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"pavem"	pointer
,	O
5	int
)	O
)	O
)	O
{	O
sscanf	function
(	O
aline	array
,	O
"%*s %i"	pointer
,	O
&	O
numpoints	int
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
numpoints	int
;	O
count	int
++	O
)	O
{	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
sscanf	function
(	O
aline	array
,	O
"%*c %f %*c %f %*c %*f %*c"	pointer
,	O
&	O
x1	float
,	O
&	O
y1	float
)	O
;	O
dx	float
=	O
x1	float
-	O
xorigin	float
;	O
dy	float
=	O
y1	float
-	O
yorigin	float
;	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
if	O
(	O
radius	float
>	O
maxradius	float
)	O
maxradius	float
=	O
radius	float
;	O
}	O
}	O
else	O
{	O
sscanf	function
(	O
aline	array
,	O
"%*s %f %f %*f %f %f %*i"	pointer
,	O
&	O
x1	float
,	O
&	O
y1	float
,	O
&	O
x2	float
,	O
&	O
y2	float
)	O
;	O
dx	float
=	O
x1	float
-	O
xorigin	float
;	O
dy	float
=	O
y1	float
-	O
yorigin	float
;	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
+	O
dy	float
)	O
;	O
if	O
(	O
radius	float
>	O
maxradius	float
)	O
maxradius	float
=	O
radius	float
;	O
dx	float
=	O
x2	float
-	O
xorigin	float
;	O
dy	float
=	O
y2	float
-	O
yorigin	float
;	O
radius	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
+	O
dy	float
)	O
;	O
if	O
(	O
radius	float
>	O
maxradius	float
)	O
maxradius	float
=	O
radius	float
;	O
}	O
}	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
city_mre	O
[	O
citycount	int
]	O
=	O
maxradius	float
;	O
printf	function
(	O
"Maximum Radial Extent of %s = %8.2f\n"	pointer
,	O
basefilename	array
[	O
citycount	int
]	O
,	O
city_mre	O
[	O
citycount	int
]	O
)	O
;	O
if	O
(	O
maxradius	float
>	O
global_city_mre	O
)	O
global_city_mre	O
=	O
maxradius	float
;	O
}	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
angle	float
=	O
MAV_PI	O
*	O
120.0	int
/	O
180.0	int
*	O
(	O
float	O
)	O
citycount	int
;	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
centx	O
[	O
citycount	int
]	O
=	O
STRUCTURE_SCALE	int
*	O
global_city_mre	O
*	O
cangle	float
;	O
centy	O
[	O
citycount	int
]	O
=	O
STRUCTURE_SCALE	int
*	O
global_city_mre	O
*	O
sangle	float
;	O
printf	function
(	O
"Citycenter of %s = (%8.2f,%8.2f)\n"	pointer
,	O
basefilename	array
[	O
citycount	int
]	O
,	O
centx	O
[	O
citycount	int
]	O
,	O
centy	O
[	O
citycount	int
]	O
)	O
;	O
}	O
mav_BBCompInit	function
(	O
&	O
city_bb	int
)	O
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
cityangle	array
[	O
citycount	int
]	O
;	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sprintf	function
(	O
strfile	array
,	O
"./data/"	pointer
)	O
;	O
strcat	O
(	O
strfile	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
strfile	array
,	O
".str"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
file	pointer
=	O
fopen	function
(	O
strfile	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to open street file %s\n"	pointer
,	O
strfile	array
)	O
;	O
}	O
else	O
{	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
aline	array
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"grass"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"canal"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"pavem"	pointer
,	O
5	int
)	O
)	O
)	O
{	O
sscanf	function
(	O
aline	array
,	O
"%*s %i"	pointer
,	O
&	O
numpoints	int
)	O
;	O
if	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"grass"	pointer
,	O
5	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
fscanf	function
(	O
file	pointer
,	O
"(%f,%f,%f)\n"	pointer
,	O
&	O
xp	pointer
[	O
i	int
]	O
,	O
&	O
yp	pointer
[	O
i	int
]	O
,	O
&	O
zp	pointer
[	O
i	int
]	O
)	O
;	O
}	O
Build_Feature	function
(	O
xp	pointer
,	O
yp	pointer
,	O
zp	pointer
,	O
numpoints	int
,	O
GRASS	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"canal"	pointer
,	O
5	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
fscanf	function
(	O
file	pointer
,	O
"(%f,%f,%f)\n"	pointer
,	O
&	O
xp	pointer
[	O
i	int
]	O
,	O
&	O
yp	pointer
[	O
i	int
]	O
,	O
&	O
zp	pointer
[	O
i	int
]	O
)	O
;	O
}	O
Build_Feature	function
(	O
xp	pointer
,	O
yp	pointer
,	O
zp	pointer
,	O
numpoints	int
,	O
CANAL	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
fscanf	function
(	O
file	pointer
,	O
"(%f,%f,%f)\n"	pointer
,	O
&	O
xp	pointer
[	O
i	int
]	O
,	O
&	O
yp	pointer
[	O
i	int
]	O
,	O
&	O
zp	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
strncmp	O
(	O
aline	array
,	O
"pavem"	pointer
,	O
5	int
)	O
)	O
{	O
Build_Feature	function
(	O
xp	pointer
,	O
yp	pointer
,	O
zp	pointer
,	O
numpoints	int
,	O
PAVEMENT	O
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
sscanf	function
(	O
aline	array
,	O
"%s %f %f %*f %f %f %*f %i"	pointer
,	O
streetname	array
,	O
&	O
x1	float
,	O
&	O
y1	float
,	O
&	O
x2	float
,	O
&	O
y2	float
,	O
&	O
ColorCode	int
)	O
;	O
x1	float
-=	O
comx	array
[	O
citycount	int
]	O
;	O
y1	float
-=	O
comy	array
[	O
citycount	int
]	O
;	O
x2	float
-=	O
comx	array
[	O
citycount	int
]	O
;	O
y2	float
-=	O
comy	array
[	O
citycount	int
]	O
;	O
x1p	float
=	O
x1	float
*	O
cangle	float
-	O
y1	float
*	O
sangle	float
;	O
y1p	float
=	O
x1	float
*	O
sangle	float
+	O
y1	float
*	O
cangle	float
;	O
x2p	float
=	O
x2	float
*	O
cangle	float
-	O
y2	float
*	O
sangle	float
;	O
y2p	float
=	O
x2	float
*	O
sangle	float
+	O
y2	float
*	O
cangle	float
;	O
strcpy	O
(	O
longstreetname	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
longstreetname	array
,	O
streetname	array
)	O
;	O
AddNewVector	function
(	O
longstreetname	array
,	O
-	O
(	O
x1p	float
-	O
centx	O
[	O
citycount	int
]	O
)	O
,	O
(	O
y1p	float
-	O
centy	O
[	O
citycount	int
]	O
)	O
,	O
-	O
(	O
x2p	float
-	O
centx	O
[	O
citycount	int
]	O
)	O
,	O
(	O
y2p	float
-	O
centy	O
[	O
citycount	int
]	O
)	O
,	O
ColorCode	int
)	O
;	O
}	O
}	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
conradius	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
0.55	int
;	O
conradius	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
0.55	int
;	O
conradius	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
0.45	int
;	O
conradius	array
[	O
0	int
]	O
[	O
3	int
]	O
=	O
0.45	int
;	O
conradius	array
[	O
0	int
]	O
[	O
4	int
]	O
=	O
0.55	int
;	O
conradius	array
[	O
0	int
]	O
[	O
5	int
]	O
=	O
0.55	int
;	O
conradius	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
0.37	int
;	O
conradius	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
0.37	int
;	O
conradius	array
[	O
1	int
]	O
[	O
2	int
]	O
=	O
0.47	int
;	O
conradius	array
[	O
1	int
]	O
[	O
3	int
]	O
=	O
0.47	int
;	O
conradius	array
[	O
1	int
]	O
[	O
4	int
]	O
=	O
0.40	int
;	O
conradius	array
[	O
1	int
]	O
[	O
5	int
]	O
=	O
0.40	int
;	O
conradius	array
[	O
2	int
]	O
[	O
0	int
]	O
=	O
0.56	int
;	O
conradius	array
[	O
2	int
]	O
[	O
1	int
]	O
=	O
0.56	int
;	O
conradius	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
0.57	int
;	O
conradius	array
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.57	int
;	O
conradius	array
[	O
2	int
]	O
[	O
4	int
]	O
=	O
0.65	int
;	O
conradius	array
[	O
2	int
]	O
[	O
5	int
]	O
=	O
0.65	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
6	int
;	O
count	int
++	O
)	O
{	O
angle	float
=	O
STREET_WIDTH	int
/	O
(	O
global_city_mre	O
*	O
conradius	array
[	O
citycount	int
]	O
[	O
count	int
]	O
)	O
;	O
switch	O
(	O
count	int
)	O
{	O
case	O
0	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
-	O
30.0	int
)	O
)	O
-	O
angle	float
;	O
break	O
;	O
case	O
1	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
-	O
30.0	int
)	O
+	O
angle	float
;	O
break	O
;	O
case	O
2	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
)	O
-	O
angle	float
;	O
break	O
;	O
case	O
3	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
)	O
+	O
angle	float
;	O
break	O
;	O
case	O
4	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
+	O
30.0	int
)	O
-	O
angle	float
;	O
break	O
;	O
case	O
5	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
-	O
180.0	int
+	O
(	O
120.0	int
*	O
citycount	int
)	O
+	O
30.0	int
)	O
+	O
angle	float
;	O
break	O
;	O
}	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
}	O
}	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
6	int
;	O
count	int
++	O
)	O
{	O
angle	float
=	O
STREET_WIDTH	int
/	O
(	O
ORIGIN_SCALE	int
*	O
global_city_mre	O
)	O
;	O
switch	O
(	O
count	int
&	O
1	int
)	O
{	O
case	O
0	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
120.0	int
*	O
(	O
count	int
>>	O
1	int
)	O
)	O
+	O
angle	float
;	O
break	O
;	O
case	O
1	int
:	O
angle	float
=	O
MAV_PI	O
/	O
180.0	int
*	O
(	O
120.0	int
*	O
(	O
count	int
>>	O
1	int
)	O
)	O
-	O
angle	float
;	O
break	O
;	O
}	O
cangle	float
=	O
(	O
float	O
)	O
cos	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
sangle	float
=	O
(	O
float	O
)	O
sin	O
(	O
(	O
double	O
)	O
angle	float
)	O
;	O
}	O
global_city_mre	O
*=	O
STRUCTURE_SCALE	int
;	O
for	O
(	O
citycount	int
=	O
0	int
;	O
citycount	int
<	O
MAX_CITY	int
;	O
citycount	int
++	O
)	O
{	O
sprintf	function
(	O
lstfile	array
,	O
"./data/"	pointer
)	O
;	O
strcat	O
(	O
lstfile	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
lstfile	array
,	O
".lst"	pointer
)	O
;	O
file	pointer
=	O
fopen	function
(	O
lstfile	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to open letters file %s\n"	pointer
,	O
lstfile	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
aline	array
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
aline	array
,	O
":"	pointer
,	O
1	int
)	O
)	O
{	O
sscanf	function
(	O
aline	array
,	O
"%s"	pointer
,	O
streetname	array
)	O
;	O
strcpy	O
(	O
longstreetname	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
longstreetname	array
,	O
streetname	array
)	O
;	O
current_vector	O
=	O
Find_Vector	function
(	O
longstreetname	array
)	O
;	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unknown vector name %s\n"	pointer
,	O
longstreetname	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
current_spacing_x	float
=	O
0.0	int
;	O
current_spacing_y	float
=	O
0.0	int
;	O
vx1	float
=	O
-	O
current_vector	O
->	O
start	O
.	O
x	float
;	O
vy1	float
=	O
current_vector	O
->	O
start	O
.	O
z	float
;	O
vx2	float
=	O
-	O
current_vector	O
->	O
end	O
.	O
x	float
;	O
vy2	float
=	O
current_vector	O
->	O
end	O
.	O
z	float
;	O
dx	float
=	O
vx2	float
-	O
vx1	float
;	O
dy	float
=	O
vy2	float
-	O
vy1	float
;	O
dlen	float
=	O
1.0	int
/	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
dx	float
*=	O
dlen	float
;	O
dy	float
*=	O
dlen	float
;	O
dir	float
=	O
atan2	O
(	O
dx	float
,	O
dy	float
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Can't have letters before a street definition \n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
sscanf	function
(	O
&	O
aline	array
[	O
2	int
]	O
,	O
"%f %f %f %f"	pointer
,	O
&	O
width	float
,	O
&	O
height	float
,	O
&	O
depth	float
,	O
&	O
spacing	float
)	O
;	O
if	O
(	O
strlen	O
(	O
aline	array
)	O
>	O
1	int
)	O
{	O
letter	O
=	O
&	O
alphabet	array
[	O
(	O
unsigned	O
char	O
)	O
aline	array
[	O
1	int
]	O
]	O
;	O
letter_width	float
=	O
letter	O
->	O
letter_width	float
;	O
}	O
else	O
letter_width	float
=	O
0.8	int
;	O
current_spacing_x	float
+=	O
(	O
letter_width	float
+	O
0.2	int
)	O
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
(	O
letter_width	float
+	O
0.2	int
)	O
*	O
width	float
*	O
dy	float
;	O
current_vector	O
->	O
phrase_length	O
=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
+	O
sqrt	O
(	O
current_spacing_x	float
*	O
current_spacing_x	float
+	O
current_spacing_y	float
*	O
current_spacing_y	float
)	O
;	O
current_vector	O
->	O
num_characters	O
++	O
;	O
}	O
}	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
v	pointer
=	O
vector_list	pointer
;	O
while	O
(	O
v	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
v	pointer
->	O
phrase_length	O
>	O
0.0	int
)	O
{	O
newdr	O
.	O
x	float
=	O
v	pointer
->	O
end	O
.	O
x	float
-	O
v	pointer
->	O
start	O
.	O
x	float
;	O
newdr	O
.	O
z	float
=	O
v	pointer
->	O
end	O
.	O
z	float
-	O
v	pointer
->	O
start	O
.	O
z	float
;	O
dlen	float
=	O
sqrt	O
(	O
newdr	O
.	O
x	float
*	O
newdr	O
.	O
x	float
+	O
newdr	O
.	O
z	float
*	O
newdr	O
.	O
z	float
)	O
;	O
v	pointer
->	O
extra_width	O
=	O
dlen	float
/	O
v	pointer
->	O
phrase_length	O
;	O
}	O
else	O
v	pointer
->	O
extra_width	O
=	O
0.0	int
;	O
v	pointer
=	O
v	pointer
->	O
next	O
;	O
}	O
file	pointer
=	O
fopen	function
(	O
lstfile	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to open letters file %s\n"	pointer
,	O
lstfile	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
current_vector	O
=	O
NULL	O
;	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
aline	array
[	O
0	int
]	O
!=	O
';'	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
aline	array
,	O
":"	pointer
,	O
1	int
)	O
)	O
{	O
sscanf	function
(	O
aline	array
,	O
"%s"	pointer
,	O
streetname	array
)	O
;	O
strcpy	O
(	O
longstreetname	array
,	O
basefilename	array
[	O
citycount	int
]	O
)	O
;	O
strcat	O
(	O
longstreetname	array
,	O
streetname	array
)	O
;	O
current_vector	O
=	O
Find_Vector	function
(	O
longstreetname	array
)	O
;	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unknown vector name %s\n"	pointer
,	O
longstreetname	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
current_spacing_x	float
=	O
0.0	int
;	O
current_spacing_y	float
=	O
0.0	int
;	O
vx1	float
=	O
-	O
current_vector	O
->	O
start	O
.	O
x	float
;	O
vy1	float
=	O
current_vector	O
->	O
start	O
.	O
z	float
;	O
vx2	float
=	O
-	O
current_vector	O
->	O
end	O
.	O
x	float
;	O
vy2	float
=	O
current_vector	O
->	O
end	O
.	O
z	float
;	O
dx	float
=	O
vx2	float
-	O
vx1	float
;	O
dy	float
=	O
vy2	float
-	O
vy1	float
;	O
dlen	float
=	O
1.0	int
/	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
dx	float
*=	O
dlen	float
;	O
dy	float
*=	O
dlen	float
;	O
dir	float
=	O
atan2	O
(	O
dx	float
,	O
dy	float
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
current_vector	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Can't have letters before a street definition \n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
sscanf	function
(	O
&	O
aline	array
[	O
2	int
]	O
,	O
"%f %f %f %f"	pointer
,	O
&	O
width	float
,	O
&	O
height	float
,	O
&	O
depth	float
,	O
&	O
spacing	float
)	O
;	O
width	float
*=	O
current_vector	O
->	O
extra_width	O
;	O
if	O
(	O
strlen	O
(	O
aline	array
)	O
>	O
1	int
)	O
{	O
letter	O
=	O
&	O
alphabet	array
[	O
(	O
unsigned	O
char	O
)	O
aline	array
[	O
1	int
]	O
]	O
;	O
letter_width	float
=	O
letter	O
->	O
letter_width	float
;	O
num_polygons	int
+=	O
letter	O
->	O
num_polys	O
;	O
character	O
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Character	O
)	O
)	O
;	O
character	O
->	O
character	O
=	O
letter	O
;	O
character	O
->	O
sp	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_MATERIAL	O
,	O
MapColorCode	function
(	O
current_vector	O
->	O
sp	pointer
->	O
colour	O
,	O
citycount	int
)	O
,	O
MapColorCode	function
(	O
current_vector	O
->	O
sp	pointer
->	O
colour	O
,	O
citycount	int
)	O
,	O
0	int
)	O
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
newx	float
=	O
-	O
(	O
vx1	float
+	O
current_spacing_x	float
)	O
;	O
newy	float
=	O
vy1	float
+	O
current_spacing_y	float
;	O
character	O
->	O
matrix	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
(	O
180.0	int
*	O
dir	float
/	O
MAV_PI	O
+	O
90.0	int
)	O
,	O
newx	float
,	O
0.0	int
,	O
newy	float
)	O
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
0	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
1	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
2	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
3	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
0	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
1	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
2	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
3	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
0	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
1	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
2	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	O
->	O
matrix	O
.	O
mat	O
[	O
3	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
mav_SMSCallbackObjectAddExec	function
(	O
city_build	pointer
,	O
mav_objectNew	function
(	O
mav_class_character	pointer
,	O
character	O
)	O
)	O
;	O
mav_BBAlign	function
(	O
character	O
->	O
character	O
->	O
bb	pointer
,	O
character	O
->	O
matrix	O
,	O
&	O
bb	pointer
)	O
;	O
mav_BBCompBB	function
(	O
bb	pointer
,	O
&	O
city_bb	int
)	O
;	O
character	O
->	O
centre	O
=	O
mav_vectorScalar	function
(	O
mav_vectorAdd	function
(	O
bb	pointer
.	O
min	O
,	O
bb	pointer
.	O
max	O
)	O
,	O
0.5	int
)	O
;	O
}	O
else	O
{	O
letter_width	float
=	O
0.8	int
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
}	O
current_spacing_x	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dy	float
;	O
}	O
}	O
fgets	function
(	O
aline	array
,	O
LINE_LEN	int
,	O
file	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"Loaded %i polygons into static scene.\n"	pointer
,	O
num_polygons	int
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"Loaded %i vectors into static scene.\n"	pointer
,	O
vectorcount	int
)	O
;	O
}	O
int	O
AmsterdamIndexConversionTable	int
[	O
(	O
AMSTERDAM_MAX_COLOR_INDEX	O
+	O
1	int
)	O
]	O
=	O
{	O
1	int
,	O
6	int
,	O
10	int
,	O
4	int
,	O
3	int
,	O
13	int
,	O
5	int
,	O
1	int
,	O
13	int
,	O
4	int
,	O
8	int
,	O
6	int
,	O
2	int
,	O
9	int
,	O
7	int
,	O
13	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
11	int
,	O
14	int
,	O
13	int
,	O
1	int
,	O
7	int
,	O
8	int
,	O
2	int
,	O
1	int
,	O
5	int
,	O
12	int
,	O
14	int
,	O
1	int
,	O
5	int
,	O
9	int
,	O
11	int
,	O
6	int
,	O
10	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
14	int
,	O
14	int
,	O
11	int
,	O
9	int
,	O
8	int
,	O
10	int
,	O
8	int
,	O
12	int
,	O
4	int
,	O
1	int
,	O
3	int
}	O
;	O
int	O
KarlsruheIndexConversionTable	int
[	O
KARLSRUHE_MAX_COLOR_INDEX	O
+	O
1	int
]	O
=	O
{	O
3	int
,	O
9	int
,	O
6	int
,	O
6	int
,	O
4	int
,	O
2	int
,	O
10	int
,	O
1	int
,	O
2	int
,	O
14	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
5	int
,	O
17	int
,	O
10	int
,	O
18	int
,	O
15	int
,	O
14	int
,	O
11	int
,	O
12	int
,	O
14	int
,	O
4	int
,	O
15	int
,	O
11	int
,	O
8	int
,	O
9	int
,	O
2	int
,	O
4	int
,	O
6	int
,	O
7	int
,	O
4	int
,	O
7	int
,	O
9	int
,	O
8	int
,	O
18	int
,	O
16	int
,	O
2	int
,	O
6	int
,	O
17	int
,	O
18	int
,	O
14	int
,	O
6	int
,	O
19	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
int	O
TheColorTable	array
[	O
NUM_COLORS	int
]	O
[	O
3	int
]	O
=	O
{	O
{	O
255	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
255	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
128	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
255	int
}	O
,	O
{	O
255	int
,	O
0	int
,	O
128	int
}	O
,	O
{	O
128	int
,	O
255	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
255	int
,	O
128	int
}	O
,	O
{	O
0	int
,	O
128	int
,	O
255	int
}	O
,	O
{	O
7	int
,	O
66	int
,	O
96	int
}	O
,	O
{	O
73	int
,	O
182	int
,	O
30	int
}	O
,	O
{	O
100	int
,	O
100	int
,	O
100	int
}	O
,	O
{	O
255	int
,	O
169	int
,	O
66	int
}	O
,	O
{	O
255	int
,	O
26	int
,	O
23	int
}	O
,	O
{	O
255	int
,	O
45	int
,	O
12	int
}	O
,	O
{	O
255	int
,	O
85	int
,	O
23	int
}	O
,	O
{	O
255	int
,	O
23	int
,	O
6	int
}	O
,	O
{	O
207	int
,	O
132	int
,	O
90	int
}	O
,	O
{	O
252	int
,	O
44	int
,	O
58	int
}	O
,	O
{	O
172	int
,	O
123	int
,	O
123	int
}	O
,	O
{	O
255	int
,	O
130	int
,	O
21	int
}	O
,	O
{	O
255	int
,	O
95	int
,	O
3	int
}	O
,	O
{	O
253	int
,	O
2	int
,	O
2	int
}	O
,	O
{	O
253	int
,	O
107	int
,	O
80	int
}	O
,	O
{	O
242	int
,	O
114	int
,	O
34	int
}	O
,	O
{	O
255	int
,	O
78	int
,	O
54	int
}	O
,	O
{	O
216	int
,	O
155	int
,	O
155	int
}	O
,	O
{	O
254	int
,	O
149	int
,	O
149	int
}	O
,	O
{	O
254	int
,	O
254	int
,	O
113	int
}	O
,	O
{	O
207	int
,	O
132	int
,	O
90	int
}	O
,	O
{	O
255	int
,	O
143	int
,	O
57	int
}	O
,	O
{	O
200	int
,	O
200	int
,	O
200	int
}	O
,	O
{	O
125	int
,	O
219	int
,	O
220	int
}	O
,	O
{	O
68	int
,	O
253	int
,	O
141	int
}	O
,	O
{	O
211	int
,	O
100	int
,	O
30	int
}	O
,	O
{	O
146	int
,	O
129	int
,	O
227	int
}	O
,	O
{	O
189	int
,	O
113	int
,	O
55	int
}	O
,	O
{	O
254	int
,	O
200	int
,	O
37	int
}	O
,	O
{	O
250	int
,	O
133	int
,	O
83	int
}	O
,	O
{	O
177	int
,	O
41	int
,	O
1	int
}	O
,	O
{	O
182	int
,	O
202	int
,	O
68	int
}	O
,	O
{	O
255	int
,	O
201	int
,	O
121	int
}	O
,	O
{	O
255	int
,	O
172	int
,	O
222	int
}	O
,	O
{	O
250	int
,	O
250	int
,	O
191	int
}	O
,	O
{	O
203	int
,	O
254	int
,	O
201	int
}	O
}	O
;	O
void	O
PrintRangeError	function
(	O
int	O
ColorCode	int
)	O
{	O
}	O
void	O
GetLetterColor	function
(	O
int	O
ColorCode	int
,	O
int	O
CityCode	int
,	O
float	O
*	O
RGB	pointer
)	O
{	O
float	O
rgb	array
[	O
3	int
]	O
;	O
int	O
index	array
;	O
switch	O
(	O
CityCode	int
)	O
{	O
case	O
MANHATTAN_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
MANHATTAN_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
MANHATTAN_MAX_COLOR_INDEX	O
;	O
}	O
rgb	array
[	O
0	int
]	O
=	O
TheColorTable	array
[	O
ColorCode	int
]	O
[	O
0	int
]	O
/	O
255.0	int
;	O
rgb	array
[	O
1	int
]	O
=	O
TheColorTable	array
[	O
ColorCode	int
]	O
[	O
1	int
]	O
/	O
255.0	int
;	O
rgb	array
[	O
2	int
]	O
=	O
TheColorTable	array
[	O
ColorCode	int
]	O
[	O
2	int
]	O
/	O
255.0	int
;	O
break	O
;	O
case	O
AMSTERDAM_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
AMSTERDAM_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
AMSTERDAM_MAX_COLOR_INDEX	O
;	O
}	O
index	array
=	O
AmsterdamIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
13	int
;	O
rgb	array
[	O
0	int
]	O
=	O
TheColorTable	array
[	O
index	array
]	O
[	O
0	int
]	O
/	O
255.0	int
;	O
rgb	array
[	O
1	int
]	O
=	O
TheColorTable	array
[	O
index	array
]	O
[	O
1	int
]	O
/	O
255.0	int
;	O
rgb	array
[	O
2	int
]	O
=	O
TheColorTable	array
[	O
index	array
]	O
[	O
2	int
]	O
/	O
255.0	int
;	O
break	O
;	O
case	O
KARLSRUHE_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
KARLSRUHE_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
KARLSRUHE_MAX_COLOR_INDEX	O
;	O
}	O
index	array
=	O
KarlsruheIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
27	int
;	O
rgb	array
[	O
0	int
]	O
=	O
TheColorTable	array
[	O
index	array
]	O
[	O
0	int
]	O
/	O
255.0	int
;	O
rgb	array
[	O
1	int
]	O
=	O
TheColorTable	array
[	O
index	array
]	O
[	O
1	int
]	O
/	O
255.0	int
;	O
rgb	array
[	O
2	int
]	O
=	O
TheColorTable	array
[	O
index	array
]	O
[	O
2	int
]	O
/	O
255.0	int
;	O
break	O
;	O
}	O
memcpy	O
(	O
RGB	pointer
,	O
rgb	array
,	O
3	int
*	O
sizeof	O
(	O
float	O
)	O
)	O
;	O
}	O
void	O
BuildColorTable	function
(	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
float	O
RGB	pointer
[	O
3	int
]	O
;	O
float	O
modulation	float
;	O
int	O
ccount	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Building color table"	pointer
)	O
;	O
ccount	int
=	O
COL_OFFSET	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
MANHATTAN_MAX_COLOR_INDEX	O
;	O
i	int
++	O
)	O
{	O
GetLetterColor	function
(	O
i	int
,	O
MANHATTAN_COLOR_CODE	O
,	O
RGB	pointer
)	O
;	O
modulation	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_SHADES	O
;	O
j	int
++	O
)	O
{	O
mav_paletteMaterialSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
)	O
;	O
ccount	int
++	O
;	O
modulation	float
-=	O
SHADE_DIFFERENCE	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
AMSTERDAM_MAX_COLOR_INDEX	O
;	O
i	int
++	O
)	O
{	O
GetLetterColor	function
(	O
i	int
,	O
AMSTERDAM_COLOR_CODE	O
,	O
RGB	pointer
)	O
;	O
modulation	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_SHADES	O
;	O
j	int
++	O
)	O
{	O
mav_paletteMaterialSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
)	O
;	O
ccount	int
++	O
;	O
modulation	float
-=	O
SHADE_DIFFERENCE	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
KARLSRUHE_MAX_COLOR_INDEX	O
;	O
i	int
++	O
)	O
{	O
GetLetterColor	function
(	O
i	int
,	O
KARLSRUHE_COLOR_CODE	O
,	O
RGB	pointer
)	O
;	O
modulation	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_SHADES	O
;	O
j	int
++	O
)	O
{	O
mav_paletteMaterialSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
0.3	int
*	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
RGB	pointer
[	O
0	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
1	int
]	O
*	O
modulation	float
,	O
RGB	pointer
[	O
2	int
]	O
*	O
modulation	float
,	O
1.0	int
)	O
;	O
ccount	int
++	O
;	O
modulation	float
-=	O
SHADE_DIFFERENCE	O
;	O
}	O
}	O
mav_paletteMaterialSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
0.3	int
*	O
1.0	int
,	O
0.3	int
*	O
1.0	int
,	O
0.3	int
*	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
ccount	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
,	O
1.0	int
)	O
;	O
white_index	int
=	O
ccount	int
;	O
ccount	int
--	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" (%i entries).\n"	pointer
,	O
ccount	int
)	O
;	O
}	O
int	O
MapColorCode	function
(	O
int	O
ColorCode	int
,	O
int	O
CityCode	int
)	O
{	O
int	O
index	array
=	O
0	int
;	O
switch	O
(	O
CityCode	int
)	O
{	O
case	O
MANHATTAN_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
MANHATTAN_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
MANHATTAN_MAX_COLOR_INDEX	O
;	O
}	O
index	array
=	O
ColorCode	int
;	O
break	O
;	O
case	O
AMSTERDAM_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
AMSTERDAM_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
AMSTERDAM_MAX_COLOR_INDEX	O
;	O
}	O
index	array
=	O
AmsterdamIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
13	int
;	O
break	O
;	O
case	O
KARLSRUHE_COLOR_CODE	O
:	O
if	O
(	O
ColorCode	int
<	O
0	int
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ColorCode	int
>	O
KARLSRUHE_MAX_COLOR_INDEX	O
)	O
{	O
PrintRangeError	function
(	O
ColorCode	int
)	O
;	O
ColorCode	int
=	O
KARLSRUHE_MAX_COLOR_INDEX	O
;	O
}	O
index	array
=	O
KarlsruheIndexConversionTable	int
[	O
ColorCode	int
]	O
+	O
27	int
;	O
break	O
;	O
}	O
return	O
(	O
COL_OFFSET	int
+	O
index	array
*	O
NUM_SHADES	O
+	O
(	O
rand	function
(	O
)	O
%	O
NUM_SHADES	O
)	O
)	O
;	O
}	O
MAV_LCity	O
*	O
mav_newLCity	function
(	O
MAV_surfaceParams	O
*	O
*	O
sp	pointer
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_LCity	O
)	O
)	O
;	O
lc	O
->	O
matrix	O
=	O
MAV_ID_MATRIX	O
;	O
return	O
lc	O
;	O
}	O
int	O
mav_initLCity	function
(	O
)	O
{	O
mav_class_character	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_character	pointer
,	O
mav_characterDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_character	pointer
,	O
mav_characterBBox	function
)	O
;	O
mav_class_feature	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_feature	pointer
,	O
mav_featureDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_feature	pointer
,	O
mav_featureBBox	function
)	O
;	O
mav_class_vector	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_vector	pointer
,	O
mav_vectorDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_vector	pointer
,	O
mav_vectorBBox	function
)	O
;	O
city_build	pointer
=	O
mav_SMSNew	function
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	function
(	O
)	O
)	O
;	O
city_sms	pointer
=	O
mav_SMSNew	function
(	O
mav_SMSClass_HBB	O
,	O
mav_HBBNew	function
(	O
)	O
)	O
;	O
city_map	pointer
=	O
mav_SMSNew	function
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	function
(	O
)	O
)	O
;	O
BuildColorTable	function
(	O
)	O
;	O
Make_Font	function
(	O
)	O
;	O
MakeAllStreets	function
(	O
)	O
;	O
mav_HBBConstructFromSMS	function
(	O
city_sms	pointer
,	O
city_build	pointer
)	O
;	O
mav_SMSDelete	function
(	O
city_build	pointer
,	O
MAV_FALSE	O
)	O
;	O
mav_SMSSelectabilitySet	function
(	O
city_sms	pointer
,	O
mav_win_all	O
,	O
MAV_FALSE	O
)	O
;	O
return	O
0	int
;	O
}	O
float	O
phi0	array
[	O
DIVN	int
]	O
,	O
phi1	array
[	O
DIVN	int
]	O
;	O
float	O
t0	array
[	O
4	int
*	O
DIVN	int
]	O
,	O
t1	array
[	O
4	int
*	O
DIVN	int
]	O
;	O
float	O
sint0	array
[	O
4	int
*	O
DIVN	int
]	O
,	O
cost0	array
[	O
4	int
*	O
DIVN	int
]	O
,	O
sint1	array
[	O
4	int
*	O
DIVN	int
]	O
,	O
cost1	array
[	O
4	int
*	O
DIVN	int
]	O
;	O
float	O
sinp0	array
[	O
DIVN	int
]	O
,	O
cosp0	array
[	O
DIVN	int
]	O
,	O
sinp1	array
[	O
DIVN	int
]	O
,	O
cosp1	array
[	O
DIVN	int
]	O
;	O
void	O
initDrawCitySky	function
(	O
)	O
{	O
int	O
i	int
;	O
float	O
theta0	float
;	O
float	O
theta1	float
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DIVN	int
;	O
i	int
++	O
)	O
{	O
phi0	array
[	O
i	int
]	O
=	O
i	int
/	O
(	O
float	O
)	O
DIVN	int
;	O
phi1	array
[	O
i	int
]	O
=	O
(	O
i	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
DIVN	int
;	O
sinp0	array
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
phi0	array
[	O
i	int
]	O
)	O
;	O
sinp1	array
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
phi1	array
[	O
i	int
]	O
)	O
;	O
cosp0	array
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
phi0	array
[	O
i	int
]	O
)	O
;	O
cosp1	array
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
phi1	array
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
*	O
DIVN	int
;	O
i	int
++	O
)	O
{	O
theta0	float
=	O
0.25	int
*	O
i	int
/	O
(	O
float	O
)	O
DIVN	int
;	O
theta1	float
=	O
0.25	int
*	O
(	O
i	int
+	O
1	int
)	O
/	O
(	O
float	O
)	O
DIVN	int
;	O
sint0	array
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
theta0	float
)	O
;	O
sint1	array
[	O
i	int
]	O
=	O
sin	O
(	O
MAV_PI_OVER_2	O
*	O
theta1	float
)	O
;	O
cost0	array
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
theta0	float
)	O
;	O
cost1	array
[	O
i	int
]	O
=	O
cos	O
(	O
MAV_PI_OVER_2	O
*	O
theta1	float
)	O
;	O
t0	array
[	O
i	int
]	O
=	O
0.01	int
+	O
0.99	int
*	O
fabs	O
(	O
0.99	int
-	O
1.98	int
*	O
theta0	float
)	O
;	O
t1	array
[	O
i	int
]	O
=	O
0.01	int
+	O
0.99	int
*	O
fabs	O
(	O
0.99	int
-	O
1.98	int
*	O
theta1	float
)	O
;	O
}	O
}	O
int	O
drawCitySky	function
(	O
)	O
{	O
MAV_cylinder	O
cyl	O
;	O
MAV_rectangle	O
r	float
;	O
MAV_object	O
o	pointer
;	O
MAV_surfaceParams	O
s	O
;	O
cyl	O
.	O
radius	float
=	O
590	int
;	O
cyl	O
.	O
height	float
=	O
450	int
;	O
cyl	O
.	O
endcap	O
=	O
0	int
;	O
cyl	O
.	O
nverts	O
=	O
30	int
;	O
cyl	O
.	O
sp	pointer
=	O
sky	pointer
;	O
cyl	O
.	O
matrix	O
=	O
mav_matrixSet	function
(	O
0	int
,	O
-	O
90	int
,	O
0	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
+	O
cyl	O
.	O
height	float
/	O
2.0	int
-	O
1.0	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
)	O
;	O
r	float
.	O
width	float
=	O
2000	int
;	O
r	float
.	O
height	float
=	O
2000	int
;	O
s	O
.	O
mode	int
=	O
MAV_COLOUR	O
;	O
s	O
.	O
colour	O
=	O
MAV_COLOUR_WHITE	O
;	O
r	float
.	O
sp	pointer
=	O
&	O
s	O
;	O
r	float
.	O
matrix	O
=	O
mav_matrixSet	function
(	O
0	int
,	O
-	O
90	int
,	O
0	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
+	O
450	int
,	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
)	O
;	O
glDisable	function
(	O
GL_FOG	O
)	O
;	O
glDisable	function
(	O
GL_CULL_FACE	O
)	O
;	O
o	pointer
.	O
the_data	O
=	O
&	O
cyl	O
;	O
o	pointer
.	O
the_class	O
=	O
mav_class_cylinder	O
;	O
mav_cylinderDraw	function
(	O
&	O
o	pointer
,	O
NULL	O
)	O
;	O
o	pointer
.	O
the_data	O
=	O
&	O
r	float
;	O
o	pointer
.	O
the_class	O
=	O
mav_class_rectangle	O
;	O
mav_rectangleDraw	function
(	O
&	O
o	pointer
,	O
NULL	O
)	O
;	O
glEnable	function
(	O
GL_CULL_FACE	O
)	O
;	O
glEnable	function
(	O
GL_FOG	O
)	O
;	O
return	O
0	int
;	O
}	O
float	O
floor_gridsize	float
;	O
void	O
initDrawCityFloor	function
(	O
)	O
{	O
floor_gridsize	float
=	O
fog_distance	int
/	O
(	O
float	O
)	O
FLOOR_STEPS	int
;	O
}	O
int	O
drawCityFloor	function
(	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
MAV_vector	O
cent	O
;	O
MAV_vector	O
p	pointer
;	O
MAV_texCoord	O
t	O
;	O
int	O
iorigx	int
,	O
iorigz	int
;	O
float	O
curx	float
,	O
curxx	float
,	O
curz	float
,	O
curzz	float
;	O
mav_surfaceParamsUse	function
(	O
lcfloor	pointer
)	O
;	O
cent	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
;	O
iorigx	int
=	O
(	O
int	O
)	O
(	O
cent	O
.	O
x	float
/	O
floor_gridsize	float
)	O
;	O
iorigz	int
=	O
(	O
int	O
)	O
(	O
cent	O
.	O
z	float
/	O
floor_gridsize	float
)	O
;	O
curx	float
=	O
(	O
float	O
)	O
(	O
iorigx	int
-	O
FLOOR_STEPS	int
)	O
*	O
floor_gridsize	float
;	O
curxx	float
=	O
curx	float
+	O
floor_gridsize	float
;	O
for	O
(	O
i	int
=	O
(	O
iorigx	int
-	O
FLOOR_STEPS	int
)	O
;	O
i	int
<=	O
(	O
iorigx	int
+	O
FLOOR_STEPS	int
)	O
;	O
i	int
++	O
)	O
{	O
curz	float
=	O
(	O
float	O
)	O
(	O
iorigz	int
-	O
FLOOR_STEPS	int
)	O
*	O
floor_gridsize	float
;	O
curzz	float
=	O
curz	float
+	O
floor_gridsize	float
;	O
for	O
(	O
j	int
=	O
(	O
iorigz	int
-	O
FLOOR_STEPS	int
)	O
;	O
j	int
<=	O
(	O
iorigz	int
+	O
FLOOR_STEPS	int
)	O
;	O
j	int
++	O
)	O
{	O
mav_gfxPolygonBegin	function
(	O
)	O
;	O
t	O
.	O
s	O
=	O
0.0	int
;	O
t	O
.	O
t	O
=	O
0.0	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
p	pointer
.	O
x	float
=	O
curx	float
;	O
p	pointer
.	O
y	float
=	O
-	O
0.1	int
;	O
p	pointer
.	O
z	float
=	O
curz	float
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
t	O
.	O
s	O
=	O
0.0	int
;	O
t	O
.	O
t	O
=	O
1.0	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
p	pointer
.	O
x	float
=	O
curx	float
;	O
p	pointer
.	O
y	float
=	O
-	O
0.1	int
;	O
p	pointer
.	O
z	float
=	O
curzz	float
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
t	O
.	O
s	O
=	O
1.0	int
;	O
t	O
.	O
t	O
=	O
1.0	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
p	pointer
.	O
x	float
=	O
curxx	float
;	O
p	pointer
.	O
y	float
=	O
-	O
0.1	int
;	O
p	pointer
.	O
z	float
=	O
curzz	float
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
t	O
.	O
s	O
=	O
1.0	int
;	O
t	O
.	O
t	O
=	O
0.0	int
;	O
mav_gfxTexCoord	function
(	O
t	O
)	O
;	O
p	pointer
.	O
x	float
=	O
curxx	float
;	O
p	pointer
.	O
y	float
=	O
-	O
0.1	int
;	O
p	pointer
.	O
z	float
=	O
curz	float
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
mav_gfxPolygonEnd	function
(	O
)	O
;	O
curz	float
+=	O
floor_gridsize	float
;	O
curzz	float
+=	O
floor_gridsize	float
;	O
}	O
curx	float
+=	O
floor_gridsize	float
;	O
curxx	float
+=	O
floor_gridsize	float
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mav_LCityDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
MAV_matrix	O
m	pointer
;	O
MAV_vector	O
right	O
,	O
view	O
,	O
up	O
,	O
eye	O
;	O
MAV_vector	O
p	pointer
;	O
eye	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
;	O
eye	O
.	O
x	float
=	O
0.0	int
;	O
eye	O
.	O
y	float
=	O
MAP_ZOOM	int
;	O
eye	O
.	O
z	float
=	O
0.0	int
;	O
right	O
.	O
x	float
=	O
1	int
;	O
right	O
.	O
y	float
=	O
0	int
;	O
right	O
.	O
z	float
=	O
0	int
;	O
view	O
.	O
x	float
=	O
0	int
;	O
view	O
.	O
y	float
=	O
-	O
1	int
;	O
view	O
.	O
z	float
=	O
0	int
;	O
up	O
=	O
mav_vectorScalar	function
(	O
mav_vectorCrossProduct	function
(	O
view	O
,	O
right	O
)	O
,	O
-	O
1	int
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
lc	O
->	O
matrix	O
)	O
;	O
current_feature	int
=	O
-	O
1	int
;	O
mav_SMSDisplay	function
(	O
mav_win_current	O
,	O
city_sms	pointer
)	O
;	O
drawCitySky	function
(	O
)	O
;	O
drawCityFloor	function
(	O
)	O
;	O
glDisable	function
(	O
GL_FOG	O
)	O
;	O
if	O
(	O
drawMap	int
)	O
{	O
m	pointer
.	O
mat	O
[	O
0	int
]	O
[	O
0	int
]	O
=	O
right	O
.	O
x	float
;	O
m	pointer
.	O
mat	O
[	O
0	int
]	O
[	O
1	int
]	O
=	O
right	O
.	O
y	float
;	O
m	pointer
.	O
mat	O
[	O
0	int
]	O
[	O
2	int
]	O
=	O
right	O
.	O
z	float
;	O
m	pointer
.	O
mat	O
[	O
0	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	pointer
.	O
mat	O
[	O
1	int
]	O
[	O
0	int
]	O
=	O
up	O
.	O
x	float
;	O
m	pointer
.	O
mat	O
[	O
1	int
]	O
[	O
1	int
]	O
=	O
up	O
.	O
y	float
;	O
m	pointer
.	O
mat	O
[	O
1	int
]	O
[	O
2	int
]	O
=	O
up	O
.	O
z	float
;	O
m	pointer
.	O
mat	O
[	O
1	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	pointer
.	O
mat	O
[	O
2	int
]	O
[	O
0	int
]	O
=	O
-	O
view	O
.	O
x	float
;	O
m	pointer
.	O
mat	O
[	O
2	int
]	O
[	O
1	int
]	O
=	O
-	O
view	O
.	O
y	float
;	O
m	pointer
.	O
mat	O
[	O
2	int
]	O
[	O
2	int
]	O
=	O
-	O
view	O
.	O
z	float
;	O
m	pointer
.	O
mat	O
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	pointer
.	O
mat	O
[	O
3	int
]	O
[	O
0	int
]	O
=	O
0.0	int
;	O
m	pointer
.	O
mat	O
[	O
3	int
]	O
[	O
1	int
]	O
=	O
0.0	int
;	O
m	pointer
.	O
mat	O
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
m	pointer
.	O
mat	O
[	O
3	int
]	O
[	O
3	int
]	O
=	O
1.0	int
;	O
mav_gfxMatrixLoad	function
(	O
m	pointer
)	O
;	O
mav_gfxMatrixTranslate	function
(	O
mav_vectorScalar	function
(	O
eye	O
,	O
-	O
1.0	int
)	O
)	O
;	O
mav_surfaceParamsUse	function
(	O
tranny	pointer
)	O
;	O
mav_gfxDepthTestSet	function
(	O
MAV_FALSE	O
)	O
;	O
mav_SMSDisplayUnCulled	function
(	O
mav_win_current	O
,	O
city_map	pointer
)	O
;	O
mav_surfaceParamsUse	function
(	O
mav_sp_default	O
)	O
;	O
mav_gfxPolygonBegin	function
(	O
)	O
;	O
p	pointer
.	O
x	float
=	O
0	int
;	O
p	pointer
.	O
y	float
=	O
1	int
;	O
p	pointer
.	O
z	float
=	O
0	int
;	O
mav_gfxNormal	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
mav_vectorAdd	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
,	O
mav_vectorScalar	function
(	O
mav_win_current	O
->	O
vp	O
->	O
right	O
,	O
50	int
)	O
)	O
;	O
p	pointer
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
p	pointer
=	O
mav_vectorScalar	function
(	O
p	pointer
,	O
map_scale	float
)	O
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
mav_vectorAdd	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
,	O
mav_vectorScalar	function
(	O
mav_win_current	O
->	O
vp	O
->	O
view	O
,	O
150	int
)	O
)	O
;	O
p	pointer
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
p	pointer
=	O
mav_vectorScalar	function
(	O
p	pointer
,	O
map_scale	float
)	O
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
mav_vectorAdd	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
,	O
mav_vectorScalar	function
(	O
mav_win_current	O
->	O
vp	O
->	O
right	O
,	O
-	O
50	int
)	O
)	O
;	O
p	pointer
.	O
z	float
-=	O
MAP_OFFSET	O
;	O
p	pointer
=	O
mav_vectorScalar	function
(	O
p	pointer
,	O
map_scale	float
)	O
;	O
mav_gfxVertex	function
(	O
p	pointer
)	O
;	O
mav_gfxPolygonEnd	function
(	O
)	O
;	O
mav_gfxDepthTestSet	function
(	O
MAV_TRUE	O
)	O
;	O
}	O
glEnable	function
(	O
GL_FOG	O
)	O
;	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mav_LCityBB	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_BB	O
*	O
bb	pointer
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
MAV_BB	O
tmp	O
;	O
tmp	O
.	O
min	O
.	O
x	float
=	O
-	O
1000000	int
;	O
tmp	O
.	O
min	O
.	O
y	float
=	O
-	O
1000000	int
;	O
tmp	O
.	O
min	O
.	O
z	float
=	O
-	O
1000000	int
;	O
tmp	O
.	O
max	O
.	O
x	float
=	O
1000000	int
;	O
tmp	O
.	O
max	O
.	O
y	float
=	O
1000000	int
;	O
tmp	O
.	O
max	O
.	O
z	float
=	O
1000000	int
;	O
mav_BBAlign	function
(	O
tmp	O
,	O
lc	O
->	O
matrix	O
,	O
bb	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_LCityGetMatrix	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_matrix	O
*	O
*	O
m	pointer
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
*	O
m	pointer
=	O
&	O
lc	O
->	O
matrix	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_LCityID	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
char	O
*	O
*	O
id	pointer
)	O
{	O
*	O
id	pointer
=	O
"LCity"	pointer
;	O
return	O
1	int
;	O
}	O
int	O
mav_LCityGetUserdef	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
void	O
*	O
*	O
*	O
ud	pointer
)	O
{	O
MAV_LCity	O
*	O
lc	O
=	O
(	O
MAV_LCity	O
*	O
)	O
mav_objectDataGet	O
(	O
obj	pointer
)	O
;	O
*	O
ud	pointer
=	O
&	O
lc	O
->	O
userdef	O
;	O
return	O
1	int
;	O
}	O
char	O
*	O
mav_LCityModuleID	function
(	O
void	O
)	O
{	O
return	O
"LCity"	pointer
;	O
}	O
float	O
maxxdiff	float
=	O
0.1	int
;	O
float	O
xscale	float
=	O
10.0	int
;	O
int	O
centercount	int
=	O
0	int
;	O
float	O
centersum	float
=	O
0.0	int
;	O
float	O
maxydiff	float
=	O
0.0	int
;	O
float	O
ycenter	float
=	O
0.0	int
;	O
float	O
yscale	float
=	O
0.0	int
;	O
FILE	struct
*	O
conffile	pointer
;	O
int	O
saveflag	int
;	O
int	O
firsttime	int
=	O
1	int
;	O
float	O
timediff	float
;	O
void	O
LCjoyMove	function
(	O
void	O
*	O
ignored	pointer
)	O
{	O
}	O
void	O
enfog	function
(	O
void	O
)	O
{	O
glFogi	function
(	O
GL_FOG_MODE	O
,	O
GL_LINEAR	O
)	O
;	O
glFogfv	function
(	O
GL_FOG_COLOR	O
,	O
fogColour	array
)	O
;	O
glFogf	function
(	O
GL_FOG_START	O
,	O
1.0	int
)	O
;	O
glFogf	function
(	O
GL_FOG_END	O
,	O
fog_distance	int
)	O
;	O
glEnable	function
(	O
GL_FOG	O
)	O
;	O
}	O
int	O
mav_paletteTextureSet2	function
(	O
MAV_palette	O
*	O
p	pointer
,	O
int	O
i	int
,	O
char	O
*	O
f	int
)	O
{	O
if	O
(	O
mav_opt_stereo	O
)	O
{	O
mav_windowSet	function
(	O
mav_win_right	O
)	O
;	O
mav_paletteTextureSet	function
(	O
p	pointer
,	O
i	int
,	O
f	int
)	O
;	O
mav_windowSet	function
(	O
mav_win_left	O
)	O
;	O
}	O
return	O
mav_paletteTextureSet	function
(	O
p	pointer
,	O
i	int
,	O
f	int
)	O
;	O
}	O
void	O
mav_LCityModuleInit	function
(	O
void	O
)	O
{	O
mav_moduleNew	function
(	O
mav_LCityModuleID	function
)	O
;	O
mav_class_character	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_character	pointer
,	O
mav_characterDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_character	pointer
,	O
mav_characterBBox	function
)	O
;	O
mav_class_feature	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_feature	pointer
,	O
mav_featureDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_feature	pointer
,	O
mav_featureBBox	function
)	O
;	O
mav_class_vector	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_vector	pointer
,	O
mav_vectorDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_vector	pointer
,	O
mav_vectorBBox	function
)	O
;	O
city_build	pointer
=	O
mav_SMSNew	function
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	function
(	O
)	O
)	O
;	O
city_map	pointer
=	O
mav_SMSNew	function
(	O
mav_SMSClass_objList	O
,	O
mav_objListNew	function
(	O
)	O
)	O
;	O
city_sms	pointer
=	O
mav_SMSNew	function
(	O
mav_SMSClass_HBB	O
,	O
mav_HBBNew	function
(	O
)	O
)	O
;	O
grass	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_GRASS	int
)	O
;	O
canal	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_CANAL	int
)	O
;	O
stone	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_STONE	int
)	O
;	O
mav_paletteTextureSet2	function
(	O
mav_palette_default	O
,	O
TEX_GRASS	int
,	O
"./data/textures/grass.ppm"	pointer
)	O
;	O
mav_paletteTextureSet2	function
(	O
mav_palette_default	O
,	O
TEX_CANAL	int
,	O
"./data/textures/water.ppm"	pointer
)	O
;	O
mav_paletteTextureSet2	function
(	O
mav_palette_default	O
,	O
TEX_STONE	int
,	O
"./data/textures/stone.ppm"	pointer
)	O
;	O
BuildColorTable	function
(	O
)	O
;	O
Make_Font	function
(	O
)	O
;	O
MakeAllStreets	function
(	O
)	O
;	O
initDrawCitySky	function
(	O
)	O
;	O
initDrawCityFloor	function
(	O
)	O
;	O
sky	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_SKY	int
)	O
;	O
lcfloor	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_TEXTURE	O
,	O
0	int
,	O
1	int
,	O
TEX_FLOOR	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
TEX_TRANNY	int
,	O
0	int
,	O
0	int
,	O
0.5	int
,	O
0.8	int
)	O
;	O
tranny	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_COLOUR	O
,	O
TEX_TRANNY	int
,	O
0	int
,	O
0	int
)	O
;	O
mav_paletteTextureSet2	function
(	O
mav_palette_default	O
,	O
TEX_FLOOR	int
,	O
"./data/textures/rock5.ppm"	pointer
)	O
;	O
mav_paletteTextureSet2	function
(	O
mav_palette_default	O
,	O
TEX_SKY	int
,	O
"./data/textures/lcsky.ppm"	pointer
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
COL_WHITE	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
map_white	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_COLOUR	O
,	O
COL_WHITE	int
,	O
0	int
,	O
0	int
)	O
;	O
mav_HBBConstructFromSMS	function
(	O
city_sms	pointer
,	O
city_build	pointer
)	O
;	O
mav_SMSDelete	function
(	O
city_build	pointer
,	O
MAV_FALSE	O
)	O
;	O
if	O
(	O
mav_opt_stereo	O
)	O
{	O
mav_windowSet	function
(	O
mav_win_right	O
)	O
;	O
enfog	function
(	O
)	O
;	O
mav_windowSet	function
(	O
mav_win_left	O
)	O
;	O
}	O
enfog	function
(	O
)	O
;	O
mav_SMSSelectabilitySet	function
(	O
city_sms	pointer
,	O
mav_win_all	O
,	O
MAV_FALSE	O
)	O
;	O
mav_class_lcity	pointer
=	O
mav_classNew	function
(	O
)	O
;	O
mav_callbackDrawSet	function
(	O
mav_win_all	O
,	O
mav_class_lcity	pointer
,	O
mav_LCityDraw	function
)	O
;	O
mav_callbackBBSet	function
(	O
mav_win_all	O
,	O
mav_class_lcity	pointer
,	O
mav_LCityBB	function
)	O
;	O
mav_callbackIDSet	function
(	O
mav_win_all	O
,	O
mav_class_lcity	pointer
,	O
mav_LCityID	function
)	O
;	O
mav_callbackGetUserdefSet	function
(	O
mav_win_all	O
,	O
mav_class_lcity	pointer
,	O
mav_LCityGetUserdef	function
)	O
;	O
mav_callbackGetMatrixSet	function
(	O
mav_win_all	O
,	O
mav_class_lcity	pointer
,	O
mav_LCityGetMatrix	function
)	O
;	O
}	O
int	O
keyPress	function
(	O
MAV_object	O
*	O
o	pointer
,	O
MAV_keyboardEvent	O
*	O
ke	pointer
)	O
{	O
if	O
(	O
ke	pointer
->	O
movement	O
==	O
MAV_PRESSED	O
)	O
{	O
switch	O
(	O
ke	pointer
->	O
key	O
)	O
{	O
case	O
'm'	O
:	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	function
(	O
1684.35	int
,	O
2	int
,	O
0.00	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	function
(	O
-	O
842.17	int
,	O
2	int
,	O
1458.69	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	function
(	O
-	O
842.17	int
,	O
2	int
,	O
-	O
1458.69	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
drawMap	int
=	O
!	O
drawMap	int
;	O
break	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
MAV_SMS	O
*	O
sms	O
;	O
MAV_object	O
*	O
o	pointer
;	O
MAV_LCity	O
*	O
lcity	O
;	O
mav_opt_maxMaterials	O
=	O
750	int
;	O
mav_opt_maxColours	O
=	O
750	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
mav_opt_stereo	O
=	O
MAV_STEREO_TWO_WINS	O
;	O
mav_initialise	function
(	O
&	O
argc	int
,	O
argv	array
)	O
;	O
mav_LCityModuleInit	function
(	O
)	O
;	O
mav_windowBackgroundColourSet	function
(	O
mav_win_all	O
,	O
fogColour	array
[	O
0	int
]	O
,	O
fogColour	array
[	O
1	int
]	O
,	O
fogColour	array
[	O
2	int
]	O
)	O
;	O
mav_windowBackfaceCullSet	function
(	O
mav_win_all	O
,	O
MAV_TRUE	O
)	O
;	O
lcity	O
=	O
mav_newLCity	function
(	O
&	O
mav_sp_default	O
)	O
;	O
mav_navigationMouse	function
(	O
mav_win_all	O
,	O
mav_navigationMouseDefault	O
)	O
;	O
mav_navigationMouseDefaultParams	function
(	O
mav_win_all	O
,	O
MAV_LEFT_BUTTON	O
,	O
mav_navigateYawFixedUp	O
,	O
0.01	int
,	O
-	O
0.0005	int
,	O
mav_navigateTransForwardsFixedUp	O
,	O
0.01	int
,	O
0.0005	int
)	O
;	O
mav_navigationMouseDefaultParams	function
(	O
mav_win_all	O
,	O
MAV_RIGHT_BUTTON	O
,	O
mav_navigateRight	O
,	O
0.01	int
,	O
0.0005	int
,	O
mav_navigateUp	O
,	O
0.01	int
,	O
0.0005	int
)	O
;	O
mav_navigationKeyboard	function
(	O
mav_win_all	O
,	O
mav_navigationKeyboardDefault	O
)	O
;	O
sms	O
=	O
mav_SMSObjListNew	function
(	O
)	O
;	O
o	pointer
=	O
mav_objectNew	function
(	O
mav_class_lcity	pointer
,	O
lcity	O
)	O
;	O
mav_SMSObjectAdd	function
(	O
sms	O
,	O
o	pointer
)	O
;	O
mav_callbackKeyboardSet	function
(	O
mav_win_all	O
,	O
mav_class_world	O
,	O
keyPress	function
)	O
;	O
mav_stp_default	O
.	O
offset	O
=	O
2.7	int
;	O
mav_vp_default	O
.	O
eye	O
=	O
mav_vectorSet	function
(	O
-	O
842.17	int
,	O
2	int
,	O
-	O
1458.69	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
mav_eventsCheck	function
(	O
)	O
;	O
mav_frameBegin	function
(	O
)	O
;	O
mav_SMSDisplay	function
(	O
mav_win_all	O
,	O
sms	O
)	O
;	O
mav_frameEnd	function
(	O
)	O
;	O
}	O
}	O
