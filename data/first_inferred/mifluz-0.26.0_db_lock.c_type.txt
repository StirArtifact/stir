static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: lock.c,v 1.4 2014/04/17 20:27:30 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__lock_checklocker	function
__P	O
(	O
(	O
DB_LOCKTAB	struct
*	O
,	O
struct	O
__db_lock	struct
*	O
,	O
u_int32_t	int
,	O
u_int32_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__lock_get_internal	function
__P	O
(	O
(	O
DB_LOCKTAB	struct
*	O
,	O
u_int32_t	int
,	O
u_int32_t	int
,	O
const	O
DBT	struct
*	O
,	O
db_lockmode_t	enum
,	O
DB_LOCK	struct
*	O
)	O
)	O
;	O
static	O
int	O
__lock_is_parent	function
__P	O
(	O
(	O
DB_LOCKTAB	struct
*	O
,	O
u_int32_t	int
,	O
DB_LOCKER	struct
*	O
)	O
)	O
;	O
static	O
int	O
__lock_put_internal	function
__P	O
(	O
(	O
DB_LOCKTAB	struct
*	O
,	O
struct	O
__db_lock	struct
*	O
,	O
u_int32_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__lock_put_nolock	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_LOCK	struct
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
__lock_remove_waiter	function
__P	O
(	O
(	O
DB_LOCKOBJ	struct
*	O
,	O
struct	O
__db_lock	struct
*	O
,	O
db_status_t	enum
)	O
)	O
;	O
static	O
const	O
char	O
__db_lock_err	array
[	O
]	O
=	O
"Lock table is out of available %s"	pointer
;	O
static	O
const	O
char	O
__db_lock_invalid	array
[	O
]	O
=	O
"%s: Lock is no longer valid"	pointer
;	O
static	O
const	O
char	O
__db_locker_invalid	array
[	O
]	O
=	O
"Locker is not valid"	pointer
;	O
int	O
CDB_lock_id	function
(	O
dbenv	pointer
,	O
idp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
*	O
idp	pointer
;	O
{	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
DB_INIT_LOCK	int
)	O
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
if	O
(	O
region	pointer
->	O
id	int
>=	O
DB_LOCK_MAXID	int
)	O
region	pointer
->	O
id	int
=	O
0	int
;	O
*	O
idp	pointer
=	O
++	O
region	pointer
->	O
id	int
;	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB_lock_vec	function
(	O
dbenv	pointer
,	O
locker	int
,	O
flags	int
,	O
list	pointer
,	O
nlist	int
,	O
elistp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
locker	int
,	O
flags	int
;	O
int	O
nlist	int
;	O
DB_LOCKREQ	struct
*	O
list	pointer
,	O
*	O
*	O
elistp	pointer
;	O
{	O
struct	O
__db_lock	struct
*	O
lp	pointer
,	O
*	O
next_lock	pointer
;	O
DB_LOCKER	struct
*	O
sh_locker	pointer
,	O
*	O
sh_parent	pointer
;	O
DB_LOCKOBJ	struct
*	O
sh_obj	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
lndx	int
,	O
ndx	int
;	O
int	O
did_abort	int
,	O
i	int
,	O
ret	int
,	O
run_dd	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
DB_INIT_LOCK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_lock_vec"	pointer
,	O
flags	int
,	O
DB_LOCK_NOWAIT	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
run_dd	int
=	O
0	int
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
(	O
DB_LOCKTAB	struct
*	O
)	O
dbenv	pointer
->	O
lk_handle	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ret	int
=	O
0	int
;	O
i	int
<	O
nlist	int
&&	O
ret	int
==	O
0	int
;	O
i	int
++	O
)	O
switch	O
(	O
list	pointer
[	O
i	int
]	O
.	O
op	enum
)	O
{	O
case	O
DB_LOCK_GET	int
:	O
ret	int
=	O
__lock_get_internal	function
(	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
locker	int
,	O
flags	int
,	O
list	pointer
[	O
i	int
]	O
.	O
obj	pointer
,	O
list	pointer
[	O
i	int
]	O
.	O
mode	enum
,	O
&	O
list	pointer
[	O
i	int
]	O
.	O
lock	struct
)	O
;	O
break	O
;	O
case	O
DB_LOCK_INHERIT	int
:	O
ndx	int
=	O
CDB___lock_locker_hash	function
(	O
locker	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
locker	int
,	O
ndx	int
,	O
0	int
,	O
&	O
sh_locker	pointer
)	O
)	O
!=	O
0	int
||	O
sh_locker	pointer
==	O
NULL	O
||	O
F_ISSET	O
(	O
sh_locker	pointer
,	O
DB_LOCKER_DELETED	int
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
&&	O
sh_locker	pointer
!=	O
NULL	O
)	O
ret	int
=	O
EACCES	int
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
__db_locker_invalid	array
)	O
;	O
break	O
;	O
}	O
if	O
(	O
sh_locker	pointer
->	O
parent_locker	long
==	O
INVALID_ROFF	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Not a child transaction"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
sh_parent	pointer
=	O
(	O
DB_LOCKER	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
sh_locker	pointer
->	O
parent_locker	long
)	O
;	O
F_SET	O
(	O
sh_locker	pointer
,	O
DB_LOCKER_DELETED	int
)	O
;	O
ndx	int
=	O
CDB___lock_locker_hash	function
(	O
locker	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
F_ISSET	O
(	O
sh_parent	pointer
,	O
DB_LOCKER_DELETED	int
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Parent locker is not valid"	pointer
)	O
;	O
ret	int
=	O
EACCES	int
;	O
}	O
break	O
;	O
}	O
for	O
(	O
lp	pointer
=	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
)	O
{	O
SH_LIST_REMOVE	O
(	O
lp	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
;	O
SH_LIST_INSERT_HEAD	O
(	O
&	O
sh_parent	pointer
->	O
heldby	struct
,	O
lp	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
->	O
holder	int
=	O
sh_parent	pointer
->	O
id	int
;	O
}	O
ret	int
=	O
__lock_checklocker	function
(	O
lt	pointer
,	O
NULL	O
,	O
locker	int
,	O
DB_LOCK_IGNOREDEL	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
DB_LOCK_PUT	int
:	O
ret	int
=	O
__lock_put_nolock	function
(	O
dbenv	pointer
,	O
&	O
list	pointer
[	O
i	int
]	O
.	O
lock	struct
,	O
&	O
run_dd	int
)	O
;	O
break	O
;	O
case	O
DB_LOCK_PUT_ALL	int
:	O
ndx	int
=	O
CDB___lock_locker_hash	function
(	O
locker	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
locker	int
,	O
ndx	int
,	O
0	int
,	O
&	O
sh_locker	pointer
)	O
)	O
!=	O
0	int
||	O
sh_locker	pointer
==	O
NULL	O
||	O
F_ISSET	O
(	O
sh_locker	pointer
,	O
DB_LOCKER_DELETED	int
)	O
)	O
break	O
;	O
F_SET	O
(	O
sh_locker	pointer
,	O
DB_LOCKER_DELETED	int
)	O
;	O
for	O
(	O
lp	pointer
=	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
)	O
{	O
SH_LIST_REMOVE	O
(	O
lp	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
;	O
sh_obj	pointer
=	O
(	O
DB_LOCKOBJ	struct
*	O
)	O
(	O
(	O
u_int8_t	char
*	O
)	O
lp	pointer
+	O
lp	pointer
->	O
obj	pointer
)	O
;	O
SHOBJECT_LOCK	O
(	O
lt	pointer
,	O
region	pointer
,	O
sh_obj	pointer
,	O
lndx	int
)	O
;	O
ret	int
=	O
__lock_put_internal	function
(	O
lt	pointer
,	O
lp	pointer
,	O
lndx	int
,	O
DB_LOCK_FREE	int
|	O
DB_LOCK_DOALL	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
break	O
;	O
}	O
ret	int
=	O
__lock_checklocker	function
(	O
lt	pointer
,	O
NULL	O
,	O
locker	int
,	O
DB_LOCK_IGNOREDEL	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
DB_LOCK_PUT_OBJ	int
:	O
OBJECT_LOCK	O
(	O
lt	pointer
,	O
region	pointer
,	O
list	pointer
[	O
i	int
]	O
.	O
obj	pointer
,	O
ndx	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getobj	function
(	O
lt	pointer
,	O
list	pointer
[	O
i	int
]	O
.	O
obj	pointer
,	O
ndx	int
,	O
0	int
,	O
&	O
sh_obj	pointer
)	O
)	O
!=	O
0	int
||	O
sh_obj	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
for	O
(	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
;	O
ret	int
==	O
0	int
&&	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
)	O
ret	int
=	O
__lock_put_internal	function
(	O
lt	pointer
,	O
lp	pointer
,	O
ndx	int
,	O
DB_LOCK_NOPROMOTE	int
|	O
DB_LOCK_DOALL	int
)	O
;	O
for	O
(	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
,	O
__db_lock	struct
)	O
;	O
ret	int
==	O
0	int
&&	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
next_lock	pointer
)	O
{	O
next_lock	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
ret	int
=	O
__lock_put_internal	function
(	O
lt	pointer
,	O
lp	pointer
,	O
ndx	int
,	O
DB_LOCK_NOPROMOTE	int
|	O
DB_LOCK_DOALL	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Invalid lock operation: %d"	pointer
,	O
list	pointer
[	O
i	int
]	O
.	O
op	enum
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
&&	O
region	pointer
->	O
need_dd	int
&&	O
region	pointer
->	O
detect	int
!=	O
DB_LOCK_NORUN	int
)	O
{	O
run_dd	int
=	O
1	int
;	O
region	pointer
->	O
need_dd	int
=	O
0	int
;	O
}	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
(	O
DB_LOCKTAB	struct
*	O
)	O
dbenv	pointer
->	O
lk_handle	pointer
)	O
;	O
if	O
(	O
run_dd	int
)	O
(	O
void	O
)	O
CDB_lock_detect	function
(	O
dbenv	pointer
,	O
0	int
,	O
region	pointer
->	O
detect	int
,	O
&	O
did_abort	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
&&	O
elistp	pointer
!=	O
NULL	O
)	O
*	O
elistp	pointer
=	O
&	O
list	pointer
[	O
i	int
-	O
1	int
]	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_lock_get	function
(	O
dbenv	pointer
,	O
locker	int
,	O
flags	int
,	O
obj	pointer
,	O
lock_mode	enum
,	O
lock	struct
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
locker	int
,	O
flags	int
;	O
const	O
DBT	struct
*	O
obj	pointer
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
DB_LOCK	struct
*	O
lock	struct
;	O
{	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
DB_INIT_LOCK	int
)	O
;	O
if	O
(	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_lock_get"	pointer
,	O
flags	int
,	O
DB_LOCK_NOWAIT	int
|	O
DB_LOCK_UPGRADE	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
lock	struct
==	O
NULL	O
)	O
return	O
(	O
EINVAL	int
)	O
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
(	O
DB_LOCKTAB	struct
*	O
)	O
dbenv	pointer
->	O
lk_handle	pointer
)	O
;	O
ret	int
=	O
__lock_get_internal	function
(	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
locker	int
,	O
flags	int
,	O
obj	pointer
,	O
lock_mode	enum
,	O
lock	struct
)	O
;	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
(	O
DB_LOCKTAB	struct
*	O
)	O
dbenv	pointer
->	O
lk_handle	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__lock_get_internal	function
(	O
lt	pointer
,	O
locker	int
,	O
flags	int
,	O
obj	pointer
,	O
lock_mode	enum
,	O
lock	struct
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
locker	int
,	O
flags	int
;	O
const	O
DBT	struct
*	O
obj	pointer
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
DB_LOCK	struct
*	O
lock	struct
;	O
{	O
struct	O
__db_lock	struct
*	O
newl	pointer
,	O
*	O
lp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
DB_LOCKOBJ	struct
*	O
sh_obj	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
u_int32_t	int
locker_ndx	int
;	O
int	O
did_abort	int
,	O
freed	int
,	O
ihold	int
,	O
on_locker_list	int
,	O
no_dd	int
,	O
ret	int
;	O
no_dd	int
=	O
ret	int
=	O
0	int
;	O
on_locker_list	int
=	O
0	int
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
dbenv	pointer
=	O
lt	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
u_int32_t	int
)	O
lock_mode	enum
>=	O
region	pointer
->	O
nmodes	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_lock_get: invalid lock mode %lu\n"	pointer
,	O
(	O
u_long	long
)	O
lock_mode	enum
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
region	pointer
->	O
nrequests	int
++	O
;	O
if	O
(	O
(	O
newl	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
__db_lock	struct
)	O
)	O
!=	O
NULL	O
)	O
SH_TAILQ_REMOVE	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
newl	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
if	O
(	O
newl	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
__db_lock_err	array
,	O
"locks"	pointer
)	O
;	O
return	O
(	O
ENOMEM	int
)	O
;	O
}	O
OBJECT_LOCK	O
(	O
lt	pointer
,	O
region	pointer
,	O
obj	pointer
,	O
lock	struct
->	O
ndx	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getobj	function
(	O
lt	pointer
,	O
obj	pointer
,	O
lock	struct
->	O
ndx	int
,	O
1	int
,	O
&	O
sh_obj	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
locker_ndx	int
=	O
CDB___lock_locker_hash	function
(	O
locker	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
locker	int
,	O
locker_ndx	int
,	O
1	int
,	O
&	O
sh_locker	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
return	O
(	O
ret	int
)	O
;	O
}	O
ihold	int
=	O
0	int
;	O
for	O
(	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
)	O
{	O
if	O
(	O
locker	int
==	O
lp	pointer
->	O
holder	int
||	O
__lock_is_parent	function
(	O
lt	pointer
,	O
lp	pointer
->	O
holder	int
,	O
sh_locker	pointer
)	O
)	O
{	O
if	O
(	O
lp	pointer
->	O
mode	enum
==	O
lock_mode	enum
&&	O
lp	pointer
->	O
status	int
==	O
DB_LSTAT_HELD	int
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_UPGRADE	int
)	O
)	O
goto	O
upgrade	pointer
;	O
lp	pointer
->	O
refcount	int
++	O
;	O
lock	struct
->	O
off	long
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lp	pointer
)	O
;	O
lock	struct
->	O
gen	int
=	O
lp	pointer
->	O
gen	int
;	O
ret	int
=	O
0	int
;	O
goto	O
done	O
;	O
}	O
else	O
ihold	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
CONFLICTS	O
(	O
lt	pointer
,	O
region	pointer
,	O
lp	pointer
->	O
mode	enum
,	O
lock_mode	enum
)	O
)	O
break	O
;	O
}	O
newl	pointer
->	O
holder	int
=	O
locker	int
;	O
newl	pointer
->	O
refcount	int
=	O
1	int
;	O
newl	pointer
->	O
mode	enum
=	O
lock_mode	enum
;	O
newl	pointer
->	O
obj	pointer
=	O
SH_PTR_TO_OFF	O
(	O
newl	pointer
,	O
sh_obj	pointer
)	O
;	O
newl	pointer
->	O
status	int
=	O
DB_LSTAT_HELD	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_UPGRADE	int
)	O
)	O
{	O
if	O
(	O
lp	pointer
==	O
NULL	O
)	O
goto	O
upgrade	pointer
;	O
if	O
(	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
)	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
dd_objs	struct
,	O
sh_obj	pointer
,	O
dd_links	struct
,	O
__db_lockobj	struct
)	O
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
newl	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
goto	O
llist	O
;	O
}	O
if	O
(	O
lp	pointer
==	O
NULL	O
&&	O
!	O
ihold	int
)	O
for	O
(	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
)	O
{	O
if	O
(	O
CONFLICTS	O
(	O
lt	pointer
,	O
region	pointer
,	O
lp	pointer
->	O
mode	enum
,	O
lock_mode	enum
)	O
&&	O
locker	int
!=	O
lp	pointer
->	O
holder	int
)	O
break	O
;	O
}	O
if	O
(	O
lp	pointer
==	O
NULL	O
)	O
SH_TAILQ_INSERT_TAIL	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
,	O
newl	pointer
,	O
links	struct
)	O
;	O
else	O
if	O
(	O
!	O
(	O
flags	int
&	O
DB_LOCK_NOWAIT	int
)	O
)	O
{	O
if	O
(	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
)	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
dd_objs	struct
,	O
sh_obj	pointer
,	O
dd_links	struct
,	O
__db_lockobj	struct
)	O
;	O
SH_TAILQ_INSERT_TAIL	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
newl	pointer
,	O
links	struct
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
DB_LOCK_NOTGRANTED	O
;	O
if	O
(	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
&&	O
LOCKER_FREEABLE	O
(	O
sh_locker	pointer
)	O
)	O
CDB___lock_freelocker	function
(	O
lt	pointer
,	O
region	pointer
,	O
sh_locker	pointer
,	O
locker_ndx	int
)	O
;	O
region	pointer
->	O
nnowaits	int
++	O
;	O
goto	O
err	pointer
;	O
}	O
llist	O
:	O
on_locker_list	int
=	O
1	int
;	O
no_dd	int
=	O
sh_locker	pointer
->	O
master_locker	long
==	O
INVALID_ROFF	int
&&	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
child_locker	struct
,	O
__db_locker	struct
)	O
==	O
NULL	O
&&	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
;	O
SH_LIST_INSERT_HEAD	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
newl	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
;	O
if	O
(	O
lp	pointer
!=	O
NULL	O
)	O
{	O
newl	pointer
->	O
status	int
=	O
DB_LSTAT_WAITING	int
;	O
region	pointer
->	O
nconflicts	int
++	O
;	O
if	O
(	O
region	pointer
->	O
detect	int
==	O
DB_LOCK_NORUN	int
)	O
region	pointer
->	O
need_dd	int
=	O
1	int
;	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
(	O
DB_LOCKTAB	struct
*	O
)	O
dbenv	pointer
->	O
lk_handle	pointer
)	O
;	O
if	O
(	O
region	pointer
->	O
detect	int
!=	O
DB_LOCK_NORUN	int
&&	O
!	O
no_dd	int
)	O
(	O
void	O
)	O
CDB_lock_detect	function
(	O
dbenv	pointer
,	O
0	int
,	O
region	pointer
->	O
detect	int
,	O
&	O
did_abort	int
)	O
;	O
MUTEX_LOCK	O
(	O
&	O
newl	pointer
->	O
mutex	union
,	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
(	O
DB_LOCKTAB	struct
*	O
)	O
dbenv	pointer
->	O
lk_handle	pointer
)	O
;	O
if	O
(	O
newl	pointer
->	O
status	int
!=	O
DB_LSTAT_PENDING	int
)	O
{	O
(	O
void	O
)	O
__lock_checklocker	function
(	O
lt	pointer
,	O
newl	pointer
,	O
newl	pointer
->	O
holder	int
,	O
0	int
,	O
&	O
freed	int
)	O
;	O
switch	O
(	O
newl	pointer
->	O
status	int
)	O
{	O
case	O
DB_LSTAT_ABORTED	int
:	O
on_locker_list	int
=	O
0	int
;	O
ret	int
=	O
DB_LOCK_DEADLOCK	O
;	O
break	O
;	O
case	O
DB_LSTAT_NOGRANT	int
:	O
ret	int
=	O
DB_LOCK_NOTGRANTED	O
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_UPGRADE	int
)	O
)	O
{	O
SH_TAILQ_REMOVE	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
,	O
newl	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
newl	pointer
->	O
links	struct
.	O
stqe_prev	long
=	O
-	O
1	int
;	O
goto	O
upgrade	pointer
;	O
}	O
else	O
newl	pointer
->	O
status	int
=	O
DB_LSTAT_HELD	int
;	O
}	O
lock	struct
->	O
off	long
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
newl	pointer
)	O
;	O
lock	struct
->	O
gen	int
=	O
newl	pointer
->	O
gen	int
;	O
return	O
(	O
0	int
)	O
;	O
upgrade	pointer
:	O
(	O
(	O
struct	O
__db_lock	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lock	struct
->	O
off	long
)	O
)	O
->	O
mode	enum
=	O
lock_mode	enum
;	O
ret	int
=	O
0	int
;	O
done	O
:	O
err	pointer
:	O
newl	pointer
->	O
status	int
=	O
DB_LSTAT_FREE	int
;	O
if	O
(	O
on_locker_list	int
)	O
{	O
SH_LIST_REMOVE	O
(	O
newl	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
;	O
}	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
newl	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_lock_put	function
(	O
dbenv	pointer
,	O
lock	struct
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
*	O
lock	struct
;	O
{	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
int	O
ret	int
,	O
run_dd	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
DB_INIT_LOCK	int
)	O
;	O
if	O
(	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
)	O
return	O
(	O
0	int
)	O
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
ret	int
=	O
__lock_put_nolock	function
(	O
dbenv	pointer
,	O
lock	struct
,	O
&	O
run_dd	int
)	O
;	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
lock	struct
->	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
run_dd	int
)	O
(	O
void	O
)	O
CDB_lock_detect	function
(	O
dbenv	pointer
,	O
0	int
,	O
(	O
(	O
DB_LOCKREGION	struct
*	O
)	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
->	O
detect	int
,	O
NULL	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__lock_put_nolock	function
(	O
dbenv	pointer
,	O
lock	struct
,	O
runp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
*	O
lock	struct
;	O
int	O
*	O
runp	pointer
;	O
{	O
struct	O
__db_lock	struct
*	O
lockp	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
int	O
ret	int
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
lockp	pointer
=	O
(	O
struct	O
__db_lock	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lock	struct
->	O
off	long
)	O
;	O
if	O
(	O
lock	struct
->	O
gen	int
!=	O
lockp	pointer
->	O
gen	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
__db_lock_invalid	array
,	O
"CDB_lock_put"	pointer
)	O
;	O
return	O
(	O
EACCES	int
)	O
;	O
}	O
ret	int
=	O
__lock_put_internal	function
(	O
lt	pointer
,	O
lockp	pointer
,	O
lock	struct
->	O
ndx	int
,	O
DB_LOCK_UNLINK	int
|	O
DB_LOCK_FREE	int
)	O
;	O
*	O
runp	pointer
=	O
0	int
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
region	pointer
->	O
need_dd	int
&&	O
region	pointer
->	O
detect	int
!=	O
DB_LOCK_NORUN	int
)	O
{	O
*	O
runp	pointer
=	O
1	int
;	O
region	pointer
->	O
need_dd	int
=	O
0	int
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___lock_downgrade	function
(	O
dbenv	pointer
,	O
lock	struct
,	O
new_mode	enum
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
*	O
lock	struct
;	O
db_lockmode_t	enum
new_mode	enum
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
flags	int
)	O
{	O
}	O
struct	O
__db_lock	struct
*	O
lockp	pointer
;	O
DB_LOCKOBJ	struct
*	O
obj	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
lockp	pointer
=	O
(	O
struct	O
__db_lock	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lock	struct
->	O
off	long
)	O
;	O
if	O
(	O
lock	struct
->	O
gen	int
!=	O
lockp	pointer
->	O
gen	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
__db_lock_invalid	array
,	O
"lock_downgrade"	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
lockp	pointer
->	O
mode	enum
=	O
new_mode	enum
;	O
obj	pointer
=	O
(	O
DB_LOCKOBJ	struct
*	O
)	O
(	O
(	O
u_int8_t	char
*	O
)	O
lockp	pointer
+	O
lockp	pointer
->	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
CDB___lock_promote	function
(	O
lt	pointer
,	O
obj	pointer
)	O
;	O
++	O
region	pointer
->	O
nreleases	int
;	O
out	O
:	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__lock_put_internal	function
(	O
lt	pointer
,	O
lockp	pointer
,	O
obj_ndx	int
,	O
flags	int
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
struct	O
__db_lock	struct
*	O
lockp	pointer
;	O
u_int32_t	int
obj_ndx	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_LOCKOBJ	struct
*	O
sh_obj	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
int	O
ret	int
,	O
state_changed	int
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
if	O
(	O
!	O
OBJ_LINKS_VALID	O
(	O
lockp	pointer
)	O
)	O
{	O
lockp	pointer
->	O
status	int
=	O
DB_LSTAT_FREE	int
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
lockp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_DOALL	int
)	O
)	O
region	pointer
->	O
nreleases	int
+=	O
lockp	pointer
->	O
refcount	int
;	O
else	O
region	pointer
->	O
nreleases	int
++	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_LOCK_DOALL	int
)	O
&&	O
lockp	pointer
->	O
refcount	int
>	O
1	int
)	O
{	O
lockp	pointer
->	O
refcount	int
--	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
lockp	pointer
->	O
gen	int
++	O
;	O
sh_obj	pointer
=	O
(	O
DB_LOCKOBJ	struct
*	O
)	O
(	O
(	O
u_int8_t	char
*	O
)	O
lockp	pointer
+	O
lockp	pointer
->	O
obj	pointer
)	O
;	O
if	O
(	O
lockp	pointer
->	O
status	int
!=	O
DB_LSTAT_HELD	int
)	O
__lock_remove_waiter	function
(	O
sh_obj	pointer
,	O
lockp	pointer
,	O
DB_LSTAT_FREE	int
)	O
;	O
else	O
{	O
SH_TAILQ_REMOVE	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
,	O
lockp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
lockp	pointer
->	O
links	struct
.	O
stqe_prev	long
=	O
-	O
1	int
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_NOPROMOTE	int
)	O
)	O
state_changed	int
=	O
0	int
;	O
else	O
state_changed	int
=	O
CDB___lock_promote	function
(	O
lt	pointer
,	O
sh_obj	pointer
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_UNLINK	int
)	O
)	O
ret	int
=	O
__lock_checklocker	function
(	O
lt	pointer
,	O
lockp	pointer
,	O
lockp	pointer
->	O
holder	int
,	O
flags	int
,	O
NULL	O
)	O
;	O
if	O
(	O
SH_TAILQ_FIRST	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
)	O
{	O
HASHREMOVE_EL	O
(	O
lt	pointer
->	O
obj_tab	pointer
,	O
obj_ndx	int
,	O
__db_lockobj	struct
,	O
links	struct
,	O
sh_obj	pointer
)	O
;	O
if	O
(	O
sh_obj	pointer
->	O
lockobj	struct
.	O
size	int
>	O
sizeof	O
(	O
sh_obj	pointer
->	O
objdata	array
)	O
)	O
CDB___db_shalloc_free	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
SH_DBT_PTR	O
(	O
&	O
sh_obj	pointer
->	O
lockobj	struct
)	O
)	O
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_objs	struct
,	O
sh_obj	pointer
,	O
links	struct
,	O
__db_lockobj	struct
)	O
;	O
state_changed	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_LOCK_UNLINK	int
)	O
&&	O
LF_ISSET	O
(	O
DB_LOCK_FREE	int
)	O
)	O
{	O
lockp	pointer
->	O
status	int
=	O
DB_LSTAT_FREE	int
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
lockp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
}	O
if	O
(	O
state_changed	int
==	O
0	int
)	O
region	pointer
->	O
need_dd	int
=	O
1	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__lock_checklocker	function
(	O
lt	pointer
,	O
lockp	pointer
,	O
locker	int
,	O
flags	int
,	O
freed	int
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
struct	O
__db_lock	struct
*	O
lockp	pointer
;	O
u_int32_t	int
locker	int
,	O
flags	int
;	O
int	O
*	O
freed	int
;	O
{	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
u_int32_t	int
indx	short
;	O
int	O
ret	int
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
freed	int
!=	O
NULL	O
)	O
*	O
freed	int
=	O
0	int
;	O
indx	short
=	O
CDB___lock_locker_hash	function
(	O
locker	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
locker	int
,	O
indx	short
,	O
0	int
,	O
&	O
sh_locker	pointer
)	O
)	O
!=	O
0	int
||	O
sh_locker	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
EACCES	int
;	O
CDB___db_err	function
(	O
lt	pointer
->	O
dbenv	pointer
,	O
__db_locker_invalid	array
)	O
;	O
goto	O
freelock	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
sh_locker	pointer
,	O
DB_LOCKER_DELETED	int
)	O
)	O
{	O
LF_CLR	O
(	O
DB_LOCK_FREE	int
)	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_LOCK_IGNOREDEL	int
)	O
)	O
goto	O
freelock	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_UNLINK	int
)	O
)	O
SH_LIST_REMOVE	O
(	O
lockp	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
;	O
if	O
(	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
&&	O
LOCKER_FREEABLE	O
(	O
sh_locker	pointer
)	O
)	O
{	O
CDB___lock_freelocker	function
(	O
lt	pointer
,	O
region	pointer
,	O
sh_locker	pointer
,	O
indx	short
)	O
;	O
if	O
(	O
freed	int
!=	O
NULL	O
)	O
*	O
freed	int
=	O
1	int
;	O
}	O
freelock	O
:	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCK_FREE	int
)	O
)	O
{	O
lockp	pointer
->	O
status	int
=	O
DB_LSTAT_FREE	int
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
lockp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___lock_addfamilylocker	function
(	O
dbenv	pointer
,	O
pid	int
,	O
id	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
pid	int
,	O
id	int
;	O
{	O
DB_LOCKER	struct
*	O
lockerp	pointer
,	O
*	O
mlockerp	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
ndx	int
;	O
int	O
ret	int
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
ndx	int
=	O
CDB___lock_locker_hash	function
(	O
pid	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
pid	int
,	O
ndx	int
,	O
1	int
,	O
&	O
mlockerp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ndx	int
=	O
CDB___lock_locker_hash	function
(	O
id	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
id	int
,	O
ndx	int
,	O
1	int
,	O
&	O
lockerp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
lockerp	pointer
->	O
parent_locker	long
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
mlockerp	pointer
)	O
;	O
if	O
(	O
mlockerp	pointer
->	O
master_locker	long
==	O
INVALID_ROFF	int
)	O
lockerp	pointer
->	O
master_locker	long
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
mlockerp	pointer
)	O
;	O
else	O
{	O
lockerp	pointer
->	O
master_locker	long
=	O
mlockerp	pointer
->	O
master_locker	long
;	O
mlockerp	pointer
=	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
mlockerp	pointer
->	O
master_locker	long
)	O
;	O
}	O
SH_LIST_INSERT_HEAD	O
(	O
&	O
mlockerp	pointer
->	O
child_locker	struct
,	O
lockerp	pointer
,	O
child_link	struct
,	O
__db_locker	struct
)	O
;	O
err	pointer
:	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___lock_freefamilylocker	function
(	O
lt	pointer
,	O
locker	int
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
locker	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
u_int32_t	int
indx	short
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
lt	pointer
->	O
dbenv	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
indx	short
=	O
CDB___lock_locker_hash	function
(	O
locker	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
locker	int
,	O
indx	short
,	O
0	int
,	O
&	O
sh_locker	pointer
)	O
)	O
!=	O
0	int
||	O
sh_locker	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
EACCES	int
;	O
goto	O
freelock	O
;	O
}	O
if	O
(	O
SH_LIST_FIRST	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
!=	O
NULL	O
)	O
{	O
ret	int
=	O
EINVAL	int
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Freeing locker with locks"	pointer
)	O
;	O
goto	O
freelock	O
;	O
}	O
if	O
(	O
sh_locker	pointer
->	O
master_locker	long
!=	O
INVALID_ROFF	int
)	O
SH_LIST_REMOVE	O
(	O
sh_locker	pointer
,	O
child_link	struct
,	O
__db_locker	struct
)	O
;	O
CDB___lock_freelocker	function
(	O
lt	pointer
,	O
region	pointer
,	O
sh_locker	pointer
,	O
indx	short
)	O
;	O
freelock	O
:	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___lock_freelocker	function
(	O
lt	pointer
,	O
region	pointer
,	O
sh_locker	pointer
,	O
indx	short
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
u_int32_t	int
indx	short
;	O
{	O
HASHREMOVE_EL	O
(	O
lt	pointer
->	O
locker_tab	pointer
,	O
indx	short
,	O
__db_locker	struct
,	O
links	struct
,	O
sh_locker	pointer
)	O
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_lockers	struct
,	O
sh_locker	pointer
,	O
links	struct
,	O
__db_locker	struct
)	O
;	O
region	pointer
->	O
nlockers	int
--	O
;	O
}	O
int	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
locker	int
,	O
indx	short
,	O
create	int
,	O
retp	pointer
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
locker	int
,	O
indx	short
;	O
int	O
create	int
;	O
DB_LOCKER	struct
*	O
*	O
retp	pointer
;	O
{	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
HASHLOOKUP	O
(	O
lt	pointer
->	O
locker_tab	pointer
,	O
indx	short
,	O
__db_locker	struct
,	O
links	struct
,	O
locker	int
,	O
sh_locker	pointer
,	O
CDB___lock_locker_cmp	function
)	O
;	O
if	O
(	O
sh_locker	pointer
==	O
NULL	O
&&	O
create	int
)	O
{	O
if	O
(	O
(	O
sh_locker	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
region	pointer
->	O
free_lockers	struct
,	O
__db_locker	struct
)	O
)	O
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
lt	pointer
->	O
dbenv	pointer
,	O
__db_lock_err	array
,	O
"locker entries"	pointer
)	O
;	O
return	O
(	O
ENOMEM	int
)	O
;	O
}	O
SH_TAILQ_REMOVE	O
(	O
&	O
region	pointer
->	O
free_lockers	struct
,	O
sh_locker	pointer
,	O
links	struct
,	O
__db_locker	struct
)	O
;	O
if	O
(	O
++	O
region	pointer
->	O
nlockers	int
>	O
region	pointer
->	O
maxnlockers	int
)	O
region	pointer
->	O
maxnlockers	int
=	O
region	pointer
->	O
nlockers	int
;	O
sh_locker	pointer
->	O
id	int
=	O
locker	int
;	O
sh_locker	pointer
->	O
dd_id	int
=	O
0	int
;	O
sh_locker	pointer
->	O
master_locker	long
=	O
INVALID_ROFF	int
;	O
sh_locker	pointer
->	O
parent_locker	long
=	O
INVALID_ROFF	int
;	O
SH_LIST_INIT	O
(	O
&	O
sh_locker	pointer
->	O
child_locker	struct
)	O
;	O
sh_locker	pointer
->	O
flags	int
=	O
0	int
;	O
SH_LIST_INIT	O
(	O
&	O
sh_locker	pointer
->	O
heldby	struct
)	O
;	O
HASHINSERT	O
(	O
lt	pointer
->	O
locker_tab	pointer
,	O
indx	short
,	O
__db_locker	struct
,	O
links	struct
,	O
sh_locker	pointer
)	O
;	O
}	O
*	O
retp	pointer
=	O
sh_locker	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___lock_getobj	function
(	O
lt	pointer
,	O
obj	pointer
,	O
ndx	int
,	O
create	int
,	O
retp	pointer
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
const	O
DBT	struct
*	O
obj	pointer
;	O
u_int32_t	int
ndx	int
;	O
int	O
create	int
;	O
DB_LOCKOBJ	struct
*	O
*	O
retp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCKOBJ	struct
*	O
sh_obj	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
int	O
ret	int
;	O
void	O
*	O
p	pointer
;	O
dbenv	pointer
=	O
lt	pointer
->	O
dbenv	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
HASHLOOKUP	O
(	O
lt	pointer
->	O
obj_tab	pointer
,	O
ndx	int
,	O
__db_lockobj	struct
,	O
links	struct
,	O
obj	pointer
,	O
sh_obj	pointer
,	O
CDB___lock_cmp	function
)	O
;	O
if	O
(	O
sh_obj	pointer
==	O
NULL	O
&&	O
create	int
)	O
{	O
if	O
(	O
(	O
sh_obj	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
region	pointer
->	O
free_objs	struct
,	O
__db_lockobj	struct
)	O
)	O
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
lt	pointer
->	O
dbenv	pointer
,	O
__db_lock_err	array
,	O
"object entries"	pointer
)	O
;	O
ret	int
=	O
ENOMEM	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
obj	pointer
->	O
size	int
<=	O
sizeof	O
(	O
sh_obj	pointer
->	O
objdata	array
)	O
)	O
p	pointer
=	O
sh_obj	pointer
->	O
objdata	array
;	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
obj	pointer
->	O
size	int
,	O
0	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"No space for lock object storage"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
memcpy	function
(	O
p	pointer
,	O
obj	pointer
->	O
data	pointer
,	O
obj	pointer
->	O
size	int
)	O
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
region	pointer
->	O
free_objs	struct
,	O
sh_obj	pointer
,	O
links	struct
,	O
__db_lockobj	struct
)	O
;	O
SH_TAILQ_INIT	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
)	O
;	O
SH_TAILQ_INIT	O
(	O
&	O
sh_obj	pointer
->	O
holders	struct
)	O
;	O
sh_obj	pointer
->	O
lockobj	struct
.	O
size	int
=	O
obj	pointer
->	O
size	int
;	O
sh_obj	pointer
->	O
lockobj	struct
.	O
off	long
=	O
SH_PTR_TO_OFF	O
(	O
&	O
sh_obj	pointer
->	O
lockobj	struct
,	O
p	pointer
)	O
;	O
HASHINSERT	O
(	O
lt	pointer
->	O
obj_tab	pointer
,	O
ndx	int
,	O
__db_lockobj	struct
,	O
links	struct
,	O
sh_obj	pointer
)	O
;	O
}	O
*	O
retp	pointer
=	O
sh_obj	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__lock_is_parent	function
(	O
lt	pointer
,	O
locker	int
,	O
sh_locker	pointer
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
locker	int
;	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
{	O
DB_LOCKER	struct
*	O
parent	pointer
;	O
parent	pointer
=	O
sh_locker	pointer
;	O
while	O
(	O
parent	pointer
->	O
parent_locker	long
!=	O
INVALID_ROFF	int
)	O
{	O
parent	pointer
=	O
(	O
DB_LOCKER	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
parent	pointer
->	O
parent_locker	long
)	O
;	O
if	O
(	O
parent	pointer
->	O
id	int
==	O
locker	int
)	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___lock_promote	function
(	O
lt	pointer
,	O
obj	pointer
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
DB_LOCKOBJ	struct
*	O
obj	pointer
;	O
{	O
struct	O
__db_lock	struct
*	O
lp_w	pointer
,	O
*	O
lp_h	pointer
,	O
*	O
next_waiter	pointer
;	O
DB_LOCKER	struct
*	O
sh_locker	pointer
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
u_int32_t	int
locker_ndx	int
;	O
int	O
had_waiters	int
,	O
state_changed	int
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
had_waiters	int
=	O
0	int
;	O
for	O
(	O
lp_w	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
,	O
state_changed	int
=	O
lp_w	pointer
==	O
NULL	O
;	O
lp_w	pointer
!=	O
NULL	O
;	O
lp_w	pointer
=	O
next_waiter	pointer
)	O
{	O
had_waiters	int
=	O
1	int
;	O
next_waiter	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp_w	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
for	O
(	O
lp_h	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
obj	pointer
->	O
holders	struct
,	O
__db_lock	struct
)	O
;	O
lp_h	pointer
!=	O
NULL	O
;	O
lp_h	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp_h	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
)	O
{	O
if	O
(	O
lp_h	pointer
->	O
holder	int
!=	O
lp_w	pointer
->	O
holder	int
&&	O
CONFLICTS	O
(	O
lt	pointer
,	O
region	pointer
,	O
lp_h	pointer
->	O
mode	enum
,	O
lp_w	pointer
->	O
mode	enum
)	O
)	O
{	O
locker_ndx	int
=	O
CDB___lock_locker_hash	function
(	O
lp_w	pointer
->	O
holder	int
)	O
%	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
CDB___lock_getlocker	function
(	O
lt	pointer
,	O
lp_w	pointer
->	O
holder	int
,	O
locker_ndx	int
,	O
0	int
,	O
&	O
sh_locker	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
__lock_is_parent	function
(	O
lt	pointer
,	O
lp_h	pointer
->	O
holder	int
,	O
sh_locker	pointer
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
lp_h	pointer
!=	O
NULL	O
)	O
break	O
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
obj	pointer
->	O
waiters	struct
,	O
lp_w	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
lp_w	pointer
->	O
status	int
=	O
DB_LSTAT_PENDING	int
;	O
SH_TAILQ_INSERT_TAIL	O
(	O
&	O
obj	pointer
->	O
holders	struct
,	O
lp_w	pointer
,	O
links	struct
)	O
;	O
MUTEX_UNLOCK	O
(	O
&	O
lp_w	pointer
->	O
mutex	union
)	O
;	O
state_changed	int
=	O
1	int
;	O
}	O
if	O
(	O
had_waiters	int
&&	O
SH_TAILQ_FIRST	O
(	O
&	O
obj	pointer
->	O
waiters	struct
,	O
__db_lock	struct
)	O
==	O
NULL	O
)	O
SH_TAILQ_REMOVE	O
(	O
&	O
region	pointer
->	O
dd_objs	struct
,	O
obj	pointer
,	O
dd_links	struct
,	O
__db_lockobj	struct
)	O
;	O
return	O
(	O
state_changed	int
)	O
;	O
}	O
static	O
void	O
__lock_remove_waiter	function
(	O
sh_obj	pointer
,	O
lockp	pointer
,	O
status	int
)	O
DB_LOCKOBJ	struct
*	O
sh_obj	pointer
;	O
struct	O
__db_lock	struct
*	O
lockp	pointer
;	O
db_status_t	enum
status	int
;	O
{	O
int	O
do_wakeup	int
;	O
do_wakeup	int
=	O
lockp	pointer
->	O
status	int
==	O
DB_LSTAT_WAITING	int
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
sh_obj	pointer
->	O
waiters	struct
,	O
lockp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
lockp	pointer
->	O
links	struct
.	O
stqe_prev	long
=	O
-	O
1	int
;	O
lockp	pointer
->	O
status	int
=	O
status	int
;	O
if	O
(	O
do_wakeup	int
)	O
MUTEX_UNLOCK	O
(	O
&	O
lockp	pointer
->	O
mutex	union
)	O
;	O
}	O
void	O
CDB___lock_printlock	function
(	O
lt	pointer
,	O
lp	pointer
,	O
ispgno	int
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
struct	O
__db_lock	struct
*	O
lp	pointer
;	O
int	O
ispgno	int
;	O
{	O
DB_LOCKOBJ	struct
*	O
lockobj	struct
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
*	O
fidp	pointer
;	O
u_int8_t	char
*	O
ptr	pointer
,	O
type	enum
;	O
const	O
char	O
*	O
mode	enum
,	O
*	O
status	int
;	O
switch	O
(	O
lp	pointer
->	O
mode	enum
)	O
{	O
case	O
DB_LOCK_IREAD	int
:	O
mode	enum
=	O
"IREAD"	pointer
;	O
break	O
;	O
case	O
DB_LOCK_IWR	int
:	O
mode	enum
=	O
"IWR"	pointer
;	O
break	O
;	O
case	O
DB_LOCK_IWRITE	int
:	O
mode	enum
=	O
"IWRITE"	pointer
;	O
break	O
;	O
case	O
DB_LOCK_NG	int
:	O
mode	enum
=	O
"NG"	pointer
;	O
break	O
;	O
case	O
DB_LOCK_READ	int
:	O
mode	enum
=	O
"READ"	pointer
;	O
break	O
;	O
case	O
DB_LOCK_WRITE	int
:	O
mode	enum
=	O
"WRITE"	pointer
;	O
break	O
;	O
default	O
:	O
mode	enum
=	O
"UNKNOWN"	pointer
;	O
break	O
;	O
}	O
switch	O
(	O
lp	pointer
->	O
status	int
)	O
{	O
case	O
DB_LSTAT_ABORTED	int
:	O
status	int
=	O
"ABORT"	pointer
;	O
break	O
;	O
case	O
DB_LSTAT_ERR	int
:	O
status	int
=	O
"ERROR"	pointer
;	O
break	O
;	O
case	O
DB_LSTAT_FREE	int
:	O
status	int
=	O
"FREE"	pointer
;	O
break	O
;	O
case	O
DB_LSTAT_HELD	int
:	O
status	int
=	O
"HELD"	pointer
;	O
break	O
;	O
case	O
DB_LSTAT_NOGRANT	int
:	O
status	int
=	O
"NONE"	pointer
;	O
break	O
;	O
case	O
DB_LSTAT_WAITING	int
:	O
status	int
=	O
"WAIT"	pointer
;	O
break	O
;	O
case	O
DB_LSTAT_PENDING	int
:	O
status	int
=	O
"PENDING"	pointer
;	O
break	O
;	O
default	O
:	O
status	int
=	O
"UNKNOWN"	pointer
;	O
break	O
;	O
}	O
printf	function
(	O
"\t%lx\t%s\t%lu\t%s\t"	pointer
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
holder	int
,	O
mode	enum
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
refcount	int
,	O
status	int
)	O
;	O
lockobj	struct
=	O
(	O
DB_LOCKOBJ	struct
*	O
)	O
(	O
(	O
u_int8_t	char
*	O
)	O
lp	pointer
+	O
lp	pointer
->	O
obj	pointer
)	O
;	O
ptr	pointer
=	O
SH_DBT_PTR	O
(	O
&	O
lockobj	struct
->	O
lockobj	struct
)	O
;	O
if	O
(	O
ispgno	int
&&	O
lockobj	struct
->	O
lockobj	struct
.	O
size	int
==	O
sizeof	O
(	O
struct	O
__db_ilock	struct
)	O
)	O
{	O
memcpy	function
(	O
&	O
pgno	int
,	O
ptr	pointer
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
fidp	pointer
=	O
(	O
u_int32_t	int
*	O
)	O
(	O
ptr	pointer
+	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
type	enum
=	O
*	O
(	O
u_int8_t	char
*	O
)	O
(	O
ptr	pointer
+	O
sizeof	O
(	O
db_pgno_t	int
)	O
+	O
DB_FILE_ID_LEN	int
)	O
;	O
printf	function
(	O
"%s  %lu (%lu %lu %lu %lu %lu)\n"	pointer
,	O
type	enum
==	O
DB_PAGE_LOCK	int
?	O
"page"	pointer
:	O
"record"	pointer
,	O
(	O
u_long	long
)	O
pgno	int
,	O
(	O
u_long	long
)	O
fidp	pointer
[	O
0	int
]	O
,	O
(	O
u_long	long
)	O
fidp	pointer
[	O
1	int
]	O
,	O
(	O
u_long	long
)	O
fidp	pointer
[	O
2	int
]	O
,	O
(	O
u_long	long
)	O
fidp	pointer
[	O
3	int
]	O
,	O
(	O
u_long	long
)	O
fidp	pointer
[	O
4	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"0x%lx "	pointer
,	O
(	O
u_long	long
)	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lockobj	struct
)	O
)	O
;	O
CDB___db_pr	function
(	O
ptr	pointer
,	O
lockobj	struct
->	O
lockobj	struct
.	O
size	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
