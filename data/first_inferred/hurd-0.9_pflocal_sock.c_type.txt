error_t	O
sock_acquire_read_pipe	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
struct	O
pipe	pointer
*	O
*	O
pipe	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
*	O
pipe	pointer
=	O
sock	pointer
->	O
read_pipe	pointer
;	O
if	O
(	O
*	O
pipe	pointer
!=	O
NULL	O
)	O
if	O
(	O
!	O
(	O
sock	pointer
->	O
pipe_class	pointer
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
&&	O
!	O
(	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
)	O
err	O
=	O
ENOTCONN	O
;	O
else	O
pipe_acquire_reader	function
(	O
*	O
pipe	pointer
)	O
;	O
else	O
if	O
(	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
)	O
err	O
=	O
EPIPE	O
;	O
else	O
err	O
=	O
ENOTCONN	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
sock_acquire_write_pipe	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
struct	O
pipe	pointer
*	O
*	O
pipe	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
*	O
pipe	pointer
=	O
sock	pointer
->	O
write_pipe	pointer
;	O
if	O
(	O
*	O
pipe	pointer
!=	O
NULL	O
)	O
pipe_acquire_writer	function
(	O
*	O
pipe	pointer
)	O
;	O
else	O
if	O
(	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
err	O
=	O
EPIPE	O
;	O
else	O
if	O
(	O
sock	pointer
->	O
pipe_class	pointer
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
EDESTADDRREQ	O
;	O
else	O
err	O
=	O
ENOTCONN	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
sock_create	function
(	O
struct	O
pipe_class	pointer
*	O
pipe_class	pointer
,	O
mode_t	O
mode	int
,	O
struct	O
sock	pointer
*	O
*	O
sock	pointer
)	O
{	O
error_t	O
err	O
;	O
struct	O
sock	pointer
*	O
new	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
sock	pointer
)	O
)	O
;	O
if	O
(	O
new	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
err	O
=	O
pipe_create	function
(	O
pipe_class	pointer
,	O
&	O
new	pointer
->	O
read_pipe	pointer
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
return	O
err	O
;	O
}	O
pipe_add_reader	function
(	O
new	pointer
->	O
read_pipe	pointer
)	O
;	O
new	pointer
->	O
refs	int
=	O
0	int
;	O
new	pointer
->	O
flags	int
=	O
0	int
;	O
new	pointer
->	O
write_pipe	pointer
=	O
NULL	O
;	O
new	pointer
->	O
mode	int
=	O
mode	int
;	O
new	pointer
->	O
id	int
=	O
MACH_PORT_NULL	O
;	O
new	pointer
->	O
listen_queue	pointer
=	O
NULL	O
;	O
new	pointer
->	O
connect_queue	pointer
=	O
NULL	O
;	O
new	pointer
->	O
pipe_class	pointer
=	O
pipe_class	pointer
;	O
new	pointer
->	O
addr	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
new	pointer
->	O
change_time	int
,	O
0	int
,	O
sizeof	O
(	O
new	pointer
->	O
change_time	int
)	O
)	O
;	O
pthread_mutex_init	function
(	O
&	O
new	pointer
->	O
lock	union
,	O
NULL	O
)	O
;	O
*	O
sock	pointer
=	O
new	pointer
;	O
return	O
0	int
;	O
}	O
void	O
sock_free	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
)	O
{	O
sock_shutdown	function
(	O
sock	pointer
,	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
|	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
;	O
if	O
(	O
sock	pointer
->	O
id	int
!=	O
MACH_PORT_NULL	O
)	O
mach_port_destroy	function
(	O
mach_task_self	function
(	O
)	O
,	O
sock	pointer
->	O
id	int
)	O
;	O
if	O
(	O
sock	pointer
->	O
listen_queue	pointer
)	O
connq_destroy	function
(	O
sock	pointer
->	O
listen_queue	pointer
)	O
;	O
free	function
(	O
sock	pointer
)	O
;	O
}	O
void	O
_sock_norefs	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
)	O
{	O
assert	function
(	O
sock	pointer
->	O
addr	pointer
==	O
NULL	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
sock_free	function
(	O
sock	pointer
)	O
;	O
}	O
error_t	O
sock_clone	function
(	O
struct	O
sock	pointer
*	O
template	pointer
,	O
struct	O
sock	pointer
*	O
*	O
sock	pointer
)	O
{	O
error_t	O
err	O
=	O
sock_create	function
(	O
template	pointer
->	O
pipe_class	pointer
,	O
template	pointer
->	O
mode	int
,	O
sock	pointer
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
(	O
*	O
sock	pointer
)	O
->	O
flags	int
=	O
template	pointer
->	O
flags	int
&	O
~	O
PFLOCAL_SOCK_CONNECTED	int
;	O
return	O
0	int
;	O
}	O
struct	O
port_class	O
*	O
sock_user_port_class	pointer
;	O
static	O
void	O
sock_user_clean	function
(	O
void	O
*	O
vuser	pointer
)	O
{	O
struct	O
sock_user	struct
*	O
user	pointer
=	O
vuser	pointer
;	O
sock_deref	function
(	O
user	pointer
->	O
sock	pointer
)	O
;	O
}	O
error_t	O
sock_create_port	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
mach_port_t	O
*	O
port	pointer
)	O
{	O
struct	O
sock_user	struct
*	O
user	pointer
;	O
error_t	O
err	O
=	O
ports_create_port	O
(	O
sock_user_port_class	pointer
,	O
sock_port_bucket	O
,	O
sizeof	O
(	O
struct	O
sock_user	struct
)	O
,	O
&	O
user	pointer
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
ensure_sock_server	function
(	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
sock	pointer
->	O
refs	int
++	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
user	pointer
->	O
sock	pointer
=	O
sock	pointer
;	O
*	O
port	pointer
=	O
ports_get_right	function
(	O
user	pointer
)	O
;	O
ports_port_deref	function
(	O
user	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
addr	pointer
{	O
struct	O
port_info	O
pi	struct
;	O
struct	O
sock	pointer
*	O
sock	pointer
;	O
pthread_mutex_t	union
lock	union
;	O
}	O
;	O
struct	O
port_class	O
*	O
addr_port_class	pointer
;	O
static	O
void	O
addr_unbind	function
(	O
void	O
*	O
vaddr	pointer
)	O
{	O
struct	O
sock	pointer
*	O
sock	pointer
;	O
struct	O
addr	pointer
*	O
addr	pointer
=	O
vaddr	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
addr	pointer
->	O
lock	union
)	O
;	O
sock	pointer
=	O
addr	pointer
->	O
sock	pointer
;	O
if	O
(	O
sock	pointer
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
sock	pointer
->	O
addr	pointer
=	O
NULL	O
;	O
addr	pointer
->	O
sock	pointer
=	O
NULL	O
;	O
ports_port_deref_weak	function
(	O
addr	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
sock_deref	function
(	O
sock	pointer
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
addr	pointer
->	O
lock	union
)	O
;	O
}	O
static	O
void	O
addr_clean	function
(	O
void	O
*	O
vaddr	pointer
)	O
{	O
struct	O
addr	pointer
*	O
addr	pointer
=	O
vaddr	pointer
;	O
assert	function
(	O
addr	pointer
->	O
sock	pointer
==	O
NULL	O
)	O
;	O
}	O
inline	O
error_t	O
addr_create	function
(	O
struct	O
addr	pointer
*	O
*	O
addr	pointer
)	O
{	O
error_t	O
err	O
=	O
ports_create_port	O
(	O
addr_port_class	pointer
,	O
sock_port_bucket	O
,	O
sizeof	O
(	O
struct	O
addr	pointer
)	O
,	O
addr	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
ensure_sock_server	function
(	O
)	O
;	O
(	O
*	O
addr	pointer
)	O
->	O
sock	pointer
=	O
NULL	O
;	O
pthread_mutex_init	function
(	O
&	O
(	O
*	O
addr	pointer
)	O
->	O
lock	union
,	O
NULL	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
sock_bind	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
struct	O
addr	pointer
*	O
addr	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
addr	pointer
*	O
old_addr	pointer
;	O
if	O
(	O
addr	pointer
)	O
pthread_mutex_lock	function
(	O
&	O
addr	pointer
->	O
lock	union
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
old_addr	pointer
=	O
sock	pointer
->	O
addr	pointer
;	O
if	O
(	O
addr	pointer
&&	O
old_addr	pointer
)	O
err	O
=	O
EINVAL	O
;	O
else	O
if	O
(	O
!	O
addr	pointer
&&	O
!	O
old_addr	pointer
)	O
err	O
=	O
EINVAL	O
;	O
else	O
if	O
(	O
addr	pointer
&&	O
addr	pointer
->	O
sock	pointer
)	O
err	O
=	O
EADDRINUSE	O
;	O
else	O
if	O
(	O
addr	pointer
)	O
addr	pointer
->	O
sock	pointer
=	O
sock	pointer
;	O
else	O
old_addr	pointer
->	O
sock	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
sock	pointer
->	O
addr	pointer
=	O
addr	pointer
;	O
if	O
(	O
addr	pointer
)	O
{	O
sock	pointer
->	O
refs	int
++	O
;	O
ports_port_ref_weak	function
(	O
addr	pointer
)	O
;	O
}	O
if	O
(	O
old_addr	pointer
)	O
{	O
sock	pointer
->	O
refs	int
--	O
;	O
ports_port_deref_weak	function
(	O
old_addr	pointer
)	O
;	O
assert	function
(	O
sock	pointer
->	O
refs	int
>	O
0	int
)	O
;	O
}	O
}	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
if	O
(	O
addr	pointer
)	O
pthread_mutex_unlock	function
(	O
&	O
addr	pointer
->	O
lock	union
)	O
;	O
return	O
err	O
;	O
}	O
static	O
inline	O
error_t	O
ensure_addr	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
struct	O
addr	pointer
*	O
*	O
addr	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
!	O
sock	pointer
->	O
addr	pointer
)	O
{	O
err	O
=	O
addr_create	function
(	O
&	O
sock	pointer
->	O
addr	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
sock	pointer
->	O
addr	pointer
->	O
sock	pointer
=	O
sock	pointer
;	O
sock	pointer
->	O
refs	int
++	O
;	O
ports_port_ref_weak	function
(	O
sock	pointer
->	O
addr	pointer
)	O
;	O
}	O
}	O
else	O
ports_port_ref	function
(	O
sock	pointer
->	O
addr	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
addr	pointer
=	O
sock	pointer
->	O
addr	pointer
;	O
return	O
err	O
;	O
}	O
error_t	O
addr_get_sock	function
(	O
struct	O
addr	pointer
*	O
addr	pointer
,	O
struct	O
sock	pointer
*	O
*	O
sock	pointer
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
addr	pointer
->	O
lock	union
)	O
;	O
*	O
sock	pointer
=	O
addr	pointer
->	O
sock	pointer
;	O
if	O
(	O
*	O
sock	pointer
)	O
(	O
*	O
sock	pointer
)	O
->	O
refs	int
++	O
;	O
pthread_mutex_unlock	function
(	O
&	O
addr	pointer
->	O
lock	union
)	O
;	O
return	O
*	O
sock	pointer
?	O
0	int
:	O
EADDRNOTAVAIL	O
;	O
}	O
error_t	O
sock_get_addr	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
struct	O
addr	pointer
*	O
*	O
addr	pointer
)	O
{	O
error_t	O
err	O
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
err	O
=	O
ensure_addr	function
(	O
sock	pointer
,	O
addr	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
return	O
err	O
;	O
}	O
static	O
pthread_mutex_t	union
socket_pair_lock	union
;	O
error_t	O
sock_connect	function
(	O
struct	O
sock	pointer
*	O
sock1	pointer
,	O
struct	O
sock	pointer
*	O
sock2	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
pipe	pointer
*	O
old_sock1_write_pipe	pointer
=	O
NULL	O
;	O
struct	O
addr	pointer
*	O
old_sock1_write_addr	pointer
=	O
NULL	O
;	O
void	O
connect	function
(	O
struct	O
sock	pointer
*	O
wr	pointer
,	O
struct	O
sock	pointer
*	O
rd	pointer
)	O
{	O
if	O
(	O
!	O
(	O
(	O
wr	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
||	O
(	O
rd	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
)	O
)	O
)	O
{	O
struct	O
pipe	pointer
*	O
pipe	pointer
=	O
rd	pointer
->	O
read_pipe	pointer
;	O
assert	function
(	O
pipe	pointer
)	O
;	O
pipe_add_writer	O
(	O
pipe	pointer
)	O
;	O
wr	pointer
->	O
write_pipe	pointer
=	O
pipe	pointer
;	O
}	O
}	O
if	O
(	O
sock1	pointer
->	O
pipe_class	pointer
!=	O
sock2	pointer
->	O
pipe_class	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	function
(	O
&	O
socket_pair_lock	union
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
sock1	pointer
->	O
lock	union
)	O
;	O
if	O
(	O
sock1	pointer
!=	O
sock2	pointer
)	O
pthread_mutex_lock	function
(	O
&	O
sock2	pointer
->	O
lock	union
)	O
;	O
if	O
(	O
(	O
sock1	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
||	O
(	O
sock2	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
)	O
err	O
=	O
EISCONN	O
;	O
else	O
{	O
old_sock1_write_pipe	pointer
=	O
sock1	pointer
->	O
write_pipe	pointer
;	O
old_sock1_write_addr	pointer
=	O
sock1	pointer
->	O
write_addr	pointer
;	O
connect	function
(	O
sock1	pointer
,	O
sock2	pointer
)	O
;	O
if	O
(	O
!	O
(	O
sock1	pointer
->	O
pipe_class	pointer
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
)	O
{	O
sock1	pointer
->	O
flags	int
|=	O
PFLOCAL_SOCK_CONNECTED	int
;	O
if	O
(	O
sock1	pointer
!=	O
sock2	pointer
)	O
{	O
connect	function
(	O
sock2	pointer
,	O
sock1	pointer
)	O
;	O
sock2	pointer
->	O
flags	int
|=	O
PFLOCAL_SOCK_CONNECTED	int
;	O
}	O
}	O
}	O
if	O
(	O
sock1	pointer
!=	O
sock2	pointer
)	O
pthread_mutex_unlock	function
(	O
&	O
sock2	pointer
->	O
lock	union
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock1	pointer
->	O
lock	union
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
socket_pair_lock	union
)	O
;	O
if	O
(	O
old_sock1_write_pipe	pointer
)	O
{	O
pipe_remove_writer	function
(	O
old_sock1_write_pipe	pointer
)	O
;	O
ports_port_deref	function
(	O
old_sock1_write_addr	pointer
)	O
;	O
}	O
return	O
err	O
;	O
}	O
void	O
sock_shutdown	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
unsigned	O
flags	int
)	O
{	O
unsigned	O
old_flags	int
;	O
struct	O
pipe	pointer
*	O
read_pipe	pointer
=	O
NULL	O
;	O
struct	O
pipe	pointer
*	O
write_pipe	pointer
=	O
NULL	O
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
old_flags	int
=	O
sock	pointer
->	O
flags	int
;	O
sock	pointer
->	O
flags	int
|=	O
flags	int
;	O
if	O
(	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
&&	O
!	O
(	O
old_flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
)	O
)	O
{	O
read_pipe	pointer
=	O
sock	pointer
->	O
read_pipe	pointer
;	O
sock	pointer
->	O
read_pipe	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
&&	O
!	O
(	O
old_flags	int
&	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
)	O
)	O
{	O
write_pipe	pointer
=	O
sock	pointer
->	O
write_pipe	pointer
;	O
sock	pointer
->	O
write_pipe	pointer
=	O
NULL	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
if	O
(	O
read_pipe	pointer
)	O
pipe_remove_reader	function
(	O
read_pipe	pointer
)	O
;	O
if	O
(	O
write_pipe	pointer
)	O
pipe_remove_writer	function
(	O
write_pipe	pointer
)	O
;	O
}	O
error_t	O
sock_global_init	function
(	O
)	O
{	O
sock_port_bucket	O
=	O
ports_create_bucket	function
(	O
)	O
;	O
sock_user_port_class	pointer
=	O
ports_create_class	function
(	O
sock_user_clean	function
,	O
NULL	O
)	O
;	O
addr_port_class	pointer
=	O
ports_create_class	function
(	O
addr_clean	function
,	O
addr_unbind	function
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
sock_global_shutdown	function
(	O
)	O
{	O
int	O
num_ports	int
=	O
ports_count_bucket	function
(	O
sock_port_bucket	O
)	O
;	O
ports_enable_bucket	function
(	O
sock_port_bucket	O
)	O
;	O
return	O
(	O
num_ports	int
==	O
0	int
?	O
0	int
:	O
EBUSY	O
)	O
;	O
}	O
