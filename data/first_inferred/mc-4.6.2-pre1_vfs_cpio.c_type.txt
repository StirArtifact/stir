enum	O
{	O
STATUS_START	int
,	O
STATUS_OK	int
,	O
STATUS_TRAIL	int
,	O
STATUS_FAIL	int
,	O
STATUS_EOF	int
}	O
;	O
enum	O
{	O
CPIO_UNKNOWN	int
=	O
0	int
,	O
CPIO_BIN	int
,	O
CPIO_BINRE	int
,	O
CPIO_OLDC	int
,	O
CPIO_NEWC	int
,	O
CPIO_CRC	int
}	O
;	O
static	O
struct	O
vfs_class	struct
vfs_cpiofs_ops	struct
;	O
struct	O
old_cpio_header	struct
{	O
unsigned	O
short	O
c_magic	short
;	O
short	O
c_dev	short
;	O
unsigned	O
short	O
c_ino	short
;	O
unsigned	O
short	O
c_mode	short
;	O
unsigned	O
short	O
c_uid	short
;	O
unsigned	O
short	O
c_gid	short
;	O
unsigned	O
short	O
c_nlink	short
;	O
short	O
c_rdev	short
;	O
unsigned	O
short	O
c_mtimes	array
[	O
2	int
]	O
;	O
unsigned	O
short	O
c_namesize	short
;	O
unsigned	O
short	O
c_filesizes	array
[	O
2	int
]	O
;	O
}	O
;	O
struct	O
new_cpio_header	struct
{	O
unsigned	O
short	O
c_magic	short
;	O
unsigned	O
long	O
c_ino	short
;	O
unsigned	O
long	O
c_mode	short
;	O
unsigned	O
long	O
c_uid	short
;	O
unsigned	O
long	O
c_gid	short
;	O
unsigned	O
long	O
c_nlink	short
;	O
unsigned	O
long	O
c_mtime	long
;	O
unsigned	O
long	O
c_filesize	long
;	O
long	O
c_dev	short
;	O
long	O
c_devmin	long
;	O
long	O
c_rdev	short
;	O
long	O
c_rdevmin	long
;	O
unsigned	O
long	O
c_namesize	short
;	O
unsigned	O
long	O
c_chksum	long
;	O
}	O
;	O
struct	O
defer_inode	struct
{	O
struct	O
defer_inode	struct
*	O
next	pointer
;	O
unsigned	O
long	O
inumber	long
;	O
unsigned	O
short	O
device	short
;	O
struct	O
vfs_s_inode	struct
*	O
inode	pointer
;	O
}	O
;	O
static	O
int	O
cpio_position	int
;	O
static	O
int	O
cpio_find_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
;	O
static	O
int	O
cpio_read_bin_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
;	O
static	O
int	O
cpio_read_oldc_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
;	O
static	O
int	O
cpio_read_crc_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
;	O
static	O
int	O
cpio_create_entry	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
struct	O
stat	struct
*	O
,	O
char	O
*	O
name	pointer
)	O
;	O
static	O
int	O
cpio_read	function
(	O
void	O
*	O
fh	pointer
,	O
char	O
*	O
buffer	pointer
,	O
int	O
count	int
)	O
;	O
static	O
struct	O
defer_inode	struct
*	O
cpio_defer_find	function
(	O
struct	O
defer_inode	struct
*	O
l	pointer
,	O
struct	O
defer_inode	struct
*	O
i	array
)	O
{	O
while	O
(	O
l	pointer
&&	O
(	O
l	pointer
->	O
inumber	long
!=	O
i	array
->	O
inumber	long
||	O
l	pointer
->	O
device	short
!=	O
i	array
->	O
device	short
)	O
)	O
l	pointer
=	O
l	pointer
->	O
next	pointer
;	O
return	O
l	pointer
;	O
}	O
static	O
int	O
cpio_skip_padding	function
(	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
switch	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
)	O
{	O
case	O
CPIO_BIN	int
:	O
case	O
CPIO_BINRE	int
:	O
return	O
CPIO_SEEK_CUR	O
(	O
super	pointer
,	O
(	O
2	int
-	O
(	O
CPIO_POS	O
(	O
super	pointer
)	O
%	O
2	int
)	O
)	O
%	O
2	int
)	O
;	O
case	O
CPIO_NEWC	int
:	O
case	O
CPIO_CRC	int
:	O
return	O
CPIO_SEEK_CUR	O
(	O
super	pointer
,	O
(	O
4	int
-	O
(	O
CPIO_POS	O
(	O
super	pointer
)	O
%	O
4	int
)	O
)	O
%	O
4	int
)	O
;	O
case	O
CPIO_OLDC	int
:	O
return	O
CPIO_POS	O
(	O
super	pointer
)	O
;	O
default	O
:	O
g_assert_not_reached	O
(	O
)	O
;	O
return	O
42	int
;	O
}	O
}	O
static	O
void	O
cpio_free_archive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
struct	O
defer_inode	struct
*	O
l	pointer
,	O
*	O
lnext	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
if	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
!=	O
-	O
1	int
)	O
mc_close	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
)	O
;	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
=	O
-	O
1	int
;	O
for	O
(	O
l	pointer
=	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
deferred	pointer
;	O
l	pointer
;	O
l	pointer
=	O
lnext	pointer
)	O
{	O
lnext	pointer
=	O
l	pointer
->	O
next	pointer
;	O
g_free	function
(	O
l	pointer
)	O
;	O
}	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
deferred	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
cpio_open_cpio_file	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
fd	int
,	O
type	enum
;	O
mode_t	int
mode	int
;	O
struct	O
vfs_s_inode	struct
*	O
root	pointer
;	O
if	O
(	O
(	O
fd	int
=	O
mc_open	function
(	O
name	pointer
,	O
O_RDONLY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot open cpio archive\n%s"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
super	pointer
->	O
name	pointer
=	O
g_strdup	function
(	O
name	pointer
)	O
;	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
=	O
-	O
1	int
;	O
mc_stat	function
(	O
name	pointer
,	O
&	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
)	O
)	O
;	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
CPIO_UNKNOWN	int
;	O
type	enum
=	O
get_compression_type	function
(	O
fd	int
)	O
;	O
if	O
(	O
type	enum
!=	O
COMPRESSION_NONE	int
)	O
{	O
char	O
*	O
s	pointer
;	O
mc_close	function
(	O
fd	int
)	O
;	O
s	pointer
=	O
g_strconcat	function
(	O
name	pointer
,	O
decompress_extension	function
(	O
type	enum
)	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
mc_open	function
(	O
s	pointer
,	O
O_RDONLY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot open cpio archive\n%s"	pointer
)	O
,	O
s	pointer
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
g_free	function
(	O
s	pointer
)	O
;	O
}	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
=	O
fd	int
;	O
mode	int
=	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
.	O
st_mode	int
&	O
07777	int
;	O
mode	int
|=	O
(	O
mode	int
&	O
0444	int
)	O
>>	O
2	int
;	O
mode	int
|=	O
S_IFDIR	O
;	O
root	pointer
=	O
vfs_s_new_inode	function
(	O
me	pointer
,	O
super	pointer
,	O
&	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
)	O
)	O
;	O
root	pointer
->	O
st	pointer
.	O
st_mode	int
=	O
mode	int
;	O
root	pointer
->	O
data_offset	long
=	O
-	O
1	int
;	O
root	pointer
->	O
st	pointer
.	O
st_nlink	long
++	O
;	O
root	pointer
->	O
st	pointer
.	O
st_dev	long
=	O
MEDATA	O
->	O
rdev	long
++	O
;	O
super	pointer
->	O
root	pointer
=	O
root	pointer
;	O
CPIO_SEEK_SET	O
(	O
super	pointer
,	O
0	int
)	O
;	O
return	O
fd	int
;	O
}	O
static	O
int	O
cpio_read_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
switch	O
(	O
cpio_find_head	function
(	O
me	pointer
,	O
super	pointer
)	O
)	O
{	O
case	O
CPIO_UNKNOWN	int
:	O
return	O
-	O
1	int
;	O
case	O
CPIO_BIN	int
:	O
case	O
CPIO_BINRE	int
:	O
return	O
cpio_read_bin_head	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
case	O
CPIO_OLDC	int
:	O
return	O
cpio_read_oldc_head	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
case	O
CPIO_NEWC	int
:	O
case	O
CPIO_CRC	int
:	O
return	O
cpio_read_crc_head	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
default	O
:	O
g_assert_not_reached	O
(	O
)	O
;	O
return	O
42	int
;	O
}	O
}	O
static	O
int	O
cpio_find_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
int	O
ptr	pointer
=	O
0	int
;	O
int	O
top	pointer
;	O
int	O
tmp	int
;	O
top	pointer
=	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
buf	pointer
,	O
256	int
)	O
;	O
if	O
(	O
top	pointer
>	O
0	int
)	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
top	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
ptr	pointer
+	O
MAGIC_LENGTH	O
>=	O
top	pointer
)	O
{	O
if	O
(	O
top	pointer
>	O
128	int
)	O
{	O
memmove	function
(	O
buf	pointer
,	O
buf	pointer
+	O
top	pointer
-	O
128	int
,	O
128	int
)	O
;	O
ptr	pointer
-=	O
top	pointer
-	O
128	int
;	O
top	pointer
=	O
128	int
;	O
}	O
if	O
(	O
(	O
tmp	int
=	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
buf	pointer
,	O
top	pointer
)	O
)	O
==	O
0	int
||	O
tmp	int
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Premature end of cpio archive\n%s"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
cpio_free_archive	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
return	O
CPIO_UNKNOWN	int
;	O
}	O
top	pointer
+=	O
tmp	int
;	O
}	O
if	O
(	O
TYPEIS	O
(	O
CPIO_BIN	int
)	O
&&	O
(	O
(	O
*	O
(	O
unsigned	O
short	O
*	O
)	O
(	O
buf	pointer
+	O
ptr	pointer
)	O
)	O
==	O
070707	int
)	O
)	O
{	O
SEEKBACK	O
;	O
RETURN	O
(	O
CPIO_BIN	int
)	O
;	O
}	O
else	O
if	O
(	O
TYPEIS	O
(	O
CPIO_BINRE	int
)	O
&&	O
(	O
(	O
*	O
(	O
unsigned	O
short	O
*	O
)	O
(	O
buf	pointer
+	O
ptr	pointer
)	O
)	O
==	O
GUINT16_SWAP_LE_BE_CONSTANT	O
(	O
070707	int
)	O
)	O
)	O
{	O
SEEKBACK	O
;	O
RETURN	O
(	O
CPIO_BINRE	int
)	O
;	O
}	O
else	O
if	O
(	O
TYPEIS	O
(	O
CPIO_OLDC	int
)	O
&&	O
(	O
!	O
strncmp	function
(	O
buf	pointer
+	O
ptr	pointer
,	O
"070707"	pointer
,	O
6	int
)	O
)	O
)	O
{	O
SEEKBACK	O
;	O
RETURN	O
(	O
CPIO_OLDC	int
)	O
;	O
}	O
else	O
if	O
(	O
TYPEIS	O
(	O
CPIO_NEWC	int
)	O
&&	O
(	O
!	O
strncmp	function
(	O
buf	pointer
+	O
ptr	pointer
,	O
"070701"	pointer
,	O
6	int
)	O
)	O
)	O
{	O
SEEKBACK	O
;	O
RETURN	O
(	O
CPIO_NEWC	int
)	O
;	O
}	O
else	O
if	O
(	O
TYPEIS	O
(	O
CPIO_CRC	int
)	O
&&	O
(	O
!	O
strncmp	function
(	O
buf	pointer
+	O
ptr	pointer
,	O
"070702"	pointer
,	O
6	int
)	O
)	O
)	O
{	O
SEEKBACK	O
;	O
RETURN	O
(	O
CPIO_CRC	int
)	O
;	O
}	O
;	O
ptr	pointer
++	O
;	O
}	O
}	O
static	O
int	O
cpio_read_bin_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
union	O
{	O
struct	O
old_cpio_header	struct
buf	pointer
;	O
short	O
shorts	array
[	O
HEAD_LENGTH	O
>>	O
1	int
]	O
;	O
}	O
u	union
;	O
int	O
len	int
;	O
char	O
*	O
name	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
(	O
len	int
=	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
(	O
char	O
*	O
)	O
&	O
u	union
.	O
buf	pointer
,	O
HEAD_LENGTH	O
)	O
)	O
<	O
HEAD_LENGTH	O
)	O
return	O
STATUS_EOF	int
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
len	int
;	O
if	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_BINRE	int
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
(	O
HEAD_LENGTH	O
>>	O
1	int
)	O
;	O
i	array
++	O
)	O
u	union
.	O
shorts	array
[	O
i	array
]	O
=	O
GUINT16_SWAP_LE_BE_CONSTANT	O
(	O
u	union
.	O
shorts	array
[	O
i	array
]	O
)	O
;	O
}	O
g_assert	O
(	O
u	union
.	O
buf	pointer
.	O
c_magic	short
==	O
070707	int
)	O
;	O
if	O
(	O
u	union
.	O
buf	pointer
.	O
c_namesize	short
==	O
0	int
||	O
u	union
.	O
buf	pointer
.	O
c_namesize	short
>	O
MC_MAXPATHLEN	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Corrupted cpio header encountered in\n%s"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
return	O
STATUS_FAIL	int
;	O
}	O
name	pointer
=	O
g_malloc	function
(	O
u	union
.	O
buf	pointer
.	O
c_namesize	short
)	O
;	O
if	O
(	O
(	O
len	int
=	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
name	pointer
,	O
u	union
.	O
buf	pointer
.	O
c_namesize	short
)	O
)	O
<	O
u	union
.	O
buf	pointer
.	O
c_namesize	short
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_EOF	int
;	O
}	O
name	pointer
[	O
u	union
.	O
buf	pointer
.	O
c_namesize	short
-	O
1	int
]	O
=	O
'\0'	O
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
len	int
;	O
cpio_skip_padding	function
(	O
super	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
"TRAILER!!!"	pointer
,	O
name	pointer
)	O
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_TRAIL	int
;	O
}	O
st	pointer
.	O
st_dev	long
=	O
u	union
.	O
buf	pointer
.	O
c_dev	short
;	O
st	pointer
.	O
st_ino	long
=	O
u	union
.	O
buf	pointer
.	O
c_ino	short
;	O
st	pointer
.	O
st_mode	int
=	O
u	union
.	O
buf	pointer
.	O
c_mode	short
;	O
st	pointer
.	O
st_nlink	long
=	O
u	union
.	O
buf	pointer
.	O
c_nlink	short
;	O
st	pointer
.	O
st_uid	int
=	O
u	union
.	O
buf	pointer
.	O
c_uid	short
;	O
st	pointer
.	O
st_gid	int
=	O
u	union
.	O
buf	pointer
.	O
c_gid	short
;	O
st	pointer
.	O
st_rdev	long
=	O
u	union
.	O
buf	pointer
.	O
c_rdev	short
;	O
st	pointer
.	O
st_size	long
=	O
(	O
u	union
.	O
buf	pointer
.	O
c_filesizes	array
[	O
0	int
]	O
<<	O
16	int
)	O
|	O
u	union
.	O
buf	pointer
.	O
c_filesizes	array
[	O
1	int
]	O
;	O
st	pointer
.	O
st_atime	O
=	O
st	pointer
.	O
st_mtime	O
=	O
st	pointer
.	O
st_ctime	O
=	O
(	O
u	union
.	O
buf	pointer
.	O
c_mtimes	array
[	O
0	int
]	O
<<	O
16	int
)	O
|	O
u	union
.	O
buf	pointer
.	O
c_mtimes	array
[	O
1	int
]	O
;	O
return	O
cpio_create_entry	function
(	O
me	pointer
,	O
super	pointer
,	O
&	O
st	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
int	O
cpio_read_oldc_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
struct	O
new_cpio_header	struct
hd	struct
;	O
union	O
{	O
struct	O
stat	struct
st	pointer
;	O
char	O
buf	pointer
[	O
HEAD_LENGTH	O
+	O
1	int
]	O
;	O
}	O
u	union
;	O
int	O
len	int
;	O
char	O
*	O
name	pointer
;	O
if	O
(	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
u	union
.	O
buf	pointer
,	O
HEAD_LENGTH	O
)	O
!=	O
HEAD_LENGTH	O
)	O
return	O
STATUS_EOF	int
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
HEAD_LENGTH	O
;	O
u	union
.	O
buf	pointer
[	O
HEAD_LENGTH	O
]	O
=	O
0	int
;	O
if	O
(	O
sscanf	function
(	O
u	union
.	O
buf	pointer
,	O
"070707%6lo%6lo%6lo%6lo%6lo%6lo%6lo%11lo%6lo%11lo"	pointer
,	O
&	O
hd	struct
.	O
c_dev	short
,	O
&	O
hd	struct
.	O
c_ino	short
,	O
&	O
hd	struct
.	O
c_mode	short
,	O
&	O
hd	struct
.	O
c_uid	short
,	O
&	O
hd	struct
.	O
c_gid	short
,	O
&	O
hd	struct
.	O
c_nlink	short
,	O
&	O
hd	struct
.	O
c_rdev	short
,	O
&	O
hd	struct
.	O
c_mtime	long
,	O
&	O
hd	struct
.	O
c_namesize	short
,	O
&	O
hd	struct
.	O
c_filesize	long
)	O
<	O
10	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Corrupted cpio header encountered in\n%s"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
return	O
STATUS_FAIL	int
;	O
}	O
if	O
(	O
hd	struct
.	O
c_namesize	short
==	O
0	int
||	O
hd	struct
.	O
c_namesize	short
>	O
MC_MAXPATHLEN	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Corrupted cpio header encountered in\n%s"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
return	O
STATUS_FAIL	int
;	O
}	O
name	pointer
=	O
g_malloc	function
(	O
hd	struct
.	O
c_namesize	short
)	O
;	O
if	O
(	O
(	O
len	int
=	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
name	pointer
,	O
hd	struct
.	O
c_namesize	short
)	O
)	O
==	O
-	O
1	int
||	O
(	O
unsigned	O
long	O
)	O
len	int
<	O
hd	struct
.	O
c_namesize	short
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_EOF	int
;	O
}	O
name	pointer
[	O
hd	struct
.	O
c_namesize	short
-	O
1	int
]	O
=	O
'\0'	O
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
len	int
;	O
cpio_skip_padding	function
(	O
super	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
"TRAILER!!!"	pointer
,	O
name	pointer
)	O
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_TRAIL	int
;	O
}	O
u	union
.	O
st	pointer
.	O
st_dev	long
=	O
hd	struct
.	O
c_dev	short
;	O
u	union
.	O
st	pointer
.	O
st_ino	long
=	O
hd	struct
.	O
c_ino	short
;	O
u	union
.	O
st	pointer
.	O
st_mode	int
=	O
hd	struct
.	O
c_mode	short
;	O
u	union
.	O
st	pointer
.	O
st_nlink	long
=	O
hd	struct
.	O
c_nlink	short
;	O
u	union
.	O
st	pointer
.	O
st_uid	int
=	O
hd	struct
.	O
c_uid	short
;	O
u	union
.	O
st	pointer
.	O
st_gid	int
=	O
hd	struct
.	O
c_gid	short
;	O
u	union
.	O
st	pointer
.	O
st_rdev	long
=	O
hd	struct
.	O
c_rdev	short
;	O
u	union
.	O
st	pointer
.	O
st_size	long
=	O
hd	struct
.	O
c_filesize	long
;	O
u	union
.	O
st	pointer
.	O
st_atime	O
=	O
u	union
.	O
st	pointer
.	O
st_mtime	O
=	O
u	union
.	O
st	pointer
.	O
st_ctime	O
=	O
hd	struct
.	O
c_mtime	long
;	O
return	O
cpio_create_entry	function
(	O
me	pointer
,	O
super	pointer
,	O
&	O
u	union
.	O
st	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
int	O
cpio_read_crc_head	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
struct	O
new_cpio_header	struct
hd	struct
;	O
union	O
{	O
struct	O
stat	struct
st	pointer
;	O
char	O
buf	pointer
[	O
HEAD_LENGTH	O
+	O
1	int
]	O
;	O
}	O
u	union
;	O
int	O
len	int
;	O
char	O
*	O
name	pointer
;	O
if	O
(	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
u	union
.	O
buf	pointer
,	O
HEAD_LENGTH	O
)	O
!=	O
HEAD_LENGTH	O
)	O
return	O
STATUS_EOF	int
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
HEAD_LENGTH	O
;	O
u	union
.	O
buf	pointer
[	O
HEAD_LENGTH	O
]	O
=	O
0	int
;	O
if	O
(	O
sscanf	function
(	O
u	union
.	O
buf	pointer
,	O
"%6ho%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx%8lx"	pointer
,	O
&	O
hd	struct
.	O
c_magic	short
,	O
&	O
hd	struct
.	O
c_ino	short
,	O
&	O
hd	struct
.	O
c_mode	short
,	O
&	O
hd	struct
.	O
c_uid	short
,	O
&	O
hd	struct
.	O
c_gid	short
,	O
&	O
hd	struct
.	O
c_nlink	short
,	O
&	O
hd	struct
.	O
c_mtime	long
,	O
&	O
hd	struct
.	O
c_filesize	long
,	O
&	O
hd	struct
.	O
c_dev	short
,	O
&	O
hd	struct
.	O
c_devmin	long
,	O
&	O
hd	struct
.	O
c_rdev	short
,	O
&	O
hd	struct
.	O
c_rdevmin	long
,	O
&	O
hd	struct
.	O
c_namesize	short
,	O
&	O
hd	struct
.	O
c_chksum	long
)	O
<	O
14	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Corrupted cpio header encountered in\n%s"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
return	O
STATUS_FAIL	int
;	O
}	O
if	O
(	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_NEWC	int
&&	O
hd	struct
.	O
c_magic	short
!=	O
070701	int
)	O
||	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_CRC	int
&&	O
hd	struct
.	O
c_magic	short
!=	O
070702	int
)	O
)	O
return	O
STATUS_FAIL	int
;	O
if	O
(	O
hd	struct
.	O
c_namesize	short
==	O
0	int
||	O
hd	struct
.	O
c_namesize	short
>	O
MC_MAXPATHLEN	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Corrupted cpio header encountered in\n%s"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
return	O
STATUS_FAIL	int
;	O
}	O
name	pointer
=	O
g_malloc	function
(	O
hd	struct
.	O
c_namesize	short
)	O
;	O
if	O
(	O
(	O
len	int
=	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
name	pointer
,	O
hd	struct
.	O
c_namesize	short
)	O
)	O
==	O
-	O
1	int
||	O
(	O
unsigned	O
long	O
)	O
len	int
<	O
hd	struct
.	O
c_namesize	short
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_EOF	int
;	O
}	O
name	pointer
[	O
hd	struct
.	O
c_namesize	short
-	O
1	int
]	O
=	O
'\0'	O
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
len	int
;	O
cpio_skip_padding	function
(	O
super	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
"TRAILER!!!"	pointer
,	O
name	pointer
)	O
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_TRAIL	int
;	O
}	O
u	union
.	O
st	pointer
.	O
st_dev	long
=	O
makedev	O
(	O
hd	struct
.	O
c_dev	short
,	O
hd	struct
.	O
c_devmin	long
)	O
;	O
u	union
.	O
st	pointer
.	O
st_ino	long
=	O
hd	struct
.	O
c_ino	short
;	O
u	union
.	O
st	pointer
.	O
st_mode	int
=	O
hd	struct
.	O
c_mode	short
;	O
u	union
.	O
st	pointer
.	O
st_nlink	long
=	O
hd	struct
.	O
c_nlink	short
;	O
u	union
.	O
st	pointer
.	O
st_uid	int
=	O
hd	struct
.	O
c_uid	short
;	O
u	union
.	O
st	pointer
.	O
st_gid	int
=	O
hd	struct
.	O
c_gid	short
;	O
u	union
.	O
st	pointer
.	O
st_rdev	long
=	O
makedev	O
(	O
hd	struct
.	O
c_rdev	short
,	O
hd	struct
.	O
c_rdevmin	long
)	O
;	O
u	union
.	O
st	pointer
.	O
st_size	long
=	O
hd	struct
.	O
c_filesize	long
;	O
u	union
.	O
st	pointer
.	O
st_atime	O
=	O
u	union
.	O
st	pointer
.	O
st_mtime	O
=	O
u	union
.	O
st	pointer
.	O
st_ctime	O
=	O
hd	struct
.	O
c_mtime	long
;	O
return	O
cpio_create_entry	function
(	O
me	pointer
,	O
super	pointer
,	O
&	O
u	union
.	O
st	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
int	O
cpio_create_entry	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
vfs_s_inode	struct
*	O
inode	pointer
=	O
NULL	O
;	O
struct	O
vfs_s_inode	struct
*	O
root	pointer
=	O
super	pointer
->	O
root	pointer
;	O
struct	O
vfs_s_entry	struct
*	O
entry	pointer
=	O
NULL	O
;	O
char	O
*	O
tn	pointer
;	O
switch	O
(	O
st	pointer
->	O
st_mode	int
&	O
S_IFMT	O
)	O
{	O
case	O
S_IFCHR	O
:	O
case	O
S_IFBLK	O
:	O
case	O
S_IFSOCK	O
:	O
case	O
S_IFIFO	O
:	O
if	O
(	O
(	O
st	pointer
->	O
st_size	long
!=	O
0	int
)	O
&&	O
(	O
st	pointer
->	O
st_rdev	long
==	O
0x0001	int
)	O
)	O
{	O
st	pointer
->	O
st_rdev	long
=	O
(	O
unsigned	O
)	O
st	pointer
->	O
st_size	long
;	O
st	pointer
->	O
st_size	long
=	O
0	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
(	O
st	pointer
->	O
st_nlink	long
>	O
1	int
)	O
&&	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_NEWC	int
||	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_CRC	int
)	O
)	O
{	O
struct	O
defer_inode	struct
i	array
,	O
*	O
l	pointer
;	O
i	array
.	O
inumber	long
=	O
st	pointer
->	O
st_ino	long
;	O
i	array
.	O
device	short
=	O
st	pointer
->	O
st_dev	long
;	O
i	array
.	O
inode	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
l	pointer
=	O
cpio_defer_find	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
deferred	pointer
,	O
&	O
i	array
)	O
)	O
!=	O
NULL	O
)	O
{	O
inode	pointer
=	O
l	pointer
->	O
inode	pointer
;	O
if	O
(	O
inode	pointer
->	O
st	pointer
.	O
st_size	long
&&	O
st	pointer
->	O
st_size	long
&&	O
(	O
inode	pointer
->	O
st	pointer
.	O
st_size	long
!=	O
st	pointer
->	O
st_size	long
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Inconsistent hardlinks of\n%s\nin cpio archive\n%s"	pointer
)	O
,	O
name	pointer
,	O
super	pointer
->	O
name	pointer
)	O
;	O
inode	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
inode	pointer
->	O
st	pointer
.	O
st_size	long
)	O
inode	pointer
->	O
st	pointer
.	O
st_size	long
=	O
st	pointer
->	O
st_size	long
;	O
}	O
}	O
for	O
(	O
tn	pointer
=	O
name	pointer
+	O
strlen	function
(	O
name	pointer
)	O
-	O
1	int
;	O
tn	pointer
>=	O
name	pointer
&&	O
*	O
tn	pointer
==	O
PATH_SEP	char
;	O
tn	pointer
--	O
)	O
*	O
tn	pointer
=	O
0	int
;	O
if	O
(	O
(	O
tn	pointer
=	O
strrchr	function
(	O
name	pointer
,	O
PATH_SEP	char
)	O
)	O
)	O
{	O
*	O
tn	pointer
=	O
0	int
;	O
root	pointer
=	O
vfs_s_find_inode	function
(	O
me	pointer
,	O
super	pointer
,	O
name	pointer
,	O
LINK_FOLLOW	int
,	O
FL_MKDIR	int
)	O
;	O
*	O
tn	pointer
=	O
PATH_SEP	char
;	O
tn	pointer
++	O
;	O
}	O
else	O
tn	pointer
=	O
name	pointer
;	O
entry	pointer
=	O
MEDATA	O
->	O
find_entry	pointer
(	O
me	pointer
,	O
root	pointer
,	O
tn	pointer
,	O
LINK_FOLLOW	int
,	O
FL_NONE	int
)	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
if	O
(	O
!	O
S_ISDIR	O
(	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"%s contains duplicate entries! Skipping!"	pointer
)	O
,	O
super	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
{	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_mode	int
=	O
st	pointer
->	O
st_mode	int
;	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_uid	int
=	O
st	pointer
->	O
st_uid	int
;	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_gid	int
=	O
st	pointer
->	O
st_gid	int
;	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_atime	O
=	O
st	pointer
->	O
st_atime	O
;	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_mtime	O
=	O
st	pointer
->	O
st_mtime	O
;	O
entry	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_ctime	O
=	O
st	pointer
->	O
st_ctime	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
inode	pointer
)	O
{	O
inode	pointer
=	O
vfs_s_new_inode	function
(	O
me	pointer
,	O
super	pointer
,	O
st	pointer
)	O
;	O
if	O
(	O
(	O
st	pointer
->	O
st_nlink	long
>	O
0	int
)	O
&&	O
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_NEWC	int
||	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
CPIO_CRC	int
)	O
)	O
{	O
struct	O
defer_inode	struct
*	O
i	array
;	O
i	array
=	O
g_new	O
(	O
struct	O
defer_inode	struct
,	O
1	int
)	O
;	O
i	array
->	O
inumber	long
=	O
st	pointer
->	O
st_ino	long
;	O
i	array
->	O
device	short
=	O
st	pointer
->	O
st_dev	long
;	O
i	array
->	O
inode	pointer
=	O
inode	pointer
;	O
i	array
->	O
next	pointer
=	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
deferred	pointer
;	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
deferred	pointer
=	O
i	array
;	O
}	O
}	O
if	O
(	O
st	pointer
->	O
st_size	long
)	O
inode	pointer
->	O
data_offset	long
=	O
CPIO_POS	O
(	O
super	pointer
)	O
;	O
entry	pointer
=	O
vfs_s_new_entry	function
(	O
me	pointer
,	O
tn	pointer
,	O
inode	pointer
)	O
;	O
vfs_s_insert_entry	function
(	O
me	pointer
,	O
root	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
->	O
st_mode	int
)	O
)	O
{	O
inode	pointer
->	O
linkname	pointer
=	O
g_malloc	function
(	O
st	pointer
->	O
st_size	long
+	O
1	int
)	O
;	O
if	O
(	O
mc_read	function
(	O
super	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
,	O
inode	pointer
->	O
linkname	pointer
,	O
st	pointer
->	O
st_size	long
)	O
<	O
st	pointer
->	O
st_size	long
)	O
{	O
inode	pointer
->	O
linkname	pointer
[	O
0	int
]	O
=	O
0	int
;	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_EOF	int
;	O
}	O
inode	pointer
->	O
linkname	pointer
[	O
st	pointer
->	O
st_size	long
]	O
=	O
0	int
;	O
CPIO_POS	O
(	O
super	pointer
)	O
+=	O
st	pointer
->	O
st_size	long
;	O
cpio_skip_padding	function
(	O
super	pointer
)	O
;	O
}	O
else	O
{	O
CPIO_SEEK_CUR	O
(	O
super	pointer
,	O
st	pointer
->	O
st_size	long
)	O
;	O
}	O
}	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
STATUS_OK	int
;	O
}	O
static	O
int	O
cpio_open_archive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
char	O
*	O
op	pointer
)	O
{	O
int	O
status	int
=	O
STATUS_START	int
;	O
(	O
void	O
)	O
op	pointer
;	O
if	O
(	O
cpio_open_cpio_file	function
(	O
me	pointer
,	O
super	pointer
,	O
name	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
status	int
=	O
cpio_read_head	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
switch	O
(	O
status	int
)	O
{	O
case	O
STATUS_EOF	int
:	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Unexpected end of file\n%s"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
case	O
STATUS_OK	int
:	O
continue	O
;	O
case	O
STATUS_TRAIL	int
:	O
break	O
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
*	O
cpio_super_check	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
op	pointer
)	O
{	O
static	O
struct	O
stat	struct
sb	struct
;	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
op	pointer
;	O
if	O
(	O
mc_stat	function
(	O
archive_name	pointer
,	O
&	O
sb	struct
)	O
)	O
return	O
NULL	O
;	O
return	O
&	O
sb	struct
;	O
}	O
static	O
int	O
cpio_super_same	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
parc	pointer
,	O
const	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
op	pointer
,	O
void	O
*	O
cookie	pointer
)	O
{	O
struct	O
stat	struct
*	O
archive_stat	pointer
=	O
cookie	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
op	pointer
;	O
if	O
(	O
strcmp	function
(	O
parc	pointer
->	O
name	pointer
,	O
archive_name	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
parc	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
.	O
st_mtime	O
<	O
archive_stat	pointer
->	O
st_mtime	O
)	O
{	O
(	O
*	O
vfs_cpiofs_ops	struct
.	O
free	function
)	O
(	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
vfs_rmstamp	function
(	O
&	O
vfs_cpiofs_ops	struct
,	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
return	O
2	int
;	O
}	O
vfs_stamp	function
(	O
&	O
vfs_cpiofs_ops	struct
,	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
cpio_read	function
(	O
void	O
*	O
fh	pointer
,	O
char	O
*	O
buffer	pointer
,	O
int	O
count	int
)	O
{	O
off_t	long
begin	pointer
=	O
FH	O
->	O
ino	pointer
->	O
data_offset	long
;	O
int	O
fd	int
=	O
FH_SUPER	O
->	O
u	union
.	O
arch	struct
.	O
fd	int
;	O
struct	O
vfs_class	struct
*	O
me	pointer
=	O
FH_SUPER	O
->	O
me	pointer
;	O
if	O
(	O
mc_lseek	function
(	O
fd	int
,	O
begin	pointer
+	O
FH	O
->	O
pos	pointer
,	O
SEEK_SET	int
)	O
!=	O
begin	pointer
+	O
FH	O
->	O
pos	pointer
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
count	int
=	O
MIN	O
(	O
count	int
,	O
FH	O
->	O
ino	pointer
->	O
st	pointer
.	O
st_size	long
-	O
FH	O
->	O
pos	pointer
)	O
;	O
if	O
(	O
(	O
count	int
=	O
mc_read	function
(	O
fd	int
,	O
buffer	pointer
,	O
count	int
)	O
)	O
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
errno	O
,	O
-	O
1	int
)	O
;	O
FH	O
->	O
pos	pointer
+=	O
count	int
;	O
return	O
count	int
;	O
}	O
static	O
int	O
cpio_fh_open	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
,	O
int	O
flags	enum
,	O
int	O
mode	int
)	O
{	O
(	O
void	O
)	O
fh	pointer
;	O
(	O
void	O
)	O
mode	int
;	O
if	O
(	O
(	O
flags	enum
&	O
O_ACCMODE	int
)	O
!=	O
O_RDONLY	int
)	O
ERRNOR	O
(	O
EROFS	int
,	O
-	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
init_cpiofs	function
(	O
void	O
)	O
{	O
static	O
struct	O
vfs_s_subclass	struct
cpio_subclass	struct
;	O
cpio_subclass	struct
.	O
flags	enum
=	O
VFS_S_READONLY	int
;	O
cpio_subclass	struct
.	O
archive_check	pointer
=	O
cpio_super_check	function
;	O
cpio_subclass	struct
.	O
archive_same	pointer
=	O
cpio_super_same	function
;	O
cpio_subclass	struct
.	O
open_archive	pointer
=	O
cpio_open_archive	function
;	O
cpio_subclass	struct
.	O
free_archive	pointer
=	O
cpio_free_archive	function
;	O
cpio_subclass	struct
.	O
fh_open	pointer
=	O
cpio_fh_open	function
;	O
vfs_s_init_class	function
(	O
&	O
vfs_cpiofs_ops	struct
,	O
&	O
cpio_subclass	struct
)	O
;	O
vfs_cpiofs_ops	struct
.	O
name	pointer
=	O
"cpiofs"	pointer
;	O
vfs_cpiofs_ops	struct
.	O
prefix	pointer
=	O
"ucpio"	pointer
;	O
vfs_cpiofs_ops	struct
.	O
read	function
=	O
cpio_read	function
;	O
vfs_cpiofs_ops	struct
.	O
setctl	pointer
=	O
NULL	O
;	O
vfs_register_class	function
(	O
&	O
vfs_cpiofs_ops	struct
)	O
;	O
}	O
