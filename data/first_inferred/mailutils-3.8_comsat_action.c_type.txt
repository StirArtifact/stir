static	O
int	O
expand_escape	function
(	O
char	O
*	O
*	O
pp	pointer
,	O
mu_message_t	pointer
msg	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
pp	pointer
;	O
char	O
*	O
start	long
,	O
*	O
sval	pointer
,	O
*	O
namep	pointer
;	O
int	O
len	int
;	O
mu_header_t	pointer
hdr	pointer
;	O
mu_body_t	pointer
body	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
rc	int
=	O
1	int
;	O
size_t	long
size	pointer
=	O
0	int
,	O
lncount	long
=	O
0	int
;	O
switch	O
(	O
*	O
++	O
p	pointer
)	O
{	O
case	O
'u'	O
:	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
username	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
case	O
'h'	O
:	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
hostname	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
*	O
++	O
p	pointer
!=	O
'{'	O
)	O
break	O
;	O
start	long
=	O
++	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'}'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
break	O
;	O
len	int
=	O
p	pointer
-	O
start	long
;	O
if	O
(	O
len	int
==	O
0	int
||	O
(	O
namep	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
memcpy	function
(	O
namep	pointer
,	O
start	long
,	O
len	int
)	O
;	O
namep	pointer
[	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
==	O
0	int
&&	O
mu_header_aget_value	O
(	O
hdr	pointer
,	O
namep	pointer
,	O
&	O
sval	pointer
)	O
==	O
0	int
)	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
sval	pointer
)	O
;	O
free	function
(	O
namep	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
rc	int
=	O
0	int
;	O
break	O
;	O
case	O
'B'	O
:	O
if	O
(	O
*	O
++	O
p	pointer
==	O
'('	O
)	O
{	O
size	pointer
=	O
strtoul	function
(	O
p	pointer
+	O
1	int
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
lncount	long
=	O
strtoul	function
(	O
p	pointer
+	O
1	int
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
')'	O
)	O
break	O
;	O
}	O
if	O
(	O
size	pointer
==	O
0	int
)	O
size	pointer
=	O
400	int
;	O
if	O
(	O
lncount	long
==	O
0	int
)	O
lncount	long
=	O
maxlines	int
;	O
if	O
(	O
mu_message_get_body	function
(	O
msg	pointer
,	O
&	O
body	pointer
)	O
==	O
0	int
&&	O
mu_body_get_streamref	function
(	O
body	pointer
,	O
&	O
stream	pointer
)	O
==	O
0	int
)	O
{	O
size_t	long
nread	long
;	O
char	O
*	O
buf	pointer
=	O
malloc	function
(	O
size	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
break	O
;	O
if	O
(	O
mu_stream_read	function
(	O
stream	pointer
,	O
buf	pointer
,	O
size	pointer
,	O
&	O
nread	long
)	O
==	O
0	int
)	O
{	O
char	O
*	O
q	pointer
;	O
buf	pointer
[	O
nread	long
]	O
=	O
0	int
;	O
q	pointer
=	O
buf	pointer
;	O
size	pointer
=	O
0	int
;	O
while	O
(	O
lncount	long
--	O
)	O
{	O
char	O
*	O
s	pointer
=	O
strchr	function
(	O
q	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
break	O
;	O
size	pointer
+=	O
s	pointer
-	O
q	pointer
+	O
1	int
;	O
q	pointer
=	O
s	pointer
+	O
1	int
;	O
}	O
mu_opool_append	function
(	O
pool	pointer
,	O
buf	pointer
,	O
size	pointer
)	O
;	O
}	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
*	O
pp	pointer
=	O
p	pointer
;	O
rc	int
=	O
0	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
char	O
*	O
expand_line	function
(	O
const	O
char	O
*	O
str	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
c	char
=	O
0	int
;	O
mu_opool_t	pointer
pool	pointer
;	O
if	O
(	O
!	O
*	O
str	pointer
)	O
return	O
NULL	O
;	O
mu_opool_create	function
(	O
&	O
pool	pointer
,	O
MU_OPOOL_ENOMEMABRT	int
)	O
;	O
for	O
(	O
p	pointer
=	O
str	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'\\'	O
:	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
c	char
=	O
mu_wordsplit_c_unquote_char	function
(	O
*	O
p	pointer
)	O
;	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
c	char
)	O
;	O
}	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
expand_escape	function
(	O
(	O
char	O
*	O
*	O
)	O
&	O
p	pointer
,	O
msg	pointer
,	O
pool	pointer
)	O
==	O
0	int
)	O
break	O
;	O
default	O
:	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
*	O
p	pointer
)	O
;	O
}	O
}	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
0	int
)	O
;	O
str	pointer
=	O
strdup	function
(	O
mu_opool_finish	function
(	O
pool	pointer
,	O
NULL	O
)	O
)	O
;	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
str	pointer
;	O
}	O
const	O
char	O
*	O
default_action	pointer
=	O
;	O
static	O
int	O
study_tty	function
(	O
mu_stream_t	pointer
str	pointer
,	O
char	O
*	O
flt	pointer
[	O
]	O
,	O
int	O
*	O
nflt	pointer
)	O
{	O
mu_transport_t	pointer
trans	array
[	O
2	int
]	O
;	O
int	O
fd	int
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_ioctl	function
(	O
str	pointer
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_ioctl"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
*	O
nflt	pointer
=	O
0	int
;	O
fd	int
=	O
(	O
int	O
)	O
(	O
intptr_t	long
)	O
trans	array
[	O
0	int
]	O
;	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
st	pointer
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
st	pointer
.	O
st_mode	int
&	O
S_IFMT	O
)	O
{	O
case	O
S_IFREG	O
:	O
return	O
0	int
;	O
case	O
S_IFCHR	O
:	O
flt	pointer
[	O
(	O
*	O
nflt	pointer
)	O
++	O
]	O
=	O
"7BIT"	pointer
;	O
{	O
struct	O
termios	struct
tbuf	struct
;	O
if	O
(	O
!	O
(	O
tcgetattr	function
(	O
fd	int
,	O
&	O
tbuf	struct
)	O
==	O
0	int
&&	O
(	O
tbuf	struct
.	O
c_oflag	int
&	O
OPOST	int
)	O
&&	O
(	O
tbuf	struct
.	O
c_oflag	int
&	O
ONLCR	int
)	O
)	O
)	O
{	O
flt	pointer
[	O
(	O
*	O
nflt	pointer
)	O
++	O
]	O
=	O
"+"	pointer
;	O
flt	pointer
[	O
(	O
*	O
nflt	pointer
)	O
++	O
]	O
=	O
"CRLF"	pointer
;	O
}	O
}	O
break	O
;	O
case	O
S_IFSOCK	O
:	O
return	O
0	int
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
mu_stream_t	pointer
_open_tty	function
(	O
const	O
char	O
*	O
device	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
dev	pointer
;	O
int	O
status	int
;	O
char	O
*	O
dfl_argv	array
[	O
4	int
]	O
;	O
status	int
=	O
mu_file_stream_create	function
(	O
&	O
dev	pointer
,	O
device	pointer
,	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open device %s: %s"	pointer
)	O
,	O
device	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
mu_stream_set_buffer	function
(	O
dev	pointer
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
status	int
=	O
study_tty	function
(	O
dev	pointer
,	O
dfl_argv	array
,	O
&	O
argc	int
)	O
;	O
if	O
(	O
status	int
)	O
return	O
NULL	O
;	O
argv	pointer
=	O
dfl_argv	array
;	O
}	O
if	O
(	O
argc	int
)	O
{	O
mu_stream_t	pointer
str	pointer
;	O
status	int
=	O
mu_filter_chain_create	function
(	O
&	O
str	pointer
,	O
dev	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
,	O
argc	int
,	O
argv	pointer
)	O
;	O
mu_stream_unref	function
(	O
dev	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_filter_chain_create"	pointer
,	O
device	pointer
,	O
status	int
)	O
;	O
return	O
NULL	O
;	O
}	O
dev	pointer
=	O
str	pointer
;	O
}	O
return	O
dev	pointer
;	O
}	O
mu_stream_t	pointer
open_tty	function
(	O
const	O
char	O
*	O
device	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
dev	pointer
;	O
if	O
(	O
!	O
device	pointer
||	O
!	O
*	O
device	pointer
||	O
strcmp	function
(	O
device	pointer
,	O
"null"	pointer
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
mu_nullstream_create	function
(	O
&	O
dev	pointer
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open null stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
dev	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
dev	pointer
=	O
_open_tty	function
(	O
device	pointer
,	O
argc	int
,	O
argv	pointer
)	O
;	O
return	O
dev	pointer
;	O
}	O
struct	O
biffrc_environ	struct
{	O
mu_stream_t	pointer
tty	pointer
;	O
mu_stream_t	pointer
logstr	pointer
;	O
mu_message_t	pointer
msg	pointer
;	O
mu_stream_t	pointer
input	pointer
;	O
struct	O
mu_locus_range	struct
locus	struct
;	O
int	O
use_default	int
;	O
char	O
*	O
errbuf	pointer
;	O
size_t	long
errsize	long
;	O
}	O
;	O
static	O
void	O
report_error	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
biffrc_errors	int
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
mu_vasnprintf	function
(	O
&	O
env	pointer
->	O
errbuf	pointer
,	O
&	O
env	pointer
->	O
errsize	long
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
if	O
(	O
biffrc_errors	int
&	O
BIFFRC_ERRORS_TO_TTY	int
)	O
mu_stream_printf	function
(	O
env	pointer
->	O
logstr	pointer
,	O
"%s\n"	pointer
,	O
env	pointer
->	O
errbuf	pointer
)	O
;	O
if	O
(	O
biffrc_errors	int
&	O
BIFFRC_ERRORS_TO_ERR	int
)	O
mu_diag_output	function
(	O
MU_DIAG_ERROR	O
,	O
"%s"	pointer
,	O
env	pointer
->	O
errbuf	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
}	O
static	O
void	O
action_beep	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_write	function
(	O
env	pointer
->	O
tty	pointer
,	O
"\a\a"	pointer
,	O
2	int
,	O
NULL	O
)	O
;	O
mu_stream_flush	function
(	O
env	pointer
->	O
tty	pointer
)	O
;	O
}	O
static	O
void	O
echo_string	function
(	O
mu_stream_t	pointer
tty	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
!	O
str	pointer
)	O
return	O
;	O
mu_stream_write	function
(	O
tty	pointer
,	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
action_echo	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
=	O
1	int
;	O
int	O
omit_newline	int
;	O
if	O
(	O
argc	int
>	O
2	int
&&	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-n"	pointer
)	O
==	O
0	int
)	O
{	O
omit_newline	int
=	O
1	int
;	O
i	int
++	O
;	O
}	O
else	O
omit_newline	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
echo_string	function
(	O
env	pointer
->	O
tty	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
++	O
i	int
<	O
argc	int
)	O
echo_string	function
(	O
env	pointer
->	O
tty	pointer
,	O
" "	pointer
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
omit_newline	int
)	O
echo_string	function
(	O
env	pointer
->	O
tty	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
action_exec	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
pstream	pointer
;	O
struct	O
stat	struct
stb	struct
;	O
int	O
status	int
;	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
if	O
(	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"not an absolute pathname: %s"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stat	struct
(	O
argv	pointer
[	O
0	int
]	O
,	O
&	O
stb	struct
)	O
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"stat"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
errno	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stb	struct
.	O
st_mode	int
&	O
(	O
S_ISUID	O
|	O
S_ISGID	O
)	O
)	O
{	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"will not execute set[ug]id programs"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
status	int
=	O
mu_prog_stream_create	function
(	O
&	O
pstream	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
argv	pointer
,	O
MU_PROG_HINT_ERRTOOUT	int
,	O
NULL	O
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
report_error	function
(	O
env	pointer
,	O
"mu_prog_stream_create(%s) failed: %s"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
;	O
}	O
mu_stream_copy	function
(	O
env	pointer
->	O
tty	pointer
,	O
pstream	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
pstream	pointer
)	O
;	O
}	O
static	O
void	O
action_default	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
env	pointer
->	O
use_default	int
=	O
1	int
;	O
}	O
static	O
void	O
action_tty	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
ntty	pointer
=	O
open_tty	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
argc	int
-	O
2	int
,	O
argv	pointer
+	O
2	int
)	O
;	O
if	O
(	O
!	O
ntty	pointer
)	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"cannot open tty %s"	pointer
)	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
env	pointer
->	O
tty	pointer
)	O
;	O
env	pointer
->	O
tty	pointer
=	O
ntty	pointer
;	O
}	O
static	O
mu_stream_t	pointer
open_rc	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
mu_stream_t	pointer
tty	pointer
)	O
{	O
struct	O
stat	struct
stb	struct
;	O
struct	O
passwd	struct
*	O
pw	pointer
=	O
getpwnam	function
(	O
username	pointer
)	O
;	O
mu_stream_t	pointer
stream	pointer
,	O
input	pointer
;	O
int	O
rc	int
;	O
static	O
char	O
*	O
linecon_args	array
[	O
]	O
=	O
{	O
"linecon"	pointer
,	O
"-i"	pointer
,	O
"#line"	pointer
,	O
NULL	O
}	O
;	O
if	O
(	O
!	O
allow_biffrc	int
||	O
pw	pointer
->	O
pw_uid	int
==	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
stb	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
stb	struct
.	O
st_uid	int
!=	O
pw	pointer
->	O
pw_uid	int
)	O
{	O
mu_diag_output	function
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"%s's %s is not owned by %s"	pointer
)	O
,	O
username	pointer
,	O
filename	pointer
,	O
username	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
stb	struct
.	O
st_mode	int
&	O
0777	int
)	O
!=	O
0600	int
)	O
{	O
mu_stream_printf	function
(	O
tty	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"Warning: your .biffrc has wrong permissions"	pointer
)	O
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"%s's %s has wrong permissions"	pointer
)	O
,	O
username	pointer
,	O
filename	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
input	pointer
,	O
filename	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
rc	int
!=	O
ENOENT	int
)	O
{	O
mu_stream_printf	function
(	O
tty	pointer
,	O
_	O
(	O
"Cannot open .biffrc file: %s\n"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"cannot open %s for %s: %s"	pointer
)	O
,	O
filename	pointer
,	O
username	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
stream	pointer
,	O
input	pointer
,	O
"LINECON"	pointer
,	O
MU_ARRAY_SIZE	O
(	O
linecon_args	array
)	O
-	O
1	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
linecon_args	array
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	function
(	O
input	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_printf	function
(	O
tty	pointer
,	O
_	O
(	O
"Cannot create filter for your .biffrc file: %s\n"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"cannot create filter for file %s of %s: %s"	pointer
)	O
,	O
filename	pointer
,	O
username	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
stream	pointer
;	O
}	O
struct	O
biffrc_stmt	struct
{	O
const	O
char	O
*	O
id	pointer
;	O
int	O
argmin	int
;	O
int	O
argmax	int
;	O
int	O
expand	int
;	O
void	O
(	O
*	O
handler	array
)	O
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
,	O
size_t	long
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
}	O
;	O
struct	O
biffrc_stmt	struct
biffrc_tab	array
[	O
]	O
=	O
{	O
{	O
"beep"	pointer
,	O
1	int
,	O
1	int
,	O
0	int
,	O
action_beep	function
}	O
,	O
{	O
"tty"	pointer
,	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
action_tty	function
}	O
,	O
{	O
"echo"	pointer
,	O
2	int
,	O
-	O
1	int
,	O
1	int
,	O
action_echo	function
}	O
,	O
{	O
"exec"	pointer
,	O
2	int
,	O
-	O
1	int
,	O
1	int
,	O
action_exec	function
}	O
,	O
{	O
"default"	pointer
,	O
1	int
,	O
1	int
,	O
0	int
,	O
action_default	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
biffrc_stmt	struct
*	O
find_stmt	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
biffrc_stmt	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
biffrc_tab	array
;	O
p	pointer
->	O
id	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
p	pointer
->	O
id	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
;	O
return	O
NULL	O
;	O
}	O
void	O
eval_biffrc	function
(	O
struct	O
biffrc_environ	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
stmt	pointer
=	O
NULL	O
;	O
size_t	long
size	pointer
=	O
0	int
;	O
size_t	long
n	int
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
int	O
wsflags	int
;	O
ws	pointer
.	O
ws_comment	pointer
=	O
"#"	pointer
;	O
wsflags	int
=	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_COMMENT	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
env	pointer
->	O
locus	struct
)	O
;	O
mu_stream_ioctl	function
(	O
env	pointer
->	O
logstr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
env	pointer
->	O
locus	struct
)	O
;	O
while	O
(	O
mu_stream_getline	function
(	O
env	pointer
->	O
input	pointer
,	O
&	O
stmt	pointer
,	O
&	O
size	pointer
,	O
&	O
n	int
)	O
==	O
0	int
&&	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
stmt	pointer
,	O
"#line "	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
env	pointer
->	O
locus	struct
.	O
beg	struct
.	O
mu_line	int
=	O
strtoul	function
(	O
stmt	pointer
+	O
6	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
'\n'	O
)	O
{	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"malformed #line directive: %s"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_LINE	int
,	O
&	O
env	pointer
->	O
locus	struct
.	O
beg	struct
.	O
mu_line	int
)	O
;	O
mu_stream_ioctl	function
(	O
env	pointer
->	O
logstr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_LINE	int
,	O
&	O
env	pointer
->	O
locus	struct
.	O
beg	struct
.	O
mu_line	int
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
mu_wordsplit	struct
(	O
stmt	pointer
,	O
&	O
ws	pointer
,	O
wsflags	int
)	O
==	O
0	int
)	O
{	O
struct	O
biffrc_stmt	struct
*	O
sp	pointer
;	O
if	O
(	O
ws	pointer
.	O
ws_wordc	long
==	O
0	int
)	O
{	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
mu_stream_ioctl	function
(	O
env	pointer
->	O
logstr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
sp	pointer
=	O
find_stmt	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"unknown keyword"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
ws	pointer
.	O
ws_wordc	long
<	O
sp	pointer
->	O
argmin	int
)	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"too few arguments"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
sp	pointer
->	O
argmax	int
!=	O
-	O
1	int
&&	O
ws	pointer
.	O
ws_wordc	long
>	O
sp	pointer
->	O
argmax	int
)	O
report_error	function
(	O
env	pointer
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
sp	pointer
->	O
expand	int
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
oldarg	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
;	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
=	O
expand_line	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
,	O
env	pointer
->	O
msg	pointer
)	O
;	O
free	function
(	O
oldarg	pointer
)	O
;	O
if	O
(	O
!	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
)	O
break	O
;	O
}	O
}	O
sp	pointer
->	O
handler	array
(	O
env	pointer
,	O
ws	pointer
.	O
ws_wordc	long
,	O
ws	pointer
.	O
ws_wordv	pointer
)	O
;	O
}	O
}	O
else	O
report_error	function
(	O
env	pointer
,	O
"%s"	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
wsflags	int
|=	O
MU_WRDSF_REUSE	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
mu_stream_ioctl	function
(	O
env	pointer
->	O
logstr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_ADVANCE_LOCUS_LINE	int
,	O
NULL	O
)	O
;	O
}	O
free	function
(	O
stmt	pointer
)	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
NULL	O
)	O
;	O
mu_stream_ioctl	function
(	O
env	pointer
->	O
logstr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
NULL	O
)	O
;	O
}	O
void	O
run_user_action	function
(	O
const	O
char	O
*	O
device	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
int	O
rc	int
,	O
mode	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
struct	O
biffrc_environ	struct
env	pointer
;	O
env	pointer
.	O
tty	pointer
=	O
open_tty	function
(	O
device	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
env	pointer
.	O
tty	pointer
)	O
return	O
;	O
env	pointer
.	O
msg	pointer
=	O
msg	pointer
;	O
env	pointer
.	O
errbuf	pointer
=	O
NULL	O
;	O
env	pointer
.	O
errsize	long
=	O
0	int
;	O
rc	int
=	O
mu_log_stream_create	function
(	O
&	O
env	pointer
.	O
logstr	pointer
,	O
env	pointer
.	O
tty	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_output	function
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"cannot create log stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
env	pointer
.	O
tty	pointer
)	O
;	O
return	O
;	O
}	O
mode	int
=	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	function
(	O
env	pointer
.	O
logstr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
env	pointer
.	O
input	pointer
=	O
open_rc	function
(	O
biffrc	pointer
,	O
env	pointer
.	O
tty	pointer
)	O
;	O
if	O
(	O
env	pointer
.	O
input	pointer
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	function
(	O
)	O
;	O
char	O
*	O
rcname	pointer
;	O
rcname	pointer
=	O
mu_make_file_name	O
(	O
cwd	short
,	O
BIFF_RC	pointer
)	O
;	O
free	function
(	O
cwd	short
)	O
;	O
if	O
(	O
!	O
rcname	pointer
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_make_file_name"	pointer
,	O
NULL	O
,	O
ENOMEM	int
)	O
;	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_file	pointer
=	O
BIFF_RC	pointer
;	O
}	O
else	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_file	pointer
=	O
rcname	pointer
;	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_line	int
=	O
1	int
;	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_col	int
=	O
0	int
;	O
memset	function
(	O
&	O
env	pointer
.	O
locus	struct
.	O
end	struct
,	O
0	int
,	O
sizeof	O
env	pointer
.	O
locus	struct
.	O
end	struct
)	O
;	O
env	pointer
.	O
use_default	int
=	O
0	int
;	O
eval_biffrc	function
(	O
&	O
env	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
env	pointer
.	O
input	pointer
)	O
;	O
free	function
(	O
rcname	pointer
)	O
;	O
}	O
else	O
env	pointer
.	O
use_default	int
=	O
1	int
;	O
if	O
(	O
env	pointer
.	O
use_default	int
&&	O
mu_static_memory_stream_create	function
(	O
&	O
stream	pointer
,	O
default_action	pointer
,	O
strlen	function
(	O
default_action	pointer
)	O
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
mu_filter_create	function
(	O
&	O
env	pointer
.	O
input	pointer
,	O
stream	pointer
,	O
"LINECON"	pointer
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_printf	function
(	O
env	pointer
.	O
tty	pointer
,	O
_	O
(	O
"Cannot create filter for the default action: %s\n"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_NOTICE	O
,	O
_	O
(	O
"cannot create default filter for %s: %s"	pointer
)	O
,	O
username	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_file	pointer
=	O
"<default>"	pointer
;	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_line	int
=	O
1	int
;	O
env	pointer
.	O
locus	struct
.	O
beg	struct
.	O
mu_col	int
=	O
0	int
;	O
eval_biffrc	function
(	O
&	O
env	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
env	pointer
.	O
input	pointer
)	O
;	O
}	O
}	O
mu_stream_destroy	function
(	O
&	O
env	pointer
.	O
logstr	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
env	pointer
.	O
tty	pointer
)	O
;	O
free	function
(	O
env	pointer
.	O
errbuf	pointer
)	O
;	O
}	O
