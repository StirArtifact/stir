static	O
void	O
connection_close_error	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_StatusCode	enum
sc	enum
,	O
const	O
char	O
*	O
emsg	pointer
)	O
{	O
if	O
(	O
NULL	O
!=	O
emsg	pointer
)	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
sc	enum
,	O
emsg	pointer
)	O
;	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_WITH_ERROR	int
)	O
;	O
}	O
static	O
bool	bool
try_grow_read_buffer	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
void	O
*	O
buf	pointer
;	O
size_t	long
new_size	long
;	O
if	O
(	O
0	int
==	O
request	pointer
->	O
read_buffer_size	long
)	O
new_size	long
=	O
daemon	function
->	O
connection_memory_limit_b	long
/	O
2	int
;	O
else	O
new_size	long
=	O
request	pointer
->	O
read_buffer_size	long
+	O
daemon	function
->	O
connection_memory_increment_b	long
;	O
buf	pointer
=	O
MHD_pool_reallocate	function
(	O
request	pointer
->	O
connection	pointer
->	O
pool	pointer
,	O
request	pointer
->	O
read_buffer	pointer
,	O
request	pointer
->	O
read_buffer_size	long
,	O
new_size	long
)	O
;	O
if	O
(	O
NULL	O
==	O
buf	pointer
)	O
return	O
false	int
;	O
request	pointer
->	O
read_buffer	pointer
=	O
buf	pointer
;	O
request	pointer
->	O
read_buffer_size	long
=	O
new_size	long
;	O
return	O
true	int
;	O
}	O
static	O
void	O
MHD_request_handle_read_	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
ssize_t	long
bytes_read	long
;	O
if	O
(	O
(	O
MHD_REQUEST_CLOSED	int
==	O
request	pointer
->	O
state	pointer
)	O
||	O
(	O
connection	pointer
->	O
suspended	enum
)	O
)	O
return	O
;	O
if	O
(	O
request	pointer
->	O
read_buffer_offset	long
+	O
daemon	function
->	O
connection_memory_increment_b	long
>	O
request	pointer
->	O
read_buffer_size	long
)	O
try_grow_read_buffer	function
(	O
request	pointer
)	O
;	O
if	O
(	O
request	pointer
->	O
read_buffer_size	long
==	O
request	pointer
->	O
read_buffer_offset	long
)	O
return	O
;	O
bytes_read	long
=	O
connection	pointer
->	O
recv_cls	pointer
(	O
connection	pointer
,	O
&	O
request	pointer
->	O
read_buffer	pointer
[	O
request	pointer
->	O
read_buffer_offset	long
]	O
,	O
request	pointer
->	O
read_buffer_size	long
-	O
request	pointer
->	O
read_buffer_offset	long
)	O
;	O
if	O
(	O
bytes_read	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
bytes_read	long
)	O
return	O
;	O
if	O
(	O
MHD_ERR_CONNRESET_	O
==	O
bytes_read	long
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
(	O
MHD_REQUEST_INIT	int
==	O
request	pointer
->	O
state	pointer
)	O
?	O
MHD_SC_CONNECTION_CLOSED	int
:	O
MHD_SC_CONNECTION_RESET_CLOSED	int
,	O
(	O
MHD_REQUEST_INIT	int
==	O
request	pointer
->	O
state	pointer
)	O
?	O
NULL	O
:	O
_	O
(	O
"Socket disconnected while reading request.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
(	O
MHD_REQUEST_INIT	int
==	O
request	pointer
->	O
state	pointer
)	O
?	O
MHD_SC_CONNECTION_CLOSED	int
:	O
MHD_SC_CONNECTION_READ_FAIL_CLOSED	int
,	O
(	O
MHD_REQUEST_INIT	int
==	O
request	pointer
->	O
state	pointer
)	O
?	O
NULL	O
:	O
_	O
(	O
"Connection socket is closed due to error when reading request.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
0	int
==	O
bytes_read	long
)	O
{	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_CLIENT_ABORT	int
)	O
;	O
return	O
;	O
}	O
request	pointer
->	O
read_buffer_offset	long
+=	O
bytes_read	long
;	O
MHD_connection_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
switch	O
(	O
request	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_REQUEST_INIT	int
:	O
case	O
MHD_REQUEST_URL_RECEIVED	int
:	O
case	O
MHD_REQUEST_HEADER_PART_RECEIVED	int
:	O
case	O
MHD_REQUEST_HEADERS_RECEIVED	int
:	O
case	O
MHD_REQUEST_HEADERS_PROCESSED	int
:	O
case	O
MHD_REQUEST_CONTINUE_SENDING	int
:	O
case	O
MHD_REQUEST_CONTINUE_SENT	int
:	O
case	O
MHD_REQUEST_BODY_RECEIVED	int
:	O
case	O
MHD_REQUEST_FOOTER_PART_RECEIVED	int
:	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_READ_ERROR	int
)	O
;	O
}	O
return	O
;	O
case	O
MHD_REQUEST_CLOSED	int
:	O
return	O
;	O
case	O
MHD_REQUEST_UPGRADE	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
default	O
:	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
request	pointer
->	O
read_buffer	pointer
,	O
request	pointer
->	O
read_buffer_size	long
+	O
1	int
,	O
request	pointer
->	O
read_buffer_offset	long
)	O
;	O
break	O
;	O
}	O
return	O
;	O
}	O
static	O
ssize_t	long
sendfile_adapter	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
struct	O
MHD_Request	struct
*	O
request	pointer
=	O
&	O
connection	pointer
->	O
request	pointer
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
request	pointer
->	O
response	pointer
;	O
ssize_t	long
ret	long
;	O
const	O
int	O
file_fd	int
=	O
response	pointer
->	O
fd	int
;	O
uint64_t	long
left	long
;	O
uint64_t	long
offsetu64	long
;	O
const	O
uint64_t	long
max_off_t	long
=	O
(	O
uint64_t	long
)	O
OFF64_T_MAX	O
;	O
off64_t	long
offset	long
;	O
const	O
bool	bool
used_thr_p_c	bool
=	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
==	O
daemon	function
->	O
threading_mode	enum
)	O
;	O
const	O
size_t	long
chunk_size	long
=	O
used_thr_p_c	bool
?	O
MHD_SENFILE_CHUNK_THR_P_C_	O
:	O
MHD_SENFILE_CHUNK_	O
;	O
size_t	long
send_size	long
=	O
0	int
;	O
mhd_assert	O
(	O
MHD_resp_sender_sendfile	int
==	O
request	pointer
->	O
resp_sender	enum
)	O
;	O
offsetu64	long
=	O
request	pointer
->	O
response_write_position	long
+	O
response	pointer
->	O
fd_off	long
;	O
left	long
=	O
response	pointer
->	O
total_size	long
-	O
request	pointer
->	O
response_write_position	long
;	O
send_size	long
=	O
(	O
left	long
>	O
chunk_size	long
)	O
?	O
chunk_size	long
:	O
(	O
size_t	long
)	O
left	long
;	O
if	O
(	O
max_off_t	long
<	O
offsetu64	long
)	O
{	O
request	pointer
->	O
resp_sender	enum
=	O
MHD_resp_sender_std	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
offset	long
=	O
(	O
off64_t	long
)	O
offsetu64	long
;	O
ret	long
=	O
sendfile64	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
file_fd	int
,	O
&	O
offset	long
,	O
send_size	long
)	O
;	O
if	O
(	O
0	int
>	O
ret	long
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_ERR_AGAIN_	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_EBADF_	O
)	O
)	O
return	O
MHD_ERR_BADF_	O
;	O
request	pointer
->	O
resp_sender	enum
=	O
MHD_resp_sender_std	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
else	O
if	O
(	O
send_size	long
>	O
(	O
size_t	long
)	O
ret	long
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
ret	long
;	O
}	O
static	O
bool	bool
check_write_done	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
enum	O
MHD_REQUEST_STATE	enum
next_state	enum
)	O
{	O
if	O
(	O
request	pointer
->	O
write_buffer_append_offset	long
!=	O
request	pointer
->	O
write_buffer_send_offset	long
)	O
return	O
false	int
;	O
request	pointer
->	O
write_buffer_append_offset	long
=	O
0	int
;	O
request	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
request	pointer
->	O
state	pointer
=	O
next_state	enum
;	O
MHD_pool_reallocate	function
(	O
request	pointer
->	O
connection	pointer
->	O
pool	pointer
,	O
request	pointer
->	O
write_buffer	pointer
,	O
request	pointer
->	O
write_buffer_size	long
,	O
0	int
)	O
;	O
request	pointer
->	O
write_buffer	pointer
=	O
NULL	O
;	O
request	pointer
->	O
write_buffer_size	long
=	O
0	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
try_ready_normal_body	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
request	pointer
->	O
response	pointer
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
ssize_t	long
ret	long
;	O
if	O
(	O
NULL	O
==	O
response	pointer
->	O
crc	pointer
)	O
return	O
true	int
;	O
if	O
(	O
(	O
0	int
==	O
response	pointer
->	O
total_size	long
)	O
||	O
(	O
request	pointer
->	O
response_write_position	long
==	O
response	pointer
->	O
total_size	long
)	O
)	O
return	O
true	int
;	O
if	O
(	O
(	O
response	pointer
->	O
data_start	long
<=	O
request	pointer
->	O
response_write_position	long
)	O
&&	O
(	O
response	pointer
->	O
data_size	long
+	O
response	pointer
->	O
data_start	long
>	O
request	pointer
->	O
response_write_position	long
)	O
)	O
return	O
true	int
;	O
if	O
(	O
MHD_resp_sender_sendfile	int
==	O
request	pointer
->	O
resp_sender	enum
)	O
{	O
return	O
true	int
;	O
}	O
ret	long
=	O
response	pointer
->	O
crc	pointer
(	O
response	pointer
->	O
crc_cls	pointer
,	O
request	pointer
->	O
response_write_position	long
,	O
response	pointer
->	O
data	pointer
,	O
(	O
size_t	long
)	O
MHD_MIN	O
(	O
(	O
uint64_t	long
)	O
response	pointer
->	O
data_buffer_size	long
,	O
response	pointer
->	O
total_size	long
-	O
request	pointer
->	O
response_write_position	long
)	O
)	O
;	O
if	O
(	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_OF_STREAM	O
)	O
==	O
ret	long
)	O
||	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_WITH_ERROR	O
)	O
==	O
ret	long
)	O
)	O
{	O
response	pointer
->	O
total_size	long
=	O
request	pointer
->	O
response_write_position	long
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_OF_STREAM	O
)	O
==	O
ret	long
)	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
else	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_APPLICATION_DATA_GENERATION_FAILURE_CLOSED	int
,	O
_	O
(	O
"Closing connection (application reported error generating data)\n"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
response	pointer
->	O
data_start	long
=	O
request	pointer
->	O
response_write_position	long
;	O
response	pointer
->	O
data_size	long
=	O
ret	long
;	O
if	O
(	O
0	int
==	O
ret	long
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_NORMAL_BODY_UNREADY	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
try_ready_chunked_body	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
request	pointer
->	O
response	pointer
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
ssize_t	long
ret	long
;	O
char	O
*	O
buf	pointer
;	O
size_t	long
size	long
;	O
char	O
cbuf	array
[	O
10	int
]	O
;	O
int	O
cblen	int
;	O
if	O
(	O
NULL	O
==	O
response	pointer
->	O
crc	pointer
)	O
return	O
true	int
;	O
if	O
(	O
0	int
==	O
request	pointer
->	O
write_buffer_size	long
)	O
{	O
size	long
=	O
MHD_MIN	O
(	O
daemon	function
->	O
connection_memory_limit_b	long
,	O
2	int
*	O
(	O
0xFFFFFF	int
+	O
sizeof	O
(	O
cbuf	array
)	O
+	O
2	int
)	O
)	O
;	O
do	O
{	O
size	long
/=	O
2	int
;	O
if	O
(	O
size	long
<	O
128	int
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_POOL_MALLOC_FAILURE	int
,	O
_	O
(	O
"Closing connection (out of memory)\n"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
buf	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
size	long
,	O
MHD_NO	int
)	O
;	O
}	O
while	O
(	O
NULL	O
==	O
buf	pointer
)	O
;	O
request	pointer
->	O
write_buffer_size	long
=	O
size	long
;	O
request	pointer
->	O
write_buffer	pointer
=	O
buf	pointer
;	O
}	O
if	O
(	O
0	int
==	O
response	pointer
->	O
total_size	long
)	O
ret	long
=	O
0	int
;	O
else	O
if	O
(	O
(	O
response	pointer
->	O
data_start	long
<=	O
request	pointer
->	O
response_write_position	long
)	O
&&	O
(	O
response	pointer
->	O
data_start	long
+	O
response	pointer
->	O
data_size	long
>	O
request	pointer
->	O
response_write_position	long
)	O
)	O
{	O
const	O
size_t	long
data_write_offset	long
=	O
(	O
size_t	long
)	O
(	O
request	pointer
->	O
response_write_position	long
-	O
response	pointer
->	O
data_start	long
)	O
;	O
ret	long
=	O
response	pointer
->	O
data_size	long
-	O
data_write_offset	long
;	O
if	O
(	O
(	O
(	O
size_t	long
)	O
ret	long
)	O
>	O
request	pointer
->	O
write_buffer_size	long
-	O
sizeof	O
(	O
cbuf	array
)	O
-	O
2	int
)	O
ret	long
=	O
request	pointer
->	O
write_buffer_size	long
-	O
sizeof	O
(	O
cbuf	array
)	O
-	O
2	int
;	O
memcpy	function
(	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
]	O
,	O
&	O
response	pointer
->	O
data	pointer
[	O
data_write_offset	long
]	O
,	O
ret	long
)	O
;	O
}	O
else	O
{	O
ret	long
=	O
response	pointer
->	O
crc	pointer
(	O
response	pointer
->	O
crc_cls	pointer
,	O
request	pointer
->	O
response_write_position	long
,	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
]	O
,	O
request	pointer
->	O
write_buffer_size	long
-	O
sizeof	O
(	O
cbuf	array
)	O
-	O
2	int
)	O
;	O
}	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_WITH_ERROR	O
)	O
==	O
ret	long
)	O
{	O
response	pointer
->	O
total_size	long
=	O
request	pointer
->	O
response_write_position	long
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_APPLICATION_DATA_GENERATION_FAILURE_CLOSED	int
,	O
_	O
(	O
"Closing connection (application error generating response)\n"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_OF_STREAM	O
)	O
==	O
ret	long
)	O
||	O
(	O
0	int
==	O
response	pointer
->	O
total_size	long
)	O
)	O
{	O
memcpy	function
(	O
request	pointer
->	O
write_buffer	pointer
,	O
"0\r\n"	pointer
,	O
3	int
)	O
;	O
request	pointer
->	O
write_buffer_append_offset	long
=	O
3	int
;	O
request	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
response	pointer
->	O
total_size	long
=	O
request	pointer
->	O
response_write_position	long
;	O
return	O
true	int
;	O
}	O
if	O
(	O
0	int
==	O
ret	long
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_CHUNKED_BODY_UNREADY	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
ret	long
>	O
0xFFFFFF	int
)	O
ret	long
=	O
0xFFFFFF	int
;	O
cblen	int
=	O
MHD_snprintf_	O
(	O
cbuf	array
,	O
sizeof	O
(	O
cbuf	array
)	O
,	O
"%X\r\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
ret	long
)	O
;	O
mhd_assert	O
(	O
cblen	int
>	O
0	int
)	O
;	O
mhd_assert	O
(	O
(	O
size_t	long
)	O
cblen	int
<	O
sizeof	O
(	O
cbuf	array
)	O
)	O
;	O
memcpy	function
(	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
-	O
cblen	int
]	O
,	O
cbuf	array
,	O
cblen	int
)	O
;	O
memcpy	function
(	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
+	O
ret	long
]	O
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
request	pointer
->	O
response_write_position	long
+=	O
ret	long
;	O
request	pointer
->	O
write_buffer_send_offset	long
=	O
sizeof	O
(	O
cbuf	array
)	O
-	O
cblen	int
;	O
request	pointer
->	O
write_buffer_append_offset	long
=	O
sizeof	O
(	O
cbuf	array
)	O
+	O
ret	long
+	O
2	int
;	O
return	O
true	int
;	O
}	O
static	O
void	O
MHD_request_handle_write_	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
ssize_t	long
ret	long
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
return	O
;	O
switch	O
(	O
request	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_REQUEST_INIT	int
:	O
case	O
MHD_REQUEST_URL_RECEIVED	int
:	O
case	O
MHD_REQUEST_HEADER_PART_RECEIVED	int
:	O
case	O
MHD_REQUEST_HEADERS_RECEIVED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_HEADERS_PROCESSED	int
:	O
return	O
;	O
case	O
MHD_REQUEST_CONTINUE_SENDING	int
:	O
ret	long
=	O
connection	pointer
->	O
send_cls	pointer
(	O
connection	pointer
,	O
&	O
HTTP_100_CONTINUE	pointer
[	O
request	pointer
->	O
continue_message_write_offset	long
]	O
,	O
MHD_STATICSTR_LEN_	O
(	O
HTTP_100_CONTINUE	pointer
)	O
-	O
request	pointer
->	O
continue_message_write_offset	long
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
_	O
(	O
"Failed to send data in request for %s.\n"	pointer
)	O
,	O
request	pointer
->	O
url	pointer
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
request	pointer
->	O
continue_message_write_offset	long
+=	O
ret	long
;	O
MHD_connection_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_CONTINUE_SENT	int
:	O
case	O
MHD_REQUEST_BODY_RECEIVED	int
:	O
case	O
MHD_REQUEST_FOOTER_PART_RECEIVED	int
:	O
case	O
MHD_REQUEST_FOOTERS_RECEIVED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_HEADERS_SENDING	int
:	O
ret	long
=	O
connection	pointer
->	O
send_cls	pointer
(	O
connection	pointer
,	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
request	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
request	pointer
->	O
write_buffer_append_offset	long
-	O
request	pointer
->	O
write_buffer_send_offset	long
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
_	O
(	O
"Connection was closed while sending response headers.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
request	pointer
->	O
write_buffer_send_offset	long
+=	O
ret	long
;	O
MHD_connection_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_HEADERS_SENDING	int
!=	O
request	pointer
->	O
state	pointer
)	O
return	O
;	O
check_write_done	function
(	O
request	pointer
,	O
MHD_REQUEST_HEADERS_SENT	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_HEADERS_SENT	int
:	O
return	O
;	O
case	O
MHD_REQUEST_NORMAL_BODY_READY	int
:	O
response	pointer
=	O
request	pointer
->	O
response	pointer
;	O
if	O
(	O
request	pointer
->	O
response_write_position	long
<	O
request	pointer
->	O
response	pointer
->	O
total_size	long
)	O
{	O
uint64_t	long
data_write_offset	long
;	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_lock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
!	O
try_ready_normal_body	function
(	O
request	pointer
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
MHD_resp_sender_sendfile	int
==	O
request	pointer
->	O
resp_sender	enum
)	O
{	O
ret	long
=	O
sendfile_adapter	function
(	O
connection	pointer
)	O
;	O
}	O
else	O
{	O
data_write_offset	long
=	O
request	pointer
->	O
response_write_position	long
-	O
response	pointer
->	O
data_start	long
;	O
if	O
(	O
data_write_offset	long
>	O
(	O
uint64_t	long
)	O
SIZE_MAX	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Data offset exceeds limit"	pointer
)	O
)	O
;	O
ret	long
=	O
connection	pointer
->	O
send_cls	pointer
(	O
connection	pointer
,	O
&	O
response	pointer
->	O
data	pointer
[	O
(	O
size_t	long
)	O
data_write_offset	long
]	O
,	O
response	pointer
->	O
data_size	long
-	O
(	O
size_t	long
)	O
data_write_offset	long
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
_	O
(	O
"Failed to send data in request for `%s'.\n"	pointer
)	O
,	O
request	pointer
->	O
url	pointer
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
request	pointer
->	O
response_write_position	long
+=	O
ret	long
;	O
MHD_connection_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
}	O
if	O
(	O
request	pointer
->	O
response_write_position	long
==	O
request	pointer
->	O
response	pointer
->	O
total_size	long
)	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_SENT	int
;	O
return	O
;	O
case	O
MHD_REQUEST_NORMAL_BODY_UNREADY	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_CHUNKED_BODY_READY	int
:	O
ret	long
=	O
connection	pointer
->	O
send_cls	pointer
(	O
connection	pointer
,	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
request	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
request	pointer
->	O
write_buffer_append_offset	long
-	O
request	pointer
->	O
write_buffer_send_offset	long
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
_	O
(	O
"Connection was closed while sending response body.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
request	pointer
->	O
write_buffer_send_offset	long
+=	O
ret	long
;	O
MHD_connection_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_CHUNKED_BODY_READY	int
!=	O
request	pointer
->	O
state	pointer
)	O
return	O
;	O
check_write_done	function
(	O
request	pointer
,	O
(	O
request	pointer
->	O
response	pointer
->	O
total_size	long
==	O
request	pointer
->	O
response_write_position	long
)	O
?	O
MHD_REQUEST_BODY_SENT	int
:	O
MHD_REQUEST_CHUNKED_BODY_UNREADY	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_CHUNKED_BODY_UNREADY	int
:	O
case	O
MHD_REQUEST_BODY_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_FOOTERS_SENDING	int
:	O
ret	long
=	O
connection	pointer
->	O
send_cls	pointer
(	O
connection	pointer
,	O
&	O
request	pointer
->	O
write_buffer	pointer
[	O
request	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
request	pointer
->	O
write_buffer_append_offset	long
-	O
request	pointer
->	O
write_buffer_send_offset	long
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_WRITE_FAIL_CLOSED	int
,	O
_	O
(	O
"Connection was closed while sending response body.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
request	pointer
->	O
write_buffer_send_offset	long
+=	O
ret	long
;	O
MHD_connection_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_FOOTERS_SENDING	int
!=	O
request	pointer
->	O
state	pointer
)	O
return	O
;	O
check_write_done	function
(	O
request	pointer
,	O
MHD_REQUEST_FOOTERS_SENT	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_FOOTERS_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_REQUEST_CLOSED	int
:	O
return	O
;	O
case	O
MHD_REQUEST_UPGRADE	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_STATEMACHINE_FAILURE_CONNECTION_CLOSED	int
,	O
_	O
(	O
"Internal error\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
bool	bool
MHD_lookup_header_token_ci	function
(	O
const	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
const	O
char	O
*	O
header	pointer
,	O
const	O
char	O
*	O
token	pointer
,	O
size_t	long
token_len	long
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
(	O
NULL	O
==	O
request	pointer
)	O
||	O
(	O
NULL	O
==	O
header	pointer
)	O
||	O
(	O
0	int
==	O
header	pointer
[	O
0	int
]	O
)	O
||	O
(	O
NULL	O
==	O
token	pointer
)	O
||	O
(	O
0	int
==	O
token	pointer
[	O
0	int
]	O
)	O
)	O
return	O
false	int
;	O
for	O
(	O
pos	long
=	O
request	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
(	O
pos	long
->	O
kind	enum
&	O
MHD_HEADER_KIND	int
)	O
)	O
&&	O
(	O
(	O
header	pointer
==	O
pos	long
->	O
header	pointer
)	O
||	O
(	O
MHD_str_equal_caseless_	function
(	O
header	pointer
,	O
pos	long
->	O
header	pointer
)	O
)	O
)	O
&&	O
(	O
MHD_str_has_token_caseless_	function
(	O
pos	long
->	O
value	pointer
,	O
token	pointer
,	O
token_len	long
)	O
)	O
)	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
keepalive_possible	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
if	O
(	O
MHD_CONN_MUST_CLOSE	int
==	O
request	pointer
->	O
keepalive	enum
)	O
return	O
false	int
;	O
if	O
(	O
NULL	O
==	O
request	pointer
->	O
version_s	pointer
)	O
return	O
false	int
;	O
if	O
(	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
)	O
&&	O
(	O
request	pointer
->	O
response	pointer
->	O
v10_only	bool
)	O
)	O
return	O
false	int
;	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
request	pointer
->	O
version_s	pointer
,	O
MHD_HTTP_VERSION_1_1	pointer
)	O
)	O
{	O
if	O
(	O
MHD_lookup_header_s_token_ci	O
(	O
request	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"upgrade"	pointer
)	O
)	O
return	O
false	int
;	O
if	O
(	O
MHD_lookup_header_s_token_ci	O
(	O
request	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"close"	pointer
)	O
)	O
return	O
false	int
;	O
return	O
true	int
;	O
}	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
request	pointer
->	O
version_s	pointer
,	O
MHD_HTTP_VERSION_1_0	pointer
)	O
)	O
{	O
if	O
(	O
MHD_lookup_header_s_token_ci	O
(	O
request	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"Keep-Alive"	pointer
)	O
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
void	O
get_date_string	function
(	O
char	O
*	O
date	pointer
,	O
size_t	long
date_len	long
)	O
{	O
static	O
const	O
char	O
*	O
const	O
days	array
[	O
]	O
=	O
{	O
"Sun"	pointer
,	O
"Mon"	pointer
,	O
"Tue"	pointer
,	O
"Wed"	pointer
,	O
"Thu"	pointer
,	O
"Fri"	pointer
,	O
"Sat"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
mons	array
[	O
]	O
=	O
{	O
"Jan"	pointer
,	O
"Feb"	pointer
,	O
"Mar"	pointer
,	O
"Apr"	pointer
,	O
"May"	pointer
,	O
"Jun"	pointer
,	O
"Jul"	pointer
,	O
"Aug"	pointer
,	O
"Sep"	pointer
,	O
"Oct"	pointer
,	O
"Nov"	pointer
,	O
"Dec"	pointer
}	O
;	O
struct	O
tm	struct
now	struct
;	O
time_t	long
t	long
;	O
date	pointer
[	O
0	int
]	O
=	O
0	int
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
if	O
(	O
NULL	O
==	O
gmtime_r	function
(	O
&	O
t	long
,	O
&	O
now	struct
)	O
)	O
return	O
;	O
MHD_snprintf_	O
(	O
date	pointer
,	O
date_len	long
,	O
"Date: %3s, %02u %3s %04u %02u:%02u:%02u GMT\r\n"	pointer
,	O
days	array
[	O
now	struct
.	O
tm_wday	int
%	O
7	int
]	O
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_mday	int
,	O
mons	array
[	O
now	struct
.	O
tm_mon	int
%	O
12	int
]	O
,	O
(	O
unsigned	O
int	O
)	O
(	O
1900	int
+	O
now	struct
.	O
tm_year	int
)	O
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_hour	int
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_min	int
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_sec	int
)	O
;	O
}	O
static	O
bool	bool
check_response_header_token_ci	function
(	O
const	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
token	pointer
,	O
size_t	long
token_len	long
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
(	O
NULL	O
==	O
key	pointer
)	O
||	O
(	O
'\0'	O
==	O
key	pointer
[	O
0	int
]	O
)	O
||	O
(	O
NULL	O
==	O
token	pointer
)	O
||	O
(	O
'\0'	O
==	O
token	pointer
[	O
0	int
]	O
)	O
)	O
return	O
false	int
;	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
kind	enum
==	O
MHD_HEADER_KIND	int
)	O
&&	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
header	pointer
,	O
key	pointer
)	O
&&	O
MHD_str_has_token_caseless_	function
(	O
pos	long
->	O
value	pointer
,	O
token	pointer
,	O
token_len	long
)	O
)	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
build_header_response	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
request	pointer
->	O
response	pointer
;	O
size_t	long
size	long
;	O
size_t	long
off	long
;	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
char	O
code	enum
[	O
256	int
]	O
;	O
char	O
date	pointer
[	O
128	int
]	O
;	O
size_t	long
datelen	long
;	O
char	O
content_length_buf	array
[	O
128	int
]	O
;	O
size_t	long
content_length_len	long
;	O
char	O
*	O
data	pointer
;	O
enum	O
MHD_ValueKind	enum
kind	enum
;	O
bool	bool
client_requested_close	bool
;	O
bool	bool
response_has_close	bool
;	O
bool	bool
response_has_keepalive	bool
;	O
const	O
char	O
*	O
have_encoding	pointer
;	O
const	O
char	O
*	O
have_content_length	pointer
;	O
bool	bool
must_add_close	bool
;	O
bool	bool
must_add_chunked_encoding	bool
;	O
bool	bool
must_add_keep_alive	bool
;	O
bool	bool
must_add_content_length	bool
;	O
mhd_assert	O
(	O
NULL	O
!=	O
request	pointer
->	O
version_s	pointer
)	O
;	O
if	O
(	O
0	int
==	O
request	pointer
->	O
version_s	pointer
[	O
0	int
]	O
)	O
{	O
data	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
0	int
,	O
MHD_YES	int
)	O
;	O
request	pointer
->	O
write_buffer	pointer
=	O
data	pointer
;	O
request	pointer
->	O
write_buffer_append_offset	long
=	O
0	int
;	O
request	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
request	pointer
->	O
write_buffer_size	long
=	O
0	int
;	O
return	O
true	int
;	O
}	O
if	O
(	O
MHD_REQUEST_FOOTERS_RECEIVED	int
==	O
request	pointer
->	O
state	pointer
)	O
{	O
const	O
char	O
*	O
reason_phrase	pointer
;	O
const	O
char	O
*	O
version	pointer
;	O
reason_phrase	pointer
=	O
MHD_get_reason_phrase_for	function
(	O
response	pointer
->	O
status_code	enum
)	O
;	O
version	pointer
=	O
(	O
response	pointer
->	O
icy	bool
)	O
?	O
"ICY"	pointer
:	O
(	O
(	O
MHD_str_equal_caseless_	function
(	O
MHD_HTTP_VERSION_1_0	pointer
,	O
request	pointer
->	O
version_s	pointer
)	O
)	O
?	O
MHD_HTTP_VERSION_1_0	pointer
:	O
MHD_HTTP_VERSION_1_1	pointer
)	O
;	O
MHD_snprintf_	O
(	O
code	enum
,	O
sizeof	O
(	O
code	enum
)	O
,	O
"%s %u %s\r\n"	pointer
,	O
version	pointer
,	O
response	pointer
->	O
status_code	enum
,	O
reason_phrase	pointer
)	O
;	O
off	long
=	O
strlen	function
(	O
code	enum
)	O
;	O
size	long
=	O
off	long
+	O
2	int
;	O
kind	enum
=	O
MHD_HEADER_KIND	int
;	O
if	O
(	O
(	O
!	O
daemon	function
->	O
suppress_date	bool
)	O
&&	O
(	O
NULL	O
==	O
MHD_response_get_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_DATE	pointer
)	O
)	O
)	O
get_date_string	function
(	O
date	pointer
,	O
sizeof	O
(	O
date	pointer
)	O
)	O
;	O
else	O
date	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
datelen	long
=	O
strlen	function
(	O
date	pointer
)	O
;	O
size	long
+=	O
datelen	long
;	O
}	O
else	O
{	O
size	long
=	O
2	int
;	O
kind	enum
=	O
MHD_FOOTER_KIND	int
;	O
off	long
=	O
0	int
;	O
datelen	long
=	O
0	int
;	O
}	O
must_add_close	bool
=	O
false	int
;	O
must_add_chunked_encoding	bool
=	O
false	int
;	O
must_add_keep_alive	bool
=	O
false	int
;	O
must_add_content_length	bool
=	O
false	int
;	O
response_has_close	bool
=	O
false	int
;	O
switch	O
(	O
request	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_REQUEST_FOOTERS_RECEIVED	int
:	O
response_has_close	bool
=	O
check_response_header_s_token_ci	O
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"close"	pointer
)	O
;	O
response_has_keepalive	bool
=	O
check_response_header_s_token_ci	O
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"Keep-Alive"	pointer
)	O
;	O
client_requested_close	bool
=	O
MHD_lookup_header_s_token_ci	O
(	O
request	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"close"	pointer
)	O
;	O
if	O
(	O
response	pointer
->	O
v10_only	bool
)	O
request	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
else	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
upgrade_handler	pointer
)	O
request	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
request	pointer
->	O
have_chunked_upload	bool
=	O
false	int
;	O
if	O
(	O
(	O
MHD_SIZE_UNKNOWN	O
==	O
response	pointer
->	O
total_size	long
)	O
&&	O
(	O
NULL	O
==	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
&&	O
(	O
!	O
client_requested_close	bool
)	O
)	O
{	O
if	O
(	O
(	O
keepalive_possible	function
(	O
request	pointer
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
MHD_HTTP_VERSION_1_1	pointer
,	O
request	pointer
->	O
version_s	pointer
)	O
)	O
)	O
{	O
have_encoding	pointer
=	O
MHD_response_get_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_TRANSFER_ENCODING	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
have_encoding	pointer
)	O
{	O
must_add_chunked_encoding	bool
=	O
true	int
;	O
request	pointer
->	O
have_chunked_upload	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
have_encoding	pointer
,	O
"identity"	pointer
)	O
)	O
{	O
must_add_close	bool
=	O
true	int
;	O
}	O
else	O
{	O
request	pointer
->	O
have_chunked_upload	bool
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
response_has_close	bool
)	O
must_add_close	bool
=	O
true	int
;	O
}	O
}	O
if	O
(	O
(	O
(	O
client_requested_close	bool
)	O
||	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
||	O
(	O
MHD_CONN_MUST_CLOSE	int
==	O
request	pointer
->	O
keepalive	enum
)	O
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
&&	O
(	O
NULL	O
==	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
!	O
response	pointer
->	O
v10_only	bool
)	O
)	O
must_add_close	bool
=	O
true	int
;	O
have_content_length	pointer
=	O
MHD_response_get_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
)	O
;	O
if	O
(	O
(	O
MHD_SIZE_UNKNOWN	O
!=	O
response	pointer
->	O
total_size	long
)	O
&&	O
(	O
MHD_HTTP_NO_CONTENT	int
!=	O
response	pointer
->	O
status_code	enum
)	O
&&	O
(	O
MHD_HTTP_NOT_MODIFIED	int
!=	O
response	pointer
->	O
status_code	enum
)	O
&&	O
(	O
MHD_HTTP_OK	int
<=	O
response	pointer
->	O
status_code	enum
)	O
&&	O
(	O
NULL	O
==	O
have_content_length	pointer
)	O
&&	O
(	O
request	pointer
->	O
method	enum
!=	O
MHD_METHOD_CONNECT	int
)	O
)	O
{	O
content_length_len	long
=	O
MHD_snprintf_	O
(	O
content_length_buf	array
,	O
sizeof	O
(	O
content_length_buf	array
)	O
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
": "	pointer
MHD_UNSIGNED_LONG_LONG_PRINTF	pointer
"\r\n"	pointer
,	O
(	O
MHD_UNSIGNED_LONG_LONG	O
)	O
response	pointer
->	O
total_size	long
)	O
;	O
must_add_content_length	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
!	O
response_has_keepalive	bool
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
&&	O
(	O
!	O
must_add_close	bool
)	O
&&	O
(	O
MHD_CONN_MUST_CLOSE	int
!=	O
request	pointer
->	O
keepalive	enum
)	O
&&	O
(	O
NULL	O
==	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
keepalive_possible	function
(	O
request	pointer
)	O
)	O
)	O
must_add_keep_alive	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_REQUEST_BODY_SENT	int
:	O
response_has_keepalive	bool
=	O
false	int
;	O
break	O
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
MHD_CONN_MUST_CLOSE	int
!=	O
request	pointer
->	O
keepalive	enum
)	O
{	O
if	O
(	O
(	O
must_add_close	bool
)	O
||	O
(	O
response_has_close	bool
)	O
)	O
request	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
else	O
if	O
(	O
(	O
must_add_keep_alive	bool
)	O
||	O
(	O
response_has_keepalive	bool
)	O
)	O
request	pointer
->	O
keepalive	enum
=	O
MHD_CONN_USE_KEEPALIVE	int
;	O
}	O
if	O
(	O
must_add_close	bool
)	O
size	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: close\r\n"	pointer
)	O
;	O
if	O
(	O
must_add_keep_alive	bool
)	O
size	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: Keep-Alive\r\n"	pointer
)	O
;	O
if	O
(	O
must_add_chunked_encoding	bool
)	O
size	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Transfer-Encoding: chunked\r\n"	pointer
)	O
;	O
if	O
(	O
must_add_content_length	bool
)	O
size	long
+=	O
content_length_len	long
;	O
mhd_assert	O
(	O
!	O
(	O
must_add_close	bool
&&	O
must_add_keep_alive	bool
)	O
)	O
;	O
mhd_assert	O
(	O
!	O
(	O
must_add_chunked_encoding	bool
&&	O
must_add_content_length	bool
)	O
)	O
;	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
kind	enum
==	O
kind	enum
)	O
&&	O
(	O
!	O
(	O
(	O
must_add_close	bool
)	O
&&	O
(	O
response_has_keepalive	bool
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
header	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
value	pointer
,	O
"Keep-Alive"	pointer
)	O
)	O
)	O
)	O
)	O
size	long
+=	O
strlen	function
(	O
pos	long
->	O
header	pointer
)	O
+	O
strlen	function
(	O
pos	long
->	O
value	pointer
)	O
+	O
4	int
;	O
}	O
data	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
size	long
+	O
1	int
,	O
MHD_NO	int
)	O
;	O
if	O
(	O
NULL	O
==	O
data	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_CONNECTION_POOL_MALLOC_FAILURE	int
,	O
"Not enough memory for write!\n"	pointer
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
MHD_REQUEST_FOOTERS_RECEIVED	int
==	O
request	pointer
->	O
state	pointer
)	O
{	O
memcpy	function
(	O
data	pointer
,	O
code	enum
,	O
off	long
)	O
;	O
}	O
if	O
(	O
must_add_close	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"Connection: close\r\n"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: close\r\n"	pointer
)	O
)	O
;	O
off	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: close\r\n"	pointer
)	O
;	O
}	O
if	O
(	O
must_add_keep_alive	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"Connection: Keep-Alive\r\n"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: Keep-Alive\r\n"	pointer
)	O
)	O
;	O
off	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: Keep-Alive\r\n"	pointer
)	O
;	O
}	O
if	O
(	O
must_add_chunked_encoding	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"Transfer-Encoding: chunked\r\n"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Transfer-Encoding: chunked\r\n"	pointer
)	O
)	O
;	O
off	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Transfer-Encoding: chunked\r\n"	pointer
)	O
;	O
}	O
if	O
(	O
must_add_content_length	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
content_length_buf	array
,	O
content_length_len	long
)	O
;	O
off	long
+=	O
content_length_len	long
;	O
}	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
kind	enum
==	O
kind	enum
)	O
&&	O
(	O
!	O
(	O
(	O
must_add_close	bool
)	O
&&	O
(	O
response_has_keepalive	bool
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
header	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
value	pointer
,	O
"Keep-Alive"	pointer
)	O
)	O
)	O
)	O
)	O
off	long
+=	O
MHD_snprintf_	O
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
size	long
-	O
off	long
,	O
"%s: %s\r\n"	pointer
,	O
pos	long
->	O
header	pointer
,	O
pos	long
->	O
value	pointer
)	O
;	O
}	O
if	O
(	O
MHD_REQUEST_FOOTERS_RECEIVED	int
==	O
request	pointer
->	O
state	pointer
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
date	pointer
,	O
datelen	long
)	O
;	O
off	long
+=	O
datelen	long
;	O
}	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
off	long
+=	O
2	int
;	O
if	O
(	O
off	long
!=	O
size	long
)	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
NULL	O
)	O
;	O
request	pointer
->	O
write_buffer	pointer
=	O
data	pointer
;	O
request	pointer
->	O
write_buffer_append_offset	long
=	O
size	long
;	O
request	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
request	pointer
->	O
write_buffer_size	long
=	O
size	long
+	O
1	int
;	O
return	O
true	int
;	O
}	O
static	O
void	O
transmit_error_response	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
enum	O
MHD_StatusCode	enum
ec	int
,	O
enum	O
MHD_HTTP_StatusCode	enum
status_code	enum
,	O
const	O
char	O
*	O
message	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
if	O
(	O
NULL	O
==	O
request	pointer
->	O
version_s	pointer
)	O
{	O
request	pointer
->	O
version_s	pointer
=	O
MHD_HTTP_VERSION_1_0	pointer
;	O
}	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_RECEIVED	int
;	O
request	pointer
->	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
MHD_DLOG	function
(	O
request	pointer
->	O
daemon	function
,	O
ec	int
,	O
_	O
(	O
"Error processing request (HTTP response code is %u (`%s')). Closing connection.\n"	pointer
)	O
,	O
status_code	enum
,	O
message	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
)	O
{	O
MHD_response_queue_for_destroy	function
(	O
request	pointer
->	O
response	pointer
)	O
;	O
request	pointer
->	O
response	pointer
=	O
NULL	O
;	O
}	O
response	pointer
=	O
MHD_response_from_buffer	function
(	O
status_code	enum
,	O
strlen	function
(	O
message	pointer
)	O
,	O
(	O
void	O
*	O
)	O
message	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
request	pointer
->	O
response	pointer
=	O
response	pointer
;	O
request	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
if	O
(	O
!	O
build_header_response	function
(	O
request	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
request	pointer
->	O
connection	pointer
,	O
ec	int
,	O
_	O
(	O
"Closing connection (failed to create response header)\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADERS_SENDING	int
;	O
}	O
}	O
static	O
enum	O
MHD_Method	enum
method_string_to_enum	function
(	O
const	O
char	O
*	O
method	enum
)	O
{	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
key	pointer
;	O
enum	O
MHD_Method	enum
value	pointer
;	O
}	O
methods	array
[	O
]	O
=	O
{	O
{	O
"OPTIONS"	pointer
,	O
MHD_METHOD_OPTIONS	int
}	O
,	O
{	O
"GET"	pointer
,	O
MHD_METHOD_GET	int
}	O
,	O
{	O
"HEAD"	pointer
,	O
MHD_METHOD_HEAD	int
}	O
,	O
{	O
"POST"	pointer
,	O
MHD_METHOD_POST	int
}	O
,	O
{	O
"PUT"	pointer
,	O
MHD_METHOD_PUT	int
}	O
,	O
{	O
"DELETE"	pointer
,	O
MHD_METHOD_DELETE	int
}	O
,	O
{	O
"TRACE"	pointer
,	O
MHD_METHOD_TRACE	int
}	O
,	O
{	O
"CONNECT"	pointer
,	O
MHD_METHOD_CONNECT	int
}	O
,	O
{	O
"ACL"	pointer
,	O
MHD_METHOD_ACL	int
}	O
,	O
{	O
"BASELINE_CONTROL"	pointer
,	O
MHD_METHOD_BASELINE_CONTROL	int
}	O
,	O
{	O
"BIND"	pointer
,	O
MHD_METHOD_BIND	int
}	O
,	O
{	O
"CHECKIN"	pointer
,	O
MHD_METHOD_CHECKIN	int
}	O
,	O
{	O
"CHECKOUT"	pointer
,	O
MHD_METHOD_CHECKOUT	int
}	O
,	O
{	O
"COPY"	pointer
,	O
MHD_METHOD_COPY	int
}	O
,	O
{	O
"LABEL"	pointer
,	O
MHD_METHOD_LABEL	int
}	O
,	O
{	O
"LINK"	pointer
,	O
MHD_METHOD_LINK	int
}	O
,	O
{	O
"LOCK"	pointer
,	O
MHD_METHOD_LOCK	int
}	O
,	O
{	O
"MERGE"	pointer
,	O
MHD_METHOD_MERGE	int
}	O
,	O
{	O
"MKACTIVITY"	pointer
,	O
MHD_METHOD_MKACTIVITY	int
}	O
,	O
{	O
"MKCOL"	pointer
,	O
MHD_METHOD_MKCOL	int
}	O
,	O
{	O
"MKREDIRECTREF"	pointer
,	O
MHD_METHOD_MKREDIRECTREF	int
}	O
,	O
{	O
"MKWORKSPACE"	pointer
,	O
MHD_METHOD_MKWORKSPACE	int
}	O
,	O
{	O
"MOVE"	pointer
,	O
MHD_METHOD_MOVE	int
}	O
,	O
{	O
"ORDERPATCH"	pointer
,	O
MHD_METHOD_ORDERPATCH	int
}	O
,	O
{	O
"PRI"	pointer
,	O
MHD_METHOD_PRI	int
}	O
,	O
{	O
"PROPFIND"	pointer
,	O
MHD_METHOD_PROPFIND	int
}	O
,	O
{	O
"PROPPATCH"	pointer
,	O
MHD_METHOD_PROPPATCH	int
}	O
,	O
{	O
"REBIND"	pointer
,	O
MHD_METHOD_REBIND	int
}	O
,	O
{	O
"REPORT"	pointer
,	O
MHD_METHOD_REPORT	int
}	O
,	O
{	O
"SEARCH"	pointer
,	O
MHD_METHOD_SEARCH	int
}	O
,	O
{	O
"UNBIND"	pointer
,	O
MHD_METHOD_UNBIND	int
}	O
,	O
{	O
"UNCHECKOUT"	pointer
,	O
MHD_METHOD_UNCHECKOUT	int
}	O
,	O
{	O
"UNLINK"	pointer
,	O
MHD_METHOD_UNLINK	int
}	O
,	O
{	O
"UNLOCK"	pointer
,	O
MHD_METHOD_UNLOCK	int
}	O
,	O
{	O
"UPDATE"	pointer
,	O
MHD_METHOD_UPDATE	int
}	O
,	O
{	O
"UPDATEDIRECTREF"	pointer
,	O
MHD_METHOD_UPDATEDIRECTREF	int
}	O
,	O
{	O
"VERSION-CONTROL"	pointer
,	O
MHD_METHOD_VERSION_CONTROL	int
}	O
,	O
{	O
NULL	O
,	O
MHD_METHOD_UNKNOWN	int
}	O
}	O
;	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
NULL	O
!=	O
methods	array
[	O
i	int
]	O
.	O
key	pointer
;	O
i	int
++	O
)	O
if	O
(	O
0	int
==	O
MHD_str_equal_caseless_	function
(	O
method	enum
,	O
methods	array
[	O
i	int
]	O
.	O
key	pointer
)	O
)	O
return	O
methods	array
[	O
i	int
]	O
.	O
value	pointer
;	O
return	O
MHD_METHOD_UNKNOWN	int
;	O
}	O
static	O
bool	bool
request_add_header	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
)	O
{	O
if	O
(	O
MHD_NO	int
==	O
MHD_request_set_value	function
(	O
request	pointer
,	O
kind	enum
,	O
key	pointer
,	O
value	pointer
)	O
)	O
{	O
MHD_DLOG	function
(	O
request	pointer
->	O
daemon	function
,	O
MHD_SC_CONNECTION_POOL_MALLOC_FAILURE	int
,	O
_	O
(	O
"Not enough memory in pool to allocate header record!\n"	pointer
)	O
)	O
;	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CLIENT_HEADER_TOO_BIG	int
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_initial_message_line	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
char	O
*	O
line	int
,	O
size_t	long
line_len	long
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
const	O
char	O
*	O
curi	pointer
;	O
char	O
*	O
uri	pointer
;	O
char	O
*	O
http_version	pointer
;	O
char	O
*	O
args	pointer
;	O
unsigned	O
int	O
unused_num_headers	int
;	O
size_t	long
url_end	long
;	O
if	O
(	O
NULL	O
==	O
(	O
uri	pointer
=	O
memchr	function
(	O
line	int
,	O
' '	O
,	O
line_len	long
)	O
)	O
)	O
return	O
false	int
;	O
uri	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
request	pointer
->	O
method_s	pointer
=	O
line	int
;	O
request	pointer
->	O
method	enum
=	O
method_string_to_enum	function
(	O
line	int
)	O
;	O
uri	pointer
++	O
;	O
while	O
(	O
(	O
' '	O
==	O
uri	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
size_t	long
)	O
(	O
uri	pointer
-	O
line	int
)	O
<	O
line_len	long
)	O
)	O
uri	pointer
++	O
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
uri	pointer
-	O
line	int
)	O
==	O
line_len	long
)	O
{	O
curi	pointer
=	O
""	pointer
;	O
uri	pointer
=	O
NULL	O
;	O
request	pointer
->	O
version_s	pointer
=	O
""	pointer
;	O
args	pointer
=	O
NULL	O
;	O
url_end	long
=	O
line_len	long
-	O
(	O
line	int
-	O
uri	pointer
)	O
;	O
}	O
else	O
{	O
curi	pointer
=	O
uri	pointer
;	O
http_version	pointer
=	O
line	int
+	O
line_len	long
-	O
1	int
;	O
while	O
(	O
(	O
' '	O
==	O
http_version	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
http_version	pointer
>	O
uri	pointer
)	O
)	O
http_version	pointer
--	O
;	O
while	O
(	O
(	O
' '	O
!=	O
http_version	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
http_version	pointer
>	O
uri	pointer
)	O
)	O
http_version	pointer
--	O
;	O
if	O
(	O
http_version	pointer
>	O
uri	pointer
)	O
{	O
http_version	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
request	pointer
->	O
version_s	pointer
=	O
http_version	pointer
+	O
1	int
;	O
args	pointer
=	O
memchr	function
(	O
uri	pointer
,	O
'?'	O
,	O
http_version	pointer
-	O
uri	pointer
)	O
;	O
}	O
else	O
{	O
request	pointer
->	O
version_s	pointer
=	O
""	pointer
;	O
args	pointer
=	O
memchr	function
(	O
uri	pointer
,	O
'?'	O
,	O
line_len	long
-	O
(	O
uri	pointer
-	O
line	int
)	O
)	O
;	O
}	O
url_end	long
=	O
http_version	pointer
-	O
uri	pointer
;	O
}	O
if	O
(	O
(	O
MHD_PSL_STRICT	int
==	O
daemon	function
->	O
protocol_strict_level	enum
)	O
&&	O
(	O
NULL	O
!=	O
memchr	function
(	O
curi	pointer
,	O
' '	O
,	O
url_end	long
)	O
)	O
)	O
{	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
early_uri_logger_cb	pointer
)	O
{	O
request	pointer
->	O
client_context	pointer
=	O
daemon	function
->	O
early_uri_logger_cb	pointer
(	O
daemon	function
->	O
early_uri_logger_cb_cls	pointer
,	O
curi	pointer
,	O
request	pointer
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
args	pointer
)	O
{	O
args	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
args	pointer
++	O
;	O
MHD_parse_arguments_	function
(	O
request	pointer
,	O
MHD_GET_ARGUMENT_KIND	int
,	O
args	pointer
,	O
&	O
request_add_header	function
,	O
&	O
unused_num_headers	int
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
uri	pointer
)	O
daemon	function
->	O
unescape_cb	pointer
(	O
daemon	function
->	O
unescape_cb_cls	pointer
,	O
request	pointer
,	O
uri	pointer
)	O
;	O
request	pointer
->	O
url	pointer
=	O
curi	pointer
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
process_header_line	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
char	O
*	O
line	int
)	O
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
char	O
*	O
colon	pointer
;	O
colon	pointer
=	O
strchr	function
(	O
line	int
,	O
':'	O
)	O
;	O
if	O
(	O
NULL	O
==	O
colon	pointer
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_PARSE_FAIL_CLOSED	int
,	O
_	O
(	O
"Received malformed line (no colon). Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
MHD_PSL_PERMISSIVE	int
!=	O
request	pointer
->	O
daemon	function
->	O
protocol_strict_level	enum
)	O
{	O
const	O
char	O
*	O
white	pointer
;	O
white	pointer
=	O
strchr	function
(	O
line	int
,	O
(	O
unsigned	O
char	O
)	O
' '	O
)	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
white	pointer
)	O
&&	O
(	O
white	pointer
<	O
colon	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_PARSE_FAIL_CLOSED	int
,	O
_	O
(	O
"Whitespace before colon forbidden by RFC 7230. Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
white	pointer
=	O
strchr	function
(	O
line	int
,	O
(	O
unsigned	O
char	O
)	O
'\t'	O
)	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
white	pointer
)	O
&&	O
(	O
white	pointer
<	O
colon	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_PARSE_FAIL_CLOSED	int
,	O
_	O
(	O
"Tab before colon forbidden by RFC 7230. Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
}	O
colon	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
colon	pointer
++	O
;	O
while	O
(	O
(	O
'\0'	O
!=	O
colon	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
colon	pointer
[	O
0	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
colon	pointer
[	O
0	int
]	O
)	O
)	O
)	O
colon	pointer
++	O
;	O
request	pointer
->	O
last	pointer
=	O
line	int
;	O
request	pointer
->	O
colon	pointer
=	O
colon	pointer
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
process_broken_line	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
char	O
*	O
line	int
,	O
enum	O
MHD_ValueKind	enum
kind	enum
)	O
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
char	O
*	O
last	pointer
;	O
char	O
*	O
tmp	pointer
;	O
size_t	long
last_len	long
;	O
size_t	long
tmp_len	long
;	O
last	pointer
=	O
request	pointer
->	O
last	pointer
;	O
if	O
(	O
(	O
' '	O
==	O
line	int
[	O
0	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
line	int
[	O
0	int
]	O
)	O
)	O
{	O
last_len	long
=	O
strlen	function
(	O
last	pointer
)	O
;	O
tmp	pointer
=	O
line	int
;	O
while	O
(	O
(	O
' '	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
)	O
tmp	pointer
++	O
;	O
tmp_len	long
=	O
strlen	function
(	O
tmp	pointer
)	O
;	O
last	pointer
=	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
last	pointer
,	O
last_len	long
+	O
1	int
,	O
last_len	long
+	O
tmp_len	long
+	O
1	int
)	O
;	O
if	O
(	O
NULL	O
==	O
last	pointer
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CLIENT_HEADER_TOO_BIG	int
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
memcpy	function
(	O
&	O
last	pointer
[	O
last_len	long
]	O
,	O
tmp	pointer
,	O
tmp_len	long
+	O
1	int
)	O
;	O
request	pointer
->	O
last	pointer
=	O
last	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
mhd_assert	O
(	O
(	O
NULL	O
!=	O
last	pointer
)	O
&&	O
(	O
NULL	O
!=	O
request	pointer
->	O
colon	pointer
)	O
)	O
;	O
if	O
(	O
!	O
request_add_header	function
(	O
request	pointer
,	O
last	pointer
,	O
request	pointer
->	O
colon	pointer
,	O
kind	enum
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CLIENT_HEADER_TOO_BIG	int
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
'\0'	O
!=	O
line	int
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
process_header_line	function
(	O
request	pointer
,	O
line	int
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CONNECTION_PARSE_FAIL_CLOSED	int
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
REQUEST_MALFORMED	pointer
)	O
;	O
return	O
false	int
;	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
char	O
*	O
get_next_header_line	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
,	O
size_t	long
*	O
line_len	long
)	O
{	O
char	O
*	O
rbuf	pointer
;	O
size_t	long
pos	long
;	O
if	O
(	O
0	int
==	O
request	pointer
->	O
read_buffer_offset	long
)	O
return	O
NULL	O
;	O
pos	long
=	O
0	int
;	O
rbuf	pointer
=	O
request	pointer
->	O
read_buffer	pointer
;	O
while	O
(	O
(	O
pos	long
<	O
request	pointer
->	O
read_buffer_offset	long
-	O
1	int
)	O
&&	O
(	O
'\r'	O
!=	O
rbuf	pointer
[	O
pos	long
]	O
)	O
&&	O
(	O
'\n'	O
!=	O
rbuf	pointer
[	O
pos	long
]	O
)	O
)	O
pos	long
++	O
;	O
if	O
(	O
(	O
pos	long
==	O
request	pointer
->	O
read_buffer_offset	long
-	O
1	int
)	O
&&	O
(	O
'\n'	O
!=	O
rbuf	pointer
[	O
pos	long
]	O
)	O
)	O
{	O
if	O
(	O
(	O
request	pointer
->	O
read_buffer_offset	long
==	O
request	pointer
->	O
read_buffer_size	long
)	O
&&	O
(	O
!	O
try_grow_read_buffer	function
(	O
request	pointer
)	O
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CLIENT_HEADER_TOO_BIG	int
,	O
(	O
NULL	O
!=	O
request	pointer
->	O
url	pointer
)	O
?	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
:	O
MHD_HTTP_URI_TOO_LONG	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
}	O
if	O
(	O
line_len	long
)	O
*	O
line_len	long
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
line_len	long
)	O
*	O
line_len	long
=	O
pos	long
;	O
if	O
(	O
(	O
'\r'	O
==	O
rbuf	pointer
[	O
pos	long
]	O
)	O
&&	O
(	O
'\n'	O
==	O
rbuf	pointer
[	O
pos	long
+	O
1	int
]	O
)	O
)	O
rbuf	pointer
[	O
pos	long
++	O
]	O
=	O
'\0'	O
;	O
rbuf	pointer
[	O
pos	long
++	O
]	O
=	O
'\0'	O
;	O
request	pointer
->	O
read_buffer	pointer
+=	O
pos	long
;	O
request	pointer
->	O
read_buffer_size	long
-=	O
pos	long
;	O
request	pointer
->	O
read_buffer_offset	long
-=	O
pos	long
;	O
return	O
rbuf	pointer
;	O
}	O
static	O
bool	bool
socket_flush_possible	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
(	O
void	O
)	O
connection	pointer
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
socket_start_extra_buffering	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
bool	bool
res	bool
=	O
false	int
;	O
(	O
void	O
)	O
connection	pointer
;	O
const	O
MHD_SCKT_OPT_BOOL_	int
on_val	int
=	O
1	int
;	O
const	O
MHD_SCKT_OPT_BOOL_	int
off_val	int
=	O
0	int
;	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
)	O
;	O
(	O
void	O
)	O
setsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_NODELAY	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
off_val	int
,	O
sizeof	O
(	O
off_val	int
)	O
)	O
;	O
res	bool
=	O
(	O
0	int
==	O
setsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_CORK	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
on_val	int
,	O
sizeof	O
(	O
on_val	int
)	O
)	O
)	O
?	O
true	int
:	O
false	int
;	O
return	O
res	bool
;	O
}	O
static	O
bool	bool
socket_start_no_buffering	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
bool	bool
res	bool
=	O
true	int
;	O
const	O
MHD_SCKT_OPT_BOOL_	int
on_val	int
=	O
1	int
;	O
const	O
MHD_SCKT_OPT_BOOL_	int
off_val	int
=	O
0	int
;	O
(	O
void	O
)	O
connection	pointer
;	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
)	O
;	O
res	bool
&=	O
(	O
0	int
==	O
setsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_CORK	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
off_val	int
,	O
sizeof	O
(	O
off_val	int
)	O
)	O
)	O
?	O
true	int
:	O
false	int
;	O
res	bool
&=	O
(	O
0	int
==	O
setsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_NODELAY	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
on_val	int
,	O
sizeof	O
(	O
on_val	int
)	O
)	O
)	O
?	O
true	int
:	O
false	int
;	O
return	O
res	bool
;	O
}	O
static	O
bool	bool
socket_start_no_buffering_flush	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
bool	bool
res	bool
=	O
true	int
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
)	O
return	O
false	int
;	O
res	bool
=	O
socket_start_no_buffering	function
(	O
connection	pointer
)	O
;	O
return	O
res	bool
;	O
}	O
static	O
bool	bool
socket_start_normal_buffering	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
bool	bool
res	bool
=	O
true	int
;	O
const	O
MHD_SCKT_OPT_BOOL_	int
off_val	int
=	O
0	int
;	O
MHD_SCKT_OPT_BOOL_	int
cork_val	int
=	O
0	int
;	O
socklen_t	int
param_size	int
=	O
sizeof	O
(	O
cork_val	int
)	O
;	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
)	O
;	O
if	O
(	O
(	O
0	int
!=	O
getsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_CORK	int
,	O
(	O
void	O
*	O
)	O
&	O
cork_val	int
,	O
&	O
param_size	int
)	O
)	O
||	O
(	O
0	int
!=	O
cork_val	int
)	O
)	O
res	bool
&=	O
(	O
0	int
==	O
setsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_CORK	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
off_val	int
,	O
sizeof	O
(	O
off_val	int
)	O
)	O
)	O
?	O
true	int
:	O
false	int
;	O
res	bool
&=	O
(	O
0	int
==	O
setsockopt	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_NODELAY	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
off_val	int
,	O
sizeof	O
(	O
off_val	int
)	O
)	O
)	O
?	O
true	int
:	O
false	int
;	O
return	O
res	bool
;	O
}	O
static	O
bool	bool
need_100_continue	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
const	O
char	O
*	O
expect	pointer
;	O
return	O
(	O
(	O
NULL	O
==	O
request	pointer
->	O
response	pointer
)	O
&&	O
(	O
NULL	O
!=	O
request	pointer
->	O
version_s	pointer
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
request	pointer
->	O
version_s	pointer
,	O
MHD_HTTP_VERSION_1_1	pointer
)	O
)	O
&&	O
(	O
NULL	O
!=	O
(	O
expect	pointer
=	O
MHD_request_lookup_value	function
(	O
request	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_EXPECT	pointer
)	O
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
expect	pointer
,	O
"100-continue"	pointer
)	O
)	O
&&	O
(	O
request	pointer
->	O
continue_message_write_offset	long
<	O
MHD_STATICSTR_LEN_	O
(	O
HTTP_100_CONTINUE	pointer
)	O
)	O
)	O
;	O
}	O
static	O
int	O
parse_cookie_header	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
const	O
char	O
*	O
hdr	pointer
;	O
char	O
*	O
cpy	pointer
;	O
char	O
*	O
pos	long
;	O
char	O
*	O
sce	pointer
;	O
char	O
*	O
semicolon	pointer
;	O
char	O
*	O
equals	pointer
;	O
char	O
*	O
ekill	pointer
;	O
char	O
old	pointer
;	O
int	O
quotes	int
;	O
hdr	pointer
=	O
MHD_request_lookup_value	function
(	O
request	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_COOKIE	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
hdr	pointer
)	O
return	O
true	int
;	O
cpy	pointer
=	O
MHD_pool_allocate	function
(	O
request	pointer
->	O
connection	pointer
->	O
pool	pointer
,	O
strlen	function
(	O
hdr	pointer
)	O
+	O
1	int
,	O
MHD_YES	int
)	O
;	O
if	O
(	O
NULL	O
==	O
cpy	pointer
)	O
{	O
MHD_DLOG	function
(	O
request	pointer
->	O
daemon	function
,	O
MHD_SC_COOKIE_POOL_ALLOCATION_FAILURE	int
,	O
_	O
(	O
"Not enough memory in pool to parse cookies!\n"	pointer
)	O
)	O
;	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_COOKIE_POOL_ALLOCATION_FAILURE	int
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
false	int
;	O
}	O
memcpy	function
(	O
cpy	pointer
,	O
hdr	pointer
,	O
strlen	function
(	O
hdr	pointer
)	O
+	O
1	int
)	O
;	O
pos	long
=	O
cpy	pointer
;	O
while	O
(	O
NULL	O
!=	O
pos	long
)	O
{	O
while	O
(	O
' '	O
==	O
*	O
pos	long
)	O
pos	long
++	O
;	O
sce	pointer
=	O
pos	long
;	O
while	O
(	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
'\0'	O
)	O
&&	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
','	O
)	O
&&	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
';'	O
)	O
&&	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
'='	O
)	O
)	O
sce	pointer
++	O
;	O
ekill	pointer
=	O
sce	pointer
-	O
1	int
;	O
while	O
(	O
(	O
*	O
ekill	pointer
==	O
' '	O
)	O
&&	O
(	O
ekill	pointer
>=	O
pos	long
)	O
)	O
*	O
(	O
ekill	pointer
--	O
)	O
=	O
'\0'	O
;	O
old	pointer
=	O
*	O
sce	pointer
;	O
*	O
sce	pointer
=	O
'\0'	O
;	O
if	O
(	O
old	pointer
!=	O
'='	O
)	O
{	O
if	O
(	O
!	O
request_add_header	function
(	O
request	pointer
,	O
pos	long
,	O
""	pointer
,	O
MHD_COOKIE_KIND	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
old	pointer
==	O
'\0'	O
)	O
break	O
;	O
pos	long
=	O
sce	pointer
+	O
1	int
;	O
continue	O
;	O
}	O
equals	pointer
=	O
sce	pointer
+	O
1	int
;	O
quotes	int
=	O
0	int
;	O
semicolon	pointer
=	O
equals	pointer
;	O
while	O
(	O
(	O
'\0'	O
!=	O
semicolon	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
0	int
!=	O
quotes	int
)	O
||	O
(	O
(	O
';'	O
!=	O
semicolon	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
','	O
!=	O
semicolon	pointer
[	O
0	int
]	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
'"'	O
==	O
semicolon	pointer
[	O
0	int
]	O
)	O
quotes	int
=	O
(	O
quotes	int
+	O
1	int
)	O
&	O
1	int
;	O
semicolon	pointer
++	O
;	O
}	O
if	O
(	O
'\0'	O
==	O
semicolon	pointer
[	O
0	int
]	O
)	O
semicolon	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
!=	O
semicolon	pointer
)	O
{	O
semicolon	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
semicolon	pointer
++	O
;	O
}	O
if	O
(	O
(	O
'"'	O
==	O
equals	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'"'	O
==	O
equals	pointer
[	O
strlen	function
(	O
equals	pointer
)	O
-	O
1	int
]	O
)	O
)	O
{	O
equals	pointer
[	O
strlen	function
(	O
equals	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
equals	pointer
++	O
;	O
}	O
if	O
(	O
!	O
request_add_header	function
(	O
request	pointer
,	O
pos	long
,	O
equals	pointer
,	O
MHD_COOKIE_KIND	int
)	O
)	O
return	O
false	int
;	O
pos	long
=	O
semicolon	pointer
;	O
}	O
return	O
true	int
;	O
}	O
static	O
void	O
parse_request_headers	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
const	O
char	O
*	O
clen	pointer
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
const	O
char	O
*	O
enc	pointer
;	O
const	O
char	O
*	O
end	pointer
;	O
parse_cookie_header	function
(	O
request	pointer
)	O
;	O
if	O
(	O
(	O
MHD_PSL_STRICT	int
==	O
daemon	function
->	O
protocol_strict_level	enum
)	O
&&	O
(	O
NULL	O
!=	O
request	pointer
->	O
version_s	pointer
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
MHD_HTTP_VERSION_1_1	pointer
,	O
request	pointer
->	O
version_s	pointer
)	O
)	O
&&	O
(	O
NULL	O
==	O
MHD_request_lookup_value	function
(	O
request	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_HOST	pointer
)	O
)	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_RECEIVED	int
;	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_HOST_HEADER_MISSING	int
,	O
_	O
(	O
"Received HTTP 1.1 request without `Host' header.\n"	pointer
)	O
)	O
;	O
mhd_assert	O
(	O
NULL	O
==	O
request	pointer
->	O
response	pointer
)	O
;	O
response	pointer
=	O
MHD_response_from_buffer	function
(	O
MHD_HTTP_BAD_REQUEST	int
,	O
MHD_STATICSTR_LEN_	O
(	O
REQUEST_LACKS_HOST	pointer
)	O
,	O
REQUEST_LACKS_HOST	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
request	pointer
->	O
response	pointer
=	O
response	pointer
;	O
return	O
;	O
}	O
request	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
enc	pointer
=	O
MHD_request_lookup_value	function
(	O
request	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_TRANSFER_ENCODING	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
enc	pointer
)	O
{	O
request	pointer
->	O
remaining_upload_size	long
=	O
MHD_SIZE_UNKNOWN	O
;	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
enc	pointer
,	O
"chunked"	pointer
)	O
)	O
request	pointer
->	O
have_chunked_upload	bool
=	O
true	int
;	O
return	O
;	O
}	O
clen	pointer
=	O
MHD_request_lookup_value	function
(	O
request	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
clen	pointer
)	O
return	O
;	O
end	pointer
=	O
clen	pointer
+	O
MHD_str_to_uint64_	function
(	O
clen	pointer
,	O
&	O
request	pointer
->	O
remaining_upload_size	long
)	O
;	O
if	O
(	O
(	O
clen	pointer
==	O
end	pointer
)	O
||	O
(	O
'\0'	O
!=	O
*	O
end	pointer
)	O
)	O
{	O
request	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
MHD_DLOG	function
(	O
request	pointer
->	O
daemon	function
,	O
MHD_SC_CONTENT_LENGTH_MALFORMED	int
,	O
"Failed to parse `Content-Length' header. Closing connection.\n"	pointer
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONTENT_LENGTH_MALFORMED	int
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
call_request_handler	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
const	O
struct	O
MHD_Action	struct
*	O
action	pointer
;	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
)	O
return	O
;	O
if	O
(	O
NULL	O
==	O
(	O
action	pointer
=	O
daemon	function
->	O
rc	pointer
(	O
daemon	function
->	O
rc_cls	pointer
,	O
request	pointer
,	O
request	pointer
->	O
url	pointer
,	O
request	pointer
->	O
method	enum
)	O
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_APPLICATION_CALLBACK_FAILURE_CLOSED	int
,	O
_	O
(	O
"Application reported internal error, closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
action	pointer
->	O
action	pointer
(	O
action	pointer
->	O
action_cls	pointer
,	O
request	pointer
)	O
;	O
}	O
static	O
void	O
process_request_body	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
size_t	long
available	long
;	O
bool	bool
instant_retry	bool
;	O
char	O
*	O
buffer_head	pointer
;	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
)	O
return	O
;	O
buffer_head	pointer
=	O
request	pointer
->	O
read_buffer	pointer
;	O
available	long
=	O
request	pointer
->	O
read_buffer_offset	long
;	O
do	O
{	O
size_t	long
to_be_processed	long
;	O
size_t	long
left_unprocessed	long
;	O
size_t	long
processed_size	long
;	O
instant_retry	bool
=	O
false	int
;	O
if	O
(	O
(	O
request	pointer
->	O
have_chunked_upload	bool
)	O
&&	O
(	O
MHD_SIZE_UNKNOWN	O
==	O
request	pointer
->	O
remaining_upload_size	long
)	O
)	O
{	O
if	O
(	O
(	O
request	pointer
->	O
current_chunk_offset	long
==	O
request	pointer
->	O
current_chunk_size	long
)	O
&&	O
(	O
0LLU	int
!=	O
request	pointer
->	O
current_chunk_offset	long
)	O
&&	O
(	O
available	long
>=	O
2	int
)	O
)	O
{	O
size_t	long
i	int
;	O
i	int
=	O
0	int
;	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
)	O
i	int
++	O
;	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
)	O
i	int
++	O
;	O
if	O
(	O
0	int
==	O
i	int
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CHUNKED_ENCODING_MALFORMED	int
,	O
_	O
(	O
"Received malformed HTTP request (bad chunked encoding). Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
available	long
-=	O
i	int
;	O
buffer_head	pointer
+=	O
i	int
;	O
request	pointer
->	O
current_chunk_offset	long
=	O
0	int
;	O
request	pointer
->	O
current_chunk_size	long
=	O
0	int
;	O
}	O
if	O
(	O
request	pointer
->	O
current_chunk_offset	long
<	O
request	pointer
->	O
current_chunk_size	long
)	O
{	O
uint64_t	long
cur_chunk_left	long
;	O
cur_chunk_left	long
=	O
request	pointer
->	O
current_chunk_size	long
-	O
request	pointer
->	O
current_chunk_offset	long
;	O
if	O
(	O
cur_chunk_left	long
>	O
available	long
)	O
{	O
to_be_processed	long
=	O
available	long
;	O
}	O
else	O
{	O
to_be_processed	long
=	O
(	O
size_t	long
)	O
cur_chunk_left	long
;	O
if	O
(	O
available	long
>	O
to_be_processed	long
)	O
instant_retry	bool
=	O
true	int
;	O
}	O
}	O
else	O
{	O
size_t	long
i	int
;	O
size_t	long
end_size	long
;	O
bool	bool
malformed	bool
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
available	long
)	O
{	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
||	O
(	O
';'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
)	O
break	O
;	O
i	int
++	O
;	O
if	O
(	O
i	int
>=	O
16	int
)	O
break	O
;	O
}	O
end_size	long
=	O
i	int
;	O
if	O
(	O
';'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
{	O
while	O
(	O
i	int
<	O
available	long
)	O
{	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
)	O
break	O
;	O
i	int
++	O
;	O
}	O
}	O
if	O
(	O
(	O
i	int
+	O
1	int
>=	O
available	long
)	O
&&	O
!	O
(	O
(	O
1	int
==	O
i	int
)	O
&&	O
(	O
2	int
==	O
available	long
)	O
&&	O
(	O
'0'	O
==	O
buffer_head	pointer
[	O
0	int
]	O
)	O
)	O
)	O
break	O
;	O
i	int
++	O
;	O
malformed	bool
=	O
(	O
end_size	long
>=	O
16	int
)	O
;	O
if	O
(	O
!	O
malformed	bool
)	O
{	O
size_t	long
num_dig	long
=	O
MHD_strx_to_uint64_n_	function
(	O
buffer_head	pointer
,	O
end_size	long
,	O
&	O
request	pointer
->	O
current_chunk_size	long
)	O
;	O
malformed	bool
=	O
(	O
end_size	long
!=	O
num_dig	long
)	O
;	O
}	O
if	O
(	O
malformed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CHUNKED_ENCODING_MALFORMED	int
,	O
_	O
(	O
"Received malformed HTTP request (bad chunked encoding). Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
i	int
<	O
available	long
)	O
&&	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	int
]	O
)	O
)	O
)	O
i	int
++	O
;	O
buffer_head	pointer
+=	O
i	int
;	O
available	long
-=	O
i	int
;	O
request	pointer
->	O
current_chunk_offset	long
=	O
0	int
;	O
if	O
(	O
available	long
>	O
0	int
)	O
instant_retry	bool
=	O
true	int
;	O
if	O
(	O
0LLU	int
==	O
request	pointer
->	O
current_chunk_size	long
)	O
{	O
request	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
break	O
;	O
}	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
0	int
!=	O
request	pointer
->	O
remaining_upload_size	long
)	O
&&	O
(	O
MHD_SIZE_UNKNOWN	O
!=	O
request	pointer
->	O
remaining_upload_size	long
)	O
&&	O
(	O
request	pointer
->	O
remaining_upload_size	long
<	O
available	long
)	O
)	O
{	O
to_be_processed	long
=	O
(	O
size_t	long
)	O
request	pointer
->	O
remaining_upload_size	long
;	O
}	O
else	O
{	O
to_be_processed	long
=	O
available	long
;	O
}	O
}	O
left_unprocessed	long
=	O
to_be_processed	long
;	O
if	O
(	O
left_unprocessed	long
>	O
to_be_processed	long
)	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
_	O
(	O
"libmicrohttpd API violation"	pointer
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
left_unprocessed	long
)	O
{	O
instant_retry	bool
=	O
false	int
;	O
if	O
(	O
(	O
MHD_TM_EXTERNAL_EVENT_LOOP	int
==	O
daemon	function
->	O
threading_mode	enum
)	O
&&	O
(	O
!	O
connection	pointer
->	O
suspended	enum
)	O
)	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_APPLICATION_HUNG_CONNECTION	int
,	O
_	O
(	O
"WARNING: incomplete upload processing and connection not suspended may result in hung connection.\n"	pointer
)	O
)	O
;	O
}	O
processed_size	long
=	O
to_be_processed	long
-	O
left_unprocessed	long
;	O
if	O
(	O
request	pointer
->	O
have_chunked_upload	bool
)	O
request	pointer
->	O
current_chunk_offset	long
+=	O
processed_size	long
;	O
buffer_head	pointer
+=	O
processed_size	long
;	O
available	long
-=	O
processed_size	long
;	O
if	O
(	O
MHD_SIZE_UNKNOWN	O
!=	O
request	pointer
->	O
remaining_upload_size	long
)	O
request	pointer
->	O
remaining_upload_size	long
-=	O
processed_size	long
;	O
}	O
while	O
(	O
instant_retry	bool
)	O
;	O
if	O
(	O
available	long
>	O
0	int
)	O
memmove	function
(	O
request	pointer
->	O
read_buffer	pointer
,	O
buffer_head	pointer
,	O
available	long
)	O
;	O
request	pointer
->	O
read_buffer_offset	long
=	O
available	long
;	O
}	O
static	O
void	O
cleanup_connection	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
connection	pointer
->	O
request	pointer
.	O
in_cleanup	bool
)	O
return	O
;	O
connection	pointer
->	O
request	pointer
.	O
in_cleanup	bool
=	O
true	int
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
request	pointer
.	O
response	pointer
)	O
{	O
MHD_response_queue_for_destroy	function
(	O
connection	pointer
->	O
request	pointer
.	O
response	pointer
)	O
;	O
connection	pointer
->	O
request	pointer
.	O
response	pointer
=	O
NULL	O
;	O
}	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
{	O
DLL_remove	O
(	O
daemon	function
->	O
suspended_connections_head	pointer
,	O
daemon	function
->	O
suspended_connections_tail	pointer
,	O
connection	pointer
)	O
;	O
connection	pointer
->	O
suspended	enum
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
if	O
(	O
connection	pointer
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_default_timeout	long
)	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
else	O
XDLL_remove	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_remove	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_insert	O
(	O
daemon	function
->	O
cleanup_head	pointer
,	O
daemon	function
->	O
cleanup_tail	pointer
,	O
connection	pointer
)	O
;	O
connection	pointer
->	O
resuming	bool
=	O
false	int
;	O
connection	pointer
->	O
request	pointer
.	O
in_idle	bool
=	O
false	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
==	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"c"	pointer
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ITC_USE_FAILED	int
,	O
_	O
(	O
"Failed to signal end of connection via inter-thread communication channel"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
static	O
bool	bool
connection_epoll_update_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
(	O
MHD_ELS_EPOLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_SUSPENDED	int
)	O
)	O
&&	O
(	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
connection	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_WRITE_READY	int
)	O
)	O
)	O
||	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
connection	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_READ_READY	int
)	O
)	O
)	O
)	O
)	O
{	O
struct	O
epoll_event	struct
event	struct
;	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
|	O
EPOLLOUT	int
|	O
EPOLLPRI	int
|	O
EPOLLET	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
connection	pointer
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
connection	pointer
->	O
socket_fd	int
,	O
&	O
event	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_EPOLL_CTL_ADD_FAILED	int
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
connection	pointer
->	O
request	pointer
.	O
state	pointer
=	O
MHD_REQUEST_CLOSED	int
;	O
cleanup_connection	function
(	O
connection	pointer
)	O
;	O
return	O
false	int
;	O
}	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
void	O
connection_update_event_loop_info	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
struct	O
MHD_Request	struct
*	O
request	pointer
=	O
&	O
connection	pointer
->	O
request	pointer
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
return	O
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
request	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_REQUEST_INIT	int
:	O
case	O
MHD_REQUEST_URL_RECEIVED	int
:	O
case	O
MHD_REQUEST_HEADER_PART_RECEIVED	int
:	O
if	O
(	O
(	O
request	pointer
->	O
read_buffer_offset	long
==	O
request	pointer
->	O
read_buffer_size	long
)	O
&&	O
(	O
!	O
try_grow_read_buffer	function
(	O
request	pointer
)	O
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CLIENT_HEADER_TOO_BIG	int
,	O
(	O
NULL	O
!=	O
request	pointer
->	O
url	pointer
)	O
?	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
:	O
MHD_HTTP_URI_TOO_LONG	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
connection	pointer
->	O
read_closed	bool
)	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_READ	int
;	O
else	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_REQUEST_HEADERS_RECEIVED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_REQUEST_HEADERS_PROCESSED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_REQUEST_CONTINUE_SENDING	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_REQUEST_CONTINUE_SENT	int
:	O
if	O
(	O
request	pointer
->	O
read_buffer_offset	long
==	O
request	pointer
->	O
read_buffer_size	long
)	O
{	O
if	O
(	O
(	O
!	O
try_grow_read_buffer	function
(	O
request	pointer
)	O
)	O
&&	O
(	O
MHD_TM_EXTERNAL_EVENT_LOOP	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_APPLICATION_HUNG_CONNECTION_CLOSED	int
,	O
MHD_HTTP_INTERNAL_SERVER_ERROR	int
,	O
INTERNAL_ERROR	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
(	O
request	pointer
->	O
read_buffer_offset	long
<	O
request	pointer
->	O
read_buffer_size	long
)	O
&&	O
(	O
!	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_READ	int
;	O
else	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_REQUEST_BODY_RECEIVED	int
:	O
case	O
MHD_REQUEST_FOOTER_PART_RECEIVED	int
:	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_READ_FAIL_CLOSED	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_READ	int
;	O
break	O
;	O
case	O
MHD_REQUEST_FOOTERS_RECEIVED	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_REQUEST_HEADERS_SENDING	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_REQUEST_HEADERS_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_REQUEST_NORMAL_BODY_READY	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_REQUEST_NORMAL_BODY_UNREADY	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_REQUEST_CHUNKED_BODY_READY	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_REQUEST_CHUNKED_BODY_UNREADY	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_REQUEST_BODY_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_REQUEST_FOOTERS_SENDING	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_REQUEST_FOOTERS_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_REQUEST_CLOSED	int
:	O
request	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
;	O
return	O
;	O
case	O
MHD_REQUEST_UPGRADE	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
bool	bool
MHD_request_handle_idle_	function
(	O
struct	O
MHD_Request	struct
*	O
request	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
request	pointer
->	O
daemon	function
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
=	O
request	pointer
->	O
connection	pointer
;	O
char	O
*	O
line	int
;	O
size_t	long
line_len	long
;	O
bool	bool
ret	long
;	O
request	pointer
->	O
in_idle	bool
=	O
true	int
;	O
while	O
(	O
!	O
connection	pointer
->	O
suspended	enum
)	O
{	O
switch	O
(	O
request	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_REQUEST_INIT	int
:	O
line	int
=	O
get_next_header_line	function
(	O
request	pointer
,	O
&	O
line_len	long
)	O
;	O
if	O
(	O
(	O
NULL	O
==	O
line	int
)	O
||	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
)	O
{	O
if	O
(	O
MHD_REQUEST_INIT	int
!=	O
request	pointer
->	O
state	pointer
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_READ_FAIL_CLOSED	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
parse_initial_message_line	function
(	O
request	pointer
,	O
line	int
,	O
line_len	long
)	O
)	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_CLOSED	int
,	O
NULL	O
)	O
;	O
else	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_URL_RECEIVED	int
;	O
continue	O
;	O
case	O
MHD_REQUEST_URL_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
request	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
MHD_REQUEST_URL_RECEIVED	int
!=	O
request	pointer
->	O
state	pointer
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_READ_FAIL_CLOSED	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADERS_RECEIVED	int
;	O
request	pointer
->	O
header_size	long
=	O
(	O
size_t	long
)	O
(	O
line	int
-	O
request	pointer
->	O
read_buffer	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
process_header_line	function
(	O
request	pointer
,	O
line	int
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CONNECTION_PARSE_FAIL_CLOSED	int
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
REQUEST_MALFORMED	pointer
)	O
;	O
break	O
;	O
}	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADER_PART_RECEIVED	int
;	O
continue	O
;	O
case	O
MHD_REQUEST_HEADER_PART_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
request	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
request	pointer
->	O
state	pointer
!=	O
MHD_REQUEST_HEADER_PART_RECEIVED	int
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_READ_FAIL_CLOSED	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_broken_line	function
(	O
request	pointer
,	O
line	int
,	O
MHD_HEADER_KIND	int
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADERS_RECEIVED	int
;	O
request	pointer
->	O
header_size	long
=	O
(	O
size_t	long
)	O
(	O
line	int
-	O
request	pointer
->	O
read_buffer	pointer
)	O
;	O
continue	O
;	O
}	O
continue	O
;	O
case	O
MHD_REQUEST_HEADERS_RECEIVED	int
:	O
parse_request_headers	function
(	O
request	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_CLOSED	int
==	O
request	pointer
->	O
state	pointer
)	O
continue	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADERS_PROCESSED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
break	O
;	O
continue	O
;	O
case	O
MHD_REQUEST_HEADERS_PROCESSED	int
:	O
call_request_handler	function
(	O
request	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_CLOSED	int
==	O
request	pointer
->	O
state	pointer
)	O
continue	O
;	O
if	O
(	O
need_100_continue	function
(	O
request	pointer
)	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_CONTINUE_SENDING	int
;	O
if	O
(	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_extra_buffering	function
(	O
connection	pointer
)	O
;	O
else	O
socket_start_no_buffering	function
(	O
connection	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
)	O
&&	O
(	O
(	O
MHD_METHOD_POST	int
==	O
request	pointer
->	O
method	enum
)	O
||	O
(	O
MHD_METHOD_PUT	int
==	O
request	pointer
->	O
method	enum
)	O
)	O
)	O
{	O
request	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
}	O
request	pointer
->	O
state	pointer
=	O
(	O
0	int
==	O
request	pointer
->	O
remaining_upload_size	long
)	O
?	O
MHD_REQUEST_FOOTERS_RECEIVED	int
:	O
MHD_REQUEST_CONTINUE_SENT	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
break	O
;	O
continue	O
;	O
case	O
MHD_REQUEST_CONTINUE_SENDING	int
:	O
if	O
(	O
request	pointer
->	O
continue_message_write_offset	long
==	O
MHD_STATICSTR_LEN_	O
(	O
HTTP_100_CONTINUE	pointer
)	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_CONTINUE_SENT	int
;	O
if	O
(	O
!	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_no_buffering_flush	function
(	O
connection	pointer
)	O
;	O
else	O
socket_start_normal_buffering	function
(	O
connection	pointer
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
MHD_REQUEST_CONTINUE_SENT	int
:	O
if	O
(	O
0	int
!=	O
request	pointer
->	O
read_buffer_offset	long
)	O
{	O
process_request_body	function
(	O
request	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_CLOSED	int
==	O
request	pointer
->	O
state	pointer
)	O
continue	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
request	pointer
->	O
remaining_upload_size	long
)	O
||	O
(	O
(	O
MHD_SIZE_UNKNOWN	O
==	O
request	pointer
->	O
remaining_upload_size	long
)	O
&&	O
(	O
0	int
==	O
request	pointer
->	O
read_buffer_offset	long
)	O
&&	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
)	O
{	O
if	O
(	O
(	O
request	pointer
->	O
have_chunked_upload	bool
)	O
&&	O
(	O
!	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_BODY_RECEIVED	int
;	O
else	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_RECEIVED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
break	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
MHD_REQUEST_BODY_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
request	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
request	pointer
->	O
state	pointer
!=	O
MHD_REQUEST_BODY_RECEIVED	int
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_CLOSED	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_RECEIVED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_header_line	function
(	O
request	pointer
,	O
line	int
)	O
)	O
{	O
transmit_error_response	function
(	O
request	pointer
,	O
MHD_SC_CONNECTION_PARSE_FAIL_CLOSED	int
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
REQUEST_MALFORMED	pointer
)	O
;	O
break	O
;	O
}	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTER_PART_RECEIVED	int
;	O
continue	O
;	O
case	O
MHD_REQUEST_FOOTER_PART_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
request	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
request	pointer
->	O
state	pointer
!=	O
MHD_REQUEST_FOOTER_PART_RECEIVED	int
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_CONNECTION_CLOSED	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_broken_line	function
(	O
request	pointer
,	O
line	int
,	O
MHD_FOOTER_KIND	int
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_RECEIVED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	enum
)	O
break	O
;	O
continue	O
;	O
}	O
continue	O
;	O
case	O
MHD_REQUEST_FOOTERS_RECEIVED	int
:	O
call_request_handler	function
(	O
request	pointer
)	O
;	O
if	O
(	O
request	pointer
->	O
state	pointer
==	O
MHD_REQUEST_CLOSED	int
)	O
continue	O
;	O
if	O
(	O
NULL	O
==	O
request	pointer
->	O
response	pointer
)	O
break	O
;	O
if	O
(	O
!	O
build_header_response	function
(	O
request	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_FAILED_RESPONSE_HEADER_GENERATION	int
,	O
_	O
(	O
"Closing connection (failed to create response header)\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADERS_SENDING	int
;	O
if	O
(	O
MHD_NO	int
!=	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_extra_buffering	function
(	O
connection	pointer
)	O
;	O
else	O
socket_start_no_buffering	function
(	O
connection	pointer
)	O
;	O
break	O
;	O
case	O
MHD_REQUEST_HEADERS_SENDING	int
:	O
break	O
;	O
case	O
MHD_REQUEST_HEADERS_SENT	int
:	O
if	O
(	O
MHD_NO	int
!=	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_no_buffering_flush	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
upgrade_handler	pointer
)	O
{	O
socket_start_normal_buffering	function
(	O
connection	pointer
)	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_UPGRADE	int
;	O
{	O
struct	O
MHD_Response	struct
*	O
const	O
resp	pointer
=	O
request	pointer
->	O
response	pointer
;	O
request	pointer
->	O
response	pointer
=	O
NULL	O
;	O
MHD_response_queue_for_destroy	function
(	O
resp	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
MHD_NO	int
!=	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_extra_buffering	function
(	O
connection	pointer
)	O
;	O
else	O
socket_start_normal_buffering	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
request	pointer
->	O
have_chunked_upload	bool
)	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_CHUNKED_BODY_UNREADY	int
;	O
else	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_NORMAL_BODY_UNREADY	int
;	O
continue	O
;	O
case	O
MHD_REQUEST_NORMAL_BODY_READY	int
:	O
break	O
;	O
case	O
MHD_REQUEST_NORMAL_BODY_UNREADY	int
:	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_lock_chk_	O
(	O
&	O
request	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
0	int
==	O
request	pointer
->	O
response	pointer
->	O
total_size	long
)	O
{	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
request	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_BODY_SENT	int
;	O
continue	O
;	O
}	O
if	O
(	O
try_ready_normal_body	function
(	O
request	pointer
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
request	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_NORMAL_BODY_READY	int
;	O
if	O
(	O
MHD_NO	int
==	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_no_buffering	function
(	O
connection	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
MHD_REQUEST_CHUNKED_BODY_READY	int
:	O
break	O
;	O
case	O
MHD_REQUEST_CHUNKED_BODY_UNREADY	int
:	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_lock_chk_	O
(	O
&	O
request	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
(	O
0	int
==	O
request	pointer
->	O
response	pointer
->	O
total_size	long
)	O
||	O
(	O
request	pointer
->	O
response_write_position	long
==	O
request	pointer
->	O
response	pointer
->	O
total_size	long
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
request	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_BODY_SENT	int
;	O
continue	O
;	O
}	O
if	O
(	O
try_ready_chunked_body	function
(	O
request	pointer
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
request	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
request	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_CHUNKED_BODY_READY	int
;	O
if	O
(	O
MHD_NO	int
==	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_no_buffering	function
(	O
connection	pointer
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
MHD_REQUEST_BODY_SENT	int
:	O
if	O
(	O
!	O
build_header_response	function
(	O
request	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
MHD_SC_FAILED_RESPONSE_HEADER_GENERATION	int
,	O
_	O
(	O
"Closing connection (failed to create response header)\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
!	O
request	pointer
->	O
have_chunked_upload	bool
)	O
||	O
(	O
request	pointer
->	O
write_buffer_send_offset	long
==	O
request	pointer
->	O
write_buffer_append_offset	long
)	O
)	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_SENT	int
;	O
else	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_FOOTERS_SENDING	int
;	O
continue	O
;	O
case	O
MHD_REQUEST_FOOTERS_SENDING	int
:	O
break	O
;	O
case	O
MHD_REQUEST_FOOTERS_SENT	int
:	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
request	pointer
->	O
response	pointer
;	O
if	O
(	O
MHD_HTTP_PROCESSING	int
==	O
response	pointer
->	O
status_code	enum
)	O
{	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_HEADERS_PROCESSED	int
;	O
MHD_response_queue_for_destroy	function
(	O
response	pointer
)	O
;	O
request	pointer
->	O
response	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
if	O
(	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_no_buffering_flush	function
(	O
connection	pointer
)	O
;	O
else	O
socket_start_normal_buffering	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
termination_cb	pointer
)	O
{	O
response	pointer
->	O
termination_cb	pointer
(	O
response	pointer
->	O
termination_cb_cls	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
,	O
request	pointer
->	O
client_context	pointer
)	O
;	O
}	O
MHD_response_queue_for_destroy	function
(	O
response	pointer
)	O
;	O
request	pointer
->	O
response	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
MHD_CONN_USE_KEEPALIVE	int
!=	O
request	pointer
->	O
keepalive	enum
)	O
||	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
{	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
MHD_pool_destroy	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
connection	pointer
->	O
pool	pointer
=	O
NULL	O
;	O
request	pointer
->	O
read_buffer	pointer
=	O
NULL	O
;	O
request	pointer
->	O
read_buffer_size	long
=	O
0	int
;	O
request	pointer
->	O
read_buffer_offset	long
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
socket_flush_possible	function
(	O
connection	pointer
)	O
)	O
socket_start_normal_buffering	function
(	O
connection	pointer
)	O
;	O
request	pointer
->	O
version_s	pointer
=	O
NULL	O
;	O
request	pointer
->	O
state	pointer
=	O
MHD_REQUEST_INIT	int
;	O
request	pointer
->	O
last	pointer
=	O
NULL	O
;	O
request	pointer
->	O
colon	pointer
=	O
NULL	O
;	O
request	pointer
->	O
header_size	long
=	O
0	int
;	O
request	pointer
->	O
keepalive	enum
=	O
MHD_CONN_KEEPALIVE_UNKOWN	int
;	O
request	pointer
->	O
read_buffer	pointer
=	O
MHD_pool_reset	function
(	O
connection	pointer
->	O
pool	pointer
,	O
request	pointer
->	O
read_buffer	pointer
,	O
request	pointer
->	O
read_buffer_offset	long
,	O
daemon	function
->	O
connection_memory_limit_b	long
/	O
2	int
)	O
;	O
request	pointer
->	O
read_buffer_size	long
=	O
daemon	function
->	O
connection_memory_limit_b	long
/	O
2	int
;	O
}	O
memset	function
(	O
request	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
MHD_Request	struct
)	O
)	O
;	O
request	pointer
->	O
daemon	function
=	O
daemon	function
;	O
request	pointer
->	O
connection	pointer
=	O
connection	pointer
;	O
continue	O
;	O
case	O
MHD_REQUEST_CLOSED	int
:	O
cleanup_connection	function
(	O
connection	pointer
)	O
;	O
request	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
false	int
;	O
case	O
MHD_REQUEST_UPGRADE	int
:	O
request	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
true	int
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
connection	pointer
->	O
suspended	enum
)	O
{	O
time_t	long
timeout	pointer
;	O
timeout	pointer
=	O
connection	pointer
->	O
connection_timeout	int
;	O
if	O
(	O
(	O
0	int
!=	O
timeout	pointer
)	O
&&	O
(	O
timeout	pointer
<	O
(	O
MHD_monotonic_sec_counter	function
(	O
)	O
-	O
connection	pointer
->	O
last_activity	long
)	O
)	O
)	O
{	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_TIMEOUT_REACHED	int
)	O
;	O
request	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
}	O
connection_update_event_loop_info	function
(	O
connection	pointer
)	O
;	O
ret	long
=	O
true	int
;	O
if	O
(	O
(	O
!	O
connection	pointer
->	O
suspended	enum
)	O
&&	O
(	O
MHD_ELS_EPOLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
)	O
{	O
ret	long
=	O
connection_epoll_update_	function
(	O
connection	pointer
)	O
;	O
}	O
request	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
ret	long
;	O
}	O
int	O
MHD_connection_call_handlers_	function
(	O
struct	O
MHD_Connection	struct
*	O
con	pointer
,	O
bool	bool
read_ready	bool
,	O
bool	bool
write_ready	bool
,	O
bool	bool
force_close	bool
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
con	pointer
->	O
daemon	function
;	O
int	O
ret	long
;	O
bool	bool
states_info_processed	bool
=	O
false	int
;	O
bool	bool
on_fasttrack	bool
=	O
(	O
con	pointer
->	O
request	pointer
.	O
state	pointer
==	O
MHD_REQUEST_INIT	int
)	O
;	O
if	O
(	O
!	O
force_close	bool
)	O
{	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
con	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
read_ready	bool
)	O
{	O
MHD_request_handle_read_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
ret	long
=	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
states_info_processed	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
con	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
write_ready	bool
)	O
{	O
MHD_request_handle_write_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
ret	long
=	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
states_info_processed	bool
=	O
true	int
;	O
}	O
}	O
else	O
{	O
MHD_connection_close_	function
(	O
con	pointer
,	O
MHD_REQUEST_TERMINATED_WITH_ERROR	int
)	O
;	O
return	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
}	O
if	O
(	O
!	O
states_info_processed	bool
)	O
{	O
ret	long
=	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
}	O
else	O
if	O
(	O
on_fasttrack	bool
&&	O
con	pointer
->	O
sk_nonblck	bool
)	O
{	O
if	O
(	O
MHD_REQUEST_HEADERS_SENDING	int
==	O
con	pointer
->	O
request	pointer
.	O
state	pointer
)	O
{	O
MHD_request_handle_write_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
ret	long
=	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
}	O
if	O
(	O
(	O
MHD_REQUEST_NORMAL_BODY_READY	int
==	O
con	pointer
->	O
request	pointer
.	O
state	pointer
)	O
||	O
(	O
MHD_REQUEST_CHUNKED_BODY_READY	int
==	O
con	pointer
->	O
request	pointer
.	O
state	pointer
)	O
)	O
{	O
MHD_request_handle_write_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
ret	long
=	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
!	O
daemon	function
->	O
data_already_pending	bool
)	O
&&	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
)	O
{	O
if	O
(	O
MHD_EVENT_LOOP_INFO_BLOCK	int
==	O
con	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
daemon	function
->	O
data_already_pending	bool
=	O
true	int
;	O
}	O
return	O
ret	long
;	O
}	O
