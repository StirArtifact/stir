OBJID	long
EDMAPROC	O
_edma_clone_simple_obj	function
(	O
OBJID	long
IdObj	long
,	O
ESint32	long
copy	long
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
idc	long
;	O
EChar	char
ClassNam1	array
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
ESint32	long
i	long
,	O
n	long
,	O
offset	long
;	O
EDMAT_BUFFER	struct
*	O
src_pbuf	pointer
,	O
*	O
dest_pbuf	pointer
;	O
EPByte	pointer
src_ptr	pointer
,	O
dest_ptr	pointer
;	O
idc	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
strcpy	function
(	O
ClassNam1	array
,	O
gClass	O
[	O
idc	long
]	O
->	O
ClassName	array
)	O
;	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	function
(	O
idc	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_shallow_clone] Basic Stage Failed."	pointer
"Can't create object of class '%s'"	pointer
,	O
ClassNam1	array
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	function
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Virtual Method Stage "	pointer
"Failed. "	pointer
"Can't create object of class '%s'"	pointer
,	O
ClassNam1	array
)	O
;	O
if	O
(	O
(	O
_edma_newobj_final_stage	function
(	O
id	long
,	O
NULL	O
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Final Stage Failed. "	pointer
"can't create object of class '%s'"	pointer
,	O
ClassNam1	array
)	O
;	O
memcpy	function
(	O
gObj	O
[	O
id	long
]	O
->	O
Data	pointer
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
,	O
gClass	O
[	O
idc	long
]	O
->	O
TamDatos	long
)	O
;	O
if	O
(	O
copy	long
)	O
{	O
n	long
=	O
gClass	O
[	O
idc	long
]	O
->	O
nProp	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
idc	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pClass	pointer
[	O
idc	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
nElem	long
>	O
0	int
)	O
{	O
edma_printf	function
(	O
"[DEBUG] CloneObj. Located ARRAY type... "	pointer
"Still Not implemented"	pointer
)	O
;	O
}	O
offset	long
=	O
pClass	pointer
[	O
idc	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Off	short
;	O
src_ptr	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
+	O
offset	long
;	O
dest_ptr	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
id	long
]	O
->	O
Data	pointer
)	O
+	O
offset	long
;	O
switch	O
(	O
pClass	pointer
[	O
idc	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
src_pbuf	pointer
=	O
(	O
EDMAT_BUFFER	struct
*	O
)	O
src_ptr	pointer
;	O
dest_pbuf	pointer
=	O
(	O
EDMAT_BUFFER	struct
*	O
)	O
dest_ptr	pointer
;	O
if	O
(	O
(	O
edma_buffer_alloc	function
(	O
dest_pbuf	pointer
,	O
src_pbuf	pointer
->	O
Size	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[%s] Can't allocate buffer for "	pointer
"cloned object"	pointer
,	O
__FUNCTION__	O
)	O
;	O
}	O
memcpy	function
(	O
dest_pbuf	pointer
->	O
dat	pointer
,	O
src_pbuf	pointer
->	O
dat	pointer
,	O
src_pbuf	pointer
->	O
Size	long
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
edma_log	function
(	O
"[%s] Clonning string '%s'"	pointer
,	O
__FUNCTION__	O
,	O
*	O
(	O
EPChar	pointer
*	O
)	O
src_ptr	pointer
)	O
;	O
if	O
(	O
(	O
*	O
(	O
EPChar	pointer
*	O
)	O
src_ptr	pointer
)	O
)	O
*	O
(	O
EPChar	pointer
*	O
)	O
dest_ptr	pointer
=	O
(	O
EPChar	pointer
)	O
strdup	function
(	O
*	O
(	O
EPChar	pointer
*	O
)	O
src_ptr	pointer
)	O
;	O
else	O
*	O
(	O
EPChar	pointer
*	O
)	O
dest_ptr	pointer
=	O
(	O
EPChar	pointer
)	O
NULL	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_clone_subobjects	function
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
id_from	long
)	O
{	O
OBJID	long
id_subobj	long
,	O
aux	long
;	O
POBJ	pointer
pObj2	pointer
,	O
pObj	pointer
;	O
ESint32	long
i	long
,	O
n	long
,	O
i1	long
,	O
n1	long
;	O
pObj	pointer
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
n	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
aux	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
id_subobj	long
=	O
_edma_clone_simple_obj	function
(	O
aux	long
,	O
1	int
)	O
;	O
if	O
(	O
id_subobj	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[%s] Can't clone subobject...."	pointer
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pObj2	pointer
=	O
gObj	O
[	O
aux	long
]	O
;	O
edma_add_superobject	function
(	O
id_from	long
,	O
id_subobj	long
,	O
pObj	pointer
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
)	O
;	O
n1	long
=	O
pObj2	pointer
->	O
nDownTable	long
;	O
if	O
(	O
n1	long
)	O
{	O
for	O
(	O
i1	long
=	O
0	int
;	O
i1	long
<	O
n1	long
;	O
i1	long
++	O
)	O
if	O
(	O
pObj2	pointer
->	O
DownTable	pointer
[	O
i1	long
]	O
.	O
Obj	long
==	O
IdObj	long
)	O
break	O
;	O
edma_add_subobject	function
(	O
id_subobj	long
,	O
id_from	long
,	O
pObj2	pointer
->	O
DownTable	pointer
[	O
i1	long
]	O
.	O
Id	pointer
)	O
;	O
}	O
else	O
{	O
edma_log	function
(	O
"[%s] WARNNING... subobject has no uplink"	pointer
,	O
__FUNCTION__	O
)	O
;	O
}	O
_edma_clone_subobjects	function
(	O
pObj2	pointer
->	O
IdObj	long
,	O
id_subobj	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_clone_superobjects	function
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
id_from	long
)	O
{	O
OBJID	long
id_subobj	long
,	O
aux	long
;	O
POBJ	pointer
pObj2	pointer
,	O
pObj	pointer
;	O
ESint32	long
i	long
,	O
n	long
,	O
i1	long
,	O
n1	long
;	O
pObj	pointer
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
n	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
aux	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
id_subobj	long
=	O
_edma_clone_simple_obj	function
(	O
aux	long
,	O
1	int
)	O
;	O
if	O
(	O
id_subobj	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[%s] Can't clone subobject...."	pointer
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pObj2	pointer
=	O
gObj	O
[	O
aux	long
]	O
;	O
edma_add_subobject	function
(	O
id_from	long
,	O
id_subobj	long
,	O
pObj	pointer
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
)	O
;	O
n1	long
=	O
pObj2	pointer
->	O
nUpTable	long
;	O
if	O
(	O
n1	long
)	O
{	O
for	O
(	O
i1	long
=	O
0	int
;	O
i1	long
<	O
n1	long
;	O
i1	long
++	O
)	O
if	O
(	O
pObj2	pointer
->	O
UpTable	pointer
[	O
i1	long
]	O
.	O
Obj	long
==	O
IdObj	long
)	O
break	O
;	O
edma_add_superobject	function
(	O
id_subobj	long
,	O
id_from	long
,	O
pObj2	pointer
->	O
UpTable	pointer
[	O
i1	long
]	O
.	O
Id	pointer
)	O
;	O
}	O
else	O
{	O
edma_log	function
(	O
"[%s] WARNNING... subobject has no uplink"	pointer
,	O
__FUNCTION__	O
)	O
;	O
}	O
_edma_clone_superobjects	function
(	O
pObj2	pointer
->	O
IdObj	long
,	O
id_subobj	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_clone_obj	function
(	O
OBJID	long
IdObj	long
)	O
{	O
OBJID	long
id_clone	long
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_clone_obj"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
id_clone	long
=	O
_edma_clone_simple_obj	function
(	O
IdObj	long
,	O
1	int
)	O
;	O
_edma_clone_superobjects	function
(	O
IdObj	long
,	O
id_clone	long
)	O
;	O
_edma_clone_subobjects	function
(	O
IdObj	long
,	O
id_clone	long
)	O
;	O
return	O
id_clone	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_shallow_clone_obj	function
(	O
OBJID	long
IdObj	long
)	O
{	O
OBJID	long
id	long
;	O
EChar	char
aux	long
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
ESint32	long
i	long
,	O
n	long
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_shallow_clone_obj"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
id	long
=	O
_edma_clone_simple_obj	function
(	O
IdObj	long
,	O
1	int
)	O
;	O
n	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
sprintf	function
(	O
aux	long
,	O
"child-%ld-%ld"	pointer
,	O
id	long
,	O
i	long
)	O
;	O
edma_add_superobject	function
(	O
id	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
)	O
;	O
edma_add_subobject	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
,	O
id	long
,	O
aux	long
)	O
;	O
}	O
return	O
id	long
;	O
}	O
