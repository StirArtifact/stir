static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_vrfy.c,v 1.2 2014/04/17 20:27:28 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__db_guesspgsize	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_FH	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_is_valid_magicno	function
__P	O
(	O
(	O
u_int32_t	int
,	O
DBTYPE	enum
*	O
)	O
)	O
;	O
static	O
int	O
__db_is_valid_pagetype	function
__P	O
(	O
(	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_meta2pgset	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
,	O
DB	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_salvage_subdbs	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
void	O
*	O
,	O
int	O
(	O
*	O
)	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
,	O
u_int32_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_salvage_unknowns	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
void	O
*	O
,	O
int	O
(	O
*	O
)	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_common	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
PAGE	struct
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_freelist	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_invalid	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
PAGE	struct
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_orderchkonly	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_pagezero	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
DB_FH	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_subdbs	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
char	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_structure	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
char	O
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_vrfy_walkpages	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
void	O
*	O
,	O
int	O
(	O
*	O
)	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___db_verify	function
(	O
dbp	pointer
,	O
file	int
,	O
database	pointer
,	O
outfile	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
file	int
,	O
*	O
database	pointer
;	O
FILE	struct
*	O
outfile	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
return	O
(	O
CDB___db_verify_internal	function
(	O
dbp	pointer
,	O
file	int
,	O
database	pointer
,	O
outfile	pointer
,	O
CDB___db_verify_callback	function
,	O
flags	int
)	O
)	O
;	O
}	O
int	O
CDB___db_verify_callback	function
(	O
handle	pointer
,	O
str_arg	pointer
)	O
void	O
*	O
handle	pointer
;	O
const	O
void	O
*	O
str_arg	pointer
;	O
{	O
char	O
*	O
str	pointer
;	O
FILE	struct
*	O
f	pointer
;	O
str	pointer
=	O
(	O
char	O
*	O
)	O
str_arg	pointer
;	O
f	pointer
=	O
(	O
FILE	struct
*	O
)	O
handle	pointer
;	O
if	O
(	O
fprintf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
str	pointer
)	O
!=	O
(	O
int	O
)	O
strlen	function
(	O
str	pointer
)	O
)	O
return	O
(	O
EIO	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_verify_internal	function
(	O
dbp_orig	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp_orig	pointer
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
subdb	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
fh	struct
,	O
*	O
fhp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
last	int
;	O
int	O
has	int
,	O
ret	int
,	O
isbad	int
;	O
char	O
*	O
real_name	pointer
;	O
dbenv	pointer
=	O
dbp_orig	pointer
->	O
dbenv	pointer
;	O
vdp	pointer
=	O
NULL	O
;	O
real_name	pointer
=	O
NULL	O
;	O
ret	int
=	O
isbad	int
=	O
0	int
;	O
memset	function
(	O
&	O
fh	struct
,	O
0	int
,	O
sizeof	O
(	O
fh	struct
)	O
)	O
;	O
fhp	pointer
=	O
&	O
fh	struct
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
DB_ILLEGAL_AFTER_OPEN	O
(	O
dbp_orig	pointer
,	O
"verify"	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DB->verify"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
&&	O
(	O
flags	int
&	O
~	O
DB_AGGRESSIVE	int
)	O
!=	O
DB_SALVAGE	int
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"CDB___db_verify"	pointer
,	O
1	int
)	O
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_ORDERCHKONLY	int
)	O
&&	O
flags	int
!=	O
DB_ORDERCHKONLY	int
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"CDB___db_verify"	pointer
,	O
1	int
)	O
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_ORDERCHKONLY	int
)	O
&&	O
subdb	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"DB_ORDERCHKONLY requires a database name"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
||	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
||	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
dbp_orig	pointer
->	O
errx	pointer
(	O
dbp_orig	pointer
,	O
"verify may not be used with transactions, logging, or locking"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_db_create	function
(	O
&	O
dbp	pointer
,	O
dbenv	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
dbp_orig	pointer
->	O
pgsize	int
>=	O
DB_MIN_PGSIZE	int
&&	O
dbp_orig	pointer
->	O
pgsize	int
<=	O
DB_MAX_PGSIZE	int
)	O
dbp	pointer
->	O
set_pagesize	pointer
(	O
dbp	pointer
,	O
dbp_orig	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_dbinfo_create	function
(	O
dbenv	pointer
,	O
1024	int
,	O
&	O
vdp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
name	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
real_name	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
DB_OSO_RDONLY	int
,	O
0444	int
,	O
fhp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_pagezero	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
fhp	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_dbenv_setup	function
(	O
dbp	pointer
,	O
name	pointer
,	O
DB_ODDFILESIZE	int
|	O
DB_RDONLY	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
last	int
,	O
DB_MPOOL_LAST	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
vdp	pointer
->	O
last_pgno	int
=	O
last	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_ORDERCHKONLY	int
)	O
)	O
{	O
ret	int
=	O
__db_vrfy_orderchkonly	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
flags	int
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_salvage_init	function
(	O
vdp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
has	int
=	O
0	int
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
&&	O
(	O
__db_salvage_subdbs	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
,	O
&	O
has	int
)	O
)	O
!=	O
0	int
)	O
isbad	int
=	O
1	int
;	O
if	O
(	O
has	int
==	O
1	int
)	O
F_SET	O
(	O
vdp	pointer
,	O
SALVAGE_PRINTHEADER	int
)	O
;	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prheader	function
(	O
dbp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
handle	pointer
,	O
callback	pointer
,	O
vdp	pointer
,	O
PGNO_BASE_MD	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_walkpages	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
&&	O
isbad	int
==	O
0	int
)	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
real_name	pointer
,	O
0	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__db_salvage_unknowns	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
isbad	int
=	O
1	int
;	O
CDB___db_salvage_destroy	function
(	O
vdp	pointer
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
err	pointer
:	O
(	O
void	O
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
name	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
&&	O
(	O
has	int
==	O
0	int
||	O
F_ISSET	O
(	O
vdp	pointer
,	O
SALVAGE_PRINTFOOTER	int
)	O
)	O
)	O
(	O
void	O
)	O
CDB___db_prfooter	function
(	O
handle	pointer
,	O
callback	pointer
)	O
;	O
done	O
:	O
if	O
(	O
F_ISSET	O
(	O
fhp	pointer
,	O
DB_FH_VALID	int
)	O
)	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
fhp	pointer
)	O
;	O
if	O
(	O
dbp	pointer
)	O
(	O
void	O
)	O
dbp	pointer
->	O
close	pointer
(	O
dbp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
vdp	pointer
)	O
(	O
void	O
)	O
CDB___db_vrfy_dbinfo_destroy	function
(	O
vdp	pointer
)	O
;	O
if	O
(	O
real_name	pointer
)	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
||	O
ret	int
==	O
DB_VERIFY_FATAL	O
)	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_pagezero	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
fhp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DBMETA	struct
*	O
meta	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_pgno_t	int
freelist	int
;	O
int	O
t_ret	int
,	O
ret	int
,	O
nr	int
,	O
swapped	int
;	O
u_int8_t	char
mbuf	array
[	O
DBMETASIZE	int
]	O
;	O
swapped	int
=	O
ret	int
=	O
t_ret	int
=	O
0	int
;	O
freelist	int
=	O
0	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
meta	pointer
=	O
(	O
DBMETA	struct
*	O
)	O
mbuf	array
;	O
dbp	pointer
->	O
type	enum
=	O
DB_UNKNOWN	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
mbuf	array
,	O
DBMETASIZE	int
,	O
(	O
size_t	long
*	O
)	O
&	O
nr	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
nr	int
!=	O
DBMETASIZE	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Incomplete metadata page %lu"	pointer
,	O
PGNO_BASE_MD	int
)	O
)	O
;	O
t_ret	int
=	O
DB_VERIFY_FATAL	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
meta	pointer
->	O
pgno	int
!=	O
PGNO_BASE_MD	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad pgno: was %lu, should be %lu"	pointer
,	O
meta	pointer
->	O
pgno	int
,	O
PGNO_BASE_MD	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
if	O
(	O
__db_is_valid_magicno	function
(	O
meta	pointer
->	O
magic	int
,	O
&	O
dbp	pointer
->	O
type	enum
)	O
)	O
swapped	int
=	O
0	int
;	O
else	O
{	O
M_32_SWAP	O
(	O
meta	pointer
->	O
magic	int
)	O
;	O
if	O
(	O
__db_is_valid_magicno	function
(	O
meta	pointer
->	O
magic	int
,	O
&	O
dbp	pointer
->	O
type	enum
)	O
)	O
swapped	int
=	O
1	int
;	O
else	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad magic no.: %lu"	pointer
,	O
meta	pointer
->	O
magic	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
}	O
if	O
(	O
swapped	int
)	O
M_32_SWAP	O
(	O
meta	pointer
->	O
version	int
)	O
;	O
if	O
(	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_BTREE	int
&&	O
meta	pointer
->	O
version	int
!=	O
DB_BTREEVERSION	int
)	O
||	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_HASH	int
&&	O
meta	pointer
->	O
version	int
!=	O
DB_HASHVERSION	int
)	O
||	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_QUEUE	int
&&	O
meta	pointer
->	O
version	int
!=	O
DB_QAMVERSION	int
)	O
)	O
{	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s%s"	pointer
,	O
"Old or incorrect DB "	pointer
,	O
"version; extraneous errors may result"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
swapped	int
)	O
M_32_SWAP	O
(	O
meta	pointer
->	O
pagesize	long
)	O
;	O
if	O
(	O
IS_VALID_PAGESIZE	O
(	O
meta	pointer
->	O
pagesize	long
)	O
)	O
dbp	pointer
->	O
pgsize	int
=	O
meta	pointer
->	O
pagesize	long
;	O
else	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad page size: %lu"	pointer
,	O
meta	pointer
->	O
pagesize	long
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
if	O
(	O
!	O
IS_VALID_PAGESIZE	O
(	O
dbp	pointer
->	O
pgsize	int
)	O
)	O
dbp	pointer
->	O
pgsize	int
=	O
__db_guesspgsize	function
(	O
dbenv	pointer
,	O
fhp	pointer
)	O
;	O
}	O
if	O
(	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_BTREE	int
&&	O
meta	pointer
->	O
type	enum
!=	O
P_BTREEMETA	int
)	O
||	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_HASH	int
&&	O
meta	pointer
->	O
type	enum
!=	O
P_HASHMETA	int
)	O
||	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_QUEUE	int
&&	O
meta	pointer
->	O
type	enum
!=	O
P_QAMMETA	int
)	O
)	O
{	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad page type: %lu"	pointer
,	O
meta	pointer
->	O
type	enum
)	O
)	O
;	O
}	O
if	O
(	O
swapped	int
)	O
M_32_SWAP	O
(	O
meta	pointer
->	O
free	int
)	O
;	O
freelist	int
=	O
meta	pointer
->	O
free	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
PGNO_BASE_MD	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
pip	pointer
->	O
pgno	int
=	O
PGNO_BASE_MD	int
;	O
pip	pointer
->	O
type	enum
=	O
meta	pointer
->	O
type	enum
;	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
;	O
pip	pointer
->	O
free	int
=	O
freelist	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
0	int
)	O
{	O
err	pointer
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s"	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
}	O
if	O
(	O
swapped	int
==	O
1	int
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
;	O
if	O
(	O
t_ret	int
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_walkpages	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
i	int
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
ret	int
=	O
isbad	int
=	O
t_ret	int
=	O
0	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"__db_vrfy_walkpages"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
vdp	pointer
->	O
last_pgno	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
&&	O
(	O
CDB___db_salvage_isdone	function
(	O
vdp	pointer
,	O
i	int
)	O
!=	O
0	int
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
i	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
i	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
isbad	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
i	int
!=	O
PGNO_BASE_MD	int
)	O
if	O
(	O
(	O
t_ret	int
=	O
__db_vrfy_common	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
)	O
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_INVALID	int
:	O
t_ret	int
=	O
__db_vrfy_invalid	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
__P_DUPLICATE	int
:	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Old-style dup page %lu"	pointer
,	O
i	int
)	O
)	O
;	O
break	O
;	O
case	O
P_HASH	int
:	O
t_ret	int
=	O
CDB___ham_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
t_ret	int
=	O
CDB___bam_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_LRECNO	int
:	O
t_ret	int
=	O
CDB___ram_vrfy_leaf	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_OVERFLOW	int
:	O
t_ret	int
=	O
CDB___db_vrfy_overflow	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
t_ret	int
=	O
CDB___ham_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
HMETA	struct
*	O
)	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_BTREEMETA	int
:	O
t_ret	int
=	O
CDB___bam_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
BTMETA	struct
*	O
)	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_QAMMETA	int
:	O
t_ret	int
=	O
CDB___qam_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
QMETA	struct
*	O
)	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
P_QAMDATA	int
:	O
t_ret	int
=	O
CDB___qam_vrfy_data	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
QPAGE	struct
*	O
)	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
;	O
break	O
;	O
default	O
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unknown page type: %lu"	pointer
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
t_ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
if	O
(	O
t_ret	int
==	O
DB_VERIFY_FATAL	O
)	O
goto	O
err	pointer
;	O
else	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
0	int
)	O
{	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
==	O
0	int
?	O
t_ret	int
:	O
ret	int
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
return	O
(	O
(	O
isbad	int
==	O
1	int
&&	O
ret	int
==	O
0	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
dbname	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
char	O
*	O
dbname	pointer
;	O
db_pgno_t	int
meta_pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
pgset	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_pgno_t	int
i	int
;	O
int	O
ret	int
,	O
isbad	int
,	O
hassubs	int
,	O
p	pointer
;	O
isbad	int
=	O
0	int
;	O
pip	pointer
=	O
NULL	O
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
pgset	pointer
=	O
vdp	pointer
->	O
pgset	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DB->verify"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"__db_vrfy_structure called with DB_SALVAGE"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
case	O
DB_RECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
0	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
0	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
hassubs	int
=	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_SUBDBS	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
isbad	int
==	O
0	int
&&	O
hassubs	int
)	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_subdbs	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
dbname	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_HASH	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
0	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
}	O
goto	O
err	pointer
;	O
default	O
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_freelist	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
)	O
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
if	O
(	O
ret	int
!=	O
0	int
||	O
isbad	int
==	O
1	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vdp	pointer
->	O
last_pgno	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
i	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
i	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
p	pointer
==	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unreferenced page %lu"	pointer
,	O
i	int
)	O
)	O
;	O
if	O
(	O
pip	pointer
->	O
type	enum
!=	O
P_LRECNO	int
&&	O
pip	pointer
->	O
type	enum
!=	O
P_LDUP	int
)	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_IS_ALLZEROES	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Totally zeroed page %lu"	pointer
,	O
i	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
pip	pointer
=	O
NULL	O
;	O
}	O
err	pointer
:	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
;	O
return	O
(	O
(	O
isbad	int
==	O
1	int
&&	O
ret	int
==	O
0	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_is_valid_pagetype	function
(	O
type	enum
)	O
u_int32_t	int
type	enum
;	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
P_INVALID	int
:	O
case	O
P_HASH	int
:	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
case	O
P_LBTREE	int
:	O
case	O
P_LRECNO	int
:	O
case	O
P_OVERFLOW	int
:	O
case	O
P_HASHMETA	int
:	O
case	O
P_BTREEMETA	int
:	O
case	O
P_QAMMETA	int
:	O
case	O
P_QAMDATA	int
:	O
case	O
P_LDUP	int
:	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_is_valid_magicno	function
(	O
magic	int
,	O
typep	pointer
)	O
u_int32_t	int
magic	int
;	O
DBTYPE	enum
*	O
typep	pointer
;	O
{	O
switch	O
(	O
magic	int
)	O
{	O
case	O
DB_BTREEMAGIC	int
:	O
*	O
typep	pointer
=	O
DB_BTREE	int
;	O
return	O
(	O
1	int
)	O
;	O
case	O
DB_HASHMAGIC	int
:	O
*	O
typep	pointer
=	O
DB_HASH	int
;	O
return	O
(	O
1	int
)	O
;	O
case	O
DB_QAMMAGIC	int
:	O
*	O
typep	pointer
=	O
DB_QUEUE	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
typep	pointer
=	O
DB_UNKNOWN	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_common	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
pip	pointer
->	O
pgno	int
=	O
pgno	int
;	O
F_CLR	O
(	O
pip	pointer
,	O
VRFY_IS_ALLZEROES	int
)	O
;	O
if	O
(	O
pgno	int
!=	O
0	int
&&	O
PGNO	O
(	O
h	pointer
)	O
==	O
0	int
)	O
{	O
for	O
(	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
;	O
p	pointer
<	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
dbp	pointer
->	O
pgsize	int
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash page %lu should be zeroed and is not"	pointer
,	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
pip	pointer
->	O
type	enum
=	O
P_HASH	int
;	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_IS_ALLZEROES	int
)	O
;	O
ret	int
=	O
0	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
PGNO	O
(	O
h	pointer
)	O
!=	O
pgno	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad page number: %lu should be %lu"	pointer
,	O
h	pointer
->	O
pgno	int
,	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
if	O
(	O
!	O
__db_is_valid_pagetype	function
(	O
h	pointer
->	O
type	enum
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad page type: %lu"	pointer
,	O
h	pointer
->	O
type	enum
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
pip	pointer
->	O
type	enum
=	O
h	pointer
->	O
type	enum
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_invalid	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
pip	pointer
->	O
next_pgno	int
=	O
pip	pointer
->	O
prev_pgno	int
=	O
0	int
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
NEXT_PGNO	O
(	O
h	pointer
)	O
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Invalid next_pgno %lu on page %lu"	pointer
,	O
NEXT_PGNO	O
(	O
h	pointer
)	O
,	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
else	O
pip	pointer
->	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
h	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_vrfy_datapage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
isbad	int
,	O
ret	int
,	O
t_ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_IBTREE	int
&&	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_IRECNO	int
)	O
{	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
PREV_PGNO	O
(	O
h	pointer
)	O
)	O
||	O
PREV_PGNO	O
(	O
h	pointer
)	O
==	O
pip	pointer
->	O
pgno	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu: Invalid prev_pgno %lu"	pointer
,	O
pip	pointer
->	O
pgno	int
,	O
PREV_PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
NEXT_PGNO	O
(	O
h	pointer
)	O
)	O
||	O
NEXT_PGNO	O
(	O
h	pointer
)	O
==	O
pip	pointer
->	O
pgno	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu: Invalid next_pgno %lu"	pointer
,	O
pip	pointer
->	O
pgno	int
,	O
NEXT_PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
}	O
pip	pointer
->	O
prev_pgno	int
=	O
PREV_PGNO	O
(	O
h	pointer
)	O
;	O
pip	pointer
->	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
h	pointer
)	O
;	O
}	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_OVERFLOW	int
)	O
{	O
if	O
(	O
BKEYDATA_PSIZE	O
(	O
0	int
)	O
*	O
NUM_ENT	O
(	O
h	pointer
)	O
>	O
dbp	pointer
->	O
pgsize	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu: Too many entries: %lu"	pointer
,	O
pgno	int
,	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
)	O
;	O
}	O
pip	pointer
->	O
entries	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
}	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
{	O
pip	pointer
->	O
bt_level	char
=	O
LEVEL	O
(	O
h	pointer
)	O
;	O
break	O
;	O
}	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
if	O
(	O
LEVEL	O
(	O
h	pointer
)	O
!=	O
LEAFLEVEL	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Btree leaf page %lu has incorrect level %lu"	pointer
,	O
pgno	int
,	O
LEVEL	O
(	O
h	pointer
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
LEVEL	O
(	O
h	pointer
)	O
!=	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Nonzero level %lu in non-btree database page %lu"	pointer
,	O
LEVEL	O
(	O
h	pointer
)	O
,	O
pgno	int
)	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
DBMETA	struct
*	O
meta	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DBTYPE	enum
dbtype	enum
,	O
magtype	enum
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
isbad	int
,	O
ret	int
,	O
t_ret	int
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
meta	pointer
->	O
type	enum
)	O
{	O
case	O
P_BTREEMETA	int
:	O
dbtype	enum
=	O
DB_BTREE	int
;	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
dbtype	enum
=	O
DB_HASH	int
;	O
break	O
;	O
case	O
P_QAMMETA	int
:	O
dbtype	enum
=	O
DB_QUEUE	int
;	O
break	O
;	O
default	O
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
__db_is_valid_magicno	function
(	O
meta	pointer
->	O
magic	int
,	O
&	O
magtype	enum
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Magic number invalid on page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
magtype	enum
!=	O
dbtype	enum
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Magic number does not match type of page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
dbtype	enum
==	O
DB_BTREE	int
&&	O
meta	pointer
->	O
version	int
!=	O
DB_BTREEVERSION	int
)	O
||	O
(	O
dbtype	enum
==	O
DB_HASH	int
&&	O
meta	pointer
->	O
version	int
!=	O
DB_HASHVERSION	int
)	O
||	O
(	O
dbtype	enum
==	O
DB_QUEUE	int
&&	O
meta	pointer
->	O
version	int
!=	O
DB_QAMVERSION	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s%s"	pointer
,	O
"Old of incorrect DB "	pointer
,	O
"version; extraneous errors may result"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
meta	pointer
->	O
pagesize	long
!=	O
dbp	pointer
->	O
pgsize	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Invalid pagesize %lu on page %lu"	pointer
,	O
meta	pointer
->	O
pagesize	long
,	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
meta	pointer
->	O
free	int
!=	O
PGNO_INVALID	int
&&	O
IS_VALID_PGNO	O
(	O
meta	pointer
->	O
free	int
)	O
)	O
pip	pointer
->	O
free	int
=	O
meta	pointer
->	O
free	int
;	O
else	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
meta	pointer
->	O
free	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Nonsensical free list pgno %lu on page %lu"	pointer
,	O
meta	pointer
->	O
free	int
,	O
pgno	int
)	O
)	O
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_freelist	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
meta	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
pgset	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
p	pointer
,	O
ret	int
,	O
t_ret	int
;	O
pgset	pointer
=	O
vdp	pointer
->	O
pgset	pointer
;	O
DB_ASSERT	O
(	O
pgset	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
meta	pointer
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
pgno	int
=	O
pip	pointer
->	O
free	int
;	O
pgno	int
!=	O
PGNO_INVALID	int
;	O
pgno	int
=	O
pip	pointer
->	O
next_pgno	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
pgno	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Invalid next_pgno on free list page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu encountered a second time on free list"	pointer
,	O
pgno	int
)	O
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
pip	pointer
->	O
type	enum
!=	O
P_INVALID	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Non-invalid page %lu on free list"	pointer
,	O
pgno	int
,	O
pip	pointer
->	O
type	enum
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_subdbs	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
dbname	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
char	O
*	O
dbname	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
mdbp	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
key	struct
,	O
data	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_pgno_t	int
meta_pgno	int
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
u_int8_t	char
type	enum
;	O
isbad	int
=	O
0	int
;	O
dbc	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_master_open	function
(	O
dbp	pointer
,	O
dbname	pointer
,	O
DB_RDONLY	int
,	O
0	int
,	O
&	O
mdbp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_icursor	function
(	O
mdbp	pointer
,	O
NULL	O
,	O
DB_BTREE	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
&	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memset	function
(	O
&	O
key	struct
,	O
0	int
,	O
sizeof	O
(	O
key	struct
)	O
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_get	pointer
(	O
dbc	pointer
,	O
&	O
key	struct
,	O
&	O
data	pointer
,	O
DB_NEXT	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
data	pointer
.	O
size	int
!=	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database entry of invalid size"	pointer
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
memcpy	function
(	O
&	O
meta_pgno	int
,	O
data	pointer
.	O
data	pointer
,	O
data	pointer
.	O
size	int
)	O
;	O
DB_NTOHL	O
(	O
&	O
meta_pgno	int
)	O
;	O
if	O
(	O
meta_pgno	int
==	O
PGNO_INVALID	int
||	O
meta_pgno	int
>	O
vdp	pointer
->	O
last_pgno	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database entry references invalid page %lu"	pointer
,	O
meta_pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
meta_pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
type	enum
=	O
pip	pointer
->	O
type	enum
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
P_BTREEMETA	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
P_QAMMETA	int
:	O
default	O
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database entry references page %lu of invalid type %lu"	pointer
,	O
meta_pgno	int
,	O
type	enum
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
ret	int
==	O
DB_NOTFOUND	O
)	O
ret	int
=	O
0	int
;	O
err	pointer
:	O
if	O
(	O
dbc	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB___db_c_close	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
mdbp	pointer
->	O
close	pointer
(	O
mdbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_vrfy_orderchkonly	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
subdb	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
BTMETA	struct
*	O
btmeta	pointer
;	O
DB	struct
*	O
mdbp	pointer
,	O
*	O
pgset	pointer
;	O
DBC	struct
*	O
pgsc	pointer
;	O
DBT	struct
key	struct
,	O
data	pointer
;	O
HASH	struct
*	O
h_internal	pointer
;	O
HMETA	struct
*	O
hmeta	pointer
;	O
PAGE	struct
*	O
h	pointer
,	O
*	O
currpg	pointer
;	O
db_pgno_t	int
meta_pgno	int
,	O
p	pointer
,	O
pgno	int
;	O
u_int32_t	int
bucket	int
;	O
int	O
t_ret	int
,	O
ret	int
;	O
currpg	pointer
=	O
h	pointer
=	O
NULL	O
;	O
pgsc	pointer
=	O
NULL	O
;	O
pgset	pointer
=	O
NULL	O
;	O
LF_CLR	O
(	O
DB_NOORDERCHK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_db_create	function
(	O
&	O
mdbp	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_master_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
DB_RDONLY	int
,	O
0	int
,	O
&	O
mdbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memset	function
(	O
&	O
key	struct
,	O
0	int
,	O
sizeof	O
(	O
key	struct
)	O
)	O
;	O
key	struct
.	O
data	pointer
=	O
(	O
void	O
*	O
)	O
subdb	pointer
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
get	pointer
(	O
dbp	pointer
,	O
NULL	O
,	O
&	O
key	struct
,	O
&	O
data	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
data	pointer
.	O
size	int
!=	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database entry of invalid size"	pointer
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
memcpy	function
(	O
&	O
meta_pgno	int
,	O
data	pointer
.	O
data	pointer
,	O
data	pointer
.	O
size	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
meta_pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
&	O
pgset	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_BTREEMETA	int
:	O
btmeta	pointer
=	O
(	O
BTMETA	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
btmeta	pointer
->	O
dbmeta	struct
,	O
BTM_RECNO	int
)	O
)	O
{	O
ret	int
=	O
0	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
,	O
pgset	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
pgset	pointer
->	O
cursor	pointer
(	O
pgset	pointer
,	O
NULL	O
,	O
&	O
pgsc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
while	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_next	function
(	O
pgsc	pointer
,	O
&	O
p	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
p	pointer
,	O
0	int
,	O
&	O
currpg	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_itemorder	function
(	O
dbp	pointer
,	O
NULL	O
,	O
currpg	pointer
,	O
p	pointer
,	O
NUM_ENT	O
(	O
currpg	pointer
)	O
,	O
1	int
,	O
F_ISSET	O
(	O
&	O
btmeta	pointer
->	O
dbmeta	struct
,	O
BTM_DUP	int
)	O
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
currpg	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
currpg	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
pgsc	pointer
->	O
c_close	pointer
(	O
pgsc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
hmeta	pointer
=	O
(	O
HMETA	struct
*	O
)	O
h	pointer
;	O
h_internal	pointer
=	O
(	O
HASH	struct
*	O
)	O
dbp	pointer
->	O
h_internal	pointer
;	O
if	O
(	O
h_internal	pointer
==	O
NULL	O
||	O
h_internal	pointer
->	O
h_hash	pointer
==	O
NULL	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB_ORDERCHKONLY requires that a hash function be set"	pointer
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
hmeta	pointer
->	O
h_charkey	int
!=	O
h_internal	pointer
->	O
h_hash	pointer
(	O
CHARKEY	pointer
,	O
sizeof	O
(	O
CHARKEY	pointer
)	O
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Incorrect hash function for database"	pointer
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
for	O
(	O
bucket	int
=	O
0	int
;	O
bucket	int
<=	O
hmeta	pointer
->	O
max_bucket	int
;	O
bucket	int
++	O
)	O
{	O
pgno	int
=	O
hmeta	pointer
->	O
spares	array
[	O
CDB___db_log2	function
(	O
bucket	int
+	O
1	int
)	O
]	O
;	O
while	O
(	O
pgno	int
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
currpg	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_vrfy_hashing	function
(	O
dbp	pointer
,	O
NUM_ENT	O
(	O
currpg	pointer
)	O
,	O
hmeta	pointer
,	O
bucket	int
,	O
pgno	int
,	O
flags	int
,	O
h_internal	pointer
->	O
h_hash	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
pgno	int
=	O
NEXT_PGNO	O
(	O
currpg	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
currpg	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
currpg	pointer
=	O
NULL	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database meta page %lu of bad type %lu"	pointer
,	O
meta_pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
}	O
err	pointer
:	O
if	O
(	O
pgsc	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
pgsc	pointer
->	O
c_close	pointer
(	O
pgsc	pointer
)	O
;	O
if	O
(	O
pgset	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
pgset	pointer
->	O
close	pointer
(	O
pgset	pointer
,	O
0	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
currpg	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
currpg	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
mdbp	pointer
->	O
close	pointer
(	O
mdbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
PAGE	struct
*	O
h	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ASSERT	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
)	O
;	O
if	O
(	O
CDB___db_salvage_isdone	function
(	O
vdp	pointer
,	O
pgno	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_HASH	int
:	O
return	O
(	O
CDB___ham_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
;	O
case	O
P_LBTREE	int
:	O
return	O
(	O
CDB___bam_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
P_LBTREE	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
NULL	O
,	O
flags	int
)	O
)	O
;	O
case	O
P_LDUP	int
:	O
return	O
(	O
CDB___db_salvage_markneeded	function
(	O
vdp	pointer
,	O
pgno	int
,	O
SALVAGE_LDUP	int
)	O
)	O
;	O
case	O
P_OVERFLOW	int
:	O
return	O
(	O
CDB___db_salvage_markneeded	function
(	O
vdp	pointer
,	O
pgno	int
,	O
SALVAGE_OVERFLOW	int
)	O
)	O
;	O
case	O
P_LRECNO	int
:	O
return	O
(	O
CDB___db_salvage_markneeded	function
(	O
vdp	pointer
,	O
pgno	int
,	O
SALVAGE_LRECNO	int
)	O
)	O
;	O
case	O
P_IBTREE	int
:	O
case	O
P_INVALID	int
:	O
case	O
P_IRECNO	int
:	O
case	O
__P_DUPLICATE	int
:	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_salvage_unknowns	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
unkdbt	struct
,	O
key	struct
,	O
*	O
dbt	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
pgtype	int
;	O
int	O
ret	int
,	O
err_ret	int
;	O
void	O
*	O
ovflbuf	pointer
;	O
memset	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
unkdbt	struct
.	O
size	int
=	O
strlen	function
(	O
"UNKNOWN"	pointer
)	O
+	O
1	int
;	O
unkdbt	struct
.	O
data	pointer
=	O
"UNKNOWN"	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
0	int
,	O
&	O
ovflbuf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
err_ret	int
=	O
0	int
;	O
while	O
(	O
(	O
ret	int
=	O
CDB___db_salvage_getnext	function
(	O
vdp	pointer
,	O
&	O
pgno	int
,	O
&	O
pgtype	int
)	O
)	O
==	O
0	int
)	O
{	O
dbt	struct
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
switch	O
(	O
pgtype	int
)	O
{	O
case	O
SALVAGE_LDUP	int
:	O
case	O
SALVAGE_LRECNODUP	int
:	O
dbt	struct
=	O
&	O
unkdbt	struct
;	O
case	O
SALVAGE_LBTREE	int
:	O
case	O
SALVAGE_LRECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
pgtype	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
dbt	struct
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
SALVAGE_OVERFLOW	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_safe_goff	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
&	O
key	struct
,	O
&	O
ovflbuf	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
key	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
SALVAGE_HASH	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
SALVAGE_INVALID	int
:	O
case	O
SALVAGE_IGNORE	int
:	O
default	O
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
}	O
CDB___os_free	function
(	O
ovflbuf	pointer
,	O
0	int
)	O
;	O
if	O
(	O
err_ret	int
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
err_ret	int
;	O
return	O
(	O
ret	int
==	O
DB_NOTFOUND	O
?	O
0	int
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_vrfy_inpitem	function
(	O
dbp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
i	int
,	O
is_btree	int
,	O
flags	int
,	O
himarkp	pointer
,	O
offsetp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
i	int
;	O
int	O
is_btree	int
;	O
u_int32_t	int
flags	int
,	O
*	O
himarkp	pointer
,	O
*	O
offsetp	pointer
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
db_indx_t	short
offset	int
,	O
len	short
;	O
DB_ASSERT	O
(	O
himarkp	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
->	O
inp	array
+	O
i	int
>=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
*	O
himarkp	pointer
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu entries listing %lu overlaps data"	pointer
,	O
pgno	int
,	O
i	int
)	O
)	O
;	O
return	O
(	O
DB_VERIFY_FATAL	O
)	O
;	O
}	O
offset	int
=	O
h	pointer
->	O
inp	array
[	O
i	int
]	O
;	O
if	O
(	O
offset	int
<=	O
INP_OFFSET	O
(	O
h	pointer
,	O
i	int
)	O
||	O
offset	int
>	O
dbp	pointer
->	O
pgsize	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad offset %lu at page %lu index %lu"	pointer
,	O
offset	int
,	O
pgno	int
,	O
i	int
)	O
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
if	O
(	O
offset	int
<	O
*	O
himarkp	pointer
)	O
*	O
himarkp	pointer
=	O
offset	int
;	O
if	O
(	O
is_btree	int
)	O
{	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	int
)	O
;	O
len	short
=	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_KEYDATA	int
?	O
bk	pointer
->	O
len	short
:	O
BOVERFLOW_SIZE	O
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
offset	int
+	O
len	short
)	O
>	O
dbp	pointer
->	O
pgsize	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %lu on page %lu extends past page boundary"	pointer
,	O
i	int
,	O
pgno	int
)	O
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
}	O
if	O
(	O
offsetp	pointer
!=	O
NULL	O
)	O
*	O
offsetp	pointer
=	O
offset	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_vrfy_duptype	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
ret	int
,	O
isbad	int
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
pip	pointer
->	O
type	enum
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_LDUP	int
:	O
if	O
(	O
!	O
LF_ISSET	O
(	O
ST_DUPSORT	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Sorted duplicate set at page %lu in unsorted-dup database"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
P_IRECNO	int
:	O
case	O
P_LRECNO	int
:	O
if	O
(	O
LF_ISSET	O
(	O
ST_DUPSORT	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unsorted duplicate set at page %lu in sorted-dup database"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
break	O
;	O
default	O
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate page %lu of inappropriate type %lu"	pointer
,	O
pgno	int
,	O
pip	pointer
->	O
type	enum
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
isbad	int
==	O
1	int
?	O
DB_VERIFY_BAD	O
:	O
0	int
)	O
;	O
}	O
int	O
CDB___db_salvage_duptree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
key	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
DBT	struct
*	O
key	struct
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
PAGE	struct
*	O
h	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
if	O
(	O
pgno	int
==	O
PGNO_INVALID	int
||	O
!	O
IS_VALID_PGNO	O
(	O
pgno	int
)	O
)	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_common	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
|	O
DB_NOORDERCHK	int
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___db_salvage_markdone	function
(	O
vdp	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_salvage_walkdupint	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
key	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
P_LRECNO	int
:	O
case	O
P_LDUP	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
key	struct
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_salvage_subdbs	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
,	O
hassubsp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
int	O
*	O
hassubsp	pointer
;	O
{	O
BTMETA	struct
*	O
btmeta	pointer
;	O
DB	struct
*	O
pgset	pointer
;	O
DBC	struct
*	O
pgsc	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
p	pointer
,	O
meta_pgno	int
;	O
int	O
ret	int
,	O
err_ret	int
;	O
err_ret	int
=	O
0	int
;	O
pgsc	pointer
=	O
NULL	O
;	O
pgset	pointer
=	O
NULL	O
;	O
meta_pgno	int
=	O
PGNO_BASE_MD	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
meta_pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_BTREEMETA	int
)	O
btmeta	pointer
=	O
(	O
BTMETA	struct
*	O
)	O
h	pointer
;	O
else	O
{	O
ret	int
=	O
0	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_common	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
PGNO_BASE_MD	int
,	O
flags	int
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___bam_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
btmeta	pointer
,	O
PGNO_BASE_MD	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
&	O
btmeta	pointer
->	O
dbmeta	struct
,	O
BTM_SUBDB	int
)	O
)	O
{	O
ret	int
=	O
0	int
;	O
goto	O
err	pointer
;	O
}	O
*	O
hassubsp	pointer
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
&	O
pgset	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
PGNO_BASE_MD	int
,	O
flags	int
,	O
pgset	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
pgset	pointer
->	O
cursor	pointer
(	O
pgset	pointer
,	O
NULL	O
,	O
&	O
pgsc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
while	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_next	function
(	O
pgsc	pointer
,	O
&	O
p	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
p	pointer
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_common	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
p	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___bam_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
p	pointer
,	O
flags	int
|	O
DB_NOORDERCHK	int
)	O
)	O
!=	O
0	int
)	O
goto	O
nextpg	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_LBTREE	int
)	O
goto	O
nextpg	O
;	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_salvage_subdbpg	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
nextpg	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
}	O
if	O
(	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
pgsc	pointer
->	O
c_close	pointer
(	O
pgsc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ret	int
=	O
pgset	pointer
->	O
close	pointer
(	O
pgset	pointer
,	O
0	int
)	O
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
err_ret	int
!=	O
0	int
)	O
?	O
err_ret	int
:	O
ret	int
)	O
;	O
err	pointer
:	O
if	O
(	O
pgsc	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
pgsc	pointer
->	O
c_close	pointer
(	O
pgsc	pointer
)	O
;	O
if	O
(	O
pgset	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
pgset	pointer
->	O
close	pointer
(	O
pgset	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_salvage_subdbpg	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
master	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
master	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
BKEYDATA	struct
*	O
bkkey	pointer
,	O
*	O
bkdata	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
DB	struct
*	O
pgset	pointer
;	O
DBC	struct
*	O
pgsc	pointer
;	O
DBT	struct
key	struct
;	O
PAGE	struct
*	O
subpg	pointer
;	O
db_indx_t	short
i	int
;	O
db_pgno_t	int
meta_pgno	int
,	O
p	pointer
;	O
int	O
ret	int
,	O
err_ret	int
,	O
t_ret	int
;	O
char	O
*	O
subdbname	pointer
;	O
ret	int
=	O
err_ret	int
=	O
0	int
;	O
subdbname	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
&	O
pgset	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_ENT	O
(	O
master	pointer
)	O
;	O
i	int
+=	O
P_INDX	int
)	O
{	O
bkkey	pointer
=	O
GET_BKEYDATA	O
(	O
master	pointer
,	O
i	int
)	O
;	O
bkdata	pointer
=	O
GET_BKEYDATA	O
(	O
master	pointer
,	O
i	int
+	O
O_INDX	int
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bkkey	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
{	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bkkey	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_safe_goff	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
bo	pointer
->	O
pgno	int
,	O
&	O
key	struct
,	O
(	O
void	O
*	O
*	O
)	O
&	O
subdbname	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
key	struct
.	O
size	int
+	O
1	int
,	O
NULL	O
,	O
&	O
subdbname	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
subdbname	pointer
[	O
key	struct
.	O
size	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
B_TYPE	O
(	O
bkkey	pointer
->	O
type	enum
==	O
B_KEYDATA	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
bkkey	pointer
->	O
len	short
+	O
1	int
,	O
NULL	O
,	O
&	O
subdbname	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
subdbname	pointer
,	O
bkkey	pointer
->	O
data	pointer
,	O
bkkey	pointer
->	O
len	short
)	O
;	O
subdbname	pointer
[	O
bkkey	pointer
->	O
len	short
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
bkdata	pointer
->	O
len	short
!=	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
{	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
continue	O
;	O
}	O
memcpy	function
(	O
&	O
meta_pgno	int
,	O
bkdata	pointer
->	O
data	pointer
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
meta_pgno	int
)	O
||	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
meta_pgno	int
,	O
0	int
,	O
&	O
subpg	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_vrfy_common	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
subpg	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
subpg	pointer
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
switch	O
(	O
TYPE	O
(	O
subpg	pointer
)	O
)	O
{	O
case	O
P_BTREEMETA	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
BTMETA	struct
*	O
)	O
subpg	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
subpg	pointer
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
HMETA	struct
*	O
)	O
subpg	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
subpg	pointer
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
default	O
:	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
subpg	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prheader	function
(	O
dbp	pointer
,	O
subdbname	pointer
,	O
0	int
,	O
0	int
,	O
handle	pointer
,	O
callback	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__db_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
,	O
pgset	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
pgset	pointer
->	O
cursor	pointer
(	O
pgset	pointer
,	O
NULL	O
,	O
&	O
pgsc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
while	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_next	function
(	O
pgsc	pointer
,	O
&	O
p	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
p	pointer
,	O
0	int
,	O
&	O
subpg	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
p	pointer
,	O
subpg	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
subpg	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
}	O
if	O
(	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
pgsc	pointer
->	O
c_close	pointer
(	O
pgsc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prfooter	function
(	O
handle	pointer
,	O
callback	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
subdbname	pointer
)	O
CDB___os_free	function
(	O
subdbname	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
pgset	pointer
->	O
close	pointer
(	O
pgset	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_salvage_markdone	function
(	O
vdp	pointer
,	O
PGNO	O
(	O
master	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
return	O
(	O
(	O
err_ret	int
!=	O
0	int
)	O
?	O
err_ret	int
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
flags	int
,	O
pgset	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
DB	struct
*	O
pgset	pointer
;	O
{	O
PAGE	struct
*	O
h	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_BTREEMETA	int
:	O
ret	int
=	O
CDB___bam_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
BTMETA	struct
*	O
)	O
h	pointer
,	O
flags	int
,	O
pgset	pointer
)	O
;	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
ret	int
=	O
CDB___ham_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
(	O
HMETA	struct
*	O
)	O
h	pointer
,	O
flags	int
,	O
pgset	pointer
)	O
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_guesspgsize	function
(	O
dbenv	pointer
,	O
fhp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
{	O
db_pgno_t	int
i	int
;	O
size_t	long
nr	int
;	O
u_int32_t	int
guess	int
;	O
u_int8_t	char
type	enum
;	O
int	O
ret	int
;	O
for	O
(	O
guess	int
=	O
DB_MAX_PGSIZE	int
;	O
guess	int
>=	O
DB_MIN_PGSIZE	int
;	O
guess	int
>>=	O
1	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
3	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
guess	int
,	O
i	int
,	O
SSZ8	O
(	O
DBMETA	struct
,	O
type	enum
)	O
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
&	O
type	enum
,	O
1	int
,	O
&	O
nr	int
)	O
)	O
!=	O
0	int
||	O
nr	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
type	enum
==	O
P_INVALID	int
||	O
type	enum
>=	O
P_PAGETYPE_MAX	int
)	O
break	O
;	O
}	O
}	O
return	O
(	O
guess	int
)	O
;	O
}	O
