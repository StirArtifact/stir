static	O
char	O
*	O
skipws	function
(	O
char	O
*	O
p	pointer
)	O
{	O
while	O
(	O
*	O
p	pointer
&&	O
ISWS	O
(	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
return	O
p	pointer
;	O
}	O
static	O
char	O
*	O
eow	function
(	O
char	O
*	O
p	pointer
)	O
{	O
while	O
(	O
*	O
p	pointer
&&	O
!	O
ISWS	O
(	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
parsegid	function
(	O
char	O
*	O
val	array
,	O
gid_t	int
*	O
pgid	pointer
)	O
{	O
struct	O
group	struct
*	O
grp	pointer
;	O
if	O
(	O
isdigit	function
(	O
val	array
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
n	long
=	O
strtoul	function
(	O
val	array
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
*	O
pgid	pointer
=	O
n	long
;	O
return	O
0	int
;	O
}	O
}	O
grp	pointer
=	O
getgrnam	function
(	O
val	array
)	O
;	O
if	O
(	O
!	O
grp	pointer
)	O
return	O
1	int
;	O
*	O
pgid	pointer
=	O
grp	pointer
->	O
gr_gid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parseuid	function
(	O
char	O
*	O
val	array
,	O
uid_t	int
*	O
puid	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
if	O
(	O
isdigit	function
(	O
val	array
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
n	long
=	O
strtoul	function
(	O
val	array
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
*	O
puid	pointer
=	O
n	long
;	O
return	O
0	int
;	O
}	O
}	O
pwd	pointer
=	O
getpwnam	function
(	O
val	array
)	O
;	O
if	O
(	O
!	O
pwd	pointer
)	O
return	O
1	int
;	O
*	O
puid	pointer
=	O
pwd	pointer
->	O
pw_uid	int
;	O
return	O
0	int
;	O
}	O
struct	O
input_buf	struct
{	O
CFSTREAM	struct
*	O
cf	pointer
;	O
struct	O
cfloc	struct
loc	pointer
;	O
struct	O
input_buf	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
input_buf	struct
*	O
input_buf_ptr	pointer
;	O
void	O
init_input_buf	function
(	O
input_buf_ptr	pointer
*	O
ibufptr	pointer
,	O
input_buf_ptr	pointer
next	pointer
,	O
CFSTREAM	struct
*	O
cf	pointer
,	O
char	O
const	O
*	O
filename	pointer
,	O
int	O
line	int
)	O
{	O
input_buf_ptr	pointer
ibuf	pointer
;	O
ibuf	pointer
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
ibuf	pointer
)	O
)	O
;	O
ibuf	pointer
->	O
cf	pointer
=	O
cf	pointer
;	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
line	int
=	O
line	int
;	O
ibuf	pointer
->	O
next	pointer
=	O
next	pointer
;	O
*	O
ibufptr	pointer
=	O
ibuf	pointer
;	O
}	O
void	O
free_input_buf	function
(	O
input_buf_ptr	pointer
*	O
ibufptr	pointer
)	O
{	O
if	O
(	O
ibufptr	pointer
&&	O
*	O
ibufptr	pointer
)	O
{	O
input_buf_ptr	pointer
ibuf	pointer
=	O
*	O
ibufptr	pointer
;	O
cfstream_close	function
(	O
ibuf	pointer
->	O
cf	pointer
)	O
;	O
free	function
(	O
ibuf	pointer
)	O
;	O
*	O
ibufptr	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
char	O
*	O
read_line_plain	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
psize	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
size_t	long
len	long
=	O
0	int
;	O
int	O
c	int
;	O
while	O
(	O
1	int
)	O
{	O
c	int
=	O
cfstream_getc	function
(	O
ibuf	pointer
->	O
cf	pointer
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
len	long
==	O
size	long
)	O
buf	pointer
=	O
x2realloc	function
(	O
buf	pointer
,	O
&	O
size	long
)	O
;	O
buf	pointer
[	O
len	long
]	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
line	int
++	O
;	O
if	O
(	O
len	long
>	O
0	int
&&	O
buf	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
len	long
--	O
;	O
}	O
else	O
break	O
;	O
}	O
else	O
len	long
++	O
;	O
}	O
if	O
(	O
buf	pointer
)	O
{	O
if	O
(	O
len	long
==	O
size	long
)	O
buf	pointer
=	O
x2realloc	function
(	O
buf	pointer
,	O
&	O
size	long
)	O
;	O
buf	pointer
[	O
len	long
]	O
=	O
0	int
;	O
}	O
*	O
pbuf	pointer
=	O
buf	pointer
;	O
*	O
psize	pointer
=	O
len	long
;	O
return	O
buf	pointer
;	O
}	O
static	O
char	O
*	O
read_line	function
(	O
input_buf_ptr	pointer
*	O
ibufptr	pointer
,	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
psize	pointer
)	O
{	O
do	O
{	O
char	O
*	O
p	pointer
=	O
read_line_plain	function
(	O
*	O
ibufptr	pointer
,	O
pbuf	pointer
,	O
psize	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
return	O
p	pointer
;	O
else	O
{	O
input_buf_ptr	pointer
next	pointer
=	O
(	O
*	O
ibufptr	pointer
)	O
->	O
next	pointer
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Finished parsing %s"	pointer
)	O
,	O
(	O
*	O
ibufptr	pointer
)	O
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
)	O
;	O
free_input_buf	function
(	O
ibufptr	pointer
)	O
;	O
*	O
ibufptr	pointer
=	O
next	pointer
;	O
if	O
(	O
next	pointer
)	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Resuming parsing %s from line %d"	pointer
)	O
,	O
next	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
,	O
next	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
line	int
)	O
;	O
}	O
}	O
while	O
(	O
*	O
ibufptr	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
unquote_char	function
(	O
int	O
c	int
)	O
{	O
char	O
*	O
p	pointer
;	O
static	O
char	O
quotetab	array
[	O
]	O
=	O
"\\\\a\ab\bf\fn\nr\rt\t"	pointer
;	O
for	O
(	O
p	pointer
=	O
quotetab	array
;	O
*	O
p	pointer
;	O
p	pointer
+=	O
2	int
)	O
if	O
(	O
*	O
p	pointer
==	O
c	int
)	O
return	O
p	pointer
[	O
1	int
]	O
;	O
return	O
c	int
;	O
}	O
static	O
char	O
*	O
copy_string	function
(	O
const	O
char	O
*	O
src	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
src	pointer
)	O
;	O
char	O
*	O
dest	pointer
;	O
int	O
add_nl	int
=	O
len	long
>	O
0	int
&&	O
src	pointer
[	O
len	long
-	O
1	int
]	O
!=	O
'\n'	O
;	O
dest	pointer
=	O
xmalloc	function
(	O
len	long
+	O
(	O
add_nl	int
?	O
1	int
:	O
0	int
)	O
+	O
1	int
)	O
;	O
for	O
(	O
p	pointer
=	O
dest	pointer
;	O
*	O
src	pointer
;	O
)	O
{	O
char	O
c	int
=	O
*	O
src	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
&&	O
*	O
src	pointer
)	O
c	int
=	O
unquote_char	function
(	O
*	O
src	pointer
++	O
)	O
;	O
*	O
p	pointer
++	O
=	O
c	int
;	O
}	O
if	O
(	O
add_nl	int
)	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
*	O
p	pointer
=	O
0	int
;	O
return	O
dest	pointer
;	O
}	O
int	O
parse_cmp_op	function
(	O
enum	O
cmp_op	enum
*	O
op	enum
,	O
char	O
*	O
*	O
pstr	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
*	O
pstr	pointer
;	O
if	O
(	O
*	O
str	pointer
==	O
'='	O
)	O
{	O
if	O
(	O
*	O
++	O
str	pointer
==	O
'='	O
)	O
str	pointer
++	O
;	O
*	O
op	enum
=	O
cmp_eq	int
;	O
}	O
else	O
if	O
(	O
*	O
str	pointer
==	O
'!'	O
)	O
{	O
if	O
(	O
*	O
++	O
str	pointer
==	O
'='	O
)	O
str	pointer
++	O
;	O
*	O
op	enum
=	O
cmp_ne	int
;	O
}	O
else	O
if	O
(	O
*	O
str	pointer
==	O
'>'	O
)	O
{	O
if	O
(	O
*	O
++	O
str	pointer
==	O
'='	O
)	O
{	O
str	pointer
++	O
;	O
*	O
op	enum
=	O
cmp_ge	int
;	O
}	O
else	O
*	O
op	enum
=	O
cmp_gt	int
;	O
}	O
else	O
if	O
(	O
*	O
str	pointer
==	O
'<'	O
)	O
{	O
if	O
(	O
*	O
++	O
str	pointer
==	O
'='	O
)	O
{	O
str	pointer
++	O
;	O
*	O
op	enum
=	O
cmp_le	int
;	O
}	O
else	O
*	O
op	enum
=	O
cmp_lt	int
;	O
}	O
else	O
if	O
(	O
c_isascii	function
(	O
*	O
str	pointer
)	O
&&	O
c_isdigit	function
(	O
*	O
str	pointer
)	O
)	O
*	O
op	enum
=	O
cmp_eq	int
;	O
else	O
return	O
1	int
;	O
str	pointer
=	O
skipws	function
(	O
str	pointer
)	O
;	O
*	O
pstr	pointer
=	O
str	pointer
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
_parse_negation	function
(	O
struct	O
test_node	struct
*	O
*	O
pnode	pointer
,	O
char	O
*	O
val	array
)	O
{	O
if	O
(	O
val	array
[	O
0	int
]	O
==	O
'!'	O
&&	O
val	array
[	O
1	int
]	O
!=	O
'='	O
)	O
{	O
struct	O
test_node	struct
*	O
neg	pointer
=	O
new_test_node	function
(	O
test_not	int
)	O
;	O
neg	pointer
->	O
v	union
.	O
arg	struct
[	O
0	int
]	O
=	O
*	O
pnode	pointer
;	O
*	O
pnode	pointer
=	O
neg	pointer
;	O
val	array
=	O
skipws	function
(	O
val	array
+	O
1	int
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
int	O
numstrtonum	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
char	O
*	O
val	array
,	O
struct	O
test_node	struct
*	O
node	pointer
)	O
{	O
char	O
*	O
q	pointer
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
=	O
strtoul	function
(	O
val	array
,	O
&	O
q	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	pointer
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"invalid number: %s"	pointer
)	O
,	O
val	array
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
parse_numtest	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
test_node	struct
*	O
numtest	pointer
,	O
char	O
*	O
val	array
,	O
int	O
(	O
*	O
valtonum	pointer
)	O
(	O
input_buf_ptr	pointer
,	O
char	O
*	O
,	O
struct	O
test_node	struct
*	O
)	O
)	O
{	O
if	O
(	O
parse_cmp_op	function
(	O
&	O
numtest	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
,	O
&	O
val	array
)	O
&&	O
val	array
[	O
strcspn	function
(	O
val	array
,	O
" \t"	pointer
)	O
]	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid opcode"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
valtonum	pointer
(	O
ibuf	pointer
,	O
val	array
,	O
numtest	pointer
)	O
;	O
}	O
struct	O
stmt_env	struct
{	O
char	O
*	O
kw	pointer
;	O
char	O
*	O
val	array
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
index	function
;	O
int	O
progmod	int
;	O
struct	O
test_node	struct
*	O
node	pointer
;	O
input_buf_ptr	pointer
ret_buf	pointer
;	O
}	O
;	O
void	O
regexp_error	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
regex_t	struct
*	O
regex	pointer
,	O
int	O
rc	int
)	O
{	O
char	O
errbuf	array
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	int
,	O
regex	pointer
,	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
)	O
;	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"invalid regexp: %s"	pointer
)	O
,	O
errbuf	array
)	O
;	O
}	O
static	O
int	O
_parse_re_flags	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
int	O
fc	int
=	O
env	pointer
->	O
argc	int
,	O
i	int
;	O
char	O
*	O
*	O
fv	pointer
=	O
env	pointer
->	O
argv	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fc	int
;	O
i	int
++	O
)	O
{	O
int	O
enable	int
,	O
flag	pointer
;	O
char	O
*	O
p	pointer
=	O
fv	pointer
[	O
i	int
]	O
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'+'	O
:	O
p	pointer
++	O
;	O
enable	int
=	O
1	int
;	O
break	O
;	O
case	O
'-'	O
:	O
p	pointer
++	O
;	O
enable	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
enable	int
=	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"extended"	pointer
)	O
==	O
0	int
)	O
flag	pointer
=	O
REG_EXTENDED	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"basic"	pointer
)	O
==	O
0	int
)	O
{	O
flag	pointer
=	O
REG_EXTENDED	int
;	O
enable	int
=	O
!	O
enable	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"icase"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
,	O
"ignore-case"	pointer
)	O
==	O
0	int
)	O
flag	pointer
=	O
REG_ICASE	O
;	O
else	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"unknown regexp flag: %s"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
enable	int
)	O
re_flags	int
|=	O
flag	pointer
;	O
else	O
re_flags	int
&=	O
~	O
flag	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_argc	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
,	O
int	O
min	int
,	O
int	O
max	int
)	O
{	O
if	O
(	O
env	pointer
->	O
argc	int
<	O
min	int
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"too few arguments"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
env	pointer
->	O
argc	int
>	O
max	int
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_command	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
test_node	struct
*	O
node	pointer
;	O
const	O
char	O
*	O
val	array
;	O
node	pointer
=	O
new_test_node	function
(	O
test_cmps	int
)	O
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
node	pointer
,	O
env	pointer
->	O
val	array
)	O
;	O
rc	int
=	O
regcomp	O
(	O
&	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
rx	struct
,	O
val	array
,	O
re_flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
regexp_error	function
(	O
ibuf	pointer
,	O
&	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
rx	struct
,	O
rc	int
)	O
;	O
else	O
{	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
=	O
cmp_match	int
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
"$command"	pointer
;	O
}	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_parse_match	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
test_node	struct
*	O
node	pointer
;	O
int	O
rc	int
;	O
const	O
char	O
*	O
val	array
;	O
node	pointer
=	O
new_test_node	function
(	O
test_cmps	int
)	O
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
node	pointer
,	O
env	pointer
->	O
val	array
)	O
;	O
rc	int
=	O
regcomp	O
(	O
&	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
rx	struct
,	O
val	array
,	O
re_flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
regexp_error	function
(	O
ibuf	pointer
,	O
&	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
rx	struct
,	O
rc	int
)	O
;	O
else	O
{	O
char	O
buf	pointer
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
char	O
*	O
p	pointer
=	O
umaxtostr	function
(	O
env	pointer
->	O
index	function
,	O
buf	pointer
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
p	pointer
)	O
+	O
4	int
)	O
;	O
strcpy	function
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
,	O
"${"	pointer
)	O
;	O
strcat	function
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
,	O
p	pointer
)	O
;	O
strcat	function
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
,	O
"}"	pointer
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
=	O
cmp_match	int
;	O
}	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_parse_argc	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
val	array
;	O
struct	O
test_node	struct
*	O
node	pointer
=	O
new_test_node	function
(	O
test_cmpn	int
)	O
;	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
env	pointer
->	O
node	pointer
,	O
env	pointer
->	O
val	array
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
"$#"	pointer
;	O
return	O
parse_numtest	function
(	O
ibuf	pointer
,	O
node	pointer
,	O
val	array
,	O
numstrtonum	function
)	O
;	O
}	O
static	O
int	O
uidtonum	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
char	O
*	O
str	pointer
,	O
struct	O
test_node	struct
*	O
node	pointer
)	O
{	O
uid_t	int
uid	int
;	O
if	O
(	O
parseuid	function
(	O
str	pointer
,	O
&	O
uid	int
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"no such user: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
1	int
;	O
}	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
=	O
uid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_uid	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
val	array
;	O
struct	O
test_node	struct
*	O
node	pointer
=	O
new_test_node	function
(	O
test_cmpn	int
)	O
;	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
env	pointer
->	O
node	pointer
,	O
env	pointer
->	O
val	array
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
"$uid"	pointer
;	O
return	O
parse_numtest	function
(	O
ibuf	pointer
,	O
node	pointer
,	O
val	array
,	O
uidtonum	function
)	O
;	O
}	O
static	O
int	O
gidtonum	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
char	O
*	O
str	pointer
,	O
struct	O
test_node	struct
*	O
node	pointer
)	O
{	O
gid_t	int
gid	int
;	O
if	O
(	O
parsegid	function
(	O
str	pointer
,	O
&	O
gid	int
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"no such group: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
1	int
;	O
}	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
=	O
gid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_gid	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
val	array
;	O
struct	O
test_node	struct
*	O
node	pointer
=	O
new_test_node	function
(	O
test_cmpn	int
)	O
;	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
env	pointer
->	O
node	pointer
,	O
env	pointer
->	O
val	array
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
"$gid"	pointer
;	O
return	O
parse_numtest	function
(	O
ibuf	pointer
,	O
node	pointer
,	O
val	array
,	O
gidtonum	function
)	O
;	O
}	O
static	O
int	O
_parse_user	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
val	array
;	O
struct	O
test_node	struct
*	O
node	pointer
;	O
if	O
(	O
env	pointer
->	O
argc	int
==	O
1	int
)	O
{	O
node	pointer
=	O
new_test_node	function
(	O
test_cmps	int
)	O
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
node	pointer
,	O
env	pointer
->	O
val	array
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
=	O
cmp_eq	int
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
"$user"	pointer
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
str	pointer
=	O
xstrdup	function
(	O
val	array
)	O
;	O
}	O
else	O
{	O
size_t	long
i	int
;	O
node	pointer
=	O
new_test_node	function
(	O
test_in	int
)	O
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
node	pointer
,	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
=	O
cmp_in	int
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
=	O
"$user"	pointer
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
=	O
xcalloc	function
(	O
env	pointer
->	O
argc	int
+	O
1	int
,	O
sizeof	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
[	O
0	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
[	O
0	int
]	O
=	O
xstrdup	function
(	O
val	array
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
env	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
[	O
i	int
]	O
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_group	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
val	array
;	O
struct	O
test_node	struct
*	O
node	pointer
;	O
size_t	long
i	int
;	O
node	pointer
=	O
new_test_node	function
(	O
test_group	int
)	O
;	O
val	array
=	O
_parse_negation	function
(	O
&	O
node	pointer
,	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
groups	pointer
=	O
xcalloc	function
(	O
env	pointer
->	O
argc	int
+	O
1	int
,	O
sizeof	O
node	pointer
->	O
v	union
.	O
groups	pointer
[	O
0	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
groups	pointer
[	O
0	int
]	O
=	O
xstrdup	function
(	O
val	array
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
env	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
node	pointer
->	O
v	union
.	O
groups	pointer
[	O
i	int
]	O
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
groups	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
env	pointer
->	O
node	pointer
=	O
node	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_umask	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
attrib_umask	function
(	O
rule	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_chroot	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
attrib_chroot	function
(	O
rule	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_limits	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
q	pointer
;	O
if	O
(	O
parse_limits	function
(	O
&	O
rule	pointer
->	O
limits	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
q	pointer
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"unknown limit: %s"	pointer
)	O
,	O
q	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
transform_node	struct
*	O
_parse_transform_common	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
;	O
char	O
*	O
expr	pointer
;	O
if	O
(	O
check_argc	function
(	O
ibuf	pointer
,	O
env	pointer
,	O
1	int
,	O
3	int
)	O
)	O
return	O
NULL	O
;	O
else	O
if	O
(	O
env	pointer
->	O
argc	int
==	O
3	int
&&	O
strcmp	function
(	O
env	pointer
->	O
argv	pointer
[	O
1	int
]	O
,	O
"~"	pointer
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"expected ~ as the second argument, but found %s"	pointer
)	O
,	O
env	pointer
->	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_set	int
)	O
;	O
switch	O
(	O
env	pointer
->	O
argc	int
)	O
{	O
case	O
1	int
:	O
expr	pointer
=	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
;	O
break	O
;	O
case	O
2	int
:	O
expr	pointer
=	O
env	pointer
->	O
argv	pointer
[	O
1	int
]	O
;	O
break	O
;	O
case	O
3	int
:	O
expr	pointer
=	O
env	pointer
->	O
argv	pointer
[	O
2	int
]	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
trans	pointer
=	O
compile_transform_expr	function
(	O
expr	pointer
,	O
re_flags	int
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
if	O
(	O
env	pointer
->	O
argc	int
>	O
1	int
)	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
else	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
=	O
NULL	O
;	O
return	O
node	pointer
;	O
}	O
static	O
int	O
_parse_transform	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
_parse_transform_common	function
(	O
ibuf	pointer
,	O
rule	pointer
,	O
env	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
return	O
1	int
;	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_command	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_transform_ar	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
_parse_transform_common	function
(	O
ibuf	pointer
,	O
rule	pointer
,	O
env	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
return	O
1	int
;	O
if	O
(	O
env	pointer
->	O
progmod	int
)	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_program	int
;	O
else	O
{	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_arg	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
ins	int
=	O
0	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
=	O
env	pointer
->	O
index	function
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_chdir	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
attrib_chdir	function
(	O
rule	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_env	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
size_t	long
i	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
rule	pointer
->	O
clrenv	int
=	O
1	int
;	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
i	int
<	O
env	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
name	pointer
=	O
env	pointer
->	O
argv	pointer
[	O
i	int
]	O
;	O
size_t	long
len	long
=	O
strcspn	function
(	O
name	pointer
,	O
"="	pointer
)	O
;	O
char	O
*	O
value	pointer
;	O
size_t	long
vlen	long
;	O
char	O
*	O
mem	pointer
=	O
NULL	O
;	O
size_t	long
msize	long
=	O
0	int
;	O
enum	O
envar_type	enum
type	enum
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
name	pointer
++	O
;	O
len	long
--	O
;	O
if	O
(	O
name	pointer
[	O
len	long
]	O
)	O
{	O
value	pointer
=	O
name	pointer
+	O
len	long
+	O
1	int
;	O
vlen	long
=	O
strlen	function
(	O
value	pointer
)	O
;	O
}	O
else	O
{	O
value	pointer
=	O
NULL	O
;	O
vlen	long
=	O
0	int
;	O
}	O
type	enum
=	O
envar_unset	int
;	O
}	O
else	O
if	O
(	O
name	pointer
[	O
len	long
]	O
)	O
{	O
if	O
(	O
len	long
==	O
0	int
)	O
continue	O
;	O
value	pointer
=	O
name	pointer
+	O
len	long
+	O
1	int
;	O
vlen	long
=	O
strlen	function
(	O
value	pointer
)	O
;	O
name	pointer
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'+'	O
)	O
{	O
name	pointer
[	O
--	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
c_ispunct	function
(	O
value	pointer
[	O
0	int
]	O
)	O
)	O
{	O
msize	long
=	O
2	int
*	O
len	long
+	O
9	int
+	O
vlen	long
+	O
1	int
;	O
mem	pointer
=	O
xmalloc	function
(	O
msize	long
)	O
;	O
snprintf	function
(	O
mem	pointer
,	O
msize	long
,	O
"${%s:-}${%s+%c}%s"	pointer
,	O
name	pointer
,	O
name	pointer
,	O
value	pointer
[	O
0	int
]	O
,	O
value	pointer
+	O
1	int
)	O
;	O
}	O
else	O
{	O
msize	long
=	O
len	long
+	O
vlen	long
+	O
6	int
;	O
snprintf	function
(	O
mem	pointer
,	O
msize	long
,	O
"${%s:-}%s"	pointer
,	O
name	pointer
,	O
value	pointer
)	O
;	O
}	O
value	pointer
=	O
mem	pointer
;	O
vlen	long
=	O
strlen	function
(	O
value	pointer
)	O
;	O
}	O
else	O
if	O
(	O
value	pointer
[	O
0	int
]	O
==	O
'+'	O
)	O
{	O
value	pointer
++	O
;	O
vlen	long
--	O
;	O
if	O
(	O
vlen	long
>	O
0	int
&&	O
c_ispunct	function
(	O
value	pointer
[	O
vlen	long
-	O
1	int
]	O
)	O
)	O
{	O
int	O
c	int
=	O
value	pointer
[	O
vlen	long
-	O
1	int
]	O
;	O
value	pointer
[	O
--	O
vlen	long
]	O
=	O
0	int
;	O
msize	long
=	O
2	int
*	O
len	long
+	O
10	int
+	O
vlen	long
+	O
1	int
;	O
mem	pointer
=	O
xmalloc	function
(	O
msize	long
)	O
;	O
snprintf	function
(	O
mem	pointer
,	O
msize	long
,	O
"%s${%s+%c}${%s:-}"	pointer
,	O
value	pointer
,	O
name	pointer
,	O
c	int
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
msize	long
=	O
len	long
+	O
vlen	long
+	O
6	int
;	O
snprintf	function
(	O
mem	pointer
,	O
msize	long
,	O
"%s${%s:-}"	pointer
,	O
value	pointer
,	O
name	pointer
)	O
;	O
}	O
value	pointer
=	O
mem	pointer
;	O
vlen	long
=	O
strlen	function
(	O
value	pointer
)	O
;	O
}	O
type	enum
=	O
envar_set	int
;	O
}	O
else	O
{	O
value	pointer
=	O
NULL	O
;	O
vlen	long
=	O
0	int
;	O
type	enum
=	O
envar_keep	int
;	O
}	O
new_envar	function
(	O
rule	pointer
,	O
name	pointer
,	O
len	long
,	O
value	pointer
,	O
vlen	long
,	O
type	enum
)	O
;	O
free	function
(	O
mem	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_debug	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
if	O
(	O
!	O
debug_option	int
)	O
{	O
debug_level	int
=	O
strtoul	function
(	O
env	pointer
->	O
val	array
,	O
NULL	O
,	O
0	int
)	O
;	O
debug	O
(	O
0	int
,	O
_	O
(	O
"debug level set to %d"	pointer
)	O
,	O
debug_level	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_sleep_time	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
q	pointer
;	O
sleep_time	int
=	O
strtoul	function
(	O
env	pointer
->	O
val	array
,	O
&	O
q	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	pointer
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"invalid time: %s"	pointer
)	O
,	O
env	pointer
->	O
val	array
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_usage_error	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
set_error_msg	function
(	O
usage_error	int
,	O
copy_string	function
(	O
env	pointer
->	O
val	array
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_nologin_error	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
set_error_msg	function
(	O
nologin_error	int
,	O
copy_string	function
(	O
env	pointer
->	O
val	array
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_config_error	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
set_error_msg	function
(	O
config_error	int
,	O
copy_string	function
(	O
env	pointer
->	O
val	array
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_system_error	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
set_error_msg	function
(	O
system_error	int
,	O
copy_string	function
(	O
env	pointer
->	O
val	array
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_fall_through	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
RUSH_ARG_UNUSED	O
)	O
{	O
rule	pointer
->	O
fall_through	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_exit	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
const	O
char	O
*	O
val	array
=	O
env	pointer
->	O
val	array
;	O
int	O
error_fd	int
;	O
if	O
(	O
c_isdigit	function
(	O
val	array
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
n	long
=	O
strtoul	function
(	O
val	array
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
!	O
ISWS	O
(	O
p	pointer
[	O
0	int
]	O
)	O
||	O
n	long
>	O
getmaxfd	O
(	O
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid file descriptor"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
val	array
=	O
skipws	function
(	O
p	pointer
)	O
;	O
error_fd	int
=	O
n	long
;	O
}	O
else	O
error_fd	int
=	O
2	int
;	O
if	O
(	O
val	array
[	O
0	int
]	O
==	O
'@'	O
)	O
{	O
if	O
(	O
val	array
[	O
1	int
]	O
==	O
'@'	O
)	O
rule	pointer
->	O
error	pointer
=	O
new_error	function
(	O
error_fd	int
,	O
val	array
+	O
1	int
,	O
1	int
)	O
;	O
else	O
{	O
int	O
n	long
=	O
string_to_error_index	function
(	O
val	array
+	O
1	int
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"Unknown message reference"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rule	pointer
->	O
error	pointer
=	O
new_standard_error	function
(	O
error_fd	int
,	O
n	long
)	O
;	O
}	O
}	O
else	O
rule	pointer
->	O
error	pointer
=	O
new_error	function
(	O
error_fd	int
,	O
val	array
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_fork	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
attrib_fork	function
(	O
rule	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_acct	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
attrib_acct	function
(	O
rule	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_acct_file_mode	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
parse_file_mode	function
(	O
env	pointer
->	O
val	array
,	O
&	O
rushdb_file_mode	int
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_acct_dir_mode	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
parse_file_mode	function
(	O
env	pointer
->	O
val	array
,	O
&	O
rushdb_dir_mode	int
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_acct_umask	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
parse_file_mode	function
(	O
env	pointer
->	O
val	array
,	O
&	O
rushdb_umask	int
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_post_socket	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
return	O
attrib_post_socket	function
(	O
rule	pointer
,	O
env	pointer
->	O
val	array
,	O
&	O
ibuf	pointer
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
_parse_text_domain	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
rule	pointer
->	O
i18n	struct
.	O
text_domain	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
val	array
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_locale_dir	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
rule	pointer
->	O
i18n	struct
.	O
localedir	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
val	array
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_locale	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
const	O
char	O
*	O
val	array
;	O
if	O
(	O
strcmp	function
(	O
env	pointer
->	O
val	array
,	O
"\"\""	pointer
)	O
==	O
0	int
)	O
val	array
=	O
""	pointer
;	O
else	O
val	array
=	O
env	pointer
->	O
val	array
;	O
rule	pointer
->	O
i18n	struct
.	O
locale	pointer
=	O
xstrdup	function
(	O
val	array
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_include	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
CFSTREAM	struct
*	O
cf	pointer
;	O
name	pointer
=	O
expand_tilde	function
(	O
env	pointer
->	O
val	array
,	O
rush_pw	pointer
->	O
pw_dir	pointer
)	O
;	O
if	O
(	O
trimslash	function
(	O
name	pointer
)	O
==	O
0	int
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid include file name"	pointer
)	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct
(	O
name	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
debug	O
(	O
1	int
,	O
_	O
(	O
"Ignoring non-existing include file %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
env	pointer
->	O
ret_buf	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"cannot stat file %s: %s"	pointer
)	O
,	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
char	O
*	O
file	pointer
=	O
make_file_name	function
(	O
name	pointer
,	O
rush_pw	pointer
->	O
pw_name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
access	function
(	O
file	pointer
,	O
F_OK	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
name	pointer
=	O
file	pointer
;	O
}	O
cf	pointer
=	O
cfstream_open_file	function
(	O
name	pointer
)	O
;	O
init_input_buf	function
(	O
&	O
env	pointer
->	O
ret_buf	pointer
,	O
ibuf	pointer
,	O
cf	pointer
,	O
name	pointer
,	O
1	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_include_security	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
int	O
i	int
;	O
int	O
rc	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
env	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cfck_keyword	function
(	O
env	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"unknown keyword: %s"	pointer
)	O
,	O
env	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
rc	int
++	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
_parse_interactive	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
rule	pointer
->	O
interactive	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_map_ar	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
;	O
unsigned	O
long	O
n	long
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
check_argc	function
(	O
ibuf	pointer
,	O
env	pointer
,	O
5	int
,	O
6	int
)	O
)	O
return	O
1	int
;	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_map	int
)	O
;	O
if	O
(	O
env	pointer
->	O
progmod	int
)	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_program	int
;	O
else	O
{	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_arg	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
ins	int
=	O
0	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
=	O
env	pointer
->	O
index	function
;	O
}	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
file	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
delim	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
key	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
n	long
=	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
key_field	int
=	O
strtoul	function
(	O
env	pointer
->	O
argv	pointer
[	O
3	int
]	O
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
||	O
n	long
!=	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
key_field	int
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"key field is not a number"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
n	long
=	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
val_field	int
=	O
strtoul	function
(	O
env	pointer
->	O
argv	pointer
[	O
4	int
]	O
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
||	O
n	long
!=	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
val_field	int
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"value field is not a number"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
env	pointer
->	O
argc	int
==	O
6	int
)	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
defval	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
5	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_delete_ar	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_delete	int
)	O
;	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_arg	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
ins	int
=	O
0	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
=	O
env	pointer
->	O
index	function
;	O
node	pointer
->	O
v	union
.	O
arg_end	int
=	O
env	pointer
->	O
index	function
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_arg_index	function
(	O
char	O
*	O
str	pointer
,	O
char	O
*	O
*	O
end	pointer
)	O
{	O
if	O
(	O
*	O
str	pointer
==	O
'$'	O
)	O
{	O
*	O
end	pointer
=	O
str	pointer
+	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
strtol	function
(	O
str	pointer
,	O
end	pointer
,	O
10	int
)	O
;	O
}	O
static	O
int	O
_parse_delete	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
;	O
int	O
from	int
,	O
to	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
check_argc	function
(	O
ibuf	pointer
,	O
env	pointer
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
from	int
=	O
get_arg_index	function
(	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"%s: not a number"	pointer
)	O
,	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
to	int
=	O
get_arg_index	function
(	O
env	pointer
->	O
argv	pointer
[	O
1	int
]	O
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"%s: not a number"	pointer
)	O
,	O
env	pointer
->	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_delete	int
)	O
;	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_arg	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
ins	int
=	O
0	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
=	O
from	int
;	O
node	pointer
->	O
v	union
.	O
arg_end	int
=	O
to	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_set	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_set	int
)	O
;	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_command	int
;	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
val	array
)	O
;	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
trans	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_set_ar	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_set	int
)	O
;	O
if	O
(	O
env	pointer
->	O
progmod	int
)	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_program	int
;	O
else	O
{	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_arg	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
ins	int
=	O
0	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
=	O
env	pointer
->	O
index	function
;	O
}	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
val	array
)	O
;	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
trans	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_setvar	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_set	int
)	O
;	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_var	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
name	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
trans	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_unsetvar	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
=	O
new_transform_node	function
(	O
rule	pointer
,	O
transform_delete	int
)	O
;	O
node	pointer
->	O
target	struct
.	O
type	enum
=	O
target_var	int
;	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
name	pointer
=	O
xstrdup	function
(	O
env	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_parse_newgroup	function
(	O
input_buf_ptr	pointer
ibuf	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
stmt_env	struct
*	O
env	pointer
)	O
{	O
if	O
(	O
parsegid	function
(	O
env	pointer
->	O
val	array
,	O
&	O
rule	pointer
->	O
gid	int
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"no such group: %s"	pointer
)	O
,	O
env	pointer
->	O
val	array
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
token	struct
{	O
char	O
*	O
name	pointer
;	O
size_t	long
namelen	long
;	O
int	O
flags	int
;	O
int	O
(	O
*	O
parser	pointer
)	O
(	O
input_buf_ptr	pointer
,	O
struct	O
rush_rule	struct
*	O
,	O
struct	O
stmt_env	struct
*	O
)	O
;	O
}	O
;	O
struct	O
token	struct
toktab	array
[	O
]	O
=	O
{	O
{	O
KW	O
(	O
"command"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_command	function
}	O
,	O
{	O
KW	O
(	O
"match"	pointer
)	O
,	O
TOK_DFL	O
|	O
TOK_IND	int
,	O
_parse_match	function
}	O
,	O
{	O
KW	O
(	O
"argc"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_argc	function
}	O
,	O
{	O
KW	O
(	O
"uid"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_uid	function
}	O
,	O
{	O
KW	O
(	O
"gid"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_gid	function
}	O
,	O
{	O
KW	O
(	O
"user"	pointer
)	O
,	O
TOK_DFLN	O
,	O
_parse_user	function
}	O
,	O
{	O
KW	O
(	O
"group"	pointer
)	O
,	O
TOK_DFLN	O
,	O
_parse_group	function
}	O
,	O
{	O
KW	O
(	O
"transform"	pointer
)	O
,	O
TOK_DFL	O
|	O
TOK_SED	int
,	O
_parse_transform	function
}	O
,	O
{	O
KW	O
(	O
"transform"	pointer
)	O
,	O
TOK_DFL	O
|	O
TOK_IND	int
|	O
TOK_SED	int
|	O
TOK_CRT	int
,	O
_parse_transform_ar	function
}	O
,	O
{	O
KW	O
(	O
"map"	pointer
)	O
,	O
TOK_RUL	int
|	O
TOK_ARGN	int
|	O
TOK_IND	int
|	O
TOK_CRT	int
,	O
_parse_map_ar	function
}	O
,	O
{	O
KW	O
(	O
"delete"	pointer
)	O
,	O
TOK_RUL	int
|	O
TOK_IND	int
,	O
_parse_delete_ar	function
}	O
,	O
{	O
KW	O
(	O
"delete"	pointer
)	O
,	O
TOK_RUL	int
|	O
TOK_ARGN	int
,	O
_parse_delete	function
}	O
,	O
{	O
KW	O
(	O
"set"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_set	function
}	O
,	O
{	O
KW	O
(	O
"set"	pointer
)	O
,	O
TOK_DFL	O
|	O
TOK_IND	int
|	O
TOK_CRT	int
,	O
_parse_set_ar	function
}	O
,	O
{	O
KW	O
(	O
"setvar"	pointer
)	O
,	O
TOK_RUL	int
|	O
TOK_ARG	int
|	O
TOK_ASSC	int
,	O
_parse_setvar	function
}	O
,	O
{	O
KW	O
(	O
"unsetvar"	pointer
)	O
,	O
TOK_RUL	int
|	O
TOK_ASSC	int
,	O
_parse_unsetvar	function
}	O
,	O
{	O
KW	O
(	O
"umask"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_umask	function
}	O
,	O
{	O
KW	O
(	O
"chroot"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_chroot	function
}	O
,	O
{	O
KW	O
(	O
"limits"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_limits	function
}	O
,	O
{	O
KW	O
(	O
"chdir"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_chdir	function
}	O
,	O
{	O
KW	O
(	O
"env"	pointer
)	O
,	O
TOK_DFLN	O
|	O
TOK_ENV	int
,	O
_parse_env	function
}	O
,	O
{	O
KW	O
(	O
"fork"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_fork	function
}	O
,	O
{	O
KW	O
(	O
"acct"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_acct	function
}	O
,	O
{	O
KW	O
(	O
"post-socket"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_post_socket	function
}	O
,	O
{	O
KW	O
(	O
"text-domain"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_text_domain	function
}	O
,	O
{	O
KW	O
(	O
"locale-dir"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_locale_dir	function
}	O
,	O
{	O
KW	O
(	O
"locale"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_locale	function
}	O
,	O
{	O
KW	O
(	O
"include"	pointer
)	O
,	O
TOK_ARG	int
|	O
TOK_NEWBUF	int
,	O
_parse_include	function
}	O
,	O
{	O
KW	O
(	O
"fall-through"	pointer
)	O
,	O
TOK_RUL	int
,	O
_parse_fall_through	function
}	O
,	O
{	O
KW	O
(	O
"exit"	pointer
)	O
,	O
TOK_RUL	int
,	O
_parse_exit	function
}	O
,	O
{	O
KW	O
(	O
"debug"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_debug	function
}	O
,	O
{	O
KW	O
(	O
"sleep-time"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_sleep_time	function
}	O
,	O
{	O
KW	O
(	O
"usage-error"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_usage_error	function
}	O
,	O
{	O
KW	O
(	O
"nologin-error"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_nologin_error	function
}	O
,	O
{	O
KW	O
(	O
"config-error"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_config_error	function
}	O
,	O
{	O
KW	O
(	O
"system-error"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_system_error	function
}	O
,	O
{	O
KW	O
(	O
"regexp"	pointer
)	O
,	O
TOK_ARGN	int
,	O
_parse_re_flags	function
}	O
,	O
{	O
KW	O
(	O
"include-security"	pointer
)	O
,	O
TOK_ARGN	int
,	O
_parse_include_security	function
}	O
,	O
{	O
KW	O
(	O
"interactive"	pointer
)	O
,	O
TOK_RUL	int
,	O
_parse_interactive	function
}	O
,	O
{	O
KW	O
(	O
"acct-file-mode"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_acct_file_mode	function
}	O
,	O
{	O
KW	O
(	O
"acct-dir-mode"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_acct_dir_mode	function
}	O
,	O
{	O
KW	O
(	O
"acct-umask"	pointer
)	O
,	O
TOK_ARG	int
,	O
_parse_acct_umask	function
}	O
,	O
{	O
KW	O
(	O
"newgroup"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_newgroup	function
}	O
,	O
{	O
KW	O
(	O
"newgrp"	pointer
)	O
,	O
TOK_DFL	O
,	O
_parse_newgroup	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
token	struct
*	O
find_token	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
*	O
plen	pointer
)	O
{	O
struct	O
token	struct
*	O
tok	pointer
;	O
int	O
len	long
=	O
strcspn	function
(	O
name	pointer
,	O
"["	pointer
)	O
;	O
for	O
(	O
tok	pointer
=	O
toktab	array
;	O
tok	pointer
->	O
name	pointer
;	O
tok	pointer
++	O
)	O
{	O
if	O
(	O
len	long
==	O
tok	pointer
->	O
namelen	long
&&	O
strncmp	function
(	O
tok	pointer
->	O
name	pointer
,	O
name	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
(	O
name	pointer
[	O
len	long
]	O
==	O
0	int
?	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_IND	int
)	O
==	O
0	int
:	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_IND	int
)	O
)	O
)	O
{	O
*	O
plen	pointer
=	O
len	long
;	O
return	O
tok	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
int	O
parse_input_buf	function
(	O
input_buf_ptr	pointer
ibuf	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
int	O
err	long
=	O
0	int
;	O
struct	O
rush_rule	struct
*	O
rule	pointer
=	O
NULL	O
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Parsing %s"	pointer
)	O
,	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
)	O
;	O
while	O
(	O
read_line	function
(	O
&	O
ibuf	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
)	O
)	O
{	O
char	O
*	O
kw	pointer
,	O
*	O
val	array
;	O
char	O
*	O
p	pointer
;	O
struct	O
token	struct
*	O
tok	pointer
;	O
int	O
len	long
;	O
int	O
rc	int
;	O
struct	O
stmt_env	struct
env	pointer
;	O
memset	function
(	O
&	O
env	pointer
,	O
0	int
,	O
sizeof	O
env	pointer
)	O
;	O
p	pointer
=	O
skipws	function
(	O
buf	pointer
)	O
;	O
debug	O
(	O
3	int
,	O
"%s:%d: %s"	pointer
,	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
,	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
line	int
,	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
0	int
||	O
p	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
kw	pointer
=	O
p	pointer
;	O
p	pointer
=	O
eow	function
(	O
kw	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
)	O
{	O
*	O
p	pointer
++	O
=	O
0	int
;	O
val	array
=	O
skipws	function
(	O
p	pointer
)	O
;	O
trimws	function
(	O
val	array
)	O
;	O
}	O
else	O
val	array
=	O
NULL	O
;	O
if	O
(	O
strcmp	function
(	O
kw	pointer
,	O
"rule"	pointer
)	O
==	O
0	int
)	O
{	O
rule	pointer
=	O
new_rush_rule	function
(	O
val	array
)	O
;	O
rule	pointer
->	O
file	pointer
=	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
;	O
rule	pointer
->	O
line	int
=	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
line	int
;	O
continue	O
;	O
}	O
tok	pointer
=	O
find_token	function
(	O
kw	pointer
,	O
&	O
len	long
)	O
;	O
if	O
(	O
!	O
tok	pointer
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"unknown statement: %s"	pointer
)	O
,	O
kw	pointer
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
env	pointer
.	O
kw	pointer
=	O
kw	pointer
;	O
env	pointer
.	O
val	array
=	O
val	array
;	O
kw	pointer
+=	O
len	long
;	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_IND	int
)	O
{	O
char	O
*	O
q	pointer
;	O
if	O
(	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_ASSC	int
)	O
==	O
TOK_ASSC	int
)	O
{	O
q	pointer
=	O
strchr	function
(	O
kw	pointer
+	O
1	int
,	O
']'	O
)	O
;	O
if	O
(	O
q	pointer
)	O
{	O
size_t	long
len	long
=	O
q	pointer
-	O
kw	pointer
-	O
1	int
;	O
env	pointer
.	O
argc	int
=	O
2	int
;	O
env	pointer
.	O
argv	pointer
=	O
xcalloc	function
(	O
env	pointer
.	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
env	pointer
.	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
env	pointer
.	O
argv	pointer
[	O
0	int
]	O
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
env	pointer
.	O
argv	pointer
[	O
0	int
]	O
,	O
kw	pointer
+	O
1	int
,	O
len	long
)	O
;	O
env	pointer
.	O
argv	pointer
[	O
0	int
]	O
[	O
len	long
]	O
=	O
0	int
;	O
env	pointer
.	O
argv	pointer
[	O
1	int
]	O
=	O
env	pointer
.	O
val	array
?	O
xstrdup	function
(	O
env	pointer
.	O
val	array
)	O
:	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
kw	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
env	pointer
.	O
index	function
=	O
-	O
1	int
;	O
q	pointer
=	O
kw	pointer
+	O
2	int
;	O
}	O
else	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_CRT	int
&&	O
kw	pointer
[	O
1	int
]	O
==	O
'^'	O
)	O
{	O
env	pointer
.	O
progmod	int
=	O
1	int
;	O
q	pointer
=	O
kw	pointer
+	O
2	int
;	O
}	O
else	O
env	pointer
.	O
index	function
=	O
strtol	function
(	O
kw	pointer
+	O
1	int
,	O
&	O
q	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	pointer
!=	O
']'	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"missing ]"	pointer
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
(	O
TOK_ARG	int
|	O
TOK_ARGN	int
)	O
&&	O
!	O
(	O
val	array
&&	O
*	O
val	array
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid statement: missing value"	pointer
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_ARGN	int
)	O
{	O
int	O
flags	int
=	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_COMMENT	int
;	O
struct	O
wordsplit	struct
ws	pointer
;	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_SED	int
)	O
flags	int
|=	O
WRDSF_SED_EXPR	int
;	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_ENV	int
)	O
{	O
flags	int
&=	O
~	O
WRDSF_NOVAR	int
;	O
flags	int
|=	O
WRDSF_ENV	int
;	O
ws	pointer
.	O
ws_env	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
environ	pointer
;	O
}	O
ws	pointer
.	O
ws_comment	pointer
=	O
"#"	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
val	array
,	O
&	O
ws	pointer
,	O
flags	int
)	O
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
_	O
(	O
"failed to parse value: %s"	pointer
)	O
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
env	pointer
.	O
argc	int
=	O
ws	pointer
.	O
ws_wordc	long
;	O
env	pointer
.	O
argv	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
;	O
ws	pointer
.	O
ws_wordc	long
=	O
0	int
;	O
ws	pointer
.	O
ws_wordv	pointer
=	O
NULL	O
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_RUL	int
)	O
{	O
if	O
(	O
!	O
rule	pointer
)	O
{	O
cferror	function
(	O
&	O
ibuf	pointer
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"statement cannot be used outside a rule"	pointer
)	O
)	O
;	O
err	long
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
rc	int
=	O
tok	pointer
->	O
parser	pointer
(	O
ibuf	pointer
,	O
rule	pointer
,	O
&	O
env	pointer
)	O
;	O
err	long
|=	O
rc	int
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
TOK_NEWBUF	int
&&	O
env	pointer
.	O
ret_buf	pointer
)	O
{	O
env	pointer
.	O
ret_buf	pointer
->	O
next	pointer
=	O
ibuf	pointer
;	O
ibuf	pointer
=	O
env	pointer
.	O
ret_buf	pointer
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"Parsing %s"	pointer
)	O
,	O
ibuf	pointer
->	O
loc	pointer
.	O
beg	struct
.	O
filename	pointer
)	O
;	O
}	O
if	O
(	O
env	pointer
.	O
node	pointer
)	O
{	O
if	O
(	O
rule	pointer
->	O
test_node	struct
)	O
{	O
struct	O
test_node	struct
*	O
np	pointer
=	O
new_test_node	function
(	O
test_and	int
)	O
;	O
np	pointer
->	O
v	union
.	O
arg	struct
[	O
0	int
]	O
=	O
rule	pointer
->	O
test_node	struct
;	O
np	pointer
->	O
v	union
.	O
arg	struct
[	O
1	int
]	O
=	O
env	pointer
.	O
node	pointer
;	O
rule	pointer
->	O
test_node	struct
=	O
np	pointer
;	O
}	O
else	O
rule	pointer
->	O
test_node	struct
=	O
env	pointer
.	O
node	pointer
;	O
}	O
}	O
if	O
(	O
tok	pointer
->	O
flags	int
&	O
(	O
TOK_ARGN	int
|	O
TOK_ASSC	int
)	O
)	O
argcv_free	function
(	O
env	pointer
.	O
argc	int
,	O
env	pointer
.	O
argv	pointer
)	O
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
err	long
;	O
}	O
int	O
cfparse_old	function
(	O
CFSTREAM	struct
*	O
cf	pointer
,	O
char	O
const	O
*	O
filename	pointer
,	O
int	O
line	int
)	O
{	O
input_buf_ptr	pointer
buf	pointer
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"<built-in>"	pointer
)	O
==	O
0	int
)	O
{	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"parsing legacy built-in configuration"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"parsing legacy configuration file %s"	pointer
)	O
,	O
filename	pointer
)	O
;	O
}	O
init_input_buf	function
(	O
&	O
buf	pointer
,	O
NULL	O
,	O
cf	pointer
,	O
filename	pointer
,	O
line	int
-	O
1	int
)	O
;	O
return	O
parse_input_buf	function
(	O
buf	pointer
)	O
;	O
}	O
