static	O
void	O
makedirs	function
(	O
char	O
const	O
*	O
)	O
;	O
typedef	O
struct	O
{	O
dev_t	long
dev	long
;	O
ino_t	long
ino	long
;	O
enum	O
file_id_type	enum
type	enum
;	O
bool	bool
queued_output	bool
;	O
}	O
file_id	struct
;	O
static	O
size_t	long
file_id_hasher	function
(	O
void	O
const	O
*	O
entry	pointer
,	O
size_t	long
table_size	long
)	O
{	O
file_id	struct
const	O
*	O
e	pointer
=	O
entry	pointer
;	O
size_t	long
i	int
=	O
e	pointer
->	O
ino	long
+	O
e	pointer
->	O
dev	long
;	O
return	O
i	int
%	O
table_size	long
;	O
}	O
static	O
bool	bool
file_id_comparator	function
(	O
void	O
const	O
*	O
entry1	pointer
,	O
void	O
const	O
*	O
entry2	pointer
)	O
{	O
file_id	struct
const	O
*	O
e1	pointer
=	O
entry1	pointer
;	O
file_id	struct
const	O
*	O
e2	pointer
=	O
entry2	pointer
;	O
return	O
(	O
e1	pointer
->	O
ino	long
==	O
e2	pointer
->	O
ino	long
&&	O
e1	pointer
->	O
dev	long
==	O
e2	pointer
->	O
dev	long
)	O
;	O
}	O
static	O
Hash_table	struct
*	O
file_id_table	pointer
;	O
void	O
init_backup_hash_table	function
(	O
void	O
)	O
{	O
file_id_table	pointer
=	O
hash_initialize	function
(	O
0	int
,	O
NULL	O
,	O
file_id_hasher	function
,	O
file_id_comparator	function
,	O
free	function
)	O
;	O
if	O
(	O
!	O
file_id_table	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
static	O
file_id	struct
*	O
__insert_file_id	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
,	O
enum	O
file_id_type	enum
type	enum
)	O
{	O
file_id	struct
*	O
p	pointer
;	O
static	O
file_id	struct
*	O
next_slot	pointer
;	O
if	O
(	O
!	O
next_slot	pointer
)	O
next_slot	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
next_slot	pointer
)	O
;	O
next_slot	pointer
->	O
dev	long
=	O
st	pointer
->	O
st_dev	long
;	O
next_slot	pointer
->	O
ino	long
=	O
st	pointer
->	O
st_ino	long
;	O
next_slot	pointer
->	O
queued_output	bool
=	O
false	int
;	O
p	pointer
=	O
hash_insert	function
(	O
file_id_table	pointer
,	O
next_slot	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
if	O
(	O
p	pointer
==	O
next_slot	pointer
)	O
next_slot	pointer
=	O
NULL	O
;	O
p	pointer
->	O
type	enum
=	O
type	enum
;	O
return	O
p	pointer
;	O
}	O
static	O
file_id	struct
*	O
__lookup_file_id	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
)	O
{	O
file_id	struct
f	struct
;	O
f	struct
.	O
dev	long
=	O
st	pointer
->	O
st_dev	long
;	O
f	struct
.	O
ino	long
=	O
st	pointer
->	O
st_ino	long
;	O
return	O
hash_lookup	function
(	O
file_id_table	pointer
,	O
&	O
f	struct
)	O
;	O
}	O
void	O
insert_file_id	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
,	O
enum	O
file_id_type	enum
type	enum
)	O
{	O
__insert_file_id	function
(	O
st	pointer
,	O
type	enum
)	O
;	O
}	O
enum	O
file_id_type	enum
lookup_file_id	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
)	O
{	O
file_id	struct
*	O
p	pointer
=	O
__lookup_file_id	function
(	O
st	pointer
)	O
;	O
return	O
p	pointer
?	O
p	pointer
->	O
type	enum
:	O
UNKNOWN	int
;	O
}	O
void	O
set_queued_output	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
,	O
bool	bool
queued_output	bool
)	O
{	O
file_id	struct
*	O
p	pointer
=	O
__lookup_file_id	function
(	O
st	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
p	pointer
=	O
__insert_file_id	function
(	O
st	pointer
,	O
UNKNOWN	int
)	O
;	O
p	pointer
->	O
queued_output	bool
=	O
queued_output	bool
;	O
}	O
bool	bool
has_queued_output	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
)	O
{	O
file_id	struct
*	O
p	pointer
=	O
__lookup_file_id	function
(	O
st	pointer
)	O
;	O
return	O
p	pointer
&&	O
p	pointer
->	O
queued_output	bool
;	O
}	O
static	O
bool	bool
_GL_ATTRIBUTE_PURE	O
contains_slash	function
(	O
const	O
char	O
*	O
s	enum
)	O
{	O
for	O
(	O
;	O
*	O
s	enum
;	O
s	enum
++	O
)	O
if	O
(	O
ISSLASH	O
(	O
*	O
s	enum
)	O
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
static	O
int	O
copy_attr	function
(	O
char	O
const	O
*	O
src_path	pointer
,	O
char	O
const	O
*	O
dst_path	pointer
)	O
{	O
return	O
0	int
;	O
}	O
void	O
set_file_attributes	function
(	O
char	O
const	O
*	O
to	pointer
,	O
enum	O
file_attributes	enum
attr	enum
,	O
char	O
const	O
*	O
from	pointer
,	O
const	O
struct	O
stat	struct
*	O
st	pointer
,	O
mode_t	int
mode	int
,	O
struct	O
timespec	struct
*	O
new_time	pointer
)	O
{	O
if	O
(	O
attr	enum
&	O
FA_TIMES	int
)	O
{	O
struct	O
timespec	struct
times	array
[	O
2	int
]	O
;	O
if	O
(	O
new_time	pointer
)	O
times	array
[	O
0	int
]	O
=	O
times	array
[	O
1	int
]	O
=	O
*	O
new_time	pointer
;	O
else	O
{	O
times	array
[	O
0	int
]	O
=	O
get_stat_atime	function
(	O
st	pointer
)	O
;	O
times	array
[	O
1	int
]	O
=	O
get_stat_mtime	function
(	O
st	pointer
)	O
;	O
}	O
if	O
(	O
lutimens	function
(	O
to	pointer
,	O
times	array
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Failed to set the timestamps of %s %s"	pointer
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	pointer
:	O
"file"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
}	O
if	O
(	O
attr	enum
&	O
FA_IDS	int
)	O
{	O
static	O
uid_t	int
euid	int
=	O
-	O
1	int
;	O
static	O
gid_t	int
egid	int
=	O
-	O
1	int
;	O
uid_t	int
uid	int
;	O
uid_t	int
gid	int
;	O
if	O
(	O
euid	int
==	O
-	O
1	int
)	O
{	O
euid	int
=	O
geteuid	function
(	O
)	O
;	O
egid	int
=	O
getegid	function
(	O
)	O
;	O
}	O
uid	int
=	O
(	O
euid	int
==	O
st	pointer
->	O
st_uid	int
)	O
?	O
-	O
1	int
:	O
st	pointer
->	O
st_uid	int
;	O
gid	int
=	O
(	O
egid	int
==	O
st	pointer
->	O
st_gid	int
)	O
?	O
-	O
1	int
:	O
st	pointer
->	O
st_gid	int
;	O
if	O
(	O
(	O
uid	int
!=	O
-	O
1	int
||	O
gid	int
!=	O
-	O
1	int
)	O
&&	O
lchown	function
(	O
to	pointer
,	O
uid	int
,	O
gid	int
)	O
!=	O
0	int
&&	O
(	O
errno	O
!=	O
EPERM	int
||	O
(	O
uid	int
!=	O
-	O
1	int
&&	O
lchown	function
(	O
to	pointer
,	O
(	O
uid	int
=	O
-	O
1	int
)	O
,	O
gid	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EPERM	int
)	O
)	O
)	O
pfatal	function
(	O
"Failed to set the %s of %s %s"	pointer
,	O
(	O
uid	int
==	O
-	O
1	int
)	O
?	O
"owner"	pointer
:	O
"owning group"	pointer
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	pointer
:	O
"file"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
}	O
if	O
(	O
attr	enum
&	O
FA_XATTRS	int
)	O
if	O
(	O
copy_attr	function
(	O
from	pointer
,	O
to	pointer
)	O
)	O
fatal_exit	function
(	O
0	int
)	O
;	O
if	O
(	O
attr	enum
&	O
FA_MODE	int
)	O
{	O
if	O
(	O
!	O
S_ISLNK	O
(	O
mode	int
)	O
&&	O
chmod	function
(	O
to	pointer
,	O
mode	int
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Failed to set the permissions of %s %s"	pointer
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	pointer
:	O
"file"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
create_backup_copy	function
(	O
char	O
const	O
*	O
from	pointer
,	O
char	O
const	O
*	O
to	pointer
,	O
const	O
struct	O
stat	struct
*	O
st	pointer
,	O
bool	bool
to_dir_known_to_exist	bool
)	O
{	O
copy_file	function
(	O
from	pointer
,	O
to	pointer
,	O
NULL	O
,	O
0	int
,	O
st	pointer
->	O
st_mode	int
,	O
to_dir_known_to_exist	bool
)	O
;	O
set_file_attributes	function
(	O
to	pointer
,	O
FA_TIMES	int
|	O
FA_IDS	int
|	O
FA_MODE	int
,	O
from	pointer
,	O
st	pointer
,	O
st	pointer
->	O
st_mode	int
,	O
NULL	O
)	O
;	O
}	O
void	O
create_backup	function
(	O
char	O
const	O
*	O
to	pointer
,	O
const	O
struct	O
stat	struct
*	O
to_st	pointer
,	O
bool	bool
leave_original	bool
)	O
{	O
if	O
(	O
to_st	pointer
&&	O
!	O
(	O
S_ISREG	O
(	O
to_st	pointer
->	O
st_mode	int
)	O
||	O
S_ISLNK	O
(	O
to_st	pointer
->	O
st_mode	int
)	O
)	O
)	O
fatal	function
(	O
"File %s is not a %s -- refusing to create backup"	pointer
,	O
to	pointer
,	O
S_ISLNK	O
(	O
to_st	pointer
->	O
st_mode	int
)	O
?	O
"symbolic link"	pointer
:	O
"regular file"	pointer
)	O
;	O
if	O
(	O
to_st	pointer
&&	O
lookup_file_id	function
(	O
to_st	pointer
)	O
==	O
CREATED	int
)	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	function
(	O
"File %s already seen\n"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
}	O
else	O
{	O
int	O
try_makedirs_errno	int
=	O
0	int
;	O
char	O
*	O
bakname	pointer
;	O
if	O
(	O
origprae	pointer
||	O
origbase	pointer
||	O
origsuff	pointer
)	O
{	O
char	O
const	O
*	O
p	pointer
=	O
origprae	pointer
?	O
origprae	pointer
:	O
""	pointer
;	O
char	O
const	O
*	O
b	struct
=	O
origbase	pointer
?	O
origbase	pointer
:	O
""	pointer
;	O
char	O
const	O
*	O
s	enum
=	O
origsuff	pointer
?	O
origsuff	pointer
:	O
""	pointer
;	O
char	O
const	O
*	O
t	struct
=	O
to	pointer
;	O
size_t	long
plen	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
size_t	long
blen	long
=	O
strlen	function
(	O
b	struct
)	O
;	O
size_t	long
slen	long
=	O
strlen	function
(	O
s	enum
)	O
;	O
size_t	long
tlen	long
=	O
strlen	function
(	O
t	struct
)	O
;	O
char	O
const	O
*	O
o	pointer
;	O
size_t	long
olen	long
;	O
for	O
(	O
o	pointer
=	O
t	struct
+	O
tlen	long
,	O
olen	long
=	O
0	int
;	O
o	pointer
>	O
t	struct
&&	O
!	O
ISSLASH	O
(	O
*	O
(	O
o	pointer
-	O
1	int
)	O
)	O
;	O
o	pointer
--	O
)	O
;	O
olen	long
=	O
t	struct
+	O
tlen	long
-	O
o	pointer
;	O
tlen	long
-=	O
olen	long
;	O
bakname	pointer
=	O
xmalloc	function
(	O
plen	long
+	O
tlen	long
+	O
blen	long
+	O
olen	long
+	O
slen	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
bakname	pointer
,	O
p	pointer
,	O
plen	long
)	O
;	O
memcpy	function
(	O
bakname	pointer
+	O
plen	long
,	O
t	struct
,	O
tlen	long
)	O
;	O
memcpy	function
(	O
bakname	pointer
+	O
plen	long
+	O
tlen	long
,	O
b	struct
,	O
blen	long
)	O
;	O
memcpy	function
(	O
bakname	pointer
+	O
plen	long
+	O
tlen	long
+	O
blen	long
,	O
o	pointer
,	O
olen	long
)	O
;	O
memcpy	function
(	O
bakname	pointer
+	O
plen	long
+	O
tlen	long
+	O
blen	long
+	O
olen	long
,	O
s	enum
,	O
slen	long
+	O
1	int
)	O
;	O
if	O
(	O
(	O
origprae	pointer
&&	O
(	O
contains_slash	function
(	O
origprae	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
origprae	pointer
)	O
)	O
||	O
contains_slash	function
(	O
to	pointer
)	O
)	O
)	O
||	O
(	O
origbase	pointer
&&	O
contains_slash	function
(	O
origbase	pointer
)	O
)	O
)	O
try_makedirs_errno	int
=	O
ENOENT	int
;	O
}	O
else	O
{	O
bakname	pointer
=	O
find_backup_file_name	function
(	O
to	pointer
,	O
backup_type	enum
)	O
;	O
if	O
(	O
!	O
bakname	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
to_st	pointer
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	function
(	O
"Creating empty file %s\n"	pointer
,	O
quotearg	function
(	O
bakname	pointer
)	O
)	O
;	O
try_makedirs_errno	int
=	O
ENOENT	int
;	O
unlink	function
(	O
bakname	pointer
)	O
;	O
while	O
(	O
(	O
fd	int
=	O
creat	function
(	O
bakname	pointer
,	O
0666	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
try_makedirs_errno	int
)	O
pfatal	function
(	O
"Can't create file %s"	pointer
,	O
quotearg	function
(	O
bakname	pointer
)	O
)	O
;	O
makedirs	function
(	O
bakname	pointer
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
}	O
if	O
(	O
close	pointer
(	O
fd	int
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't close file %s"	pointer
,	O
quotearg	function
(	O
bakname	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
leave_original	bool
)	O
create_backup_copy	function
(	O
to	pointer
,	O
bakname	pointer
,	O
to_st	pointer
,	O
try_makedirs_errno	int
==	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	function
(	O
"Renaming file %s to %s\n"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
to	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
bakname	pointer
)	O
)	O
;	O
while	O
(	O
rename	function
(	O
to	pointer
,	O
bakname	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
try_makedirs_errno	int
)	O
{	O
makedirs	function
(	O
bakname	pointer
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
errno	O
==	O
EXDEV	int
)	O
{	O
create_backup_copy	function
(	O
to	pointer
,	O
bakname	pointer
,	O
to_st	pointer
,	O
try_makedirs_errno	int
==	O
0	int
)	O
;	O
unlink	function
(	O
to	pointer
)	O
;	O
break	O
;	O
}	O
else	O
pfatal	function
(	O
"Can't rename file %s to %s"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
to	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
bakname	pointer
)	O
)	O
;	O
}	O
}	O
free	function
(	O
bakname	pointer
)	O
;	O
}	O
}	O
void	O
move_file	function
(	O
char	O
const	O
*	O
from	pointer
,	O
int	O
*	O
from_needs_removal	pointer
,	O
struct	O
stat	struct
const	O
*	O
fromst	pointer
,	O
char	O
const	O
*	O
to	pointer
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
struct	O
stat	struct
to_st	pointer
;	O
int	O
to_errno	int
;	O
to_errno	int
=	O
lstat	function
(	O
to	pointer
,	O
&	O
to_st	pointer
)	O
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
if	O
(	O
backup	bool
)	O
create_backup	function
(	O
to	pointer
,	O
to_errno	int
?	O
NULL	O
:	O
&	O
to_st	pointer
,	O
false	int
)	O
;	O
if	O
(	O
!	O
to_errno	int
)	O
insert_file_id	function
(	O
&	O
to_st	pointer
,	O
OVERWRITTEN	int
)	O
;	O
if	O
(	O
from	pointer
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
bool	bool
to_dir_known_to_exist	bool
=	O
false	int
;	O
char	O
*	O
buffer	pointer
=	O
xmalloc	function
(	O
PATH_MAX	int
)	O
;	O
int	O
fd	int
,	O
size	pointer
=	O
0	int
,	O
i	int
;	O
if	O
(	O
(	O
fd	int
=	O
open	function
(	O
from	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
<	O
0	int
)	O
pfatal	function
(	O
"Can't reopen file %s"	pointer
,	O
quotearg	function
(	O
from	pointer
)	O
)	O
;	O
while	O
(	O
(	O
i	int
=	O
read	pointer
(	O
fd	int
,	O
buffer	pointer
+	O
size	pointer
,	O
PATH_MAX	int
-	O
size	pointer
)	O
)	O
>	O
0	int
)	O
size	pointer
+=	O
i	int
;	O
if	O
(	O
i	int
!=	O
0	int
||	O
close	pointer
(	O
fd	int
)	O
!=	O
0	int
)	O
read_fatal	function
(	O
)	O
;	O
buffer	pointer
[	O
size	pointer
]	O
=	O
0	int
;	O
if	O
(	O
!	O
backup	bool
)	O
{	O
if	O
(	O
unlink	function
(	O
to	pointer
)	O
==	O
0	int
)	O
to_dir_known_to_exist	bool
=	O
true	int
;	O
}	O
if	O
(	O
symlink	function
(	O
buffer	pointer
,	O
to	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
&&	O
!	O
to_dir_known_to_exist	bool
)	O
makedirs	function
(	O
to	pointer
)	O
;	O
if	O
(	O
symlink	function
(	O
buffer	pointer
,	O
to	pointer
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't create %s %s"	pointer
,	O
"symbolic link"	pointer
,	O
to	pointer
)	O
;	O
}	O
free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
lstat	function
(	O
to	pointer
,	O
&	O
to_st	pointer
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't get file attributes of %s %s"	pointer
,	O
"symbolic link"	pointer
,	O
to	pointer
)	O
;	O
insert_file_id	function
(	O
&	O
to_st	pointer
,	O
CREATED	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	function
(	O
"Renaming file %s to %s\n"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
from	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
to	pointer
)	O
)	O
;	O
if	O
(	O
rename	function
(	O
from	pointer
,	O
to	pointer
)	O
!=	O
0	int
)	O
{	O
bool	bool
to_dir_known_to_exist	bool
=	O
false	int
;	O
if	O
(	O
errno	O
==	O
ENOENT	int
&&	O
(	O
to_errno	int
==	O
-	O
1	int
||	O
to_errno	int
==	O
ENOENT	int
)	O
)	O
{	O
makedirs	function
(	O
to	pointer
)	O
;	O
to_dir_known_to_exist	bool
=	O
true	int
;	O
if	O
(	O
rename	function
(	O
from	pointer
,	O
to	pointer
)	O
==	O
0	int
)	O
goto	O
rename_succeeded	O
;	O
}	O
if	O
(	O
errno	O
==	O
EXDEV	int
)	O
{	O
struct	O
stat	struct
tost	struct
;	O
if	O
(	O
!	O
backup	bool
)	O
{	O
if	O
(	O
unlink	function
(	O
to	pointer
)	O
==	O
0	int
)	O
to_dir_known_to_exist	bool
=	O
true	int
;	O
else	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
pfatal	function
(	O
"Can't remove file %s"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
}	O
copy_file	function
(	O
from	pointer
,	O
to	pointer
,	O
&	O
tost	struct
,	O
0	int
,	O
mode	int
,	O
to_dir_known_to_exist	bool
)	O
;	O
insert_file_id	function
(	O
&	O
tost	struct
,	O
CREATED	int
)	O
;	O
return	O
;	O
}	O
pfatal	function
(	O
"Can't rename file %s to %s"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
from	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
to	pointer
)	O
)	O
;	O
}	O
rename_succeeded	O
:	O
insert_file_id	function
(	O
fromst	pointer
,	O
CREATED	int
)	O
;	O
if	O
(	O
(	O
0	int
<	O
to_errno	int
||	O
(	O
to_errno	int
==	O
0	int
&&	O
to_st	pointer
.	O
st_nlink	long
<=	O
1	int
)	O
)	O
&&	O
from_needs_removal	pointer
)	O
*	O
from_needs_removal	pointer
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
backup	bool
)	O
{	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	function
(	O
"Removing file %s\n"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
if	O
(	O
unlink	function
(	O
to	pointer
)	O
!=	O
0	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
pfatal	function
(	O
"Can't remove file %s"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
}	O
}	O
int	O
create_file	function
(	O
char	O
const	O
*	O
file	pointer
,	O
int	O
open_flags	int
,	O
mode_t	int
mode	int
,	O
bool	bool
to_dir_known_to_exist	bool
)	O
{	O
int	O
try_makedirs_errno	int
=	O
to_dir_known_to_exist	bool
?	O
0	int
:	O
ENOENT	int
;	O
int	O
fd	int
;	O
mode	int
|=	O
S_IRUSR	O
|	O
S_IWUSR	O
;	O
mode	int
&=	O
~	O
(	O
S_IXUSR	O
|	O
S_IXGRP	O
|	O
S_IXOTH	O
)	O
;	O
do	O
{	O
if	O
(	O
!	O
(	O
O_CREAT	int
&&	O
O_TRUNC	int
)	O
)	O
close	pointer
(	O
creat	function
(	O
file	pointer
,	O
mode	int
)	O
)	O
;	O
fd	int
=	O
open	function
(	O
file	pointer
,	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
open_flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
char	O
*	O
f	struct
;	O
if	O
(	O
errno	O
!=	O
try_makedirs_errno	int
)	O
pfatal	function
(	O
"Can't create file %s"	pointer
,	O
quotearg	function
(	O
file	pointer
)	O
)	O
;	O
f	struct
=	O
xstrdup	function
(	O
file	pointer
)	O
;	O
makedirs	function
(	O
f	struct
)	O
;	O
free	function
(	O
f	struct
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
fd	int
<	O
0	int
)	O
;	O
return	O
fd	int
;	O
}	O
static	O
void	O
copy_to_fd	function
(	O
const	O
char	O
*	O
from	pointer
,	O
int	O
tofd	int
)	O
{	O
int	O
fromfd	int
;	O
ssize_t	long
i	int
;	O
if	O
(	O
(	O
fromfd	int
=	O
open	function
(	O
from	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
<	O
0	int
)	O
pfatal	function
(	O
"Can't reopen file %s"	pointer
,	O
quotearg	function
(	O
from	pointer
)	O
)	O
;	O
while	O
(	O
(	O
i	int
=	O
read	pointer
(	O
fromfd	int
,	O
buf	pointer
,	O
bufsize	long
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
(	O
ssize_t	long
)	O
-	O
1	int
)	O
read_fatal	function
(	O
)	O
;	O
if	O
(	O
full_write	function
(	O
tofd	int
,	O
buf	pointer
,	O
i	int
)	O
!=	O
i	int
)	O
write_fatal	function
(	O
)	O
;	O
}	O
if	O
(	O
close	pointer
(	O
fromfd	int
)	O
!=	O
0	int
)	O
read_fatal	function
(	O
)	O
;	O
}	O
void	O
copy_file	function
(	O
char	O
const	O
*	O
from	pointer
,	O
char	O
const	O
*	O
to	pointer
,	O
struct	O
stat	struct
*	O
tost	struct
,	O
int	O
to_flags	int
,	O
mode_t	int
mode	int
,	O
bool	bool
to_dir_known_to_exist	bool
)	O
{	O
int	O
tofd	int
;	O
if	O
(	O
debug	int
&	O
4	int
)	O
say	function
(	O
"Copying %s %s to %s\n"	pointer
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	pointer
:	O
"file"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
from	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
to	pointer
)	O
)	O
;	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
char	O
*	O
buffer	pointer
=	O
xmalloc	function
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
readlink	function
(	O
from	pointer
,	O
buffer	pointer
,	O
PATH_MAX	int
)	O
<	O
0	int
)	O
pfatal	function
(	O
"Can't read %s %s"	pointer
,	O
"symbolic link"	pointer
,	O
from	pointer
)	O
;	O
if	O
(	O
symlink	function
(	O
buffer	pointer
,	O
to	pointer
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't create %s %s"	pointer
,	O
"symbolic link"	pointer
,	O
to	pointer
)	O
;	O
if	O
(	O
tost	struct
&&	O
lstat	function
(	O
to	pointer
,	O
tost	struct
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't get file attributes of %s %s"	pointer
,	O
"symbolic link"	pointer
,	O
to	pointer
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
;	O
tofd	int
=	O
create_file	function
(	O
to	pointer
,	O
O_WRONLY	int
|	O
O_BINARY	int
|	O
to_flags	int
,	O
mode	int
,	O
to_dir_known_to_exist	bool
)	O
;	O
copy_to_fd	function
(	O
from	pointer
,	O
tofd	int
)	O
;	O
if	O
(	O
tost	struct
&&	O
fstat	function
(	O
tofd	int
,	O
tost	struct
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't get file attributes of %s %s"	pointer
,	O
"file"	pointer
,	O
to	pointer
)	O
;	O
if	O
(	O
close	pointer
(	O
tofd	int
)	O
!=	O
0	int
)	O
write_fatal	function
(	O
)	O
;	O
}	O
}	O
void	O
append_to_file	function
(	O
char	O
const	O
*	O
from	pointer
,	O
char	O
const	O
*	O
to	pointer
)	O
{	O
int	O
tofd	int
;	O
if	O
(	O
(	O
tofd	int
=	O
open	function
(	O
to	pointer
,	O
O_WRONLY	int
|	O
O_BINARY	int
|	O
O_APPEND	int
)	O
)	O
<	O
0	int
)	O
pfatal	function
(	O
"Can't reopen file %s"	pointer
,	O
quotearg	function
(	O
to	pointer
)	O
)	O
;	O
copy_to_fd	function
(	O
from	pointer
,	O
tofd	int
)	O
;	O
if	O
(	O
close	pointer
(	O
tofd	int
)	O
!=	O
0	int
)	O
write_fatal	function
(	O
)	O
;	O
}	O
static	O
char	O
const	O
DEV_NULL	array
[	O
]	O
=	O
NULL_DEVICE	pointer
;	O
static	O
char	O
const	O
RCSSUFFIX	array
[	O
]	O
=	O
",v"	pointer
;	O
static	O
char	O
const	O
CHECKOUT	array
[	O
]	O
=	O
"co %s"	pointer
;	O
static	O
char	O
const	O
CHECKOUT_LOCKED	array
[	O
]	O
=	O
"co -l %s"	pointer
;	O
static	O
char	O
const	O
RCSDIFF1	array
[	O
]	O
=	O
"rcsdiff %s"	pointer
;	O
static	O
char	O
const	O
SCCSPREFIX	array
[	O
]	O
=	O
"s."	pointer
;	O
static	O
char	O
const	O
GET	array
[	O
]	O
=	O
"get "	pointer
;	O
static	O
char	O
const	O
GET_LOCKED	array
[	O
]	O
=	O
"get -e "	pointer
;	O
static	O
char	O
const	O
SCCSDIFF1	array
[	O
]	O
=	O
"get -p "	pointer
;	O
static	O
char	O
const	O
SCCSDIFF2	array
[	O
]	O
=	O
"|diff - %s"	pointer
;	O
static	O
char	O
const	O
CLEARTOOL_CO	array
[	O
]	O
=	O
"cleartool co -unr -nc "	pointer
;	O
static	O
char	O
const	O
PERFORCE_CO	array
[	O
]	O
=	O
"p4 edit "	pointer
;	O
static	O
size_t	long
quote_system_arg	function
(	O
char	O
*	O
quoted	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
q	pointer
=	O
quotearg_style	function
(	O
shell_quoting_style	int
,	O
arg	pointer
)	O
;	O
size_t	long
len	long
=	O
strlen	function
(	O
q	pointer
)	O
;	O
if	O
(	O
quoted	pointer
)	O
memcpy	function
(	O
quoted	pointer
,	O
q	pointer
,	O
len	long
+	O
1	int
)	O
;	O
return	O
len	long
;	O
}	O
char	O
const	O
*	O
version_controller	function
(	O
char	O
const	O
*	O
filename	pointer
,	O
bool	bool
readonly	bool
,	O
struct	O
stat	struct
const	O
*	O
filestat	pointer
,	O
char	O
*	O
*	O
getbuf	pointer
,	O
char	O
*	O
*	O
diffbuf	pointer
)	O
{	O
struct	O
stat	struct
cstat	struct
;	O
char	O
*	O
dir	pointer
=	O
dir_name	function
(	O
filename	pointer
)	O
;	O
char	O
*	O
filebase	pointer
=	O
base_name	function
(	O
filename	pointer
)	O
;	O
char	O
const	O
*	O
dotslash	pointer
=	O
*	O
filename	pointer
==	O
'-'	O
?	O
"./"	pointer
:	O
""	pointer
;	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
dir	pointer
)	O
+	O
1	int
;	O
size_t	long
maxfixlen	long
=	O
sizeof	O
"SCCS/"	pointer
-	O
1	int
+	O
sizeof	O
SCCSPREFIX	array
-	O
1	int
;	O
size_t	long
maxtrysize	long
=	O
dirlen	long
+	O
strlen	function
(	O
filebase	pointer
)	O
+	O
maxfixlen	long
+	O
1	int
;	O
size_t	long
quotelen	long
=	O
quote_system_arg	function
(	O
0	int
,	O
dir	pointer
)	O
+	O
quote_system_arg	function
(	O
0	int
,	O
filebase	pointer
)	O
;	O
size_t	long
maxgetsize	long
=	O
sizeof	O
CLEARTOOL_CO	array
+	O
quotelen	long
+	O
maxfixlen	long
;	O
size_t	long
maxdiffsize	long
=	O
(	O
sizeof	O
SCCSDIFF1	array
+	O
sizeof	O
SCCSDIFF2	array
+	O
sizeof	O
DEV_NULL	array
-	O
1	int
+	O
2	int
*	O
quotelen	long
+	O
maxfixlen	long
)	O
;	O
char	O
*	O
trybuf	pointer
=	O
xmalloc	function
(	O
maxtrysize	long
)	O
;	O
char	O
const	O
*	O
r	pointer
=	O
0	int
;	O
sprintf	function
(	O
trybuf	pointer
,	O
"%s/"	pointer
,	O
dir	pointer
)	O
;	O
if	O
(	O
(	O
try2	O
(	O
"RCS/%s%s"	pointer
,	O
filebase	pointer
,	O
RCSSUFFIX	array
)	O
||	O
try1	O
(	O
"RCS/%s"	pointer
,	O
filebase	pointer
)	O
||	O
try2	O
(	O
"%s%s"	pointer
,	O
filebase	pointer
,	O
RCSSUFFIX	array
)	O
)	O
&&	O
!	O
(	O
filestat	pointer
&&	O
filestat	pointer
->	O
st_dev	long
==	O
cstat	struct
.	O
st_dev	long
&&	O
filestat	pointer
->	O
st_ino	long
==	O
cstat	struct
.	O
st_ino	long
)	O
)	O
{	O
if	O
(	O
getbuf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
getbuf	pointer
=	O
xmalloc	function
(	O
maxgetsize	long
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
readonly	bool
?	O
CHECKOUT	array
:	O
CHECKOUT_LOCKED	array
,	O
dotslash	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
filename	pointer
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
diffbuf	pointer
=	O
xmalloc	function
(	O
maxdiffsize	long
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
RCSDIFF1	array
,	O
dotslash	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
filename	pointer
)	O
;	O
*	O
p	pointer
++	O
=	O
'>'	O
;	O
strcpy	function
(	O
p	pointer
,	O
DEV_NULL	array
)	O
;	O
}	O
r	pointer
=	O
"RCS"	pointer
;	O
}	O
else	O
if	O
(	O
try2	O
(	O
"SCCS/%s%s"	pointer
,	O
SCCSPREFIX	array
,	O
filebase	pointer
)	O
||	O
try2	O
(	O
"%s%s"	pointer
,	O
SCCSPREFIX	array
,	O
filebase	pointer
)	O
)	O
{	O
if	O
(	O
getbuf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
getbuf	pointer
=	O
xmalloc	function
(	O
maxgetsize	long
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
readonly	bool
?	O
GET	array
:	O
GET_LOCKED	array
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
trybuf	pointer
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
diffbuf	pointer
=	O
xmalloc	function
(	O
maxdiffsize	long
)	O
;	O
strcpy	function
(	O
p	pointer
,	O
SCCSDIFF1	array
)	O
;	O
p	pointer
+=	O
sizeof	O
SCCSDIFF1	array
-	O
1	int
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
trybuf	pointer
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
SCCSDIFF2	array
,	O
dotslash	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
filename	pointer
)	O
;	O
*	O
p	pointer
++	O
=	O
'>'	O
;	O
strcpy	function
(	O
p	pointer
,	O
DEV_NULL	array
)	O
;	O
}	O
r	pointer
=	O
"SCCS"	pointer
;	O
}	O
else	O
if	O
(	O
!	O
readonly	bool
&&	O
filestat	pointer
&&	O
try1	O
(	O
"%s@@"	pointer
,	O
filebase	pointer
)	O
&&	O
S_ISDIR	O
(	O
cstat	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
getbuf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
getbuf	pointer
=	O
xmalloc	function
(	O
maxgetsize	long
)	O
;	O
strcpy	function
(	O
p	pointer
,	O
CLEARTOOL_CO	array
)	O
;	O
p	pointer
+=	O
sizeof	O
CLEARTOOL_CO	array
-	O
1	int
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
filename	pointer
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	pointer
)	O
*	O
diffbuf	pointer
=	O
0	int
;	O
r	pointer
=	O
"ClearCase"	pointer
;	O
}	O
else	O
if	O
(	O
!	O
readonly	bool
&&	O
filestat	pointer
&&	O
(	O
getenv	function
(	O
"P4PORT"	pointer
)	O
||	O
getenv	function
(	O
"P4USER"	pointer
)	O
||	O
getenv	function
(	O
"P4CONFIG"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
getbuf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
getbuf	pointer
=	O
xmalloc	function
(	O
maxgetsize	long
)	O
;	O
strcpy	function
(	O
p	pointer
,	O
PERFORCE_CO	array
)	O
;	O
p	pointer
+=	O
sizeof	O
PERFORCE_CO	array
-	O
1	int
;	O
p	pointer
+=	O
quote_system_arg	function
(	O
p	pointer
,	O
filename	pointer
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
diffbuf	pointer
)	O
*	O
diffbuf	pointer
=	O
0	int
;	O
r	pointer
=	O
"Perforce"	pointer
;	O
}	O
free	function
(	O
trybuf	pointer
)	O
;	O
free	function
(	O
filebase	pointer
)	O
;	O
free	function
(	O
dir	pointer
)	O
;	O
return	O
r	pointer
;	O
}	O
bool	bool
version_get	function
(	O
char	O
const	O
*	O
filename	pointer
,	O
char	O
const	O
*	O
cs	short
,	O
bool	bool
exists	bool
,	O
bool	bool
readonly	bool
,	O
char	O
const	O
*	O
getbuf	pointer
,	O
struct	O
stat	struct
*	O
filestat	pointer
)	O
{	O
if	O
(	O
patch_get	int
<	O
0	int
)	O
{	O
ask	function
(	O
"Get file %s from %s%s? [y] "	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
,	O
cs	short
,	O
readonly	bool
?	O
""	pointer
:	O
" with lock"	pointer
)	O
;	O
if	O
(	O
*	O
buf	pointer
==	O
'n'	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
dry_run	bool
)	O
{	O
if	O
(	O
!	O
exists	bool
)	O
fatal	function
(	O
"can't do dry run on nonexistent version-controlled file %s; invoke '%s' and try again"	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
,	O
getbuf	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"Getting file %s from %s%s...\n"	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
,	O
cs	short
,	O
readonly	bool
?	O
""	pointer
:	O
" with lock"	pointer
)	O
;	O
if	O
(	O
systemic	function
(	O
getbuf	pointer
)	O
!=	O
0	int
)	O
fatal	function
(	O
"Can't get file %s from %s"	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
,	O
cs	short
)	O
;	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
filestat	pointer
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"%s"	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
savebuf	function
(	O
char	O
const	O
*	O
s	enum
,	O
size_t	long
size	pointer
)	O
{	O
char	O
*	O
rv	pointer
;	O
if	O
(	O
!	O
size	pointer
)	O
return	O
NULL	O
;	O
rv	pointer
=	O
malloc	function
(	O
size	pointer
)	O
;	O
if	O
(	O
!	O
rv	pointer
)	O
{	O
if	O
(	O
!	O
using_plan_a	bool
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
else	O
memcpy	function
(	O
rv	pointer
,	O
s	enum
,	O
size	pointer
)	O
;	O
return	O
rv	pointer
;	O
}	O
char	O
*	O
savestr	function
(	O
char	O
const	O
*	O
s	enum
)	O
{	O
return	O
savebuf	function
(	O
s	enum
,	O
strlen	function
(	O
s	enum
)	O
+	O
1	int
)	O
;	O
}	O
void	O
remove_prefix	function
(	O
char	O
*	O
p	pointer
,	O
size_t	long
prefixlen	long
)	O
{	O
char	O
const	O
*	O
s	enum
=	O
p	pointer
+	O
prefixlen	long
;	O
while	O
(	O
(	O
*	O
p	pointer
++	O
=	O
*	O
s	enum
++	O
)	O
)	O
;	O
}	O
char	O
*	O
format_linenum	function
(	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
,	O
lin	long
n	int
)	O
{	O
char	O
*	O
p	pointer
=	O
numbuf	array
+	O
LINENUM_LENGTH_BOUND	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
do	O
*	O
--	O
p	pointer
=	O
'0'	O
-	O
(	O
int	O
)	O
(	O
n	int
%	O
10	int
)	O
;	O
while	O
(	O
(	O
n	int
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
*	O
--	O
p	pointer
=	O
'-'	O
;	O
}	O
else	O
{	O
do	O
*	O
--	O
p	pointer
=	O
'0'	O
+	O
(	O
int	O
)	O
(	O
n	int
%	O
10	int
)	O
;	O
while	O
(	O
(	O
n	int
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
fatal	function
(	O
char	O
const	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: **** "	pointer
,	O
program_name	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
fatal_exit	function
(	O
0	int
)	O
;	O
}	O
void	O
xalloc_die	function
(	O
void	O
)	O
{	O
fatal	function
(	O
"out of memory"	pointer
)	O
;	O
}	O
void	O
read_fatal	function
(	O
void	O
)	O
{	O
pfatal	function
(	O
"read error"	pointer
)	O
;	O
}	O
void	O
write_fatal	function
(	O
void	O
)	O
{	O
pfatal	function
(	O
"write error"	pointer
)	O
;	O
}	O
void	O
pfatal	function
(	O
char	O
const	O
*	O
format	pointer
,	O
...	O
)	O
{	O
int	O
errnum	int
=	O
errno	O
;	O
va_list	array
args	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: **** "	pointer
,	O
program_name	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
errno	O
=	O
errnum	int
;	O
perror	function
(	O
" "	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
fatal_exit	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
vsay	function
(	O
char	O
const	O
*	O
format	pointer
,	O
va_list	array
args	array
)	O
{	O
vfprintf	function
(	O
stdout	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
say	function
(	O
char	O
const	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vsay	function
(	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
void	O
ask	function
(	O
char	O
const	O
*	O
format	pointer
,	O
...	O
)	O
{	O
static	O
int	O
ttyfd	int
=	O
-	O
2	int
;	O
ssize_t	long
r	pointer
;	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
stdout	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
ttyfd	int
==	O
-	O
2	int
)	O
{	O
ttyfd	int
=	O
(	O
posixly_correct	bool
||	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
?	O
open	function
(	O
TTY_DEVICE	pointer
,	O
O_RDONLY	int
)	O
:	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
ttyfd	int
<	O
0	int
)	O
{	O
printf	function
(	O
"\n"	pointer
)	O
;	O
buf	pointer
[	O
0	int
]	O
=	O
'\n'	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
size_t	long
s	enum
=	O
0	int
;	O
while	O
(	O
(	O
r	pointer
=	O
read	pointer
(	O
ttyfd	int
,	O
buf	pointer
+	O
s	enum
,	O
bufsize	long
-	O
1	int
-	O
s	enum
)	O
)	O
==	O
bufsize	long
-	O
1	int
-	O
s	enum
&&	O
buf	pointer
[	O
bufsize	long
-	O
2	int
]	O
!=	O
'\n'	O
)	O
{	O
s	enum
=	O
bufsize	long
-	O
1	int
;	O
bufsize	long
*=	O
2	int
;	O
buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
if	O
(	O
r	pointer
==	O
0	int
)	O
printf	function
(	O
"EOF\n"	pointer
)	O
;	O
else	O
if	O
(	O
r	pointer
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"tty read failed"	pointer
)	O
;	O
ignore_value	O
(	O
close	pointer
(	O
ttyfd	int
)	O
)	O
;	O
ttyfd	int
=	O
-	O
1	int
;	O
r	pointer
=	O
0	int
;	O
}	O
buf	pointer
[	O
s	enum
+	O
r	pointer
]	O
=	O
'\0'	O
;	O
}	O
}	O
bool	bool
ok_to_reverse	function
(	O
char	O
const	O
*	O
format	pointer
,	O
...	O
)	O
{	O
bool	bool
r	pointer
=	O
false	int
;	O
if	O
(	O
noreverse	bool
||	O
!	O
(	O
force	bool
&&	O
verbosity	enum
==	O
SILENT	int
)	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vsay	function
(	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
if	O
(	O
noreverse	bool
)	O
{	O
say	function
(	O
"  Skipping patch.\n"	pointer
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
force	bool
)	O
{	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
say	function
(	O
"  Applying it anyway.\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
batch	bool
)	O
{	O
say	function
(	O
reverse	bool
?	O
"  Ignoring -R.\n"	pointer
:	O
"  Assuming -R.\n"	pointer
)	O
;	O
r	pointer
=	O
true	int
;	O
}	O
else	O
{	O
ask	function
(	O
reverse	bool
?	O
"  Ignore -R? [n] "	pointer
:	O
"  Assume -R? [n] "	pointer
)	O
;	O
r	pointer
=	O
*	O
buf	pointer
==	O
'y'	O
;	O
if	O
(	O
!	O
r	pointer
)	O
{	O
ask	function
(	O
"Apply anyway? [n] "	pointer
)	O
;	O
if	O
(	O
*	O
buf	pointer
!=	O
'y'	O
)	O
{	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
say	function
(	O
"Skipping patch.\n"	pointer
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
}	O
}	O
}	O
return	O
r	pointer
;	O
}	O
static	O
int	O
const	O
sigs	array
[	O
]	O
=	O
{	O
SIGHUP	int
,	O
SIGPIPE	int
,	O
SIGTERM	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
,	O
SIGINT	int
}	O
;	O
static	O
sigset_t	struct
initial_signal_mask	struct
;	O
static	O
sigset_t	struct
signals_to_block	struct
;	O
void	O
set_signals	function
(	O
bool	bool
reset	bool
)	O
{	O
int	O
i	int
;	O
struct	O
sigaction	struct
initial_act	struct
,	O
fatal_act	struct
;	O
fatal_act	struct
.	O
sa_handler	pointer
=	O
fatal_exit	function
;	O
sigemptyset	function
(	O
&	O
fatal_act	struct
.	O
sa_mask	struct
)	O
;	O
fatal_act	struct
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
!	O
reset	bool
)	O
{	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
sigemptyset	function
(	O
&	O
signals_to_block	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_SIGS	O
;	O
i	int
++	O
)	O
{	O
bool	bool
ignoring_signal	bool
;	O
if	O
(	O
sigaction	struct
(	O
sigs	array
[	O
i	int
]	O
,	O
(	O
struct	O
sigaction	struct
*	O
)	O
0	int
,	O
&	O
initial_act	struct
)	O
!=	O
0	int
)	O
continue	O
;	O
ignoring_signal	bool
=	O
initial_act	struct
.	O
sa_handler	pointer
==	O
SIG_IGN	O
;	O
if	O
(	O
!	O
ignoring_signal	bool
)	O
{	O
sigaddset	function
(	O
&	O
signals_to_block	struct
,	O
sigs	array
[	O
i	int
]	O
)	O
;	O
setup_handler	O
(	O
sigs	array
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
initial_signal_mask	struct
,	O
(	O
sigset_t	struct
*	O
)	O
0	int
)	O
;	O
}	O
}	O
void	O
ignore_signals	function
(	O
void	O
)	O
{	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
signals_to_block	struct
,	O
&	O
initial_signal_mask	struct
)	O
;	O
}	O
void	O
exit_with_signal	function
(	O
int	O
sig	int
)	O
{	O
sigset_t	struct
s	enum
;	O
signal	function
(	O
sig	int
,	O
SIG_DFL	O
)	O
;	O
sigemptyset	function
(	O
&	O
s	enum
)	O
;	O
sigaddset	function
(	O
&	O
s	enum
,	O
sig	int
)	O
;	O
sigprocmask	function
(	O
SIG_UNBLOCK	int
,	O
&	O
s	enum
,	O
(	O
sigset_t	struct
*	O
)	O
0	int
)	O
;	O
raise	function
(	O
sig	int
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
int	O
systemic	function
(	O
char	O
const	O
*	O
command	pointer
)	O
{	O
if	O
(	O
debug	int
&	O
8	int
)	O
say	function
(	O
"+ %s\n"	pointer
,	O
command	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
return	O
system	function
(	O
command	pointer
)	O
;	O
}	O
static	O
char	O
*	O
replace_slashes	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
f	struct
;	O
char	O
*	O
last_location_replaced	pointer
=	O
0	int
;	O
char	O
const	O
*	O
component_start	pointer
;	O
for	O
(	O
f	struct
=	O
filename	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
filename	pointer
)	O
;	O
ISSLASH	O
(	O
*	O
f	struct
)	O
;	O
f	struct
++	O
)	O
;	O
component_start	pointer
=	O
f	struct
;	O
for	O
(	O
;	O
*	O
f	struct
;	O
f	struct
++	O
)	O
if	O
(	O
ISSLASH	O
(	O
*	O
f	struct
)	O
)	O
{	O
char	O
*	O
slash	pointer
=	O
f	struct
;	O
while	O
(	O
ISSLASH	O
(	O
f	struct
[	O
1	int
]	O
)	O
)	O
f	struct
++	O
;	O
if	O
(	O
!	O
f	struct
[	O
1	int
]	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
slash	pointer
-	O
component_start	pointer
<=	O
2	int
&&	O
component_start	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
slash	pointer
[	O
-	O
1	int
]	O
==	O
'.'	O
)	O
)	O
{	O
*	O
slash	pointer
=	O
'\0'	O
;	O
last_location_replaced	pointer
=	O
slash	pointer
;	O
}	O
component_start	pointer
=	O
f	struct
+	O
1	int
;	O
}	O
return	O
last_location_replaced	pointer
;	O
}	O
static	O
void	O
makedirs	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
*	O
filename	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
char	O
*	O
f	struct
;	O
char	O
*	O
flim	pointer
=	O
replace_slashes	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
flim	pointer
)	O
{	O
for	O
(	O
f	struct
=	O
filename	pointer
;	O
f	struct
<=	O
flim	pointer
;	O
f	struct
++	O
)	O
if	O
(	O
!	O
*	O
f	struct
)	O
{	O
mkdir	function
(	O
filename	pointer
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IXUSR	O
|	O
S_IRGRP	O
|	O
S_IWGRP	O
|	O
S_IXGRP	O
|	O
S_IROTH	O
|	O
S_IWOTH	O
|	O
S_IXOTH	O
)	O
;	O
*	O
f	struct
=	O
'/'	O
;	O
}	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
}	O
void	O
removedirs	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
*	O
filename	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
i	int
!=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
ISSLASH	O
(	O
filename	pointer
[	O
i	int
]	O
)	O
&&	O
!	O
(	O
ISSLASH	O
(	O
filename	pointer
[	O
i	int
-	O
1	int
]	O
)	O
||	O
(	O
filename	pointer
[	O
i	int
-	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
i	int
==	O
1	int
||	O
ISSLASH	O
(	O
filename	pointer
[	O
i	int
-	O
2	int
]	O
)	O
||	O
(	O
filename	pointer
[	O
i	int
-	O
2	int
]	O
==	O
'.'	O
&&	O
(	O
i	int
==	O
2	int
||	O
ISSLASH	O
(	O
filename	pointer
[	O
i	int
-	O
3	int
]	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
{	O
filename	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
rmdir	function
(	O
filename	pointer
)	O
==	O
0	int
&&	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"Removed empty directory %s\n"	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
)	O
;	O
filename	pointer
[	O
i	int
]	O
=	O
'/'	O
;	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
}	O
static	O
struct	O
timespec	struct
initial_time	struct
;	O
void	O
init_time	function
(	O
void	O
)	O
{	O
gettime	function
(	O
&	O
initial_time	struct
)	O
;	O
}	O
static	O
char	O
*	O
parse_c_string	function
(	O
char	O
const	O
*	O
s	enum
,	O
char	O
const	O
*	O
*	O
endp	pointer
)	O
{	O
char	O
*	O
u	pointer
,	O
*	O
v	pointer
;	O
assert	O
(	O
*	O
s	enum
==	O
'"'	O
)	O
;	O
s	enum
++	O
;	O
u	pointer
=	O
v	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
s	enum
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	char
=	O
*	O
s	enum
++	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
0	int
:	O
goto	O
fail	O
;	O
case	O
'"'	O
:	O
*	O
v	pointer
++	O
=	O
0	int
;	O
v	pointer
=	O
realloc	function
(	O
u	pointer
,	O
v	pointer
-	O
u	pointer
)	O
;	O
if	O
(	O
v	pointer
)	O
u	pointer
=	O
v	pointer
;	O
if	O
(	O
endp	pointer
)	O
*	O
endp	pointer
=	O
s	enum
;	O
return	O
u	pointer
;	O
case	O
'\\'	O
:	O
break	O
;	O
default	O
:	O
*	O
v	pointer
++	O
=	O
c	char
;	O
continue	O
;	O
}	O
c	char
=	O
*	O
s	enum
++	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'a'	O
:	O
c	char
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
c	char
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	char
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
c	char
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	char
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	char
=	O
'\t'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
c	char
=	O
'\v'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
case	O
'"'	O
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
{	O
int	O
acc	int
=	O
(	O
c	char
-	O
'0'	O
)	O
<<	O
6	int
;	O
c	char
=	O
*	O
s	enum
++	O
;	O
if	O
(	O
c	char
<	O
'0'	O
||	O
c	char
>	O
'7'	O
)	O
goto	O
fail	O
;	O
acc	int
|=	O
(	O
c	char
-	O
'0'	O
)	O
<<	O
3	int
;	O
c	char
=	O
*	O
s	enum
++	O
;	O
if	O
(	O
c	char
<	O
'0'	O
||	O
c	char
>	O
'7'	O
)	O
goto	O
fail	O
;	O
acc	int
|=	O
(	O
c	char
-	O
'0'	O
)	O
;	O
c	char
=	O
acc	int
;	O
break	O
;	O
}	O
default	O
:	O
goto	O
fail	O
;	O
}	O
*	O
v	pointer
++	O
=	O
c	char
;	O
}	O
fail	O
:	O
free	function
(	O
u	pointer
)	O
;	O
if	O
(	O
endp	pointer
)	O
*	O
endp	pointer
=	O
s	enum
;	O
return	O
NULL	O
;	O
}	O
static	O
bool	bool
strip_leading_slashes	function
(	O
char	O
*	O
name	pointer
,	O
int	O
strip_leading	int
)	O
{	O
int	O
s	enum
=	O
strip_leading	int
;	O
char	O
*	O
p	pointer
,	O
*	O
n	int
;	O
for	O
(	O
p	pointer
=	O
n	int
=	O
name	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
{	O
while	O
(	O
ISSLASH	O
(	O
p	pointer
[	O
1	int
]	O
)	O
)	O
p	pointer
++	O
;	O
if	O
(	O
strip_leading	int
<	O
0	int
||	O
--	O
s	enum
>=	O
0	int
)	O
n	int
=	O
p	pointer
+	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
strip_leading	int
<	O
0	int
||	O
s	enum
<=	O
0	int
)	O
&&	O
*	O
n	int
)	O
{	O
memmove	function
(	O
name	pointer
,	O
n	int
,	O
strlen	function
(	O
n	int
)	O
+	O
1	int
)	O
;	O
return	O
true	int
;	O
}	O
else	O
return	O
false	int
;	O
}	O
void	O
fetchname	function
(	O
char	O
const	O
*	O
at	pointer
,	O
int	O
strip_leading	int
,	O
char	O
*	O
*	O
pname	pointer
,	O
char	O
*	O
*	O
ptimestr	pointer
,	O
struct	O
timespec	struct
*	O
pstamp	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
t	struct
;	O
char	O
*	O
timestr	pointer
=	O
NULL	O
;	O
struct	O
timespec	struct
stamp	struct
;	O
stamp	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
stamp	struct
.	O
tv_nsec	long
=	O
0	int
;	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
at	pointer
)	O
)	O
at	pointer
++	O
;	O
if	O
(	O
debug	int
&	O
128	int
)	O
say	function
(	O
"fetchname %s %d\n"	pointer
,	O
at	pointer
,	O
strip_leading	int
)	O
;	O
if	O
(	O
*	O
at	pointer
==	O
'"'	O
)	O
{	O
name	pointer
=	O
parse_c_string	function
(	O
at	pointer
,	O
&	O
t	struct
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
if	O
(	O
debug	int
&	O
128	int
)	O
say	function
(	O
"ignoring malformed filename %s\n"	pointer
,	O
quotearg	function
(	O
at	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
t	struct
=	O
at	pointer
;	O
*	O
t	struct
;	O
t	struct
++	O
)	O
{	O
if	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct
)	O
)	O
{	O
char	O
const	O
*	O
u	pointer
=	O
t	struct
;	O
while	O
(	O
*	O
u	pointer
!=	O
'\t'	O
&&	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
u	pointer
[	O
1	int
]	O
)	O
)	O
u	pointer
++	O
;	O
if	O
(	O
*	O
u	pointer
!=	O
'\t'	O
&&	O
(	O
strchr	function
(	O
u	pointer
+	O
1	int
,	O
pstamp	pointer
?	O
'\t'	O
:	O
'\n'	O
)	O
)	O
)	O
continue	O
;	O
break	O
;	O
}	O
}	O
name	pointer
=	O
savebuf	function
(	O
at	pointer
,	O
t	struct
-	O
at	pointer
+	O
1	int
)	O
;	O
name	pointer
[	O
t	struct
-	O
at	pointer
]	O
=	O
0	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"/dev/null"	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
pstamp	pointer
)	O
{	O
pstamp	pointer
->	O
tv_sec	long
=	O
0	int
;	O
pstamp	pointer
->	O
tv_nsec	long
=	O
0	int
;	O
}	O
return	O
;	O
}	O
if	O
(	O
!	O
strip_leading_slashes	function
(	O
name	pointer
,	O
strip_leading	int
)	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ptimestr	pointer
)	O
{	O
char	O
const	O
*	O
u	pointer
=	O
t	struct
+	O
strlen	function
(	O
t	struct
)	O
;	O
if	O
(	O
u	pointer
!=	O
t	struct
&&	O
*	O
(	O
u	pointer
-	O
1	int
)	O
==	O
'\n'	O
)	O
u	pointer
--	O
;	O
if	O
(	O
u	pointer
!=	O
t	struct
&&	O
*	O
(	O
u	pointer
-	O
1	int
)	O
==	O
'\r'	O
)	O
u	pointer
--	O
;	O
timestr	pointer
=	O
savebuf	function
(	O
t	struct
,	O
u	pointer
-	O
t	struct
+	O
1	int
)	O
;	O
timestr	pointer
[	O
u	pointer
-	O
t	struct
]	O
=	O
0	int
;	O
}	O
if	O
(	O
*	O
t	struct
!=	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
pstamp	pointer
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
free	function
(	O
timestr	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
set_time	bool
|	O
set_utc	bool
)	O
get_date	O
(	O
&	O
stamp	struct
,	O
t	struct
,	O
&	O
initial_time	struct
)	O
;	O
else	O
{	O
const	O
struct	O
timespec	struct
lower	struct
=	O
{	O
-	O
25L	int
*	O
60	int
*	O
60	int
}	O
,	O
upper	struct
=	O
{	O
26L	int
*	O
60	int
*	O
60	int
}	O
;	O
if	O
(	O
get_date	O
(	O
&	O
stamp	struct
,	O
t	struct
,	O
&	O
initial_time	struct
)	O
&&	O
timespec_cmp	function
(	O
stamp	struct
,	O
lower	struct
)	O
>	O
0	int
&&	O
timespec_cmp	function
(	O
stamp	struct
,	O
upper	struct
)	O
<	O
0	int
)	O
{	O
stamp	struct
.	O
tv_sec	long
=	O
0	int
;	O
stamp	struct
.	O
tv_nsec	long
=	O
0	int
;	O
}	O
}	O
}	O
free	function
(	O
*	O
pname	pointer
)	O
;	O
*	O
pname	pointer
=	O
name	pointer
;	O
if	O
(	O
ptimestr	pointer
)	O
{	O
free	function
(	O
*	O
ptimestr	pointer
)	O
;	O
*	O
ptimestr	pointer
=	O
timestr	pointer
;	O
}	O
if	O
(	O
pstamp	pointer
)	O
*	O
pstamp	pointer
=	O
stamp	struct
;	O
}	O
char	O
*	O
parse_name	function
(	O
char	O
const	O
*	O
s	enum
,	O
int	O
strip_leading	int
,	O
char	O
const	O
*	O
*	O
endp	pointer
)	O
{	O
char	O
*	O
ret	pointer
;	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	enum
)	O
)	O
s	enum
++	O
;	O
if	O
(	O
*	O
s	enum
==	O
'"'	O
)	O
ret	pointer
=	O
parse_c_string	function
(	O
s	enum
,	O
endp	pointer
)	O
;	O
else	O
{	O
char	O
const	O
*	O
t	struct
;	O
for	O
(	O
t	struct
=	O
s	enum
;	O
*	O
t	struct
&&	O
!	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct
)	O
;	O
t	struct
++	O
)	O
;	O
ret	pointer
=	O
savebuf	function
(	O
s	enum
,	O
t	struct
-	O
s	enum
+	O
1	int
)	O
;	O
ret	pointer
[	O
t	struct
-	O
s	enum
]	O
=	O
0	int
;	O
if	O
(	O
endp	pointer
)	O
*	O
endp	pointer
=	O
t	struct
;	O
}	O
if	O
(	O
!	O
strip_leading_slashes	function
(	O
ret	pointer
,	O
strip_leading	int
)	O
)	O
{	O
free	function
(	O
ret	pointer
)	O
;	O
ret	pointer
=	O
NULL	O
;	O
}	O
return	O
ret	pointer
;	O
}	O
void	O
Fseek	function
(	O
FILE	struct
*	O
stream	pointer
,	O
file_offset	long
offset	long
,	O
int	O
ptrname	int
)	O
{	O
if	O
(	O
file_seek	O
(	O
stream	pointer
,	O
offset	long
,	O
ptrname	int
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"fseek"	pointer
)	O
;	O
}	O
int	O
make_tempfile	function
(	O
char	O
const	O
*	O
*	O
name	pointer
,	O
char	O
letter	char
,	O
char	O
const	O
*	O
real_name	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
int	O
try_makedirs_errno	int
=	O
ENOENT	int
;	O
char	O
*	O
template	pointer
;	O
if	O
(	O
real_name	pointer
)	O
{	O
char	O
*	O
dirname	pointer
,	O
*	O
basename	function
;	O
dirname	pointer
=	O
dir_name	function
(	O
real_name	pointer
)	O
;	O
basename	function
=	O
base_name	function
(	O
real_name	pointer
)	O
;	O
template	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
dirname	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
basename	function
)	O
+	O
9	int
)	O
;	O
sprintf	function
(	O
template	pointer
,	O
"%s/%s.%cXXXXXX"	pointer
,	O
dirname	pointer
,	O
basename	function
,	O
letter	char
)	O
;	O
free	function
(	O
dirname	pointer
)	O
;	O
free	function
(	O
basename	function
)	O
;	O
}	O
else	O
{	O
char	O
const	O
*	O
tmpdir	pointer
;	O
tmpdir	pointer
=	O
getenv	function
(	O
"TMPDIR"	pointer
)	O
;	O
if	O
(	O
!	O
tmpdir	pointer
)	O
tmpdir	pointer
=	O
getenv	function
(	O
"TMP"	pointer
)	O
;	O
if	O
(	O
!	O
tmpdir	pointer
)	O
tmpdir	pointer
=	O
getenv	function
(	O
"TEMP"	pointer
)	O
;	O
if	O
(	O
!	O
tmpdir	pointer
)	O
tmpdir	pointer
=	O
TMPDIR	pointer
;	O
template	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
tmpdir	pointer
)	O
+	O
10	int
)	O
;	O
sprintf	function
(	O
template	pointer
,	O
"%s/p%cXXXXXX"	pointer
,	O
tmpdir	pointer
,	O
letter	char
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
gen_tempname	function
(	O
template	pointer
,	O
0	int
,	O
flags	int
,	O
GT_NOCREATE	int
)	O
)	O
pfatal	function
(	O
"Can't create temporary file %s"	pointer
,	O
template	pointer
)	O
;	O
retry	O
:	O
fd	int
=	O
open	function
(	O
template	pointer
,	O
O_CREAT	int
|	O
O_EXCL	int
|	O
flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
try_makedirs_errno	int
)	O
{	O
makedirs	function
(	O
template	pointer
)	O
;	O
try_makedirs_errno	int
=	O
0	int
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
errno	O
==	O
EEXIST	int
)	O
continue	O
;	O
pfatal	function
(	O
"Can't create temporary file %s"	pointer
,	O
template	pointer
)	O
;	O
}	O
*	O
name	pointer
=	O
template	pointer
;	O
return	O
fd	int
;	O
}	O
}	O
