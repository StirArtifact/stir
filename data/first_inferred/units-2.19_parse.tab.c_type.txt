struct	O
commtype	struct
{	O
int	O
location	int
;	O
const	O
char	O
*	O
data	pointer
;	O
struct	O
unittype	O
*	O
result	pointer
;	O
int	O
errorcode	int
;	O
}	O
;	O
static	O
int	O
err	int
;	O
int	O
yylex	O
(	O
)	O
;	O
void	O
yyerror	O
(	O
struct	O
commtype	struct
*	O
comm	pointer
,	O
char	O
*	O
)	O
;	O
int	O
unitcount	int
=	O
0	int
;	O
struct	O
function	struct
{	O
char	O
*	O
name	pointer
;	O
double	O
(	O
*	O
func	pointer
)	O
(	O
double	O
)	O
;	O
int	O
type	int
;	O
}	O
;	O
struct	O
unittype	O
*	O
getnewunit	function
(	O
)	O
{	O
struct	O
unittype	O
*	O
unit	pointer
;	O
if	O
(	O
unitcount	int
>=	O
MAXMEM	int
)	O
return	O
0	int
;	O
unit	pointer
=	O
(	O
struct	O
unittype	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
unittype	O
)	O
,	O
"(getnewunit)"	pointer
)	O
;	O
if	O
(	O
!	O
unit	pointer
)	O
return	O
0	int
;	O
initializeunit	function
(	O
unit	pointer
)	O
;	O
unitcount	int
++	O
;	O
return	O
unit	pointer
;	O
}	O
void	O
destroyunit	function
(	O
struct	O
unittype	O
*	O
unit	pointer
)	O
{	O
freeunit	function
(	O
unit	pointer
)	O
;	O
free	function
(	O
unit	pointer
)	O
;	O
unitcount	int
--	O
;	O
}	O
struct	O
unittype	O
*	O
makenumunit	function
(	O
double	O
num	double
,	O
int	O
*	O
myerr	pointer
)	O
{	O
struct	O
unittype	O
*	O
ret	pointer
;	O
ret	pointer
=	O
getnewunit	function
(	O
)	O
;	O
if	O
(	O
!	O
ret	pointer
)	O
{	O
*	O
myerr	pointer
=	O
E_PARSEMEM	O
;	O
return	O
0	int
;	O
}	O
ret	pointer
->	O
factor	O
=	O
num	double
;	O
*	O
myerr	pointer
=	O
0	int
;	O
return	O
ret	pointer
;	O
}	O
int	O
logunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
int	O
base	int
)	O
{	O
if	O
(	O
(	O
err	int
=	O
unit2num	function
(	O
theunit	pointer
)	O
)	O
)	O
return	O
err	int
;	O
theunit	pointer
->	O
factor	O
=	O
log	O
(	O
theunit	pointer
->	O
factor	O
)	O
/	O
log	O
(	O
(	O
double	O
)	O
base	int
)	O
;	O
if	O
(	O
errno	O
)	O
return	O
E_FUNC	O
;	O
return	O
0	int
;	O
}	O
int	O
funcunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
struct	O
function	struct
const	O
*	O
fun	pointer
)	O
{	O
struct	O
unittype	O
angleunit	struct
;	O
if	O
(	O
fun	pointer
->	O
type	int
==	O
ANGLEIN	int
)	O
{	O
err	int
=	O
unit2num	function
(	O
theunit	pointer
)	O
;	O
if	O
(	O
err	int
==	O
E_NOTANUMBER	O
)	O
{	O
initializeunit	function
(	O
&	O
angleunit	struct
)	O
;	O
angleunit	struct
.	O
denominator	O
[	O
0	int
]	O
=	O
dupstr	function
(	O
"radian"	pointer
)	O
;	O
angleunit	struct
.	O
denominator	O
[	O
1	int
]	O
=	O
0	int
;	O
err	int
=	O
multunit	function
(	O
theunit	pointer
,	O
&	O
angleunit	struct
)	O
;	O
freeunit	function
(	O
&	O
angleunit	struct
)	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
unit2num	function
(	O
theunit	pointer
)	O
;	O
}	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
else	O
if	O
(	O
fun	pointer
->	O
type	int
==	O
ANGLEOUT	int
||	O
fun	pointer
->	O
type	int
==	O
DIMENSIONLESS	int
)	O
{	O
if	O
(	O
(	O
err	int
=	O
unit2num	function
(	O
theunit	pointer
)	O
)	O
)	O
return	O
err	int
;	O
}	O
else	O
return	O
E_BADFUNCTYPE	O
;	O
errno	O
=	O
0	int
;	O
theunit	pointer
->	O
factor	O
=	O
(	O
*	O
(	O
fun	pointer
->	O
func	pointer
)	O
)	O
(	O
theunit	pointer
->	O
factor	O
)	O
;	O
if	O
(	O
errno	O
)	O
return	O
E_FUNC	O
;	O
if	O
(	O
fun	pointer
->	O
type	int
==	O
ANGLEOUT	int
)	O
{	O
theunit	pointer
->	O
numerator	O
[	O
0	int
]	O
=	O
dupstr	function
(	O
"radian"	pointer
)	O
;	O
theunit	pointer
->	O
numerator	O
[	O
1	int
]	O
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
enum	O
unitstokentype	enum
{	O
REAL	int
=	O
258	int
,	O
UNIT	int
=	O
259	int
,	O
REALFUNC	int
=	O
260	int
,	O
LOG	int
=	O
261	int
,	O
UNITFUNC	int
=	O
262	int
,	O
EXPONENT	int
=	O
263	int
,	O
MULTIPLY	int
=	O
264	int
,	O
MULTSTAR	int
=	O
265	int
,	O
DIVIDE	int
=	O
266	int
,	O
NUMDIV	int
=	O
267	int
,	O
SQRT	int
=	O
268	int
,	O
CUBEROOT	int
=	O
269	int
,	O
MULTMINUS	int
=	O
270	int
,	O
EOL	int
=	O
271	int
,	O
FUNCINV	int
=	O
272	int
,	O
MEMERROR	int
=	O
273	int
,	O
BADNUMBER	int
=	O
274	int
,	O
UNITEND	int
=	O
275	int
,	O
LASTUNSET	int
=	O
276	int
,	O
ADD	int
=	O
277	int
,	O
MINUS	int
=	O
278	int
,	O
UNARY	int
=	O
279	int
}	O
;	O
union	O
UNITSSTYPE	union
{	O
double	O
number	double
;	O
int	O
integer	int
;	O
struct	O
unittype	O
*	O
unit	pointer
;	O
struct	O
function	struct
*	O
realfunc	pointer
;	O
struct	O
func	pointer
*	O
unitfunc	pointer
;	O
}	O
;	O
typedef	O
union	O
UNITSSTYPE	union
UNITSSTYPE	union
;	O
int	O
unitsparse	function
(	O
struct	O
commtype	struct
*	O
comm	pointer
)	O
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
yytype_uint16	short
;	O
typedef	O
short	O
yytype_int16	short
;	O
union	O
yyalloc	union
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	O
yyvs_alloc	union
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
25	int
,	O
26	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
}	O
;	O
static	O
const	O
yytype_int16	short
yypact	array
[	O
]	O
=	O
{	O
8	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
21	int
,	O
-	O
21	int
,	O
-	O
21	int
,	O
151	int
,	O
-	O
21	int
,	O
-	O
21	int
,	O
151	int
,	O
-	O
22	int
,	O
39	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
151	int
,	O
59	int
,	O
16	int
,	O
-	O
8	int
,	O
83	int
,	O
20	int
,	O
-	O
22	int
,	O
82	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
82	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
82	int
,	O
-	O
22	int
,	O
-	O
21	int
,	O
82	int
,	O
25	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
59	int
,	O
59	int
,	O
59	int
,	O
59	int
,	O
59	int
,	O
17	int
,	O
105	int
,	O
151	int
,	O
128	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
40	int
,	O
40	int
,	O
43	int
,	O
43	int
,	O
-	O
22	int
,	O
151	int
,	O
151	int
,	O
42	int
,	O
128	int
,	O
42	int
,	O
42	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array
[	O
]	O
=	O
{	O
0	int
,	O
4	int
,	O
15	int
,	O
19	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
33	int
,	O
32	int
,	O
34	int
,	O
35	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
5	int
,	O
18	int
,	O
23	int
,	O
7	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
6	int
,	O
24	int
,	O
25	int
,	O
8	int
,	O
36	int
,	O
0	int
,	O
9	int
,	O
0	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
22	int
,	O
29	int
,	O
17	int
,	O
13	int
,	O
14	int
,	O
12	int
,	O
10	int
,	O
11	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
20	int
,	O
21	int
,	O
30	int
,	O
31	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array
[	O
]	O
=	O
{	O
-	O
22	int
,	O
-	O
22	int
,	O
-	O
22	int
,	O
19	int
,	O
24	int
,	O
-	O
3	int
,	O
0	int
}	O
;	O
static	O
const	O
yytype_int8	char
yydefgoto	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
46	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yytable	array
[	O
]	O
=	O
{	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
18	int
,	O
29	int
,	O
30	int
,	O
28	int
,	O
37	int
,	O
1	int
,	O
31	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
36	int
,	O
34	int
,	O
24	int
,	O
7	int
,	O
2	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
47	int
,	O
17	int
,	O
43	int
,	O
18	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
35	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
32	int
,	O
57	int
,	O
58	int
,	O
33	int
,	O
41	int
,	O
42	int
,	O
38	int
,	O
44	int
,	O
48	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
59	int
,	O
60	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
54	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
0	int
,	O
17	int
,	O
0	int
,	O
18	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
44	int
,	O
0	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
8	int
,	O
9	int
,	O
45	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
0	int
,	O
41	int
,	O
42	int
,	O
18	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
9	int
,	O
55	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
0	int
,	O
56	int
,	O
0	int
,	O
18	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
9	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
18	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
9	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
18	int
}	O
;	O
static	O
const	O
yytype_int8	char
yycheck	array
[	O
]	O
=	O
{	O
0	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
25	int
,	O
8	int
,	O
9	int
,	O
7	int
,	O
16	int
,	O
1	int
,	O
10	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
0	int
,	O
17	int
,	O
18	int
,	O
11	int
,	O
3	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
33	int
,	O
23	int
,	O
12	int
,	O
25	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
18	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
4	int
,	O
44	int
,	O
45	int
,	O
7	int
,	O
22	int
,	O
23	int
,	O
9	int
,	O
8	int
,	O
26	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
55	int
,	O
56	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
43	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
-	O
1	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
25	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
-	O
1	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
-	O
1	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
-	O
1	int
,	O
22	int
,	O
23	int
,	O
25	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
-	O
1	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
25	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
13	int
,	O
14	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
25	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
13	int
,	O
14	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
25	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array
[	O
]	O
=	O
{	O
0	int
,	O
1	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
11	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
23	int
,	O
25	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
33	int
,	O
32	int
,	O
32	int
,	O
33	int
,	O
4	int
,	O
7	int
,	O
33	int
,	O
30	int
,	O
0	int
,	O
16	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
22	int
,	O
23	int
,	O
12	int
,	O
8	int
,	O
15	int
,	O
33	int
,	O
32	int
,	O
26	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
31	int
,	O
15	int
,	O
23	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyr1	array
[	O
]	O
=	O
{	O
0	int
,	O
27	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
29	int
,	O
29	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
30	int
,	O
31	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
,	O
33	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyr2	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
}	O
;	O
static	O
void	O
yydestruct	function
(	O
const	O
char	O
*	O
yymsg	pointer
,	O
int	O
yytype	int
,	O
YYSTYPE	O
*	O
yyvaluep	pointer
,	O
struct	O
commtype	struct
*	O
comm	pointer
)	O
{	O
YYUSE	O
(	O
yyvaluep	pointer
)	O
;	O
YYUSE	O
(	O
comm	pointer
)	O
;	O
if	O
(	O
!	O
yymsg	pointer
)	O
yymsg	pointer
=	O
"Deleting"	pointer
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	pointer
,	O
yytype	int
,	O
yyvaluep	pointer
,	O
yylocationp	O
)	O
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
switch	O
(	O
yytype	int
)	O
{	O
case	O
4	int
:	O
{	O
destroyunit	function
(	O
(	O
(	O
*	O
yyvaluep	pointer
)	O
.	O
unit	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
29	int
:	O
{	O
destroyunit	function
(	O
(	O
(	O
*	O
yyvaluep	pointer
)	O
.	O
unit	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
30	int
:	O
{	O
destroyunit	function
(	O
(	O
(	O
*	O
yyvaluep	pointer
)	O
.	O
unit	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
32	int
:	O
{	O
destroyunit	function
(	O
(	O
(	O
*	O
yyvaluep	pointer
)	O
.	O
unit	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
33	int
:	O
{	O
destroyunit	function
(	O
(	O
(	O
*	O
yyvaluep	pointer
)	O
.	O
unit	pointer
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
}	O
int	O
yyparse	O
(	O
struct	O
commtype	struct
*	O
comm	pointer
)	O
{	O
int	O
yychar	int
;	O
YY_INITIAL_VALUE	O
(	O
static	O
YYSTYPE	O
yyval_default	union
;	O
)	O
YYSTYPE	O
yylval	union
YY_INITIAL_VALUE	O
(	O
=	O
yyval_default	union
)	O
;	O
int	O
yynerrs	O
;	O
int	O
yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	pointer
;	O
yytype_int16	short
*	O
yyssp	pointer
;	O
YYSTYPE	O
yyvsa	array
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	O
*	O
yyvs	pointer
;	O
YYSTYPE	O
*	O
yyvsp	pointer
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
=	O
0	int
;	O
YYSTYPE	O
yyval	union
;	O
int	O
yylen	int
=	O
0	int
;	O
yyssp	pointer
=	O
yyss	pointer
=	O
yyssa	array
;	O
yyvsp	pointer
=	O
yyvs	pointer
=	O
yyvsa	array
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	O
,	O
"Starting parse\n"	pointer
)	O
)	O
;	O
yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
yynerrs	O
=	O
0	int
;	O
yychar	int
=	O
YYEMPTY	O
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	pointer
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	pointer
=	O
(	O
yytype_int16	short
)	O
yystate	int
;	O
if	O
(	O
yyss	pointer
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	pointer
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
(	O
YYSIZE_T	O
)	O
(	O
yyssp	pointer
-	O
yyss	pointer
+	O
1	int
)	O
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	pointer
=	O
yyss	pointer
;	O
union	O
yyalloc	union
*	O
yyptr	pointer
=	O
(	O
union	O
yyalloc	union
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	pointer
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	pointer
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union
,	O
yyvs	pointer
)	O
;	O
if	O
(	O
yyss1	pointer
!=	O
yyssa	array
)	O
YYSTACK_FREE	O
(	O
yyss1	pointer
)	O
;	O
}	O
yyssp	pointer
=	O
yyss	pointer
+	O
yysize	long
-	O
1	int
;	O
yyvsp	pointer
=	O
yyvs	pointer
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	O
,	O
"Stack size increased to %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	pointer
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	pointer
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	O
,	O
"Entering state %d\n"	pointer
,	O
yystate	int
)	O
)	O
;	O
if	O
(	O
yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
yypact	array
[	O
yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	O
,	O
"Reading a token: "	pointer
)	O
)	O
;	O
yychar	int
=	O
yylex	O
(	O
&	O
yylval	union
,	O
comm	pointer
)	O
;	O
}	O
if	O
(	O
yychar	int
<=	O
YYEOF	int
)	O
{	O
yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	O
,	O
"Now at end of input.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	pointer
,	O
yytoken	int
,	O
&	O
yylval	union
,	O
&	O
yylloc	O
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
yycheck	array
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
yytable	array
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	int
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
yytoken	int
,	O
&	O
yylval	union
,	O
&	O
yylloc	O
)	O
;	O
yychar	int
=	O
YYEMPTY	O
;	O
yystate	int
=	O
yyn	int
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	pointer
=	O
yylval	union
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array
[	O
yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
yylen	int
=	O
yyr2	array
[	O
yyn	int
]	O
;	O
yyval	union
=	O
yyvsp	pointer
[	O
1	int
-	O
yylen	int
]	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
2	int
:	O
{	O
comm	pointer
->	O
result	pointer
=	O
makenumunit	function
(	O
1	int
,	O
&	O
err	int
)	O
;	O
CHECK	O
(	O
0	int
)	O
;	O
comm	pointer
->	O
errorcode	int
=	O
0	int
;	O
YYACCEPT	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
{	O
comm	pointer
->	O
result	pointer
=	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unit	pointer
)	O
;	O
comm	pointer
->	O
errorcode	int
=	O
0	int
;	O
YYACCEPT	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
YYABORT	O
;	O
}	O
break	O
;	O
case	O
5	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
6	int
:	O
{	O
invertunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
->	O
factor	O
*=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
->	O
factor	O
*=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
10	int
:	O
{	O
err	int
=	O
addunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
->	O
factor	O
*=	O
-	O
1	int
;	O
err	int
=	O
addunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
12	int
:	O
{	O
err	int
=	O
divunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
err	int
=	O
multunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
err	int
=	O
multunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
(	O
yyval	union
.	O
number	double
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
number	double
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
(	O
yyval	union
.	O
number	double
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
number	double
)	O
/	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
number	double
)	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
makenumunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
number	double
)	O
,	O
&	O
err	int
)	O
;	O
CHECK	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
err	int
=	O
unitpower	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
err	int
=	O
multunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
2	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
err	int
=	O
multunit	function
(	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
err	int
=	O
rootunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
,	O
2	int
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
err	int
=	O
rootunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
,	O
3	int
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
err	int
=	O
funcunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
realfunc	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
err	int
=	O
logunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
integer	int
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
err	int
=	O
evalfunc	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unitfunc	pointer
)	O
,	O
0	int
,	O
0	int
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
29	int
:	O
{	O
err	int
=	O
evalfunc	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
-	O
1	int
]	O
.	O
unitfunc	pointer
)	O
,	O
1	int
,	O
0	int
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
30	int
:	O
{	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
->	O
factor	O
*=	O
-	O
1	int
;	O
err	int
=	O
unitpower	function
(	O
(	O
yyvsp	pointer
[	O
-	O
3	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
3	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
3	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
31	int
:	O
{	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
->	O
factor	O
*=	O
-	O
1	int
;	O
err	int
=	O
unitpower	function
(	O
(	O
yyvsp	pointer
[	O
-	O
3	int
]	O
.	O
unit	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
destroyunit	function
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
-	O
3	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
(	O
yyval	union
.	O
unit	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
-	O
3	int
]	O
.	O
unit	pointer
)	O
;	O
}	O
break	O
;	O
case	O
32	int
:	O
{	O
err	int
=	O
E_BADNUM	O
;	O
CHECK	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
33	int
:	O
{	O
err	int
=	O
E_PARSEMEM	O
;	O
CHECK	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
34	int
:	O
{	O
err	int
=	O
E_UNITEND	O
;	O
CHECK	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
35	int
:	O
{	O
err	int
=	O
E_LASTUNSET	O
;	O
CHECK	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
36	int
:	O
{	O
err	int
=	O
E_NOTAFUNC	O
;	O
CHECK	O
(	O
(	O
yyvsp	pointer
[	O
0	int
]	O
.	O
unit	pointer
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	pointer
,	O
yyr1	array
[	O
yyn	int
]	O
,	O
&	O
yyval	union
,	O
&	O
yyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
yylen	int
)	O
;	O
yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
*	O
++	O
yyvsp	pointer
=	O
yyval	union
;	O
{	O
const	O
int	O
yylhs	int
=	O
yyr1	array
[	O
yyn	int
]	O
-	O
YYNTOKENS	int
;	O
const	O
int	O
yyi	int
=	O
yypgoto	array
[	O
yylhs	int
]	O
+	O
*	O
yyssp	pointer
;	O
yystate	int
=	O
(	O
0	int
<=	O
yyi	int
&&	O
yyi	int
<=	O
YYLAST	int
&&	O
yycheck	array
[	O
yyi	int
]	O
==	O
*	O
yyssp	pointer
?	O
yytable	array
[	O
yyi	int
]	O
:	O
yydefgoto	array
[	O
yylhs	int
]	O
)	O
;	O
}	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
yynerrs	O
;	O
yyerror	O
(	O
comm	pointer
,	O
YY_	O
(	O
"syntax error"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	function
(	O
"Error: discarding"	pointer
,	O
yytoken	int
,	O
&	O
yylval	union
,	O
comm	pointer
)	O
;	O
yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
YYERROR	O
;	O
YYPOPSTACK	O
(	O
yylen	int
)	O
;	O
yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
yystate	int
=	O
*	O
yyssp	pointer
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
yypact	array
[	O
yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
yycheck	array
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
yytable	array
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	pointer
==	O
yyss	pointer
)	O
YYABORT	O
;	O
yydestruct	function
(	O
"Error: popping"	pointer
,	O
yystos	array
[	O
yystate	int
]	O
,	O
yyvsp	pointer
,	O
comm	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
yystate	int
=	O
*	O
yyssp	pointer
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	pointer
=	O
yylval	union
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
yystos	array
[	O
yyn	int
]	O
,	O
yyvsp	pointer
,	O
yylsp	O
)	O
;	O
yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
yyerror	O
(	O
comm	pointer
,	O
YY_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
yychar	int
)	O
;	O
yydestruct	function
(	O
"Cleanup: discarding lookahead"	pointer
,	O
yytoken	int
,	O
&	O
yylval	union
,	O
comm	pointer
)	O
;	O
}	O
YYPOPSTACK	O
(	O
yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
while	O
(	O
yyssp	pointer
!=	O
yyss	pointer
)	O
{	O
yydestruct	function
(	O
"Cleanup: popping"	pointer
,	O
yystos	array
[	O
*	O
yyssp	pointer
]	O
,	O
yyvsp	pointer
,	O
comm	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	pointer
!=	O
yyssa	array
)	O
YYSTACK_FREE	O
(	O
yyss	pointer
)	O
;	O
return	O
yyresult	int
;	O
}	O
struct	O
function	struct
realfunctions	array
[	O
]	O
=	O
{	O
{	O
"sin"	pointer
,	O
sin	O
,	O
ANGLEIN	int
}	O
,	O
{	O
"cos"	pointer
,	O
cos	O
,	O
ANGLEIN	int
}	O
,	O
{	O
"tan"	pointer
,	O
tan	O
,	O
ANGLEIN	int
}	O
,	O
{	O
"ln"	pointer
,	O
log	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"log"	pointer
,	O
log10	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"exp"	pointer
,	O
exp	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"acos"	pointer
,	O
acos	O
,	O
ANGLEOUT	int
}	O
,	O
{	O
"atan"	pointer
,	O
atan	O
,	O
ANGLEOUT	int
}	O
,	O
{	O
"asin"	pointer
,	O
asin	O
,	O
ANGLEOUT	int
}	O
,	O
{	O
"sinh"	pointer
,	O
sinh	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"cosh"	pointer
,	O
cosh	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"tanh"	pointer
,	O
tanh	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"asinh"	pointer
,	O
asinh	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"acosh"	pointer
,	O
acosh	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
"atanh"	pointer
,	O
atanh	O
,	O
DIMENSIONLESS	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
struct	O
{	O
char	O
op	char
;	O
int	O
value	int
;	O
}	O
optable	array
[	O
]	O
=	O
{	O
{	O
'*'	O
,	O
MULTIPLY	int
}	O
,	O
{	O
'/'	O
,	O
DIVIDE	int
}	O
,	O
{	O
'|'	O
,	O
NUMDIV	int
}	O
,	O
{	O
'+'	O
,	O
ADD	int
}	O
,	O
{	O
'('	O
,	O
'('	O
}	O
,	O
{	O
')'	O
,	O
')'	O
}	O
,	O
{	O
'^'	O
,	O
EXPONENT	int
}	O
,	O
{	O
'~'	O
,	O
FUNCINV	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
int	O
value	int
;	O
}	O
strtable	array
[	O
]	O
=	O
{	O
{	O
"sqrt"	pointer
,	O
SQRT	int
}	O
,	O
{	O
"cuberoot"	pointer
,	O
CUBEROOT	int
}	O
,	O
{	O
"per"	pointer
,	O
DIVIDE	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
yylex	O
(	O
YYSTYPE	O
*	O
lvalp	pointer
,	O
struct	O
commtype	struct
*	O
comm	pointer
)	O
{	O
int	O
length	int
,	O
count	int
;	O
struct	O
unittype	O
*	O
output	pointer
;	O
const	O
char	O
*	O
inptr	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
nonunitchars	pointer
=	O
"~;+-*/|\t\n^ ()"	pointer
;	O
char	O
*	O
nonunitends	pointer
=	O
".,_"	pointer
;	O
char	O
*	O
number_start	pointer
=	O
".,0123456789"	pointer
;	O
if	O
(	O
comm	pointer
->	O
location	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
inptr	pointer
=	O
comm	pointer
->	O
data	pointer
+	O
comm	pointer
->	O
location	int
;	O
while	O
(	O
*	O
inptr	pointer
==	O
' '	O
)	O
inptr	pointer
++	O
,	O
comm	pointer
->	O
location	int
++	O
;	O
if	O
(	O
*	O
inptr	pointer
==	O
0	int
)	O
{	O
comm	pointer
->	O
location	int
=	O
-	O
1	int
;	O
return	O
EOL	int
;	O
}	O
if	O
(	O
0	int
==	O
strncmp	O
(	O
"**"	pointer
,	O
inptr	pointer
,	O
2	int
)	O
)	O
{	O
comm	pointer
->	O
location	int
+=	O
2	int
;	O
return	O
EXPONENT	int
;	O
}	O
if	O
(	O
*	O
inptr	pointer
==	O
'-'	O
)	O
{	O
comm	pointer
->	O
location	int
++	O
;	O
if	O
(	O
parserflags	O
.	O
minusminus	O
)	O
return	O
MINUS	int
;	O
return	O
MULTMINUS	int
;	O
}	O
if	O
(	O
*	O
inptr	pointer
==	O
'*'	O
)	O
{	O
comm	pointer
->	O
location	int
++	O
;	O
if	O
(	O
parserflags	O
.	O
oldstar	O
)	O
return	O
MULTIPLY	int
;	O
return	O
MULTSTAR	int
;	O
}	O
if	O
(	O
*	O
inptr	pointer
==	O
LASTUNIT	char
)	O
{	O
comm	pointer
->	O
location	int
++	O
;	O
if	O
(	O
!	O
lastunitset	O
)	O
return	O
LASTUNSET	int
;	O
output	pointer
=	O
getnewunit	function
(	O
)	O
;	O
if	O
(	O
!	O
output	pointer
)	O
return	O
MEMERROR	int
;	O
unitcopy	function
(	O
output	pointer
,	O
&	O
lastunit	O
)	O
;	O
lvalp	pointer
->	O
unit	pointer
=	O
output	pointer
;	O
return	O
UNIT	int
;	O
}	O
for	O
(	O
count	int
=	O
0	int
;	O
optable	array
[	O
count	int
]	O
.	O
op	char
;	O
count	int
++	O
)	O
{	O
if	O
(	O
*	O
inptr	pointer
==	O
optable	array
[	O
count	int
]	O
.	O
op	char
)	O
{	O
comm	pointer
->	O
location	int
++	O
;	O
return	O
optable	array
[	O
count	int
]	O
.	O
value	int
;	O
}	O
}	O
if	O
(	O
strchr	O
(	O
number_start	pointer
,	O
*	O
inptr	pointer
)	O
)	O
{	O
char	O
*	O
endloc	pointer
;	O
lvalp	pointer
->	O
number	double
=	O
strtod	O
(	O
inptr	pointer
,	O
&	O
endloc	pointer
)	O
;	O
if	O
(	O
inptr	pointer
!=	O
endloc	pointer
)	O
{	O
comm	pointer
->	O
location	int
+=	O
(	O
endloc	pointer
-	O
inptr	pointer
)	O
;	O
if	O
(	O
*	O
endloc	pointer
&&	O
strchr	O
(	O
number_start	pointer
,	O
*	O
endloc	pointer
)	O
)	O
return	O
BADNUMBER	int
;	O
else	O
return	O
REAL	int
;	O
}	O
}	O
length	int
=	O
strcspn	O
(	O
inptr	pointer
,	O
nonunitchars	pointer
)	O
;	O
if	O
(	O
!	O
length	int
)	O
{	O
comm	pointer
->	O
location	int
++	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strchr	O
(	O
nonunitends	pointer
,	O
*	O
inptr	pointer
)	O
)	O
{	O
comm	pointer
->	O
location	int
++	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strchr	O
(	O
nonunitends	pointer
,	O
inptr	pointer
[	O
length	int
-	O
1	int
]	O
)	O
)	O
{	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
return	O
0	int
;	O
}	O
name	pointer
=	O
dupnstr	function
(	O
inptr	pointer
,	O
length	int
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
strtable	array
[	O
count	int
]	O
.	O
name	pointer
;	O
count	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
strtable	array
[	O
count	int
]	O
.	O
name	pointer
)	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
return	O
strtable	array
[	O
count	int
]	O
.	O
value	int
;	O
}	O
}	O
for	O
(	O
count	int
=	O
0	int
;	O
realfunctions	array
[	O
count	int
]	O
.	O
name	pointer
;	O
count	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
realfunctions	array
[	O
count	int
]	O
.	O
name	pointer
)	O
)	O
{	O
lvalp	pointer
->	O
realfunc	pointer
=	O
realfunctions	array
+	O
count	int
;	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
REALFUNC	int
;	O
}	O
}	O
if	O
(	O
!	O
strncmp	O
(	O
name	pointer
,	O
"log"	pointer
,	O
3	int
)	O
)	O
{	O
count	int
=	O
strspn	O
(	O
name	pointer
+	O
3	int
,	O
"1234567890"	pointer
)	O
;	O
if	O
(	O
count	int
+	O
3	int
==	O
strlen	O
(	O
name	pointer
)	O
)	O
{	O
lvalp	pointer
->	O
integer	int
=	O
atoi	function
(	O
name	pointer
+	O
3	int
)	O
;	O
if	O
(	O
lvalp	pointer
->	O
integer	int
>	O
1	int
)	O
{	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
LOG	int
;	O
}	O
}	O
}	O
if	O
(	O
function_parameter	O
&&	O
!	O
strcmp	O
(	O
name	pointer
,	O
function_parameter	O
)	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
output	pointer
=	O
getnewunit	function
(	O
)	O
;	O
if	O
(	O
!	O
output	pointer
)	O
return	O
MEMERROR	int
;	O
unitcopy	function
(	O
output	pointer
,	O
parameter_value	O
)	O
;	O
lvalp	pointer
->	O
unit	pointer
=	O
output	pointer
;	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
return	O
UNIT	int
;	O
}	O
lvalp	pointer
->	O
unitfunc	pointer
=	O
fnlookup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
lvalp	pointer
->	O
unitfunc	pointer
)	O
{	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
UNITFUNC	int
;	O
}	O
comm	pointer
->	O
location	int
+=	O
length	int
;	O
if	O
(	O
strchr	O
(	O
"23456789"	pointer
,	O
inptr	pointer
[	O
length	int
-	O
1	int
]	O
)	O
&&	O
!	O
hassubscript	function
(	O
name	pointer
)	O
)	O
{	O
count	int
=	O
name	pointer
[	O
length	int
-	O
1	int
]	O
-	O
'0'	O
;	O
length	int
--	O
;	O
if	O
(	O
strchr	O
(	O
number_start	pointer
,	O
name	pointer
[	O
length	int
-	O
1	int
]	O
)	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
UNITEND	int
;	O
}	O
}	O
else	O
count	int
=	O
1	int
;	O
free	function
(	O
name	pointer
)	O
;	O
output	pointer
=	O
getnewunit	function
(	O
)	O
;	O
if	O
(	O
!	O
output	pointer
)	O
return	O
MEMERROR	int
;	O
output	pointer
->	O
numerator	O
[	O
count	int
--	O
]	O
=	O
0	int
;	O
for	O
(	O
;	O
count	int
>=	O
0	int
;	O
count	int
--	O
)	O
output	pointer
->	O
numerator	O
[	O
count	int
]	O
=	O
dupnstr	function
(	O
inptr	pointer
,	O
length	int
)	O
;	O
lvalp	pointer
->	O
unit	pointer
=	O
output	pointer
;	O
return	O
UNIT	int
;	O
}	O
void	O
yyerror	O
(	O
struct	O
commtype	struct
*	O
comm	pointer
,	O
char	O
*	O
s	pointer
)	O
{	O
}	O
int	O
parseunit	function
(	O
struct	O
unittype	O
*	O
output	pointer
,	O
char	O
const	O
*	O
input	pointer
,	O
char	O
*	O
*	O
errstr	pointer
,	O
int	O
*	O
errloc	pointer
)	O
{	O
struct	O
commtype	struct
comm	pointer
;	O
int	O
saveunitcount	int
;	O
saveunitcount	int
=	O
unitcount	int
;	O
initializeunit	function
(	O
output	pointer
)	O
;	O
comm	pointer
.	O
result	pointer
=	O
0	int
;	O
comm	pointer
.	O
location	int
=	O
0	int
;	O
comm	pointer
.	O
data	pointer
=	O
input	pointer
;	O
comm	pointer
.	O
errorcode	int
=	O
E_PARSE	O
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
yyparse	O
(	O
&	O
comm	pointer
)	O
||	O
errno	O
)	O
{	O
if	O
(	O
comm	pointer
.	O
location	int
==	O
-	O
1	int
)	O
comm	pointer
.	O
location	int
=	O
strlen	O
(	O
input	pointer
)	O
;	O
if	O
(	O
errstr	pointer
)	O
{	O
if	O
(	O
comm	pointer
.	O
errorcode	int
==	O
E_FUNC	O
||	O
errno	O
)	O
*	O
errstr	pointer
=	O
strerror	O
(	O
errno	O
)	O
;	O
else	O
*	O
errstr	pointer
=	O
errormsg	O
[	O
comm	pointer
.	O
errorcode	int
]	O
;	O
}	O
if	O
(	O
errloc	pointer
)	O
*	O
errloc	pointer
=	O
comm	pointer
.	O
location	int
;	O
if	O
(	O
unitcount	int
!=	O
saveunitcount	int
)	O
fprintf	function
(	O
stderr	O
,	O
"units: Parser leaked memory with error: %d in %d out\n"	pointer
,	O
saveunitcount	int
,	O
unitcount	int
)	O
;	O
return	O
comm	pointer
.	O
errorcode	int
;	O
}	O
else	O
{	O
if	O
(	O
errstr	pointer
)	O
*	O
errstr	pointer
=	O
0	int
;	O
multunit	function
(	O
output	pointer
,	O
comm	pointer
.	O
result	pointer
)	O
;	O
destroyunit	function
(	O
comm	pointer
.	O
result	pointer
)	O
;	O
if	O
(	O
unitcount	int
!=	O
saveunitcount	int
)	O
fprintf	function
(	O
stderr	O
,	O
"units: Parser leaked memory without error: %d in %d out\n"	pointer
,	O
saveunitcount	int
,	O
unitcount	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
