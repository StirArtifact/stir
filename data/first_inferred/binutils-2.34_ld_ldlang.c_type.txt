static	O
struct	O
obstack	struct
stat_obstack	struct
;	O
static	O
struct	O
obstack	struct
map_obstack	struct
;	O
static	O
const	O
char	O
*	O
entry_symbol_default	pointer
=	O
"start"	pointer
;	O
static	O
bfd_boolean	int
map_head_is_link_order	int
=	O
FALSE	int
;	O
static	O
lang_output_section_statement_type	struct
*	O
default_common_section	pointer
;	O
static	O
bfd_boolean	int
map_option_f	int
;	O
static	O
bfd_vma	long
print_dot	long
;	O
static	O
lang_input_statement_type	struct
*	O
first_file	pointer
;	O
static	O
const	O
char	O
*	O
current_target	pointer
;	O
static	O
lang_statement_list_type	struct
statement_list	struct
;	O
static	O
lang_statement_list_type	struct
*	O
stat_save	array
[	O
10	int
]	O
;	O
static	O
lang_statement_list_type	struct
*	O
*	O
stat_save_ptr	pointer
=	O
&	O
stat_save	array
[	O
0	int
]	O
;	O
static	O
struct	O
unique_sections	struct
*	O
unique_section_list	pointer
;	O
static	O
struct	O
asneeded_minfo	struct
*	O
asneeded_list_head	pointer
;	O
static	O
unsigned	O
int	O
opb_shift	int
=	O
0	int
;	O
static	O
void	O
exp_init_os	function
(	O
etree_type	union
*	O
)	O
;	O
static	O
lang_input_statement_type	struct
*	O
lookup_name	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
insert_undefined	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
sort_def_symbol	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
print_statement	function
(	O
lang_statement_union_type	union
*	O
,	O
lang_output_section_statement_type	struct
*	O
)	O
;	O
static	O
void	O
print_statement_list	function
(	O
lang_statement_union_type	union
*	O
,	O
lang_output_section_statement_type	struct
*	O
)	O
;	O
static	O
void	O
print_statements	function
(	O
void	O
)	O
;	O
static	O
void	O
print_input_section	function
(	O
asection	struct
*	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
lang_one_common	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
lang_record_phdrs	function
(	O
void	O
)	O
;	O
static	O
void	O
lang_do_version_exports_section	function
(	O
void	O
)	O
;	O
static	O
void	O
lang_finalize_version_expr_head	function
(	O
struct	O
bfd_elf_version_expr_head	struct
*	O
)	O
;	O
static	O
void	O
lang_do_memory_regions	function
(	O
void	O
)	O
;	O
const	O
char	O
*	O
output_target	pointer
;	O
lang_output_section_statement_type	struct
*	O
abs_output_section	pointer
;	O
lang_statement_list_type	struct
lang_os_list	struct
;	O
lang_statement_list_type	struct
*	O
stat_ptr	pointer
=	O
&	O
statement_list	struct
;	O
lang_statement_list_type	struct
file_chain	struct
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
lang_statement_list_type	struct
input_file_chain	struct
;	O
struct	O
bfd_sym_chain	struct
entry_symbol	struct
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
const	O
char	O
*	O
entry_section	pointer
=	O
".text"	pointer
;	O
struct	O
lang_input_statement_flags	struct
input_flags	struct
;	O
bfd_boolean	int
entry_from_cmdline	int
;	O
bfd_boolean	int
undef_from_cmdline	int
;	O
bfd_boolean	int
lang_has_input_file	int
=	O
FALSE	int
;	O
bfd_boolean	int
had_output_filename	int
=	O
FALSE	int
;	O
bfd_boolean	int
lang_float_flag	int
=	O
FALSE	int
;	O
bfd_boolean	int
delete_output_file_on_failure	int
=	O
FALSE	int
;	O
struct	O
lang_phdr	struct
*	O
lang_phdr_list	pointer
;	O
struct	O
lang_nocrossrefs	struct
*	O
nocrossref_list	pointer
;	O
struct	O
asneeded_minfo	struct
*	O
*	O
asneeded_list_tail	pointer
;	O
static	O
ctf_file_t	struct
*	O
ctf_output	pointer
;	O
int	O
lang_statement_iteration	int
=	O
0	int
;	O
void	O
*	O
stat_alloc	function
(	O
size_t	long
size	int
)	O
{	O
return	O
obstack_alloc	O
(	O
&	O
stat_obstack	struct
,	O
size	int
)	O
;	O
}	O
static	O
int	O
name_match	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
wildcardp	O
(	O
pattern	pointer
)	O
)	O
return	O
fnmatch	function
(	O
pattern	pointer
,	O
name	pointer
,	O
0	int
)	O
;	O
return	O
strcmp	function
(	O
pattern	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
char	O
*	O
archive_path	function
(	O
const	O
char	O
*	O
pattern	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
link_info	struct
.	O
path_separator	char
==	O
0	int
)	O
return	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
pattern	pointer
,	O
link_info	struct
.	O
path_separator	char
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
bfd_boolean	int
input_statement_is_archive_path	function
(	O
const	O
char	O
*	O
file_spec	pointer
,	O
char	O
*	O
sep	pointer
,	O
lang_input_statement_type	struct
*	O
f	pointer
)	O
{	O
bfd_boolean	int
match	pointer
=	O
FALSE	int
;	O
if	O
(	O
(	O
*	O
(	O
sep	pointer
+	O
1	int
)	O
==	O
0	int
||	O
name_match	function
(	O
sep	pointer
+	O
1	int
,	O
f	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
&&	O
(	O
(	O
sep	pointer
!=	O
file_spec	pointer
)	O
==	O
(	O
f	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
f	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
!=	O
NULL	O
)	O
)	O
)	O
{	O
match	pointer
=	O
TRUE	int
;	O
if	O
(	O
sep	pointer
!=	O
file_spec	pointer
)	O
{	O
const	O
char	O
*	O
aname	pointer
=	O
f	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
->	O
filename	pointer
;	O
*	O
sep	pointer
=	O
0	int
;	O
match	pointer
=	O
name_match	function
(	O
file_spec	pointer
,	O
aname	pointer
)	O
==	O
0	int
;	O
*	O
sep	pointer
=	O
link_info	struct
.	O
path_separator	char
;	O
}	O
}	O
return	O
match	pointer
;	O
}	O
static	O
bfd_boolean	int
unique_section_p	function
(	O
const	O
asection	struct
*	O
sec	pointer
,	O
const	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
struct	O
unique_sections	struct
*	O
unam	pointer
;	O
const	O
char	O
*	O
secnam	pointer
;	O
if	O
(	O
!	O
link_info	struct
.	O
resolve_section_groups	int
&&	O
sec	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
bfd_is_group_section	O
(	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
return	O
!	O
(	O
os	int
!=	O
NULL	O
&&	O
strcmp	function
(	O
os	int
->	O
name	pointer
,	O
DISCARD_SECTION_NAME	pointer
)	O
==	O
0	int
)	O
;	O
secnam	pointer
=	O
sec	pointer
->	O
name	pointer
;	O
for	O
(	O
unam	pointer
=	O
unique_section_list	pointer
;	O
unam	pointer
;	O
unam	pointer
=	O
unam	pointer
->	O
next	pointer
)	O
if	O
(	O
name_match	function
(	O
unam	pointer
->	O
name	pointer
,	O
secnam	pointer
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
walk_wild_file_in_exclude_list	function
(	O
struct	O
name_list	struct
*	O
exclude_list	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
)	O
{	O
struct	O
name_list	struct
*	O
list_tmp	pointer
;	O
for	O
(	O
list_tmp	pointer
=	O
exclude_list	pointer
;	O
list_tmp	pointer
;	O
list_tmp	pointer
=	O
list_tmp	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
archive_path	function
(	O
list_tmp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
input_statement_is_archive_path	function
(	O
list_tmp	pointer
->	O
name	pointer
,	O
p	pointer
,	O
file	pointer
)	O
)	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
name_match	function
(	O
list_tmp	pointer
->	O
name	pointer
,	O
file	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
else	O
if	O
(	O
file	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
file	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
!=	O
NULL	O
&&	O
name_match	function
(	O
list_tmp	pointer
->	O
name	pointer
,	O
file	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
walk_wild_consider_section	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
asection	struct
*	O
s	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
walk_wild_file_in_exclude_list	function
(	O
sec	pointer
->	O
spec	struct
.	O
exclude_name_list	pointer
,	O
file	pointer
)	O
)	O
return	O
;	O
(	O
*	O
callback	pointer
)	O
(	O
ptr	pointer
,	O
sec	pointer
,	O
s	pointer
,	O
ptr	pointer
->	O
section_flag_list	pointer
,	O
file	pointer
,	O
data	pointer
)	O
;	O
}	O
static	O
void	O
walk_wild_section_general	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
struct	O
wildcard_list	struct
*	O
sec	pointer
;	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
sec	pointer
=	O
ptr	pointer
->	O
section_list	pointer
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
(	O
*	O
callback	pointer
)	O
(	O
ptr	pointer
,	O
sec	pointer
,	O
s	pointer
,	O
ptr	pointer
->	O
section_flag_list	pointer
,	O
file	pointer
,	O
data	pointer
)	O
;	O
while	O
(	O
sec	pointer
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
skip	int
=	O
FALSE	int
;	O
if	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
skip	int
=	O
name_match	function
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
!=	O
0	int
;	O
}	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
sec	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
typedef	O
struct	O
{	O
asection	struct
*	O
found_section	pointer
;	O
bfd_boolean	int
multiple_sections_found	int
;	O
}	O
section_iterator_callback_data	struct
;	O
static	O
bfd_boolean	int
section_iterator_callback	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
s	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
section_iterator_callback_data	struct
*	O
d	pointer
=	O
(	O
section_iterator_callback_data	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
d	pointer
->	O
found_section	pointer
!=	O
NULL	O
)	O
{	O
d	pointer
->	O
multiple_sections_found	int
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
d	pointer
->	O
found_section	pointer
=	O
s	pointer
;	O
return	O
FALSE	int
;	O
}	O
static	O
asection	struct
*	O
find_section	function
(	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
,	O
bfd_boolean	int
*	O
multiple_sections_found	int
)	O
{	O
section_iterator_callback_data	struct
cb_data	struct
=	O
{	O
NULL	O
,	O
FALSE	int
}	O
;	O
bfd_get_section_by_name_if	function
(	O
file	pointer
->	O
the_bfd	pointer
,	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
,	O
section_iterator_callback	function
,	O
&	O
cb_data	struct
)	O
;	O
*	O
multiple_sections_found	int
=	O
cb_data	struct
.	O
multiple_sections_found	int
;	O
return	O
cb_data	struct
.	O
found_section	pointer
;	O
}	O
static	O
bfd_boolean	int
is_simple_wild	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
=	O
strcspn	function
(	O
name	pointer
,	O
"*?["	pointer
)	O
;	O
return	O
len	long
>=	O
4	int
&&	O
name	pointer
[	O
len	long
]	O
==	O
'*'	O
&&	O
name	pointer
[	O
len	long
+	O
1	int
]	O
==	O
'\0'	O
;	O
}	O
static	O
bfd_boolean	int
match_simple_wild	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
pattern	pointer
[	O
0	int
]	O
!=	O
name	pointer
[	O
0	int
]	O
||	O
pattern	pointer
[	O
1	int
]	O
!=	O
name	pointer
[	O
1	int
]	O
||	O
pattern	pointer
[	O
2	int
]	O
!=	O
name	pointer
[	O
2	int
]	O
||	O
pattern	pointer
[	O
3	int
]	O
!=	O
name	pointer
[	O
3	int
]	O
)	O
return	O
FALSE	int
;	O
pattern	pointer
+=	O
4	int
;	O
name	pointer
+=	O
4	int
;	O
while	O
(	O
*	O
pattern	pointer
!=	O
'*'	O
)	O
if	O
(	O
*	O
name	pointer
++	O
!=	O
*	O
pattern	pointer
++	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
get_init_priority	function
(	O
const	O
asection	struct
*	O
sec	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
const	O
char	O
*	O
dot	long
;	O
dot	long
=	O
strrchr	function
(	O
name	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
dot	long
!=	O
NULL	O
&&	O
ISDIGIT	O
(	O
dot	long
[	O
1	int
]	O
)	O
)	O
{	O
char	O
*	O
end	pointer
;	O
unsigned	O
long	O
init_priority	long
=	O
strtoul	function
(	O
dot	long
+	O
1	int
,	O
&	O
end	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
end	pointer
==	O
0	int
)	O
{	O
if	O
(	O
dot	long
==	O
name	pointer
+	O
6	int
&&	O
(	O
strncmp	function
(	O
name	pointer
,	O
".ctors"	pointer
,	O
6	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
name	pointer
,	O
".dtors"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
)	O
init_priority	long
=	O
65535	int
-	O
init_priority	long
;	O
if	O
(	O
init_priority	long
<=	O
INT_MAX	O
)	O
return	O
init_priority	long
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
compare_section	function
(	O
sort_type	enum
sort	enum
,	O
asection	struct
*	O
asec	pointer
,	O
asection	struct
*	O
bsec	pointer
)	O
{	O
int	O
ret	pointer
;	O
int	O
a_priority	int
,	O
b_priority	int
;	O
switch	O
(	O
sort	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
by_init_priority	int
:	O
a_priority	int
=	O
get_init_priority	function
(	O
asec	pointer
)	O
;	O
b_priority	int
=	O
get_init_priority	function
(	O
bsec	pointer
)	O
;	O
if	O
(	O
a_priority	int
<	O
0	int
||	O
b_priority	int
<	O
0	int
)	O
goto	O
sort_by_name	O
;	O
ret	pointer
=	O
a_priority	int
-	O
b_priority	int
;	O
if	O
(	O
ret	pointer
)	O
break	O
;	O
else	O
goto	O
sort_by_name	O
;	O
case	O
by_alignment_name	int
:	O
ret	pointer
=	O
bfd_section_alignment	function
(	O
bsec	pointer
)	O
-	O
bfd_section_alignment	function
(	O
asec	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
break	O
;	O
case	O
by_name	int
:	O
sort_by_name	O
:	O
ret	pointer
=	O
strcmp	function
(	O
bfd_section_name	function
(	O
asec	pointer
)	O
,	O
bfd_section_name	function
(	O
bsec	pointer
)	O
)	O
;	O
break	O
;	O
case	O
by_name_alignment	int
:	O
ret	pointer
=	O
strcmp	function
(	O
bfd_section_name	function
(	O
asec	pointer
)	O
,	O
bfd_section_name	function
(	O
bsec	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
)	O
break	O
;	O
case	O
by_alignment	int
:	O
ret	pointer
=	O
bfd_section_alignment	function
(	O
bsec	pointer
)	O
-	O
bfd_section_alignment	function
(	O
asec	pointer
)	O
;	O
break	O
;	O
}	O
return	O
ret	pointer
;	O
}	O
static	O
lang_section_bst_type	struct
*	O
*	O
wild_sort_fast	function
(	O
lang_wild_statement_type	struct
*	O
wild	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
section	pointer
)	O
{	O
lang_section_bst_type	struct
*	O
*	O
tree	pointer
;	O
tree	pointer
=	O
&	O
wild	pointer
->	O
tree	pointer
;	O
if	O
(	O
!	O
wild	pointer
->	O
filenames_sorted	int
&&	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
==	O
none	int
)	O
)	O
{	O
while	O
(	O
*	O
tree	pointer
)	O
tree	pointer
=	O
&	O
(	O
(	O
*	O
tree	pointer
)	O
->	O
right	pointer
)	O
;	O
return	O
tree	pointer
;	O
}	O
while	O
(	O
*	O
tree	pointer
)	O
{	O
if	O
(	O
compare_section	function
(	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
,	O
section	pointer
,	O
(	O
*	O
tree	pointer
)	O
->	O
section	pointer
)	O
<	O
0	int
)	O
tree	pointer
=	O
&	O
(	O
(	O
*	O
tree	pointer
)	O
->	O
left	pointer
)	O
;	O
else	O
tree	pointer
=	O
&	O
(	O
(	O
*	O
tree	pointer
)	O
->	O
right	pointer
)	O
;	O
}	O
return	O
tree	pointer
;	O
}	O
static	O
void	O
output_section_callback_fast	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
,	O
asection	struct
*	O
section	pointer
,	O
struct	O
flag_info	struct
*	O
sflag_list	pointer
ATTRIBUTE_UNUSED	O
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
void	O
*	O
output	pointer
)	O
{	O
lang_section_bst_type	struct
*	O
node	pointer
;	O
lang_section_bst_type	struct
*	O
*	O
tree	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
(	O
lang_output_section_statement_type	struct
*	O
)	O
output	pointer
;	O
if	O
(	O
unique_section_p	function
(	O
section	pointer
,	O
os	int
)	O
)	O
return	O
;	O
node	pointer
=	O
(	O
lang_section_bst_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
lang_section_bst_type	struct
)	O
)	O
;	O
node	pointer
->	O
left	pointer
=	O
0	int
;	O
node	pointer
->	O
right	pointer
=	O
0	int
;	O
node	pointer
->	O
section	pointer
=	O
section	pointer
;	O
tree	pointer
=	O
wild_sort_fast	function
(	O
ptr	pointer
,	O
sec	pointer
,	O
file	pointer
,	O
section	pointer
)	O
;	O
if	O
(	O
tree	pointer
!=	O
NULL	O
)	O
*	O
tree	pointer
=	O
node	pointer
;	O
}	O
static	O
void	O
output_section_callback_tree_to_list	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_section_bst_type	struct
*	O
tree	pointer
,	O
void	O
*	O
output	pointer
)	O
{	O
if	O
(	O
tree	pointer
->	O
left	pointer
)	O
output_section_callback_tree_to_list	function
(	O
ptr	pointer
,	O
tree	pointer
->	O
left	pointer
,	O
output	pointer
)	O
;	O
lang_add_section	function
(	O
&	O
ptr	pointer
->	O
children	struct
,	O
tree	pointer
->	O
section	pointer
,	O
NULL	O
,	O
(	O
lang_output_section_statement_type	struct
*	O
)	O
output	pointer
)	O
;	O
if	O
(	O
tree	pointer
->	O
right	pointer
)	O
output_section_callback_tree_to_list	function
(	O
ptr	pointer
,	O
tree	pointer
->	O
right	pointer
,	O
output	pointer
)	O
;	O
free	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
walk_wild_section_specs1_wild0	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
bfd_boolean	int
multiple_sections_found	int
;	O
struct	O
wildcard_list	struct
*	O
sec0	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
0	int
]	O
;	O
asection	struct
*	O
s0	pointer
=	O
find_section	function
(	O
file	pointer
,	O
sec0	pointer
,	O
&	O
multiple_sections_found	int
)	O
;	O
if	O
(	O
multiple_sections_found	int
)	O
walk_wild_section_general	function
(	O
ptr	pointer
,	O
file	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
if	O
(	O
s0	pointer
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s0	pointer
,	O
sec0	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
static	O
void	O
walk_wild_section_specs1_wild1	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
struct	O
wildcard_list	struct
*	O
wildsec0	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
0	int
]	O
;	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
bfd_boolean	int
skip	int
=	O
!	O
match_simple_wild	function
(	O
wildsec0	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
;	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
wildsec0	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
static	O
void	O
walk_wild_section_specs2_wild1	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
struct	O
wildcard_list	struct
*	O
sec0	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
0	int
]	O
;	O
struct	O
wildcard_list	struct
*	O
wildsec1	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
1	int
]	O
;	O
bfd_boolean	int
multiple_sections_found	int
;	O
asection	struct
*	O
s0	pointer
=	O
find_section	function
(	O
file	pointer
,	O
sec0	pointer
,	O
&	O
multiple_sections_found	int
)	O
;	O
if	O
(	O
multiple_sections_found	int
)	O
{	O
walk_wild_section_general	function
(	O
ptr	pointer
,	O
file	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
==	O
s0	pointer
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
sec0	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
bfd_boolean	int
skip	int
=	O
!	O
match_simple_wild	function
(	O
wildsec1	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
;	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
wildsec1	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
walk_wild_section_specs3_wild2	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
struct	O
wildcard_list	struct
*	O
sec0	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
0	int
]	O
;	O
struct	O
wildcard_list	struct
*	O
wildsec1	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
1	int
]	O
;	O
struct	O
wildcard_list	struct
*	O
wildsec2	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
2	int
]	O
;	O
bfd_boolean	int
multiple_sections_found	int
;	O
asection	struct
*	O
s0	pointer
=	O
find_section	function
(	O
file	pointer
,	O
sec0	pointer
,	O
&	O
multiple_sections_found	int
)	O
;	O
if	O
(	O
multiple_sections_found	int
)	O
{	O
walk_wild_section_general	function
(	O
ptr	pointer
,	O
file	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
==	O
s0	pointer
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
sec0	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
bfd_boolean	int
skip	int
=	O
!	O
match_simple_wild	function
(	O
wildsec1	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
;	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
wildsec1	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
{	O
skip	int
=	O
!	O
match_simple_wild	function
(	O
wildsec2	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
;	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
wildsec2	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
walk_wild_section_specs4_wild2	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
struct	O
wildcard_list	struct
*	O
sec0	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
0	int
]	O
;	O
struct	O
wildcard_list	struct
*	O
sec1	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
1	int
]	O
;	O
struct	O
wildcard_list	struct
*	O
wildsec2	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
2	int
]	O
;	O
struct	O
wildcard_list	struct
*	O
wildsec3	pointer
=	O
ptr	pointer
->	O
handler_data	array
[	O
3	int
]	O
;	O
bfd_boolean	int
multiple_sections_found	int
;	O
asection	struct
*	O
s0	pointer
=	O
find_section	function
(	O
file	pointer
,	O
sec0	pointer
,	O
&	O
multiple_sections_found	int
)	O
,	O
*	O
s1	pointer
;	O
if	O
(	O
multiple_sections_found	int
)	O
{	O
walk_wild_section_general	function
(	O
ptr	pointer
,	O
file	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
return	O
;	O
}	O
s1	pointer
=	O
find_section	function
(	O
file	pointer
,	O
sec1	pointer
,	O
&	O
multiple_sections_found	int
)	O
;	O
if	O
(	O
multiple_sections_found	int
)	O
{	O
walk_wild_section_general	function
(	O
ptr	pointer
,	O
file	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
==	O
s0	pointer
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
sec0	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
if	O
(	O
s	pointer
==	O
s1	pointer
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
sec1	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
bfd_boolean	int
skip	int
=	O
!	O
match_simple_wild	function
(	O
wildsec2	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
;	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
wildsec2	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
{	O
skip	int
=	O
!	O
match_simple_wild	function
(	O
wildsec3	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sname	pointer
)	O
;	O
if	O
(	O
!	O
skip	int
)	O
walk_wild_consider_section	function
(	O
ptr	pointer
,	O
file	pointer
,	O
s	pointer
,	O
wildsec3	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
walk_wild_section	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
file	pointer
->	O
flags	int
.	O
just_syms	int
)	O
return	O
;	O
(	O
*	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
)	O
(	O
ptr	pointer
,	O
file	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
wild_spec_can_overlap	function
(	O
const	O
char	O
*	O
name1	pointer
,	O
const	O
char	O
*	O
name2	pointer
)	O
{	O
size_t	long
prefix1_len	long
=	O
strcspn	function
(	O
name1	pointer
,	O
"?*["	pointer
)	O
;	O
size_t	long
prefix2_len	long
=	O
strcspn	function
(	O
name2	pointer
,	O
"?*["	pointer
)	O
;	O
size_t	long
min_prefix_len	long
;	O
if	O
(	O
name1	pointer
[	O
prefix1_len	long
]	O
==	O
'\0'	O
)	O
prefix1_len	long
++	O
;	O
if	O
(	O
name2	pointer
[	O
prefix2_len	long
]	O
==	O
'\0'	O
)	O
prefix2_len	long
++	O
;	O
min_prefix_len	long
=	O
prefix1_len	long
<	O
prefix2_len	long
?	O
prefix1_len	long
:	O
prefix2_len	long
;	O
return	O
memcmp	function
(	O
name1	pointer
,	O
name2	pointer
,	O
min_prefix_len	long
)	O
==	O
0	int
;	O
}	O
static	O
void	O
analyze_walk_wild_section_handler	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
)	O
{	O
int	O
sec_count	int
=	O
0	int
;	O
int	O
wild_name_count	int
=	O
0	int
;	O
struct	O
wildcard_list	struct
*	O
sec	pointer
;	O
int	O
signature	int
;	O
int	O
data_counter	int
;	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
=	O
walk_wild_section_general	function
;	O
ptr	pointer
->	O
handler_data	array
[	O
0	int
]	O
=	O
NULL	O
;	O
ptr	pointer
->	O
handler_data	array
[	O
1	int
]	O
=	O
NULL	O
;	O
ptr	pointer
->	O
handler_data	array
[	O
2	int
]	O
=	O
NULL	O
;	O
ptr	pointer
->	O
handler_data	array
[	O
3	int
]	O
=	O
NULL	O
;	O
ptr	pointer
->	O
tree	pointer
=	O
NULL	O
;	O
for	O
(	O
sec	pointer
=	O
ptr	pointer
->	O
section_list	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
++	O
sec_count	int
;	O
if	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
wildcardp	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
)	O
)	O
{	O
++	O
wild_name_count	int
;	O
if	O
(	O
!	O
is_simple_wild	function
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
)	O
)	O
return	O
;	O
}	O
}	O
if	O
(	O
sec_count	int
==	O
0	int
||	O
sec_count	int
>	O
4	int
)	O
return	O
;	O
for	O
(	O
sec	pointer
=	O
ptr	pointer
->	O
section_list	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
struct	O
wildcard_list	struct
*	O
sec2	pointer
;	O
for	O
(	O
sec2	pointer
=	O
sec	pointer
->	O
next	pointer
;	O
sec2	pointer
!=	O
NULL	O
;	O
sec2	pointer
=	O
sec2	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
wild_spec_can_overlap	function
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
,	O
sec2	pointer
->	O
spec	struct
.	O
name	pointer
)	O
)	O
return	O
;	O
}	O
}	O
signature	int
=	O
(	O
sec_count	int
<<	O
8	int
)	O
+	O
wild_name_count	int
;	O
switch	O
(	O
signature	int
)	O
{	O
case	O
0x0100	int
:	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
=	O
walk_wild_section_specs1_wild0	function
;	O
break	O
;	O
case	O
0x0101	int
:	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
=	O
walk_wild_section_specs1_wild1	function
;	O
break	O
;	O
case	O
0x0201	int
:	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
=	O
walk_wild_section_specs2_wild1	function
;	O
break	O
;	O
case	O
0x0302	int
:	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
=	O
walk_wild_section_specs3_wild2	function
;	O
break	O
;	O
case	O
0x0402	int
:	O
ptr	pointer
->	O
walk_wild_section_handler	pointer
=	O
walk_wild_section_specs4_wild2	function
;	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
data_counter	int
=	O
0	int
;	O
for	O
(	O
sec	pointer
=	O
ptr	pointer
->	O
section_list	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
wildcardp	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
)	O
)	O
ptr	pointer
->	O
handler_data	array
[	O
data_counter	int
++	O
]	O
=	O
sec	pointer
;	O
for	O
(	O
sec	pointer
=	O
ptr	pointer
->	O
section_list	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
wildcardp	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
)	O
)	O
ptr	pointer
->	O
handler_data	array
[	O
data_counter	int
++	O
]	O
=	O
sec	pointer
;	O
}	O
static	O
void	O
walk_wild_file	function
(	O
lang_wild_statement_type	struct
*	O
s	pointer
,	O
lang_input_statement_type	struct
*	O
f	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
walk_wild_file_in_exclude_list	function
(	O
s	pointer
->	O
exclude_name_list	pointer
,	O
f	pointer
)	O
)	O
return	O
;	O
if	O
(	O
f	pointer
->	O
the_bfd	pointer
==	O
NULL	O
||	O
!	O
bfd_check_format	function
(	O
f	pointer
->	O
the_bfd	pointer
,	O
bfd_archive	int
)	O
)	O
walk_wild_section	function
(	O
s	pointer
,	O
f	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
else	O
{	O
bfd	struct
*	O
member	pointer
;	O
member	pointer
=	O
bfd_openr_next_archived_file	function
(	O
f	pointer
->	O
the_bfd	pointer
,	O
NULL	O
)	O
;	O
while	O
(	O
member	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bfd_usrdata	function
(	O
member	pointer
)	O
!=	O
NULL	O
)	O
walk_wild_section	function
(	O
s	pointer
,	O
bfd_usrdata	function
(	O
member	pointer
)	O
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
member	pointer
=	O
bfd_openr_next_archived_file	function
(	O
f	pointer
->	O
the_bfd	pointer
,	O
member	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
walk_wild	function
(	O
lang_wild_statement_type	struct
*	O
s	pointer
,	O
callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
const	O
char	O
*	O
file_spec	pointer
=	O
s	pointer
->	O
filename	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
file_spec	pointer
==	O
NULL	O
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
f	pointer
)	O
{	O
walk_wild_file	function
(	O
s	pointer
,	O
f	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
p	pointer
=	O
archive_path	function
(	O
file_spec	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
f	pointer
)	O
{	O
if	O
(	O
input_statement_is_archive_path	function
(	O
file_spec	pointer
,	O
p	pointer
,	O
f	pointer
)	O
)	O
walk_wild_file	function
(	O
s	pointer
,	O
f	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
wildcardp	O
(	O
file_spec	pointer
)	O
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
f	pointer
)	O
{	O
if	O
(	O
fnmatch	function
(	O
file_spec	pointer
,	O
f	pointer
->	O
filename	pointer
,	O
0	int
)	O
==	O
0	int
)	O
walk_wild_file	function
(	O
s	pointer
,	O
f	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
else	O
{	O
lang_input_statement_type	struct
*	O
f	pointer
;	O
f	pointer
=	O
lookup_name	function
(	O
file_spec	pointer
)	O
;	O
if	O
(	O
f	pointer
)	O
walk_wild_file	function
(	O
s	pointer
,	O
f	pointer
,	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
}	O
void	O
lang_for_each_statement_worker	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
lang_statement_union_type	union
*	O
)	O
,	O
lang_statement_union_type	union
*	O
s	pointer
)	O
{	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
func	pointer
(	O
s	pointer
)	O
;	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_constructors_statement_enum	int
:	O
lang_for_each_statement_worker	function
(	O
func	pointer
,	O
constructor_list	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
if	O
(	O
s	pointer
->	O
output_section_statement	struct
.	O
constraint	int
!=	O
-	O
1	int
)	O
lang_for_each_statement_worker	function
(	O
func	pointer
,	O
s	pointer
->	O
output_section_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_wild_statement_enum	int
:	O
lang_for_each_statement_worker	function
(	O
func	pointer
,	O
s	pointer
->	O
wild_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
lang_for_each_statement_worker	function
(	O
func	pointer
,	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_data_statement_enum	int
:	O
case	O
lang_reloc_statement_enum	int
:	O
case	O
lang_object_symbols_statement_enum	int
:	O
case	O
lang_output_statement_enum	int
:	O
case	O
lang_target_statement_enum	int
:	O
case	O
lang_input_section_enum	int
:	O
case	O
lang_input_statement_enum	int
:	O
case	O
lang_assignment_statement_enum	int
:	O
case	O
lang_padding_statement_enum	int
:	O
case	O
lang_address_statement_enum	int
:	O
case	O
lang_fill_statement_enum	int
:	O
case	O
lang_insert_statement_enum	int
:	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
lang_for_each_statement	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
lang_statement_union_type	union
*	O
)	O
)	O
{	O
lang_for_each_statement_worker	function
(	O
func	pointer
,	O
statement_list	struct
.	O
head	pointer
)	O
;	O
}	O
void	O
lang_list_init	function
(	O
lang_statement_list_type	struct
*	O
list	pointer
)	O
{	O
list	pointer
->	O
head	pointer
=	O
NULL	O
;	O
list	pointer
->	O
tail	pointer
=	O
&	O
list	pointer
->	O
head	pointer
;	O
}	O
static	O
void	O
lang_statement_append	function
(	O
lang_statement_list_type	struct
*	O
list	pointer
,	O
void	O
*	O
element	pointer
,	O
void	O
*	O
field	pointer
)	O
{	O
*	O
(	O
list	pointer
->	O
tail	pointer
)	O
=	O
element	pointer
;	O
list	pointer
->	O
tail	pointer
=	O
field	pointer
;	O
}	O
void	O
push_stat_ptr	function
(	O
lang_statement_list_type	struct
*	O
new_ptr	pointer
)	O
{	O
if	O
(	O
stat_save_ptr	pointer
>=	O
stat_save	array
+	O
sizeof	O
(	O
stat_save	array
)	O
/	O
sizeof	O
(	O
stat_save	array
[	O
0	int
]	O
)	O
)	O
abort	function
(	O
)	O
;	O
*	O
stat_save_ptr	pointer
++	O
=	O
stat_ptr	pointer
;	O
stat_ptr	pointer
=	O
new_ptr	pointer
;	O
}	O
void	O
pop_stat_ptr	function
(	O
void	O
)	O
{	O
if	O
(	O
stat_save_ptr	pointer
<=	O
stat_save	array
)	O
abort	function
(	O
)	O
;	O
stat_ptr	pointer
=	O
*	O
--	O
stat_save_ptr	pointer
;	O
}	O
static	O
lang_statement_union_type	union
*	O
new_statement	function
(	O
enum	O
statement_enum	enum
type	enum
,	O
size_t	long
size	int
,	O
lang_statement_list_type	struct
*	O
list	pointer
)	O
{	O
lang_statement_union_type	union
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
stat_alloc	function
(	O
size	int
)	O
;	O
new_stmt	pointer
->	O
header	struct
.	O
type	enum
=	O
type	enum
;	O
new_stmt	pointer
->	O
header	struct
.	O
next	pointer
=	O
NULL	O
;	O
lang_statement_append	function
(	O
list	pointer
,	O
new_stmt	pointer
,	O
&	O
new_stmt	pointer
->	O
header	struct
.	O
next	pointer
)	O
;	O
return	O
new_stmt	pointer
;	O
}	O
static	O
lang_input_statement_type	struct
*	O
new_afile	function
(	O
const	O
char	O
*	O
name	pointer
,	O
lang_input_file_enum_type	enum
file_type	enum
,	O
const	O
char	O
*	O
target	pointer
)	O
{	O
lang_input_statement_type	struct
*	O
p	pointer
;	O
lang_has_input_file	int
=	O
TRUE	int
;	O
p	pointer
=	O
new_stat	O
(	O
lang_input_statement	O
,	O
stat_ptr	pointer
)	O
;	O
memset	function
(	O
&	O
p	pointer
->	O
the_bfd	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
p	pointer
)	O
-	O
offsetof	O
(	O
lang_input_statement_type	struct
,	O
the_bfd	pointer
)	O
)	O
;	O
p	pointer
->	O
target	pointer
=	O
target	pointer
;	O
p	pointer
->	O
flags	int
.	O
dynamic	int
=	O
input_flags	struct
.	O
dynamic	int
;	O
p	pointer
->	O
flags	int
.	O
add_DT_NEEDED_for_dynamic	int
=	O
input_flags	struct
.	O
add_DT_NEEDED_for_dynamic	int
;	O
p	pointer
->	O
flags	int
.	O
add_DT_NEEDED_for_regular	int
=	O
input_flags	struct
.	O
add_DT_NEEDED_for_regular	int
;	O
p	pointer
->	O
flags	int
.	O
whole_archive	int
=	O
input_flags	struct
.	O
whole_archive	int
;	O
p	pointer
->	O
flags	int
.	O
sysrooted	int
=	O
input_flags	struct
.	O
sysrooted	int
;	O
switch	O
(	O
file_type	enum
)	O
{	O
case	O
lang_input_file_is_symbols_only_enum	int
:	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
p	pointer
->	O
local_sym_name	pointer
=	O
name	pointer
;	O
p	pointer
->	O
flags	int
.	O
real	int
=	O
TRUE	int
;	O
p	pointer
->	O
flags	int
.	O
just_syms	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
lang_input_file_is_fake_enum	int
:	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
p	pointer
->	O
local_sym_name	pointer
=	O
name	pointer
;	O
break	O
;	O
case	O
lang_input_file_is_l_enum	int
:	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
':'	O
&&	O
name	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
+	O
1	int
;	O
p	pointer
->	O
flags	int
.	O
full_name_provided	int
=	O
TRUE	int
;	O
}	O
else	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
p	pointer
->	O
local_sym_name	pointer
=	O
concat	function
(	O
"-l"	pointer
,	O
name	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
p	pointer
->	O
flags	int
.	O
maybe_archive	int
=	O
TRUE	int
;	O
p	pointer
->	O
flags	int
.	O
real	int
=	O
TRUE	int
;	O
p	pointer
->	O
flags	int
.	O
search_dirs	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
lang_input_file_is_marker_enum	int
:	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
p	pointer
->	O
local_sym_name	pointer
=	O
name	pointer
;	O
p	pointer
->	O
flags	int
.	O
search_dirs	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
lang_input_file_is_search_file_enum	int
:	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
p	pointer
->	O
local_sym_name	pointer
=	O
name	pointer
;	O
p	pointer
->	O
flags	int
.	O
real	int
=	O
TRUE	int
;	O
p	pointer
->	O
flags	int
.	O
search_dirs	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
lang_input_file_is_file_enum	int
:	O
p	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
p	pointer
->	O
local_sym_name	pointer
=	O
name	pointer
;	O
p	pointer
->	O
flags	int
.	O
real	int
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
}	O
lang_statement_append	function
(	O
&	O
input_file_chain	struct
,	O
p	pointer
,	O
&	O
p	pointer
->	O
next_real_file	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
lang_input_statement_type	struct
*	O
lang_add_input_file	function
(	O
const	O
char	O
*	O
name	pointer
,	O
lang_input_file_enum_type	enum
file_type	enum
,	O
const	O
char	O
*	O
target	pointer
)	O
{	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
(	O
*	O
name	pointer
==	O
'='	O
||	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
"$SYSROOT"	pointer
)	O
)	O
)	O
{	O
lang_input_statement_type	struct
*	O
ret	pointer
;	O
char	O
*	O
sysrooted_name	pointer
=	O
concat	function
(	O
ld_sysroot	pointer
,	O
name	pointer
+	O
(	O
*	O
name	pointer
==	O
'='	O
?	O
1	int
:	O
strlen	function
(	O
"$SYSROOT"	pointer
)	O
)	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
unsigned	O
int	O
outer_sysrooted	int
=	O
input_flags	struct
.	O
sysrooted	int
;	O
input_flags	struct
.	O
sysrooted	int
=	O
0	int
;	O
ret	pointer
=	O
new_afile	function
(	O
sysrooted_name	pointer
,	O
file_type	enum
,	O
target	pointer
)	O
;	O
input_flags	struct
.	O
sysrooted	int
=	O
outer_sysrooted	int
;	O
return	O
ret	pointer
;	O
}	O
return	O
new_afile	function
(	O
name	pointer
,	O
file_type	enum
,	O
target	pointer
)	O
;	O
}	O
struct	O
out_section_hash_entry	struct
{	O
struct	O
bfd_hash_entry	struct
root	struct
;	O
lang_statement_union_type	union
s	pointer
;	O
}	O
;	O
static	O
struct	O
bfd_hash_table	struct
output_section_statement_table	struct
;	O
static	O
struct	O
bfd_hash_entry	struct
*	O
output_section_statement_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
lang_output_section_statement_type	struct
*	O
*	O
nextp	pointer
;	O
struct	O
out_section_hash_entry	struct
*	O
ret	pointer
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
entry	pointer
=	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
*	O
ret	pointer
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
entry	pointer
;	O
}	O
entry	pointer
=	O
bfd_hash_newfunc	function
(	O
entry	pointer
,	O
table	pointer
,	O
string	pointer
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
entry	pointer
;	O
ret	pointer
=	O
(	O
struct	O
out_section_hash_entry	struct
*	O
)	O
entry	pointer
;	O
memset	function
(	O
&	O
ret	pointer
->	O
s	pointer
,	O
0	int
,	O
sizeof	O
(	O
ret	pointer
->	O
s	pointer
)	O
)	O
;	O
ret	pointer
->	O
s	pointer
.	O
header	struct
.	O
type	enum
=	O
lang_output_section_statement_enum	int
;	O
ret	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
subsection_alignment	pointer
=	O
NULL	O
;	O
ret	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
section_alignment	pointer
=	O
NULL	O
;	O
ret	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
block_value	int
=	O
1	int
;	O
lang_list_init	function
(	O
&	O
ret	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
children	struct
)	O
;	O
lang_statement_append	function
(	O
stat_ptr	pointer
,	O
&	O
ret	pointer
->	O
s	pointer
,	O
&	O
ret	pointer
->	O
s	pointer
.	O
header	struct
.	O
next	pointer
)	O
;	O
if	O
(	O
lang_os_list	struct
.	O
head	pointer
!=	O
NULL	O
)	O
ret	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
prev	pointer
=	O
(	O
(	O
lang_output_section_statement_type	struct
*	O
)	O
(	O
(	O
char	O
*	O
)	O
lang_os_list	struct
.	O
tail	pointer
-	O
offsetof	O
(	O
lang_output_section_statement_type	struct
,	O
next	pointer
)	O
)	O
)	O
;	O
nextp	pointer
=	O
&	O
ret	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
next	pointer
;	O
lang_statement_append	function
(	O
&	O
lang_os_list	struct
,	O
&	O
ret	pointer
->	O
s	pointer
,	O
nextp	pointer
)	O
;	O
return	O
&	O
ret	pointer
->	O
root	struct
;	O
}	O
static	O
void	O
output_section_statement_table_init	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
bfd_hash_table_init_n	function
(	O
&	O
output_section_statement_table	struct
,	O
output_section_statement_newfunc	function
,	O
sizeof	O
(	O
struct	O
out_section_hash_entry	struct
)	O
,	O
61	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can not create hash table: %E\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
output_section_statement_table_free	function
(	O
void	O
)	O
{	O
bfd_hash_table_free	function
(	O
&	O
output_section_statement_table	struct
)	O
;	O
}	O
void	O
lang_init	function
(	O
void	O
)	O
{	O
obstack_begin	O
(	O
&	O
stat_obstack	struct
,	O
1000	int
)	O
;	O
stat_ptr	pointer
=	O
&	O
statement_list	struct
;	O
output_section_statement_table_init	function
(	O
)	O
;	O
lang_list_init	function
(	O
stat_ptr	pointer
)	O
;	O
lang_list_init	function
(	O
&	O
input_file_chain	struct
)	O
;	O
lang_list_init	function
(	O
&	O
lang_os_list	struct
)	O
;	O
lang_list_init	function
(	O
&	O
file_chain	struct
)	O
;	O
first_file	pointer
=	O
lang_add_input_file	function
(	O
NULL	O
,	O
lang_input_file_is_marker_enum	int
,	O
NULL	O
)	O
;	O
abs_output_section	pointer
=	O
lang_output_section_statement_lookup	function
(	O
BFD_ABS_SECTION_NAME	pointer
,	O
0	int
,	O
TRUE	int
)	O
;	O
abs_output_section	pointer
->	O
bfd_section	struct
=	O
bfd_abs_section_ptr	O
;	O
asneeded_list_head	pointer
=	O
NULL	O
;	O
asneeded_list_tail	pointer
=	O
&	O
asneeded_list_head	pointer
;	O
}	O
void	O
lang_finish	function
(	O
void	O
)	O
{	O
output_section_statement_table_free	function
(	O
)	O
;	O
}	O
static	O
lang_memory_region_type	struct
*	O
lang_memory_region_list	pointer
;	O
static	O
lang_memory_region_type	struct
*	O
*	O
lang_memory_region_list_tail	pointer
=	O
&	O
lang_memory_region_list	pointer
;	O
lang_memory_region_type	struct
*	O
lang_memory_region_lookup	function
(	O
const	O
char	O
*	O
const	O
name	pointer
,	O
bfd_boolean	int
create	int
)	O
{	O
lang_memory_region_name	struct
*	O
n	long
;	O
lang_memory_region_type	struct
*	O
r	pointer
;	O
lang_memory_region_type	struct
*	O
new_region	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
r	pointer
=	O
lang_memory_region_list	pointer
;	O
r	pointer
!=	O
NULL	O
;	O
r	pointer
=	O
r	pointer
->	O
next	pointer
)	O
for	O
(	O
n	long
=	O
&	O
r	pointer
->	O
name_list	struct
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
n	long
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
create	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P:%pS: warning: redeclaration of memory region `%s'\n"	pointer
)	O
,	O
NULL	O
,	O
name	pointer
)	O
;	O
return	O
r	pointer
;	O
}	O
if	O
(	O
!	O
create	int
&&	O
strcmp	function
(	O
name	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%P:%pS: warning: memory region `%s' not declared\n"	pointer
)	O
,	O
NULL	O
,	O
name	pointer
)	O
;	O
new_region	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
lang_memory_region_type	struct
)	O
)	O
;	O
new_region	pointer
->	O
name_list	struct
.	O
name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
new_region	pointer
->	O
name_list	struct
.	O
next	pointer
=	O
NULL	O
;	O
new_region	pointer
->	O
next	pointer
=	O
NULL	O
;	O
new_region	pointer
->	O
origin_exp	pointer
=	O
NULL	O
;	O
new_region	pointer
->	O
origin	long
=	O
0	int
;	O
new_region	pointer
->	O
length_exp	pointer
=	O
NULL	O
;	O
new_region	pointer
->	O
length	long
=	O
~	O
(	O
bfd_size_type	long
)	O
0	int
;	O
new_region	pointer
->	O
current	long
=	O
0	int
;	O
new_region	pointer
->	O
last_os	pointer
=	O
NULL	O
;	O
new_region	pointer
->	O
flags	int
=	O
0	int
;	O
new_region	pointer
->	O
not_flags	int
=	O
0	int
;	O
new_region	pointer
->	O
had_full_message	int
=	O
FALSE	int
;	O
*	O
lang_memory_region_list_tail	pointer
=	O
new_region	pointer
;	O
lang_memory_region_list_tail	pointer
=	O
&	O
new_region	pointer
->	O
next	pointer
;	O
return	O
new_region	pointer
;	O
}	O
void	O
lang_memory_region_alias	function
(	O
const	O
char	O
*	O
alias	pointer
,	O
const	O
char	O
*	O
region_name	pointer
)	O
{	O
lang_memory_region_name	struct
*	O
n	long
;	O
lang_memory_region_type	struct
*	O
r	pointer
;	O
lang_memory_region_type	struct
*	O
region	pointer
;	O
if	O
(	O
strcmp	function
(	O
region_name	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
alias	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
==	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: error: alias for default memory region\n"	pointer
)	O
,	O
NULL	O
)	O
;	O
region	pointer
=	O
NULL	O
;	O
for	O
(	O
r	pointer
=	O
lang_memory_region_list	pointer
;	O
r	pointer
!=	O
NULL	O
;	O
r	pointer
=	O
r	pointer
->	O
next	pointer
)	O
for	O
(	O
n	long
=	O
&	O
r	pointer
->	O
name_list	struct
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
{	O
if	O
(	O
region	pointer
==	O
NULL	O
&&	O
strcmp	function
(	O
n	long
->	O
name	pointer
,	O
region_name	pointer
)	O
==	O
0	int
)	O
region	pointer
=	O
r	pointer
;	O
if	O
(	O
strcmp	function
(	O
n	long
->	O
name	pointer
,	O
alias	pointer
)	O
==	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: error: redefinition of memory region "	pointer
"alias `%s'\n"	pointer
)	O
,	O
NULL	O
,	O
alias	pointer
)	O
;	O
}	O
if	O
(	O
region	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: error: memory region `%s' "	pointer
"for alias `%s' does not exist\n"	pointer
)	O
,	O
NULL	O
,	O
region_name	pointer
,	O
alias	pointer
)	O
;	O
n	long
=	O
stat_alloc	function
(	O
sizeof	O
(	O
lang_memory_region_name	struct
)	O
)	O
;	O
n	long
->	O
name	pointer
=	O
xstrdup	function
(	O
alias	pointer
)	O
;	O
n	long
->	O
next	pointer
=	O
region	pointer
->	O
name_list	struct
.	O
next	pointer
;	O
region	pointer
->	O
name_list	struct
.	O
next	pointer
=	O
n	long
;	O
}	O
static	O
lang_memory_region_type	struct
*	O
lang_memory_default	function
(	O
asection	struct
*	O
section	pointer
)	O
{	O
lang_memory_region_type	struct
*	O
p	pointer
;	O
flagword	int
sec_flags	int
=	O
section	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
sec_flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_READONLY	int
|	O
SEC_CODE	int
)	O
)	O
==	O
SEC_ALLOC	int
)	O
sec_flags	int
|=	O
SEC_DATA	int
;	O
for	O
(	O
p	pointer
=	O
lang_memory_region_list	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
p	pointer
->	O
flags	int
&	O
sec_flags	int
)	O
!=	O
0	int
&&	O
(	O
p	pointer
->	O
not_flags	int
&	O
sec_flags	int
)	O
==	O
0	int
)	O
{	O
return	O
p	pointer
;	O
}	O
}	O
return	O
lang_memory_region_lookup	function
(	O
DEFAULT_MEMORY_REGION	pointer
,	O
FALSE	int
)	O
;	O
}	O
lang_output_section_statement_type	struct
*	O
lang_output_section_get	function
(	O
const	O
asection	struct
*	O
output_section	pointer
)	O
{	O
return	O
bfd_section_userdata	function
(	O
output_section	pointer
)	O
;	O
}	O
lang_output_section_statement_type	struct
*	O
lang_output_section_statement_lookup	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
constraint	int
,	O
bfd_boolean	int
create	int
)	O
{	O
struct	O
out_section_hash_entry	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
(	O
(	O
struct	O
out_section_hash_entry	struct
*	O
)	O
bfd_hash_lookup	function
(	O
&	O
output_section_statement_table	struct
,	O
name	pointer
,	O
create	int
,	O
FALSE	int
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
create	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed creating section `%s': %E\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
name	pointer
!=	O
NULL	O
)	O
{	O
struct	O
out_section_hash_entry	struct
*	O
last_ent	pointer
;	O
name	pointer
=	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
name	pointer
;	O
if	O
(	O
create	int
&&	O
constraint	int
==	O
SPECIAL	int
)	O
last_ent	pointer
=	O
entry	pointer
;	O
else	O
do	O
{	O
if	O
(	O
constraint	int
==	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
constraint	int
||	O
(	O
constraint	int
==	O
0	int
&&	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
constraint	int
>=	O
0	int
)	O
)	O
return	O
&	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
;	O
last_ent	pointer
=	O
entry	pointer
;	O
entry	pointer
=	O
(	O
struct	O
out_section_hash_entry	struct
*	O
)	O
entry	pointer
->	O
root	struct
.	O
next	pointer
;	O
}	O
while	O
(	O
entry	pointer
!=	O
NULL	O
&&	O
name	pointer
==	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
name	pointer
)	O
;	O
if	O
(	O
!	O
create	int
)	O
return	O
NULL	O
;	O
entry	pointer
=	O
(	O
(	O
struct	O
out_section_hash_entry	struct
*	O
)	O
output_section_statement_newfunc	function
(	O
NULL	O
,	O
&	O
output_section_statement_table	struct
,	O
name	pointer
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed creating section `%s': %E\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
entry	pointer
->	O
root	struct
=	O
last_ent	pointer
->	O
root	struct
;	O
last_ent	pointer
->	O
root	struct
.	O
next	pointer
=	O
&	O
entry	pointer
->	O
root	struct
;	O
}	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
name	pointer
=	O
name	pointer
;	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
constraint	int
=	O
constraint	int
;	O
return	O
&	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
;	O
}	O
lang_output_section_statement_type	struct
*	O
next_matching_output_section_statement	function
(	O
lang_output_section_statement_type	struct
*	O
os	int
,	O
int	O
constraint	int
)	O
{	O
struct	O
out_section_hash_entry	struct
*	O
entry	pointer
=	O
(	O
struct	O
out_section_hash_entry	struct
*	O
)	O
(	O
(	O
char	O
*	O
)	O
os	int
-	O
offsetof	O
(	O
struct	O
out_section_hash_entry	struct
,	O
s	pointer
.	O
output_section_statement	struct
)	O
)	O
;	O
const	O
char	O
*	O
name	pointer
=	O
os	int
->	O
name	pointer
;	O
ASSERT	O
(	O
name	pointer
==	O
entry	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
do	O
{	O
entry	pointer
=	O
(	O
struct	O
out_section_hash_entry	struct
*	O
)	O
entry	pointer
->	O
root	struct
.	O
next	pointer
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
||	O
name	pointer
!=	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
name	pointer
)	O
return	O
NULL	O
;	O
}	O
while	O
(	O
constraint	int
!=	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
constraint	int
&&	O
(	O
constraint	int
!=	O
0	int
||	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
.	O
constraint	int
<	O
0	int
)	O
)	O
;	O
return	O
&	O
entry	pointer
->	O
s	pointer
.	O
output_section_statement	struct
;	O
}	O
lang_output_section_statement_type	struct
*	O
lang_output_section_find_by_flags	function
(	O
const	O
asection	struct
*	O
sec	pointer
,	O
flagword	int
sec_flags	int
,	O
lang_output_section_statement_type	struct
*	O
*	O
exact	pointer
,	O
lang_match_sec_type_func	pointer
match_type	pointer
)	O
{	O
lang_output_section_statement_type	struct
*	O
first	pointer
,	O
*	O
look	pointer
,	O
*	O
found	pointer
;	O
flagword	int
look_flags	int
,	O
differ	int
;	O
first	pointer
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
first	pointer
=	O
first	pointer
->	O
next	pointer
;	O
found	pointer
=	O
NULL	O
;	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
if	O
(	O
match_type	pointer
&&	O
!	O
match_type	pointer
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
look	pointer
->	O
bfd_section	struct
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
continue	O
;	O
}	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_CODE	int
|	O
SEC_SMALL_DATA	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
if	O
(	O
found	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
exact	pointer
!=	O
NULL	O
)	O
*	O
exact	pointer
=	O
found	pointer
;	O
return	O
found	pointer
;	O
}	O
if	O
(	O
(	O
sec_flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
&&	O
(	O
sec_flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
if	O
(	O
match_type	pointer
&&	O
!	O
match_type	pointer
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
look	pointer
->	O
bfd_section	struct
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
continue	O
;	O
}	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_CODE	int
|	O
SEC_SMALL_DATA	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
}	O
else	O
if	O
(	O
(	O
sec_flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
&&	O
(	O
sec_flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
if	O
(	O
match_type	pointer
&&	O
!	O
match_type	pointer
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
look	pointer
->	O
bfd_section	struct
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
continue	O
;	O
}	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_SMALL_DATA	int
)	O
)	O
||	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
)	O
)	O
&&	O
!	O
(	O
look_flags	int
&	O
SEC_SMALL_DATA	int
)	O
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
}	O
else	O
if	O
(	O
(	O
sec_flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
&&	O
(	O
sec_flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
bfd_boolean	int
seen_thread_local	int
=	O
FALSE	int
;	O
match_type	pointer
=	O
NULL	O
;	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
differ	int
=	O
look_flags	int
^	O
(	O
sec_flags	int
|	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_THREAD_LOCAL	int
|	O
SEC_ALLOC	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
look_flags	int
&	O
SEC_LOAD	int
)	O
&&	O
(	O
sec_flags	int
&	O
SEC_LOAD	int
)	O
)	O
break	O
;	O
found	pointer
=	O
look	pointer
;	O
seen_thread_local	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
seen_thread_local	int
)	O
break	O
;	O
else	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
)	O
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
}	O
else	O
if	O
(	O
(	O
sec_flags	int
&	O
SEC_SMALL_DATA	int
)	O
!=	O
0	int
&&	O
(	O
sec_flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
if	O
(	O
match_type	pointer
&&	O
!	O
match_type	pointer
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
look	pointer
->	O
bfd_section	struct
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
continue	O
;	O
}	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
||	O
(	O
(	O
look_flags	int
&	O
SEC_SMALL_DATA	int
)	O
&&	O
!	O
(	O
sec_flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
}	O
else	O
if	O
(	O
(	O
sec_flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
!=	O
0	int
&&	O
(	O
sec_flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
if	O
(	O
match_type	pointer
&&	O
!	O
match_type	pointer
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
look	pointer
->	O
bfd_section	struct
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
continue	O
;	O
}	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_SMALL_DATA	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
}	O
else	O
if	O
(	O
(	O
sec_flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
if	O
(	O
match_type	pointer
&&	O
!	O
match_type	pointer
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
look	pointer
->	O
bfd_section	struct
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
continue	O
;	O
}	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
SEC_ALLOC	int
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
}	O
else	O
{	O
for	O
(	O
look	pointer
=	O
first	pointer
;	O
look	pointer
;	O
look	pointer
=	O
look	pointer
->	O
next	pointer
)	O
{	O
look_flags	int
=	O
look	pointer
->	O
flags	int
;	O
if	O
(	O
look	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
look_flags	int
=	O
look	pointer
->	O
bfd_section	struct
->	O
flags	int
;	O
differ	int
=	O
look_flags	int
^	O
sec_flags	int
;	O
if	O
(	O
!	O
(	O
differ	int
&	O
SEC_DEBUGGING	int
)	O
)	O
found	pointer
=	O
look	pointer
;	O
}	O
return	O
found	pointer
;	O
}	O
if	O
(	O
found	pointer
||	O
!	O
match_type	pointer
)	O
return	O
found	pointer
;	O
return	O
lang_output_section_find_by_flags	function
(	O
sec	pointer
,	O
sec_flags	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
static	O
asection	struct
*	O
output_prev_sec_find	function
(	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
lookup	pointer
;	O
for	O
(	O
lookup	pointer
=	O
os	int
->	O
prev	pointer
;	O
lookup	pointer
!=	O
NULL	O
;	O
lookup	pointer
=	O
lookup	pointer
->	O
prev	pointer
)	O
{	O
if	O
(	O
lookup	pointer
->	O
constraint	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
lookup	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
lookup	pointer
->	O
bfd_section	struct
->	O
owner	pointer
!=	O
NULL	O
)	O
return	O
lookup	pointer
->	O
bfd_section	struct
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
lang_statement_union_type	union
*	O
*	O
insert_os_after	function
(	O
lang_output_section_statement_type	struct
*	O
after	pointer
)	O
{	O
lang_statement_union_type	union
*	O
*	O
where	long
;	O
lang_statement_union_type	union
*	O
*	O
assign	struct
=	O
NULL	O
;	O
bfd_boolean	int
ignore_first	int
;	O
ignore_first	int
=	O
after	pointer
==	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
for	O
(	O
where	long
=	O
&	O
after	pointer
->	O
header	struct
.	O
next	pointer
;	O
*	O
where	long
!=	O
NULL	O
;	O
where	long
=	O
&	O
(	O
*	O
where	long
)	O
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
(	O
*	O
where	long
)	O
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_assignment_statement_enum	int
:	O
if	O
(	O
assign	struct
==	O
NULL	O
)	O
{	O
lang_assignment_statement_type	struct
*	O
ass	pointer
;	O
ass	pointer
=	O
&	O
(	O
*	O
where	long
)	O
->	O
assignment_statement	struct
;	O
if	O
(	O
ass	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
!=	O
etree_assert	int
&&	O
ass	pointer
->	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
ass	pointer
->	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
ignore_first	int
)	O
assign	struct
=	O
where	long
;	O
ignore_first	int
=	O
FALSE	int
;	O
}	O
}	O
continue	O
;	O
case	O
lang_wild_statement_enum	int
:	O
case	O
lang_input_section_enum	int
:	O
case	O
lang_object_symbols_statement_enum	int
:	O
case	O
lang_fill_statement_enum	int
:	O
case	O
lang_data_statement_enum	int
:	O
case	O
lang_reloc_statement_enum	int
:	O
case	O
lang_padding_statement_enum	int
:	O
case	O
lang_constructors_statement_enum	int
:	O
assign	struct
=	O
NULL	O
;	O
ignore_first	int
=	O
FALSE	int
;	O
continue	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
if	O
(	O
assign	struct
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
s	pointer
=	O
(	O
*	O
where	long
)	O
->	O
output_section_statement	struct
.	O
bfd_section	struct
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
s	pointer
->	O
map_head	union
.	O
s	pointer
==	O
NULL	O
||	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
where	long
=	O
assign	struct
;	O
}	O
break	O
;	O
case	O
lang_input_statement_enum	int
:	O
case	O
lang_address_statement_enum	int
:	O
case	O
lang_target_statement_enum	int
:	O
case	O
lang_output_statement_enum	int
:	O
case	O
lang_group_statement_enum	int
:	O
case	O
lang_insert_statement_enum	int
:	O
continue	O
;	O
}	O
break	O
;	O
}	O
return	O
where	long
;	O
}	O
lang_output_section_statement_type	struct
*	O
lang_insert_orphan	function
(	O
asection	struct
*	O
s	pointer
,	O
const	O
char	O
*	O
secname	pointer
,	O
int	O
constraint	int
,	O
lang_output_section_statement_type	struct
*	O
after	pointer
,	O
struct	O
orphan_save	struct
*	O
place	pointer
,	O
etree_type	union
*	O
address	long
,	O
lang_statement_list_type	struct
*	O
add_child	pointer
)	O
{	O
lang_statement_list_type	struct
add	struct
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
lang_output_section_statement_type	struct
*	O
*	O
os_tail	pointer
;	O
if	O
(	O
after	pointer
!=	O
NULL	O
)	O
{	O
lang_list_init	function
(	O
&	O
add	struct
)	O
;	O
push_stat_ptr	function
(	O
&	O
add	struct
)	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
||	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
0	int
)	O
address	long
=	O
exp_intop	function
(	O
0	int
)	O
;	O
os_tail	pointer
=	O
(	O
lang_output_section_statement_type	struct
*	O
*	O
)	O
lang_os_list	struct
.	O
tail	pointer
;	O
os	int
=	O
lang_enter_output_section_statement	function
(	O
secname	pointer
,	O
address	long
,	O
normal_section	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
constraint	int
,	O
0	int
)	O
;	O
if	O
(	O
add_child	pointer
==	O
NULL	O
)	O
add_child	pointer
=	O
&	O
os	int
->	O
children	struct
;	O
lang_add_section	function
(	O
add_child	pointer
,	O
s	pointer
,	O
NULL	O
,	O
os	int
)	O
;	O
if	O
(	O
after	pointer
&&	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
region	pointer
=	O
(	O
after	pointer
->	O
region	pointer
?	O
after	pointer
->	O
region	pointer
->	O
name_list	struct
.	O
name	pointer
:	O
DEFAULT_MEMORY_REGION	pointer
)	O
;	O
const	O
char	O
*	O
lma_region	pointer
=	O
(	O
after	pointer
->	O
lma_region	pointer
?	O
after	pointer
->	O
lma_region	pointer
->	O
name_list	struct
.	O
name	pointer
:	O
NULL	O
)	O
;	O
lang_leave_output_section_statement	function
(	O
NULL	O
,	O
region	pointer
,	O
after	pointer
->	O
phdrs	pointer
,	O
lma_region	pointer
)	O
;	O
}	O
else	O
lang_leave_output_section_statement	function
(	O
NULL	O
,	O
DEFAULT_MEMORY_REGION	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
after	pointer
!=	O
NULL	O
)	O
pop_stat_ptr	function
(	O
)	O
;	O
if	O
(	O
after	pointer
!=	O
NULL	O
&&	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
snew	pointer
,	O
*	O
as	pointer
;	O
bfd_boolean	int
place_after	int
=	O
place	pointer
->	O
stmt	pointer
==	O
NULL	O
;	O
bfd_boolean	int
insert_after	int
=	O
TRUE	int
;	O
snew	pointer
=	O
os	int
->	O
bfd_section	struct
;	O
if	O
(	O
place	pointer
->	O
section	pointer
==	O
NULL	O
&&	O
after	pointer
!=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
)	O
{	O
asection	struct
*	O
bfd_section	struct
=	O
after	pointer
->	O
bfd_section	struct
;	O
if	O
(	O
bfd_section	struct
==	O
NULL	O
)	O
bfd_section	struct
=	O
output_prev_sec_find	function
(	O
after	pointer
)	O
;	O
if	O
(	O
bfd_section	struct
!=	O
NULL	O
&&	O
bfd_section	struct
!=	O
snew	pointer
)	O
place	pointer
->	O
section	pointer
=	O
&	O
bfd_section	struct
->	O
next	pointer
;	O
}	O
if	O
(	O
place	pointer
->	O
section	pointer
==	O
NULL	O
)	O
place	pointer
->	O
section	pointer
=	O
&	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
as	pointer
=	O
*	O
place	pointer
->	O
section	pointer
;	O
if	O
(	O
!	O
as	pointer
)	O
{	O
bfd_section_list_remove	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
snew	pointer
)	O
;	O
bfd_section_list_append	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
snew	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
&&	O
(	O
bfd_get_flavour	function
(	O
s	pointer
->	O
owner	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
&&	O
(	O
(	O
elf_section_type	O
(	O
s	pointer
)	O
==	O
SHT_NOTE	int
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
||	O
(	O
elf_section_type	O
(	O
as	pointer
)	O
==	O
SHT_NOTE	int
&&	O
(	O
as	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
)	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
asection	struct
*	O
after_sec	pointer
;	O
bfd_boolean	int
after_sec_note	int
=	O
FALSE	int
;	O
static	O
asection	struct
*	O
first_orphan_note	pointer
=	O
NULL	O
;	O
after_sec	pointer
=	O
NULL	O
;	O
if	O
(	O
elf_section_type	O
(	O
s	pointer
)	O
==	O
SHT_NOTE	int
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
{	O
first_orphan_note	pointer
=	O
NULL	O
;	O
for	O
(	O
sec	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
!	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
)	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
sec	pointer
!=	O
snew	pointer
&&	O
elf_section_type	O
(	O
sec	pointer
)	O
==	O
SHT_NOTE	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
first_orphan_note	pointer
)	O
first_orphan_note	pointer
=	O
sec	pointer
;	O
if	O
(	O
sec	pointer
->	O
alignment_power	int
>=	O
s	pointer
->	O
alignment_power	int
)	O
after_sec	pointer
=	O
sec	pointer
;	O
}	O
else	O
if	O
(	O
first_orphan_note	pointer
)	O
{	O
break	O
;	O
}	O
after_sec_note	int
=	O
first_orphan_note	pointer
!=	O
NULL	O
;	O
if	O
(	O
after_sec	pointer
==	O
NULL	O
&&	O
after_sec_note	int
)	O
{	O
after_sec	pointer
=	O
first_orphan_note	pointer
;	O
insert_after	int
=	O
FALSE	int
;	O
}	O
}	O
else	O
if	O
(	O
first_orphan_note	pointer
)	O
{	O
after_sec_note	int
=	O
TRUE	int
;	O
after_sec	pointer
=	O
as	pointer
;	O
for	O
(	O
sec	pointer
=	O
as	pointer
->	O
next	pointer
;	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
!	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
)	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
elf_section_type	O
(	O
sec	pointer
)	O
==	O
SHT_NOTE	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
after_sec	pointer
=	O
sec	pointer
;	O
}	O
if	O
(	O
after_sec_note	int
)	O
{	O
if	O
(	O
after_sec	pointer
)	O
{	O
lang_output_section_statement_type	struct
*	O
stmt	pointer
,	O
*	O
next	pointer
;	O
bfd_boolean	int
found	pointer
=	O
FALSE	int
;	O
for	O
(	O
stmt	pointer
=	O
after	pointer
;	O
stmt	pointer
!=	O
NULL	O
;	O
stmt	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
stmt	pointer
->	O
next	pointer
;	O
if	O
(	O
insert_after	int
)	O
{	O
if	O
(	O
stmt	pointer
->	O
bfd_section	struct
==	O
after_sec	pointer
)	O
{	O
place_after	int
=	O
TRUE	int
;	O
found	pointer
=	O
TRUE	int
;	O
after	pointer
=	O
stmt	pointer
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
next	pointer
&&	O
next	pointer
->	O
bfd_section	struct
==	O
after_sec	pointer
)	O
{	O
place_after	int
=	O
TRUE	int
;	O
found	pointer
=	O
TRUE	int
;	O
after	pointer
=	O
stmt	pointer
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found	pointer
)	O
for	O
(	O
stmt	pointer
=	O
after	pointer
;	O
stmt	pointer
!=	O
NULL	O
;	O
stmt	pointer
=	O
stmt	pointer
->	O
prev	pointer
)	O
{	O
if	O
(	O
insert_after	int
)	O
{	O
if	O
(	O
stmt	pointer
->	O
bfd_section	struct
==	O
after_sec	pointer
)	O
{	O
place_after	int
=	O
TRUE	int
;	O
after	pointer
=	O
stmt	pointer
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
stmt	pointer
->	O
next	pointer
->	O
bfd_section	struct
==	O
after_sec	pointer
)	O
{	O
place_after	int
=	O
TRUE	int
;	O
after	pointer
=	O
stmt	pointer
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
after_sec	pointer
==	O
NULL	O
||	O
(	O
insert_after	int
&&	O
after_sec	pointer
->	O
next	pointer
!=	O
snew	pointer
)	O
||	O
(	O
!	O
insert_after	int
&&	O
after_sec	pointer
->	O
prev	pointer
!=	O
snew	pointer
)	O
)	O
{	O
bfd_section_list_remove	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
snew	pointer
)	O
;	O
if	O
(	O
after_sec	pointer
)	O
{	O
if	O
(	O
insert_after	int
)	O
bfd_section_list_insert_after	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
after_sec	pointer
,	O
snew	pointer
)	O
;	O
else	O
bfd_section_list_insert_before	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
after_sec	pointer
,	O
snew	pointer
)	O
;	O
}	O
else	O
bfd_section_list_prepend	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
snew	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
as	pointer
!=	O
snew	pointer
&&	O
as	pointer
->	O
prev	pointer
!=	O
snew	pointer
)	O
{	O
bfd_section_list_remove	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
snew	pointer
)	O
;	O
bfd_section_list_insert_before	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
as	pointer
,	O
snew	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
as	pointer
!=	O
snew	pointer
&&	O
as	pointer
->	O
prev	pointer
!=	O
snew	pointer
)	O
{	O
bfd_section_list_remove	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
snew	pointer
)	O
;	O
bfd_section_list_insert_before	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
as	pointer
,	O
snew	pointer
)	O
;	O
}	O
place	pointer
->	O
section	pointer
=	O
&	O
snew	pointer
->	O
next	pointer
;	O
if	O
(	O
add	struct
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
lang_output_section_statement_type	struct
*	O
newly_added_os	pointer
;	O
if	O
(	O
place_after	int
)	O
{	O
lang_statement_union_type	union
*	O
*	O
where	long
=	O
insert_os_after	function
(	O
after	pointer
)	O
;	O
*	O
add	struct
.	O
tail	pointer
=	O
*	O
where	long
;	O
*	O
where	long
=	O
add	struct
.	O
head	pointer
;	O
place	pointer
->	O
os_tail	pointer
=	O
&	O
after	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
*	O
add	struct
.	O
tail	pointer
=	O
*	O
place	pointer
->	O
stmt	pointer
;	O
*	O
place	pointer
->	O
stmt	pointer
=	O
add	struct
.	O
head	pointer
;	O
}	O
if	O
(	O
*	O
stat_ptr	pointer
->	O
tail	pointer
==	O
add	struct
.	O
head	pointer
)	O
stat_ptr	pointer
->	O
tail	pointer
=	O
add	struct
.	O
tail	pointer
;	O
place	pointer
->	O
stmt	pointer
=	O
add	struct
.	O
tail	pointer
;	O
newly_added_os	pointer
=	O
*	O
os_tail	pointer
;	O
*	O
os_tail	pointer
=	O
NULL	O
;	O
newly_added_os	pointer
->	O
prev	pointer
=	O
(	O
lang_output_section_statement_type	struct
*	O
)	O
(	O
(	O
char	O
*	O
)	O
place	pointer
->	O
os_tail	pointer
-	O
offsetof	O
(	O
lang_output_section_statement_type	struct
,	O
next	pointer
)	O
)	O
;	O
newly_added_os	pointer
->	O
next	pointer
=	O
*	O
place	pointer
->	O
os_tail	pointer
;	O
if	O
(	O
newly_added_os	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
newly_added_os	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
newly_added_os	pointer
;	O
*	O
place	pointer
->	O
os_tail	pointer
=	O
newly_added_os	pointer
;	O
place	pointer
->	O
os_tail	pointer
=	O
&	O
newly_added_os	pointer
->	O
next	pointer
;	O
if	O
(	O
*	O
os_tail	pointer
==	O
NULL	O
)	O
lang_os_list	struct
.	O
tail	pointer
=	O
(	O
lang_statement_union_type	union
*	O
*	O
)	O
os_tail	pointer
;	O
}	O
}	O
return	O
os	int
;	O
}	O
static	O
void	O
lang_print_asneeded	function
(	O
void	O
)	O
{	O
struct	O
asneeded_minfo	struct
*	O
m	pointer
;	O
if	O
(	O
asneeded_list_head	pointer
==	O
NULL	O
)	O
return	O
;	O
minfo	pointer
(	O
_	O
(	O
"\nAs-needed library included to satisfy reference by file (symbol)\n\n"	pointer
)	O
)	O
;	O
for	O
(	O
m	pointer
=	O
asneeded_list_head	pointer
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
{	O
size_t	long
len	long
;	O
minfo	pointer
(	O
"%s"	pointer
,	O
m	pointer
->	O
soname	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
m	pointer
->	O
soname	pointer
)	O
;	O
if	O
(	O
len	long
>=	O
29	int
)	O
{	O
print_nl	function
(	O
)	O
;	O
len	long
=	O
0	int
;	O
}	O
while	O
(	O
len	long
<	O
30	int
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
if	O
(	O
m	pointer
->	O
ref	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
"%pB "	pointer
,	O
m	pointer
->	O
ref	pointer
)	O
;	O
minfo	pointer
(	O
"(%pT)\n"	pointer
,	O
m	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
lang_map_flags	function
(	O
flagword	int
flag	int
)	O
{	O
if	O
(	O
flag	int
&	O
SEC_ALLOC	int
)	O
minfo	pointer
(	O
"a"	pointer
)	O
;	O
if	O
(	O
flag	int
&	O
SEC_CODE	int
)	O
minfo	pointer
(	O
"x"	pointer
)	O
;	O
if	O
(	O
flag	int
&	O
SEC_READONLY	int
)	O
minfo	pointer
(	O
"r"	pointer
)	O
;	O
if	O
(	O
flag	int
&	O
SEC_DATA	int
)	O
minfo	pointer
(	O
"w"	pointer
)	O
;	O
if	O
(	O
flag	int
&	O
SEC_LOAD	int
)	O
minfo	pointer
(	O
"l"	pointer
)	O
;	O
}	O
void	O
lang_map	function
(	O
void	O
)	O
{	O
lang_memory_region_type	struct
*	O
m	pointer
;	O
bfd_boolean	int
dis_header_printed	int
=	O
FALSE	int
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
file	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
if	O
(	O
(	O
file	pointer
->	O
the_bfd	pointer
->	O
flags	int
&	O
(	O
BFD_LINKER_CREATED	int
|	O
DYNAMIC	int
)	O
)	O
!=	O
0	int
||	O
file	pointer
->	O
flags	int
.	O
just_syms	int
)	O
continue	O
;	O
if	O
(	O
config	struct
.	O
print_map_discarded	int
)	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
output_section	pointer
==	O
NULL	O
||	O
s	pointer
->	O
output_section	pointer
->	O
owner	pointer
!=	O
link_info	struct
.	O
output_bfd	pointer
)	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_LINKER_CREATED	int
|	O
SEC_KEEP	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
dis_header_printed	int
)	O
{	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
_	O
(	O
"\nDiscarded input sections\n\n"	pointer
)	O
)	O
;	O
dis_header_printed	int
=	O
TRUE	int
;	O
}	O
print_input_section	function
(	O
s	pointer
,	O
TRUE	int
)	O
;	O
}	O
}	O
minfo	pointer
(	O
_	O
(	O
"\nMemory Configuration\n\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"%-16s %-18s %-18s %s\n"	pointer
,	O
_	O
(	O
"Name"	pointer
)	O
,	O
_	O
(	O
"Origin"	pointer
)	O
,	O
_	O
(	O
"Length"	pointer
)	O
,	O
_	O
(	O
"Attributes"	pointer
)	O
)	O
;	O
for	O
(	O
m	pointer
=	O
lang_memory_region_list	pointer
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
int	O
len	long
;	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"%-16s "	pointer
,	O
m	pointer
->	O
name_list	struct
.	O
name	pointer
)	O
;	O
sprintf_vma	O
(	O
buf	pointer
,	O
m	pointer
->	O
origin	long
)	O
;	O
minfo	pointer
(	O
"0x%s "	pointer
,	O
buf	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
len	long
<	O
16	int
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
minfo	pointer
(	O
"0x%V"	pointer
,	O
m	pointer
->	O
length	long
)	O
;	O
if	O
(	O
m	pointer
->	O
flags	int
||	O
m	pointer
->	O
not_flags	int
)	O
{	O
if	O
(	O
m	pointer
->	O
flags	int
)	O
{	O
print_space	function
(	O
)	O
;	O
lang_map_flags	function
(	O
m	pointer
->	O
flags	int
)	O
;	O
}	O
if	O
(	O
m	pointer
->	O
not_flags	int
)	O
{	O
minfo	pointer
(	O
" !"	pointer
)	O
;	O
lang_map_flags	function
(	O
m	pointer
->	O
not_flags	int
)	O
;	O
}	O
}	O
print_nl	function
(	O
)	O
;	O
}	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
_	O
(	O
"\nLinker script and memory map\n\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
link_info	struct
.	O
reduce_memory_overheads	int
)	O
{	O
obstack_begin	O
(	O
&	O
map_obstack	struct
,	O
1000	int
)	O
;	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
sort_def_symbol	function
,	O
0	int
)	O
;	O
}	O
expld	struct
.	O
phase	enum
=	O
lang_fixed_phase_enum	int
;	O
lang_statement_iteration	int
++	O
;	O
print_statements	function
(	O
)	O
;	O
ldemul_extra_map_file_text	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
sort_def_symbol	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
hash_entry	pointer
,	O
void	O
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
(	O
hash_entry	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
hash_entry	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
link_info	struct
.	O
output_bfd	pointer
&&	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
)	O
{	O
input_section_userdata_type	struct
*	O
ud	pointer
;	O
struct	O
map_symbol_def	struct
*	O
def	struct
;	O
ud	pointer
=	O
bfd_section_userdata	function
(	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
;	O
if	O
(	O
!	O
ud	pointer
)	O
{	O
ud	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
*	O
ud	pointer
)	O
)	O
;	O
bfd_set_section_userdata	function
(	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
,	O
ud	pointer
)	O
;	O
ud	pointer
->	O
map_symbol_def_tail	pointer
=	O
&	O
ud	pointer
->	O
map_symbol_def_head	pointer
;	O
ud	pointer
->	O
map_symbol_def_count	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
ud	pointer
->	O
map_symbol_def_tail	pointer
)	O
ud	pointer
->	O
map_symbol_def_tail	pointer
=	O
&	O
ud	pointer
->	O
map_symbol_def_head	pointer
;	O
def	struct
=	O
(	O
struct	O
map_symbol_def	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
map_obstack	struct
,	O
sizeof	O
*	O
def	struct
)	O
;	O
def	struct
->	O
entry	pointer
=	O
hash_entry	pointer
;	O
*	O
(	O
ud	pointer
->	O
map_symbol_def_tail	pointer
)	O
=	O
def	struct
;	O
ud	pointer
->	O
map_symbol_def_tail	pointer
=	O
&	O
def	struct
->	O
next	pointer
;	O
ud	pointer
->	O
map_symbol_def_count	long
++	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
init_os	function
(	O
lang_output_section_statement_type	struct
*	O
s	pointer
,	O
flagword	int
flags	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
s	pointer
->	O
name	pointer
,	O
DISCARD_SECTION_NAME	pointer
)	O
==	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: illegal use of `%s' section\n"	pointer
)	O
,	O
DISCARD_SECTION_NAME	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
constraint	int
!=	O
SPECIAL	int
)	O
s	pointer
->	O
bfd_section	struct
=	O
bfd_get_section_by_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
s	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
bfd_section	struct
==	O
NULL	O
)	O
s	pointer
->	O
bfd_section	struct
=	O
bfd_make_section_anyway_with_flags	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
s	pointer
->	O
name	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
->	O
bfd_section	struct
==	O
NULL	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: output format %s cannot represent section"	pointer
" called %s: %E\n"	pointer
)	O
,	O
link_info	struct
.	O
output_bfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
s	pointer
->	O
name	pointer
)	O
;	O
}	O
s	pointer
->	O
bfd_section	struct
->	O
output_section	pointer
=	O
s	pointer
->	O
bfd_section	struct
;	O
s	pointer
->	O
bfd_section	struct
->	O
output_offset	long
=	O
0	int
;	O
bfd_set_section_userdata	function
(	O
s	pointer
->	O
bfd_section	struct
,	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
addr_tree	pointer
!=	O
NULL	O
)	O
exp_init_os	function
(	O
s	pointer
->	O
addr_tree	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
load_base	pointer
!=	O
NULL	O
)	O
exp_init_os	function
(	O
s	pointer
->	O
load_base	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
section_alignment	pointer
!=	O
NULL	O
)	O
s	pointer
->	O
bfd_section	struct
->	O
alignment_power	int
=	O
exp_get_power	function
(	O
s	pointer
->	O
section_alignment	pointer
,	O
"section alignment"	pointer
)	O
;	O
}	O
static	O
void	O
exp_init_os	function
(	O
etree_type	union
*	O
exp	pointer
)	O
{	O
switch	O
(	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
)	O
{	O
case	O
etree_assign	int
:	O
case	O
etree_provide	int
:	O
case	O
etree_provided	int
:	O
exp_init_os	function
(	O
exp	pointer
->	O
assign	struct
.	O
src	pointer
)	O
;	O
break	O
;	O
case	O
etree_binary	int
:	O
exp_init_os	function
(	O
exp	pointer
->	O
binary	int
.	O
lhs	pointer
)	O
;	O
exp_init_os	function
(	O
exp	pointer
->	O
binary	int
.	O
rhs	pointer
)	O
;	O
break	O
;	O
case	O
etree_trinary	int
:	O
exp_init_os	function
(	O
exp	pointer
->	O
trinary	struct
.	O
cond	pointer
)	O
;	O
exp_init_os	function
(	O
exp	pointer
->	O
trinary	struct
.	O
lhs	pointer
)	O
;	O
exp_init_os	function
(	O
exp	pointer
->	O
trinary	struct
.	O
rhs	pointer
)	O
;	O
break	O
;	O
case	O
etree_assert	int
:	O
exp_init_os	function
(	O
exp	pointer
->	O
assert_s	struct
.	O
child	pointer
)	O
;	O
break	O
;	O
case	O
etree_unary	int
:	O
exp_init_os	function
(	O
exp	pointer
->	O
unary	struct
.	O
child	pointer
)	O
;	O
break	O
;	O
case	O
etree_name	int
:	O
switch	O
(	O
exp	pointer
->	O
type	enum
.	O
node_code	int
)	O
{	O
case	O
ADDR	int
:	O
case	O
LOADADDR	int
:	O
case	O
SIZEOF	int
:	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
lang_output_section_find	O
(	O
exp	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
if	O
(	O
os	int
!=	O
NULL	O
&&	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
init_os	function
(	O
os	int
,	O
0	int
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
section_already_linked	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
lang_input_statement_type	struct
*	O
entry	pointer
=	O
(	O
lang_input_statement_type	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
just_syms	int
)	O
{	O
bfd_link_just_syms	O
(	O
abfd	pointer
,	O
sec	pointer
,	O
&	O
link_info	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
(	O
SEC_GROUP	int
|	O
SEC_KEEP	int
|	O
SEC_EXCLUDE	int
)	O
)	O
==	O
SEC_EXCLUDE	int
)	O
sec	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
if	O
(	O
!	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
)	O
bfd_section_already_linked	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
&	O
link_info	struct
)	O
;	O
}	O
static	O
bfd_boolean	int
lang_discard_section_p	function
(	O
asection	struct
*	O
section	pointer
)	O
{	O
bfd_boolean	int
discard	enum
;	O
flagword	int
flags	int
=	O
section	pointer
->	O
flags	int
;	O
discard	enum
=	O
(	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
&&	O
link_info	struct
.	O
resolve_section_groups	int
)	O
discard	enum
=	O
TRUE	int
;	O
if	O
(	O
(	O
link_info	struct
.	O
strip	enum
==	O
strip_debugger	int
||	O
link_info	struct
.	O
strip	enum
==	O
strip_all	int
)	O
&&	O
(	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
discard	enum
=	O
TRUE	int
;	O
return	O
discard	enum
;	O
}	O
void	O
lang_add_section	function
(	O
lang_statement_list_type	struct
*	O
ptr	pointer
,	O
asection	struct
*	O
section	pointer
,	O
struct	O
flag_info	struct
*	O
sflag_info	pointer
,	O
lang_output_section_statement_type	struct
*	O
output	pointer
)	O
{	O
flagword	int
flags	int
=	O
section	pointer
->	O
flags	int
;	O
bfd_boolean	int
discard	enum
;	O
lang_input_section_type	struct
*	O
new_section	pointer
;	O
bfd	struct
*	O
abfd	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
;	O
discard	enum
=	O
lang_discard_section_p	function
(	O
section	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
output	pointer
->	O
name	pointer
,	O
DISCARD_SECTION_NAME	pointer
)	O
==	O
0	int
)	O
discard	enum
=	O
TRUE	int
;	O
if	O
(	O
discard	enum
)	O
{	O
if	O
(	O
section	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
{	O
section	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
sflag_info	pointer
)	O
{	O
bfd_boolean	int
keep	int
;	O
keep	int
=	O
bfd_lookup_section_flags	O
(	O
&	O
link_info	struct
,	O
sflag_info	pointer
,	O
section	pointer
)	O
;	O
if	O
(	O
!	O
keep	int
)	O
return	O
;	O
}	O
if	O
(	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
return	O
;	O
flags	int
&=	O
~	O
SEC_NEVER_LOAD	int
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_GROUP	int
)	O
)	O
==	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_GROUP	int
)	O
)	O
{	O
if	O
(	O
link_info	struct
.	O
resolve_section_groups	int
)	O
flags	int
&=	O
~	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES	int
|	O
SEC_RELOC	int
)	O
;	O
else	O
flags	int
&=	O
~	O
(	O
SEC_LINK_DUPLICATES	int
|	O
SEC_RELOC	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
flags	int
&=	O
~	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES	int
|	O
SEC_RELOC	int
)	O
;	O
switch	O
(	O
output	pointer
->	O
sectype	enum
)	O
{	O
case	O
normal_section	int
:	O
case	O
overlay_section	int
:	O
case	O
first_overlay_section	int
:	O
break	O
;	O
case	O
noalloc_section	int
:	O
flags	int
&=	O
~	O
SEC_ALLOC	int
;	O
break	O
;	O
case	O
noload_section	int
:	O
flags	int
&=	O
~	O
SEC_LOAD	int
;	O
flags	int
|=	O
SEC_NEVER_LOAD	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
flags	int
&=	O
~	O
SEC_HAS_CONTENTS	int
;	O
else	O
flags	int
&=	O
~	O
SEC_ALLOC	int
;	O
break	O
;	O
}	O
if	O
(	O
output	pointer
->	O
bfd_section	struct
==	O
NULL	O
)	O
init_os	function
(	O
output	pointer
,	O
flags	int
)	O
;	O
output	pointer
->	O
bfd_section	struct
->	O
flags	int
&=	O
flags	int
|	O
~	O
SEC_READONLY	int
;	O
if	O
(	O
output	pointer
->	O
bfd_section	struct
->	O
linker_has_input	int
)	O
{	O
flags	int
&=	O
~	O
SEC_READONLY	int
;	O
if	O
(	O
(	O
output	pointer
->	O
bfd_section	struct
->	O
flags	int
&	O
(	O
SEC_MERGE	int
|	O
SEC_STRINGS	int
)	O
)	O
!=	O
(	O
flags	int
&	O
(	O
SEC_MERGE	int
|	O
SEC_STRINGS	int
)	O
)	O
||	O
(	O
(	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
&&	O
output	pointer
->	O
bfd_section	struct
->	O
entsize	int
!=	O
section	pointer
->	O
entsize	int
)	O
)	O
{	O
output	pointer
->	O
bfd_section	struct
->	O
flags	int
&=	O
~	O
(	O
SEC_MERGE	int
|	O
SEC_STRINGS	int
)	O
;	O
flags	int
&=	O
~	O
(	O
SEC_MERGE	int
|	O
SEC_STRINGS	int
)	O
;	O
}	O
}	O
output	pointer
->	O
bfd_section	struct
->	O
flags	int
|=	O
flags	int
;	O
if	O
(	O
!	O
output	pointer
->	O
bfd_section	struct
->	O
linker_has_input	int
)	O
{	O
output	pointer
->	O
bfd_section	struct
->	O
linker_has_input	int
=	O
1	int
;	O
bfd_init_private_section_data	O
(	O
section	pointer
->	O
owner	pointer
,	O
section	pointer
,	O
link_info	struct
.	O
output_bfd	pointer
,	O
output	pointer
->	O
bfd_section	struct
,	O
&	O
link_info	struct
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
)	O
output	pointer
->	O
bfd_section	struct
->	O
entsize	int
=	O
section	pointer
->	O
entsize	int
;	O
}	O
if	O
(	O
(	O
flags	int
&	O
SEC_TIC54X_BLOCK	int
)	O
!=	O
0	int
&&	O
bfd_get_arch	function
(	O
section	pointer
->	O
owner	pointer
)	O
==	O
bfd_arch_tic54x	int
)	O
{	O
output	pointer
->	O
block_value	int
=	O
128	int
;	O
}	O
if	O
(	O
section	pointer
->	O
alignment_power	int
>	O
output	pointer
->	O
bfd_section	struct
->	O
alignment_power	int
)	O
output	pointer
->	O
bfd_section	struct
->	O
alignment_power	int
=	O
section	pointer
->	O
alignment_power	int
;	O
section	pointer
->	O
output_section	pointer
=	O
output	pointer
->	O
bfd_section	struct
;	O
if	O
(	O
!	O
map_head_is_link_order	int
)	O
{	O
asection	struct
*	O
s	pointer
=	O
output	pointer
->	O
bfd_section	struct
->	O
map_tail	union
.	O
s	pointer
;	O
output	pointer
->	O
bfd_section	struct
->	O
map_tail	union
.	O
s	pointer
=	O
section	pointer
;	O
section	pointer
->	O
map_head	union
.	O
s	pointer
=	O
NULL	O
;	O
section	pointer
->	O
map_tail	union
.	O
s	pointer
=	O
s	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
s	pointer
->	O
map_head	union
.	O
s	pointer
=	O
section	pointer
;	O
else	O
output	pointer
->	O
bfd_section	struct
->	O
map_head	union
.	O
s	pointer
=	O
section	pointer
;	O
}	O
new_section	pointer
=	O
new_stat	O
(	O
lang_input_section	O
,	O
ptr	pointer
)	O
;	O
new_section	pointer
->	O
section	pointer
=	O
section	pointer
;	O
}	O
static	O
lang_statement_union_type	union
*	O
wild_sort	function
(	O
lang_wild_statement_type	struct
*	O
wild	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
asection	struct
*	O
section	pointer
)	O
{	O
lang_statement_union_type	union
*	O
l	pointer
;	O
if	O
(	O
!	O
wild	pointer
->	O
filenames_sorted	int
&&	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
==	O
none	int
)	O
)	O
return	O
NULL	O
;	O
for	O
(	O
l	pointer
=	O
wild	pointer
->	O
children	struct
.	O
head	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
lang_input_section_type	struct
*	O
ls	pointer
;	O
if	O
(	O
l	pointer
->	O
header	struct
.	O
type	enum
!=	O
lang_input_section_enum	int
)	O
continue	O
;	O
ls	pointer
=	O
&	O
l	pointer
->	O
input_section	pointer
;	O
if	O
(	O
wild	pointer
->	O
filenames_sorted	int
)	O
{	O
const	O
char	O
*	O
fn	pointer
,	O
*	O
ln	pointer
;	O
bfd_boolean	int
fa	int
,	O
la	int
;	O
int	O
i	pointer
;	O
if	O
(	O
file	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
file	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
!=	O
NULL	O
)	O
{	O
fn	pointer
=	O
bfd_get_filename	function
(	O
file	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
)	O
;	O
fa	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
fn	pointer
=	O
file	pointer
->	O
filename	pointer
;	O
fa	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
ls	pointer
->	O
section	pointer
->	O
owner	pointer
->	O
my_archive	pointer
!=	O
NULL	O
)	O
{	O
ln	pointer
=	O
bfd_get_filename	function
(	O
ls	pointer
->	O
section	pointer
->	O
owner	pointer
->	O
my_archive	pointer
)	O
;	O
la	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
ln	pointer
=	O
ls	pointer
->	O
section	pointer
->	O
owner	pointer
->	O
filename	pointer
;	O
la	int
=	O
FALSE	int
;	O
}	O
i	pointer
=	O
filename_cmp	function
(	O
fn	pointer
,	O
ln	pointer
)	O
;	O
if	O
(	O
i	pointer
>	O
0	int
)	O
continue	O
;	O
else	O
if	O
(	O
i	pointer
<	O
0	int
)	O
break	O
;	O
if	O
(	O
fa	int
||	O
la	int
)	O
{	O
if	O
(	O
fa	int
)	O
fn	pointer
=	O
file	pointer
->	O
filename	pointer
;	O
if	O
(	O
la	int
)	O
ln	pointer
=	O
ls	pointer
->	O
section	pointer
->	O
owner	pointer
->	O
filename	pointer
;	O
i	pointer
=	O
filename_cmp	function
(	O
fn	pointer
,	O
ln	pointer
)	O
;	O
if	O
(	O
i	pointer
>	O
0	int
)	O
continue	O
;	O
else	O
if	O
(	O
i	pointer
<	O
0	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
!=	O
none	int
&&	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
!=	O
by_none	int
)	O
if	O
(	O
compare_section	function
(	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
,	O
section	pointer
,	O
ls	pointer
->	O
section	pointer
)	O
<	O
0	int
)	O
break	O
;	O
}	O
return	O
l	pointer
;	O
}	O
static	O
void	O
output_section_callback	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
,	O
asection	struct
*	O
section	pointer
,	O
struct	O
flag_info	struct
*	O
sflag_info	pointer
,	O
lang_input_statement_type	struct
*	O
file	pointer
,	O
void	O
*	O
output	pointer
)	O
{	O
lang_statement_union_type	union
*	O
before	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
(	O
lang_output_section_statement_type	struct
*	O
)	O
output	pointer
;	O
if	O
(	O
unique_section_p	function
(	O
section	pointer
,	O
os	int
)	O
)	O
return	O
;	O
before	pointer
=	O
wild_sort	function
(	O
ptr	pointer
,	O
sec	pointer
,	O
file	pointer
,	O
section	pointer
)	O
;	O
if	O
(	O
before	pointer
==	O
NULL	O
)	O
lang_add_section	function
(	O
&	O
ptr	pointer
->	O
children	struct
,	O
section	pointer
,	O
sflag_info	pointer
,	O
os	int
)	O
;	O
else	O
{	O
lang_statement_list_type	struct
list	pointer
;	O
lang_statement_union_type	union
*	O
*	O
pp	pointer
;	O
lang_list_init	function
(	O
&	O
list	pointer
)	O
;	O
lang_add_section	function
(	O
&	O
list	pointer
,	O
section	pointer
,	O
sflag_info	pointer
,	O
os	int
)	O
;	O
if	O
(	O
list	pointer
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
ASSERT	O
(	O
list	pointer
.	O
head	pointer
->	O
header	struct
.	O
next	pointer
==	O
NULL	O
)	O
;	O
for	O
(	O
pp	pointer
=	O
&	O
ptr	pointer
->	O
children	struct
.	O
head	pointer
;	O
*	O
pp	pointer
!=	O
before	pointer
;	O
pp	pointer
=	O
&	O
(	O
*	O
pp	pointer
)	O
->	O
header	struct
.	O
next	pointer
)	O
ASSERT	O
(	O
*	O
pp	pointer
!=	O
NULL	O
)	O
;	O
list	pointer
.	O
head	pointer
->	O
header	struct
.	O
next	pointer
=	O
*	O
pp	pointer
;	O
*	O
pp	pointer
=	O
list	pointer
.	O
head	pointer
;	O
}	O
}	O
}	O
static	O
void	O
check_section_callback	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
section	pointer
,	O
struct	O
flag_info	struct
*	O
sflag_info	pointer
ATTRIBUTE_UNUSED	O
,	O
lang_input_statement_type	struct
*	O
file	pointer
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
output	pointer
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
(	O
lang_output_section_statement_type	struct
*	O
)	O
output	pointer
;	O
if	O
(	O
unique_section_p	function
(	O
section	pointer
,	O
os	int
)	O
)	O
return	O
;	O
if	O
(	O
section	pointer
->	O
output_section	pointer
==	O
NULL	O
&&	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
os	int
->	O
all_input_readonly	int
=	O
FALSE	int
;	O
}	O
static	O
lang_input_statement_type	struct
*	O
lookup_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
lang_input_statement_type	struct
*	O
search	pointer
;	O
for	O
(	O
search	pointer
=	O
(	O
void	O
*	O
)	O
input_file_chain	struct
.	O
head	pointer
;	O
search	pointer
!=	O
NULL	O
;	O
search	pointer
=	O
search	pointer
->	O
next_real_file	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
=	O
search	pointer
->	O
local_sym_name	pointer
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
&&	O
filename_cmp	function
(	O
filename	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
search	pointer
==	O
NULL	O
)	O
{	O
lang_statement_union_type	union
*	O
*	O
tail	pointer
=	O
stat_ptr	pointer
->	O
tail	pointer
;	O
lang_statement_union_type	union
*	O
*	O
after	pointer
=	O
(	O
void	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
input_file_chain	struct
.	O
tail	pointer
-	O
offsetof	O
(	O
lang_input_statement_type	struct
,	O
next_real_file	pointer
)	O
+	O
offsetof	O
(	O
lang_input_statement_type	struct
,	O
header	struct
.	O
next	pointer
)	O
)	O
;	O
lang_statement_union_type	union
*	O
rest	pointer
=	O
*	O
after	pointer
;	O
stat_ptr	pointer
->	O
tail	pointer
=	O
after	pointer
;	O
search	pointer
=	O
new_afile	function
(	O
name	pointer
,	O
lang_input_file_is_search_file_enum	int
,	O
default_target	pointer
)	O
;	O
*	O
stat_ptr	pointer
->	O
tail	pointer
=	O
rest	pointer
;	O
if	O
(	O
*	O
tail	pointer
==	O
NULL	O
)	O
stat_ptr	pointer
->	O
tail	pointer
=	O
tail	pointer
;	O
}	O
if	O
(	O
search	pointer
->	O
flags	int
.	O
loaded	int
||	O
!	O
search	pointer
->	O
flags	int
.	O
real	int
)	O
return	O
search	pointer
;	O
if	O
(	O
!	O
load_symbols	function
(	O
search	pointer
,	O
NULL	O
)	O
)	O
return	O
NULL	O
;	O
return	O
search	pointer
;	O
}	O
struct	O
excluded_lib	struct
{	O
char	O
*	O
name	pointer
;	O
struct	O
excluded_lib	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
excluded_lib	struct
*	O
excluded_libs	pointer
;	O
void	O
add_excluded_libs	function
(	O
const	O
char	O
*	O
list	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
list	pointer
,	O
*	O
end	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
struct	O
excluded_lib	struct
*	O
entry	pointer
;	O
end	pointer
=	O
strpbrk	function
(	O
p	pointer
,	O
",:"	pointer
)	O
;	O
if	O
(	O
end	pointer
==	O
NULL	O
)	O
end	pointer
=	O
p	pointer
+	O
strlen	function
(	O
p	pointer
)	O
;	O
entry	pointer
=	O
(	O
struct	O
excluded_lib	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
entry	pointer
)	O
)	O
;	O
entry	pointer
->	O
next	pointer
=	O
excluded_libs	pointer
;	O
entry	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
end	pointer
-	O
p	pointer
+	O
1	int
)	O
;	O
memcpy	function
(	O
entry	pointer
->	O
name	pointer
,	O
p	pointer
,	O
end	pointer
-	O
p	pointer
)	O
;	O
entry	pointer
->	O
name	pointer
[	O
end	pointer
-	O
p	pointer
]	O
=	O
'\0'	O
;	O
excluded_libs	pointer
=	O
entry	pointer
;	O
if	O
(	O
*	O
end	pointer
==	O
'\0'	O
)	O
break	O
;	O
p	pointer
=	O
end	pointer
+	O
1	int
;	O
}	O
}	O
static	O
void	O
check_excluded_libs	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
excluded_lib	struct
*	O
lib	pointer
=	O
excluded_libs	pointer
;	O
while	O
(	O
lib	pointer
)	O
{	O
int	O
len	long
=	O
strlen	function
(	O
lib	pointer
->	O
name	pointer
)	O
;	O
const	O
char	O
*	O
filename	pointer
=	O
lbasename	function
(	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
lib	pointer
->	O
name	pointer
,	O
"ALL"	pointer
)	O
==	O
0	int
)	O
{	O
abfd	pointer
->	O
no_export	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
if	O
(	O
filename_ncmp	function
(	O
lib	pointer
->	O
name	pointer
,	O
filename	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
(	O
filename	pointer
[	O
len	long
]	O
==	O
'\0'	O
||	O
(	O
filename	pointer
[	O
len	long
]	O
==	O
'.'	O
&&	O
filename	pointer
[	O
len	long
+	O
1	int
]	O
==	O
'a'	O
&&	O
filename	pointer
[	O
len	long
+	O
2	int
]	O
==	O
'\0'	O
)	O
)	O
)	O
{	O
abfd	pointer
->	O
no_export	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
lib	pointer
=	O
lib	pointer
->	O
next	pointer
;	O
}	O
}	O
bfd_boolean	int
load_symbols	function
(	O
lang_input_statement_type	struct
*	O
entry	pointer
,	O
lang_statement_list_type	struct
*	O
place	pointer
)	O
{	O
char	O
*	O
*	O
matching	pointer
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
loaded	int
)	O
return	O
TRUE	int
;	O
ldfile_open_file	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
missing_file	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
trace_files	int
||	O
verbose	int
)	O
info_msg	function
(	O
"%pI\n"	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
bfd_archive	int
)	O
&&	O
!	O
bfd_check_format_matches	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
bfd_object	int
,	O
&	O
matching	pointer
)	O
)	O
{	O
bfd_error_type	enum
err	pointer
;	O
struct	O
lang_input_statement_flags	struct
save_flags	struct
;	O
extern	O
FILE	struct
*	O
yyin	pointer
;	O
err	pointer
=	O
bfd_get_error	function
(	O
)	O
;	O
if	O
(	O
ldemul_unrecognized_file	function
(	O
entry	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
err	pointer
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
einfo	pointer
(	O
_	O
(	O
"%P: %pB: file not recognized: %E;"	pointer
" matching formats:"	pointer
)	O
,	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
matching	pointer
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
einfo	pointer
(	O
" %s"	pointer
,	O
*	O
p	pointer
)	O
;	O
einfo	pointer
(	O
"%F\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
err	pointer
!=	O
bfd_error_file_not_recognized	int
||	O
place	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: file not recognized: %E\n"	pointer
)	O
,	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
bfd_close	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
entry	pointer
->	O
the_bfd	pointer
=	O
NULL	O
;	O
save_flags	struct
=	O
input_flags	struct
;	O
ldfile_open_command_file	function
(	O
entry	pointer
->	O
filename	pointer
)	O
;	O
push_stat_ptr	function
(	O
place	pointer
)	O
;	O
input_flags	struct
.	O
add_DT_NEEDED_for_regular	int
=	O
entry	pointer
->	O
flags	int
.	O
add_DT_NEEDED_for_regular	int
;	O
input_flags	struct
.	O
add_DT_NEEDED_for_dynamic	int
=	O
entry	pointer
->	O
flags	int
.	O
add_DT_NEEDED_for_dynamic	int
;	O
input_flags	struct
.	O
whole_archive	int
=	O
entry	pointer
->	O
flags	int
.	O
whole_archive	int
;	O
input_flags	struct
.	O
dynamic	int
=	O
entry	pointer
->	O
flags	int
.	O
dynamic	int
;	O
ldfile_assumed_script	int
=	O
TRUE	int
;	O
parser_input	enum
=	O
input_script	int
;	O
yyparse	function
(	O
)	O
;	O
ldfile_assumed_script	int
=	O
FALSE	int
;	O
save_flags	struct
.	O
missing_file	int
|=	O
input_flags	struct
.	O
missing_file	int
;	O
input_flags	struct
=	O
save_flags	struct
;	O
pop_stat_ptr	function
(	O
)	O
;	O
fclose	function
(	O
yyin	pointer
)	O
;	O
yyin	pointer
=	O
NULL	O
;	O
entry	pointer
->	O
flags	int
.	O
loaded	int
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
ldemul_recognized_file	function
(	O
entry	pointer
)	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
bfd_get_format	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
bfd_object	int
:	O
if	O
(	O
!	O
entry	pointer
->	O
flags	int
.	O
reload	int
)	O
ldlang_add_file	function
(	O
entry	pointer
)	O
;	O
break	O
;	O
case	O
bfd_archive	int
:	O
check_excluded_libs	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
bfd_set_usrdata	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
whole_archive	int
)	O
{	O
bfd	struct
*	O
member	pointer
=	O
NULL	O
;	O
bfd_boolean	int
loaded	int
=	O
TRUE	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
bfd	struct
*	O
subsbfd	pointer
;	O
member	pointer
=	O
bfd_openr_next_archived_file	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
member	pointer
)	O
;	O
if	O
(	O
member	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
member	pointer
,	O
bfd_object	int
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: member %pB in archive is not an object\n"	pointer
)	O
,	O
entry	pointer
->	O
the_bfd	pointer
,	O
member	pointer
)	O
;	O
loaded	int
=	O
FALSE	int
;	O
}	O
subsbfd	pointer
=	O
member	pointer
;	O
if	O
(	O
!	O
(	O
*	O
link_info	struct
.	O
callbacks	pointer
->	O
add_archive_element	pointer
)	O
(	O
&	O
link_info	struct
,	O
member	pointer
,	O
"--whole-archive"	pointer
,	O
&	O
subsbfd	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_link_add_symbols	O
(	O
subsbfd	pointer
,	O
&	O
link_info	struct
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: error adding symbols: %E\n"	pointer
)	O
,	O
member	pointer
)	O
;	O
loaded	int
=	O
FALSE	int
;	O
}	O
}	O
entry	pointer
->	O
flags	int
.	O
loaded	int
=	O
loaded	int
;	O
return	O
loaded	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
bfd_link_add_symbols	O
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
&	O
link_info	struct
)	O
)	O
entry	pointer
->	O
flags	int
.	O
loaded	int
=	O
TRUE	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: error adding symbols: %E\n"	pointer
)	O
,	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
return	O
entry	pointer
->	O
flags	int
.	O
loaded	int
;	O
}	O
static	O
void	O
wild	pointer
(	O
lang_wild_statement_type	struct
*	O
s	pointer
,	O
const	O
char	O
*	O
target	pointer
ATTRIBUTE_UNUSED	O
,	O
lang_output_section_statement_type	struct
*	O
output	pointer
)	O
{	O
struct	O
wildcard_list	struct
*	O
sec	pointer
;	O
if	O
(	O
s	pointer
->	O
handler_data	array
[	O
0	int
]	O
&&	O
s	pointer
->	O
handler_data	array
[	O
0	int
]	O
->	O
spec	struct
.	O
sorted	enum
==	O
by_name	int
&&	O
!	O
s	pointer
->	O
filenames_sorted	int
)	O
{	O
lang_section_bst_type	struct
*	O
tree	pointer
;	O
walk_wild	function
(	O
s	pointer
,	O
output_section_callback_fast	function
,	O
output	pointer
)	O
;	O
tree	pointer
=	O
s	pointer
->	O
tree	pointer
;	O
if	O
(	O
tree	pointer
)	O
{	O
output_section_callback_tree_to_list	function
(	O
s	pointer
,	O
tree	pointer
,	O
output	pointer
)	O
;	O
s	pointer
->	O
tree	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
walk_wild	function
(	O
s	pointer
,	O
output_section_callback	function
,	O
output	pointer
)	O
;	O
if	O
(	O
default_common_section	pointer
==	O
NULL	O
)	O
for	O
(	O
sec	pointer
=	O
s	pointer
->	O
section_list	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
,	O
"COMMON"	pointer
)	O
==	O
0	int
)	O
{	O
default_common_section	pointer
=	O
output	pointer
;	O
break	O
;	O
}	O
}	O
static	O
int	O
get_target	function
(	O
const	O
bfd_target	struct
*	O
target	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
const	O
char	O
*	O
sought	pointer
=	O
(	O
const	O
char	O
*	O
)	O
data	pointer
;	O
return	O
strcmp	function
(	O
target	pointer
->	O
name	pointer
,	O
sought	pointer
)	O
==	O
0	int
;	O
}	O
static	O
void	O
stricpy	function
(	O
char	O
*	O
dest	pointer
,	O
const	O
char	O
*	O
src	pointer
)	O
{	O
char	O
c	struct
;	O
while	O
(	O
(	O
c	struct
=	O
*	O
src	pointer
++	O
)	O
!=	O
0	int
)	O
*	O
dest	pointer
++	O
=	O
TOLOWER	O
(	O
c	struct
)	O
;	O
*	O
dest	pointer
=	O
0	int
;	O
}	O
static	O
void	O
strcut	function
(	O
char	O
*	O
haystack	pointer
,	O
const	O
char	O
*	O
needle	pointer
)	O
{	O
haystack	pointer
=	O
strstr	function
(	O
haystack	pointer
,	O
needle	pointer
)	O
;	O
if	O
(	O
haystack	pointer
)	O
{	O
char	O
*	O
src	pointer
;	O
for	O
(	O
src	pointer
=	O
haystack	pointer
+	O
strlen	function
(	O
needle	pointer
)	O
;	O
*	O
src	pointer
;	O
)	O
*	O
haystack	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
*	O
haystack	pointer
=	O
0	int
;	O
}	O
}	O
static	O
int	O
name_compare	function
(	O
const	O
char	O
*	O
first	pointer
,	O
const	O
char	O
*	O
second	pointer
)	O
{	O
char	O
*	O
copy1	pointer
;	O
char	O
*	O
copy2	pointer
;	O
int	O
result	struct
;	O
copy1	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
first	pointer
)	O
+	O
1	int
)	O
;	O
copy2	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
second	pointer
)	O
+	O
1	int
)	O
;	O
stricpy	function
(	O
copy1	pointer
,	O
first	pointer
)	O
;	O
stricpy	function
(	O
copy2	pointer
,	O
second	pointer
)	O
;	O
strcut	function
(	O
copy1	pointer
,	O
"big"	pointer
)	O
;	O
strcut	function
(	O
copy1	pointer
,	O
"little"	pointer
)	O
;	O
strcut	function
(	O
copy2	pointer
,	O
"big"	pointer
)	O
;	O
strcut	function
(	O
copy2	pointer
,	O
"little"	pointer
)	O
;	O
for	O
(	O
result	struct
=	O
0	int
;	O
copy1	pointer
[	O
result	struct
]	O
==	O
copy2	pointer
[	O
result	struct
]	O
;	O
result	struct
++	O
)	O
if	O
(	O
copy1	pointer
[	O
result	struct
]	O
==	O
0	int
)	O
{	O
result	struct
*=	O
10	int
;	O
break	O
;	O
}	O
free	function
(	O
copy1	pointer
)	O
;	O
free	function
(	O
copy2	pointer
)	O
;	O
return	O
result	struct
;	O
}	O
static	O
const	O
bfd_target	struct
*	O
winner	pointer
;	O
static	O
int	O
closest_target_match	function
(	O
const	O
bfd_target	struct
*	O
target	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
const	O
bfd_target	struct
*	O
original	pointer
=	O
(	O
const	O
bfd_target	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_BIG	int
&&	O
target	pointer
->	O
byteorder	enum
!=	O
BFD_ENDIAN_BIG	int
)	O
return	O
0	int
;	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_LITTLE	int
&&	O
target	pointer
->	O
byteorder	enum
!=	O
BFD_ENDIAN_LITTLE	int
)	O
return	O
0	int
;	O
if	O
(	O
target	pointer
->	O
flavour	enum
!=	O
original	pointer
->	O
flavour	enum
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
target	pointer
->	O
name	pointer
,	O
"elf32-big"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
target	pointer
->	O
name	pointer
,	O
"elf64-big"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
target	pointer
->	O
name	pointer
,	O
"elf32-little"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
target	pointer
->	O
name	pointer
,	O
"elf64-little"	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
winner	pointer
==	O
NULL	O
)	O
{	O
winner	pointer
=	O
target	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
name_compare	function
(	O
target	pointer
->	O
name	pointer
,	O
original	pointer
->	O
name	pointer
)	O
>	O
name_compare	function
(	O
winner	pointer
->	O
name	pointer
,	O
original	pointer
->	O
name	pointer
)	O
)	O
winner	pointer
=	O
target	pointer
;	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
get_first_input_target	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
target	pointer
=	O
NULL	O
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
==	O
lang_input_statement_enum	int
&&	O
s	pointer
->	O
flags	int
.	O
real	int
)	O
{	O
ldfile_open_file	function
(	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
bfd_check_format	function
(	O
s	pointer
->	O
the_bfd	pointer
,	O
bfd_object	int
)	O
)	O
{	O
target	pointer
=	O
bfd_get_target	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
}	O
}	O
return	O
target	pointer
;	O
}	O
const	O
char	O
*	O
lang_get_output_target	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
target	pointer
;	O
if	O
(	O
output_target	pointer
!=	O
NULL	O
)	O
return	O
output_target	pointer
;	O
if	O
(	O
current_target	pointer
!=	O
default_target	pointer
&&	O
current_target	pointer
!=	O
NULL	O
)	O
return	O
current_target	pointer
;	O
target	pointer
=	O
get_first_input_target	function
(	O
)	O
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
)	O
return	O
target	pointer
;	O
return	O
default_target	pointer
;	O
}	O
static	O
void	O
open_output	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
output_target	pointer
=	O
lang_get_output_target	function
(	O
)	O
;	O
if	O
(	O
command_line	struct
.	O
endian	enum
!=	O
ENDIAN_UNSET	int
)	O
{	O
const	O
bfd_target	struct
*	O
target	pointer
=	O
bfd_iterate_over_targets	function
(	O
get_target	function
,	O
(	O
void	O
*	O
)	O
output_target	pointer
)	O
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
)	O
{	O
enum	O
bfd_endian	enum
desired_endian	enum
;	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_BIG	int
)	O
desired_endian	enum
=	O
BFD_ENDIAN_BIG	int
;	O
else	O
desired_endian	enum
=	O
BFD_ENDIAN_LITTLE	int
;	O
if	O
(	O
target	pointer
->	O
byteorder	enum
!=	O
desired_endian	enum
)	O
{	O
if	O
(	O
target	pointer
->	O
alternative_target	pointer
!=	O
NULL	O
&&	O
(	O
target	pointer
->	O
alternative_target	pointer
->	O
byteorder	enum
==	O
desired_endian	enum
)	O
)	O
output_target	pointer
=	O
target	pointer
->	O
alternative_target	pointer
->	O
name	pointer
;	O
else	O
{	O
bfd_iterate_over_targets	function
(	O
closest_target_match	function
,	O
(	O
void	O
*	O
)	O
target	pointer
)	O
;	O
if	O
(	O
winner	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: could not find any targets"	pointer
" that match endianness requirement\n"	pointer
)	O
)	O
;	O
else	O
output_target	pointer
=	O
winner	pointer
->	O
name	pointer
;	O
}	O
}	O
}	O
}	O
link_info	struct
.	O
output_bfd	pointer
=	O
bfd_openw	function
(	O
name	pointer
,	O
output_target	pointer
)	O
;	O
if	O
(	O
link_info	struct
.	O
output_bfd	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_invalid_target	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: target %s not found\n"	pointer
)	O
,	O
output_target	pointer
)	O
;	O
einfo	pointer
(	O
_	O
(	O
"%F%P: cannot open output file %s: %E\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
}	O
delete_output_file_on_failure	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
bfd_set_format	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
bfd_object	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: can not make object file: %E\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
bfd_set_arch_mach	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
ldfile_output_architecture	enum
,	O
ldfile_output_machine	long
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: can not set architecture: %E\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
link_info	struct
.	O
hash	long
=	O
bfd_link_hash_table_create	O
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
if	O
(	O
link_info	struct
.	O
hash	long
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can not create hash table: %E\n"	pointer
)	O
)	O
;	O
bfd_set_gp_size	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
g_switch_value	int
)	O
;	O
}	O
static	O
void	O
ldlang_open_output	function
(	O
lang_statement_union_type	union
*	O
statement	pointer
)	O
{	O
switch	O
(	O
statement	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_output_statement_enum	int
:	O
ASSERT	O
(	O
link_info	struct
.	O
output_bfd	pointer
==	O
NULL	O
)	O
;	O
open_output	function
(	O
statement	pointer
->	O
output_statement	struct
.	O
name	pointer
)	O
;	O
ldemul_set_output_arch	function
(	O
)	O
;	O
if	O
(	O
config	struct
.	O
magic_demand_paged	int
&&	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
link_info	struct
.	O
output_bfd	pointer
->	O
flags	int
|=	O
D_PAGED	int
;	O
else	O
link_info	struct
.	O
output_bfd	pointer
->	O
flags	int
&=	O
~	O
D_PAGED	int
;	O
if	O
(	O
config	struct
.	O
text_read_only	int
)	O
link_info	struct
.	O
output_bfd	pointer
->	O
flags	int
|=	O
WP_TEXT	int
;	O
else	O
link_info	struct
.	O
output_bfd	pointer
->	O
flags	int
&=	O
~	O
WP_TEXT	int
;	O
if	O
(	O
link_info	struct
.	O
traditional_format	int
)	O
link_info	struct
.	O
output_bfd	pointer
->	O
flags	int
|=	O
BFD_TRADITIONAL_FORMAT	int
;	O
else	O
link_info	struct
.	O
output_bfd	pointer
->	O
flags	int
&=	O
~	O
BFD_TRADITIONAL_FORMAT	int
;	O
break	O
;	O
case	O
lang_target_statement_enum	int
:	O
current_target	pointer
=	O
statement	pointer
->	O
target_statement	struct
.	O
target	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
init_opb	function
(	O
asection	struct
*	O
s	pointer
)	O
{	O
unsigned	O
int	O
x	int
;	O
opb_shift	int
=	O
0	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
s	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ELF_OCTETS	int
)	O
!=	O
0	int
)	O
return	O
;	O
x	int
=	O
bfd_arch_mach_octets_per_byte	function
(	O
ldfile_output_architecture	enum
,	O
ldfile_output_machine	long
)	O
;	O
if	O
(	O
x	int
>	O
1	int
)	O
while	O
(	O
(	O
x	int
&	O
1	int
)	O
==	O
0	int
)	O
{	O
x	int
>>=	O
1	int
;	O
++	O
opb_shift	int
;	O
}	O
ASSERT	O
(	O
x	int
==	O
1	int
)	O
;	O
}	O
enum	O
open_bfd_mode	enum
{	O
OPEN_BFD_NORMAL	int
=	O
0	int
,	O
OPEN_BFD_FORCE	int
=	O
1	int
,	O
OPEN_BFD_RESCAN	int
=	O
2	int
}	O
;	O
static	O
lang_input_statement_type	struct
*	O
plugin_insert	pointer
=	O
NULL	O
;	O
static	O
struct	O
bfd_link_hash_entry	struct
*	O
plugin_undefs	pointer
=	O
NULL	O
;	O
static	O
void	O
open_input_bfds	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
enum	O
open_bfd_mode	enum
mode	pointer
)	O
{	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_constructors_statement_enum	int
:	O
open_input_bfds	function
(	O
constructor_list	struct
.	O
head	pointer
,	O
mode	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
open_input_bfds	function
(	O
s	pointer
->	O
output_section_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
mode	pointer
)	O
;	O
break	O
;	O
case	O
lang_wild_statement_enum	int
:	O
if	O
(	O
(	O
mode	pointer
&	O
OPEN_BFD_RESCAN	int
)	O
==	O
0	int
&&	O
s	pointer
->	O
wild_statement	struct
.	O
filename	pointer
&&	O
!	O
wildcardp	O
(	O
s	pointer
->	O
wild_statement	struct
.	O
filename	pointer
)	O
&&	O
!	O
archive_path	function
(	O
s	pointer
->	O
wild_statement	struct
.	O
filename	pointer
)	O
)	O
lookup_name	function
(	O
s	pointer
->	O
wild_statement	struct
.	O
filename	pointer
)	O
;	O
open_input_bfds	function
(	O
s	pointer
->	O
wild_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
mode	pointer
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
undefs	pointer
;	O
lang_input_statement_type	struct
*	O
plugin_insert_save	pointer
;	O
do	O
{	O
plugin_insert_save	pointer
=	O
plugin_insert	pointer
;	O
undefs	pointer
=	O
link_info	struct
.	O
hash	long
->	O
undefs_tail	pointer
;	O
open_input_bfds	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
mode	pointer
|	O
OPEN_BFD_FORCE	int
)	O
;	O
}	O
while	O
(	O
undefs	pointer
!=	O
link_info	struct
.	O
hash	long
->	O
undefs_tail	pointer
||	O
(	O
plugin_insert	pointer
!=	O
plugin_insert_save	pointer
&&	O
plugin_undefs	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
lang_target_statement_enum	int
:	O
current_target	pointer
=	O
s	pointer
->	O
target_statement	struct
.	O
target	pointer
;	O
break	O
;	O
case	O
lang_input_statement_enum	int
:	O
if	O
(	O
s	pointer
->	O
input_statement	struct
.	O
flags	int
.	O
real	int
)	O
{	O
lang_statement_union_type	union
*	O
*	O
os_tail	pointer
;	O
lang_statement_list_type	struct
add	struct
;	O
bfd	struct
*	O
abfd	pointer
;	O
s	pointer
->	O
input_statement	struct
.	O
target	pointer
=	O
current_target	pointer
;	O
if	O
(	O
mode	pointer
!=	O
OPEN_BFD_NORMAL	int
&&	O
(	O
(	O
mode	pointer
&	O
OPEN_BFD_RESCAN	int
)	O
==	O
0	int
||	O
plugin_insert	pointer
==	O
NULL	O
)	O
&&	O
s	pointer
->	O
input_statement	struct
.	O
flags	int
.	O
loaded	int
&&	O
(	O
abfd	pointer
=	O
s	pointer
->	O
input_statement	struct
.	O
the_bfd	pointer
)	O
!=	O
NULL	O
&&	O
(	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_archive	int
&&	O
!	O
s	pointer
->	O
input_statement	struct
.	O
flags	int
.	O
whole_archive	int
)	O
||	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_object	int
&&	O
(	O
(	O
abfd	pointer
->	O
flags	int
)	O
&	O
DYNAMIC	int
)	O
!=	O
0	int
&&	O
s	pointer
->	O
input_statement	struct
.	O
flags	int
.	O
add_DT_NEEDED_for_regular	int
&&	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
elf_dyn_lib_class	O
(	O
abfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
)	O
)	O
)	O
{	O
s	pointer
->	O
input_statement	struct
.	O
flags	int
.	O
loaded	int
=	O
FALSE	int
;	O
s	pointer
->	O
input_statement	struct
.	O
flags	int
.	O
reload	int
=	O
TRUE	int
;	O
}	O
os_tail	pointer
=	O
lang_os_list	struct
.	O
tail	pointer
;	O
lang_list_init	function
(	O
&	O
add	struct
)	O
;	O
if	O
(	O
!	O
load_symbols	function
(	O
&	O
s	pointer
->	O
input_statement	struct
,	O
&	O
add	struct
)	O
)	O
config	struct
.	O
make_executable	int
=	O
FALSE	int
;	O
if	O
(	O
add	struct
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
os_tail	pointer
!=	O
lang_os_list	struct
.	O
tail	pointer
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: %s contains output sections;"	pointer
" did you forget -T?\n"	pointer
)	O
,	O
s	pointer
->	O
input_statement	struct
.	O
filename	pointer
)	O
;	O
*	O
stat_ptr	pointer
->	O
tail	pointer
=	O
add	struct
.	O
head	pointer
;	O
stat_ptr	pointer
->	O
tail	pointer
=	O
add	struct
.	O
tail	pointer
;	O
}	O
else	O
{	O
*	O
add	struct
.	O
tail	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
;	O
s	pointer
->	O
header	struct
.	O
next	pointer
=	O
add	struct
.	O
head	pointer
;	O
}	O
}	O
}	O
if	O
(	O
&	O
s	pointer
->	O
input_statement	struct
==	O
plugin_insert	pointer
)	O
plugin_insert	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
lang_assignment_statement_enum	int
:	O
if	O
(	O
s	pointer
->	O
assignment_statement	struct
.	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
!=	O
etree_assert	int
)	O
exp_fold_tree_no_dot	function
(	O
s	pointer
->	O
assignment_statement	struct
.	O
exp	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
input_flags	struct
.	O
missing_file	int
)	O
einfo	pointer
(	O
"%F"	pointer
)	O
;	O
}	O
static	O
void	O
ldlang_open_ctf	function
(	O
void	O
)	O
{	O
int	O
any_ctf	int
=	O
0	int
;	O
int	O
err	pointer
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
file	pointer
)	O
{	O
asection	struct
*	O
sect	pointer
;	O
if	O
(	O
(	O
file	pointer
->	O
the_ctf	pointer
=	O
ctf_bfdopen	function
(	O
file	pointer
->	O
the_bfd	pointer
,	O
&	O
err	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
err	pointer
!=	O
ECTF_NOCTFDATA	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: CTF section in `%pI' not loaded: "	pointer
"its types will be discarded: `%s'\n"	pointer
)	O
,	O
file	pointer
,	O
ctf_errmsg	function
(	O
err	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
sect	pointer
=	O
bfd_get_section_by_name	function
(	O
file	pointer
->	O
the_bfd	pointer
,	O
".ctf"	pointer
)	O
;	O
sect	pointer
->	O
size	int
=	O
0	int
;	O
sect	pointer
->	O
flags	int
|=	O
SEC_NEVER_LOAD	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_LINKER_CREATED	int
;	O
any_ctf	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
any_ctf	int
)	O
{	O
ctf_output	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
ctf_output	pointer
=	O
ctf_create	function
(	O
&	O
err	pointer
)	O
)	O
!=	O
NULL	O
)	O
return	O
;	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: CTF output not created: `s'\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
err	pointer
)	O
)	O
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
errfile	pointer
)	O
ctf_close	function
(	O
errfile	pointer
->	O
the_ctf	pointer
)	O
;	O
}	O
static	O
void	O
lang_merge_ctf	function
(	O
void	O
)	O
{	O
asection	struct
*	O
output_sect	pointer
;	O
if	O
(	O
!	O
ctf_output	pointer
)	O
return	O
;	O
output_sect	pointer
=	O
bfd_get_section_by_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
".ctf"	pointer
)	O
;	O
if	O
(	O
output_sect	pointer
==	O
NULL	O
)	O
{	O
ctf_file_close	function
(	O
ctf_output	pointer
)	O
;	O
ctf_output	pointer
=	O
NULL	O
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
file	pointer
)	O
{	O
ctf_close	function
(	O
file	pointer
->	O
the_ctf	pointer
)	O
;	O
file	pointer
->	O
the_ctf	pointer
=	O
NULL	O
;	O
}	O
return	O
;	O
}	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
file	pointer
)	O
{	O
if	O
(	O
!	O
file	pointer
->	O
the_ctf	pointer
)	O
continue	O
;	O
if	O
(	O
ctf_link_add_ctf	function
(	O
ctf_output	pointer
,	O
file	pointer
->	O
the_ctf	pointer
,	O
file	pointer
->	O
filename	pointer
)	O
<	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: cannot link with CTF in %pB: %s\n"	pointer
)	O
,	O
file	pointer
->	O
the_bfd	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
ctf_close	function
(	O
file	pointer
->	O
the_ctf	pointer
)	O
;	O
file	pointer
->	O
the_ctf	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
ctf_link	function
(	O
ctf_output	pointer
,	O
CTF_LINK_SHARE_UNCONFLICTED	int
)	O
<	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: CTF linking failed; output will have no CTF section: %s\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
if	O
(	O
output_sect	pointer
)	O
{	O
output_sect	pointer
->	O
size	int
=	O
0	int
;	O
output_sect	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
}	O
}	O
}	O
void	O
ldlang_ctf_apply_strsym	function
(	O
struct	O
elf_sym_strtab	struct
*	O
syms	pointer
,	O
bfd_size_type	long
symcount	int
,	O
struct	O
elf_strtab_hash	O
*	O
symstrtab	pointer
)	O
{	O
ldemul_examine_strtab_for_ctf	function
(	O
ctf_output	pointer
,	O
syms	pointer
,	O
symcount	int
,	O
symstrtab	pointer
)	O
;	O
}	O
static	O
void	O
lang_write_ctf	function
(	O
int	O
late	int
)	O
{	O
size_t	long
output_size	long
;	O
asection	struct
*	O
output_sect	pointer
;	O
if	O
(	O
!	O
ctf_output	pointer
)	O
return	O
;	O
if	O
(	O
late	int
)	O
{	O
if	O
(	O
ldemul_emit_ctf_early	function
(	O
)	O
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
ldemul_emit_ctf_early	function
(	O
)	O
)	O
return	O
;	O
}	O
output_sect	pointer
=	O
bfd_get_section_by_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
".ctf"	pointer
)	O
;	O
if	O
(	O
output_sect	pointer
)	O
{	O
output_sect	pointer
->	O
contents	pointer
=	O
ctf_link_write	function
(	O
ctf_output	pointer
,	O
&	O
output_size	long
,	O
CTF_COMPRESSION_THRESHOLD	int
)	O
;	O
output_sect	pointer
->	O
size	int
=	O
output_size	long
;	O
output_sect	pointer
->	O
flags	int
|=	O
SEC_IN_MEMORY	int
|	O
SEC_KEEP	int
;	O
if	O
(	O
!	O
output_sect	pointer
->	O
contents	pointer
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: CTF section emission failed; output will have no "	pointer
"CTF section: %s\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
output_sect	pointer
->	O
size	int
=	O
0	int
;	O
output_sect	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
}	O
}	O
ctf_file_close	function
(	O
ctf_output	pointer
)	O
;	O
ctf_output	pointer
=	O
NULL	O
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
file	pointer
)	O
file	pointer
->	O
the_ctf	pointer
=	O
NULL	O
;	O
}	O
void	O
ldlang_write_ctf_late	function
(	O
void	O
)	O
{	O
lang_write_ctf	function
(	O
1	int
)	O
;	O
}	O
typedef	O
struct	O
bfd_sym_chain	struct
ldlang_undef_chain_list_type	struct
;	O
void	O
ldlang_add_undef	function
(	O
const	O
char	O
*	O
const	O
name	pointer
,	O
bfd_boolean	int
cmdline	int
)	O
{	O
ldlang_undef_chain_list_type	struct
*	O
new_undef	pointer
;	O
undef_from_cmdline	int
=	O
undef_from_cmdline	int
||	O
cmdline	int
;	O
new_undef	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
*	O
new_undef	pointer
)	O
)	O
;	O
new_undef	pointer
->	O
next	pointer
=	O
ldlang_undef_chain_list_head	O
;	O
ldlang_undef_chain_list_head	O
=	O
new_undef	pointer
;	O
new_undef	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
link_info	struct
.	O
output_bfd	pointer
!=	O
NULL	O
)	O
insert_undefined	function
(	O
new_undef	pointer
->	O
name	pointer
)	O
;	O
}	O
static	O
void	O
insert_undefined	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
name	pointer
,	O
TRUE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bfd_link_hash_lookup failed: %E\n"	pointer
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
)	O
{	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
NULL	O
;	O
h	pointer
->	O
non_ir_ref_regular	int
=	O
TRUE	int
;	O
if	O
(	O
is_elf_hash_table	O
(	O
link_info	struct
.	O
hash	long
)	O
)	O
(	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
)	O
->	O
mark	int
=	O
1	int
;	O
bfd_link_add_undef	function
(	O
link_info	struct
.	O
hash	long
,	O
h	pointer
)	O
;	O
}	O
}	O
static	O
void	O
lang_place_undefineds	function
(	O
void	O
)	O
{	O
ldlang_undef_chain_list_type	struct
*	O
ptr	pointer
;	O
for	O
(	O
ptr	pointer
=	O
ldlang_undef_chain_list_head	O
;	O
ptr	pointer
!=	O
NULL	O
;	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
)	O
insert_undefined	function
(	O
ptr	pointer
->	O
name	pointer
)	O
;	O
}	O
struct	O
require_defined_symbol	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
require_defined_symbol	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
require_defined_symbol	struct
*	O
require_defined_symbol_list	pointer
;	O
void	O
ldlang_add_require_defined	function
(	O
const	O
char	O
*	O
const	O
name	pointer
)	O
{	O
struct	O
require_defined_symbol	struct
*	O
ptr	pointer
;	O
ldlang_add_undef	function
(	O
name	pointer
,	O
TRUE	int
)	O
;	O
ptr	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
*	O
ptr	pointer
)	O
)	O
;	O
ptr	pointer
->	O
next	pointer
=	O
require_defined_symbol_list	pointer
;	O
ptr	pointer
->	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
require_defined_symbol_list	pointer
=	O
ptr	pointer
;	O
}	O
static	O
void	O
ldlang_check_require_defined_symbols	function
(	O
void	O
)	O
{	O
struct	O
require_defined_symbol	struct
*	O
ptr	pointer
;	O
for	O
(	O
ptr	pointer
=	O
require_defined_symbol_list	pointer
;	O
ptr	pointer
!=	O
NULL	O
;	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
ptr	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: required symbol `%s' not defined\n"	pointer
)	O
,	O
ptr	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
check_input_sections	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
lang_output_section_statement_type	struct
*	O
output_section_statement	struct
)	O
{	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_wild_statement_enum	int
:	O
walk_wild	function
(	O
&	O
s	pointer
->	O
wild_statement	struct
,	O
check_section_callback	function
,	O
output_section_statement	struct
)	O
;	O
if	O
(	O
!	O
output_section_statement	struct
->	O
all_input_readonly	int
)	O
return	O
;	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
check_input_sections	function
(	O
constructor_list	struct
.	O
head	pointer
,	O
output_section_statement	struct
)	O
;	O
if	O
(	O
!	O
output_section_statement	struct
->	O
all_input_readonly	int
)	O
return	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
check_input_sections	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
output_section_statement	struct
)	O
;	O
if	O
(	O
!	O
output_section_statement	struct
->	O
all_input_readonly	int
)	O
return	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
update_wild_statements	function
(	O
lang_statement_union_type	union
*	O
s	pointer
)	O
{	O
struct	O
wildcard_list	struct
*	O
sec	pointer
;	O
switch	O
(	O
sort_section	enum
)	O
{	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
case	O
none	int
:	O
break	O
;	O
case	O
by_name	int
:	O
case	O
by_alignment	int
:	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
default	O
:	O
break	O
;	O
case	O
lang_wild_statement_enum	int
:	O
for	O
(	O
sec	pointer
=	O
s	pointer
->	O
wild_statement	struct
.	O
section_list	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
,	O
".init"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
,	O
".fini"	pointer
)	O
!=	O
0	int
)	O
switch	O
(	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
)	O
{	O
case	O
none	int
:	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
=	O
sort_section	enum
;	O
break	O
;	O
case	O
by_name	int
:	O
if	O
(	O
sort_section	enum
==	O
by_alignment	int
)	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
=	O
by_name_alignment	int
;	O
break	O
;	O
case	O
by_alignment	int
:	O
if	O
(	O
sort_section	enum
==	O
by_name	int
)	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
=	O
by_alignment_name	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
update_wild_statements	function
(	O
constructor_list	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
update_wild_statements	function
(	O
s	pointer
->	O
output_section_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
update_wild_statements	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
static	O
void	O
map_input_to_output_sections	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
const	O
char	O
*	O
target	pointer
,	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
lang_output_section_statement_type	struct
*	O
tos	pointer
;	O
flagword	int
flags	int
;	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_wild_statement_enum	int
:	O
wild	pointer
(	O
&	O
s	pointer
->	O
wild_statement	struct
,	O
target	pointer
,	O
os	int
)	O
;	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
map_input_to_output_sections	function
(	O
constructor_list	struct
.	O
head	pointer
,	O
target	pointer
,	O
os	int
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
tos	pointer
=	O
&	O
s	pointer
->	O
output_section_statement	struct
;	O
if	O
(	O
tos	pointer
->	O
constraint	int
!=	O
0	int
)	O
{	O
if	O
(	O
tos	pointer
->	O
constraint	int
!=	O
ONLY_IF_RW	int
&&	O
tos	pointer
->	O
constraint	int
!=	O
ONLY_IF_RO	int
)	O
break	O
;	O
tos	pointer
->	O
all_input_readonly	int
=	O
TRUE	int
;	O
check_input_sections	function
(	O
tos	pointer
->	O
children	struct
.	O
head	pointer
,	O
tos	pointer
)	O
;	O
if	O
(	O
tos	pointer
->	O
all_input_readonly	int
!=	O
(	O
tos	pointer
->	O
constraint	int
==	O
ONLY_IF_RO	int
)	O
)	O
{	O
tos	pointer
->	O
constraint	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
}	O
map_input_to_output_sections	function
(	O
tos	pointer
->	O
children	struct
.	O
head	pointer
,	O
target	pointer
,	O
tos	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_statement_enum	int
:	O
break	O
;	O
case	O
lang_target_statement_enum	int
:	O
target	pointer
=	O
s	pointer
->	O
target_statement	struct
.	O
target	pointer
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
map_input_to_output_sections	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
target	pointer
,	O
os	int
)	O
;	O
break	O
;	O
case	O
lang_data_statement_enum	int
:	O
exp_init_os	function
(	O
s	pointer
->	O
data_statement	struct
.	O
exp	pointer
)	O
;	O
flags	int
=	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
;	O
switch	O
(	O
os	int
->	O
sectype	enum
)	O
{	O
case	O
normal_section	int
:	O
case	O
overlay_section	int
:	O
case	O
first_overlay_section	int
:	O
break	O
;	O
case	O
noalloc_section	int
:	O
flags	int
=	O
SEC_HAS_CONTENTS	int
;	O
break	O
;	O
case	O
noload_section	int
:	O
if	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
flags	int
=	O
SEC_NEVER_LOAD	int
|	O
SEC_ALLOC	int
;	O
else	O
flags	int
=	O
SEC_NEVER_LOAD	int
|	O
SEC_HAS_CONTENTS	int
;	O
break	O
;	O
}	O
if	O
(	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
init_os	function
(	O
os	int
,	O
flags	int
)	O
;	O
else	O
os	int
->	O
bfd_section	struct
->	O
flags	int
|=	O
flags	int
;	O
break	O
;	O
case	O
lang_input_section_enum	int
:	O
break	O
;	O
case	O
lang_fill_statement_enum	int
:	O
case	O
lang_object_symbols_statement_enum	int
:	O
case	O
lang_reloc_statement_enum	int
:	O
case	O
lang_padding_statement_enum	int
:	O
case	O
lang_input_statement_enum	int
:	O
if	O
(	O
os	int
!=	O
NULL	O
&&	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
init_os	function
(	O
os	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
lang_assignment_statement_enum	int
:	O
if	O
(	O
os	int
!=	O
NULL	O
&&	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
init_os	function
(	O
os	int
,	O
0	int
)	O
;	O
exp_init_os	function
(	O
s	pointer
->	O
assignment_statement	struct
.	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
lang_address_statement_enum	int
:	O
if	O
(	O
!	O
s	pointer
->	O
address_statement	struct
.	O
segment	pointer
||	O
!	O
s	pointer
->	O
address_statement	struct
.	O
segment	pointer
->	O
used	int
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
s	pointer
->	O
address_statement	struct
.	O
section_name	pointer
;	O
tos	pointer
=	O
lang_output_section_statement_lookup	function
(	O
name	pointer
,	O
0	int
,	O
TRUE	int
)	O
;	O
tos	pointer
->	O
addr_tree	pointer
=	O
s	pointer
->	O
address_statement	struct
.	O
address	long
;	O
if	O
(	O
tos	pointer
->	O
bfd_section	struct
==	O
NULL	O
)	O
init_os	function
(	O
tos	pointer
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
lang_insert_statement_enum	int
:	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
process_insert_statements	function
(	O
lang_statement_union_type	union
*	O
*	O
start	pointer
)	O
{	O
lang_statement_union_type	union
*	O
*	O
s	pointer
;	O
lang_output_section_statement_type	struct
*	O
first_os	pointer
=	O
NULL	O
;	O
lang_output_section_statement_type	struct
*	O
last_os	pointer
=	O
NULL	O
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
s	pointer
=	O
start	pointer
;	O
while	O
(	O
*	O
s	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
type	enum
==	O
lang_output_section_statement_enum	int
)	O
{	O
os	int
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
output_section_statement	struct
;	O
ASSERT	O
(	O
last_os	pointer
==	O
NULL	O
||	O
last_os	pointer
->	O
next	pointer
==	O
os	int
)	O
;	O
last_os	pointer
=	O
os	int
;	O
last_os	pointer
->	O
constraint	int
=	O
-	O
2	int
-	O
last_os	pointer
->	O
constraint	int
;	O
if	O
(	O
first_os	pointer
==	O
NULL	O
)	O
first_os	pointer
=	O
last_os	pointer
;	O
}	O
else	O
if	O
(	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
type	enum
==	O
lang_group_statement_enum	int
)	O
{	O
process_insert_statements	function
(	O
&	O
(	O
*	O
s	pointer
)	O
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
type	enum
==	O
lang_insert_statement_enum	int
)	O
{	O
lang_insert_statement_type	struct
*	O
i	pointer
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
insert_statement	struct
;	O
lang_output_section_statement_type	struct
*	O
where	long
;	O
lang_statement_union_type	union
*	O
*	O
ptr	pointer
;	O
lang_statement_union_type	union
*	O
first	pointer
;	O
where	long
=	O
lang_output_section_find	O
(	O
i	pointer
->	O
where	long
)	O
;	O
if	O
(	O
where	long
!=	O
NULL	O
&&	O
i	pointer
->	O
is_before	int
)	O
{	O
do	O
where	long
=	O
where	long
->	O
prev	pointer
;	O
while	O
(	O
where	long
!=	O
NULL	O
&&	O
where	long
->	O
constraint	int
<	O
0	int
)	O
;	O
}	O
if	O
(	O
where	long
==	O
NULL	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s not found for insert\n"	pointer
)	O
,	O
i	pointer
->	O
where	long
)	O
;	O
return	O
;	O
}	O
if	O
(	O
last_os	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
first_sec	pointer
,	O
*	O
last_sec	pointer
;	O
struct	O
lang_output_section_statement_struct	struct
*	O
*	O
next	pointer
;	O
first_os	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
last_os	pointer
->	O
next	pointer
;	O
if	O
(	O
last_os	pointer
->	O
next	pointer
==	O
NULL	O
)	O
{	O
next	pointer
=	O
&	O
first_os	pointer
->	O
prev	pointer
->	O
next	pointer
;	O
lang_os_list	struct
.	O
tail	pointer
=	O
(	O
lang_statement_union_type	union
*	O
*	O
)	O
next	pointer
;	O
}	O
else	O
last_os	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
first_os	pointer
->	O
prev	pointer
;	O
last_os	pointer
->	O
next	pointer
=	O
where	long
->	O
next	pointer
;	O
if	O
(	O
where	long
->	O
next	pointer
==	O
NULL	O
)	O
{	O
next	pointer
=	O
&	O
last_os	pointer
->	O
next	pointer
;	O
lang_os_list	struct
.	O
tail	pointer
=	O
(	O
lang_statement_union_type	union
*	O
*	O
)	O
next	pointer
;	O
}	O
else	O
where	long
->	O
next	pointer
->	O
prev	pointer
=	O
last_os	pointer
;	O
first_os	pointer
->	O
prev	pointer
=	O
where	long
;	O
where	long
->	O
next	pointer
=	O
first_os	pointer
;	O
first_sec	pointer
=	O
NULL	O
;	O
last_sec	pointer
=	O
NULL	O
;	O
for	O
(	O
os	int
=	O
first_os	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
os	int
->	O
constraint	int
=	O
-	O
2	int
-	O
os	int
->	O
constraint	int
;	O
if	O
(	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
os	int
->	O
bfd_section	struct
->	O
owner	pointer
!=	O
NULL	O
)	O
{	O
last_sec	pointer
=	O
os	int
->	O
bfd_section	struct
;	O
if	O
(	O
first_sec	pointer
==	O
NULL	O
)	O
first_sec	pointer
=	O
last_sec	pointer
;	O
}	O
if	O
(	O
os	int
==	O
last_os	pointer
)	O
break	O
;	O
}	O
if	O
(	O
last_sec	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
where	long
->	O
bfd_section	struct
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
sec	pointer
=	O
output_prev_sec_find	function
(	O
where	long
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
sec	pointer
!=	O
last_sec	pointer
)	O
{	O
if	O
(	O
first_sec	pointer
->	O
prev	pointer
!=	O
NULL	O
)	O
first_sec	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
last_sec	pointer
->	O
next	pointer
;	O
else	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
=	O
last_sec	pointer
->	O
next	pointer
;	O
if	O
(	O
last_sec	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
last_sec	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
first_sec	pointer
->	O
prev	pointer
;	O
else	O
link_info	struct
.	O
output_bfd	pointer
->	O
section_last	pointer
=	O
first_sec	pointer
->	O
prev	pointer
;	O
last_sec	pointer
->	O
next	pointer
=	O
sec	pointer
->	O
next	pointer
;	O
if	O
(	O
sec	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
sec	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
last_sec	pointer
;	O
else	O
link_info	struct
.	O
output_bfd	pointer
->	O
section_last	pointer
=	O
last_sec	pointer
;	O
first_sec	pointer
->	O
prev	pointer
=	O
sec	pointer
;	O
sec	pointer
->	O
next	pointer
=	O
first_sec	pointer
;	O
}	O
}	O
first_os	pointer
=	O
NULL	O
;	O
last_os	pointer
=	O
NULL	O
;	O
}	O
ptr	pointer
=	O
insert_os_after	function
(	O
where	long
)	O
;	O
first	pointer
=	O
*	O
start	pointer
;	O
*	O
start	pointer
=	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
next	pointer
;	O
*	O
s	pointer
=	O
*	O
ptr	pointer
;	O
if	O
(	O
*	O
s	pointer
==	O
NULL	O
)	O
statement_list	struct
.	O
tail	pointer
=	O
s	pointer
;	O
*	O
ptr	pointer
=	O
first	pointer
;	O
s	pointer
=	O
start	pointer
;	O
continue	O
;	O
}	O
s	pointer
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
next	pointer
;	O
}	O
for	O
(	O
os	int
=	O
first_os	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
os	int
->	O
constraint	int
=	O
-	O
2	int
-	O
os	int
->	O
constraint	int
;	O
if	O
(	O
os	int
==	O
last_os	pointer
)	O
break	O
;	O
}	O
}	O
void	O
strip_excluded_output_sections	function
(	O
void	O
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
{	O
expld	struct
.	O
phase	enum
=	O
lang_mark_phase_enum	int
;	O
expld	struct
.	O
dataseg	struct
.	O
phase	enum
=	O
exp_seg_none	int
;	O
one_lang_size_sections_pass	function
(	O
NULL	O
,	O
FALSE	int
)	O
;	O
lang_reset_memory_regions	function
(	O
)	O
;	O
}	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
asection	struct
*	O
output_section	pointer
;	O
bfd_boolean	int
exclude	int
;	O
if	O
(	O
os	int
->	O
constraint	int
<	O
0	int
)	O
continue	O
;	O
output_section	pointer
=	O
os	int
->	O
bfd_section	struct
;	O
if	O
(	O
output_section	pointer
==	O
NULL	O
)	O
continue	O
;	O
exclude	int
=	O
(	O
output_section	pointer
->	O
rawsize	long
==	O
0	int
&&	O
(	O
output_section	pointer
->	O
flags	int
&	O
SEC_KEEP	int
)	O
==	O
0	int
&&	O
!	O
bfd_section_removed_from_list	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
output_section	pointer
)	O
)	O
;	O
if	O
(	O
exclude	int
&&	O
output_section	pointer
->	O
map_head	union
.	O
s	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
output_section	pointer
->	O
map_head	union
.	O
s	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
map_head	union
.	O
s	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
||	O
link_info	struct
.	O
emitrelocations	int
)	O
)	O
{	O
exclude	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
exclude	int
)	O
{	O
if	O
(	O
!	O
os	int
->	O
update_dot	int
)	O
os	int
->	O
ignored	int
=	O
TRUE	int
;	O
output_section	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
bfd_section_list_remove	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
output_section	pointer
)	O
;	O
link_info	struct
.	O
output_bfd	pointer
->	O
section_count	int
--	O
;	O
}	O
}	O
}	O
void	O
lang_clear_os_map	function
(	O
void	O
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
if	O
(	O
map_head_is_link_order	int
)	O
return	O
;	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
asection	struct
*	O
output_section	pointer
;	O
if	O
(	O
os	int
->	O
constraint	int
<	O
0	int
)	O
continue	O
;	O
output_section	pointer
=	O
os	int
->	O
bfd_section	struct
;	O
if	O
(	O
output_section	pointer
==	O
NULL	O
)	O
continue	O
;	O
output_section	pointer
->	O
map_head	union
.	O
link_order	pointer
=	O
NULL	O
;	O
output_section	pointer
->	O
map_tail	union
.	O
link_order	pointer
=	O
NULL	O
;	O
}	O
map_head_is_link_order	int
=	O
TRUE	int
;	O
}	O
static	O
void	O
print_output_section_statement	function
(	O
lang_output_section_statement_type	struct
*	O
output_section_statement	struct
)	O
{	O
asection	struct
*	O
section	pointer
=	O
output_section_statement	struct
->	O
bfd_section	struct
;	O
int	O
len	long
;	O
if	O
(	O
output_section_statement	struct
!=	O
abs_output_section	pointer
)	O
{	O
minfo	pointer
(	O
"\n%s"	pointer
,	O
output_section_statement	struct
->	O
name	pointer
)	O
;	O
if	O
(	O
section	pointer
!=	O
NULL	O
)	O
{	O
print_dot	long
=	O
section	pointer
->	O
vma	long
;	O
len	long
=	O
strlen	function
(	O
output_section_statement	struct
->	O
name	pointer
)	O
;	O
if	O
(	O
len	long
>=	O
SECTION_NAME_MAP_LENGTH	O
-	O
1	int
)	O
{	O
print_nl	function
(	O
)	O
;	O
len	long
=	O
0	int
;	O
}	O
while	O
(	O
len	long
<	O
SECTION_NAME_MAP_LENGTH	O
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
minfo	pointer
(	O
"0x%V %W"	pointer
,	O
section	pointer
->	O
vma	long
,	O
TO_ADDR	O
(	O
section	pointer
->	O
size	int
)	O
)	O
;	O
if	O
(	O
section	pointer
->	O
vma	long
!=	O
section	pointer
->	O
lma	long
)	O
minfo	pointer
(	O
_	O
(	O
" load address 0x%V"	pointer
)	O
,	O
section	pointer
->	O
lma	long
)	O
;	O
if	O
(	O
output_section_statement	struct
->	O
update_dot_tree	pointer
!=	O
NULL	O
)	O
exp_fold_tree	function
(	O
output_section_statement	struct
->	O
update_dot_tree	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
print_dot	long
)	O
;	O
}	O
print_nl	function
(	O
)	O
;	O
}	O
print_statement_list	function
(	O
output_section_statement	struct
->	O
children	struct
.	O
head	pointer
,	O
output_section_statement	struct
)	O
;	O
}	O
static	O
void	O
print_assignment	function
(	O
lang_assignment_statement_type	struct
*	O
assignment	pointer
,	O
lang_output_section_statement_type	struct
*	O
output_section	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
bfd_boolean	int
is_dot	int
;	O
etree_type	union
*	O
tree	pointer
;	O
asection	struct
*	O
osec	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
SECTION_NAME_MAP_LENGTH	O
;	O
i	pointer
++	O
)	O
print_space	function
(	O
)	O
;	O
if	O
(	O
assignment	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_assert	int
)	O
{	O
is_dot	int
=	O
FALSE	int
;	O
tree	pointer
=	O
assignment	pointer
->	O
exp	pointer
->	O
assert_s	struct
.	O
child	pointer
;	O
}	O
else	O
{	O
const	O
char	O
*	O
dst	pointer
=	O
assignment	pointer
->	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
;	O
is_dot	int
=	O
(	O
dst	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
dst	pointer
[	O
1	int
]	O
==	O
0	int
)	O
;	O
tree	pointer
=	O
assignment	pointer
->	O
exp	pointer
;	O
}	O
osec	pointer
=	O
output_section	pointer
->	O
bfd_section	struct
;	O
if	O
(	O
osec	pointer
==	O
NULL	O
)	O
osec	pointer
=	O
bfd_abs_section_ptr	O
;	O
if	O
(	O
assignment	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
!=	O
etree_provide	int
)	O
exp_fold_tree	function
(	O
tree	pointer
,	O
osec	pointer
,	O
&	O
print_dot	long
)	O
;	O
else	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
bfd_vma	long
value	long
;	O
if	O
(	O
assignment	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_assert	int
||	O
is_dot	int
||	O
expld	struct
.	O
assign_name	pointer
!=	O
NULL	O
)	O
{	O
value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
)	O
value	long
+=	O
expld	struct
.	O
result	struct
.	O
section	pointer
->	O
vma	long
;	O
minfo	pointer
(	O
"0x%V"	pointer
,	O
value	long
)	O
;	O
if	O
(	O
is_dot	int
)	O
print_dot	long
=	O
value	long
;	O
}	O
else	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
assignment	pointer
->	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
{	O
value	long
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
;	O
value	long
+=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
value	long
+=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
;	O
minfo	pointer
(	O
"[0x%V]"	pointer
,	O
value	long
)	O
;	O
}	O
else	O
minfo	pointer
(	O
"[unresolved]"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
assignment	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_provide	int
)	O
minfo	pointer
(	O
"[!provide]"	pointer
)	O
;	O
else	O
minfo	pointer
(	O
"*undef*   "	pointer
)	O
;	O
minfo	pointer
(	O
"        "	pointer
)	O
;	O
}	O
expld	struct
.	O
assign_name	pointer
=	O
NULL	O
;	O
minfo	pointer
(	O
"                "	pointer
)	O
;	O
exp_print_tree	function
(	O
assignment	pointer
->	O
exp	pointer
)	O
;	O
print_nl	function
(	O
)	O
;	O
}	O
static	O
void	O
print_input_statement	function
(	O
lang_input_statement_type	struct
*	O
statm	pointer
)	O
{	O
if	O
(	O
statm	pointer
->	O
filename	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"LOAD %s\n"	pointer
,	O
statm	pointer
->	O
filename	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
print_one_symbol	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
hash_entry	pointer
,	O
void	O
*	O
ptr	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
(	O
asection	struct
*	O
)	O
ptr	pointer
;	O
if	O
(	O
(	O
hash_entry	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
hash_entry	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
sec	pointer
==	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
SECTION_NAME_MAP_LENGTH	O
;	O
i	pointer
++	O
)	O
print_space	function
(	O
)	O
;	O
minfo	pointer
(	O
"0x%V   "	pointer
,	O
(	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
+	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
+	O
hash_entry	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
)	O
)	O
;	O
minfo	pointer
(	O
"             %pT\n"	pointer
,	O
hash_entry	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
hash_entry_addr_cmp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
bfd_link_hash_entry	struct
*	O
l	pointer
=	O
*	O
(	O
const	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
)	O
a	pointer
;	O
const	O
struct	O
bfd_link_hash_entry	struct
*	O
r	pointer
=	O
*	O
(	O
const	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
)	O
b	pointer
;	O
if	O
(	O
l	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
<	O
r	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
l	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
>	O
r	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
print_all_symbols	function
(	O
asection	struct
*	O
sec	pointer
)	O
{	O
input_section_userdata_type	struct
*	O
ud	pointer
=	O
bfd_section_userdata	function
(	O
sec	pointer
)	O
;	O
struct	O
map_symbol_def	struct
*	O
def	struct
;	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
entries	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
!	O
ud	pointer
)	O
return	O
;	O
*	O
ud	pointer
->	O
map_symbol_def_tail	pointer
=	O
0	int
;	O
entries	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
)	O
obstack_alloc	O
(	O
&	O
map_obstack	struct
,	O
ud	pointer
->	O
map_symbol_def_count	long
*	O
sizeof	O
(	O
*	O
entries	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
def	struct
=	O
ud	pointer
->	O
map_symbol_def_head	pointer
;	O
def	struct
;	O
def	struct
=	O
def	struct
->	O
next	pointer
,	O
i	pointer
++	O
)	O
entries	pointer
[	O
i	pointer
]	O
=	O
def	struct
->	O
entry	pointer
;	O
qsort	function
(	O
entries	pointer
,	O
ud	pointer
->	O
map_symbol_def_count	long
,	O
sizeof	O
(	O
*	O
entries	pointer
)	O
,	O
hash_entry_addr_cmp	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ud	pointer
->	O
map_symbol_def_count	long
;	O
i	pointer
++	O
)	O
print_one_symbol	function
(	O
entries	pointer
[	O
i	pointer
]	O
,	O
sec	pointer
)	O
;	O
obstack_free	O
(	O
&	O
map_obstack	struct
,	O
entries	pointer
)	O
;	O
}	O
static	O
void	O
print_input_section	function
(	O
asection	struct
*	O
i	pointer
,	O
bfd_boolean	int
is_discarded	int
)	O
{	O
bfd_size_type	long
size	int
=	O
i	pointer
->	O
size	int
;	O
int	O
len	long
;	O
bfd_vma	long
addr	pointer
;	O
init_opb	function
(	O
i	pointer
)	O
;	O
print_space	function
(	O
)	O
;	O
minfo	pointer
(	O
"%s"	pointer
,	O
i	pointer
->	O
name	pointer
)	O
;	O
len	long
=	O
1	int
+	O
strlen	function
(	O
i	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
len	long
>=	O
SECTION_NAME_MAP_LENGTH	O
-	O
1	int
)	O
{	O
print_nl	function
(	O
)	O
;	O
len	long
=	O
0	int
;	O
}	O
while	O
(	O
len	long
<	O
SECTION_NAME_MAP_LENGTH	O
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
if	O
(	O
i	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
i	pointer
->	O
output_section	pointer
->	O
owner	pointer
==	O
link_info	struct
.	O
output_bfd	pointer
)	O
addr	pointer
=	O
i	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
i	pointer
->	O
output_offset	long
;	O
else	O
{	O
addr	pointer
=	O
print_dot	long
;	O
if	O
(	O
!	O
is_discarded	int
)	O
size	int
=	O
0	int
;	O
}	O
minfo	pointer
(	O
"0x%V %W %pB\n"	pointer
,	O
addr	pointer
,	O
TO_ADDR	O
(	O
size	int
)	O
,	O
i	pointer
->	O
owner	pointer
)	O
;	O
if	O
(	O
size	int
!=	O
i	pointer
->	O
rawsize	long
&&	O
i	pointer
->	O
rawsize	long
!=	O
0	int
)	O
{	O
len	long
=	O
SECTION_NAME_MAP_LENGTH	O
+	O
3	int
;	O
len	long
+=	O
16	int
;	O
while	O
(	O
len	long
>	O
0	int
)	O
{	O
print_space	function
(	O
)	O
;	O
--	O
len	long
;	O
}	O
minfo	pointer
(	O
_	O
(	O
"%W (size before relaxing)\n"	pointer
)	O
,	O
TO_ADDR	O
(	O
i	pointer
->	O
rawsize	long
)	O
)	O
;	O
}	O
if	O
(	O
i	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
i	pointer
->	O
output_section	pointer
->	O
owner	pointer
==	O
link_info	struct
.	O
output_bfd	pointer
)	O
{	O
if	O
(	O
link_info	struct
.	O
reduce_memory_overheads	int
)	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
print_one_symbol	function
,	O
i	pointer
)	O
;	O
else	O
print_all_symbols	function
(	O
i	pointer
)	O
;	O
if	O
(	O
addr	pointer
+	O
TO_ADDR	O
(	O
size	int
)	O
>	O
print_dot	long
)	O
print_dot	long
=	O
addr	pointer
+	O
TO_ADDR	O
(	O
size	int
)	O
;	O
}	O
}	O
static	O
void	O
print_fill_statement	function
(	O
lang_fill_statement_type	struct
*	O
fill	pointer
)	O
{	O
size_t	long
size	int
;	O
unsigned	O
char	O
*	O
p	pointer
;	O
fputs	function
(	O
" FILL mask 0x"	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
fill	pointer
->	O
fill	pointer
->	O
data	pointer
,	O
size	int
=	O
fill	pointer
->	O
fill	pointer
->	O
size	int
;	O
size	int
!=	O
0	int
;	O
p	pointer
++	O
,	O
size	int
--	O
)	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"%02x"	pointer
,	O
*	O
p	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
}	O
static	O
void	O
print_data_statement	function
(	O
lang_data_statement_type	struct
*	O
data	pointer
)	O
{	O
int	O
i	pointer
;	O
bfd_vma	long
addr	pointer
;	O
bfd_size_type	long
size	int
;	O
const	O
char	O
*	O
name	pointer
;	O
init_opb	function
(	O
data	pointer
->	O
output_section	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
SECTION_NAME_MAP_LENGTH	O
;	O
i	pointer
++	O
)	O
print_space	function
(	O
)	O
;	O
addr	pointer
=	O
data	pointer
->	O
output_offset	long
;	O
if	O
(	O
data	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
addr	pointer
+=	O
data	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
switch	O
(	O
data	pointer
->	O
type	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
BYTE	int
:	O
size	int
=	O
BYTE_SIZE	O
;	O
name	pointer
=	O
"BYTE"	pointer
;	O
break	O
;	O
case	O
SHORT	int
:	O
size	int
=	O
SHORT_SIZE	O
;	O
name	pointer
=	O
"SHORT"	pointer
;	O
break	O
;	O
case	O
LONG	int
:	O
size	int
=	O
LONG_SIZE	O
;	O
name	pointer
=	O
"LONG"	pointer
;	O
break	O
;	O
case	O
QUAD	int
:	O
size	int
=	O
QUAD_SIZE	O
;	O
name	pointer
=	O
"QUAD"	pointer
;	O
break	O
;	O
case	O
SQUAD	int
:	O
size	int
=	O
QUAD_SIZE	O
;	O
name	pointer
=	O
"SQUAD"	pointer
;	O
break	O
;	O
}	O
if	O
(	O
size	int
<	O
TO_SIZE	O
(	O
(	O
unsigned	O
)	O
1	int
)	O
)	O
size	int
=	O
TO_SIZE	O
(	O
(	O
unsigned	O
)	O
1	int
)	O
;	O
minfo	pointer
(	O
"0x%V %W %s 0x%v"	pointer
,	O
addr	pointer
,	O
TO_ADDR	O
(	O
size	int
)	O
,	O
name	pointer
,	O
data	pointer
->	O
value	long
)	O
;	O
if	O
(	O
data	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
!=	O
etree_value	int
)	O
{	O
print_space	function
(	O
)	O
;	O
exp_print_tree	function
(	O
data	pointer
->	O
exp	pointer
)	O
;	O
}	O
print_nl	function
(	O
)	O
;	O
print_dot	long
=	O
addr	pointer
+	O
TO_ADDR	O
(	O
size	int
)	O
;	O
}	O
static	O
void	O
print_address_statement	function
(	O
lang_address_statement_type	struct
*	O
address	long
)	O
{	O
minfo	pointer
(	O
_	O
(	O
"Address of section %s set to "	pointer
)	O
,	O
address	long
->	O
section_name	pointer
)	O
;	O
exp_print_tree	function
(	O
address	long
->	O
address	long
)	O
;	O
print_nl	function
(	O
)	O
;	O
}	O
static	O
void	O
print_reloc_statement	function
(	O
lang_reloc_statement_type	struct
*	O
reloc	enum
)	O
{	O
int	O
i	pointer
;	O
bfd_vma	long
addr	pointer
;	O
bfd_size_type	long
size	int
;	O
init_opb	function
(	O
reloc	enum
->	O
output_section	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
SECTION_NAME_MAP_LENGTH	O
;	O
i	pointer
++	O
)	O
print_space	function
(	O
)	O
;	O
addr	pointer
=	O
reloc	enum
->	O
output_offset	long
;	O
if	O
(	O
reloc	enum
->	O
output_section	pointer
!=	O
NULL	O
)	O
addr	pointer
+=	O
reloc	enum
->	O
output_section	pointer
->	O
vma	long
;	O
size	int
=	O
bfd_get_reloc_size	function
(	O
reloc	enum
->	O
howto	pointer
)	O
;	O
minfo	pointer
(	O
"0x%V %W RELOC %s "	pointer
,	O
addr	pointer
,	O
TO_ADDR	O
(	O
size	int
)	O
,	O
reloc	enum
->	O
howto	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
reloc	enum
->	O
name	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
"%s+"	pointer
,	O
reloc	enum
->	O
name	pointer
)	O
;	O
else	O
minfo	pointer
(	O
"%s+"	pointer
,	O
reloc	enum
->	O
section	pointer
->	O
name	pointer
)	O
;	O
exp_print_tree	function
(	O
reloc	enum
->	O
addend_exp	pointer
)	O
;	O
print_nl	function
(	O
)	O
;	O
print_dot	long
=	O
addr	pointer
+	O
TO_ADDR	O
(	O
size	int
)	O
;	O
}	O
static	O
void	O
print_padding_statement	function
(	O
lang_padding_statement_type	struct
*	O
s	pointer
)	O
{	O
int	O
len	long
;	O
bfd_vma	long
addr	pointer
;	O
init_opb	function
(	O
s	pointer
->	O
output_section	pointer
)	O
;	O
minfo	pointer
(	O
" *fill*"	pointer
)	O
;	O
len	long
=	O
sizeof	O
" *fill*"	pointer
-	O
1	int
;	O
while	O
(	O
len	long
<	O
SECTION_NAME_MAP_LENGTH	O
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
addr	pointer
=	O
s	pointer
->	O
output_offset	long
;	O
if	O
(	O
s	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
addr	pointer
+=	O
s	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
minfo	pointer
(	O
"0x%V %W "	pointer
,	O
addr	pointer
,	O
TO_ADDR	O
(	O
s	pointer
->	O
size	int
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
fill	pointer
->	O
size	int
!=	O
0	int
)	O
{	O
size_t	long
size	int
;	O
unsigned	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
s	pointer
->	O
fill	pointer
->	O
data	pointer
,	O
size	int
=	O
s	pointer
->	O
fill	pointer
->	O
size	int
;	O
size	int
!=	O
0	int
;	O
p	pointer
++	O
,	O
size	int
--	O
)	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"%02x"	pointer
,	O
*	O
p	pointer
)	O
;	O
}	O
print_nl	function
(	O
)	O
;	O
print_dot	long
=	O
addr	pointer
+	O
TO_ADDR	O
(	O
s	pointer
->	O
size	int
)	O
;	O
}	O
static	O
void	O
print_wild_statement	function
(	O
lang_wild_statement_type	struct
*	O
w	pointer
,	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
struct	O
wildcard_list	struct
*	O
sec	pointer
;	O
print_space	function
(	O
)	O
;	O
if	O
(	O
w	pointer
->	O
exclude_name_list	pointer
)	O
{	O
name_list	struct
*	O
tmp	pointer
;	O
minfo	pointer
(	O
"EXCLUDE_FILE(%s"	pointer
,	O
w	pointer
->	O
exclude_name_list	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
tmp	pointer
=	O
w	pointer
->	O
exclude_name_list	pointer
->	O
next	pointer
;	O
tmp	pointer
;	O
tmp	pointer
=	O
tmp	pointer
->	O
next	pointer
)	O
minfo	pointer
(	O
" %s"	pointer
,	O
tmp	pointer
->	O
name	pointer
)	O
;	O
minfo	pointer
(	O
") "	pointer
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
filenames_sorted	int
)	O
minfo	pointer
(	O
"SORT_BY_NAME("	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
filename	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
"%s"	pointer
,	O
w	pointer
->	O
filename	pointer
)	O
;	O
else	O
minfo	pointer
(	O
"*"	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
filenames_sorted	int
)	O
minfo	pointer
(	O
")"	pointer
)	O
;	O
minfo	pointer
(	O
"("	pointer
)	O
;	O
for	O
(	O
sec	pointer
=	O
w	pointer
->	O
section_list	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
int	O
closing_paren	int
=	O
0	int
;	O
switch	O
(	O
sec	pointer
->	O
spec	struct
.	O
sorted	enum
)	O
{	O
case	O
none	int
:	O
break	O
;	O
case	O
by_name	int
:	O
minfo	pointer
(	O
"SORT_BY_NAME("	pointer
)	O
;	O
closing_paren	int
=	O
1	int
;	O
break	O
;	O
case	O
by_alignment	int
:	O
minfo	pointer
(	O
"SORT_BY_ALIGNMENT("	pointer
)	O
;	O
closing_paren	int
=	O
1	int
;	O
break	O
;	O
case	O
by_name_alignment	int
:	O
minfo	pointer
(	O
"SORT_BY_NAME(SORT_BY_ALIGNMENT("	pointer
)	O
;	O
closing_paren	int
=	O
2	int
;	O
break	O
;	O
case	O
by_alignment_name	int
:	O
minfo	pointer
(	O
"SORT_BY_ALIGNMENT(SORT_BY_NAME("	pointer
)	O
;	O
closing_paren	int
=	O
2	int
;	O
break	O
;	O
case	O
by_none	int
:	O
minfo	pointer
(	O
"SORT_NONE("	pointer
)	O
;	O
closing_paren	int
=	O
1	int
;	O
break	O
;	O
case	O
by_init_priority	int
:	O
minfo	pointer
(	O
"SORT_BY_INIT_PRIORITY("	pointer
)	O
;	O
closing_paren	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
sec	pointer
->	O
spec	struct
.	O
exclude_name_list	pointer
!=	O
NULL	O
)	O
{	O
name_list	struct
*	O
tmp	pointer
;	O
minfo	pointer
(	O
"EXCLUDE_FILE(%s"	pointer
,	O
sec	pointer
->	O
spec	struct
.	O
exclude_name_list	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
tmp	pointer
=	O
sec	pointer
->	O
spec	struct
.	O
exclude_name_list	pointer
->	O
next	pointer
;	O
tmp	pointer
;	O
tmp	pointer
=	O
tmp	pointer
->	O
next	pointer
)	O
minfo	pointer
(	O
" %s"	pointer
,	O
tmp	pointer
->	O
name	pointer
)	O
;	O
minfo	pointer
(	O
") "	pointer
)	O
;	O
}	O
if	O
(	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
"%s"	pointer
,	O
sec	pointer
->	O
spec	struct
.	O
name	pointer
)	O
;	O
else	O
minfo	pointer
(	O
"*"	pointer
)	O
;	O
for	O
(	O
;	O
closing_paren	int
>	O
0	int
;	O
closing_paren	int
--	O
)	O
minfo	pointer
(	O
")"	pointer
)	O
;	O
if	O
(	O
sec	pointer
->	O
next	pointer
)	O
minfo	pointer
(	O
" "	pointer
)	O
;	O
}	O
minfo	pointer
(	O
")"	pointer
)	O
;	O
print_nl	function
(	O
)	O
;	O
print_statement_list	function
(	O
w	pointer
->	O
children	struct
.	O
head	pointer
,	O
os	int
)	O
;	O
}	O
static	O
void	O
print_group	function
(	O
lang_group_statement_type	struct
*	O
s	pointer
,	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"START GROUP\n"	pointer
)	O
;	O
print_statement_list	function
(	O
s	pointer
->	O
children	struct
.	O
head	pointer
,	O
os	int
)	O
;	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"END GROUP\n"	pointer
)	O
;	O
}	O
static	O
void	O
print_statement_list	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
print_statement	function
(	O
s	pointer
,	O
os	int
)	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
;	O
}	O
}	O
static	O
void	O
print_statement	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
lang_output_section_statement_type	struct
*	O
os	int
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
default	O
:	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
_	O
(	O
"Fail with %d\n"	pointer
)	O
,	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
;	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
if	O
(	O
constructor_list	struct
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
constructors_sorted	int
)	O
minfo	pointer
(	O
" SORT (CONSTRUCTORS)\n"	pointer
)	O
;	O
else	O
minfo	pointer
(	O
" CONSTRUCTORS\n"	pointer
)	O
;	O
print_statement_list	function
(	O
constructor_list	struct
.	O
head	pointer
,	O
os	int
)	O
;	O
}	O
break	O
;	O
case	O
lang_wild_statement_enum	int
:	O
print_wild_statement	function
(	O
&	O
s	pointer
->	O
wild_statement	struct
,	O
os	int
)	O
;	O
break	O
;	O
case	O
lang_address_statement_enum	int
:	O
print_address_statement	function
(	O
&	O
s	pointer
->	O
address_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_object_symbols_statement_enum	int
:	O
minfo	pointer
(	O
" CREATE_OBJECT_SYMBOLS\n"	pointer
)	O
;	O
break	O
;	O
case	O
lang_fill_statement_enum	int
:	O
print_fill_statement	function
(	O
&	O
s	pointer
->	O
fill_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_data_statement_enum	int
:	O
print_data_statement	function
(	O
&	O
s	pointer
->	O
data_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_reloc_statement_enum	int
:	O
print_reloc_statement	function
(	O
&	O
s	pointer
->	O
reloc_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_input_section_enum	int
:	O
print_input_section	function
(	O
s	pointer
->	O
input_section	pointer
.	O
section	pointer
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
lang_padding_statement_enum	int
:	O
print_padding_statement	function
(	O
&	O
s	pointer
->	O
padding_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
print_output_section_statement	function
(	O
&	O
s	pointer
->	O
output_section_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_assignment_statement_enum	int
:	O
print_assignment	function
(	O
&	O
s	pointer
->	O
assignment_statement	struct
,	O
os	int
)	O
;	O
break	O
;	O
case	O
lang_target_statement_enum	int
:	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"TARGET(%s)\n"	pointer
,	O
s	pointer
->	O
target_statement	struct
.	O
target	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_statement_enum	int
:	O
minfo	pointer
(	O
"OUTPUT(%s"	pointer
,	O
s	pointer
->	O
output_statement	struct
.	O
name	pointer
)	O
;	O
if	O
(	O
output_target	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
" %s"	pointer
,	O
output_target	pointer
)	O
;	O
minfo	pointer
(	O
")\n"	pointer
)	O
;	O
break	O
;	O
case	O
lang_input_statement_enum	int
:	O
print_input_statement	function
(	O
&	O
s	pointer
->	O
input_statement	struct
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
print_group	function
(	O
&	O
s	pointer
->	O
group_statement	struct
,	O
os	int
)	O
;	O
break	O
;	O
case	O
lang_insert_statement_enum	int
:	O
minfo	pointer
(	O
"INSERT %s %s\n"	pointer
,	O
s	pointer
->	O
insert_statement	struct
.	O
is_before	int
?	O
"BEFORE"	pointer
:	O
"AFTER"	pointer
,	O
s	pointer
->	O
insert_statement	struct
.	O
where	long
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
print_statements	function
(	O
void	O
)	O
{	O
print_statement_list	function
(	O
statement_list	struct
.	O
head	pointer
,	O
abs_output_section	pointer
)	O
;	O
}	O
void	O
dprint_statement	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
int	O
n	long
)	O
{	O
FILE	struct
*	O
map_save	pointer
=	O
config	struct
.	O
map_file	pointer
;	O
config	struct
.	O
map_file	pointer
=	O
stderr	pointer
;	O
if	O
(	O
n	long
<	O
0	int
)	O
print_statement_list	function
(	O
s	pointer
,	O
abs_output_section	pointer
)	O
;	O
else	O
{	O
while	O
(	O
s	pointer
&&	O
--	O
n	long
>=	O
0	int
)	O
{	O
print_statement	function
(	O
s	pointer
,	O
abs_output_section	pointer
)	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
;	O
}	O
}	O
config	struct
.	O
map_file	pointer
=	O
map_save	pointer
;	O
}	O
static	O
void	O
insert_pad	function
(	O
lang_statement_union_type	union
*	O
*	O
ptr	pointer
,	O
fill_type	struct
*	O
fill	pointer
,	O
bfd_size_type	long
alignment_needed	long
,	O
asection	struct
*	O
output_section	pointer
,	O
bfd_vma	long
dot	long
)	O
{	O
static	O
fill_type	struct
zero_fill	struct
;	O
lang_statement_union_type	union
*	O
pad	pointer
=	O
NULL	O
;	O
if	O
(	O
ptr	pointer
!=	O
&	O
statement_list	struct
.	O
head	pointer
)	O
pad	pointer
=	O
(	O
(	O
lang_statement_union_type	union
*	O
)	O
(	O
(	O
char	O
*	O
)	O
ptr	pointer
-	O
offsetof	O
(	O
lang_statement_union_type	union
,	O
header	struct
.	O
next	pointer
)	O
)	O
)	O
;	O
if	O
(	O
pad	pointer
!=	O
NULL	O
&&	O
pad	pointer
->	O
header	struct
.	O
type	enum
==	O
lang_padding_statement_enum	int
&&	O
pad	pointer
->	O
padding_statement	struct
.	O
output_section	pointer
==	O
output_section	pointer
)	O
{	O
}	O
else	O
if	O
(	O
(	O
pad	pointer
=	O
*	O
ptr	pointer
)	O
!=	O
NULL	O
&&	O
pad	pointer
->	O
header	struct
.	O
type	enum
==	O
lang_padding_statement_enum	int
&&	O
pad	pointer
->	O
padding_statement	struct
.	O
output_section	pointer
==	O
output_section	pointer
)	O
{	O
}	O
else	O
{	O
pad	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
lang_padding_statement_type	struct
)	O
)	O
;	O
pad	pointer
->	O
header	struct
.	O
next	pointer
=	O
*	O
ptr	pointer
;	O
*	O
ptr	pointer
=	O
pad	pointer
;	O
pad	pointer
->	O
header	struct
.	O
type	enum
=	O
lang_padding_statement_enum	int
;	O
pad	pointer
->	O
padding_statement	struct
.	O
output_section	pointer
=	O
output_section	pointer
;	O
if	O
(	O
fill	pointer
==	O
NULL	O
)	O
fill	pointer
=	O
&	O
zero_fill	struct
;	O
pad	pointer
->	O
padding_statement	struct
.	O
fill	pointer
=	O
fill	pointer
;	O
}	O
pad	pointer
->	O
padding_statement	struct
.	O
output_offset	long
=	O
dot	long
-	O
output_section	pointer
->	O
vma	long
;	O
pad	pointer
->	O
padding_statement	struct
.	O
size	int
=	O
alignment_needed	long
;	O
if	O
(	O
!	O
(	O
output_section	pointer
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
output_section	pointer
->	O
size	int
=	O
TO_SIZE	O
(	O
dot	long
+	O
TO_ADDR	O
(	O
alignment_needed	long
)	O
-	O
output_section	pointer
->	O
vma	long
)	O
;	O
}	O
static	O
bfd_vma	long
size_input_section	function
(	O
lang_statement_union_type	union
*	O
*	O
this_ptr	pointer
,	O
lang_output_section_statement_type	struct
*	O
output_section_statement	struct
,	O
fill_type	struct
*	O
fill	pointer
,	O
bfd_vma	long
dot	long
)	O
{	O
lang_input_section_type	struct
*	O
is	pointer
=	O
&	O
(	O
(	O
*	O
this_ptr	pointer
)	O
->	O
input_section	pointer
)	O
;	O
asection	struct
*	O
i	pointer
=	O
is	pointer
->	O
section	pointer
;	O
asection	struct
*	O
o	pointer
=	O
output_section_statement	struct
->	O
bfd_section	struct
;	O
if	O
(	O
i	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_JUST_SYMS	int
)	O
i	pointer
->	O
output_offset	long
=	O
i	pointer
->	O
vma	long
-	O
o	pointer
->	O
vma	long
;	O
else	O
if	O
(	O
(	O
(	O
i	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
)	O
||	O
output_section_statement	struct
->	O
ignored	int
)	O
i	pointer
->	O
output_offset	long
=	O
dot	long
-	O
o	pointer
->	O
vma	long
;	O
else	O
{	O
bfd_size_type	long
alignment_needed	long
;	O
if	O
(	O
output_section_statement	struct
->	O
subsection_alignment	pointer
!=	O
NULL	O
)	O
i	pointer
->	O
alignment_power	int
=	O
exp_get_power	function
(	O
output_section_statement	struct
->	O
subsection_alignment	pointer
,	O
"subsection alignment"	pointer
)	O
;	O
if	O
(	O
o	pointer
->	O
alignment_power	int
<	O
i	pointer
->	O
alignment_power	int
)	O
o	pointer
->	O
alignment_power	int
=	O
i	pointer
->	O
alignment_power	int
;	O
alignment_needed	long
=	O
align_power	O
(	O
dot	long
,	O
i	pointer
->	O
alignment_power	int
)	O
-	O
dot	long
;	O
if	O
(	O
alignment_needed	long
!=	O
0	int
)	O
{	O
insert_pad	function
(	O
this_ptr	pointer
,	O
fill	pointer
,	O
TO_SIZE	O
(	O
alignment_needed	long
)	O
,	O
o	pointer
,	O
dot	long
)	O
;	O
dot	long
+=	O
alignment_needed	long
;	O
}	O
i	pointer
->	O
output_offset	long
=	O
dot	long
-	O
o	pointer
->	O
vma	long
;	O
dot	long
+=	O
TO_ADDR	O
(	O
i	pointer
->	O
size	int
)	O
;	O
if	O
(	O
!	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
o	pointer
->	O
size	int
=	O
TO_SIZE	O
(	O
dot	long
-	O
o	pointer
->	O
vma	long
)	O
;	O
}	O
return	O
dot	long
;	O
}	O
struct	O
check_sec	struct
{	O
asection	struct
*	O
sec	pointer
;	O
bfd_boolean	int
warned	int
;	O
}	O
;	O
static	O
int	O
sort_sections_by_lma	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
asection	struct
*	O
sec1	pointer
=	O
(	O
(	O
const	O
struct	O
check_sec	struct
*	O
)	O
arg1	pointer
)	O
->	O
sec	pointer
;	O
const	O
asection	struct
*	O
sec2	pointer
=	O
(	O
(	O
const	O
struct	O
check_sec	struct
*	O
)	O
arg2	pointer
)	O
->	O
sec	pointer
;	O
if	O
(	O
sec1	pointer
->	O
lma	long
<	O
sec2	pointer
->	O
lma	long
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
lma	long
>	O
sec2	pointer
->	O
lma	long
)	O
return	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
id	int
<	O
sec2	pointer
->	O
id	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
id	int
>	O
sec2	pointer
->	O
id	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sort_sections_by_vma	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
asection	struct
*	O
sec1	pointer
=	O
(	O
(	O
const	O
struct	O
check_sec	struct
*	O
)	O
arg1	pointer
)	O
->	O
sec	pointer
;	O
const	O
asection	struct
*	O
sec2	pointer
=	O
(	O
(	O
const	O
struct	O
check_sec	struct
*	O
)	O
arg2	pointer
)	O
->	O
sec	pointer
;	O
if	O
(	O
sec1	pointer
->	O
vma	long
<	O
sec2	pointer
->	O
vma	long
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
vma	long
>	O
sec2	pointer
->	O
vma	long
)	O
return	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
id	int
<	O
sec2	pointer
->	O
id	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
id	int
>	O
sec2	pointer
->	O
id	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
lang_check_section_addresses	function
(	O
void	O
)	O
{	O
asection	struct
*	O
s	pointer
,	O
*	O
p	pointer
;	O
struct	O
check_sec	struct
*	O
sections	pointer
;	O
size_t	long
i	pointer
,	O
count	int
;	O
bfd_vma	long
addr_mask	long
;	O
bfd_vma	long
s_start	long
;	O
bfd_vma	long
s_end	long
;	O
bfd_vma	long
p_start	long
=	O
0	int
;	O
bfd_vma	long
p_end	long
=	O
0	int
;	O
lang_memory_region_type	struct
*	O
m	pointer
;	O
bfd_boolean	int
overlays	int
;	O
addr_mask	long
=	O
(	O
(	O
bfd_vma	long
)	O
1	int
<<	O
(	O
bfd_arch_bits_per_address	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
-	O
1	int
)	O
)	O
-	O
1	int
;	O
addr_mask	long
=	O
(	O
addr_mask	long
<<	O
1	int
)	O
+	O
1	int
;	O
for	O
(	O
s	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
s_end	long
=	O
(	O
s	pointer
->	O
vma	long
+	O
s	pointer
->	O
size	int
)	O
&	O
addr_mask	long
;	O
if	O
(	O
s_end	long
!=	O
0	int
&&	O
s_end	long
<	O
(	O
s	pointer
->	O
vma	long
&	O
addr_mask	long
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: section %s VMA wraps around address space\n"	pointer
)	O
,	O
s	pointer
->	O
name	pointer
)	O
;	O
else	O
{	O
s_end	long
=	O
(	O
s	pointer
->	O
lma	long
+	O
s	pointer
->	O
size	int
)	O
&	O
addr_mask	long
;	O
if	O
(	O
s_end	long
!=	O
0	int
&&	O
s_end	long
<	O
(	O
s	pointer
->	O
lma	long
&	O
addr_mask	long
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: section %s LMA wraps around address space\n"	pointer
)	O
,	O
s	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
if	O
(	O
bfd_count_sections	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
<=	O
1	int
)	O
return	O
;	O
count	int
=	O
bfd_count_sections	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
sections	pointer
=	O
XNEWVEC	O
(	O
struct	O
check_sec	struct
,	O
count	int
)	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
s	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
IGNORE_SECTION	O
(	O
s	pointer
)	O
||	O
s	pointer
->	O
size	int
==	O
0	int
)	O
continue	O
;	O
sections	pointer
[	O
count	int
]	O
.	O
sec	pointer
=	O
s	pointer
;	O
sections	pointer
[	O
count	int
]	O
.	O
warned	int
=	O
FALSE	int
;	O
count	int
++	O
;	O
}	O
if	O
(	O
count	int
<=	O
1	int
)	O
{	O
free	function
(	O
sections	pointer
)	O
;	O
return	O
;	O
}	O
qsort	function
(	O
sections	pointer
,	O
count	int
,	O
sizeof	O
(	O
*	O
sections	pointer
)	O
,	O
sort_sections_by_lma	function
)	O
;	O
for	O
(	O
p	pointer
=	O
NULL	O
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
s	pointer
=	O
sections	pointer
[	O
i	pointer
]	O
.	O
sec	pointer
;	O
init_opb	function
(	O
s	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
{	O
s_start	long
=	O
s	pointer
->	O
lma	long
;	O
s_end	long
=	O
s_start	long
+	O
TO_ADDR	O
(	O
s	pointer
->	O
size	int
)	O
-	O
1	int
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
(	O
s_start	long
<=	O
p_end	long
||	O
p_end	long
<	O
p_start	long
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: section %s LMA [%V,%V]"	pointer
" overlaps section %s LMA [%V,%V]\n"	pointer
)	O
,	O
s	pointer
->	O
name	pointer
,	O
s_start	long
,	O
s_end	long
,	O
p	pointer
->	O
name	pointer
,	O
p_start	long
,	O
p_end	long
)	O
;	O
sections	pointer
[	O
i	pointer
]	O
.	O
warned	int
=	O
TRUE	int
;	O
}	O
p	pointer
=	O
s	pointer
;	O
p_start	long
=	O
s_start	long
;	O
p_end	long
=	O
s_end	long
;	O
}	O
}	O
qsort	function
(	O
sections	pointer
,	O
count	int
,	O
sizeof	O
(	O
*	O
sections	pointer
)	O
,	O
sort_sections_by_vma	function
)	O
;	O
overlays	int
=	O
FALSE	int
;	O
p_start	long
=	O
sections	pointer
[	O
0	int
]	O
.	O
sec	pointer
->	O
vma	long
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
s_start	long
=	O
sections	pointer
[	O
i	pointer
]	O
.	O
sec	pointer
->	O
vma	long
;	O
if	O
(	O
p_start	long
==	O
s_start	long
)	O
{	O
overlays	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
p_start	long
=	O
s_start	long
;	O
}	O
if	O
(	O
!	O
overlays	int
)	O
{	O
for	O
(	O
p	pointer
=	O
NULL	O
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
s	pointer
=	O
sections	pointer
[	O
i	pointer
]	O
.	O
sec	pointer
;	O
init_opb	function
(	O
s	pointer
)	O
;	O
s_start	long
=	O
s	pointer
->	O
vma	long
;	O
s_end	long
=	O
s_start	long
+	O
TO_ADDR	O
(	O
s	pointer
->	O
size	int
)	O
-	O
1	int
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
!	O
sections	pointer
[	O
i	pointer
]	O
.	O
warned	int
&&	O
(	O
s_start	long
<=	O
p_end	long
||	O
p_end	long
<	O
p_start	long
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: section %s VMA [%V,%V]"	pointer
" overlaps section %s VMA [%V,%V]\n"	pointer
)	O
,	O
s	pointer
->	O
name	pointer
,	O
s_start	long
,	O
s_end	long
,	O
p	pointer
->	O
name	pointer
,	O
p_start	long
,	O
p_end	long
)	O
;	O
p	pointer
=	O
s	pointer
;	O
p_start	long
=	O
s_start	long
;	O
p_end	long
=	O
s_end	long
;	O
}	O
}	O
free	function
(	O
sections	pointer
)	O
;	O
for	O
(	O
m	pointer
=	O
lang_memory_region_list	pointer
;	O
m	pointer
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
if	O
(	O
m	pointer
->	O
had_full_message	int
)	O
{	O
unsigned	O
long	O
over	long
=	O
m	pointer
->	O
current	long
-	O
(	O
m	pointer
->	O
origin	long
+	O
m	pointer
->	O
length	long
)	O
;	O
einfo	pointer
(	O
ngettext	function
(	O
"%X%P: region `%s' overflowed by %lu byte\n"	pointer
,	O
"%X%P: region `%s' overflowed by %lu bytes\n"	pointer
,	O
over	long
)	O
,	O
m	pointer
->	O
name_list	struct
.	O
name	pointer
,	O
over	long
)	O
;	O
}	O
}	O
static	O
void	O
os_region_check	function
(	O
lang_output_section_statement_type	struct
*	O
os	int
,	O
lang_memory_region_type	struct
*	O
region	pointer
,	O
etree_type	union
*	O
tree	pointer
,	O
bfd_vma	long
rbase	long
)	O
{	O
if	O
(	O
(	O
region	pointer
->	O
current	long
<	O
region	pointer
->	O
origin	long
||	O
(	O
region	pointer
->	O
current	long
-	O
region	pointer
->	O
origin	long
>	O
region	pointer
->	O
length	long
)	O
)	O
&&	O
(	O
(	O
region	pointer
->	O
current	long
!=	O
region	pointer
->	O
origin	long
+	O
region	pointer
->	O
length	long
)	O
||	O
rbase	long
==	O
0	int
)	O
)	O
{	O
if	O
(	O
tree	pointer
!=	O
NULL	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: address 0x%v of %pB section `%s'"	pointer
" is not within region `%s'\n"	pointer
)	O
,	O
region	pointer
->	O
current	long
,	O
os	int
->	O
bfd_section	struct
->	O
owner	pointer
,	O
os	int
->	O
bfd_section	struct
->	O
name	pointer
,	O
region	pointer
->	O
name_list	struct
.	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
region	pointer
->	O
had_full_message	int
)	O
{	O
region	pointer
->	O
had_full_message	int
=	O
TRUE	int
;	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %pB section `%s' will not fit in region `%s'\n"	pointer
)	O
,	O
os	int
->	O
bfd_section	struct
->	O
owner	pointer
,	O
os	int
->	O
bfd_section	struct
->	O
name	pointer
,	O
region	pointer
->	O
name_list	struct
.	O
name	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
ldlang_check_relro_region	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
seg_align_type	struct
*	O
seg	pointer
)	O
{	O
if	O
(	O
seg	pointer
->	O
relro	int
==	O
exp_seg_relro_start	int
)	O
{	O
if	O
(	O
!	O
seg	pointer
->	O
relro_start_stat	pointer
)	O
seg	pointer
->	O
relro_start_stat	pointer
=	O
s	pointer
;	O
else	O
{	O
ASSERT	O
(	O
seg	pointer
->	O
relro_start_stat	pointer
==	O
s	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
seg	pointer
->	O
relro	int
==	O
exp_seg_relro_end	int
)	O
{	O
if	O
(	O
!	O
seg	pointer
->	O
relro_end_stat	pointer
)	O
seg	pointer
->	O
relro_end_stat	pointer
=	O
s	pointer
;	O
else	O
{	O
ASSERT	O
(	O
seg	pointer
->	O
relro_end_stat	pointer
==	O
s	pointer
)	O
;	O
}	O
}	O
}	O
static	O
bfd_vma	long
lang_size_sections_1	function
(	O
lang_statement_union_type	union
*	O
*	O
prev	pointer
,	O
lang_output_section_statement_type	struct
*	O
output_section_statement	struct
,	O
fill_type	struct
*	O
fill	pointer
,	O
bfd_vma	long
dot	long
,	O
bfd_boolean	int
*	O
relax	pointer
,	O
bfd_boolean	int
check_regions	int
)	O
{	O
lang_statement_union_type	union
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
*	O
prev	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_output_section_statement_enum	int
:	O
{	O
bfd_vma	long
newdot	long
,	O
after	pointer
,	O
dotdelta	long
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
lang_memory_region_type	struct
*	O
r	pointer
;	O
int	O
section_alignment	pointer
=	O
0	int
;	O
os	int
=	O
&	O
s	pointer
->	O
output_section_statement	struct
;	O
init_opb	function
(	O
os	int
->	O
bfd_section	struct
)	O
;	O
if	O
(	O
os	int
->	O
constraint	int
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
os	int
->	O
addr_tree	pointer
==	O
NULL	O
&&	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
)	O
)	O
os	int
->	O
addr_tree	pointer
=	O
exp_intop	function
(	O
0	int
)	O
;	O
if	O
(	O
os	int
->	O
addr_tree	pointer
!=	O
NULL	O
)	O
{	O
os	int
->	O
processed_vma	int
=	O
FALSE	int
;	O
exp_fold_tree	function
(	O
os	int
->	O
addr_tree	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
dot	long
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
dot	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
)	O
dot	long
+=	O
expld	struct
.	O
result	struct
.	O
section	pointer
->	O
vma	long
;	O
}	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: non constant or forward reference"	pointer
" address expression for section %s\n"	pointer
)	O
,	O
os	int
->	O
addr_tree	pointer
,	O
os	int
->	O
name	pointer
)	O
;	O
}	O
if	O
(	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
(	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_ecoff_flavour	int
)	O
||	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
)	O
)	O
&&	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_COFF_SHARED_LIBRARY	int
)	O
!=	O
0	int
)	O
{	O
asection	struct
*	O
input	pointer
;	O
if	O
(	O
os	int
->	O
children	struct
.	O
head	pointer
==	O
NULL	O
||	O
os	int
->	O
children	struct
.	O
head	pointer
->	O
header	struct
.	O
next	pointer
!=	O
NULL	O
||	O
(	O
os	int
->	O
children	struct
.	O
head	pointer
->	O
header	struct
.	O
type	enum
!=	O
lang_input_section_enum	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: internal error on COFF shared library"	pointer
" section %s\n"	pointer
)	O
,	O
os	int
->	O
name	pointer
)	O
;	O
input	pointer
=	O
os	int
->	O
children	struct
.	O
head	pointer
->	O
input_section	pointer
.	O
section	pointer
;	O
bfd_set_section_vma	function
(	O
os	int
->	O
bfd_section	struct
,	O
bfd_section_vma	function
(	O
input	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
os	int
->	O
bfd_section	struct
->	O
size	int
=	O
input	pointer
->	O
size	int
;	O
break	O
;	O
}	O
newdot	long
=	O
dot	long
;	O
dotdelta	long
=	O
0	int
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
os	int
->	O
bfd_section	struct
)	O
)	O
{	O
ASSERT	O
(	O
os	int
->	O
bfd_section	struct
->	O
vma	long
==	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
os	int
->	O
addr_tree	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
os	int
->	O
region	pointer
==	O
NULL	O
||	O
(	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
)	O
)	O
&&	O
os	int
->	O
region	pointer
->	O
name_list	struct
.	O
name	pointer
[	O
0	int
]	O
==	O
'*'	O
&&	O
strcmp	function
(	O
os	int
->	O
region	pointer
->	O
name_list	struct
.	O
name	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
==	O
0	int
)	O
)	O
{	O
os	int
->	O
region	pointer
=	O
lang_memory_default	function
(	O
os	int
->	O
bfd_section	struct
)	O
;	O
}	O
if	O
(	O
!	O
os	int
->	O
ignored	int
&&	O
!	O
IGNORE_SECTION	O
(	O
os	int
->	O
bfd_section	struct
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
check_regions	int
&&	O
strcmp	function
(	O
os	int
->	O
region	pointer
->	O
name_list	struct
.	O
name	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
==	O
0	int
&&	O
lang_memory_region_list	pointer
!=	O
NULL	O
&&	O
(	O
strcmp	function
(	O
lang_memory_region_list	pointer
->	O
name_list	struct
.	O
name	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
!=	O
0	int
||	O
lang_memory_region_list	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
&&	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
{	O
if	O
(	O
command_line	struct
.	O
check_section_addresses	char
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: error: no memory region specified"	pointer
" for loadable section `%s'\n"	pointer
)	O
,	O
bfd_section_name	function
(	O
os	int
->	O
bfd_section	struct
)	O
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: no memory region specified"	pointer
" for loadable section `%s'\n"	pointer
)	O
,	O
bfd_section_name	function
(	O
os	int
->	O
bfd_section	struct
)	O
)	O
;	O
}	O
newdot	long
=	O
os	int
->	O
region	pointer
->	O
current	long
;	O
section_alignment	pointer
=	O
os	int
->	O
bfd_section	struct
->	O
alignment_power	int
;	O
}	O
else	O
section_alignment	pointer
=	O
exp_get_power	function
(	O
os	int
->	O
section_alignment	pointer
,	O
"section alignment"	pointer
)	O
;	O
if	O
(	O
section_alignment	pointer
>	O
0	int
)	O
{	O
bfd_vma	long
savedot	long
=	O
newdot	long
;	O
newdot	long
=	O
align_power	O
(	O
newdot	long
,	O
section_alignment	pointer
)	O
;	O
dotdelta	long
=	O
newdot	long
-	O
savedot	long
;	O
if	O
(	O
dotdelta	long
!=	O
0	int
&&	O
(	O
config	struct
.	O
warn_section_align	int
||	O
os	int
->	O
addr_tree	pointer
!=	O
NULL	O
)	O
&&	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
ngettext	function
(	O
"%P: warning: changing start of "	pointer
"section %s by %lu byte\n"	pointer
,	O
"%P: warning: changing start of "	pointer
"section %s by %lu bytes\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dotdelta	long
)	O
,	O
os	int
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
dotdelta	long
)	O
;	O
}	O
bfd_set_section_vma	function
(	O
os	int
->	O
bfd_section	struct
,	O
newdot	long
)	O
;	O
os	int
->	O
bfd_section	struct
->	O
output_offset	long
=	O
0	int
;	O
}	O
lang_size_sections_1	function
(	O
&	O
os	int
->	O
children	struct
.	O
head	pointer
,	O
os	int
,	O
os	int
->	O
fill	pointer
,	O
newdot	long
,	O
relax	pointer
,	O
check_regions	int
)	O
;	O
os	int
->	O
processed_vma	int
=	O
TRUE	int
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
os	int
->	O
bfd_section	struct
)	O
||	O
os	int
->	O
ignored	int
)	O
ASSERT	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
==	O
0	int
)	O
;	O
else	O
{	O
dot	long
=	O
os	int
->	O
bfd_section	struct
->	O
vma	long
;	O
after	pointer
=	O
(	O
(	O
dot	long
+	O
TO_ADDR	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
)	O
+	O
os	int
->	O
block_value	int
-	O
1	int
)	O
&	O
-	O
(	O
bfd_vma	long
)	O
os	int
->	O
block_value	int
)	O
;	O
if	O
(	O
!	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
os	int
->	O
bfd_section	struct
->	O
size	int
=	O
TO_SIZE	O
(	O
after	pointer
-	O
os	int
->	O
bfd_section	struct
->	O
vma	long
)	O
;	O
}	O
r	pointer
=	O
os	int
->	O
region	pointer
;	O
if	O
(	O
r	pointer
==	O
NULL	O
)	O
r	pointer
=	O
lang_memory_region_lookup	function
(	O
DEFAULT_MEMORY_REGION	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
os	int
->	O
load_base	pointer
)	O
{	O
bfd_vma	long
lma	long
=	O
exp_get_abs_int	function
(	O
os	int
->	O
load_base	pointer
,	O
0	int
,	O
"load base"	pointer
)	O
;	O
os	int
->	O
bfd_section	struct
->	O
lma	long
=	O
lma	long
;	O
}	O
else	O
if	O
(	O
os	int
->	O
lma_region	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
lma	long
=	O
os	int
->	O
lma_region	pointer
->	O
current	long
;	O
if	O
(	O
os	int
->	O
align_lma_with_input	int
)	O
lma	long
+=	O
dotdelta	long
;	O
else	O
{	O
if	O
(	O
os	int
->	O
lma_region	pointer
!=	O
os	int
->	O
region	pointer
)	O
section_alignment	pointer
=	O
exp_get_power	function
(	O
os	int
->	O
section_alignment	pointer
,	O
"section alignment"	pointer
)	O
;	O
if	O
(	O
section_alignment	pointer
>	O
0	int
)	O
lma	long
=	O
align_power	O
(	O
lma	long
,	O
section_alignment	pointer
)	O
;	O
}	O
os	int
->	O
bfd_section	struct
->	O
lma	long
=	O
lma	long
;	O
}	O
else	O
if	O
(	O
r	pointer
->	O
last_os	pointer
!=	O
NULL	O
&&	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
bfd_vma	long
lma	long
;	O
asection	struct
*	O
last	pointer
;	O
last	pointer
=	O
r	pointer
->	O
last_os	pointer
->	O
output_section_statement	struct
.	O
bfd_section	struct
;	O
if	O
(	O
dot	long
<	O
last	pointer
->	O
vma	long
&&	O
os	int
->	O
bfd_section	struct
->	O
size	int
!=	O
0	int
&&	O
dot	long
+	O
TO_ADDR	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
)	O
<=	O
last	pointer
->	O
vma	long
)	O
{	O
if	O
(	O
last	pointer
->	O
vma	long
!=	O
last	pointer
->	O
lma	long
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: dot moved backwards "	pointer
"before `%s'\n"	pointer
)	O
,	O
os	int
->	O
name	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
os	int
->	O
sectype	enum
==	O
overlay_section	int
)	O
lma	long
=	O
last	pointer
->	O
lma	long
+	O
TO_ADDR	O
(	O
last	pointer
->	O
size	int
)	O
;	O
else	O
lma	long
=	O
os	int
->	O
bfd_section	struct
->	O
vma	long
+	O
last	pointer
->	O
lma	long
-	O
last	pointer
->	O
vma	long
;	O
if	O
(	O
section_alignment	pointer
>	O
0	int
)	O
lma	long
=	O
align_power	O
(	O
lma	long
,	O
section_alignment	pointer
)	O
;	O
os	int
->	O
bfd_section	struct
->	O
lma	long
=	O
lma	long
;	O
}	O
}	O
os	int
->	O
processed_lma	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
(	O
!	O
IGNORE_SECTION	O
(	O
os	int
->	O
bfd_section	struct
)	O
&&	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
!=	O
0	int
||	O
(	O
r	pointer
->	O
last_os	pointer
==	O
NULL	O
&&	O
os	int
->	O
bfd_section	struct
->	O
vma	long
!=	O
os	int
->	O
bfd_section	struct
->	O
lma	long
)	O
||	O
(	O
r	pointer
->	O
last_os	pointer
!=	O
NULL	O
&&	O
dot	long
>=	O
(	O
r	pointer
->	O
last_os	pointer
->	O
output_section_statement	struct
.	O
bfd_section	struct
->	O
vma	long
)	O
)	O
)	O
)	O
||	O
os	int
->	O
sectype	enum
==	O
first_overlay_section	int
)	O
&&	O
os	int
->	O
lma_region	pointer
==	O
NULL	O
&&	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
r	pointer
->	O
last_os	pointer
=	O
s	pointer
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
os	int
->	O
bfd_section	struct
)	O
||	O
os	int
->	O
ignored	int
)	O
break	O
;	O
if	O
(	O
!	O
IS_TBSS	O
(	O
os	int
->	O
bfd_section	struct
)	O
||	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
dotdelta	long
=	O
TO_ADDR	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
)	O
;	O
else	O
dotdelta	long
=	O
0	int
;	O
dot	long
+=	O
dotdelta	long
;	O
if	O
(	O
os	int
->	O
update_dot_tree	pointer
!=	O
0	int
)	O
exp_fold_tree	function
(	O
os	int
->	O
update_dot_tree	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
dot	long
)	O
;	O
if	O
(	O
os	int
->	O
region	pointer
!=	O
NULL	O
&&	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
)	O
)	O
)	O
{	O
os	int
->	O
region	pointer
->	O
current	long
=	O
dot	long
;	O
if	O
(	O
check_regions	int
)	O
os_region_check	function
(	O
os	int
,	O
os	int
->	O
region	pointer
,	O
os	int
->	O
addr_tree	pointer
,	O
os	int
->	O
bfd_section	struct
->	O
vma	long
)	O
;	O
if	O
(	O
os	int
->	O
lma_region	pointer
!=	O
NULL	O
&&	O
os	int
->	O
lma_region	pointer
!=	O
os	int
->	O
region	pointer
&&	O
(	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_LOAD	int
)	O
||	O
os	int
->	O
align_lma_with_input	int
)	O
)	O
{	O
os	int
->	O
lma_region	pointer
->	O
current	long
=	O
os	int
->	O
bfd_section	struct
->	O
lma	long
+	O
dotdelta	long
;	O
if	O
(	O
check_regions	int
)	O
os_region_check	function
(	O
os	int
,	O
os	int
->	O
lma_region	pointer
,	O
NULL	O
,	O
os	int
->	O
bfd_section	struct
->	O
lma	long
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
dot	long
=	O
lang_size_sections_1	function
(	O
&	O
constructor_list	struct
.	O
head	pointer
,	O
output_section_statement	struct
,	O
fill	pointer
,	O
dot	long
,	O
relax	pointer
,	O
check_regions	int
)	O
;	O
break	O
;	O
case	O
lang_data_statement_enum	int
:	O
{	O
unsigned	O
int	O
size	int
=	O
0	int
;	O
s	pointer
->	O
data_statement	struct
.	O
output_offset	long
=	O
dot	long
-	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
vma	long
;	O
s	pointer
->	O
data_statement	struct
.	O
output_section	pointer
=	O
output_section_statement	struct
->	O
bfd_section	struct
;	O
exp_fold_tree	function
(	O
s	pointer
->	O
data_statement	struct
.	O
exp	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
dot	long
)	O
;	O
switch	O
(	O
s	pointer
->	O
data_statement	struct
.	O
type	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
QUAD	int
:	O
case	O
SQUAD	int
:	O
size	int
=	O
QUAD_SIZE	O
;	O
break	O
;	O
case	O
LONG	int
:	O
size	int
=	O
LONG_SIZE	O
;	O
break	O
;	O
case	O
SHORT	int
:	O
size	int
=	O
SHORT_SIZE	O
;	O
break	O
;	O
case	O
BYTE	int
:	O
size	int
=	O
BYTE_SIZE	O
;	O
break	O
;	O
}	O
if	O
(	O
size	int
<	O
TO_SIZE	O
(	O
(	O
unsigned	O
)	O
1	int
)	O
)	O
size	int
=	O
TO_SIZE	O
(	O
(	O
unsigned	O
)	O
1	int
)	O
;	O
dot	long
+=	O
TO_ADDR	O
(	O
size	int
)	O
;	O
if	O
(	O
!	O
(	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
size	int
=	O
TO_SIZE	O
(	O
dot	long
-	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
vma	long
)	O
;	O
}	O
break	O
;	O
case	O
lang_reloc_statement_enum	int
:	O
{	O
int	O
size	int
;	O
s	pointer
->	O
reloc_statement	struct
.	O
output_offset	long
=	O
dot	long
-	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
vma	long
;	O
s	pointer
->	O
reloc_statement	struct
.	O
output_section	pointer
=	O
output_section_statement	struct
->	O
bfd_section	struct
;	O
size	int
=	O
bfd_get_reloc_size	function
(	O
s	pointer
->	O
reloc_statement	struct
.	O
howto	pointer
)	O
;	O
dot	long
+=	O
TO_ADDR	O
(	O
size	int
)	O
;	O
if	O
(	O
!	O
(	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
size	int
=	O
TO_SIZE	O
(	O
dot	long
-	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
vma	long
)	O
;	O
}	O
break	O
;	O
case	O
lang_wild_statement_enum	int
:	O
dot	long
=	O
lang_size_sections_1	function
(	O
&	O
s	pointer
->	O
wild_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
output_section_statement	struct
,	O
fill	pointer
,	O
dot	long
,	O
relax	pointer
,	O
check_regions	int
)	O
;	O
break	O
;	O
case	O
lang_object_symbols_statement_enum	int
:	O
link_info	struct
.	O
create_object_symbols_section	pointer
=	O
output_section_statement	struct
->	O
bfd_section	struct
;	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
break	O
;	O
case	O
lang_output_statement_enum	int
:	O
case	O
lang_target_statement_enum	int
:	O
break	O
;	O
case	O
lang_input_section_enum	int
:	O
{	O
asection	struct
*	O
i	pointer
;	O
i	pointer
=	O
s	pointer
->	O
input_section	pointer
.	O
section	pointer
;	O
if	O
(	O
relax	pointer
)	O
{	O
bfd_boolean	int
again	int
;	O
if	O
(	O
!	O
bfd_relax_section	O
(	O
i	pointer
->	O
owner	pointer
,	O
i	pointer
,	O
&	O
link_info	struct
,	O
&	O
again	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can't relax section: %E\n"	pointer
)	O
)	O
;	O
if	O
(	O
again	int
)	O
*	O
relax	pointer
=	O
TRUE	int
;	O
}	O
dot	long
=	O
size_input_section	function
(	O
prev	pointer
,	O
output_section_statement	struct
,	O
fill	pointer
,	O
dot	long
)	O
;	O
}	O
break	O
;	O
case	O
lang_input_statement_enum	int
:	O
break	O
;	O
case	O
lang_fill_statement_enum	int
:	O
s	pointer
->	O
fill_statement	struct
.	O
output_section	pointer
=	O
output_section_statement	struct
->	O
bfd_section	struct
;	O
fill	pointer
=	O
s	pointer
->	O
fill_statement	struct
.	O
fill	pointer
;	O
break	O
;	O
case	O
lang_assignment_statement_enum	int
:	O
{	O
bfd_vma	long
newdot	long
=	O
dot	long
;	O
etree_type	union
*	O
tree	pointer
=	O
s	pointer
->	O
assignment_statement	struct
.	O
exp	pointer
;	O
expld	struct
.	O
dataseg	struct
.	O
relro	int
=	O
exp_seg_relro_none	int
;	O
exp_fold_tree	function
(	O
tree	pointer
,	O
output_section_statement	struct
->	O
bfd_section	struct
,	O
&	O
newdot	long
)	O
;	O
ldlang_check_relro_region	function
(	O
s	pointer
,	O
&	O
expld	struct
.	O
dataseg	struct
)	O
;	O
expld	struct
.	O
dataseg	struct
.	O
relro	int
=	O
exp_seg_relro_none	int
;	O
if	O
(	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_provided	int
||	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_assign	int
)	O
&&	O
(	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
[	O
0	int
]	O
!=	O
'.'	O
||	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
)	O
output_section_statement	struct
->	O
update_dot	int
=	O
1	int
;	O
if	O
(	O
!	O
output_section_statement	struct
->	O
ignored	int
)	O
{	O
if	O
(	O
output_section_statement	struct
==	O
abs_output_section	pointer
)	O
{	O
lang_memory_region_lookup	function
(	O
DEFAULT_MEMORY_REGION	pointer
,	O
FALSE	int
)	O
->	O
current	long
=	O
newdot	long
;	O
}	O
else	O
if	O
(	O
newdot	long
!=	O
dot	long
)	O
{	O
insert_pad	function
(	O
&	O
s	pointer
->	O
header	struct
.	O
next	pointer
,	O
fill	pointer
,	O
TO_SIZE	O
(	O
newdot	long
-	O
dot	long
)	O
,	O
output_section_statement	struct
->	O
bfd_section	struct
,	O
dot	long
)	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
;	O
if	O
(	O
output_section_statement	struct
->	O
sectype	enum
!=	O
noalloc_section	int
&&	O
(	O
output_section_statement	struct
->	O
sectype	enum
!=	O
noload_section	int
||	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
)	O
)	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
}	O
dot	long
=	O
newdot	long
;	O
}	O
}	O
break	O
;	O
case	O
lang_padding_statement_enum	int
:	O
s	pointer
->	O
padding_statement	struct
.	O
size	int
=	O
0	int
;	O
s	pointer
->	O
padding_statement	struct
.	O
output_offset	long
=	O
dot	long
-	O
output_section_statement	struct
->	O
bfd_section	struct
->	O
vma	long
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
dot	long
=	O
lang_size_sections_1	function
(	O
&	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
output_section_statement	struct
,	O
fill	pointer
,	O
dot	long
,	O
relax	pointer
,	O
check_regions	int
)	O
;	O
break	O
;	O
case	O
lang_insert_statement_enum	int
:	O
break	O
;	O
case	O
lang_address_statement_enum	int
:	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
prev	pointer
=	O
&	O
s	pointer
->	O
header	struct
.	O
next	pointer
;	O
}	O
return	O
dot	long
;	O
}	O
bfd_boolean	int
ldlang_override_segment_assignment	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
current_section	pointer
,	O
asection	struct
*	O
previous_section	pointer
,	O
bfd_boolean	int
new_segment	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
cur	pointer
;	O
lang_output_section_statement_type	struct
*	O
prev	pointer
;	O
if	O
(	O
new_segment	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
current_section	pointer
==	O
NULL	O
||	O
previous_section	pointer
==	O
NULL	O
)	O
return	O
new_segment	int
;	O
if	O
(	O
config	struct
.	O
separate_code	int
&&	O
(	O
(	O
current_section	pointer
->	O
flags	int
^	O
previous_section	pointer
->	O
flags	int
)	O
&	O
SEC_CODE	int
)	O
)	O
return	O
TRUE	int
;	O
cur	pointer
=	O
lang_output_section_find	O
(	O
current_section	pointer
->	O
name	pointer
)	O
;	O
prev	pointer
=	O
lang_output_section_find	O
(	O
previous_section	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
cur	pointer
==	O
NULL	O
||	O
prev	pointer
==	O
NULL	O
)	O
return	O
new_segment	int
;	O
return	O
cur	pointer
->	O
region	pointer
!=	O
prev	pointer
->	O
region	pointer
;	O
}	O
void	O
one_lang_size_sections_pass	function
(	O
bfd_boolean	int
*	O
relax	pointer
,	O
bfd_boolean	int
check_regions	int
)	O
{	O
lang_statement_iteration	int
++	O
;	O
lang_size_sections_1	function
(	O
&	O
statement_list	struct
.	O
head	pointer
,	O
abs_output_section	pointer
,	O
0	int
,	O
0	int
,	O
relax	pointer
,	O
check_regions	int
)	O
;	O
}	O
static	O
bfd_boolean	int
lang_size_segment	function
(	O
seg_align_type	struct
*	O
seg	pointer
)	O
{	O
bfd_vma	long
first	pointer
,	O
last	pointer
;	O
first	pointer
=	O
-	O
seg	pointer
->	O
base	int
&	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
;	O
last	pointer
=	O
seg	pointer
->	O
end	pointer
&	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
;	O
if	O
(	O
first	pointer
&&	O
last	pointer
&&	O
(	O
(	O
seg	pointer
->	O
base	int
&	O
~	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
)	O
!=	O
(	O
seg	pointer
->	O
end	pointer
&	O
~	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
)	O
)	O
&&	O
first	pointer
+	O
last	pointer
<=	O
seg	pointer
->	O
pagesize	long
)	O
{	O
seg	pointer
->	O
phase	enum
=	O
exp_seg_adjust	int
;	O
return	O
TRUE	int
;	O
}	O
seg	pointer
->	O
phase	enum
=	O
exp_seg_done	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_vma	long
lang_size_relro_segment_1	function
(	O
seg_align_type	struct
*	O
seg	pointer
)	O
{	O
bfd_vma	long
relro_end	long
,	O
desired_end	long
;	O
asection	struct
*	O
sec	pointer
;	O
relro_end	long
=	O
(	O
(	O
seg	pointer
->	O
relro_end	long
+	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
&	O
~	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
)	O
;	O
desired_end	long
=	O
relro_end	long
-	O
seg	pointer
->	O
relro_offset	long
;	O
for	O
(	O
sec	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
section_last	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
prev	pointer
)	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
sec	pointer
->	O
vma	long
>=	O
seg	pointer
->	O
base	int
&&	O
sec	pointer
->	O
vma	long
<	O
seg	pointer
->	O
relro_end	long
-	O
seg	pointer
->	O
relro_offset	long
)	O
{	O
bfd_vma	long
start	pointer
,	O
end	pointer
,	O
bump	long
;	O
end	pointer
=	O
start	pointer
=	O
sec	pointer
->	O
vma	long
;	O
if	O
(	O
!	O
IS_TBSS	O
(	O
sec	pointer
)	O
)	O
end	pointer
+=	O
TO_ADDR	O
(	O
sec	pointer
->	O
size	int
)	O
;	O
bump	long
=	O
desired_end	long
-	O
end	pointer
;	O
start	pointer
+=	O
bump	long
;	O
start	pointer
&=	O
~	O
(	O
(	O
(	O
bfd_vma	long
)	O
1	int
<<	O
sec	pointer
->	O
alignment_power	int
)	O
-	O
1	int
)	O
;	O
desired_end	long
=	O
start	pointer
;	O
}	O
seg	pointer
->	O
phase	enum
=	O
exp_seg_relro_adjust	int
;	O
ASSERT	O
(	O
desired_end	long
>=	O
seg	pointer
->	O
base	int
)	O
;	O
seg	pointer
->	O
base	int
=	O
desired_end	long
;	O
return	O
relro_end	long
;	O
}	O
static	O
bfd_boolean	int
lang_size_relro_segment	function
(	O
bfd_boolean	int
*	O
relax	pointer
,	O
bfd_boolean	int
check_regions	int
)	O
{	O
bfd_boolean	int
do_reset	int
=	O
FALSE	int
;	O
bfd_boolean	int
do_data_relro	int
;	O
bfd_vma	long
data_initial_base	long
,	O
data_relro_end	long
;	O
if	O
(	O
link_info	struct
.	O
relro	int
&&	O
expld	struct
.	O
dataseg	struct
.	O
relro_end	long
)	O
{	O
do_data_relro	int
=	O
TRUE	int
;	O
data_initial_base	long
=	O
expld	struct
.	O
dataseg	struct
.	O
base	int
;	O
data_relro_end	long
=	O
lang_size_relro_segment_1	function
(	O
&	O
expld	struct
.	O
dataseg	struct
)	O
;	O
}	O
else	O
{	O
do_data_relro	int
=	O
FALSE	int
;	O
data_initial_base	long
=	O
data_relro_end	long
=	O
0	int
;	O
}	O
if	O
(	O
do_data_relro	int
)	O
{	O
lang_reset_memory_regions	function
(	O
)	O
;	O
one_lang_size_sections_pass	function
(	O
relax	pointer
,	O
check_regions	int
)	O
;	O
if	O
(	O
do_data_relro	int
&&	O
expld	struct
.	O
dataseg	struct
.	O
relro_end	long
>	O
data_relro_end	long
)	O
{	O
expld	struct
.	O
dataseg	struct
.	O
base	int
=	O
data_initial_base	long
;	O
;	O
do_reset	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
do_data_relro	int
&&	O
lang_size_segment	function
(	O
&	O
expld	struct
.	O
dataseg	struct
)	O
)	O
do_reset	int
=	O
TRUE	int
;	O
return	O
do_reset	int
;	O
}	O
void	O
lang_size_sections	function
(	O
bfd_boolean	int
*	O
relax	pointer
,	O
bfd_boolean	int
check_regions	int
)	O
{	O
expld	struct
.	O
phase	enum
=	O
lang_allocating_phase_enum	int
;	O
expld	struct
.	O
dataseg	struct
.	O
phase	enum
=	O
exp_seg_none	int
;	O
one_lang_size_sections_pass	function
(	O
relax	pointer
,	O
check_regions	int
)	O
;	O
if	O
(	O
expld	struct
.	O
dataseg	struct
.	O
phase	enum
!=	O
exp_seg_end_seen	int
)	O
expld	struct
.	O
dataseg	struct
.	O
phase	enum
=	O
exp_seg_done	int
;	O
if	O
(	O
expld	struct
.	O
dataseg	struct
.	O
phase	enum
==	O
exp_seg_end_seen	int
)	O
{	O
bfd_boolean	int
do_reset	int
=	O
lang_size_relro_segment	function
(	O
relax	pointer
,	O
check_regions	int
)	O
;	O
if	O
(	O
do_reset	int
)	O
{	O
lang_reset_memory_regions	function
(	O
)	O
;	O
one_lang_size_sections_pass	function
(	O
relax	pointer
,	O
check_regions	int
)	O
;	O
}	O
if	O
(	O
link_info	struct
.	O
relro	int
&&	O
expld	struct
.	O
dataseg	struct
.	O
relro_end	long
)	O
{	O
link_info	struct
.	O
relro_start	long
=	O
expld	struct
.	O
dataseg	struct
.	O
base	int
;	O
link_info	struct
.	O
relro_end	long
=	O
expld	struct
.	O
dataseg	struct
.	O
relro_end	long
;	O
}	O
}	O
}	O
static	O
lang_output_section_statement_type	struct
*	O
current_section	pointer
;	O
static	O
lang_assignment_statement_type	struct
*	O
current_assign	pointer
;	O
static	O
bfd_boolean	int
prefer_next_section	int
;	O
static	O
bfd_vma	long
lang_do_assignments_1	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
lang_output_section_statement_type	struct
*	O
current_os	pointer
,	O
fill_type	struct
*	O
fill	pointer
,	O
bfd_vma	long
dot	long
,	O
bfd_boolean	int
*	O
found_end	pointer
)	O
{	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_constructors_statement_enum	int
:	O
dot	long
=	O
lang_do_assignments_1	function
(	O
constructor_list	struct
.	O
head	pointer
,	O
current_os	pointer
,	O
fill	pointer
,	O
dot	long
,	O
found_end	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
bfd_vma	long
newdot	long
;	O
os	int
=	O
&	O
(	O
s	pointer
->	O
output_section_statement	struct
)	O
;	O
os	int
->	O
after_end	int
=	O
*	O
found_end	pointer
;	O
init_opb	function
(	O
os	int
->	O
bfd_section	struct
)	O
;	O
if	O
(	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
!	O
os	int
->	O
ignored	int
)	O
{	O
if	O
(	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
current_section	pointer
=	O
os	int
;	O
prefer_next_section	int
=	O
FALSE	int
;	O
}	O
dot	long
=	O
os	int
->	O
bfd_section	struct
->	O
vma	long
;	O
}	O
newdot	long
=	O
lang_do_assignments_1	function
(	O
os	int
->	O
children	struct
.	O
head	pointer
,	O
os	int
,	O
os	int
->	O
fill	pointer
,	O
dot	long
,	O
found_end	pointer
)	O
;	O
if	O
(	O
!	O
os	int
->	O
ignored	int
)	O
{	O
if	O
(	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
IS_TBSS	O
(	O
os	int
->	O
bfd_section	struct
)	O
||	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
dot	long
+=	O
TO_ADDR	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
)	O
;	O
if	O
(	O
os	int
->	O
update_dot_tree	pointer
!=	O
NULL	O
)	O
exp_fold_tree	function
(	O
os	int
->	O
update_dot_tree	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
dot	long
)	O
;	O
}	O
else	O
dot	long
=	O
newdot	long
;	O
}	O
}	O
break	O
;	O
case	O
lang_wild_statement_enum	int
:	O
dot	long
=	O
lang_do_assignments_1	function
(	O
s	pointer
->	O
wild_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
current_os	pointer
,	O
fill	pointer
,	O
dot	long
,	O
found_end	pointer
)	O
;	O
break	O
;	O
case	O
lang_object_symbols_statement_enum	int
:	O
case	O
lang_output_statement_enum	int
:	O
case	O
lang_target_statement_enum	int
:	O
break	O
;	O
case	O
lang_data_statement_enum	int
:	O
exp_fold_tree	function
(	O
s	pointer
->	O
data_statement	struct
.	O
exp	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
dot	long
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
s	pointer
->	O
data_statement	struct
.	O
value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
)	O
s	pointer
->	O
data_statement	struct
.	O
value	long
+=	O
expld	struct
.	O
result	struct
.	O
section	pointer
->	O
vma	long
;	O
}	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid data statement\n"	pointer
)	O
)	O
;	O
{	O
unsigned	O
int	O
size	int
;	O
switch	O
(	O
s	pointer
->	O
data_statement	struct
.	O
type	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
QUAD	int
:	O
case	O
SQUAD	int
:	O
size	int
=	O
QUAD_SIZE	O
;	O
break	O
;	O
case	O
LONG	int
:	O
size	int
=	O
LONG_SIZE	O
;	O
break	O
;	O
case	O
SHORT	int
:	O
size	int
=	O
SHORT_SIZE	O
;	O
break	O
;	O
case	O
BYTE	int
:	O
size	int
=	O
BYTE_SIZE	O
;	O
break	O
;	O
}	O
if	O
(	O
size	int
<	O
TO_SIZE	O
(	O
(	O
unsigned	O
)	O
1	int
)	O
)	O
size	int
=	O
TO_SIZE	O
(	O
(	O
unsigned	O
)	O
1	int
)	O
;	O
dot	long
+=	O
TO_ADDR	O
(	O
size	int
)	O
;	O
}	O
break	O
;	O
case	O
lang_reloc_statement_enum	int
:	O
exp_fold_tree	function
(	O
s	pointer
->	O
reloc_statement	struct
.	O
addend_exp	pointer
,	O
bfd_abs_section_ptr	O
,	O
&	O
dot	long
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
s	pointer
->	O
reloc_statement	struct
.	O
addend_value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid reloc statement\n"	pointer
)	O
)	O
;	O
dot	long
+=	O
TO_ADDR	O
(	O
bfd_get_reloc_size	function
(	O
s	pointer
->	O
reloc_statement	struct
.	O
howto	pointer
)	O
)	O
;	O
break	O
;	O
case	O
lang_input_section_enum	int
:	O
{	O
asection	struct
*	O
in	pointer
=	O
s	pointer
->	O
input_section	pointer
.	O
section	pointer
;	O
if	O
(	O
(	O
in	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
)	O
dot	long
+=	O
TO_ADDR	O
(	O
in	pointer
->	O
size	int
)	O
;	O
}	O
break	O
;	O
case	O
lang_input_statement_enum	int
:	O
break	O
;	O
case	O
lang_fill_statement_enum	int
:	O
fill	pointer
=	O
s	pointer
->	O
fill_statement	struct
.	O
fill	pointer
;	O
break	O
;	O
case	O
lang_assignment_statement_enum	int
:	O
current_assign	pointer
=	O
&	O
s	pointer
->	O
assignment_statement	struct
;	O
if	O
(	O
current_assign	pointer
->	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
!=	O
etree_assert	int
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
current_assign	pointer
->	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
;	O
if	O
(	O
current_os	pointer
==	O
abs_output_section	pointer
&&	O
p	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
0	int
)	O
prefer_next_section	int
=	O
TRUE	int
;	O
while	O
(	O
*	O
p	pointer
==	O
'_'	O
)	O
++	O
p	pointer
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"end"	pointer
)	O
==	O
0	int
)	O
*	O
found_end	pointer
=	O
TRUE	int
;	O
}	O
exp_fold_tree	function
(	O
s	pointer
->	O
assignment_statement	struct
.	O
exp	pointer
,	O
(	O
current_os	pointer
->	O
bfd_section	struct
!=	O
NULL	O
?	O
current_os	pointer
->	O
bfd_section	struct
:	O
bfd_und_section_ptr	O
)	O
,	O
&	O
dot	long
)	O
;	O
break	O
;	O
case	O
lang_padding_statement_enum	int
:	O
dot	long
+=	O
TO_ADDR	O
(	O
s	pointer
->	O
padding_statement	struct
.	O
size	int
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
dot	long
=	O
lang_do_assignments_1	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
current_os	pointer
,	O
fill	pointer
,	O
dot	long
,	O
found_end	pointer
)	O
;	O
break	O
;	O
case	O
lang_insert_statement_enum	int
:	O
break	O
;	O
case	O
lang_address_statement_enum	int
:	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
dot	long
;	O
}	O
void	O
lang_do_assignments	function
(	O
lang_phase_type	enum
phase	enum
)	O
{	O
bfd_boolean	int
found_end	pointer
=	O
FALSE	int
;	O
current_section	pointer
=	O
NULL	O
;	O
prefer_next_section	int
=	O
FALSE	int
;	O
expld	struct
.	O
phase	enum
=	O
phase	enum
;	O
lang_statement_iteration	int
++	O
;	O
lang_do_assignments_1	function
(	O
statement_list	struct
.	O
head	pointer
,	O
abs_output_section	pointer
,	O
NULL	O
,	O
0	int
,	O
&	O
found_end	pointer
)	O
;	O
}	O
asection	struct
*	O
section_for_dot	function
(	O
void	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
if	O
(	O
current_section	pointer
==	O
NULL	O
||	O
prefer_next_section	int
)	O
{	O
lang_statement_union_type	union
*	O
stmt	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
for	O
(	O
stmt	pointer
=	O
(	O
lang_statement_union_type	union
*	O
)	O
current_assign	pointer
;	O
stmt	pointer
!=	O
NULL	O
;	O
stmt	pointer
=	O
stmt	pointer
->	O
header	struct
.	O
next	pointer
)	O
if	O
(	O
stmt	pointer
->	O
header	struct
.	O
type	enum
==	O
lang_output_section_statement_enum	int
)	O
break	O
;	O
os	int
=	O
&	O
stmt	pointer
->	O
output_section_statement	struct
;	O
while	O
(	O
os	int
!=	O
NULL	O
&&	O
!	O
os	int
->	O
after_end	int
&&	O
(	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
||	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
||	O
bfd_section_removed_from_list	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
os	int
->	O
bfd_section	struct
)	O
)	O
)	O
os	int
=	O
os	int
->	O
next	pointer
;	O
if	O
(	O
current_section	pointer
==	O
NULL	O
||	O
os	int
==	O
NULL	O
||	O
!	O
os	int
->	O
after_end	int
)	O
{	O
if	O
(	O
os	int
!=	O
NULL	O
)	O
s	pointer
=	O
os	int
->	O
bfd_section	struct
;	O
else	O
s	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
section_last	pointer
;	O
while	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
||	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
)	O
s	pointer
=	O
s	pointer
->	O
prev	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
return	O
s	pointer
;	O
return	O
bfd_abs_section_ptr	O
;	O
}	O
}	O
s	pointer
=	O
current_section	pointer
->	O
bfd_section	struct
;	O
while	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
||	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
||	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
||	O
bfd_section_removed_from_list	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
s	pointer
)	O
)	O
)	O
s	pointer
=	O
s	pointer
->	O
prev	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
while	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
||	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
)	O
s	pointer
=	O
s	pointer
->	O
next	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
return	O
s	pointer
;	O
return	O
bfd_abs_section_ptr	O
;	O
}	O
static	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
start_stop_syms	pointer
;	O
static	O
size_t	long
start_stop_count	long
=	O
0	int
;	O
static	O
size_t	long
start_stop_alloc	long
=	O
0	int
;	O
static	O
void	O
lang_define_start_stop	function
(	O
const	O
char	O
*	O
symbol	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
bfd_define_start_stop	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
symbol	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
start_stop_count	long
==	O
start_stop_alloc	long
)	O
{	O
start_stop_alloc	long
=	O
2	int
*	O
start_stop_alloc	long
+	O
10	int
;	O
start_stop_syms	pointer
=	O
xrealloc	function
(	O
start_stop_syms	pointer
,	O
start_stop_alloc	long
*	O
sizeof	O
(	O
*	O
start_stop_syms	pointer
)	O
)	O
;	O
}	O
start_stop_syms	pointer
[	O
start_stop_count	long
++	O
]	O
=	O
h	pointer
;	O
}	O
}	O
static	O
void	O
lang_init_start_stop	function
(	O
void	O
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
asection	struct
*	O
s	pointer
;	O
char	O
leading_char	char
=	O
bfd_get_symbol_leading_char	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
for	O
(	O
abfd	pointer
=	O
link_info	struct
.	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
ps	pointer
;	O
const	O
char	O
*	O
secname	pointer
=	O
s	pointer
->	O
name	pointer
;	O
for	O
(	O
ps	pointer
=	O
secname	pointer
;	O
*	O
ps	pointer
!=	O
'\0'	O
;	O
ps	pointer
++	O
)	O
if	O
(	O
!	O
ISALNUM	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
ps	pointer
)	O
&&	O
*	O
ps	pointer
!=	O
'_'	O
)	O
break	O
;	O
if	O
(	O
*	O
ps	pointer
==	O
'\0'	O
)	O
{	O
char	O
*	O
symbol	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
10	int
+	O
strlen	function
(	O
secname	pointer
)	O
)	O
;	O
symbol	pointer
[	O
0	int
]	O
=	O
leading_char	char
;	O
sprintf	function
(	O
symbol	pointer
+	O
(	O
leading_char	char
!=	O
0	int
)	O
,	O
"__start_%s"	pointer
,	O
secname	pointer
)	O
;	O
lang_define_start_stop	function
(	O
symbol	pointer
,	O
s	pointer
)	O
;	O
symbol	pointer
[	O
1	int
]	O
=	O
leading_char	char
;	O
memcpy	function
(	O
symbol	pointer
+	O
1	int
+	O
(	O
leading_char	char
!=	O
0	int
)	O
,	O
"__stop"	pointer
,	O
6	int
)	O
;	O
lang_define_start_stop	function
(	O
symbol	pointer
+	O
1	int
,	O
s	pointer
)	O
;	O
free	function
(	O
symbol	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
foreach_start_stop	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
)	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
start_stop_count	long
;	O
++	O
i	pointer
)	O
func	pointer
(	O
start_stop_syms	pointer
[	O
i	pointer
]	O
)	O
;	O
}	O
static	O
void	O
undef_start_stop	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
ldscript_def	int
)	O
return	O
;	O
if	O
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
==	O
NULL	O
||	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
owner	pointer
!=	O
link_info	struct
.	O
output_bfd	pointer
||	O
strcmp	function
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
name	pointer
,	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
name	pointer
)	O
!=	O
0	int
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
sec	pointer
->	O
map_head	union
.	O
s	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
map_head	union
.	O
s	pointer
)	O
if	O
(	O
strcmp	function
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
name	pointer
,	O
i	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
i	pointer
;	O
return	O
;	O
}	O
}	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
lang_undef_start_stop	function
(	O
void	O
)	O
{	O
foreach_start_stop	function
(	O
undef_start_stop	function
)	O
;	O
}	O
static	O
void	O
lang_init_startof_sizeof	function
(	O
void	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
secname	pointer
=	O
s	pointer
->	O
name	pointer
;	O
char	O
*	O
symbol	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
10	int
+	O
strlen	function
(	O
secname	pointer
)	O
)	O
;	O
sprintf	function
(	O
symbol	pointer
,	O
".startof.%s"	pointer
,	O
secname	pointer
)	O
;	O
lang_define_start_stop	function
(	O
symbol	pointer
,	O
s	pointer
)	O
;	O
memcpy	function
(	O
symbol	pointer
+	O
1	int
,	O
".size"	pointer
,	O
5	int
)	O
;	O
lang_define_start_stop	function
(	O
symbol	pointer
+	O
1	int
,	O
s	pointer
)	O
;	O
free	function
(	O
symbol	pointer
)	O
;	O
}	O
}	O
static	O
void	O
set_start_stop	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
ldscript_def	int
||	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_defined	int
)	O
return	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
string	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
string	pointer
[	O
2	int
]	O
==	O
'i'	O
)	O
{	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
TO_ADDR	O
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
size	int
)	O
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
}	O
}	O
else	O
{	O
int	O
has_lead	int
=	O
bfd_get_symbol_leading_char	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
!=	O
0	int
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
string	pointer
[	O
4	int
+	O
has_lead	int
]	O
==	O
'o'	O
)	O
{	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
TO_ADDR	O
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
size	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
lang_finalize_start_stop	function
(	O
void	O
)	O
{	O
foreach_start_stop	function
(	O
set_start_stop	function
)	O
;	O
}	O
static	O
void	O
lang_end	function
(	O
void	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
bfd_boolean	int
warn	int
;	O
if	O
(	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
!	O
link_info	struct
.	O
gc_sections	int
)	O
||	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
)	O
warn	int
=	O
entry_from_cmdline	int
;	O
else	O
warn	int
=	O
TRUE	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
gc_sections	int
&&	O
!	O
link_info	struct
.	O
gc_keep_exported	int
&&	O
!	O
(	O
entry_from_cmdline	int
||	O
undef_from_cmdline	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: gc-sections requires either an entry or "	pointer
"an undefined symbol\n"	pointer
)	O
)	O
;	O
if	O
(	O
entry_symbol	struct
.	O
name	pointer
==	O
NULL	O
)	O
{	O
entry_symbol	struct
.	O
name	pointer
=	O
entry_symbol_default	pointer
;	O
warn	int
=	O
FALSE	int
;	O
}	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
entry_symbol	struct
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
val	array
;	O
val	array
=	O
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
+	O
bfd_section_vma	function
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
)	O
+	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
!	O
bfd_set_start_address	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
val	array
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: can't set start address\n"	pointer
)	O
,	O
entry_symbol	struct
.	O
name	pointer
)	O
;	O
}	O
else	O
{	O
bfd_vma	long
val	array
;	O
const	O
char	O
*	O
send	pointer
;	O
val	array
=	O
bfd_scan_vma	function
(	O
entry_symbol	struct
.	O
name	pointer
,	O
&	O
send	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
send	pointer
==	O
'\0'	O
)	O
{	O
if	O
(	O
!	O
bfd_set_start_address	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
val	array
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can't set start address\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
asection	struct
*	O
ts	pointer
;	O
ts	pointer
=	O
bfd_get_section_by_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
entry_section	pointer
)	O
;	O
if	O
(	O
ts	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
warn	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: cannot find entry symbol %s;"	pointer
" defaulting to %V\n"	pointer
)	O
,	O
entry_symbol	struct
.	O
name	pointer
,	O
bfd_section_vma	function
(	O
ts	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_start_address	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
bfd_section_vma	function
(	O
ts	pointer
)	O
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can't set start address\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
warn	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: cannot find entry symbol %s;"	pointer
" not setting start address\n"	pointer
)	O
,	O
entry_symbol	struct
.	O
name	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
ignore_bfd_errors	function
(	O
const	O
char	O
*	O
fmt	pointer
ATTRIBUTE_UNUSED	O
,	O
va_list	array
ap	array
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
static	O
void	O
lang_check	function
(	O
void	O
)	O
{	O
lang_input_statement_type	struct
*	O
file	pointer
;	O
bfd	struct
*	O
input_bfd	pointer
;	O
const	O
bfd_arch_info_type	struct
*	O
compatible	pointer
;	O
for	O
(	O
file	pointer
=	O
(	O
void	O
*	O
)	O
file_chain	struct
.	O
head	pointer
;	O
file	pointer
!=	O
NULL	O
;	O
file	pointer
=	O
file	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
file	pointer
->	O
flags	int
.	O
claimed	int
)	O
continue	O
;	O
input_bfd	pointer
=	O
file	pointer
->	O
the_bfd	pointer
;	O
compatible	pointer
=	O
bfd_arch_get_compatible	function
(	O
input_bfd	pointer
,	O
link_info	struct
.	O
output_bfd	pointer
,	O
command_line	struct
.	O
accept_unknown_input_arch	int
)	O
;	O
if	O
(	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
||	O
link_info	struct
.	O
emitrelocations	int
)	O
&&	O
(	O
compatible	pointer
==	O
NULL	O
||	O
(	O
bfd_get_flavour	function
(	O
input_bfd	pointer
)	O
!=	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
)	O
)	O
&&	O
(	O
bfd_get_file_flags	function
(	O
input_bfd	pointer
)	O
&	O
HAS_RELOC	int
)	O
!=	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: relocatable linking with relocations from"	pointer
" format %s (%pB) to format %s (%pB) is not supported\n"	pointer
)	O
,	O
bfd_get_target	function
(	O
input_bfd	pointer
)	O
,	O
input_bfd	pointer
,	O
bfd_get_target	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
,	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
}	O
if	O
(	O
compatible	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
command_line	struct
.	O
warn_mismatch	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %s architecture of input file `%pB'"	pointer
" is incompatible with %s output\n"	pointer
)	O
,	O
bfd_printable_name	function
(	O
input_bfd	pointer
)	O
,	O
input_bfd	pointer
,	O
bfd_printable_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
bfd_count_sections	function
(	O
input_bfd	pointer
)	O
)	O
{	O
bfd_error_handler_type	pointer
pfn	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
command_line	struct
.	O
warn_mismatch	int
)	O
pfn	pointer
=	O
bfd_set_error_handler	function
(	O
ignore_bfd_errors	function
)	O
;	O
if	O
(	O
!	O
bfd_merge_private_bfd_data	function
(	O
input_bfd	pointer
,	O
&	O
link_info	struct
)	O
)	O
{	O
if	O
(	O
command_line	struct
.	O
warn_mismatch	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: failed to merge target specific data"	pointer
" of file %pB\n"	pointer
)	O
,	O
input_bfd	pointer
)	O
;	O
}	O
if	O
(	O
!	O
command_line	struct
.	O
warn_mismatch	int
)	O
bfd_set_error_handler	function
(	O
pfn	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
lang_common	function
(	O
void	O
)	O
{	O
if	O
(	O
link_info	struct
.	O
inhibit_common_definition	int
)	O
return	O
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
!	O
command_line	struct
.	O
force_common_definition	int
)	O
return	O
;	O
if	O
(	O
!	O
config	struct
.	O
sort_common	enum
)	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
lang_one_common	function
,	O
NULL	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
power	int
;	O
if	O
(	O
config	struct
.	O
sort_common	enum
==	O
sort_descending	int
)	O
{	O
for	O
(	O
power	int
=	O
4	int
;	O
power	int
>	O
0	int
;	O
power	int
--	O
)	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
lang_one_common	function
,	O
&	O
power	int
)	O
;	O
power	int
=	O
0	int
;	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
lang_one_common	function
,	O
&	O
power	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
power	int
=	O
0	int
;	O
power	int
<=	O
4	int
;	O
power	int
++	O
)	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
lang_one_common	function
,	O
&	O
power	int
)	O
;	O
power	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
bfd_link_hash_traverse	function
(	O
link_info	struct
.	O
hash	long
,	O
lang_one_common	function
,	O
&	O
power	int
)	O
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
lang_one_common	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
info	pointer
)	O
{	O
unsigned	O
int	O
power_of_two	int
;	O
bfd_vma	long
size	int
;	O
asection	struct
*	O
section	pointer
;	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_common	int
)	O
return	O
TRUE	int
;	O
size	int
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	int
;	O
power_of_two	int
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
;	O
if	O
(	O
config	struct
.	O
sort_common	enum
==	O
sort_descending	int
&&	O
power_of_two	int
<	O
*	O
(	O
unsigned	O
int	O
*	O
)	O
info	pointer
)	O
return	O
TRUE	int
;	O
else	O
if	O
(	O
config	struct
.	O
sort_common	enum
==	O
sort_ascending	int
&&	O
power_of_two	int
>	O
*	O
(	O
unsigned	O
int	O
*	O
)	O
info	pointer
)	O
return	O
TRUE	int
;	O
section	pointer
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
;	O
if	O
(	O
!	O
bfd_define_common_symbol	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
h	pointer
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: could not define common symbol `%pT': %E\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
map_file	pointer
!=	O
NULL	O
)	O
{	O
static	O
bfd_boolean	int
header_printed	int
;	O
int	O
len	long
;	O
char	O
*	O
name	pointer
;	O
char	O
buf	pointer
[	O
50	int
]	O
;	O
if	O
(	O
!	O
header_printed	int
)	O
{	O
minfo	pointer
(	O
_	O
(	O
"\nAllocating common symbols\n"	pointer
)	O
)	O
;	O
minfo	pointer
(	O
_	O
(	O
"Common symbol       size              file\n\n"	pointer
)	O
)	O
;	O
header_printed	int
=	O
TRUE	int
;	O
}	O
name	pointer
=	O
bfd_demangle	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
,	O
DMGL_ANSI	O
|	O
DMGL_PARAMS	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
minfo	pointer
(	O
"%s"	pointer
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
;	O
}	O
else	O
{	O
minfo	pointer
(	O
"%s"	pointer
,	O
name	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
len	long
>=	O
19	int
)	O
{	O
print_nl	function
(	O
)	O
;	O
len	long
=	O
0	int
;	O
}	O
while	O
(	O
len	long
<	O
20	int
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
minfo	pointer
(	O
"0x"	pointer
)	O
;	O
if	O
(	O
size	int
<=	O
0xffffffff	int
)	O
sprintf	function
(	O
buf	pointer
,	O
"%lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
size	int
)	O
;	O
else	O
sprintf_vma	O
(	O
buf	pointer
,	O
size	int
)	O
;	O
minfo	pointer
(	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
len	long
<	O
16	int
)	O
{	O
print_space	function
(	O
)	O
;	O
++	O
len	long
;	O
}	O
minfo	pointer
(	O
"%pB\n"	pointer
,	O
section	pointer
->	O
owner	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
ldlang_place_orphan	function
(	O
asection	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
config	struct
.	O
orphan_handling	enum
==	O
orphan_handling_discard	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
lang_output_section_statement_lookup	function
(	O
DISCARD_SECTION_NAME	pointer
,	O
0	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
os	int
->	O
addr_tree	pointer
==	O
NULL	O
&&	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
||	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
0	int
)	O
)	O
os	int
->	O
addr_tree	pointer
=	O
exp_intop	function
(	O
0	int
)	O
;	O
lang_add_section	function
(	O
&	O
os	int
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
os	int
)	O
;	O
}	O
else	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
const	O
char	O
*	O
name	pointer
=	O
s	pointer
->	O
name	pointer
;	O
int	O
constraint	int
=	O
0	int
;	O
if	O
(	O
config	struct
.	O
orphan_handling	enum
==	O
orphan_handling_error	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: error: unplaced orphan section `%pA' from `%pB'\n"	pointer
)	O
,	O
s	pointer
,	O
s	pointer
->	O
owner	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
unique_orphan_sections	int
||	O
unique_section_p	function
(	O
s	pointer
,	O
NULL	O
)	O
)	O
constraint	int
=	O
SPECIAL	int
;	O
os	int
=	O
ldemul_place_orphan	function
(	O
s	pointer
,	O
name	pointer
,	O
constraint	int
)	O
;	O
if	O
(	O
os	int
==	O
NULL	O
)	O
{	O
os	int
=	O
lang_output_section_statement_lookup	function
(	O
name	pointer
,	O
constraint	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
os	int
->	O
addr_tree	pointer
==	O
NULL	O
&&	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
||	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
0	int
)	O
)	O
os	int
->	O
addr_tree	pointer
=	O
exp_intop	function
(	O
0	int
)	O
;	O
lang_add_section	function
(	O
&	O
os	int
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
os	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
orphan_handling	enum
==	O
orphan_handling_warn	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: orphan section `%pA' from `%pB' being "	pointer
"placed in section `%s'\n"	pointer
)	O
,	O
s	pointer
,	O
s	pointer
->	O
owner	pointer
,	O
os	int
->	O
name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
lang_place_orphans	function
(	O
void	O
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
file	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
file	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
file	pointer
->	O
flags	int
.	O
just_syms	int
)	O
bfd_link_just_syms	O
(	O
file	pointer
->	O
the_bfd	pointer
,	O
s	pointer
,	O
&	O
link_info	struct
)	O
;	O
else	O
if	O
(	O
lang_discard_section_p	function
(	O
s	pointer
)	O
)	O
s	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
s	pointer
->	O
name	pointer
,	O
"COMMON"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
||	O
command_line	struct
.	O
force_common_definition	int
)	O
{	O
if	O
(	O
default_common_section	pointer
==	O
NULL	O
)	O
default_common_section	pointer
=	O
lang_output_section_statement_lookup	function
(	O
".bss"	pointer
,	O
0	int
,	O
TRUE	int
)	O
;	O
lang_add_section	function
(	O
&	O
default_common_section	pointer
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
default_common_section	pointer
)	O
;	O
}	O
}	O
else	O
ldlang_place_orphan	function
(	O
s	pointer
)	O
;	O
}	O
}	O
}	O
}	O
void	O
lang_set_flags	function
(	O
lang_memory_region_type	struct
*	O
ptr	pointer
,	O
const	O
char	O
*	O
flags	int
,	O
int	O
invert	int
)	O
{	O
flagword	int
*	O
ptr_flags	pointer
;	O
ptr_flags	pointer
=	O
invert	int
?	O
&	O
ptr	pointer
->	O
not_flags	int
:	O
&	O
ptr	pointer
->	O
flags	int
;	O
while	O
(	O
*	O
flags	int
)	O
{	O
switch	O
(	O
*	O
flags	int
)	O
{	O
case	O
'!'	O
:	O
invert	int
=	O
!	O
invert	int
;	O
ptr_flags	pointer
=	O
invert	int
?	O
&	O
ptr	pointer
->	O
not_flags	int
:	O
&	O
ptr	pointer
->	O
flags	int
;	O
break	O
;	O
case	O
'A'	O
:	O
case	O
'a'	O
:	O
*	O
ptr_flags	pointer
|=	O
SEC_ALLOC	int
;	O
break	O
;	O
case	O
'R'	O
:	O
case	O
'r'	O
:	O
*	O
ptr_flags	pointer
|=	O
SEC_READONLY	int
;	O
break	O
;	O
case	O
'W'	O
:	O
case	O
'w'	O
:	O
*	O
ptr_flags	pointer
|=	O
SEC_DATA	int
;	O
break	O
;	O
case	O
'X'	O
:	O
case	O
'x'	O
:	O
*	O
ptr_flags	pointer
|=	O
SEC_CODE	int
;	O
break	O
;	O
case	O
'L'	O
:	O
case	O
'l'	O
:	O
case	O
'I'	O
:	O
case	O
'i'	O
:	O
*	O
ptr_flags	pointer
|=	O
SEC_LOAD	int
;	O
break	O
;	O
default	O
:	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid character %c (%d) in flags\n"	pointer
)	O
,	O
*	O
flags	int
,	O
*	O
flags	int
)	O
;	O
break	O
;	O
}	O
flags	int
++	O
;	O
}	O
}	O
void	O
lang_for_each_input_file	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
lang_input_statement_type	struct
*	O
)	O
)	O
{	O
lang_input_statement_type	struct
*	O
f	pointer
;	O
for	O
(	O
f	pointer
=	O
(	O
void	O
*	O
)	O
input_file_chain	struct
.	O
head	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
next_real_file	pointer
)	O
if	O
(	O
f	pointer
->	O
flags	int
.	O
real	int
)	O
func	pointer
(	O
f	pointer
)	O
;	O
}	O
void	O
lang_for_each_file	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
lang_input_statement_type	struct
*	O
)	O
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
f	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
flags	int
.	O
real	int
)	O
func	pointer
(	O
f	pointer
)	O
;	O
}	O
}	O
void	O
ldlang_add_file	function
(	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
lang_statement_append	function
(	O
&	O
file_chain	struct
,	O
entry	pointer
,	O
&	O
entry	pointer
->	O
next	pointer
)	O
;	O
ASSERT	O
(	O
entry	pointer
->	O
the_bfd	pointer
->	O
link	function
.	O
next	pointer
==	O
NULL	O
)	O
;	O
ASSERT	O
(	O
entry	pointer
->	O
the_bfd	pointer
!=	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
*	O
link_info	struct
.	O
input_bfds_tail	pointer
=	O
entry	pointer
->	O
the_bfd	pointer
;	O
link_info	struct
.	O
input_bfds_tail	pointer
=	O
&	O
entry	pointer
->	O
the_bfd	pointer
->	O
link	function
.	O
next	pointer
;	O
bfd_set_usrdata	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
entry	pointer
)	O
;	O
bfd_set_gp_size	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
g_switch_value	int
)	O
;	O
bfd_map_over_sections	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
section_already_linked	function
,	O
entry	pointer
)	O
;	O
}	O
void	O
lang_add_output	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
from_script	int
)	O
{	O
if	O
(	O
!	O
had_output_filename	int
||	O
!	O
from_script	int
)	O
{	O
output_filename	pointer
=	O
name	pointer
;	O
had_output_filename	int
=	O
TRUE	int
;	O
}	O
}	O
lang_output_section_statement_type	struct
*	O
lang_enter_output_section_statement	function
(	O
const	O
char	O
*	O
output_section_statement_name	pointer
,	O
etree_type	union
*	O
address_exp	pointer
,	O
enum	O
section_type	enum
sectype	enum
,	O
etree_type	union
*	O
align	pointer
,	O
etree_type	union
*	O
subalign	pointer
,	O
etree_type	union
*	O
ebase	pointer
,	O
int	O
constraint	int
,	O
int	O
align_with_input	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
lang_output_section_statement_lookup	function
(	O
output_section_statement_name	pointer
,	O
constraint	int
,	O
TRUE	int
)	O
;	O
current_section	pointer
=	O
os	int
;	O
if	O
(	O
os	int
->	O
addr_tree	pointer
==	O
NULL	O
)	O
{	O
os	int
->	O
addr_tree	pointer
=	O
address_exp	pointer
;	O
}	O
os	int
->	O
sectype	enum
=	O
sectype	enum
;	O
if	O
(	O
sectype	enum
!=	O
noload_section	int
)	O
os	int
->	O
flags	int
=	O
SEC_NO_FLAGS	int
;	O
else	O
os	int
->	O
flags	int
=	O
SEC_NEVER_LOAD	int
;	O
os	int
->	O
block_value	int
=	O
1	int
;	O
push_stat_ptr	function
(	O
&	O
os	int
->	O
children	struct
)	O
;	O
os	int
->	O
align_lma_with_input	int
=	O
align_with_input	int
==	O
ALIGN_WITH_INPUT	int
;	O
if	O
(	O
os	int
->	O
align_lma_with_input	int
&&	O
align	pointer
!=	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: error: align with input and explicit align specified\n"	pointer
)	O
,	O
NULL	O
)	O
;	O
os	int
->	O
subsection_alignment	pointer
=	O
subalign	pointer
;	O
os	int
->	O
section_alignment	pointer
=	O
align	pointer
;	O
os	int
->	O
load_base	pointer
=	O
ebase	pointer
;	O
return	O
os	int
;	O
}	O
void	O
lang_final	function
(	O
void	O
)	O
{	O
lang_output_statement_type	struct
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_output_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
name	pointer
=	O
output_filename	pointer
;	O
}	O
void	O
lang_reset_memory_regions	function
(	O
void	O
)	O
{	O
lang_memory_region_type	struct
*	O
p	pointer
=	O
lang_memory_region_list	pointer
;	O
asection	struct
*	O
o	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
for	O
(	O
p	pointer
=	O
lang_memory_region_list	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
p	pointer
->	O
current	long
=	O
p	pointer
->	O
origin	long
;	O
p	pointer
->	O
last_os	pointer
=	O
NULL	O
;	O
}	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
os	int
->	O
processed_vma	int
=	O
FALSE	int
;	O
os	int
->	O
processed_lma	int
=	O
FALSE	int
;	O
}	O
for	O
(	O
o	pointer
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
o	pointer
->	O
rawsize	long
=	O
o	pointer
->	O
size	int
;	O
if	O
(	O
!	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_FIXED_SIZE	int
)	O
)	O
o	pointer
->	O
size	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
gc_section_callback	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
section	pointer
,	O
struct	O
flag_info	struct
*	O
sflag_info	pointer
ATTRIBUTE_UNUSED	O
,	O
lang_input_statement_type	struct
*	O
file	pointer
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
data	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
ptr	pointer
->	O
keep_sections	int
)	O
section	pointer
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
}	O
static	O
void	O
lang_gc_sections_1	function
(	O
lang_statement_union_type	union
*	O
s	pointer
)	O
{	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_wild_statement_enum	int
:	O
walk_wild	function
(	O
&	O
s	pointer
->	O
wild_statement	struct
,	O
gc_section_callback	function
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
lang_gc_sections_1	function
(	O
constructor_list	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
lang_gc_sections_1	function
(	O
s	pointer
->	O
output_section_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
lang_gc_sections_1	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
lang_gc_sections	function
(	O
void	O
)	O
{	O
lang_gc_sections_1	function
(	O
statement_list	struct
.	O
head	pointer
)	O
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
f	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
if	O
(	O
f	pointer
->	O
flags	int
.	O
claimed	int
)	O
continue	O
;	O
for	O
(	O
sec	pointer
=	O
f	pointer
->	O
the_bfd	pointer
->	O
sections	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
==	O
0	int
)	O
sec	pointer
->	O
flags	int
&=	O
~	O
SEC_EXCLUDE	int
;	O
}	O
}	O
if	O
(	O
link_info	struct
.	O
gc_sections	int
)	O
bfd_gc_sections	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
}	O
static	O
void	O
find_relro_section_callback	function
(	O
lang_wild_statement_type	struct
*	O
ptr	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
wildcard_list	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
section	pointer
,	O
struct	O
flag_info	struct
*	O
sflag_info	pointer
ATTRIBUTE_UNUSED	O
,	O
lang_input_statement_type	struct
*	O
file	pointer
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
section	pointer
->	O
output_section	pointer
->	O
owner	pointer
==	O
link_info	struct
.	O
output_bfd	pointer
&&	O
(	O
section	pointer
->	O
output_section	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
!	O
IGNORE_SECTION	O
(	O
section	pointer
)	O
&&	O
section	pointer
->	O
size	int
!=	O
0	int
)	O
{	O
bfd_boolean	int
*	O
has_relro_section	pointer
=	O
(	O
bfd_boolean	int
*	O
)	O
data	pointer
;	O
*	O
has_relro_section	pointer
=	O
TRUE	int
;	O
}	O
}	O
static	O
void	O
lang_find_relro_sections_1	function
(	O
lang_statement_union_type	union
*	O
s	pointer
,	O
seg_align_type	struct
*	O
seg	pointer
,	O
bfd_boolean	int
*	O
has_relro_section	pointer
)	O
{	O
if	O
(	O
*	O
has_relro_section	pointer
)	O
return	O
;	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
header	struct
.	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
==	O
seg	pointer
->	O
relro_end_stat	pointer
)	O
break	O
;	O
switch	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_wild_statement_enum	int
:	O
walk_wild	function
(	O
&	O
s	pointer
->	O
wild_statement	struct
,	O
find_relro_section_callback	function
,	O
has_relro_section	pointer
)	O
;	O
break	O
;	O
case	O
lang_constructors_statement_enum	int
:	O
lang_find_relro_sections_1	function
(	O
constructor_list	struct
.	O
head	pointer
,	O
seg	pointer
,	O
has_relro_section	pointer
)	O
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
lang_find_relro_sections_1	function
(	O
s	pointer
->	O
output_section_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
seg	pointer
,	O
has_relro_section	pointer
)	O
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
lang_find_relro_sections_1	function
(	O
s	pointer
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
,	O
seg	pointer
,	O
has_relro_section	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
lang_find_relro_sections	function
(	O
void	O
)	O
{	O
bfd_boolean	int
has_relro_section	pointer
=	O
FALSE	int
;	O
lang_find_relro_sections_1	function
(	O
expld	struct
.	O
dataseg	struct
.	O
relro_start_stat	pointer
,	O
&	O
expld	struct
.	O
dataseg	struct
,	O
&	O
has_relro_section	pointer
)	O
;	O
if	O
(	O
!	O
has_relro_section	pointer
)	O
link_info	struct
.	O
relro	int
=	O
FALSE	int
;	O
}	O
void	O
lang_relax_sections	function
(	O
bfd_boolean	int
need_layout	int
)	O
{	O
if	O
(	O
RELAXATION_ENABLED	O
)	O
{	O
int	O
i	pointer
=	O
link_info	struct
.	O
relax_pass	int
;	O
link_info	struct
.	O
relax_pass	int
=	O
0	int
;	O
while	O
(	O
i	pointer
--	O
)	O
{	O
bfd_boolean	int
relax_again	int
;	O
link_info	struct
.	O
relax_trip	int
=	O
-	O
1	int
;	O
do	O
{	O
link_info	struct
.	O
relax_trip	int
++	O
;	O
lang_do_assignments	function
(	O
lang_assigning_phase_enum	int
)	O
;	O
lang_reset_memory_regions	function
(	O
)	O
;	O
relax_again	int
=	O
FALSE	int
;	O
lang_size_sections	function
(	O
&	O
relax_again	int
,	O
FALSE	int
)	O
;	O
}	O
while	O
(	O
relax_again	int
)	O
;	O
link_info	struct
.	O
relax_pass	int
++	O
;	O
}	O
need_layout	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
need_layout	int
)	O
{	O
lang_do_assignments	function
(	O
lang_assigning_phase_enum	int
)	O
;	O
lang_reset_memory_regions	function
(	O
)	O
;	O
lang_size_sections	function
(	O
NULL	O
,	O
TRUE	int
)	O
;	O
}	O
}	O
static	O
lang_input_statement_type	struct
*	O
find_replacements_insert_point	function
(	O
bfd_boolean	int
*	O
before	pointer
)	O
{	O
lang_input_statement_type	struct
*	O
claim1	pointer
,	O
*	O
lastobject	pointer
;	O
lastobject	pointer
=	O
(	O
void	O
*	O
)	O
input_file_chain	struct
.	O
head	pointer
;	O
for	O
(	O
claim1	pointer
=	O
(	O
void	O
*	O
)	O
file_chain	struct
.	O
head	pointer
;	O
claim1	pointer
!=	O
NULL	O
;	O
claim1	pointer
=	O
claim1	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
claim1	pointer
->	O
flags	int
.	O
claimed	int
)	O
{	O
*	O
before	pointer
=	O
claim1	pointer
->	O
flags	int
.	O
claim_archive	int
;	O
return	O
claim1	pointer
->	O
flags	int
.	O
claim_archive	int
?	O
lastobject	pointer
:	O
claim1	pointer
;	O
}	O
if	O
(	O
claim1	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
claim1	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
==	O
NULL	O
)	O
lastobject	pointer
=	O
claim1	pointer
;	O
}	O
*	O
before	pointer
=	O
FALSE	int
;	O
return	O
lastobject	pointer
;	O
}	O
static	O
lang_input_statement_type	struct
*	O
*	O
find_rescan_insertion	function
(	O
lang_input_statement_type	struct
*	O
add	struct
)	O
{	O
bfd	struct
*	O
add_bfd	pointer
=	O
add	struct
->	O
the_bfd	pointer
;	O
lang_input_statement_type	struct
*	O
f	pointer
;	O
lang_input_statement_type	struct
*	O
last_loaded	pointer
=	O
NULL	O
;	O
lang_input_statement_type	struct
*	O
before	pointer
=	O
NULL	O
;	O
lang_input_statement_type	struct
*	O
*	O
iter	pointer
=	O
NULL	O
;	O
if	O
(	O
add_bfd	pointer
->	O
my_archive	pointer
!=	O
NULL	O
)	O
add_bfd	pointer
=	O
add_bfd	pointer
->	O
my_archive	pointer
;	O
for	O
(	O
f	pointer
=	O
(	O
void	O
*	O
)	O
input_file_chain	struct
.	O
head	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
next_real_file	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
the_bfd	pointer
==	O
add_bfd	pointer
)	O
{	O
before	pointer
=	O
last_loaded	pointer
;	O
if	O
(	O
f	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
return	O
&	O
f	pointer
->	O
next	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
f	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
f	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
last_loaded	pointer
=	O
f	pointer
;	O
}	O
for	O
(	O
iter	pointer
=	O
before	pointer
?	O
&	O
before	pointer
->	O
next	pointer
:	O
&	O
file_chain	struct
.	O
head	pointer
->	O
input_statement	struct
.	O
next	pointer
;	O
*	O
iter	pointer
!=	O
NULL	O
;	O
iter	pointer
=	O
&	O
(	O
*	O
iter	pointer
)	O
->	O
next	pointer
)	O
if	O
(	O
!	O
(	O
*	O
iter	pointer
)	O
->	O
flags	int
.	O
claim_archive	int
&&	O
(	O
*	O
iter	pointer
)	O
->	O
the_bfd	pointer
->	O
my_archive	pointer
==	O
NULL	O
)	O
break	O
;	O
return	O
iter	pointer
;	O
}	O
static	O
void	O
lang_list_insert_after	function
(	O
lang_statement_list_type	struct
*	O
destlist	pointer
,	O
lang_statement_list_type	struct
*	O
srclist	pointer
,	O
lang_statement_union_type	union
*	O
*	O
field	pointer
)	O
{	O
*	O
(	O
srclist	pointer
->	O
tail	pointer
)	O
=	O
*	O
field	pointer
;	O
*	O
field	pointer
=	O
srclist	pointer
->	O
head	pointer
;	O
if	O
(	O
destlist	pointer
->	O
tail	pointer
==	O
field	pointer
)	O
destlist	pointer
->	O
tail	pointer
=	O
srclist	pointer
->	O
tail	pointer
;	O
}	O
static	O
void	O
lang_list_remove_tail	function
(	O
lang_statement_list_type	struct
*	O
destlist	pointer
,	O
lang_statement_list_type	struct
*	O
origlist	pointer
)	O
{	O
union	O
lang_statement_union	union
*	O
*	O
savetail	pointer
;	O
ASSERT	O
(	O
origlist	pointer
->	O
head	pointer
==	O
destlist	pointer
->	O
head	pointer
)	O
;	O
savetail	pointer
=	O
origlist	pointer
->	O
tail	pointer
;	O
origlist	pointer
->	O
head	pointer
=	O
*	O
(	O
savetail	pointer
)	O
;	O
origlist	pointer
->	O
tail	pointer
=	O
destlist	pointer
->	O
tail	pointer
;	O
destlist	pointer
->	O
tail	pointer
=	O
savetail	pointer
;	O
*	O
savetail	pointer
=	O
NULL	O
;	O
}	O
static	O
lang_statement_union_type	union
*	O
*	O
find_next_input_statement	function
(	O
lang_statement_union_type	union
*	O
*	O
s	pointer
)	O
{	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
next	pointer
)	O
{	O
lang_statement_union_type	union
*	O
*	O
t	pointer
;	O
switch	O
(	O
(	O
*	O
s	pointer
)	O
->	O
header	struct
.	O
type	enum
)	O
{	O
case	O
lang_input_statement_enum	int
:	O
return	O
s	pointer
;	O
case	O
lang_wild_statement_enum	int
:	O
t	pointer
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
wild_statement	struct
.	O
children	struct
.	O
head	pointer
;	O
break	O
;	O
case	O
lang_group_statement_enum	int
:	O
t	pointer
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
group_statement	struct
.	O
children	struct
.	O
head	pointer
;	O
break	O
;	O
case	O
lang_output_section_statement_enum	int
:	O
t	pointer
=	O
&	O
(	O
*	O
s	pointer
)	O
->	O
output_section_statement	struct
.	O
children	struct
.	O
head	pointer
;	O
break	O
;	O
default	O
:	O
continue	O
;	O
}	O
t	pointer
=	O
find_next_input_statement	function
(	O
t	pointer
)	O
;	O
if	O
(	O
*	O
t	pointer
)	O
return	O
t	pointer
;	O
}	O
return	O
s	pointer
;	O
}	O
void	O
lang_add_gc_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
bfd_sym_chain	struct
*	O
sym	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
;	O
sym	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
*	O
sym	pointer
)	O
)	O
;	O
sym	pointer
->	O
next	pointer
=	O
link_info	struct
.	O
gc_sym_list	pointer
;	O
sym	pointer
->	O
name	pointer
=	O
name	pointer
;	O
link_info	struct
.	O
gc_sym_list	pointer
=	O
sym	pointer
;	O
}	O
static	O
void	O
lang_check_relocs	function
(	O
void	O
)	O
{	O
if	O
(	O
link_info	struct
.	O
check_relocs_after_open_input	int
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
for	O
(	O
abfd	pointer
=	O
link_info	struct
.	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
(	O
bfd	struct
*	O
)	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
!	O
bfd_link_check_relocs	function
(	O
abfd	pointer
,	O
&	O
link_info	struct
)	O
)	O
{	O
config	struct
.	O
make_executable	int
=	O
FALSE	int
;	O
}	O
}	O
}	O
static	O
void	O
lang_propagate_lma_regions	function
(	O
void	O
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
if	O
(	O
os	int
->	O
prev	pointer
!=	O
NULL	O
&&	O
os	int
->	O
lma_region	pointer
==	O
NULL	O
&&	O
os	int
->	O
load_base	pointer
==	O
NULL	O
&&	O
os	int
->	O
addr_tree	pointer
==	O
NULL	O
&&	O
os	int
->	O
region	pointer
==	O
os	int
->	O
prev	pointer
->	O
region	pointer
)	O
os	int
->	O
lma_region	pointer
=	O
os	int
->	O
prev	pointer
->	O
lma_region	pointer
;	O
}	O
}	O
void	O
lang_process	function
(	O
void	O
)	O
{	O
if	O
(	O
link_info	struct
.	O
dynamic_list	pointer
)	O
lang_finalize_version_expr_head	function
(	O
&	O
link_info	struct
.	O
dynamic_list	pointer
->	O
head	pointer
)	O
;	O
current_target	pointer
=	O
default_target	pointer
;	O
lang_for_each_statement	function
(	O
ldlang_open_output	function
)	O
;	O
init_opb	function
(	O
NULL	O
)	O
;	O
ldemul_create_output_section_statements	function
(	O
)	O
;	O
lang_place_undefineds	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_section_already_linked_table_init	function
(	O
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can not create hash table: %E\n"	pointer
)	O
)	O
;	O
current_target	pointer
=	O
default_target	pointer
;	O
lang_statement_iteration	int
++	O
;	O
open_input_bfds	function
(	O
statement_list	struct
.	O
head	pointer
,	O
OPEN_BFD_NORMAL	int
)	O
;	O
lang_do_memory_regions	function
(	O
)	O
;	O
if	O
(	O
link_info	struct
.	O
lto_plugin_active	int
)	O
{	O
lang_statement_list_type	struct
added	struct
;	O
lang_statement_list_type	struct
files	struct
,	O
inputfiles	struct
;	O
added	struct
=	O
*	O
stat_ptr	pointer
;	O
files	struct
=	O
file_chain	struct
;	O
inputfiles	struct
=	O
input_file_chain	struct
;	O
if	O
(	O
plugin_call_all_symbols_read	function
(	O
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: plugin reported error after all symbols read\n"	pointer
)	O
,	O
plugin_error_plugin	function
(	O
)	O
)	O
;	O
plugin_undefs	pointer
=	O
link_info	struct
.	O
hash	long
->	O
undefs_tail	pointer
;	O
open_input_bfds	function
(	O
*	O
added	struct
.	O
tail	pointer
,	O
OPEN_BFD_NORMAL	int
)	O
;	O
if	O
(	O
plugin_undefs	pointer
==	O
link_info	struct
.	O
hash	long
->	O
undefs_tail	pointer
)	O
plugin_undefs	pointer
=	O
NULL	O
;	O
lang_list_remove_tail	function
(	O
stat_ptr	pointer
,	O
&	O
added	struct
)	O
;	O
lang_list_remove_tail	function
(	O
&	O
file_chain	struct
,	O
&	O
files	struct
)	O
;	O
lang_list_remove_tail	function
(	O
&	O
input_file_chain	struct
,	O
&	O
inputfiles	struct
)	O
;	O
if	O
(	O
added	struct
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
before	pointer
;	O
lang_statement_union_type	union
*	O
*	O
prev	pointer
;	O
plugin_insert	pointer
=	O
find_replacements_insert_point	function
(	O
&	O
before	pointer
)	O
;	O
ASSERT	O
(	O
plugin_insert	pointer
!=	O
NULL	O
)	O
;	O
prev	pointer
=	O
&	O
plugin_insert	pointer
->	O
header	struct
.	O
next	pointer
;	O
if	O
(	O
before	pointer
)	O
{	O
prev	pointer
=	O
find_next_input_statement	function
(	O
prev	pointer
)	O
;	O
if	O
(	O
*	O
prev	pointer
!=	O
(	O
void	O
*	O
)	O
plugin_insert	pointer
->	O
next_real_file	pointer
)	O
{	O
prev	pointer
=	O
&	O
plugin_insert	pointer
->	O
header	struct
.	O
next	pointer
;	O
}	O
}	O
lang_list_insert_after	function
(	O
stat_ptr	pointer
,	O
&	O
added	struct
,	O
prev	pointer
)	O
;	O
lang_list_insert_after	function
(	O
&	O
input_file_chain	struct
,	O
&	O
inputfiles	struct
,	O
(	O
void	O
*	O
)	O
&	O
plugin_insert	pointer
->	O
next_real_file	pointer
)	O
;	O
if	O
(	O
plugin_insert	pointer
->	O
filename	pointer
)	O
lang_list_insert_after	function
(	O
&	O
file_chain	struct
,	O
&	O
files	struct
,	O
(	O
void	O
*	O
)	O
&	O
plugin_insert	pointer
->	O
next	pointer
)	O
;	O
else	O
lang_list_insert_after	function
(	O
&	O
file_chain	struct
,	O
&	O
files	struct
,	O
&	O
file_chain	struct
.	O
head	pointer
)	O
;	O
files	struct
=	O
file_chain	struct
;	O
lang_statement_iteration	int
++	O
;	O
open_input_bfds	function
(	O
statement_list	struct
.	O
head	pointer
,	O
OPEN_BFD_RESCAN	int
)	O
;	O
lang_list_remove_tail	function
(	O
&	O
file_chain	struct
,	O
&	O
files	struct
)	O
;	O
while	O
(	O
files	struct
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
lang_input_statement_type	struct
*	O
*	O
insert	pointer
;	O
lang_input_statement_type	struct
*	O
*	O
iter	pointer
,	O
*	O
temp	union
;	O
bfd	struct
*	O
my_arch	pointer
;	O
insert	pointer
=	O
find_rescan_insertion	function
(	O
&	O
files	struct
.	O
head	pointer
->	O
input_statement	struct
)	O
;	O
iter	pointer
=	O
&	O
files	struct
.	O
head	pointer
->	O
input_statement	struct
.	O
next	pointer
;	O
my_arch	pointer
=	O
files	struct
.	O
head	pointer
->	O
input_statement	struct
.	O
the_bfd	pointer
->	O
my_archive	pointer
;	O
if	O
(	O
my_arch	pointer
!=	O
NULL	O
)	O
for	O
(	O
;	O
*	O
iter	pointer
!=	O
NULL	O
;	O
iter	pointer
=	O
&	O
(	O
*	O
iter	pointer
)	O
->	O
next	pointer
)	O
if	O
(	O
(	O
*	O
iter	pointer
)	O
->	O
the_bfd	pointer
->	O
my_archive	pointer
!=	O
my_arch	pointer
)	O
break	O
;	O
temp	union
=	O
*	O
insert	pointer
;	O
*	O
insert	pointer
=	O
&	O
files	struct
.	O
head	pointer
->	O
input_statement	struct
;	O
files	struct
.	O
head	pointer
=	O
(	O
lang_statement_union_type	union
*	O
)	O
*	O
iter	pointer
;	O
*	O
iter	pointer
=	O
temp	union
;	O
if	O
(	O
my_arch	pointer
!=	O
NULL	O
)	O
{	O
lang_input_statement_type	struct
*	O
parent	pointer
=	O
bfd_usrdata	function
(	O
my_arch	pointer
)	O
;	O
if	O
(	O
parent	pointer
!=	O
NULL	O
)	O
parent	pointer
->	O
next	pointer
=	O
(	O
lang_input_statement_type	struct
*	O
)	O
(	O
(	O
char	O
*	O
)	O
iter	pointer
-	O
offsetof	O
(	O
lang_input_statement_type	struct
,	O
next	pointer
)	O
)	O
;	O
}	O
}	O
}	O
}	O
ASSERT	O
(	O
link_info	struct
.	O
gc_sym_list	pointer
==	O
NULL	O
)	O
;	O
link_info	struct
.	O
gc_sym_list	pointer
=	O
&	O
entry_symbol	struct
;	O
if	O
(	O
entry_symbol	struct
.	O
name	pointer
==	O
NULL	O
)	O
{	O
link_info	struct
.	O
gc_sym_list	pointer
=	O
ldlang_undef_chain_list_head	O
;	O
lang_add_gc_name	function
(	O
entry_symbol_default	pointer
)	O
;	O
}	O
lang_add_gc_name	function
(	O
link_info	struct
.	O
init_function	pointer
)	O
;	O
lang_add_gc_name	function
(	O
link_info	struct
.	O
fini_function	pointer
)	O
;	O
ldemul_after_open	function
(	O
)	O
;	O
if	O
(	O
config	struct
.	O
map_file	pointer
!=	O
NULL	O
)	O
lang_print_asneeded	function
(	O
)	O
;	O
ldlang_open_ctf	function
(	O
)	O
;	O
bfd_section_already_linked_table_free	function
(	O
)	O
;	O
lang_check	function
(	O
)	O
;	O
if	O
(	O
command_line	struct
.	O
version_exports_section	pointer
)	O
lang_do_version_exports_section	function
(	O
)	O
;	O
ldctor_build_sets	function
(	O
)	O
;	O
if	O
(	O
config	struct
.	O
build_constructors	int
)	O
lang_init_start_stop	function
(	O
)	O
;	O
lang_do_assignments	function
(	O
lang_mark_phase_enum	int
)	O
;	O
expld	struct
.	O
phase	enum
=	O
lang_first_phase_enum	int
;	O
lang_common	function
(	O
)	O
;	O
lang_gc_sections	function
(	O
)	O
;	O
lang_check_relocs	function
(	O
)	O
;	O
ldemul_after_check_relocs	function
(	O
)	O
;	O
update_wild_statements	function
(	O
statement_list	struct
.	O
head	pointer
)	O
;	O
lang_statement_iteration	int
++	O
;	O
map_input_to_output_sections	function
(	O
statement_list	struct
.	O
head	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
process_insert_statements	function
(	O
&	O
lang_os_list	struct
.	O
head	pointer
->	O
header	struct
.	O
next	pointer
)	O
;	O
lang_place_orphans	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
asection	struct
*	O
found	pointer
;	O
bfd_merge_sections	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
found	pointer
=	O
bfd_get_section_by_name	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
".text"	pointer
)	O
;	O
if	O
(	O
found	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
config	struct
.	O
text_read_only	int
)	O
found	pointer
->	O
flags	int
|=	O
SEC_READONLY	int
;	O
else	O
found	pointer
->	O
flags	int
&=	O
~	O
SEC_READONLY	int
;	O
}	O
}	O
lang_merge_ctf	function
(	O
)	O
;	O
lang_write_ctf	function
(	O
0	int
)	O
;	O
lang_propagate_lma_regions	function
(	O
)	O
;	O
if	O
(	O
config	struct
.	O
build_constructors	int
)	O
lang_undef_start_stop	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
lang_init_startof_sizeof	function
(	O
)	O
;	O
ldemul_before_allocation	function
(	O
)	O
;	O
lang_record_phdrs	function
(	O
)	O
;	O
if	O
(	O
link_info	struct
.	O
relro	int
&&	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
lang_find_relro_sections	function
(	O
)	O
;	O
lang_size_sections	function
(	O
NULL	O
,	O
!	O
RELAXATION_ENABLED	O
)	O
;	O
ldemul_after_allocation	function
(	O
)	O
;	O
lang_finalize_start_stop	function
(	O
)	O
;	O
lang_do_assignments	function
(	O
lang_final_phase_enum	int
)	O
;	O
ldemul_finish	function
(	O
)	O
;	O
ldexp_finalize_syms	function
(	O
)	O
;	O
if	O
(	O
command_line	struct
.	O
check_section_addresses	char
)	O
lang_check_section_addresses	function
(	O
)	O
;	O
ldlang_check_require_defined_symbols	function
(	O
)	O
;	O
lang_end	function
(	O
)	O
;	O
}	O
void	O
lang_add_wild	function
(	O
struct	O
wildcard_spec	struct
*	O
filespec	pointer
,	O
struct	O
wildcard_list	struct
*	O
section_list	pointer
,	O
bfd_boolean	int
keep_sections	int
)	O
{	O
struct	O
wildcard_list	struct
*	O
curr	pointer
,	O
*	O
next	pointer
;	O
lang_wild_statement_type	struct
*	O
new_stmt	pointer
;	O
for	O
(	O
curr	pointer
=	O
section_list	pointer
,	O
section_list	pointer
=	O
NULL	O
;	O
curr	pointer
!=	O
NULL	O
;	O
section_list	pointer
=	O
curr	pointer
,	O
curr	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
curr	pointer
->	O
next	pointer
=	O
section_list	pointer
;	O
}	O
if	O
(	O
filespec	pointer
!=	O
NULL	O
&&	O
filespec	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
filespec	pointer
->	O
name	pointer
,	O
"*"	pointer
)	O
==	O
0	int
)	O
filespec	pointer
->	O
name	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
!	O
wildcardp	O
(	O
filespec	pointer
->	O
name	pointer
)	O
)	O
lang_has_input_file	int
=	O
TRUE	int
;	O
}	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_wild_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
new_stmt	pointer
->	O
filenames_sorted	int
=	O
FALSE	int
;	O
new_stmt	pointer
->	O
section_flag_list	pointer
=	O
NULL	O
;	O
new_stmt	pointer
->	O
exclude_name_list	pointer
=	O
NULL	O
;	O
if	O
(	O
filespec	pointer
!=	O
NULL	O
)	O
{	O
new_stmt	pointer
->	O
filename	pointer
=	O
filespec	pointer
->	O
name	pointer
;	O
new_stmt	pointer
->	O
filenames_sorted	int
=	O
filespec	pointer
->	O
sorted	enum
==	O
by_name	int
;	O
new_stmt	pointer
->	O
section_flag_list	pointer
=	O
filespec	pointer
->	O
section_flag_list	pointer
;	O
new_stmt	pointer
->	O
exclude_name_list	pointer
=	O
filespec	pointer
->	O
exclude_name_list	pointer
;	O
}	O
new_stmt	pointer
->	O
section_list	pointer
=	O
section_list	pointer
;	O
new_stmt	pointer
->	O
keep_sections	int
=	O
keep_sections	int
;	O
lang_list_init	function
(	O
&	O
new_stmt	pointer
->	O
children	struct
)	O
;	O
analyze_walk_wild_section_handler	function
(	O
new_stmt	pointer
)	O
;	O
}	O
void	O
lang_section_start	function
(	O
const	O
char	O
*	O
name	pointer
,	O
etree_type	union
*	O
address	long
,	O
const	O
segment_type	struct
*	O
segment	pointer
)	O
{	O
lang_address_statement_type	struct
*	O
ad	pointer
;	O
ad	pointer
=	O
new_stat	O
(	O
lang_address_statement	O
,	O
stat_ptr	pointer
)	O
;	O
ad	pointer
->	O
section_name	pointer
=	O
name	pointer
;	O
ad	pointer
->	O
address	long
=	O
address	long
;	O
ad	pointer
->	O
segment	pointer
=	O
segment	pointer
;	O
}	O
void	O
lang_add_entry	function
(	O
const	O
char	O
*	O
name	pointer
,	O
bfd_boolean	int
cmdline	int
)	O
{	O
if	O
(	O
entry_symbol	struct
.	O
name	pointer
==	O
NULL	O
||	O
cmdline	int
||	O
!	O
entry_from_cmdline	int
)	O
{	O
entry_symbol	struct
.	O
name	pointer
=	O
name	pointer
;	O
entry_from_cmdline	int
=	O
cmdline	int
;	O
}	O
}	O
void	O
lang_default_entry	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
entry_symbol_default	pointer
=	O
name	pointer
;	O
}	O
void	O
lang_add_target	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
lang_target_statement_type	struct
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_target_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
target	pointer
=	O
name	pointer
;	O
}	O
void	O
lang_add_map	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
while	O
(	O
*	O
name	pointer
)	O
{	O
switch	O
(	O
*	O
name	pointer
)	O
{	O
case	O
'F'	O
:	O
map_option_f	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
name	pointer
++	O
;	O
}	O
}	O
void	O
lang_add_fill	function
(	O
fill_type	struct
*	O
fill	pointer
)	O
{	O
lang_fill_statement_type	struct
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_fill_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
fill	pointer
=	O
fill	pointer
;	O
}	O
void	O
lang_add_data	function
(	O
int	O
type	enum
,	O
union	O
etree_union	union
*	O
exp	pointer
)	O
{	O
lang_data_statement_type	struct
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_data_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
exp	pointer
=	O
exp	pointer
;	O
new_stmt	pointer
->	O
type	enum
=	O
type	enum
;	O
}	O
void	O
lang_add_reloc	function
(	O
bfd_reloc_code_real_type	enum
reloc	enum
,	O
reloc_howto_type	struct
*	O
howto	pointer
,	O
asection	struct
*	O
section	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
union	O
etree_union	union
*	O
addend	long
)	O
{	O
lang_reloc_statement_type	struct
*	O
p	pointer
=	O
new_stat	O
(	O
lang_reloc_statement	O
,	O
stat_ptr	pointer
)	O
;	O
p	pointer
->	O
reloc	enum
=	O
reloc	enum
;	O
p	pointer
->	O
howto	pointer
=	O
howto	pointer
;	O
p	pointer
->	O
section	pointer
=	O
section	pointer
;	O
p	pointer
->	O
name	pointer
=	O
name	pointer
;	O
p	pointer
->	O
addend_exp	pointer
=	O
addend	long
;	O
p	pointer
->	O
addend_value	long
=	O
0	int
;	O
p	pointer
->	O
output_section	pointer
=	O
NULL	O
;	O
p	pointer
->	O
output_offset	long
=	O
0	int
;	O
}	O
lang_assignment_statement_type	struct
*	O
lang_add_assignment	function
(	O
etree_type	union
*	O
exp	pointer
)	O
{	O
lang_assignment_statement_type	struct
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_assignment_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
exp	pointer
=	O
exp	pointer
;	O
return	O
new_stmt	pointer
;	O
}	O
void	O
lang_add_attribute	function
(	O
enum	O
statement_enum	enum
attribute	enum
)	O
{	O
new_statement	function
(	O
attribute	enum
,	O
sizeof	O
(	O
lang_statement_header_type	struct
)	O
,	O
stat_ptr	pointer
)	O
;	O
}	O
void	O
lang_startup	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
first_file	pointer
->	O
filename	pointer
!=	O
NULL	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: multiple STARTUP files\n"	pointer
)	O
)	O
;	O
}	O
first_file	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
first_file	pointer
->	O
local_sym_name	pointer
=	O
name	pointer
;	O
first_file	pointer
->	O
flags	int
.	O
real	int
=	O
TRUE	int
;	O
}	O
void	O
lang_float	function
(	O
bfd_boolean	int
maybe	int
)	O
{	O
lang_float_flag	int
=	O
maybe	int
;	O
}	O
static	O
void	O
lang_get_regions	function
(	O
lang_memory_region_type	struct
*	O
*	O
region	pointer
,	O
lang_memory_region_type	struct
*	O
*	O
lma_region	pointer
,	O
const	O
char	O
*	O
memspec	pointer
,	O
const	O
char	O
*	O
lma_memspec	pointer
,	O
bfd_boolean	int
have_lma	int
,	O
bfd_boolean	int
have_vma	int
)	O
{	O
*	O
lma_region	pointer
=	O
lang_memory_region_lookup	function
(	O
lma_memspec	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
lma_memspec	pointer
!=	O
NULL	O
&&	O
!	O
have_vma	int
&&	O
strcmp	function
(	O
memspec	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
)	O
==	O
0	int
)	O
*	O
region	pointer
=	O
*	O
lma_region	pointer
;	O
else	O
*	O
region	pointer
=	O
lang_memory_region_lookup	function
(	O
memspec	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
have_lma	int
&&	O
lma_memspec	pointer
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P:%pS: section has both a load address and a load region\n"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
void	O
lang_leave_output_section_statement	function
(	O
fill_type	struct
*	O
fill	pointer
,	O
const	O
char	O
*	O
memspec	pointer
,	O
lang_output_section_phdr_list	struct
*	O
phdrs	pointer
,	O
const	O
char	O
*	O
lma_memspec	pointer
)	O
{	O
lang_get_regions	function
(	O
&	O
current_section	pointer
->	O
region	pointer
,	O
&	O
current_section	pointer
->	O
lma_region	pointer
,	O
memspec	pointer
,	O
lma_memspec	pointer
,	O
current_section	pointer
->	O
load_base	pointer
!=	O
NULL	O
,	O
current_section	pointer
->	O
addr_tree	pointer
!=	O
NULL	O
)	O
;	O
current_section	pointer
->	O
fill	pointer
=	O
fill	pointer
;	O
current_section	pointer
->	O
phdrs	pointer
=	O
phdrs	pointer
;	O
pop_stat_ptr	function
(	O
)	O
;	O
}	O
void	O
lang_add_output_format	function
(	O
const	O
char	O
*	O
format	enum
,	O
const	O
char	O
*	O
big	pointer
,	O
const	O
char	O
*	O
little	pointer
,	O
int	O
from_script	int
)	O
{	O
if	O
(	O
output_target	pointer
==	O
NULL	O
||	O
!	O
from_script	int
)	O
{	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_BIG	int
&&	O
big	pointer
!=	O
NULL	O
)	O
format	enum
=	O
big	pointer
;	O
else	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_LITTLE	int
&&	O
little	pointer
!=	O
NULL	O
)	O
format	enum
=	O
little	pointer
;	O
output_target	pointer
=	O
format	enum
;	O
}	O
}	O
void	O
lang_add_insert	function
(	O
const	O
char	O
*	O
where	long
,	O
int	O
is_before	int
)	O
{	O
lang_insert_statement_type	struct
*	O
new_stmt	pointer
;	O
new_stmt	pointer
=	O
new_stat	O
(	O
lang_insert_statement	O
,	O
stat_ptr	pointer
)	O
;	O
new_stmt	pointer
->	O
where	long
=	O
where	long
;	O
new_stmt	pointer
->	O
is_before	int
=	O
is_before	int
;	O
saved_script_handle	pointer
=	O
previous_script_handle	pointer
;	O
}	O
void	O
lang_enter_group	function
(	O
void	O
)	O
{	O
lang_group_statement_type	struct
*	O
g	pointer
;	O
g	pointer
=	O
new_stat	O
(	O
lang_group_statement	O
,	O
stat_ptr	pointer
)	O
;	O
lang_list_init	function
(	O
&	O
g	pointer
->	O
children	struct
)	O
;	O
push_stat_ptr	function
(	O
&	O
g	pointer
->	O
children	struct
)	O
;	O
}	O
void	O
lang_leave_group	function
(	O
void	O
)	O
{	O
pop_stat_ptr	function
(	O
)	O
;	O
}	O
void	O
lang_new_phdr	function
(	O
const	O
char	O
*	O
name	pointer
,	O
etree_type	union
*	O
type	enum
,	O
bfd_boolean	int
filehdr	int
,	O
bfd_boolean	int
phdrs	pointer
,	O
etree_type	union
*	O
at	pointer
,	O
etree_type	union
*	O
flags	int
)	O
{	O
struct	O
lang_phdr	struct
*	O
n	long
,	O
*	O
*	O
pp	pointer
;	O
bfd_boolean	int
hdrs	int
;	O
n	long
=	O
stat_alloc	function
(	O
sizeof	O
(	O
struct	O
lang_phdr	struct
)	O
)	O
;	O
n	long
->	O
next	pointer
=	O
NULL	O
;	O
n	long
->	O
name	pointer
=	O
name	pointer
;	O
n	long
->	O
type	enum
=	O
exp_get_vma	function
(	O
type	enum
,	O
0	int
,	O
"program header type"	pointer
)	O
;	O
n	long
->	O
filehdr	int
=	O
filehdr	int
;	O
n	long
->	O
phdrs	pointer
=	O
phdrs	pointer
;	O
n	long
->	O
at	pointer
=	O
at	pointer
;	O
n	long
->	O
flags	int
=	O
flags	int
;	O
hdrs	int
=	O
n	long
->	O
type	enum
==	O
1	int
&&	O
(	O
phdrs	pointer
||	O
filehdr	int
)	O
;	O
for	O
(	O
pp	pointer
=	O
&	O
lang_phdr_list	pointer
;	O
*	O
pp	pointer
!=	O
NULL	O
;	O
pp	pointer
=	O
&	O
(	O
*	O
pp	pointer
)	O
->	O
next	pointer
)	O
if	O
(	O
hdrs	int
&&	O
(	O
*	O
pp	pointer
)	O
->	O
type	enum
==	O
1	int
&&	O
!	O
(	O
(	O
*	O
pp	pointer
)	O
->	O
filehdr	int
||	O
(	O
*	O
pp	pointer
)	O
->	O
phdrs	pointer
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P:%pS: PHDRS and FILEHDR are not supported"	pointer
" when prior PT_LOAD headers lack them\n"	pointer
)	O
,	O
NULL	O
)	O
;	O
hdrs	int
=	O
FALSE	int
;	O
}	O
*	O
pp	pointer
=	O
n	long
;	O
}	O
static	O
void	O
lang_record_phdrs	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
alc	int
;	O
asection	struct
*	O
*	O
secs	pointer
;	O
lang_output_section_phdr_list	struct
*	O
last	pointer
;	O
struct	O
lang_phdr	struct
*	O
l	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
alc	int
=	O
10	int
;	O
secs	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
xmalloc	function
(	O
alc	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
)	O
;	O
last	pointer
=	O
NULL	O
;	O
for	O
(	O
l	pointer
=	O
lang_phdr_list	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
int	O
c	struct
;	O
flagword	int
flags	int
;	O
bfd_vma	long
at	pointer
;	O
c	struct
=	O
0	int
;	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
lang_output_section_phdr_list	struct
*	O
pl	pointer
;	O
if	O
(	O
os	int
->	O
constraint	int
<	O
0	int
)	O
continue	O
;	O
pl	pointer
=	O
os	int
->	O
phdrs	pointer
;	O
if	O
(	O
pl	pointer
!=	O
NULL	O
)	O
last	pointer
=	O
pl	pointer
;	O
else	O
{	O
if	O
(	O
os	int
->	O
sectype	enum
==	O
noload_section	int
||	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
||	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
l	pointer
->	O
type	enum
==	O
3	int
)	O
continue	O
;	O
if	O
(	O
last	pointer
==	O
NULL	O
)	O
{	O
lang_output_section_statement_type	struct
*	O
tmp_os	pointer
;	O
for	O
(	O
tmp_os	pointer
=	O
os	int
;	O
tmp_os	pointer
;	O
tmp_os	pointer
=	O
tmp_os	pointer
->	O
next	pointer
)	O
if	O
(	O
tmp_os	pointer
->	O
phdrs	pointer
)	O
{	O
last	pointer
=	O
tmp_os	pointer
->	O
phdrs	pointer
;	O
break	O
;	O
}	O
if	O
(	O
last	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: no sections assigned to phdrs\n"	pointer
)	O
)	O
;	O
}	O
pl	pointer
=	O
last	pointer
;	O
}	O
if	O
(	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
continue	O
;	O
for	O
(	O
;	O
pl	pointer
!=	O
NULL	O
;	O
pl	pointer
=	O
pl	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
pl	pointer
->	O
name	pointer
,	O
l	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
c	struct
>=	O
alc	int
)	O
{	O
alc	int
*=	O
2	int
;	O
secs	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
xrealloc	function
(	O
secs	pointer
,	O
alc	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
)	O
;	O
}	O
secs	pointer
[	O
c	struct
]	O
=	O
os	int
->	O
bfd_section	struct
;	O
++	O
c	struct
;	O
pl	pointer
->	O
used	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
if	O
(	O
l	pointer
->	O
flags	int
==	O
NULL	O
)	O
flags	int
=	O
0	int
;	O
else	O
flags	int
=	O
exp_get_vma	function
(	O
l	pointer
->	O
flags	int
,	O
0	int
,	O
"phdr flags"	pointer
)	O
;	O
if	O
(	O
l	pointer
->	O
at	pointer
==	O
NULL	O
)	O
at	pointer
=	O
0	int
;	O
else	O
at	pointer
=	O
exp_get_vma	function
(	O
l	pointer
->	O
at	pointer
,	O
0	int
,	O
"phdr load address"	pointer
)	O
;	O
if	O
(	O
!	O
bfd_record_phdr	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
l	pointer
->	O
type	enum
,	O
l	pointer
->	O
flags	int
!=	O
NULL	O
,	O
flags	int
,	O
l	pointer
->	O
at	pointer
!=	O
NULL	O
,	O
at	pointer
,	O
l	pointer
->	O
filehdr	int
,	O
l	pointer
->	O
phdrs	pointer
,	O
c	struct
,	O
secs	pointer
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bfd_record_phdr failed: %E\n"	pointer
)	O
)	O
;	O
}	O
free	function
(	O
secs	pointer
)	O
;	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
{	O
lang_output_section_phdr_list	struct
*	O
pl	pointer
;	O
if	O
(	O
os	int
->	O
constraint	int
<	O
0	int
||	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
continue	O
;	O
for	O
(	O
pl	pointer
=	O
os	int
->	O
phdrs	pointer
;	O
pl	pointer
!=	O
NULL	O
;	O
pl	pointer
=	O
pl	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
pl	pointer
->	O
used	int
&&	O
strcmp	function
(	O
pl	pointer
->	O
name	pointer
,	O
"NONE"	pointer
)	O
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: section `%s' assigned to non-existent phdr `%s'\n"	pointer
)	O
,	O
os	int
->	O
name	pointer
,	O
pl	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
void	O
lang_add_nocrossref	function
(	O
lang_nocrossref_type	struct
*	O
l	pointer
)	O
{	O
struct	O
lang_nocrossrefs	struct
*	O
n	long
;	O
n	long
=	O
(	O
struct	O
lang_nocrossrefs	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
n	long
)	O
;	O
n	long
->	O
next	pointer
=	O
nocrossref_list	pointer
;	O
n	long
->	O
list	pointer
=	O
l	pointer
;	O
n	long
->	O
onlyfirst	int
=	O
FALSE	int
;	O
nocrossref_list	pointer
=	O
n	long
;	O
link_info	struct
.	O
notice_all	int
=	O
TRUE	int
;	O
}	O
void	O
lang_add_nocrossref_to	function
(	O
lang_nocrossref_type	struct
*	O
l	pointer
)	O
{	O
lang_add_nocrossref	function
(	O
l	pointer
)	O
;	O
nocrossref_list	pointer
->	O
onlyfirst	int
=	O
TRUE	int
;	O
}	O
static	O
etree_type	union
*	O
overlay_vma	pointer
;	O
static	O
etree_type	union
*	O
overlay_subalign	pointer
;	O
static	O
etree_type	union
*	O
overlay_max	pointer
;	O
struct	O
overlay_list	struct
{	O
struct	O
overlay_list	struct
*	O
next	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
}	O
;	O
static	O
struct	O
overlay_list	struct
*	O
overlay_list	struct
;	O
void	O
lang_enter_overlay	function
(	O
etree_type	union
*	O
vma_expr	pointer
,	O
etree_type	union
*	O
subalign	pointer
)	O
{	O
ASSERT	O
(	O
overlay_vma	pointer
==	O
NULL	O
&&	O
overlay_subalign	pointer
==	O
NULL	O
&&	O
overlay_max	pointer
==	O
NULL	O
)	O
;	O
overlay_vma	pointer
=	O
vma_expr	pointer
;	O
overlay_subalign	pointer
=	O
subalign	pointer
;	O
}	O
void	O
lang_enter_overlay_section	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
overlay_list	struct
*	O
n	long
;	O
etree_type	union
*	O
size	int
;	O
lang_enter_output_section_statement	function
(	O
name	pointer
,	O
overlay_vma	pointer
,	O
overlay_section	int
,	O
0	int
,	O
overlay_subalign	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
overlay_list	struct
==	O
NULL	O
)	O
overlay_vma	pointer
=	O
exp_nameop	function
(	O
ADDR	int
,	O
name	pointer
)	O
;	O
n	long
=	O
(	O
struct	O
overlay_list	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
n	long
)	O
;	O
n	long
->	O
os	int
=	O
current_section	pointer
;	O
n	long
->	O
next	pointer
=	O
overlay_list	struct
;	O
overlay_list	struct
=	O
n	long
;	O
size	int
=	O
exp_nameop	function
(	O
SIZEOF	int
,	O
name	pointer
)	O
;	O
if	O
(	O
overlay_max	pointer
==	O
NULL	O
)	O
overlay_max	pointer
=	O
size	int
;	O
else	O
overlay_max	pointer
=	O
exp_binop	function
(	O
MAX_K	int
,	O
overlay_max	pointer
,	O
size	int
)	O
;	O
}	O
void	O
lang_leave_overlay_section	function
(	O
fill_type	struct
*	O
fill	pointer
,	O
lang_output_section_phdr_list	struct
*	O
phdrs	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
*	O
clean	pointer
,	O
*	O
s2	pointer
;	O
const	O
char	O
*	O
s1	pointer
;	O
char	O
*	O
buf	pointer
;	O
name	pointer
=	O
current_section	pointer
->	O
name	pointer
;	O
lang_leave_output_section_statement	function
(	O
fill	pointer
,	O
DEFAULT_MEMORY_REGION	pointer
,	O
phdrs	pointer
,	O
0	int
)	O
;	O
clean	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
s2	pointer
=	O
clean	pointer
;	O
for	O
(	O
s1	pointer
=	O
name	pointer
;	O
*	O
s1	pointer
!=	O
'\0'	O
;	O
s1	pointer
++	O
)	O
if	O
(	O
ISALNUM	O
(	O
*	O
s1	pointer
)	O
||	O
*	O
s1	pointer
==	O
'_'	O
)	O
*	O
s2	pointer
++	O
=	O
*	O
s1	pointer
;	O
*	O
s2	pointer
=	O
'\0'	O
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
clean	pointer
)	O
+	O
sizeof	O
"__load_start_"	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"__load_start_%s"	pointer
,	O
clean	pointer
)	O
;	O
lang_add_assignment	function
(	O
exp_provide	function
(	O
buf	pointer
,	O
exp_nameop	function
(	O
LOADADDR	int
,	O
name	pointer
)	O
,	O
FALSE	int
)	O
)	O
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
clean	pointer
)	O
+	O
sizeof	O
"__load_stop_"	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"__load_stop_%s"	pointer
,	O
clean	pointer
)	O
;	O
lang_add_assignment	function
(	O
exp_provide	function
(	O
buf	pointer
,	O
exp_binop	function
(	O
'+'	O
,	O
exp_nameop	function
(	O
LOADADDR	int
,	O
name	pointer
)	O
,	O
exp_nameop	function
(	O
SIZEOF	int
,	O
name	pointer
)	O
)	O
,	O
FALSE	int
)	O
)	O
;	O
free	function
(	O
clean	pointer
)	O
;	O
}	O
void	O
lang_leave_overlay	function
(	O
etree_type	union
*	O
lma_expr	pointer
,	O
int	O
nocrossrefs	int
,	O
fill_type	struct
*	O
fill	pointer
,	O
const	O
char	O
*	O
memspec	pointer
,	O
lang_output_section_phdr_list	struct
*	O
phdrs	pointer
,	O
const	O
char	O
*	O
lma_memspec	pointer
)	O
{	O
lang_memory_region_type	struct
*	O
region	pointer
;	O
lang_memory_region_type	struct
*	O
lma_region	pointer
;	O
struct	O
overlay_list	struct
*	O
l	pointer
;	O
lang_nocrossref_type	struct
*	O
nocrossref	pointer
;	O
lang_get_regions	function
(	O
&	O
region	pointer
,	O
&	O
lma_region	pointer
,	O
memspec	pointer
,	O
lma_memspec	pointer
,	O
lma_expr	pointer
!=	O
NULL	O
,	O
FALSE	int
)	O
;	O
nocrossref	pointer
=	O
NULL	O
;	O
if	O
(	O
overlay_list	struct
!=	O
NULL	O
)	O
{	O
overlay_list	struct
->	O
os	int
->	O
update_dot	int
=	O
1	int
;	O
overlay_list	struct
->	O
os	int
->	O
update_dot_tree	pointer
=	O
exp_assign	function
(	O
"."	pointer
,	O
exp_binop	function
(	O
'+'	O
,	O
overlay_vma	pointer
,	O
overlay_max	pointer
)	O
,	O
FALSE	int
)	O
;	O
}	O
l	pointer
=	O
overlay_list	struct
;	O
while	O
(	O
l	pointer
!=	O
NULL	O
)	O
{	O
struct	O
overlay_list	struct
*	O
next	pointer
;	O
if	O
(	O
fill	pointer
!=	O
NULL	O
&&	O
l	pointer
->	O
os	int
->	O
fill	pointer
==	O
NULL	O
)	O
l	pointer
->	O
os	int
->	O
fill	pointer
=	O
fill	pointer
;	O
l	pointer
->	O
os	int
->	O
region	pointer
=	O
region	pointer
;	O
l	pointer
->	O
os	int
->	O
lma_region	pointer
=	O
lma_region	pointer
;	O
if	O
(	O
l	pointer
->	O
next	pointer
==	O
0	int
)	O
{	O
l	pointer
->	O
os	int
->	O
load_base	pointer
=	O
lma_expr	pointer
;	O
l	pointer
->	O
os	int
->	O
sectype	enum
=	O
first_overlay_section	int
;	O
}	O
if	O
(	O
phdrs	pointer
!=	O
NULL	O
&&	O
l	pointer
->	O
os	int
->	O
phdrs	pointer
==	O
NULL	O
)	O
l	pointer
->	O
os	int
->	O
phdrs	pointer
=	O
phdrs	pointer
;	O
if	O
(	O
nocrossrefs	int
)	O
{	O
lang_nocrossref_type	struct
*	O
nc	pointer
;	O
nc	pointer
=	O
(	O
lang_nocrossref_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
nc	pointer
)	O
;	O
nc	pointer
->	O
name	pointer
=	O
l	pointer
->	O
os	int
->	O
name	pointer
;	O
nc	pointer
->	O
next	pointer
=	O
nocrossref	pointer
;	O
nocrossref	pointer
=	O
nc	pointer
;	O
}	O
next	pointer
=	O
l	pointer
->	O
next	pointer
;	O
free	function
(	O
l	pointer
)	O
;	O
l	pointer
=	O
next	pointer
;	O
}	O
if	O
(	O
nocrossref	pointer
!=	O
NULL	O
)	O
lang_add_nocrossref	function
(	O
nocrossref	pointer
)	O
;	O
overlay_vma	pointer
=	O
NULL	O
;	O
overlay_list	struct
=	O
NULL	O
;	O
overlay_max	pointer
=	O
NULL	O
;	O
overlay_subalign	pointer
=	O
NULL	O
;	O
}	O
static	O
struct	O
bfd_elf_version_expr	struct
*	O
lang_vers_match	function
(	O
struct	O
bfd_elf_version_expr_head	struct
*	O
head	pointer
,	O
struct	O
bfd_elf_version_expr	struct
*	O
prev	pointer
,	O
const	O
char	O
*	O
sym	pointer
)	O
{	O
const	O
char	O
*	O
c_sym	pointer
;	O
const	O
char	O
*	O
cxx_sym	pointer
=	O
sym	pointer
;	O
const	O
char	O
*	O
java_sym	pointer
=	O
sym	pointer
;	O
struct	O
bfd_elf_version_expr	struct
*	O
expr	pointer
=	O
NULL	O
;	O
enum	O
demangling_styles	enum
curr_style	enum
;	O
curr_style	enum
=	O
CURRENT_DEMANGLING_STYLE	O
;	O
cplus_demangle_set_style	function
(	O
no_demangling	int
)	O
;	O
c_sym	pointer
=	O
bfd_demangle	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
sym	pointer
,	O
DMGL_NO_OPTS	int
)	O
;	O
if	O
(	O
!	O
c_sym	pointer
)	O
c_sym	pointer
=	O
sym	pointer
;	O
cplus_demangle_set_style	function
(	O
curr_style	enum
)	O
;	O
if	O
(	O
head	pointer
->	O
mask	int
&	O
BFD_ELF_VERSION_CXX_TYPE	int
)	O
{	O
cxx_sym	pointer
=	O
bfd_demangle	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
sym	pointer
,	O
DMGL_PARAMS	O
|	O
DMGL_ANSI	O
)	O
;	O
if	O
(	O
!	O
cxx_sym	pointer
)	O
cxx_sym	pointer
=	O
sym	pointer
;	O
}	O
if	O
(	O
head	pointer
->	O
mask	int
&	O
BFD_ELF_VERSION_JAVA_TYPE	int
)	O
{	O
java_sym	pointer
=	O
bfd_demangle	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
sym	pointer
,	O
DMGL_JAVA	O
)	O
;	O
if	O
(	O
!	O
java_sym	pointer
)	O
java_sym	pointer
=	O
sym	pointer
;	O
}	O
if	O
(	O
head	pointer
->	O
htab	struct
&&	O
(	O
prev	pointer
==	O
NULL	O
||	O
prev	pointer
->	O
literal	int
)	O
)	O
{	O
struct	O
bfd_elf_version_expr	struct
e	struct
;	O
switch	O
(	O
prev	pointer
?	O
prev	pointer
->	O
mask	int
:	O
0	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
head	pointer
->	O
mask	int
&	O
BFD_ELF_VERSION_C_TYPE	int
)	O
{	O
e	struct
.	O
pattern	pointer
=	O
c_sym	pointer
;	O
expr	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
htab_find	function
(	O
(	O
htab_t	pointer
)	O
head	pointer
->	O
htab	struct
,	O
&	O
e	struct
)	O
;	O
while	O
(	O
expr	pointer
&&	O
strcmp	function
(	O
expr	pointer
->	O
pattern	pointer
,	O
c_sym	pointer
)	O
==	O
0	int
)	O
if	O
(	O
expr	pointer
->	O
mask	int
==	O
BFD_ELF_VERSION_C_TYPE	int
)	O
goto	O
out_ret	O
;	O
else	O
expr	pointer
=	O
expr	pointer
->	O
next	pointer
;	O
}	O
case	O
BFD_ELF_VERSION_C_TYPE	int
:	O
if	O
(	O
head	pointer
->	O
mask	int
&	O
BFD_ELF_VERSION_CXX_TYPE	int
)	O
{	O
e	struct
.	O
pattern	pointer
=	O
cxx_sym	pointer
;	O
expr	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
htab_find	function
(	O
(	O
htab_t	pointer
)	O
head	pointer
->	O
htab	struct
,	O
&	O
e	struct
)	O
;	O
while	O
(	O
expr	pointer
&&	O
strcmp	function
(	O
expr	pointer
->	O
pattern	pointer
,	O
cxx_sym	pointer
)	O
==	O
0	int
)	O
if	O
(	O
expr	pointer
->	O
mask	int
==	O
BFD_ELF_VERSION_CXX_TYPE	int
)	O
goto	O
out_ret	O
;	O
else	O
expr	pointer
=	O
expr	pointer
->	O
next	pointer
;	O
}	O
case	O
BFD_ELF_VERSION_CXX_TYPE	int
:	O
if	O
(	O
head	pointer
->	O
mask	int
&	O
BFD_ELF_VERSION_JAVA_TYPE	int
)	O
{	O
e	struct
.	O
pattern	pointer
=	O
java_sym	pointer
;	O
expr	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
htab_find	function
(	O
(	O
htab_t	pointer
)	O
head	pointer
->	O
htab	struct
,	O
&	O
e	struct
)	O
;	O
while	O
(	O
expr	pointer
&&	O
strcmp	function
(	O
expr	pointer
->	O
pattern	pointer
,	O
java_sym	pointer
)	O
==	O
0	int
)	O
if	O
(	O
expr	pointer
->	O
mask	int
==	O
BFD_ELF_VERSION_JAVA_TYPE	int
)	O
goto	O
out_ret	O
;	O
else	O
expr	pointer
=	O
expr	pointer
->	O
next	pointer
;	O
}	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
prev	pointer
==	O
NULL	O
||	O
prev	pointer
->	O
literal	int
)	O
expr	pointer
=	O
head	pointer
->	O
remaining	pointer
;	O
else	O
expr	pointer
=	O
prev	pointer
->	O
next	pointer
;	O
for	O
(	O
;	O
expr	pointer
;	O
expr	pointer
=	O
expr	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
if	O
(	O
!	O
expr	pointer
->	O
pattern	pointer
)	O
continue	O
;	O
if	O
(	O
expr	pointer
->	O
pattern	pointer
[	O
0	int
]	O
==	O
'*'	O
&&	O
expr	pointer
->	O
pattern	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
expr	pointer
->	O
mask	int
==	O
BFD_ELF_VERSION_JAVA_TYPE	int
)	O
s	pointer
=	O
java_sym	pointer
;	O
else	O
if	O
(	O
expr	pointer
->	O
mask	int
==	O
BFD_ELF_VERSION_CXX_TYPE	int
)	O
s	pointer
=	O
cxx_sym	pointer
;	O
else	O
s	pointer
=	O
c_sym	pointer
;	O
if	O
(	O
fnmatch	function
(	O
expr	pointer
->	O
pattern	pointer
,	O
s	pointer
,	O
0	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
out_ret	O
:	O
if	O
(	O
c_sym	pointer
!=	O
sym	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
c_sym	pointer
)	O
;	O
if	O
(	O
cxx_sym	pointer
!=	O
sym	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
cxx_sym	pointer
)	O
;	O
if	O
(	O
java_sym	pointer
!=	O
sym	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
java_sym	pointer
)	O
;	O
return	O
expr	pointer
;	O
}	O
static	O
const	O
char	O
*	O
realsymbol	function
(	O
const	O
char	O
*	O
pattern	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
bfd_boolean	int
changed	int
=	O
FALSE	int
,	O
backslash	int
=	O
FALSE	int
;	O
char	O
*	O
s	pointer
,	O
*	O
symbol	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
pattern	pointer
)	O
+	O
1	int
)	O
;	O
for	O
(	O
p	pointer
=	O
pattern	pointer
,	O
s	pointer
=	O
symbol	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
++	O
p	pointer
)	O
{	O
if	O
(	O
backslash	int
)	O
{	O
*	O
(	O
s	pointer
-	O
1	int
)	O
=	O
*	O
p	pointer
;	O
backslash	int
=	O
FALSE	int
;	O
changed	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'?'	O
||	O
*	O
p	pointer
==	O
'*'	O
||	O
*	O
p	pointer
==	O
'['	O
)	O
{	O
free	function
(	O
symbol	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
*	O
s	pointer
++	O
=	O
*	O
p	pointer
;	O
backslash	int
=	O
*	O
p	pointer
==	O
'\\'	O
;	O
}	O
}	O
if	O
(	O
changed	int
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
return	O
symbol	pointer
;	O
}	O
else	O
{	O
free	function
(	O
symbol	pointer
)	O
;	O
return	O
pattern	pointer
;	O
}	O
}	O
struct	O
bfd_elf_version_expr	struct
*	O
lang_new_vers_pattern	function
(	O
struct	O
bfd_elf_version_expr	struct
*	O
orig	pointer
,	O
const	O
char	O
*	O
new_name	pointer
,	O
const	O
char	O
*	O
lang	pointer
,	O
bfd_boolean	int
literal_p	int
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ret	pointer
)	O
;	O
ret	pointer
->	O
next	pointer
=	O
orig	pointer
;	O
ret	pointer
->	O
symver	int
=	O
0	int
;	O
ret	pointer
->	O
script	int
=	O
0	int
;	O
ret	pointer
->	O
literal	int
=	O
TRUE	int
;	O
ret	pointer
->	O
pattern	pointer
=	O
literal_p	int
?	O
new_name	pointer
:	O
realsymbol	function
(	O
new_name	pointer
)	O
;	O
if	O
(	O
ret	pointer
->	O
pattern	pointer
==	O
NULL	O
)	O
{	O
ret	pointer
->	O
pattern	pointer
=	O
new_name	pointer
;	O
ret	pointer
->	O
literal	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
lang	pointer
==	O
NULL	O
||	O
strcasecmp	function
(	O
lang	pointer
,	O
"C"	pointer
)	O
==	O
0	int
)	O
ret	pointer
->	O
mask	int
=	O
BFD_ELF_VERSION_C_TYPE	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
lang	pointer
,	O
"C++"	pointer
)	O
==	O
0	int
)	O
ret	pointer
->	O
mask	int
=	O
BFD_ELF_VERSION_CXX_TYPE	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
lang	pointer
,	O
"Java"	pointer
)	O
==	O
0	int
)	O
ret	pointer
->	O
mask	int
=	O
BFD_ELF_VERSION_JAVA_TYPE	int
;	O
else	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: unknown language `%s' in version information\n"	pointer
)	O
,	O
lang	pointer
)	O
;	O
ret	pointer
->	O
mask	int
=	O
BFD_ELF_VERSION_C_TYPE	int
;	O
}	O
return	O
ldemul_new_vers_pattern	function
(	O
ret	pointer
)	O
;	O
}	O
struct	O
bfd_elf_version_tree	struct
*	O
lang_new_vers_node	function
(	O
struct	O
bfd_elf_version_expr	struct
*	O
globals	struct
,	O
struct	O
bfd_elf_version_expr	struct
*	O
locals	struct
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
struct	O
bfd_elf_version_tree	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
*	O
ret	pointer
)	O
;	O
ret	pointer
->	O
globals	struct
.	O
list	pointer
=	O
globals	struct
;	O
ret	pointer
->	O
locals	struct
.	O
list	pointer
=	O
locals	struct
;	O
ret	pointer
->	O
match	pointer
=	O
lang_vers_match	function
;	O
ret	pointer
->	O
name_indx	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
version_index	int
;	O
static	O
hashval_t	int
version_expr_head_hash	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
const	O
struct	O
bfd_elf_version_expr	struct
*	O
e	struct
=	O
(	O
const	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
p	pointer
;	O
return	O
htab_hash_string	function
(	O
e	struct
->	O
pattern	pointer
)	O
;	O
}	O
static	O
int	O
version_expr_head_eq	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
const	O
struct	O
bfd_elf_version_expr	struct
*	O
e1	pointer
=	O
(	O
const	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
p1	pointer
;	O
const	O
struct	O
bfd_elf_version_expr	struct
*	O
e2	pointer
=	O
(	O
const	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
p2	pointer
;	O
return	O
strcmp	function
(	O
e1	pointer
->	O
pattern	pointer
,	O
e2	pointer
->	O
pattern	pointer
)	O
==	O
0	int
;	O
}	O
static	O
void	O
lang_finalize_version_expr_head	function
(	O
struct	O
bfd_elf_version_expr_head	struct
*	O
head	pointer
)	O
{	O
size_t	long
count	int
=	O
0	int
;	O
struct	O
bfd_elf_version_expr	struct
*	O
e	struct
,	O
*	O
next	pointer
;	O
struct	O
bfd_elf_version_expr	struct
*	O
*	O
list_loc	pointer
,	O
*	O
*	O
remaining_loc	pointer
;	O
for	O
(	O
e	struct
=	O
head	pointer
->	O
list	pointer
;	O
e	struct
;	O
e	struct
=	O
e	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
e	struct
->	O
literal	int
)	O
count	int
++	O
;	O
head	pointer
->	O
mask	int
|=	O
e	struct
->	O
mask	int
;	O
}	O
if	O
(	O
count	int
)	O
{	O
head	pointer
->	O
htab	struct
=	O
htab_create	function
(	O
count	int
*	O
2	int
,	O
version_expr_head_hash	function
,	O
version_expr_head_eq	function
,	O
NULL	O
)	O
;	O
list_loc	pointer
=	O
&	O
head	pointer
->	O
list	pointer
;	O
remaining_loc	pointer
=	O
&	O
head	pointer
->	O
remaining	pointer
;	O
for	O
(	O
e	struct
=	O
head	pointer
->	O
list	pointer
;	O
e	struct
;	O
e	struct
=	O
next	pointer
)	O
{	O
next	pointer
=	O
e	struct
->	O
next	pointer
;	O
if	O
(	O
!	O
e	struct
->	O
literal	int
)	O
{	O
*	O
remaining_loc	pointer
=	O
e	struct
;	O
remaining_loc	pointer
=	O
&	O
e	struct
->	O
next	pointer
;	O
}	O
else	O
{	O
void	O
*	O
*	O
loc	pointer
=	O
htab_find_slot	function
(	O
(	O
htab_t	pointer
)	O
head	pointer
->	O
htab	struct
,	O
e	struct
,	O
INSERT	int
)	O
;	O
if	O
(	O
*	O
loc	pointer
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
e1	pointer
,	O
*	O
last	pointer
;	O
e1	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
*	O
loc	pointer
;	O
last	pointer
=	O
NULL	O
;	O
do	O
{	O
if	O
(	O
e1	pointer
->	O
mask	int
==	O
e	struct
->	O
mask	int
)	O
{	O
last	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
last	pointer
=	O
e1	pointer
;	O
e1	pointer
=	O
e1	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
e1	pointer
&&	O
strcmp	function
(	O
e1	pointer
->	O
pattern	pointer
,	O
e	struct
->	O
pattern	pointer
)	O
==	O
0	int
)	O
;	O
if	O
(	O
last	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
e	struct
)	O
;	O
}	O
else	O
{	O
e	struct
->	O
next	pointer
=	O
last	pointer
->	O
next	pointer
;	O
last	pointer
->	O
next	pointer
=	O
e	struct
;	O
}	O
}	O
else	O
{	O
*	O
loc	pointer
=	O
e	struct
;	O
*	O
list_loc	pointer
=	O
e	struct
;	O
list_loc	pointer
=	O
&	O
e	struct
->	O
next	pointer
;	O
}	O
}	O
}	O
*	O
remaining_loc	pointer
=	O
NULL	O
;	O
*	O
list_loc	pointer
=	O
head	pointer
->	O
remaining	pointer
;	O
}	O
else	O
head	pointer
->	O
remaining	pointer
=	O
head	pointer
->	O
list	pointer
;	O
}	O
void	O
lang_register_vers_node	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
bfd_elf_version_tree	struct
*	O
version	pointer
,	O
struct	O
bfd_elf_version_deps	struct
*	O
deps	pointer
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
,	O
*	O
*	O
pp	pointer
;	O
struct	O
bfd_elf_version_expr	struct
*	O
e1	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
""	pointer
;	O
if	O
(	O
link_info	struct
.	O
version_info	pointer
!=	O
NULL	O
&&	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
link_info	struct
.	O
version_info	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%X%P: anonymous version tag cannot be combined"	pointer
" with other version tags\n"	pointer
)	O
)	O
;	O
free	function
(	O
version	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
t	pointer
=	O
link_info	struct
.	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
t	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: duplicate version tag `%s'\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
lang_finalize_version_expr_head	function
(	O
&	O
version	pointer
->	O
globals	struct
)	O
;	O
lang_finalize_version_expr_head	function
(	O
&	O
version	pointer
->	O
locals	struct
)	O
;	O
for	O
(	O
e1	pointer
=	O
version	pointer
->	O
globals	struct
.	O
list	pointer
;	O
e1	pointer
!=	O
NULL	O
;	O
e1	pointer
=	O
e1	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
t	pointer
=	O
link_info	struct
.	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
e2	pointer
;	O
if	O
(	O
t	pointer
->	O
locals	struct
.	O
htab	struct
&&	O
e1	pointer
->	O
literal	int
)	O
{	O
e2	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
htab_find	function
(	O
(	O
htab_t	pointer
)	O
t	pointer
->	O
locals	struct
.	O
htab	struct
,	O
e1	pointer
)	O
;	O
while	O
(	O
e2	pointer
&&	O
strcmp	function
(	O
e1	pointer
->	O
pattern	pointer
,	O
e2	pointer
->	O
pattern	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
e1	pointer
->	O
mask	int
==	O
e2	pointer
->	O
mask	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: duplicate expression `%s'"	pointer
" in version information\n"	pointer
)	O
,	O
e1	pointer
->	O
pattern	pointer
)	O
;	O
e2	pointer
=	O
e2	pointer
->	O
next	pointer
;	O
}	O
}	O
else	O
if	O
(	O
!	O
e1	pointer
->	O
literal	int
)	O
for	O
(	O
e2	pointer
=	O
t	pointer
->	O
locals	struct
.	O
remaining	pointer
;	O
e2	pointer
!=	O
NULL	O
;	O
e2	pointer
=	O
e2	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
e1	pointer
->	O
pattern	pointer
,	O
e2	pointer
->	O
pattern	pointer
)	O
==	O
0	int
&&	O
e1	pointer
->	O
mask	int
==	O
e2	pointer
->	O
mask	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: duplicate expression `%s'"	pointer
" in version information\n"	pointer
)	O
,	O
e1	pointer
->	O
pattern	pointer
)	O
;	O
}	O
}	O
for	O
(	O
e1	pointer
=	O
version	pointer
->	O
locals	struct
.	O
list	pointer
;	O
e1	pointer
!=	O
NULL	O
;	O
e1	pointer
=	O
e1	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
t	pointer
=	O
link_info	struct
.	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
e2	pointer
;	O
if	O
(	O
t	pointer
->	O
globals	struct
.	O
htab	struct
&&	O
e1	pointer
->	O
literal	int
)	O
{	O
e2	pointer
=	O
(	O
struct	O
bfd_elf_version_expr	struct
*	O
)	O
htab_find	function
(	O
(	O
htab_t	pointer
)	O
t	pointer
->	O
globals	struct
.	O
htab	struct
,	O
e1	pointer
)	O
;	O
while	O
(	O
e2	pointer
&&	O
strcmp	function
(	O
e1	pointer
->	O
pattern	pointer
,	O
e2	pointer
->	O
pattern	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
e1	pointer
->	O
mask	int
==	O
e2	pointer
->	O
mask	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: duplicate expression `%s'"	pointer
" in version information\n"	pointer
)	O
,	O
e1	pointer
->	O
pattern	pointer
)	O
;	O
e2	pointer
=	O
e2	pointer
->	O
next	pointer
;	O
}	O
}	O
else	O
if	O
(	O
!	O
e1	pointer
->	O
literal	int
)	O
for	O
(	O
e2	pointer
=	O
t	pointer
->	O
globals	struct
.	O
remaining	pointer
;	O
e2	pointer
!=	O
NULL	O
;	O
e2	pointer
=	O
e2	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
e1	pointer
->	O
pattern	pointer
,	O
e2	pointer
->	O
pattern	pointer
)	O
==	O
0	int
&&	O
e1	pointer
->	O
mask	int
==	O
e2	pointer
->	O
mask	int
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: duplicate expression `%s'"	pointer
" in version information\n"	pointer
)	O
,	O
e1	pointer
->	O
pattern	pointer
)	O
;	O
}	O
}	O
version	pointer
->	O
deps	pointer
=	O
deps	pointer
;	O
version	pointer
->	O
name	pointer
=	O
name	pointer
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
++	O
version_index	int
;	O
version	pointer
->	O
vernum	int
=	O
version_index	int
;	O
}	O
else	O
version	pointer
->	O
vernum	int
=	O
0	int
;	O
for	O
(	O
pp	pointer
=	O
&	O
link_info	struct
.	O
version_info	pointer
;	O
*	O
pp	pointer
!=	O
NULL	O
;	O
pp	pointer
=	O
&	O
(	O
*	O
pp	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pp	pointer
=	O
version	pointer
;	O
}	O
struct	O
bfd_elf_version_deps	struct
*	O
lang_add_vers_depend	function
(	O
struct	O
bfd_elf_version_deps	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
bfd_elf_version_deps	struct
*	O
ret	pointer
;	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
;	O
ret	pointer
=	O
(	O
struct	O
bfd_elf_version_deps	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ret	pointer
)	O
;	O
ret	pointer
->	O
next	pointer
=	O
list	pointer
;	O
for	O
(	O
t	pointer
=	O
link_info	struct
.	O
version_info	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
t	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
ret	pointer
->	O
version_needed	pointer
=	O
t	pointer
;	O
return	O
ret	pointer
;	O
}	O
}	O
einfo	pointer
(	O
_	O
(	O
"%X%P: unable to find version dependency `%s'\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
ret	pointer
->	O
version_needed	pointer
=	O
NULL	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
lang_do_version_exports_section	function
(	O
void	O
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
greg	pointer
=	O
NULL	O
,	O
*	O
lreg	pointer
;	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
is	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
is	pointer
->	O
the_bfd	pointer
,	O
".exports"	pointer
)	O
;	O
char	O
*	O
contents	pointer
,	O
*	O
p	pointer
;	O
bfd_size_type	long
len	long
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
continue	O
;	O
len	long
=	O
sec	pointer
->	O
size	int
;	O
contents	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
)	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
is	pointer
->	O
the_bfd	pointer
,	O
sec	pointer
,	O
contents	pointer
,	O
0	int
,	O
len	long
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%X%P: unable to read .exports section contents\n"	pointer
)	O
,	O
sec	pointer
)	O
;	O
p	pointer
=	O
contents	pointer
;	O
while	O
(	O
p	pointer
<	O
contents	pointer
+	O
len	long
)	O
{	O
greg	pointer
=	O
lang_new_vers_pattern	function
(	O
greg	pointer
,	O
p	pointer
,	O
NULL	O
,	O
FALSE	int
)	O
;	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'\0'	O
)	O
+	O
1	int
;	O
}	O
sec	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
|	O
SEC_KEEP	int
;	O
}	O
lreg	pointer
=	O
lang_new_vers_pattern	function
(	O
NULL	O
,	O
"*"	pointer
,	O
NULL	O
,	O
FALSE	int
)	O
;	O
lang_register_vers_node	function
(	O
command_line	struct
.	O
version_exports_section	pointer
,	O
lang_new_vers_node	function
(	O
greg	pointer
,	O
lreg	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
lang_do_memory_regions	function
(	O
void	O
)	O
{	O
lang_memory_region_type	struct
*	O
r	pointer
=	O
lang_memory_region_list	pointer
;	O
for	O
(	O
;	O
r	pointer
!=	O
NULL	O
;	O
r	pointer
=	O
r	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
r	pointer
->	O
origin_exp	pointer
)	O
{	O
exp_fold_tree_no_dot	function
(	O
r	pointer
->	O
origin_exp	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
r	pointer
->	O
origin	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
r	pointer
->	O
current	long
=	O
r	pointer
->	O
origin	long
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid origin for memory region %s\n"	pointer
)	O
,	O
r	pointer
->	O
name_list	struct
.	O
name	pointer
)	O
;	O
}	O
if	O
(	O
r	pointer
->	O
length_exp	pointer
)	O
{	O
exp_fold_tree_no_dot	function
(	O
r	pointer
->	O
length_exp	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
r	pointer
->	O
length	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid length for memory region %s\n"	pointer
)	O
,	O
r	pointer
->	O
name_list	struct
.	O
name	pointer
)	O
;	O
}	O
}	O
}	O
void	O
lang_add_unique	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
unique_sections	struct
*	O
ent	pointer
;	O
for	O
(	O
ent	pointer
=	O
unique_section_list	pointer
;	O
ent	pointer
;	O
ent	pointer
=	O
ent	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
ent	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
;	O
ent	pointer
=	O
(	O
struct	O
unique_sections	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ent	pointer
)	O
;	O
ent	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
ent	pointer
->	O
next	pointer
=	O
unique_section_list	pointer
;	O
unique_section_list	pointer
=	O
ent	pointer
;	O
}	O
void	O
lang_append_dynamic_list	function
(	O
struct	O
bfd_elf_version_expr	struct
*	O
dynamic	int
)	O
{	O
if	O
(	O
link_info	struct
.	O
dynamic_list	pointer
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
tail	pointer
;	O
for	O
(	O
tail	pointer
=	O
dynamic	int
;	O
tail	pointer
->	O
next	pointer
!=	O
NULL	O
;	O
tail	pointer
=	O
tail	pointer
->	O
next	pointer
)	O
;	O
tail	pointer
->	O
next	pointer
=	O
link_info	struct
.	O
dynamic_list	pointer
->	O
head	pointer
.	O
list	pointer
;	O
link_info	struct
.	O
dynamic_list	pointer
->	O
head	pointer
.	O
list	pointer
=	O
dynamic	int
;	O
}	O
else	O
{	O
struct	O
bfd_elf_dynamic_list	struct
*	O
d	pointer
;	O
d	pointer
=	O
(	O
struct	O
bfd_elf_dynamic_list	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
*	O
d	pointer
)	O
;	O
d	pointer
->	O
head	pointer
.	O
list	pointer
=	O
dynamic	int
;	O
d	pointer
->	O
match	pointer
=	O
lang_vers_match	function
;	O
link_info	struct
.	O
dynamic_list	pointer
=	O
d	pointer
;	O
}	O
}	O
void	O
lang_append_dynamic_list_cpp_typeinfo	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
symbols	array
[	O
]	O
=	O
{	O
"typeinfo name for*"	pointer
,	O
"typeinfo for*"	pointer
}	O
;	O
struct	O
bfd_elf_version_expr	struct
*	O
dynamic	int
=	O
NULL	O
;	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
symbols	array
)	O
;	O
i	pointer
++	O
)	O
dynamic	int
=	O
lang_new_vers_pattern	function
(	O
dynamic	int
,	O
symbols	array
[	O
i	pointer
]	O
,	O
"C++"	pointer
,	O
FALSE	int
)	O
;	O
lang_append_dynamic_list	function
(	O
dynamic	int
)	O
;	O
}	O
void	O
lang_append_dynamic_list_cpp_new	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
symbols	array
[	O
]	O
=	O
{	O
"operator new*"	pointer
,	O
"operator delete*"	pointer
}	O
;	O
struct	O
bfd_elf_version_expr	struct
*	O
dynamic	int
=	O
NULL	O
;	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
symbols	array
)	O
;	O
i	pointer
++	O
)	O
dynamic	int
=	O
lang_new_vers_pattern	function
(	O
dynamic	int
,	O
symbols	array
[	O
i	pointer
]	O
,	O
"C++"	pointer
,	O
FALSE	int
)	O
;	O
lang_append_dynamic_list	function
(	O
dynamic	int
)	O
;	O
}	O
void	O
lang_ld_feature	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
p	pointer
=	O
str	pointer
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
char	O
sep	pointer
;	O
while	O
(	O
*	O
p	pointer
==	O
','	O
||	O
ISSPACE	O
(	O
*	O
p	pointer
)	O
)	O
++	O
p	pointer
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
break	O
;	O
q	pointer
=	O
p	pointer
+	O
1	int
;	O
while	O
(	O
*	O
q	pointer
&&	O
*	O
q	pointer
!=	O
','	O
&&	O
!	O
ISSPACE	O
(	O
*	O
q	pointer
)	O
)	O
++	O
q	pointer
;	O
sep	pointer
=	O
*	O
q	pointer
;	O
*	O
q	pointer
=	O
0	int
;	O
if	O
(	O
strcasecmp	function
(	O
p	pointer
,	O
"SANE_EXPR"	pointer
)	O
==	O
0	int
)	O
config	struct
.	O
sane_expr	int
=	O
TRUE	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%X%P: unknown feature `%s'\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
*	O
q	pointer
=	O
sep	pointer
;	O
p	pointer
=	O
q	pointer
;	O
}	O
}	O
static	O
void	O
lang_print_memory_size	function
(	O
bfd_vma	long
sz	long
)	O
{	O
if	O
(	O
(	O
sz	long
&	O
0x3fffffff	int
)	O
==	O
0	int
)	O
printf	function
(	O
"%10"	pointer
BFD_VMA_FMT	pointer
"u GB"	pointer
,	O
sz	long
>>	O
30	int
)	O
;	O
else	O
if	O
(	O
(	O
sz	long
&	O
0xfffff	int
)	O
==	O
0	int
)	O
printf	function
(	O
"%10"	pointer
BFD_VMA_FMT	pointer
"u MB"	pointer
,	O
sz	long
>>	O
20	int
)	O
;	O
else	O
if	O
(	O
(	O
sz	long
&	O
0x3ff	int
)	O
==	O
0	int
)	O
printf	function
(	O
"%10"	pointer
BFD_VMA_FMT	pointer
"u KB"	pointer
,	O
sz	long
>>	O
10	int
)	O
;	O
else	O
printf	function
(	O
" %10"	pointer
BFD_VMA_FMT	pointer
"u B"	pointer
,	O
sz	long
)	O
;	O
}	O
void	O
lang_print_memory_usage	function
(	O
void	O
)	O
{	O
lang_memory_region_type	struct
*	O
r	pointer
;	O
printf	function
(	O
"Memory region         Used Size  Region Size  %%age Used\n"	pointer
)	O
;	O
for	O
(	O
r	pointer
=	O
lang_memory_region_list	pointer
;	O
r	pointer
->	O
next	pointer
!=	O
NULL	O
;	O
r	pointer
=	O
r	pointer
->	O
next	pointer
)	O
{	O
bfd_vma	long
used_length	long
=	O
r	pointer
->	O
current	long
-	O
r	pointer
->	O
origin	long
;	O
printf	function
(	O
"%16s: "	pointer
,	O
r	pointer
->	O
name_list	struct
.	O
name	pointer
)	O
;	O
lang_print_memory_size	function
(	O
used_length	long
)	O
;	O
lang_print_memory_size	function
(	O
(	O
bfd_vma	long
)	O
r	pointer
->	O
length	long
)	O
;	O
if	O
(	O
r	pointer
->	O
length	long
!=	O
0	int
)	O
{	O
double	O
percent	double
=	O
used_length	long
*	O
100.0	int
/	O
r	pointer
->	O
length	long
;	O
printf	function
(	O
"    %6.2f%%"	pointer
,	O
percent	double
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
