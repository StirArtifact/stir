extern	O
int	O
bs_mode	int
;	O
public	O
int	O
utf_mode	int
=	O
0	int
;	O
struct	O
charset	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
*	O
p_flag	pointer
;	O
char	O
*	O
desc	pointer
;	O
}	O
charsets	array
[	O
]	O
=	O
{	O
{	O
"ascii"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.b"	pointer
}	O
,	O
{	O
"utf-8"	pointer
,	O
&	O
utf_mode	int
,	O
"8bcccbcc18b95.b126.bb"	pointer
}	O
,	O
{	O
"iso8859"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.33b."	pointer
}	O
,	O
{	O
"latin3"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.33b5.b8.b15.b4.b12.b18.b12.b."	pointer
}	O
,	O
{	O
"arabic"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.33b.3b.7b2.13b.3b.b26.5b19.b"	pointer
}	O
,	O
{	O
"greek"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.33b4.2b4.b3.b35.b44.b"	pointer
}	O
,	O
{	O
"greek2005"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.33b14.b35.b44.b"	pointer
}	O
,	O
{	O
"hebrew"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.33b.b29.32b28.2b2.b"	pointer
}	O
,	O
{	O
"koi8-r"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.b."	pointer
}	O
,	O
{	O
"KOI8-T"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.b8.b6.b8.b.b.5b7.3b4.b4.b3.b.b.3b."	pointer
}	O
,	O
{	O
"georgianps"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.3b11.4b12.2b."	pointer
}	O
,	O
{	O
"tcvn"	pointer
,	O
NULL	O
,	O
"b..b...bcccbccbbb7.8b95.b48.5b."	pointer
}	O
,	O
{	O
"TIS-620"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.b.4b.11b7.8b."	pointer
}	O
,	O
{	O
"next"	pointer
,	O
NULL	O
,	O
"8bcccbcc18b95.bb125.bb"	pointer
}	O
,	O
{	O
"dos"	pointer
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b."	pointer
}	O
,	O
{	O
"windows-1251"	pointer
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b24.b."	pointer
}	O
,	O
{	O
"windows-1252"	pointer
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b.b11.b.2b12.b."	pointer
}	O
,	O
{	O
"windows-1255"	pointer
,	O
NULL	O
,	O
"8bcccbcc12bc5b95.b.b8.b.5b9.b.4b."	pointer
}	O
,	O
{	O
"ebcdic"	pointer
,	O
NULL	O
,	O
"5bc6bcc7bcc41b.9b7.9b5.b..8b6.10b6.b9.7b9.8b8.17b3.3b9.7b9.8b8.6b10.b.b.b."	pointer
}	O
,	O
{	O
"IBM-1047"	pointer
,	O
NULL	O
,	O
"4cbcbc3b9cbccbccbb4c6bcc5b3cbbc4bc4bccbc191.b"	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
struct	O
cs_alias	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
oname	pointer
;	O
}	O
cs_aliases	array
[	O
]	O
=	O
{	O
{	O
"UTF-8"	pointer
,	O
"utf-8"	pointer
}	O
,	O
{	O
"utf8"	pointer
,	O
"utf-8"	pointer
}	O
,	O
{	O
"UTF8"	pointer
,	O
"utf-8"	pointer
}	O
,	O
{	O
"ANSI_X3.4-1968"	pointer
,	O
"ascii"	pointer
}	O
,	O
{	O
"US-ASCII"	pointer
,	O
"ascii"	pointer
}	O
,	O
{	O
"latin1"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-1"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"latin9"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-15"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"latin2"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-2"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-3"	pointer
,	O
"latin3"	pointer
}	O
,	O
{	O
"latin4"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-4"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"cyrillic"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-5"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-6"	pointer
,	O
"arabic"	pointer
}	O
,	O
{	O
"ISO-8859-7"	pointer
,	O
"greek"	pointer
}	O
,	O
{	O
"IBM9005"	pointer
,	O
"greek2005"	pointer
}	O
,	O
{	O
"ISO-8859-8"	pointer
,	O
"hebrew"	pointer
}	O
,	O
{	O
"latin5"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-9"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"latin6"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-10"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"latin7"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-13"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"latin8"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-14"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"latin10"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"ISO-8859-16"	pointer
,	O
"iso8859"	pointer
}	O
,	O
{	O
"IBM437"	pointer
,	O
"dos"	pointer
}	O
,	O
{	O
"EBCDIC-US"	pointer
,	O
"ebcdic"	pointer
}	O
,	O
{	O
"IBM1047"	pointer
,	O
"IBM-1047"	pointer
}	O
,	O
{	O
"KOI8-R"	pointer
,	O
"koi8-r"	pointer
}	O
,	O
{	O
"KOI8-U"	pointer
,	O
"koi8-r"	pointer
}	O
,	O
{	O
"GEORGIAN-PS"	pointer
,	O
"georgianps"	pointer
}	O
,	O
{	O
"TCVN5712-1"	pointer
,	O
"tcvn"	pointer
}	O
,	O
{	O
"NEXTSTEP"	pointer
,	O
"next"	pointer
}	O
,	O
{	O
"windows"	pointer
,	O
"windows-1252"	pointer
}	O
,	O
{	O
"CP1251"	pointer
,	O
"windows-1251"	pointer
}	O
,	O
{	O
"CP1252"	pointer
,	O
"windows-1252"	pointer
}	O
,	O
{	O
"CP1255"	pointer
,	O
"windows-1255"	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
char	O
chardef	array
[	O
256	int
]	O
;	O
static	O
char	O
*	O
binfmt	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
utfbinfmt	pointer
=	O
NULL	O
;	O
public	O
int	O
binattr	int
=	O
AT_STANDOUT	O
;	O
static	O
void	O
ichardef	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
char	O
*	O
cp	pointer
;	O
int	O
n	int
;	O
char	O
v	char
;	O
n	int
=	O
0	int
;	O
v	char
=	O
0	int
;	O
cp	pointer
=	O
chardef	array
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
*	O
s	pointer
++	O
)	O
{	O
case	O
'.'	O
:	O
v	char
=	O
0	int
;	O
break	O
;	O
case	O
'c'	O
:	O
v	char
=	O
IS_CONTROL_CHAR	int
;	O
break	O
;	O
case	O
'b'	O
:	O
v	char
=	O
IS_BINARY_CHAR	int
|	O
IS_CONTROL_CHAR	int
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
n	int
=	O
(	O
10	int
*	O
n	int
)	O
+	O
(	O
s	pointer
[	O
-	O
1	int
]	O
-	O
'0'	O
)	O
;	O
continue	O
;	O
default	O
:	O
error	function
(	O
"invalid chardef"	pointer
,	O
NULL_PARG	O
)	O
;	O
quit	function
(	O
QUIT_ERROR	int
)	O
;	O
}	O
do	O
{	O
if	O
(	O
cp	pointer
>=	O
chardef	array
+	O
sizeof	O
(	O
chardef	array
)	O
)	O
{	O
error	function
(	O
"chardef longer than 256"	pointer
,	O
NULL_PARG	O
)	O
;	O
quit	function
(	O
QUIT_ERROR	int
)	O
;	O
}	O
*	O
cp	pointer
++	O
=	O
v	char
;	O
}	O
while	O
(	O
--	O
n	int
>	O
0	int
)	O
;	O
n	int
=	O
0	int
;	O
}	O
while	O
(	O
cp	pointer
<	O
chardef	array
+	O
sizeof	O
(	O
chardef	array
)	O
)	O
*	O
cp	pointer
++	O
=	O
v	char
;	O
}	O
static	O
int	O
icharset	function
(	O
name	pointer
,	O
no_error	int
)	O
char	O
*	O
name	pointer
;	O
int	O
no_error	int
;	O
{	O
struct	O
charset	struct
*	O
p	pointer
;	O
struct	O
cs_alias	struct
*	O
a	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
*	O
name	pointer
==	O
'\0'	O
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
a	pointer
=	O
cs_aliases	array
;	O
a	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
a	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
a	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
name	pointer
=	O
a	pointer
->	O
oname	pointer
;	O
break	O
;	O
}	O
}	O
for	O
(	O
p	pointer
=	O
charsets	array
;	O
p	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
p	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
ichardef	function
(	O
p	pointer
->	O
desc	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
p_flag	pointer
!=	O
NULL	O
)	O
{	O
*	O
(	O
p	pointer
->	O
p_flag	pointer
)	O
=	O
1	int
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
no_error	int
)	O
{	O
error	function
(	O
"invalid charset name"	pointer
,	O
NULL_PARG	O
)	O
;	O
quit	function
(	O
QUIT_ERROR	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
ilocale	function
(	O
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
(	O
int	O
)	O
sizeof	O
(	O
chardef	array
)	O
;	O
c	int
++	O
)	O
{	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
chardef	array
[	O
c	int
]	O
=	O
0	int
;	O
else	O
if	O
(	O
iscntrl	function
(	O
c	int
)	O
)	O
chardef	array
[	O
c	int
]	O
=	O
IS_CONTROL_CHAR	int
;	O
else	O
chardef	array
[	O
c	int
]	O
=	O
IS_BINARY_CHAR	int
|	O
IS_CONTROL_CHAR	int
;	O
}	O
}	O
public	O
void	O
setfmt	function
(	O
s	pointer
,	O
fmtvarptr	pointer
,	O
attrptr	pointer
,	O
default_fmt	pointer
)	O
char	O
*	O
s	pointer
;	O
char	O
*	O
*	O
fmtvarptr	pointer
;	O
int	O
*	O
attrptr	pointer
;	O
char	O
*	O
default_fmt	pointer
;	O
{	O
if	O
(	O
s	pointer
&&	O
utf_mode	int
)	O
{	O
char	O
constant	O
*	O
t	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
t	pointer
)	O
{	O
if	O
(	O
*	O
t	pointer
<	O
' '	O
||	O
*	O
t	pointer
>	O
'~'	O
)	O
{	O
s	pointer
=	O
default_fmt	pointer
;	O
goto	O
attr	int
;	O
}	O
t	pointer
++	O
;	O
}	O
}	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
*	O
s	pointer
==	O
'\0'	O
||	O
(	O
*	O
s	pointer
==	O
'*'	O
&&	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'\0'	O
||	O
s	pointer
[	O
2	int
]	O
==	O
'\0'	O
||	O
strchr	function
(	O
s	pointer
+	O
2	int
,	O
'n'	O
)	O
)	O
)	O
||	O
(	O
*	O
s	pointer
!=	O
'*'	O
&&	O
strchr	function
(	O
s	pointer
,	O
'n'	O
)	O
)	O
)	O
s	pointer
=	O
default_fmt	pointer
;	O
attr	int
:	O
if	O
(	O
*	O
s	pointer
==	O
'*'	O
&&	O
s	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
s	pointer
[	O
1	int
]	O
)	O
{	O
case	O
'd'	O
:	O
*	O
attrptr	pointer
=	O
AT_BOLD	O
;	O
break	O
;	O
case	O
'k'	O
:	O
*	O
attrptr	pointer
=	O
AT_BLINK	O
;	O
break	O
;	O
case	O
's'	O
:	O
*	O
attrptr	pointer
=	O
AT_STANDOUT	O
;	O
break	O
;	O
case	O
'u'	O
:	O
*	O
attrptr	pointer
=	O
AT_UNDERLINE	O
;	O
break	O
;	O
default	O
:	O
*	O
attrptr	pointer
=	O
AT_NORMAL	O
;	O
break	O
;	O
}	O
s	pointer
+=	O
2	int
;	O
}	O
*	O
fmtvarptr	pointer
=	O
s	pointer
;	O
}	O
static	O
void	O
set_charset	function
(	O
)	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
lgetenv	function
(	O
"LESSCHARSET"	pointer
)	O
;	O
if	O
(	O
icharset	function
(	O
s	pointer
,	O
0	int
)	O
)	O
return	O
;	O
s	pointer
=	O
lgetenv	function
(	O
"LESSCHARDEF"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
ichardef	function
(	O
s	pointer
)	O
;	O
return	O
;	O
}	O
s	pointer
=	O
nl_langinfo	function
(	O
CODESET	int
)	O
;	O
if	O
(	O
icharset	function
(	O
s	pointer
,	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
(	O
s	pointer
=	O
lgetenv	function
(	O
"LC_ALL"	pointer
)	O
)	O
!=	O
NULL	O
||	O
(	O
s	pointer
=	O
lgetenv	function
(	O
"LC_CTYPE"	pointer
)	O
)	O
!=	O
NULL	O
||	O
(	O
s	pointer
=	O
lgetenv	function
(	O
"LANG"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strstr	function
(	O
s	pointer
,	O
"UTF-8"	pointer
)	O
!=	O
NULL	O
||	O
strstr	function
(	O
s	pointer
,	O
"utf-8"	pointer
)	O
!=	O
NULL	O
||	O
strstr	function
(	O
s	pointer
,	O
"UTF8"	pointer
)	O
!=	O
NULL	O
||	O
strstr	function
(	O
s	pointer
,	O
"utf8"	pointer
)	O
!=	O
NULL	O
)	O
if	O
(	O
icharset	function
(	O
"utf-8"	pointer
,	O
1	int
)	O
)	O
return	O
;	O
}	O
ilocale	function
(	O
)	O
;	O
}	O
public	O
void	O
init_charset	function
(	O
)	O
{	O
char	O
*	O
s	pointer
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
set_charset	function
(	O
)	O
;	O
s	pointer
=	O
lgetenv	function
(	O
"LESSBINFMT"	pointer
)	O
;	O
setfmt	function
(	O
s	pointer
,	O
&	O
binfmt	pointer
,	O
&	O
binattr	int
,	O
"*s<%02X>"	pointer
)	O
;	O
s	pointer
=	O
lgetenv	function
(	O
"LESSUTFBINFMT"	pointer
)	O
;	O
setfmt	function
(	O
s	pointer
,	O
&	O
utfbinfmt	pointer
,	O
&	O
binattr	int
,	O
"<U+%04lX>"	pointer
)	O
;	O
}	O
public	O
int	O
binary_char	function
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
if	O
(	O
utf_mode	int
)	O
return	O
(	O
is_ubin_char	function
(	O
c	int
)	O
)	O
;	O
c	int
&=	O
0377	int
;	O
return	O
(	O
chardef	array
[	O
c	int
]	O
&	O
IS_BINARY_CHAR	int
)	O
;	O
}	O
public	O
int	O
control_char	function
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
c	int
&=	O
0377	int
;	O
return	O
(	O
chardef	array
[	O
c	int
]	O
&	O
IS_CONTROL_CHAR	int
)	O
;	O
}	O
public	O
char	O
*	O
prchar	function
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
static	O
char	O
buf	pointer
[	O
32	int
]	O
;	O
c	int
&=	O
0377	int
;	O
if	O
(	O
(	O
c	int
<	O
128	int
||	O
!	O
utf_mode	int
)	O
&&	O
!	O
control_char	function
(	O
c	int
)	O
)	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%c"	pointer
,	O
(	O
int	O
)	O
c	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
ESC	O
)	O
strcpy	function
(	O
buf	pointer
,	O
"ESC"	pointer
)	O
;	O
else	O
if	O
(	O
c	int
<	O
128	int
&&	O
!	O
control_char	function
(	O
c	int
^	O
0100	int
)	O
)	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"^%c"	pointer
,	O
(	O
int	O
)	O
(	O
c	int
^	O
0100	int
)	O
)	O
;	O
else	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
binfmt	pointer
,	O
c	int
)	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
public	O
char	O
*	O
prutfchar	function
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
static	O
char	O
buf	pointer
[	O
32	int
]	O
;	O
if	O
(	O
ch	long
==	O
ESC	O
)	O
strcpy	function
(	O
buf	pointer
,	O
"ESC"	pointer
)	O
;	O
else	O
if	O
(	O
ch	long
<	O
128	int
&&	O
control_char	function
(	O
ch	long
)	O
)	O
{	O
if	O
(	O
!	O
control_char	function
(	O
ch	long
^	O
0100	int
)	O
)	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"^%c"	pointer
,	O
(	O
(	O
char	O
)	O
ch	long
)	O
^	O
0100	int
)	O
;	O
else	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
binfmt	pointer
,	O
(	O
char	O
)	O
ch	long
)	O
;	O
}	O
else	O
if	O
(	O
is_ubin_char	function
(	O
ch	long
)	O
)	O
{	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
utfbinfmt	pointer
,	O
ch	long
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
if	O
(	O
ch	long
>=	O
0x80000000	int
)	O
ch	long
=	O
0xFFFD	int
;	O
put_wchar	function
(	O
&	O
p	pointer
,	O
ch	long
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
public	O
int	O
utf_len	function
(	O
ch	long
)	O
unsigned	O
char	O
ch	long
;	O
{	O
if	O
(	O
(	O
ch	long
&	O
0x80	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xE0	int
)	O
==	O
0xC0	int
)	O
return	O
2	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xF0	int
)	O
==	O
0xE0	int
)	O
return	O
3	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xF8	int
)	O
==	O
0xF0	int
)	O
return	O
4	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xFC	int
)	O
==	O
0xF8	int
)	O
return	O
5	int
;	O
if	O
(	O
(	O
ch	long
&	O
0xFE	int
)	O
==	O
0xFC	int
)	O
return	O
6	int
;	O
return	O
1	int
;	O
}	O
public	O
int	O
is_utf8_well_formed	function
(	O
ss	pointer
,	O
slen	int
)	O
char	O
*	O
ss	pointer
;	O
int	O
slen	int
;	O
{	O
int	O
i	int
;	O
int	O
len	int
;	O
unsigned	O
char	O
*	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
ss	pointer
;	O
if	O
(	O
IS_UTF8_INVALID	O
(	O
s	pointer
[	O
0	int
]	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
len	int
=	O
utf_len	function
(	O
s	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
len	int
>	O
slen	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
len	int
==	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
len	int
==	O
2	int
)	O
{	O
if	O
(	O
s	pointer
[	O
0	int
]	O
<	O
0xC2	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
mask	char
;	O
mask	char
=	O
(	O
~	O
(	O
(	O
1	int
<<	O
(	O
8	int
-	O
len	int
)	O
)	O
-	O
1	int
)	O
)	O
&	O
0xFF	int
;	O
if	O
(	O
s	pointer
[	O
0	int
]	O
==	O
mask	char
&&	O
(	O
s	pointer
[	O
1	int
]	O
&	O
mask	char
)	O
==	O
0x80	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
IS_UTF8_TRAIL	O
(	O
s	pointer
[	O
i	int
]	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
public	O
void	O
utf_skip_to_lead	function
(	O
pp	pointer
,	O
limit	pointer
)	O
char	O
*	O
*	O
pp	pointer
;	O
char	O
*	O
limit	pointer
;	O
{	O
do	O
{	O
++	O
(	O
*	O
pp	pointer
)	O
;	O
}	O
while	O
(	O
*	O
pp	pointer
<	O
limit	pointer
&&	O
!	O
IS_UTF8_LEAD	O
(	O
(	O
*	O
pp	pointer
)	O
[	O
0	int
]	O
&	O
0377	int
)	O
&&	O
!	O
IS_ASCII_OCTET	O
(	O
(	O
*	O
pp	pointer
)	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
public	O
LWCHAR	long
get_wchar	function
(	O
p	pointer
)	O
constant	O
char	O
*	O
p	pointer
;	O
{	O
switch	O
(	O
utf_len	function
(	O
p	pointer
[	O
0	int
]	O
)	O
)	O
{	O
case	O
1	int
:	O
default	O
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
p	pointer
[	O
0	int
]	O
&	O
0xFF	int
)	O
;	O
case	O
2	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	pointer
[	O
0	int
]	O
&	O
0x1F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	pointer
[	O
1	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
3	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	pointer
[	O
0	int
]	O
&	O
0x0F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	pointer
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	pointer
[	O
2	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
4	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	pointer
[	O
0	int
]	O
&	O
0x07	int
)	O
<<	O
18	int
)	O
|	O
(	O
(	O
p	pointer
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	pointer
[	O
2	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	pointer
[	O
3	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
5	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	pointer
[	O
0	int
]	O
&	O
0x03	int
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
p	pointer
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
18	int
)	O
|	O
(	O
(	O
p	pointer
[	O
2	int
]	O
&	O
0x3F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	pointer
[	O
3	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	pointer
[	O
4	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
case	O
6	int
:	O
return	O
(	O
LWCHAR	long
)	O
(	O
(	O
(	O
p	pointer
[	O
0	int
]	O
&	O
0x01	int
)	O
<<	O
30	int
)	O
|	O
(	O
(	O
p	pointer
[	O
1	int
]	O
&	O
0x3F	int
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
p	pointer
[	O
2	int
]	O
&	O
0x3F	int
)	O
<<	O
18	int
)	O
|	O
(	O
(	O
p	pointer
[	O
3	int
]	O
&	O
0x3F	int
)	O
<<	O
12	int
)	O
|	O
(	O
(	O
p	pointer
[	O
4	int
]	O
&	O
0x3F	int
)	O
<<	O
6	int
)	O
|	O
(	O
p	pointer
[	O
5	int
]	O
&	O
0x3F	int
)	O
)	O
;	O
}	O
}	O
public	O
void	O
put_wchar	function
(	O
pp	pointer
,	O
ch	long
)	O
char	O
*	O
*	O
pp	pointer
;	O
LWCHAR	long
ch	long
;	O
{	O
if	O
(	O
!	O
utf_mode	int
||	O
ch	long
<	O
0x80	int
)	O
{	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
ch	long
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x800	int
)	O
{	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xC0	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x1F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x10000	int
)	O
{	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xE0	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x0F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x200000	int
)	O
{	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xF0	int
|	O
(	O
(	O
ch	long
>>	O
18	int
)	O
&	O
0x07	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	long
<	O
0x4000000	int
)	O
{	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xF0	int
|	O
(	O
(	O
ch	long
>>	O
24	int
)	O
&	O
0x03	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
18	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
else	O
{	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0xF0	int
|	O
(	O
(	O
ch	long
>>	O
30	int
)	O
&	O
0x01	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
24	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
18	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
12	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
(	O
ch	long
>>	O
6	int
)	O
&	O
0x3F	int
)	O
)	O
;	O
*	O
(	O
*	O
pp	pointer
)	O
++	O
=	O
(	O
char	O
)	O
(	O
0x80	int
|	O
(	O
ch	long
&	O
0x3F	int
)	O
)	O
;	O
}	O
}	O
public	O
LWCHAR	long
step_char	function
(	O
pp	pointer
,	O
dir	int
,	O
limit	pointer
)	O
char	O
*	O
*	O
pp	pointer
;	O
signed	O
int	O
dir	int
;	O
constant	O
char	O
*	O
limit	pointer
;	O
{	O
LWCHAR	long
ch	long
;	O
int	O
len	int
;	O
char	O
*	O
p	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
utf_mode	int
)	O
{	O
if	O
(	O
dir	int
>	O
0	int
)	O
ch	long
=	O
(	O
LWCHAR	long
)	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
p	pointer
<	O
limit	pointer
)	O
?	O
*	O
p	pointer
++	O
:	O
0	int
)	O
;	O
else	O
ch	long
=	O
(	O
LWCHAR	long
)	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
p	pointer
>	O
limit	pointer
)	O
?	O
*	O
--	O
p	pointer
:	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
dir	int
>	O
0	int
)	O
{	O
len	int
=	O
utf_len	function
(	O
*	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
+	O
len	int
>	O
limit	pointer
)	O
{	O
ch	long
=	O
0	int
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
limit	pointer
;	O
}	O
else	O
{	O
ch	long
=	O
get_wchar	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
len	int
;	O
}	O
}	O
else	O
{	O
while	O
(	O
p	pointer
>	O
limit	pointer
&&	O
IS_UTF8_TRAIL	O
(	O
p	pointer
[	O
-	O
1	int
]	O
)	O
)	O
p	pointer
--	O
;	O
if	O
(	O
p	pointer
>	O
limit	pointer
)	O
ch	long
=	O
get_wchar	function
(	O
--	O
p	pointer
)	O
;	O
else	O
ch	long
=	O
0	int
;	O
}	O
*	O
pp	pointer
=	O
p	pointer
;	O
return	O
ch	long
;	O
}	O
DECLARE_RANGE_TABLE_START	O
(	O
compose	O
)	O
DECLARE_RANGE_TABLE_END	O
(	O
compose	O
)	O
DECLARE_RANGE_TABLE_START	O
(	O
ubin	int
)	O
DECLARE_RANGE_TABLE_END	O
(	O
ubin	int
)	O
DECLARE_RANGE_TABLE_START	O
(	O
wide	O
)	O
DECLARE_RANGE_TABLE_END	O
(	O
wide	O
)	O
DECLARE_RANGE_TABLE_START	O
(	O
fmt	pointer
)	O
DECLARE_RANGE_TABLE_END	O
(	O
fmt	pointer
)	O
static	O
struct	O
wchar_range	struct
comb_table	array
[	O
]	O
=	O
{	O
{	O
0x0644	int
,	O
0x0622	int
}	O
,	O
{	O
0x0644	int
,	O
0x0623	int
}	O
,	O
{	O
0x0644	int
,	O
0x0625	int
}	O
,	O
{	O
0x0644	int
,	O
0x0627	int
}	O
,	O
}	O
;	O
static	O
int	O
is_in_table	function
(	O
ch	long
,	O
table	pointer
)	O
LWCHAR	long
ch	long
;	O
struct	O
wchar_range_table	struct
*	O
table	pointer
;	O
{	O
int	O
hi	int
;	O
int	O
lo	int
;	O
if	O
(	O
ch	long
<	O
table	pointer
->	O
table	pointer
[	O
0	int
]	O
.	O
first	long
)	O
return	O
0	int
;	O
lo	int
=	O
0	int
;	O
hi	int
=	O
table	pointer
->	O
count	int
-	O
1	int
;	O
while	O
(	O
lo	int
<=	O
hi	int
)	O
{	O
int	O
mid	int
=	O
(	O
lo	int
+	O
hi	int
)	O
/	O
2	int
;	O
if	O
(	O
ch	long
>	O
table	pointer
->	O
table	pointer
[	O
mid	int
]	O
.	O
last	long
)	O
lo	int
=	O
mid	int
+	O
1	int
;	O
else	O
if	O
(	O
ch	long
<	O
table	pointer
->	O
table	pointer
[	O
mid	int
]	O
.	O
first	long
)	O
hi	int
=	O
mid	int
-	O
1	int
;	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
public	O
int	O
is_composing_char	function
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
return	O
is_in_table	function
(	O
ch	long
,	O
&	O
compose_table	struct
)	O
||	O
(	O
bs_mode	int
!=	O
BS_CONTROL	int
&&	O
is_in_table	function
(	O
ch	long
,	O
&	O
fmt_table	struct
)	O
)	O
;	O
}	O
public	O
int	O
is_ubin_char	function
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
int	O
ubin	int
=	O
is_in_table	function
(	O
ch	long
,	O
&	O
ubin_table	struct
)	O
||	O
(	O
bs_mode	int
==	O
BS_CONTROL	int
&&	O
is_in_table	function
(	O
ch	long
,	O
&	O
fmt_table	struct
)	O
)	O
;	O
return	O
ubin	int
;	O
}	O
public	O
int	O
is_wide_char	function
(	O
ch	long
)	O
LWCHAR	long
ch	long
;	O
{	O
return	O
is_in_table	function
(	O
ch	long
,	O
&	O
wide_table	struct
)	O
;	O
}	O
public	O
int	O
is_combining_char	function
(	O
ch1	long
,	O
ch2	long
)	O
LWCHAR	long
ch1	long
;	O
LWCHAR	long
ch2	long
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
comb_table	array
)	O
/	O
sizeof	O
(	O
*	O
comb_table	array
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ch1	long
==	O
comb_table	array
[	O
i	int
]	O
.	O
first	long
&&	O
ch2	long
==	O
comb_table	array
[	O
i	int
]	O
.	O
last	long
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
