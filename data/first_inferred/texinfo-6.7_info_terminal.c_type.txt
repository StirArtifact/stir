VFunction	function
*	O
terminal_begin_inverse_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_end_inverse_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_begin_standout_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_end_standout_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_begin_underline_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_end_underline_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_begin_bold_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_begin_blink_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_end_all_modes_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_default_colour_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_set_colour_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_set_bgcolour_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_prep_terminal_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_unprep_terminal_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_up_line_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_down_line_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_clear_screen_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_clear_to_eol_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_get_screen_size_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_goto_xy_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_initialize_terminal_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_new_terminal_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_put_text_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_ring_bell_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_write_chars_hook	pointer
=	O
NULL	O
;	O
VFunction	function
*	O
terminal_scroll_terminal_hook	pointer
=	O
NULL	O
;	O
int	O
mouse_protocol	int
=	O
MP_NONE	int
;	O
static	O
char	O
*	O
term_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
term_string_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
term_name	pointer
;	O
static	O
char	O
*	O
term_goto	pointer
,	O
*	O
term_clreol	pointer
,	O
*	O
term_cr	pointer
,	O
*	O
term_clrpag	pointer
;	O
static	O
char	O
*	O
term_begin_use	pointer
,	O
*	O
term_end_use	pointer
;	O
static	O
char	O
*	O
term_AL	pointer
,	O
*	O
term_DL	pointer
,	O
*	O
term_al	pointer
,	O
*	O
term_dl	pointer
;	O
static	O
char	O
*	O
term_cs	pointer
;	O
static	O
char	O
*	O
term_SF	pointer
,	O
*	O
term_SR	pointer
;	O
static	O
char	O
*	O
term_keypad_on	pointer
,	O
*	O
term_keypad_off	pointer
;	O
static	O
char	O
*	O
term_up	pointer
;	O
static	O
char	O
*	O
term_dn	pointer
;	O
static	O
char	O
*	O
audible_bell	pointer
;	O
static	O
char	O
*	O
visible_bell	pointer
;	O
static	O
char	O
*	O
term_invbeg	pointer
;	O
static	O
char	O
*	O
term_invend	pointer
;	O
static	O
char	O
*	O
term_Km	pointer
;	O
char	O
*	O
term_so	pointer
,	O
*	O
term_se	pointer
;	O
char	O
*	O
term_us	pointer
,	O
*	O
term_ue	pointer
;	O
char	O
*	O
term_AF	pointer
,	O
*	O
term_AB	pointer
;	O
char	O
*	O
term_op	pointer
;	O
char	O
*	O
term_md	pointer
;	O
char	O
*	O
term_mb	pointer
;	O
char	O
*	O
term_me	pointer
;	O
static	O
int	O
output_character_function	function
(	O
int	O
c	int
)	O
{	O
putc	function
(	O
c	int
,	O
stdout	pointer
)	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
terminal_begin_using_terminal	function
(	O
void	O
)	O
{	O
void	O
(	O
*	O
sigsave	pointer
)	O
(	O
int	O
signum	int
)	O
;	O
if	O
(	O
mouse_protocol	int
==	O
MP_NORMAL_TRACKING	int
&&	O
term_Km	pointer
&&	O
!	O
strcmp	function
(	O
term_Km	pointer
,	O
"\033[M"	pointer
)	O
)	O
send_to_terminal	O
(	O
"\033[?1000h"	pointer
)	O
;	O
else	O
term_Km	pointer
=	O
0	int
;	O
if	O
(	O
term_keypad_on	pointer
)	O
send_to_terminal	O
(	O
term_keypad_on	pointer
)	O
;	O
if	O
(	O
!	O
term_begin_use	pointer
||	O
!	O
*	O
term_begin_use	pointer
)	O
return	O
;	O
sigsave	pointer
=	O
signal	function
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
send_to_terminal	O
(	O
term_begin_use	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
STREQ	O
(	O
term_name	pointer
,	O
"sun-cmd"	pointer
)	O
)	O
sleep	function
(	O
1	int
)	O
;	O
signal	function
(	O
SIGWINCH	int
,	O
sigsave	pointer
)	O
;	O
}	O
static	O
void	O
terminal_end_using_terminal	function
(	O
void	O
)	O
{	O
void	O
(	O
*	O
sigsave	pointer
)	O
(	O
int	O
signum	int
)	O
;	O
if	O
(	O
term_Km	pointer
)	O
send_to_terminal	O
(	O
"\033[?1000l"	pointer
)	O
;	O
if	O
(	O
term_keypad_off	pointer
)	O
send_to_terminal	O
(	O
term_keypad_off	pointer
)	O
;	O
if	O
(	O
!	O
term_end_use	pointer
||	O
!	O
*	O
term_end_use	pointer
)	O
return	O
;	O
sigsave	pointer
=	O
signal	function
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
send_to_terminal	O
(	O
term_end_use	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
STREQ	O
(	O
term_name	pointer
,	O
"sun-cmd"	pointer
)	O
)	O
sleep	function
(	O
1	int
)	O
;	O
signal	function
(	O
SIGWINCH	int
,	O
sigsave	pointer
)	O
;	O
}	O
int	O
screenwidth	int
,	O
screenheight	int
;	O
int	O
terminal_is_dumb_p	int
=	O
0	int
;	O
int	O
terminal_has_visible_bell_p	int
=	O
0	int
;	O
int	O
terminal_use_visible_bell_p	int
=	O
0	int
;	O
int	O
terminal_can_scroll	int
=	O
0	int
;	O
int	O
terminal_can_scroll_region	int
=	O
0	int
;	O
char	O
*	O
term_ku	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kd	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kr	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kl	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kP	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kN	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kh	pointer
=	O
NULL	O
;	O
char	O
*	O
term_ke	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kD	pointer
=	O
NULL	O
;	O
char	O
*	O
term_ki	pointer
=	O
NULL	O
;	O
char	O
*	O
term_kB	pointer
=	O
NULL	O
;	O
void	O
terminal_goto_xy	function
(	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
if	O
(	O
terminal_goto_xy_hook	pointer
)	O
(	O
*	O
terminal_goto_xy_hook	pointer
)	O
(	O
x	int
,	O
y	int
)	O
;	O
else	O
{	O
if	O
(	O
term_goto	pointer
)	O
tputs	function
(	O
tgoto	function
(	O
term_goto	pointer
,	O
x	int
,	O
y	int
)	O
,	O
1	int
,	O
output_character_function	function
)	O
;	O
}	O
}	O
void	O
terminal_put_text	function
(	O
char	O
*	O
string	pointer
)	O
{	O
if	O
(	O
terminal_put_text_hook	pointer
)	O
(	O
*	O
terminal_put_text_hook	pointer
)	O
(	O
string	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
"%s"	pointer
,	O
string	pointer
)	O
;	O
}	O
}	O
void	O
terminal_write_chars	function
(	O
char	O
*	O
string	pointer
,	O
int	O
nchars	int
)	O
{	O
if	O
(	O
terminal_write_chars_hook	pointer
)	O
(	O
*	O
terminal_write_chars_hook	pointer
)	O
(	O
string	pointer
,	O
nchars	int
)	O
;	O
else	O
{	O
if	O
(	O
nchars	int
)	O
fwrite	function
(	O
string	pointer
,	O
1	int
,	O
nchars	int
,	O
stdout	pointer
)	O
;	O
}	O
}	O
void	O
terminal_clear_to_eol	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_clear_to_eol_hook	pointer
)	O
(	O
*	O
terminal_clear_to_eol_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_clreol	pointer
)	O
;	O
}	O
}	O
void	O
terminal_clear_screen	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_clear_screen_hook	pointer
)	O
(	O
*	O
terminal_clear_screen_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_clrpag	pointer
)	O
;	O
}	O
}	O
void	O
terminal_up_line	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_up_line_hook	pointer
)	O
(	O
*	O
terminal_up_line_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_up	pointer
)	O
;	O
}	O
}	O
void	O
terminal_down_line	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_down_line_hook	pointer
)	O
(	O
*	O
terminal_down_line_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_dn	pointer
)	O
;	O
}	O
}	O
void	O
terminal_begin_inverse	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_inverse_hook	pointer
)	O
(	O
*	O
terminal_begin_inverse_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_invbeg	pointer
)	O
;	O
}	O
}	O
void	O
terminal_end_inverse	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_inverse_hook	pointer
)	O
(	O
*	O
terminal_end_inverse_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_invend	pointer
)	O
;	O
}	O
}	O
void	O
terminal_begin_standout	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_standout_hook	pointer
)	O
(	O
*	O
terminal_begin_standout_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_so	pointer
)	O
;	O
}	O
}	O
void	O
terminal_end_standout	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_standout_hook	pointer
)	O
(	O
*	O
terminal_end_standout_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_se	pointer
)	O
;	O
}	O
}	O
void	O
terminal_begin_underline	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_underline_hook	pointer
)	O
(	O
*	O
terminal_begin_underline_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_us	pointer
)	O
;	O
}	O
}	O
void	O
terminal_end_underline	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_underline_hook	pointer
)	O
(	O
*	O
terminal_end_underline_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_ue	pointer
)	O
;	O
}	O
}	O
void	O
terminal_begin_bold	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_bold_hook	pointer
)	O
(	O
*	O
terminal_begin_bold_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_md	pointer
)	O
;	O
}	O
}	O
void	O
terminal_begin_blink	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_begin_blink_hook	pointer
)	O
(	O
*	O
terminal_begin_blink_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_mb	pointer
)	O
;	O
}	O
}	O
void	O
terminal_end_all_modes	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_end_all_modes_hook	pointer
)	O
(	O
*	O
terminal_end_all_modes_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
send_to_terminal	O
(	O
term_me	pointer
)	O
;	O
}	O
}	O
void	O
terminal_ring_bell	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_ring_bell_hook	pointer
)	O
(	O
*	O
terminal_ring_bell_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
if	O
(	O
terminal_has_visible_bell_p	int
&&	O
terminal_use_visible_bell_p	int
)	O
send_to_terminal	O
(	O
visible_bell	pointer
)	O
;	O
else	O
send_to_terminal	O
(	O
audible_bell	pointer
)	O
;	O
}	O
}	O
static	O
void	O
terminal_delete_lines	function
(	O
int	O
start	int
,	O
int	O
count	int
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
start	int
<	O
0	int
)	O
start	int
=	O
0	int
;	O
lines	int
=	O
screenheight	int
-	O
start	int
;	O
terminal_goto_xy	function
(	O
0	int
,	O
start	int
)	O
;	O
if	O
(	O
term_DL	pointer
)	O
tputs	function
(	O
tgoto	function
(	O
term_DL	pointer
,	O
0	int
,	O
count	int
)	O
,	O
lines	int
,	O
output_character_function	function
)	O
;	O
else	O
{	O
while	O
(	O
count	int
--	O
)	O
tputs	function
(	O
term_dl	pointer
,	O
lines	int
,	O
output_character_function	function
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
terminal_insert_lines	function
(	O
int	O
start	int
,	O
int	O
count	int
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
start	int
<	O
0	int
)	O
start	int
=	O
0	int
;	O
lines	int
=	O
screenheight	int
-	O
start	int
;	O
terminal_goto_xy	function
(	O
0	int
,	O
start	int
)	O
;	O
if	O
(	O
term_AL	pointer
)	O
tputs	function
(	O
tgoto	function
(	O
term_AL	pointer
,	O
0	int
,	O
count	int
)	O
,	O
lines	int
,	O
output_character_function	function
)	O
;	O
else	O
{	O
while	O
(	O
count	int
--	O
)	O
tputs	function
(	O
term_al	pointer
,	O
lines	int
,	O
output_character_function	function
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
terminal_scroll_region	function
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
amount	int
)	O
{	O
if	O
(	O
amount	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
terminal_scroll_terminal_hook	pointer
)	O
{	O
(	O
*	O
terminal_scroll_terminal_hook	pointer
)	O
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
terminal_can_scroll_region	int
)	O
{	O
tputs	function
(	O
tgoto	function
(	O
term_cs	pointer
,	O
end	int
-	O
1	int
,	O
start	int
)	O
,	O
0	int
,	O
output_character_function	function
)	O
;	O
if	O
(	O
amount	int
>	O
0	int
)	O
tputs	function
(	O
tgoto	function
(	O
term_SR	pointer
,	O
0	int
,	O
amount	int
)	O
,	O
0	int
,	O
output_character_function	function
)	O
;	O
else	O
tputs	function
(	O
tgoto	function
(	O
term_SF	pointer
,	O
0	int
,	O
-	O
amount	int
)	O
,	O
0	int
,	O
output_character_function	function
)	O
;	O
tputs	function
(	O
tgoto	function
(	O
term_cs	pointer
,	O
screenheight	int
-	O
1	int
,	O
0	int
)	O
,	O
0	int
,	O
output_character_function	function
)	O
;	O
return	O
;	O
}	O
}	O
void	O
terminal_scroll_terminal	function
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
amount	int
)	O
{	O
if	O
(	O
!	O
terminal_can_scroll	int
)	O
return	O
;	O
if	O
(	O
amount	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
terminal_scroll_terminal_hook	pointer
)	O
(	O
*	O
terminal_scroll_terminal_hook	pointer
)	O
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
else	O
if	O
(	O
amount	int
>	O
0	int
)	O
{	O
terminal_delete_lines	function
(	O
end	int
,	O
amount	int
)	O
;	O
terminal_insert_lines	function
(	O
start	int
,	O
amount	int
)	O
;	O
}	O
else	O
{	O
int	O
abs_amount	int
=	O
-	O
amount	int
;	O
terminal_delete_lines	function
(	O
start	int
-	O
abs_amount	int
,	O
abs_amount	int
)	O
;	O
terminal_insert_lines	function
(	O
end	int
-	O
abs_amount	int
,	O
abs_amount	int
)	O
;	O
}	O
}	O
static	O
void	O
terminal_default_colour	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_default_colour_hook	pointer
)	O
(	O
*	O
terminal_default_colour_hook	pointer
)	O
(	O
)	O
;	O
else	O
tputs	function
(	O
term_op	pointer
,	O
0	int
,	O
output_character_function	function
)	O
;	O
}	O
static	O
void	O
terminal_set_colour	function
(	O
int	O
colour	int
)	O
{	O
if	O
(	O
terminal_set_colour_hook	pointer
)	O
(	O
*	O
terminal_set_colour_hook	pointer
)	O
(	O
colour	int
)	O
;	O
else	O
tputs	function
(	O
tgoto	function
(	O
term_AF	pointer
,	O
0	int
,	O
colour	int
)	O
,	O
0	int
,	O
output_character_function	function
)	O
;	O
}	O
static	O
void	O
terminal_set_bgcolour	function
(	O
int	O
colour	int
)	O
{	O
if	O
(	O
terminal_set_bgcolour_hook	pointer
)	O
(	O
*	O
terminal_set_bgcolour_hook	pointer
)	O
(	O
colour	int
)	O
;	O
else	O
tputs	function
(	O
tgoto	function
(	O
term_AB	pointer
,	O
0	int
,	O
colour	int
)	O
,	O
0	int
,	O
output_character_function	function
)	O
;	O
}	O
static	O
unsigned	O
long	O
terminal_rendition	long
;	O
void	O
terminal_switch_rendition	function
(	O
unsigned	O
long	O
new	long
)	O
{	O
unsigned	O
long	O
old	long
=	O
terminal_rendition	long
;	O
if	O
(	O
(	O
old	long
&	O
new	long
&	O
COMBINED_MODES	O
)	O
!=	O
(	O
old	long
&	O
COMBINED_MODES	O
)	O
)	O
{	O
terminal_end_all_modes	function
(	O
)	O
;	O
old	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
&&	O
(	O
old	long
&	O
COLOUR_MASK	int
)	O
||	O
!	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
&&	O
(	O
old	long
&	O
BGCOLOUR_MASK	int
)	O
)	O
{	O
terminal_default_colour	function
(	O
)	O
;	O
old	long
&=	O
~	O
(	O
COLOUR_MASK	int
|	O
BGCOLOUR_MASK	int
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
!=	O
(	O
old	long
&	O
COLOUR_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
>=	O
8	int
)	O
{	O
terminal_set_colour	function
(	O
(	O
new	long
&	O
COLOUR_MASK	int
)	O
-	O
8	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
!=	O
(	O
old	long
&	O
BGCOLOUR_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
>>	O
9	int
>=	O
8	int
)	O
{	O
terminal_set_bgcolour	function
(	O
(	O
(	O
new	long
&	O
BGCOLOUR_MASK	int
)	O
>>	O
9	int
)	O
-	O
8	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
new	long
&	O
UNDERLINE_MASK	int
)	O
!=	O
(	O
old	long
&	O
UNDERLINE_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
UNDERLINE_MASK	int
)	O
)	O
terminal_begin_underline	function
(	O
)	O
;	O
else	O
terminal_end_underline	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
STANDOUT_MASK	int
)	O
!=	O
(	O
old	long
&	O
STANDOUT_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
STANDOUT_MASK	int
)	O
)	O
terminal_begin_standout	function
(	O
)	O
;	O
else	O
terminal_end_standout	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
BOLD_MASK	int
)	O
!=	O
(	O
old	long
&	O
BOLD_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
BOLD_MASK	int
)	O
)	O
terminal_begin_bold	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
new	long
&	O
BLINK_MASK	int
)	O
!=	O
(	O
old	long
&	O
BLINK_MASK	int
)	O
)	O
{	O
if	O
(	O
(	O
new	long
&	O
BLINK_MASK	int
)	O
)	O
terminal_begin_blink	function
(	O
)	O
;	O
}	O
terminal_rendition	long
=	O
new	long
;	O
}	O
void	O
terminal_new_terminal	function
(	O
char	O
*	O
terminal_name	pointer
)	O
{	O
if	O
(	O
terminal_new_terminal_hook	pointer
)	O
(	O
*	O
terminal_new_terminal_hook	pointer
)	O
(	O
terminal_name	pointer
)	O
;	O
else	O
{	O
terminal_initialize_terminal	function
(	O
terminal_name	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
env_lines	pointer
,	O
*	O
env_columns	pointer
;	O
void	O
terminal_get_screen_size	function
(	O
void	O
)	O
{	O
if	O
(	O
terminal_get_screen_size_hook	pointer
)	O
(	O
*	O
terminal_get_screen_size_hook	pointer
)	O
(	O
)	O
;	O
else	O
{	O
screenwidth	int
=	O
screenheight	int
=	O
0	int
;	O
{	O
struct	O
winsize	struct
window_size	struct
;	O
if	O
(	O
ioctl	function
(	O
fileno	function
(	O
stdout	pointer
)	O
,	O
TIOCGWINSZ	int
,	O
&	O
window_size	struct
)	O
==	O
0	int
)	O
{	O
screenwidth	int
=	O
(	O
int	O
)	O
window_size	struct
.	O
ws_col	short
;	O
screenheight	int
=	O
(	O
int	O
)	O
window_size	struct
.	O
ws_row	short
;	O
}	O
}	O
if	O
(	O
screenwidth	int
<=	O
0	int
)	O
{	O
if	O
(	O
env_columns	pointer
)	O
screenwidth	int
=	O
atoi	function
(	O
env_columns	pointer
)	O
;	O
if	O
(	O
screenwidth	int
<=	O
0	int
)	O
screenwidth	int
=	O
tgetnum	function
(	O
"co"	pointer
)	O
;	O
}	O
if	O
(	O
screenheight	int
<=	O
0	int
)	O
{	O
if	O
(	O
env_lines	pointer
)	O
screenheight	int
=	O
atoi	function
(	O
env_lines	pointer
)	O
;	O
if	O
(	O
screenheight	int
<=	O
0	int
)	O
screenheight	int
=	O
tgetnum	function
(	O
"li"	pointer
)	O
;	O
}	O
if	O
(	O
screenwidth	int
<=	O
0	int
)	O
screenwidth	int
=	O
80	int
;	O
if	O
(	O
screenheight	int
<=	O
0	int
)	O
screenheight	int
=	O
24	int
;	O
}	O
}	O
BYTEMAP_ENTRY	struct
*	O
byte_seq_to_key	pointer
;	O
static	O
void	O
add_seq_to_byte_map	function
(	O
int	O
key_id	int
,	O
char	O
*	O
seq	pointer
)	O
{	O
BYTEMAP_ENTRY	struct
*	O
b	pointer
=	O
byte_seq_to_key	pointer
;	O
unsigned	O
char	O
*	O
c	int
=	O
(	O
unsigned	O
char	O
*	O
)	O
seq	pointer
;	O
for	O
(	O
;	O
*	O
c	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
b	pointer
[	O
*	O
c	int
]	O
.	O
type	enum
=	O
BYTEMAP_KEY	int
;	O
b	pointer
[	O
*	O
c	int
]	O
.	O
key	int
=	O
key_id	int
;	O
}	O
else	O
{	O
b	pointer
[	O
*	O
c	int
]	O
.	O
type	enum
=	O
BYTEMAP_MAP	int
;	O
b	pointer
[	O
*	O
c	int
]	O
.	O
key	int
=	O
0	int
;	O
if	O
(	O
!	O
b	pointer
[	O
*	O
c	int
]	O
.	O
next	pointer
)	O
b	pointer
[	O
*	O
c	int
]	O
.	O
next	pointer
=	O
xzalloc	function
(	O
256	int
*	O
sizeof	O
(	O
BYTEMAP_ENTRY	struct
)	O
)	O
;	O
b	pointer
=	O
b	pointer
[	O
*	O
c	int
]	O
.	O
next	pointer
;	O
}	O
}	O
}	O
int	O
ISO_Latin_p	int
=	O
1	int
;	O
static	O
void	O
initialize_byte_map	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
static	O
struct	O
special_keys	struct
{	O
int	O
key_id	int
;	O
char	O
*	O
*	O
byte_seq	pointer
;	O
}	O
keys	pointer
[	O
]	O
=	O
{	O
KEY_RIGHT_ARROW	int
,	O
&	O
term_kr	pointer
,	O
KEY_LEFT_ARROW	int
,	O
&	O
term_kl	pointer
,	O
KEY_UP_ARROW	int
,	O
&	O
term_ku	pointer
,	O
KEY_DOWN_ARROW	int
,	O
&	O
term_kd	pointer
,	O
KEY_PAGE_UP	int
,	O
&	O
term_kP	pointer
,	O
KEY_PAGE_DOWN	int
,	O
&	O
term_kN	pointer
,	O
KEY_HOME	int
,	O
&	O
term_kh	pointer
,	O
KEY_END	int
,	O
&	O
term_ke	pointer
,	O
KEY_DELETE	int
,	O
&	O
term_kD	pointer
,	O
KEY_INSERT	int
,	O
&	O
term_ki	pointer
,	O
KEY_BACK_TAB	int
,	O
&	O
term_kB	pointer
}	O
;	O
static	O
struct	O
special_keys2	struct
{	O
int	O
key_id	int
;	O
char	O
*	O
byte_seq	pointer
;	O
}	O
keys2	array
[	O
]	O
=	O
{	O
KEY_RIGHT_ARROW	int
,	O
"\033[C"	pointer
,	O
KEY_RIGHT_ARROW	int
,	O
"\033OC"	pointer
,	O
KEY_LEFT_ARROW	int
,	O
"\033[D"	pointer
,	O
KEY_LEFT_ARROW	int
,	O
"\033OD"	pointer
,	O
KEY_UP_ARROW	int
,	O
"\033[A"	pointer
,	O
KEY_UP_ARROW	int
,	O
"\033OA"	pointer
,	O
KEY_DOWN_ARROW	int
,	O
"\033[B"	pointer
,	O
KEY_DOWN_ARROW	int
,	O
"\033OB"	pointer
}	O
;	O
byte_seq_to_key	pointer
=	O
xmalloc	function
(	O
256	int
*	O
sizeof	O
(	O
BYTEMAP_ENTRY	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
128	int
;	O
i	int
++	O
)	O
{	O
byte_seq_to_key	pointer
[	O
i	int
]	O
.	O
type	enum
=	O
BYTEMAP_KEY	int
;	O
byte_seq_to_key	pointer
[	O
i	int
]	O
.	O
key	int
=	O
i	int
;	O
byte_seq_to_key	pointer
[	O
i	int
]	O
.	O
next	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
ISO_Latin_p	int
)	O
for	O
(	O
i	int
=	O
128	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
{	O
byte_seq_to_key	pointer
[	O
i	int
]	O
.	O
type	enum
=	O
BYTEMAP_KEY	int
;	O
byte_seq_to_key	pointer
[	O
i	int
]	O
.	O
key	int
=	O
(	O
i	int
-	O
128	int
)	O
+	O
KEYMAP_META_BASE	int
;	O
byte_seq_to_key	pointer
[	O
i	int
]	O
.	O
next	pointer
=	O
0	int
;	O
}	O
byte_seq_to_key	pointer
[	O
'\177'	O
]	O
.	O
type	enum
=	O
BYTEMAP_KEY	int
;	O
byte_seq_to_key	pointer
[	O
'\177'	O
]	O
.	O
key	int
=	O
KEY_DELETE	int
;	O
byte_seq_to_key	pointer
[	O
'\177'	O
]	O
.	O
next	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
keys	pointer
)	O
/	O
sizeof	O
(	O
*	O
keys	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
*	O
keys	pointer
[	O
i	int
]	O
.	O
byte_seq	pointer
)	O
continue	O
;	O
add_seq_to_byte_map	function
(	O
keys	pointer
[	O
i	int
]	O
.	O
key_id	int
,	O
*	O
keys	pointer
[	O
i	int
]	O
.	O
byte_seq	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
keys2	array
)	O
/	O
sizeof	O
(	O
*	O
keys2	array
)	O
;	O
i	int
++	O
)	O
{	O
add_seq_to_byte_map	function
(	O
keys2	array
[	O
i	int
]	O
.	O
key_id	int
,	O
keys2	array
[	O
i	int
]	O
.	O
byte_seq	pointer
)	O
;	O
}	O
if	O
(	O
term_Km	pointer
)	O
add_seq_to_byte_map	function
(	O
KEY_MOUSE	int
,	O
term_Km	pointer
)	O
;	O
byte_seq_to_key	pointer
[	O
'\033'	O
]	O
.	O
type	enum
=	O
BYTEMAP_ESC	int
;	O
}	O
void	O
terminal_initialize_terminal	function
(	O
char	O
*	O
terminal_name	pointer
)	O
{	O
char	O
*	O
buffer	pointer
;	O
terminal_is_dumb_p	int
=	O
0	int
;	O
if	O
(	O
terminal_initialize_terminal_hook	pointer
)	O
{	O
(	O
*	O
terminal_initialize_terminal_hook	pointer
)	O
(	O
terminal_name	pointer
)	O
;	O
initialize_byte_map	function
(	O
)	O
;	O
return	O
;	O
}	O
term_name	pointer
=	O
terminal_name	pointer
?	O
terminal_name	pointer
:	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
if	O
(	O
!	O
term_name	pointer
)	O
term_name	pointer
=	O
"dumb"	pointer
;	O
env_lines	pointer
=	O
getenv	function
(	O
"LINES"	pointer
)	O
;	O
env_columns	pointer
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
;	O
if	O
(	O
!	O
term_string_buffer	pointer
)	O
term_string_buffer	pointer
=	O
xmalloc	function
(	O
2048	int
)	O
;	O
if	O
(	O
!	O
term_buffer	pointer
)	O
term_buffer	pointer
=	O
xmalloc	function
(	O
2048	int
)	O
;	O
buffer	pointer
=	O
term_string_buffer	pointer
;	O
term_clrpag	pointer
=	O
term_cr	pointer
=	O
term_clreol	pointer
=	O
NULL	O
;	O
if	O
(	O
tgetent	function
(	O
term_buffer	pointer
,	O
term_name	pointer
)	O
<	O
0	int
)	O
{	O
terminal_is_dumb_p	int
=	O
1	int
;	O
screenwidth	int
=	O
80	int
;	O
screenheight	int
=	O
24	int
;	O
term_cr	pointer
=	O
"\r"	pointer
;	O
term_up	pointer
=	O
term_dn	pointer
=	O
audible_bell	pointer
=	O
visible_bell	pointer
=	O
NULL	O
;	O
term_ku	pointer
=	O
term_kd	pointer
=	O
term_kl	pointer
=	O
term_kr	pointer
=	O
NULL	O
;	O
term_kP	pointer
=	O
term_kN	pointer
=	O
NULL	O
;	O
term_kh	pointer
=	O
term_ke	pointer
=	O
NULL	O
;	O
term_kD	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
BC	pointer
=	O
tgetstr	function
(	O
"pc"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
PC	char
=	O
BC	pointer
?	O
*	O
BC	pointer
:	O
0	int
;	O
{	O
struct	O
termios	struct
ti	struct
;	O
if	O
(	O
tcgetattr	function
(	O
fileno	function
(	O
stdout	pointer
)	O
,	O
&	O
ti	struct
)	O
!=	O
-	O
1	int
)	O
ospeed	short
=	O
cfgetospeed	function
(	O
&	O
ti	struct
)	O
;	O
else	O
ospeed	short
=	O
B9600	int
;	O
}	O
term_cr	pointer
=	O
tgetstr	function
(	O
"cr"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_clreol	pointer
=	O
tgetstr	function
(	O
"ce"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_clrpag	pointer
=	O
tgetstr	function
(	O
"cl"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_goto	pointer
=	O
tgetstr	function
(	O
"cm"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_AL	pointer
=	O
tgetstr	function
(	O
"AL"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_DL	pointer
=	O
tgetstr	function
(	O
"DL"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_al	pointer
=	O
tgetstr	function
(	O
"al"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_dl	pointer
=	O
tgetstr	function
(	O
"dl"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_cs	pointer
=	O
tgetstr	function
(	O
"cs"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_SF	pointer
=	O
tgetstr	function
(	O
"SF"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_SR	pointer
=	O
tgetstr	function
(	O
"SR"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
terminal_can_scroll	int
=	O
(	O
(	O
term_AL	pointer
||	O
term_al	pointer
)	O
&&	O
(	O
term_DL	pointer
||	O
term_dl	pointer
)	O
)	O
;	O
terminal_can_scroll_region	int
=	O
term_cs	pointer
&&	O
term_SF	pointer
&&	O
term_SR	pointer
;	O
term_invbeg	pointer
=	O
tgetstr	function
(	O
"mr"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
term_invbeg	pointer
)	O
term_invend	pointer
=	O
tgetstr	function
(	O
"me"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
else	O
term_invend	pointer
=	O
NULL	O
;	O
term_so	pointer
=	O
tgetstr	function
(	O
"so"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
term_so	pointer
)	O
term_se	pointer
=	O
tgetstr	function
(	O
"se"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
else	O
term_se	pointer
=	O
NULL	O
;	O
term_us	pointer
=	O
tgetstr	function
(	O
"us"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
term_us	pointer
)	O
term_ue	pointer
=	O
tgetstr	function
(	O
"ue"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
else	O
term_ue	pointer
=	O
NULL	O
;	O
term_AF	pointer
=	O
tgetstr	function
(	O
"AF"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
term_AF	pointer
)	O
term_AB	pointer
=	O
tgetstr	function
(	O
"AB"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
else	O
term_AB	pointer
=	O
NULL	O
;	O
term_op	pointer
=	O
tgetstr	function
(	O
"op"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_md	pointer
=	O
tgetstr	function
(	O
"md"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_mb	pointer
=	O
tgetstr	function
(	O
"mb"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_me	pointer
=	O
tgetstr	function
(	O
"me"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
!	O
term_me	pointer
)	O
term_md	pointer
=	O
0	int
;	O
if	O
(	O
!	O
term_cr	pointer
)	O
term_cr	pointer
=	O
"\r"	pointer
;	O
terminal_get_screen_size	function
(	O
)	O
;	O
term_up	pointer
=	O
tgetstr	function
(	O
"up"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_dn	pointer
=	O
tgetstr	function
(	O
"dn"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
visible_bell	pointer
=	O
tgetstr	function
(	O
"vb"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
terminal_has_visible_bell_p	int
=	O
(	O
visible_bell	pointer
!=	O
NULL	O
)	O
;	O
audible_bell	pointer
=	O
tgetstr	function
(	O
"bl"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
!	O
audible_bell	pointer
)	O
audible_bell	pointer
=	O
"\007"	pointer
;	O
term_begin_use	pointer
=	O
tgetstr	function
(	O
"ti"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_end_use	pointer
=	O
tgetstr	function
(	O
"te"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_keypad_on	pointer
=	O
tgetstr	function
(	O
"ks"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_keypad_off	pointer
=	O
tgetstr	function
(	O
"ke"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_ku	pointer
=	O
tgetstr	function
(	O
"ku"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kd	pointer
=	O
tgetstr	function
(	O
"kd"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kr	pointer
=	O
tgetstr	function
(	O
"kr"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kl	pointer
=	O
tgetstr	function
(	O
"kl"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kP	pointer
=	O
tgetstr	function
(	O
"kP"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kN	pointer
=	O
tgetstr	function
(	O
"kN"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kh	pointer
=	O
tgetstr	function
(	O
"kh"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_ke	pointer
=	O
tgetstr	function
(	O
"@7"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_ki	pointer
=	O
tgetstr	function
(	O
"kI"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kD	pointer
=	O
tgetstr	function
(	O
"kD"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_kB	pointer
=	O
tgetstr	function
(	O
"kB"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
term_Km	pointer
=	O
tgetstr	function
(	O
"Km"	pointer
,	O
&	O
buffer	pointer
)	O
;	O
initialize_byte_map	function
(	O
)	O
;	O
if	O
(	O
!	O
term_goto	pointer
)	O
terminal_is_dumb_p	int
=	O
1	int
;	O
}	O
struct	O
termios	struct
original_termios	struct
,	O
ttybuff	struct
;	O
int	O
terminal_prep_terminal	function
(	O
void	O
)	O
{	O
int	O
tty	int
;	O
if	O
(	O
terminal_is_dumb_p	int
)	O
return	O
0	int
;	O
if	O
(	O
terminal_prep_terminal_hook	pointer
)	O
{	O
(	O
*	O
terminal_prep_terminal_hook	pointer
)	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
terminal_begin_using_terminal	function
(	O
)	O
;	O
tty	int
=	O
fileno	function
(	O
stdin	pointer
)	O
;	O
tcgetattr	function
(	O
tty	int
,	O
&	O
original_termios	struct
)	O
;	O
tcgetattr	function
(	O
tty	int
,	O
&	O
ttybuff	struct
)	O
;	O
ttybuff	struct
.	O
c_iflag	int
&=	O
(	O
~	O
ISTRIP	int
&	O
~	O
INLCR	int
&	O
~	O
IGNCR	int
&	O
~	O
ICRNL	int
&	O
~	O
IXON	int
)	O
;	O
ttybuff	struct
.	O
c_oflag	int
&=	O
~	O
ONLCR	int
;	O
ttybuff	struct
.	O
c_oflag	int
&=	O
~	O
OCRNL	int
;	O
ttybuff	struct
.	O
c_lflag	int
&=	O
(	O
~	O
ICANON	int
&	O
~	O
ECHO	int
)	O
;	O
ttybuff	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
ttybuff	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
if	O
(	O
ttybuff	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
==	O
'\177'	O
)	O
ttybuff	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ttybuff	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
==	O
'\177'	O
)	O
ttybuff	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ttybuff	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
==	O
'\026'	O
)	O
ttybuff	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
-	O
1	int
;	O
tcsetattr	function
(	O
tty	int
,	O
TCSANOW	int
,	O
&	O
ttybuff	struct
)	O
;	O
tcflow	function
(	O
tty	int
,	O
TCOOFF	int
)	O
;	O
tcflow	function
(	O
tty	int
,	O
TCOON	int
)	O
;	O
return	O
1	int
;	O
}	O
void	O
terminal_unprep_terminal	function
(	O
void	O
)	O
{	O
int	O
tty	int
;	O
if	O
(	O
terminal_unprep_terminal_hook	pointer
)	O
{	O
(	O
*	O
terminal_unprep_terminal_hook	pointer
)	O
(	O
)	O
;	O
return	O
;	O
}	O
tty	int
=	O
fileno	function
(	O
stdin	pointer
)	O
;	O
tcsetattr	function
(	O
tty	int
,	O
TCSANOW	int
,	O
&	O
original_termios	struct
)	O
;	O
terminal_end_using_terminal	function
(	O
)	O
;	O
}	O
