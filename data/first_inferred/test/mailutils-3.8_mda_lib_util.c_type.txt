int	O
exit_code	int
;	O
void	O
mda_close_fds	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
long	O
fdlimit	long
=	O
sysconf	function
(	O
_SC_OPEN_MAX	int
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
fdlimit	long
;	O
i	int
++	O
)	O
close	function
(	O
i	int
)	O
;	O
}	O
int	O
mda_switch_user_id	function
(	O
struct	O
mu_auth_data	struct
*	O
auth	*
,	O
int	O
user	*
)	O
{	O
int	O
rc	int
;	O
uid_t	int
uid	int
;	O
if	O
(	O
!	O
auth	*
||	O
auth	*
->	O
change_uid	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
user	*
)	O
uid	int
=	O
auth	*
->	O
uid	int
;	O
else	O
uid	int
=	O
0	int
;	O
rc	int
=	O
setreuid	function
(	O
0	int
,	O
uid	int
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
mda_error	function
(	O
"setreuid(0, %d): %s (r=%d, e=%d)"	int
,	O
uid	int
,	O
strerror	function
(	O
errno	O
)	O
,	O
getuid	function
(	O
)	O
,	O
geteuid	function
(	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
temp_errors	array
[	O
]	O
=	O
{	O
EAGAIN	int
,	O
EBUSY	int
,	O
EUSERS	int
,	O
ECONNABORTED	int
,	O
ECONNREFUSED	int
,	O
ECONNRESET	int
,	O
EDEADLK	int
,	O
EDEADLOCK	int
,	O
EFBIG	int
,	O
EHOSTDOWN	int
,	O
EHOSTUNREACH	int
,	O
EMFILE	int
,	O
ENETDOWN	int
,	O
ENETUNREACH	int
,	O
ENETRESET	int
,	O
ENFILE	int
,	O
ENOBUFS	int
,	O
ENOMEM	int
,	O
ENOSPC	int
,	O
EROFS	int
,	O
ESTALE	int
,	O
ETIMEDOUT	int
,	O
EWOULDBLOCK	O
,	O
}	O
;	O
static	O
void	O
guess_retval	function
(	O
int	O
ec	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
exit_code	int
==	O
EX_TEMPFAIL	int
)	O
return	O
;	O
if	O
(	O
ec	int
==	O
EDQUOT	int
)	O
{	O
exit_code	int
=	O
EX_QUOTA	int
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
temp_errors	array
)	O
/	O
sizeof	O
(	O
temp_errors	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
temp_errors	array
[	O
i	int
]	O
==	O
ec	int
)	O
{	O
exit_code	int
=	O
EX_TEMPFAIL	int
;	O
return	O
;	O
}	O
exit_code	int
=	O
EX_UNAVAILABLE	int
;	O
}	O
void	O
mda_error	function
(	O
const	O
char	O
*	O
fmt	*
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
guess_retval	function
(	O
errno	O
)	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	*
)	O
;	O
mu_verror	function
(	O
fmt	*
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
static	O
struct	O
mu_cli_capa	struct
mda_cli_capa	array
[	O
]	O
=	O
{	O
{	O
"forward"	*
,	O
NULL	O
,	O
mda_forward_cfg	O
}	O
,	O
{	O
"deliver"	*
,	O
mda_deliver_options	*
,	O
mda_deliver_cfg	int
}	O
,	O
{	O
"quota"	*
,	O
NULL	O
,	O
mda_mailquota_cfg	int
}	O
,	O
{	O
"script"	*
,	O
mda_script_options	*
,	O
mda_script_cfg	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mda_cli_capa_init	function
(	O
void	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
mda_cli_capa	array
[	O
i	long
]	O
.	O
name	*
;	O
i	long
++	O
)	O
mu_cli_capa_register	function
(	O
&	O
mda_cli_capa	array
[	O
i	int
]	O
)	O
;	O
}	O