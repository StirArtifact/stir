static	O
int	O
rl_digit_loop	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
_rl_history_set_point	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
void	O
_rl_free_history_entry	function
PARAMS	O
(	O
(	O
HIST_ENTRY	struct
*	O
)	O
)	O
;	O
int	O
_rl_history_preserve_point	int
=	O
0	int
;	O
_rl_arg_cxt	int
_rl_argcxt	int
;	O
int	O
_rl_history_saved_point	int
=	O
-	O
1	int
;	O
int	O
_rl_arg_overflow	function
(	O
)	O
{	O
if	O
(	O
rl_numeric_arg	int
>	O
1000000	int
)	O
{	O
_rl_argcxt	int
=	O
0	int
;	O
rl_explicit_arg	int
=	O
rl_numeric_arg	int
=	O
0	int
;	O
rl_ding	function
(	O
)	O
;	O
rl_restore_prompt	function
(	O
)	O
;	O
rl_clear_message	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
_rl_arg_init	function
(	O
)	O
{	O
rl_save_prompt	function
(	O
)	O
;	O
_rl_argcxt	int
=	O
0	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
}	O
int	O
_rl_arg_getchar	function
(	O
)	O
{	O
int	O
c	int
;	O
rl_message	function
(	O
"(arg: %d) "	pointer
,	O
rl_arg_sign	int
*	O
rl_numeric_arg	int
)	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
return	O
c	int
;	O
}	O
int	O
_rl_arg_dispatch	function
(	O
cxt	int
,	O
c	int
)	O
_rl_arg_cxt	int
cxt	int
;	O
int	O
c	int
;	O
{	O
int	O
key	int
,	O
r	int
;	O
key	int
=	O
c	int
;	O
if	O
(	O
c	int
>=	O
0	int
&&	O
_rl_keymap	pointer
[	O
c	int
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
_rl_keymap	pointer
[	O
c	int
]	O
.	O
function	pointer
==	O
rl_universal_argument	function
)	O
{	O
if	O
(	O
(	O
cxt	int
&	O
NUM_SAWDIGITS	int
)	O
==	O
0	int
)	O
{	O
rl_numeric_arg	int
*=	O
4	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_argcxt	int
|=	O
NUM_READONE	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
key	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
rl_restore_prompt	function
(	O
)	O
;	O
rl_clear_message	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
if	O
(	O
key	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
(	O
_rl_dispatch	function
(	O
key	int
,	O
_rl_keymap	pointer
)	O
)	O
;	O
}	O
}	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
if	O
(	O
_rl_digit_p	function
(	O
c	int
)	O
)	O
{	O
r	int
=	O
_rl_digit_value	function
(	O
c	int
)	O
;	O
rl_numeric_arg	int
=	O
rl_explicit_arg	int
?	O
(	O
rl_numeric_arg	int
*	O
10	int
)	O
+	O
r	int
:	O
r	int
;	O
rl_explicit_arg	int
=	O
1	int
;	O
_rl_argcxt	int
|=	O
NUM_SAWDIGITS	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'-'	O
&&	O
rl_explicit_arg	int
==	O
0	int
)	O
{	O
rl_numeric_arg	int
=	O
1	int
;	O
_rl_argcxt	int
|=	O
NUM_SAWMINUS	int
;	O
rl_arg_sign	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
_rl_argcxt	int
&	O
NUM_SAWMINUS	int
)	O
&&	O
rl_numeric_arg	int
==	O
1	int
&&	O
rl_explicit_arg	int
==	O
0	int
)	O
rl_explicit_arg	int
=	O
1	int
;	O
rl_restore_prompt	function
(	O
)	O
;	O
rl_clear_message	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
r	int
=	O
_rl_dispatch	function
(	O
key	int
,	O
_rl_keymap	pointer
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
if	O
(	O
rl_done	int
==	O
0	int
)	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
r	int
=	O
0	int
;	O
}	O
return	O
r	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
rl_digit_loop	function
(	O
)	O
{	O
int	O
c	int
,	O
r	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
_rl_arg_overflow	function
(	O
)	O
)	O
return	O
1	int
;	O
c	int
=	O
_rl_arg_getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
_rl_abort_internal	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	int
=	O
_rl_arg_dispatch	function
(	O
_rl_argcxt	int
,	O
c	int
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
||	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
}	O
return	O
r	int
;	O
}	O
void	O
_rl_reset_argument	function
(	O
)	O
{	O
rl_numeric_arg	int
=	O
rl_arg_sign	int
=	O
1	int
;	O
rl_explicit_arg	int
=	O
0	int
;	O
_rl_argcxt	int
=	O
0	int
;	O
}	O
int	O
rl_digit_argument	function
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
_rl_arg_init	function
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_arg_dispatch	function
(	O
_rl_argcxt	int
,	O
key	int
)	O
;	O
rl_message	function
(	O
"(arg: %d) "	pointer
,	O
rl_arg_sign	int
*	O
rl_numeric_arg	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
rl_execute_next	function
(	O
key	int
)	O
;	O
return	O
(	O
rl_digit_loop	function
(	O
)	O
)	O
;	O
}	O
}	O
int	O
rl_universal_argument	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_arg_init	function
(	O
)	O
;	O
rl_numeric_arg	int
*=	O
4	int
;	O
return	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
?	O
0	int
:	O
rl_digit_loop	function
(	O
)	O
)	O
;	O
}	O
int	O
_rl_arg_callback	function
(	O
cxt	int
)	O
_rl_arg_cxt	int
cxt	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
c	int
=	O
_rl_arg_getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
_rl_argcxt	int
&	O
NUM_READONE	int
)	O
{	O
_rl_argcxt	int
&=	O
~	O
NUM_READONE	int
;	O
rl_restore_prompt	function
(	O
)	O
;	O
rl_clear_message	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
rl_execute_next	function
(	O
c	int
)	O
;	O
return	O
0	int
;	O
}	O
r	int
=	O
_rl_arg_dispatch	function
(	O
cxt	int
,	O
c	int
)	O
;	O
return	O
(	O
r	int
!=	O
1	int
)	O
;	O
}	O
int	O
rl_discard_argument	function
(	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
rl_clear_message	function
(	O
)	O
;	O
_rl_reset_argument	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
HIST_ENTRY	struct
*	O
_rl_saved_line_for_history	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
NULL	O
;	O
void	O
_rl_start_using_history	function
(	O
)	O
{	O
using_history	function
(	O
)	O
;	O
if	O
(	O
_rl_saved_line_for_history	pointer
)	O
_rl_free_history_entry	function
(	O
_rl_saved_line_for_history	pointer
)	O
;	O
_rl_saved_line_for_history	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
NULL	O
;	O
}	O
void	O
_rl_free_history_entry	function
(	O
entry	pointer
)	O
HIST_ENTRY	struct
*	O
entry	pointer
;	O
{	O
if	O
(	O
entry	pointer
==	O
0	int
)	O
return	O
;	O
FREE	O
(	O
entry	pointer
->	O
line	pointer
)	O
;	O
FREE	O
(	O
entry	pointer
->	O
timestamp	pointer
)	O
;	O
xfree	function
(	O
entry	pointer
)	O
;	O
}	O
int	O
rl_maybe_replace_line	function
(	O
)	O
{	O
HIST_ENTRY	struct
*	O
temp	pointer
;	O
temp	pointer
=	O
current_history	function
(	O
)	O
;	O
if	O
(	O
temp	pointer
&&	O
(	O
(	O
UNDO_LIST	struct
*	O
)	O
(	O
temp	pointer
->	O
data	pointer
)	O
!=	O
rl_undo_list	pointer
)	O
)	O
{	O
temp	pointer
=	O
replace_history_entry	function
(	O
where_history	function
(	O
)	O
,	O
rl_line_buffer	pointer
,	O
(	O
histdata_t	pointer
)	O
rl_undo_list	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
->	O
line	pointer
)	O
;	O
FREE	O
(	O
temp	pointer
->	O
timestamp	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_maybe_unsave_line	function
(	O
)	O
{	O
if	O
(	O
_rl_saved_line_for_history	pointer
)	O
{	O
rl_replace_line	function
(	O
_rl_saved_line_for_history	pointer
->	O
line	pointer
,	O
0	int
)	O
;	O
rl_undo_list	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
_rl_saved_line_for_history	pointer
->	O
data	pointer
;	O
_rl_free_history_entry	function
(	O
_rl_saved_line_for_history	pointer
)	O
;	O
_rl_saved_line_for_history	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
NULL	O
;	O
rl_point	int
=	O
rl_end	int
;	O
}	O
else	O
rl_ding	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_maybe_save_line	function
(	O
)	O
{	O
if	O
(	O
_rl_saved_line_for_history	pointer
==	O
0	int
)	O
{	O
_rl_saved_line_for_history	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
HIST_ENTRY	struct
)	O
)	O
;	O
_rl_saved_line_for_history	pointer
->	O
line	pointer
=	O
savestring	O
(	O
rl_line_buffer	pointer
)	O
;	O
_rl_saved_line_for_history	pointer
->	O
timestamp	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
_rl_saved_line_for_history	pointer
->	O
data	pointer
=	O
(	O
char	O
*	O
)	O
rl_undo_list	pointer
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_rl_free_saved_history_line	function
(	O
)	O
{	O
if	O
(	O
_rl_saved_line_for_history	pointer
)	O
{	O
_rl_free_history_entry	function
(	O
_rl_saved_line_for_history	pointer
)	O
;	O
_rl_saved_line_for_history	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
_rl_history_set_point	function
(	O
)	O
{	O
rl_point	int
=	O
(	O
_rl_history_preserve_point	int
&&	O
_rl_history_saved_point	int
!=	O
-	O
1	int
)	O
?	O
_rl_history_saved_point	int
:	O
rl_end	int
;	O
if	O
(	O
rl_point	int
>	O
rl_end	int
)	O
rl_point	int
=	O
rl_end	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
&&	O
_rl_keymap	pointer
!=	O
vi_insertion_keymap	array
)	O
rl_point	int
=	O
0	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
rl_mark	int
=	O
(	O
rl_point	int
==	O
rl_end	int
?	O
0	int
:	O
rl_end	int
)	O
;	O
}	O
void	O
rl_replace_from_history	function
(	O
entry	pointer
,	O
flags	int
)	O
HIST_ENTRY	struct
*	O
entry	pointer
;	O
int	O
flags	int
;	O
{	O
rl_replace_line	function
(	O
entry	pointer
->	O
line	pointer
,	O
0	int
)	O
;	O
rl_undo_list	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
entry	pointer
->	O
data	pointer
;	O
rl_point	int
=	O
rl_end	int
;	O
rl_mark	int
=	O
0	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
{	O
rl_point	int
=	O
0	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
}	O
}	O
void	O
_rl_revert_all_lines	function
(	O
)	O
{	O
int	O
hpos	int
;	O
HIST_ENTRY	struct
*	O
entry	pointer
;	O
UNDO_LIST	struct
*	O
ul	pointer
,	O
*	O
saved_undo_list	pointer
;	O
char	O
*	O
lbuf	pointer
;	O
lbuf	pointer
=	O
savestring	O
(	O
rl_line_buffer	pointer
)	O
;	O
saved_undo_list	pointer
=	O
rl_undo_list	pointer
;	O
hpos	int
=	O
where_history	function
(	O
)	O
;	O
entry	pointer
=	O
(	O
hpos	int
==	O
history_length	int
)	O
?	O
previous_history	function
(	O
)	O
:	O
current_history	function
(	O
)	O
;	O
while	O
(	O
entry	pointer
)	O
{	O
if	O
(	O
ul	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
entry	pointer
->	O
data	pointer
)	O
{	O
if	O
(	O
ul	pointer
==	O
saved_undo_list	pointer
)	O
saved_undo_list	pointer
=	O
0	int
;	O
rl_replace_from_history	function
(	O
entry	pointer
,	O
0	int
)	O
;	O
entry	pointer
->	O
data	pointer
=	O
0	int
;	O
while	O
(	O
rl_undo_list	pointer
)	O
rl_do_undo	function
(	O
)	O
;	O
FREE	O
(	O
entry	pointer
->	O
line	pointer
)	O
;	O
entry	pointer
->	O
line	pointer
=	O
savestring	O
(	O
rl_line_buffer	pointer
)	O
;	O
}	O
entry	pointer
=	O
previous_history	function
(	O
)	O
;	O
}	O
rl_undo_list	pointer
=	O
saved_undo_list	pointer
;	O
history_set_pos	function
(	O
hpos	int
)	O
;	O
rl_replace_line	function
(	O
lbuf	pointer
,	O
0	int
)	O
;	O
_rl_set_the_line	function
(	O
)	O
;	O
xfree	function
(	O
lbuf	pointer
)	O
;	O
}	O
void	O
rl_clear_history	function
(	O
)	O
{	O
HIST_ENTRY	struct
*	O
*	O
hlist	pointer
,	O
*	O
hent	pointer
;	O
register	O
int	O
i	int
;	O
UNDO_LIST	struct
*	O
ul	pointer
,	O
*	O
saved_undo_list	pointer
;	O
saved_undo_list	pointer
=	O
rl_undo_list	pointer
;	O
hlist	pointer
=	O
history_list	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
{	O
hent	pointer
=	O
hlist	pointer
[	O
i	int
]	O
;	O
if	O
(	O
ul	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
hent	pointer
->	O
data	pointer
)	O
{	O
if	O
(	O
ul	pointer
==	O
saved_undo_list	pointer
)	O
saved_undo_list	pointer
=	O
0	int
;	O
_rl_free_undo_list	function
(	O
ul	pointer
)	O
;	O
hent	pointer
->	O
data	pointer
=	O
0	int
;	O
}	O
_rl_free_history_entry	function
(	O
hent	pointer
)	O
;	O
}	O
history_offset	int
=	O
history_length	int
=	O
0	int
;	O
rl_undo_list	pointer
=	O
saved_undo_list	pointer
;	O
}	O
int	O
rl_beginning_of_history	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_get_previous_history	function
(	O
1	int
+	O
where_history	function
(	O
)	O
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_end_of_history	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_maybe_replace_line	function
(	O
)	O
;	O
using_history	function
(	O
)	O
;	O
rl_maybe_unsave_line	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_get_next_history	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
HIST_ENTRY	struct
*	O
temp	pointer
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_get_previous_history	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
rl_maybe_replace_line	function
(	O
)	O
;	O
if	O
(	O
_rl_history_saved_point	int
==	O
-	O
1	int
&&	O
(	O
rl_point	int
||	O
rl_end	int
)	O
)	O
_rl_history_saved_point	int
=	O
(	O
rl_point	int
==	O
rl_end	int
)	O
?	O
-	O
1	int
:	O
rl_point	int
;	O
temp	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
NULL	O
;	O
while	O
(	O
count	int
)	O
{	O
temp	pointer
=	O
next_history	function
(	O
)	O
;	O
if	O
(	O
!	O
temp	pointer
)	O
break	O
;	O
--	O
count	int
;	O
}	O
if	O
(	O
temp	pointer
==	O
0	int
)	O
rl_maybe_unsave_line	function
(	O
)	O
;	O
else	O
{	O
rl_replace_from_history	function
(	O
temp	pointer
,	O
0	int
)	O
;	O
_rl_history_set_point	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_get_previous_history	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
HIST_ENTRY	struct
*	O
old_temp	pointer
,	O
*	O
temp	pointer
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_get_next_history	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
_rl_history_saved_point	int
==	O
-	O
1	int
&&	O
(	O
rl_point	int
||	O
rl_end	int
)	O
)	O
_rl_history_saved_point	int
=	O
(	O
rl_point	int
==	O
rl_end	int
)	O
?	O
-	O
1	int
:	O
rl_point	int
;	O
rl_maybe_save_line	function
(	O
)	O
;	O
rl_maybe_replace_line	function
(	O
)	O
;	O
temp	pointer
=	O
old_temp	pointer
=	O
(	O
HIST_ENTRY	struct
*	O
)	O
NULL	O
;	O
while	O
(	O
count	int
)	O
{	O
temp	pointer
=	O
previous_history	function
(	O
)	O
;	O
if	O
(	O
temp	pointer
==	O
0	int
)	O
break	O
;	O
old_temp	pointer
=	O
temp	pointer
;	O
--	O
count	int
;	O
}	O
if	O
(	O
!	O
temp	pointer
&&	O
old_temp	pointer
)	O
temp	pointer
=	O
old_temp	pointer
;	O
if	O
(	O
temp	pointer
==	O
0	int
)	O
rl_ding	function
(	O
)	O
;	O
else	O
{	O
rl_replace_from_history	function
(	O
temp	pointer
,	O
0	int
)	O
;	O
_rl_history_set_point	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_vi_editing_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_set_insert_mode	function
(	O
RL_IM_INSERT	int
,	O
1	int
)	O
;	O
rl_editing_mode	int
=	O
vi_mode	int
;	O
rl_vi_insert_mode	function
(	O
1	int
,	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_emacs_editing_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_editing_mode	int
=	O
emacs_mode	int
;	O
_rl_set_insert_mode	function
(	O
RL_IM_INSERT	int
,	O
1	int
)	O
;	O
_rl_keymap	pointer
=	O
emacs_standard_keymap	array
;	O
if	O
(	O
_rl_show_mode_in_prompt	int
)	O
_rl_reset_prompt	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
_rl_set_insert_mode	function
(	O
im	int
,	O
force	int
)	O
int	O
im	int
,	O
force	int
;	O
{	O
rl_insert_mode	int
=	O
im	int
;	O
}	O
int	O
rl_overwrite_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
==	O
0	int
)	O
_rl_set_insert_mode	function
(	O
rl_insert_mode	int
^	O
1	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
count	int
>	O
0	int
)	O
_rl_set_insert_mode	function
(	O
RL_IM_OVERWRITE	int
,	O
0	int
)	O
;	O
else	O
_rl_set_insert_mode	function
(	O
RL_IM_INSERT	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O