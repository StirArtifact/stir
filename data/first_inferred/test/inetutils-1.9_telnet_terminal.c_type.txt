Ring	struct
ttyoring	struct
,	O
ttyiring	pointer
;	O
unsigned	O
char	O
ttyobuf	array
[	O
2	int
*	O
BUFSIZ	int
]	O
,	O
ttyibuf	array
[	O
BUFSIZ	int
]	O
;	O
int	O
termdata	int
;	O
cc_t	enum
termAytChar	enum
;	O
void	O
init_terminal	function
(	O
void	O
)	O
{	O
if	O
(	O
ring_init	function
(	O
&	O
ttyoring	struct
,	O
ttyobuf	pointer
,	O
sizeof	O
ttyobuf	pointer
)	O
!=	O
1	int
)	O
{	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
ring_init	function
(	O
&	O
ttyiring	struct
,	O
ttyibuf	pointer
,	O
sizeof	O
ttyibuf	pointer
)	O
!=	O
1	int
)	O
{	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
autoflush	pointer
=	O
TerminalAutoFlush	function
(	O
)	O
;	O
}	O
int	O
ttyflush	function
(	O
int	O
drop	int
)	O
{	O
register	O
int	O
n	int
,	O
n0	int
,	O
n1	int
;	O
n0	int
=	O
ring_full_count	function
(	O
&	O
ttyoring	int
)	O
;	O
if	O
(	O
(	O
n1	int
=	O
n	int
=	O
ring_full_consecutive	function
(	O
&	O
ttyoring	int
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
drop	int
)	O
{	O
TerminalFlushOutput	function
(	O
)	O
;	O
}	O
else	O
{	O
n	int
=	O
TerminalWrite	function
(	O
(	O
char	O
*	O
)	O
ttyoring	struct
.	O
consume	pointer
,	O
n	int
)	O
;	O
}	O
}	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
termdata	int
&&	O
n	int
)	O
{	O
Dump	function
(	O
'>'	O
,	O
ttyoring	struct
.	O
consume	pointer
,	O
n	int
)	O
;	O
}	O
if	O
(	O
n1	int
==	O
n	int
&&	O
n0	long
>	O
n	long
)	O
{	O
n1	long
=	O
n0	long
-	O
n	long
;	O
if	O
(	O
!	O
drop	int
)	O
n1	long
=	O
TerminalWrite	function
(	O
(	O
char	O
*	O
)	O
ttyoring	struct
.	O
bottom	pointer
,	O
n1	long
)	O
;	O
if	O
(	O
n1	long
>	O
0	int
)	O
n	long
+=	O
n1	long
;	O
}	O
ring_consumed	function
(	O
&	O
ttyoring	struct
,	O
n	long
)	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n	long
==	O
n0	long
)	O
{	O
if	O
(	O
n0	long
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
n0	long
-	O
n	long
+	O
1	int
;	O
}	O
int	O
getconnmode	function
(	O
void	O
)	O
{	O
extern	O
int	O
linemode	int
;	O
int	O
mode	int
=	O
0	int
;	O
extern	O
int	O
kludgelinemode	int
;	O
if	O
(	O
In3270	int
)	O
return	O
(	O
MODE_FLOW	int
)	O
;	O
if	O
(	O
my_want_state_is_dont	function
(	O
TELOPT_ECHO	int
)	O
)	O
mode	int
|=	O
MODE_ECHO	int
;	O
if	O
(	O
localflow	int
)	O
mode	int
|=	O
MODE_FLOW	int
;	O
if	O
(	O
my_want_state_is_will	function
(	O
TELOPT_BINARY	int
)	O
)	O
mode	int
|=	O
MODE_INBIN	int
;	O
if	O
(	O
his_want_state_is_will	function
(	O
TELOPT_BINARY	int
)	O
)	O
mode	int
|=	O
MODE_OUTBIN	int
;	O
if	O
(	O
kludgelinemode	int
)	O
{	O
if	O
(	O
my_want_state_is_dont	function
(	O
TELOPT_SGA	int
)	O
)	O
{	O
mode	int
|=	O
(	O
MODE_TRAPSIG	int
|	O
MODE_EDIT	int
)	O
;	O
if	O
(	O
dontlecho	int
&&	O
(	O
clocks	struct
.	O
echotoggle	int
>	O
clocks	struct
.	O
modenegotiated	int
)	O
)	O
{	O
mode	int
&=	O
~	O
MODE_ECHO	int
;	O
}	O
}	O
return	O
(	O
mode	int
)	O
;	O
}	O
if	O
(	O
my_want_state_is_will	function
(	O
TELOPT_LINEMODE	int
)	O
)	O
mode	int
|=	O
linemode	int
;	O
return	O
(	O
mode	int
)	O
;	O
}	O
void	O
setconnmode	function
(	O
int	O
force	int
)	O
{	O
register	O
int	O
newmode	int
;	O
newmode	int
=	O
getconnmode	function
(	O
)	O
|	O
(	O
force	int
?	O
MODE_FORCE	int
:	O
0	int
)	O
;	O
TerminalNewMode	function
(	O
newmode	int
)	O
;	O
}	O
void	O
setcommandmode	function
(	O
void	O
)	O
{	O
TerminalNewMode	function
(	O
-	O
1	int
)	O
;	O
}	O