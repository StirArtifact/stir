struct	O
rec_rset_fprops_s	struct
{	O
char	O
*	O
fname	pointer
;	O
bool	bool
key_p	bool
;	O
bool	bool
auto_p	bool
;	O
rec_type_t	pointer
type	enum
;	O
char	O
*	O
type_name	pointer
;	O
struct	O
rec_rset_fprops_s	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
rec_rset_fprops_s	struct
*	O
rec_rset_fprops_t	pointer
;	O
struct	O
rec_rset_s	struct
{	O
rec_record_t	pointer
descriptor	pointer
;	O
size_t	long
descriptor_pos	long
;	O
rec_rset_fprops_t	pointer
field_props	pointer
;	O
rec_type_reg_t	pointer
type_reg	pointer
;	O
rec_fex_t	pointer
order_by_fields	pointer
;	O
size_t	long
min_size	long
;	O
size_t	long
max_size	long
;	O
rec_sex_t	pointer
*	O
constraints	pointer
;	O
size_t	long
num_constraints	long
;	O
int	O
record_type	int
;	O
int	O
comment_type	int
;	O
rec_mset_t	pointer
mset	pointer
;	O
}	O
;	O
static	O
void	O
rec_rset_init	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
;	O
static	O
void	O
rec_rset_update_types	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
;	O
static	O
void	O
rec_rset_update_field_props	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
;	O
static	O
void	O
rec_rset_update_size_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
;	O
static	O
void	O
rec_rset_update_sex_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
;	O
static	O
bool	bool
rec_rset_record_equal_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
)	O
;	O
static	O
void	O
rec_rset_record_disp_fn	function
(	O
void	O
*	O
data	pointer
)	O
;	O
static	O
void	O
*	O
rec_rset_record_dup_fn	function
(	O
void	O
*	O
data	pointer
)	O
;	O
static	O
int	O
rec_rset_record_compare_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
,	O
int	O
type1	pointer
)	O
;	O
static	O
bool	bool
rec_rset_comment_equal_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
)	O
;	O
static	O
void	O
rec_rset_comment_disp_fn	function
(	O
void	O
*	O
data	pointer
)	O
;	O
static	O
void	O
*	O
rec_rset_comment_dup_fn	function
(	O
void	O
*	O
data	pointer
)	O
;	O
static	O
int	O
rec_rset_comment_compare_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
,	O
int	O
type2	int
)	O
;	O
static	O
bool	bool
rec_rset_type_field_p	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
static	O
rec_fex_t	pointer
rec_rset_type_field_fex	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
static	O
char	O
*	O
rec_rset_type_field_type	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
static	O
rec_rset_fprops_t	pointer
rec_rset_get_props	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
bool	bool
create_p	bool
)	O
;	O
static	O
bool	bool
rec_rset_add_auto_field_int	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
;	O
static	O
bool	bool
rec_rset_add_auto_field_date	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
;	O
static	O
bool	bool
rec_rset_add_auto_field_uuid	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
;	O
static	O
rec_record_t	pointer
rec_rset_merge_records	function
(	O
rec_record_t	pointer
to_record	pointer
,	O
rec_record_t	pointer
from_record	pointer
,	O
rec_fex_t	pointer
excluded_fields	pointer
)	O
;	O
static	O
int	O
rec_rset_compare_typed_records	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record1	pointer
,	O
rec_record_t	pointer
record2	pointer
,	O
rec_fex_t	pointer
fields	pointer
)	O
;	O
rec_rset_t	pointer
rec_rset_new	function
(	O
void	O
)	O
{	O
rec_rset_t	pointer
rset	pointer
;	O
rset	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
rec_rset_s	struct
)	O
)	O
;	O
if	O
(	O
rset	pointer
)	O
{	O
rec_rset_init	function
(	O
rset	pointer
)	O
;	O
rset	pointer
->	O
mset	pointer
=	O
rec_mset_new	function
(	O
)	O
;	O
if	O
(	O
rset	pointer
->	O
mset	pointer
)	O
{	O
rset	pointer
->	O
descriptor	pointer
=	O
NULL	O
;	O
rset	pointer
->	O
descriptor_pos	long
=	O
0	int
;	O
rset	pointer
->	O
min_size	long
=	O
0	int
;	O
rset	pointer
->	O
max_size	long
=	O
SIZE_MAX	O
;	O
rset	pointer
->	O
constraints	pointer
=	O
NULL	O
;	O
rset	pointer
->	O
num_constraints	long
=	O
0	int
;	O
rset	pointer
->	O
type_reg	pointer
=	O
rec_type_reg_new	function
(	O
)	O
;	O
if	O
(	O
!	O
rset	pointer
->	O
type_reg	pointer
)	O
{	O
rec_rset_destroy	function
(	O
rset	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
rset	pointer
->	O
field_props	pointer
=	O
NULL	O
;	O
rset	pointer
->	O
order_by_fields	pointer
=	O
NULL	O
;	O
rset	pointer
->	O
record_type	int
=	O
rec_mset_register_type	function
(	O
rset	pointer
->	O
mset	pointer
,	O
"record"	pointer
,	O
rec_rset_record_disp_fn	function
,	O
rec_rset_record_equal_fn	function
,	O
rec_rset_record_dup_fn	function
,	O
rec_rset_record_compare_fn	function
)	O
;	O
rset	pointer
->	O
comment_type	int
=	O
rec_mset_register_type	function
(	O
rset	pointer
->	O
mset	pointer
,	O
"comment"	pointer
,	O
rec_rset_comment_disp_fn	function
,	O
rec_rset_comment_equal_fn	function
,	O
rec_rset_comment_dup_fn	function
,	O
rec_rset_comment_compare_fn	function
)	O
;	O
}	O
else	O
{	O
rec_rset_destroy	function
(	O
rset	pointer
)	O
;	O
rset	pointer
=	O
NULL	O
;	O
}	O
}	O
return	O
rset	pointer
;	O
}	O
void	O
rec_rset_destroy	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_rset_fprops_t	pointer
props	pointer
,	O
aux	pointer
=	O
NULL	O
;	O
size_t	long
i	long
=	O
0	int
;	O
if	O
(	O
rset	pointer
)	O
{	O
rec_record_destroy	function
(	O
rset	pointer
->	O
descriptor	pointer
)	O
;	O
rec_type_reg_destroy	function
(	O
rset	pointer
->	O
type_reg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rset	pointer
->	O
num_constraints	long
;	O
i	long
++	O
)	O
{	O
rec_sex_destroy	function
(	O
rset	pointer
->	O
constraints	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
rset	pointer
->	O
constraints	pointer
)	O
;	O
props	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
while	O
(	O
props	pointer
)	O
{	O
aux	pointer
=	O
props	pointer
;	O
if	O
(	O
aux	pointer
->	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
aux	pointer
->	O
type	enum
)	O
;	O
}	O
free	function
(	O
aux	pointer
->	O
fname	pointer
)	O
;	O
free	function
(	O
aux	pointer
->	O
type_name	pointer
)	O
;	O
props	pointer
=	O
props	pointer
->	O
next	pointer
;	O
free	function
(	O
aux	pointer
)	O
;	O
}	O
rec_fex_destroy	function
(	O
rset	pointer
->	O
order_by_fields	pointer
)	O
;	O
rec_mset_destroy	function
(	O
rset	pointer
->	O
mset	pointer
)	O
;	O
free	function
(	O
rset	pointer
)	O
;	O
}	O
}	O
rec_rset_t	pointer
rec_rset_dup	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_rset_t	pointer
new	pointer
=	O
NULL	O
;	O
new	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
rec_rset_s	struct
)	O
)	O
;	O
if	O
(	O
new	pointer
)	O
{	O
rec_rset_init	function
(	O
new	pointer
)	O
;	O
new	pointer
->	O
record_type	int
=	O
rset	pointer
->	O
record_type	int
;	O
new	pointer
->	O
comment_type	int
=	O
rset	pointer
->	O
comment_type	int
;	O
new	pointer
->	O
mset	pointer
=	O
NULL	O
;	O
new	pointer
->	O
min_size	long
=	O
rset	pointer
->	O
min_size	long
;	O
new	pointer
->	O
max_size	long
=	O
rset	pointer
->	O
max_size	long
;	O
new	pointer
->	O
type_reg	pointer
=	O
NULL	O
;	O
new	pointer
->	O
field_props	pointer
=	O
NULL	O
;	O
new	pointer
->	O
constraints	pointer
=	O
NULL	O
;	O
new	pointer
->	O
num_constraints	long
=	O
0	int
;	O
if	O
(	O
rset	pointer
->	O
order_by_fields	pointer
)	O
{	O
new	pointer
->	O
order_by_fields	pointer
=	O
rec_fex_dup	function
(	O
rset	pointer
->	O
order_by_fields	pointer
)	O
;	O
if	O
(	O
!	O
new	pointer
->	O
order_by_fields	pointer
)	O
{	O
rec_rset_destroy	function
(	O
new	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
new	pointer
->	O
mset	pointer
=	O
rec_mset_dup	function
(	O
rset	pointer
->	O
mset	pointer
)	O
;	O
if	O
(	O
!	O
new	pointer
->	O
mset	pointer
)	O
{	O
rec_rset_destroy	function
(	O
new	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
new	pointer
;	O
}	O
rec_mset_t	pointer
rec_rset_mset	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
mset	pointer
;	O
}	O
size_t	long
rec_rset_num_elems	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rec_mset_count	function
(	O
rset	pointer
->	O
mset	pointer
,	O
MSET_ANY	int
)	O
;	O
}	O
size_t	long
rec_rset_num_records	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rec_mset_count	function
(	O
rset	pointer
->	O
mset	pointer
,	O
rset	pointer
->	O
record_type	int
)	O
;	O
}	O
size_t	long
rec_rset_num_comments	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rec_mset_count	function
(	O
rset	pointer
->	O
mset	pointer
,	O
rset	pointer
->	O
comment_type	int
)	O
;	O
}	O
rec_record_t	pointer
rec_rset_descriptor	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
descriptor	pointer
;	O
}	O
void	O
rec_rset_set_descriptor	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
{	O
if	O
(	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
rec_record_destroy	function
(	O
rset	pointer
->	O
descriptor	pointer
)	O
;	O
rset	pointer
->	O
descriptor	pointer
=	O
NULL	O
;	O
}	O
rset	pointer
->	O
descriptor	pointer
=	O
record	pointer
;	O
rec_rset_update_types	function
(	O
rset	pointer
)	O
;	O
rec_rset_update_field_props	function
(	O
rset	pointer
)	O
;	O
rec_rset_update_size_constraints	function
(	O
rset	pointer
)	O
;	O
rec_rset_update_sex_constraints	function
(	O
rset	pointer
)	O
;	O
}	O
size_t	long
rec_rset_descriptor_pos	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
descriptor_pos	long
;	O
}	O
void	O
rec_rset_set_descriptor_pos	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
size_t	long
position	long
)	O
{	O
rset	pointer
->	O
descriptor_pos	long
=	O
position	long
;	O
}	O
void	O
rec_rset_set_type	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
type	enum
)	O
{	O
rec_field_t	pointer
rec_field	pointer
;	O
if	O
(	O
!	O
type	enum
)	O
{	O
return	O
;	O
}	O
if	O
(	O
!	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
rset	pointer
->	O
descriptor	pointer
=	O
rec_record_new	function
(	O
)	O
;	O
}	O
rec_field	pointer
=	O
rec_record_get_field_by_name	function
(	O
rset	pointer
->	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
rec_field	pointer
)	O
{	O
rec_field_set_value	function
(	O
rec_field	pointer
,	O
type	enum
)	O
;	O
}	O
else	O
{	O
rec_field	pointer
=	O
rec_field_new	function
(	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
type	enum
)	O
;	O
rec_mset_append	function
(	O
rec_record_mset	function
(	O
rset	pointer
->	O
descriptor	pointer
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
rec_field	pointer
,	O
MSET_FIELD	int
)	O
;	O
}	O
}	O
char	O
*	O
rec_rset_type	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
char	O
*	O
res	pointer
;	O
rec_field_t	pointer
field	pointer
;	O
res	pointer
=	O
NULL	O
;	O
if	O
(	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
rset	pointer
->	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
field	pointer
)	O
{	O
res	pointer
=	O
rec_extract_type	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
}	O
}	O
return	O
res	pointer
;	O
}	O
char	O
*	O
rec_rset_url	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
char	O
*	O
res	pointer
;	O
rec_field_t	pointer
field	pointer
;	O
res	pointer
=	O
NULL	O
;	O
if	O
(	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
rset	pointer
->	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
field	pointer
)	O
{	O
res	pointer
=	O
rec_extract_url	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
}	O
}	O
return	O
res	pointer
;	O
}	O
rec_type_reg_t	pointer
rec_rset_get_type_reg	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
type_reg	pointer
;	O
}	O
void	O
rec_rset_rename_field	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
const	O
char	O
*	O
new_field_name	pointer
)	O
{	O
size_t	long
j	long
;	O
rec_record_t	pointer
descriptor	pointer
;	O
rec_fex_t	pointer
fex	pointer
;	O
char	O
*	O
fex_str	pointer
;	O
char	O
*	O
type_str	pointer
;	O
rec_buf_t	pointer
buf	pointer
;	O
char	O
*	O
result	pointer
;	O
size_t	long
result_size	long
;	O
rec_fex_elem_t	pointer
fex_elem	pointer
;	O
const	O
char	O
*	O
fex_fname	pointer
;	O
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
rec_mset_t	pointer
descriptor_mset	pointer
=	O
rec_record_mset	function
(	O
descriptor	pointer
)	O
;	O
rec_mset_iterator_t	struct
iter	struct
=	O
rec_mset_iterator	function
(	O
descriptor_mset	pointer
)	O
;	O
rec_field_t	pointer
field	pointer
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_TYPE	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_rset_type_field_p	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
)	O
{	O
continue	O
;	O
}	O
fex	pointer
=	O
rec_rset_type_field_fex	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
if	O
(	O
fex	pointer
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
rec_fex_size	function
(	O
fex	pointer
)	O
;	O
j	long
++	O
)	O
{	O
fex_elem	pointer
=	O
rec_fex_get	function
(	O
fex	pointer
,	O
j	long
)	O
;	O
fex_fname	pointer
=	O
rec_fex_elem_field_name	function
(	O
fex_elem	pointer
)	O
;	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
fex_fname	pointer
)	O
)	O
{	O
rec_fex_elem_set_field_name	function
(	O
fex_elem	pointer
,	O
new_field_name	pointer
)	O
;	O
}	O
}	O
fex_str	pointer
=	O
rec_fex_str	function
(	O
fex	pointer
,	O
REC_FEX_CSV	int
)	O
;	O
type_str	pointer
=	O
rec_rset_type_field_type	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
buf	pointer
=	O
rec_buf_new	function
(	O
&	O
result	pointer
,	O
&	O
result_size	long
)	O
;	O
rec_buf_puts	function
(	O
fex_str	pointer
,	O
buf	pointer
)	O
;	O
rec_buf_putc	function
(	O
' '	O
,	O
buf	pointer
)	O
;	O
rec_buf_puts	function
(	O
type_str	pointer
,	O
buf	pointer
)	O
;	O
rec_buf_close	function
(	O
buf	pointer
)	O
;	O
rec_field_set_value	function
(	O
field	pointer
,	O
result	pointer
)	O
;	O
free	function
(	O
fex_str	pointer
)	O
;	O
free	function
(	O
type_str	pointer
)	O
;	O
rec_fex_destroy	function
(	O
fex	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_UNIQUE	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_PROHIBIT	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_SORT	int
)	O
)	O
)	O
{	O
fex	pointer
=	O
rec_fex_new	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
fex	pointer
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
rec_fex_size	function
(	O
fex	pointer
)	O
;	O
j	long
++	O
)	O
{	O
fex_elem	pointer
=	O
rec_fex_get	function
(	O
fex	pointer
,	O
j	long
)	O
;	O
fex_fname	pointer
=	O
rec_fex_elem_field_name	function
(	O
fex_elem	pointer
)	O
;	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
fex_fname	pointer
)	O
)	O
{	O
rec_fex_elem_set_field_name	function
(	O
fex_elem	pointer
,	O
new_field_name	pointer
)	O
;	O
}	O
}	O
fex_str	pointer
=	O
rec_fex_str	function
(	O
fex	pointer
,	O
REC_FEX_SIMPLE	int
)	O
;	O
rec_field_set_value	function
(	O
field	pointer
,	O
fex_str	pointer
)	O
;	O
free	function
(	O
fex_str	pointer
)	O
;	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
rec_rset_update_field_props	function
(	O
rset	pointer
)	O
;	O
}	O
const	O
char	O
*	O
rec_rset_key	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
const	O
char	O
*	O
key	pointer
=	O
NULL	O
;	O
rec_rset_fprops_t	pointer
props	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
while	O
(	O
props	pointer
)	O
{	O
if	O
(	O
props	pointer
->	O
key_p	bool
)	O
{	O
key	pointer
=	O
props	pointer
->	O
fname	pointer
;	O
break	O
;	O
}	O
props	pointer
=	O
props	pointer
->	O
next	pointer
;	O
}	O
return	O
key	pointer
;	O
}	O
rec_fex_t	pointer
rec_rset_auto	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_fex_t	pointer
fex	pointer
;	O
rec_rset_fprops_t	pointer
props	pointer
;	O
fex	pointer
=	O
rec_fex_new	function
(	O
NULL	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
props	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
while	O
(	O
props	pointer
)	O
{	O
if	O
(	O
props	pointer
->	O
auto_p	bool
)	O
{	O
rec_fex_append	function
(	O
fex	pointer
,	O
props	pointer
->	O
fname	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
}	O
props	pointer
=	O
props	pointer
->	O
next	pointer
;	O
}	O
return	O
fex	pointer
;	O
}	O
rec_type_t	pointer
rec_rset_get_field_type	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
)	O
{	O
rec_type_t	pointer
type	enum
=	O
NULL	O
;	O
rec_rset_fprops_t	pointer
props	pointer
=	O
NULL	O
;	O
props	pointer
=	O
rec_rset_get_props	function
(	O
rset	pointer
,	O
field_name	pointer
,	O
false	int
)	O
;	O
if	O
(	O
props	pointer
)	O
{	O
type	enum
=	O
props	pointer
->	O
type	enum
;	O
if	O
(	O
!	O
type	enum
&&	O
props	pointer
->	O
type_name	pointer
)	O
{	O
type	enum
=	O
rec_type_reg_get	function
(	O
rset	pointer
->	O
type_reg	pointer
,	O
props	pointer
->	O
type_name	pointer
)	O
;	O
}	O
}	O
return	O
type	enum
;	O
}	O
size_t	long
rec_rset_min_records	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
min_size	long
;	O
}	O
size_t	long
rec_rset_max_records	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
max_size	long
;	O
}	O
char	O
*	O
rec_rset_source	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_record_t	pointer
record	pointer
;	O
record	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
!	O
record	pointer
)	O
{	O
record	pointer
=	O
(	O
rec_record_t	pointer
)	O
rec_mset_get_at	function
(	O
rset	pointer
->	O
mset	pointer
,	O
MSET_RECORD	int
,	O
0	int
)	O
;	O
}	O
return	O
rec_record_source	function
(	O
record	pointer
)	O
;	O
}	O
bool	bool
rec_rset_set_order_by_fields	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_fex_t	pointer
field_names	pointer
)	O
{	O
rec_fex_destroy	function
(	O
rset	pointer
->	O
order_by_fields	pointer
)	O
;	O
rset	pointer
->	O
order_by_fields	pointer
=	O
rec_fex_dup	function
(	O
field_names	pointer
)	O
;	O
return	O
(	O
rset	pointer
->	O
order_by_fields	pointer
!=	O
NULL	O
)	O
;	O
}	O
rec_fex_t	pointer
rec_rset_order_by_fields	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
order_by_fields	pointer
;	O
}	O
rec_rset_t	pointer
rec_rset_sort	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_fex_t	pointer
sort_by	pointer
)	O
{	O
if	O
(	O
sort_by	pointer
)	O
{	O
rec_rset_set_order_by_fields	function
(	O
rset	pointer
,	O
sort_by	pointer
)	O
;	O
}	O
if	O
(	O
rset	pointer
->	O
order_by_fields	pointer
)	O
{	O
if	O
(	O
!	O
rec_mset_sort	function
(	O
rset	pointer
->	O
mset	pointer
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
rec_rset_update_field_props	function
(	O
rset	pointer
)	O
;	O
}	O
return	O
rset	pointer
;	O
}	O
rec_rset_t	pointer
rec_rset_group	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_fex_t	pointer
group_by	pointer
)	O
{	O
rec_mset_iterator_t	struct
iter	struct
;	O
rec_record_t	pointer
record	pointer
;	O
rec_mset_elem_t	pointer
elem	pointer
;	O
size_t	long
map_size	long
;	O
bool	bool
*	O
deletion_map	pointer
;	O
size_t	long
num_record	long
;	O
map_size	long
=	O
sizeof	O
(	O
bool	bool
)	O
*	O
rec_rset_num_records	function
(	O
rset	pointer
)	O
;	O
deletion_map	pointer
=	O
malloc	function
(	O
map_size	long
)	O
;	O
if	O
(	O
!	O
deletion_map	pointer
)	O
{	O
return	O
NULL	O
;	O
}	O
memset	function
(	O
deletion_map	pointer
,	O
false	int
,	O
map_size	long
)	O
;	O
num_record	long
=	O
0	int
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
record	pointer
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
deletion_map	pointer
[	O
num_record	long
]	O
)	O
{	O
size_t	long
num_record_2	long
=	O
num_record	long
;	O
rec_mset_iterator_t	struct
iter2	struct
=	O
iter	struct
;	O
rec_record_t	pointer
record2	pointer
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter2	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
record2	pointer
,	O
NULL	O
)	O
)	O
{	O
num_record_2	long
++	O
;	O
if	O
(	O
rec_rset_compare_typed_records	function
(	O
rset	pointer
,	O
record	pointer
,	O
record2	pointer
,	O
group_by	pointer
)	O
!=	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
rec_rset_merge_records	function
(	O
record	pointer
,	O
record2	pointer
,	O
group_by	pointer
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
deletion_map	pointer
[	O
num_record_2	long
]	O
=	O
true	int
;	O
}	O
}	O
}	O
num_record	long
++	O
;	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
num_record	long
=	O
0	int
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
record	pointer
,	O
&	O
elem	pointer
)	O
)	O
{	O
if	O
(	O
deletion_map	pointer
[	O
num_record	long
]	O
)	O
{	O
rec_mset_remove_elem	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
,	O
elem	pointer
)	O
;	O
}	O
num_record	long
++	O
;	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
free	function
(	O
deletion_map	pointer
)	O
;	O
return	O
rset	pointer
;	O
}	O
rec_rset_t	pointer
rec_rset_add_auto_fields	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
{	O
rec_fex_t	pointer
auto_fields	pointer
;	O
rec_type_t	pointer
type	enum
;	O
size_t	long
i	long
;	O
if	O
(	O
(	O
auto_fields	pointer
=	O
rec_rset_auto	function
(	O
rset	pointer
)	O
)	O
)	O
{	O
size_t	long
num_auto_fields	long
=	O
rec_fex_size	function
(	O
auto_fields	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_auto_fields	long
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
auto_field_name	pointer
=	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
auto_fields	pointer
,	O
i	long
)	O
)	O
;	O
if	O
(	O
!	O
rec_record_field_p	function
(	O
record	pointer
,	O
auto_field_name	pointer
)	O
)	O
{	O
type	enum
=	O
rec_rset_get_field_type	function
(	O
rset	pointer
,	O
auto_field_name	pointer
)	O
;	O
if	O
(	O
type	enum
)	O
{	O
switch	O
(	O
rec_type_kind	function
(	O
type	enum
)	O
)	O
{	O
case	O
REC_TYPE_INT	int
:	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
if	O
(	O
!	O
rec_rset_add_auto_field_int	function
(	O
rset	pointer
,	O
auto_field_name	pointer
,	O
record	pointer
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
if	O
(	O
!	O
rec_rset_add_auto_field_date	function
(	O
rset	pointer
,	O
auto_field_name	pointer
,	O
record	pointer
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_UUID	int
:	O
{	O
if	O
(	O
!	O
rec_rset_add_auto_field_uuid	function
(	O
rset	pointer
,	O
auto_field_name	pointer
,	O
record	pointer
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
return	O
rset	pointer
;	O
}	O
size_t	long
rec_rset_num_sex_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
return	O
rset	pointer
->	O
num_constraints	long
;	O
}	O
rec_sex_t	pointer
rec_rset_sex_constraint	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
size_t	long
index	function
)	O
{	O
return	O
rset	pointer
->	O
constraints	pointer
[	O
index	function
]	O
;	O
}	O
static	O
void	O
rec_rset_init	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
memset	function
(	O
rset	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
rec_rset_s	struct
)	O
)	O
;	O
}	O
static	O
void	O
rec_rset_record_disp_fn	function
(	O
void	O
*	O
data	pointer
)	O
{	O
rec_record_t	pointer
record	pointer
=	O
(	O
rec_record_t	pointer
)	O
data	pointer
;	O
rec_record_destroy	function
(	O
record	pointer
)	O
;	O
}	O
static	O
bool	bool
rec_rset_record_equal_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
)	O
{	O
return	O
(	O
data1	pointer
==	O
data2	pointer
)	O
;	O
}	O
static	O
void	O
*	O
rec_rset_record_dup_fn	function
(	O
void	O
*	O
data	pointer
)	O
{	O
rec_record_t	pointer
record	pointer
=	O
(	O
rec_record_t	pointer
)	O
data	pointer
;	O
rec_record_t	pointer
new	pointer
=	O
rec_record_dup	function
(	O
record	pointer
)	O
;	O
return	O
(	O
void	O
*	O
)	O
new	pointer
;	O
}	O
static	O
int	O
rec_rset_record_compare_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
,	O
int	O
type2	int
)	O
{	O
rec_rset_t	pointer
rset	pointer
=	O
NULL	O
;	O
rec_record_t	pointer
record1	pointer
=	O
NULL	O
;	O
rec_record_t	pointer
record2	pointer
=	O
NULL	O
;	O
int	O
type_comparison	int
=	O
0	int
;	O
if	O
(	O
type2	int
==	O
MSET_COMMENT	int
)	O
{	O
return	O
1	int
;	O
}	O
record1	pointer
=	O
(	O
rec_record_t	pointer
)	O
data1	pointer
;	O
record2	pointer
=	O
(	O
rec_record_t	pointer
)	O
data2	pointer
;	O
rset	pointer
=	O
(	O
rec_rset_t	pointer
)	O
rec_record_container	function
(	O
record1	pointer
)	O
;	O
type_comparison	int
=	O
rec_rset_compare_typed_records	function
(	O
rset	pointer
,	O
record1	pointer
,	O
record2	pointer
,	O
rset	pointer
->	O
order_by_fields	pointer
)	O
;	O
if	O
(	O
type_comparison	int
==	O
0	int
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
return	O
type_comparison	int
;	O
}	O
static	O
void	O
rec_rset_comment_disp_fn	function
(	O
void	O
*	O
data	pointer
)	O
{	O
rec_comment_t	pointer
comment	pointer
=	O
(	O
rec_comment_t	pointer
)	O
data	pointer
;	O
rec_comment_destroy	function
(	O
comment	pointer
)	O
;	O
}	O
static	O
bool	bool
rec_rset_comment_equal_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
)	O
{	O
return	O
(	O
data1	pointer
==	O
data2	pointer
)	O
;	O
}	O
static	O
void	O
*	O
rec_rset_comment_dup_fn	function
(	O
void	O
*	O
data	pointer
)	O
{	O
rec_comment_t	pointer
comment	pointer
=	O
(	O
rec_comment_t	pointer
)	O
data	pointer
;	O
rec_comment_t	pointer
new	pointer
=	O
rec_comment_dup	function
(	O
comment	pointer
)	O
;	O
return	O
(	O
void	O
*	O
)	O
new	pointer
;	O
}	O
static	O
int	O
rec_rset_comment_compare_fn	function
(	O
void	O
*	O
data1	pointer
,	O
void	O
*	O
data2	pointer
,	O
int	O
type2	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
rec_rset_update_sex_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
{	O
size_t	long
i	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rset	pointer
->	O
num_constraints	long
;	O
i	long
++	O
)	O
{	O
rec_sex_destroy	function
(	O
rset	pointer
->	O
constraints	pointer
[	O
i	long
]	O
)	O
;	O
}	O
rset	pointer
->	O
num_constraints	long
=	O
0	int
;	O
}	O
if	O
(	O
!	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
return	O
;	O
}	O
{	O
size_t	long
num_constraints	long
=	O
rec_record_get_num_fields_by_name	function
(	O
rset	pointer
->	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_CONSTRAINT	int
)	O
)	O
;	O
rset	pointer
->	O
constraints	pointer
=	O
malloc	function
(	O
num_constraints	long
*	O
sizeof	O
(	O
rec_sex_t	pointer
)	O
)	O
;	O
if	O
(	O
!	O
rset	pointer
->	O
constraints	pointer
)	O
{	O
return	O
;	O
}	O
}	O
{	O
rec_field_t	pointer
field	pointer
=	O
NULL	O
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
rset	pointer
->	O
descriptor	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
field_name	pointer
=	O
rec_field_name	function
(	O
field	pointer
)	O
;	O
const	O
char	O
*	O
field_value	pointer
=	O
rec_field_value	function
(	O
field	pointer
)	O
;	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_CONSTRAINT	int
)	O
)	O
)	O
{	O
rec_sex_t	pointer
sex	pointer
=	O
rec_sex_new	function
(	O
false	int
)	O
;	O
if	O
(	O
!	O
sex	pointer
)	O
{	O
return	O
;	O
}	O
if	O
(	O
rec_sex_compile	function
(	O
sex	pointer
,	O
field_value	pointer
)	O
)	O
{	O
rset	pointer
->	O
constraints	pointer
[	O
rset	pointer
->	O
num_constraints	long
++	O
]	O
=	O
sex	pointer
;	O
}	O
else	O
{	O
rec_sex_destroy	function
(	O
sex	pointer
)	O
;	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
}	O
static	O
void	O
rec_rset_update_size_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_field_t	pointer
field	pointer
;	O
enum	O
rec_size_condition_e	enum
condition	enum
;	O
size_t	long
size	pointer
=	O
0	int
;	O
rset	pointer
->	O
min_size	long
=	O
0	int
;	O
rset	pointer
->	O
max_size	long
=	O
SIZE_MAX	O
;	O
if	O
(	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
rset	pointer
->	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_SIZE	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
field	pointer
&&	O
rec_match	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
REC_INT_SIZE_RE	O
)	O
)	O
{	O
condition	enum
=	O
rec_extract_size_condition	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
size	pointer
=	O
rec_extract_size	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
switch	O
(	O
condition	enum
)	O
{	O
case	O
SIZE_COND_E	int
:	O
{	O
rset	pointer
->	O
min_size	long
=	O
size	pointer
;	O
rset	pointer
->	O
max_size	long
=	O
size	pointer
;	O
break	O
;	O
}	O
case	O
SIZE_COND_L	int
:	O
{	O
rset	pointer
->	O
max_size	long
=	O
size	pointer
-	O
1	int
;	O
break	O
;	O
}	O
case	O
SIZE_COND_LE	int
:	O
{	O
rset	pointer
->	O
max_size	long
=	O
size	pointer
;	O
break	O
;	O
}	O
case	O
SIZE_COND_G	int
:	O
{	O
rset	pointer
->	O
min_size	long
=	O
size	pointer
+	O
1	int
;	O
break	O
;	O
}	O
case	O
SIZE_COND_GE	int
:	O
{	O
rset	pointer
->	O
min_size	long
=	O
size	pointer
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
rec_rset_update_field_props	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_rset_fprops_t	pointer
props	pointer
=	O
NULL	O
;	O
char	O
*	O
type_name	pointer
=	O
NULL	O
;	O
props	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
while	O
(	O
props	pointer
)	O
{	O
props	pointer
->	O
key_p	bool
=	O
false	int
;	O
props	pointer
->	O
auto_p	bool
=	O
false	int
;	O
if	O
(	O
props	pointer
->	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
props	pointer
->	O
type	enum
)	O
;	O
props	pointer
->	O
type	enum
=	O
NULL	O
;	O
}	O
props	pointer
=	O
props	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
rec_field_t	pointer
field	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
rset	pointer
->	O
descriptor	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
field_name	pointer
=	O
rec_field_name	function
(	O
field	pointer
)	O
;	O
const	O
char	O
*	O
field_value	pointer
=	O
rec_field_value	function
(	O
field	pointer
)	O
;	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_TYPE	int
)	O
)	O
&&	O
rec_rset_type_field_p	function
(	O
field_value	pointer
)	O
)	O
{	O
size_t	long
i	long
;	O
rec_fex_t	pointer
fex	pointer
=	O
rec_rset_type_field_fex	function
(	O
field_value	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	function
(	O
fex	pointer
)	O
;	O
i	long
++	O
)	O
{	O
char	O
*	O
field_type	pointer
=	O
rec_rset_type_field_type	function
(	O
field_value	pointer
)	O
;	O
rec_type_t	pointer
type	enum
=	O
rec_type_new	function
(	O
field_type	pointer
)	O
;	O
if	O
(	O
!	O
type	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
field_type	pointer
;	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
,	O
&	O
type_name	pointer
)	O
;	O
props	pointer
=	O
rec_rset_get_props	function
(	O
rset	pointer
,	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex	pointer
,	O
i	long
)	O
)	O
,	O
true	int
)	O
;	O
if	O
(	O
props	pointer
->	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
props	pointer
->	O
type	enum
)	O
;	O
props	pointer
->	O
type	enum
=	O
NULL	O
;	O
}	O
free	function
(	O
props	pointer
->	O
type_name	pointer
)	O
;	O
props	pointer
->	O
type_name	pointer
=	O
type_name	pointer
;	O
}	O
else	O
{	O
props	pointer
=	O
rec_rset_get_props	function
(	O
rset	pointer
,	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex	pointer
,	O
i	long
)	O
)	O
,	O
true	int
)	O
;	O
if	O
(	O
props	pointer
->	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
props	pointer
->	O
type	enum
)	O
;	O
}	O
free	function
(	O
props	pointer
->	O
type_name	pointer
)	O
;	O
props	pointer
->	O
type_name	pointer
=	O
NULL	O
;	O
props	pointer
->	O
type	enum
=	O
type	enum
;	O
}	O
free	function
(	O
field_type	pointer
)	O
;	O
}	O
rec_fex_destroy	function
(	O
fex	pointer
)	O
;	O
}	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
)	O
{	O
const	O
char	O
*	O
field_value	pointer
=	O
rec_field_value	function
(	O
field	pointer
)	O
;	O
char	O
*	O
type_name	pointer
=	O
NULL	O
;	O
rec_skip_blanks	function
(	O
&	O
field_value	pointer
)	O
;	O
rec_parse_regexp	function
(	O
&	O
field_value	pointer
,	O
"^"	pointer
REC_RECORD_TYPE_RE	O
,	O
&	O
type_name	pointer
)	O
;	O
props	pointer
=	O
rec_rset_get_props	function
(	O
rset	pointer
,	O
type_name	pointer
,	O
true	int
)	O
;	O
props	pointer
->	O
key_p	bool
=	O
true	int
;	O
free	function
(	O
type_name	pointer
)	O
;	O
}	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_AUTO	int
)	O
)	O
)	O
{	O
rec_fex_t	pointer
fex	pointer
=	O
rec_fex_new	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
fex	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	function
(	O
fex	pointer
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
auto_field_name	pointer
=	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex	pointer
,	O
i	long
)	O
)	O
;	O
props	pointer
=	O
rec_rset_get_props	function
(	O
rset	pointer
,	O
auto_field_name	pointer
,	O
true	int
)	O
;	O
props	pointer
->	O
auto_p	bool
=	O
true	int
;	O
}	O
}	O
}	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_SORT	int
)	O
)	O
)	O
{	O
const	O
char	O
*	O
field_value	pointer
=	O
rec_field_value	function
(	O
field	pointer
)	O
;	O
rec_fex_t	pointer
fex	pointer
=	O
rec_fex_new	function
(	O
field_value	pointer
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
fex	pointer
)	O
{	O
rec_fex_destroy	function
(	O
rset	pointer
->	O
order_by_fields	pointer
)	O
;	O
rset	pointer
->	O
order_by_fields	pointer
=	O
fex	pointer
;	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
props	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
while	O
(	O
props	pointer
)	O
{	O
if	O
(	O
props	pointer
->	O
auto_p	bool
&&	O
!	O
props	pointer
->	O
type	enum
&&	O
!	O
props	pointer
->	O
type_name	pointer
)	O
{	O
props	pointer
->	O
type	enum
=	O
rec_type_new	function
(	O
"int"	pointer
)	O
;	O
}	O
props	pointer
=	O
props	pointer
->	O
next	pointer
;	O
}	O
}	O
static	O
void	O
rec_rset_update_types	function
(	O
rec_rset_t	pointer
rset	pointer
)	O
{	O
rec_field_t	pointer
field	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
=	O
NULL	O
;	O
rec_type_t	pointer
type	enum
;	O
char	O
*	O
type_name	pointer
,	O
*	O
to_type	pointer
=	O
NULL	O
;	O
if	O
(	O
rset	pointer
->	O
descriptor	pointer
)	O
{	O
rec_type_reg_destroy	function
(	O
rset	pointer
->	O
type_reg	pointer
)	O
;	O
rset	pointer
->	O
type_reg	pointer
=	O
rec_type_reg_new	function
(	O
)	O
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
rset	pointer
->	O
descriptor	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
field_name	pointer
=	O
rec_field_name	function
(	O
field	pointer
)	O
;	O
const	O
char	O
*	O
field_value	pointer
=	O
rec_field_value	function
(	O
field	pointer
)	O
;	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_TYPEDEF	int
)	O
)	O
)	O
{	O
p	pointer
=	O
field_value	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
,	O
&	O
type_name	pointer
)	O
)	O
{	O
type	enum
=	O
rec_type_new	function
(	O
p	pointer
)	O
;	O
if	O
(	O
type	enum
)	O
{	O
rec_type_set_name	function
(	O
type	enum
,	O
type_name	pointer
)	O
;	O
rec_type_reg_add	function
(	O
rset	pointer
->	O
type_reg	pointer
,	O
type	enum
)	O
;	O
}	O
else	O
{	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
q	pointer
=	O
p	pointer
;	O
if	O
(	O
rec_parse_regexp	function
(	O
&	O
q	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
"[ \t\n]*"	pointer
,	O
NULL	O
)	O
)	O
{	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
,	O
&	O
to_type	pointer
)	O
;	O
rec_type_reg_add_synonym	function
(	O
rset	pointer
->	O
type_reg	pointer
,	O
type_name	pointer
,	O
to_type	pointer
)	O
;	O
}	O
}	O
free	function
(	O
type_name	pointer
)	O
;	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
}	O
static	O
bool	bool
rec_rset_type_field_p	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_FNAME_LIST_CS_RE	O
,	O
NULL	O
)	O
)	O
{	O
return	O
false	int
;	O
}	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
return	O
(	O
rec_type_descr_p	function
(	O
p	pointer
)	O
||	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
"[ \t\n]*$"	pointer
,	O
NULL	O
)	O
)	O
;	O
}	O
static	O
rec_fex_t	pointer
rec_rset_type_field_fex	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
rec_fex_t	pointer
fex	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
name	pointer
;	O
p	pointer
=	O
str	pointer
;	O
if	O
(	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_FNAME_LIST_CS_RE	O
,	O
&	O
name	pointer
)	O
)	O
{	O
fex	pointer
=	O
rec_fex_new	function
(	O
name	pointer
,	O
REC_FEX_CSV	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
return	O
fex	pointer
;	O
}	O
static	O
char	O
*	O
rec_rset_type_field_type	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
result	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
rec_rset_type_field_p	function
(	O
str	pointer
)	O
)	O
{	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_FNAME_LIST_CS_RE	O
,	O
NULL	O
)	O
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
result	pointer
=	O
strdup	function
(	O
p	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
rec_rset_fprops_t	pointer
rec_rset_get_props	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
bool	bool
create_p	bool
)	O
{	O
rec_rset_fprops_t	pointer
props	pointer
=	O
NULL	O
;	O
props	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
while	O
(	O
props	pointer
)	O
{	O
if	O
(	O
rec_field_name_equal_p	function
(	O
fname	pointer
,	O
props	pointer
->	O
fname	pointer
)	O
)	O
{	O
break	O
;	O
}	O
props	pointer
=	O
props	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
!	O
props	pointer
&&	O
create_p	bool
)	O
{	O
props	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
rec_rset_fprops_s	struct
)	O
)	O
;	O
if	O
(	O
props	pointer
)	O
{	O
props	pointer
->	O
fname	pointer
=	O
strdup	function
(	O
fname	pointer
)	O
;	O
props	pointer
->	O
auto_p	bool
=	O
false	int
;	O
props	pointer
->	O
key_p	bool
=	O
false	int
;	O
props	pointer
->	O
type	enum
=	O
NULL	O
;	O
props	pointer
->	O
type_name	pointer
=	O
NULL	O
;	O
props	pointer
->	O
next	pointer
=	O
rset	pointer
->	O
field_props	pointer
;	O
rset	pointer
->	O
field_props	pointer
=	O
props	pointer
;	O
}	O
}	O
return	O
props	pointer
;	O
}	O
static	O
bool	bool
rec_rset_add_auto_field_int	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
{	O
rec_mset_iterator_t	struct
iter	struct
;	O
rec_record_t	pointer
rec	pointer
;	O
rec_field_t	pointer
field	pointer
;	O
size_t	long
num_fields	long
,	O
i	long
;	O
int	O
auto_value	int
,	O
field_value	pointer
;	O
char	O
*	O
end	pointer
;	O
char	O
*	O
auto_value_str	pointer
;	O
auto_value	int
=	O
0	int
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
rec	pointer
,	O
NULL	O
)	O
)	O
{	O
num_fields	long
=	O
rec_record_get_num_fields_by_name	function
(	O
rec	pointer
,	O
field_name	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fields	long
;	O
i	long
++	O
)	O
{	O
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
rec	pointer
,	O
field_name	pointer
,	O
i	long
)	O
;	O
errno	O
=	O
0	int
;	O
field_value	pointer
=	O
strtol	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
&	O
end	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
errno	O
==	O
0	int
)	O
&&	O
(	O
*	O
end	pointer
==	O
'\0'	O
)	O
)	O
{	O
if	O
(	O
auto_value	int
<=	O
field_value	pointer
)	O
{	O
auto_value	int
=	O
field_value	pointer
+	O
1	int
;	O
}	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
auto_value_str	pointer
,	O
"%d"	pointer
,	O
auto_value	int
)	O
!=	O
-	O
1	int
)	O
{	O
field	pointer
=	O
rec_field_new	function
(	O
field_name	pointer
,	O
auto_value_str	pointer
)	O
;	O
if	O
(	O
!	O
field	pointer
)	O
{	O
free	function
(	O
auto_value_str	pointer
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
rec_mset_insert_at	function
(	O
rec_record_mset	function
(	O
record	pointer
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
field	pointer
,	O
0	int
)	O
)	O
{	O
free	function
(	O
auto_value_str	pointer
)	O
;	O
return	O
false	int
;	O
}	O
free	function
(	O
auto_value_str	pointer
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
rec_rset_add_auto_field_date	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
{	O
rec_field_t	pointer
auto_field	pointer
;	O
time_t	long
t	long
;	O
char	O
outstr	array
[	O
200	int
]	O
;	O
struct	O
tm	struct
*	O
tmp	pointer
;	O
t	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
tmp	pointer
=	O
localtime	function
(	O
&	O
t	long
)	O
;	O
setlocale	function
(	O
LC_TIME	O
,	O
"C"	pointer
)	O
;	O
strftime	function
(	O
outstr	array
,	O
sizeof	O
(	O
outstr	array
)	O
,	O
"%a, %d %b %Y %T %z"	pointer
,	O
tmp	pointer
)	O
;	O
setlocale	function
(	O
LC_TIME	O
,	O
""	pointer
)	O
;	O
auto_field	pointer
=	O
rec_field_new	function
(	O
field_name	pointer
,	O
outstr	array
)	O
;	O
if	O
(	O
!	O
auto_field	pointer
)	O
{	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
rec_mset_insert_at	function
(	O
rec_record_mset	function
(	O
record	pointer
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
auto_field	pointer
,	O
0	int
)	O
)	O
{	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
rec_rset_add_auto_field_uuid	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
const	O
char	O
*	O
field_name	pointer
,	O
rec_record_t	pointer
record	pointer
)	O
{	O
rec_field_t	pointer
auto_field	pointer
;	O
uuid_t	array
uu	array
;	O
char	O
uu_str	array
[	O
40	int
]	O
;	O
uuid_generate_time	function
(	O
uu	array
)	O
;	O
uuid_unparse	function
(	O
uu	array
,	O
uu_str	array
)	O
;	O
auto_field	pointer
=	O
rec_field_new	function
(	O
field_name	pointer
,	O
uu_str	array
)	O
;	O
if	O
(	O
!	O
auto_field	pointer
)	O
{	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
rec_mset_insert_at	function
(	O
rec_record_mset	function
(	O
record	pointer
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
auto_field	pointer
,	O
0	int
)	O
)	O
{	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
rec_record_t	pointer
rec_rset_merge_records	function
(	O
rec_record_t	pointer
to_record	pointer
,	O
rec_record_t	pointer
from_record	pointer
,	O
rec_fex_t	pointer
group_by_fields	pointer
)	O
{	O
rec_mset_elem_t	pointer
elem	pointer
;	O
void	O
*	O
data	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
from_record	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_ANY	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
data	pointer
,	O
&	O
elem	pointer
)	O
)	O
{	O
if	O
(	O
rec_mset_elem_type	function
(	O
elem	pointer
)	O
==	O
MSET_FIELD	int
)	O
{	O
rec_field_t	pointer
field	pointer
=	O
(	O
rec_field_t	pointer
)	O
data	pointer
;	O
if	O
(	O
rec_fex_member_p	function
(	O
group_by_fields	pointer
,	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
!	O
rec_mset_append	function
(	O
rec_record_mset	function
(	O
to_record	pointer
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
rec_field_dup	function
(	O
field	pointer
)	O
,	O
MSET_ANY	int
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
rec_comment_t	pointer
comment	pointer
=	O
(	O
rec_comment_t	pointer
)	O
data	pointer
;	O
rec_mset_append	function
(	O
rec_record_mset	function
(	O
to_record	pointer
)	O
,	O
MSET_COMMENT	int
,	O
(	O
void	O
*	O
)	O
rec_comment_dup	function
(	O
comment	pointer
)	O
,	O
MSET_ANY	int
)	O
;	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
return	O
to_record	pointer
;	O
}	O
static	O
int	O
rec_rset_compare_typed_records	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record1	pointer
,	O
rec_record_t	pointer
record2	pointer
,	O
rec_fex_t	pointer
fields	pointer
)	O
{	O
int	O
result	pointer
=	O
0	int
;	O
size_t	long
i	long
=	O
0	int
;	O
size_t	long
num_fields	long
=	O
rec_fex_size	function
(	O
fields	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fields	long
;	O
i	long
++	O
)	O
{	O
rec_fex_elem_t	pointer
elem	pointer
=	O
rec_fex_get	function
(	O
fields	pointer
,	O
i	long
)	O
;	O
const	O
char	O
*	O
field_name	pointer
=	O
rec_fex_elem_field_name	function
(	O
elem	pointer
)	O
;	O
rec_field_t	pointer
field1	pointer
=	O
rec_record_get_field_by_name	function
(	O
record1	pointer
,	O
field_name	pointer
,	O
0	int
)	O
;	O
rec_field_t	pointer
field2	pointer
=	O
rec_record_get_field_by_name	function
(	O
record2	pointer
,	O
field_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
field1	pointer
&&	O
!	O
field2	pointer
)	O
{	O
result	pointer
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
field1	pointer
&&	O
field2	pointer
)	O
{	O
result	pointer
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
field1	pointer
&&	O
!	O
field2	pointer
)	O
{	O
result	pointer
=	O
-	O
1	int
;	O
break	O
;	O
}	O
result	pointer
=	O
rec_type_values_cmp	function
(	O
rec_rset_get_field_type	function
(	O
rset	pointer
,	O
field_name	pointer
)	O
,	O
rec_field_value	function
(	O
field1	pointer
)	O
,	O
rec_field_value	function
(	O
field2	pointer
)	O
)	O
;	O
if	O
(	O
result	pointer
!=	O
0	int
)	O
{	O
break	O
;	O
}	O
}	O
return	O
result	pointer
;	O
}	O
