static	O
void	O
status_string	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
s	pointer
,	O
int	O
w	pointer
)	O
{	O
char	O
byte_str	array
[	O
16	int
]	O
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
<	O
edit	pointer
->	O
last_byte	long
)	O
{	O
unsigned	O
char	O
cur_byte	char
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
g_snprintf	function
(	O
byte_str	array
,	O
sizeof	O
(	O
byte_str	array
)	O
,	O
"%c %3d 0x%02X"	pointer
,	O
is_printable	function
(	O
cur_byte	char
)	O
?	O
cur_byte	char
:	O
'.'	O
,	O
(	O
int	O
)	O
cur_byte	char
,	O
(	O
unsigned	O
)	O
cur_byte	char
)	O
;	O
}	O
else	O
{	O
strcpy	function
(	O
byte_str	array
,	O
"<EOF>"	pointer
)	O
;	O
}	O
g_snprintf	function
(	O
s	pointer
,	O
w	pointer
,	O
"[%c%c%c%c] %2ld L:[%3ld+%2ld %3ld/%3ld] *(%-4ld/%4ldb)= %s"	pointer
,	O
edit	pointer
->	O
mark1	long
!=	O
edit	pointer
->	O
mark2	long
?	O
(	O
column_highlighting	int
?	O
'C'	O
:	O
'B'	O
)	O
:	O
'-'	O
,	O
edit	pointer
->	O
modified	long
?	O
'M'	O
:	O
'-'	O
,	O
edit	pointer
->	O
macro_i	int
<	O
0	int
?	O
'-'	O
:	O
'R'	O
,	O
edit	pointer
->	O
overwrite	int
==	O
0	int
?	O
'-'	O
:	O
'O'	O
,	O
edit	pointer
->	O
curs_col	long
,	O
edit	pointer
->	O
start_line	long
+	O
1	int
,	O
edit	pointer
->	O
curs_row	long
,	O
edit	pointer
->	O
curs_line	long
+	O
1	int
,	O
edit	pointer
->	O
total_lines	long
+	O
1	int
,	O
edit	pointer
->	O
curs1	long
,	O
edit	pointer
->	O
last_byte	long
,	O
byte_str	array
)	O
;	O
}	O
static	O
inline	O
void	O
printwstr	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
tty_printf	function
(	O
"%-*.*s"	pointer
,	O
len	int
,	O
len	int
,	O
s	pointer
)	O
;	O
}	O
void	O
edit_status	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
const	O
int	O
w	pointer
=	O
edit	pointer
->	O
widget	pointer
.	O
cols	int
;	O
const	O
size_t	long
status_size	long
=	O
w	pointer
+	O
1	int
;	O
char	O
*	O
const	O
status	int
=	O
g_malloc	function
(	O
status_size	long
)	O
;	O
int	O
status_len	int
;	O
const	O
char	O
*	O
fname	pointer
=	O
""	pointer
;	O
int	O
fname_len	int
;	O
const	O
int	O
gap	int
=	O
3	int
;	O
const	O
int	O
right_gap	int
=	O
2	int
;	O
const	O
int	O
preferred_fname_len	int
=	O
16	int
;	O
status_string	function
(	O
edit	pointer
,	O
status	int
,	O
status_size	long
)	O
;	O
status_len	int
=	O
(	O
int	O
)	O
strlen	function
(	O
status	int
)	O
;	O
if	O
(	O
edit	pointer
->	O
filename	pointer
)	O
fname	pointer
=	O
edit	pointer
->	O
filename	pointer
;	O
fname_len	int
=	O
strlen	function
(	O
fname	pointer
)	O
;	O
if	O
(	O
fname_len	int
<	O
preferred_fname_len	int
)	O
fname_len	int
=	O
preferred_fname_len	int
;	O
if	O
(	O
fname_len	int
+	O
gap	int
+	O
status_len	int
+	O
right_gap	int
>=	O
w	pointer
)	O
{	O
if	O
(	O
preferred_fname_len	int
+	O
gap	int
+	O
status_len	int
+	O
right_gap	int
>=	O
w	pointer
)	O
fname_len	int
=	O
preferred_fname_len	int
;	O
else	O
fname_len	int
=	O
w	pointer
-	O
(	O
gap	int
+	O
status_len	int
+	O
right_gap	int
)	O
;	O
fname	pointer
=	O
name_trunc	function
(	O
fname	pointer
,	O
fname_len	int
)	O
;	O
}	O
widget_move	O
(	O
edit	pointer
,	O
0	int
,	O
0	int
)	O
;	O
attrset	function
(	O
SELECTED_COLOR	O
)	O
;	O
printwstr	function
(	O
fname	pointer
,	O
fname_len	int
+	O
gap	int
)	O
;	O
printwstr	function
(	O
status	int
,	O
w	pointer
-	O
(	O
fname_len	int
+	O
gap	int
)	O
)	O
;	O
attrset	function
(	O
EDITOR_NORMAL_COLOR	O
)	O
;	O
g_free	function
(	O
status	int
)	O
;	O
}	O
void	O
edit_scroll_screen_over_cursor	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
p	pointer
;	O
int	O
outby	int
;	O
int	O
b_extreme	int
,	O
t_extreme	int
,	O
l_extreme	int
,	O
r_extreme	int
;	O
if	O
(	O
edit	pointer
->	O
num_widget_lines	int
<=	O
0	int
||	O
edit	pointer
->	O
num_widget_columns	int
<=	O
0	int
)	O
return	O
;	O
r_extreme	int
=	O
EDIT_RIGHT_EXTREME	O
;	O
l_extreme	int
=	O
EDIT_LEFT_EXTREME	O
;	O
b_extreme	int
=	O
EDIT_BOTTOM_EXTREME	O
;	O
t_extreme	int
=	O
EDIT_TOP_EXTREME	O
;	O
if	O
(	O
edit	pointer
->	O
found_len	int
)	O
{	O
b_extreme	int
=	O
max	long
(	O
edit	pointer
->	O
num_widget_lines	int
/	O
4	int
,	O
b_extreme	int
)	O
;	O
t_extreme	int
=	O
max	long
(	O
edit	pointer
->	O
num_widget_lines	int
/	O
4	int
,	O
t_extreme	int
)	O
;	O
}	O
if	O
(	O
b_extreme	int
+	O
t_extreme	int
+	O
1	int
>	O
edit	pointer
->	O
num_widget_lines	int
)	O
{	O
int	O
n	long
;	O
n	long
=	O
b_extreme	int
+	O
t_extreme	int
;	O
b_extreme	int
=	O
(	O
b_extreme	int
*	O
(	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
)	O
)	O
/	O
n	long
;	O
t_extreme	int
=	O
(	O
t_extreme	int
*	O
(	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
)	O
)	O
/	O
n	long
;	O
}	O
if	O
(	O
l_extreme	int
+	O
r_extreme	int
+	O
1	int
>	O
edit	pointer
->	O
num_widget_columns	int
)	O
{	O
int	O
n	long
;	O
n	long
=	O
l_extreme	int
+	O
t_extreme	int
;	O
l_extreme	int
=	O
(	O
l_extreme	int
*	O
(	O
edit	pointer
->	O
num_widget_columns	int
-	O
1	int
)	O
)	O
/	O
n	long
;	O
r_extreme	int
=	O
(	O
r_extreme	int
*	O
(	O
edit	pointer
->	O
num_widget_columns	int
-	O
1	int
)	O
)	O
/	O
n	long
;	O
}	O
p	pointer
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
outby	int
=	O
p	pointer
+	O
edit	pointer
->	O
start_col	long
-	O
edit	pointer
->	O
num_widget_columns	int
+	O
1	int
+	O
(	O
r_extreme	int
+	O
edit	pointer
->	O
found_len	int
)	O
;	O
if	O
(	O
outby	int
>	O
0	int
)	O
edit_scroll_right	function
(	O
edit	pointer
,	O
outby	int
)	O
;	O
outby	int
=	O
l_extreme	int
-	O
p	pointer
-	O
edit	pointer
->	O
start_col	long
;	O
if	O
(	O
outby	int
>	O
0	int
)	O
edit_scroll_left	function
(	O
edit	pointer
,	O
outby	int
)	O
;	O
p	pointer
=	O
edit	pointer
->	O
curs_row	long
;	O
outby	int
=	O
p	pointer
-	O
edit	pointer
->	O
num_widget_lines	int
+	O
1	int
+	O
b_extreme	int
;	O
if	O
(	O
outby	int
>	O
0	int
)	O
edit_scroll_downward	function
(	O
edit	pointer
,	O
outby	int
)	O
;	O
outby	int
=	O
t_extreme	int
-	O
p	pointer
;	O
if	O
(	O
outby	int
>	O
0	int
)	O
edit_scroll_upward	function
(	O
edit	pointer
,	O
outby	int
)	O
;	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
}	O
static	O
void	O
print_to_widget	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
row	long
,	O
int	O
start_col	long
,	O
int	O
start_col_real	int
,	O
long	O
end_col	long
,	O
unsigned	O
int	O
line	int
[	O
]	O
)	O
{	O
unsigned	O
int	O
*	O
p	pointer
;	O
int	O
x	array
=	O
start_col_real	int
+	O
EDIT_TEXT_HORIZONTAL_OFFSET	int
;	O
int	O
x1	int
=	O
start_col	long
+	O
EDIT_TEXT_HORIZONTAL_OFFSET	int
;	O
int	O
y	short
=	O
row	long
+	O
EDIT_TEXT_VERTICAL_OFFSET	int
;	O
int	O
cols_to_skip	int
=	O
abs	function
(	O
x	array
)	O
;	O
set_color	O
(	O
EDITOR_NORMAL_COLOR	O
)	O
;	O
edit_move	O
(	O
x1	int
,	O
y	short
)	O
;	O
hline	function
(	O
' '	O
,	O
end_col	long
+	O
1	int
-	O
EDIT_TEXT_HORIZONTAL_OFFSET	int
-	O
x1	int
)	O
;	O
edit_move	O
(	O
x1	int
+	O
FONT_OFFSET_X	int
,	O
y	short
+	O
FONT_OFFSET_Y	int
)	O
;	O
p	pointer
=	O
line	int
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
int	O
style	int
;	O
int	O
textchar	int
;	O
int	O
color	pointer
;	O
if	O
(	O
cols_to_skip	int
)	O
{	O
p	pointer
++	O
;	O
cols_to_skip	int
--	O
;	O
continue	O
;	O
}	O
style	int
=	O
*	O
p	pointer
&	O
0xFF00	int
;	O
textchar	int
=	O
*	O
p	pointer
&	O
0xFF	int
;	O
color	pointer
=	O
*	O
p	pointer
>>	O
16	int
;	O
if	O
(	O
style	int
&	O
MOD_ABNORMAL	O
)	O
{	O
color	pointer
=	O
0	int
;	O
}	O
if	O
(	O
style	int
&	O
MOD_WHITESPACE	O
)	O
{	O
if	O
(	O
style	int
&	O
MOD_MARKED	O
)	O
{	O
textchar	int
=	O
' '	O
;	O
set_color	O
(	O
EDITOR_MARKED_COLOR	O
)	O
;	O
}	O
else	O
{	O
set_color	O
(	O
EDITOR_WHITESPACE_COLOR	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
style	int
&	O
MOD_BOLD	O
)	O
{	O
set_color	O
(	O
EDITOR_BOLD_COLOR	O
)	O
;	O
}	O
else	O
if	O
(	O
style	int
&	O
MOD_MARKED	O
)	O
{	O
set_color	O
(	O
EDITOR_MARKED_COLOR	O
)	O
;	O
}	O
else	O
{	O
lowlevel_set_color	O
(	O
color	pointer
)	O
;	O
}	O
}	O
addch	O
(	O
textchar	int
)	O
;	O
p	pointer
++	O
;	O
}	O
}	O
int	O
visible_tabs	int
=	O
1	int
,	O
visible_tws	int
=	O
1	int
;	O
static	O
void	O
edit_draw_this_line	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
b	pointer
,	O
long	O
row	long
,	O
long	O
start_col	long
,	O
long	O
end_col	long
)	O
{	O
static	O
unsigned	O
int	O
line	int
[	O
MAX_LINE_LEN	int
]	O
;	O
unsigned	O
int	O
*	O
p	pointer
=	O
line	int
;	O
long	O
m1	long
=	O
0	int
,	O
m2	long
=	O
0	int
,	O
q	long
,	O
c1	int
,	O
c2	int
,	O
tws	long
;	O
int	O
col	int
,	O
start_col_real	int
;	O
unsigned	O
int	O
c	int
;	O
int	O
color	pointer
;	O
int	O
i	array
;	O
edit_get_syntax_color	function
(	O
edit	pointer
,	O
b	pointer
-	O
1	int
,	O
&	O
color	pointer
)	O
;	O
q	long
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
b	pointer
,	O
start_col	long
-	O
edit	pointer
->	O
start_col	long
,	O
0	int
)	O
;	O
start_col_real	int
=	O
(	O
col	int
=	O
(	O
int	O
)	O
edit_move_forward3	function
(	O
edit	pointer
,	O
b	pointer
,	O
0	int
,	O
q	long
)	O
)	O
+	O
edit	pointer
->	O
start_col	long
;	O
c1	int
=	O
min	long
(	O
edit	pointer
->	O
column1	int
,	O
edit	pointer
->	O
column2	int
)	O
;	O
c2	int
=	O
max	long
(	O
edit	pointer
->	O
column1	int
,	O
edit	pointer
->	O
column2	int
)	O
;	O
if	O
(	O
col	int
+	O
16	int
>	O
-	O
edit	pointer
->	O
start_col	long
)	O
{	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
m1	long
,	O
&	O
m2	long
)	O
;	O
if	O
(	O
row	long
<=	O
edit	pointer
->	O
total_lines	long
-	O
edit	pointer
->	O
start_line	long
)	O
{	O
if	O
(	O
use_colors	int
&&	O
visible_tws	int
)	O
{	O
tws	long
=	O
edit_eol	function
(	O
edit	pointer
,	O
b	pointer
)	O
;	O
while	O
(	O
tws	long
>	O
b	pointer
&&	O
(	O
(	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
tws	long
-	O
1	int
)	O
)	O
==	O
' '	O
||	O
c	int
==	O
'\t'	O
)	O
)	O
tws	long
--	O
;	O
}	O
while	O
(	O
col	int
<=	O
end_col	long
-	O
edit	pointer
->	O
start_col	long
)	O
{	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
q	long
==	O
edit	pointer
->	O
curs1	long
)	O
*	O
p	pointer
|=	O
MOD_CURSOR	O
;	O
if	O
(	O
q	long
>=	O
m1	long
&&	O
q	long
<	O
m2	long
)	O
{	O
if	O
(	O
column_highlighting	int
)	O
{	O
int	O
x	array
;	O
x	array
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
b	pointer
,	O
0	int
,	O
q	long
)	O
;	O
if	O
(	O
x	array
>=	O
c1	int
&&	O
x	array
<	O
c2	int
)	O
*	O
p	pointer
|=	O
MOD_MARKED	O
;	O
}	O
else	O
*	O
p	pointer
|=	O
MOD_MARKED	O
;	O
}	O
if	O
(	O
q	long
==	O
edit	pointer
->	O
bracket	long
)	O
*	O
p	pointer
|=	O
MOD_BOLD	O
;	O
if	O
(	O
q	long
>=	O
edit	pointer
->	O
found_start	long
&&	O
q	long
<	O
edit	pointer
->	O
found_start	long
+	O
edit	pointer
->	O
found_len	int
)	O
*	O
p	pointer
|=	O
MOD_BOLD	O
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
q	long
)	O
;	O
edit_get_syntax_color	function
(	O
edit	pointer
,	O
q	long
,	O
&	O
color	pointer
)	O
;	O
*	O
p	pointer
|=	O
color	pointer
<<	O
16	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\n'	O
:	O
col	int
=	O
end_col	long
-	O
edit	pointer
->	O
start_col	long
+	O
1	int
;	O
*	O
(	O
p	pointer
++	O
)	O
|=	O
' '	O
;	O
break	O
;	O
case	O
'\t'	O
:	O
i	array
=	O
TAB_SIZE	O
-	O
(	O
(	O
int	O
)	O
col	int
%	O
TAB_SIZE	O
)	O
;	O
col	int
+=	O
i	array
;	O
if	O
(	O
use_colors	int
&&	O
visible_tabs	int
)	O
{	O
c	int
=	O
(	O
*	O
p	pointer
&	O
~	O
MOD_CURSOR	O
)	O
|	O
MOD_WHITESPACE	O
;	O
if	O
(	O
i	array
>	O
2	int
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
|=	O
'<'	O
|	O
MOD_WHITESPACE	O
;	O
while	O
(	O
--	O
i	array
>	O
1	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
c	int
|	O
'-'	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
c	int
|	O
'>'	O
;	O
}	O
else	O
if	O
(	O
i	array
>	O
1	int
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
|=	O
'<'	O
|	O
MOD_WHITESPACE	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
c	int
|	O
'>'	O
;	O
}	O
else	O
*	O
(	O
p	pointer
++	O
)	O
|=	O
'>'	O
|	O
MOD_WHITESPACE	O
;	O
}	O
else	O
if	O
(	O
use_colors	int
&&	O
visible_tws	int
&&	O
q	long
>=	O
tws	long
)	O
{	O
*	O
p	pointer
|=	O
'.'	O
|	O
MOD_WHITESPACE	O
;	O
c	int
=	O
*	O
(	O
p	pointer
++	O
)	O
&	O
~	O
MOD_CURSOR	O
;	O
while	O
(	O
--	O
i	array
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
c	int
;	O
}	O
else	O
{	O
*	O
p	pointer
|=	O
' '	O
;	O
c	int
=	O
*	O
(	O
p	pointer
++	O
)	O
&	O
~	O
MOD_CURSOR	O
;	O
while	O
(	O
--	O
i	array
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
c	int
;	O
}	O
break	O
;	O
case	O
' '	O
:	O
if	O
(	O
use_colors	int
&&	O
visible_tws	int
&&	O
q	long
>=	O
tws	long
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
|=	O
'.'	O
|	O
MOD_WHITESPACE	O
;	O
col	int
++	O
;	O
break	O
;	O
}	O
default	O
:	O
c	int
=	O
convert_to_display_c	O
(	O
c	int
)	O
;	O
if	O
(	O
c	int
<	O
32	int
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
'^'	O
|	O
MOD_ABNORMAL	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
(	O
c	int
+	O
0x40	int
)	O
|	O
MOD_ABNORMAL	O
;	O
col	int
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
127	int
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
'^'	O
|	O
MOD_ABNORMAL	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
'?'	O
|	O
MOD_ABNORMAL	O
;	O
col	int
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
is_printable	function
(	O
c	int
)	O
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
|=	O
c	int
;	O
}	O
else	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
'.'	O
|	O
MOD_ABNORMAL	O
;	O
}	O
col	int
++	O
;	O
break	O
;	O
}	O
q	long
++	O
;	O
}	O
}	O
}	O
else	O
{	O
start_col_real	int
=	O
start_col	long
=	O
0	int
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
print_to_widget	function
(	O
edit	pointer
,	O
row	long
,	O
start_col	long
,	O
start_col_real	int
,	O
end_col	long
,	O
line	int
)	O
;	O
}	O
static	O
void	O
edit_draw_this_char	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
curs	long
,	O
long	O
row	long
)	O
{	O
int	O
b	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
curs	long
)	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
row	long
,	O
0	int
,	O
edit	pointer
->	O
num_widget_columns	int
-	O
1	int
)	O
;	O
}	O
static	O
void	O
render_edit_text	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
start_row	long
,	O
long	O
start_column	long
,	O
long	O
end_row	long
,	O
long	O
end_column	long
)	O
{	O
long	O
row	long
=	O
0	int
,	O
curs_row	long
;	O
static	O
int	O
prev_curs_row	int
=	O
0	int
;	O
static	O
long	O
prev_curs	long
=	O
0	int
;	O
int	O
force	int
=	O
edit	pointer
->	O
force	int
;	O
long	O
b	pointer
;	O
if	O
(	O
(	O
!	O
(	O
force	int
&	O
REDRAW_CHAR_ONLY	O
)	O
)	O
||	O
(	O
force	int
&	O
REDRAW_PAGE	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
force	int
&	O
REDRAW_IN_BOUNDS	O
)	O
)	O
{	O
start_row	long
=	O
0	int
;	O
end_row	long
=	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
;	O
start_column	long
=	O
0	int
;	O
end_column	long
=	O
edit	pointer
->	O
num_widget_columns	int
-	O
1	int
;	O
}	O
if	O
(	O
force	int
&	O
REDRAW_PAGE	O
)	O
{	O
row	long
=	O
start_row	long
;	O
b	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
start_display	long
,	O
start_row	long
,	O
0	int
)	O
;	O
while	O
(	O
row	long
<=	O
end_row	long
)	O
{	O
if	O
(	O
key_pending	O
(	O
edit	pointer
)	O
)	O
goto	O
exit_render	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
row	long
,	O
start_column	long
,	O
end_column	long
)	O
;	O
b	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
b	pointer
,	O
1	int
,	O
0	int
)	O
;	O
row	long
++	O
;	O
}	O
}	O
else	O
{	O
curs_row	long
=	O
edit	pointer
->	O
curs_row	long
;	O
if	O
(	O
force	int
&	O
REDRAW_BEFORE_CURSOR	O
)	O
{	O
if	O
(	O
start_row	long
<	O
curs_row	long
)	O
{	O
long	O
upto	int
=	O
curs_row	long
-	O
1	int
<=	O
end_row	long
?	O
curs_row	long
-	O
1	int
:	O
end_row	long
;	O
row	long
=	O
start_row	long
;	O
b	pointer
=	O
edit	pointer
->	O
start_display	long
;	O
while	O
(	O
row	long
<=	O
upto	int
)	O
{	O
if	O
(	O
key_pending	O
(	O
edit	pointer
)	O
)	O
goto	O
exit_render	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
row	long
,	O
start_column	long
,	O
end_column	long
)	O
;	O
b	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
b	pointer
,	O
1	int
,	O
0	int
)	O
;	O
}	O
}	O
}	O
b	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
curs_row	long
>=	O
start_row	long
&&	O
curs_row	long
<=	O
end_row	long
)	O
{	O
if	O
(	O
key_pending	O
(	O
edit	pointer
)	O
)	O
goto	O
exit_render	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
curs_row	long
,	O
start_column	long
,	O
end_column	long
)	O
;	O
}	O
if	O
(	O
force	int
&	O
REDRAW_AFTER_CURSOR	O
)	O
{	O
if	O
(	O
end_row	long
>	O
curs_row	long
)	O
{	O
row	long
=	O
curs_row	long
+	O
1	int
<	O
start_row	long
?	O
start_row	long
:	O
curs_row	long
+	O
1	int
;	O
b	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
b	pointer
,	O
1	int
,	O
0	int
)	O
;	O
while	O
(	O
row	long
<=	O
end_row	long
)	O
{	O
if	O
(	O
key_pending	O
(	O
edit	pointer
)	O
)	O
goto	O
exit_render	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
row	long
,	O
start_column	long
,	O
end_column	long
)	O
;	O
b	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
b	pointer
,	O
1	int
,	O
0	int
)	O
;	O
row	long
++	O
;	O
}	O
}	O
}	O
if	O
(	O
force	int
&	O
REDRAW_LINE_ABOVE	O
&&	O
curs_row	long
>=	O
1	int
)	O
{	O
row	long
=	O
curs_row	long
-	O
1	int
;	O
b	pointer
=	O
edit_move_backward	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
,	O
1	int
)	O
;	O
if	O
(	O
row	long
>=	O
start_row	long
&&	O
row	long
<=	O
end_row	long
)	O
{	O
if	O
(	O
key_pending	O
(	O
edit	pointer
)	O
)	O
goto	O
exit_render	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
row	long
,	O
start_column	long
,	O
end_column	long
)	O
;	O
}	O
}	O
if	O
(	O
force	int
&	O
REDRAW_LINE_BELOW	O
&&	O
row	long
<	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
)	O
{	O
row	long
=	O
curs_row	long
+	O
1	int
;	O
b	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
b	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
b	pointer
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
row	long
>=	O
start_row	long
&&	O
row	long
<=	O
end_row	long
)	O
{	O
if	O
(	O
key_pending	O
(	O
edit	pointer
)	O
)	O
goto	O
exit_render	O
;	O
edit_draw_this_line	function
(	O
edit	pointer
,	O
b	pointer
,	O
row	long
,	O
start_column	long
,	O
end_column	long
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
prev_curs_row	int
<	O
edit	pointer
->	O
curs_row	long
)	O
{	O
edit_draw_this_char	function
(	O
edit	pointer
,	O
prev_curs	long
,	O
prev_curs_row	int
)	O
;	O
edit_draw_this_char	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
,	O
edit	pointer
->	O
curs_row	long
)	O
;	O
}	O
else	O
{	O
edit_draw_this_char	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
,	O
edit	pointer
->	O
curs_row	long
)	O
;	O
edit_draw_this_char	function
(	O
edit	pointer
,	O
prev_curs	long
,	O
prev_curs_row	int
)	O
;	O
}	O
}	O
edit	pointer
->	O
force	int
=	O
0	int
;	O
prev_curs_row	int
=	O
edit	pointer
->	O
curs_row	long
;	O
prev_curs	long
=	O
edit	pointer
->	O
curs1	long
;	O
exit_render	O
:	O
edit	pointer
->	O
screen_modified	int
=	O
0	int
;	O
return	O
;	O
}	O
static	O
void	O
edit_render	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
page	int
,	O
int	O
row_start	int
,	O
int	O
col_start	int
,	O
int	O
row_end	int
,	O
int	O
col_end	int
)	O
{	O
if	O
(	O
page	int
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
|	O
REDRAW_IN_BOUNDS	O
;	O
if	O
(	O
edit	pointer
->	O
force	int
&	O
REDRAW_COMPLETELY	O
)	O
buttonbar_redraw	function
(	O
edit	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
;	O
render_edit_text	function
(	O
edit	pointer
,	O
row_start	int
,	O
col_start	int
,	O
row_end	int
,	O
col_end	int
)	O
;	O
if	O
(	O
edit	pointer
->	O
force	int
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
void	O
edit_render_keypress	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_render	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O