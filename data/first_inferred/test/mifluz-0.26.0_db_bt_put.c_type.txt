static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_put.c,v 1.6 2014/04/17 20:27:25 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__bam_dup_convert	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
PAGE	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__bam_ovput	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
,	O
PAGE	struct
*	O
,	O
u_int32_t	int
,	O
DBT	struct
*	O
)	O
)	O
;	O
int	O
CDB___bam_iitem	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
op	enum
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
op	enum
,	O
flags	int
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
,	O
bk_tmp	struct
;	O
BTREE	struct
*	O
t	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
bk_hdr	struct
,	O
tdbt	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_indx_t	short
indx	short
;	O
u_int32_t	int
data_size	int
,	O
have_bytes	int
,	O
need_bytes	int
,	O
needed	int
;	O
int	O
cmp	int
,	O
bigkey	int
,	O
bigdata	int
,	O
dupadjust	int
,	O
padrec	int
,	O
replace	int
,	O
ret	int
,	O
was_deleted	int
;	O
COMPQUIET	O
(	O
bk	pointer
,	O
NULL	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
h	pointer
=	O
cp	pointer
->	O
page	pointer
;	O
indx	short
=	O
cp	pointer
->	O
indx	short
;	O
dupadjust	int
=	O
replace	int
=	O
was_deleted	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
&&	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
&&	O
data	pointer
->	O
dlen	int
!=	O
data	pointer
->	O
size	int
)	O
{	O
data_size	int
=	O
data	pointer
->	O
size	int
;	O
goto	O
len_err	O
;	O
}	O
data_size	int
=	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
?	O
CDB___bam_partsize	function
(	O
op	enum
,	O
data	pointer
,	O
h	pointer
,	O
indx	short
)	O
:	O
data	pointer
->	O
size	int
;	O
padrec	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
)	O
{	O
if	O
(	O
data_size	int
>	O
t	pointer
->	O
re_len	int
)	O
{	O
len_err	O
:	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Length improper for fixed length record %lu"	pointer
,	O
(	O
u_long	long
)	O
data_size	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
data_size	int
<	O
t	pointer
->	O
re_len	int
)	O
{	O
padrec	int
=	O
1	int
;	O
data_size	int
=	O
t	pointer
->	O
re_len	int
;	O
}	O
}	O
if	O
(	O
padrec	int
||	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
tdbt	struct
=	O
*	O
data	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_build	function
(	O
dbc	pointer
,	O
op	enum
,	O
&	O
tdbt	struct
,	O
h	pointer
,	O
indx	short
,	O
data_size	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
data	pointer
=	O
&	O
tdbt	struct
;	O
}	O
if	O
(	O
op	enum
==	O
DB_CURRENT	int
&&	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
h	pointer
,	O
indx	short
+	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
O_INDX	int
:	O
0	int
)	O
,	O
dbp	pointer
->	O
dup_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Current data differs from put data"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
}	O
needed	int
=	O
0	int
;	O
bigdata	int
=	O
data_size	int
>	O
cp	pointer
->	O
ovflsize	short
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
DB_KEYFIRST	int
:	O
bigkey	int
=	O
key	struct
->	O
size	int
>	O
cp	pointer
->	O
ovflsize	short
;	O
if	O
(	O
bigkey	int
)	O
needed	int
+=	O
BOVERFLOW_PSIZE	O
;	O
else	O
needed	int
+=	O
BKEYDATA_PSIZE	O
(	O
key	struct
->	O
size	int
)	O
;	O
if	O
(	O
bigdata	int
)	O
needed	int
+=	O
BOVERFLOW_PSIZE	O
;	O
else	O
needed	int
+=	O
BKEYDATA_PSIZE	O
(	O
data_size	int
)	O
;	O
break	O
;	O
case	O
DB_AFTER	int
:	O
case	O
DB_BEFORE	int
:	O
case	O
DB_CURRENT	int
:	O
bigkey	int
=	O
0	int
;	O
if	O
(	O
op	enum
==	O
DB_CURRENT	int
)	O
{	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
O_INDX	int
:	O
0	int
)	O
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
have_bytes	int
=	O
BKEYDATA_PSIZE	O
(	O
bk	pointer
->	O
len	short
)	O
;	O
else	O
have_bytes	int
=	O
BOVERFLOW_PSIZE	O
;	O
need_bytes	int
=	O
0	int
;	O
}	O
else	O
{	O
have_bytes	int
=	O
0	int
;	O
need_bytes	int
=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
}	O
if	O
(	O
bigdata	int
)	O
need_bytes	int
+=	O
BOVERFLOW_PSIZE	O
;	O
else	O
need_bytes	int
+=	O
BKEYDATA_PSIZE	O
(	O
data_size	int
)	O
;	O
if	O
(	O
have_bytes	int
<	O
need_bytes	int
)	O
needed	int
+=	O
need_bytes	int
-	O
have_bytes	int
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_iitem"	pointer
,	O
op	enum
)	O
)	O
;	O
}	O
if	O
(	O
P_FREESPACE	O
(	O
h	pointer
)	O
<	O
needed	int
||	O
(	O
t	pointer
->	O
bt_maxkey	int
!=	O
0	int
&&	O
NUM_ENT	O
(	O
h	pointer
)	O
>	O
t	pointer
->	O
bt_maxkey	int
)	O
)	O
return	O
(	O
DB_NEEDSPLIT	O
)	O
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
DB_KEYFIRST	int
:	O
if	O
(	O
bigkey	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_ovput	function
(	O
dbc	pointer
,	O
B_OVERFLOW	int
,	O
PGNO_INVALID	int
,	O
h	pointer
,	O
indx	short
,	O
key	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
BKEYDATA_SIZE	O
(	O
key	struct
->	O
size	int
)	O
,	O
NULL	O
,	O
key	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
1	int
)	O
;	O
++	O
indx	short
;	O
break	O
;	O
case	O
DB_AFTER	int
:	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_adjindx	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
+	O
P_INDX	int
,	O
indx	short
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
+	O
P_INDX	int
,	O
1	int
)	O
;	O
indx	short
+=	O
3	int
;	O
dupadjust	int
=	O
1	int
;	O
cp	pointer
->	O
indx	short
+=	O
2	int
;	O
}	O
else	O
{	O
++	O
indx	short
;	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
1	int
)	O
;	O
cp	pointer
->	O
indx	short
+=	O
1	int
;	O
}	O
break	O
;	O
case	O
DB_BEFORE	int
:	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_adjindx	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
indx	short
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
1	int
)	O
;	O
++	O
indx	short
;	O
dupadjust	int
=	O
1	int
;	O
}	O
else	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
1	int
)	O
;	O
break	O
;	O
case	O
DB_CURRENT	int
:	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
++	O
indx	short
;	O
dupadjust	int
=	O
1	int
;	O
was_deleted	int
=	O
B_DISSET	O
(	O
bk	pointer
->	O
type	enum
)	O
;	O
}	O
if	O
(	O
bigdata	int
||	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
!=	O
B_KEYDATA	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_ditem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
}	O
replace	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_iitem"	pointer
,	O
op	enum
)	O
)	O
;	O
}	O
if	O
(	O
bigdata	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_ovput	function
(	O
dbc	pointer
,	O
B_OVERFLOW	int
,	O
PGNO_INVALID	int
,	O
h	pointer
,	O
indx	short
,	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
LF_ISSET	O
(	O
BI_DELETED	int
)	O
)	O
{	O
B_TSET	O
(	O
bk_tmp	struct
.	O
type	enum
,	O
B_KEYDATA	int
,	O
1	int
)	O
;	O
bk_tmp	struct
.	O
len	short
=	O
data	pointer
->	O
size	int
;	O
bk_hdr	struct
.	O
data	pointer
=	O
&	O
bk_tmp	struct
;	O
bk_hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BKEYDATA	struct
,	O
data	pointer
)	O
;	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
BKEYDATA_SIZE	O
(	O
data	pointer
->	O
size	int
)	O
,	O
&	O
bk_hdr	struct
,	O
data	pointer
)	O
;	O
}	O
else	O
if	O
(	O
replace	int
)	O
ret	int
=	O
CDB___bam_ritem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
data	pointer
)	O
;	O
else	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
BKEYDATA_SIZE	O
(	O
data	pointer
->	O
size	int
)	O
,	O
NULL	O
,	O
data	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fset	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
op	enum
==	O
DB_CURRENT	int
)	O
(	O
void	O
)	O
CDB___bam_ca_delete	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
indx	short
-	O
O_INDX	int
:	O
indx	short
,	O
0	int
)	O
;	O
else	O
{	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
1	int
)	O
;	O
cp	pointer
->	O
indx	short
=	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
indx	short
-	O
O_INDX	int
:	O
indx	short
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
&&	O
(	O
op	enum
!=	O
DB_CURRENT	int
||	O
was_deleted	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_adjust	function
(	O
dbc	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
dupadjust	int
&&	O
P_FREESPACE	O
(	O
h	pointer
)	O
<=	O
dbp	pointer
->	O
pgsize	int
/	O
2	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_dup_convert	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
-	O
O_INDX	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_RECNO	int
)	O
F_SET	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
u_int32_t	int
CDB___bam_partsize	function
(	O
op	enum
,	O
data	pointer
,	O
h	pointer
,	O
indx	short
)	O
u_int32_t	int
op	enum
,	O
indx	short
;	O
DBT	struct
*	O
data	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
u_int32_t	int
nbytes	long
;	O
if	O
(	O
op	enum
!=	O
DB_CURRENT	int
)	O
return	O
(	O
data	pointer
->	O
doff	int
+	O
data	pointer
->	O
size	int
)	O
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
O_INDX	int
:	O
0	int
)	O
)	O
;	O
nbytes	long
=	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
?	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
)	O
->	O
tlen	int
:	O
bk	pointer
->	O
len	short
;	O
if	O
(	O
nbytes	long
<	O
data	pointer
->	O
doff	int
+	O
data	pointer
->	O
dlen	int
)	O
return	O
(	O
data	pointer
->	O
doff	int
+	O
data	pointer
->	O
size	int
)	O
;	O
return	O
(	O
nbytes	long
+	O
data	pointer
->	O
size	int
-	O
data	pointer
->	O
dlen	int
)	O
;	O
}	O
int	O
CDB___bam_build	function
(	O
dbc	pointer
,	O
op	enum
,	O
dbt	struct
,	O
h	pointer
,	O
indx	short
,	O
nbytes	long
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
op	enum
,	O
indx	short
,	O
nbytes	long
;	O
DBT	struct
*	O
dbt	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
,	O
tbk	struct
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
BTREE	struct
*	O
t	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
copy	struct
;	O
u_int32_t	int
len	short
,	O
tlen	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
int	O
ret	int
;	O
COMPQUIET	O
(	O
bo	pointer
,	O
NULL	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
if	O
(	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
<	O
nbytes	long
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
nbytes	long
,	O
NULL	O
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
=	O
nbytes	long
;	O
}	O
memset	function
(	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
?	O
t	pointer
->	O
re_pad	int
:	O
0	int
,	O
nbytes	long
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_PARTIAL	int
)	O
||	O
op	enum
!=	O
DB_CURRENT	int
)	O
{	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
+	O
dbt	struct
->	O
doff	int
;	O
tlen	int
=	O
dbt	struct
->	O
doff	int
;	O
goto	O
user_copy	O
;	O
}	O
if	O
(	O
indx	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
{	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
O_INDX	int
:	O
0	int
)	O
)	O
;	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
}	O
else	O
{	O
bk	pointer
=	O
&	O
tbk	struct
;	O
B_TSET	O
(	O
bk	pointer
->	O
type	enum
,	O
B_KEYDATA	int
,	O
0	int
)	O
;	O
bk	pointer
->	O
len	short
=	O
0	int
;	O
}	O
if	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
{	O
memset	function
(	O
&	O
copy	struct
,	O
0	int
,	O
sizeof	O
(	O
copy	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
&	O
copy	struct
,	O
bo	pointer
->	O
tlen	int
,	O
bo	pointer
->	O
pgno	int
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
tlen	int
=	O
dbt	struct
->	O
doff	int
;	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
+	O
dbt	struct
->	O
doff	int
;	O
if	O
(	O
bo	pointer
->	O
tlen	int
>	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
)	O
{	O
len	short
=	O
bo	pointer
->	O
tlen	int
-	O
(	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
)	O
;	O
if	O
(	O
dbt	struct
->	O
dlen	int
!=	O
dbt	struct
->	O
size	int
)	O
memmove	function
(	O
p	pointer
+	O
dbt	struct
->	O
size	int
,	O
p	pointer
+	O
dbt	struct
->	O
dlen	int
,	O
len	short
)	O
;	O
tlen	int
+=	O
len	short
;	O
}	O
}	O
else	O
{	O
memcpy	function
(	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
bk	pointer
->	O
data	pointer
,	O
dbt	struct
->	O
doff	int
>	O
bk	pointer
->	O
len	short
?	O
bk	pointer
->	O
len	short
:	O
dbt	struct
->	O
doff	int
)	O
;	O
tlen	int
=	O
dbt	struct
->	O
doff	int
;	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
+	O
dbt	struct
->	O
doff	int
;	O
len	short
=	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
;	O
if	O
(	O
bk	pointer
->	O
len	short
>	O
len	short
)	O
{	O
memcpy	function
(	O
p	pointer
+	O
dbt	struct
->	O
size	int
,	O
bk	pointer
->	O
data	pointer
+	O
len	short
,	O
bk	pointer
->	O
len	short
-	O
len	short
)	O
;	O
tlen	int
+=	O
bk	pointer
->	O
len	short
-	O
len	short
;	O
}	O
}	O
user_copy	O
:	O
memcpy	function
(	O
p	pointer
,	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
;	O
tlen	int
+=	O
dbt	struct
->	O
size	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
size	int
=	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
?	O
t	pointer
->	O
re_len	int
:	O
tlen	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
dlen	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
doff	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
flags	int
=	O
0	int
;	O
*	O
dbt	struct
=	O
dbc	pointer
->	O
rdata	struct
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_ritem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
data	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
u_int32_t	int
indx	short
;	O
DBT	struct
*	O
data	pointer
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
orig	struct
,	O
repl	struct
;	O
db_indx_t	short
cnt	short
,	O
lo	short
,	O
ln	short
,	O
min	short
,	O
off	long
,	O
prefix	int
,	O
suffix	int
;	O
int32_t	int
nbytes	long
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
p	pointer
,	O
*	O
t	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
min	short
=	O
data	pointer
->	O
size	int
<	O
bk	pointer
->	O
len	short
?	O
data	pointer
->	O
size	int
:	O
bk	pointer
->	O
len	short
;	O
for	O
(	O
prefix	int
=	O
0	int
,	O
p	pointer
=	O
bk	pointer
->	O
data	pointer
,	O
t	pointer
=	O
data	pointer
->	O
data	pointer
;	O
prefix	int
<	O
min	short
&&	O
*	O
p	pointer
==	O
*	O
t	pointer
;	O
++	O
prefix	int
,	O
++	O
p	pointer
,	O
++	O
t	pointer
)	O
;	O
min	short
-=	O
prefix	int
;	O
for	O
(	O
suffix	int
=	O
0	int
,	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
bk	pointer
->	O
data	pointer
+	O
bk	pointer
->	O
len	short
-	O
1	int
,	O
t	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
data	pointer
->	O
data	pointer
+	O
data	pointer
->	O
size	int
-	O
1	int
;	O
suffix	int
<	O
min	short
&&	O
*	O
p	pointer
==	O
*	O
t	pointer
;	O
++	O
suffix	int
,	O
--	O
p	pointer
,	O
--	O
t	pointer
)	O
;	O
orig	struct
.	O
data	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
bk	pointer
->	O
data	pointer
+	O
prefix	int
;	O
orig	struct
.	O
size	int
=	O
bk	pointer
->	O
len	short
-	O
(	O
prefix	int
+	O
suffix	int
)	O
;	O
repl	struct
.	O
data	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
data	pointer
->	O
data	pointer
+	O
prefix	int
;	O
repl	struct
.	O
size	int
=	O
data	pointer
->	O
size	int
-	O
(	O
prefix	int
+	O
suffix	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_repl_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
h	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
&	O
LSN	O
(	O
h	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
indx	short
,	O
(	O
u_int32_t	int
)	O
B_DISSET	O
(	O
bk	pointer
->	O
type	enum
)	O
,	O
&	O
orig	struct
,	O
&	O
repl	struct
,	O
(	O
u_int32_t	int
)	O
prefix	int
,	O
(	O
u_int32_t	int
)	O
suffix	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
HOFFSET	O
(	O
h	pointer
)	O
;	O
t	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
bk	pointer
;	O
lo	short
=	O
BKEYDATA_SIZE	O
(	O
bk	pointer
->	O
len	short
)	O
;	O
ln	short
=	O
BKEYDATA_SIZE	O
(	O
data	pointer
->	O
size	int
)	O
;	O
if	O
(	O
lo	short
!=	O
ln	short
)	O
{	O
nbytes	long
=	O
lo	short
-	O
ln	short
;	O
if	O
(	O
p	pointer
==	O
t	pointer
)	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
+=	O
nbytes	long
;	O
else	O
{	O
memmove	function
(	O
p	pointer
+	O
nbytes	long
,	O
p	pointer
,	O
t	pointer
-	O
p	pointer
)	O
;	O
off	long
=	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
;	O
for	O
(	O
cnt	short
=	O
0	int
;	O
cnt	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
++	O
cnt	short
)	O
if	O
(	O
h	pointer
->	O
inp	array
[	O
cnt	short
]	O
<=	O
off	long
)	O
h	pointer
->	O
inp	array
[	O
cnt	short
]	O
+=	O
nbytes	long
;	O
}	O
HOFFSET	O
(	O
h	pointer
)	O
+=	O
nbytes	long
;	O
t	pointer
+=	O
nbytes	long
;	O
}	O
bk	pointer
=	O
(	O
BKEYDATA	struct
*	O
)	O
t	pointer
;	O
B_TSET	O
(	O
bk	pointer
->	O
type	enum
,	O
B_KEYDATA	int
,	O
0	int
)	O
;	O
bk	pointer
->	O
len	short
=	O
data	pointer
->	O
size	int
;	O
memcpy	function
(	O
bk	pointer
->	O
data	pointer
,	O
data	pointer
->	O
data	pointer
,	O
data	pointer
->	O
size	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_dup_convert	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
u_int32_t	int
indx	short
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
hdr	struct
;	O
PAGE	struct
*	O
dp	pointer
;	O
db_indx_t	short
cnt	short
,	O
cpindx	short
,	O
first	short
,	O
sz	short
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
while	O
(	O
indx	short
>	O
0	int
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
-	O
P_INDX	int
]	O
)	O
indx	short
-=	O
P_INDX	int
;	O
for	O
(	O
cnt	short
=	O
0	int
,	O
sz	short
=	O
0	int
,	O
first	short
=	O
indx	short
;	O
;	O
++	O
cnt	short
,	O
indx	short
+=	O
P_INDX	int
)	O
{	O
if	O
(	O
indx	short
>=	O
NUM_ENT	O
(	O
h	pointer
)	O
||	O
h	pointer
->	O
inp	array
[	O
first	short
]	O
!=	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
)	O
break	O
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
)	O
;	O
sz	short
+=	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_KEYDATA	int
?	O
BKEYDATA_PSIZE	O
(	O
bk	pointer
->	O
len	short
)	O
:	O
BOVERFLOW_PSIZE	O
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
O_INDX	int
)	O
;	O
sz	short
+=	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_KEYDATA	int
?	O
BKEYDATA_PSIZE	O
(	O
bk	pointer
->	O
len	short
)	O
:	O
BOVERFLOW_PSIZE	O
;	O
}	O
if	O
(	O
cnt	short
==	O
1	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
sz	short
<	O
dbp	pointer
->	O
pgsize	int
/	O
4	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
(	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
P_LRECNO	int
:	O
P_LDUP	int
)	O
|	O
dbp	pointer
->	O
tags	char
)	O
,	O
&	O
dp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
P_INIT	O
(	O
dp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
dp	pointer
->	O
pgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
LEAFLEVEL	int
,	O
TYPE	O
(	O
dp	pointer
)	O
,	O
TAGS	O
(	O
dp	pointer
)	O
)	O
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
for	O
(	O
indx	short
=	O
first	short
+	O
O_INDX	int
,	O
cpindx	short
=	O
0	int
;	O
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_ca_dup	function
(	O
dbp	pointer
,	O
first	short
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
-	O
O_INDX	int
,	O
PGNO	O
(	O
dp	pointer
)	O
,	O
cpindx	short
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
bk	pointer
;	O
hdr	struct
.	O
size	int
=	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_KEYDATA	int
?	O
BKEYDATA_SIZE	O
(	O
bk	pointer
->	O
len	short
)	O
:	O
BOVERFLOW_SIZE	O
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
||	O
!	O
B_DISSET	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
dp	pointer
,	O
cpindx	short
,	O
hdr	struct
.	O
size	int
,	O
&	O
hdr	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
++	O
cpindx	short
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ditem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
hdr	struct
.	O
size	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
-	O
1	int
)	O
;	O
if	O
(	O
--	O
cnt	short
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_adjindx	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
first	short
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
indx	short
,	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__bam_ovput	function
(	O
dbc	pointer
,	O
B_DUPLICATE	int
,	O
dp	pointer
->	O
pgno	int
,	O
h	pointer
,	O
indx	short
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
return	O
(	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
dp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
;	O
err	pointer
:	O
(	O
void	O
)	O
CDB___db_free	function
(	O
dbc	pointer
,	O
dp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_ovput	function
(	O
dbc	pointer
,	O
type	enum
,	O
pgno	int
,	O
h	pointer
,	O
indx	short
,	O
item	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
type	enum
,	O
indx	short
;	O
db_pgno_t	int
pgno	int
;	O
PAGE	struct
*	O
h	pointer
;	O
DBT	struct
*	O
item	pointer
;	O
{	O
BOVERFLOW	struct
bo	pointer
;	O
DBT	struct
hdr	struct
;	O
int	O
ret	int
;	O
UMRW	O
(	O
bo	pointer
.	O
unused1	array
)	O
;	O
B_TSET	O
(	O
bo	pointer
.	O
type	enum
,	O
type	enum
,	O
0	int
)	O
;	O
UMRW	O
(	O
bo	pointer
.	O
unused2	array
)	O
;	O
if	O
(	O
type	enum
==	O
B_OVERFLOW	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_poff	function
(	O
dbc	pointer
,	O
item	pointer
,	O
&	O
bo	pointer
.	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
bo	pointer
.	O
tlen	int
=	O
item	pointer
->	O
size	int
;	O
}	O
else	O
{	O
bo	pointer
.	O
pgno	int
=	O
pgno	int
;	O
bo	pointer
.	O
tlen	int
=	O
0	int
;	O
}	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
bo	pointer
;	O
hdr	struct
.	O
size	int
=	O
BOVERFLOW_SIZE	O
;	O
return	O
(	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
h	pointer
,	O
indx	short
,	O
BOVERFLOW_SIZE	O
,	O
&	O
hdr	struct
,	O
NULL	O
)	O
)	O
;	O
}	O