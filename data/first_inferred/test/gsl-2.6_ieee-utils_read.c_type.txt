static	O
int	O
lookup_string	function
(	O
const	O
char	O
*	O
p	*
,	O
int	O
*	O
precision	*
,	O
int	O
*	O
rounding	*
,	O
int	O
*	O
exception_mask	*
)	O
;	O
int	O
gsl_ieee_read_mode_string	function
(	O
const	O
char	O
*	O
description	*
,	O
int	O
*	O
precision	*
,	O
int	O
*	O
rounding	*
,	O
int	O
*	O
exception_mask	*
)	O
{	O
char	O
*	O
start	*
;	O
char	O
*	O
end	*
;	O
char	O
*	O
p	*
;	O
int	O
precision_count	int
=	O
0	int
;	O
int	O
rounding_count	int
=	O
0	int
;	O
int	O
exception_count	int
=	O
0	int
;	O
start	*
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
description	*
)	O
+	O
1	int
)	O
;	O
if	O
(	O
start	int
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"no memory to parse mode string"	*
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
strcpy	function
(	O
start	*
,	O
description	*
)	O
;	O
p	*
=	O
start	*
;	O
*	O
precision	*
=	O
0	int
;	O
*	O
rounding	*
=	O
0	int
;	O
*	O
exception_mask	*
=	O
0	int
;	O
do	O
{	O
int	O
status	int
;	O
int	O
new_precision	int
,	O
new_rounding	int
,	O
new_exception	int
;	O
end	*
=	O
strchr	function
(	O
p	*
,	O
','	O
)	O
;	O
if	O
(	O
end	int
)	O
{	O
*	O
end	*
=	O
'\0'	O
;	O
do	O
{	O
end	*
++	O
;	O
}	O
while	O
(	O
*	O
end	*
==	O
' '	O
||	O
*	O
end	*
==	O
','	O
)	O
;	O
}	O
new_precision	int
=	O
0	int
;	O
new_rounding	int
=	O
0	int
;	O
new_exception	int
=	O
0	int
;	O
status	int
=	O
lookup_string	function
(	O
p	*
,	O
&	O
new_precision	*
,	O
&	O
new_rounding	int
,	O
&	O
new_exception	*
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
start	*
)	O
;	O
GSL_ERROR	O
(	O
"unrecognized GSL_IEEE_MODE string.\nValid settings are:\n\n"	*
"  single-precision double-precision extended-precision\n"	*
"  round-to-nearest round-down round-up round-to-zero\n"	*
"  mask-invalid mask-denormalized mask-division-by-zero\n"	*
"  mask-overflow mask-underflow mask-all\n"	*
"  trap-common trap-inexact\n"	*
"\n"	*
"separated by commas. "	*
"(e.g. GSL_IEEE_MODE=\"round-down,mask-underflow\")"	*
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
new_precision	int
)	O
{	O
*	O
precision	*
=	O
new_precision	int
;	O
precision_count	int
++	O
;	O
if	O
(	O
precision_count	int
>	O
1	int
)	O
{	O
free	function
(	O
start	*
)	O
;	O
GSL_ERROR	O
(	O
"attempted to set IEEE precision twice"	*
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
new_rounding	int
)	O
{	O
*	O
rounding	*
=	O
new_rounding	int
;	O
rounding_count	int
++	O
;	O
if	O
(	O
rounding_count	int
>	O
1	int
)	O
{	O
free	function
(	O
start	*
)	O
;	O
GSL_ERROR	O
(	O
"attempted to set IEEE rounding mode twice"	*
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
new_exception	int
)	O
{	O
*	O
exception_mask	*
|=	O
new_exception	int
;	O
exception_count	int
++	O
;	O
}	O
p	*
=	O
end	*
;	O
}	O
while	O
(	O
end	*
&&	O
*	O
p	*
!=	O
'\0'	O
)	O
;	O
free	function
(	O
start	*
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
lookup_string	function
(	O
const	O
char	O
*	O
p	*
,	O
int	O
*	O
precision	*
,	O
int	O
*	O
rounding	*
,	O
int	O
*	O
exception_mask	*
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"single-precision"	*
)	O
==	O
0	int
)	O
{	O
*	O
precision	*
=	O
GSL_IEEE_SINGLE_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"double-precision"	*
)	O
==	O
0	int
)	O
{	O
*	O
precision	*
=	O
GSL_IEEE_DOUBLE_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"extended-precision"	*
)	O
==	O
0	int
)	O
{	O
*	O
precision	*
=	O
GSL_IEEE_EXTENDED_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"round-to-nearest"	*
)	O
==	O
0	int
)	O
{	O
*	O
rounding	*
=	O
GSL_IEEE_ROUND_TO_NEAREST	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"round-down"	*
)	O
==	O
0	int
)	O
{	O
*	O
rounding	*
=	O
GSL_IEEE_ROUND_DOWN	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"round-up"	*
)	O
==	O
0	int
)	O
{	O
*	O
rounding	*
=	O
GSL_IEEE_ROUND_UP	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"round-to-zero"	*
)	O
==	O
0	int
)	O
{	O
*	O
rounding	*
=	O
GSL_IEEE_ROUND_TO_ZERO	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"mask-all"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_MASK_ALL	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"mask-invalid"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_MASK_INVALID	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"mask-denormalized"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_MASK_DENORMALIZED	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"mask-division-by-zero"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_MASK_DIVISION_BY_ZERO	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"mask-overflow"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_MASK_OVERFLOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"mask-underflow"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_MASK_UNDERFLOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"trap-inexact"	*
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	*
=	O
GSL_IEEE_TRAP_INEXACT	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	*
,	O
"trap-common"	*
)	O
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O