typedef	O
long	O
int	O
long_int	long
;	O
verify	O
(	O
long_int_is_wide_enough	struct
,	O
INT_MAX	O
==	O
INT_MAX	O
*	O
(	O
long_int	long
)	O
2	int
/	O
2	int
)	O
;	O
verify	O
(	O
time_t_is_integer	struct
,	O
TYPE_IS_INTEGER	O
(	O
time_t	long
)	O
)	O
;	O
verify	O
(	O
twos_complement_arithmetic	struct
,	O
(	O
TYPE_TWOS_COMPLEMENT	O
(	O
int	O
)	O
&&	O
TYPE_TWOS_COMPLEMENT	O
(	O
long_int	long
)	O
&&	O
TYPE_TWOS_COMPLEMENT	O
(	O
time_t	long
)	O
)	O
)	O
;	O
verify	O
(	O
base_year_is_a_multiple_of_100	struct
,	O
TM_YEAR_BASE	int
%	O
100	int
==	O
0	int
)	O
;	O
static	O
int	O
leapyear	function
(	O
long_int	long
year	long
)	O
{	O
return	O
(	O
(	O
year	long
&	O
3	int
)	O
==	O
0	int
&&	O
(	O
year	long
%	O
100	int
!=	O
0	int
||	O
(	O
(	O
year	long
/	O
100	int
)	O
&	O
3	int
)	O
==	O
(	O
-	O
(	O
TM_YEAR_BASE	int
/	O
100	int
)	O
&	O
3	int
)	O
)	O
)	O
;	O
}	O
static	O
const	O
unsigned	O
short	O
int	O
__mon_yday	array
[	O
2	int
]	O
[	O
13	int
]	O
=	O
{	O
{	O
0	int
,	O
31	int
,	O
59	int
,	O
90	int
,	O
120	int
,	O
151	int
,	O
181	int
,	O
212	int
,	O
243	int
,	O
273	int
,	O
304	int
,	O
334	int
,	O
365	int
}	O
,	O
{	O
0	int
,	O
31	int
,	O
60	int
,	O
91	int
,	O
121	int
,	O
152	int
,	O
182	int
,	O
213	int
,	O
244	int
,	O
274	int
,	O
305	int
,	O
335	int
,	O
366	int
}	O
}	O
;	O
static	O
int	O
isdst_differ	function
(	O
int	O
a	array
,	O
int	O
b	int
)	O
{	O
return	O
(	O
!	O
a	array
!=	O
!	O
b	int
)	O
&&	O
(	O
0	int
<=	O
a	array
)	O
&&	O
(	O
0	int
<=	O
b	int
)	O
;	O
}	O
static	O
time_t	long
ydhms_diff	function
(	O
long_int	long
year1	long
,	O
long_int	long
yday1	long
,	O
int	O
hour1	int
,	O
int	O
min1	int
,	O
int	O
sec1	int
,	O
int	O
year0	int
,	O
int	O
yday0	int
,	O
int	O
hour0	int
,	O
int	O
min0	int
,	O
int	O
sec0	int
)	O
{	O
verify	O
(	O
C99_integer_division	struct
,	O
-	O
1	int
/	O
2	int
==	O
0	int
)	O
;	O
int	O
a4	int
=	O
SHR	O
(	O
year1	long
,	O
2	int
)	O
+	O
SHR	O
(	O
TM_YEAR_BASE	int
,	O
2	int
)	O
-	O
!	O
(	O
year1	long
&	O
3	int
)	O
;	O
int	O
b4	int
=	O
SHR	O
(	O
year0	int
,	O
2	int
)	O
+	O
SHR	O
(	O
TM_YEAR_BASE	int
,	O
2	int
)	O
-	O
!	O
(	O
year0	int
&	O
3	int
)	O
;	O
int	O
a100	int
=	O
a4	int
/	O
25	int
-	O
(	O
a4	int
%	O
25	int
<	O
0	int
)	O
;	O
int	O
b100	int
=	O
b4	int
/	O
25	int
-	O
(	O
b4	int
%	O
25	int
<	O
0	int
)	O
;	O
int	O
a400	int
=	O
SHR	O
(	O
a100	int
,	O
2	int
)	O
;	O
int	O
b400	int
=	O
SHR	O
(	O
b100	int
,	O
2	int
)	O
;	O
int	O
intervening_leap_days	int
=	O
(	O
a4	int
-	O
b4	int
)	O
-	O
(	O
a100	int
-	O
b100	int
)	O
+	O
(	O
a400	int
-	O
b400	int
)	O
;	O
time_t	long
tyear1	long
=	O
year1	long
;	O
time_t	long
years	long
=	O
tyear1	long
-	O
year0	int
;	O
time_t	long
days	long
=	O
365	int
*	O
years	long
+	O
yday1	long
-	O
yday0	int
+	O
intervening_leap_days	int
;	O
time_t	long
hours	long
=	O
24	int
*	O
days	long
+	O
hour1	int
-	O
hour0	int
;	O
time_t	long
minutes	long
=	O
60	int
*	O
hours	long
+	O
min1	int
-	O
min0	int
;	O
time_t	long
seconds	long
=	O
60	int
*	O
minutes	long
+	O
sec1	int
-	O
sec0	int
;	O
return	O
seconds	long
;	O
}	O
static	O
time_t	long
time_t_avg	function
(	O
time_t	long
a	array
,	O
time_t	long
b	int
)	O
{	O
return	O
SHR	O
(	O
a	array
,	O
1	int
)	O
+	O
SHR	O
(	O
b	int
,	O
1	int
)	O
+	O
(	O
a	array
&	O
b	int
&	O
1	int
)	O
;	O
}	O
static	O
int	O
time_t_add_ok	function
(	O
time_t	long
a	array
,	O
time_t	long
b	int
)	O
{	O
if	O
(	O
!	O
TYPE_SIGNED	O
(	O
time_t	long
)	O
)	O
{	O
time_t	long
sum	long
=	O
a	array
+	O
b	int
;	O
return	O
(	O
sum	long
<	O
a	array
)	O
==	O
(	O
TIME_T_MIDPOINT	O
<=	O
b	int
)	O
;	O
}	O
else	O
if	O
(	O
WRAPV	int
)	O
{	O
time_t	long
sum	long
=	O
a	array
+	O
b	int
;	O
return	O
(	O
sum	long
<	O
a	array
)	O
==	O
(	O
b	int
<	O
0	int
)	O
;	O
}	O
else	O
{	O
time_t	long
avg	long
=	O
time_t_avg	function
(	O
a	array
,	O
b	int
)	O
;	O
return	O
TIME_T_MIN	O
/	O
2	int
<=	O
avg	long
&&	O
avg	long
<=	O
TIME_T_MAX	O
/	O
2	int
;	O
}	O
}	O
static	O
int	O
time_t_int_add_ok	function
(	O
time_t	long
a	array
,	O
int	O
b	int
)	O
{	O
verify	O
(	O
int_no_wider_than_time_t	struct
,	O
INT_MAX	O
<=	O
TIME_T_MAX	O
)	O
;	O
if	O
(	O
WRAPV	int
)	O
{	O
time_t	long
sum	long
=	O
a	array
+	O
b	int
;	O
return	O
(	O
sum	long
<	O
a	array
)	O
==	O
(	O
b	int
<	O
0	int
)	O
;	O
}	O
else	O
{	O
int	O
a_odd	int
=	O
a	array
&	O
1	int
;	O
time_t	long
avg	long
=	O
SHR	O
(	O
a	array
,	O
1	int
)	O
+	O
(	O
SHR	O
(	O
b	int
,	O
1	int
)	O
+	O
(	O
a_odd	int
&	O
b	int
)	O
)	O
;	O
return	O
TIME_T_MIN	O
/	O
2	int
<=	O
avg	long
&&	O
avg	long
<=	O
TIME_T_MAX	O
/	O
2	int
;	O
}	O
}	O
static	O
time_t	long
guess_time_tm	function
(	O
long_int	long
year	long
,	O
long_int	long
yday	long
,	O
int	O
hour	int
,	O
int	O
min	int
,	O
int	O
sec	int
,	O
const	O
time_t	long
*	O
t	pointer
,	O
const	O
struct	O
tm	struct
*	O
tp	pointer
)	O
{	O
if	O
(	O
tp	pointer
)	O
{	O
time_t	long
d	long
=	O
ydhms_diff	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
tp	pointer
->	O
tm_year	int
,	O
tp	pointer
->	O
tm_yday	int
,	O
tp	pointer
->	O
tm_hour	int
,	O
tp	pointer
->	O
tm_min	int
,	O
tp	pointer
->	O
tm_sec	int
)	O
;	O
if	O
(	O
time_t_add_ok	function
(	O
*	O
t	pointer
,	O
d	long
)	O
)	O
return	O
*	O
t	pointer
+	O
d	long
;	O
}	O
return	O
(	O
*	O
t	pointer
<	O
TIME_T_MIDPOINT	O
?	O
(	O
*	O
t	pointer
<=	O
TIME_T_MIN	O
+	O
1	int
?	O
*	O
t	pointer
+	O
1	int
:	O
TIME_T_MIN	O
)	O
:	O
(	O
TIME_T_MAX	O
-	O
1	int
<=	O
*	O
t	pointer
?	O
*	O
t	pointer
-	O
1	int
:	O
TIME_T_MAX	O
)	O
)	O
;	O
}	O
static	O
struct	O
tm	struct
*	O
ranged_convert	function
(	O
struct	O
tm	struct
*	O
(	O
*	O
convert	pointer
)	O
(	O
const	O
time_t	long
*	O
,	O
struct	O
tm	struct
*	O
)	O
,	O
time_t	long
*	O
t	pointer
,	O
struct	O
tm	struct
*	O
tp	pointer
)	O
{	O
struct	O
tm	struct
*	O
r	pointer
=	O
convert	pointer
(	O
t	pointer
,	O
tp	pointer
)	O
;	O
if	O
(	O
!	O
r	pointer
&&	O
*	O
t	pointer
)	O
{	O
time_t	long
bad	long
=	O
*	O
t	pointer
;	O
time_t	long
ok	long
=	O
0	int
;	O
while	O
(	O
bad	long
!=	O
ok	long
+	O
(	O
bad	long
<	O
0	int
?	O
-	O
1	int
:	O
1	int
)	O
)	O
{	O
time_t	long
mid	long
=	O
*	O
t	pointer
=	O
time_t_avg	function
(	O
ok	long
,	O
bad	long
)	O
;	O
r	pointer
=	O
convert	pointer
(	O
t	pointer
,	O
tp	pointer
)	O
;	O
if	O
(	O
r	pointer
)	O
ok	long
=	O
mid	long
;	O
else	O
bad	long
=	O
mid	long
;	O
}	O
if	O
(	O
!	O
r	pointer
&&	O
ok	long
)	O
{	O
*	O
t	pointer
=	O
ok	long
;	O
r	pointer
=	O
convert	pointer
(	O
t	pointer
,	O
tp	pointer
)	O
;	O
}	O
}	O
return	O
r	pointer
;	O
}	O
time_t	long
__mktime_internal	O
(	O
struct	O
tm	struct
*	O
tp	pointer
,	O
struct	O
tm	struct
*	O
(	O
*	O
convert	pointer
)	O
(	O
const	O
time_t	long
*	O
,	O
struct	O
tm	struct
*	O
)	O
,	O
time_t	long
*	O
offset	long
)	O
{	O
time_t	long
t	pointer
,	O
gt	long
,	O
t0	long
,	O
t1	long
,	O
t2	long
;	O
struct	O
tm	struct
tm	struct
;	O
int	O
remaining_probes	int
=	O
6	int
;	O
int	O
sec	int
=	O
tp	pointer
->	O
tm_sec	int
;	O
int	O
min	int
=	O
tp	pointer
->	O
tm_min	int
;	O
int	O
hour	int
=	O
tp	pointer
->	O
tm_hour	int
;	O
int	O
mday	int
=	O
tp	pointer
->	O
tm_mday	int
;	O
int	O
mon	int
=	O
tp	pointer
->	O
tm_mon	int
;	O
int	O
year_requested	int
=	O
tp	pointer
->	O
tm_year	int
;	O
int	O
isdst	int
=	O
tp	pointer
->	O
tm_isdst	int
;	O
int	O
dst2	int
;	O
int	O
mon_remainder	int
=	O
mon	int
%	O
12	int
;	O
int	O
negative_mon_remainder	int
=	O
mon_remainder	int
<	O
0	int
;	O
int	O
mon_years	int
=	O
mon	int
/	O
12	int
-	O
negative_mon_remainder	int
;	O
long_int	long
lyear_requested	long
=	O
year_requested	int
;	O
long_int	long
year	long
=	O
lyear_requested	long
+	O
mon_years	int
;	O
int	O
mon_yday	int
=	O
(	O
(	O
__mon_yday	array
[	O
leapyear	function
(	O
year	long
)	O
]	O
[	O
mon_remainder	int
+	O
12	int
*	O
negative_mon_remainder	int
]	O
)	O
-	O
1	int
)	O
;	O
long_int	long
lmday	long
=	O
mday	int
;	O
long_int	long
yday	long
=	O
mon_yday	int
+	O
lmday	long
;	O
time_t	long
guessed_offset	long
=	O
*	O
offset	long
;	O
int	O
sec_requested	int
=	O
sec	int
;	O
if	O
(	O
LEAP_SECONDS_POSSIBLE	int
)	O
{	O
if	O
(	O
sec	int
<	O
0	int
)	O
sec	int
=	O
0	int
;	O
if	O
(	O
59	int
<	O
sec	int
)	O
sec	int
=	O
59	int
;	O
}	O
t0	long
=	O
ydhms_diff	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
EPOCH_YEAR	int
-	O
TM_YEAR_BASE	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
-	O
guessed_offset	long
)	O
;	O
if	O
(	O
TIME_T_MAX	O
/	O
INT_MAX	O
/	O
366	int
/	O
24	int
/	O
60	int
/	O
60	int
<	O
3	int
)	O
{	O
int	O
ALOG2_SECONDS_PER_BIENNIUM	int
=	O
26	int
;	O
int	O
ALOG2_MINUTES_PER_BIENNIUM	int
=	O
20	int
;	O
int	O
ALOG2_HOURS_PER_BIENNIUM	int
=	O
14	int
;	O
int	O
ALOG2_DAYS_PER_BIENNIUM	int
=	O
10	int
;	O
int	O
LOG2_YEARS_PER_BIENNIUM	int
=	O
1	int
;	O
int	O
approx_requested_biennia	int
=	O
(	O
SHR	O
(	O
year_requested	int
,	O
LOG2_YEARS_PER_BIENNIUM	int
)	O
-	O
SHR	O
(	O
EPOCH_YEAR	int
-	O
TM_YEAR_BASE	int
,	O
LOG2_YEARS_PER_BIENNIUM	int
)	O
+	O
SHR	O
(	O
mday	int
,	O
ALOG2_DAYS_PER_BIENNIUM	int
)	O
+	O
SHR	O
(	O
hour	int
,	O
ALOG2_HOURS_PER_BIENNIUM	int
)	O
+	O
SHR	O
(	O
min	int
,	O
ALOG2_MINUTES_PER_BIENNIUM	int
)	O
+	O
(	O
LEAP_SECONDS_POSSIBLE	int
?	O
0	int
:	O
SHR	O
(	O
sec	int
,	O
ALOG2_SECONDS_PER_BIENNIUM	int
)	O
)	O
)	O
;	O
int	O
approx_biennia	int
=	O
SHR	O
(	O
t0	long
,	O
ALOG2_SECONDS_PER_BIENNIUM	int
)	O
;	O
int	O
diff	int
=	O
approx_biennia	int
-	O
approx_requested_biennia	int
;	O
int	O
approx_abs_diff	int
=	O
diff	int
<	O
0	int
?	O
-	O
1	int
-	O
diff	int
:	O
diff	int
;	O
time_t	long
time_t_max	long
=	O
TIME_T_MAX	O
;	O
time_t	long
time_t_min	long
=	O
TIME_T_MIN	O
;	O
time_t	long
overflow_threshold	long
=	O
(	O
time_t_max	long
/	O
3	int
-	O
time_t_min	long
/	O
3	int
)	O
>>	O
ALOG2_SECONDS_PER_BIENNIUM	int
;	O
if	O
(	O
overflow_threshold	long
<	O
approx_abs_diff	int
)	O
{	O
time_t	long
repaired_t0	long
=	O
-	O
1	int
-	O
t0	long
;	O
approx_biennia	int
=	O
SHR	O
(	O
repaired_t0	long
,	O
ALOG2_SECONDS_PER_BIENNIUM	int
)	O
;	O
diff	int
=	O
approx_biennia	int
-	O
approx_requested_biennia	int
;	O
approx_abs_diff	int
=	O
diff	int
<	O
0	int
?	O
-	O
1	int
-	O
diff	int
:	O
diff	int
;	O
if	O
(	O
overflow_threshold	long
<	O
approx_abs_diff	int
)	O
return	O
-	O
1	int
;	O
guessed_offset	long
+=	O
repaired_t0	long
-	O
t0	long
;	O
t0	long
=	O
repaired_t0	long
;	O
}	O
}	O
for	O
(	O
t	pointer
=	O
t1	long
=	O
t2	long
=	O
t0	long
,	O
dst2	int
=	O
0	int
;	O
(	O
gt	long
=	O
guess_time_tm	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
&	O
t	pointer
,	O
ranged_convert	function
(	O
convert	pointer
,	O
&	O
t	pointer
,	O
&	O
tm	struct
)	O
)	O
,	O
t	pointer
!=	O
gt	long
)	O
;	O
t1	long
=	O
t2	long
,	O
t2	long
=	O
t	pointer
,	O
t	pointer
=	O
gt	long
,	O
dst2	int
=	O
tm	struct
.	O
tm_isdst	int
!=	O
0	int
)	O
if	O
(	O
t	pointer
==	O
t1	long
&&	O
t	pointer
!=	O
t2	long
&&	O
(	O
tm	struct
.	O
tm_isdst	int
<	O
0	int
||	O
(	O
isdst	int
<	O
0	int
?	O
dst2	int
<=	O
(	O
tm	struct
.	O
tm_isdst	int
!=	O
0	int
)	O
:	O
(	O
isdst	int
!=	O
0	int
)	O
!=	O
(	O
tm	struct
.	O
tm_isdst	int
!=	O
0	int
)	O
)	O
)	O
)	O
goto	O
offset_found	O
;	O
else	O
if	O
(	O
--	O
remaining_probes	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
isdst_differ	function
(	O
isdst	int
,	O
tm	struct
.	O
tm_isdst	int
)	O
)	O
{	O
int	O
stride	int
=	O
601200	int
;	O
int	O
duration_max	int
=	O
536454000	int
;	O
int	O
delta_bound	int
=	O
duration_max	int
/	O
2	int
+	O
stride	int
;	O
int	O
delta	int
,	O
direction	int
;	O
for	O
(	O
delta	int
=	O
stride	int
;	O
delta	int
<	O
delta_bound	int
;	O
delta	int
+=	O
stride	int
)	O
for	O
(	O
direction	int
=	O
-	O
1	int
;	O
direction	int
<=	O
1	int
;	O
direction	int
+=	O
2	int
)	O
if	O
(	O
time_t_int_add_ok	function
(	O
t	pointer
,	O
delta	int
*	O
direction	int
)	O
)	O
{	O
time_t	long
ot	long
=	O
t	pointer
+	O
delta	int
*	O
direction	int
;	O
struct	O
tm	struct
otm	struct
;	O
ranged_convert	function
(	O
convert	pointer
,	O
&	O
ot	long
,	O
&	O
otm	struct
)	O
;	O
if	O
(	O
!	O
isdst_differ	function
(	O
isdst	int
,	O
otm	struct
.	O
tm_isdst	int
)	O
)	O
{	O
t	pointer
=	O
guess_time_tm	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
&	O
ot	long
,	O
&	O
otm	struct
)	O
;	O
ranged_convert	function
(	O
convert	pointer
,	O
&	O
t	pointer
,	O
&	O
tm	struct
)	O
;	O
goto	O
offset_found	O
;	O
}	O
}	O
}	O
offset_found	O
:	O
*	O
offset	long
=	O
guessed_offset	long
+	O
t	pointer
-	O
t0	long
;	O
if	O
(	O
LEAP_SECONDS_POSSIBLE	int
&&	O
sec_requested	int
!=	O
tm	struct
.	O
tm_sec	int
)	O
{	O
int	O
sec_adjustment	int
=	O
(	O
sec	int
==	O
0	int
&&	O
tm	struct
.	O
tm_sec	int
==	O
60	int
)	O
-	O
sec	int
;	O
if	O
(	O
!	O
time_t_int_add_ok	function
(	O
t	pointer
,	O
sec_requested	int
)	O
)	O
return	O
-	O
1	int
;	O
t1	long
=	O
t	pointer
+	O
sec_requested	int
;	O
if	O
(	O
!	O
time_t_int_add_ok	function
(	O
t1	long
,	O
sec_adjustment	int
)	O
)	O
return	O
-	O
1	int
;	O
t2	long
=	O
t1	long
+	O
sec_adjustment	int
;	O
if	O
(	O
!	O
convert	pointer
(	O
&	O
t2	long
,	O
&	O
tm	struct
)	O
)	O
return	O
-	O
1	int
;	O
t	pointer
=	O
t2	long
;	O
}	O
*	O
tp	pointer
=	O
tm	struct
;	O
return	O
t	pointer
;	O
}	O
static	O
time_t	long
localtime_offset	long
;	O
time_t	long
mktime	function
(	O
struct	O
tm	struct
*	O
tp	pointer
)	O
{	O
return	O
__mktime_internal	O
(	O
tp	pointer
,	O
__localtime_r	O
,	O
&	O
localtime_offset	long
)	O
;	O
}	O