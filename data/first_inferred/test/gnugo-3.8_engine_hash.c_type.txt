static	O
Hash_data	struct
white_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
black_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
ko_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
komaster_hash	array
[	O
NUM_KOMASTER_STATES	int
]	O
;	O
static	O
Hash_data	struct
kom_pos_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
goal_hash	array
[	O
BOARDMAX	O
]	O
;	O
static	O
Hashvalue	O
hash_rand	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
Hashvalue	O
h	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
32	int
*	O
i	int
<	O
(	O
int	O
)	O
(	O
CHAR_BIT	O
*	O
sizeof	O
(	O
Hashvalue	*
)	O
)	O
;	O
i	int
++	O
)	O
h	int
|=	O
(	O
Hashvalue	int
)	O
gg_urand	function
(	O
)	O
<<	O
32	int
*	O
i	int
;	O
return	O
h	int
;	O
}	O
void	O
hash_init_zobrist_array	function
(	O
Hash_data	struct
*	O
array	*
,	O
int	O
size	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_HASHVALUES	int
;	O
j	int
++	O
)	O
array	array
[	O
i	int
]	O
.	O
hashval	array
[	O
j	int
]	O
=	O
hash_rand	function
(	O
)	O
;	O
}	O
void	O
hash_init	function
(	O
void	O
)	O
{	O
static	O
int	O
is_initialized	int
=	O
0	int
;	O
if	O
(	O
is_initialized	int
)	O
return	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
black_hash	*
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
white_hash	*
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
ko_hash	*
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
komaster_hash	*
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
kom_pos_hash	*
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
goal_hash	*
)	O
;	O
is_initialized	int
=	O
1	int
;	O
}	O
void	O
hashdata_recalc	function
(	O
Hash_data	struct
*	O
hd	*
,	O
Intersection	struct
*	O
p	*
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
hashdata_clear	function
(	O
hd	*
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	*
[	O
pos	int
]	O
==	O
WHITE	int
)	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
white_hash	*
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
p	*
[	O
pos	int
]	O
==	O
BLACK	int
)	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
black_hash	*
[	O
pos	int
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
0	int
)	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
ko_hash	array
[	O
ko_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_clear	function
(	O
Hash_data	struct
*	O
hd	*
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_HASHVALUES	int
;	O
i	int
++	O
)	O
hd	*
->	O
hashval	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
void	O
hashdata_invert_ko	function
(	O
Hash_data	struct
*	O
hd	*
,	O
int	O
pos	int
)	O
{	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
ko_hash	*
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_stone	function
(	O
Hash_data	struct
*	O
hd	*
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
color	enum
==	O
BLACK	int
)	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
black_hash	*
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
white_hash	*
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_komaster	function
(	O
Hash_data	struct
*	O
hd	*
,	O
int	O
komaster	int
)	O
{	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
komaster_hash	array
[	O
komaster	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_kom_pos	function
(	O
Hash_data	struct
*	O
hd	*
,	O
int	O
kom_pos	int
)	O
{	O
hashdata_xor	function
(	O
*	O
hd	*
,	O
kom_pos_hash	array
[	O
kom_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_calc_orientation_invariant	function
(	O
Hash_data	struct
*	O
hd	*
,	O
Intersection	struct
*	O
p	*
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
int	O
rot	int
;	O
Hash_data	O
hd_rot	int
;	O
for	O
(	O
rot	int
=	O
0	int
;	O
rot	int
<	O
8	int
;	O
rot	int
++	O
)	O
{	O
hashdata_clear	function
(	O
&	O
hd_rot	*
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	*
[	O
pos	int
]	O
==	O
WHITE	int
)	O
hashdata_xor	function
(	O
hd_rot	*
,	O
white_hash	array
[	O
rotate1	function
(	O
pos	int
,	O
rot	*
)	O
]	O
)	O
;	O
else	O
if	O
(	O
p	*
[	O
pos	int
]	O
==	O
BLACK	int
)	O
hashdata_xor	function
(	O
hd_rot	*
,	O
black_hash	array
[	O
rotate1	function
(	O
pos	int
,	O
rot	*
)	O
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_xor	function
(	O
hd_rot	*
,	O
ko_hash	array
[	O
rotate1	function
(	O
ko_pos	*
,	O
rot	*
)	O
]	O
)	O
;	O
if	O
(	O
rot	int
==	O
0	int
||	O
hashdata_is_smaller	function
(	O
hd_rot	*
,	O
*	O
hd	*
)	O
)	O
*	O
hd	*
=	O
hd_rot	int
;	O
}	O
}	O
Hash_data	O
goal_to_hashvalue	function
(	O
const	O
signed	O
char	O
*	O
goal	*
)	O
{	O
int	O
pos	int
;	O
Hash_data	struct
return_value	*
;	O
hashdata_clear	function
(	O
&	O
return_value	*
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	*
[	O
pos	int
]	O
)	O
hashdata_xor	function
(	O
return_value	*
,	O
goal_hash	*
[	O
pos	int
]	O
)	O
;	O
return	O
return_value	*
;	O
}	O
char	O
*	O
hashdata_to_string	function
(	O
Hash_data	struct
*	O
hashdata	*
)	O
{	O
static	O
char	O
buffer	array
[	O
BUFFER_SIZE	int
]	O
;	O
int	O
n	int
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
NUM_HASHVALUES	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
n	int
+=	O
sprintf	function
(	O
buffer	*
+	O
n	int
,	O
HASHVALUE_PRINT_FORMAT	*
,	O
HASHVALUE_NUM_DIGITS	*
,	O
hashdata	*
->	O
hashval	array
[	O
k	int
]	O
)	O
;	O
gg_assert	O
(	O
n	int
<	O
BUFFER_SIZE	O
)	O
;	O
}	O
return	O
buffer	*
;	O
}	O