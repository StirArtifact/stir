static	O
const	O
char	O
power_letter	array
[	O
]	O
=	O
{	O
0	int
,	O
'K'	O
,	O
'M'	O
,	O
'G'	O
,	O
'T'	O
,	O
'P'	O
,	O
'E'	O
,	O
'Z'	O
,	O
'Y'	O
}	O
;	O
static	O
long	O
double	O
adjust_value	function
(	O
int	O
inexact_style	int
,	O
long	O
double	O
value	pointer
)	O
{	O
if	O
(	O
inexact_style	int
!=	O
human_round_to_nearest	int
&&	O
value	pointer
<	O
UINTMAX_MAX	O
)	O
{	O
uintmax_t	long
u	long
=	O
value	pointer
;	O
value	pointer
=	O
u	long
+	O
(	O
inexact_style	int
==	O
human_ceiling	int
&&	O
u	long
!=	O
value	pointer
)	O
;	O
}	O
return	O
value	pointer
;	O
}	O
static	O
char	O
*	O
group_number	function
(	O
char	O
*	O
number	pointer
,	O
size_t	long
numberlen	long
,	O
char	O
const	O
*	O
grouping	pointer
,	O
char	O
const	O
*	O
thousands_sep	pointer
)	O
{	O
register	O
char	O
*	O
d	pointer
;	O
size_t	long
grouplen	long
=	O
SIZE_MAX	O
;	O
size_t	long
thousands_seplen	long
=	O
strlen	function
(	O
thousands_sep	pointer
)	O
;	O
size_t	long
i	long
=	O
numberlen	long
;	O
char	O
buf	array
[	O
2	int
*	O
INT_STRLEN_BOUND	O
(	O
uintmax_t	long
)	O
+	O
1	int
]	O
;	O
memcpy	function
(	O
buf	array
,	O
number	pointer
,	O
numberlen	long
)	O
;	O
d	pointer
=	O
number	pointer
+	O
numberlen	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
unsigned	O
char	O
g	char
=	O
*	O
grouping	pointer
;	O
if	O
(	O
g	char
)	O
{	O
grouplen	long
=	O
g	char
<	O
CHAR_MAX	O
?	O
g	char
:	O
i	long
;	O
grouping	pointer
++	O
;	O
}	O
if	O
(	O
i	long
<	O
grouplen	long
)	O
grouplen	long
=	O
i	long
;	O
d	pointer
-=	O
grouplen	long
;	O
i	long
-=	O
grouplen	long
;	O
memcpy	function
(	O
d	pointer
,	O
buf	array
+	O
i	long
,	O
grouplen	long
)	O
;	O
if	O
(	O
i	long
==	O
0	int
)	O
return	O
d	pointer
;	O
d	pointer
-=	O
thousands_seplen	long
;	O
memcpy	function
(	O
d	pointer
,	O
thousands_sep	pointer
,	O
thousands_seplen	long
)	O
;	O
}	O
}	O
char	O
*	O
human_readable	function
(	O
uintmax_t	long
n	long
,	O
char	O
*	O
buf	array
,	O
int	O
opts	int
,	O
uintmax_t	long
from_block_size	long
,	O
uintmax_t	long
to_block_size	long
)	O
{	O
int	O
inexact_style	int
=	O
opts	int
&	O
(	O
human_round_to_nearest	int
|	O
human_floor	int
|	O
human_ceiling	int
)	O
;	O
unsigned	O
int	O
base	int
=	O
opts	int
&	O
human_base_1024	int
?	O
1024	int
:	O
1000	int
;	O
uintmax_t	long
amt	long
;	O
int	O
tenths	int
;	O
int	O
exponent	int
=	O
-	O
1	int
;	O
int	O
exponent_max	int
=	O
sizeof	O
power_letter	array
-	O
1	int
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
psuffix	pointer
;	O
char	O
const	O
*	O
integerlim	pointer
;	O
int	O
rounding	int
;	O
char	O
const	O
*	O
decimal_point	pointer
=	O
"."	pointer
;	O
size_t	long
decimal_pointlen	long
=	O
1	int
;	O
char	O
const	O
*	O
grouping	pointer
=	O
""	pointer
;	O
char	O
const	O
*	O
thousands_sep	pointer
=	O
""	pointer
;	O
struct	O
lconv	struct
const	O
*	O
l	pointer
=	O
localeconv	function
(	O
)	O
;	O
size_t	long
pointlen	long
=	O
strlen	function
(	O
l	pointer
->	O
decimal_point	pointer
)	O
;	O
if	O
(	O
0	int
<	O
pointlen	long
&&	O
pointlen	long
<=	O
MB_LEN_MAX	int
)	O
{	O
decimal_point	pointer
=	O
l	pointer
->	O
decimal_point	pointer
;	O
decimal_pointlen	long
=	O
pointlen	long
;	O
}	O
grouping	pointer
=	O
l	pointer
->	O
grouping	pointer
;	O
if	O
(	O
strlen	function
(	O
l	pointer
->	O
thousands_sep	pointer
)	O
<=	O
MB_LEN_MAX	int
)	O
thousands_sep	pointer
=	O
l	pointer
->	O
thousands_sep	pointer
;	O
psuffix	pointer
=	O
buf	array
+	O
LONGEST_HUMAN_READABLE	O
-	O
HUMAN_READABLE_SUFFIX_LENGTH_MAX	int
;	O
p	pointer
=	O
psuffix	pointer
;	O
if	O
(	O
to_block_size	long
<=	O
from_block_size	long
)	O
{	O
if	O
(	O
from_block_size	long
%	O
to_block_size	long
==	O
0	int
)	O
{	O
uintmax_t	long
multiplier	long
=	O
from_block_size	long
/	O
to_block_size	long
;	O
amt	long
=	O
n	long
*	O
multiplier	long
;	O
if	O
(	O
amt	long
/	O
multiplier	long
==	O
n	long
)	O
{	O
tenths	int
=	O
0	int
;	O
rounding	int
=	O
0	int
;	O
goto	O
use_integer_arithmetic	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
from_block_size	long
!=	O
0	int
&&	O
to_block_size	long
%	O
from_block_size	long
==	O
0	int
)	O
{	O
uintmax_t	long
divisor	long
=	O
to_block_size	long
/	O
from_block_size	long
;	O
uintmax_t	long
r10	long
=	O
(	O
n	long
%	O
divisor	long
)	O
*	O
10	int
;	O
uintmax_t	long
r2	long
=	O
(	O
r10	long
%	O
divisor	long
)	O
*	O
2	int
;	O
amt	long
=	O
n	long
/	O
divisor	long
;	O
tenths	int
=	O
r10	long
/	O
divisor	long
;	O
rounding	int
=	O
r2	long
<	O
divisor	long
?	O
0	int
<	O
r2	long
:	O
2	int
+	O
(	O
divisor	long
<	O
r2	long
)	O
;	O
goto	O
use_integer_arithmetic	O
;	O
}	O
{	O
long	O
double	O
dto_block_size	long double
=	O
to_block_size	long
;	O
long	O
double	O
damt	long double
=	O
n	long
*	O
(	O
from_block_size	long
/	O
dto_block_size	long double
)	O
;	O
size_t	long
buflen	long
;	O
size_t	long
nonintegerlen	long
;	O
if	O
(	O
!	O
(	O
opts	int
&	O
human_autoscale	int
)	O
)	O
{	O
sprintf	function
(	O
buf	array
,	O
"%.0Lf"	pointer
,	O
adjust_value	function
(	O
inexact_style	int
,	O
damt	long double
)	O
)	O
;	O
buflen	long
=	O
strlen	function
(	O
buf	array
)	O
;	O
nonintegerlen	long
=	O
0	int
;	O
}	O
else	O
{	O
long	O
double	O
e	long double
=	O
1	int
;	O
exponent	int
=	O
0	int
;	O
do	O
{	O
e	long double
*=	O
base	int
;	O
exponent	int
++	O
;	O
}	O
while	O
(	O
e	long double
*	O
base	int
<=	O
damt	long double
&&	O
exponent	int
<	O
exponent_max	int
)	O
;	O
damt	long double
/=	O
e	long double
;	O
sprintf	function
(	O
buf	array
,	O
"%.1Lf"	pointer
,	O
adjust_value	function
(	O
inexact_style	int
,	O
damt	long double
)	O
)	O
;	O
buflen	long
=	O
strlen	function
(	O
buf	array
)	O
;	O
nonintegerlen	long
=	O
decimal_pointlen	long
+	O
1	int
;	O
if	O
(	O
1	int
+	O
nonintegerlen	long
+	O
!	O
(	O
opts	int
&	O
human_base_1024	int
)	O
<	O
buflen	long
||	O
(	O
(	O
opts	int
&	O
human_suppress_point_zero	int
)	O
&&	O
buf	array
[	O
buflen	long
-	O
1	int
]	O
==	O
'0'	O
)	O
)	O
{	O
sprintf	function
(	O
buf	array
,	O
"%.0Lf"	pointer
,	O
adjust_value	function
(	O
inexact_style	int
,	O
damt	long double
*	O
10	int
)	O
/	O
10	int
)	O
;	O
buflen	long
=	O
strlen	function
(	O
buf	array
)	O
;	O
nonintegerlen	long
=	O
0	int
;	O
}	O
}	O
p	pointer
=	O
psuffix	pointer
-	O
buflen	long
;	O
memmove	function
(	O
p	pointer
,	O
buf	array
,	O
buflen	long
)	O
;	O
integerlim	pointer
=	O
p	pointer
+	O
buflen	long
-	O
nonintegerlen	long
;	O
}	O
goto	O
do_grouping	O
;	O
use_integer_arithmetic	O
:	O
{	O
if	O
(	O
opts	int
&	O
human_autoscale	int
)	O
{	O
exponent	int
=	O
0	int
;	O
if	O
(	O
base	int
<=	O
amt	long
)	O
{	O
do	O
{	O
unsigned	O
int	O
r10	long
=	O
(	O
amt	long
%	O
base	int
)	O
*	O
10	int
+	O
tenths	int
;	O
unsigned	O
int	O
r2	long
=	O
(	O
r10	long
%	O
base	int
)	O
*	O
2	int
+	O
(	O
rounding	int
>>	O
1	int
)	O
;	O
amt	long
/=	O
base	int
;	O
tenths	int
=	O
r10	long
/	O
base	int
;	O
rounding	int
=	O
(	O
r2	long
<	O
base	int
?	O
(	O
r2	long
+	O
rounding	int
)	O
!=	O
0	int
:	O
2	int
+	O
(	O
base	int
<	O
r2	long
+	O
rounding	int
)	O
)	O
;	O
exponent	int
++	O
;	O
}	O
while	O
(	O
base	int
<=	O
amt	long
&&	O
exponent	int
<	O
exponent_max	int
)	O
;	O
if	O
(	O
amt	long
<	O
10	int
)	O
{	O
if	O
(	O
inexact_style	int
==	O
human_round_to_nearest	int
?	O
2	int
<	O
rounding	int
+	O
(	O
tenths	int
&	O
1	int
)	O
:	O
inexact_style	int
==	O
human_ceiling	int
&&	O
0	int
<	O
rounding	int
)	O
{	O
tenths	int
++	O
;	O
rounding	int
=	O
0	int
;	O
if	O
(	O
tenths	int
==	O
10	int
)	O
{	O
amt	long
++	O
;	O
tenths	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
amt	long
<	O
10	int
&&	O
(	O
tenths	int
||	O
!	O
(	O
opts	int
&	O
human_suppress_point_zero	int
)	O
)	O
)	O
{	O
*	O
--	O
p	pointer
=	O
'0'	O
+	O
tenths	int
;	O
p	pointer
-=	O
decimal_pointlen	long
;	O
memcpy	function
(	O
p	pointer
,	O
decimal_point	pointer
,	O
decimal_pointlen	long
)	O
;	O
tenths	int
=	O
rounding	int
=	O
0	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
inexact_style	int
==	O
human_round_to_nearest	int
?	O
5	int
<	O
tenths	int
+	O
(	O
0	int
<	O
rounding	int
+	O
(	O
amt	long
&	O
1	int
)	O
)	O
:	O
inexact_style	int
==	O
human_ceiling	int
&&	O
0	int
<	O
tenths	int
+	O
rounding	int
)	O
{	O
amt	long
++	O
;	O
if	O
(	O
(	O
opts	int
&	O
human_autoscale	int
)	O
&&	O
amt	long
==	O
base	int
&&	O
exponent	int
<	O
exponent_max	int
)	O
{	O
exponent	int
++	O
;	O
if	O
(	O
!	O
(	O
opts	int
&	O
human_suppress_point_zero	int
)	O
)	O
{	O
*	O
--	O
p	pointer
=	O
'0'	O
;	O
p	pointer
-=	O
decimal_pointlen	long
;	O
memcpy	function
(	O
p	pointer
,	O
decimal_point	pointer
,	O
decimal_pointlen	long
)	O
;	O
}	O
amt	long
=	O
1	int
;	O
}	O
}	O
integerlim	pointer
=	O
p	pointer
;	O
do	O
{	O
int	O
digit	int
=	O
amt	long
%	O
10	int
;	O
*	O
--	O
p	pointer
=	O
digit	int
+	O
'0'	O
;	O
}	O
while	O
(	O
(	O
amt	long
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
}	O
do_grouping	O
:	O
if	O
(	O
opts	int
&	O
human_group_digits	int
)	O
p	pointer
=	O
group_number	function
(	O
p	pointer
,	O
integerlim	pointer
-	O
p	pointer
,	O
grouping	pointer
,	O
thousands_sep	pointer
)	O
;	O
if	O
(	O
opts	int
&	O
human_SI	int
)	O
{	O
if	O
(	O
exponent	int
<	O
0	int
)	O
{	O
uintmax_t	long
power	long
;	O
exponent	int
=	O
0	int
;	O
for	O
(	O
power	long
=	O
1	int
;	O
power	long
<	O
to_block_size	long
;	O
power	long
*=	O
base	int
)	O
if	O
(	O
++	O
exponent	int
==	O
exponent_max	int
)	O
break	O
;	O
}	O
if	O
(	O
(	O
exponent	int
|	O
(	O
opts	int
&	O
human_B	int
)	O
)	O
&&	O
(	O
opts	int
&	O
human_space_before_unit	int
)	O
)	O
*	O
psuffix	pointer
++	O
=	O
' '	O
;	O
if	O
(	O
exponent	int
)	O
*	O
psuffix	pointer
++	O
=	O
(	O
!	O
(	O
opts	int
&	O
human_base_1024	int
)	O
&&	O
exponent	int
==	O
1	int
?	O
'k'	O
:	O
power_letter	array
[	O
exponent	int
]	O
)	O
;	O
if	O
(	O
opts	int
&	O
human_B	int
)	O
{	O
if	O
(	O
(	O
opts	int
&	O
human_base_1024	int
)	O
&&	O
exponent	int
)	O
*	O
psuffix	pointer
++	O
=	O
'i'	O
;	O
*	O
psuffix	pointer
++	O
=	O
'B'	O
;	O
}	O
}	O
*	O
psuffix	pointer
=	O
'\0'	O
;	O
return	O
p	pointer
;	O
}	O
static	O
char	O
const	O
*	O
const	O
block_size_args	array
[	O
]	O
=	O
{	O
"human-readable"	pointer
,	O
"si"	pointer
,	O
0	int
}	O
;	O
static	O
int	O
const	O
block_size_opts	array
[	O
]	O
=	O
{	O
human_autoscale	int
+	O
human_SI	int
+	O
human_base_1024	int
,	O
human_autoscale	int
+	O
human_SI	int
}	O
;	O
static	O
uintmax_t	long
default_block_size	function
(	O
void	O
)	O
{	O
return	O
getenv	function
(	O
"POSIXLY_CORRECT"	pointer
)	O
?	O
512	int
:	O
DEFAULT_BLOCK_SIZE	int
;	O
}	O
static	O
strtol_error	enum
humblock	function
(	O
char	O
const	O
*	O
spec	pointer
,	O
uintmax_t	long
*	O
block_size	pointer
,	O
int	O
*	O
options	pointer
)	O
{	O
int	O
i	long
;	O
int	O
opts	int
=	O
0	int
;	O
if	O
(	O
!	O
spec	pointer
&&	O
!	O
(	O
spec	pointer
=	O
getenv	function
(	O
"BLOCK_SIZE"	pointer
)	O
)	O
&&	O
!	O
(	O
spec	pointer
=	O
getenv	function
(	O
"BLOCKSIZE"	pointer
)	O
)	O
)	O
*	O
block_size	pointer
=	O
default_block_size	function
(	O
)	O
;	O
else	O
{	O
if	O
(	O
*	O
spec	pointer
==	O
'\''	O
)	O
{	O
opts	int
|=	O
human_group_digits	int
;	O
spec	pointer
++	O
;	O
}	O
if	O
(	O
0	int
<=	O
(	O
i	long
=	O
ARGMATCH	O
(	O
spec	pointer
,	O
block_size_args	array
,	O
block_size_opts	array
)	O
)	O
)	O
{	O
opts	int
|=	O
block_size_opts	array
[	O
i	long
]	O
;	O
*	O
block_size	pointer
=	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
ptr	pointer
;	O
strtol_error	enum
e	long double
=	O
xstrtoumax	function
(	O
spec	pointer
,	O
&	O
ptr	pointer
,	O
0	int
,	O
block_size	pointer
,	O
"eEgGkKmMpPtTyYzZ0"	pointer
)	O
;	O
if	O
(	O
e	long double
!=	O
LONGINT_OK	int
)	O
{	O
*	O
options	pointer
=	O
0	int
;	O
return	O
e	long double
;	O
}	O
for	O
(	O
;	O
!	O
(	O
'0'	O
<=	O
*	O
spec	pointer
&&	O
*	O
spec	pointer
<=	O
'9'	O
)	O
;	O
spec	pointer
++	O
)	O
if	O
(	O
spec	pointer
==	O
ptr	pointer
)	O
{	O
opts	int
|=	O
human_SI	int
;	O
if	O
(	O
ptr	pointer
[	O
-	O
1	int
]	O
==	O
'B'	O
)	O
opts	int
|=	O
human_B	int
;	O
if	O
(	O
ptr	pointer
[	O
-	O
1	int
]	O
!=	O
'B'	O
||	O
ptr	pointer
[	O
-	O
2	int
]	O
==	O
'i'	O
)	O
opts	int
|=	O
human_base_1024	int
;	O
break	O
;	O
}	O
}	O
}	O
*	O
options	pointer
=	O
opts	int
;	O
return	O
LONGINT_OK	int
;	O
}	O
enum	O
strtol_error	enum
human_options	function
(	O
char	O
const	O
*	O
spec	pointer
,	O
int	O
*	O
opts	int
,	O
uintmax_t	long
*	O
block_size	pointer
)	O
{	O
strtol_error	enum
e	long double
=	O
humblock	function
(	O
spec	pointer
,	O
block_size	pointer
,	O
opts	int
)	O
;	O
if	O
(	O
*	O
block_size	pointer
==	O
0	int
)	O
{	O
*	O
block_size	pointer
=	O
default_block_size	function
(	O
)	O
;	O
e	long double
=	O
LONGINT_INVALID	int
;	O
}	O
return	O
e	long double
;	O
}	O
