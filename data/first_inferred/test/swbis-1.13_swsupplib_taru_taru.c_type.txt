TARU	struct
*	O
taru_create	function
(	O
void	O
)	O
{	O
TARU	struct
*	O
taru	pointer
=	O
(	O
TARU	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
TARU	struct
)	O
)	O
;	O
taru	pointer
->	O
idM	char
=	O
'A'	O
;	O
taru	pointer
->	O
headerM	pointer
=	O
strob_open	function
(	O
1024	int
)	O
;	O
taru	pointer
->	O
header_lengthM	int
=	O
0	int
;	O
taru	pointer
->	O
taru_tarheaderflagsM	int
=	O
0	int
;	O
taru	pointer
->	O
do_record_headerM	int
=	O
0	int
;	O
taru	pointer
->	O
u_name_bufferM	pointer
=	O
strob_open	function
(	O
8	int
)	O
;	O
taru	pointer
->	O
u_ent_bufferM	pointer
=	O
strob_open	function
(	O
SNAME_LEN	int
+	O
SNAME_LEN	int
)	O
;	O
taru	pointer
->	O
nullfdM	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
taru	pointer
->	O
md5bufM	pointer
=	O
strob_open	function
(	O
64	int
)	O
;	O
strob_set_memlength	function
(	O
taru	pointer
->	O
md5bufM	pointer
,	O
64	int
)	O
;	O
taru	pointer
->	O
linkrecord_disableM	int
=	O
0	int
;	O
taru	pointer
->	O
preview_fdM	int
=	O
-	O
1	int
;	O
taru	pointer
->	O
preview_levelM	int
=	O
TARU_PV_0	int
;	O
taru	pointer
->	O
preview_bufferM	pointer
=	O
strob_open	function
(	O
64	int
)	O
;	O
taru	pointer
->	O
read_bufferM	pointer
=	O
strob_open	function
(	O
TARRECORDSIZE	int
*	O
4	int
)	O
;	O
taru	pointer
->	O
read_buffer_posM	int
=	O
0	int
;	O
taru	pointer
->	O
exthdr_dataM	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
taru	pointer
->	O
etarM	pointer
=	O
etar_open	function
(	O
0	int
)	O
;	O
taru	pointer
->	O
localbufM	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
return	O
taru	pointer
;	O
}	O
void	O
taru_delete	function
(	O
TARU	struct
*	O
taru	pointer
)	O
{	O
strob_close	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
;	O
strob_close	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
)	O
;	O
strob_close	function
(	O
taru	pointer
->	O
u_ent_bufferM	pointer
)	O
;	O
strob_close	function
(	O
taru	pointer
->	O
md5bufM	pointer
)	O
;	O
strob_close	function
(	O
taru	pointer
->	O
preview_bufferM	pointer
)	O
;	O
swbis_devnull_close	O
(	O
taru	pointer
->	O
nullfdM	int
)	O
;	O
etar_close	function
(	O
taru	pointer
->	O
etarM	pointer
)	O
;	O
free	function
(	O
taru	pointer
)	O
;	O
}	O
int	O
taru_read_pax_data_blocks	function
(	O
TARU	struct
*	O
taru	pointer
,	O
int	O
fd	int
,	O
char	O
*	O
fsource_buffer	pointer
,	O
int	O
data_len	pointer
,	O
ssize_t	long
(	O
*	O
vfread	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
int	O
n_blocks_to_read	int
;	O
int	O
n	long
;	O
unsigned	O
char	O
*	O
buf	pointer
;	O
int	O
ret	int
;	O
int	O
retval	int
=	O
0	int
;	O
STROB	struct
*	O
strb	pointer
=	O
taru	pointer
->	O
read_bufferM	pointer
;	O
n_blocks_to_read	int
=	O
data_len	pointer
/	O
(	O
int	O
)	O
TARRECORDSIZE	int
;	O
if	O
(	O
data_len	pointer
%	O
TARRECORDSIZE	int
)	O
n_blocks_to_read	int
++	O
;	O
strob_set_length	function
(	O
strb	pointer
,	O
taru	pointer
->	O
read_buffer_posM	int
+	O
n_blocks_to_read	int
*	O
TARRECORDSIZE	int
+	O
TARRECORDSIZE	int
+	O
10	int
)	O
;	O
buf	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
strob_str	function
(	O
strb	pointer
)	O
+	O
taru	pointer
->	O
read_buffer_posM	int
;	O
n	long
=	O
0	int
;	O
while	O
(	O
n	long
<	O
n_blocks_to_read	int
)	O
{	O
if	O
(	O
fsource_buffer	pointer
)	O
{	O
memcpy	function
(	O
buf	pointer
+	O
n	long
*	O
TARRECORDSIZE	int
,	O
(	O
void	O
*	O
)	O
(	O
fsource_buffer	pointer
+	O
(	O
n	long
+	O
1	int
)	O
*	O
TARRECORDSIZE	int
)	O
,	O
(	O
size_t	long
)	O
TARRECORDSIZE	int
)	O
;	O
ret	int
=	O
TARRECORDSIZE	int
;	O
}	O
else	O
{	O
ret	int
=	O
vfread	pointer
(	O
fd	int
,	O
buf	pointer
+	O
n	long
*	O
TARRECORDSIZE	int
,	O
TARRECORDSIZE	int
)	O
;	O
}	O
if	O
(	O
ret	int
!=	O
TARRECORDSIZE	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
taru	pointer
->	O
do_record_headerM	int
)	O
{	O
strob_set_memlength	function
(	O
taru	pointer
->	O
headerM	pointer
,	O
taru	pointer
->	O
header_lengthM	int
+	O
512	int
)	O
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
+	O
taru	pointer
->	O
header_lengthM	int
)	O
,	O
(	O
void	O
*	O
)	O
(	O
buf	pointer
+	O
n	long
*	O
TARRECORDSIZE	int
)	O
,	O
512	int
)	O
;	O
taru	pointer
->	O
header_lengthM	int
+=	O
512	int
;	O
}	O
retval	int
+=	O
ret	int
;	O
taru	pointer
->	O
read_buffer_posM	int
+=	O
ret	int
;	O
n	long
++	O
;	O
}	O
*	O
(	O
buf	pointer
+	O
retval	int
)	O
=	O
'\0'	O
;	O
return	O
retval	int
;	O
}	O
void	O
taru_set_header_recording	function
(	O
TARU	struct
*	O
taru	pointer
,	O
int	O
n	long
)	O
{	O
taru	pointer
->	O
do_record_headerM	int
=	O
n	long
;	O
}	O
char	O
*	O
taru_get_recorded_header	function
(	O
TARU	struct
*	O
taru	pointer
,	O
int	O
*	O
len	int
)	O
{	O
if	O
(	O
len	int
)	O
*	O
len	int
=	O
taru	pointer
->	O
header_lengthM	int
;	O
return	O
strob_str	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
;	O
}	O
void	O
taru_clear_header_buffer	function
(	O
TARU	struct
*	O
taru	pointer
)	O
{	O
taru	pointer
->	O
header_lengthM	int
=	O
0	int
;	O
}	O
intmax_t	long
taru_hdr_get_filesize	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
static	O
int	O
check_off_t	int
=	O
0	int
;	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	long
>=	O
LLONG_MAX	O
)	O
{	O
SWLIB_FATAL	O
(	O
"c_filesize too big: >=LLONG_MAX"	pointer
)	O
;	O
}	O
if	O
(	O
check_off_t	int
==	O
0	int
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
sizeof	O
(	O
st	pointer
.	O
st_size	long
)	O
<	O
5	int
)	O
{	O
check_off_t	int
=	O
1	int
;	O
}	O
else	O
{	O
check_off_t	int
=	O
2	int
;	O
}	O
}	O
if	O
(	O
check_off_t	int
==	O
1	int
&&	O
file_hdr	pointer
->	O
c_filesize	long
>=	O
LONG_MAX	O
)	O
{	O
SWLIB_FATAL	O
(	O
"c_filesize too big: >=LONG_MAX"	pointer
)	O
;	O
}	O
return	O
(	O
intmax_t	long
)	O
(	O
file_hdr	pointer
->	O
c_filesize	long
)	O
;	O
}	O
void	O
taru_append_to_header_buffer	function
(	O
TARU	struct
*	O
taru	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
)	O
{	O
char	O
*	O
s	pointer
;	O
strob_set_length	function
(	O
taru	pointer
->	O
headerM	pointer
,	O
taru	pointer
->	O
header_lengthM	int
+	O
len	int
+	O
1	int
)	O
;	O
s	pointer
=	O
strob_str	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
;	O
memcpy	function
(	O
s	pointer
+	O
taru	pointer
->	O
header_lengthM	int
,	O
buf	pointer
,	O
len	int
)	O
;	O
taru	pointer
->	O
header_lengthM	int
+=	O
len	int
;	O
}	O
void	O
taru_digs_print	function
(	O
FILE_DIGS	struct
*	O
digs	pointer
,	O
STROB	struct
*	O
buffer	array
)	O
{	O
if	O
(	O
digs	pointer
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
strob_sprintf	function
(	O
buffer	array
,	O
STROB_DO_APPEND	int
,	O
" [%s]"	pointer
,	O
digs	pointer
->	O
md5	array
)	O
;	O
else	O
strob_sprintf	function
(	O
buffer	array
,	O
STROB_DO_APPEND	int
,	O
" []"	pointer
)	O
;	O
if	O
(	O
digs	pointer
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
strob_sprintf	function
(	O
buffer	array
,	O
STROB_DO_APPEND	int
,	O
" [%s]"	pointer
,	O
digs	pointer
->	O
sha1	array
)	O
;	O
else	O
strob_sprintf	function
(	O
buffer	array
,	O
STROB_DO_APPEND	int
,	O
" []"	pointer
)	O
;	O
}	O
void	O
taru_digs_delete	function
(	O
FILE_DIGS	struct
*	O
digs	pointer
)	O
{	O
free	function
(	O
digs	pointer
)	O
;	O
}	O
FILE_DIGS	struct
*	O
taru_digs_create	function
(	O
void	O
)	O
{	O
FILE_DIGS	struct
*	O
digs	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
FILE_DIGS	struct
)	O
)	O
;	O
if	O
(	O
!	O
digs	pointer
)	O
return	O
digs	pointer
;	O
taru_digs_init	function
(	O
digs	pointer
,	O
DIGS_ENABLE_OFF	int
,	O
0	int
)	O
;	O
return	O
digs	pointer
;	O
}	O
void	O
taru_digs_init	function
(	O
FILE_DIGS	struct
*	O
digs	pointer
,	O
int	O
enable	int
,	O
int	O
poison	int
)	O
{	O
digs	pointer
->	O
do_poisonM	int
=	O
poison	int
;	O
digs	pointer
->	O
md5	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
digs	pointer
->	O
sha1	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
digs	pointer
->	O
sha512	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
digs	pointer
->	O
size	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
enable	int
>=	O
0	int
)	O
{	O
digs	pointer
->	O
do_md5	short
=	O
enable	int
;	O
digs	pointer
->	O
do_sha1	short
=	O
enable	int
;	O
digs	pointer
->	O
do_sha512	short
=	O
enable	int
;	O
digs	pointer
->	O
do_size	short
=	O
enable	int
;	O
}	O
}	O
int	O
taru_ustar_field_size_check	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taru_fill_exthdr_needs_mask	function
(	O
file_hdr	pointer
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_fill_exthdr_needs_mask	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
tarheaderflags	int
)	O
{	O
int	O
mask	int
=	O
0	int
;	O
if	O
(	O
taru_is_tar_filename_too_long	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
mask	int
|=	O
TARU_EHUM_PATH	O
;	O
}	O
if	O
(	O
taru_is_tar_linkname_too_long	function
(	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
,	O
0	int
,	O
NULL	O
)	O
)	O
{	O
mask	int
|=	O
TARU_EHUM_LINKPATH	O
;	O
}	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	long
>	O
TAR_MAX_SIZE	int
)	O
{	O
mask	int
|=	O
TARU_EHUM_SIZE	O
;	O
}	O
if	O
(	O
file_hdr	pointer
->	O
c_uid	short
>	O
TAR_MAX_UID	O
)	O
{	O
mask	int
|=	O
TARU_EHUM_UID	O
;	O
}	O
if	O
(	O
file_hdr	pointer
->	O
c_gid	short
>	O
TAR_MAX_UID	O
)	O
{	O
mask	int
|=	O
TARU_EHUM_GID	O
;	O
}	O
if	O
(	O
strlen	function
(	O
ahsStaticGetTarUsername	function
(	O
file_hdr	pointer
)	O
)	O
>=	O
THB_FL_uname	int
)	O
{	O
mask	int
|=	O
TARU_EHUM_UNAME	O
;	O
}	O
if	O
(	O
strlen	function
(	O
ahsStaticGetTarGroupname	function
(	O
file_hdr	pointer
)	O
)	O
>=	O
THB_FL_gname	int
)	O
{	O
mask	int
|=	O
TARU_EHUM_GNAME	O
;	O
}	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	long
>	O
TAR_MAX_SIZE	int
)	O
{	O
mask	int
|=	O
TARU_EHUM_SIZE	O
;	O
}	O
if	O
(	O
file_hdr	pointer
->	O
c_dev_maj	long
>	O
TAR_MAX_DEVICE	O
)	O
{	O
mask	int
|=	O
TARU_EHUM_DEV_MAJ	O
;	O
}	O
if	O
(	O
file_hdr	pointer
->	O
c_dev_min	long
>	O
TAR_MAX_DEVICE	O
)	O
{	O
mask	int
|=	O
TARU_EHUM_DEV_MIN	O
;	O
}	O
if	O
(	O
(	O
tarheaderflags	int
&	O
TARU_TAR_PAXEXTHDR_MD	O
)	O
!=	O
0	int
)	O
{	O
mask	int
|=	O
TARU_EHUM_PATH	O
;	O
mask	int
|=	O
TARU_EHUM_LINKPATH	O
;	O
mask	int
|=	O
TARU_EHUM_SIZE	O
;	O
mask	int
|=	O
TARU_EHUM_UID	O
;	O
mask	int
|=	O
TARU_EHUM_GID	O
;	O
mask	int
|=	O
TARU_EHUM_UNAME	O
;	O
mask	int
|=	O
TARU_EHUM_GNAME	O
;	O
mask	int
|=	O
TARU_EHUM_MTIME	O
;	O
mask	int
|=	O
TARU_EHUM_SIZE	O
;	O
}	O
return	O
mask	int
;	O
}	O
void	O
taru_exatt_init	function
(	O
EXATT	struct
*	O
hnew	pointer
)	O
{	O
hnew	pointer
->	O
is_in_useM	int
=	O
0	int
;	O
hnew	pointer
->	O
lenM	int
=	O
-	O
1	int
;	O
hnew	pointer
->	O
vendorM	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
hnew	pointer
->	O
namespaceM	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
strob_strcpy	function
(	O
hnew	pointer
->	O
attrnameM	pointer
,	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
hnew	pointer
->	O
attrvalueM	pointer
,	O
""	pointer
)	O
;	O
}	O
EXATT	struct
*	O
taru_exatt_create	function
(	O
void	O
)	O
{	O
EXATT	struct
*	O
hnew	pointer
;	O
hnew	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
EXATT	struct
)	O
)	O
;	O
strcpy	function
(	O
hnew	pointer
->	O
magicM	array
,	O
"XH"	pointer
)	O
;	O
hnew	pointer
->	O
attrnameM	pointer
=	O
strob_open	function
(	O
22	int
)	O
;	O
hnew	pointer
->	O
attrvalueM	pointer
=	O
strob_open	function
(	O
22	int
)	O
;	O
taru_exatt_init	function
(	O
hnew	pointer
)	O
;	O
return	O
hnew	pointer
;	O
}	O
void	O
taru_exatt_delete	function
(	O
EXATT	struct
*	O
p	pointer
)	O
{	O
strob_close	function
(	O
(	O
STROB	struct
*	O
)	O
(	O
p	pointer
->	O
attrnameM	pointer
)	O
)	O
;	O
strob_close	function
(	O
(	O
STROB	struct
*	O
)	O
(	O
p	pointer
->	O
attrvalueM	pointer
)	O
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
void	O
taru_exattshow_debug	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
EXATT	struct
*	O
p	pointer
;	O
int	O
index	function
;	O
if	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
==	O
NULL	O
)	O
{	O
return	O
;	O
}	O
index	function
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"extended header begin\n"	pointer
)	O
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
EXATT	struct
*	O
)	O
cplob_val	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"attribute=[%s] value=[%s]\n"	pointer
,	O
strob_str	function
(	O
p	pointer
->	O
attrnameM	pointer
)	O
,	O
strob_str	function
(	O
p	pointer
->	O
attrvalueM	pointer
)	O
)	O
;	O
index	function
++	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"extended header end\n"	pointer
)	O
;	O
}	O
void	O
taru_exattlist_delete_all	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
EXATT	struct
*	O
p	pointer
;	O
int	O
index	function
;	O
if	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
==	O
NULL	O
)	O
{	O
return	O
;	O
}	O
index	function
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
EXATT	struct
*	O
)	O
cplob_val	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
taru_exatt_delete	function
(	O
p	pointer
)	O
;	O
index	function
++	O
;	O
}	O
}	O
EXATT	struct
*	O
taru_exattlist_get_free	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
EXATT	struct
*	O
p	pointer
;	O
int	O
index	function
;	O
if	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
==	O
NULL	O
)	O
{	O
file_hdr	pointer
->	O
extattlistM	pointer
=	O
(	O
void	O
*	O
)	O
cplob_open	function
(	O
3	int
)	O
;	O
(	O
(	O
CPLOB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
)	O
)	O
->	O
refcountM	int
=	O
1	int
;	O
}	O
index	function
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
EXATT	struct
*	O
)	O
cplob_val	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
is_in_useM	int
==	O
0	int
)	O
{	O
taru_exatt_init	function
(	O
p	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
index	function
++	O
;	O
}	O
p	pointer
=	O
taru_exatt_create	function
(	O
)	O
;	O
cplob_add_nta	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
(	O
char	O
*	O
)	O
p	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
taru_exattlist_init	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
EXATT	struct
*	O
p	pointer
;	O
int	O
index	function
;	O
if	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
==	O
NULL	O
)	O
{	O
file_hdr	pointer
->	O
extattlistM	pointer
=	O
(	O
void	O
*	O
)	O
cplob_open	function
(	O
22	int
)	O
;	O
(	O
(	O
CPLOB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
)	O
)	O
->	O
refcountM	int
=	O
1	int
;	O
}	O
index	function
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
EXATT	struct
*	O
)	O
cplob_val	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
p	pointer
->	O
is_in_useM	int
==	O
0	int
;	O
index	function
++	O
;	O
}	O
}	O
int	O
taru_exatt_parse_fqname	function
(	O
EXATT	struct
*	O
exatt	pointer
,	O
char	O
*	O
attr	pointer
,	O
int	O
attrlen	int
)	O
{	O
int	O
retval	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
has_prefix	int
=	O
0	int
;	O
int	O
has_namespace	int
=	O
0	int
;	O
int	O
has_name	int
=	O
0	int
;	O
retval	int
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strncpy	function
(	O
tmp	pointer
,	O
attr	pointer
,	O
attrlen	int
)	O
;	O
swlib_strncpy	function
(	O
exatt	pointer
->	O
vendorM	array
,	O
""	pointer
,	O
2	int
)	O
;	O
swlib_strncpy	function
(	O
exatt	pointer
->	O
namespaceM	array
,	O
""	pointer
,	O
2	int
)	O
;	O
strob_strcpy	function
(	O
(	O
STROB	struct
*	O
)	O
exatt	pointer
->	O
attrnameM	pointer
,	O
""	pointer
)	O
;	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
"."	pointer
)	O
;	O
while	O
(	O
s	pointer
)	O
{	O
if	O
(	O
isupper	function
(	O
*	O
s	pointer
)	O
&&	O
has_prefix	int
==	O
0	int
)	O
{	O
swlib_strncpy	function
(	O
exatt	pointer
->	O
vendorM	array
,	O
s	pointer
,	O
EXATT_PREFIX_LEN	int
)	O
;	O
has_prefix	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
isupper	function
(	O
*	O
s	pointer
)	O
&&	O
has_namespace	int
==	O
0	int
)	O
{	O
swlib_strncpy	function
(	O
exatt	pointer
->	O
namespaceM	array
,	O
s	pointer
,	O
EXATT_NAMESPACE_LEN	int
)	O
;	O
has_namespace	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
isupper	function
(	O
*	O
s	pointer
)	O
&&	O
has_name	int
==	O
0	int
)	O
{	O
strob_strcpy	function
(	O
exatt	pointer
->	O
attrnameM	pointer
,	O
s	pointer
)	O
;	O
has_name	int
=	O
1	int
;	O
}	O
else	O
{	O
retval	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"."	pointer
)	O
;	O
}	O
if	O
(	O
has_namespace	int
&&	O
!	O
has_name	int
&&	O
!	O
has_prefix	int
)	O
{	O
strob_strcpy	function
(	O
(	O
STROB	struct
*	O
)	O
exatt	pointer
->	O
attrnameM	pointer
,	O
exatt	pointer
->	O
namespaceM	array
)	O
;	O
swlib_strncpy	function
(	O
exatt	pointer
->	O
namespaceM	array
,	O
""	pointer
,	O
2	int
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
void	O
taru_init_header_digs	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
if	O
(	O
file_hdr	pointer
->	O
digsM	pointer
==	O
NULL	O
)	O
file_hdr	pointer
->	O
digsM	pointer
=	O
taru_digs_create	function
(	O
)	O
;	O
else	O
taru_digs_init	function
(	O
file_hdr	pointer
->	O
digsM	pointer
,	O
DIGS_ENABLE_OFF	int
,	O
0	int
)	O
;	O
}	O
void	O
taru_free_header_digs	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
if	O
(	O
file_hdr	pointer
->	O
digsM	pointer
)	O
{	O
taru_digs_delete	function
(	O
file_hdr	pointer
->	O
digsM	pointer
)	O
;	O
file_hdr	pointer
->	O
digsM	pointer
=	O
NULL	O
;	O
}	O
}	O
void	O
taru_init_header	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
EXATT	struct
*	O
p	pointer
;	O
int	O
index	function
;	O
file_hdr	pointer
->	O
c_mode	short
=	O
0400	int
;	O
file_hdr	pointer
->	O
c_uid	short
=	O
AHS_ID_NOBODY	O
;	O
file_hdr	pointer
->	O
c_gid	short
=	O
AHS_ID_NOBODY	O
;	O
file_hdr	pointer
->	O
c_nlink	short
=	O
0	int
;	O
file_hdr	pointer
->	O
c_mtime	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
file_hdr	pointer
->	O
c_ctime	long
=	O
file_hdr	pointer
->	O
c_mtime	long
;	O
file_hdr	pointer
->	O
c_atime	long
=	O
file_hdr	pointer
->	O
c_mtime	long
;	O
file_hdr	pointer
->	O
c_atime_nsec	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_ctime_nsec	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_filesize	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_dev_maj	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_dev_min	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_rdev_maj	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_rdev_min	long
=	O
0	int
;	O
file_hdr	pointer
->	O
c_cu	char
=	O
TARU_C_BY_USYS	int
;	O
file_hdr	pointer
->	O
c_cg	char
=	O
TARU_C_BY_GSYS	int
;	O
file_hdr	pointer
->	O
c_is_tar_lnktype	char
=	O
-	O
1	int
;	O
ahsStaticSetTarGroupname	function
(	O
file_hdr	pointer
,	O
""	pointer
)	O
;	O
ahsStaticSetTarUsername	function
(	O
file_hdr	pointer
,	O
""	pointer
)	O
;	O
ahsStaticSetPaxLinkname	function
(	O
file_hdr	pointer
,	O
""	pointer
)	O
;	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
""	pointer
)	O
;	O
file_hdr	pointer
->	O
usage_maskM	char
=	O
0	int
;	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
=	O
0	int
;	O
file_hdr	pointer
->	O
extHeader_needs_maskM	int
=	O
0	int
;	O
taru_init_header_digs	function
(	O
file_hdr	pointer
)	O
;	O
if	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
)	O
{	O
index	function
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
EXATT	struct
*	O
)	O
cplob_val	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
p	pointer
->	O
is_in_useM	int
==	O
0	int
;	O
index	function
++	O
;	O
}	O
}	O
}	O
struct	O
new_cpio_header	struct
*	O
taru_make_header	function
(	O
void	O
)	O
{	O
struct	O
new_cpio_header	struct
*	O
hnew	pointer
;	O
hnew	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
new_cpio_header	struct
)	O
)	O
;	O
hnew	pointer
->	O
c_name	pointer
=	O
NULL	O
;	O
hnew	pointer
->	O
c_tar_linkname	pointer
=	O
NULL	O
;	O
hnew	pointer
->	O
c_username	pointer
=	O
NULL	O
;	O
hnew	pointer
->	O
c_groupname	pointer
=	O
NULL	O
;	O
hnew	pointer
->	O
digsM	pointer
=	O
NULL	O
;	O
hnew	pointer
->	O
extattlistM	pointer
=	O
NULL	O
;	O
taru_init_header	function
(	O
hnew	pointer
)	O
;	O
return	O
hnew	pointer
;	O
}	O
void	O
taru_set_tarheader_flag	function
(	O
TARU	struct
*	O
taru	pointer
,	O
int	O
flag	int
,	O
int	O
n	long
)	O
{	O
if	O
(	O
n	long
)	O
{	O
taru	pointer
->	O
taru_tarheaderflagsM	int
|=	O
flag	int
;	O
}	O
else	O
{	O
taru	pointer
->	O
taru_tarheaderflagsM	int
&=	O
~	O
flag	int
;	O
}	O
}	O
void	O
taru_set_preview_level	function
(	O
TARU	struct
*	O
taru	pointer
,	O
int	O
preview_level	int
)	O
{	O
taru	pointer
->	O
preview_levelM	int
=	O
preview_level	int
;	O
}	O
int	O
taru_get_preview_level	function
(	O
TARU	struct
*	O
taru	pointer
)	O
{	O
return	O
taru	pointer
->	O
preview_levelM	int
;	O
}	O
void	O
taru_set_preview_fd	function
(	O
TARU	struct
*	O
taru	pointer
,	O
int	O
fd	int
)	O
{	O
taru	pointer
->	O
preview_fdM	int
=	O
fd	int
;	O
}	O
int	O
taru_get_preview_fd	function
(	O
TARU	struct
*	O
taru	pointer
)	O
{	O
return	O
taru	pointer
->	O
preview_fdM	int
;	O
}	O
void	O
taru_free_header	function
(	O
struct	O
new_cpio_header	struct
*	O
h	pointer
)	O
{	O
CPLOB	struct
*	O
p	pointer
;	O
taru_free_header_digs	function
(	O
h	pointer
)	O
;	O
ahsStaticSetTarGroupname	function
(	O
h	pointer
,	O
NULL	O
)	O
;	O
ahsStaticSetTarUsername	function
(	O
h	pointer
,	O
NULL	O
)	O
;	O
ahsStaticSetPaxLinkname	function
(	O
h	pointer
,	O
NULL	O
)	O
;	O
ahsStaticSetTarFilename	function
(	O
h	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
h	pointer
->	O
extattlistM	pointer
)	O
{	O
p	pointer
=	O
(	O
CPLOB	struct
*	O
)	O
(	O
h	pointer
->	O
extattlistM	pointer
)	O
;	O
p	pointer
->	O
refcountM	int
--	O
;	O
if	O
(	O
p	pointer
->	O
refcountM	int
<=	O
0	int
)	O
{	O
taru_exattlist_delete_all	function
(	O
h	pointer
)	O
;	O
cplob_shallow_close	function
(	O
p	pointer
)	O
;	O
}	O
}	O
swbis_free	O
(	O
h	pointer
)	O
;	O
}	O
int	O
taru_print_tar_ls_list	function
(	O
STROB	struct
*	O
buf	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
vflag	int
)	O
{	O
int	O
type	enum
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
type	enum
=	O
taru_get_tar_filetype	function
(	O
file_hdr	pointer
->	O
c_mode	short
)	O
;	O
if	O
(	O
(	O
file_hdr	pointer
->	O
c_is_tar_lnktype	char
==	O
1	int
)	O
||	O
(	O
type	enum
==	O
REGTYPE	char
&&	O
strlen	function
(	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
)	O
)	O
{	O
type	enum
=	O
LNKTYPE	char
;	O
}	O
if	O
(	O
type	enum
>=	O
0	int
)	O
ls_list_to_string	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
,	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
,	O
file_hdr	pointer
,	O
(	O
time_t	long
)	O
(	O
0	int
)	O
,	O
buf	pointer
,	O
ahsStaticGetTarUsername	function
(	O
file_hdr	pointer
)	O
,	O
ahsStaticGetTarGroupname	function
(	O
file_hdr	pointer
)	O
,	O
type	enum
,	O
vflag	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unrecognized file type in mode [%d] for file: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
(	O
file_hdr	pointer
->	O
c_mode	short
)	O
,	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
strob_strcat	function
(	O
buf	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
taru_write_preview_line	function
(	O
TARU	struct
*	O
taru	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
flag	int
;	O
int	O
level	int
;	O
char	O
*	O
filename	pointer
;	O
STROB	struct
*	O
buffer	array
;	O
flag	int
=	O
0	int
;	O
if	O
(	O
taru	pointer
->	O
preview_fdM	int
<	O
0	int
||	O
taru	pointer
->	O
preview_levelM	int
==	O
TARU_PV_0	int
)	O
{	O
return	O
;	O
}	O
fd	int
=	O
taru	pointer
->	O
preview_fdM	int
;	O
level	int
=	O
taru	pointer
->	O
preview_levelM	int
;	O
buffer	array
=	O
taru	pointer
->	O
preview_bufferM	pointer
;	O
filename	pointer
=	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
;	O
if	O
(	O
isatty	function
(	O
fd	int
)	O
)	O
{	O
flag	int
=	O
ls_list_get_encoding_flag	function
(	O
)	O
;	O
ls_list_set_encoding_by_lang	function
(	O
)	O
;	O
}	O
if	O
(	O
level	int
>=	O
TARU_PV_3	int
)	O
{	O
taru_print_tar_ls_list	function
(	O
buffer	array
,	O
file_hdr	pointer
,	O
LS_LIST_VERBOSE_L2	O
)	O
;	O
}	O
else	O
if	O
(	O
level	int
>=	O
TARU_PV_2	int
)	O
{	O
taru_print_tar_ls_list	function
(	O
buffer	array
,	O
file_hdr	pointer
,	O
LS_LIST_VERBOSE_L1	O
)	O
;	O
}	O
else	O
if	O
(	O
level	int
>=	O
TARU_PV_1	int
)	O
{	O
strob_strcpy	function
(	O
buffer	array
,	O
""	pointer
)	O
;	O
ls_list_safe_print_to_strob	function
(	O
filename	pointer
,	O
buffer	array
,	O
0	int
)	O
;	O
strob_strcat	function
(	O
buffer	array
,	O
"\n"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
buffer	array
,	O
""	pointer
)	O
;	O
}	O
if	O
(	O
strob_strlen	function
(	O
buffer	array
)	O
)	O
{	O
uxfio_write	function
(	O
fd	int
,	O
strob_str	function
(	O
buffer	array
)	O
,	O
strob_strlen	function
(	O
buffer	array
)	O
)	O
;	O
}	O
if	O
(	O
isatty	function
(	O
fd	int
)	O
)	O
{	O
ls_list_set_encoding_flag	function
(	O
flag	int
)	O
;	O
}	O
}	O
int	O
taru_set_tar_header_policy	function
(	O
TARU	struct
*	O
taru	pointer
,	O
char	O
*	O
user_format	pointer
,	O
int	O
*	O
p_arf_format	pointer
)	O
{	O
int	O
xx	int
;	O
int	O
*	O
format	pointer
;	O
if	O
(	O
!	O
p_arf_format	pointer
)	O
format	pointer
=	O
&	O
xx	int
;	O
else	O
format	pointer
=	O
p_arf_format	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"ustar"	pointer
)	O
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
0	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"gnu"	pointer
)	O
||	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"gnutar"	pointer
)	O
||	O
0	int
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUPOSIX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_BLOCKSIZE_B1	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_GNUTAR	O
,	O
1	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"ustar.star"	pointer
)	O
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUPOSIX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_STAR	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_BLOCKSIZE_B1	O
,	O
1	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"oldgnu"	pointer
)	O
||	O
0	int
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_BLOCKSIZE_B1	O
,	O
1	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"ustar0"	pointer
)	O
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_BLOCKSIZE_B1	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUPOSIX	O
,	O
1	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"bsdpax3"	pointer
)	O
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_BLOCKSIZE_B1	O
,	O
1	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
0	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"newc"	pointer
)	O
)	O
{	O
*	O
format	pointer
=	O
arf_newascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"crc"	pointer
)	O
)	O
{	O
*	O
format	pointer
=	O
arf_crcascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"odc"	pointer
)	O
)	O
{	O
*	O
format	pointer
=	O
arf_oldascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"pax"	pointer
)	O
||	O
!	O
strcmp	function
(	O
user_format	pointer
,	O
"posix"	pointer
)	O
)	O
{	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUPOSIX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
0	int
)	O
;	O
taru_set_tarheader_flag	function
(	O
taru	pointer
,	O
TARU_TAR_PAXEXTHDR	O
,	O
1	int
)	O
;	O
*	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unrecognized format: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
user_format	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
taru_check_devno_for_tar	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
if	O
(	O
file_hdr	pointer
->	O
c_rdev_maj	long
>	O
2097151	int
)	O
return	O
1	int
;	O
if	O
(	O
file_hdr	pointer
->	O
c_rdev_min	long
>	O
2097151	int
)	O
return	O
2	int
;	O
return	O
0	int
;	O
}	O
int	O
taru_check_devno_for_system	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
int	O
d	int
=	O
makedev	O
(	O
file_hdr	pointer
->	O
c_rdev_maj	long
,	O
file_hdr	pointer
->	O
c_rdev_min	long
)	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
file_hdr	pointer
->	O
c_rdev_maj	long
)	O
!=	O
(	O
int	O
)	O
minor	O
(	O
d	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
(	O
int	O
)	O
(	O
file_hdr	pointer
->	O
c_rdev_min	long
)	O
!=	O
(	O
int	O
)	O
minor	O
(	O
d	int
)	O
)	O
return	O
2	int
;	O
return	O
0	int
;	O
}	O
