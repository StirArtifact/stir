static	O
const	O
char	O
cright_years_z	array
[	O
]	O
=	O
"1994-2015"	pointer
;	O
static	O
inline	O
unsigned	O
char	O
to_uchar	function
(	O
char	O
ch	char
)	O
{	O
return	O
ch	char
;	O
}	O
struct	O
tm	struct
*	O
localtime	function
(	O
)	O
;	O
static	O
char	O
explain_text_fmt	array
[	O
sizeof	O
(	O
explain_fmt_fmt_z	array
)	O
]	O
;	O
static	O
int	O
const	O
explain_1_len	int
=	O
sizeof	O
(	O
explain_1_z	array
)	O
-	O
1	int
;	O
static	O
int	O
const	O
explain_2_len	int
=	O
sizeof	O
(	O
explain_2_z	array
)	O
-	O
1	int
;	O
typedef	O
enum	O
{	O
QUOT_ID_LNAME	int
,	O
QUOT_ID_RNAME	int
,	O
QUOT_ID_PATH	int
}	O
quot_id_t	enum
;	O
typedef	O
struct	O
{	O
char	O
const	O
*	O
cmpr_name	pointer
;	O
char	O
const	O
*	O
cmpr_cmd_fmt	pointer
;	O
char	O
const	O
*	O
cmpr_title	pointer
;	O
char	O
const	O
*	O
cmpr_mode	pointer
;	O
char	O
const	O
*	O
cmpr_unpack	pointer
;	O
char	O
const	O
*	O
cmpr_unnote	pointer
;	O
unsigned	O
long	O
cmpr_level	long
;	O
}	O
compact_state_t	struct
;	O
compact_state_t	struct
gzip_compaction	struct
=	O
{	O
.	O
cmpr_name	pointer
=	O
"gzip"	pointer
,	O
.	O
cmpr_cmd_fmt	pointer
=	O
"gzip -c -%u %s"	pointer
,	O
.	O
cmpr_title	pointer
=	O
"gzipped"	pointer
,	O
.	O
cmpr_mode	pointer
=	O
"gzi"	pointer
,	O
.	O
cmpr_unpack	pointer
=	O
"gzip -dc ${lock_dir}/gzi > %s && \\\n"	pointer
,	O
.	O
cmpr_unnote	pointer
=	O
"gunzipping file %s"	pointer
}	O
;	O
compact_state_t	struct
xz_compaction	struct
=	O
{	O
.	O
cmpr_name	pointer
=	O
"xz"	pointer
,	O
.	O
cmpr_cmd_fmt	pointer
=	O
"xz -zc -%u %s"	pointer
,	O
.	O
cmpr_title	pointer
=	O
"xz-compressed"	pointer
,	O
.	O
cmpr_mode	pointer
=	O
"xzi"	pointer
,	O
.	O
cmpr_unpack	pointer
=	O
"xz -dc ${lock_dir}/xzi > %s && \\\n"	pointer
,	O
.	O
cmpr_unnote	pointer
=	O
"xz-decompressing file %s"	pointer
}	O
;	O
compact_state_t	struct
bzip2_compaction	struct
=	O
{	O
.	O
cmpr_name	pointer
=	O
"bzip2"	pointer
,	O
.	O
cmpr_cmd_fmt	pointer
=	O
"bzip2 -zkc -%u %s"	pointer
,	O
.	O
cmpr_title	pointer
=	O
"bzipped"	pointer
,	O
.	O
cmpr_mode	pointer
=	O
"bzi"	pointer
,	O
.	O
cmpr_unpack	pointer
=	O
"bzip2 -dkc ${lock_dir}/bzi > %s && \\\n"	pointer
,	O
.	O
cmpr_unnote	pointer
=	O
"bunzipping file %s"	pointer
}	O
;	O
compact_state_t	struct
*	O
const	O
compaction	array
[	O
]	O
=	O
{	O
&	O
gzip_compaction	struct
,	O
&	O
xz_compaction	struct
,	O
&	O
bzip2_compaction	struct
}	O
;	O
compact_state_t	struct
*	O
cmpr_state	pointer
=	O
NULL	O
;	O
static	O
int	O
const	O
compact_ct	int
=	O
sizeof	O
(	O
compaction	array
)	O
/	O
sizeof	O
(	O
compaction	array
[	O
0	int
]	O
)	O
;	O
static	O
int	O
line_prefix	int
=	O
'\0'	O
;	O
static	O
size_t	long
here_delimiter_length	long
=	O
0	int
;	O
typedef	O
enum	O
{	O
fail	int
=	O
~	O
1	int
,	O
doue_true	int
=	O
true	int
,	O
doue_false	int
=	O
false	int
}	O
do_uue_t	enum
;	O
do_uue_t	enum
uuencode_file	enum
=	O
fail	int
;	O
int	O
opt_idx	int
=	O
0	int
;	O
static	O
FILE	struct
*	O
output	pointer
=	O
NULL	O
;	O
static	O
off_t	long
archive_type_position	long
=	O
0	int
;	O
static	O
off_t	long
first_file_position	long
=	O
0	int
;	O
static	O
char	O
*	O
output_filename	pointer
=	O
NULL	O
;	O
static	O
int	O
part_number	int
=	O
0	int
;	O
static	O
unsigned	O
char	O
byte_is_binary	array
[	O
256	int
]	O
;	O
static	O
struct	O
stat	struct
struct_stat	struct
;	O
static	O
int	O
sharpid	int
=	O
0	int
;	O
static	O
int	O
translate_script	int
=	O
0	int
;	O
static	O
int	O
mkdir_alloc_ct	int
=	O
0	int
;	O
static	O
int	O
mkdir_already_ct	int
=	O
0	int
;	O
static	O
char	O
*	O
*	O
mkdir_already	pointer
;	O
static	O
void	O
open_output	function
(	O
void	O
)	O
;	O
static	O
void	O
close_output	function
(	O
int	O
next_part_no	int
)	O
;	O
typedef	O
int	O
(	O
*	O
walker_t	pointer
)	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
init_shar_msg	function
(	O
void	O
)	O
{	O
int	O
ix	int
;	O
struct	O
quoting_options	O
*	O
alwaysq	pointer
,	O
*	O
doubleq	pointer
;	O
if	O
(	O
translate_script	int
)	O
{	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
SHAR_MSG_CT	int
;	O
ix	int
++	O
)	O
shar_msg_table	array
[	O
ix	int
]	O
=	O
gettext	function
(	O
shar_msg_table	array
[	O
ix	int
]	O
)	O
;	O
}	O
alwaysq	pointer
=	O
clone_quoting_options	function
(	O
NULL	O
)	O
;	O
set_quoting_style	function
(	O
alwaysq	pointer
,	O
shell_always_quoting_style	int
)	O
;	O
doubleq	pointer
=	O
clone_quoting_options	function
(	O
NULL	O
)	O
;	O
set_quoting_style	function
(	O
doubleq	pointer
,	O
c_quoting_style	int
)	O
;	O
set_char_quoting	function
(	O
doubleq	pointer
,	O
'"'	O
,	O
1	int
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
SHAR_MSG_CT	int
;	O
ix	int
++	O
)	O
{	O
char	O
const	O
*	O
pz	pointer
=	O
shar_msg_table	array
[	O
ix	int
]	O
;	O
switch	O
(	O
shar_msg_xform	array
[	O
ix	int
]	O
)	O
{	O
case	O
XFORM_PLAIN	int
:	O
continue	O
;	O
case	O
XFORM_APOSTROPHE	int
:	O
pz	pointer
=	O
quotearg_alloc	function
(	O
pz	pointer
,	O
shar_msg_size	array
[	O
ix	int
]	O
,	O
alwaysq	pointer
)	O
;	O
break	O
;	O
case	O
XFORM_DBL_QUOTE	int
:	O
pz	pointer
=	O
quotearg_alloc	function
(	O
pz	pointer
,	O
shar_msg_size	array
[	O
ix	int
]	O
,	O
doubleq	pointer
)	O
;	O
break	O
;	O
}	O
shar_msg_table	array
[	O
ix	int
]	O
=	O
pz	pointer
;	O
}	O
free	function
(	O
alwaysq	pointer
)	O
;	O
free	function
(	O
doubleq	pointer
)	O
;	O
}	O
static	O
char	O
const	O
*	O
format_report	function
(	O
char	O
const	O
*	O
fmt	pointer
,	O
char	O
const	O
*	O
what	pointer
)	O
{	O
if	O
(	O
fmt	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
{	O
size_t	long
sz	long
=	O
strlen	function
(	O
fmt	pointer
)	O
+	O
strlen	function
(	O
what	pointer
)	O
+	O
2	int
;	O
char	O
*	O
res	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
int	O
len	long
=	O
snprintf	function
(	O
res	pointer
,	O
sz	long
,	O
fmt	pointer
,	O
what	pointer
)	O
;	O
if	O
(	O
(	O
unsigned	O
)	O
len	long
<	O
sz	long
)	O
return	O
res	pointer
;	O
if	O
(	O
len	long
<	O
0	int
)	O
die	function
(	O
SHAR_EXIT_BUG	int
,	O
_	O
(	O
"printf formatting error:  %s\n"	pointer
)	O
,	O
fmt	pointer
)	O
;	O
res	pointer
=	O
scribble_get	function
(	O
len	long
+	O
1	int
)	O
;	O
return	O
res	pointer
;	O
}	O
}	O
static	O
void	O
echo_status	function
(	O
const	O
char	O
*	O
test	pointer
,	O
const	O
char	O
*	O
ok_fmt	pointer
,	O
const	O
char	O
*	O
bad_fmt	pointer
,	O
const	O
char	O
*	O
what	pointer
,	O
int	O
die_on_failure	int
)	O
{	O
char	O
const	O
*	O
good_quot	pointer
;	O
char	O
const	O
*	O
bad_quot	pointer
;	O
char	O
const	O
*	O
die_str	pointer
;	O
good_quot	pointer
=	O
format_report	function
(	O
ok_fmt	pointer
,	O
what	pointer
)	O
;	O
bad_quot	pointer
=	O
format_report	function
(	O
bad_fmt	pointer
,	O
what	pointer
)	O
;	O
die_str	pointer
=	O
die_on_failure	int
?	O
show_status_dies_z	array
:	O
""	pointer
;	O
if	O
(	O
good_quot	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bad_quot	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
output	pointer
,	O
show_all_status_z	array
,	O
test	pointer
,	O
good_quot	pointer
,	O
bad_quot	pointer
,	O
die_str	pointer
)	O
;	O
else	O
fprintf	function
(	O
output	pointer
,	O
show_good_status_z	array
,	O
test	pointer
,	O
good_quot	pointer
)	O
;	O
}	O
else	O
if	O
(	O
bad_quot	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
output	pointer
,	O
show_bad_status_z	array
,	O
test	pointer
,	O
bad_quot	pointer
,	O
die_str	pointer
)	O
;	O
else	O
die	function
(	O
SHAR_EXIT_BUG	int
,	O
_	O
(	O
"sharutils bug - no status"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
echo_text	function
(	O
const	O
char	O
*	O
format_pz	pointer
,	O
const	O
char	O
*	O
arg_pz	pointer
,	O
bool	bool
cascade	bool
)	O
{	O
static	O
char	O
const	O
continue_z	array
[	O
]	O
=	O
" &&\n"	pointer
;	O
size_t	long
sz	long
=	O
strlen	function
(	O
format_pz	pointer
)	O
+	O
strlen	function
(	O
arg_pz	pointer
)	O
+	O
sizeof	O
(	O
continue_z	array
)	O
;	O
char	O
*	O
bf	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
unsigned	O
int	O
len	long
=	O
(	O
unsigned	O
)	O
snprintf	function
(	O
bf	pointer
,	O
sz	long
,	O
format_pz	pointer
,	O
arg_pz	pointer
)	O
;	O
if	O
(	O
cascade	bool
)	O
memcpy	function
(	O
bf	pointer
+	O
len	long
,	O
continue_z	array
,	O
sizeof	O
(	O
continue_z	array
)	O
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
bf	pointer
)	O
;	O
}	O
static	O
int	O
walkdown	function
(	O
walker_t	pointer
routine	pointer
,	O
const	O
char	O
*	O
local_name	pointer
,	O
const	O
char	O
*	O
restore_name	pointer
)	O
{	O
DIR	struct
*	O
directory	pointer
;	O
int	O
status	int
;	O
char	O
*	O
local_name_copy	pointer
;	O
size_t	long
local_name_length	long
;	O
size_t	long
sizeof_local_name	long
;	O
char	O
*	O
restore_name_copy	pointer
;	O
int	O
restore_offset	int
;	O
size_t	long
restore_name_length	long
;	O
size_t	long
sizeof_restore_name	long
;	O
if	O
(	O
stat	struct
(	O
local_name	pointer
,	O
&	O
struct_stat	struct
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
local_name	pointer
)	O
;	O
return	O
SHAR_EXIT_FILE_NOT_FOUND	int
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
struct_stat	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
return	O
(	O
*	O
routine	pointer
)	O
(	O
local_name	pointer
,	O
restore_name	pointer
)	O
;	O
if	O
(	O
directory	pointer
=	O
opendir	function
(	O
local_name	pointer
)	O
,	O
!	O
directory	pointer
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
local_name	pointer
)	O
;	O
return	O
SHAR_EXIT_CANNOT_OPENDIR	int
;	O
}	O
status	int
=	O
0	int
;	O
local_name_length	long
=	O
strlen	function
(	O
local_name	pointer
)	O
+	O
1	int
;	O
sizeof_local_name	long
=	O
local_name_length	long
+	O
32	int
;	O
local_name_copy	pointer
=	O
xmalloc	function
(	O
sizeof_local_name	long
)	O
;	O
memcpy	function
(	O
local_name_copy	pointer
,	O
local_name	pointer
,	O
local_name_length	long
-	O
1	int
)	O
;	O
local_name_copy	pointer
[	O
local_name_length	long
-	O
1	int
]	O
=	O
'/'	O
;	O
local_name_copy	pointer
[	O
local_name_length	long
]	O
=	O
NUL	char
;	O
restore_name_length	long
=	O
strlen	function
(	O
restore_name	pointer
)	O
+	O
1	int
;	O
sizeof_restore_name	long
=	O
restore_name_length	long
+	O
32	int
;	O
restore_name_copy	pointer
=	O
xmalloc	function
(	O
sizeof_restore_name	long
)	O
;	O
memcpy	function
(	O
restore_name_copy	pointer
,	O
restore_name	pointer
,	O
restore_name_length	long
-	O
1	int
)	O
;	O
restore_name_copy	pointer
[	O
restore_name_length	long
-	O
1	int
]	O
=	O
'/'	O
;	O
restore_name_copy	pointer
[	O
restore_name_length	long
]	O
=	O
NUL	char
;	O
if	O
(	O
(	O
restore_name_copy	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
&&	O
(	O
restore_name_copy	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
)	O
restore_offset	int
=	O
2	int
;	O
else	O
restore_offset	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
dirent	struct
*	O
entry	pointer
=	O
readdir	function
(	O
directory	pointer
)	O
;	O
const	O
char	O
*	O
pzN	pointer
;	O
int	O
space_need	int
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
break	O
;	O
pzN	pointer
=	O
entry	pointer
->	O
d_name	array
;	O
if	O
(	O
*	O
pzN	pointer
==	O
'.'	O
)	O
{	O
if	O
(	O
pzN	pointer
[	O
1	int
]	O
==	O
NUL	char
)	O
continue	O
;	O
if	O
(	O
(	O
pzN	pointer
[	O
1	int
]	O
==	O
'.'	O
)	O
&&	O
(	O
pzN	pointer
[	O
2	int
]	O
==	O
NUL	char
)	O
)	O
continue	O
;	O
}	O
space_need	int
=	O
1	int
+	O
NAMLEN	O
(	O
entry	pointer
)	O
;	O
if	O
(	O
local_name_length	long
+	O
space_need	int
>	O
sizeof_local_name	long
)	O
{	O
sizeof_local_name	long
=	O
local_name_length	long
+	O
space_need	int
+	O
16	int
;	O
local_name_copy	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
local_name_copy	pointer
,	O
sizeof_local_name	long
)	O
;	O
}	O
strcpy	function
(	O
local_name_copy	pointer
+	O
local_name_length	long
,	O
pzN	pointer
)	O
;	O
if	O
(	O
restore_name_length	long
+	O
space_need	int
>	O
sizeof_restore_name	long
)	O
{	O
sizeof_restore_name	long
=	O
restore_name_length	long
+	O
space_need	int
+	O
16	int
;	O
restore_name_copy	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
restore_name_copy	pointer
,	O
sizeof_restore_name	long
)	O
;	O
}	O
strcpy	function
(	O
restore_name_copy	pointer
+	O
restore_name_length	long
,	O
pzN	pointer
)	O
;	O
status	int
=	O
walkdown	function
(	O
routine	pointer
,	O
local_name_copy	pointer
,	O
restore_name_copy	pointer
+	O
restore_offset	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
break	O
;	O
}	O
free	function
(	O
local_name_copy	pointer
)	O
;	O
free	function
(	O
restore_name_copy	pointer
)	O
;	O
if	O
(	O
closedir	function
(	O
directory	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
local_name	pointer
)	O
;	O
return	O
SHAR_EXIT_CANNOT_OPENDIR	int
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
walktree	function
(	O
walker_t	pointer
routine	pointer
,	O
const	O
char	O
*	O
local_name	pointer
)	O
{	O
const	O
char	O
*	O
restore_name	pointer
;	O
char	O
*	O
local_name_copy	pointer
;	O
{	O
int	O
len	long
=	O
strlen	function
(	O
local_name	pointer
)	O
;	O
char	O
*	O
cursor	pointer
;	O
local_name_copy	pointer
=	O
(	O
char	O
*	O
)	O
alloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
local_name_copy	pointer
,	O
local_name	pointer
,	O
len	long
+	O
1	int
)	O
;	O
cursor	pointer
=	O
local_name_copy	pointer
+	O
len	long
-	O
1	int
;	O
while	O
(	O
*	O
cursor	pointer
==	O
'/'	O
&&	O
cursor	pointer
>	O
local_name_copy	pointer
)	O
*	O
(	O
cursor	pointer
--	O
)	O
=	O
NUL	char
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
BASENAME	O
)	O
)	O
restore_name	pointer
=	O
base_name	function
(	O
local_name_copy	pointer
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
local_name_copy	pointer
,	O
"./"	pointer
,	O
2	int
)	O
)	O
restore_name	pointer
=	O
local_name_copy	pointer
+	O
2	int
;	O
else	O
restore_name	pointer
=	O
local_name_copy	pointer
;	O
return	O
walkdown	function
(	O
routine	pointer
,	O
local_name_copy	pointer
,	O
restore_name	pointer
)	O
;	O
}	O
static	O
char	O
*	O
mode_string	function
(	O
unsigned	O
mode	int
)	O
{	O
static	O
char	O
const	O
modes	int
[	O
]	O
=	O
"-rwxrwxrwx"	pointer
;	O
static	O
char	O
result	array
[	O
12	int
]	O
;	O
int	O
ix	int
=	O
1	int
;	O
int	O
msk	int
=	O
0400	int
;	O
strcpy	function
(	O
result	array
,	O
"----------"	pointer
)	O
;	O
do	O
{	O
if	O
(	O
mode	int
&	O
msk	int
)	O
result	array
[	O
ix	int
]	O
=	O
modes	int
[	O
ix	int
]	O
;	O
ix	int
++	O
;	O
msk	int
>>=	O
1	int
;	O
}	O
while	O
(	O
msk	int
!=	O
0	int
)	O
;	O
if	O
(	O
mode	int
&	O
04000	int
)	O
result	array
[	O
3	int
]	O
=	O
's'	O
;	O
if	O
(	O
mode	int
&	O
02000	int
)	O
result	array
[	O
6	int
]	O
=	O
's'	O
;	O
return	O
result	array
;	O
}	O
static	O
void	O
generate_configure	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_MD5_DIGEST	O
)	O
)	O
fprintf	function
(	O
output	pointer
,	O
md5check_z	array
,	O
SM_not_verifying_sums	O
)	O
;	O
fputs	function
(	O
clobber_check_z	array
,	O
output	pointer
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_I18N	O
)	O
)	O
{	O
fputs	function
(	O
i18n_z	array
,	O
output	pointer
)	O
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
VANILLA_OPERATION	O
)	O
)	O
fputs	function
(	O
dev_tty_nocheck_z	array
,	O
output	pointer
)	O
;	O
else	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
fputs	function
(	O
dev_tty_check_z	array
,	O
output	pointer
)	O
;	O
fputs	function
(	O
echo_checks_z	array
,	O
output	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_TIMESTAMP	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
timestamp_z	array
,	O
SM_time_not_set	O
)	O
;	O
}	O
if	O
(	O
(	O
!	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
||	O
(	O
part_number	int
==	O
1	int
)	O
)	O
{	O
echo_status	function
(	O
ck_lockdir_z	array
,	O
NULL	O
,	O
SM_lock_dir_exists	O
,	O
lock_dir_z	array
,	O
1	int
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
VANILLA_OPERATION	O
)	O
)	O
echo_status	function
(	O
make_lock_dir_z	array
,	O
NULL	O
,	O
SM_no_lock_dir	O
,	O
lock_dir_z	array
,	O
1	int
)	O
;	O
else	O
echo_status	function
(	O
make_lock_dir_z	array
,	O
SM_x_lock_dir_created	O
,	O
SM_x_no_lock_dir	O
,	O
lock_dir_z	array
,	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
output	pointer
,	O
seq_check_z	array
,	O
SM_unpack_part_1	O
,	O
part_number	int
,	O
SM_unpack_next_part	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
query_answers_z	array
,	O
SM_ans_yes	O
,	O
SM_yes_means	O
,	O
SM_ans_no	O
,	O
SM_no_means	O
,	O
SM_ans_all	O
,	O
SM_all_means	O
,	O
SM_ans_none	O
,	O
SM_none_means	O
,	O
SM_ans_help	O
,	O
SM_help_means	O
,	O
SM_ans_quit	O
,	O
SM_quit_means	O
)	O
;	O
}	O
}	O
static	O
void	O
generate_mkdir	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
const	O
char	O
*	O
quoted_path	pointer
;	O
{	O
int	O
ct	int
=	O
mkdir_already_ct	int
;	O
char	O
*	O
*	O
pp	pointer
=	O
mkdir_already	pointer
;	O
while	O
(	O
--	O
ct	int
>	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
(	O
pp	pointer
++	O
)	O
,	O
path	pointer
)	O
==	O
0	int
)	O
return	O
;	O
}	O
}	O
if	O
(	O
++	O
mkdir_already_ct	int
>	O
mkdir_alloc_ct	int
)	O
{	O
mkdir_alloc_ct	int
+=	O
16	int
+	O
(	O
mkdir_alloc_ct	int
/	O
2	int
)	O
;	O
if	O
(	O
mkdir_alloc_ct	int
<	O
0	int
)	O
die	function
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Too many directories for mkdir generation"	pointer
)	O
)	O
;	O
if	O
(	O
mkdir_already	pointer
!=	O
NULL	O
)	O
mkdir_already	pointer
=	O
xrealloc	function
(	O
mkdir_already	pointer
,	O
mkdir_alloc_ct	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
else	O
mkdir_already	pointer
=	O
xmalloc	function
(	O
mkdir_alloc_ct	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
mkdir_already	pointer
[	O
mkdir_already_ct	int
-	O
1	int
]	O
=	O
xstrdup	function
(	O
path	pointer
)	O
;	O
quoted_path	pointer
=	O
quotearg_n_style	function
(	O
QUOT_ID_PATH	int
,	O
shell_always_quoting_style	int
,	O
path	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
dir_check_z	array
,	O
quoted_path	pointer
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
dir_create_z	array
,	O
quoted_path	pointer
)	O
;	O
echo_status	function
(	O
aok_check_z	array
,	O
SM_x_dir_created	O
,	O
SM_x_no_dir	O
,	O
path	pointer
,	O
1	int
)	O
;	O
}	O
else	O
fprintf	function
(	O
output	pointer
,	O
"  mkdir %s || exit 1\n"	pointer
,	O
quoted_path	pointer
)	O
;	O
fputs	function
(	O
"fi\n"	pointer
,	O
output	pointer
)	O
;	O
}	O
static	O
void	O
clear_mkdir_already	function
(	O
void	O
)	O
{	O
char	O
*	O
*	O
pp	pointer
=	O
mkdir_already	pointer
;	O
int	O
ct	int
=	O
mkdir_already_ct	int
;	O
mkdir_already_ct	int
=	O
0	int
;	O
while	O
(	O
--	O
ct	int
>=	O
0	int
)	O
{	O
free	function
(	O
*	O
pp	pointer
)	O
;	O
*	O
(	O
pp	pointer
++	O
)	O
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
generate_mkdir_script	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
cursor	pointer
;	O
for	O
(	O
cursor	pointer
=	O
strchr	function
(	O
path	pointer
,	O
'/'	O
)	O
;	O
cursor	pointer
;	O
cursor	pointer
=	O
strchr	function
(	O
cursor	pointer
+	O
1	int
,	O
'/'	O
)	O
)	O
{	O
if	O
(	O
cursor	pointer
==	O
path	pointer
||	O
*	O
(	O
cursor	pointer
-	O
1	int
)	O
==	O
'/'	O
)	O
continue	O
;	O
if	O
(	O
cursor	pointer
[	O
-	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
cursor	pointer
==	O
path	pointer
+	O
1	int
||	O
cursor	pointer
[	O
-	O
2	int
]	O
==	O
'/'	O
)	O
)	O
continue	O
;	O
*	O
cursor	pointer
=	O
0	int
;	O
generate_mkdir	function
(	O
path	pointer
)	O
;	O
*	O
cursor	pointer
=	O
'/'	O
;	O
}	O
}	O
static	O
int	O
check_accessibility	function
(	O
const	O
char	O
*	O
local_name	pointer
,	O
const	O
char	O
*	O
restore_name	pointer
)	O
{	O
if	O
(	O
access	function
(	O
local_name	pointer
,	O
4	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot access %s"	pointer
)	O
,	O
local_name	pointer
)	O
;	O
return	O
SHAR_EXIT_FILE_NOT_FOUND	int
;	O
}	O
return	O
SHAR_EXIT_SUCCESS	int
;	O
}	O
static	O
int	O
generate_one_header_line	function
(	O
const	O
char	O
*	O
local_name	pointer
,	O
const	O
char	O
*	O
restore_name	pointer
)	O
{	O
char	O
buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
fprintf	function
(	O
output	pointer
,	O
"# %6s %s %s\n"	pointer
,	O
offtostr	function
(	O
struct_stat	struct
.	O
st_size	long
,	O
buf	array
)	O
,	O
mode_string	function
(	O
struct_stat	struct
.	O
st_mode	int
)	O
,	O
restore_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_caution_notes	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
{	O
char	O
const	O
*	O
msg	pointer
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
msg	pointer
=	O
exist_keep_z	array
;	O
else	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
msg	pointer
=	O
exist_ask_z	array
;	O
else	O
msg	pointer
=	O
exist_kill_z	array
;	O
fprintf	function
(	O
fp	pointer
,	O
exist_note_z	array
,	O
msg	pointer
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
{	O
int	O
len	long
=	O
snprintf	function
(	O
explain_text_fmt	array
,	O
sizeof	O
(	O
explain_text_fmt	array
)	O
,	O
explain_fmt_fmt_z	array
,	O
explain_1_len	int
,	O
explain_2_len	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
)	O
len	long
>=	O
sizeof	O
(	O
explain_text_fmt	array
)	O
)	O
strcpy	function
(	O
explain_text_fmt	array
,	O
"#%-256s\n#%-256s\n"	pointer
)	O
;	O
fputs	function
(	O
"#\n"	pointer
,	O
output	pointer
)	O
;	O
archive_type_position	long
=	O
ftello	function
(	O
output	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
explain_text_fmt	array
,	O
""	pointer
,	O
""	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_header_stamp	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
{	O
char	O
const	O
*	O
pz	pointer
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
""	pointer
;	O
char	O
const	O
*	O
ch	char
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
", a shell"	pointer
:	O
"a shell"	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
file_leader_z	array
,	O
pz	pointer
,	O
ch	char
,	O
PACKAGE	pointer
,	O
VERSION	pointer
,	O
sharpid	int
)	O
;	O
}	O
{	O
static	O
char	O
ftime_fmt	array
[	O
]	O
=	O
"%Y-%m-%d %H:%M %Z"	pointer
;	O
char	O
buffer	array
[	O
sizeof	O
(	O
ftime_fmt	array
)	O
+	O
64	int
]	O
;	O
time_t	long
now	long
;	O
struct	O
tm	struct
*	O
local_time	pointer
;	O
time	struct
(	O
&	O
now	long
)	O
;	O
local_time	pointer
=	O
localtime	function
(	O
&	O
now	long
)	O
;	O
{	O
size_t	long
l	long
=	O
strftime	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
-	O
1	int
,	O
ftime_fmt	array
,	O
local_time	pointer
)	O
;	O
if	O
(	O
l	long
==	O
0	int
)	O
{	O
ftime_fmt	array
[	O
sizeof	O
(	O
ftime_fmt	array
)	O
-	O
2	int
]	O
=	O
'z'	O
;	O
l	long
=	O
strftime	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
-	O
1	int
,	O
ftime_fmt	array
,	O
local_time	pointer
)	O
;	O
}	O
if	O
(	O
l	long
>	O
0	int
)	O
fprintf	function
(	O
fp	pointer
,	O
made_on_comment_z	array
,	O
buffer	array
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
)	O
;	O
}	O
}	O
{	O
char	O
*	O
c_dir	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
c_dir	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
source_dir_comment_z	array
,	O
c_dir	pointer
)	O
;	O
free	function
(	O
c_dir	pointer
)	O
;	O
}	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot get current directory name"	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
generate_full_header	function
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	pointer
)	O
{	O
int	O
counter	int
;	O
for	O
(	O
counter	int
=	O
0	int
;	O
counter	int
<	O
argc	int
;	O
counter	int
++	O
)	O
{	O
struct	O
stat	struct
sb	struct
;	O
if	O
(	O
stat	struct
(	O
argv	pointer
[	O
counter	int
]	O
,	O
&	O
sb	struct
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
walktree	function
(	O
check_accessibility	function
,	O
argv	pointer
[	O
counter	int
]	O
)	O
)	O
exit	function
(	O
SHAR_EXIT_FAILED	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
{	O
static	O
char	O
const	O
by	array
[	O
]	O
=	O
"Submitted-by: %s\nArchive-name: %s%s%02d\n\n"	pointer
;	O
bool	bool
has_slash	bool
=	O
(	O
strchr	function
(	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
;	O
int	O
part	int
=	O
(	O
part_number	int
>	O
0	int
)	O
?	O
part_number	int
:	O
1	int
;	O
fprintf	function
(	O
output	pointer
,	O
by	array
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
,	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
has_slash	bool
?	O
""	pointer
:	O
"/part"	pointer
,	O
part	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CUT_MARK	O
)	O
)	O
fputs	function
(	O
cut_mark_line_z	array
,	O
output	pointer
)	O
;	O
print_header_stamp	function
(	O
output	pointer
)	O
;	O
print_caution_notes	function
(	O
output	pointer
)	O
;	O
fputs	function
(	O
contents_z	array
,	O
output	pointer
)	O
;	O
for	O
(	O
counter	int
=	O
0	int
;	O
counter	int
<	O
argc	int
;	O
counter	int
++	O
)	O
{	O
struct	O
stat	struct
sb	struct
;	O
if	O
(	O
stat	struct
(	O
argv	pointer
[	O
counter	int
]	O
,	O
&	O
sb	struct
)	O
!=	O
0	int
)	O
continue	O
;	O
(	O
void	O
)	O
walktree	function
(	O
generate_one_header_line	function
,	O
argv	pointer
[	O
counter	int
]	O
)	O
;	O
}	O
fputs	function
(	O
"#\n"	pointer
,	O
output	pointer
)	O
;	O
generate_configure	function
(	O
)	O
;	O
}	O
void	O
change_files	function
(	O
const	O
char	O
*	O
restore_name	pointer
,	O
off_t	long
*	O
remaining_size	pointer
)	O
{	O
DEBUG_PRINT	O
(	O
"New file, remaining %s, "	pointer
,	O
*	O
remaining_size	pointer
)	O
;	O
DEBUG_PRINT	O
(	O
"Limit still %s\n"	pointer
,	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
)	O
;	O
fputs	function
(	O
" :\n"	pointer
,	O
output	pointer
)	O
;	O
echo_status	function
(	O
"test $? -ne 0"	pointer
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
restore_name	pointer
,	O
0	int
)	O
;	O
{	O
size_t	long
sz	long
=	O
strlen	function
(	O
SM_end_of_part	O
)	O
+	O
2	int
*	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
sz	long
,	O
SM_end_of_part	O
,	O
part_number	int
,	O
part_number	int
+	O
1	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
bf	pointer
)	O
;	O
}	O
close_output	function
(	O
part_number	int
+	O
1	int
)	O
;	O
clear_mkdir_already	function
(	O
)	O
;	O
open_output	function
(	O
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Starting file %s\n"	pointer
)	O
,	O
output_filename	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
"Submitted-by: %s\n"	pointer
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
"Archive-name: %s%s%02d\n\n"	pointer
,	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
strchr	function
(	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
'/'	O
)	O
?	O
""	pointer
:	O
"/part"	pointer
,	O
part_number	int
?	O
part_number	int
:	O
1	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CUT_MARK	O
)	O
)	O
fputs	function
(	O
cut_mark_line_z	array
,	O
output	pointer
)	O
;	O
{	O
static	O
const	O
char	O
part_z	array
[	O
]	O
=	O
"part %02d of %s "	pointer
;	O
char	O
const	O
*	O
nm	pointer
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
"a multipart"	pointer
;	O
off_t	long
len	long
=	O
sizeof	O
(	O
part_z	array
)	O
+	O
strlen	function
(	O
nm	pointer
)	O
+	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	pointer
=	O
scribble_get	function
(	O
len	long
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
len	long
,	O
part_z	array
,	O
part_number	int
,	O
nm	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
file_leader_z	array
,	O
bf	pointer
,	O
""	pointer
,	O
PACKAGE	pointer
,	O
VERSION	pointer
,	O
sharpid	int
)	O
;	O
}	O
generate_configure	function
(	O
)	O
;	O
first_file_position	long
=	O
ftello	function
(	O
output	pointer
)	O
;	O
}	O
static	O
void	O
read_byte_size	function
(	O
char	O
*	O
wc	pointer
,	O
size_t	long
wc_sz	long
,	O
FILE	struct
*	O
pfp	pointer
)	O
{	O
char	O
*	O
pz	pointer
=	O
wc	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
ch	char
=	O
getc	function
(	O
pfp	pointer
)	O
;	O
if	O
(	O
ch	char
==	O
EOF	O
)	O
goto	O
bogus_number	O
;	O
if	O
(	O
isdigit	function
(	O
ch	char
)	O
)	O
{	O
*	O
(	O
pz	pointer
++	O
)	O
=	O
ch	char
;	O
break	O
;	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
ch	char
=	O
getc	function
(	O
pfp	pointer
)	O
;	O
if	O
(	O
!	O
isdigit	function
(	O
ch	char
)	O
)	O
break	O
;	O
*	O
(	O
pz	pointer
++	O
)	O
=	O
ch	char
;	O
if	O
(	O
pz	pointer
>=	O
wc	pointer
+	O
wc_sz	long
)	O
goto	O
bogus_number	O
;	O
}	O
*	O
pz	pointer
=	O
NUL	char
;	O
return	O
;	O
bogus_number	O
:	O
wc	pointer
[	O
0	int
]	O
=	O
'0'	O
;	O
wc	pointer
[	O
1	int
]	O
=	O
NUL	char
;	O
}	O
static	O
void	O
emit_char_ct_validation	function
(	O
char	O
const	O
*	O
local_name	pointer
,	O
char	O
const	O
*	O
quoted_name	pointer
,	O
char	O
const	O
*	O
restore_name	pointer
,	O
int	O
did_md5	int
)	O
{	O
char	O
wc	pointer
[	O
1	int
+	O
LOG10_MAX_INT	int
*	O
2	int
]	O
;	O
char	O
*	O
command	pointer
;	O
static	O
char	O
const	O
cct_cmd	array
[	O
]	O
=	O
"LC_ALL=C wc -c < %s"	pointer
;	O
command	pointer
=	O
alloca	O
(	O
sizeof	O
(	O
cct_cmd	array
)	O
+	O
strlen	function
(	O
quoted_name	pointer
)	O
)	O
;	O
sprintf	function
(	O
command	pointer
,	O
cct_cmd	array
,	O
quoted_name	pointer
)	O
;	O
{	O
FILE	struct
*	O
pfp	pointer
=	O
popen	function
(	O
command	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
pfp	pointer
==	O
NULL	O
)	O
die	function
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Could not popen command"	pointer
)	O
,	O
command	pointer
)	O
;	O
read_byte_size	function
(	O
wc	pointer
,	O
sizeof	O
(	O
wc	pointer
)	O
,	O
pfp	pointer
)	O
;	O
pclose	function
(	O
pfp	pointer
)	O
;	O
}	O
if	O
(	O
did_md5	int
)	O
fputs	function
(	O
otherwise_z	array
,	O
output	pointer
)	O
;	O
{	O
size_t	long
sz	long
=	O
strlen	function
(	O
SM_bad_size	O
)	O
+	O
strlen	function
(	O
restore_name	pointer
)	O
+	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
sz	long
,	O
SM_bad_size	O
,	O
restore_name	pointer
,	O
wc	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
ck_chct_z	array
,	O
restore_name	pointer
,	O
wc	pointer
,	O
bf	pointer
)	O
;	O
}	O
}	O
static	O
do_uue_t	enum
file_needs_encoding	function
(	O
char	O
const	O
*	O
fname	pointer
)	O
{	O
FILE	struct
*	O
infp	pointer
;	O
int	O
line_length	int
;	O
if	O
(	O
cmpr_state	pointer
!=	O
NULL	O
)	O
return	O
true	int
;	O
switch	O
(	O
WHICH_OPT_MIXED_UUENCODE	O
)	O
{	O
case	O
VALUE_OPT_TEXT_FILES	char
:	O
return	O
false	int
;	O
case	O
VALUE_OPT_UUENCODE	char
:	O
return	O
true	int
;	O
default	O
:	O
break	O
;	O
}	O
infp	pointer
=	O
fopen	function
(	O
fname	pointer
,	O
freadonly_mode	array
)	O
;	O
if	O
(	O
infp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open file %s"	pointer
)	O
,	O
fname	pointer
)	O
;	O
return	O
fail	int
;	O
}	O
line_length	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
ch	char
=	O
getc	function
(	O
infp	pointer
)	O
;	O
retest_char	O
:	O
switch	O
(	O
ch	char
)	O
{	O
case	O
EOF	O
:	O
goto	O
loop_done	O
;	O
case	O
'\n'	O
:	O
line_length	int
=	O
0	int
;	O
break	O
;	O
case	O
'F'	O
:	O
case	O
'f'	O
:	O
if	O
(	O
line_length	int
>	O
0	int
)	O
{	O
line_length	int
++	O
;	O
break	O
;	O
}	O
{	O
static	O
char	O
const	O
from	array
[	O
]	O
=	O
"rom "	pointer
;	O
char	O
const	O
*	O
p	pointer
=	O
from	array
;	O
for	O
(	O
;	O
;	O
)	O
{	O
line_length	int
++	O
;	O
ch	char
=	O
getc	function
(	O
infp	pointer
)	O
;	O
if	O
(	O
ch	char
!=	O
*	O
p	pointer
)	O
goto	O
retest_char	O
;	O
if	O
(	O
*	O
++	O
p	pointer
==	O
NUL	char
)	O
{	O
line_length	int
=	O
MAXIMUM_NON_BINARY_LINE	int
;	O
goto	O
loop_done	O
;	O
}	O
}	O
}	O
default	O
:	O
if	O
(	O
BYTE_IS_BINARY	O
(	O
ch	char
)	O
)	O
{	O
line_length	int
=	O
MAXIMUM_NON_BINARY_LINE	int
;	O
goto	O
loop_done	O
;	O
}	O
line_length	int
++	O
;	O
}	O
if	O
(	O
line_length	int
>=	O
MAXIMUM_NON_BINARY_LINE	int
)	O
break	O
;	O
}	O
loop_done	O
:	O
;	O
fclose	function
(	O
infp	pointer
)	O
;	O
return	O
(	O
line_length	int
!=	O
0	int
)	O
?	O
true	int
:	O
false	int
;	O
}	O
static	O
void	O
encode_file_to_pipe	function
(	O
int	O
out_fd	int
,	O
const	O
char	O
*	O
local_name	pointer
,	O
const	O
char	O
*	O
q_local_name	pointer
,	O
const	O
char	O
*	O
restore_name	pointer
)	O
{	O
FILE	struct
*	O
in_fp	pointer
;	O
FILE	struct
*	O
out_fp	pointer
;	O
char	O
*	O
cmdline	pointer
=	O
alloca	O
(	O
strlen	function
(	O
q_local_name	pointer
)	O
+	O
64	int
)	O
;	O
char	O
const	O
*	O
open_txt	pointer
=	O
cmdline	pointer
;	O
char	O
const	O
*	O
open_fmt	pointer
=	O
"popen"	pointer
;	O
if	O
(	O
cmpr_state	pointer
!=	O
NULL	O
)	O
{	O
sprintf	function
(	O
cmdline	pointer
,	O
cmpr_state	pointer
->	O
cmpr_cmd_fmt	pointer
,	O
cmpr_state	pointer
->	O
cmpr_level	long
,	O
q_local_name	pointer
)	O
;	O
in_fp	pointer
=	O
popen	function
(	O
cmdline	pointer
,	O
freadonly_mode	array
)	O
;	O
}	O
else	O
{	O
in_fp	pointer
=	O
fopen	function
(	O
local_name	pointer
,	O
freadonly_mode	array
)	O
;	O
open_fmt	pointer
=	O
"fopen"	pointer
;	O
open_txt	pointer
=	O
local_name	pointer
;	O
}	O
if	O
(	O
in_fp	pointer
==	O
NULL	O
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
open_fmt	pointer
,	O
open_txt	pointer
)	O
;	O
out_fp	pointer
=	O
fdopen	function
(	O
out_fd	int
,	O
fwriteonly_mode	array
)	O
;	O
fprintf	function
(	O
out_fp	pointer
,	O
mode_fmt_z	array
,	O
restore_name	pointer
)	O
;	O
copy_file_encoded	function
(	O
in_fp	pointer
,	O
out_fp	pointer
)	O
;	O
fprintf	function
(	O
out_fp	pointer
,	O
"end\n"	pointer
)	O
;	O
if	O
(	O
cmpr_state	pointer
!=	O
NULL	O
)	O
pclose	function
(	O
in_fp	pointer
)	O
;	O
else	O
fclose	function
(	O
in_fp	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
FILE	struct
*	O
open_encoded_file	function
(	O
char	O
const	O
*	O
local_name	pointer
,	O
char	O
const	O
*	O
q_local_name	pointer
,	O
const	O
char	O
*	O
restore_name	pointer
)	O
{	O
int	O
pipex	array
[	O
2	int
]	O
;	O
if	O
(	O
pipe	function
(	O
pipex	array
)	O
<	O
0	int
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"call"	pointer
)	O
,	O
"pipe(2)"	pointer
)	O
;	O
fflush	function
(	O
output	pointer
)	O
;	O
switch	O
(	O
fork	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
close	pointer
(	O
pipex	array
[	O
0	int
]	O
)	O
;	O
encode_file_to_pipe	function
(	O
pipex	array
[	O
1	int
]	O
,	O
local_name	pointer
,	O
q_local_name	pointer
,	O
restore_name	pointer
)	O
;	O
case	O
-	O
1	int
:	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"call"	pointer
)	O
,	O
"fork"	pointer
)	O
;	O
return	O
NULL	O
;	O
default	O
:	O
break	O
;	O
}	O
close	pointer
(	O
pipex	array
[	O
1	int
]	O
)	O
;	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fdopen	function
(	O
pipex	array
[	O
0	int
]	O
,	O
freadonly_mode	array
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
"fdopen"	pointer
,	O
_	O
(	O
"pipe fd"	pointer
)	O
)	O
;	O
return	O
fp	pointer
;	O
}	O
}	O
static	O
FILE	struct
*	O
open_shar_input	function
(	O
const	O
char	O
*	O
local_name	pointer
,	O
const	O
char	O
*	O
q_local_name	pointer
,	O
const	O
char	O
*	O
restore_name	pointer
,	O
const	O
char	O
*	O
q_restore_name	pointer
,	O
const	O
char	O
*	O
*	O
file_type_p	pointer
,	O
const	O
char	O
*	O
*	O
file_type_remote_p	pointer
,	O
int	O
*	O
pipe_p	pointer
)	O
{	O
FILE	struct
*	O
infp	pointer
;	O
uuencode_file	enum
=	O
file_needs_encoding	function
(	O
local_name	pointer
)	O
;	O
if	O
(	O
uuencode_file	enum
==	O
fail	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
uuencode_file	enum
)	O
{	O
*	O
file_type_p	pointer
=	O
_	O
(	O
"text"	pointer
)	O
;	O
*	O
file_type_remote_p	pointer
=	O
SM_type_text	O
;	O
infp	pointer
=	O
fopen	function
(	O
local_name	pointer
,	O
freadonly_mode	array
)	O
;	O
if	O
(	O
infp	pointer
==	O
NULL	O
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
"fopen"	pointer
,	O
local_name	pointer
)	O
;	O
*	O
pipe_p	pointer
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
cmpr_state	pointer
!=	O
NULL	O
)	O
*	O
file_type_p	pointer
=	O
*	O
file_type_remote_p	pointer
=	O
cmpr_state	pointer
->	O
cmpr_title	pointer
;	O
else	O
{	O
*	O
file_type_p	pointer
=	O
_	O
(	O
"text"	pointer
)	O
;	O
*	O
file_type_remote_p	pointer
=	O
_	O
(	O
"(text)"	pointer
)	O
;	O
}	O
infp	pointer
=	O
open_encoded_file	function
(	O
local_name	pointer
,	O
q_local_name	pointer
,	O
restore_name	pointer
)	O
;	O
*	O
pipe_p	pointer
=	O
1	int
;	O
}	O
return	O
infp	pointer
;	O
}	O
static	O
void	O
split_shar_ed_file	function
(	O
char	O
const	O
*	O
restore	pointer
,	O
off_t	long
*	O
size_left	pointer
,	O
int	O
*	O
split_flag	pointer
)	O
{	O
DEBUG_PRINT	O
(	O
"New file, remaining %s, "	pointer
,	O
(	O
*	O
size_left	pointer
)	O
)	O
;	O
DEBUG_PRINT	O
(	O
"Limit still %s\n"	pointer
,	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
"%s\n"	pointer
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
fputs	function
(	O
" :\n"	pointer
,	O
output	pointer
)	O
;	O
echo_status	function
(	O
"test $? -ne 0"	pointer
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
restore	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
fputs	function
(	O
"fi\n"	pointer
,	O
output	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
size_t	long
sz	long
=	O
strlen	function
(	O
SM_end_of_part	O
)	O
+	O
2	int
*	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
sz	long
,	O
SM_end_of_part	O
,	O
part_number	int
,	O
part_number	int
+	O
1	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
bf	pointer
)	O
;	O
}	O
else	O
{	O
char	O
const	O
*	O
nm	pointer
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
SM_word_archive	O
;	O
size_t	long
sz1	long
=	O
strlen	function
(	O
SM_s_end_of_part	O
)	O
+	O
strlen	function
(	O
nm	pointer
)	O
+	O
LOG10_MAX_INT	int
;	O
size_t	long
sz2	long
=	O
strlen	function
(	O
SM_contin_in_part	O
)	O
+	O
strlen	function
(	O
restore	pointer
)	O
+	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	pointer
;	O
if	O
(	O
sz1	long
<	O
sz2	long
)	O
sz1	long
=	O
sz2	long
;	O
bf	pointer
=	O
scribble_get	function
(	O
sz1	long
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
sz1	long
,	O
SM_s_end_of_part	O
,	O
nm	pointer
,	O
part_number	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
bf	pointer
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
sz1	long
,	O
SM_contin_in_part	O
,	O
restore	pointer
,	O
(	O
long	O
)	O
part_number	int
+	O
1	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
bf	pointer
)	O
;	O
}	O
fwrite	function
(	O
split_file_z	array
,	O
sizeof	O
(	O
split_file_z	array
)	O
-	O
1	int
,	O
1	int
,	O
output	pointer
)	O
;	O
if	O
(	O
part_number	int
==	O
1	int
)	O
{	O
fseeko	function
(	O
output	pointer
,	O
archive_type_position	long
,	O
SEEK_SET	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
explain_text_fmt	array
,	O
explain_1_z	array
,	O
explain_2_z	array
)	O
;	O
fseeko	function
(	O
output	pointer
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
}	O
close_output	function
(	O
part_number	int
+	O
1	int
)	O
;	O
open_output	function
(	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
"Submitted-by: %s\n"	pointer
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
"Archive-name: %s%s%02d\n\n"	pointer
,	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
strchr	function
(	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
'/'	O
)	O
?	O
""	pointer
:	O
"/part"	pointer
,	O
part_number	int
?	O
part_number	int
:	O
1	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CUT_MARK	O
)	O
)	O
fputs	function
(	O
cut_mark_line_z	array
,	O
output	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
continue_archive_z	array
,	O
base_name	function
(	O
output_filename	pointer
)	O
,	O
part_number	int
,	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
"a multipart archive"	pointer
,	O
restore	pointer
,	O
sharpid	int
)	O
;	O
generate_configure	function
(	O
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
fputs	function
(	O
split_continue_quietly_z	array
,	O
output	pointer
)	O
;	O
else	O
{	O
fputs	function
(	O
split_continue_z	array
,	O
output	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
SM_still_skipping	O
,	O
restore	pointer
)	O
;	O
fputs	function
(	O
otherwise_z	array
,	O
output	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Continuing file %s\n"	pointer
)	O
,	O
output_filename	pointer
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	function
(	O
SM_continuing	O
,	O
restore	pointer
,	O
false	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
split_resume_z	array
,	O
line_prefix	int
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
,	O
uuencode_file	enum
?	O
"${lock_dir}/uue"	pointer
:	O
restore	pointer
)	O
;	O
(	O
*	O
size_left	pointer
)	O
=	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
-	O
ftello	function
(	O
output	pointer
)	O
;	O
*	O
split_flag	pointer
=	O
1	int
;	O
}	O
static	O
void	O
process_shar_input	function
(	O
FILE	struct
*	O
input	pointer
,	O
off_t	long
*	O
size_left	pointer
,	O
int	O
*	O
split_flag	pointer
,	O
char	O
const	O
*	O
restore	pointer
,	O
char	O
const	O
*	O
q_restore	pointer
)	O
{	O
char	O
*	O
inbf	pointer
=	O
scribble_get	function
(	O
BUFSIZ	int
)	O
;	O
if	O
(	O
uuencode_file	enum
&&	O
(	O
cmpr_state	pointer
!=	O
NULL	O
)	O
)	O
{	O
char	O
*	O
p	pointer
=	O
fgets	function
(	O
inbf	pointer
,	O
BUFSIZ	int
,	O
input	pointer
)	O
;	O
char	O
*	O
e	pointer
;	O
if	O
(	O
(	O
p	pointer
==	O
NULL	O
)	O
||	O
(	O
strncmp	function
(	O
p	pointer
,	O
mode_fmt_z	array
,	O
6	int
)	O
!=	O
0	int
)	O
)	O
return	O
;	O
e	pointer
=	O
p	pointer
+	O
strlen	function
(	O
p	pointer
)	O
;	O
while	O
(	O
isspace	function
(	O
to_uchar	function
(	O
e	pointer
[	O
-	O
1	int
]	O
)	O
)	O
&&	O
(	O
e	pointer
>	O
p	pointer
)	O
)	O
e	pointer
--	O
;	O
while	O
(	O
!	O
isspace	function
(	O
to_uchar	function
(	O
e	pointer
[	O
-	O
1	int
]	O
)	O
)	O
&&	O
(	O
e	pointer
>	O
p	pointer
)	O
)	O
e	pointer
--	O
;	O
fwrite	function
(	O
p	pointer
,	O
e	pointer
-	O
p	pointer
,	O
1	int
,	O
output	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
"_sh%05d/%s\n"	pointer
,	O
(	O
int	O
)	O
sharpid	int
,	O
cmpr_state	pointer
->	O
cmpr_mode	pointer
)	O
;	O
}	O
while	O
(	O
fgets	function
(	O
inbf	pointer
,	O
BUFSIZ	int
,	O
input	pointer
)	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
FORCE_PREFIX	O
)	O
&&	O
ISASCII	int
(	O
inbf	pointer
[	O
0	int
]	O
)	O
&&	O
IS_GRAPH	O
(	O
inbf	pointer
[	O
0	int
]	O
)	O
&&	O
inbf	pointer
[	O
0	int
]	O
!=	O
line_prefix	int
&&	O
inbf	pointer
[	O
0	int
]	O
!=	O
'~'	O
&&	O
inbf	pointer
[	O
0	int
]	O
!=	O
'.'	O
&&	O
(	O
inbf	pointer
[	O
0	int
]	O
!=	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
[	O
0	int
]	O
||	O
strncmp	function
(	O
inbf	pointer
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
,	O
here_delimiter_length	long
)	O
)	O
&&	O
(	O
inbf	pointer
[	O
0	int
]	O
!=	O
'e'	O
||	O
strncmp	function
(	O
inbf	pointer
,	O
"exit 0"	pointer
,	O
6	int
)	O
)	O
&&	O
(	O
inbf	pointer
[	O
0	int
]	O
!=	O
'F'	O
||	O
strncmp	function
(	O
inbf	pointer
,	O
"From"	pointer
,	O
4	int
)	O
)	O
)	O
fputs	function
(	O
inbf	pointer
,	O
output	pointer
)	O
;	O
else	O
{	O
fprintf	function
(	O
output	pointer
,	O
"%c%s"	pointer
,	O
line_prefix	int
,	O
inbf	pointer
)	O
;	O
(	O
*	O
size_left	pointer
)	O
--	O
;	O
}	O
if	O
(	O
*	O
inbf	pointer
&&	O
inbf	pointer
[	O
strlen	function
(	O
inbf	pointer
)	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
putc	function
(	O
'\n'	O
,	O
output	pointer
)	O
;	O
(	O
*	O
size_left	pointer
)	O
--	O
;	O
}	O
(	O
*	O
size_left	pointer
)	O
-=	O
CRLF_STRLEN	O
(	O
inbf	pointer
)	O
;	O
if	O
(	O
WHICH_OPT_WHOLE_SIZE_LIMIT	O
!=	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
)	O
continue	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
size_left	pointer
)	O
>=	O
0	int
)	O
continue	O
;	O
split_shar_ed_file	function
(	O
restore	pointer
,	O
size_left	pointer
,	O
split_flag	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_query_user	function
(	O
char	O
const	O
*	O
rname	pointer
)	O
{	O
size_t	long
rname_len	long
=	O
strlen	function
(	O
rname	pointer
)	O
;	O
size_t	long
sz	long
=	O
strlen	function
(	O
SM_overwriting	O
)	O
+	O
rname_len	long
;	O
char	O
*	O
str_a	pointer
,	O
*	O
str_b	pointer
;	O
str_a	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
str_a	pointer
,	O
sz	long
,	O
SM_overwriting	O
,	O
rname	pointer
)	O
;	O
sz	long
=	O
strlen	function
(	O
SM_overwrite	O
)	O
+	O
rname_len	long
;	O
str_b	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
str_b	pointer
,	O
sz	long
,	O
SM_overwrite	O
,	O
rname	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
query_user_z	array
,	O
str_a	pointer
,	O
str_b	pointer
)	O
;	O
sz	long
=	O
strlen	function
(	O
SM_skipping	O
)	O
+	O
rname_len	long
;	O
str_b	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
str_b	pointer
,	O
sz	long
,	O
SM_skipping	O
,	O
rname	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
query_check_z	array
,	O
SM_extract_aborted	O
,	O
str_b	pointer
,	O
str_b	pointer
)	O
;	O
}	O
static	O
int	O
start_sharing_file	function
(	O
char	O
const	O
*	O
*	O
lnameq_p	pointer
,	O
char	O
const	O
*	O
*	O
rnameq_p	pointer
,	O
FILE	struct
*	O
*	O
fpp	pointer
,	O
off_t	long
*	O
size_left_p	pointer
,	O
int	O
*	O
pipe_p	pointer
)	O
{	O
char	O
const	O
*	O
lname	pointer
=	O
*	O
lnameq_p	pointer
;	O
char	O
const	O
*	O
rname	pointer
=	O
*	O
rnameq_p	pointer
;	O
char	O
const	O
*	O
file_type	pointer
;	O
char	O
const	O
*	O
file_type_remote	pointer
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
struct_stat	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: Not a regular file"	pointer
)	O
,	O
lname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
access	function
(	O
lname	pointer
,	O
R_OK	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Cannot access %s"	pointer
)	O
,	O
lname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
*	O
lnameq_p	pointer
=	O
quotearg_n_style	function
(	O
QUOT_ID_LNAME	int
,	O
shell_always_quoting_style	int
,	O
lname	pointer
)	O
;	O
*	O
rnameq_p	pointer
=	O
quotearg_n_style	function
(	O
QUOT_ID_RNAME	int
,	O
shell_always_quoting_style	int
,	O
rname	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
{	O
off_t	long
current_size	long
=	O
ftello	function
(	O
output	pointer
)	O
;	O
off_t	long
encoded_size	long
=	O
1024	int
+	O
(	O
uuencode_file	enum
?	O
(	O
struct_stat	struct
.	O
st_size	long
+	O
struct_stat	struct
.	O
st_size	long
/	O
3	int
)	O
:	O
struct_stat	struct
.	O
st_size	long
)	O
;	O
*	O
size_left_p	pointer
=	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
-	O
current_size	long
;	O
DEBUG_PRINT	O
(	O
"In shar: remaining size %s\n"	pointer
,	O
*	O
size_left_p	pointer
)	O
;	O
if	O
(	O
(	O
WHICH_OPT_WHOLE_SIZE_LIMIT	O
!=	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
)	O
&&	O
(	O
current_size	long
>	O
first_file_position	long
)	O
&&	O
(	O
encoded_size	long
>	O
*	O
size_left_p	pointer
)	O
)	O
{	O
change_files	function
(	O
*	O
rnameq_p	pointer
,	O
size_left_p	pointer
)	O
;	O
current_size	long
=	O
ftello	function
(	O
output	pointer
)	O
;	O
*	O
size_left_p	pointer
=	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
-	O
current_size	long
;	O
}	O
}	O
else	O
*	O
size_left_p	pointer
=	O
~	O
0	int
;	O
fprintf	function
(	O
output	pointer
,	O
break_line_z	array
,	O
rname	pointer
)	O
;	O
generate_mkdir_script	function
(	O
rname	pointer
)	O
;	O
if	O
(	O
struct_stat	struct
.	O
st_size	long
==	O
0	int
)	O
{	O
file_type	pointer
=	O
_	O
(	O
"empty"	pointer
)	O
;	O
file_type_remote	pointer
=	O
SM_is_empty	O
;	O
*	O
fpp	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
*	O
fpp	pointer
=	O
open_shar_input	function
(	O
lname	pointer
,	O
*	O
lnameq_p	pointer
,	O
rname	pointer
,	O
*	O
rnameq_p	pointer
,	O
&	O
file_type	pointer
,	O
&	O
file_type_remote	pointer
,	O
pipe_p	pointer
)	O
;	O
if	O
(	O
*	O
fpp	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
pre_exist_z	array
,	O
*	O
rnameq_p	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
print_query_user	function
(	O
rname	pointer
)	O
;	O
else	O
echo_text	function
(	O
SM_skip_exist	O
,	O
rname	pointer
,	O
false	int
)	O
;	O
fputs	function
(	O
otherwise_z	array
,	O
output	pointer
)	O
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Saving %s (%s)"	pointer
)	O
,	O
lname	pointer
,	O
file_type	pointer
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
size_t	long
sz	long
=	O
strlen	function
(	O
SM_x_extracting	O
)	O
+	O
strlen	function
(	O
rname	pointer
)	O
+	O
strlen	function
(	O
file_type_remote	pointer
)	O
;	O
char	O
*	O
bf	pointer
=	O
scribble_get	function
(	O
sz	long
)	O
;	O
snprintf	function
(	O
bf	pointer
,	O
sz	long
,	O
SM_x_extracting	O
,	O
rname	pointer
,	O
file_type_remote	pointer
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
bf	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
finish_sharing_file	function
(	O
const	O
char	O
*	O
lname	pointer
,	O
const	O
char	O
*	O
lname_q	pointer
,	O
const	O
char	O
*	O
rname	pointer
,	O
const	O
char	O
*	O
rname_q	pointer
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_TIMESTAMP	O
)	O
)	O
{	O
struct	O
tm	struct
*	O
restore_time	pointer
;	O
restore_time	pointer
=	O
localtime	function
(	O
&	O
struct_stat	struct
.	O
st_mtime	O
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
shar_touch_z	array
,	O
(	O
restore_time	pointer
->	O
tm_year	int
+	O
1900	int
)	O
/	O
100	int
,	O
(	O
restore_time	pointer
->	O
tm_year	int
+	O
1900	int
)	O
%	O
100	int
,	O
restore_time	pointer
->	O
tm_mon	int
+	O
1	int
,	O
restore_time	pointer
->	O
tm_mday	int
,	O
restore_time	pointer
->	O
tm_hour	int
,	O
restore_time	pointer
->	O
tm_min	int
,	O
restore_time	pointer
->	O
tm_sec	int
,	O
rname_q	pointer
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
VANILLA_OPERATION	O
)	O
)	O
{	O
fputs	function
(	O
":\n"	pointer
,	O
output	pointer
)	O
;	O
echo_status	function
(	O
"test $? -ne 0"	pointer
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
rname	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
md5buffer	array
[	O
16	int
]	O
;	O
FILE	struct
*	O
fp	pointer
=	O
NULL	O
;	O
int	O
did_md5	int
=	O
0	int
;	O
fprintf	function
(	O
output	pointer
,	O
SM_restore_mode	O
,	O
(	O
unsigned	O
)	O
(	O
struct_stat	struct
.	O
st_mode	int
&	O
0777	int
)	O
,	O
rname_q	pointer
)	O
;	O
echo_status	function
(	O
"test $? -ne 0"	pointer
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
rname	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_MD5_DIGEST	O
)	O
&&	O
(	O
fp	pointer
=	O
fopen	function
(	O
lname	pointer
,	O
freadonly_mode	array
)	O
)	O
!=	O
NULL	O
&&	O
md5_stream	function
(	O
fp	pointer
,	O
md5buffer	array
)	O
==	O
0	int
)	O
{	O
size_t	long
cnt	long
;	O
did_md5	int
=	O
1	int
;	O
fprintf	function
(	O
output	pointer
,	O
md5test_z	array
,	O
rname_q	pointer
,	O
SM_md5_check_failed	O
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
for	O
(	O
cnt	long
=	O
0	int
;	O
cnt	long
<	O
16	int
;	O
++	O
cnt	long
)	O
fprintf	function
(	O
output	pointer
,	O
"%02x"	pointer
,	O
md5buffer	array
[	O
cnt	long
]	O
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
" %c%s\n%s\n"	pointer
,	O
' '	O
,	O
rname	pointer
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
}	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHARACTER_COUNT	O
)	O
)	O
emit_char_ct_validation	function
(	O
lname	pointer
,	O
lname_q	pointer
,	O
rname_q	pointer
,	O
did_md5	int
)	O
;	O
if	O
(	O
did_md5	int
)	O
fputs	function
(	O
"  fi\n"	pointer
,	O
output	pointer
)	O
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
fputs	function
(	O
"fi\n"	pointer
,	O
output	pointer
)	O
;	O
}	O
static	O
int	O
shar	function
(	O
const	O
char	O
*	O
lname	pointer
,	O
const	O
char	O
*	O
rname	pointer
)	O
{	O
FILE	struct
*	O
input	pointer
;	O
off_t	long
size_left	pointer
;	O
int	O
split_flag	pointer
=	O
0	int
;	O
char	O
const	O
*	O
lname_q	pointer
=	O
lname	pointer
;	O
char	O
const	O
*	O
rname_q	pointer
=	O
rname	pointer
;	O
int	O
pipe_p	pointer
;	O
scribble_free	function
(	O
)	O
;	O
if	O
(	O
!	O
start_sharing_file	function
(	O
&	O
lname_q	pointer
,	O
&	O
rname_q	pointer
,	O
&	O
input	pointer
,	O
&	O
size_left	pointer
,	O
&	O
pipe_p	pointer
)	O
)	O
return	O
SHAR_EXIT_FAILED	int
;	O
if	O
(	O
struct_stat	struct
.	O
st_size	long
==	O
0	int
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
" > %s &&\n"	pointer
,	O
rname_q	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
uuencode_file	enum
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
"  sed 's/^%c//' << '%s' "	pointer
,	O
line_prefix	int
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
NO_PIPING	O
)	O
)	O
fprintf	function
(	O
output	pointer
,	O
"> ${lock_dir}/uue &&\n"	pointer
)	O
;	O
else	O
fputs	function
(	O
"| uudecode &&\n"	pointer
,	O
output	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
output	pointer
,	O
"  sed 's/^%c//' << '%s' > %s &&\n"	pointer
,	O
line_prefix	int
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
,	O
rname_q	pointer
)	O
;	O
}	O
process_shar_input	function
(	O
input	pointer
,	O
&	O
size_left	pointer
,	O
&	O
split_flag	pointer
,	O
rname	pointer
,	O
rname_q	pointer
)	O
;	O
if	O
(	O
!	O
pipe_p	pointer
)	O
fclose	function
(	O
input	pointer
)	O
;	O
else	O
{	O
fclose	function
(	O
input	pointer
)	O
;	O
while	O
(	O
wait	function
(	O
NULL	O
)	O
>=	O
0	int
)	O
;	O
}	O
fprintf	function
(	O
output	pointer
,	O
"%s\n"	pointer
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
if	O
(	O
split_flag	pointer
&&	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	function
(	O
SM_file_complete	O
,	O
rname	pointer
,	O
true	int
)	O
;	O
if	O
(	O
uuencode_file	enum
&&	O
HAVE_OPT	O
(	O
NO_PIPING	O
)	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	function
(	O
SM_uudec_file	O
,	O
rname	pointer
,	O
true	int
)	O
;	O
fwrite	function
(	O
shar_decode_z	array
,	O
sizeof	O
(	O
shar_decode_z	array
)	O
-	O
1	int
,	O
1	int
,	O
output	pointer
)	O
;	O
}	O
if	O
(	O
cmpr_state	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	function
(	O
cmpr_state	pointer
->	O
cmpr_unnote	pointer
,	O
rname	pointer
,	O
true	int
)	O
;	O
fprintf	function
(	O
output	pointer
,	O
cmpr_state	pointer
->	O
cmpr_unpack	pointer
,	O
rname_q	pointer
)	O
;	O
}	O
}	O
finish_sharing_file	function
(	O
lname	pointer
,	O
lname_q	pointer
,	O
rname	pointer
,	O
rname_q	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
void	O
parse_output_base_name	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
bad_fmt	pointer
=	O
_	O
(	O
"Invalid format for output file names (%s): %s"	pointer
)	O
;	O
int	O
c	char
;	O
int	O
hadarg	int
=	O
0	int
;	O
char	O
const	O
*	O
p	pointer
;	O
int	O
base_name_len	int
=	O
128	int
;	O
for	O
(	O
p	pointer
=	O
arg	pointer
;	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
!=	O
0	int
;	O
)	O
{	O
base_name_len	int
++	O
;	O
if	O
(	O
c	char
!=	O
'%'	O
)	O
continue	O
;	O
c	char
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
c	char
==	O
'%'	O
)	O
continue	O
;	O
if	O
(	O
hadarg	int
)	O
usage_message	function
(	O
bad_fmt	pointer
,	O
_	O
(	O
"more than one format element"	pointer
)	O
,	O
arg	pointer
)	O
;	O
while	O
(	O
c	char
!=	O
0	int
&&	O
strchr	function
(	O
"#0+- 'I"	pointer
,	O
c	char
)	O
!=	O
0	int
)	O
c	char
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
c	char
==	O
0	int
)	O
usage_message	function
(	O
bad_fmt	pointer
,	O
_	O
(	O
"no conversion character"	pointer
)	O
,	O
arg	pointer
)	O
;	O
if	O
(	O
c	char
>=	O
'0'	O
&&	O
c	char
<=	O
'9'	O
)	O
{	O
long	O
v	union
;	O
char	O
const	O
*	O
skp	pointer
;	O
errno	O
=	O
0	int
;	O
v	union
=	O
strtol	function
(	O
(	O
void	O
*	O
)	O
(	O
p	pointer
-	O
1	int
)	O
,	O
(	O
void	O
*	O
)	O
&	O
skp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
v	union
==	O
0	int
)	O
||	O
(	O
v	union
>	O
16	int
)	O
||	O
(	O
errno	O
!=	O
0	int
)	O
)	O
usage_message	function
(	O
bad_fmt	pointer
,	O
_	O
(	O
"format is too wide"	pointer
)	O
,	O
arg	pointer
)	O
;	O
p	pointer
=	O
skp	pointer
;	O
c	char
=	O
*	O
p	pointer
++	O
;	O
base_name_len	int
+=	O
v	union
;	O
}	O
if	O
(	O
c	char
==	O
'.'	O
)	O
{	O
c	char
=	O
*	O
p	pointer
++	O
;	O
while	O
(	O
c	char
!=	O
0	int
&&	O
c	char
>=	O
'0'	O
&&	O
c	char
<=	O
'9'	O
)	O
c	char
=	O
*	O
p	pointer
++	O
;	O
}	O
if	O
(	O
c	char
==	O
0	int
||	O
strchr	function
(	O
"diouxX"	pointer
,	O
c	char
)	O
==	O
0	int
)	O
usage_message	function
(	O
bad_fmt	pointer
,	O
_	O
(	O
"invalid conversion character"	pointer
)	O
,	O
arg	pointer
)	O
;	O
hadarg	int
=	O
1	int
;	O
}	O
output_filename	pointer
=	O
xmalloc	function
(	O
base_name_len	int
)	O
;	O
if	O
(	O
!	O
hadarg	int
)	O
{	O
static	O
char	O
const	O
sfx	array
[	O
]	O
=	O
".%02d"	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
char	O
*	O
fmt	pointer
=	O
xmalloc	function
(	O
len	long
+	O
sizeof	O
(	O
sfx	array
)	O
)	O
;	O
bool	bool
svd	bool
=	O
initialization_done	bool
;	O
memcpy	function
(	O
fmt	pointer
,	O
arg	pointer
,	O
len	long
)	O
;	O
memcpy	function
(	O
fmt	pointer
+	O
len	long
,	O
sfx	array
,	O
sizeof	O
(	O
sfx	array
)	O
)	O
;	O
initialization_done	bool
=	O
false	int
;	O
SET_OPT_OUTPUT_PREFIX	O
(	O
fmt	pointer
)	O
;	O
initialization_done	bool
=	O
svd	bool
;	O
}	O
}	O
static	O
void	O
open_output	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
OUTPUT_PREFIX	O
)	O
)	O
{	O
output	pointer
=	O
stdout	pointer
;	O
return	O
;	O
}	O
if	O
(	O
output_filename	pointer
==	O
NULL	O
)	O
parse_output_base_name	function
(	O
OPT_ARG	O
(	O
OUTPUT_PREFIX	O
)	O
)	O
;	O
sprintf	function
(	O
output_filename	pointer
,	O
OPT_ARG	O
(	O
OUTPUT_PREFIX	O
)	O
,	O
++	O
part_number	int
)	O
;	O
output	pointer
=	O
fopen	function
(	O
output_filename	pointer
,	O
fwriteonly_mode	array
)	O
;	O
if	O
(	O
output	pointer
==	O
NULL	O
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Opening"	pointer
)	O
,	O
output_filename	pointer
)	O
;	O
}	O
static	O
void	O
close_output	function
(	O
int	O
part	int
)	O
{	O
if	O
(	O
part	int
>	O
0	int
)	O
fprintf	function
(	O
output	pointer
,	O
"echo %d > ${lock_dir}/seq\n"	pointer
,	O
part	int
)	O
;	O
fputs	function
(	O
"exit 0\n"	pointer
,	O
output	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
output	pointer
)	O
!=	O
0	int
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Closing"	pointer
)	O
,	O
output_filename	pointer
)	O
;	O
}	O
static	O
char	O
*	O
trim	function
(	O
char	O
*	O
pz	pointer
)	O
{	O
char	O
*	O
res	pointer
;	O
while	O
(	O
isspace	function
(	O
to_uchar	function
(	O
*	O
pz	pointer
)	O
)	O
)	O
pz	pointer
++	O
;	O
switch	O
(	O
*	O
pz	pointer
)	O
{	O
case	O
NUL	char
:	O
case	O
'#'	O
:	O
return	O
NULL	O
;	O
}	O
res	pointer
=	O
pz	pointer
;	O
pz	pointer
+=	O
strlen	function
(	O
pz	pointer
)	O
;	O
while	O
(	O
isspace	function
(	O
to_uchar	function
(	O
pz	pointer
[	O
-	O
1	int
]	O
)	O
)	O
)	O
pz	pointer
--	O
;	O
*	O
pz	pointer
=	O
NUL	char
;	O
return	O
res	pointer
;	O
}	O
static	O
void	O
set_submitter	function
(	O
void	O
)	O
{	O
char	O
*	O
buffer	array
;	O
char	O
*	O
uname	function
=	O
getuser	function
(	O
getuid	function
(	O
)	O
)	O
;	O
size_t	long
len	long
=	O
strlen	function
(	O
uname	function
)	O
;	O
if	O
(	O
uname	function
==	O
NULL	O
)	O
fserr	function
(	O
SHAR_EXIT_FAILED	int
,	O
"getpwuid"	pointer
,	O
"getuid()"	pointer
)	O
;	O
buffer	array
=	O
xmalloc	function
(	O
len	long
+	O
2	int
+	O
HOST_NAME_MAX	int
)	O
;	O
memcpy	function
(	O
buffer	array
,	O
uname	function
,	O
len	long
)	O
;	O
buffer	array
[	O
len	long
++	O
]	O
=	O
'@'	O
;	O
gethostname	function
(	O
buffer	array
+	O
len	long
,	O
HOST_NAME_MAX	int
)	O
;	O
SET_OPT_SUBMITTER	O
(	O
buffer	array
)	O
;	O
}	O
static	O
void	O
configure_shar	function
(	O
int	O
*	O
argc_p	pointer
,	O
char	O
*	O
*	O
*	O
argv_p	pointer
)	O
{	O
line_prefix	int
=	O
(	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
[	O
0	int
]	O
==	O
DEFAULT_LINE_PREFIX_1	char
?	O
DEFAULT_LINE_PREFIX_2	char
:	O
DEFAULT_LINE_PREFIX_1	char
)	O
;	O
here_delimiter_length	long
=	O
strlen	function
(	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
gzip_compaction	struct
.	O
cmpr_level	long
=	O
xz_compaction	struct
.	O
cmpr_level	long
=	O
bzip2_compaction	struct
.	O
cmpr_level	long
=	O
DESC	O
(	O
LEVEL_OF_COMPRESSION	O
)	O
.	O
optArg	union
.	O
argInt	long
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
SUBMITTER	O
)	O
)	O
set_submitter	function
(	O
)	O
;	O
open_output	function
(	O
)	O
;	O
if	O
(	O
isatty	function
(	O
fileno	function
(	O
output	pointer
)	O
)	O
&&	O
isatty	function
(	O
STDERR_FILENO	int
)	O
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
freopen	function
(	O
"/dev/null"	pointer
,	O
fwriteonly_mode	array
,	O
stderr	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
stderr	pointer
)	O
error	function
(	O
SHAR_EXIT_FAILED	int
,	O
errno	O
,	O
_	O
(	O
"reopening stderr to /dev/null"	pointer
)	O
)	O
;	O
}	O
memset	function
(	O
(	O
char	O
*	O
)	O
byte_is_binary	array
,	O
1	int
,	O
sizeof	O
(	O
byte_is_binary	array
)	O
)	O
;	O
byte_is_binary	array
[	O
'\b'	O
]	O
=	O
0	int
;	O
byte_is_binary	array
[	O
'\t'	O
]	O
=	O
0	int
;	O
byte_is_binary	array
[	O
'\f'	O
]	O
=	O
0	int
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
byte_is_binary	array
+	O
0x20	int
,	O
0	int
,	O
0x7F	int
-	O
0x20	int
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
INPUT_FILE_LIST	O
)	O
)	O
{	O
char	O
*	O
*	O
list	pointer
;	O
int	O
max_argc	int
=	O
32	int
;	O
char	O
*	O
get_buf	pointer
=	O
scribble_get	function
(	O
BUFSIZ	int
)	O
;	O
*	O
argc_p	pointer
=	O
0	int
;	O
list	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
max_argc	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
pz	pointer
=	O
fgets	function
(	O
get_buf	pointer
,	O
BUFSIZ	int
,	O
stdin	pointer
)	O
;	O
if	O
(	O
pz	pointer
==	O
NULL	O
)	O
break	O
;	O
pz	pointer
=	O
trim	function
(	O
pz	pointer
)	O
;	O
if	O
(	O
pz	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
*	O
argc_p	pointer
==	O
max_argc	int
)	O
{	O
max_argc	int
+=	O
max_argc	int
/	O
2	int
;	O
list	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
list	pointer
,	O
max_argc	int
*	O
sizeof	O
(	O
*	O
list	pointer
)	O
)	O
;	O
}	O
list	pointer
[	O
(	O
*	O
argc_p	pointer
)	O
++	O
]	O
=	O
xstrdup	function
(	O
pz	pointer
)	O
;	O
}	O
*	O
argv_p	pointer
=	O
list	pointer
;	O
opt_idx	int
=	O
0	int
;	O
}	O
scribble_free	function
(	O
)	O
;	O
if	O
(	O
opt_idx	int
>=	O
*	O
argc_p	pointer
)	O
usage_message	function
(	O
_	O
(	O
"No input files"	pointer
)	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
{	O
if	O
(	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
<	O
4096	int
)	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
*=	O
1024	int
;	O
if	O
(	O
WHICH_OPT_WHOLE_SIZE_LIMIT	O
==	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
)	O
SET_OPT_NO_PIPING	O
;	O
}	O
generate_full_header	function
(	O
*	O
argc_p	pointer
-	O
opt_idx	int
,	O
&	O
(	O
*	O
argv_p	pointer
)	O
[	O
opt_idx	int
]	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"PLEASE avoid -X shars on Usenet or public networks"	pointer
)	O
)	O
;	O
fputs	function
(	O
"shar_wish=\n"	pointer
,	O
output	pointer
)	O
;	O
}	O
first_file_position	long
=	O
ftello	function
(	O
output	pointer
)	O
;	O
}	O
void	O
check_intermixing	function
(	O
tOptions	struct
*	O
opts	pointer
,	O
tOptDesc	struct
*	O
od	pointer
)	O
{	O
(	O
void	O
)	O
opts	pointer
;	O
(	O
void	O
)	O
od	pointer
;	O
if	O
(	O
initialization_done	bool
&&	O
!	O
HAVE_OPT	O
(	O
INTERMIX_TYPE	O
)	O
)	O
usage_message	function
(	O
_	O
(	O
"The '%s' option may not be intermixed with file names\nunless the --intermix-type option has been specified."	pointer
)	O
,	O
od	pointer
->	O
pz_Name	pointer
)	O
;	O
}	O
void	O
validate_opt_context	function
(	O
tOptions	struct
*	O
opts	pointer
,	O
tOptDesc	struct
*	O
od	pointer
)	O
{	O
(	O
void	O
)	O
opts	pointer
;	O
(	O
void	O
)	O
od	pointer
;	O
if	O
(	O
initialization_done	bool
)	O
usage_message	function
(	O
_	O
(	O
"The '%s' option must appear before any file names"	pointer
)	O
,	O
od	pointer
->	O
pz_Name	pointer
)	O
;	O
}	O
void	O
set_compaction	function
(	O
tOptions	struct
*	O
opts	pointer
,	O
tOptDesc	struct
*	O
od	pointer
)	O
{	O
char	O
const	O
*	O
c_type	pointer
=	O
od	pointer
->	O
optArg	union
.	O
argString	pointer
;	O
int	O
ix	int
=	O
0	int
;	O
(	O
void	O
)	O
opts	pointer
;	O
(	O
void	O
)	O
od	pointer
;	O
check_intermixing	function
(	O
opts	pointer
,	O
od	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
c_type	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
{	O
cmpr_state	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
c_type	pointer
,	O
compaction	array
[	O
ix	int
]	O
->	O
cmpr_name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
++	O
ix	int
>=	O
compact_ct	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid compaction type:  %s\nthe known types are:\n"	pointer
)	O
,	O
c_type	pointer
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
compact_ct	int
;	O
ix	int
++	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\t%s\n"	pointer
,	O
compaction	array
[	O
ix	int
]	O
->	O
cmpr_name	pointer
)	O
;	O
USAGE	O
(	O
SHAR_EXIT_OPTION_ERROR	int
)	O
;	O
}	O
}	O
cmpr_state	pointer
=	O
compaction	array
[	O
ix	int
]	O
;	O
}	O
static	O
void	O
initialize	function
(	O
int	O
*	O
argcp	pointer
,	O
char	O
*	O
*	O
*	O
argvp	pointer
)	O
{	O
sharpid	int
=	O
(	O
int	O
)	O
getpid	function
(	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
scribble_init	function
(	O
)	O
;	O
opt_idx	int
=	O
optionProcess	function
(	O
&	O
sharOptions	struct
,	O
*	O
argcp	pointer
,	O
*	O
argvp	pointer
)	O
;	O
if	O
(	O
opt_idx	int
==	O
*	O
argcp	pointer
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
INPUT_FILE_LIST	O
)	O
)	O
SET_OPT_INPUT_FILE_LIST	O
(	O
"-"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
INPUT_FILE_LIST	O
)	O
&&	O
(	O
opt_idx	int
!=	O
*	O
argcp	pointer
)	O
)	O
usage_message	function
(	O
_	O
(	O
"files on command line and --input-file-list specified"	pointer
)	O
)	O
;	O
}	O
init_shar_msg	function
(	O
)	O
;	O
configure_shar	function
(	O
argcp	pointer
,	O
argvp	pointer
)	O
;	O
initialization_done	bool
=	O
true	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
shar_exit_code_t	enum
status	int
=	O
SHAR_EXIT_SUCCESS	int
;	O
initialize	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
while	O
(	O
opt_idx	int
<	O
argc	int
)	O
{	O
char	O
*	O
arg	pointer
=	O
argv	pointer
[	O
opt_idx	int
++	O
]	O
;	O
struct	O
stat	struct
sb	struct
;	O
if	O
(	O
stat	struct
(	O
arg	pointer
,	O
&	O
sb	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
INTERMIX_TYPE	O
)	O
&&	O
(	O
*	O
arg	pointer
==	O
'-'	O
)	O
)	O
{	O
while	O
(	O
*	O
++	O
arg	pointer
==	O
'-'	O
)	O
;	O
optionLoadLine	function
(	O
&	O
sharOptions	struct
,	O
arg	pointer
)	O
;	O
}	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
arg	pointer
)	O
;	O
continue	O
;	O
}	O
{	O
shar_exit_code_t	enum
s	enum
=	O
walktree	function
(	O
shar	function
,	O
arg	pointer
)	O
;	O
if	O
(	O
status	int
==	O
SHAR_EXIT_SUCCESS	int
)	O
status	int
=	O
s	enum
;	O
}	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
&&	O
part_number	int
>	O
1	int
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
echo_string_z	array
,	O
SM_you_are_done	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Created %d files\n"	pointer
)	O
,	O
part_number	int
)	O
;	O
}	O
echo_status	function
(	O
"rm -fr ${lock_dir}"	pointer
,	O
SM_x_rem_lock_dir	O
,	O
SM_x_no_rem_lock_dir	O
,	O
"${lock_dir}"	pointer
,	O
1	int
)	O
;	O
close_output	function
(	O
0	int
)	O
;	O
scribble_deinit	function
(	O
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O