static	O
SCAR	struct
*	O
g_script_array	array
[	O
SCAR_ARRAY_LEN	int
+	O
1	int
]	O
;	O
static	O
void	O
select_error_codes	function
(	O
char	O
*	O
script_tag	pointer
,	O
int	O
*	O
event_error_value	pointer
,	O
int	O
*	O
event_warning_value	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_postinstall	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_postremove	pointer
)	O
==	O
0	int
||	O
0	int
)	O
{	O
*	O
event_error_value	pointer
=	O
SW_POST_SCRIPT_ERROR	int
;	O
*	O
event_warning_value	pointer
=	O
SW_POST_SCRIPT_WARNING	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_preinstall	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_preremove	pointer
)	O
==	O
0	int
||	O
0	int
)	O
{	O
*	O
event_error_value	pointer
=	O
SW_PRE_SCRIPT_ERROR	int
;	O
*	O
event_warning_value	pointer
=	O
SW_PRE_SCRIPT_WARNING	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_configure	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_unconfigure	pointer
)	O
==	O
0	int
||	O
0	int
)	O
{	O
*	O
event_error_value	pointer
=	O
SW_CONFIGURE_ERROR	int
;	O
*	O
event_warning_value	pointer
=	O
SW_CONFIGURE_WARNING	int
;	O
}	O
else	O
{	O
*	O
event_error_value	pointer
=	O
SW_CONFIGURE_ERROR	int
;	O
*	O
event_warning_value	pointer
=	O
SW_CONFIGURE_ERROR	int
;	O
SWLIB_INTERNAL	O
(	O
""	pointer
)	O
;	O
}	O
}	O
static	O
void	O
make_padding_for_login_shell	function
(	O
int	O
blocks	int
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
blocks	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
7	int
;	O
j	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
6	int
;	O
i	int
++	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"########"	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"#######\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
int	O
environ_exclude	function
(	O
char	O
*	O
varname	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
retval	int
;	O
int	O
ret	pointer
;	O
char	O
*	O
pat	pointer
;	O
char	O
*	O
exc	pointer
;	O
STROB	struct
*	O
patlist	pointer
;	O
const	O
char	O
exclude_list	array
[	O
]	O
=	O
":_:PATH:LD_LIBRARY_PATH:IFS:LD_PRELOAD:"	pointer
":SHELL:HOME:LANG:USER:TMPDIR:TERM:TERMCAP:TZ:MAIL:XAUTHORITY:"	pointer
":LOGNAME:HOME:BASH_ENV:CDPATH:DISPLAY:HOSTNAME:HISTSIZE:"	pointer
":SSH_ASKPASS:SSH_AUTH_SOCK:SSH_CONNECTION:SSH_ORIGINAL_COMMAND:SSH_TTY:"	pointer
":SSH_AGENT_PID:SSH_AGENT_PID:"	pointer
":GPG_AGENT_INFO:PWD:LS_COLORS:WINDOWID:"	pointer
":G_BROKEN_FILENAMES:LESSOPEN:SHLVL:ENV:OLDPWD:"	pointer
""	pointer
;	O
const	O
char	O
pattern_list	array
[	O
]	O
=	O
":CVS*:SSH*:JMM*:GPG*:JX_*"	pointer
;	O
retval	int
=	O
0	int
;	O
if	O
(	O
strchr	function
(	O
varname	pointer
,	O
':'	O
)	O
)	O
return	O
1	int
;	O
exc	pointer
=	O
(	O
char	O
*	O
)	O
exclude_list	array
;	O
while	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
exc	pointer
,	O
varname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
s	pointer
-	O
1	int
)	O
==	O
':'	O
&&	O
*	O
(	O
s	pointer
+	O
strlen	function
(	O
varname	pointer
)	O
)	O
==	O
':'	O
)	O
{	O
retval	int
=	O
1	int
;	O
break	O
;	O
}	O
exc	pointer
=	O
s	pointer
+	O
strlen	function
(	O
varname	pointer
)	O
;	O
}	O
if	O
(	O
retval	int
)	O
return	O
1	int
;	O
patlist	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
pat	pointer
=	O
strob_strtok	function
(	O
patlist	pointer
,	O
(	O
char	O
*	O
)	O
pattern_list	array
,	O
":\r\n"	pointer
)	O
;	O
while	O
(	O
pat	pointer
&&	O
strlen	function
(	O
pat	pointer
)	O
)	O
{	O
ret	pointer
=	O
fnmatch	function
(	O
pat	pointer
,	O
varname	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
retval	int
=	O
1	int
;	O
break	O
;	O
}	O
pat	pointer
=	O
strob_strtok	function
(	O
patlist	pointer
,	O
NULL	O
,	O
":\r\n"	pointer
)	O
;	O
}	O
strob_close	function
(	O
patlist	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
void	O
abort_script	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
GB	struct
*	O
G	pointer
,	O
int	O
fd	int
)	O
{	O
swicol_set_master_alarm	function
(	O
swicol	pointer
)	O
;	O
swpl_send_abort	function
(	O
swicol	pointer
,	O
fd	int
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
set_ls_list_flags	function
(	O
void	O
)	O
{	O
int	O
ls_verbose	int
;	O
ls_verbose	int
=	O
0	int
;	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_MD5	O
|	O
LS_LIST_VERBOSE_WITH_SHA1	O
|	O
LS_LIST_VERBOSE_WITH_SHA512	O
)	O
;	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_SIZE	O
|	O
LS_LIST_VERBOSE_WITH_ALL_DATES	O
)	O
;	O
return	O
ls_verbose	int
;	O
}	O
static	O
void	O
merge_name_id	function
(	O
int	O
*	O
ls_verbose	int
,	O
int	O
available_attributes	pointer
)	O
{	O
int	O
x	pointer
;	O
x	pointer
=	O
*	O
ls_verbose	int
;	O
if	O
(	O
available_attributes	pointer
&	O
LS_LIST_VERBOSE_WITH_SYSTEM_IDS	O
)	O
{	O
x	pointer
|=	O
LS_LIST_VERBOSE_WITH_SYSTEM_IDS	O
;	O
}	O
if	O
(	O
available_attributes	pointer
&	O
LS_LIST_VERBOSE_WITH_SYSTEM_NAMES	O
)	O
{	O
x	pointer
|=	O
LS_LIST_VERBOSE_WITH_SYSTEM_NAMES	O
;	O
}	O
*	O
ls_verbose	int
=	O
x	pointer
;	O
}	O
static	O
void	O
apply_location_to_path	function
(	O
STROB	struct
*	O
buf	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
char	O
*	O
location	pointer
)	O
{	O
strob_strcpy	function
(	O
buf	pointer
,	O
location	pointer
)	O
;	O
swlib_squash_leading_dot_slash	function
(	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
swlib_squash_all_leading_slash	function
(	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
swlib_unix_dircat	function
(	O
buf	pointer
,	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
static	O
int	O
determine_ls_list_flags	function
(	O
int	O
attr	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
check_contents	int
)	O
{	O
FILE_DIGS	struct
*	O
digs	pointer
;	O
int	O
ls_verbose	int
;	O
ls_verbose	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
attr	pointer
&	O
TARU_UM_UID	O
&&	O
attr	pointer
&	O
TARU_UM_OWNER	O
)	O
{	O
E_DEBUG	O
(	O
"Has owner and uid"	pointer
)	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SYSTEM_IDS	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SYSTEM_NAMES	O
;	O
}	O
else	O
if	O
(	O
attr	pointer
&	O
TARU_UM_UID	O
)	O
{	O
E_DEBUG	O
(	O
"Has uid only"	pointer
)	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SYSTEM_IDS	O
;	O
ls_verbose	int
&=	O
~	O
LS_LIST_VERBOSE_WITH_SYSTEM_NAMES	O
;	O
}	O
else	O
if	O
(	O
attr	pointer
&	O
TARU_UM_OWNER	O
)	O
{	O
E_DEBUG	O
(	O
"Has owner only"	pointer
)	O
;	O
ls_verbose	int
&=	O
~	O
LS_LIST_VERBOSE_WITH_SYSTEM_IDS	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SYSTEM_NAMES	O
;	O
}	O
if	O
(	O
check_contents	int
==	O
0	int
)	O
{	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_MD5	O
|	O
LS_LIST_VERBOSE_WITH_SHA1	O
|	O
LS_LIST_VERBOSE_WITH_SHA512	O
)	O
;	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_SIZE	O
)	O
;	O
}	O
digs	pointer
=	O
file_hdr	pointer
->	O
digsM	pointer
;	O
if	O
(	O
digs	pointer
)	O
{	O
if	O
(	O
digs	pointer
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
E_DEBUG	O
(	O
"Turning on md5"	pointer
)	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_MD5	O
;	O
}	O
if	O
(	O
digs	pointer
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
E_DEBUG	O
(	O
"Turning on sha1"	pointer
)	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SHA1	O
;	O
}	O
if	O
(	O
digs	pointer
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
E_DEBUG	O
(	O
"Turning on sha512"	pointer
)	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SHA512	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"Turning off digests"	pointer
)	O
;	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_MD5	O
|	O
LS_LIST_VERBOSE_WITH_SHA1	O
|	O
LS_LIST_VERBOSE_WITH_SHA512	O
)	O
;	O
}	O
return	O
ls_verbose	int
;	O
}	O
static	O
int	O
determine_here_document_stop_word_bystr	function
(	O
STROB	struct
*	O
here_payload	pointer
,	O
STROB	struct
*	O
stopbuf	pointer
)	O
{	O
char	O
*	O
ret_t	pointer
;	O
char	O
*	O
ret	pointer
;	O
int	O
n	long
;	O
n	long
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
do	O
{	O
strob_set_length	function
(	O
stopbuf	pointer
,	O
L_tmpnam	int
+	O
1	int
)	O
;	O
ret_t	pointer
=	O
tmpnam	function
(	O
strob_str	function
(	O
stopbuf	pointer
)	O
)	O
;	O
if	O
(	O
ret_t	pointer
==	O
NULL	O
)	O
return	O
2	int
;	O
ret	pointer
=	O
strob_strstr	function
(	O
here_payload	pointer
,	O
strob_str	function
(	O
stopbuf	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
n	long
++	O
;	O
}	O
while	O
(	O
ret	pointer
==	O
0	int
&&	O
n	long
<	O
10	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
determine_here_document_stop_word	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
STROB	struct
*	O
stopbuf	pointer
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
payload	pointer
;	O
payload	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
swpl_print_file_list_to_buf	function
(	O
fl	pointer
,	O
payload	pointer
)	O
;	O
ret	pointer
=	O
determine_here_document_stop_word_bystr	function
(	O
payload	pointer
,	O
stopbuf	pointer
)	O
;	O
strob_close	function
(	O
payload	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
write_control_script_code_fragment	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
,	O
char	O
*	O
swspec_tags	pointer
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
tmp2	pointer
;	O
STROB	struct
*	O
tmp3	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
tmp2	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
tmp3	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s %s"	pointer
,	O
swspec_tags	pointer
,	O
script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp2	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
G	pointer
->	O
g_opt_previewM	int
)	O
{	O
strob_strcat	function
(	O
tmp2	pointer
,	O
": "	pointer
SWEVENT_ATT_STATUS_PREVIEW	O
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
tmp2	pointer
,	O
": "	pointer
SWEVENT_STATUS_PFX	O
"$sw_retval"	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
tmp3	pointer
,	O
STROB_DO_APPEND	int
,	O
SW_A_SCRIPT_ID	pointer
"=%d"	pointer
,	O
script	pointer
->	O
sidM	int
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"# Start of swpl_write_control_script_code_fragment\n"	pointer
"	cscf_opt_preview=\"%d\"\n"	pointer
"	cd \"%s\" || exit 44\n"	pointer
"	cd \"%s\" || exit 45\n"	pointer
"	script_control_val=$?\n"	pointer
"	case \"$swbis_ignore_scripts\" in yes) script_control_val=_ignore_;; esac\n"	pointer
"	case \"$cscf_opt_preview\" in 1) script_control_val=_preview_;; esac\n"	pointer
"	case $script_control_val in  # Case_swproglib.c_002\n"	pointer
"		0)\n"	pointer
"			%s\n"	pointer
"			%s\n"	pointer
"			"	pointer
SWBIS_PGM_SH	pointer
" "	pointer
SW_A_CONTROL_SH	pointer
" \"%s\" \"%s\"\n"	pointer
"			sw_retval=$?\n"	pointer
"			%s\n"	pointer
"			;;\n"	pointer
"		_preview_)\n"	pointer
"			%s\n"	pointer
"			%s\n"	pointer
"			sw_retval=0\n"	pointer
"			%s\n"	pointer
"			;;\n"	pointer
"		_ignore_)\n"	pointer
"			sw_retval=0\n"	pointer
"			;;\n"	pointer
"		*)\n"	pointer
"			sw_retval="	pointer
SWBIS_STATUS_COMMAND_NOT_FOUND	pointer
"\n"	pointer
"			;;\n"	pointer
"	esac  # Case_swproglib.c_002\n"	pointer
"# End of swpl_write_control_script_code_fragment\n"	pointer
,	O
G	pointer
->	O
g_opt_previewM	int
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_entryM	pointer
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SWI_MSG	int
,	O
strob_str	function
(	O
tmp3	pointer
)	O
)	O
,	O
swspec_tags	pointer
,	O
script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CONTROL_SCRIPT_ENDS	int
,	O
strob_str	function
(	O
tmp2	pointer
)	O
)	O
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SWI_MSG	int
,	O
strob_str	function
(	O
tmp3	pointer
)	O
)	O
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CONTROL_SCRIPT_ENDS	int
,	O
strob_str	function
(	O
tmp2	pointer
)	O
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
strob_close	function
(	O
tmp3	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
construct_script_cases	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
,	O
char	O
*	O
tagspec	pointer
,	O
char	O
*	O
script_tag	pointer
,	O
int	O
error_event_value	int
,	O
int	O
warning_event_value	int
)	O
{	O
int	O
ret	pointer
;	O
struct	O
extendedOptions	struct
*	O
opta	pointer
;	O
int	O
script_retcode	int
;	O
int	O
swi_retcode	int
;	O
STROB	struct
*	O
tmp2	pointer
;	O
STROB	struct
*	O
tmp3	pointer
;	O
tmp2	pointer
=	O
strob_open	function
(	O
48	int
)	O
;	O
tmp3	pointer
=	O
strob_open	function
(	O
48	int
)	O
;	O
opta	pointer
=	O
swi	pointer
->	O
optaM	pointer
;	O
SWLIB_ASSERT	O
(	O
script	pointer
!=	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
write_control_script_code_fragment	function
(	O
G	pointer
,	O
swi	pointer
,	O
script	pointer
,	O
tagspec	pointer
,	O
buf	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	pointer
==	O
0	int
)	O
;	O
if	O
(	O
0	int
&&	O
strcmp	function
(	O
swlib_utilname_get	function
(	O
)	O
,	O
SW_UTN_CONFIG	pointer
)	O
==	O
0	int
)	O
{	O
script_retcode	int
=	O
SW_WARNING	int
;	O
swi_retcode	int
=	O
0	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swextopt_is_option_true	function
(	O
SW_E_enforce_scripts	int
,	O
opta	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"SW_E_enforce_scripts is true"	pointer
)	O
;	O
script_retcode	int
=	O
SW_ERROR	int
;	O
swi_retcode	int
=	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"SW_E_enforce_scripts is false"	pointer
)	O
;	O
script_retcode	int
=	O
SW_WARNING	int
;	O
swi_retcode	int
=	O
0	int
;	O
}	O
}	O
strob_sprintf	function
(	O
tmp2	pointer
,	O
0	int
,	O
"%s: status=$sw_retval"	pointer
,	O
script_tag	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp3	pointer
,	O
0	int
,	O
"%s: status=$script_retval"	pointer
,	O
script_tag	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"# Start of construct_script_cases\n"	pointer
"	case \"$sw_retval\" in\n"	pointer
"		"	pointer
SWBIS_STATUS_COMMAND_NOT_FOUND	pointer
")\n"	pointer
"			# Special return code of control.sh which means\n"	pointer
"			# no script for the specified control_script tag\n"	pointer
"			sw_retval=0\n"	pointer
"			;;\n"	pointer
"		%d)\n"	pointer
"			sw_retval=0\n"	pointer
"			;;\n"	pointer
"		%d)\n"	pointer
"			%s\n"	pointer
"			sw_retval=0\n"	pointer
"			;;\n"	pointer
"		%d)\n"	pointer
"			script_retval=%d\n"	pointer
"			%s\n"	pointer
"			sw_retval=\"%d\"\n"	pointer
"			;;\n"	pointer
"		*)\n"	pointer
"			sw_retval=1\n"	pointer
"			;;\n"	pointer
"	esac\n"	pointer
"# End of construct_script_cases\n"	pointer
,	O
SW_SUCCESS	int
,	O
SW_WARNING	int
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
warning_event_value	int
,	O
strob_str	function
(	O
tmp2	pointer
)	O
)	O
,	O
SW_ERROR	int
,	O
script_retcode	int
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
error_event_value	int
,	O
strob_str	function
(	O
tmp3	pointer
)	O
)	O
,	O
swi_retcode	int
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
strob_close	function
(	O
tmp3	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
form_entry_names	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICAT_E	struct
*	O
e	pointer
,	O
char	O
*	O
iscpath	pointer
,	O
STROB	struct
*	O
tmp_epath	pointer
,	O
STROB	struct
*	O
tmp_depath	pointer
)	O
{	O
char	O
*	O
epath	pointer
;	O
char	O
*	O
depath	pointer
;	O
char	O
*	O
s_ret1	pointer
;	O
char	O
*	O
s_ret2	pointer
;	O
int	O
retval	int
;	O
retval	int
=	O
0	int
;	O
E_DEBUG	O
(	O
"Entering"	pointer
)	O
;	O
E_DEBUG2	O
(	O
"iscpath=[%s]"	pointer
,	O
iscpath	pointer
)	O
;	O
s_ret1	pointer
=	O
swicat_e_form_catalog_path	function
(	O
e	pointer
,	O
tmp_epath	pointer
,	O
iscpath	pointer
,	O
SWICAT_ACTIVE_ENTRY	int
)	O
;	O
epath	pointer
=	O
strob_str	function
(	O
tmp_epath	pointer
)	O
;	O
E_DEBUG2	O
(	O
"epath=[%s]"	pointer
,	O
epath	pointer
)	O
;	O
s_ret2	pointer
=	O
swicat_e_form_catalog_path	function
(	O
e	pointer
,	O
tmp_depath	pointer
,	O
iscpath	pointer
,	O
SWICAT_DEACTIVE_ENTRY	int
)	O
;	O
depath	pointer
=	O
strob_str	function
(	O
tmp_depath	pointer
)	O
;	O
E_DEBUG2	O
(	O
"dpath=[%s]"	pointer
,	O
depath	pointer
)	O
;	O
if	O
(	O
swlib_check_clean_path	function
(	O
epath	pointer
)	O
!=	O
0	int
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"tainted path name: %s\n"	pointer
,	O
epath	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp_epath	pointer
,	O
""	pointer
)	O
;	O
s_ret1	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
swlib_check_clean_path	function
(	O
depath	pointer
)	O
!=	O
0	int
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"tainted path name: %s\n"	pointer
,	O
depath	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp_depath	pointer
,	O
""	pointer
)	O
;	O
s_ret2	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
s_ret1	pointer
==	O
NULL	O
||	O
s_ret2	pointer
==	O
NULL	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
common_remove_catalog_entry	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
epath	pointer
,	O
char	O
*	O
depath	pointer
,	O
char	O
*	O
task_id	pointer
)	O
{	O
STROB	struct
*	O
btmp	pointer
;	O
STROB	struct
*	O
dir2	pointer
;	O
int	O
retval	int
;	O
int	O
ret	pointer
;	O
retval	int
=	O
0	int
;	O
btmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
dir2	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strcpy	function
(	O
dir2	pointer
,	O
epath	pointer
)	O
;	O
swlib_unix_dirtrunc_n	function
(	O
dir2	pointer
,	O
2	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
task_id	pointer
,	O
SWBIS_TS_remove_catalog_entry	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
btmp	pointer
,	O
0	int
,	O
CSHID	O
"	# Remove all old catalog entries\n"	pointer
" 	(cd \"%s\" && find . -type d -name '_[0-9]*' -exec rm -fr {} \\; 2>/dev/null ) </dev/null \n"	pointer
,	O
strob_str	function
(	O
dir2	pointer
)	O
)	O
;	O
}	O
strob_sprintf	function
(	O
btmp	pointer
,	O
1	int
,	O
CSHID	O
"	rm -fr \"%s\" 1>&2\n"	pointer
"	mv -f \"%s\" \"%s\" 1>&2\n"	pointer
"	sw_retval=$?\n"	pointer
" 	(cd \"%s\" && rmdir * 2>/dev/null ) </dev/null \n"	pointer
"	case $sw_retval in 0) ;; *) sw_retval=2 ;; esac\n"	pointer
"	dd count=1 bs=512 of=/dev/null 2>/dev/null\n"	pointer
,	O
depath	pointer
,	O
epath	pointer
,	O
depath	pointer
,	O
strob_str	function
(	O
dir2	pointer
)	O
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
swicol	pointer
->	O
targetpathM	pointer
,	O
strob_str	function
(	O
btmp	pointer
)	O
,	O
task_id	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
retval	int
++	O
;	O
goto	O
error_out	O
;	O
}	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
retval	int
++	O
;	O
goto	O
error_out	O
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_9	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
retval	int
=	O
ret	pointer
;	O
SWLIB_INTERNAL	O
(	O
""	pointer
)	O
;	O
goto	O
error_out	O
;	O
}	O
if	O
(	O
ret	pointer
>	O
0	int
)	O
{	O
retval	int
=	O
ret	pointer
;	O
}	O
error_out	O
:	O
strob_close	function
(	O
btmp	pointer
)	O
;	O
strob_close	function
(	O
dir2	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
int	O
alter_catalog_entry	function
(	O
int	O
remove_restore	int
,	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
SWICAT_E	struct
*	O
e	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
iscpath	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
tmp2	pointer
;	O
char	O
*	O
epath	pointer
;	O
char	O
*	O
depath	pointer
;	O
int	O
retval	int
;	O
int	O
ret	pointer
;	O
retval	int
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
tmp2	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
ret	pointer
=	O
form_entry_names	function
(	O
G	pointer
,	O
e	pointer
,	O
iscpath	pointer
,	O
tmp	pointer
,	O
tmp2	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
return	O
1	int
;	O
epath	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
depath	pointer
=	O
strob_str	function
(	O
tmp2	pointer
)	O
;	O
if	O
(	O
remove_restore	int
==	O
0	int
)	O
ret	pointer
=	O
common_remove_catalog_entry	function
(	O
G	pointer
,	O
swicol	pointer
,	O
ofd	int
,	O
epath	pointer
,	O
depath	pointer
,	O
SWBIS_TS_remove_catalog_entry	pointer
)	O
;	O
else	O
ret	pointer
=	O
common_remove_catalog_entry	function
(	O
G	pointer
,	O
swicol	pointer
,	O
ofd	int
,	O
depath	pointer
,	O
epath	pointer
,	O
SWBIS_TS_restore_catalog_entry	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
return	O
2	int
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
int	O
parse_ls_ld_output	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
ls_output	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
char	O
*	O
value	int
;	O
char	O
*	O
attribute	pointer
;	O
int	O
ret	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
s	pointer
;	O
mode_t	int
mode	int
;	O
char	O
*	O
xp	pointer
;	O
char	O
*	O
s_mode	pointer
;	O
char	O
*	O
owner	pointer
;	O
char	O
*	O
group	char
;	O
E_DEBUG2	O
(	O
"ls output = [%s]"	pointer
,	O
ls_output	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
ls_output	pointer
,	O
"\r\n"	pointer
)	O
;	O
while	O
(	O
line	pointer
)	O
{	O
ret	pointer
=	O
swevent_parse_attribute_event	function
(	O
line	pointer
,	O
&	O
attribute	pointer
,	O
&	O
value	int
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
attribute	pointer
,	O
"ls_ld"	pointer
)	O
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"value=[%s]"	pointer
,	O
value	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
xp	pointer
=	O
value	int
;	O
while	O
(	O
xp	pointer
&&	O
*	O
xp	pointer
&&	O
isspace	function
(	O
(	O
int	O
)	O
*	O
xp	pointer
)	O
)	O
xp	pointer
++	O
;	O
while	O
(	O
xp	pointer
&&	O
*	O
xp	pointer
&&	O
isdigit	function
(	O
(	O
int	O
)	O
*	O
xp	pointer
)	O
)	O
xp	pointer
++	O
;	O
value	int
=	O
xp	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
s_mode	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
value	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
s_mode	pointer
)	O
return	O
-	O
1	int
;	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
-	O
2	int
;	O
owner	pointer
=	O
s	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
==	O
1	int
&&	O
isdigit	function
(	O
(	O
int	O
)	O
(	O
*	O
s	pointer
)	O
)	O
)	O
{	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
" "	pointer
)	O
;	O
owner	pointer
=	O
s	pointer
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
-	O
4	int
;	O
group	char
=	O
s	pointer
;	O
}	O
else	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
s	pointer
++	O
;	O
group	char
=	O
s	pointer
;	O
}	O
mode	int
=	O
swlib_filestring_to_mode	function
(	O
s_mode	pointer
,	O
0	int
)	O
;	O
if	O
(	O
strlen	function
(	O
owner	pointer
)	O
&&	O
strlen	function
(	O
group	char
)	O
&&	O
mode	int
>	O
0666	int
)	O
{	O
E_DEBUG2	O
(	O
"owner=%s"	pointer
,	O
owner	pointer
)	O
;	O
E_DEBUG2	O
(	O
"group=%s"	pointer
,	O
group	char
)	O
;	O
E_DEBUG2	O
(	O
"mode=%s"	pointer
,	O
s_mode	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_ownerM	pointer
=	O
strdup	function
(	O
owner	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_groupM	pointer
=	O
strdup	function
(	O
group	char
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_modeM	int
=	O
mode	int
;	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"FAILED:  owner=%s"	pointer
,	O
owner	pointer
)	O
;	O
E_DEBUG2	O
(	O
"FAILED:  group=%s"	pointer
,	O
group	char
)	O
;	O
E_DEBUG2	O
(	O
"FAILED:  mode=%s"	pointer
,	O
s_mode	pointer
)	O
;	O
return	O
-	O
5	int
;	O
}	O
ret	pointer
=	O
0	int
;	O
break	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"bad message: %s\n"	pointer
,	O
attribute	pointer
)	O
;	O
ret	pointer
=	O
-	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"\r\n"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
i_construct_analysis_script	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
script_name	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
*	O
p_script	pointer
)	O
{	O
int	O
ret	pointer
;	O
SWI_PRODUCT	struct
*	O
prod	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
;	O
struct	O
extendedOptions	struct
*	O
opta	pointer
;	O
int	O
checkscript_retcode	int
;	O
int	O
swi_retcode	int
;	O
int	O
check_def_retcode	int
;	O
opta	pointer
=	O
swi	pointer
->	O
optaM	pointer
;	O
prod	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
0	int
)	O
;	O
if	O
(	O
swi_product_has_control_file	function
(	O
prod	pointer
,	O
script_name	pointer
)	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"	cd \"%s\"\n"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
)	O
;	O
script	pointer
=	O
swi_product_get_control_script_by_tag	function
(	O
prod	pointer
,	O
script_name	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
script	pointer
!=	O
NULL	O
)	O
;	O
ret	pointer
=	O
write_control_script_code_fragment	function
(	O
G	pointer
,	O
swi	pointer
,	O
script	pointer
,	O
prod	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
,	O
buf	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	pointer
==	O
0	int
)	O
;	O
if	O
(	O
swextopt_is_option_true	function
(	O
SW_E_enforce_scripts	int
,	O
opta	pointer
)	O
)	O
{	O
checkscript_retcode	int
=	O
SW_ERROR	int
;	O
swi_retcode	int
=	O
1	int
;	O
}	O
else	O
{	O
checkscript_retcode	int
=	O
SW_WARNING	int
;	O
swi_retcode	int
=	O
0	int
;	O
}	O
if	O
(	O
G	pointer
->	O
g_force	int
)	O
{	O
check_def_retcode	int
=	O
0	int
;	O
}	O
else	O
{	O
check_def_retcode	int
=	O
SW_DESELECT	int
;	O
}	O
*	O
p_script	pointer
=	O
script	pointer
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"case \"$sw_retval\" in\n"	pointer
"	%d)\n"	pointer
"		sw_retval=0\n"	pointer
"		;;\n"	pointer
"	%d)\n"	pointer
"		sw_retval=0\n"	pointer
"		%s\n"	pointer
"		;;\n"	pointer
"	%d)\n"	pointer
"		script_retval=%d\n"	pointer
"		sw_retval=%d\n"	pointer
"		%s\n"	pointer
"		sw_retval=0\n"	pointer
"		;;\n"	pointer
"	%d)\n"	pointer
"		script_retval=%d\n"	pointer
"		sw_retval=%d\n"	pointer
"		%s\n"	pointer
"		sw_retval=0\n"	pointer
"		;;\n"	pointer
"	*)\n"	pointer
"		sw_retval=4\n"	pointer
"		;;\n"	pointer
"esac\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
,	O
SW_SUCCESS	int
,	O
SW_WARNING	int
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CHECK_SCRIPT_WARNING	int
,	O
"status=$sw_retval"	pointer
)	O
,	O
SW_ERROR	int
,	O
checkscript_retcode	int
,	O
swi_retcode	int
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CHECK_SCRIPT_ERROR	int
,	O
"status=$script_retval"	pointer
)	O
,	O
SW_DESELECT	int
,	O
SW_DESELECT	int
,	O
check_def_retcode	int
,	O
TEVENT	O
(	O
2	int
,	O
(	O
swi	pointer
->	O
verboseM	int
)	O
,	O
SW_CHECK_SCRIPT_EXCLUDE	int
,	O
"status=$sw_retval"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
*	O
p_script	pointer
=	O
NULL	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"sw_retval=0\n"	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
construct_binsh_name	function
(	O
char	O
*	O
shell	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
shell	pointer
,	O
SH_A_sh	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWBIS_PGM_BIN_SH	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
shell	pointer
,	O
SH_A_bash	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWBIS_PGM_BIN_BASH	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
shell	pointer
,	O
SH_A_ksh	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWBIS_PGM_BIN_KSH	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
shell	pointer
,	O
SH_A_mksh	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWBIS_PGM_BIN_MKSH	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid selection in construct_binsh_name(), defaulting to sh\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
SWBIS_PGM_BIN_SH	pointer
;	O
}	O
;	O
}	O
void	O
swpl_write_chdir_catalog_fragment	function
(	O
STROB	struct
*	O
tmp	pointer
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
id_str	pointer
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"cd \"%s\"\n"	pointer
"case \"$?\" in\n"	pointer
"	0)\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"	echo error: cd \"%s\" failed for task \"%s\" 1>&2\n"	pointer
"	exit 1\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
,	O
catalog_path	pointer
,	O
catalog_path	pointer
,	O
id_str	pointer
)	O
;	O
}	O
void	O
swpl_print_file_list_to_buf	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
ix	int
;	O
ix	int
=	O
0	int
;	O
while	O
(	O
(	O
name	pointer
=	O
swi_fl_get_path	function
(	O
fl	pointer
,	O
ix	int
++	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
}	O
void	O
swpl_set_detected_catalog_perms	function
(	O
SWI	struct
*	O
swi	pointer
,	O
ETAR	struct
*	O
etar	pointer
,	O
int	O
tar_type	int
)	O
{	O
mode_t	int
mode	int
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_ownerM	pointer
)	O
etar_set_uname	function
(	O
etar	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_ownerM	pointer
)	O
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_groupM	pointer
)	O
etar_set_gname	function
(	O
etar	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_groupM	pointer
)	O
;	O
mode	int
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_modeM	int
;	O
if	O
(	O
mode	int
>	O
0	int
)	O
{	O
if	O
(	O
tar_type	int
==	O
REGTYPE	char
)	O
{	O
mode	int
&=	O
~	O
(	O
S_IXUSR	O
|	O
S_IXGRP	O
|	O
S_IXOTH	O
|	O
S_ISVTX	O
|	O
S_ISUID	O
|	O
S_ISGID	O
)	O
;	O
}	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
mode	int
)	O
)	O
;	O
}	O
}	O
int	O
swpl_send_null_task	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
msgtag	pointer
,	O
int	O
retcode	int
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"sw_retval=%d"	pointer
,	O
retcode	int
)	O
;	O
ret	pointer
=	O
swpl_send_null_task2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
event_fd	int
,	O
msgtag	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_send_null_task2	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
msgtag	pointer
,	O
char	O
*	O
status_expression	pointer
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
ts_msg	pointer
;	O
ts_msg	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_strcat	function
(	O
ts_msg	pointer
,	O
msgtag	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
CSHID	O
"# sw_retval=%%d\n"	pointer
"%s\n"	pointer
"sleep 0\n"	pointer
"dd bs=512 count=1 of=/dev/null 2>/dev/null\n"	pointer
"case $sw_retval in 0) exit 0 ;; *) exit $sw_retval;; esac\n"	pointer
,	O
status_expression	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
"."	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
strob_str	function
(	O
ts_msg	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_get_utsname_attributes(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
if	O
(	O
ret	pointer
>	O
0	int
)	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
event_fd	int
,	O
SWICOL_TL_12	int
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
}	O
strob_close	function
(	O
ts_msg	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
swicol_clear_task_idstring	function
(	O
swicol	pointer
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
void	O
swpl_init_header_root	function
(	O
ETAR	struct
*	O
etar	pointer
)	O
{	O
etar_set_typeflag	function
(	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
0640	int
)	O
)	O
;	O
etar_set_uid	function
(	O
etar	pointer
,	O
0	int
)	O
;	O
etar_set_gid	function
(	O
etar	pointer
,	O
0	int
)	O
;	O
etar_set_uname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_gname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
}	O
void	O
swpl_scary_init_script_array	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SCAR_ARRAY_LEN	int
;	O
i	int
++	O
)	O
{	O
g_script_array	array
[	O
i	int
]	O
=	O
(	O
SCAR	struct
*	O
)	O
NULL	O
;	O
}	O
}	O
SWI_CONTROL_SCRIPT	struct
*	O
swpl2_find_by_id	function
(	O
int	O
id	pointer
,	O
CISFBA	struct
*	O
bav	pointer
,	O
CISF_BASE	struct
*	O
*	O
bpp	pointer
)	O
{	O
int	O
i	int
;	O
VPLOB	union
*	O
v	int
;	O
CISF_BASE	struct
*	O
b	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
sc	pointer
;	O
v	int
=	O
bav	pointer
->	O
base_arrayM	pointer
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
b	pointer
=	O
(	O
CISF_BASE	struct
*	O
)	O
vplob_val	function
(	O
v	int
,	O
i	int
++	O
)	O
)	O
)	O
{	O
E_DEBUG2	O
(	O
"index=%d"	pointer
,	O
i	int
)	O
;	O
E_DEBUG2	O
(	O
"id = %d"	pointer
,	O
id	pointer
)	O
;	O
sc	pointer
=	O
swi_xfile_get_control_script_by_id	function
(	O
b	pointer
->	O
ixfileM	pointer
,	O
id	pointer
)	O
;	O
if	O
(	O
sc	pointer
)	O
{	O
E_DEBUG2	O
(	O
"Found id = %d"	pointer
,	O
id	pointer
)	O
;	O
if	O
(	O
bpp	pointer
)	O
*	O
bpp	pointer
=	O
b	pointer
;	O
return	O
sc	pointer
;	O
}	O
}	O
E_DEBUG	O
(	O
"Returning NULL"	pointer
)	O
;	O
if	O
(	O
bpp	pointer
)	O
*	O
bpp	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
SCAR	struct
*	O
*	O
swpl_get_script_array	function
(	O
void	O
)	O
{	O
return	O
g_script_array	array
;	O
}	O
SCAR	struct
*	O
swpl_scary_create	function
(	O
char	O
*	O
tag	pointer
,	O
char	O
*	O
tagspec	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
)	O
{	O
SCAR	struct
*	O
scary	pointer
;	O
scary	pointer
=	O
(	O
SCAR	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SCAR	struct
)	O
)	O
;	O
if	O
(	O
!	O
scary	pointer
)	O
return	O
scary	pointer
;	O
scary	pointer
->	O
tagM	pointer
=	O
strdup	function
(	O
tag	pointer
)	O
;	O
scary	pointer
->	O
tagspecM	pointer
=	O
strdup	function
(	O
tagspec	pointer
)	O
;	O
scary	pointer
->	O
scriptM	pointer
=	O
script	pointer
;	O
return	O
scary	pointer
;	O
}	O
void	O
swpl_scary_delete	function
(	O
SCAR	struct
*	O
scary	pointer
)	O
{	O
free	function
(	O
scary	pointer
->	O
tagM	pointer
)	O
;	O
free	function
(	O
scary	pointer
->	O
tagspecM	pointer
)	O
;	O
free	function
(	O
scary	pointer
)	O
;	O
}	O
SCAR	struct
*	O
swpl_scary_add	function
(	O
SCAR	struct
*	O
*	O
array	pointer
,	O
SCAR	struct
*	O
script	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SCAR_ARRAY_LEN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
array	pointer
[	O
i	int
]	O
==	O
(	O
SCAR	struct
*	O
)	O
NULL	O
)	O
{	O
array	pointer
[	O
i	int
]	O
=	O
script	pointer
;	O
return	O
script	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
void	O
swpl2_cisf_base_array_add	function
(	O
CISF_PRODUCT	struct
*	O
cisf	pointer
,	O
CISF_BASE	struct
*	O
b	pointer
)	O
{	O
VPLOB	union
*	O
v	int
=	O
cisf	pointer
->	O
cbaM	pointer
->	O
base_arrayM	pointer
;	O
vplob_add	function
(	O
v	int
,	O
b	pointer
)	O
;	O
}	O
CISF_BASE	struct
*	O
swpl2_cisf_base_array_get	function
(	O
CISF_PRODUCT	struct
*	O
cisf	pointer
,	O
int	O
ix	int
)	O
{	O
CISF_BASE	struct
*	O
b	pointer
;	O
VPLOB	union
*	O
v	int
=	O
cisf	pointer
->	O
cbaM	pointer
->	O
base_arrayM	pointer
;	O
b	pointer
=	O
(	O
CISF_BASE	struct
*	O
)	O
vplob_val	function
(	O
v	int
,	O
ix	int
)	O
;	O
return	O
b	pointer
;	O
}	O
void	O
swpl_scary_show_array	function
(	O
SCAR	struct
*	O
*	O
array	pointer
)	O
{	O
int	O
i	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
18	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SCAR_ARRAY_LEN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
array	pointer
[	O
i	int
]	O
==	O
(	O
SCAR	struct
*	O
)	O
NULL	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
swlib_writef	function
(	O
STDERR_FILENO	int
,	O
tmp	pointer
,	O
"%d tag=[%s] tagspec=[%s] script=[%p]\n"	pointer
,	O
i	int
,	O
array	pointer
[	O
i	int
]	O
->	O
tagM	pointer
,	O
array	pointer
[	O
i	int
]	O
->	O
tagspecM	pointer
,	O
array	pointer
[	O
i	int
]	O
->	O
scriptM	pointer
)	O
;	O
}	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
;	O
}	O
SWI_CONTROL_SCRIPT	struct
*	O
swpl_scary_find_script	function
(	O
SCAR	struct
*	O
*	O
array	pointer
,	O
char	O
*	O
tag	pointer
,	O
char	O
*	O
tagspec	pointer
)	O
{	O
int	O
i	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
retval	int
=	O
NULL	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
18	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SCAR_ARRAY_LEN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
array	pointer
[	O
i	int
]	O
==	O
(	O
SCAR	struct
*	O
)	O
NULL	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
array	pointer
[	O
i	int
]	O
->	O
tagM	pointer
,	O
tag	pointer
)	O
==	O
0	int
&&	O
strcmp	function
(	O
array	pointer
[	O
i	int
]	O
->	O
tagspecM	pointer
,	O
tagspec	pointer
)	O
==	O
0	int
&&	O
1	int
)	O
{	O
retval	int
=	O
array	pointer
[	O
i	int
]	O
->	O
scriptM	pointer
;	O
break	O
;	O
}	O
}	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_retrieve_files	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
SWICAT_E	struct
*	O
e	pointer
,	O
SWI_FILELIST	union
*	O
file_list	pointer
,	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
int	O
archive_fd	int
,	O
char	O
*	O
pax_write_command_key	pointer
,	O
int	O
ls_fd	int
,	O
int	O
ls_verbose	int
,	O
FILE_DIGS	struct
*	O
digs	pointer
)	O
{	O
TARU	struct
*	O
taru	pointer
;	O
STROB	struct
*	O
scriptbuf	pointer
;	O
STROB	struct
*	O
shell_lib_buf	pointer
;	O
int	O
ret	pointer
;	O
scriptbuf	pointer
=	O
strob_open	function
(	O
300	int
)	O
;	O
shell_lib_buf	pointer
=	O
strob_open	function
(	O
300	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"rm_retval=1\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"sw_retval=1\n"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"dd bs=512 count=1 of=/dev/null 2>/dev/null\n"	pointer
"sw_retval=$?\n"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swpl_make_verify_command_script_fragment	function
(	O
G	pointer
,	O
scriptbuf	pointer
,	O
file_list	pointer
,	O
pax_write_command_key	pointer
,	O
ls_fd	int
<	O
0	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
"."	pointer
,	O
strob_str	function
(	O
scriptbuf	pointer
)	O
,	O
SWBIS_TS_retrieve_files_archive	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
swicol_set_master_alarm	function
(	O
swicol	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_set_tar_header_policy	function
(	O
taru	pointer
,	O
"pax"	pointer
,	O
NULL	O
)	O
;	O
ret	pointer
=	O
taru_process_copy_out	function
(	O
taru	pointer
,	O
ifd	int
,	O
archive_fd	int
,	O
NULL	O
,	O
NULL	O
,	O
arf_ustar	int
,	O
ls_fd	int
,	O
ls_verbose	int
,	O
(	O
intmax_t	long
*	O
)	O
NULL	O
,	O
digs	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_delete	function
(	O
taru	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
swicol_set_master_alarm	function
(	O
swicol	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_12	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
scriptbuf	pointer
)	O
;	O
strob_close	function
(	O
shell_lib_buf	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
void	O
swpl2_audit_cisf_bases	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
CISF_PRODUCT	struct
*	O
cisf	pointer
)	O
{	O
int	O
fileset_index	int
;	O
CISF_FILESET	union
*	O
f	pointer
;	O
E_DEBUG	O
(	O
"entering"	pointer
)	O
;	O
cplob_shallow_reset	function
(	O
(	O
CPLOB	struct
*	O
)	O
(	O
cisf	pointer
->	O
cbaM	pointer
->	O
base_arrayM	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
"add top level"	pointer
)	O
;	O
swpl2_cisf_base_array_add	function
(	O
cisf	pointer
,	O
(	O
void	O
*	O
)	O
(	O
&	O
(	O
cisf	pointer
->	O
cisf_baseM	struct
)	O
)	O
)	O
;	O
fileset_index	int
=	O
0	int
;	O
f	pointer
=	O
(	O
CISF_FILESET	union
*	O
)	O
vplob_val	function
(	O
cisf	pointer
->	O
isetsM	pointer
,	O
fileset_index	int
++	O
)	O
;	O
while	O
(	O
f	pointer
)	O
{	O
E_DEBUG2	O
(	O
"GOT f fileset_index=%d\n"	pointer
,	O
fileset_index	int
)	O
;	O
E_DEBUG	O
(	O
"add fileset\n"	pointer
)	O
;	O
swpl2_cisf_base_array_add	function
(	O
cisf	pointer
,	O
(	O
void	O
*	O
)	O
(	O
&	O
(	O
f	pointer
->	O
cisf_baseM	struct
)	O
)	O
)	O
;	O
f	pointer
=	O
(	O
CISF_FILESET	union
*	O
)	O
vplob_val	function
(	O
cisf	pointer
->	O
isetsM	pointer
,	O
fileset_index	int
++	O
)	O
;	O
}	O
E_DEBUG	O
(	O
"leaving"	pointer
)	O
;	O
}	O
void	O
swpl_audit_execution_scripts	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
SCAR	struct
*	O
*	O
scary_scripts	pointer
)	O
{	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
product_xxinstall_script	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
fileset_xxinstall_script	pointer
;	O
STROB	struct
*	O
tagspec	pointer
;	O
SCAR	struct
*	O
scary_script	pointer
;	O
int	O
fileset_index	int
;	O
char	O
*	O
*	O
ts	pointer
;	O
char	O
*	O
tag	pointer
;	O
char	O
*	O
execution_scripts	array
[	O
]	O
=	O
{	O
SW_A_checkinstall	pointer
,	O
SW_A_postinstall	pointer
,	O
SW_A_preinstall	pointer
,	O
SW_A_configure	pointer
,	O
SW_A_checkremove	pointer
,	O
SW_A_preremove	pointer
,	O
SW_A_postremove	pointer
,	O
SW_A_unconfigure	pointer
,	O
SW_A_unpostinstall	pointer
,	O
SW_A_unpreinstall	pointer
,	O
SW_A_request	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
tagspec	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swpl_scary_init_script_array	function
(	O
)	O
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
0	int
)	O
;	O
ts	pointer
=	O
execution_scripts	array
;	O
for	O
(	O
;	O
tag	pointer
=	O
(	O
*	O
ts	pointer
)	O
,	O
*	O
ts	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
ts	pointer
++	O
)	O
{	O
product_xxinstall_script	pointer
=	O
swi_product_get_control_script_by_tag	function
(	O
product	pointer
,	O
tag	pointer
)	O
;	O
if	O
(	O
product_xxinstall_script	pointer
)	O
{	O
scary_script	pointer
=	O
swpl_scary_create	function
(	O
tag	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
,	O
product_xxinstall_script	pointer
)	O
;	O
swpl_scary_add	function
(	O
scary_scripts	pointer
,	O
scary_script	pointer
)	O
;	O
}	O
}	O
fileset_index	int
=	O
0	int
;	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
fileset_index	int
++	O
)	O
;	O
while	O
(	O
fileset	pointer
)	O
{	O
strob_sprintf	function
(	O
tagspec	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s.%s"	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
,	O
fileset	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
ts	pointer
=	O
execution_scripts	array
;	O
for	O
(	O
;	O
tag	pointer
=	O
(	O
*	O
ts	pointer
)	O
,	O
*	O
ts	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
ts	pointer
++	O
)	O
{	O
fileset_xxinstall_script	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
fileset	pointer
,	O
tag	pointer
)	O
;	O
if	O
(	O
fileset_xxinstall_script	pointer
)	O
{	O
scary_script	pointer
=	O
swpl_scary_create	function
(	O
tag	pointer
,	O
strob_str	function
(	O
tagspec	pointer
)	O
,	O
fileset_xxinstall_script	pointer
)	O
;	O
swpl_scary_add	function
(	O
scary_scripts	pointer
,	O
scary_script	pointer
)	O
;	O
}	O
}	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
fileset_index	int
++	O
)	O
;	O
}	O
strob_close	function
(	O
tagspec	pointer
)	O
;	O
}	O
int	O
swpl_write_case_block	function
(	O
SWI	struct
*	O
swi	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
tag	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
swicat_write_script_cases	function
(	O
swi	pointer
,	O
tmp	pointer
,	O
tag	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"# generated by swpl_write_case_block\n"	pointer
"	%s)\n"	pointer
"%s"	pointer
"		;;\n"	pointer
,	O
tag	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
uintmax_t	long
swpl_get_whole_block_size	function
(	O
uintmax_t	long
size	long
)	O
{	O
uintmax_t	long
ret	pointer
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
size	long
%	O
TARRECORDSIZE	int
)	O
ret	pointer
=	O
(	O
(	O
size	long
/	O
TARRECORDSIZE	int
)	O
+	O
1	int
)	O
*	O
TARRECORDSIZE	int
;	O
else	O
ret	pointer
=	O
(	O
(	O
size	long
/	O
TARRECORDSIZE	int
)	O
)	O
*	O
TARRECORDSIZE	int
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_write_session_options_file	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
)	O
{	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
swextopt_writeExtendedOptions_strob	function
(	O
buf	pointer
,	O
(	O
struct	O
extendedOptions	struct
*	O
)	O
(	O
swi	pointer
->	O
optaM	pointer
)	O
,	O
swi	pointer
->	O
swc_idM	int
,	O
1	int
)	O
;	O
return	O
strob_strlen	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
swpl_write_single_file_tar_archive	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
data	pointer
,	O
AHS	struct
*	O
ahs	pointer
)	O
{	O
ETAR	struct
*	O
etar	pointer
;	O
int	O
ret	pointer
;	O
int	O
retval	int
=	O
0	int
;	O
etar	pointer
=	O
etar_open	function
(	O
swi	pointer
->	O
xformatM	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
)	O
;	O
etar_init_hdr	function
(	O
etar	pointer
)	O
;	O
swpl_init_header_root	function
(	O
etar	pointer
)	O
;	O
etar_set_size	function
(	O
etar	pointer
,	O
strlen	function
(	O
data	pointer
)	O
)	O
;	O
if	O
(	O
etar_set_pathname	function
(	O
etar	pointer
,	O
name	pointer
)	O
)	O
SWLIB_FATAL	O
(	O
"name too long"	pointer
)	O
;	O
swpl_set_detected_catalog_perms	function
(	O
swi	pointer
,	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
if	O
(	O
ahs	pointer
)	O
{	O
etar_set_uname	function
(	O
etar	pointer
,	O
ahs_get_tar_username	function
(	O
ahs	pointer
)	O
)	O
;	O
etar_set_gname	function
(	O
etar	pointer
,	O
ahs_get_tar_groupname	function
(	O
ahs	pointer
)	O
)	O
;	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
long	O
)	O
ahs_get_mode	function
(	O
ahs	pointer
)	O
)	O
;	O
}	O
etar_set_chksum	function
(	O
etar	pointer
)	O
;	O
ret	pointer
=	O
etar_emit_header	function
(	O
etar	pointer
,	O
ofd	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_write_single_file_tar_archive(): etar_emit_header(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
retval	int
+=	O
ret	pointer
;	O
ret	pointer
=	O
etar_emit_data_from_buffer	function
(	O
etar	pointer
,	O
ofd	int
,	O
data	pointer
,	O
strlen	function
(	O
data	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_write_single_file_tar_archive(): etar_emit_data_from_buffer(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
retval	int
+=	O
ret	pointer
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
2	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_write_single_file_tar_archive(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
retval	int
+=	O
ret	pointer
;	O
etar_close	function
(	O
etar	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_load_single_status_value	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
id_str	pointer
,	O
int	O
status_msg	int
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
data	pointer
;	O
ret	pointer
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
data	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_memset	function
(	O
data	pointer
,	O
'\0'	O
,	O
513	int
)	O
;	O
strob_sprintf	function
(	O
data	pointer
,	O
0	int
,	O
"%d\n"	pointer
,	O
status_msg	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"# Read the status from the the management host\n"	pointer
"# and exit with its value.  This is used to \n"	pointer
"# convey an error from the management host to the\n"	pointer
"# target host\n"	pointer
"MHOST_STATUS=$(dd bs=512 count=1);\n"	pointer
"case \"$MHOST_STATUS\" in\n"	pointer
"	0)\n"	pointer
"		sw_retval=0\n"	pointer
"		;;\n"	pointer
"	*)\n"	pointer
"		sw_retval=1\n"	pointer
"		;;\n"	pointer
"esac\n"	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
1	int
,	O
"/"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
id_str	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
data	pointer
)	O
)	O
,	O
512	int
)	O
;	O
if	O
(	O
ret	pointer
==	O
512	int
)	O
ret	pointer
=	O
0	int
;	O
else	O
ret	pointer
=	O
2	int
;	O
}	O
else	O
{	O
ret	pointer
=	O
1	int
;	O
}	O
strob_close	function
(	O
data	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_load_single_file_tar_archive	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
pax_read_command	pointer
,	O
int	O
alt_catalog_root	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
id_str	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
data	pointer
,	O
AHS	struct
*	O
ahs	pointer
)	O
{	O
int	O
ret	pointer
;	O
unsigned	O
long	O
int	O
stdin_file_size	long
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
namebuf	pointer
;	O
STROB	struct
*	O
tmpv	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmpv	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
namebuf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
G	pointer
->	O
g_verboseG	int
>	O
SWC_VERBOSE_4	int
)	O
{	O
strob_strcpy	function
(	O
tmpv	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
tmpv	pointer
,	O
"1>/dev/null 2>&1"	pointer
)	O
;	O
}	O
stdin_file_size	long
=	O
swpl_get_whole_block_size	function
(	O
(	O
unsigned	O
long	O
int	O
)	O
strlen	function
(	O
data	pointer
)	O
)	O
+	O
TARRECORDSIZE	int
+	O
TARRECORDSIZE	int
+	O
TARRECORDSIZE	int
+	O
0	int
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"cd \"%s\"\n"	pointer
"case \"$?\" in\n"	pointer
"	0)\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"	echo error: cd \"%s\" failed for task \"%s\" 1>&2\n"	pointer
"	exit 1\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
,	O
catalog_path	pointer
,	O
catalog_path	pointer
,	O
id_str	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"dd 2>/dev/null | (%s %s; sw_retval=$?; dd of=/dev/null 2>/dev/null; exit $sw_retval) \n"	pointer
"sw_retval=$?\n"	pointer
"# dd of=/dev/null 2>/dev/null\n"	pointer
,	O
pax_read_command	pointer
,	O
strob_str	function
(	O
tmpv	pointer
)	O
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
stdin_file_size	long
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
id_str	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
swpl_write_single_file_tar_archive	function
(	O
swi	pointer
,	O
ofd	int
,	O
name	pointer
,	O
data	pointer
,	O
ahs	pointer
)	O
;	O
if	O
(	O
ret	pointer
<=	O
0	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ret	pointer
!=	O
(	O
int	O
)	O
stdin_file_size	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"ret=%d  stdin_file_size=%lu\n"	pointer
,	O
ret	pointer
,	O
stdin_file_size	long
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
event_fd	int
,	O
SWICOL_TL_12	int
)	O
;	O
if	O
(	O
swi	pointer
->	O
debug_eventsM	int
)	O
swicol_show_events_to_fd	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
STDERR_FILENO	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
strob_close	function
(	O
tmpv	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_write_tar_installed_software_index_file	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
pax_read_command	pointer
,	O
int	O
alt_catalog_root	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
id_str	pointer
,	O
char	O
*	O
sw_a_installed	pointer
,	O
AHS	struct
*	O
ahs	pointer
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
STROB	struct
*	O
name	pointer
;	O
STROB	struct
*	O
data	pointer
;	O
name	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
data	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
swicat_isf_installed_software	function
(	O
data	pointer
,	O
swi	pointer
)	O
;	O
strob_strcpy	function
(	O
name	pointer
,	O
sw_a_installed	pointer
)	O
;	O
ret	pointer
=	O
swpl_load_single_file_tar_archive	function
(	O
G	pointer
,	O
swi	pointer
,	O
ofd	int
,	O
catalog_path	pointer
,	O
pax_read_command	pointer
,	O
alt_catalog_root	int
,	O
event_fd	int
,	O
id_str	pointer
,	O
strob_str	function
(	O
name	pointer
)	O
,	O
strob_str	function
(	O
data	pointer
)	O
,	O
ahs	pointer
)	O
;	O
strob_close	function
(	O
name	pointer
)	O
;	O
strob_close	function
(	O
data	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_construct_configure_script	function
(	O
GB	struct
*	O
G	pointer
,	O
CISF_PRODUCT	struct
*	O
cisf	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
do_configure	int
)	O
{	O
int	O
ret	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"	# Start of code generated by swpl_construct_configure_script \n"	pointer
"		ssv_do_configure=%d\n"	pointer
"		case \"$ssv_do_configure\" in\n"	pointer
"		1)\n"	pointer
,	O
do_configure	int
)	O
;	O
ret	pointer
=	O
swpl_construct_script	function
(	O
G	pointer
,	O
cisf	pointer
,	O
buf	pointer
,	O
swi	pointer
,	O
SW_A_configure	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"		;;\n"	pointer
"		esac\n"	pointer
"	# End of code generated by swpl_construct_configure_script \n"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl2_construct_control_script	function
(	O
GB	struct
*	O
G	pointer
,	O
CISF_BASE	struct
*	O
cisf_base	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
script_tag	pointer
,	O
char	O
*	O
parent_tag	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
toap	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
xx_script	pointer
;	O
char	O
*	O
target_path	pointer
;	O
struct	O
extendedOptions	struct
*	O
opta	pointer
;	O
int	O
event_error_value	pointer
;	O
int	O
event_warning_value	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
opta	pointer
=	O
swi	pointer
->	O
optaM	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
toap	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
select_error_codes	function
(	O
script_tag	pointer
,	O
&	O
event_error_value	pointer
,	O
&	O
event_warning_value	pointer
)	O
;	O
E_DEBUG2	O
(	O
"script_tag=%s"	pointer
,	O
script_tag	pointer
)	O
;	O
xx_script	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
cisf_base	pointer
->	O
ixfileM	pointer
,	O
script_tag	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
xx_script	pointer
)	O
{	O
return	O
0	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"# Begin code generated by swproglib.c:swpl_construct_control_script\n"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
)	O
{	O
target_path	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
;	O
}	O
else	O
{	O
target_path	pointer
=	O
"."	pointer
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
parent_tag	pointer
&&	O
strlen	function
(	O
parent_tag	pointer
)	O
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s.%s"	pointer
,	O
parent_tag	pointer
,	O
cisf_base	pointer
->	O
ixfileM	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
cisf_base	pointer
->	O
ixfileM	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
"\tcd \"%s\"\n"	pointer
,	O
target_path	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
construct_script_cases	function
(	O
G	pointer
,	O
toap	pointer
,	O
swi	pointer
,	O
xx_script	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
script_tag	pointer
,	O
event_error_value	pointer
,	O
event_warning_value	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
"# End of code generated by swproglib.c:swpl_construct_control_script\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s"	pointer
,	O
strob_str	function
(	O
toap	pointer
)	O
)	O
;	O
strob_close	function
(	O
toap	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_construct_script	function
(	O
GB	struct
*	O
G	pointer
,	O
CISF_PRODUCT	struct
*	O
cisf	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
script_tag	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
toap	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
product_xxinstall_script	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
fileset_xxinstall_script	pointer
;	O
char	O
*	O
target_path	pointer
;	O
struct	O
extendedOptions	struct
*	O
opta	pointer
;	O
int	O
product_ix	int
;	O
int	O
fileset_ix	int
;	O
int	O
event_error_value	pointer
;	O
int	O
event_warning_value	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
opta	pointer
=	O
swi	pointer
->	O
optaM	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
toap	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
product_ix	int
=	O
cisf	pointer
->	O
cisf_baseM	struct
.	O
cf_indexM	int
;	O
fileset_ix	int
=	O
(	O
(	O
CISF_FILESET	union
*	O
)	O
vplob_val	function
(	O
cisf	pointer
->	O
isetsM	pointer
,	O
0	int
)	O
)	O
->	O
cisf_baseM	struct
.	O
cf_indexM	int
;	O
if	O
(	O
fileset_ix	int
!=	O
0	int
||	O
product_ix	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"***  ERROR in cisf object\n"	pointer
)	O
;	O
product_ix	int
=	O
fileset_ix	int
=	O
0	int
;	O
}	O
select_error_codes	function
(	O
script_tag	pointer
,	O
&	O
event_error_value	pointer
,	O
&	O
event_warning_value	pointer
)	O
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_ix	int
)	O
;	O
product_xxinstall_script	pointer
=	O
swi_product_get_control_script_by_tag	function
(	O
product	pointer
,	O
script_tag	pointer
)	O
;	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
fileset_ix	int
)	O
;	O
fileset_xxinstall_script	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
fileset	pointer
,	O
script_tag	pointer
)	O
;	O
if	O
(	O
!	O
product_xxinstall_script	pointer
&&	O
!	O
fileset_xxinstall_script	pointer
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
)	O
{	O
target_path	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
;	O
}	O
else	O
{	O
target_path	pointer
=	O
"."	pointer
;	O
}	O
if	O
(	O
product_xxinstall_script	pointer
)	O
{	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"# Start of code generated by swproglib.c:swpl_construct_script\n"	pointer
,	O
"cd \"%s\"\n"	pointer
,	O
target_path	pointer
)	O
;	O
construct_script_cases	function
(	O
G	pointer
,	O
toap	pointer
,	O
swi	pointer
,	O
product_xxinstall_script	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
,	O
script_tag	pointer
,	O
event_error_value	pointer
,	O
event_warning_value	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
fileset_xxinstall_script	pointer
)	O
{	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"	case \"$sw_retval\" in  # Case_construct_script_003\n"	pointer
"	0)\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s.%s"	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
,	O
fileset	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
"\tcd \"%s\"\n"	pointer
,	O
target_path	pointer
)	O
;	O
construct_script_cases	function
(	O
G	pointer
,	O
toap	pointer
,	O
swi	pointer
,	O
fileset_xxinstall_script	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
script_tag	pointer
,	O
event_error_value	pointer
,	O
event_warning_value	pointer
)	O
;	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
"	;;\n"	pointer
"	esac # Case_construct_script_003\n"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
toap	pointer
,	O
STROB_DO_APPEND	int
,	O
"# End of code generated by swproglib.c:swpl_construct_script\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s"	pointer
,	O
strob_str	function
(	O
toap	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
toap	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_construct_analysis_script	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
script_name	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
*	O
p_script	pointer
)	O
{	O
return	O
i_construct_analysis_script	function
(	O
G	pointer
,	O
script_name	pointer
,	O
buf	pointer
,	O
swi	pointer
,	O
p_script	pointer
)	O
;	O
}	O
int	O
swpl_compare_name	function
(	O
char	O
*	O
name1	pointer
,	O
char	O
*	O
name2	pointer
,	O
char	O
*	O
att	pointer
,	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
ret	pointer
;	O
if	O
(	O
strlen	function
(	O
name1	pointer
)	O
==	O
0	int
||	O
strlen	function
(	O
name2	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
ret	pointer
=	O
swlib_dir_compare	function
(	O
name1	pointer
,	O
name2	pointer
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
)	O
{	O
if	O
(	O
swlib_compare_8859	function
(	O
name1	pointer
,	O
name2	pointer
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: attribute mismatch: %s: att=%s: storage=[%s] INFO=[%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
filename	pointer
,	O
att	pointer
,	O
name1	pointer
,	O
name2	pointer
)	O
;	O
}	O
else	O
{	O
ret	pointer
=	O
0	int
;	O
}	O
}	O
return	O
ret	pointer
?	O
1	int
:	O
0	int
;	O
}	O
void	O
swpl_safe_check_pathname	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
swlib_is_sh_tainted_string	function
(	O
s	pointer
)	O
)	O
{	O
SWLIB_FATAL	O
(	O
"tainted string"	pointer
)	O
;	O
}	O
}	O
void	O
swpl_sanitize_pathname	function
(	O
char	O
*	O
s	pointer
)	O
{	O
swlib_squash_all_leading_slash	function
(	O
s	pointer
)	O
;	O
}	O
char	O
*	O
swpl_get_attribute	function
(	O
SWHEADER	struct
*	O
header	struct
,	O
char	O
*	O
att	pointer
,	O
int	O
*	O
len	int
)	O
{	O
char	O
*	O
line	pointer
;	O
char	O
*	O
value	int
;	O
line	pointer
=	O
swheader_get_attribute	function
(	O
header	struct
,	O
att	pointer
,	O
NULL	O
)	O
;	O
value	int
=	O
swheaderline_get_value	function
(	O
line	pointer
,	O
len	int
)	O
;	O
return	O
value	int
;	O
}	O
void	O
swpl_enforce_one_prod_one_fileset	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
if	O
(	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
0	int
]	O
)	O
==	O
NULL	O
||	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
0	int
]	O
->	O
swi_coM	array
[	O
0	int
]	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: currently,  only one (1) products/filesets.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
1	int
]	O
||	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
0	int
]	O
->	O
swi_coM	array
[	O
1	int
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: currently, multiple products/filesets not yet supported\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
return	O
;	O
}	O
int	O
swpl_does_have_prod_postinstall	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
int	O
ret	pointer
;	O
SWI_PRODUCT	struct
*	O
prod	pointer
;	O
prod	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
0	int
)	O
;	O
ret	pointer
=	O
swi_product_has_control_file	function
(	O
prod	pointer
,	O
SW_A_postinstall	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_get_fileset_file_count	function
(	O
SWHEADER	struct
*	O
infoheader	pointer
)	O
{	O
int	O
count	int
=	O
0	int
;	O
char	O
*	O
next_line	pointer
;	O
swheader_reset	function
(	O
infoheader	pointer
)	O
;	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
infoheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
while	O
(	O
next_line	pointer
)	O
{	O
count	int
++	O
;	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
infoheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
return	O
count	int
++	O
;	O
}	O
int	O
swpl_write_out_signature_member	function
(	O
SWI	struct
*	O
swi	pointer
,	O
struct	O
tar_header	struct
*	O
ptar_hdr	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
ofd	int
,	O
int	O
signum	int
,	O
int	O
*	O
package_ret	pointer
,	O
char	O
*	O
installer_sig	pointer
)	O
{	O
int	O
ifd	int
;	O
XFORMAT	struct
*	O
xformat	pointer
=	O
swi	pointer
->	O
xformatM	pointer
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
ret	pointer
;	O
unsigned	O
long	O
filesize	long
;	O
unsigned	O
long	O
package_filesize	long
;	O
char	O
*	O
sig	pointer
;	O
int	O
siglen	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
ETAR	struct
*	O
etar	pointer
;	O
ifd	int
=	O
xformat_get_ifd	function
(	O
xformat	pointer
)	O
;	O
etar	pointer
=	O
etar_open	function
(	O
swi	pointer
->	O
xformatM	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
)	O
;	O
etar_init_hdr	function
(	O
etar	pointer
)	O
;	O
swpl_init_header_root	function
(	O
etar	pointer
)	O
;	O
ret	pointer
=	O
uxfio_read	function
(	O
ifd	int
,	O
(	O
void	O
*	O
)	O
(	O
ptar_hdr	pointer
)	O
,	O
TARRECORDSIZE	int
)	O
;	O
if	O
(	O
ret	pointer
!=	O
TARRECORDSIZE	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
if	O
(	O
installer_sig	pointer
&&	O
strlen	function
(	O
installer_sig	pointer
)	O
)	O
{	O
ret	pointer
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
-	O
TARRECORDSIZE	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
}	O
taru_otoul	function
(	O
ptar_hdr	pointer
->	O
size	long
,	O
&	O
filesize	long
)	O
;	O
package_filesize	long
=	O
filesize	long
+	O
TARRECORDSIZE	int
;	O
*	O
package_ret	pointer
=	O
package_filesize	long
;	O
if	O
(	O
filesize	long
!=	O
512	int
&&	O
filesize	long
!=	O
1024	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"filesize=%d\n"	pointer
,	O
(	O
int	O
)	O
filesize	long
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
sig	pointer
=	O
malloc	function
(	O
(	O
size_t	long
)	O
filesize	long
)	O
;	O
if	O
(	O
!	O
sig	pointer
)	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
if	O
(	O
installer_sig	pointer
&&	O
strlen	function
(	O
installer_sig	pointer
)	O
)	O
{	O
memset	function
(	O
sig	pointer
,	O
(	O
int	O
)	O
'\n'	O
,	O
(	O
size_t	long
)	O
filesize	long
)	O
;	O
memcpy	function
(	O
sig	pointer
,	O
installer_sig	pointer
,	O
strlen	function
(	O
installer_sig	pointer
)	O
)	O
;	O
}	O
else	O
{	O
ret	pointer
=	O
uxfio_read	function
(	O
ifd	int
,	O
(	O
void	O
*	O
)	O
(	O
sig	pointer
)	O
,	O
(	O
size_t	long
)	O
filesize	long
)	O
;	O
if	O
(	O
(	O
int	O
)	O
ret	pointer
!=	O
(	O
int	O
)	O
filesize	long
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
}	O
sig	pointer
[	O
filesize	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
siglen	int
=	O
strlen	function
(	O
sig	pointer
)	O
;	O
etar_set_size	function
(	O
etar	pointer
,	O
siglen	int
)	O
;	O
swpl_set_detected_catalog_perms	function
(	O
swi	pointer
,	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
SWINSTALL_INCAT_NAME	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
tmp	pointer
,	O
SWINSTALL_CATALOG_TAR	pointer
)	O
;	O
swlib_squash_all_leading_slash	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
signum	int
<=	O
1	int
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
".sig"	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
".sig%d"	pointer
,	O
signum	int
)	O
;	O
}	O
if	O
(	O
etar_set_pathname	function
(	O
etar	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
)	O
SWLIB_FATAL	O
(	O
"name too long"	pointer
)	O
;	O
etar_set_chksum	function
(	O
etar	pointer
)	O
;	O
ret	pointer
=	O
uxfio_unix_safe_write	function
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
etar_get_hdr	function
(	O
etar	pointer
)	O
)	O
,	O
TARRECORDSIZE	int
)	O
;	O
if	O
(	O
ret	pointer
!=	O
TARRECORDSIZE	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
retval	int
+=	O
ret	pointer
;	O
if	O
(	O
siglen	int
<=	O
512	int
)	O
filesize	long
=	O
512	int
;	O
else	O
if	O
(	O
siglen	int
<=	O
1024	int
)	O
filesize	long
=	O
1024	int
;	O
else	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
ret	pointer
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
sig	pointer
)	O
,	O
filesize	long
)	O
;	O
if	O
(	O
ret	pointer
!=	O
(	O
int	O
)	O
filesize	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_write_out_signature_member(): ret=%d filesize=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
,	O
(	O
int	O
)	O
filesize	long
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_write_out_signature_member(): %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
retval	int
+=	O
ret	pointer
;	O
etar_close	function
(	O
etar	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
free	function
(	O
sig	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_write_out_all_signatures	function
(	O
SWI	struct
*	O
swi	pointer
,	O
struct	O
tar_header	struct
*	O
ptar_hdr	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
ofd	int
,	O
int	O
startoffset	int
,	O
int	O
endoffset	int
,	O
unsigned	O
long	O
filesize	long
)	O
{	O
int	O
curpos	int
;	O
int	O
ifd	int
;	O
int	O
ret	pointer
=	O
0	int
;	O
int	O
sig_number	int
;	O
int	O
current	pointer
=	O
0	int
;	O
int	O
package_current	int
=	O
0	int
;	O
int	O
package_ret	pointer
=	O
0	int
;	O
int	O
sig_block_length	int
=	O
endoffset	int
-	O
startoffset	int
;	O
XFORMAT	struct
*	O
xformat	pointer
=	O
swi	pointer
->	O
xformatM	pointer
;	O
ifd	int
=	O
xformat_get_ifd	function
(	O
xformat	pointer
)	O
;	O
curpos	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
0L	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
curpos	int
<	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
if	O
(	O
sig_block_length	int
<	O
1024	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
uxfio_lseek	function
(	O
ifd	int
,	O
startoffset	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
sig_number	int
=	O
sig_block_length	int
/	O
(	O
int	O
)	O
(	O
filesize	long
+	O
TARRECORDSIZE	int
)	O
;	O
if	O
(	O
sig_block_length	int
%	O
(	O
int	O
)	O
(	O
filesize	long
+	O
TARRECORDSIZE	int
)	O
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installer_sigM	pointer
&&	O
sig_number	int
>=	O
1	int
)	O
{	O
sig_number	int
++	O
;	O
ret	pointer
=	O
swpl_write_out_signature_member	function
(	O
swi	pointer
,	O
ptar_hdr	pointer
,	O
file_hdr	pointer
,	O
ofd	int
,	O
sig_number	int
--	O
,	O
&	O
package_ret	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installer_sigM	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
return	O
ret	pointer
;	O
}	O
current	pointer
+=	O
ret	pointer
;	O
}	O
while	O
(	O
package_current	int
<	O
sig_block_length	int
)	O
{	O
if	O
(	O
sig_number	int
<=	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
ret	pointer
=	O
swpl_write_out_signature_member	function
(	O
swi	pointer
,	O
ptar_hdr	pointer
,	O
file_hdr	pointer
,	O
ofd	int
,	O
sig_number	int
--	O
,	O
&	O
package_ret	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
return	O
ret	pointer
;	O
}	O
package_current	int
+=	O
package_ret	pointer
;	O
current	pointer
+=	O
ret	pointer
;	O
}	O
if	O
(	O
uxfio_lseek	function
(	O
ifd	int
,	O
curpos	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
return	O
current	pointer
;	O
}	O
int	O
swpl_write_catalog_data	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
int	O
sig_block_start	pointer
,	O
int	O
sig_block_end	pointer
)	O
{	O
int	O
curpos	int
;	O
int	O
ifd	int
;	O
int	O
iend	int
;	O
int	O
amount	long
;	O
XFORMAT	struct
*	O
xformat	pointer
=	O
swi	pointer
->	O
xformatM	pointer
;	O
SWI_PACKAGE	struct
*	O
package	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
;	O
int	O
retval	int
;	O
int	O
ret	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
ifd	int
=	O
xformat_get_ifd	function
(	O
xformat	pointer
)	O
;	O
curpos	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
0L	int
,	O
SEEK_CUR	int
)	O
;	O
E_DEBUG2	O
(	O
"current position = [%d]"	pointer
,	O
curpos	int
)	O
;	O
if	O
(	O
curpos	int
<	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"ifd=%d"	pointer
,	O
ifd	int
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
ifd	int
,	O
package	pointer
->	O
catalog_start_offsetM	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
sig_block_start	pointer
>	O
0	int
)	O
{	O
iend	int
=	O
sig_block_start	pointer
;	O
}	O
else	O
{	O
iend	int
=	O
package	pointer
->	O
catalog_end_offsetM	int
;	O
}	O
amount	long
=	O
iend	int
-	O
package	pointer
->	O
catalog_start_offsetM	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"amount before signature [%d]"	pointer
,	O
amount	long
)	O
;	O
if	O
(	O
swlib_pump_amount	function
(	O
ofd	int
,	O
ifd	int
,	O
amount	long
)	O
!=	O
amount	long
)	O
{	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
retval	int
=	O
amount	long
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
sig_block_start	pointer
>	O
0	int
)	O
{	O
amount	long
=	O
sig_block_end	pointer
-	O
sig_block_start	pointer
;	O
if	O
(	O
uxfio_lseek	function
(	O
ifd	int
,	O
amount	long
,	O
SEEK_CUR	int
)	O
<	O
0	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
E_DEBUG2	O
(	O
"amount = sig_block_end - sig_block_start  [%d]"	pointer
,	O
amount	long
)	O
;	O
amount	long
=	O
package	pointer
->	O
catalog_end_offsetM	int
-	O
sig_block_end	pointer
;	O
if	O
(	O
swlib_pump_amount	function
(	O
ofd	int
,	O
ifd	int
,	O
amount	long
)	O
!=	O
amount	long
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"remaining after signature [%d]"	pointer
,	O
amount	long
)	O
;	O
retval	int
+=	O
amount	long
;	O
}	O
else	O
{	O
;	O
}	O
if	O
(	O
uxfio_lseek	function
(	O
ifd	int
,	O
curpos	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_fatal_error	O
(	O
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"retval before trailers [%d]"	pointer
,	O
retval	int
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
2	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_write_catalog_data(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
retval	int
+=	O
ret	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_send_abort	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
msgtag	pointer
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
ret	pointer
=	O
swpl_send_null_task	function
(	O
swicol	pointer
,	O
ofd	int
,	O
event_fd	int
,	O
msgtag	pointer
,	O
SW_ERROR	int
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_report_status	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
ret	pointer
=	O
swpl_send_null_task2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
event_fd	int
,	O
SWBIS_TS_report_status	pointer
,	O
"sw_retval=$rp_status"	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_send_success	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
msgtag	pointer
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
ret	pointer
=	O
swpl_send_null_task	function
(	O
swicol	pointer
,	O
ofd	int
,	O
event_fd	int
,	O
msgtag	pointer
,	O
SW_SUCCESS	int
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_send_nothing_and_wait	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
msgtag	pointer
,	O
int	O
tl	int
,	O
int	O
retcode	int
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"sw_retval=%d\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
,	O
retcode	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
"."	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
msgtag	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: send_nothing_and_wait(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
event_fd	int
,	O
tl	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
SWLIB_INTERNAL	O
(	O
""	pointer
)	O
;	O
}	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_send_signature_files	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
pax_read_command	pointer
,	O
int	O
alt_catalog_root	int
,	O
int	O
event_fd	int
,	O
struct	O
tar_header	struct
*	O
ptar_hdr	pointer
,	O
int	O
sig_block_start	pointer
,	O
int	O
sig_block_end	pointer
,	O
unsigned	O
long	O
filesize	long
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
int	O
padamount	int
;	O
int	O
stdin_file_size	long
;	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
sig_block_length	int
;	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
;	O
struct	O
tar_header	struct
*	O
tar_hdr	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
tar_hdr	pointer
=	O
(	O
struct	O
tar_header	struct
*	O
)	O
malloc	function
(	O
TARRECORDSIZE	int
+	O
1	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
file_hdr	pointer
=	O
taru_make_header	function
(	O
)	O
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
tar_hdr	pointer
,	O
(	O
void	O
*	O
)	O
ptar_hdr	pointer
,	O
TARRECORDSIZE	int
)	O
;	O
sig_block_length	int
=	O
sig_block_end	pointer
-	O
sig_block_start	pointer
;	O
stdin_file_size	long
=	O
sig_block_length	int
+	O
TARRECORDSIZE	int
+	O
TARRECORDSIZE	int
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installer_sigM	pointer
&&	O
strlen	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installer_sigM	pointer
)	O
)	O
{	O
stdin_file_size	long
+=	O
(	O
filesize	long
+	O
TARRECORDSIZE	int
)	O
;	O
}	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"cd \"%s\"\n"	pointer
"case \"$?\" in\n"	pointer
"	0)\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"	echo error: cd \"%s\" failed in routine \"%s\" 1>&2\n"	pointer
"	exit 1\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
,	O
catalog_path	pointer
,	O
catalog_path	pointer
,	O
"__send_signature_files"	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"dd 2>/dev/null | %s\n"	pointer
"sw_retval=$?\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
,	O
pax_read_command	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
stdin_file_size	long
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_Load_signatures	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
swpl_write_out_all_signatures	function
(	O
swi	pointer
,	O
tar_hdr	pointer
,	O
file_hdr	pointer
,	O
ofd	int
,	O
sig_block_start	pointer
,	O
sig_block_end	pointer
,	O
filesize	long
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ret	pointer
>	O
(	O
stdin_file_size	long
-	O
TARRECORDSIZE	int
-	O
TARRECORDSIZE	int
)	O
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
padamount	int
=	O
stdin_file_size	long
-	O
ret	pointer
;	O
ret	pointer
=	O
swlib_pad_amount	function
(	O
ofd	int
,	O
padamount	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
||	O
ret	pointer
!=	O
padamount	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
event_fd	int
,	O
SWICOL_TL_12	int
)	O
;	O
if	O
(	O
swi	pointer
->	O
debug_eventsM	int
)	O
swicol_show_events_to_fd	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
STDERR_FILENO	int
,	O
-	O
1	int
)	O
;	O
}	O
taru_free_header	function
(	O
file_hdr	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
free	function
(	O
tar_hdr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_common_catalog_tarfile_operation	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
pax_read_command	pointer
,	O
int	O
alt_catalog_root	int
,	O
int	O
event_fd	int
,	O
char	O
*	O
script	pointer
,	O
char	O
*	O
id_str	pointer
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
STROB	struct
*	O
script_buf	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
script_buf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"cd \"%s\"\n"	pointer
"case \"$?\" in\n"	pointer
"	0)\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"	echo error: cd \"%s\" failed for task \"%s\" 1>&2\n"	pointer
"	exit 1\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
,	O
catalog_path	pointer
,	O
catalog_path	pointer
,	O
id_str	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\n%s\n"	pointer
,	O
script	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
512	int
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
strob_str	function
(	O
script_buf	pointer
)	O
,	O
id_str	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_common_catalog_tarfile_operation(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
event_fd	int
,	O
SWICOL_TL_12	int
)	O
;	O
if	O
(	O
swi	pointer
->	O
debug_eventsM	int
)	O
swicol_show_events_to_fd	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
STDERR_FILENO	int
,	O
-	O
1	int
)	O
;	O
}	O
strob_close	function
(	O
script_buf	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
void	O
swpl_update_state_by_cisf_base	function
(	O
CISF_BASE	struct
*	O
cfb	pointer
,	O
char	O
*	O
state	pointer
)	O
{	O
time	struct
(	O
&	O
(	O
cfb	pointer
->	O
ixfileM	pointer
->	O
baseM	struct
.	O
mod_timeM	long
)	O
)	O
;	O
swi_xfile_set_state	function
(	O
cfb	pointer
->	O
ixfileM	pointer
,	O
state	pointer
)	O
;	O
}	O
void	O
swpl_update_fileset_state	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
swsel	pointer
,	O
char	O
*	O
state	pointer
)	O
{	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
int	O
fileset_index	int
=	O
0	int
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
0	int
)	O
;	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
fileset_index	int
++	O
)	O
;	O
while	O
(	O
fileset	pointer
)	O
{	O
swi_xfile_set_state	function
(	O
fileset	pointer
,	O
state	pointer
)	O
;	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
fileset_index	int
++	O
)	O
;	O
}	O
}	O
void	O
swpl2_update_fileset_state	function
(	O
CISF_BASE	struct
*	O
cisf_base	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
,	O
int	O
status	int
)	O
{	O
SWI_XFILE	struct
*	O
xfile	pointer
;	O
char	O
*	O
script_tag	pointer
;	O
if	O
(	O
cisf_base	pointer
->	O
typeidM	int
==	O
CISF_ID_PRODUCT	O
)	O
{	O
return	O
;	O
}	O
xfile	pointer
=	O
cisf_base	pointer
->	O
ixfileM	pointer
;	O
script_tag	pointer
=	O
script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
;	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_configure	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
status	int
==	O
0	int
)	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_CONFIGURED	pointer
)	O
;	O
else	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_CORRUPT	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_postinstall	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
status	int
==	O
0	int
)	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_INSTALLED	pointer
)	O
;	O
else	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_CORRUPT	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_preinstall	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_preremove	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
status	int
==	O
0	int
)	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_TRANSIENT	pointer
)	O
;	O
else	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_CORRUPT	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
script_tag	pointer
,	O
SW_A_unconfigure	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
status	int
==	O
0	int
)	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_INSTALLED	pointer
)	O
;	O
else	O
swpl_update_state_by_cisf_base	function
(	O
cisf_base	pointer
,	O
SW_STATE_CORRUPT	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"bad script tag in swpl2_update_fileset_state\n"	pointer
)	O
;	O
}	O
}	O
int	O
swpl2_update_execution_script_results	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
CISF_PRODUCT	struct
*	O
cisf	pointer
)	O
{	O
char	O
*	O
ununtag	pointer
;	O
STROB	struct
*	O
buf	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
ununscript	pointer
;	O
CISF_BASE	struct
*	O
cisf_base	pointer
;	O
int	O
event_index	int
=	O
-	O
1	int
;	O
int	O
event_start_index	int
;	O
int	O
status	int
;	O
int	O
script_id	int
;	O
int	O
result	pointer
;	O
char	O
*	O
message	pointer
;	O
char	O
*	O
id_msg	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
num_processed	int
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
num_processed	int
=	O
0	int
;	O
buf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
event_start_index	int
=	O
0	int
;	O
message	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
event_start_index	int
,	O
&	O
event_index	int
)	O
;	O
event_index	int
++	O
;	O
while	O
(	O
message	pointer
)	O
{	O
E_DEBUG2	O
(	O
"message=%s"	pointer
,	O
message	pointer
)	O
;	O
id_msg	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
SWI_MSG	int
,	O
event_index	int
,	O
&	O
event_index	int
)	O
;	O
SWLIB_ASSERT	O
(	O
id_msg	pointer
!=	O
NULL	O
)	O
;	O
s	pointer
=	O
strstr	function
(	O
id_msg	pointer
,	O
SW_A_SCRIPT_ID	pointer
"="	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
s	pointer
+=	O
strlen	function
(	O
SW_A_SCRIPT_ID	pointer
"="	pointer
)	O
;	O
script_id	int
=	O
swlib_atoi	function
(	O
s	pointer
,	O
&	O
result	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
result	pointer
==	O
0	int
)	O
;	O
E_DEBUG2	O
(	O
"Looking for script id [%d]\n"	pointer
,	O
script_id	int
)	O
;	O
script	pointer
=	O
swpl2_find_by_id	function
(	O
script_id	int
,	O
cisf	pointer
->	O
cbaM	pointer
,	O
&	O
cisf_base	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
script	pointer
!=	O
NULL	O
)	O
;	O
E_DEBUG2	O
(	O
"Found script id [%d]\n"	pointer
,	O
script_id	int
)	O
;	O
status	int
=	O
swicol_rpsh_get_event_status	function
(	O
swicol	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
SW_CONTROL_SCRIPT_ENDS	int
,	O
event_index	int
,	O
&	O
event_index	int
)	O
;	O
SWLIB_ASSERT	O
(	O
status	int
>=	O
0	int
)	O
;	O
if	O
(	O
cisf_base	pointer
&&	O
script	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
,	O
SW_A_unconfigure	pointer
)	O
==	O
0	int
)	O
{	O
ununtag	pointer
=	O
SW_A_configure	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
,	O
SW_A_unpostinstall	pointer
)	O
==	O
0	int
)	O
{	O
ununtag	pointer
=	O
SW_A_postinstall	pointer
;	O
}	O
else	O
{	O
ununtag	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
ununtag	pointer
)	O
{	O
ununscript	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
cisf_base	pointer
->	O
ixfileM	pointer
,	O
ununtag	pointer
)	O
;	O
if	O
(	O
ununscript	pointer
)	O
{	O
ununscript	pointer
->	O
resultM	int
=	O
SWI_RESULT_UNDEFINED	O
;	O
}	O
}	O
}	O
script	pointer
->	O
resultM	int
=	O
status	int
;	O
num_processed	int
++	O
;	O
swpl2_update_fileset_state	function
(	O
cisf_base	pointer
,	O
script	pointer
,	O
status	int
)	O
;	O
E_DEBUG2	O
(	O
"script result=%d"	pointer
,	O
status	int
)	O
;	O
message	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
event_index	int
+	O
1	int
,	O
&	O
event_index	int
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
num_processed	int
;	O
}	O
int	O
swpl2_normalize_configure_script_results	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
script_name	pointer
,	O
CISF_PRODUCT	struct
*	O
cisf	pointer
)	O
{	O
int	O
i	int
;	O
int	O
product_result	int
;	O
CISF_BASE	struct
*	O
base	int
;	O
SWI_CONTROL_SCRIPT	struct
*	O
product_script	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
;	O
SWI_XFILE	struct
*	O
xfile	pointer
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
i	int
=	O
0	int
;	O
base	int
=	O
swpl2_cisf_base_array_get	function
(	O
cisf	pointer
,	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
base	int
||	O
base	int
->	O
typeidM	int
!=	O
CISF_ID_PRODUCT	O
)	O
{	O
E_DEBUG	O
(	O
"error 1"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
xfile	pointer
=	O
base	int
->	O
ixfileM	pointer
;	O
product_script	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
xfile	pointer
,	O
script_name	pointer
)	O
;	O
if	O
(	O
!	O
product_script	pointer
)	O
{	O
E_DEBUG	O
(	O
"returning 0"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
product_result	int
=	O
product_script	pointer
->	O
resultM	int
;	O
E_DEBUG2	O
(	O
"product_result=%d"	pointer
,	O
product_result	int
)	O
;	O
while	O
(	O
(	O
base	int
=	O
swpl2_cisf_base_array_get	function
(	O
cisf	pointer
,	O
i	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"GOT fileset"	pointer
)	O
;	O
if	O
(	O
base	int
->	O
typeidM	int
==	O
CISF_ID_PRODUCT	O
)	O
{	O
E_DEBUG	O
(	O
"error 2"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
else	O
if	O
(	O
base	int
->	O
typeidM	int
==	O
CISF_ID_FILESET	O
)	O
{	O
xfile	pointer
=	O
base	int
->	O
ixfileM	pointer
;	O
if	O
(	O
!	O
xfile	pointer
)	O
{	O
E_DEBUG	O
(	O
"error 4"	pointer
)	O
;	O
return	O
4	int
;	O
}	O
script	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
xfile	pointer
,	O
script_name	pointer
)	O
;	O
if	O
(	O
script	pointer
==	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"updating fileset result to product_result=%d"	pointer
,	O
product_result	int
)	O
;	O
swpl2_update_fileset_state	function
(	O
base	int
,	O
product_script	pointer
,	O
product_result	int
)	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"error 3"	pointer
)	O
;	O
return	O
3	int
;	O
}	O
i	int
++	O
;	O
}	O
E_DEBUG2	O
(	O
"Leaving i=%d"	pointer
,	O
i	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_update_execution_script_results	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
SCAR	struct
*	O
*	O
array	pointer
)	O
{	O
STROB	struct
*	O
buf	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
;	O
int	O
event_index	int
=	O
-	O
1	int
;	O
int	O
event_start_index	int
;	O
int	O
status	int
;	O
char	O
*	O
savechp	pointer
;	O
char	O
*	O
tag	pointer
;	O
char	O
*	O
tagspec	pointer
;	O
char	O
*	O
message	pointer
;	O
char	O
*	O
id_msg	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
buf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
event_start_index	int
=	O
0	int
;	O
E_DEBUG2	O
(	O
"event_start_index=%d"	pointer
,	O
event_start_index	int
)	O
;	O
message	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
event_start_index	int
,	O
&	O
event_index	int
)	O
;	O
event_index	int
++	O
;	O
while	O
(	O
message	pointer
)	O
{	O
E_DEBUG2	O
(	O
"message=%s"	pointer
,	O
message	pointer
)	O
;	O
tagspec	pointer
=	O
message	pointer
;	O
tag	pointer
=	O
strchr	function
(	O
message	pointer
,	O
(	O
int	O
)	O
(	O
' '	O
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
tag	pointer
!=	O
NULL	O
)	O
;	O
savechp	pointer
=	O
tag	pointer
;	O
*	O
tag	pointer
=	O
'\0'	O
;	O
tag	pointer
++	O
;	O
script	pointer
=	O
swpl_scary_find_script	function
(	O
array	pointer
,	O
tag	pointer
,	O
tagspec	pointer
)	O
;	O
E_DEBUG2	O
(	O
"script tag=%s"	pointer
,	O
tag	pointer
)	O
;	O
E_DEBUG2	O
(	O
"script tagspec=%s"	pointer
,	O
tagspec	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
script	pointer
!=	O
NULL	O
)	O
;	O
id_msg	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
SWI_MSG	int
,	O
event_index	int
,	O
&	O
event_index	int
)	O
;	O
status	int
=	O
swicol_rpsh_get_event_status	function
(	O
swicol	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
SW_CONTROL_SCRIPT_ENDS	int
,	O
event_index	int
,	O
&	O
event_index	int
)	O
;	O
SWLIB_ASSERT	O
(	O
status	int
>=	O
0	int
)	O
;	O
script	pointer
->	O
resultM	int
=	O
status	int
;	O
E_DEBUG2	O
(	O
"script result=%d"	pointer
,	O
status	int
)	O
;	O
message	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
event_index	int
+	O
1	int
,	O
&	O
event_index	int
)	O
;	O
*	O
savechp	pointer
=	O
(	O
int	O
)	O
(	O
' '	O
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_unpack_catalog_tarfile	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
pax_read_command	pointer
,	O
int	O
alt_catalog_root	int
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
tmpv	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmpv	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
G	pointer
->	O
g_verboseG	int
>=	O
SWC_VERBOSE_6	int
)	O
{	O
strob_strcpy	function
(	O
tmpv	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmpv	pointer
,	O
0	int
,	O
"1>/dev/null"	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
CSHID	O
"#set -vx\n"	pointer
"# echo unpacking catalog %s 1>&2\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
"# pwd 1>&2\n"	pointer
"cd  "	pointer
SWINSTALL_INCAT_NAME	pointer
" || exit 1\n"	pointer
"%s %s <catalog.tar %s\n"	pointer
"sw_retval=$?\n"	pointer
,	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
,	O
pax_read_command	pointer
,	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
,	O
strob_str	function
(	O
tmpv	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swpl_common_catalog_tarfile_operation	function
(	O
swi	pointer
,	O
ofd	int
,	O
catalog_path	pointer
,	O
pax_read_command	pointer
,	O
alt_catalog_root	int
,	O
event_fd	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_Catalog_unpack	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmpv	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_remove_catalog_directory	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
catalog_path	pointer
,	O
char	O
*	O
pax_read_command	pointer
,	O
int	O
alt_catalog_root	int
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	pointer
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
path	pointer
;	O
STROB	struct
*	O
tmptok	pointer
;	O
STROB	struct
*	O
rmdir_command	pointer
;	O
char	O
*	O
token	pointer
;	O
char	O
*	O
start	int
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
path	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmptok	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
rmdir_command	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_strcpy	function
(	O
path	pointer
,	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
)	O
;	O
if	O
(	O
swlib_check_clean_relative_path	function
(	O
strob_str	function
(	O
path	pointer
)	O
)	O
)	O
return	O
1	int
;	O
swlib_squash_trailing_slash	function
(	O
strob_str	function
(	O
path	pointer
)	O
)	O
;	O
if	O
(	O
strstr	function
(	O
strob_str	function
(	O
path	pointer
)	O
,	O
SW_A_catalog	pointer
)	O
==	O
NULL	O
)	O
return	O
2	int
;	O
strob_strcpy	function
(	O
rmdir_command	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
strchr	function
(	O
strob_str	function
(	O
path	pointer
)	O
,	O
'/'	O
)	O
)	O
{	O
start	int
=	O
strob_str	function
(	O
path	pointer
)	O
;	O
token	pointer
=	O
strrchr	function
(	O
start	int
,	O
'/'	O
)	O
;	O
while	O
(	O
token	pointer
)	O
{	O
*	O
token	pointer
=	O
'\0'	O
;	O
strob_sprintf	function
(	O
rmdir_command	pointer
,	O
1	int
,	O
" && rmdir \"%s\""	pointer
,	O
start	int
)	O
;	O
token	pointer
=	O
strrchr	function
(	O
start	int
,	O
'/'	O
)	O
;	O
}	O
}	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
CSHID	O
"cd "	pointer
SWINSTALL_INCAT_NAME	pointer
" || exit 1\n"	pointer
"/bin/rm -fr \"%s\" %s\n"	pointer
"sw_retval=$?\n"	pointer
"#echo rmdir command is [\"%s\"] 1>&2\n"	pointer
"#echo rm command is [\"%s\"] 1>&2\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
,	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
,	O
strob_str	function
(	O
rmdir_command	pointer
)	O
,	O
strob_str	function
(	O
rmdir_command	pointer
)	O
,	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
)	O
;	O
ret	pointer
=	O
swpl_common_catalog_tarfile_operation	function
(	O
swi	pointer
,	O
ofd	int
,	O
catalog_path	pointer
,	O
pax_read_command	pointer
,	O
alt_catalog_root	int
,	O
event_fd	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_Catalog_dir_remove	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
path	pointer
)	O
;	O
strob_close	function
(	O
rmdir_command	pointer
)	O
;	O
strob_close	function
(	O
tmptok	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_get_utsname_attributes	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
SWUTS	struct
*	O
uts	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
STROB	struct
*	O
tmp1	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
CSHID	O
"sw_retval=0\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
"exit $sw_retval\n"	pointer
"%s"	pointer
,	O
shlib_get_function_text_by_name	function
(	O
"shls_config_guess"	pointer
,	O
tmp1	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_run_config_guess"	pointer
,	O
tmp1	pointer
,	O
NULL	O
)	O
,	O
TEVENT	O
(	O
2	int
,	O
1	int
,	O
SWI_ATTRIBUTE	int
,	O
SW_A_machine_type	pointer
"=\"$(uname -m)\""	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
1	int
,	O
SWI_ATTRIBUTE	int
,	O
SW_A_os_name	pointer
"=\"$(uname -s)\""	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
1	int
,	O
SWI_ATTRIBUTE	int
,	O
SW_A_os_release	pointer
"=\"$(uname -r)\""	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
1	int
,	O
SWI_ATTRIBUTE	int
,	O
SW_A_os_version	pointer
"=\"$(uname -v)\""	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
1	int
,	O
SWI_ATTRIBUTE	int
,	O
SW_A_architecture	pointer
"=\"$(shls_run_config_guess)\""	pointer
)	O
,	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
"."	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_uts	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swpl_get_utsname_attributes(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
event_fd	int
,	O
SWICOL_TL_100	int
)	O
;	O
swicol_print_events	function
(	O
swicol	pointer
,	O
tmp	pointer
,	O
swicol	pointer
->	O
event_indexM	int
)	O
;	O
swuts_read_from_events	function
(	O
uts	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"utsname=[%s]"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
ret	pointer
==	O
2	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
1	int
,	O
(	O
struct	O
sw_logspec	struct
*	O
)	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"SW_RESOURCE_ERROR on target host:  %d second time limit expired\n"	pointer
,	O
5	int
)	O
;	O
}	O
ret	pointer
=	O
-	O
1	int
;	O
}	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmp1	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_get_catalog_perms	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	pointer
;	O
SWICOL	struct
*	O
swicol	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
swicol	pointer
=	O
swi	pointer
->	O
swicolM	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
CSHID	O
"sw_retval=0\n"	pointer
"ISC=\"%s\"\n"	pointer
"LSO=`tar chf - \"$ISC\" 2>/dev/null | tar tvf - 2>/dev/null | head -1`\n"	pointer
"%s\n"	pointer
"dd of=/dev/null 2>/dev/null\n"	pointer
"exit $sw_retval\n"	pointer
"%s"	pointer
,	O
get_opta_isc	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_installed_software_catalog	int
)	O
,	O
TEVENT	O
(	O
2	int
,	O
1	int
,	O
SWI_ATTRIBUTE	int
,	O
"ls_ld=\"$LSO\""	pointer
)	O
,	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_get_catalog_perms	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: get_catalog_perms(): etar_write_trailer_blocks(): ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
event_fd	int
,	O
SWICOL_TL_100	int
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
swicol_print_events	function
(	O
swicol	pointer
,	O
tmp	pointer
,	O
swicol	pointer
->	O
event_indexM	int
)	O
;	O
ret	pointer
=	O
parse_ls_ld_output	function
(	O
swi	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_ownerM	pointer
=	O
strdup	function
(	O
"root"	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_groupM	pointer
=	O
strdup	function
(	O
"root"	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_catalog_modeM	int
=	O
0755	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: (swpl_get_catalog_perms) parsing (retrieval) of tar listing failed: ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: root/root (0755) will be used for catalog ownerships\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
}	O
else	O
{	O
ret	pointer
=	O
-	O
3	int
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swpl_determine_tar_listing_verbose_level	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
int	O
taru_ls_verbose_level	int
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
if	O
(	O
swi	pointer
->	O
swc_idM	int
==	O
SWC_U_I	O
)	O
{	O
if	O
(	O
swi	pointer
->	O
verboseM	int
>=	O
SWC_VERBOSE_3	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_ls_verbose_level	int
=	O
LS_LIST_VERBOSE_L1	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_ls_verbose_level	int
=	O
LS_LIST_VERBOSE_L0	O
;	O
}	O
}	O
else	O
if	O
(	O
swi	pointer
->	O
swc_idM	int
==	O
SWC_U_L	O
)	O
{	O
if	O
(	O
swi	pointer
->	O
verboseM	int
>=	O
SWC_VERBOSE_2	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_ls_verbose_level	int
=	O
LS_LIST_VERBOSE_L1	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_ls_verbose_level	int
=	O
LS_LIST_VERBOSE_L0	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_ls_verbose_level	int
=	O
LS_LIST_VERBOSE_L0	O
;	O
}	O
E_DEBUG2	O
(	O
"[%d]"	pointer
,	O
taru_ls_verbose_level	int
)	O
;	O
return	O
taru_ls_verbose_level	int
;	O
}	O
int	O
swpl_assert_all_file_definitions_installed	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWHEADER	struct
*	O
infoheader	pointer
)	O
{	O
int	O
ret	pointer
;	O
char	O
*	O
next_line	pointer
;	O
char	O
*	O
keyword	pointer
;	O
char	O
*	O
missing_name	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
swheader_store_state	function
(	O
infoheader	pointer
,	O
NULL	O
)	O
;	O
swheader_reset	function
(	O
infoheader	pointer
)	O
;	O
while	O
(	O
(	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
infoheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
)	O
)	O
{	O
keyword	pointer
=	O
swheaderline_get_keyword	function
(	O
next_line	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
keyword	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
keyword	pointer
,	O
SW_A_control_file	pointer
)	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
swheaderline_get_flag1	function
(	O
next_line	pointer
)	O
==	O
0	int
)	O
{	O
missing_name	pointer
=	O
swpl_get_attribute	function
(	O
infoheader	pointer
,	O
SW_A_path	pointer
,	O
NULL	O
)	O
;	O
swlib_doif_writef	O
(	O
swi	pointer
->	O
verboseM	int
,	O
SWC_VERBOSE_1	int
,	O
(	O
struct	O
sw_logspec	struct
*	O
)	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"warning: missing from storage section: %s\n"	pointer
,	O
missing_name	pointer
)	O
;	O
ret	pointer
++	O
;	O
}	O
}	O
swheader_restore_state	function
(	O
infoheader	pointer
,	O
NULL	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
VPLOB	union
*	O
swpl_get_same_revision_specs	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
product_number	int
,	O
char	O
*	O
location	pointer
)	O
{	O
char	O
*	O
revision	pointer
;	O
char	O
*	O
tag	pointer
;	O
VPLOB	union
*	O
swspecs	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWHEADER	struct
*	O
global_index	pointer
;	O
SWVERID	struct
*	O
swverid	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
swspecs	pointer
=	O
vplob_open	function
(	O
)	O
;	O
if	O
(	O
location	pointer
&&	O
strlen	function
(	O
location	pointer
)	O
==	O
0	int
)	O
location	pointer
=	O
NULL	O
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_number	int
)	O
;	O
SWLIB_ASSERT	O
(	O
product	pointer
!=	O
NULL	O
)	O
;	O
global_index	pointer
=	O
swi_get_global_index_header	function
(	O
swi	pointer
)	O
;	O
swheader_store_state	function
(	O
global_index	pointer
,	O
NULL	O
)	O
;	O
swheader_reset	function
(	O
global_index	pointer
)	O
;	O
swheader_set_current_offset	function
(	O
global_index	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
header_indexM	int
)	O
;	O
tag	pointer
=	O
swheader_get_single_attribute_value	function
(	O
global_index	pointer
,	O
SW_A_tag	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
tag	pointer
!=	O
NULL	O
)	O
;	O
revision	pointer
=	O
swheader_get_single_attribute_value	function
(	O
global_index	pointer
,	O
SW_A_revision	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
revision	pointer
!=	O
NULL	O
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s,r<%s"	pointer
,	O
tag	pointer
,	O
revision	pointer
)	O
;	O
if	O
(	O
location	pointer
)	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
",l=%s"	pointer
,	O
location	pointer
)	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
vplob_add	function
(	O
swspecs	pointer
,	O
swverid	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s,r==%s"	pointer
,	O
tag	pointer
,	O
revision	pointer
)	O
;	O
if	O
(	O
location	pointer
)	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
",l=%s"	pointer
,	O
location	pointer
)	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
vplob_add	function
(	O
swspecs	pointer
,	O
swverid	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s,r>%s"	pointer
,	O
tag	pointer
,	O
revision	pointer
)	O
;	O
if	O
(	O
location	pointer
)	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
",l=%s"	pointer
,	O
location	pointer
)	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
vplob_add	function
(	O
swspecs	pointer
,	O
swverid	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s,r==%s"	pointer
,	O
tag	pointer
,	O
revision	pointer
)	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
vplob_add	function
(	O
swspecs	pointer
,	O
swverid	pointer
)	O
;	O
swheader_restore_state	function
(	O
global_index	pointer
,	O
NULL	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
swspecs	pointer
;	O
}	O
VPLOB	union
*	O
swpl_get_dependency_specs	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
requisite_keyword	pointer
,	O
int	O
product_number	int
,	O
int	O
fileset_number	int
)	O
{	O
char	O
*	O
depspec	pointer
;	O
char	O
*	O
value	int
;	O
VPLOB	union
*	O
swspecs	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
SWHEADER	struct
*	O
global_index	pointer
;	O
SWVERID	struct
*	O
swverid	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
tmp2	pointer
;	O
char	O
*	O
*	O
xlist	pointer
;	O
char	O
*	O
*	O
list	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmp2	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
swspecs	pointer
=	O
vplob_open	function
(	O
)	O
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_number	int
)	O
;	O
SWLIB_ASSERT	O
(	O
product	pointer
!=	O
NULL	O
)	O
;	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
fileset_number	int
)	O
;	O
SWLIB_ASSERT	O
(	O
fileset	pointer
!=	O
NULL	O
)	O
;	O
global_index	pointer
=	O
swi_get_global_index_header	function
(	O
swi	pointer
)	O
;	O
swheader_store_state	function
(	O
global_index	pointer
,	O
NULL	O
)	O
;	O
swheader_reset	function
(	O
global_index	pointer
)	O
;	O
swheader_set_current_offset	function
(	O
global_index	pointer
,	O
fileset	pointer
->	O
baseM	struct
.	O
header_indexM	int
)	O
;	O
xlist	pointer
=	O
swheader_get_attribute_list	function
(	O
global_index	pointer
,	O
requisite_keyword	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
list	pointer
=	O
xlist	pointer
;	O
while	O
(	O
*	O
list	pointer
)	O
{	O
value	int
=	O
swheaderline_get_value	function
(	O
*	O
list	pointer
,	O
NULL	O
)	O
;	O
swlib_expand_escapes	function
(	O
(	O
char	O
*	O
*	O
)	O
(	O
NULL	O
)	O
,	O
NULL	O
,	O
value	int
,	O
tmp	pointer
)	O
;	O
depspec	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
" \n\r\t"	pointer
)	O
;	O
while	O
(	O
depspec	pointer
)	O
{	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
depspec	pointer
)	O
;	O
if	O
(	O
swverid	pointer
==	O
NULL	O
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"error processing software spec: %s\n"	pointer
,	O
depspec	pointer
)	O
;	O
}	O
else	O
{	O
SWVERID	struct
*	O
next	pointer
;	O
next	pointer
=	O
swverid	pointer
;	O
vplob_add	function
(	O
swspecs	pointer
,	O
next	pointer
)	O
;	O
while	O
(	O
(	O
next	pointer
=	O
swverid_get_alternate	function
(	O
next	pointer
)	O
)	O
)	O
{	O
vplob_add	function
(	O
swspecs	pointer
,	O
next	pointer
)	O
;	O
}	O
swverid_disconnect_alternates	function
(	O
swverid	pointer
)	O
;	O
}	O
depspec	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
" \n\r\t"	pointer
)	O
;	O
}	O
list	pointer
++	O
;	O
}	O
free	function
(	O
xlist	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
swheader_restore_state	function
(	O
global_index	pointer
,	O
NULL	O
)	O
;	O
return	O
swspecs	pointer
;	O
}	O
int	O
swpl_get_catalog_entries	function
(	O
GB	struct
*	O
G	pointer
,	O
VPLOB	union
*	O
swspecs	pointer
,	O
VPLOB	union
*	O
pre_swspecs	pointer
,	O
VPLOB	union
*	O
co_swspecs	pointer
,	O
VPLOB	union
*	O
ex_swspecs	pointer
,	O
char	O
*	O
target_path	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
target_fd0	int
,	O
int	O
target_fd1	int
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
char	O
*	O
pgm_mode	pointer
)	O
{	O
STROB	struct
*	O
isc_script_buf	pointer
;	O
int	O
aa_fd	int
;	O
int	O
ret	pointer
;	O
int	O
retval	int
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
retval	int
=	O
0	int
;	O
isc_script_buf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
swpl_test_pgm_mode	function
(	O
pgm_mode	pointer
,	O
SWLIST_PMODE_PROD	pointer
)	O
==	O
0	int
)	O
{	O
swicat_write_isc_script	function
(	O
isc_script_buf	pointer
,	O
G	pointer
,	O
swspecs	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SWICAT_FORM_P1	pointer
)	O
;	O
}	O
else	O
if	O
(	O
swpl_test_pgm_mode	function
(	O
pgm_mode	pointer
,	O
SWLIST_PMODE_DIR	pointer
)	O
==	O
0	int
)	O
{	O
swicat_write_isc_script	function
(	O
isc_script_buf	pointer
,	O
G	pointer
,	O
swspecs	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SWICAT_FORM_DIR1	pointer
)	O
;	O
}	O
else	O
if	O
(	O
swpl_test_pgm_mode	function
(	O
pgm_mode	pointer
,	O
SWLIST_PMODE_DEP1	pointer
)	O
==	O
0	int
)	O
{	O
swicat_write_isc_script	function
(	O
isc_script_buf	pointer
,	O
G	pointer
,	O
NULL	O
,	O
pre_swspecs	pointer
,	O
NULL	O
,	O
ex_swspecs	pointer
,	O
SWICAT_FORM_DEP1	pointer
)	O
;	O
}	O
else	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"bad internal mode: %s\n"	pointer
,	O
pgm_mode	pointer
)	O
;	O
swicat_write_isc_script	function
(	O
isc_script_buf	pointer
,	O
G	pointer
,	O
NULL	O
,	O
pre_swspecs	pointer
,	O
NULL	O
,	O
ex_swspecs	pointer
,	O
SWICAT_FORM_DEP1	pointer
)	O
;	O
}	O
swicol	pointer
->	O
needs_synct_eoaM	int
=	O
1	int
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
target_fd1	int
,	O
512	int
,	O
target_path	pointer
,	O
strob_str	function
(	O
isc_script_buf	pointer
)	O
,	O
SWBIS_TS_Get_iscs_listing	pointer
)	O
;	O
swicol	pointer
->	O
needs_synct_eoaM	int
=	O
0	int
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swicol_rpsh_task_send_script2 error\n"	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
target_fd1	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"etar_write_trailer_blocks error\n"	pointer
)	O
;	O
retval	int
=	O
-	O
2	int
;	O
return	O
retval	int
;	O
}	O
aa_fd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swlib_synct_suck	function
(	O
aa_fd	int
,	O
target_fd0	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
-	O
3	int
;	O
return	O
retval	int
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_30	int
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
SWLIB_INTERNAL	O
(	O
""	pointer
)	O
;	O
}	O
retval	int
=	O
-	O
4	int
;	O
sw_e_msg	function
(	O
G	pointer
,	O
"swicol_rpsh_task_expect failed: status=%d\n"	pointer
,	O
ret	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_lseek	function
(	O
aa_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
swicat_squash_null_bytes	function
(	O
aa_fd	int
)	O
;	O
uxfio_lseek	function
(	O
aa_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
retval	int
=	O
aa_fd	int
;	O
strob_close	function
(	O
isc_script_buf	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_do_list_catalog_entries2	function
(	O
GB	struct
*	O
G	pointer
,	O
VPLOB	union
*	O
swspecs	pointer
,	O
VPLOB	union
*	O
pre_swspecs	pointer
,	O
VPLOB	union
*	O
co_swspecs	pointer
,	O
VPLOB	union
*	O
ex_swspecs	pointer
,	O
char	O
*	O
target_path	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
target_fd0	int
,	O
int	O
target_fd1	int
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
char	O
*	O
pgm_mode	pointer
)	O
{	O
int	O
retval	int
;	O
int	O
memfd	int
;	O
char	O
*	O
memtext	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
retval	int
=	O
0	int
;	O
memfd	int
=	O
swpl_get_catalog_entries	function
(	O
G	pointer
,	O
swspecs	pointer
,	O
pre_swspecs	pointer
,	O
co_swspecs	pointer
,	O
ex_swspecs	pointer
,	O
target_path	pointer
,	O
swicol	pointer
,	O
target_fd0	int
,	O
target_fd1	int
,	O
opta	pointer
,	O
pgm_mode	pointer
)	O
;	O
if	O
(	O
memfd	int
<	O
0	int
)	O
return	O
memfd	int
;	O
uxfio_lseek	function
(	O
memfd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
swpl_test_pgm_mode	function
(	O
pgm_mode	pointer
,	O
SWLIST_PMODE_PROD	pointer
)	O
==	O
0	int
||	O
swpl_test_pgm_mode	function
(	O
pgm_mode	pointer
,	O
SWLIST_PMODE_DIR	pointer
)	O
==	O
0	int
||	O
G	pointer
->	O
g_verboseG	int
>=	O
SWC_VERBOSE_3	int
||	O
0	int
)	O
{	O
swlib_pipe_pump	function
(	O
STDOUT_FILENO	int
,	O
memfd	int
)	O
;	O
}	O
if	O
(	O
swpl_test_pgm_mode	function
(	O
pgm_mode	pointer
,	O
SWLIST_PMODE_DEP1	pointer
)	O
==	O
0	int
)	O
{	O
SWICAT_REQ	struct
*	O
req	pointer
;	O
int	O
ret	pointer
;	O
req	pointer
=	O
swicat_req_create	function
(	O
)	O
;	O
memtext	pointer
=	O
uxfio_get_fd_mem	function
(	O
memfd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
ret	pointer
=	O
swicat_req_analyze	function
(	O
G	pointer
,	O
req	pointer
,	O
memtext	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
||	O
ret	pointer
>	O
0	int
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"internal error analyzing dependencies, ret=%d\n"	pointer
,	O
ret	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
if	O
(	O
swicat_req_get_pre_result	function
(	O
req	pointer
)	O
!=	O
0	int
||	O
swicat_req_get_ex_result	function
(	O
req	pointer
)	O
!=	O
0	int
||	O
0	int
)	O
{	O
retval	int
=	O
1	int
;	O
swicat_req_print	function
(	O
G	pointer
,	O
req	pointer
)	O
;	O
}	O
swicat_req_delete	function
(	O
req	pointer
)	O
;	O
}	O
uxfio_close	function
(	O
memfd	int
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_test_pgm_mode	function
(	O
char	O
*	O
pgm_mode	pointer
,	O
char	O
*	O
test_mode	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
test_mode	pointer
,	O
pgm_mode	pointer
)	O
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
int	O
swpl_get_catalog_tar	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
target_path	pointer
,	O
VPLOB	union
*	O
upgrade_specs	pointer
,	O
int	O
target_fd0	int
,	O
int	O
target_fd1	int
)	O
{	O
char	O
*	O
path	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
oflags	int
;	O
SWVARFS	struct
*	O
swvarfs	pointer
;	O
STROB	struct
*	O
isc_script_buf	pointer
;	O
struct	O
extendedOptions	struct
*	O
opta	pointer
;	O
int	O
ret	pointer
;	O
int	O
cfd	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
opta	pointer
=	O
swi	pointer
->	O
optaM	pointer
;	O
isc_script_buf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swicat_write_isc_script	function
(	O
isc_script_buf	pointer
,	O
G	pointer
,	O
upgrade_specs	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SWICAT_FORM_TAR1	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
target_fd1	int
,	O
512	int
,	O
target_path	pointer
,	O
strob_str	function
(	O
isc_script_buf	pointer
)	O
,	O
SWBIS_TS_Get_iscs_entry	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swicol_set_master_alarm	function
(	O
swi	pointer
->	O
swicolM	pointer
)	O
;	O
}	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
target_fd1	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
cfd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
if	O
(	O
swicol_get_master_alarm_status	function
(	O
swi	pointer
->	O
swicolM	pointer
)	O
==	O
0	int
&&	O
ret	pointer
==	O
512	int
)	O
{	O
TARU	struct
*	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
taru_process_copy_out	function
(	O
taru	pointer
,	O
target_fd0	int
,	O
cfd	int
,	O
NULL	O
,	O
NULL	O
,	O
arf_ustar	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
(	O
intmax_t	long
*	O
)	O
NULL	O
,	O
NULL	O
)	O
;	O
taru_delete	function
(	O
taru	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_30	int
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
cfd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
-	O
3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
cfd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
-	O
4	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
cfd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
return	O
-	O
5	int
;	O
}	O
oflags	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swvarfs	pointer
=	O
swvarfs_opendup	function
(	O
cfd	int
,	O
oflags	int
,	O
(	O
mode_t	int
)	O
0	int
)	O
;	O
while	O
(	O
(	O
path	pointer
=	O
swvarfs_get_next_dirent	function
(	O
swvarfs	pointer
,	O
&	O
st	pointer
)	O
)	O
!=	O
NULL	O
&&	O
strlen	function
(	O
path	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
G	pointer
->	O
devel_verboseM	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"<debug>: path=[%s]\n"	pointer
,	O
path	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swvarfs_dirent_reset	function
(	O
swvarfs	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
(	O
path	pointer
=	O
swvarfs_get_next_dirent	function
(	O
swvarfs	pointer
,	O
&	O
st	pointer
)	O
)	O
!=	O
NULL	O
&&	O
strlen	function
(	O
path	pointer
)	O
)	O
{	O
if	O
(	O
G	pointer
->	O
devel_verboseM	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"<debug> path=[%s]\n"	pointer
,	O
path	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swvarfs_close	function
(	O
swvarfs	pointer
)	O
;	O
strob_close	function
(	O
isc_script_buf	pointer
)	O
;	O
E_DEBUG2	O
(	O
"returning %d"	pointer
,	O
cfd	int
)	O
;	O
return	O
cfd	int
;	O
}	O
void	O
swpl_tty_raw_ctl	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
c	int
)	O
{	O
static	O
int	O
g	int
=	O
0	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
g	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
1	int
)	O
{	O
g	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
g	int
)	O
{	O
g	int
=	O
0	int
;	O
if	O
(	O
swlib_tty_raw	function
(	O
STDIN_FILENO	int
)	O
<	O
0	int
)	O
sw_e_msg	function
(	O
G	pointer
,	O
"tty_raw error"	pointer
)	O
;	O
}	O
}	O
}	O
char	O
*	O
swpl_get_samepackage_query_response	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
target_path	pointer
,	O
int	O
target_fd0	int
,	O
int	O
target_fd1	int
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
VPLOB	union
*	O
packagespecs	pointer
,	O
int	O
*	O
p_retval	pointer
,	O
int	O
make_dummy_response	int
)	O
{	O
int	O
uxfio_fd	int
;	O
char	O
*	O
mem	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
E_DEBUG	O
(	O
"calling swpl_get_catalog_entries"	pointer
)	O
;	O
uxfio_fd	int
=	O
swpl_get_catalog_entries	function
(	O
G	pointer
,	O
(	O
VPLOB	union
*	O
)	O
NULL	O
,	O
packagespecs	pointer
,	O
(	O
VPLOB	union
*	O
)	O
NULL	O
,	O
(	O
VPLOB	union
*	O
)	O
NULL	O
,	O
target_path	pointer
,	O
swicol	pointer
,	O
target_fd0	int
,	O
target_fd1	int
,	O
opta	pointer
,	O
SWLIST_PMODE_DEP1	pointer
)	O
;	O
if	O
(	O
uxfio_fd	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
uxfio_fd	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
abort_script	function
(	O
swicol	pointer
,	O
G	pointer
,	O
target_fd1	int
)	O
;	O
(	O
*	O
p_retval	pointer
)	O
++	O
;	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swicat_squash_null_bytes	function
(	O
uxfio_fd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_lseek	function
(	O
uxfio_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
mem	pointer
=	O
swi_com_new_fd_mem	function
(	O
uxfio_fd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
0	int
&&	O
G	pointer
->	O
devel_verboseM	int
&&	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"[[%s]]\n"	pointer
,	O
mem	pointer
)	O
;	O
uxfio_close	function
(	O
uxfio_fd	int
)	O
;	O
E_DEBUG	O
(	O
"END"	pointer
)	O
;	O
return	O
mem	pointer
;	O
}	O
SWICAT_REQ	struct
*	O
swpl_analyze_samepackage_query_response	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
response_image	pointer
,	O
SWICAT_SL	struct
*	O
*	O
p_sl	pointer
)	O
{	O
int	O
ret	pointer
;	O
SWICAT_REQ	struct
*	O
req	pointer
;	O
SWICAT_SL	struct
*	O
sl	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
if	O
(	O
response_image	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
req	pointer
=	O
swicat_req_create	function
(	O
)	O
;	O
ret	pointer
=	O
swicat_req_analyze	function
(	O
G	pointer
,	O
req	pointer
,	O
response_image	pointer
,	O
p_sl	pointer
)	O
;	O
sl	pointer
=	O
*	O
p_sl	pointer
;	O
if	O
(	O
ret	pointer
<	O
0	int
||	O
ret	pointer
>	O
0	int
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"internal error from swicat_req_analyze, ret=%d\n"	pointer
,	O
ret	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
;	O
}	O
return	O
req	pointer
;	O
}	O
char	O
*	O
swpl_shellfrag_session_lock	function
(	O
STROB	struct
*	O
buf	pointer
,	O
int	O
vlv	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
0	int
,	O
CSHID	O
"#\n"	pointer
"#  <<<<----- here's the code to lock a session \n"	pointer
"#\n"	pointer
"lock_did_lock=\"\"\n"	pointer
"shls_bashin2 \""	pointer
SWBIS_TS_make_locked_session	pointer
"\"\n"	pointer
"sw_retval=$?\n"	pointer
" # sw_retval:\n"	pointer
" #   0: OK, proceed by invoking bash -s\n"	pointer
" #   1: Not OK, either commanded abort or internal error\n"	pointer
"lock_status=0\n"	pointer
"case $sw_retval in\n"	pointer
"	0) \n"	pointer
"	# Ok to make test for lock\n"	pointer
"	$sh_dash_s\n"	pointer
"	sw_retval=$?\n"	pointer
"	lock_status=$sw_retval\n"	pointer
"	;;\n"	pointer
"	# 2)  Dead Code, we never get here\n"	pointer
"	# sw_retval=1\n"	pointer
"	# opt_allow_no_lock=\"\"\n"	pointer
"	# lock_status=2\n"	pointer
"	# ;;\n"	pointer
"	*)\n"	pointer
"	sw_retval=1\n"	pointer
"	opt_allow_no_lock=\"\"\n"	pointer
"	lock_status="	pointer
SWBIS_STATUS_COMMAND_NOT_FOUND	pointer
"\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
"swexec_status=$sw_retval\n"	pointer
"case \"$lock_status\" in\n"	pointer
"0)\n"	pointer
"       # Got Lock\n"	pointer
"	lock_did_lock=true\n"	pointer
"	case \"$opt_to_stdout\" in\n"	pointer
"	True)\n"	pointer
"		lock_did_lock=\"\"\n"	pointer
"		;;\n"	pointer
"	*)\n"	pointer
"		%s\n"	pointer
"		;;\n"	pointer
"	esac\n"	pointer
"	;;\n"	pointer
"2) # Read-Only Access \n"	pointer
"	case \"$opt_allow_no_lock\" in	\"\") ;; *) lock_status=0 ;; esac\n"	pointer
"	case \"$opt_allow_no_lock\" in\n"	pointer
"	*)\n"	pointer
"		%s\n"	pointer
"		%s\n"	pointer
"		sw_retval=0\n"	pointer
"		swexec_status=$sw_retval\n"	pointer
"		;;\n"	pointer
"	esac\n"	pointer
"	;;\n"	pointer
"1) # Lock failed \n"	pointer
"	case \"$opt_allow_no_lock\" in\n"	pointer
"	\"\")\n"	pointer
"		%s\n"	pointer
"		%s\n"	pointer
"		;;\n"	pointer
"	*)\n"	pointer
"		%s\n"	pointer
"		%s\n"	pointer
"		lock_status=0\n"	pointer
"		sw_retval=0\n"	pointer
"		swexec_status=$sw_retval\n"	pointer
"		;;\n"	pointer
"	esac\n"	pointer
"	;;\n"	pointer
SWBIS_STATUS_COMMAND_NOT_FOUND	pointer
")\n"	pointer
"	# do nothing \n"	pointer
"	;;\n"	pointer
"*)\n"	pointer
"	%s\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
"case \"$opt_force_lock\" in \"\") ;; *) lock_did_lock=true; ;; esac\n"	pointer
"#\n"	pointer
"#  <<<<----- here ends the code to lock a session \n"	pointer
"#\n"	pointer
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_LOCK_CREATED	int
,	O
"lockpath=$LOCKPATH: status=$sw_retval"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_IS_READ_ONLY	int
,	O
"lockpath=$LOCKPATH: status=1"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_LOCK_FAILURE	int
,	O
"lockpath=$LOCKPATH: status=1"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_CONFLICTING_SESSION_IN_PROGRESS	int
,	O
"lockpath=${LOCKPATH}: status=1"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_LOCK_FAILURE	int
,	O
"lockpath=$LOCKPATH: status=1"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_CONFLICTING_SESSION_IN_PROGRESS	int
,	O
"lockpath=$LOCKPATH: status=2"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_LOCK_FAILURE	int
,	O
"lockpath=$LOCKPATH: status=2"	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_LOCK_FAILURE	int
,	O
"lockpath=$LOCKPATH: status=$lock_status"	pointer
)	O
)	O
;	O
return	O
strob_str	function
(	O
buf	pointer
)	O
;	O
}	O
char	O
*	O
swpl_shellfrag_session_unlock	function
(	O
STROB	struct
*	O
buf	pointer
,	O
int	O
vlv	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
0	int
,	O
CSHID	O
"case \"$lock_did_lock\" in\n"	pointer
"       \"\") ;;\n"	pointer
"       *)\n"	pointer
"       lf_remove_lock \"$opt_force_lock\"\n"	pointer
"       %s\n"	pointer
"       ;;\n"	pointer
"esac\n"	pointer
,	O
TEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOC_LOCK_REMOVED	int
,	O
"status=$?"	pointer
)	O
)	O
;	O
return	O
strob_str	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
swpl_session_lock	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
target_path	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
shell_lib_buf	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"target_path=[%s]"	pointer
,	O
target_path	pointer
)	O
;	O
shell_lib_buf	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
CSHID	O
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"lf_make_lock </dev/null\n"	pointer
"sw_retval=$?\n"	pointer
"dd count=1 bs=512 of=/dev/null 2>/dev/null\n"	pointer
,	O
shlib_get_function_text_by_name	function
(	O
"lf_make_lockfile_name"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"lf_make_lockfile_entry"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"lf_append_lockfile_entry"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"lf_test_lock"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"lf_make_lock"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
target_path	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_make_locked_session	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"swicol_rpsh_task_send_script2 returned %d"	pointer
,	O
ret	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error from etar_write_trailer_blocks"	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
event_fd	int
,	O
SWICOL_TL_12	int
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"lock returning %d"	pointer
,	O
ret	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
ret	pointer
>	O
0	int
&&	O
G	pointer
->	O
g_force_locks	int
==	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"lock returning %d"	pointer
,	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
shell_lib_buf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
swpl_looper_payload_routine	function
(	O
STROB	struct
*	O
buf	pointer
,	O
int	O
vlv	int
,	O
char	O
*	O
locked_region	pointer
)	O
{	O
STROB	struct
*	O
lockfrag_buffer	pointer
;	O
STROB	struct
*	O
unlockfrag_buffer	pointer
;	O
lockfrag_buffer	pointer
=	O
strob_open	function
(	O
164	int
)	O
;	O
unlockfrag_buffer	pointer
=	O
strob_open	function
(	O
164	int
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
0	int
,	O
CSHID	O
"shls_looper_payload()\n"	pointer
"{\n"	pointer
"	catalog_entry_dir=\"$1\"\n"	pointer
"	case \"$targetpath\" in \"\") return 1;; esac\n"	pointer
"	cd \"$targetpath\"\n"	pointer
"	case $? in\n"	pointer
"		0)\n"	pointer
"			test -d \"$catalog_entry_dir\" ||\n"	pointer
"			echo error: \"'\" \"$catalog_entry_dir\" \"'\" is not a directory 1>&2 ||\n"	pointer
"			return 1\n"	pointer
"			shls_bashin2 \""	pointer
SWBIS_TS_check_loop	pointer
"\"\n"	pointer
"			sw_retval=$?\n"	pointer
"			case $sw_retval in 0) $sh_dash_s;; *) return 1;; esac\n"	pointer
"			sw_retval=$?\n"	pointer
"			swexec_status=$sw_retval\n"	pointer
"			catentdir=\"$catalog_entry_dir\"\n"	pointer
"			# remove the last two directory components\n"	pointer
"			catentdir=\"${catentdir%%/*}\"\n"	pointer
"			catentdir=\"${catentdir%%/*}\"\n"	pointer
"			LOCKPATH=\"$catentdir\"\n"	pointer
"			LOCKENTRY=$$\n"	pointer
"			# set the lock_status to an error\n"	pointer
"			lock_status=3\n"	pointer
"			lock_did_lock=\"\"\n"	pointer
"			# the locking code gets put inline here\n"	pointer
"			%s\n"	pointer
"			case \"$lock_status\" in\n"	pointer
"			0)\n"	pointer
"				%s\n"	pointer
"			;;\n"	pointer
"			esac\n"	pointer
"			%s\n"	pointer
"			return $swexec_status\n"	pointer
"		;;\n"	pointer
"		*)\n"	pointer
"			return 1\n"	pointer
"		;;\n"	pointer
"	esac\n"	pointer
"	#echo $1>>/tmp/looper.out\n"	pointer
"}\n"	pointer
,	O
swpl_shellfrag_session_lock	function
(	O
lockfrag_buffer	pointer
,	O
vlv	int
)	O
,	O
locked_region	pointer
,	O
swpl_shellfrag_session_unlock	function
(	O
unlockfrag_buffer	pointer
,	O
vlv	int
)	O
)	O
;	O
strob_close	function
(	O
lockfrag_buffer	pointer
)	O
;	O
strob_close	function
(	O
unlockfrag_buffer	pointer
)	O
;	O
return	O
strob_str	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
swpl_signature_policy_accept	function
(	O
GB	struct
*	O
G	pointer
,	O
SWGPG_VALIDATE	struct
*	O
w	pointer
,	O
int	O
verbose_level	int
,	O
char	O
*	O
swspec_string	pointer
)	O
{	O
int	O
retval	int
;	O
int	O
n	long
;	O
int	O
num_of_sigs	int
;	O
int	O
ngood	int
;	O
int	O
ret	pointer
;	O
int	O
gotta_have_all	int
;	O
struct	O
extendedOptions	struct
*	O
opta	pointer
;	O
char	O
*	O
blob	pointer
;	O
int	O
result	pointer
;	O
int	O
sig_level	int
;	O
int	O
sig_fd	int
;	O
int	O
logger_fd	int
;	O
int	O
status_fd	int
;	O
int	O
not_confirmed_msg_fd	int
;	O
opta	pointer
=	O
G	pointer
->	O
optaM	pointer
;	O
swgpg_set_status_array	function
(	O
w	pointer
)	O
;	O
sig_level	int
=	O
swlib_atoi	function
(	O
get_opta	function
(	O
opta	pointer
,	O
SW_E_swbis_sig_level	int
)	O
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
result	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
gotta_have_all	int
=	O
swextopt_is_option_true	function
(	O
SW_E_swbis_enforce_all_signatures	int
,	O
opta	pointer
)	O
;	O
n	long
=	O
0	int
;	O
num_of_sigs	int
=	O
swgpg_get_number_of_sigs	function
(	O
w	pointer
)	O
;	O
ngood	int
=	O
0	int
;	O
while	O
(	O
(	O
blob	pointer
=	O
strar_get	function
(	O
w	pointer
->	O
list_of_status_blobsM	pointer
,	O
n	long
)	O
)	O
!=	O
NULL	O
)	O
{	O
sig_fd	int
=	O
-	O
1	int
;	O
status_fd	int
=	O
-	O
1	int
;	O
logger_fd	int
=	O
-	O
1	int
;	O
ret	pointer
=	O
swgpg_get_status	function
(	O
w	pointer
,	O
n	long
)	O
;	O
switch	O
(	O
ret	pointer
)	O
{	O
case	O
SWGPG_SIG_VALID	int
:	O
ngood	int
++	O
;	O
if	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_2	int
)	O
{	O
logger_fd	int
=	O
STDOUT_FILENO	int
;	O
}	O
if	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_3	int
)	O
{	O
status_fd	int
=	O
STDOUT_FILENO	int
;	O
}	O
break	O
;	O
default	O
:	O
logger_fd	int
=	O
STDERR_FILENO	int
;	O
if	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_3	int
)	O
status_fd	int
=	O
STDERR_FILENO	int
;	O
break	O
;	O
}	O
swgpg_show	function
(	O
w	pointer
,	O
n	long
,	O
sig_fd	int
,	O
status_fd	int
,	O
logger_fd	int
)	O
;	O
n	long
++	O
;	O
}	O
retval	int
=	O
1	int
;	O
if	O
(	O
sig_level	int
==	O
0	int
&&	O
!	O
gotta_have_all	int
)	O
{	O
retval	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
sig_level	int
>	O
0	int
&&	O
!	O
gotta_have_all	int
)	O
{	O
if	O
(	O
ngood	int
>=	O
sig_level	int
)	O
{	O
retval	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
sig_level	int
<	O
0	int
)	O
{	O
if	O
(	O
ngood	int
==	O
num_of_sigs	int
&&	O
ngood	int
>	O
0	int
&&	O
1	int
)	O
{	O
retval	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
sig_level	int
>	O
0	int
&&	O
gotta_have_all	int
)	O
{	O
if	O
(	O
ngood	int
>=	O
sig_level	int
&&	O
ngood	int
==	O
num_of_sigs	int
&&	O
ngood	int
>	O
0	int
&&	O
1	int
)	O
{	O
retval	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
strcmp	function
(	O
swlib_utilname_get	function
(	O
)	O
,	O
"swlist"	pointer
)	O
==	O
0	int
)	O
{	O
not_confirmed_msg_fd	int
=	O
STDERR_FILENO	int
;	O
}	O
else	O
{	O
not_confirmed_msg_fd	int
=	O
STDOUT_FILENO	int
;	O
}	O
if	O
(	O
retval	int
)	O
{	O
swc_stderr_fd2_set	function
(	O
G	pointer
,	O
STDERR_FILENO	int
)	O
;	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"%s at sig_level=%d for %s: %d sigs, %d good: status=1\n"	pointer
,	O
swevent_code	function
(	O
SW_ISC_INTEGRITY_NOT_CONFIRMED	int
)	O
,	O
sig_level	int
,	O
swspec_string	pointer
,	O
num_of_sigs	int
,	O
ngood	int
)	O
;	O
swc_stderr_fd2_restore	function
(	O
G	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sig_level	int
==	O
0	int
&&	O
num_of_sigs	int
!=	O
ngood	int
)	O
{	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"Warning: %s at sig_level=%d for %s: %d sigs, %d good: status=2\n"	pointer
,	O
swevent_code	function
(	O
SW_ISC_INTEGRITY_NOT_CONFIRMED	int
)	O
,	O
sig_level	int
,	O
swspec_string	pointer
,	O
num_of_sigs	int
,	O
ngood	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
sig_level	int
>	O
0	int
&&	O
ngood	int
>=	O
sig_level	int
)	O
||	O
(	O
sig_level	int
==	O
0	int
&&	O
num_of_sigs	int
>	O
0	int
&&	O
num_of_sigs	int
==	O
ngood	int
)	O
||	O
0	int
)	O
{	O
swc_stderr_fd2_set	function
(	O
G	pointer
,	O
not_confirmed_msg_fd	int
)	O
;	O
swc_stderr_fd2_set	function
(	O
G	pointer
,	O
STDOUT_FILENO	int
)	O
;	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_2	int
,	O
"%s at sig_level=%d for %s: %d sigs, %d good: status=0\n"	pointer
,	O
swevent_code	function
(	O
SW_ISC_INTEGRITY_CONFIRMED	int
)	O
,	O
sig_level	int
,	O
swspec_string	pointer
,	O
num_of_sigs	int
,	O
ngood	int
)	O
;	O
swc_stderr_fd2_restore	function
(	O
G	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
sig_level	int
==	O
0	int
&&	O
num_of_sigs	int
==	O
0	int
)	O
||	O
0	int
)	O
{	O
swc_stderr_fd2_set	function
(	O
G	pointer
,	O
not_confirmed_msg_fd	int
)	O
;	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"%s at sig_level=%d for %s: %d sigs, %d good: status=0\n"	pointer
,	O
swevent_code	function
(	O
SW_ISC_INTEGRITY_NOT_CONFIRMED	int
)	O
,	O
sig_level	int
,	O
swspec_string	pointer
,	O
num_of_sigs	int
,	O
ngood	int
)	O
;	O
swc_stderr_fd2_restore	function
(	O
G	pointer
)	O
;	O
}	O
else	O
{	O
swc_stderr_fd2_set	function
(	O
G	pointer
,	O
not_confirmed_msg_fd	int
)	O
;	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"%s at sig_level=%d for %s: %d sigs, %d good: status=0\n"	pointer
,	O
swevent_code	function
(	O
SW_ISC_INTEGRITY_NOT_CONFIRMED	int
)	O
,	O
sig_level	int
,	O
swspec_string	pointer
,	O
num_of_sigs	int
,	O
ngood	int
)	O
;	O
swc_stderr_fd2_restore	function
(	O
G	pointer
)	O
;	O
}	O
}	O
return	O
retval	int
;	O
}	O
int	O
swpl_remove_catalog_entry	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
SWICAT_E	struct
*	O
e	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
iscpath	pointer
)	O
{	O
int	O
retval	int
;	O
retval	int
=	O
alter_catalog_entry	function
(	O
0	int
,	O
G	pointer
,	O
swicol	pointer
,	O
e	pointer
,	O
ofd	int
,	O
iscpath	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_restore_catalog_entry	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
SWICAT_E	struct
*	O
e	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
iscpath	pointer
)	O
{	O
int	O
retval	int
;	O
retval	int
=	O
alter_catalog_entry	function
(	O
1	int
,	O
G	pointer
,	O
swicol	pointer
,	O
e	pointer
,	O
ofd	int
,	O
iscpath	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
char	O
*	O
swpl_rename_suffix	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
"swbisold"	pointer
)	O
;	O
return	O
strob_str	function
(	O
buf	pointer
)	O
;	O
}	O
void	O
swpl_tag_volatile_files	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
)	O
{	O
int	O
ix	int
;	O
char	O
*	O
sx	pointer
;	O
int	O
is_volatile	int
;	O
char	O
*	O
prefix	pointer
;	O
int	O
type	enum
;	O
swi_fl_qsort_forward	function
(	O
fl	pointer
)	O
;	O
ix	int
=	O
0	int
;	O
prefix	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
sx	pointer
=	O
swi_fl_get_path	function
(	O
fl	pointer
,	O
ix	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
type	enum
=	O
swi_fl_get_type	function
(	O
fl	pointer
,	O
ix	int
)	O
,	O
is_volatile	int
=	O
swi_fl_is_volatile	function
(	O
fl	pointer
,	O
ix	int
)	O
;	O
if	O
(	O
prefix	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
type	enum
==	O
DIRTYPE	char
&&	O
is_volatile	int
)	O
{	O
if	O
(	O
prefix	pointer
)	O
free	function
(	O
prefix	pointer
)	O
;	O
prefix	pointer
=	O
strdup	function
(	O
sx	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
strstr	function
(	O
sx	pointer
,	O
prefix	pointer
)	O
==	O
sx	pointer
)	O
{	O
swi_fl_set_is_volatile	function
(	O
fl	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
ix	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
prefix	pointer
)	O
free	function
(	O
prefix	pointer
)	O
;	O
prefix	pointer
=	O
NULL	O
;	O
}	O
}	O
ix	int
++	O
;	O
}	O
if	O
(	O
prefix	pointer
)	O
free	function
(	O
prefix	pointer
)	O
;	O
}	O
int	O
swpl_show_file_list	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI_FILELIST	union
*	O
fl	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
ix	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_fl_qsort_forward	function
(	O
fl	pointer
)	O
;	O
ix	int
=	O
0	int
;	O
while	O
(	O
(	O
name	pointer
=	O
swi_fl_get_path	function
(	O
fl	pointer
,	O
ix	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"%s\n"	pointer
,	O
name	pointer
)	O
;	O
ix	int
++	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_make_here_document_source	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
scriptbuf	pointer
,	O
STROB	struct
*	O
here_payload	pointer
)	O
{	O
STROB	struct
*	O
stop_word	pointer
;	O
int	O
ret	pointer
;	O
stop_word	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
ret	pointer
=	O
determine_here_document_stop_word_bystr	function
(	O
here_payload	pointer
,	O
stop_word	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
exit	function
(	O
12	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"(\n"	pointer
"cat <<'%s'\n"	pointer
,	O
strob_str	function
(	O
stop_word	pointer
)	O
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s"	pointer
,	O
strob_str	function
(	O
here_payload	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
")"	pointer
,	O
strob_str	function
(	O
stop_word	pointer
)	O
)	O
;	O
strob_close	function
(	O
stop_word	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_make_verify_command_script_fragment	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
scriptbuf	pointer
,	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
char	O
*	O
pax_write_command_key	pointer
,	O
int	O
be_silent	int
)	O
{	O
int	O
ret	pointer
;	O
int	O
check_volatile	int
;	O
int	O
is_volatile	int
;	O
STROB	struct
*	O
stop_word	pointer
;	O
STROB	struct
*	O
shell_lib_buf	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
ix	int
;	O
shell_lib_buf	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swpl_tag_volatile_files	function
(	O
fl	pointer
)	O
;	O
stop_word	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
ret	pointer
=	O
determine_here_document_stop_word	function
(	O
fl	pointer
,	O
stop_word	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
exit	function
(	O
12	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_fl_qsort_forward	function
(	O
fl	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"rm_retval=0\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
,	O
shlib_get_function_text_by_name	function
(	O
"shls_check_for_gnu_tar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_check_for_recent_gnu_gtar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_check_for_gnu_gtar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
"%s\n"	pointer
,	O
shlib_get_function_text_by_name	function
(	O
"shls_missing_which"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_write_files_ar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"gtar"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"pax"	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"check_has_gnu_gtar=0\n"	pointer
"check_has_gnu_tar=0\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"tar"	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"shls_check_for_gnu_tar\n"	pointer
"check_has_gnu_tar=$?\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"shls_check_for_gnu_gtar\n"	pointer
"check_has_gnu_gtar=$?\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"detect"	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"check_has_gnu_tar=0\n"	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"check_has_gnu_tar=0\n"	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\n"	pointer
"GTAR=/\n"	pointer
"case $check_has_gnu_gtar in\n"	pointer
"	0)\n"	pointer
"	GTAR=gtar\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
"\n"	pointer
"case $check_has_gnu_tar in\n"	pointer
"	0)\n"	pointer
"	GTAR=tar\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"	case $check_has_gnu_gtar in\n"	pointer
"		0)\n"	pointer
"		;;\n"	pointer
"		*)\n"	pointer
"		# Neither gtar or GNU tar was found, fail now\n"	pointer
"		# simulate the response of GNU tar to an empty list\n"	pointer
"		dd count=2 bs=512 if=/dev/zero 2>/dev/null \n"	pointer
"		exit "	pointer
xSTR	O
(	O
SWP_RP_STATUS_NO_GNU_TAR	int
)	O
"\n"	pointer
"		;;\n"	pointer
"		esac\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"(\n"	pointer
"cat <<'%s'\n"	pointer
,	O
strob_str	function
(	O
stop_word	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ix	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
swlib_utilname_get	function
(	O
)	O
,	O
SWUTIL_NAME_SWVERIFY	pointer
)	O
==	O
0	int
)	O
{	O
check_volatile	int
=	O
swextopt_is_option_true	function
(	O
SW_E_check_volatile	int
,	O
G	pointer
->	O
optaM	pointer
)	O
;	O
}	O
else	O
{	O
check_volatile	int
=	O
0	int
;	O
}	O
while	O
(	O
(	O
name	pointer
=	O
swi_fl_get_path	function
(	O
fl	pointer
,	O
ix	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
G	pointer
->	O
devel_verboseM	int
)	O
{	O
SWLIB_INFO3	O
(	O
"INFO; file=[%s] type=[%c]"	pointer
,	O
name	pointer
,	O
(	O
char	O
)	O
swi_fl_get_type	function
(	O
fl	pointer
,	O
ix	int
)	O
)	O
;	O
}	O
is_volatile	int
=	O
0	int
;	O
if	O
(	O
check_volatile	int
==	O
0	int
)	O
{	O
is_volatile	int
=	O
swi_fl_is_volatile	function
(	O
fl	pointer
,	O
ix	int
)	O
;	O
}	O
if	O
(	O
is_volatile	int
==	O
0	int
)	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
,	O
name	pointer
)	O
;	O
ix	int
++	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
") |"	pointer
,	O
strob_str	function
(	O
stop_word	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
G	pointer
->	O
g_do_dereferenceM	int
||	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"tar"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"gtar"	pointer
)	O
==	O
0	int
||	O
0	int
)	O
{	O
do_tar_key	O
:	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"gtar_hdref=\"\"\n"	pointer
"case \"%s\" in\n"	pointer
"yes)\n"	pointer
"	shls_check_for_recent_gnu_gtar\n"	pointer
"	case $? in\n"	pointer
"		0)\n"	pointer
"		gtar_hdref=\"--hard-dereference\"\n"	pointer
"		;;\n"	pointer
"		*)\n"	pointer
"		echo \"swinstall: warning: tar option ''--hard-derefence'' is not available\" 1>&2\n"	pointer
"		;;\n"	pointer
"	esac\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"case \"$GTAR\" in\n"	pointer
"	/)\n"	pointer
"	# FATAL error GNU tar is missing\n"	pointer
"	# simulate the response of GNU tar to an empty list\n"	pointer
"	dd count=2 bs=512 if=/dev/zero 2>/dev/null \n"	pointer
"	exit "	pointer
xSTR	O
(	O
SWP_RP_STATUS_NO_GNU_TAR	int
)	O
"\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
" $GTAR %scf - -b 1 -H pax %s $gtar_hdref  --no-recursion --files-from=- %s\n"	pointer
,	O
(	O
G	pointer
->	O
g_do_hard_dereferenceM	int
==	O
0	int
?	O
""	pointer
:	O
"yes"	pointer
)	O
,	O
(	O
char	O
*	O
)	O
(	O
G	pointer
->	O
g_verboseG	int
>	O
SWC_VERBOSE_2	int
?	O
"v"	pointer
:	O
""	pointer
)	O
,	O
(	O
G	pointer
->	O
g_do_dereferenceM	int
==	O
0	int
?	O
""	pointer
:	O
"--dereference"	pointer
)	O
,	O
(	O
be_silent	int
?	O
"2>/dev/null"	pointer
:	O
""	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"pax"	pointer
)	O
==	O
0	int
||	O
0	int
)	O
{	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
" pax -d -w -b 512\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
pax_write_command_key	pointer
,	O
"detect"	pointer
)	O
==	O
0	int
||	O
0	int
)	O
{	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
" shls_write_files_ar\n"	pointer
CSHID	O
"# Support controlled bailout in the event \n"	pointer
"# neither GNU tar or pax is present \n"	pointer
"case $? in 126) exit "	pointer
xSTR	O
(	O
SWP_RP_STATUS_NO_GNU_TAR	int
)	O
";; esac\n"	pointer
)	O
;	O
}	O
else	O
{	O
goto	O
do_tar_key	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"# FIXME, sw_retval should be set here\n"	pointer
"### Not used   retrieve_retval=$?\n"	pointer
CSHID	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
shell_lib_buf	pointer
)	O
;	O
strob_close	function
(	O
stop_word	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_ls_fileset_from_iscat	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
int	O
ls_verbose	int
,	O
int	O
*	O
available_attributes	pointer
,	O
int	O
skip_volatile	int
,	O
int	O
check_contents	int
)	O
{	O
int	O
retval	int
;	O
SWHEADER_STATE	struct
state1	struct
;	O
SWHEADER	struct
*	O
indexheader	pointer
;	O
SWHEADER	struct
*	O
infoheader	pointer
;	O
SWI_PRODUCT	struct
*	O
current_product	pointer
;	O
SWI_XFILE	struct
*	O
current_fileset	pointer
;	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
;	O
char	O
*	O
next_line	pointer
;	O
char	O
*	O
directory	pointer
;	O
char	O
*	O
next_attr	pointer
;	O
char	O
*	O
keyword	pointer
;	O
char	O
*	O
value	int
;	O
int	O
has_md5	int
;	O
int	O
has_sha1	int
;	O
int	O
has_sha512	int
;	O
AHS	struct
*	O
info_ahs2	pointer
;	O
int	O
ret	pointer
;	O
STROB	struct
*	O
ls_line	pointer
;	O
STROB	struct
*	O
tmp2	pointer
;	O
int	O
file_attribute_usage	int
;	O
FILE_DIGS	struct
*	O
digs	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
has_md5	int
=	O
0	int
;	O
has_sha1	int
=	O
0	int
;	O
has_sha512	int
=	O
0	int
;	O
tmp2	pointer
=	O
strob_open	function
(	O
30	int
)	O
;	O
file_attribute_usage	int
=	O
0	int
;	O
retval	int
=	O
0	int
;	O
info_ahs2	pointer
=	O
ahs_open	function
(	O
)	O
;	O
ls_line	pointer
=	O
strob_open	function
(	O
60	int
)	O
;	O
if	O
(	O
check_contents	int
==	O
0	int
)	O
{	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_MD5	O
|	O
LS_LIST_VERBOSE_WITH_SHA1	O
|	O
LS_LIST_VERBOSE_WITH_SHA512	O
)	O
;	O
ls_verbose	int
&=	O
~	O
(	O
LS_LIST_VERBOSE_WITH_SIZE	O
)	O
;	O
}	O
swpl_enforce_one_prod_one_fileset	function
(	O
swi	pointer
)	O
;	O
current_product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
0	int
)	O
;	O
current_fileset	pointer
=	O
swi_product_get_fileset	function
(	O
current_product	pointer
,	O
0	int
)	O
;	O
indexheader	pointer
=	O
swi_get_global_index_header	function
(	O
swi	pointer
)	O
;	O
swheader_set_current_offset	function
(	O
indexheader	pointer
,	O
current_product	pointer
->	O
p_baseM	struct
.	O
header_indexM	int
)	O
;	O
directory	pointer
=	O
swheader_get_single_attribute_value	function
(	O
indexheader	pointer
,	O
SW_A_directory	pointer
)	O
;	O
directory	pointer
=	O
swlib_attribute_check_default	function
(	O
SW_A_product	pointer
,	O
SW_A_directory	pointer
,	O
directory	pointer
)	O
;	O
infoheader	pointer
=	O
swi_get_fileset_info_header	function
(	O
swi	pointer
,	O
0	int
,	O
0	int
)	O
;	O
swheader_store_state	function
(	O
infoheader	pointer
,	O
NULL	O
)	O
;	O
swheader_reset	function
(	O
infoheader	pointer
)	O
;	O
file_hdr	pointer
=	O
ahs_vfile_hdr	function
(	O
info_ahs2	pointer
)	O
;	O
taru_init_header_digs	function
(	O
file_hdr	pointer
)	O
;	O
digs	pointer
=	O
file_hdr	pointer
->	O
digsM	pointer
;	O
taru_digs_init	function
(	O
digs	pointer
,	O
check_contents	int
?	O
1	int
:	O
0	int
,	O
DIGS_DO_POISON	int
)	O
;	O
while	O
(	O
(	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
infoheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
)	O
)	O
{	O
E_DEBUG2	O
(	O
"next_line=%s\n"	pointer
,	O
next_line	pointer
)	O
;	O
if	O
(	O
swheaderline_get_type	function
(	O
next_line	pointer
)	O
!=	O
SWPARSE_MD_TYPE_OBJ	char
)	O
{	O
SWBIS_IMPL_ERROR_DIE	O
(	O
1	int
)	O
;	O
}	O
keyword	pointer
=	O
swheaderline_get_keyword	function
(	O
next_line	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
keyword	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
keyword	pointer
,	O
SW_A_control_file	pointer
)	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
taru_init_header	function
(	O
file_hdr	pointer
)	O
;	O
file_hdr	pointer
->	O
digsM	pointer
=	O
digs	pointer
;	O
taru_digs_init	function
(	O
digs	pointer
,	O
check_contents	int
?	O
1	int
:	O
0	int
,	O
DIGS_DO_POISON	int
)	O
;	O
swheader_store_state	function
(	O
infoheader	pointer
,	O
&	O
state1	struct
)	O
;	O
ret	pointer
=	O
swheader_fileobject2filehdr	function
(	O
infoheader	pointer
,	O
file_hdr	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
{	O
SWLIB_FATAL	O
(	O
""	pointer
)	O
;	O
}	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
)	O
{	O
swlib_apply_location	function
(	O
tmp2	pointer
,	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
,	O
directory	pointer
)	O
;	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
strob_str	function
(	O
tmp2	pointer
)	O
)	O
;	O
}	O
if	O
(	O
file_attribute_usage	int
==	O
0	int
)	O
{	O
file_attribute_usage	int
=	O
file_hdr	pointer
->	O
usage_maskM	char
;	O
}	O
else	O
{	O
file_attribute_usage	int
&=	O
file_hdr	pointer
->	O
usage_maskM	char
;	O
}	O
*	O
available_attributes	pointer
|=	O
determine_ls_list_flags	function
(	O
file_attribute_usage	int
,	O
file_hdr	pointer
,	O
check_contents	int
)	O
;	O
if	O
(	O
check_contents	int
)	O
{	O
if	O
(	O
*	O
available_attributes	pointer
&	O
LS_LIST_VERBOSE_WITH_MD5	O
)	O
{	O
has_md5	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
available_attributes	pointer
&	O
LS_LIST_VERBOSE_WITH_SHA1	O
)	O
{	O
has_sha1	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
available_attributes	pointer
&	O
LS_LIST_VERBOSE_WITH_SHA512	O
)	O
{	O
has_sha512	int
=	O
1	int
;	O
}	O
if	O
(	O
has_md5	int
)	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_MD5	O
;	O
if	O
(	O
has_sha1	int
)	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SHA1	O
;	O
if	O
(	O
has_sha512	int
)	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_WITH_SHA512	O
;	O
}	O
merge_name_id	function
(	O
&	O
ls_verbose	int
,	O
*	O
available_attributes	pointer
)	O
;	O
swheader_restore_state	function
(	O
infoheader	pointer
,	O
&	O
state1	struct
)	O
;	O
if	O
(	O
0	int
)	O
{	O
value	int
=	O
swheaderline_get_value	function
(	O
next_line	pointer
,	O
(	O
int	O
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
swlib_doif_writef	O
(	O
swi	pointer
->	O
verboseM	int
,	O
SWC_VERBOSE_1	int
,	O
(	O
struct	O
sw_logspec	struct
*	O
)	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"%s %s\n"	pointer
,	O
keyword	pointer
,	O
value	int
?	O
value	int
:	O
""	pointer
)	O
;	O
while	O
(	O
(	O
next_attr	pointer
=	O
swheader_get_next_attribute	function
(	O
infoheader	pointer
)	O
)	O
)	O
{	O
keyword	pointer
=	O
swheaderline_get_keyword	function
(	O
next_attr	pointer
)	O
;	O
value	int
=	O
swheaderline_get_value	function
(	O
next_attr	pointer
,	O
(	O
int	O
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
swlib_doif_writef	O
(	O
swi	pointer
->	O
verboseM	int
,	O
SWC_VERBOSE_1	int
,	O
(	O
struct	O
sw_logspec	struct
*	O
)	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"%s %s\n"	pointer
,	O
keyword	pointer
,	O
value	int
?	O
value	int
:	O
""	pointer
)	O
;	O
}	O
}	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_PREPEND_DOTSLASH	O
;	O
ls_verbose	int
|=	O
LS_LIST_VERBOSE_LINKNAME_PLAIN	O
;	O
taru_print_tar_ls_list	function
(	O
ls_line	pointer
,	O
file_hdr	pointer
,	O
ls_verbose	int
)	O
;	O
if	O
(	O
skip_volatile	int
&&	O
file_hdr	pointer
->	O
usage_maskM	char
&	O
TARU_UM_IS_VOLATILE	O
)	O
{	O
;	O
}	O
else	O
{	O
if	O
(	O
ofd	int
>=	O
0	int
)	O
{	O
uxfio_unix_atomic_write	function
(	O
ofd	int
,	O
strob_str	function
(	O
ls_line	pointer
)	O
,	O
strob_strlen	function
(	O
ls_line	pointer
)	O
)	O
;	O
}	O
}	O
}	O
swheader_restore_state	function
(	O
infoheader	pointer
,	O
NULL	O
)	O
;	O
ahs_close	function
(	O
info_ahs2	pointer
)	O
;	O
strob_close	function
(	O
ls_line	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
void	O
swpl_bashin_posixsh	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
prog	pointer
;	O
char	O
*	O
swbis	pointer
;	O
char	O
*	O
binsh	pointer
;	O
binsh	pointer
=	O
"sh"	pointer
;	O
prog	pointer
=	O
swlib_utilname_get	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
prog	pointer
,	O
"swremove"	pointer
)	O
==	O
0	int
)	O
{	O
prog	pointer
=	O
"/"	pointer
;	O
swbis	pointer
=	O
"/"	pointer
;	O
}	O
else	O
{	O
swbis	pointer
=	O
"/_swbis"	pointer
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"{\n"	pointer
"export XXX_PKG\n"	pointer
"export XXX_PGM\n"	pointer
"export XXX_SH\n"	pointer
"export PATH\n"	pointer
"XXX_PKG=\"%s\"\n"	pointer
"XXX_PGM=\"%s\"\n"	pointer
"XPATH=`getconf PATH`\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"PATH=\"$XPATH\"\n"	pointer
";;\n"	pointer
"*)\n"	pointer
"PATH=/bin:/usr/bin\n"	pointer
"echo \"swbis: $XXX_PGM: getconf not found (required by --shell-command=posix option)\" 1>&2\n"	pointer
"echo \"swbis: $XXX_PGM: fatal, exiting with status 125\" 1>&2\n"	pointer
"exit 125\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"xxx_missing_which() {\n"	pointer
"# Prefix: xxabb\n"	pointer
"xxabb_pgm=\"$1\"\n"	pointer
"xxabb_name=`which $xxabb_pgm 2>/dev/null`\n"	pointer
"test -f \"$xxabb_name\" -o -h \"$xxabb_name\"\n"	pointer
"case \"$?\" in\n"	pointer
"0) echo \"$xxabb_name\"; return 0; ;;\n"	pointer
"*) echo \"/\"; return 1; ;;\n"	pointer
"esac\n"	pointer
"return 0\n"	pointer
"}\n"	pointer
"XXX_SH=`xxx_missing_which sh`\n"	pointer
"test -x \"$XXX_SH\" &&\n"	pointer
"{\n"	pointer
"\"$XXX_SH\" -s 1>/dev/null 2>&1 <<HERE\n"	pointer
"(read A; exit 0);\n"	pointer
"/\n"	pointer
"HERE\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"exec \"$XXX_SH\" -s  \"$XXX_PKG\" /\"_$XXX_PGM\" / / PSH=\"\\\"\"$XXX_SH\" -s\\\"\"\n"	pointer
"exit 121\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"}\n"	pointer
"echo \"swbis: $XXX_PGM: a POSIX shell in PATH=getconf PATH is not suitable on host `hostname`\" 1>&2\n"	pointer
"echo \"swbis: $XXX_PGM: fatal, exiting with status 124\" 1>&2\n"	pointer
"exit 124\n"	pointer
"}\n"	pointer
,	O
swbis	pointer
,	O
prog	pointer
)	O
;	O
make_padding_for_login_shell	function
(	O
16	int
,	O
buf	pointer
)	O
;	O
}	O
void	O
swpl_bashin_testsh	function
(	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
shell	pointer
)	O
{	O
char	O
*	O
prog	pointer
;	O
char	O
*	O
swbis	pointer
;	O
char	O
*	O
binsh	pointer
;	O
binsh	pointer
=	O
construct_binsh_name	function
(	O
shell	pointer
)	O
;	O
prog	pointer
=	O
swlib_utilname_get	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
prog	pointer
,	O
"swremove"	pointer
)	O
==	O
0	int
)	O
{	O
prog	pointer
=	O
"/"	pointer
;	O
swbis	pointer
=	O
"/"	pointer
;	O
}	O
else	O
{	O
swbis	pointer
=	O
"/_swbis"	pointer
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"{\n"	pointer
"export XXX_PKG\n"	pointer
"export XXX_PGM\n"	pointer
"export XXX_SH\n"	pointer
"XXX_PKG=\"%s\"\n"	pointer
"XXX_PGM=\"%s\"\n"	pointer
"XXX_SH=\"%s\"\n"	pointer
"test -x $XXX_SH &&\n"	pointer
"{\n"	pointer
"$XXX_SH -s 1>/dev/null 2>&1 <<HERE\n"	pointer
"(read A; exit 0);\n"	pointer
"/\n"	pointer
"HERE\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"exec $XXX_SH -s  $XXX_PKG /_$XXX_PGM / / PSH=\"\\\"\"$XXX_SH\" -s\\\"\"\n"	pointer
"exit 121\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"}\n"	pointer
"echo \"swbis: $XXX_PGM: the specified shell is not suitable on host `hostname`\" 1>&2\n"	pointer
"echo \"swbis: $XXX_PGM: fatal, exiting with status 126\" 1>&2\n"	pointer
"exit 126\n"	pointer
"}\n"	pointer
,	O
swbis	pointer
,	O
prog	pointer
,	O
binsh	pointer
)	O
;	O
make_padding_for_login_shell	function
(	O
16	int
,	O
buf	pointer
)	O
;	O
}	O
void	O
swpl_bashin_detect	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
prog	pointer
;	O
char	O
*	O
swbis	pointer
;	O
prog	pointer
=	O
swlib_utilname_get	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
prog	pointer
,	O
"swremove"	pointer
)	O
==	O
0	int
)	O
{	O
prog	pointer
=	O
"/"	pointer
;	O
swbis	pointer
=	O
"/"	pointer
;	O
}	O
else	O
{	O
swbis	pointer
=	O
"/_swbis"	pointer
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"{\n"	pointer
"export XXX_PKG\n"	pointer
"export XXX_PGM\n"	pointer
"export XXX_SH\n"	pointer
"XXX_PKG=\"%s\"\n"	pointer
"XXX_PGM=\"%s\"\n"	pointer
"XXX_SH=/bin/bash\n"	pointer
"test -x $XXX_SH &&\n"	pointer
"{\n"	pointer
"$XXX_SH -s 1>/dev/null 2>&1 <<HERE\n"	pointer
"(read A; exit 0);\n"	pointer
"/\n"	pointer
"HERE\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"exec $XXX_SH -s  $XXX_PKG /_$XXX_PGM / / PSH=\"\\\"\"$XXX_SH\" -s\\\"\"\n"	pointer
"exit 121\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"}\n"	pointer
"XXX_SH=/bin/ksh\n"	pointer
"test -x $XXX_SH &&\n"	pointer
"{\n"	pointer
"$XXX_SH -s 1>/dev/null 2>&1 <<HERE\n"	pointer
"(read A; exit 0);\n"	pointer
"/\n"	pointer
"HERE\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"exec $XXX_SH -s  $XXX_PKG /_$XXX_PGM / / PSH=\"\\\"\"$XXX_SH\" -s\\\"\"\n"	pointer
"exit 121\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"}\n"	pointer
"XXX_SH=/usr/xpg4/bin/sh\n"	pointer
"test -x $XXX_SH &&\n"	pointer
"{\n"	pointer
"$XXX_SH -s 1>/dev/null 2>&1 <<HERE\n"	pointer
"(read A; exit 0);\n"	pointer
"/\n"	pointer
"HERE\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"exec $XXX_SH -s  $XXX_PKG /_$XXX_PGM / / PSH=\"\\\"\"$XXX_SH\" -s\\\"\"\n"	pointer
"exit 121\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"}\n"	pointer
"XXX_SH=/bin/sh\n"	pointer
"test -x $XXX_SH &&\n"	pointer
"{\n"	pointer
"$XXX_SH -s 1>/dev/null 2>&1 <<HERE\n"	pointer
"(read A; exit 0);\n"	pointer
"/\n"	pointer
"HERE\n"	pointer
"case $? in\n"	pointer
"0)\n"	pointer
"exec $XXX_SH -s  $XXX_PKG /_$XXX_PGM / / PSH=\"\\\"\"$XXX_SH\" -s\\\"\"\n"	pointer
"exit 121\n"	pointer
";;\n"	pointer
"esac\n"	pointer
"}\n"	pointer
"echo \"swbis: $XXX_PGM: no suitable shell found on host `hostname`\" 1>&2\n"	pointer
"echo \"swbis: $XXX_PGM: fatal, exiting with status 126\" 1>&2\n"	pointer
"exit 126\n"	pointer
"}\n"	pointer
,	O
swbis	pointer
,	O
prog	pointer
)	O
;	O
make_padding_for_login_shell	function
(	O
16	int
,	O
buf	pointer
)	O
;	O
}	O
int	O
swpl_check_package_signatures	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
*	O
p_num_checked	pointer
)	O
{	O
int	O
i	int
;	O
int	O
retval	int
;	O
int	O
ret	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
signed_bytes_fd	int
;	O
SWGPG_VALIDATE	struct
*	O
swgpg	pointer
;	O
STROB	struct
*	O
gpg_status	pointer
;	O
int	O
sig_block_start	pointer
;	O
int	O
sig_block_end	pointer
;	O
CPLOB	struct
*	O
archive_files	pointer
;	O
SWI_FILE_MEMBER	struct
*	O
afile	pointer
;	O
int	O
num_checked	int
;	O
if	O
(	O
p_num_checked	pointer
)	O
*	O
p_num_checked	pointer
=	O
0	int
;	O
num_checked	int
=	O
0	int
;	O
retval	int
=	O
0	int
;	O
swgpg	pointer
=	O
swgpg_create	function
(	O
)	O
;	O
gpg_status	pointer
=	O
strob_open	function
(	O
33	int
)	O
;	O
archive_files	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfilesM	pointer
->	O
archive_filesM	pointer
;	O
swi_examine_signature_blocks	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfilesM	pointer
,	O
&	O
sig_block_start	pointer
,	O
&	O
sig_block_end	pointer
)	O
;	O
signed_bytes_fd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
swpl_write_catalog_data	function
(	O
swi	pointer
,	O
signed_bytes_fd	int
,	O
sig_block_start	pointer
,	O
sig_block_end	pointer
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
afile	pointer
=	O
(	O
SWI_FILE_MEMBER	struct
*	O
)	O
cplob_val	function
(	O
archive_files	pointer
,	O
i	int
++	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
afile	pointer
->	O
pathnameM	pointer
,	O
"/"	pointer
SW_A_signature	pointer
)	O
)	O
&&	O
(	O
*	O
(	O
s	pointer
+	O
strlen	function
(	O
"/"	pointer
SW_A_signature	pointer
)	O
)	O
==	O
'\0'	O
)	O
)	O
{	O
uxfio_lseek	function
(	O
signed_bytes_fd	int
,	O
0L	int
,	O
SEEK_SET	int
)	O
;	O
strob_memset	function
(	O
gpg_status	pointer
,	O
(	O
int	O
)	O
(	O
'\0'	O
)	O
,	O
500	int
)	O
;	O
ret	pointer
=	O
swgpg_run_gpg_verify	function
(	O
swgpg	pointer
,	O
signed_bytes_fd	int
,	O
afile	pointer
->	O
dataM	pointer
,	O
G	pointer
->	O
g_verboseG	int
,	O
gpg_status	pointer
)	O
;	O
ret	pointer
=	O
swgpg_determine_signature_status	function
(	O
strob_str	function
(	O
gpg_status	pointer
)	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
||	O
G	pointer
->	O
g_verboseG	int
>=	O
SWC_VERBOSE_3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
strob_str	function
(	O
gpg_status	pointer
)	O
)	O
;	O
}	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
retval	int
++	O
;	O
}	O
num_checked	int
++	O
;	O
}	O
}	O
if	O
(	O
p_num_checked	pointer
)	O
*	O
p_num_checked	pointer
=	O
num_checked	int
;	O
uxfio_close	function
(	O
signed_bytes_fd	int
)	O
;	O
swgpg_delete	function
(	O
swgpg	pointer
)	O
;	O
strob_close	function
(	O
gpg_status	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
char	O
*	O
swpl_make_package_signature	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
)	O
{	O
int	O
retval	int
;	O
char	O
*	O
sig	pointer
;	O
int	O
signed_bytes_fd	int
;	O
int	O
sig_block_start	pointer
;	O
int	O
sig_block_end	pointer
;	O
CPLOB	struct
*	O
archive_files	pointer
;	O
char	O
*	O
gpg_name	pointer
;	O
char	O
*	O
gpg_path	pointer
;	O
SHCMD	struct
*	O
sigcmd	pointer
;	O
int	O
signer_status	int
;	O
retval	int
=	O
0	int
;	O
archive_files	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfilesM	pointer
->	O
archive_filesM	pointer
;	O
gpg_name	pointer
=	O
getenv	function
(	O
"GNUPGNAME"	pointer
)	O
;	O
gpg_path	pointer
=	O
getenv	function
(	O
"GNUPGHOME"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
gpg_name	pointer
||	O
!	O
gpg_path	pointer
)	O
{	O
if	O
(	O
!	O
gpg_name	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: GNUPGNAME not set\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
if	O
(	O
!	O
gpg_path	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: GNUPGHOME not set\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
sigcmd	pointer
=	O
swgpg_get_package_signature_command	function
(	O
"GPG"	pointer
,	O
gpg_name	pointer
,	O
gpg_path	pointer
,	O
SWGPG_SWP_PASS_AGENT	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_examine_signature_blocks	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfilesM	pointer
,	O
&	O
sig_block_start	pointer
,	O
&	O
sig_block_end	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
signed_bytes_fd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swpl_write_catalog_data	function
(	O
swi	pointer
,	O
signed_bytes_fd	int
,	O
sig_block_start	pointer
,	O
sig_block_end	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_lseek	function
(	O
signed_bytes_fd	int
,	O
0L	int
,	O
SEEK_SET	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
sig	pointer
=	O
swgpg_get_package_signature	function
(	O
sigcmd	pointer
,	O
&	O
signer_status	int
,	O
SWGPG_SWP_PASS_AGENT	pointer
,	O
NULL	O
,	O
signed_bytes_fd	int
,	O
0	int
,	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_close	function
(	O
signed_bytes_fd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
sig	pointer
;	O
}	O
char	O
*	O
swpl_make_environ_transfer_image	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
*	O
list	pointer
;	O
char	O
*	O
att	pointer
;	O
char	O
*	O
varname	pointer
;	O
char	O
*	O
value	int
;	O
char	O
*	O
q	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
v	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
30	int
)	O
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
list	pointer
=	O
environ	pointer
;	O
while	O
(	O
(	O
att	pointer
=	O
*	O
(	O
list	pointer
++	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
q	pointer
=	O
NULL	O
;	O
q	pointer
=	O
strchr	function
(	O
att	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
continue	O
;	O
*	O
q	pointer
=	O
'\0'	O
;	O
value	int
=	O
q	pointer
+	O
1	int
;	O
varname	pointer
=	O
att	pointer
;	O
if	O
(	O
environ_exclude	function
(	O
varname	pointer
)	O
)	O
goto	O
HERE_reject_var	O
;	O
if	O
(	O
strpbrk	function
(	O
varname	pointer
,	O
SWBIS_WS_TAINTED_CHARS	pointer
SWBIS_TAINTED_CHARS	pointer
"-:;"	pointer
)	O
)	O
goto	O
HERE_reject_var	O
;	O
if	O
(	O
strpbrk	function
(	O
value	int
,	O
"`"	pointer
)	O
)	O
goto	O
HERE_reject_var	O
;	O
v	int
=	O
value	int
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
""	pointer
)	O
;	O
while	O
(	O
*	O
v	int
)	O
{	O
if	O
(	O
*	O
v	int
==	O
'"'	O
)	O
{	O
strob_strcat	function
(	O
tmp	pointer
,	O
"\\\""	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
v	int
==	O
'$'	O
)	O
{	O
strob_strcat	function
(	O
tmp	pointer
,	O
"\\$"	pointer
)	O
;	O
}	O
else	O
{	O
strob_charcat	function
(	O
tmp	pointer
,	O
*	O
v	int
)	O
;	O
}	O
v	int
++	O
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
DO_APPEND	int
,	O
"export %s\n%s=${%s=\"%s\"}\n"	pointer
,	O
varname	pointer
,	O
varname	pointer
,	O
varname	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
HERE_reject_var	O
:	O
*	O
q	pointer
=	O
'='	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
strob_str	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
swpl_run_check_script	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
script_name	pointer
,	O
char	O
*	O
id_string	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
int	O
event_fd	int
,	O
int	O
*	O
p_check_status	pointer
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
buf	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
check_script	pointer
;	O
int	O
stdin_file_size	long
;	O
int	O
this_index	int
;	O
int	O
script_status	int
;	O
char	O
*	O
check_message	pointer
;	O
buf	pointer
=	O
strob_open	function
(	O
400	int
)	O
;	O
ret	pointer
=	O
swpl_construct_analysis_script	function
(	O
G	pointer
,	O
script_name	pointer
,	O
buf	pointer
,	O
swi	pointer
,	O
&	O
check_script	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	pointer
==	O
0	int
)	O
;	O
stdin_file_size	long
=	O
512	int
;	O
swicol_set_task_idstring	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
id_string	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
512	int
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
strob_str	function
(	O
buf	pointer
)	O
,	O
id_string	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
{	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
return	O
-	O
1	int
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
event_fd	int
,	O
SWICOL_TL_9	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
swi	pointer
->	O
debug_eventsM	int
)	O
swicol_show_events_to_fd	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
STDERR_FILENO	int
,	O
-	O
1	int
)	O
;	O
check_message	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
SW_CONTROL_SCRIPT_BEGINS	int
,	O
-	O
1	int
,	O
&	O
this_index	int
)	O
;	O
*	O
p_check_status	pointer
=	O
-	O
1	int
;	O
if	O
(	O
check_message	pointer
)	O
{	O
SWLIB_ASSERT	O
(	O
strstr	function
(	O
check_message	pointer
,	O
script_name	pointer
)	O
!=	O
NULL	O
)	O
;	O
script_status	int
=	O
swicol_rpsh_get_event_status	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
NULL	O
,	O
SW_CONTROL_SCRIPT_ENDS	int
,	O
this_index	int
,	O
&	O
this_index	int
)	O
;	O
check_script	pointer
->	O
resultM	int
=	O
script_status	int
;	O
*	O
p_check_status	pointer
=	O
script_status	int
;	O
}	O
else	O
{	O
;	O
}	O
}	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
CISF_PRODUCT	struct
*	O
swpl_cisf_product_create	function
(	O
SWI_PRODUCT	struct
*	O
product	pointer
)	O
{	O
CISF_PRODUCT	struct
*	O
x	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
x	pointer
=	O
(	O
CISF_PRODUCT	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
CISF_PRODUCT	struct
)	O
)	O
;	O
x	pointer
->	O
swiM	pointer
=	O
NULL	O
;	O
x	pointer
->	O
productM	pointer
=	O
NULL	O
;	O
swpl_cisf_init_base	function
(	O
&	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
)	O
;	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
.	O
atM	pointer
=	O
swheader_state_create	function
(	O
)	O
;	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
.	O
typeidM	int
=	O
CISF_ID_PRODUCT	O
;	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
.	O
ixfileM	pointer
=	O
product	pointer
->	O
xfileM	pointer
;	O
x	pointer
->	O
cisf_baseM	struct
.	O
ixfileM	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
=	O
strdup	function
(	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
)	O
;	O
x	pointer
->	O
isetsM	pointer
=	O
vplob_open	function
(	O
)	O
;	O
x	pointer
->	O
cbaM	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
CISFBA	struct
)	O
)	O
;	O
x	pointer
->	O
cbaM	pointer
->	O
base_arrayM	pointer
=	O
vplob_open	function
(	O
)	O
;	O
return	O
x	pointer
;	O
}	O
void	O
swpl_cisf_init_base	function
(	O
CISF_BASE	struct
*	O
x	pointer
)	O
{	O
x	pointer
->	O
ixfileM	pointer
=	O
NULL	O
;	O
x	pointer
->	O
atM	pointer
=	O
NULL	O
;	O
x	pointer
->	O
cf_indexM	int
=	O
-	O
1	int
;	O
x	pointer
->	O
typeidM	int
=	O
-	O
1	int
;	O
}	O
CISF_FILESET	union
*	O
swpl_cisf_fileset_create	function
(	O
void	O
)	O
{	O
CISF_FILESET	union
*	O
x	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
x	pointer
=	O
(	O
CISF_FILESET	union
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
CISF_FILESET	union
)	O
)	O
;	O
swpl_cisf_init_base	function
(	O
&	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
)	O
;	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
.	O
atM	pointer
=	O
swheader_state_create	function
(	O
)	O
;	O
(	O
x	pointer
->	O
cisf_baseM	struct
)	O
.	O
typeidM	int
=	O
CISF_ID_FILESET	O
;	O
return	O
x	pointer
;	O
}	O
void	O
swpl_cisf_product_delete	function
(	O
CISF_PRODUCT	struct
*	O
x	pointer
)	O
{	O
swheader_state_delete	function
(	O
x	pointer
->	O
cisf_baseM	struct
.	O
atM	pointer
)	O
;	O
vplob_close	function
(	O
x	pointer
->	O
isetsM	pointer
)	O
;	O
free	function
(	O
x	pointer
)	O
;	O
}	O
void	O
swpl_cisf_fileset_delete	function
(	O
CISF_FILESET	union
*	O
x	pointer
)	O
{	O
swheader_state_delete	function
(	O
x	pointer
->	O
cisf_baseM	struct
.	O
atM	pointer
)	O
;	O
free	function
(	O
x	pointer
)	O
;	O
}	O
void	O
swpl_cisf_init_single_single	function
(	O
CISF_PRODUCT	struct
*	O
x	pointer
,	O
SWI	struct
*	O
swi	pointer
)	O
{	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
CISF_FILESET	union
*	O
xf	pointer
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
0	int
)	O
;	O
fileset	pointer
=	O
swi_product_get_fileset	function
(	O
product	pointer
,	O
0	int
)	O
;	O
x	pointer
->	O
productM	pointer
=	O
product	pointer
;	O
x	pointer
->	O
cisf_baseM	struct
.	O
cf_indexM	int
=	O
0	int
;	O
x	pointer
->	O
cisf_baseM	struct
.	O
ixfileM	pointer
=	O
product	pointer
->	O
xfileM	pointer
;	O
if	O
(	O
(	O
xf	pointer
=	O
vplob_val	function
(	O
x	pointer
->	O
isetsM	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
{	O
xf	pointer
=	O
swpl_cisf_fileset_create	function
(	O
)	O
;	O
vplob_add	function
(	O
x	pointer
->	O
isetsM	pointer
,	O
xf	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
xf	pointer
->	O
cisf_baseM	struct
.	O
ixfileM	pointer
=	O
fileset	pointer
;	O
xf	pointer
->	O
cisf_baseM	struct
.	O
cf_indexM	int
=	O
0	int
;	O
}	O
int	O
swpl_run_make_installed_live	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
target_path	pointer
)	O
{	O
int	O
ret	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swicol_set_task_idstring	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
SWBIS_TS_make_live_INSTALLED	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"cd \"%s\"\n"	pointer
"case \"$?\" in\n"	pointer
"	0)\n"	pointer
"		sw_retval=0\n"	pointer
"		;;\n"	pointer
"	*)\n"	pointer
"		sw_retval=1\n"	pointer
"		;;\n"	pointer
"esac\n"	pointer
"case \"$sw_retval\" in\n"	pointer
"	0)\n"	pointer
"		mv -f "	pointer
SW_A__INSTALLED	pointer
" "	pointer
SW_A_INSTALLED	pointer
"\n"	pointer
"		sw_retval=$?\n"	pointer
"		;;\n"	pointer
"esac\n"	pointer
"dd count=1 bs=512 of=/dev/null 2>/dev/null\n"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_entryM	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
512	int
,	O
target_path	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWBIS_TS_make_live_INSTALLED	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_8	int
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swpl_run_check_overwrite	function
(	O
GB	struct
*	O
G	pointer
,	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
target_path	pointer
,	O
int	O
fp_keep_fd	int
)	O
{	O
int	O
ret	pointer
;	O
int	O
retval	int
;	O
int	O
keep_fd	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
stopbuf	pointer
;	O
STROB	struct
*	O
payload	pointer
;	O
STROB	struct
*	O
scriptbuf	pointer
;	O
int	O
target_fd0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
stopbuf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
payload	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
scriptbuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
target_fd0	int
=	O
G	pointer
->	O
g_target_fdar	pointer
[	O
0	int
]	O
;	O
retval	int
=	O
0	int
;	O
swpl_print_file_list_to_buf	function
(	O
fl	pointer
,	O
payload	pointer
)	O
;	O
ret	pointer
=	O
swpl_make_here_document_source	function
(	O
G	pointer
,	O
tmp	pointer
,	O
payload	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
retval	int
++	O
;	O
swicol_set_task_idstring	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
SWBIS_TS_check_OVERWRITE	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"sw_retval=0\n"	pointer
"(\n"	pointer
"(\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"dd count=1 bs=512 of=/dev/null 2>/dev/null\n"	pointer
"# result=\"\"\n"	pointer
"IFS=\"`printf '\\n\\t'`\"\n"	pointer
"for file in `\n"	pointer
"%s"	pointer
"`\n"	pointer
"do\n"	pointer
"	if test -e \"$file\"; then\n"	pointer
"		# result=exist\n"	pointer
"		echo \"$file\"\n"	pointer
"	fi\n"	pointer
"#%s\n"	pointer
"done\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
swevent_code	function
(	O
SW_FILE_EXISTS	int
)	O
)	O
;	O
swlib_append_synct_eof	function
(	O
scriptbuf	pointer
)	O
;	O
swi	pointer
->	O
swicolM	pointer
->	O
needs_synct_eoaM	int
=	O
1	int
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
ofd	int
,	O
512	int
,	O
target_path	pointer
,	O
strob_str	function
(	O
scriptbuf	pointer
)	O
,	O
SWBIS_TS_check_OVERWRITE	pointer
)	O
;	O
swi	pointer
->	O
swicolM	pointer
->	O
needs_synct_eoaM	int
=	O
0	int
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
if	O
(	O
fp_keep_fd	int
<	O
0	int
)	O
keep_fd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
else	O
keep_fd	int
=	O
fp_keep_fd	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swlib_synct_suck	function
(	O
keep_fd	int
,	O
target_fd0	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"swlib_synct_suck ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
retval	int
=	O
-	O
3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_lseek	function
(	O
keep_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
swicat_squash_null_bytes	function
(	O
keep_fd	int
)	O
;	O
uxfio_lseek	function
(	O
keep_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swi	pointer
->	O
swicolM	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_500	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
-	O
4	int
;	O
}	O
if	O
(	O
fp_keep_fd	int
<	O
0	int
)	O
swlib_close_memfd	function
(	O
keep_fd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
stopbuf	pointer
)	O
;	O
strob_close	function
(	O
payload	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swpl_run_get_prelink_filelist	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
ofd	int
,	O
int	O
*	O
pfp_prelink_fd	pointer
)	O
{	O
int	O
ret	pointer
;	O
int	O
retval	int
;	O
int	O
prelink_fd	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
scriptbuf	pointer
;	O
int	O
target_fd0	int
;	O
char	O
*	O
target_path	pointer
=	O
"/"	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
scriptbuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
target_fd0	int
=	O
G	pointer
->	O
g_target_fdar	pointer
[	O
0	int
]	O
;	O
retval	int
=	O
0	int
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"PATH=/usr/sbin:/usr/bin:/sbin:\"$PATH\"\n"	pointer
"missing_which() {\n"	pointer
"# Prefix: xxa\n"	pointer
"xxa_pgm=\"$1\"\n"	pointer
"xxa_name=`which $xxa_pgm 2>/dev/null`\n"	pointer
"test -f \"$xxa_name\" -o -h \"$xxa_name\"\n"	pointer
"case \"$?\" in\n"	pointer
"0) echo \"$xxa_name\"; return 0; ;;\n"	pointer
"*) echo \"/\"; return 1; ;;\n"	pointer
"esac\n"	pointer
"return 0\n"	pointer
"}\n"	pointer
"PRELINK=`missing_which prelink`\n"	pointer
"case \"$?\" in\n"	pointer
"0)\n"	pointer
"\"$PRELINK\" -v -p |\n"	pointer
"grep -v '^ ' |\n"	pointer
"sed -e 's/[(\[].*//' |\n"	pointer
"sed -e 's/:$//' |\n"	pointer
"sed -e 's/[ \t]*$//' |\n"	pointer
"sort |\n"	pointer
"dd 2>/dev/null\n"	pointer
";;\n"	pointer
"*)\n"	pointer
";;\n"	pointer
"esac\n"	pointer
)	O
;	O
swicol_set_task_idstring	function
(	O
swicol	pointer
,	O
SWBIS_TS_Get_prelink_filelist	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"sw_retval=0\n"	pointer
"(\n"	pointer
"(\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
scriptbuf	pointer
,	O
STROB_DO_APPEND	int
,	O
"dd count=1 bs=512 of=/dev/null 2>/dev/null\n"	pointer
"IFS=\"`printf ' \\t\\n'`\"\n"	pointer
"%s"	pointer
"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
swlib_append_synct_eof	function
(	O
scriptbuf	pointer
)	O
;	O
swicol	pointer
->	O
needs_synct_eoaM	int
=	O
1	int
;	O
ret	pointer
=	O
swicol_rpsh_task_send_script2	function
(	O
swicol	pointer
,	O
ofd	int
,	O
512	int
,	O
target_path	pointer
,	O
strob_str	function
(	O
scriptbuf	pointer
)	O
,	O
SWBIS_TS_Get_prelink_filelist	pointer
)	O
;	O
swicol	pointer
->	O
needs_synct_eoaM	int
=	O
0	int
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
*	O
pfp_prelink_fd	pointer
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
ofd	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
*	O
pfp_prelink_fd	pointer
=	O
-	O
1	int
;	O
return	O
-	O
2	int
;	O
}	O
prelink_fd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swlib_synct_suck	function
(	O
prelink_fd	int
,	O
target_fd0	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"swlib_synct_suck ret=%d"	pointer
,	O
ret	pointer
)	O
;	O
retval	int
=	O
-	O
3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_lseek	function
(	O
prelink_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
swicat_squash_null_bytes	function
(	O
prelink_fd	int
)	O
;	O
uxfio_lseek	function
(	O
prelink_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	pointer
=	O
swicol_rpsh_task_expect	function
(	O
swicol	pointer
,	O
G	pointer
->	O
g_swi_event_fd	int
,	O
SWICOL_TL_500	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
-	O
4	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
retval	int
==	O
0	int
)	O
{	O
*	O
pfp_prelink_fd	pointer
=	O
prelink_fd	int
;	O
}	O
else	O
{	O
swlib_close_memfd	function
(	O
prelink_fd	int
)	O
;	O
*	O
pfp_prelink_fd	pointer
=	O
-	O
1	int
;	O
}	O
return	O
retval	int
;	O
}	O
void	O
swpl_agent_fail_message	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
current_arg	pointer
,	O
int	O
status	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"SW_AGENT_INITIALIZATION_FAILED for target %s: status=%d\n"	pointer
,	O
current_arg	pointer
,	O
status	int
)	O
;	O
if	O
(	O
status	int
==	O
255	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"possible cause: invalid authentication credentials\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
status	int
==	O
127	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"possible cause: the specified shell not found\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
status	int
==	O
126	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"swbis is unable to operate because the specified or alternate shell program (sh)\n"	pointer
"%s: conforming to POSIX 1003.1 at locations /bin/bash, /bin/ksh, /bin/mksh,\n"	pointer
"%s: /usr/xpg4/bin/sh, or /bin/sh was not found (or found and not suitable).\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
status	int
==	O
124	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"swbis is unable to operate because the shell found in PATH returned by\n"	pointer
"%s: getconf was found not conforming to POSIX 1003.1\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
}	O
