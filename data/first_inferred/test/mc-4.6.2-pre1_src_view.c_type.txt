typedef	O
unsigned	O
char	O
byte	char
;	O
typedef	O
unsigned	O
long	O
offset_type	long
;	O
typedef	O
unsigned	O
int	O
screen_dimen	int
;	O
struct	O
coord_cache_entry	struct
{	O
offset_type	long
cc_offset	long
;	O
offset_type	long
cc_line	long
;	O
offset_type	long
cc_column	long
;	O
offset_type	long
cc_nroff_column	long
;	O
}	O
;	O
struct	O
hexedit_change_node	struct
{	O
struct	O
hexedit_change_node	struct
*	O
next	pointer
;	O
offset_type	long
offset	long
;	O
byte	char
value	pointer
;	O
}	O
;	O
enum	O
view_ds	enum
{	O
DS_NONE	int
,	O
DS_STDIO_PIPE	int
,	O
DS_VFS_PIPE	int
,	O
DS_FILE	int
,	O
DS_STRING	int
}	O
;	O
struct	O
area	struct
{	O
screen_dimen	int
top	pointer
,	O
left	int
;	O
screen_dimen	int
height	int
,	O
width	int
;	O
}	O
;	O
struct	O
WView	struct
{	O
Widget	struct
widget	pointer
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
command	pointer
;	O
enum	O
view_ds	enum
datasource	enum
;	O
FILE	struct
*	O
ds_stdio_pipe	pointer
;	O
int	O
ds_vfs_pipe	int
;	O
int	O
ds_file_fd	int
;	O
off_t	long
ds_file_filesize	long
;	O
off_t	long
ds_file_offset	long
;	O
byte	char
*	O
ds_file_data	pointer
;	O
size_t	long
ds_file_datalen	long
;	O
size_t	long
ds_file_datasize	long
;	O
byte	char
*	O
ds_string_data	pointer
;	O
size_t	long
ds_string_len	long
;	O
gboolean	int
growbuf_in_use	int
;	O
byte	char
*	O
*	O
growbuf_blockptr	pointer
;	O
size_t	long
growbuf_blocks	long
;	O
size_t	long
growbuf_lastindex	long
;	O
gboolean	int
growbuf_finished	int
;	O
gboolean	int
hex_mode	int
;	O
gboolean	int
hexedit_mode	int
;	O
gboolean	int
hexview_in_text	int
;	O
gboolean	int
text_nroff_mode	int
;	O
gboolean	int
text_wrap_mode	int
;	O
gboolean	int
magic_mode	int
;	O
gboolean	int
hexedit_lownibble	int
;	O
GArray	struct
*	O
coord_cache	pointer
;	O
screen_dimen	int
dpy_frame_size	int
;	O
offset_type	long
dpy_start	long
;	O
offset_type	long
dpy_end	long
;	O
offset_type	long
dpy_text_column	long
;	O
offset_type	long
hex_cursor	long
;	O
screen_dimen	int
cursor_col	int
;	O
screen_dimen	int
cursor_row	int
;	O
struct	O
hexedit_change_node	struct
*	O
change_list	pointer
;	O
struct	O
area	struct
status_area	struct
;	O
struct	O
area	struct
ruler_area	struct
;	O
struct	O
area	struct
data_area	struct
;	O
int	O
dirty	int
;	O
gboolean	int
dpy_bbar_dirty	int
;	O
int	O
bytes_per_line	int
;	O
offset_type	long
search_start	long
;	O
offset_type	long
search_length	long
;	O
char	O
*	O
search_exp	pointer
;	O
int	O
direction	int
;	O
void	O
(	O
*	O
last_search	pointer
)	O
(	O
WView	struct
*	O
)	O
;	O
gboolean	int
want_to_quit	int
;	O
int	O
marker	int
;	O
offset_type	long
marks	array
[	O
10	int
]	O
;	O
int	O
move_dir	int
;	O
offset_type	long
update_steps	long
;	O
offset_type	long
update_activate	long
;	O
}	O
;	O
int	O
max_dirt_limit	int
=	O
10	int
;	O
static	O
enum	O
ruler_type	enum
{	O
RULER_NONE	int
,	O
RULER_TOP	int
,	O
RULER_BOTTOM	int
}	O
ruler	enum
=	O
RULER_NONE	int
;	O
int	O
mouse_move_pages_viewer	int
=	O
1	int
;	O
int	O
global_wrap_mode	int
=	O
1	int
;	O
int	O
default_hex_mode	int
=	O
0	int
;	O
int	O
default_magic_flag	int
=	O
1	int
;	O
int	O
default_nroff_flag	int
=	O
1	int
;	O
int	O
altered_hex_mode	int
=	O
0	int
;	O
int	O
altered_magic_flag	int
=	O
0	int
;	O
int	O
altered_nroff_flag	int
=	O
0	int
;	O
static	O
const	O
char	O
hex_char	array
[	O
]	O
=	O
"0123456789ABCDEF"	pointer
;	O
int	O
mcview_remember_file_position	int
=	O
FALSE	O
;	O
static	O
cb_ret_t	enum
view_callback	function
(	O
Widget	struct
*	O
,	O
widget_msg_t	enum
,	O
int	O
)	O
;	O
static	O
int	O
regexp_view_search	function
(	O
WView	struct
*	O
view	pointer
,	O
char	O
*	O
pattern	pointer
,	O
char	O
*	O
string	pointer
,	O
int	O
match_type	int
)	O
;	O
static	O
void	O
view_labels	function
(	O
WView	struct
*	O
view	pointer
)	O
;	O
static	O
void	O
view_init_growbuf	function
(	O
WView	struct
*	O
)	O
;	O
static	O
void	O
view_place_cursor	function
(	O
WView	struct
*	O
view	pointer
)	O
;	O
static	O
void	O
display	function
(	O
WView	struct
*	O
)	O
;	O
static	O
void	O
view_done	function
(	O
WView	struct
*	O
)	O
;	O
static	O
inline	O
screen_dimen	int
dimen_doz	function
(	O
screen_dimen	int
a	pointer
,	O
screen_dimen	int
b	pointer
)	O
{	O
return	O
(	O
a	pointer
>=	O
b	pointer
)	O
?	O
a	pointer
-	O
b	pointer
:	O
0	int
;	O
}	O
static	O
inline	O
screen_dimen	int
dimen_min	function
(	O
screen_dimen	int
a	pointer
,	O
screen_dimen	int
b	pointer
)	O
{	O
return	O
(	O
a	pointer
<	O
b	pointer
)	O
?	O
a	pointer
:	O
b	pointer
;	O
}	O
static	O
inline	O
offset_type	long
offset_doz	function
(	O
offset_type	long
a	pointer
,	O
offset_type	long
b	pointer
)	O
{	O
return	O
(	O
a	pointer
>=	O
b	pointer
)	O
?	O
a	pointer
-	O
b	pointer
:	O
0	int
;	O
}	O
static	O
inline	O
offset_type	long
offset_rounddown	function
(	O
offset_type	long
a	pointer
,	O
offset_type	long
b	pointer
)	O
{	O
assert	O
(	O
b	pointer
!=	O
0	int
)	O
;	O
return	O
a	pointer
-	O
a	pointer
%	O
b	pointer
;	O
}	O
static	O
inline	O
gboolean	int
view_is_in_panel	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
return	O
(	O
view	pointer
->	O
dpy_frame_size	int
!=	O
0	int
)	O
;	O
}	O
static	O
void	O
view_compute_areas	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
struct	O
area	struct
view_area	struct
;	O
screen_dimen	int
height	int
,	O
rest	int
,	O
y	short
;	O
view_area	struct
.	O
top	pointer
=	O
view	pointer
->	O
dpy_frame_size	int
;	O
view_area	struct
.	O
left	int
=	O
view	pointer
->	O
dpy_frame_size	int
;	O
view_area	struct
.	O
height	int
=	O
dimen_doz	function
(	O
view	pointer
->	O
widget	pointer
.	O
lines	pointer
,	O
2	int
*	O
view	pointer
->	O
dpy_frame_size	int
)	O
;	O
view_area	struct
.	O
width	int
=	O
dimen_doz	function
(	O
view	pointer
->	O
widget	pointer
.	O
cols	int
,	O
2	int
*	O
view	pointer
->	O
dpy_frame_size	int
)	O
;	O
view	pointer
->	O
status_area	struct
=	O
view_area	struct
;	O
view	pointer
->	O
ruler_area	struct
=	O
view_area	struct
;	O
view	pointer
->	O
data_area	struct
=	O
view_area	struct
;	O
rest	int
=	O
view_area	struct
.	O
height	int
;	O
height	int
=	O
dimen_min	function
(	O
rest	int
,	O
1	int
)	O
;	O
view	pointer
->	O
status_area	struct
.	O
height	int
=	O
height	int
;	O
rest	int
-=	O
height	int
;	O
height	int
=	O
dimen_min	function
(	O
rest	int
,	O
(	O
ruler	enum
==	O
RULER_NONE	int
||	O
view	pointer
->	O
hex_mode	int
)	O
?	O
0	int
:	O
2	int
)	O
;	O
view	pointer
->	O
ruler_area	struct
.	O
height	int
=	O
height	int
;	O
rest	int
-=	O
height	int
;	O
view	pointer
->	O
data_area	struct
.	O
height	int
=	O
rest	int
;	O
y	short
=	O
view_area	struct
.	O
top	pointer
;	O
view	pointer
->	O
status_area	struct
.	O
top	pointer
=	O
y	short
;	O
y	short
+=	O
view	pointer
->	O
status_area	struct
.	O
height	int
;	O
if	O
(	O
ruler	enum
==	O
RULER_TOP	int
)	O
{	O
view	pointer
->	O
ruler_area	struct
.	O
top	pointer
=	O
y	short
;	O
y	short
+=	O
view	pointer
->	O
ruler_area	struct
.	O
height	int
;	O
}	O
view	pointer
->	O
data_area	struct
.	O
top	pointer
=	O
y	short
;	O
y	short
+=	O
view	pointer
->	O
data_area	struct
.	O
height	int
;	O
if	O
(	O
ruler	enum
==	O
RULER_BOTTOM	int
)	O
{	O
view	pointer
->	O
ruler_area	struct
.	O
top	pointer
=	O
y	short
;	O
y	short
+=	O
view	pointer
->	O
ruler_area	struct
.	O
height	int
;	O
}	O
}	O
static	O
void	O
view_hexedit_free_change_list	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
struct	O
hexedit_change_node	struct
*	O
curr	pointer
,	O
*	O
next	pointer
;	O
for	O
(	O
curr	pointer
=	O
view	pointer
->	O
change_list	pointer
;	O
curr	pointer
!=	O
NULL	O
;	O
curr	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
g_free	function
(	O
curr	pointer
)	O
;	O
}	O
view	pointer
->	O
change_list	pointer
=	O
NULL	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_init_growbuf	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
growbuf_in_use	int
=	O
TRUE	O
;	O
view	pointer
->	O
growbuf_blockptr	pointer
=	O
NULL	O
;	O
view	pointer
->	O
growbuf_blocks	long
=	O
0	int
;	O
view	pointer
->	O
growbuf_lastindex	long
=	O
VIEW_PAGE_SIZE	O
;	O
view	pointer
->	O
growbuf_finished	int
=	O
FALSE	O
;	O
}	O
static	O
void	O
view_growbuf_free	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
size_t	long
i	array
;	O
assert	O
(	O
view	pointer
->	O
growbuf_in_use	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
view	pointer
->	O
growbuf_blocks	long
;	O
i	array
++	O
)	O
g_free	function
(	O
view	pointer
->	O
growbuf_blockptr	pointer
[	O
i	array
]	O
)	O
;	O
g_free	function
(	O
view	pointer
->	O
growbuf_blockptr	pointer
)	O
;	O
view	pointer
->	O
growbuf_blockptr	pointer
=	O
NULL	O
;	O
view	pointer
->	O
growbuf_in_use	int
=	O
FALSE	O
;	O
}	O
static	O
offset_type	long
view_growbuf_filesize	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
assert	O
(	O
view	pointer
->	O
growbuf_in_use	int
)	O
;	O
if	O
(	O
view	pointer
->	O
growbuf_blocks	long
==	O
0	int
)	O
return	O
0	int
;	O
else	O
return	O
(	O
(	O
offset_type	long
)	O
view	pointer
->	O
growbuf_blocks	long
-	O
1	int
)	O
*	O
VIEW_PAGE_SIZE	O
+	O
view	pointer
->	O
growbuf_lastindex	long
;	O
}	O
static	O
void	O
view_growbuf_read_until	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
ofs	long
)	O
{	O
ssize_t	long
nread	long
;	O
byte	char
*	O
p	pointer
;	O
size_t	long
bytesfree	long
;	O
gboolean	int
short_read	int
;	O
assert	O
(	O
view	pointer
->	O
growbuf_in_use	int
)	O
;	O
if	O
(	O
view	pointer
->	O
growbuf_finished	int
)	O
return	O
;	O
short_read	int
=	O
FALSE	O
;	O
while	O
(	O
view_growbuf_filesize	function
(	O
view	pointer
)	O
<	O
ofs	long
||	O
short_read	int
)	O
{	O
if	O
(	O
view	pointer
->	O
growbuf_lastindex	long
==	O
VIEW_PAGE_SIZE	O
)	O
{	O
byte	char
*	O
newblock	pointer
=	O
g_try_malloc	function
(	O
VIEW_PAGE_SIZE	O
)	O
;	O
byte	char
*	O
*	O
newblocks	pointer
=	O
g_try_malloc	function
(	O
sizeof	O
(	O
*	O
newblocks	pointer
)	O
*	O
(	O
view	pointer
->	O
growbuf_blocks	long
+	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
newblock	pointer
||	O
!	O
newblocks	pointer
)	O
{	O
g_free	function
(	O
newblock	pointer
)	O
;	O
g_free	function
(	O
newblocks	pointer
)	O
;	O
return	O
;	O
}	O
memcpy	function
(	O
newblocks	pointer
,	O
view	pointer
->	O
growbuf_blockptr	pointer
,	O
sizeof	O
(	O
*	O
newblocks	pointer
)	O
*	O
view	pointer
->	O
growbuf_blocks	long
)	O
;	O
g_free	function
(	O
view	pointer
->	O
growbuf_blockptr	pointer
)	O
;	O
view	pointer
->	O
growbuf_blockptr	pointer
=	O
newblocks	pointer
;	O
view	pointer
->	O
growbuf_blockptr	pointer
[	O
view	pointer
->	O
growbuf_blocks	long
++	O
]	O
=	O
newblock	pointer
;	O
view	pointer
->	O
growbuf_lastindex	long
=	O
0	int
;	O
}	O
p	pointer
=	O
view	pointer
->	O
growbuf_blockptr	pointer
[	O
view	pointer
->	O
growbuf_blocks	long
-	O
1	int
]	O
+	O
view	pointer
->	O
growbuf_lastindex	long
;	O
bytesfree	long
=	O
VIEW_PAGE_SIZE	O
-	O
view	pointer
->	O
growbuf_lastindex	long
;	O
if	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_STDIO_PIPE	int
)	O
{	O
nread	long
=	O
fread	function
(	O
p	pointer
,	O
1	int
,	O
bytesfree	long
,	O
view	pointer
->	O
ds_stdio_pipe	pointer
)	O
;	O
if	O
(	O
nread	long
==	O
0	int
)	O
{	O
view	pointer
->	O
growbuf_finished	int
=	O
TRUE	O
;	O
(	O
void	O
)	O
pclose	function
(	O
view	pointer
->	O
ds_stdio_pipe	pointer
)	O
;	O
display	function
(	O
view	pointer
)	O
;	O
close_error_pipe	function
(	O
0	int
,	O
NULL	O
)	O
;	O
view	pointer
->	O
ds_stdio_pipe	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_VFS_PIPE	int
)	O
;	O
do	O
{	O
nread	long
=	O
mc_read	function
(	O
view	pointer
->	O
ds_vfs_pipe	int
,	O
p	pointer
,	O
bytesfree	long
)	O
;	O
}	O
while	O
(	O
nread	long
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
nread	long
==	O
-	O
1	int
||	O
nread	long
==	O
0	int
)	O
{	O
view	pointer
->	O
growbuf_finished	int
=	O
TRUE	O
;	O
(	O
void	O
)	O
mc_close	function
(	O
view	pointer
->	O
ds_vfs_pipe	int
)	O
;	O
view	pointer
->	O
ds_vfs_pipe	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
}	O
short_read	int
=	O
(	O
(	O
size_t	long
)	O
nread	long
<	O
bytesfree	long
)	O
;	O
view	pointer
->	O
growbuf_lastindex	long
+=	O
nread	long
;	O
}	O
}	O
static	O
int	O
get_byte_growing_buffer	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
byte_index	long
)	O
{	O
offset_type	long
pageno	long
=	O
byte_index	long
/	O
VIEW_PAGE_SIZE	O
;	O
offset_type	long
pageindex	long
=	O
byte_index	long
%	O
VIEW_PAGE_SIZE	O
;	O
assert	O
(	O
view	pointer
->	O
growbuf_in_use	int
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
pageno	long
!=	O
pageno	long
)	O
return	O
-	O
1	int
;	O
view_growbuf_read_until	function
(	O
view	pointer
,	O
byte_index	long
+	O
1	int
)	O
;	O
if	O
(	O
view	pointer
->	O
growbuf_blocks	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pageno	long
<	O
view	pointer
->	O
growbuf_blocks	long
-	O
1	int
)	O
return	O
view	pointer
->	O
growbuf_blockptr	pointer
[	O
pageno	long
]	O
[	O
pageindex	long
]	O
;	O
if	O
(	O
pageno	long
==	O
view	pointer
->	O
growbuf_blocks	long
-	O
1	int
&&	O
pageindex	long
<	O
view	pointer
->	O
growbuf_lastindex	long
)	O
return	O
view	pointer
->	O
growbuf_blockptr	pointer
[	O
pageno	long
]	O
[	O
pageindex	long
]	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
offset_type	long
view_get_filesize	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
switch	O
(	O
view	pointer
->	O
datasource	enum
)	O
{	O
case	O
DS_NONE	int
:	O
return	O
0	int
;	O
case	O
DS_STDIO_PIPE	int
:	O
case	O
DS_VFS_PIPE	int
:	O
return	O
view_growbuf_filesize	function
(	O
view	pointer
)	O
;	O
case	O
DS_FILE	int
:	O
return	O
view	pointer
->	O
ds_file_filesize	long
;	O
case	O
DS_STRING	int
:	O
return	O
view	pointer
->	O
ds_string_len	long
;	O
default	O
:	O
assert	O
(	O
!	O
"Unknown datasource type"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
inline	O
gboolean	int
view_may_still_grow	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
return	O
(	O
view	pointer
->	O
growbuf_in_use	int
&&	O
!	O
view	pointer
->	O
growbuf_finished	int
)	O
;	O
}	O
static	O
inline	O
gboolean	int
already_loaded	function
(	O
offset_type	long
offset	long
,	O
offset_type	long
idx	int
,	O
size_t	long
size	long
)	O
{	O
return	O
(	O
offset	long
<=	O
idx	int
&&	O
idx	int
-	O
offset	long
<	O
size	long
)	O
;	O
}	O
static	O
inline	O
void	O
view_file_load_data	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
byte_index	long
)	O
{	O
offset_type	long
blockoffset	long
;	O
ssize_t	long
res	long
;	O
size_t	long
bytes_read	pointer
;	O
assert	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_FILE	int
)	O
;	O
if	O
(	O
already_loaded	function
(	O
view	pointer
->	O
ds_file_offset	long
,	O
byte_index	long
,	O
view	pointer
->	O
ds_file_datalen	long
)	O
)	O
return	O
;	O
if	O
(	O
byte_index	long
>=	O
view	pointer
->	O
ds_file_filesize	long
)	O
return	O
;	O
blockoffset	long
=	O
offset_rounddown	function
(	O
byte_index	long
,	O
view	pointer
->	O
ds_file_datasize	long
)	O
;	O
if	O
(	O
mc_lseek	function
(	O
view	pointer
->	O
ds_file_fd	int
,	O
blockoffset	long
,	O
SEEK_SET	int
)	O
==	O
-	O
1	int
)	O
goto	O
error	pointer
;	O
bytes_read	pointer
=	O
0	int
;	O
while	O
(	O
bytes_read	pointer
<	O
view	pointer
->	O
ds_file_datasize	long
)	O
{	O
res	long
=	O
mc_read	function
(	O
view	pointer
->	O
ds_file_fd	int
,	O
view	pointer
->	O
ds_file_data	pointer
+	O
bytes_read	pointer
,	O
view	pointer
->	O
ds_file_datasize	long
-	O
bytes_read	pointer
)	O
;	O
if	O
(	O
res	long
==	O
-	O
1	int
)	O
goto	O
error	pointer
;	O
if	O
(	O
res	long
==	O
0	int
)	O
break	O
;	O
bytes_read	pointer
+=	O
(	O
size_t	long
)	O
res	long
;	O
}	O
view	pointer
->	O
ds_file_offset	long
=	O
blockoffset	long
;	O
if	O
(	O
bytes_read	pointer
>	O
view	pointer
->	O
ds_file_filesize	long
-	O
view	pointer
->	O
ds_file_offset	long
)	O
{	O
view	pointer
->	O
ds_file_datalen	long
=	O
view	pointer
->	O
ds_file_filesize	long
-	O
view	pointer
->	O
ds_file_offset	long
;	O
}	O
else	O
{	O
view	pointer
->	O
ds_file_datalen	long
=	O
bytes_read	pointer
;	O
}	O
return	O
;	O
error	pointer
:	O
view	pointer
->	O
ds_file_datalen	long
=	O
0	int
;	O
}	O
static	O
int	O
get_byte_none	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
byte_index	long
)	O
{	O
assert	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_NONE	int
)	O
;	O
(	O
void	O
)	O
&	O
view	pointer
;	O
(	O
void	O
)	O
byte_index	long
;	O
return	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
get_byte_file	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
byte_index	long
)	O
{	O
assert	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_FILE	int
)	O
;	O
view_file_load_data	function
(	O
view	pointer
,	O
byte_index	long
)	O
;	O
if	O
(	O
already_loaded	function
(	O
view	pointer
->	O
ds_file_offset	long
,	O
byte_index	long
,	O
view	pointer
->	O
ds_file_datalen	long
)	O
)	O
return	O
view	pointer
->	O
ds_file_data	pointer
[	O
byte_index	long
-	O
view	pointer
->	O
ds_file_offset	long
]	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
get_byte_string	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
byte_index	long
)	O
{	O
assert	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_STRING	int
)	O
;	O
if	O
(	O
byte_index	long
<	O
view	pointer
->	O
ds_string_len	long
)	O
return	O
view	pointer
->	O
ds_string_data	pointer
[	O
byte_index	long
]	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
get_byte	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
offset	long
)	O
{	O
switch	O
(	O
view	pointer
->	O
datasource	enum
)	O
{	O
case	O
DS_STDIO_PIPE	int
:	O
case	O
DS_VFS_PIPE	int
:	O
return	O
get_byte_growing_buffer	function
(	O
view	pointer
,	O
offset	long
)	O
;	O
case	O
DS_FILE	int
:	O
return	O
get_byte_file	function
(	O
view	pointer
,	O
offset	long
)	O
;	O
case	O
DS_STRING	int
:	O
return	O
get_byte_string	function
(	O
view	pointer
,	O
offset	long
)	O
;	O
case	O
DS_NONE	int
:	O
return	O
get_byte_none	function
(	O
view	pointer
,	O
offset	long
)	O
;	O
}	O
assert	O
(	O
!	O
"Unknown datasource type"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
get_byte_indexed	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
base	int
,	O
offset_type	long
ofs	long
)	O
{	O
if	O
(	O
base	int
<=	O
OFFSETTYPE_MAX	O
-	O
ofs	long
)	O
return	O
get_byte	function
(	O
view	pointer
,	O
base	int
+	O
ofs	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
view_set_byte	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
offset	long
,	O
byte	char
b	pointer
)	O
{	O
(	O
void	O
)	O
&	O
b	pointer
;	O
assert	O
(	O
offset	long
<	O
view_get_filesize	function
(	O
view	pointer
)	O
)	O
;	O
assert	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_FILE	int
)	O
;	O
view	pointer
->	O
ds_file_datalen	long
=	O
0	int
;	O
}	O
static	O
void	O
view_set_datasource_none	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
datasource	enum
=	O
DS_NONE	int
;	O
}	O
static	O
void	O
view_set_datasource_vfs_pipe	function
(	O
WView	struct
*	O
view	pointer
,	O
int	O
fd	int
)	O
{	O
assert	O
(	O
fd	int
!=	O
-	O
1	int
)	O
;	O
view	pointer
->	O
datasource	enum
=	O
DS_VFS_PIPE	int
;	O
view	pointer
->	O
ds_vfs_pipe	int
=	O
fd	int
;	O
view_init_growbuf	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_set_datasource_stdio_pipe	function
(	O
WView	struct
*	O
view	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
assert	O
(	O
fp	pointer
!=	O
NULL	O
)	O
;	O
view	pointer
->	O
datasource	enum
=	O
DS_STDIO_PIPE	int
;	O
view	pointer
->	O
ds_stdio_pipe	pointer
=	O
fp	pointer
;	O
view_init_growbuf	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_set_datasource_string	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
view	pointer
->	O
datasource	enum
=	O
DS_STRING	int
;	O
view	pointer
->	O
ds_string_data	pointer
=	O
(	O
byte	char
*	O
)	O
g_strdup	function
(	O
s	pointer
)	O
;	O
view	pointer
->	O
ds_string_len	long
=	O
strlen	function
(	O
s	pointer
)	O
;	O
}	O
static	O
void	O
view_set_datasource_file	function
(	O
WView	struct
*	O
view	pointer
,	O
int	O
fd	int
,	O
const	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
view	pointer
->	O
datasource	enum
=	O
DS_FILE	int
;	O
view	pointer
->	O
ds_file_fd	int
=	O
fd	int
;	O
view	pointer
->	O
ds_file_filesize	long
=	O
st	pointer
->	O
st_size	long
;	O
view	pointer
->	O
ds_file_offset	long
=	O
0	int
;	O
view	pointer
->	O
ds_file_data	pointer
=	O
g_malloc	function
(	O
4096	int
)	O
;	O
view	pointer
->	O
ds_file_datalen	long
=	O
0	int
;	O
view	pointer
->	O
ds_file_datasize	long
=	O
4096	int
;	O
}	O
static	O
void	O
view_close_datasource	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
switch	O
(	O
view	pointer
->	O
datasource	enum
)	O
{	O
case	O
DS_NONE	int
:	O
break	O
;	O
case	O
DS_STDIO_PIPE	int
:	O
if	O
(	O
view	pointer
->	O
ds_stdio_pipe	pointer
!=	O
NULL	O
)	O
{	O
(	O
void	O
)	O
pclose	function
(	O
view	pointer
->	O
ds_stdio_pipe	pointer
)	O
;	O
display	function
(	O
view	pointer
)	O
;	O
close_error_pipe	function
(	O
0	int
,	O
NULL	O
)	O
;	O
view	pointer
->	O
ds_stdio_pipe	pointer
=	O
NULL	O
;	O
}	O
view_growbuf_free	function
(	O
view	pointer
)	O
;	O
break	O
;	O
case	O
DS_VFS_PIPE	int
:	O
if	O
(	O
view	pointer
->	O
ds_vfs_pipe	int
!=	O
-	O
1	int
)	O
{	O
(	O
void	O
)	O
mc_close	function
(	O
view	pointer
->	O
ds_vfs_pipe	int
)	O
;	O
view	pointer
->	O
ds_vfs_pipe	int
=	O
-	O
1	int
;	O
}	O
view_growbuf_free	function
(	O
view	pointer
)	O
;	O
break	O
;	O
case	O
DS_FILE	int
:	O
(	O
void	O
)	O
mc_close	function
(	O
view	pointer
->	O
ds_file_fd	int
)	O
;	O
view	pointer
->	O
ds_file_fd	int
=	O
-	O
1	int
;	O
g_free	function
(	O
view	pointer
->	O
ds_file_data	pointer
)	O
;	O
view	pointer
->	O
ds_file_data	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
DS_STRING	int
:	O
g_free	function
(	O
view	pointer
->	O
ds_string_data	pointer
)	O
;	O
view	pointer
->	O
ds_string_data	pointer
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
!	O
"Unknown datasource type"	pointer
)	O
;	O
}	O
view	pointer
->	O
datasource	enum
=	O
DS_NONE	int
;	O
}	O
enum	O
ccache_type	enum
{	O
CCACHE_OFFSET	int
,	O
CCACHE_LINECOL	int
}	O
;	O
static	O
inline	O
gboolean	int
coord_cache_entry_less	function
(	O
const	O
struct	O
coord_cache_entry	struct
*	O
a	pointer
,	O
const	O
struct	O
coord_cache_entry	struct
*	O
b	pointer
,	O
enum	O
ccache_type	enum
crit	enum
,	O
gboolean	int
nroff_mode	int
)	O
{	O
if	O
(	O
crit	enum
==	O
CCACHE_OFFSET	int
)	O
return	O
(	O
a	pointer
->	O
cc_offset	long
<	O
b	pointer
->	O
cc_offset	long
)	O
;	O
if	O
(	O
a	pointer
->	O
cc_line	long
<	O
b	pointer
->	O
cc_line	long
)	O
return	O
TRUE	O
;	O
if	O
(	O
a	pointer
->	O
cc_line	long
==	O
b	pointer
->	O
cc_line	long
)	O
{	O
if	O
(	O
nroff_mode	int
)	O
{	O
return	O
(	O
a	pointer
->	O
cc_nroff_column	long
<	O
b	pointer
->	O
cc_nroff_column	long
)	O
;	O
}	O
else	O
{	O
return	O
(	O
a	pointer
->	O
cc_column	long
<	O
b	pointer
->	O
cc_column	long
)	O
;	O
}	O
}	O
return	O
FALSE	O
;	O
}	O
static	O
inline	O
gboolean	int
is_nroff_sequence	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
offset	long
)	O
{	O
int	O
c0	int
,	O
c1	int
,	O
c2	int
;	O
c1	int
=	O
get_byte_indexed	function
(	O
view	pointer
,	O
offset	long
,	O
1	int
)	O
;	O
if	O
(	O
c1	int
==	O
-	O
1	int
||	O
c1	int
!=	O
'\b'	O
)	O
return	O
FALSE	O
;	O
c0	int
=	O
get_byte_indexed	function
(	O
view	pointer
,	O
offset	long
,	O
0	int
)	O
;	O
if	O
(	O
c0	int
==	O
-	O
1	int
||	O
!	O
is_printable	function
(	O
c0	int
)	O
)	O
return	O
FALSE	O
;	O
c2	int
=	O
get_byte_indexed	function
(	O
view	pointer
,	O
offset	long
,	O
2	int
)	O
;	O
if	O
(	O
c2	int
==	O
-	O
1	int
||	O
!	O
is_printable	function
(	O
c2	int
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
c0	int
==	O
c2	int
||	O
c0	int
==	O
'_'	O
||	O
(	O
c0	int
==	O
'+'	O
&&	O
c2	int
==	O
'o'	O
)	O
)	O
;	O
}	O
static	O
inline	O
guint	int
view_ccache_find	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
struct	O
coord_cache_entry	struct
*	O
cache	pointer
,	O
const	O
struct	O
coord_cache_entry	struct
*	O
coord	pointer
,	O
enum	O
ccache_type	enum
sort_by	enum
)	O
{	O
guint	int
base	int
,	O
i	array
,	O
limit	pointer
;	O
limit	pointer
=	O
view	pointer
->	O
coord_cache	pointer
->	O
len	int
;	O
assert	O
(	O
limit	pointer
!=	O
0	int
)	O
;	O
base	int
=	O
0	int
;	O
while	O
(	O
limit	pointer
>	O
1	int
)	O
{	O
i	array
=	O
base	int
+	O
limit	pointer
/	O
2	int
;	O
if	O
(	O
coord_cache_entry_less	function
(	O
coord	pointer
,	O
&	O
cache	pointer
[	O
i	array
]	O
,	O
sort_by	enum
,	O
view	pointer
->	O
text_nroff_mode	int
)	O
)	O
{	O
}	O
else	O
{	O
base	int
=	O
i	array
;	O
}	O
limit	pointer
=	O
(	O
limit	pointer
+	O
1	int
)	O
/	O
2	int
;	O
}	O
return	O
base	int
;	O
}	O
static	O
void	O
view_ccache_lookup	function
(	O
WView	struct
*	O
view	pointer
,	O
struct	O
coord_cache_entry	struct
*	O
coord	pointer
,	O
enum	O
ccache_type	enum
lookup_what	enum
)	O
{	O
guint	int
i	array
;	O
struct	O
coord_cache_entry	struct
*	O
cache	pointer
,	O
current	pointer
,	O
next	pointer
,	O
entry	struct
;	O
enum	O
ccache_type	enum
sorter	enum
;	O
offset_type	long
limit	pointer
;	O
enum	O
{	O
NROFF_START	int
,	O
NROFF_BACKSPACE	int
,	O
NROFF_CONTINUATION	int
}	O
nroff_state	enum
;	O
if	O
(	O
!	O
view	pointer
->	O
coord_cache	pointer
)	O
{	O
view	pointer
->	O
coord_cache	pointer
=	O
g_array_new	function
(	O
FALSE	O
,	O
FALSE	O
,	O
sizeof	O
(	O
struct	O
coord_cache_entry	struct
)	O
)	O
;	O
current	pointer
.	O
cc_offset	long
=	O
0	int
;	O
current	pointer
.	O
cc_line	long
=	O
0	int
;	O
current	pointer
.	O
cc_column	long
=	O
0	int
;	O
current	pointer
.	O
cc_nroff_column	long
=	O
0	int
;	O
g_array_append_val	O
(	O
view	pointer
->	O
coord_cache	pointer
,	O
current	pointer
)	O
;	O
}	O
sorter	enum
=	O
(	O
lookup_what	enum
==	O
CCACHE_OFFSET	int
)	O
?	O
CCACHE_LINECOL	int
:	O
CCACHE_OFFSET	int
;	O
retry	O
:	O
cache	pointer
=	O
&	O
(	O
g_array_index	O
(	O
view	pointer
->	O
coord_cache	pointer
,	O
struct	O
coord_cache_entry	struct
,	O
0	int
)	O
)	O
;	O
i	array
=	O
view_ccache_find	function
(	O
view	pointer
,	O
cache	pointer
,	O
coord	pointer
,	O
sorter	enum
)	O
;	O
current	pointer
=	O
cache	pointer
[	O
i	array
]	O
;	O
if	O
(	O
i	array
+	O
1	int
<	O
view	pointer
->	O
coord_cache	pointer
->	O
len	int
)	O
limit	pointer
=	O
cache	pointer
[	O
i	array
+	O
1	int
]	O
.	O
cc_offset	long
;	O
else	O
limit	pointer
=	O
current	pointer
.	O
cc_offset	long
+	O
VIEW_COORD_CACHE_GRANUL	int
;	O
entry	struct
=	O
current	pointer
;	O
nroff_state	enum
=	O
NROFF_START	int
;	O
for	O
(	O
;	O
current	pointer
.	O
cc_offset	long
<	O
limit	pointer
;	O
current	pointer
=	O
next	pointer
)	O
{	O
int	O
c	int
,	O
nextc	int
;	O
if	O
(	O
(	O
c	int
=	O
get_byte	function
(	O
view	pointer
,	O
current	pointer
.	O
cc_offset	long
)	O
)	O
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
!	O
coord_cache_entry_less	function
(	O
&	O
current	pointer
,	O
coord	pointer
,	O
sorter	enum
,	O
view	pointer
->	O
text_nroff_mode	int
)	O
)	O
{	O
if	O
(	O
lookup_what	enum
==	O
CCACHE_OFFSET	int
&&	O
view	pointer
->	O
text_nroff_mode	int
&&	O
nroff_state	enum
!=	O
NROFF_START	int
)	O
{	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
next	pointer
.	O
cc_offset	long
=	O
current	pointer
.	O
cc_offset	long
+	O
1	int
;	O
next	pointer
.	O
cc_line	long
=	O
current	pointer
.	O
cc_line	long
;	O
next	pointer
.	O
cc_column	long
=	O
current	pointer
.	O
cc_column	long
+	O
1	int
;	O
next	pointer
.	O
cc_nroff_column	long
=	O
current	pointer
.	O
cc_nroff_column	long
+	O
1	int
;	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
nextc	int
=	O
get_byte_indexed	function
(	O
view	pointer
,	O
current	pointer
.	O
cc_offset	long
,	O
1	int
)	O
;	O
if	O
(	O
nextc	int
==	O
'\r'	O
||	O
nextc	int
==	O
'\n'	O
)	O
{	O
next	pointer
.	O
cc_column	long
=	O
current	pointer
.	O
cc_column	long
;	O
next	pointer
.	O
cc_nroff_column	long
=	O
current	pointer
.	O
cc_nroff_column	long
;	O
}	O
else	O
{	O
next	pointer
.	O
cc_line	long
=	O
current	pointer
.	O
cc_line	long
+	O
1	int
;	O
next	pointer
.	O
cc_column	long
=	O
0	int
;	O
next	pointer
.	O
cc_nroff_column	long
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
nroff_state	enum
==	O
NROFF_BACKSPACE	int
)	O
{	O
next	pointer
.	O
cc_nroff_column	long
=	O
current	pointer
.	O
cc_nroff_column	long
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
{	O
next	pointer
.	O
cc_column	long
=	O
offset_rounddown	function
(	O
current	pointer
.	O
cc_column	long
,	O
8	int
)	O
+	O
8	int
;	O
next	pointer
.	O
cc_nroff_column	long
=	O
offset_rounddown	function
(	O
current	pointer
.	O
cc_nroff_column	long
,	O
8	int
)	O
+	O
8	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
next	pointer
.	O
cc_line	long
=	O
current	pointer
.	O
cc_line	long
+	O
1	int
;	O
next	pointer
.	O
cc_column	long
=	O
0	int
;	O
next	pointer
.	O
cc_nroff_column	long
=	O
0	int
;	O
}	O
else	O
{	O
}	O
switch	O
(	O
nroff_state	enum
)	O
{	O
case	O
NROFF_START	int
:	O
case	O
NROFF_CONTINUATION	int
:	O
if	O
(	O
is_nroff_sequence	function
(	O
view	pointer
,	O
current	pointer
.	O
cc_offset	long
)	O
)	O
nroff_state	enum
=	O
NROFF_BACKSPACE	int
;	O
else	O
nroff_state	enum
=	O
NROFF_START	int
;	O
break	O
;	O
case	O
NROFF_BACKSPACE	int
:	O
nroff_state	enum
=	O
NROFF_CONTINUATION	int
;	O
break	O
;	O
}	O
if	O
(	O
nroff_state	enum
==	O
NROFF_START	int
&&	O
c	int
!=	O
'\r'	O
)	O
entry	struct
=	O
next	pointer
;	O
}	O
if	O
(	O
i	array
+	O
1	int
==	O
view	pointer
->	O
coord_cache	pointer
->	O
len	int
&&	O
entry	struct
.	O
cc_offset	long
!=	O
cache	pointer
[	O
i	array
]	O
.	O
cc_offset	long
)	O
{	O
g_array_append_val	O
(	O
view	pointer
->	O
coord_cache	pointer
,	O
entry	struct
)	O
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
lookup_what	enum
==	O
CCACHE_OFFSET	int
)	O
{	O
coord	pointer
->	O
cc_offset	long
=	O
current	pointer
.	O
cc_offset	long
;	O
}	O
else	O
{	O
coord	pointer
->	O
cc_line	long
=	O
current	pointer
.	O
cc_line	long
;	O
coord	pointer
->	O
cc_column	long
=	O
current	pointer
.	O
cc_column	long
;	O
coord	pointer
->	O
cc_nroff_column	long
=	O
current	pointer
.	O
cc_nroff_column	long
;	O
}	O
}	O
static	O
void	O
view_coord_to_offset	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
*	O
ret_offset	pointer
,	O
offset_type	long
line	int
,	O
offset_type	long
column	pointer
)	O
{	O
struct	O
coord_cache_entry	struct
coord	pointer
;	O
coord	pointer
.	O
cc_line	long
=	O
line	int
;	O
coord	pointer
.	O
cc_column	long
=	O
column	pointer
;	O
coord	pointer
.	O
cc_nroff_column	long
=	O
column	pointer
;	O
view_ccache_lookup	function
(	O
view	pointer
,	O
&	O
coord	pointer
,	O
CCACHE_OFFSET	int
)	O
;	O
*	O
ret_offset	pointer
=	O
coord	pointer
.	O
cc_offset	long
;	O
}	O
static	O
void	O
view_offset_to_coord	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
*	O
ret_line	pointer
,	O
offset_type	long
*	O
ret_column	pointer
,	O
offset_type	long
offset	long
)	O
{	O
struct	O
coord_cache_entry	struct
coord	pointer
;	O
coord	pointer
.	O
cc_offset	long
=	O
offset	long
;	O
view_ccache_lookup	function
(	O
view	pointer
,	O
&	O
coord	pointer
,	O
CCACHE_LINECOL	int
)	O
;	O
*	O
ret_line	pointer
=	O
coord	pointer
.	O
cc_line	long
;	O
*	O
ret_column	pointer
=	O
(	O
view	pointer
->	O
text_nroff_mode	int
)	O
?	O
coord	pointer
.	O
cc_nroff_column	long
:	O
coord	pointer
.	O
cc_column	long
;	O
}	O
static	O
void	O
view_move_up	function
(	O
WView	struct
*	O
,	O
offset_type	long
)	O
;	O
static	O
void	O
view_moveto_bol	function
(	O
WView	struct
*	O
)	O
;	O
static	O
void	O
view_scroll_to_cursor	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
const	O
offset_type	long
bytes	pointer
=	O
view	pointer
->	O
bytes_per_line	int
;	O
const	O
offset_type	long
displaysize	long
=	O
view	pointer
->	O
data_area	struct
.	O
height	int
*	O
bytes	pointer
;	O
const	O
offset_type	long
cursor	long
=	O
view	pointer
->	O
hex_cursor	long
;	O
offset_type	long
topleft	long
=	O
view	pointer
->	O
dpy_start	long
;	O
if	O
(	O
topleft	long
+	O
displaysize	long
<=	O
cursor	long
)	O
topleft	long
=	O
offset_rounddown	function
(	O
cursor	long
,	O
bytes	pointer
)	O
-	O
(	O
displaysize	long
-	O
bytes	pointer
)	O
;	O
if	O
(	O
cursor	long
<	O
topleft	long
)	O
topleft	long
=	O
offset_rounddown	function
(	O
cursor	long
,	O
bytes	pointer
)	O
;	O
view	pointer
->	O
dpy_start	long
=	O
topleft	long
;	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
offset_type	long
line	int
,	O
col	long
,	O
columns	pointer
;	O
columns	pointer
=	O
view	pointer
->	O
data_area	struct
.	O
width	int
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
+	O
view	pointer
->	O
dpy_text_column	long
)	O
;	O
if	O
(	O
columns	pointer
!=	O
0	int
)	O
col	long
=	O
offset_rounddown	function
(	O
col	long
,	O
columns	pointer
)	O
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
col	long
)	O
;	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
}	O
else	O
{	O
}	O
}	O
static	O
void	O
view_movement_fixups	function
(	O
WView	struct
*	O
view	pointer
,	O
gboolean	int
reset_search	int
)	O
{	O
view_scroll_to_cursor	function
(	O
view	pointer
)	O
;	O
if	O
(	O
reset_search	int
)	O
{	O
view	pointer
->	O
search_start	long
=	O
view	pointer
->	O
dpy_start	long
;	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
}	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_moveto_top	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
dpy_start	long
=	O
0	int
;	O
view	pointer
->	O
hex_cursor	long
=	O
0	int
;	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
view_movement_fixups	function
(	O
view	pointer
,	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
view_moveto_bottom	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
offset_type	long
datalines	long
,	O
lines_up	long
,	O
filesize	long
,	O
last_offset	long
;	O
if	O
(	O
view	pointer
->	O
growbuf_in_use	int
)	O
view_growbuf_read_until	function
(	O
view	pointer
,	O
OFFSETTYPE_MAX	O
)	O
;	O
filesize	long
=	O
view_get_filesize	function
(	O
view	pointer
)	O
;	O
last_offset	long
=	O
offset_doz	function
(	O
filesize	long
,	O
1	int
)	O
;	O
datalines	long
=	O
view	pointer
->	O
data_area	struct
.	O
height	int
;	O
lines_up	long
=	O
offset_doz	function
(	O
datalines	long
,	O
1	int
)	O
;	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
view	pointer
->	O
hex_cursor	long
=	O
filesize	long
;	O
view_move_up	function
(	O
view	pointer
,	O
lines_up	long
)	O
;	O
view	pointer
->	O
hex_cursor	long
=	O
last_offset	long
;	O
}	O
else	O
{	O
view	pointer
->	O
dpy_start	long
=	O
last_offset	long
;	O
view_moveto_bol	function
(	O
view	pointer
)	O
;	O
view_move_up	function
(	O
view	pointer
,	O
lines_up	long
)	O
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
view_moveto_bol	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
view	pointer
->	O
hex_cursor	long
-=	O
view	pointer
->	O
hex_cursor	long
%	O
view	pointer
->	O
bytes_per_line	int
;	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
}	O
else	O
{	O
offset_type	long
line	int
,	O
column	pointer
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
column	pointer
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
0	int
)	O
;	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
view_moveto_eol	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
offset_type	long
filesize	long
,	O
bol	long
;	O
bol	long
=	O
offset_rounddown	function
(	O
view	pointer
->	O
hex_cursor	long
,	O
view	pointer
->	O
bytes_per_line	int
)	O
;	O
if	O
(	O
get_byte_indexed	function
(	O
view	pointer
,	O
bol	long
,	O
view	pointer
->	O
bytes_per_line	int
-	O
1	int
)	O
!=	O
-	O
1	int
)	O
{	O
view	pointer
->	O
hex_cursor	long
=	O
bol	long
+	O
view	pointer
->	O
bytes_per_line	int
-	O
1	int
;	O
}	O
else	O
{	O
filesize	long
=	O
view_get_filesize	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
hex_cursor	long
=	O
offset_doz	function
(	O
filesize	long
,	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
}	O
else	O
{	O
offset_type	long
line	int
,	O
col	long
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
OFFSETTYPE_MAX	O
)	O
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
FALSE	O
)	O
;	O
}	O
static	O
void	O
view_moveto_offset	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
offset	long
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
view	pointer
->	O
hex_cursor	long
=	O
offset	long
;	O
view	pointer
->	O
dpy_start	long
=	O
offset	long
-	O
offset	long
%	O
view	pointer
->	O
bytes_per_line	int
;	O
}	O
else	O
{	O
view	pointer
->	O
dpy_start	long
=	O
offset	long
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
view_moveto	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
line	int
,	O
offset_type	long
col	long
)	O
{	O
offset_type	long
offset	long
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
offset	long
,	O
line	int
,	O
col	long
)	O
;	O
view_moveto_offset	function
(	O
view	pointer
,	O
offset	long
)	O
;	O
}	O
static	O
void	O
view_move_up	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
lines	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
offset_type	long
bytes	pointer
=	O
lines	pointer
*	O
view	pointer
->	O
bytes_per_line	int
;	O
if	O
(	O
view	pointer
->	O
hex_cursor	long
>=	O
bytes	pointer
)	O
{	O
view	pointer
->	O
hex_cursor	long
-=	O
bytes	pointer
;	O
if	O
(	O
view	pointer
->	O
hex_cursor	long
<	O
view	pointer
->	O
dpy_start	long
)	O
view	pointer
->	O
dpy_start	long
=	O
offset_doz	function
(	O
view	pointer
->	O
dpy_start	long
,	O
bytes	pointer
)	O
;	O
}	O
else	O
{	O
view	pointer
->	O
hex_cursor	long
%=	O
view	pointer
->	O
bytes_per_line	int
;	O
}	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
const	O
screen_dimen	int
width	int
=	O
view	pointer
->	O
data_area	struct
.	O
width	int
;	O
offset_type	long
i	array
,	O
col	long
,	O
line	int
,	O
linestart	long
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
lines	pointer
;	O
i	array
++	O
)	O
{	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
if	O
(	O
col	long
>=	O
width	int
)	O
{	O
col	long
-=	O
width	int
;	O
}	O
else	O
if	O
(	O
line	int
>=	O
1	int
)	O
{	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
linestart	long
,	O
line	int
,	O
0	int
)	O
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
linestart	long
-	O
1	int
)	O
;	O
if	O
(	O
col	long
>	O
0	int
&&	O
col	long
%	O
width	int
==	O
0	int
)	O
col	long
-=	O
width	int
;	O
else	O
col	long
-=	O
col	long
%	O
width	int
;	O
}	O
else	O
{	O
}	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
col	long
)	O
;	O
}	O
}	O
else	O
{	O
offset_type	long
line	int
,	O
column	pointer
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
column	pointer
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
line	int
=	O
offset_doz	function
(	O
line	int
,	O
lines	pointer
)	O
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
column	pointer
)	O
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
(	O
lines	pointer
!=	O
1	int
)	O
)	O
;	O
}	O
static	O
void	O
view_move_down	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
lines	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
offset_type	long
i	array
,	O
limit	pointer
,	O
last_byte	long
;	O
last_byte	long
=	O
view_get_filesize	function
(	O
view	pointer
)	O
;	O
if	O
(	O
last_byte	long
>=	O
(	O
offset_type	long
)	O
view	pointer
->	O
bytes_per_line	int
)	O
limit	pointer
=	O
last_byte	long
-	O
view	pointer
->	O
bytes_per_line	int
;	O
else	O
limit	pointer
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
lines	pointer
&&	O
view	pointer
->	O
hex_cursor	long
<	O
limit	pointer
;	O
i	array
++	O
)	O
{	O
view	pointer
->	O
hex_cursor	long
+=	O
view	pointer
->	O
bytes_per_line	int
;	O
if	O
(	O
lines	pointer
!=	O
1	int
)	O
view	pointer
->	O
dpy_start	long
+=	O
view	pointer
->	O
bytes_per_line	int
;	O
}	O
}	O
else	O
if	O
(	O
view	pointer
->	O
dpy_end	long
==	O
view_get_filesize	function
(	O
view	pointer
)	O
)	O
{	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
offset_type	long
line	int
,	O
col	long
,	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
lines	pointer
;	O
i	array
++	O
)	O
{	O
offset_type	long
new_offset	long
,	O
chk_line	long
,	O
chk_col	long
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
col	long
+=	O
view	pointer
->	O
data_area	struct
.	O
width	int
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
new_offset	long
,	O
line	int
,	O
col	long
)	O
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
chk_line	long
,	O
&	O
chk_col	long
,	O
new_offset	long
)	O
;	O
if	O
(	O
chk_line	long
==	O
line	int
&&	O
chk_col	long
==	O
col	long
&&	O
get_byte	function
(	O
view	pointer
,	O
new_offset	long
)	O
==	O
'\n'	O
)	O
new_offset	long
++	O
;	O
view	pointer
->	O
dpy_start	long
=	O
new_offset	long
;	O
}	O
}	O
else	O
{	O
offset_type	long
line	int
,	O
col	long
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
line	int
+=	O
lines	pointer
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
col	long
)	O
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
(	O
lines	pointer
!=	O
1	int
)	O
)	O
;	O
}	O
static	O
void	O
view_move_left	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
columns	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
assert	O
(	O
columns	pointer
==	O
1	int
)	O
;	O
if	O
(	O
view	pointer
->	O
hexview_in_text	int
||	O
!	O
view	pointer
->	O
hexedit_lownibble	int
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_cursor	long
>	O
0	int
)	O
view	pointer
->	O
hex_cursor	long
--	O
;	O
}	O
if	O
(	O
!	O
view	pointer
->	O
hexview_in_text	int
)	O
view	pointer
->	O
hexedit_lownibble	int
=	O
!	O
view	pointer
->	O
hexedit_lownibble	int
;	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
}	O
else	O
{	O
if	O
(	O
view	pointer
->	O
dpy_text_column	long
>=	O
columns	pointer
)	O
view	pointer
->	O
dpy_text_column	long
-=	O
columns	pointer
;	O
else	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
FALSE	O
)	O
;	O
}	O
static	O
void	O
view_move_right	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
columns	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
assert	O
(	O
columns	pointer
==	O
1	int
)	O
;	O
if	O
(	O
view	pointer
->	O
hexview_in_text	int
||	O
view	pointer
->	O
hexedit_lownibble	int
)	O
{	O
if	O
(	O
get_byte_indexed	function
(	O
view	pointer
,	O
view	pointer
->	O
hex_cursor	long
,	O
1	int
)	O
!=	O
-	O
1	int
)	O
view	pointer
->	O
hex_cursor	long
++	O
;	O
}	O
if	O
(	O
!	O
view	pointer
->	O
hexview_in_text	int
)	O
view	pointer
->	O
hexedit_lownibble	int
=	O
!	O
view	pointer
->	O
hexedit_lownibble	int
;	O
}	O
else	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
}	O
else	O
{	O
view	pointer
->	O
dpy_text_column	long
+=	O
columns	pointer
;	O
}	O
view_movement_fixups	function
(	O
view	pointer
,	O
FALSE	O
)	O
;	O
}	O
static	O
void	O
view_toggle_hex_mode	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
hex_mode	int
=	O
!	O
view	pointer
->	O
hex_mode	int
;	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
view	pointer
->	O
hex_cursor	long
=	O
view	pointer
->	O
dpy_start	long
;	O
view	pointer
->	O
dpy_start	long
=	O
offset_rounddown	function
(	O
view	pointer
->	O
dpy_start	long
,	O
view	pointer
->	O
bytes_per_line	int
)	O
;	O
view	pointer
->	O
widget	pointer
.	O
options	int
|=	O
W_WANT_CURSOR	O
;	O
}	O
else	O
{	O
view	pointer
->	O
dpy_start	long
=	O
view	pointer
->	O
hex_cursor	long
;	O
view_moveto_bol	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
widget	pointer
.	O
options	int
&=	O
~	O
W_WANT_CURSOR	O
;	O
}	O
altered_hex_mode	int
=	O
1	int
;	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_toggle_hexedit_mode	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
hexedit_mode	int
=	O
!	O
view	pointer
->	O
hexedit_mode	int
;	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_toggle_wrap_mode	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
text_wrap_mode	int
=	O
!	O
view	pointer
->	O
text_wrap_mode	int
;	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
view_scroll_to_cursor	function
(	O
view	pointer
)	O
;	O
}	O
else	O
{	O
offset_type	long
line	int
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
(	O
view	pointer
->	O
dpy_text_column	long
)	O
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
view_coord_to_offset	function
(	O
view	pointer
,	O
&	O
(	O
view	pointer
->	O
dpy_start	long
)	O
,	O
line	int
,	O
0	int
)	O
;	O
}	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_toggle_nroff_mode	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view	pointer
->	O
text_nroff_mode	int
=	O
!	O
view	pointer
->	O
text_nroff_mode	int
;	O
altered_nroff_flag	int
=	O
1	int
;	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_toggle_magic_mode	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
char	O
*	O
filename	pointer
,	O
*	O
command	pointer
;	O
altered_magic_flag	int
=	O
1	int
;	O
view	pointer
->	O
magic_mode	int
=	O
!	O
view	pointer
->	O
magic_mode	int
;	O
filename	pointer
=	O
g_strdup	function
(	O
view	pointer
->	O
filename	pointer
)	O
;	O
command	pointer
=	O
g_strdup	function
(	O
view	pointer
->	O
command	pointer
)	O
;	O
view_done	function
(	O
view	pointer
)	O
;	O
view_load	function
(	O
view	pointer
,	O
command	pointer
,	O
filename	pointer
,	O
0	int
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
g_free	function
(	O
command	pointer
)	O
;	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_done	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
mcview_remember_file_position	int
&&	O
view	pointer
->	O
filename	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
canon_fname	pointer
;	O
offset_type	long
line	int
,	O
col	long
;	O
canon_fname	pointer
=	O
vfs_canon	function
(	O
view	pointer
->	O
filename	pointer
)	O
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
save_file_position	function
(	O
canon_fname	pointer
,	O
line	int
+	O
1	int
,	O
col	long
)	O
;	O
g_free	function
(	O
canon_fname	pointer
)	O
;	O
}	O
default_hex_mode	int
=	O
view	pointer
->	O
hex_mode	int
;	O
default_nroff_flag	int
=	O
view	pointer
->	O
text_nroff_mode	int
;	O
default_magic_flag	int
=	O
view	pointer
->	O
magic_mode	int
;	O
global_wrap_mode	int
=	O
view	pointer
->	O
text_wrap_mode	int
;	O
g_free	function
(	O
view	pointer
->	O
filename	pointer
)	O
,	O
view	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
g_free	function
(	O
view	pointer
->	O
command	pointer
)	O
,	O
view	pointer
->	O
command	pointer
=	O
NULL	O
;	O
view_close_datasource	function
(	O
view	pointer
)	O
;	O
if	O
(	O
view	pointer
->	O
coord_cache	pointer
)	O
{	O
g_array_free	function
(	O
view	pointer
->	O
coord_cache	pointer
,	O
TRUE	O
)	O
,	O
view	pointer
->	O
coord_cache	pointer
=	O
NULL	O
;	O
}	O
view_hexedit_free_change_list	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_show_error	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
view_close_datasource	function
(	O
view	pointer
)	O
;	O
if	O
(	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
{	O
view_set_datasource_string	function
(	O
view	pointer
,	O
msg	pointer
)	O
;	O
}	O
else	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
"%s"	pointer
,	O
msg	pointer
)	O
;	O
}	O
}	O
static	O
gboolean	int
view_load_command_output	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
char	O
*	O
command	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
view_close_datasource	function
(	O
view	pointer
)	O
;	O
open_error_pipe	function
(	O
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
popen	function
(	O
command	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
display	function
(	O
view	pointer
)	O
;	O
if	O
(	O
!	O
close_error_pipe	function
(	O
view_is_in_panel	function
(	O
view	pointer
)	O
?	O
-	O
1	int
:	O
1	int
,	O
NULL	O
)	O
)	O
view_show_error	function
(	O
view	pointer
,	O
_	O
(	O
" Cannot spawn child process "	pointer
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
view_set_datasource_stdio_pipe	function
(	O
view	pointer
,	O
fp	pointer
)	O
;	O
if	O
(	O
get_byte	function
(	O
view	pointer
,	O
0	int
)	O
==	O
-	O
1	int
)	O
{	O
view_close_datasource	function
(	O
view	pointer
)	O
;	O
display	function
(	O
view	pointer
)	O
;	O
if	O
(	O
!	O
close_error_pipe	function
(	O
view_is_in_panel	function
(	O
view	pointer
)	O
?	O
-	O
1	int
:	O
1	int
,	O
NULL	O
)	O
)	O
view_show_error	function
(	O
view	pointer
,	O
_	O
(	O
"Empty output from child filter"	pointer
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
gboolean	int
view_load	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
char	O
*	O
command	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
int	O
start_line	int
)	O
{	O
int	O
i	array
,	O
type	enum
;	O
int	O
fd	int
=	O
-	O
1	int
;	O
char	O
tmp	array
[	O
BUF_MEDIUM	int
]	O
;	O
struct	O
stat	struct
st	pointer
;	O
gboolean	int
retval	pointer
=	O
FALSE	O
;	O
assert	O
(	O
view	pointer
->	O
bytes_per_line	int
!=	O
0	int
)	O
;	O
view_done	function
(	O
view	pointer
)	O
;	O
view_set_datasource_none	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
filename	pointer
=	O
g_strdup	function
(	O
file	pointer
)	O
;	O
view	pointer
->	O
command	pointer
=	O
0	int
;	O
view	pointer
->	O
marker	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
10	int
;	O
i	array
++	O
)	O
view	pointer
->	O
marks	array
[	O
i	array
]	O
=	O
0	int
;	O
if	O
(	O
!	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
{	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
}	O
if	O
(	O
command	pointer
&&	O
(	O
view	pointer
->	O
magic_mode	int
||	O
file	pointer
==	O
NULL	O
||	O
file	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
retval	pointer
=	O
view_load_command_output	function
(	O
view	pointer
,	O
command	pointer
)	O
;	O
}	O
else	O
if	O
(	O
file	pointer
!=	O
NULL	O
&&	O
file	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
fd	int
=	O
mc_open	function
(	O
file	pointer
,	O
O_RDONLY	int
|	O
O_NONBLOCK	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
g_snprintf	function
(	O
tmp	array
,	O
sizeof	O
(	O
tmp	array
)	O
,	O
_	O
(	O
" Cannot open \"%s\"\n %s "	pointer
)	O
,	O
file	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
view_show_error	function
(	O
view	pointer
,	O
tmp	array
)	O
;	O
goto	O
finish	O
;	O
}	O
if	O
(	O
mc_fstat	function
(	O
fd	int
,	O
&	O
st	pointer
)	O
==	O
-	O
1	int
)	O
{	O
mc_close	function
(	O
fd	int
)	O
;	O
g_snprintf	function
(	O
tmp	array
,	O
sizeof	O
(	O
tmp	array
)	O
,	O
_	O
(	O
" Cannot stat \"%s\"\n %s "	pointer
)	O
,	O
file	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
view_show_error	function
(	O
view	pointer
,	O
tmp	array
)	O
;	O
goto	O
finish	O
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
mc_close	function
(	O
fd	int
)	O
;	O
view_show_error	function
(	O
view	pointer
,	O
_	O
(	O
" Cannot view: not a regular file "	pointer
)	O
)	O
;	O
goto	O
finish	O
;	O
}	O
if	O
(	O
st	pointer
.	O
st_size	long
==	O
0	int
||	O
mc_lseek	function
(	O
fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
==	O
-	O
1	int
)	O
{	O
view_set_datasource_vfs_pipe	function
(	O
view	pointer
,	O
fd	int
)	O
;	O
}	O
else	O
{	O
type	enum
=	O
get_compression_type	function
(	O
fd	int
)	O
;	O
if	O
(	O
view	pointer
->	O
magic_mode	int
&&	O
(	O
type	enum
!=	O
COMPRESSION_NONE	int
)	O
)	O
{	O
g_free	function
(	O
view	pointer
->	O
filename	pointer
)	O
;	O
view	pointer
->	O
filename	pointer
=	O
g_strconcat	function
(	O
file	pointer
,	O
decompress_extension	function
(	O
type	enum
)	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
view_set_datasource_file	function
(	O
view	pointer
,	O
fd	int
,	O
&	O
st	pointer
)	O
;	O
}	O
retval	pointer
=	O
TRUE	O
;	O
}	O
finish	O
:	O
view	pointer
->	O
command	pointer
=	O
g_strdup	function
(	O
command	pointer
)	O
;	O
view	pointer
->	O
dpy_start	long
=	O
0	int
;	O
view	pointer
->	O
search_start	long
=	O
0	int
;	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
view	pointer
->	O
last_search	pointer
=	O
0	int
;	O
assert	O
(	O
view	pointer
->	O
bytes_per_line	int
!=	O
0	int
)	O
;	O
if	O
(	O
mcview_remember_file_position	int
&&	O
file	pointer
!=	O
NULL	O
&&	O
start_line	int
==	O
0	int
)	O
{	O
long	O
line	int
,	O
col	long
;	O
char	O
*	O
canon_fname	pointer
;	O
canon_fname	pointer
=	O
vfs_canon	function
(	O
file	pointer
)	O
;	O
load_file_position	function
(	O
file	pointer
,	O
&	O
line	int
,	O
&	O
col	long
)	O
;	O
g_free	function
(	O
canon_fname	pointer
)	O
;	O
view_moveto	function
(	O
view	pointer
,	O
offset_doz	function
(	O
line	int
,	O
1	int
)	O
,	O
col	long
)	O
;	O
}	O
else	O
if	O
(	O
start_line	int
>	O
0	int
)	O
{	O
view_moveto	function
(	O
view	pointer
,	O
start_line	int
-	O
1	int
,	O
0	int
)	O
;	O
}	O
view	pointer
->	O
hexedit_lownibble	int
=	O
FALSE	O
;	O
view	pointer
->	O
hexview_in_text	int
=	O
FALSE	O
;	O
view	pointer
->	O
change_list	pointer
=	O
NULL	O
;	O
return	O
retval	pointer
;	O
}	O
static	O
void	O
view_update_bytes_per_line	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
const	O
screen_dimen	int
cols	int
=	O
view	pointer
->	O
data_area	struct
.	O
width	int
;	O
int	O
bytes	pointer
;	O
if	O
(	O
cols	int
<	O
8	int
+	O
17	int
)	O
bytes	pointer
=	O
4	int
;	O
else	O
bytes	pointer
=	O
4	int
*	O
(	O
(	O
cols	int
-	O
8	int
)	O
/	O
(	O
(	O
cols	int
<	O
80	int
)	O
?	O
17	int
:	O
18	int
)	O
)	O
;	O
assert	O
(	O
bytes	pointer
!=	O
0	int
)	O
;	O
view	pointer
->	O
bytes_per_line	int
=	O
bytes	pointer
;	O
view	pointer
->	O
dirty	int
=	O
max_dirt_limit	int
+	O
1	int
;	O
}	O
static	O
void	O
view_percent	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
p	pointer
)	O
{	O
const	O
screen_dimen	int
top	pointer
=	O
view	pointer
->	O
status_area	struct
.	O
top	pointer
;	O
const	O
screen_dimen	int
right	int
=	O
view	pointer
->	O
status_area	struct
.	O
left	int
+	O
view	pointer
->	O
status_area	struct
.	O
width	int
;	O
const	O
screen_dimen	int
height	int
=	O
view	pointer
->	O
status_area	struct
.	O
height	int
;	O
int	O
percent	int
;	O
offset_type	long
filesize	long
;	O
if	O
(	O
height	int
<	O
1	int
||	O
right	int
<	O
4	int
)	O
return	O
;	O
if	O
(	O
view_may_still_grow	function
(	O
view	pointer
)	O
)	O
return	O
;	O
filesize	long
=	O
view_get_filesize	function
(	O
view	pointer
)	O
;	O
if	O
(	O
filesize	long
==	O
0	int
||	O
view	pointer
->	O
dpy_end	long
==	O
filesize	long
)	O
percent	int
=	O
100	int
;	O
else	O
if	O
(	O
p	pointer
>	O
(	O
INT_MAX	O
/	O
100	int
)	O
)	O
percent	int
=	O
p	pointer
/	O
(	O
filesize	long
/	O
100	int
)	O
;	O
else	O
percent	int
=	O
p	pointer
*	O
100	int
/	O
filesize	long
;	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
,	O
right	int
-	O
4	int
)	O
;	O
tty_printf	function
(	O
"%3d%%"	pointer
,	O
percent	int
)	O
;	O
}	O
static	O
void	O
view_display_status	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
const	O
screen_dimen	int
top	pointer
=	O
view	pointer
->	O
status_area	struct
.	O
top	pointer
;	O
const	O
screen_dimen	int
left	int
=	O
view	pointer
->	O
status_area	struct
.	O
left	int
;	O
const	O
screen_dimen	int
width	int
=	O
view	pointer
->	O
status_area	struct
.	O
width	int
;	O
const	O
screen_dimen	int
height	int
=	O
view	pointer
->	O
status_area	struct
.	O
height	int
;	O
const	O
char	O
*	O
file_label	pointer
,	O
*	O
file_name	pointer
;	O
screen_dimen	int
file_label_width	int
;	O
int	O
i	array
;	O
if	O
(	O
height	int
<	O
1	int
)	O
return	O
;	O
tty_setcolor	function
(	O
SELECTED_COLOR	O
)	O
;	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
,	O
left	int
)	O
;	O
hline	function
(	O
' '	O
,	O
width	int
)	O
;	O
file_label	pointer
=	O
_	O
(	O
"File: %s"	pointer
)	O
;	O
file_label_width	int
=	O
strlen	function
(	O
file_label	pointer
)	O
-	O
2	int
;	O
file_name	pointer
=	O
view	pointer
->	O
filename	pointer
?	O
view	pointer
->	O
filename	pointer
:	O
view	pointer
->	O
command	pointer
?	O
view	pointer
->	O
command	pointer
:	O
""	pointer
;	O
if	O
(	O
width	int
<	O
file_label_width	int
+	O
6	int
)	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	function
(	O
file_name	pointer
,	O
width	int
)	O
)	O
;	O
else	O
{	O
i	array
=	O
(	O
width	int
>	O
22	int
?	O
22	int
:	O
width	int
)	O
-	O
file_label_width	int
;	O
tty_printf	function
(	O
file_label	pointer
,	O
name_trunc	function
(	O
file_name	pointer
,	O
i	array
)	O
)	O
;	O
if	O
(	O
width	int
>	O
46	int
)	O
{	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
,	O
left	int
+	O
24	int
)	O
;	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
tty_printf	function
(	O
_	O
(	O
"Offset 0x%08lx"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
view	pointer
->	O
hex_cursor	long
)	O
;	O
else	O
{	O
offset_type	long
line	int
,	O
col	long
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
tty_printf	function
(	O
_	O
(	O
"Line %lu Col %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
line	int
+	O
1	int
,	O
(	O
unsigned	O
long	O
)	O
(	O
view	pointer
->	O
text_wrap_mode	int
?	O
col	long
:	O
view	pointer
->	O
dpy_text_column	long
)	O
)	O
;	O
}	O
}	O
if	O
(	O
width	int
>	O
62	int
)	O
{	O
offset_type	long
filesize	long
;	O
filesize	long
=	O
view_get_filesize	function
(	O
view	pointer
)	O
;	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
,	O
left	int
+	O
43	int
)	O
;	O
if	O
(	O
!	O
view_may_still_grow	function
(	O
view	pointer
)	O
)	O
{	O
tty_printf	function
(	O
_	O
(	O
"%s bytes"	pointer
)	O
,	O
size_trunc	function
(	O
filesize	long
)	O
)	O
;	O
}	O
else	O
{	O
tty_printf	function
(	O
_	O
(	O
">= %s bytes"	pointer
)	O
,	O
size_trunc	function
(	O
filesize	long
)	O
)	O
;	O
}	O
}	O
if	O
(	O
width	int
>	O
26	int
)	O
{	O
view_percent	function
(	O
view	pointer
,	O
view	pointer
->	O
hex_mode	int
?	O
view	pointer
->	O
hex_cursor	long
:	O
view	pointer
->	O
dpy_end	long
)	O
;	O
}	O
}	O
tty_setcolor	function
(	O
SELECTED_COLOR	O
)	O
;	O
}	O
static	O
inline	O
void	O
view_display_clean	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
tty_setcolor	function
(	O
NORMAL_COLOR	O
)	O
;	O
widget_erase	function
(	O
(	O
Widget	struct
*	O
)	O
view	pointer
)	O
;	O
if	O
(	O
view	pointer
->	O
dpy_frame_size	int
!=	O
0	int
)	O
{	O
draw_double_box	function
(	O
view	pointer
->	O
widget	pointer
.	O
parent	pointer
,	O
view	pointer
->	O
widget	pointer
.	O
y	short
,	O
view	pointer
->	O
widget	pointer
.	O
x	array
,	O
view	pointer
->	O
widget	pointer
.	O
lines	pointer
,	O
view	pointer
->	O
widget	pointer
.	O
cols	int
)	O
;	O
}	O
}	O
typedef	O
enum	O
{	O
MARK_NORMAL	int
,	O
MARK_SELECTED	int
,	O
MARK_CURSOR	int
,	O
MARK_CHANGED	int
}	O
mark_t	enum
;	O
static	O
inline	O
int	O
view_count_backspaces	function
(	O
WView	struct
*	O
view	pointer
,	O
off_t	long
offset	long
)	O
{	O
int	O
backspaces	int
=	O
0	int
;	O
while	O
(	O
offset	long
>=	O
2	int
*	O
backspaces	int
&&	O
get_byte	function
(	O
view	pointer
,	O
offset	long
-	O
2	int
*	O
backspaces	int
)	O
==	O
'\b'	O
)	O
backspaces	int
++	O
;	O
return	O
backspaces	int
;	O
}	O
static	O
void	O
view_display_ruler	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
static	O
const	O
char	O
ruler_chars	array
[	O
]	O
=	O
"|----*----"	pointer
;	O
const	O
screen_dimen	int
top	pointer
=	O
view	pointer
->	O
ruler_area	struct
.	O
top	pointer
;	O
const	O
screen_dimen	int
left	int
=	O
view	pointer
->	O
ruler_area	struct
.	O
left	int
;	O
const	O
screen_dimen	int
width	int
=	O
view	pointer
->	O
ruler_area	struct
.	O
width	int
;	O
const	O
screen_dimen	int
height	int
=	O
view	pointer
->	O
ruler_area	struct
.	O
height	int
;	O
const	O
screen_dimen	int
line_row	int
=	O
(	O
ruler	enum
==	O
RULER_TOP	int
)	O
?	O
0	int
:	O
1	int
;	O
const	O
screen_dimen	int
nums_row	int
=	O
(	O
ruler	enum
==	O
RULER_TOP	int
)	O
?	O
1	int
:	O
0	int
;	O
char	O
r_buff	array
[	O
10	int
]	O
;	O
offset_type	long
cl	pointer
;	O
screen_dimen	int
c	int
;	O
if	O
(	O
ruler	enum
==	O
RULER_NONE	int
||	O
height	int
<	O
1	int
)	O
return	O
;	O
tty_setcolor	function
(	O
MARKED_COLOR	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
width	int
;	O
c	int
++	O
)	O
{	O
cl	pointer
=	O
view	pointer
->	O
dpy_text_column	long
+	O
c	int
;	O
if	O
(	O
line_row	int
<	O
height	int
)	O
{	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
+	O
line_row	int
,	O
left	int
+	O
c	int
)	O
;	O
tty_print_char	function
(	O
ruler_chars	array
[	O
cl	pointer
%	O
10	int
]	O
)	O
;	O
}	O
if	O
(	O
(	O
cl	pointer
!=	O
0	int
)	O
&&	O
(	O
cl	pointer
%	O
10	int
)	O
==	O
0	int
)	O
{	O
g_snprintf	function
(	O
r_buff	array
,	O
sizeof	O
(	O
r_buff	array
)	O
,	O
"%"	pointer
OFFSETTYPE_PRId	pointer
,	O
cl	pointer
)	O
;	O
if	O
(	O
nums_row	int
<	O
height	int
)	O
{	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
+	O
nums_row	int
,	O
left	int
+	O
c	int
-	O
1	int
)	O
;	O
tty_print_string	function
(	O
r_buff	array
)	O
;	O
}	O
}	O
}	O
attrset	function
(	O
NORMAL_COLOR	O
)	O
;	O
}	O
static	O
void	O
view_display_hex	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
const	O
screen_dimen	int
top	pointer
=	O
view	pointer
->	O
data_area	struct
.	O
top	pointer
;	O
const	O
screen_dimen	int
left	int
=	O
view	pointer
->	O
data_area	struct
.	O
left	int
;	O
const	O
screen_dimen	int
height	int
=	O
view	pointer
->	O
data_area	struct
.	O
height	int
;	O
const	O
screen_dimen	int
width	int
=	O
view	pointer
->	O
data_area	struct
.	O
width	int
;	O
const	O
int	O
ngroups	int
=	O
view	pointer
->	O
bytes_per_line	int
/	O
4	int
;	O
const	O
screen_dimen	int
text_start	int
=	O
8	int
+	O
13	int
*	O
ngroups	int
+	O
(	O
(	O
width	int
<	O
80	int
)	O
?	O
0	int
:	O
(	O
ngroups	int
-	O
1	int
+	O
1	int
)	O
)	O
;	O
screen_dimen	int
row	int
,	O
col	long
;	O
offset_type	long
from	char
;	O
int	O
c	int
;	O
mark_t	enum
boldflag	enum
=	O
MARK_NORMAL	int
;	O
struct	O
hexedit_change_node	struct
*	O
curr	pointer
=	O
view	pointer
->	O
change_list	pointer
;	O
size_t	long
i	array
;	O
char	O
hex_buff	array
[	O
10	int
]	O
;	O
int	O
bytes	pointer
;	O
view_display_clean	function
(	O
view	pointer
)	O
;	O
from	char
=	O
view	pointer
->	O
dpy_start	long
;	O
while	O
(	O
curr	pointer
&&	O
(	O
curr	pointer
->	O
offset	long
<	O
from	char
)	O
)	O
{	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
}	O
for	O
(	O
row	int
=	O
0	int
;	O
get_byte	function
(	O
view	pointer
,	O
from	char
)	O
!=	O
-	O
1	int
&&	O
row	int
<	O
height	int
;	O
row	int
++	O
)	O
{	O
col	long
=	O
0	int
;	O
g_snprintf	function
(	O
hex_buff	array
,	O
sizeof	O
(	O
hex_buff	array
)	O
,	O
"%08"	pointer
OFFSETTYPE_PRIX	pointer
" "	pointer
,	O
from	char
)	O
;	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
+	O
row	int
,	O
left	int
)	O
;	O
tty_setcolor	function
(	O
MARKED_COLOR	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
col	long
<	O
width	int
&&	O
hex_buff	array
[	O
i	array
]	O
!=	O
'\0'	O
;	O
i	array
++	O
)	O
{	O
tty_print_char	function
(	O
hex_buff	array
[	O
i	array
]	O
)	O
;	O
col	long
+=	O
1	int
;	O
}	O
tty_setcolor	function
(	O
NORMAL_COLOR	O
)	O
;	O
for	O
(	O
bytes	pointer
=	O
0	int
;	O
bytes	pointer
<	O
view	pointer
->	O
bytes_per_line	int
;	O
bytes	pointer
++	O
,	O
from	char
++	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
get_byte	function
(	O
view	pointer
,	O
from	char
)	O
)	O
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
from	char
==	O
view	pointer
->	O
hex_cursor	long
&&	O
!	O
view	pointer
->	O
hexview_in_text	int
)	O
{	O
view	pointer
->	O
cursor_row	int
=	O
row	int
;	O
view	pointer
->	O
cursor_col	int
=	O
col	long
;	O
}	O
boldflag	enum
=	O
(	O
from	char
==	O
view	pointer
->	O
hex_cursor	long
)	O
?	O
MARK_CURSOR	int
:	O
(	O
curr	pointer
!=	O
NULL	O
&&	O
from	char
==	O
curr	pointer
->	O
offset	long
)	O
?	O
MARK_CHANGED	int
:	O
(	O
view	pointer
->	O
search_start	long
<=	O
from	char
&&	O
from	char
<	O
view	pointer
->	O
search_start	long
+	O
view	pointer
->	O
search_length	long
)	O
?	O
MARK_SELECTED	int
:	O
MARK_NORMAL	int
;	O
if	O
(	O
curr	pointer
!=	O
NULL	O
&&	O
from	char
==	O
curr	pointer
->	O
offset	long
)	O
{	O
c	int
=	O
curr	pointer
->	O
value	pointer
;	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
}	O
tty_setcolor	function
(	O
boldflag	enum
==	O
MARK_NORMAL	int
?	O
NORMAL_COLOR	O
:	O
boldflag	enum
==	O
MARK_SELECTED	int
?	O
MARKED_COLOR	O
:	O
boldflag	enum
==	O
MARK_CHANGED	int
?	O
VIEW_UNDERLINED_COLOR	O
:	O
view	pointer
->	O
hexview_in_text	int
?	O
MARKED_SELECTED_COLOR	O
:	O
VIEW_UNDERLINED_COLOR	O
)	O
;	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
+	O
row	int
,	O
left	int
+	O
col	long
)	O
;	O
if	O
(	O
col	long
<	O
width	int
)	O
{	O
tty_print_char	function
(	O
hex_char	array
[	O
c	int
/	O
16	int
]	O
)	O
;	O
col	long
+=	O
1	int
;	O
}	O
if	O
(	O
col	long
<	O
width	int
)	O
{	O
tty_print_char	function
(	O
hex_char	array
[	O
c	int
%	O
16	int
]	O
)	O
;	O
col	long
+=	O
1	int
;	O
}	O
tty_setcolor	function
(	O
NORMAL_COLOR	O
)	O
;	O
if	O
(	O
bytes	pointer
!=	O
view	pointer
->	O
bytes_per_line	int
-	O
1	int
)	O
{	O
if	O
(	O
col	long
<	O
width	int
)	O
{	O
tty_print_char	function
(	O
' '	O
)	O
;	O
col	long
+=	O
1	int
;	O
}	O
if	O
(	O
bytes	pointer
%	O
4	int
==	O
3	int
)	O
{	O
if	O
(	O
view	pointer
->	O
data_area	struct
.	O
width	int
>=	O
80	int
&&	O
col	long
<	O
width	int
)	O
{	O
tty_print_one_vline	function
(	O
)	O
;	O
col	long
+=	O
1	int
;	O
}	O
if	O
(	O
col	long
<	O
width	int
)	O
{	O
tty_print_char	function
(	O
' '	O
)	O
;	O
col	long
+=	O
1	int
;	O
}	O
}	O
}	O
tty_setcolor	function
(	O
boldflag	enum
==	O
MARK_NORMAL	int
?	O
NORMAL_COLOR	O
:	O
boldflag	enum
==	O
MARK_SELECTED	int
?	O
MARKED_COLOR	O
:	O
boldflag	enum
==	O
MARK_CHANGED	int
?	O
VIEW_UNDERLINED_COLOR	O
:	O
view	pointer
->	O
hexview_in_text	int
?	O
VIEW_UNDERLINED_COLOR	O
:	O
MARKED_SELECTED_COLOR	O
)	O
;	O
c	int
=	O
convert_to_display_c	O
(	O
c	int
)	O
;	O
if	O
(	O
!	O
is_printable	function
(	O
c	int
)	O
)	O
c	int
=	O
'.'	O
;	O
if	O
(	O
text_start	int
+	O
bytes	pointer
<	O
width	int
)	O
{	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
+	O
row	int
,	O
left	int
+	O
text_start	int
+	O
bytes	pointer
)	O
;	O
tty_print_char	function
(	O
c	int
)	O
;	O
}	O
if	O
(	O
from	char
==	O
view	pointer
->	O
hex_cursor	long
&&	O
view	pointer
->	O
hexview_in_text	int
)	O
{	O
view	pointer
->	O
cursor_row	int
=	O
row	int
;	O
view	pointer
->	O
cursor_col	int
=	O
text_start	int
+	O
bytes	pointer
;	O
}	O
}	O
}	O
tty_setcolor	function
(	O
NORMAL_COLOR	O
)	O
;	O
view_place_cursor	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
dpy_end	long
=	O
from	char
;	O
}	O
static	O
void	O
view_display_text	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
const	O
screen_dimen	int
left	int
=	O
view	pointer
->	O
data_area	struct
.	O
left	int
;	O
const	O
screen_dimen	int
top	pointer
=	O
view	pointer
->	O
data_area	struct
.	O
top	pointer
;	O
const	O
screen_dimen	int
width	int
=	O
view	pointer
->	O
data_area	struct
.	O
width	int
;	O
const	O
screen_dimen	int
height	int
=	O
view	pointer
->	O
data_area	struct
.	O
height	int
;	O
screen_dimen	int
row	int
,	O
col	long
;	O
offset_type	long
from	char
;	O
int	O
c	int
;	O
struct	O
hexedit_change_node	struct
*	O
curr	pointer
=	O
view	pointer
->	O
change_list	pointer
;	O
view_display_clean	function
(	O
view	pointer
)	O
;	O
view_display_ruler	function
(	O
view	pointer
)	O
;	O
from	char
=	O
view	pointer
->	O
dpy_start	long
;	O
while	O
(	O
curr	pointer
&&	O
(	O
curr	pointer
->	O
offset	long
<	O
from	char
)	O
)	O
{	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
}	O
tty_setcolor	function
(	O
NORMAL_COLOR	O
)	O
;	O
for	O
(	O
row	int
=	O
0	int
,	O
col	long
=	O
0	int
;	O
row	int
<	O
height	int
&&	O
(	O
c	int
=	O
get_byte	function
(	O
view	pointer
,	O
from	char
)	O
)	O
!=	O
-	O
1	int
;	O
from	char
++	O
)	O
{	O
if	O
(	O
view	pointer
->	O
text_nroff_mode	int
&&	O
c	int
==	O
'\b'	O
)	O
{	O
int	O
c_prev	int
;	O
int	O
c_next	int
;	O
if	O
(	O
(	O
c_next	int
=	O
get_byte_indexed	function
(	O
view	pointer
,	O
from	char
,	O
1	int
)	O
)	O
!=	O
-	O
1	int
&&	O
is_printable	function
(	O
c_next	int
)	O
&&	O
from	char
>=	O
1	int
&&	O
(	O
c_prev	int
=	O
get_byte	function
(	O
view	pointer
,	O
from	char
-	O
1	int
)	O
)	O
!=	O
-	O
1	int
&&	O
is_printable	function
(	O
c_prev	int
)	O
&&	O
(	O
c_prev	int
==	O
c_next	int
||	O
c_prev	int
==	O
'_'	O
||	O
(	O
c_prev	int
==	O
'+'	O
&&	O
c_next	int
==	O
'o'	O
)	O
)	O
)	O
{	O
if	O
(	O
col	long
==	O
0	int
)	O
{	O
if	O
(	O
row	int
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
row	int
--	O
;	O
col	long
=	O
width	int
;	O
}	O
col	long
--	O
;	O
if	O
(	O
c_prev	int
==	O
'_'	O
&&	O
(	O
c_next	int
!=	O
'_'	O
||	O
view_count_backspaces	function
(	O
view	pointer
,	O
from	char
)	O
==	O
1	int
)	O
)	O
tty_setcolor	function
(	O
VIEW_UNDERLINED_COLOR	O
)	O
;	O
else	O
tty_setcolor	function
(	O
MARKED_COLOR	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
(	O
c	int
==	O
'\n'	O
)	O
||	O
(	O
col	long
>=	O
width	int
&&	O
view	pointer
->	O
text_wrap_mode	int
)	O
)	O
{	O
col	long
=	O
0	int
;	O
row	int
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
row	int
>=	O
height	int
)	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
c	int
=	O
get_byte_indexed	function
(	O
view	pointer
,	O
from	char
,	O
1	int
)	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
||	O
c	int
==	O
'\n'	O
)	O
continue	O
;	O
col	long
=	O
0	int
;	O
row	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
{	O
offset_type	long
line	int
,	O
column	pointer
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
column	pointer
,	O
from	char
)	O
;	O
col	long
+=	O
(	O
8	int
-	O
column	pointer
%	O
8	int
)	O
;	O
if	O
(	O
view	pointer
->	O
text_wrap_mode	int
&&	O
col	long
>=	O
width	int
&&	O
width	int
!=	O
0	int
)	O
{	O
row	int
+=	O
col	long
/	O
width	int
;	O
col	long
%=	O
width	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
view	pointer
->	O
search_start	long
<=	O
from	char
&&	O
from	char
<	O
view	pointer
->	O
search_start	long
+	O
view	pointer
->	O
search_length	long
)	O
{	O
tty_setcolor	function
(	O
SELECTED_COLOR	O
)	O
;	O
}	O
if	O
(	O
col	long
>=	O
view	pointer
->	O
dpy_text_column	long
&&	O
col	long
-	O
view	pointer
->	O
dpy_text_column	long
<	O
width	int
)	O
{	O
widget_move	O
(	O
view	pointer
,	O
top	pointer
+	O
row	int
,	O
left	int
+	O
(	O
col	long
-	O
view	pointer
->	O
dpy_text_column	long
)	O
)	O
;	O
c	int
=	O
convert_to_display_c	O
(	O
c	int
)	O
;	O
if	O
(	O
!	O
is_printable	function
(	O
c	int
)	O
)	O
c	int
=	O
'.'	O
;	O
tty_print_char	function
(	O
c	int
)	O
;	O
}	O
col	long
++	O
;	O
tty_setcolor	function
(	O
NORMAL_COLOR	O
)	O
;	O
}	O
view	pointer
->	O
dpy_end	long
=	O
from	char
;	O
}	O
static	O
void	O
display	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view_compute_areas	function
(	O
view	pointer
)	O
;	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
view_display_hex	function
(	O
view	pointer
)	O
;	O
}	O
else	O
{	O
view_display_text	function
(	O
view	pointer
)	O
;	O
}	O
view_display_status	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_place_cursor	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
const	O
screen_dimen	int
top	pointer
=	O
view	pointer
->	O
data_area	struct
.	O
top	pointer
;	O
const	O
screen_dimen	int
left	int
=	O
view	pointer
->	O
data_area	struct
.	O
left	int
;	O
screen_dimen	int
col	long
;	O
col	long
=	O
view	pointer
->	O
cursor_col	int
;	O
if	O
(	O
!	O
view	pointer
->	O
hexview_in_text	int
&&	O
view	pointer
->	O
hexedit_lownibble	int
)	O
col	long
++	O
;	O
widget_move	O
(	O
&	O
view	pointer
->	O
widget	pointer
,	O
top	pointer
+	O
view	pointer
->	O
cursor_row	int
,	O
left	int
+	O
col	long
)	O
;	O
}	O
static	O
void	O
view_update	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
static	O
int	O
dirt_limit	int
=	O
1	int
;	O
if	O
(	O
view	pointer
->	O
dpy_bbar_dirty	int
)	O
{	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
FALSE	O
;	O
view_labels	function
(	O
view	pointer
)	O
;	O
buttonbar_redraw	function
(	O
view	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
;	O
}	O
if	O
(	O
view	pointer
->	O
dirty	int
>	O
dirt_limit	int
)	O
{	O
display	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
dirty	int
=	O
0	int
;	O
dirt_limit	int
++	O
;	O
if	O
(	O
dirt_limit	int
>	O
max_dirt_limit	int
)	O
dirt_limit	int
=	O
max_dirt_limit	int
;	O
}	O
if	O
(	O
view	pointer
->	O
dirty	int
)	O
{	O
if	O
(	O
is_idle	function
(	O
)	O
)	O
{	O
display	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
dirty	int
=	O
0	int
;	O
if	O
(	O
dirt_limit	int
>	O
1	int
)	O
dirt_limit	int
--	O
;	O
}	O
else	O
{	O
view_display_status	function
(	O
view	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
enqueue_change	function
(	O
struct	O
hexedit_change_node	struct
*	O
*	O
head	pointer
,	O
struct	O
hexedit_change_node	struct
*	O
node	pointer
)	O
{	O
struct	O
hexedit_change_node	struct
*	O
*	O
chnode	pointer
=	O
head	pointer
;	O
while	O
(	O
*	O
chnode	pointer
!=	O
NULL	O
&&	O
(	O
*	O
chnode	pointer
)	O
->	O
offset	long
<	O
node	pointer
->	O
offset	long
)	O
chnode	pointer
=	O
&	O
(	O
(	O
*	O
chnode	pointer
)	O
->	O
next	pointer
)	O
;	O
node	pointer
->	O
next	pointer
=	O
*	O
chnode	pointer
;	O
*	O
chnode	pointer
=	O
node	pointer
;	O
}	O
static	O
cb_ret_t	enum
view_handle_editkey	function
(	O
WView	struct
*	O
view	pointer
,	O
int	O
key	pointer
)	O
{	O
struct	O
hexedit_change_node	struct
*	O
node	pointer
;	O
byte	char
byte_val	char
;	O
node	pointer
=	O
view	pointer
->	O
change_list	pointer
;	O
while	O
(	O
node	pointer
&&	O
(	O
node	pointer
->	O
offset	long
!=	O
view	pointer
->	O
hex_cursor	long
)	O
)	O
node	pointer
=	O
node	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
view	pointer
->	O
hexview_in_text	int
)	O
{	O
unsigned	O
int	O
hexvalue	int
=	O
0	int
;	O
if	O
(	O
key	pointer
>=	O
'0'	O
&&	O
key	pointer
<=	O
'9'	O
)	O
hexvalue	int
=	O
0	int
+	O
(	O
key	pointer
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
key	pointer
>=	O
'A'	O
&&	O
key	pointer
<=	O
'F'	O
)	O
hexvalue	int
=	O
10	int
+	O
(	O
key	pointer
-	O
'A'	O
)	O
;	O
else	O
if	O
(	O
key	pointer
>=	O
'a'	O
&&	O
key	pointer
<=	O
'f'	O
)	O
hexvalue	int
=	O
10	int
+	O
(	O
key	pointer
-	O
'a'	O
)	O
;	O
else	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
node	pointer
)	O
byte_val	char
=	O
node	pointer
->	O
value	pointer
;	O
else	O
byte_val	char
=	O
get_byte	function
(	O
view	pointer
,	O
view	pointer
->	O
hex_cursor	long
)	O
;	O
if	O
(	O
view	pointer
->	O
hexedit_lownibble	int
)	O
{	O
byte_val	char
=	O
(	O
byte_val	char
&	O
0xf0	int
)	O
|	O
(	O
hexvalue	int
)	O
;	O
}	O
else	O
{	O
byte_val	char
=	O
(	O
byte_val	char
&	O
0x0f	int
)	O
|	O
(	O
hexvalue	int
<<	O
4	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
key	pointer
<	O
256	int
&&	O
(	O
is_printable	function
(	O
key	pointer
)	O
||	O
(	O
key	pointer
==	O
'\n'	O
)	O
)	O
)	O
byte_val	char
=	O
key	pointer
;	O
else	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
if	O
(	O
!	O
node	pointer
)	O
{	O
node	pointer
=	O
g_new	O
(	O
struct	O
hexedit_change_node	struct
,	O
1	int
)	O
;	O
node	pointer
->	O
offset	long
=	O
view	pointer
->	O
hex_cursor	long
;	O
node	pointer
->	O
value	pointer
=	O
byte_val	char
;	O
enqueue_change	function
(	O
&	O
view	pointer
->	O
change_list	pointer
,	O
node	pointer
)	O
;	O
}	O
else	O
{	O
node	pointer
->	O
value	pointer
=	O
byte_val	char
;	O
}	O
view	pointer
->	O
dirty	int
++	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
view_move_right	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
static	O
gboolean	int
view_hexedit_save_changes	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
struct	O
hexedit_change_node	struct
*	O
curr	pointer
,	O
*	O
next	pointer
;	O
int	O
fp	pointer
,	O
answer	int
;	O
char	O
*	O
text	pointer
,	O
*	O
error	pointer
;	O
if	O
(	O
view	pointer
->	O
change_list	pointer
==	O
NULL	O
)	O
return	O
TRUE	O
;	O
retry_save	O
:	O
assert	O
(	O
view	pointer
->	O
filename	pointer
!=	O
NULL	O
)	O
;	O
fp	pointer
=	O
mc_open	function
(	O
view	pointer
->	O
filename	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
fp	pointer
==	O
-	O
1	int
)	O
goto	O
save_error	O
;	O
for	O
(	O
curr	pointer
=	O
view	pointer
->	O
change_list	pointer
;	O
curr	pointer
!=	O
NULL	O
;	O
curr	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
curr	pointer
->	O
next	pointer
;	O
if	O
(	O
mc_lseek	function
(	O
fp	pointer
,	O
curr	pointer
->	O
offset	long
,	O
SEEK_SET	int
)	O
==	O
-	O
1	int
||	O
mc_write	function
(	O
fp	pointer
,	O
&	O
(	O
curr	pointer
->	O
value	pointer
)	O
,	O
1	int
)	O
!=	O
1	int
)	O
goto	O
save_error	O
;	O
view	pointer
->	O
change_list	pointer
=	O
next	pointer
;	O
view	pointer
->	O
dirty	int
++	O
;	O
view_set_byte	function
(	O
view	pointer
,	O
curr	pointer
->	O
offset	long
,	O
curr	pointer
->	O
value	pointer
)	O
;	O
g_free	function
(	O
curr	pointer
)	O
;	O
}	O
if	O
(	O
mc_close	function
(	O
fp	pointer
)	O
==	O
-	O
1	int
)	O
{	O
error	pointer
=	O
g_strdup	function
(	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
message	pointer
(	O
D_ERROR	int
,	O
_	O
(	O
" Save file "	pointer
)	O
,	O
_	O
(	O
" Error while closing the file: \n %s \n"	pointer
" Data may have been written or not. "	pointer
)	O
,	O
error	pointer
)	O
;	O
g_free	function
(	O
error	pointer
)	O
;	O
}	O
view_update	function
(	O
view	pointer
)	O
;	O
return	O
TRUE	O
;	O
save_error	O
:	O
error	pointer
=	O
g_strdup	function
(	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
text	pointer
=	O
g_strdup_printf	function
(	O
_	O
(	O
" Cannot save file: \n %s "	pointer
)	O
,	O
error	pointer
)	O
;	O
g_free	function
(	O
error	pointer
)	O
;	O
(	O
void	O
)	O
mc_close	function
(	O
fp	pointer
)	O
;	O
answer	int
=	O
query_dialog	function
(	O
_	O
(	O
" Save file "	pointer
)	O
,	O
text	pointer
,	O
D_ERROR	int
,	O
2	int
,	O
_	O
(	O
"&Retry"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
;	O
g_free	function
(	O
text	pointer
)	O
;	O
if	O
(	O
answer	int
==	O
0	int
)	O
goto	O
retry_save	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
gboolean	int
view_ok_to_quit	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
int	O
r	pointer
;	O
if	O
(	O
view	pointer
->	O
change_list	pointer
==	O
NULL	O
)	O
return	O
TRUE	O
;	O
r	pointer
=	O
query_dialog	function
(	O
_	O
(	O
"Quit"	pointer
)	O
,	O
_	O
(	O
" File was modified, Save with exit? "	pointer
)	O
,	O
D_NORMAL	int
,	O
3	int
,	O
_	O
(	O
"&Cancel quit"	pointer
)	O
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
;	O
switch	O
(	O
r	pointer
)	O
{	O
case	O
1	int
:	O
return	O
view_hexedit_save_changes	function
(	O
view	pointer
)	O
;	O
case	O
2	int
:	O
view_hexedit_free_change_list	function
(	O
view	pointer
)	O
;	O
return	O
TRUE	O
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
inline	O
void	O
my_define	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
idx	int
,	O
const	O
char	O
*	O
text	pointer
,	O
void	O
(	O
*	O
fn	pointer
)	O
(	O
WView	struct
*	O
)	O
,	O
WView	struct
*	O
view	pointer
)	O
{	O
buttonbar_set_label_data	function
(	O
h	pointer
,	O
idx	int
,	O
text	pointer
,	O
(	O
buttonbarfn	pointer
)	O
fn	pointer
,	O
view	pointer
)	O
;	O
}	O
static	O
int	O
icase_search_p	function
(	O
WView	struct
*	O
view	pointer
,	O
char	O
*	O
text	pointer
,	O
char	O
*	O
data	pointer
,	O
int	O
nothing	int
)	O
{	O
const	O
char	O
*	O
q	pointer
;	O
int	O
lng	pointer
;	O
const	O
int	O
direction	int
=	O
view	pointer
->	O
direction	int
;	O
(	O
void	O
)	O
nothing	int
;	O
if	O
(	O
direction	int
==	O
-	O
1	int
)	O
{	O
g_strreverse	function
(	O
text	pointer
)	O
;	O
g_strreverse	function
(	O
data	pointer
)	O
;	O
}	O
q	pointer
=	O
_icase_search	function
(	O
text	pointer
,	O
data	pointer
,	O
&	O
lng	pointer
)	O
;	O
if	O
(	O
direction	int
==	O
-	O
1	int
)	O
{	O
g_strreverse	function
(	O
text	pointer
)	O
;	O
g_strreverse	function
(	O
data	pointer
)	O
;	O
}	O
if	O
(	O
q	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
direction	int
>	O
0	int
)	O
view	pointer
->	O
search_start	long
=	O
q	pointer
-	O
data	pointer
-	O
lng	pointer
;	O
else	O
view	pointer
->	O
search_start	long
=	O
strlen	function
(	O
data	pointer
)	O
-	O
(	O
q	pointer
-	O
data	pointer
)	O
;	O
view	pointer
->	O
search_length	long
=	O
lng	pointer
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
grow_string_buffer	function
(	O
char	O
*	O
text	pointer
,	O
gulong	long
*	O
size	long
)	O
{	O
char	O
*	O
new	pointer
;	O
*	O
size	long
+=	O
160	int
;	O
new	pointer
=	O
g_realloc	function
(	O
text	pointer
,	O
*	O
size	long
)	O
;	O
if	O
(	O
text	pointer
==	O
NULL	O
)	O
{	O
*	O
new	pointer
=	O
'\0'	O
;	O
}	O
return	O
new	pointer
;	O
}	O
static	O
char	O
*	O
get_line_at	function
(	O
WView	struct
*	O
view	pointer
,	O
offset_type	long
*	O
p	pointer
,	O
offset_type	long
*	O
skipped	pointer
)	O
{	O
char	O
*	O
buffer	pointer
=	O
NULL	O
;	O
gulong	long
buffer_size	long
=	O
0	int
;	O
offset_type	long
usable_size	long
=	O
0	int
;	O
int	O
ch	int
;	O
const	O
int	O
direction	int
=	O
view	pointer
->	O
direction	int
;	O
offset_type	long
pos	pointer
=	O
*	O
p	pointer
;	O
offset_type	long
i	array
=	O
0	int
;	O
int	O
prev	pointer
=	O
'\0'	O
;	O
*	O
skipped	pointer
=	O
0	int
;	O
if	O
(	O
pos	pointer
==	O
0	int
&&	O
direction	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
while	O
(	O
(	O
ch	int
=	O
get_byte	function
(	O
view	pointer
,	O
pos	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
pos	pointer
==	O
0	int
&&	O
direction	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
pos	pointer
+=	O
direction	int
;	O
i	array
++	O
;	O
}	O
*	O
skipped	pointer
=	O
i	array
;	O
if	O
(	O
i	array
==	O
0	int
&&	O
(	O
pos	pointer
!=	O
0	int
||	O
direction	int
==	O
-	O
1	int
)	O
)	O
{	O
prev	pointer
=	O
get_byte	function
(	O
view	pointer
,	O
pos	pointer
-	O
direction	int
)	O
;	O
if	O
(	O
(	O
prev	pointer
==	O
-	O
1	int
)	O
||	O
(	O
prev	pointer
==	O
'\n'	O
)	O
)	O
prev	pointer
=	O
'\0'	O
;	O
}	O
for	O
(	O
i	array
=	O
1	int
;	O
ch	int
!=	O
-	O
1	int
;	O
ch	int
=	O
get_byte	function
(	O
view	pointer
,	O
pos	pointer
)	O
)	O
{	O
if	O
(	O
i	array
>=	O
usable_size	long
)	O
{	O
buffer	pointer
=	O
grow_string_buffer	function
(	O
buffer	pointer
,	O
&	O
buffer_size	long
)	O
;	O
usable_size	long
=	O
buffer_size	long
-	O
2	int
;	O
}	O
buffer	pointer
[	O
i	array
++	O
]	O
=	O
ch	int
;	O
if	O
(	O
pos	pointer
==	O
0	int
&&	O
direction	int
==	O
-	O
1	int
)	O
break	O
;	O
pos	pointer
+=	O
direction	int
;	O
if	O
(	O
ch	int
==	O
'\n'	O
||	O
ch	int
==	O
'\0'	O
)	O
{	O
i	array
--	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
buffer	pointer
)	O
{	O
buffer	pointer
[	O
0	int
]	O
=	O
prev	pointer
;	O
buffer	pointer
[	O
i	array
]	O
=	O
'\0'	O
;	O
if	O
(	O
direction	int
==	O
-	O
1	int
)	O
{	O
g_strreverse	function
(	O
buffer	pointer
+	O
1	int
)	O
;	O
}	O
}	O
*	O
p	pointer
=	O
pos	pointer
;	O
return	O
buffer	pointer
;	O
}	O
static	O
void	O
search_update_steps	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
offset_type	long
filesize	long
=	O
view_get_filesize	function
(	O
view	pointer
)	O
;	O
if	O
(	O
filesize	long
!=	O
0	int
)	O
view	pointer
->	O
update_steps	long
=	O
40000	int
;	O
else	O
view	pointer
->	O
update_steps	long
=	O
filesize	long
/	O
100	int
;	O
if	O
(	O
view	pointer
->	O
update_steps	long
<	O
20000	int
)	O
view	pointer
->	O
update_steps	long
=	O
20000	int
;	O
}	O
static	O
void	O
search	pointer
(	O
WView	struct
*	O
view	pointer
,	O
char	O
*	O
text	pointer
,	O
int	O
(	O
*	O
search	pointer
)	O
(	O
WView	struct
*	O
,	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
{	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
offset_type	long
p	pointer
,	O
beginning	long
,	O
search_start	long
;	O
int	O
found_len	int
;	O
int	O
search_status	int
;	O
Dlg_head	struct
*	O
d	double
=	O
0	int
;	O
offset_type	long
forward_line_start	long
;	O
offset_type	long
reverse_line_start	long
;	O
offset_type	long
t	long
;	O
if	O
(	O
verbose	int
)	O
{	O
d	double
=	O
create_message	function
(	O
D_NORMAL	int
,	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
"Searching %s"	pointer
)	O
,	O
text	pointer
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
found_len	int
=	O
view	pointer
->	O
search_length	long
;	O
search_start	long
=	O
view	pointer
->	O
search_start	long
;	O
if	O
(	O
view	pointer
->	O
direction	int
==	O
1	int
)	O
{	O
p	pointer
=	O
search_start	long
+	O
(	O
(	O
found_len	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
}	O
else	O
{	O
p	pointer
=	O
search_start	long
-	O
(	O
(	O
found_len	int
&&	O
search_start	long
>=	O
1	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
}	O
beginning	long
=	O
p	pointer
;	O
search_update_steps	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
update_activate	long
=	O
0	int
;	O
enable_interrupt_key	O
(	O
)	O
;	O
for	O
(	O
;	O
;	O
g_free	function
(	O
s	pointer
)	O
)	O
{	O
if	O
(	O
p	pointer
>=	O
view	pointer
->	O
update_activate	long
)	O
{	O
view	pointer
->	O
update_activate	long
+=	O
view	pointer
->	O
update_steps	long
;	O
if	O
(	O
verbose	int
)	O
{	O
view_percent	function
(	O
view	pointer
,	O
p	pointer
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
if	O
(	O
got_interrupt	O
(	O
)	O
)	O
break	O
;	O
}	O
forward_line_start	long
=	O
p	pointer
;	O
s	pointer
=	O
get_line_at	function
(	O
view	pointer
,	O
&	O
p	pointer
,	O
&	O
t	long
)	O
;	O
reverse_line_start	long
=	O
p	pointer
;	O
if	O
(	O
!	O
s	pointer
)	O
break	O
;	O
search_status	int
=	O
(	O
*	O
search	pointer
)	O
(	O
view	pointer
,	O
text	pointer
,	O
s	pointer
+	O
1	int
,	O
match_normal	int
)	O
;	O
if	O
(	O
search_status	int
<	O
0	int
)	O
{	O
g_free	function
(	O
s	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
search_status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
*	O
s	pointer
&&	O
!	O
view	pointer
->	O
search_start	long
&&	O
(	O
search	pointer
==	O
regexp_view_search	function
)	O
)	O
{	O
if	O
(	O
(	O
*	O
text	pointer
==	O
'^'	O
&&	O
view	pointer
->	O
direction	int
==	O
1	int
)	O
||	O
(	O
view	pointer
->	O
direction	int
==	O
-	O
1	int
&&	O
text	pointer
[	O
strlen	function
(	O
text	pointer
)	O
-	O
1	int
]	O
==	O
'$'	O
)	O
)	O
{	O
continue	O
;	O
}	O
}	O
if	O
(	O
view	pointer
->	O
direction	int
==	O
1	int
)	O
t	long
+=	O
forward_line_start	long
;	O
else	O
t	long
=	O
reverse_line_start	long
?	O
reverse_line_start	long
+	O
2	int
:	O
0	int
;	O
view	pointer
->	O
search_start	long
+=	O
t	long
;	O
if	O
(	O
t	long
!=	O
beginning	long
)	O
{	O
view	pointer
->	O
dpy_start	long
=	O
t	long
;	O
}	O
g_free	function
(	O
s	pointer
)	O
;	O
break	O
;	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
dlg_run_done	function
(	O
d	double
)	O
;	O
destroy_dlg	function
(	O
d	double
)	O
;	O
}	O
if	O
(	O
!	O
s	pointer
)	O
{	O
message	pointer
(	O
0	int
,	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
" Search string not found "	pointer
)	O
)	O
;	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
}	O
}	O
static	O
offset_type	long
block_search	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
char	O
*	O
buffer	pointer
,	O
int	O
len	int
)	O
{	O
int	O
direction	int
=	O
view	pointer
->	O
direction	int
;	O
const	O
char	O
*	O
d	double
=	O
buffer	pointer
;	O
char	O
b	pointer
;	O
offset_type	long
e	long
;	O
enable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
direction	int
==	O
1	int
)	O
e	long
=	O
view	pointer
->	O
search_start	long
+	O
(	O
(	O
view	pointer
->	O
search_length	long
)	O
?	O
1	int
:	O
0	int
)	O
;	O
else	O
e	long
=	O
view	pointer
->	O
search_start	long
-	O
(	O
(	O
view	pointer
->	O
search_length	long
&&	O
view	pointer
->	O
search_start	long
>=	O
1	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
search_update_steps	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
update_activate	long
=	O
0	int
;	O
if	O
(	O
direction	int
==	O
-	O
1	int
)	O
{	O
for	O
(	O
d	double
+=	O
len	int
-	O
1	int
;	O
;	O
e	long
--	O
)	O
{	O
if	O
(	O
e	long
<=	O
view	pointer
->	O
update_activate	long
)	O
{	O
view	pointer
->	O
update_activate	long
-=	O
view	pointer
->	O
update_steps	long
;	O
if	O
(	O
verbose	int
)	O
{	O
view_percent	function
(	O
view	pointer
,	O
e	long
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
if	O
(	O
got_interrupt	O
(	O
)	O
)	O
break	O
;	O
}	O
b	pointer
=	O
get_byte	function
(	O
view	pointer
,	O
e	long
)	O
;	O
if	O
(	O
*	O
d	double
==	O
b	pointer
)	O
{	O
if	O
(	O
d	double
==	O
buffer	pointer
)	O
{	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
e	long
;	O
}	O
d	double
--	O
;	O
}	O
else	O
{	O
e	long
+=	O
buffer	pointer
+	O
len	int
-	O
1	int
-	O
d	double
;	O
d	double
=	O
buffer	pointer
+	O
len	int
-	O
1	int
;	O
}	O
if	O
(	O
e	long
==	O
0	int
)	O
break	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
get_byte	function
(	O
view	pointer
,	O
e	long
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
e	long
>=	O
view	pointer
->	O
update_activate	long
)	O
{	O
view	pointer
->	O
update_activate	long
+=	O
view	pointer
->	O
update_steps	long
;	O
if	O
(	O
verbose	int
)	O
{	O
view_percent	function
(	O
view	pointer
,	O
e	long
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
if	O
(	O
got_interrupt	O
(	O
)	O
)	O
break	O
;	O
}	O
b	pointer
=	O
get_byte	function
(	O
view	pointer
,	O
e	long
++	O
)	O
;	O
if	O
(	O
*	O
d	double
==	O
b	pointer
)	O
{	O
d	double
++	O
;	O
if	O
(	O
d	double
-	O
buffer	pointer
==	O
len	int
)	O
{	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
e	long
-	O
len	int
;	O
}	O
}	O
else	O
{	O
e	long
-=	O
d	double
-	O
buffer	pointer
;	O
d	double
=	O
buffer	pointer
;	O
}	O
}	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
INVALID_OFFSET	O
;	O
}	O
static	O
void	O
hex_search	function
(	O
WView	struct
*	O
view	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
cur	pointer
;	O
int	O
block_len	int
;	O
offset_type	long
pos	pointer
;	O
int	O
parse_error	int
=	O
0	int
;	O
if	O
(	O
!	O
*	O
text	pointer
)	O
{	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
return	O
;	O
}	O
buffer	pointer
=	O
g_new	O
(	O
char	O
,	O
strlen	function
(	O
text	pointer
)	O
)	O
;	O
cur	pointer
=	O
buffer	pointer
;	O
while	O
(	O
*	O
text	pointer
)	O
{	O
int	O
val	array
;	O
int	O
ptr	pointer
;	O
if	O
(	O
*	O
text	pointer
==	O
' '	O
||	O
*	O
text	pointer
==	O
'\t'	O
)	O
{	O
text	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
sscanf	function
(	O
text	pointer
,	O
"%i%n"	pointer
,	O
&	O
val	array
,	O
&	O
ptr	pointer
)	O
>	O
0	int
)	O
{	O
if	O
(	O
val	array
<	O
-	O
128	int
||	O
val	array
>	O
255	int
)	O
{	O
parse_error	int
=	O
1	int
;	O
break	O
;	O
}	O
*	O
cur	pointer
++	O
=	O
(	O
char	O
)	O
val	array
;	O
text	pointer
+=	O
ptr	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
text	pointer
==	O
'"'	O
)	O
{	O
const	O
char	O
*	O
next_quote	pointer
;	O
text	pointer
++	O
;	O
next_quote	pointer
=	O
strchr	function
(	O
text	pointer
,	O
'"'	O
)	O
;	O
if	O
(	O
next_quote	pointer
)	O
{	O
memcpy	function
(	O
cur	pointer
,	O
text	pointer
,	O
next_quote	pointer
-	O
text	pointer
)	O
;	O
cur	pointer
+=	O
next_quote	pointer
-	O
text	pointer
;	O
text	pointer
=	O
next_quote	pointer
+	O
1	int
;	O
continue	O
;	O
}	O
}	O
parse_error	int
=	O
1	int
;	O
break	O
;	O
}	O
block_len	int
=	O
cur	pointer
-	O
buffer	pointer
;	O
if	O
(	O
block_len	int
<=	O
0	int
||	O
parse_error	int
)	O
{	O
message	pointer
(	O
0	int
,	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
"Invalid hex search expression"	pointer
)	O
)	O
;	O
g_free	function
(	O
buffer	pointer
)	O
;	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
return	O
;	O
}	O
pos	pointer
=	O
block_search	function
(	O
view	pointer
,	O
buffer	pointer
,	O
block_len	int
)	O
;	O
g_free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
pos	pointer
==	O
INVALID_OFFSET	O
)	O
{	O
message	pointer
(	O
0	int
,	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
" Search string not found "	pointer
)	O
)	O
;	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
return	O
;	O
}	O
view	pointer
->	O
search_start	long
=	O
pos	pointer
;	O
view	pointer
->	O
search_length	long
=	O
block_len	int
;	O
view	pointer
->	O
hex_cursor	long
=	O
view	pointer
->	O
search_start	long
;	O
view	pointer
->	O
hexedit_lownibble	int
=	O
FALSE	O
;	O
view	pointer
->	O
dpy_start	long
=	O
pos	pointer
-	O
pos	pointer
%	O
view	pointer
->	O
bytes_per_line	int
;	O
}	O
static	O
int	O
regexp_view_search	function
(	O
WView	struct
*	O
view	pointer
,	O
char	O
*	O
pattern	pointer
,	O
char	O
*	O
string	pointer
,	O
int	O
match_type	int
)	O
{	O
static	O
regex_t	struct
r	pointer
;	O
static	O
char	O
*	O
old_pattern	pointer
=	O
NULL	O
;	O
static	O
int	O
old_type	int
;	O
regmatch_t	struct
pmatch	array
[	O
1	int
]	O
;	O
int	O
i	array
,	O
flags	enum
=	O
REG_ICASE	O
;	O
if	O
(	O
old_pattern	pointer
==	O
NULL	O
||	O
strcmp	function
(	O
old_pattern	pointer
,	O
pattern	pointer
)	O
!=	O
0	int
||	O
old_type	int
!=	O
match_type	int
)	O
{	O
if	O
(	O
old_pattern	pointer
!=	O
NULL	O
)	O
{	O
regfree	function
(	O
&	O
r	pointer
)	O
;	O
g_free	function
(	O
old_pattern	pointer
)	O
;	O
old_pattern	pointer
=	O
0	int
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
pattern	pointer
[	O
i	array
]	O
!=	O
'\0'	O
;	O
i	array
++	O
)	O
{	O
if	O
(	O
isupper	function
(	O
(	O
unsigned	O
char	O
)	O
pattern	pointer
[	O
i	array
]	O
)	O
)	O
{	O
flags	enum
=	O
0	int
;	O
break	O
;	O
}	O
}	O
flags	enum
|=	O
REG_EXTENDED	int
;	O
if	O
(	O
regcomp	function
(	O
&	O
r	pointer
,	O
pattern	pointer
,	O
flags	enum
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Invalid regular expression "	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_pattern	pointer
=	O
g_strdup	function
(	O
pattern	pointer
)	O
;	O
old_type	int
=	O
match_type	int
;	O
}	O
if	O
(	O
regexec	function
(	O
&	O
r	pointer
,	O
string	pointer
,	O
1	int
,	O
pmatch	array
,	O
0	int
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
view	pointer
->	O
search_length	long
=	O
pmatch	array
[	O
0	int
]	O
.	O
rm_eo	int
-	O
pmatch	array
[	O
0	int
]	O
.	O
rm_so	int
;	O
view	pointer
->	O
search_start	long
=	O
pmatch	array
[	O
0	int
]	O
.	O
rm_so	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
do_regexp_search	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
search	pointer
(	O
view	pointer
,	O
view	pointer
->	O
search_exp	pointer
,	O
regexp_view_search	function
)	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
do_normal_search	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
hex_search	function
(	O
view	pointer
,	O
view	pointer
->	O
search_exp	pointer
)	O
;	O
else	O
search	pointer
(	O
view	pointer
,	O
view	pointer
->	O
search_exp	pointer
,	O
icase_search_p	function
)	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_help_cmd	function
(	O
void	O
)	O
{	O
interactive_display	function
(	O
NULL	O
,	O
"[Internal File Viewer]"	pointer
)	O
;	O
}	O
static	O
void	O
view_toggle_hexedit_mode_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view_toggle_hexedit_mode	function
(	O
view	pointer
)	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_toggle_wrap_mode_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view_toggle_wrap_mode	function
(	O
view	pointer
)	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_toggle_hex_mode_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view_toggle_hex_mode	function
(	O
view	pointer
)	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_moveto_line_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
char	O
*	O
answer	int
,	O
*	O
answer_end	pointer
,	O
prompt	pointer
[	O
BUF_SMALL	int
]	O
;	O
offset_type	long
line	int
,	O
col	long
;	O
view_offset_to_coord	function
(	O
view	pointer
,	O
&	O
line	int
,	O
&	O
col	long
,	O
view	pointer
->	O
dpy_start	long
)	O
;	O
g_snprintf	function
(	O
prompt	pointer
,	O
sizeof	O
(	O
prompt	pointer
)	O
,	O
_	O
(	O
" The current line number is %d.\n"	pointer
" Enter the new line number:"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
line	int
+	O
1	int
)	O
)	O
;	O
answer	int
=	O
input_dialog	function
(	O
_	O
(	O
" Goto line "	pointer
)	O
,	O
prompt	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
answer	int
!=	O
NULL	O
&&	O
answer	int
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
errno	O
=	O
0	int
;	O
line	int
=	O
strtoul	function
(	O
answer	int
,	O
&	O
answer_end	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
answer_end	pointer
==	O
'\0'	O
&&	O
errno	O
==	O
0	int
&&	O
line	int
>=	O
1	int
)	O
view_moveto	function
(	O
view	pointer
,	O
line	int
-	O
1	int
,	O
0	int
)	O
;	O
}	O
g_free	function
(	O
answer	int
)	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_moveto_addr_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
char	O
*	O
line	int
,	O
*	O
error	pointer
,	O
prompt	pointer
[	O
BUF_SMALL	int
]	O
;	O
offset_type	long
addr	pointer
;	O
g_snprintf	function
(	O
prompt	pointer
,	O
sizeof	O
(	O
prompt	pointer
)	O
,	O
_	O
(	O
" The current address is 0x%lx.\n"	pointer
" Enter the new address:"	pointer
)	O
,	O
view	pointer
->	O
hex_cursor	long
)	O
;	O
line	int
=	O
input_dialog	function
(	O
_	O
(	O
" Goto Address "	pointer
)	O
,	O
prompt	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
line	int
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
line	int
!=	O
'\0'	O
)	O
{	O
addr	pointer
=	O
strtoul	function
(	O
line	int
,	O
&	O
error	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
*	O
error	pointer
==	O
'\0'	O
)	O
&&	O
get_byte	function
(	O
view	pointer
,	O
addr	pointer
)	O
!=	O
-	O
1	int
)	O
{	O
view_moveto_offset	function
(	O
view	pointer
,	O
addr	pointer
)	O
;	O
}	O
else	O
{	O
message	pointer
(	O
D_ERROR	int
,	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Invalid address "	pointer
)	O
)	O
;	O
}	O
}	O
g_free	function
(	O
line	int
)	O
;	O
}	O
view	pointer
->	O
dirty	int
++	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_hexedit_save_changes_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
(	O
void	O
)	O
view_hexedit_save_changes	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
regexp_search	function
(	O
WView	struct
*	O
view	pointer
,	O
int	O
direction	int
)	O
{	O
const	O
char	O
*	O
defval	pointer
;	O
char	O
*	O
regexp	pointer
;	O
static	O
char	O
*	O
last_regexp	pointer
;	O
defval	pointer
=	O
(	O
last_regexp	pointer
!=	O
NULL	O
?	O
last_regexp	pointer
:	O
""	pointer
)	O
;	O
regexp	pointer
=	O
input_dialog	function
(	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
" Enter regexp:"	pointer
)	O
,	O
defval	pointer
)	O
;	O
if	O
(	O
regexp	pointer
==	O
NULL	O
||	O
regexp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
g_free	function
(	O
regexp	pointer
)	O
;	O
return	O
;	O
}	O
g_free	function
(	O
last_regexp	pointer
)	O
;	O
view	pointer
->	O
search_exp	pointer
=	O
last_regexp	pointer
=	O
regexp	pointer
;	O
view	pointer
->	O
direction	int
=	O
direction	int
;	O
do_regexp_search	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
last_search	pointer
=	O
do_regexp_search	function
;	O
}	O
static	O
void	O
view_regexp_search_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
regexp_search	function
(	O
view	pointer
,	O
1	int
)	O
;	O
}	O
static	O
void	O
view_normal_search_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
char	O
*	O
defval	pointer
,	O
*	O
exp	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
last_search_string	pointer
;	O
enum	O
{	O
SEARCH_DLG_HEIGHT	int
=	O
8	int
,	O
SEARCH_DLG_WIDTH	int
=	O
58	int
}	O
;	O
static	O
int	O
replace_backwards	int
;	O
int	O
treplace_backwards	int
=	O
replace_backwards	int
;	O
static	O
QuickWidget	struct
quick_widgets	array
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
5	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
5	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
3	int
,	O
SEARCH_DLG_WIDTH	int
,	O
4	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Backwards"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
SEARCH_DLG_WIDTH	int
,	O
3	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
""	pointer
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"Search"	pointer
)	O
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
SEARCH_DLG_WIDTH	int
,	O
2	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter search string:"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
static	O
QuickDialog	struct
Quick_input	struct
=	O
{	O
SEARCH_DLG_WIDTH	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
"Search"	pointer
)	O
,	O
"[Input Line Keys]"	pointer
,	O
quick_widgets	array
,	O
0	int
}	O
;	O
defval	pointer
=	O
g_strdup	function
(	O
last_search_string	pointer
!=	O
NULL	O
?	O
last_search_string	pointer
:	O
""	pointer
)	O
;	O
convert_to_display	O
(	O
defval	pointer
)	O
;	O
quick_widgets	array
[	O
2	int
]	O
.	O
result	long
=	O
&	O
treplace_backwards	int
;	O
quick_widgets	array
[	O
3	int
]	O
.	O
str_result	pointer
=	O
&	O
exp	pointer
;	O
quick_widgets	array
[	O
3	int
]	O
.	O
text	pointer
=	O
defval	pointer
;	O
if	O
(	O
quick_dialog	function
(	O
&	O
Quick_input	struct
)	O
==	O
B_CANCEL	int
)	O
goto	O
cleanup	O
;	O
replace_backwards	int
=	O
treplace_backwards	int
;	O
if	O
(	O
exp	pointer
==	O
NULL	O
||	O
exp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
goto	O
cleanup	O
;	O
convert_from_input	O
(	O
exp	pointer
)	O
;	O
g_free	function
(	O
last_search_string	pointer
)	O
;	O
view	pointer
->	O
search_exp	pointer
=	O
last_search_string	pointer
=	O
exp	pointer
;	O
exp	pointer
=	O
NULL	O
;	O
view	pointer
->	O
direction	int
=	O
replace_backwards	int
?	O
-	O
1	int
:	O
1	int
;	O
do_normal_search	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
last_search	pointer
=	O
do_normal_search	function
;	O
cleanup	O
:	O
g_free	function
(	O
exp	pointer
)	O
;	O
g_free	function
(	O
defval	pointer
)	O
;	O
}	O
static	O
void	O
view_toggle_magic_mode_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view_toggle_magic_mode	function
(	O
view	pointer
)	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_toggle_nroff_mode_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
view_toggle_nroff_mode	function
(	O
view	pointer
)	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
static	O
void	O
view_quit_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
view_ok_to_quit	function
(	O
view	pointer
)	O
)	O
dlg_stop	function
(	O
view	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
;	O
}	O
static	O
void	O
view_labels	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
view	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
buttonbar_set_label	function
(	O
h	pointer
,	O
1	int
,	O
Q_	function
(	O
"ButtonBar|Help"	pointer
)	O
,	O
view_help_cmd	function
)	O
;	O
my_define	function
(	O
h	pointer
,	O
10	int
,	O
Q_	function
(	O
"ButtonBar|Quit"	pointer
)	O
,	O
view_quit_cmd	function
,	O
view	pointer
)	O
;	O
my_define	function
(	O
h	pointer
,	O
4	int
,	O
view	pointer
->	O
hex_mode	int
?	O
Q_	function
(	O
"ButtonBar|Ascii"	pointer
)	O
:	O
Q_	function
(	O
"ButtonBar|Hex"	pointer
)	O
,	O
view_toggle_hex_mode_cmd	function
,	O
view	pointer
)	O
;	O
my_define	function
(	O
h	pointer
,	O
5	int
,	O
view	pointer
->	O
hex_mode	int
?	O
Q_	function
(	O
"ButtonBar|Goto"	pointer
)	O
:	O
Q_	function
(	O
"ButtonBar|Line"	pointer
)	O
,	O
view	pointer
->	O
hex_mode	int
?	O
view_moveto_addr_cmd	function
:	O
view_moveto_line_cmd	function
,	O
view	pointer
)	O
;	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
if	O
(	O
view	pointer
->	O
hexedit_mode	int
)	O
{	O
my_define	function
(	O
h	pointer
,	O
2	int
,	O
Q_	function
(	O
"ButtonBar|View"	pointer
)	O
,	O
view_toggle_hexedit_mode_cmd	function
,	O
view	pointer
)	O
;	O
}	O
else	O
if	O
(	O
view	pointer
->	O
datasource	enum
==	O
DS_FILE	int
)	O
{	O
my_define	function
(	O
h	pointer
,	O
2	int
,	O
Q_	function
(	O
"ButtonBar|Edit"	pointer
)	O
,	O
view_toggle_hexedit_mode_cmd	function
,	O
view	pointer
)	O
;	O
}	O
else	O
{	O
buttonbar_clear_label	function
(	O
h	pointer
,	O
2	int
)	O
;	O
}	O
my_define	function
(	O
h	pointer
,	O
6	int
,	O
Q_	function
(	O
"ButtonBar|Save"	pointer
)	O
,	O
view_hexedit_save_changes_cmd	function
,	O
view	pointer
)	O
;	O
}	O
else	O
{	O
my_define	function
(	O
h	pointer
,	O
2	int
,	O
view	pointer
->	O
text_wrap_mode	int
?	O
Q_	function
(	O
"ButtonBar|UnWrap"	pointer
)	O
:	O
Q_	function
(	O
"ButtonBar|Wrap"	pointer
)	O
,	O
view_toggle_wrap_mode_cmd	function
,	O
view	pointer
)	O
;	O
my_define	function
(	O
h	pointer
,	O
6	int
,	O
Q_	function
(	O
"ButtonBar|RxSrch"	pointer
)	O
,	O
view_regexp_search_cmd	function
,	O
view	pointer
)	O
;	O
}	O
my_define	function
(	O
h	pointer
,	O
7	int
,	O
view	pointer
->	O
hex_mode	int
?	O
Q_	function
(	O
"ButtonBar|HxSrch"	pointer
)	O
:	O
Q_	function
(	O
"ButtonBar|Search"	pointer
)	O
,	O
view_normal_search_cmd	function
,	O
view	pointer
)	O
;	O
my_define	function
(	O
h	pointer
,	O
8	int
,	O
view	pointer
->	O
magic_mode	int
?	O
Q_	function
(	O
"ButtonBar|Raw"	pointer
)	O
:	O
Q_	function
(	O
"ButtonBar|Parse"	pointer
)	O
,	O
view_toggle_magic_mode_cmd	function
,	O
view	pointer
)	O
;	O
if	O
(	O
!	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
{	O
my_define	function
(	O
h	pointer
,	O
9	int
,	O
view	pointer
->	O
text_nroff_mode	int
?	O
Q_	function
(	O
"ButtonBar|Unform"	pointer
)	O
:	O
Q_	function
(	O
"ButtonBar|Format"	pointer
)	O
,	O
view_toggle_nroff_mode_cmd	function
,	O
view	pointer
)	O
;	O
my_define	function
(	O
h	pointer
,	O
3	int
,	O
Q_	function
(	O
"ButtonBar|Quit"	pointer
)	O
,	O
view_quit_cmd	function
,	O
view	pointer
)	O
;	O
}	O
}	O
static	O
cb_ret_t	enum
check_left_right_keys	function
(	O
WView	struct
*	O
view	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
KEY_LEFT	int
)	O
{	O
view_move_left	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
c	int
==	O
KEY_RIGHT	int
)	O
{	O
view_move_right	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
view	pointer
->	O
hex_mode	int
||	O
view	pointer
->	O
text_wrap_mode	int
)	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
c	int
==	O
(	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
)	O
)	O
{	O
if	O
(	O
view	pointer
->	O
dpy_text_column	long
>=	O
10	int
)	O
view	pointer
->	O
dpy_text_column	long
-=	O
10	int
;	O
else	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
view	pointer
->	O
dirty	int
++	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
c	int
==	O
(	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
)	O
)	O
{	O
if	O
(	O
view	pointer
->	O
dpy_text_column	long
<=	O
OFFSETTYPE_MAX	O
-	O
10	int
)	O
view	pointer
->	O
dpy_text_column	long
+=	O
10	int
;	O
else	O
view	pointer
->	O
dpy_text_column	long
=	O
OFFSETTYPE_MAX	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
static	O
void	O
view_continue_search_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
if	O
(	O
view	pointer
->	O
last_search	pointer
)	O
{	O
view	pointer
->	O
last_search	pointer
(	O
view	pointer
)	O
;	O
}	O
else	O
{	O
view_normal_search_cmd	function
(	O
view	pointer
)	O
;	O
}	O
}	O
static	O
void	O
view_toggle_ruler_cmd	function
(	O
WView	struct
*	O
view	pointer
)	O
{	O
static	O
const	O
enum	O
ruler_type	enum
next	pointer
[	O
3	int
]	O
=	O
{	O
RULER_TOP	int
,	O
RULER_BOTTOM	int
,	O
RULER_NONE	int
}	O
;	O
assert	O
(	O
(	O
size_t	long
)	O
ruler	enum
<	O
3	int
)	O
;	O
ruler	enum
=	O
next	pointer
[	O
(	O
size_t	long
)	O
ruler	enum
]	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
}	O
static	O
void	O
view_cmk_move_up	function
(	O
void	O
*	O
w	pointer
,	O
int	O
n	long
)	O
{	O
view_move_up	function
(	O
(	O
WView	struct
*	O
)	O
w	pointer
,	O
n	long
)	O
;	O
}	O
static	O
void	O
view_cmk_move_down	function
(	O
void	O
*	O
w	pointer
,	O
int	O
n	long
)	O
{	O
view_move_down	function
(	O
(	O
WView	struct
*	O
)	O
w	pointer
,	O
n	long
)	O
;	O
}	O
static	O
void	O
view_cmk_moveto_top	function
(	O
void	O
*	O
w	pointer
,	O
int	O
n	long
)	O
{	O
(	O
void	O
)	O
&	O
n	long
;	O
view_moveto_top	function
(	O
(	O
WView	struct
*	O
)	O
w	pointer
)	O
;	O
}	O
static	O
void	O
view_cmk_moveto_bottom	function
(	O
void	O
*	O
w	pointer
,	O
int	O
n	long
)	O
{	O
(	O
void	O
)	O
&	O
n	long
;	O
view_moveto_bottom	function
(	O
(	O
WView	struct
*	O
)	O
w	pointer
)	O
;	O
}	O
static	O
cb_ret_t	enum
view_handle_key	function
(	O
WView	struct
*	O
view	pointer
,	O
int	O
c	int
)	O
{	O
c	int
=	O
convert_from_input_c	O
(	O
c	int
)	O
;	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\t'	O
:	O
view	pointer
->	O
hexview_in_text	int
=	O
!	O
view	pointer
->	O
hexview_in_text	int
;	O
view	pointer
->	O
dirty	int
++	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'a'	O
)	O
:	O
view_moveto_bol	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'b'	O
)	O
:	O
view_move_left	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'e'	O
)	O
:	O
view_moveto_eol	function
(	O
view	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'f'	O
)	O
:	O
view_move_right	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
view	pointer
->	O
hexedit_mode	int
&&	O
view_handle_editkey	function
(	O
view	pointer
,	O
c	int
)	O
==	O
MSG_HANDLED	int
)	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
check_left_right_keys	function
(	O
view	pointer
,	O
c	int
)	O
)	O
return	O
MSG_HANDLED	int
;	O
if	O
(	O
check_movement_keys	function
(	O
c	int
,	O
view	pointer
->	O
data_area	struct
.	O
height	int
+	O
1	int
,	O
view	pointer
,	O
view_cmk_move_up	function
,	O
view_cmk_move_down	function
,	O
view_cmk_moveto_top	function
,	O
view_cmk_moveto_bottom	function
)	O
)	O
return	O
MSG_HANDLED	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'?'	O
:	O
regexp_search	function
(	O
view	pointer
,	O
-	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'/'	O
:	O
regexp_search	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'r'	O
)	O
:	O
case	O
XCTRL	O
(	O
's'	O
)	O
:	O
case	O
'n'	O
:	O
case	O
KEY_F	O
(	O
17	int
)	O
:	O
view_continue_search_cmd	function
(	O
view	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
ALT	O
(	O
'r'	O
)	O
:	O
view_toggle_ruler_cmd	function
(	O
view	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'h'	O
:	O
view_move_left	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'j'	O
:	O
case	O
'\n'	O
:	O
case	O
'e'	O
:	O
view_move_down	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'd'	O
:	O
view_move_down	function
(	O
view	pointer
,	O
(	O
view	pointer
->	O
data_area	struct
.	O
height	int
+	O
1	int
)	O
/	O
2	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'u'	O
:	O
view_move_up	function
(	O
view	pointer
,	O
(	O
view	pointer
->	O
data_area	struct
.	O
height	int
+	O
1	int
)	O
/	O
2	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'k'	O
:	O
case	O
'y'	O
:	O
view_move_up	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'l'	O
:	O
view_move_right	function
(	O
view	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
' '	O
:	O
case	O
'f'	O
:	O
view_move_down	function
(	O
view	pointer
,	O
view	pointer
->	O
data_area	struct
.	O
height	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'o'	O
)	O
:	O
view_other_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'!'	O
:	O
exec_shell	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'b'	O
:	O
view_move_up	function
(	O
view	pointer
,	O
view	pointer
->	O
data_area	struct
.	O
height	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_IC	int
:	O
view_move_up	function
(	O
view	pointer
,	O
2	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_DC	int
:	O
view_move_down	function
(	O
view	pointer
,	O
2	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'm'	O
:	O
view	pointer
->	O
marks	array
[	O
view	pointer
->	O
marker	int
]	O
=	O
view	pointer
->	O
dpy_start	long
;	O
return	O
MSG_HANDLED	int
;	O
case	O
'r'	O
:	O
view	pointer
->	O
dpy_start	long
=	O
view	pointer
->	O
marks	array
[	O
view	pointer
->	O
marker	int
]	O
;	O
view	pointer
->	O
dirty	int
++	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'f'	O
)	O
:	O
case	O
XCTRL	O
(	O
'b'	O
)	O
:	O
if	O
(	O
!	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
view	pointer
->	O
move_dir	int
=	O
c	int
==	O
XCTRL	O
(	O
'f'	O
)	O
?	O
1	int
:	O
-	O
1	int
;	O
case	O
'q'	O
:	O
case	O
XCTRL	O
(	O
'g'	O
)	O
:	O
case	O
ESC_CHAR	char
:	O
if	O
(	O
view_ok_to_quit	function
(	O
view	pointer
)	O
)	O
view	pointer
->	O
want_to_quit	int
=	O
TRUE	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
view	pointer
->	O
marker	int
=	O
c	int
-	O
'0'	O
;	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
static	O
int	O
view_event	function
(	O
WView	struct
*	O
view	pointer
,	O
Gpm_Event	struct
*	O
event	pointer
,	O
int	O
*	O
result	long
)	O
{	O
screen_dimen	int
y	short
,	O
x	array
;	O
*	O
result	long
=	O
MOU_NORMAL	int
;	O
if	O
(	O
!	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOWN	int
|	O
GPM_DRAG	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
event	pointer
->	O
buttons	int
&	O
GPM_B_UP	O
)	O
&&	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_DOWN	int
)	O
)	O
{	O
view_move_up	function
(	O
view	pointer
,	O
2	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
event	pointer
->	O
buttons	int
&	O
GPM_B_DOWN	O
)	O
&&	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_DOWN	int
)	O
)	O
{	O
view_move_down	function
(	O
view	pointer
,	O
2	int
)	O
;	O
return	O
1	int
;	O
}	O
x	array
=	O
event	pointer
->	O
x	array
;	O
y	short
=	O
event	pointer
->	O
y	short
;	O
if	O
(	O
!	O
view	pointer
->	O
text_wrap_mode	int
)	O
{	O
if	O
(	O
x	array
<	O
view	pointer
->	O
data_area	struct
.	O
width	int
*	O
1	int
/	O
4	int
)	O
{	O
view_move_left	function
(	O
view	pointer
,	O
1	int
)	O
;	O
goto	O
processed	O
;	O
}	O
else	O
if	O
(	O
x	array
<	O
view	pointer
->	O
data_area	struct
.	O
width	int
*	O
3	int
/	O
4	int
)	O
{	O
}	O
else	O
{	O
view_move_right	function
(	O
view	pointer
,	O
1	int
)	O
;	O
goto	O
processed	O
;	O
}	O
}	O
if	O
(	O
y	short
<	O
view	pointer
->	O
data_area	struct
.	O
top	pointer
+	O
view	pointer
->	O
data_area	struct
.	O
height	int
*	O
1	int
/	O
3	int
)	O
{	O
if	O
(	O
mouse_move_pages_viewer	int
)	O
view_move_up	function
(	O
view	pointer
,	O
view	pointer
->	O
data_area	struct
.	O
height	int
/	O
2	int
)	O
;	O
else	O
view_move_up	function
(	O
view	pointer
,	O
1	int
)	O
;	O
goto	O
processed	O
;	O
}	O
else	O
if	O
(	O
y	short
<	O
view	pointer
->	O
data_area	struct
.	O
top	pointer
+	O
view	pointer
->	O
data_area	struct
.	O
height	int
*	O
2	int
/	O
3	int
)	O
{	O
}	O
else	O
{	O
if	O
(	O
mouse_move_pages_viewer	int
)	O
view_move_down	function
(	O
view	pointer
,	O
view	pointer
->	O
data_area	struct
.	O
height	int
/	O
2	int
)	O
;	O
else	O
view_move_down	function
(	O
view	pointer
,	O
1	int
)	O
;	O
goto	O
processed	O
;	O
}	O
return	O
0	int
;	O
processed	O
:	O
*	O
result	long
=	O
MOU_REPEAT	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
real_view_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
x	array
)	O
{	O
WView	struct
*	O
view	pointer
=	O
(	O
WView	struct
*	O
)	O
x	array
;	O
int	O
result	long
;	O
if	O
(	O
view_event	function
(	O
view	pointer
,	O
event	pointer
,	O
&	O
result	long
)	O
)	O
view_update	function
(	O
view	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
void	O
view_adjust_size	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
WView	struct
*	O
view	pointer
;	O
WButtonBar	struct
*	O
bar	pointer
;	O
view	pointer
=	O
(	O
WView	struct
*	O
)	O
find_widget_type	function
(	O
h	pointer
,	O
view_callback	function
)	O
;	O
bar	pointer
=	O
find_buttonbar	function
(	O
h	pointer
)	O
;	O
widget_set_size	function
(	O
&	O
view	pointer
->	O
widget	pointer
,	O
0	int
,	O
0	int
,	O
LINES	O
-	O
1	int
,	O
COLS	O
)	O
;	O
widget_set_size	function
(	O
(	O
Widget	struct
*	O
)	O
bar	pointer
,	O
LINES	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
COLS	O
)	O
;	O
view_compute_areas	function
(	O
view	pointer
)	O
;	O
view_update_bytes_per_line	function
(	O
view	pointer
)	O
;	O
}	O
static	O
cb_ret_t	enum
view_dialog_callback	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_RESIZE	int
:	O
view_adjust_size	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
int	O
mc_internal_viewer	function
(	O
const	O
char	O
*	O
command	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
int	O
*	O
move_dir_p	pointer
,	O
int	O
start_line	int
)	O
{	O
gboolean	int
succeeded	int
;	O
WView	struct
*	O
wview	pointer
;	O
WButtonBar	struct
*	O
bar	pointer
;	O
Dlg_head	struct
*	O
view_dlg	pointer
;	O
view_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
LINES	O
,	O
COLS	O
,	O
NULL	O
,	O
view_dialog_callback	function
,	O
"[Internal File Viewer]"	pointer
,	O
NULL	O
,	O
DLG_WANT_TAB	O
)	O
;	O
wview	pointer
=	O
view_new	function
(	O
0	int
,	O
0	int
,	O
COLS	O
,	O
LINES	O
-	O
1	int
,	O
0	int
)	O
;	O
bar	pointer
=	O
buttonbar_new	function
(	O
1	int
)	O
;	O
add_widget	function
(	O
view_dlg	pointer
,	O
bar	pointer
)	O
;	O
add_widget	function
(	O
view_dlg	pointer
,	O
wview	pointer
)	O
;	O
succeeded	int
=	O
view_load	function
(	O
wview	pointer
,	O
command	pointer
,	O
file	pointer
,	O
start_line	int
)	O
;	O
if	O
(	O
succeeded	int
)	O
{	O
run_dlg	function
(	O
view_dlg	pointer
)	O
;	O
if	O
(	O
move_dir_p	pointer
)	O
*	O
move_dir_p	pointer
=	O
wview	pointer
->	O
move_dir	int
;	O
}	O
else	O
{	O
if	O
(	O
move_dir_p	pointer
)	O
*	O
move_dir_p	pointer
=	O
0	int
;	O
}	O
destroy_dlg	function
(	O
view_dlg	pointer
)	O
;	O
return	O
succeeded	int
;	O
}	O
static	O
void	O
view_hook	function
(	O
void	O
*	O
v	pointer
)	O
{	O
WView	struct
*	O
view	pointer
=	O
(	O
WView	struct
*	O
)	O
v	pointer
;	O
WPanel	struct
*	O
panel	pointer
;	O
if	O
(	O
!	O
is_idle	function
(	O
)	O
)	O
{	O
if	O
(	O
!	O
hook_present	function
(	O
idle_hook	pointer
,	O
view_hook	function
)	O
)	O
add_hook	function
(	O
&	O
idle_hook	pointer
,	O
view_hook	function
,	O
v	pointer
)	O
;	O
return	O
;	O
}	O
delete_hook	function
(	O
&	O
idle_hook	pointer
,	O
view_hook	function
)	O
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_listing	int
)	O
panel	pointer
=	O
current_panel	pointer
;	O
else	O
if	O
(	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
panel	pointer
=	O
other_panel	O
;	O
else	O
return	O
;	O
view_load	function
(	O
view	pointer
,	O
0	int
,	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
fname	pointer
,	O
0	int
)	O
;	O
display	function
(	O
view	pointer
)	O
;	O
}	O
static	O
cb_ret_t	enum
view_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WView	struct
*	O
view	pointer
=	O
(	O
WView	struct
*	O
)	O
w	pointer
;	O
cb_ret_t	enum
i	array
;	O
Dlg_head	struct
*	O
h	pointer
=	O
view	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
view_compute_areas	function
(	O
view	pointer
)	O
;	O
view_update_bytes_per_line	function
(	O
view	pointer
)	O
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_INIT	int
:	O
if	O
(	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
add_hook	function
(	O
&	O
select_file_hook	pointer
,	O
view_hook	function
,	O
view	pointer
)	O
;	O
else	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DRAW	int
:	O
display	function
(	O
view	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_CURSOR	int
:	O
if	O
(	O
view	pointer
->	O
hex_mode	int
)	O
view_place_cursor	function
(	O
view	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
i	array
=	O
view_handle_key	function
(	O
(	O
WView	struct
*	O
)	O
view	pointer
,	O
parm	int
)	O
;	O
if	O
(	O
view	pointer
->	O
want_to_quit	int
&&	O
!	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
else	O
{	O
view_update	function
(	O
view	pointer
)	O
;	O
}	O
return	O
i	array
;	O
case	O
WIDGET_FOCUS	int
:	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view_update	function
(	O
view	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
view_done	function
(	O
view	pointer
)	O
;	O
if	O
(	O
view_is_in_panel	function
(	O
view	pointer
)	O
)	O
delete_hook	function
(	O
&	O
select_file_hook	pointer
,	O
view_hook	function
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
WView	struct
*	O
view_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
cols	int
,	O
int	O
lines	pointer
,	O
int	O
is_panel	int
)	O
{	O
WView	struct
*	O
view	pointer
=	O
g_new0	O
(	O
WView	struct
,	O
1	int
)	O
;	O
size_t	long
i	array
;	O
init_widget	function
(	O
&	O
view	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
lines	pointer
,	O
cols	int
,	O
view_callback	function
,	O
real_view_event	function
)	O
;	O
view	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
view	pointer
->	O
command	pointer
=	O
NULL	O
;	O
view_set_datasource_none	function
(	O
view	pointer
)	O
;	O
view	pointer
->	O
growbuf_in_use	int
=	O
FALSE	O
;	O
view	pointer
->	O
hex_mode	int
=	O
FALSE	O
;	O
view	pointer
->	O
hexedit_mode	int
=	O
FALSE	O
;	O
view	pointer
->	O
hexview_in_text	int
=	O
FALSE	O
;	O
view	pointer
->	O
text_nroff_mode	int
=	O
FALSE	O
;	O
view	pointer
->	O
text_wrap_mode	int
=	O
FALSE	O
;	O
view	pointer
->	O
magic_mode	int
=	O
FALSE	O
;	O
view	pointer
->	O
hexedit_lownibble	int
=	O
FALSE	O
;	O
view	pointer
->	O
coord_cache	pointer
=	O
NULL	O
;	O
view	pointer
->	O
dpy_frame_size	int
=	O
is_panel	int
?	O
1	int
:	O
0	int
;	O
view	pointer
->	O
dpy_start	long
=	O
0	int
;	O
view	pointer
->	O
dpy_text_column	long
=	O
0	int
;	O
view	pointer
->	O
dpy_end	long
=	O
0	int
;	O
view	pointer
->	O
hex_cursor	long
=	O
0	int
;	O
view	pointer
->	O
cursor_col	int
=	O
0	int
;	O
view	pointer
->	O
cursor_row	int
=	O
0	int
;	O
view	pointer
->	O
change_list	pointer
=	O
NULL	O
;	O
view	pointer
->	O
dirty	int
=	O
0	int
;	O
view	pointer
->	O
dpy_bbar_dirty	int
=	O
TRUE	O
;	O
view	pointer
->	O
bytes_per_line	int
=	O
1	int
;	O
view	pointer
->	O
search_start	long
=	O
0	int
;	O
view	pointer
->	O
search_length	long
=	O
0	int
;	O
view	pointer
->	O
search_exp	pointer
=	O
NULL	O
;	O
view	pointer
->	O
direction	int
=	O
1	int
;	O
view	pointer
->	O
last_search	pointer
=	O
0	int
;	O
view	pointer
->	O
want_to_quit	int
=	O
FALSE	O
;	O
view	pointer
->	O
marker	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
sizeof	O
(	O
view	pointer
->	O
marks	array
)	O
/	O
sizeof	O
(	O
view	pointer
->	O
marks	array
[	O
0	int
]	O
)	O
;	O
i	array
++	O
)	O
view	pointer
->	O
marks	array
[	O
i	array
]	O
=	O
0	int
;	O
view	pointer
->	O
move_dir	int
=	O
0	int
;	O
view	pointer
->	O
update_steps	long
=	O
0	int
;	O
view	pointer
->	O
update_activate	long
=	O
0	int
;	O
if	O
(	O
default_hex_mode	int
)	O
view_toggle_hex_mode	function
(	O
view	pointer
)	O
;	O
if	O
(	O
default_nroff_flag	int
)	O
view_toggle_nroff_mode	function
(	O
view	pointer
)	O
;	O
if	O
(	O
global_wrap_mode	int
)	O
view_toggle_wrap_mode	function
(	O
view	pointer
)	O
;	O
if	O
(	O
default_magic_flag	int
)	O
view_toggle_magic_mode	function
(	O
view	pointer
)	O
;	O
return	O
view	pointer
;	O
}	O