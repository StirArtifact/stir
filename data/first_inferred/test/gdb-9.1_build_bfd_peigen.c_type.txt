void	O
_bfd_pei_swap_sym_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
ext1	pointer
,	O
void	O
*	O
in1	pointer
)	O
{	O
SYMENT	O
*	O
ext	pointer
=	O
(	O
SYMENT	O
*	O
)	O
ext1	pointer
;	O
struct	O
internal_syment	struct
*	O
in	pointer
=	O
(	O
struct	O
internal_syment	struct
*	O
)	O
in1	pointer
;	O
if	O
(	O
ext	pointer
->	O
e	struct
.	O
e_name	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
in	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
=	O
0	int
;	O
in	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e	struct
.	O
e	struct
.	O
e_offset	array
)	O
;	O
}	O
else	O
memcpy	function
(	O
in	pointer
->	O
_n	union
.	O
_n_name	array
,	O
ext	pointer
->	O
e	struct
.	O
e_name	array
,	O
SYMNMLEN	int
)	O
;	O
in	pointer
->	O
n_value	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e_value	array
)	O
;	O
in	pointer
->	O
n_scnum	int
=	O
(	O
short	O
)	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e_scnum	array
)	O
;	O
if	O
(	O
sizeof	O
(	O
ext	pointer
->	O
e_type	array
)	O
==	O
2	int
)	O
in	pointer
->	O
n_type	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e_type	array
)	O
;	O
else	O
in	pointer
->	O
n_type	short
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e_type	array
)	O
;	O
in	pointer
->	O
n_sclass	char
=	O
H_GET_8	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e_sclass	array
)	O
;	O
in	pointer
->	O
n_numaux	char
=	O
H_GET_8	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
e_numaux	array
)	O
;	O
if	O
(	O
in	pointer
->	O
n_sclass	char
==	O
C_SECTION	int
)	O
{	O
char	O
namebuf	array
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
const	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
in	pointer
->	O
n_value	long
=	O
0x0	int
;	O
if	O
(	O
in	pointer
->	O
n_scnum	int
==	O
0	int
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
name	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
abfd	pointer
,	O
in	pointer
,	O
namebuf	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to find name for empty section"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_target	int
)	O
;	O
return	O
;	O
}	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
in	pointer
->	O
n_scnum	int
=	O
sec	pointer
->	O
target_index	int
;	O
}	O
if	O
(	O
in	pointer
->	O
n_scnum	int
==	O
0	int
)	O
{	O
int	O
unused_section_number	int
=	O
0	int
;	O
asection	struct
*	O
sec	pointer
;	O
flagword	int
flags	int
;	O
for	O
(	O
sec	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
if	O
(	O
unused_section_number	int
<=	O
sec	pointer
->	O
target_index	int
)	O
unused_section_number	int
=	O
sec	pointer
->	O
target_index	int
+	O
1	int
;	O
if	O
(	O
name	pointer
==	O
namebuf	array
)	O
{	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
strlen	function
(	O
namebuf	array
)	O
+	O
1	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: out of memory creating name for empty section"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
return	O
;	O
}	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
name	pointer
,	O
namebuf	array
)	O
;	O
}	O
flags	int
=	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_DATA	int
|	O
SEC_LOAD	int
;	O
sec	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to create fake empty section"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
return	O
;	O
}	O
sec	pointer
->	O
vma	long
=	O
0	int
;	O
sec	pointer
->	O
lma	long
=	O
0	int
;	O
sec	pointer
->	O
size	long
=	O
0	int
;	O
sec	pointer
->	O
filepos	long
=	O
0	int
;	O
sec	pointer
->	O
rel_filepos	long
=	O
0	int
;	O
sec	pointer
->	O
reloc_count	int
=	O
0	int
;	O
sec	pointer
->	O
line_filepos	long
=	O
0	int
;	O
sec	pointer
->	O
lineno_count	int
=	O
0	int
;	O
sec	pointer
->	O
userdata	pointer
=	O
NULL	O
;	O
sec	pointer
->	O
next	pointer
=	O
NULL	O
;	O
sec	pointer
->	O
alignment_power	int
=	O
2	int
;	O
sec	pointer
->	O
target_index	int
=	O
unused_section_number	int
;	O
in	pointer
->	O
n_scnum	int
=	O
unused_section_number	int
;	O
}	O
in	pointer
->	O
n_sclass	char
=	O
C_STAT	int
;	O
}	O
}	O
static	O
bfd_boolean	int
abs_finder	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
bfd_vma	long
abs_val	long
=	O
*	O
(	O
bfd_vma	long
*	O
)	O
data	pointer
;	O
return	O
(	O
sec	pointer
->	O
vma	long
<=	O
abs_val	long
)	O
&&	O
(	O
(	O
sec	pointer
->	O
vma	long
+	O
(	O
1ULL	int
<<	O
32	int
)	O
)	O
>	O
abs_val	long
)	O
;	O
}	O
unsigned	O
int	O
_bfd_pei_swap_sym_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
inp	pointer
,	O
void	O
*	O
extp	pointer
)	O
{	O
struct	O
internal_syment	struct
*	O
in	pointer
=	O
(	O
struct	O
internal_syment	struct
*	O
)	O
inp	pointer
;	O
SYMENT	O
*	O
ext	pointer
=	O
(	O
SYMENT	O
*	O
)	O
extp	pointer
;	O
if	O
(	O
in	pointer
->	O
_n	union
.	O
_n_name	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
H_PUT_32	O
(	O
abfd	pointer
,	O
0	int
,	O
ext	pointer
->	O
e	struct
.	O
e	struct
.	O
e_zeroes	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
,	O
ext	pointer
->	O
e	struct
.	O
e	struct
.	O
e_offset	array
)	O
;	O
}	O
else	O
memcpy	function
(	O
ext	pointer
->	O
e	struct
.	O
e_name	array
,	O
in	pointer
->	O
_n	union
.	O
_n_name	array
,	O
SYMNMLEN	int
)	O
;	O
if	O
(	O
sizeof	O
(	O
in	pointer
->	O
n_value	long
)	O
>	O
4	int
&&	O
in	pointer
->	O
n_value	long
>	O
(	O
(	O
1ULL	int
<<	O
(	O
sizeof	O
(	O
in	pointer
->	O
n_value	long
)	O
>	O
4	int
?	O
32	int
:	O
31	int
)	O
)	O
-	O
1	int
)	O
&&	O
in	pointer
->	O
n_scnum	int
==	O
N_ABS	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
bfd_sections_find_if	function
(	O
abfd	pointer
,	O
abs_finder	function
,	O
&	O
in	pointer
->	O
n_value	long
)	O
;	O
if	O
(	O
sec	pointer
)	O
{	O
in	pointer
->	O
n_value	long
-=	O
sec	pointer
->	O
vma	long
;	O
in	pointer
->	O
n_scnum	int
=	O
sec	pointer
->	O
target_index	int
;	O
}	O
}	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
n_value	long
,	O
ext	pointer
->	O
e_value	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
n_scnum	int
,	O
ext	pointer
->	O
e_scnum	array
)	O
;	O
if	O
(	O
sizeof	O
(	O
ext	pointer
->	O
e_type	array
)	O
==	O
2	int
)	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
n_type	short
,	O
ext	pointer
->	O
e_type	array
)	O
;	O
else	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
n_type	short
,	O
ext	pointer
->	O
e_type	array
)	O
;	O
H_PUT_8	O
(	O
abfd	pointer
,	O
in	pointer
->	O
n_sclass	char
,	O
ext	pointer
->	O
e_sclass	array
)	O
;	O
H_PUT_8	O
(	O
abfd	pointer
,	O
in	pointer
->	O
n_numaux	char
,	O
ext	pointer
->	O
e_numaux	array
)	O
;	O
return	O
SYMESZ	int
;	O
}	O
void	O
_bfd_pei_swap_aux_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
ext1	pointer
,	O
int	O
type	enum
,	O
int	O
in_class	int
,	O
int	O
indx	long
ATTRIBUTE_UNUSED	O
,	O
int	O
numaux	char
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
in1	pointer
)	O
{	O
AUXENT	O
*	O
ext	pointer
=	O
(	O
AUXENT	O
*	O
)	O
ext1	pointer
;	O
union	O
internal_auxent	union
*	O
in	pointer
=	O
(	O
union	O
internal_auxent	union
*	O
)	O
in1	pointer
;	O
memset	function
(	O
in	pointer
,	O
0	int
,	O
sizeof	O
*	O
in	pointer
)	O
;	O
switch	O
(	O
in_class	int
)	O
{	O
case	O
C_FILE	int
:	O
if	O
(	O
ext	pointer
->	O
x_file	union
.	O
x_fname	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
in	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_zeroes	long
=	O
0	int
;	O
in	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
)	O
;	O
}	O
else	O
memcpy	function
(	O
in	pointer
->	O
x_file	union
.	O
x_fname	array
,	O
ext	pointer
->	O
x_file	union
.	O
x_fname	array
,	O
FILNMLEN	int
)	O
;	O
return	O
;	O
case	O
C_STAT	int
:	O
case	O
C_LEAFSTAT	int
:	O
case	O
C_HIDDEN	int
:	O
if	O
(	O
type	enum
==	O
T_NULL	int
)	O
{	O
in	pointer
->	O
x_scn	struct
.	O
x_scnlen	long
=	O
GET_SCN_SCNLEN	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
in	pointer
->	O
x_scn	struct
.	O
x_nreloc	short
=	O
GET_SCN_NRELOC	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
in	pointer
->	O
x_scn	struct
.	O
x_nlinno	short
=	O
GET_SCN_NLINNO	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
in	pointer
->	O
x_scn	struct
.	O
x_checksum	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_scn	struct
.	O
x_checksum	long
)	O
;	O
in	pointer
->	O
x_scn	struct
.	O
x_associated	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_scn	struct
.	O
x_associated	short
)	O
;	O
in	pointer
->	O
x_scn	struct
.	O
x_comdat	char
=	O
H_GET_8	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_scn	struct
.	O
x_comdat	char
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
in	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
)	O
;	O
in	pointer
->	O
x_sym	struct
.	O
x_tvndx	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_tvndx	short
)	O
;	O
if	O
(	O
in_class	int
==	O
C_BLOCK	int
||	O
in_class	int
==	O
C_FCN	int
||	O
ISFCN	O
(	O
type	enum
)	O
||	O
ISTAG	O
(	O
in_class	int
)	O
)	O
{	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_lnnoptr	long
=	O
GET_FCN_LNNOPTR	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
=	O
GET_FCN_ENDNDX	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
}	O
else	O
{	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
0	int
]	O
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
0	int
]	O
)	O
;	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
1	int
]	O
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
1	int
]	O
)	O
;	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
2	int
]	O
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
2	int
]	O
)	O
;	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
3	int
]	O
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
3	int
]	O
)	O
;	O
}	O
if	O
(	O
ISFCN	O
(	O
type	enum
)	O
)	O
{	O
in	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_fsize	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_fsize	long
)	O
;	O
}	O
else	O
{	O
in	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_lnno	short
=	O
GET_LNSZ_LNNO	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
in	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_size	short
=	O
GET_LNSZ_SIZE	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
}	O
}	O
unsigned	O
int	O
_bfd_pei_swap_aux_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
inp	pointer
,	O
int	O
type	enum
,	O
int	O
in_class	int
,	O
int	O
indx	long
ATTRIBUTE_UNUSED	O
,	O
int	O
numaux	char
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
extp	pointer
)	O
{	O
union	O
internal_auxent	union
*	O
in	pointer
=	O
(	O
union	O
internal_auxent	union
*	O
)	O
inp	pointer
;	O
AUXENT	O
*	O
ext	pointer
=	O
(	O
AUXENT	O
*	O
)	O
extp	pointer
;	O
memset	function
(	O
ext	pointer
,	O
0	int
,	O
AUXESZ	int
)	O
;	O
switch	O
(	O
in_class	int
)	O
{	O
case	O
C_FILE	int
:	O
if	O
(	O
in	pointer
->	O
x_file	union
.	O
x_fname	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
H_PUT_32	O
(	O
abfd	pointer
,	O
0	int
,	O
ext	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_zeroes	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
,	O
ext	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
)	O
;	O
}	O
else	O
memcpy	function
(	O
ext	pointer
->	O
x_file	union
.	O
x_fname	array
,	O
in	pointer
->	O
x_file	union
.	O
x_fname	array
,	O
FILNMLEN	int
)	O
;	O
return	O
AUXESZ	int
;	O
case	O
C_STAT	int
:	O
case	O
C_LEAFSTAT	int
:	O
case	O
C_HIDDEN	int
:	O
if	O
(	O
type	enum
==	O
T_NULL	int
)	O
{	O
PUT_SCN_SCNLEN	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_scn	struct
.	O
x_scnlen	long
,	O
ext	pointer
)	O
;	O
PUT_SCN_NRELOC	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_scn	struct
.	O
x_nreloc	short
,	O
ext	pointer
)	O
;	O
PUT_SCN_NLINNO	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_scn	struct
.	O
x_nlinno	short
,	O
ext	pointer
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_scn	struct
.	O
x_checksum	long
,	O
ext	pointer
->	O
x_scn	struct
.	O
x_checksum	long
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_scn	struct
.	O
x_associated	short
,	O
ext	pointer
->	O
x_scn	struct
.	O
x_associated	short
)	O
;	O
H_PUT_8	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_scn	struct
.	O
x_comdat	char
,	O
ext	pointer
->	O
x_scn	struct
.	O
x_comdat	char
)	O
;	O
return	O
AUXESZ	int
;	O
}	O
break	O
;	O
}	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_tvndx	short
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_tvndx	short
)	O
;	O
if	O
(	O
in_class	int
==	O
C_BLOCK	int
||	O
in_class	int
==	O
C_FCN	int
||	O
ISFCN	O
(	O
type	enum
)	O
||	O
ISTAG	O
(	O
in_class	int
)	O
)	O
{	O
PUT_FCN_LNNOPTR	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_lnnoptr	long
,	O
ext	pointer
)	O
;	O
PUT_FCN_ENDNDX	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
,	O
ext	pointer
)	O
;	O
}	O
else	O
{	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
0	int
]	O
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
0	int
]	O
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
1	int
]	O
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
1	int
]	O
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
2	int
]	O
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
2	int
]	O
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
3	int
]	O
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_ary	struct
.	O
x_dimen	array
[	O
3	int
]	O
)	O
;	O
}	O
if	O
(	O
ISFCN	O
(	O
type	enum
)	O
)	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_fsize	long
,	O
ext	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_fsize	long
)	O
;	O
else	O
{	O
PUT_LNSZ_LNNO	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_lnno	short
,	O
ext	pointer
)	O
;	O
PUT_LNSZ_SIZE	O
(	O
abfd	pointer
,	O
in	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_size	short
,	O
ext	pointer
)	O
;	O
}	O
return	O
AUXESZ	int
;	O
}	O
void	O
_bfd_pei_swap_lineno_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
ext1	pointer
,	O
void	O
*	O
in1	pointer
)	O
{	O
LINENO	O
*	O
ext	pointer
=	O
(	O
LINENO	O
*	O
)	O
ext1	pointer
;	O
struct	O
internal_lineno	struct
*	O
in	pointer
=	O
(	O
struct	O
internal_lineno	struct
*	O
)	O
in1	pointer
;	O
in	pointer
->	O
l_addr	union
.	O
l_symndx	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
l_addr	union
.	O
l_symndx	long
)	O
;	O
in	pointer
->	O
l_lnno	long
=	O
GET_LINENO_LNNO	O
(	O
abfd	pointer
,	O
ext	pointer
)	O
;	O
}	O
unsigned	O
int	O
_bfd_pei_swap_lineno_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
inp	pointer
,	O
void	O
*	O
outp	pointer
)	O
{	O
struct	O
internal_lineno	struct
*	O
in	pointer
=	O
(	O
struct	O
internal_lineno	struct
*	O
)	O
inp	pointer
;	O
struct	O
external_lineno	struct
*	O
ext	pointer
=	O
(	O
struct	O
external_lineno	struct
*	O
)	O
outp	pointer
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
l_addr	union
.	O
l_symndx	long
,	O
ext	pointer
->	O
l_addr	union
.	O
l_symndx	long
)	O
;	O
PUT_LINENO_LNNO	O
(	O
abfd	pointer
,	O
in	pointer
->	O
l_lnno	long
,	O
ext	pointer
)	O
;	O
return	O
LINESZ	O
;	O
}	O
void	O
_bfd_pei_swap_aouthdr_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
aouthdr_ext1	pointer
,	O
void	O
*	O
aouthdr_int1	pointer
)	O
{	O
PEAOUTHDR	struct
*	O
src	pointer
=	O
(	O
PEAOUTHDR	struct
*	O
)	O
aouthdr_ext1	pointer
;	O
AOUTHDR	struct
*	O
aouthdr_ext	pointer
=	O
(	O
AOUTHDR	struct
*	O
)	O
aouthdr_ext1	pointer
;	O
struct	O
internal_aouthdr	struct
*	O
aouthdr_int	pointer
=	O
(	O
struct	O
internal_aouthdr	struct
*	O
)	O
aouthdr_int1	pointer
;	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
a	pointer
=	O
&	O
aouthdr_int	pointer
->	O
pe	struct
;	O
aouthdr_int	pointer
->	O
magic	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
magic	short
)	O
;	O
aouthdr_int	pointer
->	O
vstamp	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
vstamp	short
)	O
;	O
aouthdr_int	pointer
->	O
tsize	long
=	O
GET_AOUTHDR_TSIZE	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
tsize	long
)	O
;	O
aouthdr_int	pointer
->	O
dsize	long
=	O
GET_AOUTHDR_DSIZE	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
dsize	long
)	O
;	O
aouthdr_int	pointer
->	O
bsize	long
=	O
GET_AOUTHDR_BSIZE	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
bsize	long
)	O
;	O
aouthdr_int	pointer
->	O
entry	pointer
=	O
GET_AOUTHDR_ENTRY	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
entry	pointer
)	O
;	O
aouthdr_int	pointer
->	O
text_start	long
=	O
GET_AOUTHDR_TEXT_START	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
text_start	long
)	O
;	O
aouthdr_int	pointer
->	O
data_start	long
=	O
GET_AOUTHDR_DATA_START	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
data_start	long
)	O
;	O
a	pointer
->	O
BaseOfData	long
=	O
aouthdr_int	pointer
->	O
data_start	long
;	O
a	pointer
->	O
Magic	short
=	O
aouthdr_int	pointer
->	O
magic	short
;	O
a	pointer
->	O
MajorLinkerVersion	char
=	O
H_GET_8	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
vstamp	short
)	O
;	O
a	pointer
->	O
MinorLinkerVersion	char
=	O
H_GET_8	O
(	O
abfd	pointer
,	O
aouthdr_ext	pointer
->	O
vstamp	short
+	O
1	int
)	O
;	O
a	pointer
->	O
SizeOfCode	long
=	O
aouthdr_int	pointer
->	O
tsize	long
;	O
a	pointer
->	O
SizeOfInitializedData	long
=	O
aouthdr_int	pointer
->	O
dsize	long
;	O
a	pointer
->	O
SizeOfUninitializedData	long
=	O
aouthdr_int	pointer
->	O
bsize	long
;	O
a	pointer
->	O
AddressOfEntryPoint	long
=	O
aouthdr_int	pointer
->	O
entry	pointer
;	O
a	pointer
->	O
BaseOfCode	long
=	O
aouthdr_int	pointer
->	O
text_start	long
;	O
a	pointer
->	O
ImageBase	long
=	O
GET_OPTHDR_IMAGE_BASE	O
(	O
abfd	pointer
,	O
src	pointer
->	O
ImageBase	long
)	O
;	O
a	pointer
->	O
SectionAlignment	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SectionAlignment	int
)	O
;	O
a	pointer
->	O
FileAlignment	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
FileAlignment	int
)	O
;	O
a	pointer
->	O
MajorOperatingSystemVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
MajorOperatingSystemVersion	short
)	O
;	O
a	pointer
->	O
MinorOperatingSystemVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
MinorOperatingSystemVersion	short
)	O
;	O
a	pointer
->	O
MajorImageVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
MajorImageVersion	short
)	O
;	O
a	pointer
->	O
MinorImageVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
MinorImageVersion	short
)	O
;	O
a	pointer
->	O
MajorSubsystemVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
MajorSubsystemVersion	short
)	O
;	O
a	pointer
->	O
MinorSubsystemVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
MinorSubsystemVersion	short
)	O
;	O
a	pointer
->	O
Reserved1	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
Reserved1	int
)	O
;	O
a	pointer
->	O
SizeOfImage	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SizeOfImage	int
)	O
;	O
a	pointer
->	O
SizeOfHeaders	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SizeOfHeaders	int
)	O
;	O
a	pointer
->	O
CheckSum	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
CheckSum	int
)	O
;	O
a	pointer
->	O
Subsystem	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
Subsystem	short
)	O
;	O
a	pointer
->	O
DllCharacteristics	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
DllCharacteristics	short
)	O
;	O
a	pointer
->	O
SizeOfStackReserve	long
=	O
GET_OPTHDR_SIZE_OF_STACK_RESERVE	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SizeOfStackReserve	long
)	O
;	O
a	pointer
->	O
SizeOfStackCommit	long
=	O
GET_OPTHDR_SIZE_OF_STACK_COMMIT	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SizeOfStackCommit	long
)	O
;	O
a	pointer
->	O
SizeOfHeapReserve	long
=	O
GET_OPTHDR_SIZE_OF_HEAP_RESERVE	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SizeOfHeapReserve	long
)	O
;	O
a	pointer
->	O
SizeOfHeapCommit	long
=	O
GET_OPTHDR_SIZE_OF_HEAP_COMMIT	O
(	O
abfd	pointer
,	O
src	pointer
->	O
SizeOfHeapCommit	long
)	O
;	O
a	pointer
->	O
LoaderFlags	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
LoaderFlags	int
)	O
;	O
a	pointer
->	O
NumberOfRvaAndSizes	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
NumberOfRvaAndSizes	int
)	O
;	O
{	O
unsigned	O
idx	int
;	O
if	O
(	O
a	pointer
->	O
NumberOfRvaAndSizes	int
>	O
IMAGE_NUMBEROF_DIRECTORY_ENTRIES	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: aout header specifies an invalid number of"	pointer
" data-directory entries: %u"	pointer
)	O
,	O
abfd	pointer
,	O
a	pointer
->	O
NumberOfRvaAndSizes	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
a	pointer
->	O
NumberOfRvaAndSizes	int
=	O
0	int
;	O
}	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
a	pointer
->	O
NumberOfRvaAndSizes	int
;	O
idx	int
++	O
)	O
{	O
int	O
size	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
[	O
1	int
]	O
)	O
;	O
a	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
Size	long
=	O
size	long
;	O
if	O
(	O
size	long
)	O
a	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
VirtualAddress	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
[	O
0	int
]	O
)	O
;	O
else	O
a	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
VirtualAddress	long
=	O
0	int
;	O
}	O
while	O
(	O
idx	int
<	O
IMAGE_NUMBEROF_DIRECTORY_ENTRIES	int
)	O
{	O
a	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
Size	long
=	O
0	int
;	O
a	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
VirtualAddress	long
=	O
0	int
;	O
idx	int
++	O
;	O
}	O
}	O
if	O
(	O
aouthdr_int	pointer
->	O
entry	pointer
)	O
{	O
aouthdr_int	pointer
->	O
entry	pointer
+=	O
a	pointer
->	O
ImageBase	long
;	O
aouthdr_int	pointer
->	O
entry	pointer
&=	O
0xffffffff	int
;	O
}	O
if	O
(	O
aouthdr_int	pointer
->	O
tsize	long
)	O
{	O
aouthdr_int	pointer
->	O
text_start	long
+=	O
a	pointer
->	O
ImageBase	long
;	O
aouthdr_int	pointer
->	O
text_start	long
&=	O
0xffffffff	int
;	O
}	O
if	O
(	O
aouthdr_int	pointer
->	O
dsize	long
)	O
{	O
aouthdr_int	pointer
->	O
data_start	long
+=	O
a	pointer
->	O
ImageBase	long
;	O
aouthdr_int	pointer
->	O
data_start	long
&=	O
0xffffffff	int
;	O
}	O
}	O
static	O
void	O
add_data_entry	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
aout	pointer
,	O
int	O
idx	int
,	O
char	O
*	O
name	pointer
,	O
bfd_vma	long
base	int
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
sec	pointer
!=	O
NULL	O
)	O
&&	O
(	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
!=	O
NULL	O
)	O
&&	O
(	O
pei_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
!=	O
NULL	O
)	O
)	O
{	O
int	O
size	long
=	O
pei_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
virt_size	long
;	O
aout	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
Size	long
=	O
size	long
;	O
if	O
(	O
size	long
)	O
{	O
aout	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
VirtualAddress	long
=	O
(	O
sec	pointer
->	O
vma	long
-	O
base	int
)	O
&	O
0xffffffff	int
;	O
sec	pointer
->	O
flags	int
|=	O
SEC_DATA	int
;	O
}	O
}	O
}	O
unsigned	O
int	O
_bfd_pei_swap_aouthdr_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
in	pointer
,	O
void	O
*	O
out	pointer
)	O
{	O
struct	O
internal_aouthdr	struct
*	O
aouthdr_in	pointer
=	O
(	O
struct	O
internal_aouthdr	struct
*	O
)	O
in	pointer
;	O
pe_data_type	struct
*	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
extra	pointer
=	O
&	O
pe	struct
->	O
pe_opthdr	struct
;	O
PEAOUTHDR	struct
*	O
aouthdr_out	pointer
=	O
(	O
PEAOUTHDR	struct
*	O
)	O
out	pointer
;	O
bfd_vma	long
sa	long
,	O
fa	long
,	O
ib	long
;	O
IMAGE_DATA_DIRECTORY	struct
idata2	struct
,	O
idata5	struct
,	O
tls	struct
;	O
sa	long
=	O
extra	pointer
->	O
SectionAlignment	int
;	O
fa	long
=	O
extra	pointer
->	O
FileAlignment	int
;	O
ib	long
=	O
extra	pointer
->	O
ImageBase	long
;	O
idata2	struct
=	O
pe	struct
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
;	O
idata5	struct
=	O
pe	struct
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
;	O
tls	struct
=	O
pe	struct
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_TLS_TABLE	int
]	O
;	O
if	O
(	O
aouthdr_in	pointer
->	O
tsize	long
)	O
{	O
aouthdr_in	pointer
->	O
text_start	long
-=	O
ib	long
;	O
aouthdr_in	pointer
->	O
text_start	long
&=	O
0xffffffff	int
;	O
}	O
if	O
(	O
aouthdr_in	pointer
->	O
dsize	long
)	O
{	O
aouthdr_in	pointer
->	O
data_start	long
-=	O
ib	long
;	O
aouthdr_in	pointer
->	O
data_start	long
&=	O
0xffffffff	int
;	O
}	O
if	O
(	O
aouthdr_in	pointer
->	O
entry	pointer
)	O
{	O
aouthdr_in	pointer
->	O
entry	pointer
-=	O
ib	long
;	O
aouthdr_in	pointer
->	O
entry	pointer
&=	O
0xffffffff	int
;	O
}	O
aouthdr_in	pointer
->	O
bsize	long
=	O
FA	O
(	O
aouthdr_in	pointer
->	O
bsize	long
)	O
;	O
extra	pointer
->	O
NumberOfRvaAndSizes	int
=	O
IMAGE_NUMBEROF_DIRECTORY_ENTRIES	int
;	O
add_data_entry	function
(	O
abfd	pointer
,	O
extra	pointer
,	O
PE_EXPORT_TABLE	int
,	O
".edata"	pointer
,	O
ib	long
)	O
;	O
add_data_entry	function
(	O
abfd	pointer
,	O
extra	pointer
,	O
PE_RESOURCE_TABLE	int
,	O
".rsrc"	pointer
,	O
ib	long
)	O
;	O
add_data_entry	function
(	O
abfd	pointer
,	O
extra	pointer
,	O
PE_EXCEPTION_TABLE	int
,	O
".pdata"	pointer
,	O
ib	long
)	O
;	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
=	O
idata2	struct
;	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
=	O
idata5	struct
;	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_TLS_TABLE	int
]	O
=	O
tls	struct
;	O
if	O
(	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
.	O
VirtualAddress	long
==	O
0	int
)	O
add_data_entry	function
(	O
abfd	pointer
,	O
extra	pointer
,	O
PE_IMPORT_TABLE	int
,	O
".idata"	pointer
,	O
ib	long
)	O
;	O
if	O
(	O
pe	struct
->	O
has_reloc_section	int
)	O
add_data_entry	function
(	O
abfd	pointer
,	O
extra	pointer
,	O
PE_BASE_RELOCATION_TABLE	int
,	O
".reloc"	pointer
,	O
ib	long
)	O
;	O
{	O
asection	struct
*	O
sec	pointer
;	O
bfd_vma	long
hsize	long
=	O
0	int
;	O
bfd_vma	long
dsize	long
=	O
0	int
;	O
bfd_vma	long
isize	long
=	O
0	int
;	O
bfd_vma	long
tsize	long
=	O
0	int
;	O
for	O
(	O
sec	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
int	O
rounded	int
=	O
FA	O
(	O
sec	pointer
->	O
size	long
)	O
;	O
if	O
(	O
rounded	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
hsize	long
==	O
0	int
)	O
hsize	long
=	O
sec	pointer
->	O
filepos	long
;	O
if	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_DATA	int
)	O
dsize	long
+=	O
rounded	int
;	O
if	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
tsize	long
+=	O
rounded	int
;	O
if	O
(	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
!=	O
NULL	O
&&	O
pei_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
!=	O
NULL	O
)	O
isize	long
=	O
(	O
sec	pointer
->	O
vma	long
-	O
extra	pointer
->	O
ImageBase	long
+	O
SA	O
(	O
FA	O
(	O
pei_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
virt_size	long
)	O
)	O
)	O
;	O
}	O
aouthdr_in	pointer
->	O
dsize	long
=	O
dsize	long
;	O
aouthdr_in	pointer
->	O
tsize	long
=	O
tsize	long
;	O
extra	pointer
->	O
SizeOfHeaders	int
=	O
hsize	long
;	O
extra	pointer
->	O
SizeOfImage	int
=	O
isize	long
;	O
}	O
H_PUT_16	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
magic	short
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
magic	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
(	O
LINKER_VERSION	O
/	O
100	int
+	O
(	O
LINKER_VERSION	O
%	O
100	int
)	O
*	O
256	int
)	O
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
vstamp	short
)	O
;	O
PUT_AOUTHDR_TSIZE	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
tsize	long
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
tsize	long
)	O
;	O
PUT_AOUTHDR_DSIZE	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
dsize	long
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
dsize	long
)	O
;	O
PUT_AOUTHDR_BSIZE	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
bsize	long
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
bsize	long
)	O
;	O
PUT_AOUTHDR_ENTRY	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
entry	pointer
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
entry	pointer
)	O
;	O
PUT_AOUTHDR_TEXT_START	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
text_start	long
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
text_start	long
)	O
;	O
PUT_AOUTHDR_DATA_START	O
(	O
abfd	pointer
,	O
aouthdr_in	pointer
->	O
data_start	long
,	O
aouthdr_out	pointer
->	O
standard	struct
.	O
data_start	long
)	O
;	O
PUT_OPTHDR_IMAGE_BASE	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
ImageBase	long
,	O
aouthdr_out	pointer
->	O
ImageBase	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SectionAlignment	int
,	O
aouthdr_out	pointer
->	O
SectionAlignment	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
FileAlignment	int
,	O
aouthdr_out	pointer
->	O
FileAlignment	int
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
MajorOperatingSystemVersion	short
,	O
aouthdr_out	pointer
->	O
MajorOperatingSystemVersion	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
MinorOperatingSystemVersion	short
,	O
aouthdr_out	pointer
->	O
MinorOperatingSystemVersion	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
MajorImageVersion	short
,	O
aouthdr_out	pointer
->	O
MajorImageVersion	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
MinorImageVersion	short
,	O
aouthdr_out	pointer
->	O
MinorImageVersion	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
MajorSubsystemVersion	short
,	O
aouthdr_out	pointer
->	O
MajorSubsystemVersion	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
MinorSubsystemVersion	short
,	O
aouthdr_out	pointer
->	O
MinorSubsystemVersion	short
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
Reserved1	int
,	O
aouthdr_out	pointer
->	O
Reserved1	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SizeOfImage	int
,	O
aouthdr_out	pointer
->	O
SizeOfImage	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SizeOfHeaders	int
,	O
aouthdr_out	pointer
->	O
SizeOfHeaders	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
CheckSum	int
,	O
aouthdr_out	pointer
->	O
CheckSum	int
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
Subsystem	short
,	O
aouthdr_out	pointer
->	O
Subsystem	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
DllCharacteristics	short
,	O
aouthdr_out	pointer
->	O
DllCharacteristics	short
)	O
;	O
PUT_OPTHDR_SIZE_OF_STACK_RESERVE	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SizeOfStackReserve	long
,	O
aouthdr_out	pointer
->	O
SizeOfStackReserve	long
)	O
;	O
PUT_OPTHDR_SIZE_OF_STACK_COMMIT	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SizeOfStackCommit	long
,	O
aouthdr_out	pointer
->	O
SizeOfStackCommit	long
)	O
;	O
PUT_OPTHDR_SIZE_OF_HEAP_RESERVE	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SizeOfHeapReserve	long
,	O
aouthdr_out	pointer
->	O
SizeOfHeapReserve	long
)	O
;	O
PUT_OPTHDR_SIZE_OF_HEAP_COMMIT	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
SizeOfHeapCommit	long
,	O
aouthdr_out	pointer
->	O
SizeOfHeapCommit	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
LoaderFlags	int
,	O
aouthdr_out	pointer
->	O
LoaderFlags	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
NumberOfRvaAndSizes	int
,	O
aouthdr_out	pointer
->	O
NumberOfRvaAndSizes	int
)	O
;	O
{	O
int	O
idx	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
IMAGE_NUMBEROF_DIRECTORY_ENTRIES	int
;	O
idx	int
++	O
)	O
{	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
VirtualAddress	long
,	O
aouthdr_out	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
[	O
0	int
]	O
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
extra	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
.	O
Size	long
,	O
aouthdr_out	pointer
->	O
DataDirectory	array
[	O
idx	int
]	O
[	O
1	int
]	O
)	O
;	O
}	O
}	O
return	O
AOUTSZ	O
;	O
}	O
unsigned	O
int	O
_bfd_pei_only_swap_filehdr_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
in	pointer
,	O
void	O
*	O
out	pointer
)	O
{	O
int	O
idx	int
;	O
struct	O
internal_filehdr	struct
*	O
filehdr_in	pointer
=	O
(	O
struct	O
internal_filehdr	struct
*	O
)	O
in	pointer
;	O
struct	O
external_PEI_filehdr	struct
*	O
filehdr_out	pointer
=	O
(	O
struct	O
external_PEI_filehdr	struct
*	O
)	O
out	pointer
;	O
if	O
(	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
has_reloc_section	int
||	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
dont_strip_reloc	int
)	O
filehdr_in	pointer
->	O
f_flags	short
&=	O
~	O
F_RELFLG	O
;	O
if	O
(	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
dll	int
)	O
filehdr_in	pointer
->	O
f_flags	short
|=	O
F_DLL	O
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_magic	short
=	O
IMAGE_DOS_SIGNATURE	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cblp	short
=	O
0x90	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cp	short
=	O
0x3	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_crlc	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cparhdr	short
=	O
0x4	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_minalloc	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_maxalloc	short
=	O
0xffff	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_ss	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_sp	short
=	O
0xb8	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_csum	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_ip	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cs	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_lfarlc	short
=	O
0x40	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_ovno	short
=	O
0x0	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
4	int
;	O
idx	int
++	O
)	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_res	array
[	O
idx	int
]	O
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_oemid	short
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_oeminfo	short
=	O
0x0	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
10	int
;	O
idx	int
++	O
)	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_res2	array
[	O
idx	int
]	O
=	O
0x0	int
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_lfanew	long
=	O
0x80	int
;	O
memcpy	function
(	O
filehdr_in	pointer
->	O
pe	struct
.	O
dos_message	array
,	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
dos_message	array
,	O
sizeof	O
(	O
filehdr_in	pointer
->	O
pe	struct
.	O
dos_message	array
)	O
)	O
;	O
filehdr_in	pointer
->	O
pe	struct
.	O
nt_signature	long
=	O
IMAGE_NT_SIGNATURE	int
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_magic	short
,	O
filehdr_out	pointer
->	O
f_magic	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_nscns	int
,	O
filehdr_out	pointer
->	O
f_nscns	int
)	O
;	O
if	O
(	O
(	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
insert_timestamp	int
)	O
)	O
H_PUT_32	O
(	O
abfd	pointer
,	O
time	struct
(	O
0	int
)	O
,	O
filehdr_out	pointer
->	O
f_timdat	long
)	O
;	O
else	O
H_PUT_32	O
(	O
abfd	pointer
,	O
0	int
,	O
filehdr_out	pointer
->	O
f_timdat	long
)	O
;	O
PUT_FILEHDR_SYMPTR	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_symptr	long
,	O
filehdr_out	pointer
->	O
f_symptr	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_nsyms	long
,	O
filehdr_out	pointer
->	O
f_nsyms	long
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_opthdr	short
,	O
filehdr_out	pointer
->	O
f_opthdr	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_flags	short
,	O
filehdr_out	pointer
->	O
f_flags	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_magic	short
,	O
filehdr_out	pointer
->	O
e_magic	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cblp	short
,	O
filehdr_out	pointer
->	O
e_cblp	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cp	short
,	O
filehdr_out	pointer
->	O
e_cp	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_crlc	short
,	O
filehdr_out	pointer
->	O
e_crlc	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cparhdr	short
,	O
filehdr_out	pointer
->	O
e_cparhdr	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_minalloc	short
,	O
filehdr_out	pointer
->	O
e_minalloc	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_maxalloc	short
,	O
filehdr_out	pointer
->	O
e_maxalloc	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_ss	short
,	O
filehdr_out	pointer
->	O
e_ss	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_sp	short
,	O
filehdr_out	pointer
->	O
e_sp	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_csum	short
,	O
filehdr_out	pointer
->	O
e_csum	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_ip	short
,	O
filehdr_out	pointer
->	O
e_ip	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_cs	short
,	O
filehdr_out	pointer
->	O
e_cs	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_lfarlc	short
,	O
filehdr_out	pointer
->	O
e_lfarlc	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_ovno	short
,	O
filehdr_out	pointer
->	O
e_ovno	short
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
4	int
;	O
idx	int
++	O
)	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_res	array
[	O
idx	int
]	O
,	O
filehdr_out	pointer
->	O
e_res	array
[	O
idx	int
]	O
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_oemid	short
,	O
filehdr_out	pointer
->	O
e_oemid	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_oeminfo	short
,	O
filehdr_out	pointer
->	O
e_oeminfo	short
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
10	int
;	O
idx	int
++	O
)	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_res2	array
[	O
idx	int
]	O
,	O
filehdr_out	pointer
->	O
e_res2	array
[	O
idx	int
]	O
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
e_lfanew	long
,	O
filehdr_out	pointer
->	O
e_lfanew	long
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
16	int
;	O
idx	int
++	O
)	O
H_PUT_32	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
dos_message	array
[	O
idx	int
]	O
,	O
filehdr_out	pointer
->	O
dos_message	array
[	O
idx	int
]	O
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
pe	struct
.	O
nt_signature	long
,	O
filehdr_out	pointer
->	O
nt_signature	long
)	O
;	O
return	O
FILHSZ	int
;	O
}	O
unsigned	O
int	O
_bfd_pe_only_swap_filehdr_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
in	pointer
,	O
void	O
*	O
out	pointer
)	O
{	O
struct	O
internal_filehdr	struct
*	O
filehdr_in	pointer
=	O
(	O
struct	O
internal_filehdr	struct
*	O
)	O
in	pointer
;	O
FILHDR	O
*	O
filehdr_out	pointer
=	O
(	O
FILHDR	O
*	O
)	O
out	pointer
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_magic	short
,	O
filehdr_out	pointer
->	O
f_magic	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_nscns	int
,	O
filehdr_out	pointer
->	O
f_nscns	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_timdat	long
,	O
filehdr_out	pointer
->	O
f_timdat	long
)	O
;	O
PUT_FILEHDR_SYMPTR	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_symptr	long
,	O
filehdr_out	pointer
->	O
f_symptr	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_nsyms	long
,	O
filehdr_out	pointer
->	O
f_nsyms	long
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_opthdr	short
,	O
filehdr_out	pointer
->	O
f_opthdr	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
filehdr_in	pointer
->	O
f_flags	short
,	O
filehdr_out	pointer
->	O
f_flags	short
)	O
;	O
return	O
FILHSZ	int
;	O
}	O
unsigned	O
int	O
_bfd_pei_swap_scnhdr_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
in	pointer
,	O
void	O
*	O
out	pointer
)	O
{	O
struct	O
internal_scnhdr	struct
*	O
scnhdr_int	pointer
=	O
(	O
struct	O
internal_scnhdr	struct
*	O
)	O
in	pointer
;	O
SCNHDR	O
*	O
scnhdr_ext	pointer
=	O
(	O
SCNHDR	O
*	O
)	O
out	pointer
;	O
unsigned	O
int	O
ret	pointer
=	O
SCNHSZ	int
;	O
bfd_vma	long
ps	long
;	O
bfd_vma	long
ss	long
;	O
memcpy	function
(	O
scnhdr_ext	pointer
->	O
s_name	array
,	O
scnhdr_int	pointer
->	O
s_name	array
,	O
sizeof	O
(	O
scnhdr_int	pointer
->	O
s_name	array
)	O
)	O
;	O
PUT_SCNHDR_VADDR	O
(	O
abfd	pointer
,	O
(	O
(	O
scnhdr_int	pointer
->	O
s_vaddr	long
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
)	O
&	O
0xffffffff	int
)	O
,	O
scnhdr_ext	pointer
->	O
s_vaddr	long
)	O
;	O
if	O
(	O
(	O
scnhdr_int	pointer
->	O
s_flags	long
&	O
IMAGE_SCN_CNT_UNINITIALIZED_DATA	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
bfd_pei_p	O
(	O
abfd	pointer
)	O
)	O
{	O
ps	long
=	O
scnhdr_int	pointer
->	O
s_size	long
;	O
ss	long
=	O
0	int
;	O
}	O
else	O
{	O
ps	long
=	O
0	int
;	O
ss	long
=	O
scnhdr_int	pointer
->	O
s_size	long
;	O
}	O
}	O
else	O
{	O
if	O
(	O
bfd_pei_p	O
(	O
abfd	pointer
)	O
)	O
ps	long
=	O
scnhdr_int	pointer
->	O
s_paddr	long
;	O
else	O
ps	long
=	O
0	int
;	O
ss	long
=	O
scnhdr_int	pointer
->	O
s_size	long
;	O
}	O
PUT_SCNHDR_SIZE	O
(	O
abfd	pointer
,	O
ss	long
,	O
scnhdr_ext	pointer
->	O
s_size	long
)	O
;	O
PUT_SCNHDR_PADDR	O
(	O
abfd	pointer
,	O
ps	long
,	O
scnhdr_ext	pointer
->	O
s_paddr	long
)	O
;	O
PUT_SCNHDR_SCNPTR	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_scnptr	long
,	O
scnhdr_ext	pointer
->	O
s_scnptr	long
)	O
;	O
PUT_SCNHDR_RELPTR	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_relptr	long
,	O
scnhdr_ext	pointer
->	O
s_relptr	long
)	O
;	O
PUT_SCNHDR_LNNOPTR	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_lnnoptr	long
,	O
scnhdr_ext	pointer
->	O
s_lnnoptr	long
)	O
;	O
{	O
typedef	O
struct	O
{	O
char	O
section_name	array
[	O
SCNNMLEN	O
]	O
;	O
unsigned	O
long	O
must_have	long
;	O
}	O
pe_required_section_flags	struct
;	O
pe_required_section_flags	struct
known_sections	array
[	O
]	O
=	O
{	O
{	O
".arch"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_DISCARDABLE	int
|	O
IMAGE_SCN_ALIGN_8BYTES	O
}	O
,	O
{	O
".bss"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_UNINITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_WRITE	int
}	O
,	O
{	O
".data"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_WRITE	int
}	O
,	O
{	O
".edata"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
}	O
,	O
{	O
".idata"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_WRITE	int
}	O
,	O
{	O
".pdata"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
}	O
,	O
{	O
".rdata"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
}	O
,	O
{	O
".reloc"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_DISCARDABLE	int
}	O
,	O
{	O
".rsrc"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_WRITE	int
}	O
,	O
{	O
".text"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_CODE	int
|	O
IMAGE_SCN_MEM_EXECUTE	int
}	O
,	O
{	O
".tls"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
|	O
IMAGE_SCN_MEM_WRITE	int
}	O
,	O
{	O
".xdata"	pointer
,	O
IMAGE_SCN_MEM_READ	int
|	O
IMAGE_SCN_CNT_INITIALIZED_DATA	int
}	O
,	O
}	O
;	O
pe_required_section_flags	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
known_sections	array
;	O
p	pointer
<	O
known_sections	array
+	O
ARRAY_SIZE	O
(	O
known_sections	array
)	O
;	O
p	pointer
++	O
)	O
if	O
(	O
memcmp	function
(	O
scnhdr_int	pointer
->	O
s_name	array
,	O
p	pointer
->	O
section_name	array
,	O
SCNNMLEN	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
scnhdr_int	pointer
->	O
s_name	array
,	O
".text"	pointer
,	O
sizeof	O
".text"	pointer
)	O
||	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
WP_TEXT	int
)	O
)	O
scnhdr_int	pointer
->	O
s_flags	long
&=	O
~	O
IMAGE_SCN_MEM_WRITE	int
;	O
scnhdr_int	pointer
->	O
s_flags	long
|=	O
p	pointer
->	O
must_have	long
;	O
break	O
;	O
}	O
H_PUT_32	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_flags	long
,	O
scnhdr_ext	pointer
->	O
s_flags	long
)	O
;	O
}	O
if	O
(	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
link_info	pointer
&&	O
!	O
bfd_link_relocatable	O
(	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
link_info	pointer
)	O
&&	O
!	O
bfd_link_pic	O
(	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
link_info	pointer
)	O
&&	O
memcmp	function
(	O
scnhdr_int	pointer
->	O
s_name	array
,	O
".text"	pointer
,	O
sizeof	O
".text"	pointer
)	O
==	O
0	int
)	O
{	O
H_PUT_16	O
(	O
abfd	pointer
,	O
(	O
scnhdr_int	pointer
->	O
s_nlnno	long
&	O
0xffff	int
)	O
,	O
scnhdr_ext	pointer
->	O
s_nlnno	long
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
(	O
scnhdr_int	pointer
->	O
s_nlnno	long
>>	O
16	int
)	O
,	O
scnhdr_ext	pointer
->	O
s_nreloc	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
scnhdr_int	pointer
->	O
s_nlnno	long
<=	O
0xffff	int
)	O
H_PUT_16	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_nlnno	long
,	O
scnhdr_ext	pointer
->	O
s_nlnno	long
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: line number overflow: 0x%lx > 0xffff"	pointer
)	O
,	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_nlnno	long
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
0xffff	int
,	O
scnhdr_ext	pointer
->	O
s_nlnno	long
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
if	O
(	O
scnhdr_int	pointer
->	O
s_nreloc	long
<	O
0xffff	int
)	O
H_PUT_16	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_nreloc	long
,	O
scnhdr_ext	pointer
->	O
s_nreloc	long
)	O
;	O
else	O
{	O
H_PUT_16	O
(	O
abfd	pointer
,	O
0xffff	int
,	O
scnhdr_ext	pointer
->	O
s_nreloc	long
)	O
;	O
scnhdr_int	pointer
->	O
s_flags	long
|=	O
IMAGE_SCN_LNK_NRELOC_OVFL	int
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
scnhdr_int	pointer
->	O
s_flags	long
,	O
scnhdr_ext	pointer
->	O
s_flags	long
)	O
;	O
}	O
}	O
return	O
ret	pointer
;	O
}	O
void	O
_bfd_pei_swap_debugdir_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
ext1	pointer
,	O
void	O
*	O
in1	pointer
)	O
{	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
ext	pointer
=	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
)	O
ext1	pointer
;	O
struct	O
internal_IMAGE_DEBUG_DIRECTORY	struct
*	O
in	pointer
=	O
(	O
struct	O
internal_IMAGE_DEBUG_DIRECTORY	struct
*	O
)	O
in1	pointer
;	O
in	pointer
->	O
Characteristics	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
Characteristics	long
)	O
;	O
in	pointer
->	O
TimeDateStamp	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
TimeDateStamp	long
)	O
;	O
in	pointer
->	O
MajorVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
MajorVersion	short
)	O
;	O
in	pointer
->	O
MinorVersion	short
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
MinorVersion	short
)	O
;	O
in	pointer
->	O
Type	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
Type	long
)	O
;	O
in	pointer
->	O
SizeOfData	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
SizeOfData	long
)	O
;	O
in	pointer
->	O
AddressOfRawData	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
AddressOfRawData	long
)	O
;	O
in	pointer
->	O
PointerToRawData	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
ext	pointer
->	O
PointerToRawData	long
)	O
;	O
}	O
unsigned	O
int	O
_bfd_pei_swap_debugdir_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
inp	pointer
,	O
void	O
*	O
extp	pointer
)	O
{	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
ext	pointer
=	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
)	O
extp	pointer
;	O
struct	O
internal_IMAGE_DEBUG_DIRECTORY	struct
*	O
in	pointer
=	O
(	O
struct	O
internal_IMAGE_DEBUG_DIRECTORY	struct
*	O
)	O
inp	pointer
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
Characteristics	long
,	O
ext	pointer
->	O
Characteristics	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
TimeDateStamp	long
,	O
ext	pointer
->	O
TimeDateStamp	long
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
MajorVersion	short
,	O
ext	pointer
->	O
MajorVersion	short
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
in	pointer
->	O
MinorVersion	short
,	O
ext	pointer
->	O
MinorVersion	short
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
Type	long
,	O
ext	pointer
->	O
Type	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
SizeOfData	long
,	O
ext	pointer
->	O
SizeOfData	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
AddressOfRawData	long
,	O
ext	pointer
->	O
AddressOfRawData	long
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
in	pointer
->	O
PointerToRawData	long
,	O
ext	pointer
->	O
PointerToRawData	long
)	O
;	O
return	O
sizeof	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
)	O
;	O
}	O
CODEVIEW_INFO	struct
*	O
_bfd_pei_slurp_codeview_record	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
file_ptr	long
where	long
,	O
unsigned	O
long	O
length	long
,	O
CODEVIEW_INFO	struct
*	O
cvinfo	pointer
)	O
{	O
char	O
buffer	pointer
[	O
256	int
+	O
1	int
]	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
where	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
bfd_bread	function
(	O
buffer	pointer
,	O
256	int
,	O
abfd	pointer
)	O
<	O
4	int
)	O
return	O
NULL	O
;	O
buffer	pointer
[	O
256	int
]	O
=	O
'\0'	O
;	O
cvinfo	pointer
->	O
CVSignature	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
buffer	pointer
)	O
;	O
cvinfo	pointer
->	O
Age	long
=	O
0	int
;	O
if	O
(	O
(	O
cvinfo	pointer
->	O
CVSignature	long
==	O
CVINFO_PDB70_CVSIGNATURE	int
)	O
&&	O
(	O
length	long
>	O
sizeof	O
(	O
CV_INFO_PDB70	struct
)	O
)	O
)	O
{	O
CV_INFO_PDB70	struct
*	O
cvinfo70	pointer
=	O
(	O
CV_INFO_PDB70	struct
*	O
)	O
(	O
buffer	pointer
)	O
;	O
cvinfo	pointer
->	O
Age	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
cvinfo70	pointer
->	O
Age	long
)	O
;	O
bfd_putb32	function
(	O
bfd_getl32	function
(	O
cvinfo70	pointer
->	O
Signature	array
)	O
,	O
cvinfo	pointer
->	O
Signature	array
)	O
;	O
bfd_putb16	function
(	O
bfd_getl16	function
(	O
&	O
(	O
cvinfo70	pointer
->	O
Signature	array
[	O
4	int
]	O
)	O
)	O
,	O
&	O
(	O
cvinfo	pointer
->	O
Signature	array
[	O
4	int
]	O
)	O
)	O
;	O
bfd_putb16	function
(	O
bfd_getl16	function
(	O
&	O
(	O
cvinfo70	pointer
->	O
Signature	array
[	O
6	int
]	O
)	O
)	O
,	O
&	O
(	O
cvinfo	pointer
->	O
Signature	array
[	O
6	int
]	O
)	O
)	O
;	O
memcpy	function
(	O
&	O
(	O
cvinfo	pointer
->	O
Signature	array
[	O
8	int
]	O
)	O
,	O
&	O
(	O
cvinfo70	pointer
->	O
Signature	array
[	O
8	int
]	O
)	O
,	O
8	int
)	O
;	O
cvinfo	pointer
->	O
SignatureLength	int
=	O
CV_INFO_SIGNATURE_LENGTH	int
;	O
return	O
cvinfo	pointer
;	O
}	O
else	O
if	O
(	O
(	O
cvinfo	pointer
->	O
CVSignature	long
==	O
CVINFO_PDB20_CVSIGNATURE	int
)	O
&&	O
(	O
length	long
>	O
sizeof	O
(	O
CV_INFO_PDB20	struct
)	O
)	O
)	O
{	O
CV_INFO_PDB20	struct
*	O
cvinfo20	pointer
=	O
(	O
CV_INFO_PDB20	struct
*	O
)	O
(	O
buffer	pointer
)	O
;	O
cvinfo	pointer
->	O
Age	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
cvinfo20	pointer
->	O
Age	long
)	O
;	O
memcpy	function
(	O
cvinfo	pointer
->	O
Signature	array
,	O
cvinfo20	pointer
->	O
Signature	array
,	O
4	int
)	O
;	O
cvinfo	pointer
->	O
SignatureLength	int
=	O
4	int
;	O
return	O
cvinfo	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
unsigned	O
int	O
_bfd_pei_write_codeview_record	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
file_ptr	long
where	long
,	O
CODEVIEW_INFO	struct
*	O
cvinfo	pointer
)	O
{	O
const	O
bfd_size_type	long
size	long
=	O
sizeof	O
(	O
CV_INFO_PDB70	struct
)	O
+	O
1	int
;	O
bfd_size_type	long
written	long
;	O
CV_INFO_PDB70	struct
*	O
cvinfo70	pointer
;	O
char	O
*	O
buffer	pointer
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
where	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
buffer	pointer
=	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
cvinfo70	pointer
=	O
(	O
CV_INFO_PDB70	struct
*	O
)	O
buffer	pointer
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
CVINFO_PDB70_CVSIGNATURE	int
,	O
cvinfo70	pointer
->	O
CvSignature	array
)	O
;	O
bfd_putl32	function
(	O
bfd_getb32	function
(	O
cvinfo	pointer
->	O
Signature	array
)	O
,	O
cvinfo70	pointer
->	O
Signature	array
)	O
;	O
bfd_putl16	function
(	O
bfd_getb16	function
(	O
&	O
(	O
cvinfo	pointer
->	O
Signature	array
[	O
4	int
]	O
)	O
)	O
,	O
&	O
(	O
cvinfo70	pointer
->	O
Signature	array
[	O
4	int
]	O
)	O
)	O
;	O
bfd_putl16	function
(	O
bfd_getb16	function
(	O
&	O
(	O
cvinfo	pointer
->	O
Signature	array
[	O
6	int
]	O
)	O
)	O
,	O
&	O
(	O
cvinfo70	pointer
->	O
Signature	array
[	O
6	int
]	O
)	O
)	O
;	O
memcpy	function
(	O
&	O
(	O
cvinfo70	pointer
->	O
Signature	array
[	O
8	int
]	O
)	O
,	O
&	O
(	O
cvinfo	pointer
->	O
Signature	array
[	O
8	int
]	O
)	O
,	O
8	int
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
cvinfo	pointer
->	O
Age	long
,	O
cvinfo70	pointer
->	O
Age	long
)	O
;	O
cvinfo70	pointer
->	O
PdbFileName	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
written	long
=	O
bfd_bwrite	function
(	O
buffer	pointer
,	O
size	long
,	O
abfd	pointer
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
return	O
written	long
==	O
size	long
?	O
size	long
:	O
0	int
;	O
}	O
static	O
char	O
*	O
dir_names	array
[	O
IMAGE_NUMBEROF_DIRECTORY_ENTRIES	int
]	O
=	O
{	O
N_	O
(	O
"Export Directory [.edata (or where ever we found it)]"	pointer
)	O
,	O
N_	O
(	O
"Import Directory [parts of .idata]"	pointer
)	O
,	O
N_	O
(	O
"Resource Directory [.rsrc]"	pointer
)	O
,	O
N_	O
(	O
"Exception Directory [.pdata]"	pointer
)	O
,	O
N_	O
(	O
"Security Directory"	pointer
)	O
,	O
N_	O
(	O
"Base Relocation Directory [.reloc]"	pointer
)	O
,	O
N_	O
(	O
"Debug Directory"	pointer
)	O
,	O
N_	O
(	O
"Description Directory"	pointer
)	O
,	O
N_	O
(	O
"Special Directory"	pointer
)	O
,	O
N_	O
(	O
"Thread Storage Directory [.tls]"	pointer
)	O
,	O
N_	O
(	O
"Load Configuration Directory"	pointer
)	O
,	O
N_	O
(	O
"Bound Import Directory"	pointer
)	O
,	O
N_	O
(	O
"Import Address Table Directory"	pointer
)	O
,	O
N_	O
(	O
"Delay Import Directory"	pointer
)	O
,	O
N_	O
(	O
"CLR Runtime Header"	pointer
)	O
,	O
N_	O
(	O
"Reserved"	pointer
)	O
}	O
;	O
static	O
bfd_boolean	int
pe_print_idata	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_byte	char
*	O
data	pointer
;	O
asection	struct
*	O
section	pointer
;	O
bfd_signed_vma	long
adj	long
;	O
bfd_size_type	long
datasize	long
=	O
0	int
;	O
bfd_size_type	long
dataoff	long
;	O
bfd_size_type	long
i	pointer
;	O
int	O
onaline	int
=	O
20	int
;	O
pe_data_type	struct
*	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
extra	pointer
=	O
&	O
pe	struct
->	O
pe_opthdr	struct
;	O
bfd_vma	long
addr	pointer
;	O
addr	pointer
=	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
.	O
VirtualAddress	long
;	O
if	O
(	O
addr	pointer
==	O
0	int
&&	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
.	O
Size	long
==	O
0	int
)	O
{	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".idata"	pointer
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
addr	pointer
=	O
section	pointer
->	O
vma	long
;	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
datasize	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
addr	pointer
+=	O
extra	pointer
->	O
ImageBase	long
;	O
for	O
(	O
section	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
addr	pointer
>=	O
section	pointer
->	O
vma	long
&&	O
addr	pointer
<	O
section	pointer
->	O
vma	long
+	O
datasize	long
)	O
break	O
;	O
}	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an import table, but the section containing it could not be found\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an import table in %s, but that section has no contents\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an import table in %s at 0x%lx\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
)	O
;	O
dataoff	long
=	O
addr	pointer
-	O
section	pointer
->	O
vma	long
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThe Import Tables (interpreted %s section contents)\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
" vma:            Hint    Time      Forward  DLL       First\n                 Table   Stamp     Chain    Name      Thunk\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
adj	long
=	O
section	pointer
->	O
vma	long
-	O
extra	pointer
->	O
ImageBase	long
;	O
for	O
(	O
i	pointer
=	O
dataoff	long
;	O
i	pointer
+	O
onaline	int
<=	O
datasize	long
;	O
i	pointer
+=	O
onaline	int
)	O
{	O
bfd_vma	long
hint_addr	long
;	O
bfd_vma	long
time_stamp	long
;	O
bfd_vma	long
forward_chain	long
;	O
bfd_vma	long
dll_name	long
;	O
bfd_vma	long
first_thunk	long
;	O
int	O
idx	int
=	O
0	int
;	O
bfd_size_type	long
j	long
;	O
char	O
*	O
dll	int
;	O
fprintf	function
(	O
file	pointer
,	O
" %08lx\t"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
i	pointer
+	O
adj	long
)	O
)	O
;	O
hint_addr	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
)	O
;	O
time_stamp	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
4	int
)	O
;	O
forward_chain	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
8	int
)	O
;	O
dll_name	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
12	int
)	O
;	O
first_thunk	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
16	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%08lx %08lx %08lx %08lx %08lx\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
hint_addr	long
,	O
(	O
unsigned	O
long	O
)	O
time_stamp	long
,	O
(	O
unsigned	O
long	O
)	O
forward_chain	long
,	O
(	O
unsigned	O
long	O
)	O
dll_name	long
,	O
(	O
unsigned	O
long	O
)	O
first_thunk	long
)	O
;	O
if	O
(	O
hint_addr	long
==	O
0	int
&&	O
first_thunk	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
dll_name	long
-	O
adj	long
>=	O
section	pointer
->	O
size	long
)	O
break	O
;	O
dll	int
=	O
(	O
char	O
*	O
)	O
data	pointer
+	O
dll_name	long
-	O
adj	long
;	O
bfd_size_type	long
maxlen	long
=	O
(	O
char	O
*	O
)	O
(	O
data	pointer
+	O
datasize	long
)	O
-	O
dll	int
-	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\n\tDLL Name: %.*s\n"	pointer
)	O
,	O
(	O
int	O
)	O
maxlen	long
,	O
dll	int
)	O
;	O
if	O
(	O
hint_addr	long
==	O
0	int
)	O
hint_addr	long
=	O
first_thunk	long
;	O
if	O
(	O
hint_addr	long
!=	O
0	int
&&	O
hint_addr	long
-	O
adj	long
<	O
datasize	long
)	O
{	O
bfd_byte	char
*	O
ft_data	pointer
;	O
asection	struct
*	O
ft_section	pointer
;	O
bfd_vma	long
ft_addr	long
;	O
bfd_size_type	long
ft_datasize	long
;	O
int	O
ft_idx	int
;	O
int	O
ft_allocated	int
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tvma:  Hint/Ord Member-Name Bound-To\n"	pointer
)	O
)	O
;	O
idx	int
=	O
hint_addr	long
-	O
adj	long
;	O
ft_addr	long
=	O
first_thunk	long
+	O
extra	pointer
->	O
ImageBase	long
;	O
ft_idx	int
=	O
first_thunk	long
-	O
adj	long
;	O
ft_data	pointer
=	O
data	pointer
+	O
ft_idx	int
;	O
ft_datasize	long
=	O
datasize	long
-	O
ft_idx	int
;	O
ft_allocated	int
=	O
0	int
;	O
if	O
(	O
first_thunk	long
!=	O
hint_addr	long
)	O
{	O
for	O
(	O
ft_section	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
ft_section	pointer
!=	O
NULL	O
;	O
ft_section	pointer
=	O
ft_section	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
ft_addr	long
>=	O
ft_section	pointer
->	O
vma	long
&&	O
ft_addr	long
<	O
ft_section	pointer
->	O
vma	long
+	O
ft_section	pointer
->	O
size	long
)	O
break	O
;	O
}	O
if	O
(	O
ft_section	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is a first thunk, but the section containing it could not be found\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ft_section	pointer
!=	O
section	pointer
)	O
{	O
ft_idx	int
=	O
first_thunk	long
-	O
(	O
ft_section	pointer
->	O
vma	long
-	O
extra	pointer
->	O
ImageBase	long
)	O
;	O
ft_datasize	long
=	O
ft_section	pointer
->	O
size	long
-	O
ft_idx	int
;	O
ft_data	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
ft_datasize	long
)	O
;	O
if	O
(	O
ft_data	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
ft_section	pointer
,	O
ft_data	pointer
,	O
(	O
bfd_vma	long
)	O
ft_idx	int
,	O
ft_datasize	long
)	O
)	O
{	O
free	function
(	O
ft_data	pointer
)	O
;	O
continue	O
;	O
}	O
ft_allocated	int
=	O
1	int
;	O
}	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
idx	int
+	O
j	long
+	O
4	int
<=	O
datasize	long
;	O
j	long
+=	O
4	int
)	O
{	O
bfd_size_type	long
amt	long
;	O
unsigned	O
long	O
member	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
idx	int
+	O
j	long
)	O
;	O
if	O
(	O
member	long
==	O
0	int
)	O
break	O
;	O
amt	long
=	O
member	long
-	O
adj	long
;	O
if	O
(	O
HighBitSet	O
(	O
member	long
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
"\t%04lx\t %4lu  <none>"	pointer
,	O
member	long
,	O
WithoutHighBit	O
(	O
member	long
)	O
)	O
;	O
else	O
if	O
(	O
amt	long
>=	O
datasize	long
||	O
amt	long
+	O
2	int
>=	O
datasize	long
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\t<corrupt: 0x%04lx>"	pointer
)	O
,	O
member	long
)	O
;	O
else	O
{	O
int	O
ordinal	int
;	O
char	O
*	O
member_name	pointer
;	O
ordinal	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
amt	long
)	O
;	O
member_name	pointer
=	O
(	O
char	O
*	O
)	O
data	pointer
+	O
amt	long
+	O
2	int
;	O
fprintf	function
(	O
file	pointer
,	O
"\t%04lx\t %4d  %.*s"	pointer
,	O
member	long
,	O
ordinal	int
,	O
(	O
int	O
)	O
(	O
datasize	long
-	O
(	O
amt	long
+	O
2	int
)	O
)	O
,	O
member_name	pointer
)	O
;	O
}	O
if	O
(	O
time_stamp	long
!=	O
0	int
&&	O
first_thunk	long
!=	O
0	int
&&	O
first_thunk	long
!=	O
hint_addr	long
&&	O
j	long
+	O
4	int
<=	O
ft_datasize	long
)	O
fprintf	function
(	O
file	pointer
,	O
"\t%04lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ft_data	pointer
+	O
j	long
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
ft_allocated	int
)	O
free	function
(	O
ft_data	pointer
)	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pe_print_edata	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_byte	char
*	O
data	pointer
;	O
asection	struct
*	O
section	pointer
;	O
bfd_size_type	long
datasize	long
=	O
0	int
;	O
bfd_size_type	long
dataoff	long
;	O
bfd_size_type	long
i	pointer
;	O
bfd_vma	long
adj	long
;	O
struct	O
EDT_type	struct
{	O
long	O
export_flags	long
;	O
long	O
time_stamp	long
;	O
short	O
major_ver	short
;	O
short	O
minor_ver	short
;	O
bfd_vma	long
name	pointer
;	O
long	O
base	int
;	O
unsigned	O
long	O
num_functions	long
;	O
unsigned	O
long	O
num_names	long
;	O
bfd_vma	long
eat_addr	long
;	O
bfd_vma	long
npt_addr	long
;	O
bfd_vma	long
ot_addr	long
;	O
}	O
edt	struct
;	O
pe_data_type	struct
*	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
extra	pointer
=	O
&	O
pe	struct
->	O
pe_opthdr	struct
;	O
bfd_vma	long
addr	pointer
;	O
addr	pointer
=	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_EXPORT_TABLE	int
]	O
.	O
VirtualAddress	long
;	O
if	O
(	O
addr	pointer
==	O
0	int
&&	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_EXPORT_TABLE	int
]	O
.	O
Size	long
==	O
0	int
)	O
{	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".edata"	pointer
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
addr	pointer
=	O
section	pointer
->	O
vma	long
;	O
dataoff	long
=	O
0	int
;	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
datasize	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
addr	pointer
+=	O
extra	pointer
->	O
ImageBase	long
;	O
for	O
(	O
section	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
if	O
(	O
addr	pointer
>=	O
section	pointer
->	O
vma	long
&&	O
addr	pointer
<	O
section	pointer
->	O
vma	long
+	O
section	pointer
->	O
size	long
)	O
break	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an export table, but the section containing it could not be found\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an export table in %s, but that section has no contents\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
dataoff	long
=	O
addr	pointer
-	O
section	pointer
->	O
vma	long
;	O
datasize	long
=	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_EXPORT_TABLE	int
]	O
.	O
Size	long
;	O
if	O
(	O
dataoff	long
>	O
section	pointer
->	O
size	long
||	O
datasize	long
>	O
section	pointer
->	O
size	long
-	O
dataoff	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an export table in %s, but it does not fit into that section\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
datasize	long
<	O
40	int
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an export table in %s, but it is too small (%d)\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
int	O
)	O
datasize	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is an export table in %s at 0x%lx\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
)	O
;	O
data	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
datasize	long
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
section	pointer
,	O
data	pointer
,	O
(	O
file_ptr	long
)	O
dataoff	long
,	O
datasize	long
)	O
)	O
return	O
FALSE	int
;	O
edt	struct
.	O
export_flags	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
0	int
)	O
;	O
edt	struct
.	O
time_stamp	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
;	O
edt	struct
.	O
major_ver	short
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
8	int
)	O
;	O
edt	struct
.	O
minor_ver	short
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
10	int
)	O
;	O
edt	struct
.	O
name	pointer
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
12	int
)	O
;	O
edt	struct
.	O
base	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
16	int
)	O
;	O
edt	struct
.	O
num_functions	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
20	int
)	O
;	O
edt	struct
.	O
num_names	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
24	int
)	O
;	O
edt	struct
.	O
eat_addr	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
28	int
)	O
;	O
edt	struct
.	O
npt_addr	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
32	int
)	O
;	O
edt	struct
.	O
ot_addr	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
36	int
)	O
;	O
adj	long
=	O
section	pointer
->	O
vma	long
-	O
extra	pointer
->	O
ImageBase	long
+	O
dataoff	long
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThe Export Tables (interpreted %s section contents)\n\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Export Flags \t\t\t%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
edt	struct
.	O
export_flags	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Time/Date stamp \t\t%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
edt	struct
.	O
time_stamp	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Major/Minor \t\t\t%d/%d\n"	pointer
)	O
,	O
edt	struct
.	O
major_ver	short
,	O
edt	struct
.	O
minor_ver	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Name \t\t\t\t"	pointer
)	O
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
edt	struct
.	O
name	pointer
)	O
;	O
if	O
(	O
(	O
edt	struct
.	O
name	pointer
>=	O
adj	long
)	O
&&	O
(	O
edt	struct
.	O
name	pointer
<	O
adj	long
+	O
datasize	long
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" %.*s\n"	pointer
,	O
(	O
int	O
)	O
(	O
datasize	long
-	O
(	O
edt	struct
.	O
name	pointer
-	O
adj	long
)	O
)	O
,	O
data	pointer
+	O
edt	struct
.	O
name	pointer
-	O
adj	long
)	O
;	O
else	O
fprintf	function
(	O
file	pointer
,	O
"(outside .edata section)\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Ordinal Base \t\t\t%ld\n"	pointer
)	O
,	O
edt	struct
.	O
base	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Number in:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tExport Address Table \t\t%08lx\n"	pointer
)	O
,	O
edt	struct
.	O
num_functions	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\t[Name Pointer/Ordinal] Table\t%08lx\n"	pointer
)	O
,	O
edt	struct
.	O
num_names	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Table Addresses\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tExport Address Table \t\t"	pointer
)	O
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
edt	struct
.	O
eat_addr	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tName Pointer Table \t\t"	pointer
)	O
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
edt	struct
.	O
npt_addr	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tOrdinal Table \t\t\t"	pointer
)	O
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
edt	struct
.	O
ot_addr	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nExport Address Table -- Ordinal Base %ld\n"	pointer
)	O
,	O
edt	struct
.	O
base	int
)	O
;	O
if	O
(	O
edt	struct
.	O
eat_addr	long
-	O
adj	long
>=	O
datasize	long
||	O
(	O
edt	struct
.	O
num_functions	long
+	O
1	int
)	O
*	O
4	int
<	O
edt	struct
.	O
num_functions	long
||	O
edt	struct
.	O
eat_addr	long
-	O
adj	long
+	O
(	O
edt	struct
.	O
num_functions	long
+	O
1	int
)	O
*	O
4	int
>	O
datasize	long
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"	pointer
)	O
,	O
(	O
long	O
)	O
edt	struct
.	O
eat_addr	long
,	O
(	O
long	O
)	O
edt	struct
.	O
num_functions	long
)	O
;	O
else	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
edt	struct
.	O
num_functions	long
;	O
++	O
i	pointer
)	O
{	O
bfd_vma	long
eat_member	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
edt	struct
.	O
eat_addr	long
+	O
(	O
i	pointer
*	O
4	int
)	O
-	O
adj	long
)	O
;	O
if	O
(	O
eat_member	long
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
eat_member	long
-	O
adj	long
<=	O
datasize	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n"	pointer
,	O
(	O
long	O
)	O
i	pointer
,	O
(	O
long	O
)	O
(	O
i	pointer
+	O
edt	struct
.	O
base	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
eat_member	long
,	O
_	O
(	O
"Forwarder RVA"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
datasize	long
-	O
(	O
eat_member	long
-	O
adj	long
)	O
)	O
,	O
data	pointer
+	O
eat_member	long
-	O
adj	long
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
file	pointer
,	O
"\t[%4ld] +base[%4ld] %04lx %s\n"	pointer
,	O
(	O
long	O
)	O
i	pointer
,	O
(	O
long	O
)	O
(	O
i	pointer
+	O
edt	struct
.	O
base	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
eat_member	long
,	O
_	O
(	O
"Export RVA"	pointer
)	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\n[Ordinal/Name Pointer] Table\n"	pointer
)	O
)	O
;	O
if	O
(	O
edt	struct
.	O
npt_addr	long
+	O
(	O
edt	struct
.	O
num_names	long
*	O
4	int
)	O
-	O
adj	long
>=	O
datasize	long
||	O
edt	struct
.	O
num_names	long
*	O
4	int
<	O
edt	struct
.	O
num_names	long
||	O
(	O
data	pointer
+	O
edt	struct
.	O
npt_addr	long
-	O
adj	long
)	O
<	O
data	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"	pointer
)	O
,	O
(	O
long	O
)	O
edt	struct
.	O
npt_addr	long
,	O
(	O
long	O
)	O
edt	struct
.	O
num_names	long
)	O
;	O
else	O
if	O
(	O
edt	struct
.	O
ot_addr	long
+	O
(	O
edt	struct
.	O
num_names	long
*	O
2	int
)	O
-	O
adj	long
>=	O
datasize	long
||	O
data	pointer
+	O
edt	struct
.	O
ot_addr	long
-	O
adj	long
<	O
data	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"	pointer
)	O
,	O
(	O
long	O
)	O
edt	struct
.	O
ot_addr	long
,	O
(	O
long	O
)	O
edt	struct
.	O
num_names	long
)	O
;	O
else	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
edt	struct
.	O
num_names	long
;	O
++	O
i	pointer
)	O
{	O
bfd_vma	long
name_ptr	long
;	O
bfd_vma	long
ord	long
;	O
ord	long
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
edt	struct
.	O
ot_addr	long
+	O
(	O
i	pointer
*	O
2	int
)	O
-	O
adj	long
)	O
;	O
name_ptr	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
edt	struct
.	O
npt_addr	long
+	O
(	O
i	pointer
*	O
4	int
)	O
-	O
adj	long
)	O
;	O
if	O
(	O
(	O
name_ptr	long
-	O
adj	long
)	O
>=	O
datasize	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\t[%4ld] <corrupt offset: %lx>\n"	pointer
)	O
,	O
(	O
long	O
)	O
ord	long
,	O
(	O
long	O
)	O
name_ptr	long
)	O
;	O
}	O
else	O
{	O
char	O
*	O
name	pointer
=	O
(	O
char	O
*	O
)	O
data	pointer
+	O
name_ptr	long
-	O
adj	long
;	O
fprintf	function
(	O
file	pointer
,	O
"\t[%4ld] %.*s\n"	pointer
,	O
(	O
long	O
)	O
ord	long
,	O
(	O
int	O
)	O
(	O
(	O
char	O
*	O
)	O
(	O
data	pointer
+	O
datasize	long
)	O
-	O
name	pointer
)	O
,	O
name	pointer
)	O
;	O
}	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pe_print_pdata	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_byte	char
*	O
data	pointer
=	O
0	int
;	O
asection	struct
*	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".pdata"	pointer
)	O
;	O
bfd_size_type	long
datasize	long
=	O
0	int
;	O
bfd_size_type	long
i	pointer
;	O
bfd_size_type	long
start	long
,	O
stop	long
;	O
int	O
onaline	int
=	O
PDATA_ROW_SIZE	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
||	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
==	O
NULL	O
||	O
pei_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
stop	long
=	O
pei_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
->	O
virt_size	long
;	O
if	O
(	O
(	O
stop	long
%	O
onaline	int
)	O
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning, .pdata section size (%ld) is not a multiple of %d\n"	pointer
)	O
,	O
(	O
long	O
)	O
stop	long
,	O
onaline	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThe Function Table (interpreted .pdata section contents)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
" vma:\t\tBegin    End      EH       EH       PrologEnd  Exception\n     \t\tAddress  Address  Handler  Data     Address    Mask\n"	pointer
)	O
)	O
;	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
datasize	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
datasize	long
<	O
stop	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Virtual size of .pdata section (%ld) larger than real size (%ld)\n"	pointer
)	O
,	O
(	O
long	O
)	O
stop	long
,	O
(	O
long	O
)	O
datasize	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
start	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
start	long
;	O
i	pointer
<	O
stop	long
;	O
i	pointer
+=	O
onaline	int
)	O
{	O
bfd_vma	long
begin_addr	long
;	O
bfd_vma	long
end_addr	long
;	O
bfd_vma	long
eh_handler	long
;	O
bfd_vma	long
eh_data	long
;	O
bfd_vma	long
prolog_end_addr	long
;	O
int	O
em_data	int
;	O
if	O
(	O
i	pointer
+	O
PDATA_ROW_SIZE	O
>	O
stop	long
)	O
break	O
;	O
begin_addr	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
)	O
;	O
end_addr	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
4	int
)	O
;	O
eh_handler	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
8	int
)	O
;	O
eh_data	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
12	int
)	O
;	O
prolog_end_addr	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
16	int
)	O
;	O
if	O
(	O
begin_addr	long
==	O
0	int
&&	O
end_addr	long
==	O
0	int
&&	O
eh_handler	long
==	O
0	int
&&	O
eh_data	long
==	O
0	int
&&	O
prolog_end_addr	long
==	O
0	int
)	O
break	O
;	O
em_data	int
=	O
(	O
(	O
eh_handler	long
&	O
0x1	int
)	O
<<	O
2	int
)	O
|	O
(	O
prolog_end_addr	long
&	O
0x3	int
)	O
;	O
eh_handler	long
&=	O
~	O
(	O
bfd_vma	long
)	O
0x3	int
;	O
prolog_end_addr	long
&=	O
~	O
(	O
bfd_vma	long
)	O
0x3	int
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
+	O
section	pointer
->	O
vma	long
)	O
;	O
fputc	function
(	O
'\t'	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
begin_addr	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
end_addr	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
eh_handler	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
eh_data	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
prolog_end_addr	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"   %x"	pointer
,	O
em_data	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
typedef	O
struct	O
sym_cache	struct
{	O
int	O
symcount	int
;	O
asymbol	struct
*	O
*	O
syms	pointer
;	O
}	O
sym_cache	struct
;	O
static	O
asymbol	struct
*	O
*	O
slurp_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sym_cache	struct
*	O
psc	pointer
)	O
{	O
asymbol	struct
*	O
*	O
sy	pointer
=	O
NULL	O
;	O
long	O
storage	long
;	O
if	O
(	O
!	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
HAS_SYMS	int
)	O
)	O
{	O
psc	pointer
->	O
symcount	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
storage	long
=	O
bfd_get_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
storage	long
<	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
storage	long
)	O
{	O
sy	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
storage	long
)	O
;	O
if	O
(	O
sy	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
psc	pointer
->	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
abfd	pointer
,	O
sy	pointer
)	O
;	O
if	O
(	O
psc	pointer
->	O
symcount	int
<	O
0	int
)	O
return	O
NULL	O
;	O
return	O
sy	pointer
;	O
}	O
static	O
const	O
char	O
*	O
my_symbol_for_address	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
func	pointer
,	O
sym_cache	struct
*	O
psc	pointer
)	O
{	O
int	O
i	pointer
;	O
if	O
(	O
psc	pointer
->	O
syms	pointer
==	O
0	int
)	O
psc	pointer
->	O
syms	pointer
=	O
slurp_symtab	function
(	O
abfd	pointer
,	O
psc	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
psc	pointer
->	O
symcount	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
psc	pointer
->	O
syms	pointer
[	O
i	pointer
]	O
->	O
section	pointer
->	O
vma	long
+	O
psc	pointer
->	O
syms	pointer
[	O
i	pointer
]	O
->	O
value	long
==	O
func	pointer
)	O
return	O
psc	pointer
->	O
syms	pointer
[	O
i	pointer
]	O
->	O
name	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
cleanup_syms	function
(	O
sym_cache	struct
*	O
psc	pointer
)	O
{	O
psc	pointer
->	O
symcount	int
=	O
0	int
;	O
free	function
(	O
psc	pointer
->	O
syms	pointer
)	O
;	O
psc	pointer
->	O
syms	pointer
=	O
NULL	O
;	O
}	O
bfd_boolean	int
_bfd_pe_print_ce_compressed_pdata	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_byte	char
*	O
data	pointer
=	O
NULL	O
;	O
asection	struct
*	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".pdata"	pointer
)	O
;	O
bfd_size_type	long
datasize	long
=	O
0	int
;	O
bfd_size_type	long
i	pointer
;	O
bfd_size_type	long
start	long
,	O
stop	long
;	O
int	O
onaline	int
=	O
PDATA_ROW_SIZE	O
;	O
struct	O
sym_cache	struct
cache	pointer
=	O
{	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
||	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
==	O
NULL	O
||	O
pei_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
stop	long
=	O
pei_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
->	O
virt_size	long
;	O
if	O
(	O
(	O
stop	long
%	O
onaline	int
)	O
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning, .pdata section size (%ld) is not a multiple of %d\n"	pointer
)	O
,	O
(	O
long	O
)	O
stop	long
,	O
onaline	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThe Function Table (interpreted .pdata section contents)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
" vma:\t\tBegin    Prolog   Function Flags    Exception EH\n     \t\tAddress  Length   Length   32b exc  Handler   Data\n"	pointer
)	O
)	O
;	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
datasize	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
start	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
start	long
;	O
i	pointer
<	O
stop	long
;	O
i	pointer
+=	O
onaline	int
)	O
{	O
bfd_vma	long
begin_addr	long
;	O
bfd_vma	long
other_data	long
;	O
bfd_vma	long
prolog_length	long
,	O
function_length	long
;	O
int	O
flag32bit	int
,	O
exception_flag	int
;	O
asection	struct
*	O
tsection	pointer
;	O
if	O
(	O
i	pointer
+	O
PDATA_ROW_SIZE	O
>	O
stop	long
)	O
break	O
;	O
begin_addr	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
)	O
;	O
other_data	long
=	O
GET_PDATA_ENTRY	O
(	O
abfd	pointer
,	O
data	pointer
+	O
i	pointer
+	O
4	int
)	O
;	O
if	O
(	O
begin_addr	long
==	O
0	int
&&	O
other_data	long
==	O
0	int
)	O
break	O
;	O
prolog_length	long
=	O
(	O
other_data	long
&	O
0x000000FF	int
)	O
;	O
function_length	long
=	O
(	O
other_data	long
&	O
0x3FFFFF00	int
)	O
>>	O
8	int
;	O
flag32bit	int
=	O
(	O
int	O
)	O
(	O
(	O
other_data	long
&	O
0x40000000	int
)	O
>>	O
30	int
)	O
;	O
exception_flag	int
=	O
(	O
int	O
)	O
(	O
(	O
other_data	long
&	O
0x80000000	int
)	O
>>	O
31	int
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
+	O
section	pointer
->	O
vma	long
)	O
;	O
fputc	function
(	O
'\t'	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
begin_addr	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
prolog_length	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
function_length	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%2d  %2d   "	pointer
,	O
flag32bit	int
,	O
exception_flag	int
)	O
;	O
tsection	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".text"	pointer
)	O
;	O
if	O
(	O
tsection	pointer
&&	O
coff_section_data	O
(	O
abfd	pointer
,	O
tsection	pointer
)	O
&&	O
pei_section_data	O
(	O
abfd	pointer
,	O
tsection	pointer
)	O
)	O
{	O
bfd_vma	long
eh_off	long
=	O
(	O
begin_addr	long
-	O
8	int
)	O
-	O
tsection	pointer
->	O
vma	long
;	O
bfd_byte	char
*	O
tdata	union
;	O
tdata	union
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
8	int
)	O
;	O
if	O
(	O
tdata	union
)	O
{	O
if	O
(	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
tsection	pointer
,	O
tdata	union
,	O
eh_off	long
,	O
8	int
)	O
)	O
{	O
bfd_vma	long
eh	long
,	O
eh_data	long
;	O
eh	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
tdata	union
)	O
;	O
eh_data	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
tdata	union
+	O
4	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%08x  "	pointer
,	O
(	O
unsigned	O
int	O
)	O
eh	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%08x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
eh_data	long
)	O
;	O
if	O
(	O
eh	long
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
my_symbol_for_address	function
(	O
abfd	pointer
,	O
eh	long
,	O
&	O
cache	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
" (%s) "	pointer
,	O
s	pointer
)	O
;	O
}	O
}	O
free	function
(	O
tdata	union
)	O
;	O
}	O
}	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
free	function
(	O
data	pointer
)	O
;	O
cleanup_syms	function
(	O
&	O
cache	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
const	O
tbl	array
[	O
]	O
=	O
{	O
"ABSOLUTE"	pointer
,	O
"HIGH"	pointer
,	O
"LOW"	pointer
,	O
"HIGHLOW"	pointer
,	O
"HIGHADJ"	pointer
,	O
"MIPS_JMPADDR"	pointer
,	O
"SECTION"	pointer
,	O
"REL32"	pointer
,	O
"RESERVED1"	pointer
,	O
"MIPS_JMPADDR16"	pointer
,	O
"DIR64"	pointer
,	O
"HIGH3ADJ"	pointer
,	O
"UNKNOWN"	pointer
,	O
}	O
;	O
static	O
bfd_boolean	int
pe_print_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_byte	char
*	O
data	pointer
=	O
0	int
;	O
asection	struct
*	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".reloc"	pointer
)	O
;	O
bfd_byte	char
*	O
p	pointer
,	O
*	O
end	pointer
;	O
if	O
(	O
section	pointer
==	O
NULL	O
||	O
section	pointer
->	O
size	long
==	O
0	int
||	O
!	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
return	O
TRUE	int
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\n\nPE File Base Relocations (interpreted .reloc section contents)\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
p	pointer
=	O
data	pointer
;	O
end	pointer
=	O
data	pointer
+	O
section	pointer
->	O
size	long
;	O
while	O
(	O
p	pointer
+	O
8	int
<=	O
end	pointer
)	O
{	O
int	O
j	long
;	O
bfd_vma	long
virtual_address	long
;	O
unsigned	O
long	O
number	long
,	O
size	long
;	O
bfd_byte	char
*	O
chunk_end	pointer
;	O
virtual_address	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
p	pointer
)	O
;	O
size	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
p	pointer
+	O
4	int
)	O
;	O
p	pointer
+=	O
8	int
;	O
number	long
=	O
(	O
size	long
-	O
8	int
)	O
/	O
2	int
;	O
if	O
(	O
size	long
==	O
0	int
)	O
break	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
virtual_address	long
,	O
size	long
,	O
size	long
,	O
number	long
)	O
;	O
chunk_end	pointer
=	O
p	pointer
-	O
8	int
+	O
size	long
;	O
if	O
(	O
chunk_end	pointer
>	O
end	pointer
)	O
chunk_end	pointer
=	O
end	pointer
;	O
j	long
=	O
0	int
;	O
while	O
(	O
p	pointer
+	O
2	int
<=	O
chunk_end	pointer
)	O
{	O
unsigned	O
short	O
e	struct
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
p	pointer
)	O
;	O
unsigned	O
int	O
t	int
=	O
(	O
e	struct
&	O
0xF000	int
)	O
>>	O
12	int
;	O
int	O
off	int
=	O
e	struct
&	O
0x0FFF	int
;	O
if	O
(	O
t	int
>=	O
sizeof	O
(	O
tbl	array
)	O
/	O
sizeof	O
(	O
tbl	array
[	O
0	int
]	O
)	O
)	O
t	int
=	O
(	O
sizeof	O
(	O
tbl	array
)	O
/	O
sizeof	O
(	O
tbl	array
[	O
0	int
]	O
)	O
)	O
-	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\treloc %4d offset %4x [%4lx] %s"	pointer
)	O
,	O
j	long
,	O
off	int
,	O
(	O
unsigned	O
long	O
)	O
(	O
off	int
+	O
virtual_address	long
)	O
,	O
tbl	array
[	O
t	int
]	O
)	O
;	O
p	pointer
+=	O
2	int
;	O
j	long
++	O
;	O
if	O
(	O
t	int
==	O
IMAGE_REL_BASED_HIGHADJ	int
&&	O
p	pointer
+	O
2	int
<=	O
chunk_end	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
" (%4x)"	pointer
,	O
(	O
unsigned	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
p	pointer
)	O
)	O
;	O
p	pointer
+=	O
2	int
;	O
j	long
++	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
free	function
(	O
data	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
typedef	O
struct	O
rsrc_regions	struct
{	O
bfd_byte	char
*	O
section_start	pointer
;	O
bfd_byte	char
*	O
section_end	pointer
;	O
bfd_byte	char
*	O
strings_start	pointer
;	O
bfd_byte	char
*	O
resource_start	pointer
;	O
}	O
rsrc_regions	struct
;	O
static	O
bfd_byte	char
*	O
rsrc_print_resource_directory	function
(	O
FILE	struct
*	O
,	O
bfd	struct
*	O
,	O
unsigned	O
int	O
,	O
bfd_byte	char
*	O
,	O
rsrc_regions	struct
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_byte	char
*	O
rsrc_print_resource_entries	function
(	O
FILE	struct
*	O
file	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
indent	int
,	O
bfd_boolean	int
is_name	int
,	O
bfd_byte	char
*	O
data	pointer
,	O
rsrc_regions	struct
*	O
regions	pointer
,	O
bfd_vma	long
rva_bias	long
)	O
{	O
unsigned	O
long	O
entry	pointer
,	O
addr	pointer
,	O
size	long
;	O
bfd_byte	char
*	O
leaf	pointer
;	O
if	O
(	O
data	pointer
+	O
8	int
>=	O
regions	pointer
->	O
section_end	pointer
)	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"%03x %*.s Entry: "	pointer
)	O
,	O
(	O
int	O
)	O
(	O
data	pointer
-	O
regions	pointer
->	O
section_start	pointer
)	O
,	O
indent	int
,	O
" "	pointer
)	O
;	O
entry	pointer
=	O
(	O
unsigned	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
if	O
(	O
is_name	int
)	O
{	O
bfd_byte	char
*	O
name	pointer
;	O
if	O
(	O
HighBitSet	O
(	O
entry	pointer
)	O
)	O
name	pointer
=	O
regions	pointer
->	O
section_start	pointer
+	O
WithoutHighBit	O
(	O
entry	pointer
)	O
;	O
else	O
name	pointer
=	O
regions	pointer
->	O
section_start	pointer
+	O
entry	pointer
-	O
rva_bias	long
;	O
if	O
(	O
name	pointer
+	O
2	int
<	O
regions	pointer
->	O
section_end	pointer
&&	O
name	pointer
>	O
regions	pointer
->	O
section_start	pointer
)	O
{	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
regions	pointer
->	O
strings_start	pointer
==	O
NULL	O
)	O
regions	pointer
->	O
strings_start	pointer
=	O
name	pointer
;	O
len	long
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"name: [val: %08lx len %d]: "	pointer
)	O
,	O
entry	pointer
,	O
len	long
)	O
;	O
if	O
(	O
name	pointer
+	O
2	int
+	O
len	long
*	O
2	int
<	O
regions	pointer
->	O
section_end	pointer
)	O
{	O
while	O
(	O
len	long
--	O
)	O
{	O
char	O
c	struct
;	O
name	pointer
+=	O
2	int
;	O
c	struct
=	O
*	O
name	pointer
;	O
if	O
(	O
c	struct
>	O
0	int
&&	O
c	struct
<	O
32	int
)	O
fprintf	function
(	O
file	pointer
,	O
"^%c"	pointer
,	O
c	struct
+	O
64	int
)	O
;	O
else	O
fprintf	function
(	O
file	pointer
,	O
"%.1s"	pointer
,	O
name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"<corrupt string length: %#x>\n"	pointer
)	O
,	O
len	long
)	O
;	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"<corrupt string offset: %#lx>\n"	pointer
)	O
,	O
entry	pointer
)	O
;	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
}	O
}	O
else	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"ID: %#08lx"	pointer
)	O
,	O
entry	pointer
)	O
;	O
entry	pointer
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
", Value: %#08lx\n"	pointer
)	O
,	O
entry	pointer
)	O
;	O
if	O
(	O
HighBitSet	O
(	O
entry	pointer
)	O
)	O
{	O
data	pointer
=	O
regions	pointer
->	O
section_start	pointer
+	O
WithoutHighBit	O
(	O
entry	pointer
)	O
;	O
if	O
(	O
data	pointer
<=	O
regions	pointer
->	O
section_start	pointer
||	O
data	pointer
>	O
regions	pointer
->	O
section_end	pointer
)	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
return	O
rsrc_print_resource_directory	function
(	O
file	pointer
,	O
abfd	pointer
,	O
indent	int
+	O
1	int
,	O
data	pointer
,	O
regions	pointer
,	O
rva_bias	long
)	O
;	O
}	O
leaf	pointer
=	O
regions	pointer
->	O
section_start	pointer
+	O
entry	pointer
;	O
if	O
(	O
leaf	pointer
+	O
16	int
>=	O
regions	pointer
->	O
section_end	pointer
||	O
leaf	pointer
<	O
regions	pointer
->	O
section_start	pointer
)	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"%03x %*.s  Leaf: Addr: %#08lx, Size: %#08lx, Codepage: %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
entry	pointer
)	O
,	O
indent	int
,	O
" "	pointer
,	O
addr	pointer
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
leaf	pointer
)	O
,	O
size	long
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
leaf	pointer
+	O
4	int
)	O
,	O
(	O
int	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
leaf	pointer
+	O
8	int
)	O
)	O
;	O
if	O
(	O
bfd_get_32	O
(	O
abfd	pointer
,	O
leaf	pointer
+	O
12	int
)	O
!=	O
0	int
||	O
(	O
regions	pointer
->	O
section_start	pointer
+	O
(	O
addr	pointer
-	O
rva_bias	long
)	O
+	O
size	long
>	O
regions	pointer
->	O
section_end	pointer
)	O
)	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
if	O
(	O
regions	pointer
->	O
resource_start	pointer
==	O
NULL	O
)	O
regions	pointer
->	O
resource_start	pointer
=	O
regions	pointer
->	O
section_start	pointer
+	O
(	O
addr	pointer
-	O
rva_bias	long
)	O
;	O
return	O
regions	pointer
->	O
section_start	pointer
+	O
(	O
addr	pointer
-	O
rva_bias	long
)	O
+	O
size	long
;	O
}	O
static	O
bfd_byte	char
*	O
rsrc_print_resource_directory	function
(	O
FILE	struct
*	O
file	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
indent	int
,	O
bfd_byte	char
*	O
data	pointer
,	O
rsrc_regions	struct
*	O
regions	pointer
,	O
bfd_vma	long
rva_bias	long
)	O
{	O
unsigned	O
int	O
num_names	long
,	O
num_ids	int
;	O
bfd_byte	char
*	O
highest_data	pointer
=	O
data	pointer
;	O
if	O
(	O
data	pointer
+	O
16	int
>=	O
regions	pointer
->	O
section_end	pointer
)	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
"%03x %*.s "	pointer
,	O
(	O
int	O
)	O
(	O
data	pointer
-	O
regions	pointer
->	O
section_start	pointer
)	O
,	O
indent	int
,	O
" "	pointer
)	O
;	O
switch	O
(	O
indent	int
)	O
{	O
case	O
0	int
:	O
fprintf	function
(	O
file	pointer
,	O
"Type"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	function
(	O
file	pointer
,	O
"Name"	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
fprintf	function
(	O
file	pointer
,	O
"Language"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"<unknown directory type: %d>\n"	pointer
)	O
,	O
indent	int
)	O
;	O
return	O
regions	pointer
->	O
section_end	pointer
+	O
1	int
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
" Table: Char: %d, Time: %08lx, Ver: %d/%d, Num Names: %d, IDs: %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
,	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
,	O
(	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
8	int
)	O
,	O
(	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
10	int
)	O
,	O
num_names	long
=	O
(	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
12	int
)	O
,	O
num_ids	int
=	O
(	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
14	int
)	O
)	O
;	O
data	pointer
+=	O
16	int
;	O
while	O
(	O
num_names	long
--	O
)	O
{	O
bfd_byte	char
*	O
entry_end	pointer
;	O
entry_end	pointer
=	O
rsrc_print_resource_entries	function
(	O
file	pointer
,	O
abfd	pointer
,	O
indent	int
+	O
1	int
,	O
TRUE	int
,	O
data	pointer
,	O
regions	pointer
,	O
rva_bias	long
)	O
;	O
data	pointer
+=	O
8	int
;	O
highest_data	pointer
=	O
max	O
(	O
highest_data	pointer
,	O
entry_end	pointer
)	O
;	O
if	O
(	O
entry_end	pointer
>=	O
regions	pointer
->	O
section_end	pointer
)	O
return	O
entry_end	pointer
;	O
}	O
while	O
(	O
num_ids	int
--	O
)	O
{	O
bfd_byte	char
*	O
entry_end	pointer
;	O
entry_end	pointer
=	O
rsrc_print_resource_entries	function
(	O
file	pointer
,	O
abfd	pointer
,	O
indent	int
+	O
1	int
,	O
FALSE	int
,	O
data	pointer
,	O
regions	pointer
,	O
rva_bias	long
)	O
;	O
data	pointer
+=	O
8	int
;	O
highest_data	pointer
=	O
max	O
(	O
highest_data	pointer
,	O
entry_end	pointer
)	O
;	O
if	O
(	O
entry_end	pointer
>=	O
regions	pointer
->	O
section_end	pointer
)	O
return	O
entry_end	pointer
;	O
}	O
return	O
max	O
(	O
highest_data	pointer
,	O
data	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
rsrc_print_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
bfd_vma	long
rva_bias	long
;	O
pe_data_type	struct
*	O
pe	struct
;	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_size_type	long
datasize	long
;	O
asection	struct
*	O
section	pointer
;	O
bfd_byte	char
*	O
data	pointer
;	O
rsrc_regions	struct
regions	pointer
;	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
pe	struct
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".rsrc"	pointer
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
return	O
TRUE	int
;	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
datasize	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
rva_bias	long
=	O
section	pointer
->	O
vma	long
-	O
pe	struct
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
regions	pointer
.	O
section_start	pointer
=	O
data	pointer
;	O
regions	pointer
.	O
section_end	pointer
=	O
data	pointer
+	O
datasize	long
;	O
regions	pointer
.	O
strings_start	pointer
=	O
NULL	O
;	O
regions	pointer
.	O
resource_start	pointer
=	O
NULL	O
;	O
fflush	function
(	O
file	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nThe .rsrc Resource Directory section:\n"	pointer
)	O
;	O
while	O
(	O
data	pointer
<	O
regions	pointer
.	O
section_end	pointer
)	O
{	O
bfd_byte	char
*	O
p	pointer
=	O
data	pointer
;	O
data	pointer
=	O
rsrc_print_resource_directory	function
(	O
file	pointer
,	O
abfd	pointer
,	O
0	int
,	O
data	pointer
,	O
&	O
regions	pointer
,	O
rva_bias	long
)	O
;	O
if	O
(	O
data	pointer
==	O
regions	pointer
.	O
section_end	pointer
+	O
1	int
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Corrupt .rsrc section detected!\n"	pointer
)	O
)	O
;	O
else	O
{	O
int	O
align	int
=	O
(	O
1	int
<<	O
section	pointer
->	O
alignment_power	int
)	O
-	O
1	int
;	O
data	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
(	O
(	O
(	O
ptrdiff_t	long
)	O
(	O
data	pointer
+	O
align	int
)	O
)	O
&	O
~	O
align	int
)	O
;	O
rva_bias	long
+=	O
data	pointer
-	O
p	pointer
;	O
if	O
(	O
data	pointer
==	O
(	O
regions	pointer
.	O
section_end	pointer
-	O
4	int
)	O
)	O
data	pointer
=	O
regions	pointer
.	O
section_end	pointer
;	O
else	O
if	O
(	O
data	pointer
<	O
regions	pointer
.	O
section_end	pointer
)	O
{	O
while	O
(	O
++	O
data	pointer
<	O
regions	pointer
.	O
section_end	pointer
)	O
if	O
(	O
*	O
data	pointer
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
data	pointer
<	O
regions	pointer
.	O
section_end	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nWARNING: Extra data in .rsrc section - it will be ignored by Windows:\n"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
regions	pointer
.	O
strings_start	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
" String table starts at offset: %#03x\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
regions	pointer
.	O
strings_start	pointer
-	O
regions	pointer
.	O
section_start	pointer
)	O
)	O
;	O
if	O
(	O
regions	pointer
.	O
resource_start	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
" Resources start at offset: %#03x\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
regions	pointer
.	O
resource_start	pointer
-	O
regions	pointer
.	O
section_start	pointer
)	O
)	O
;	O
free	function
(	O
regions	pointer
.	O
section_start	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
debug_type_names	array
[	O
IMAGE_NUMBEROF_DEBUG_TYPES	int
]	O
=	O
{	O
"Unknown"	pointer
,	O
"COFF"	pointer
,	O
"CodeView"	pointer
,	O
"FPO"	pointer
,	O
"Misc"	pointer
,	O
"Exception"	pointer
,	O
"Fixup"	pointer
,	O
"OMAP-to-SRC"	pointer
,	O
"OMAP-from-SRC"	pointer
,	O
"Borland"	pointer
,	O
"Reserved"	pointer
,	O
"CLSID"	pointer
,	O
}	O
;	O
static	O
bfd_boolean	int
pe_print_debugdata	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
pe_data_type	struct
*	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
extra	pointer
=	O
&	O
pe	struct
->	O
pe_opthdr	struct
;	O
asection	struct
*	O
section	pointer
;	O
bfd_byte	char
*	O
data	pointer
=	O
0	int
;	O
bfd_size_type	long
dataoff	long
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_vma	long
addr	pointer
=	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
VirtualAddress	long
;	O
bfd_size_type	long
size	long
=	O
extra	pointer
->	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
Size	long
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
addr	pointer
+=	O
extra	pointer
->	O
ImageBase	long
;	O
for	O
(	O
section	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
addr	pointer
>=	O
section	pointer
->	O
vma	long
)	O
&&	O
(	O
addr	pointer
<	O
(	O
section	pointer
->	O
vma	long
+	O
section	pointer
->	O
size	long
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is a debug directory, but the section containing it could not be found\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is a debug directory in %s, but that section has no contents\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
size	long
<	O
size	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nError: section %s contains the debug data starting address but it is too small\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThere is a debug directory in %s at 0x%lx\n\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
)	O
;	O
dataoff	long
=	O
addr	pointer
-	O
section	pointer
->	O
vma	long
;	O
if	O
(	O
size	long
>	O
(	O
section	pointer
->	O
size	long
-	O
dataoff	long
)	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"The debug data size field in the data directory is too big for the section"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Type                Size     Rva      Offset\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
size	long
/	O
sizeof	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
)	O
;	O
i	pointer
++	O
)	O
{	O
const	O
char	O
*	O
type_name	pointer
;	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
ext	pointer
=	O
&	O
(	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
)	O
(	O
data	pointer
+	O
dataoff	long
)	O
)	O
[	O
i	pointer
]	O
;	O
struct	O
internal_IMAGE_DEBUG_DIRECTORY	struct
idd	struct
;	O
_bfd_pei_swap_debugdir_in	function
(	O
abfd	pointer
,	O
ext	pointer
,	O
&	O
idd	struct
)	O
;	O
if	O
(	O
(	O
idd	struct
.	O
Type	long
)	O
>=	O
IMAGE_NUMBEROF_DEBUG_TYPES	int
)	O
type_name	pointer
=	O
debug_type_names	array
[	O
0	int
]	O
;	O
else	O
type_name	pointer
=	O
debug_type_names	array
[	O
idd	struct
.	O
Type	long
]	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %2ld  %14s %08lx %08lx %08lx\n"	pointer
,	O
idd	struct
.	O
Type	long
,	O
type_name	pointer
,	O
idd	struct
.	O
SizeOfData	long
,	O
idd	struct
.	O
AddressOfRawData	long
,	O
idd	struct
.	O
PointerToRawData	long
)	O
;	O
if	O
(	O
idd	struct
.	O
Type	long
==	O
PE_IMAGE_DEBUG_TYPE_CODEVIEW	int
)	O
{	O
char	O
signature	array
[	O
CV_INFO_SIGNATURE_LENGTH	int
*	O
2	int
+	O
1	int
]	O
;	O
char	O
buffer	pointer
[	O
256	int
+	O
1	int
]	O
ATTRIBUTE_ALIGNED_ALIGNOF	O
(	O
CODEVIEW_INFO	struct
)	O
;	O
CODEVIEW_INFO	struct
*	O
cvinfo	pointer
=	O
(	O
CODEVIEW_INFO	struct
*	O
)	O
buffer	pointer
;	O
if	O
(	O
!	O
_bfd_pei_slurp_codeview_record	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
idd	struct
.	O
PointerToRawData	long
,	O
idd	struct
.	O
SizeOfData	long
,	O
cvinfo	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
cvinfo	pointer
->	O
SignatureLength	int
;	O
i	pointer
++	O
)	O
sprintf	function
(	O
&	O
signature	array
[	O
i	pointer
*	O
2	int
]	O
,	O
"%02x"	pointer
,	O
cvinfo	pointer
->	O
Signature	array
[	O
i	pointer
]	O
&	O
0xff	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"(format %c%c%c%c signature %s age %ld)\n"	pointer
)	O
,	O
buffer	pointer
[	O
0	int
]	O
,	O
buffer	pointer
[	O
1	int
]	O
,	O
buffer	pointer
[	O
2	int
]	O
,	O
buffer	pointer
[	O
3	int
]	O
,	O
signature	array
,	O
cvinfo	pointer
->	O
Age	long
)	O
;	O
}	O
}	O
if	O
(	O
size	long
%	O
sizeof	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
)	O
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"The debug directory size is not a multiple of the debug directory entry size\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_pe_print_private_bfd_data_common	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
int	O
j	long
;	O
pe_data_type	struct
*	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
internal_extra_pe_aouthdr	struct
*	O
i	pointer
=	O
&	O
pe	struct
->	O
pe_opthdr	struct
;	O
const	O
char	O
*	O
subsystem_name	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name	pointer
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nCharacteristics 0x%x\n"	pointer
)	O
,	O
pe	struct
->	O
real_flags	int
)	O
;	O
PF	O
(	O
IMAGE_FILE_RELOCS_STRIPPED	int
,	O
"relocations stripped"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_EXECUTABLE_IMAGE	int
,	O
"executable"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_LINE_NUMS_STRIPPED	int
,	O
"line numbers stripped"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_LOCAL_SYMS_STRIPPED	int
,	O
"symbols stripped"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_LARGE_ADDRESS_AWARE	int
,	O
"large address aware"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_BYTES_REVERSED_LO	int
,	O
"little endian"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_32BIT_MACHINE	int
,	O
"32 bit words"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_DEBUG_STRIPPED	int
,	O
"debugging information removed"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_SYSTEM	int
,	O
"system file"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_DLL	int
,	O
"DLL"	pointer
)	O
;	O
PF	O
(	O
IMAGE_FILE_BYTES_REVERSED_HI	int
,	O
"big endian"	pointer
)	O
;	O
{	O
time_t	long
t	int
=	O
pe	struct
->	O
coff	struct
.	O
timestamp	long
;	O
fprintf	function
(	O
file	pointer
,	O
"\nTime/Date\t\t%s"	pointer
,	O
ctime	function
(	O
&	O
t	int
)	O
)	O
;	O
}	O
switch	O
(	O
i	pointer
->	O
Magic	short
)	O
{	O
case	O
IMAGE_NT_OPTIONAL_HDR_MAGIC	int
:	O
name	pointer
=	O
"PE32"	pointer
;	O
break	O
;	O
case	O
IMAGE_NT_OPTIONAL_HDR64_MAGIC	int
:	O
name	pointer
=	O
"PE32+"	pointer
;	O
break	O
;	O
case	O
IMAGE_NT_OPTIONAL_HDRROM_MAGIC	int
:	O
name	pointer
=	O
"ROM"	pointer
;	O
break	O
;	O
default	O
:	O
name	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"Magic\t\t\t%04x"	pointer
,	O
i	pointer
->	O
Magic	short
)	O
;	O
if	O
(	O
name	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
"\t(%s)"	pointer
,	O
name	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nMajorLinkerVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MajorLinkerVersion	char
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MinorLinkerVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MinorLinkerVersion	char
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"SizeOfCode\t\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfCode	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nSizeOfInitializedData\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfInitializedData	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nSizeOfUninitializedData\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfUninitializedData	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nAddressOfEntryPoint\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
AddressOfEntryPoint	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nBaseOfCode\t\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
BaseOfCode	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nBaseOfData\t\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
BaseOfData	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nImageBase\t\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
ImageBase	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nSectionAlignment\t%08x\n"	pointer
,	O
i	pointer
->	O
SectionAlignment	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"FileAlignment\t\t%08x\n"	pointer
,	O
i	pointer
->	O
FileAlignment	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MajorOSystemVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MajorOperatingSystemVersion	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MinorOSystemVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MinorOperatingSystemVersion	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MajorImageVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MajorImageVersion	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MinorImageVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MinorImageVersion	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MajorSubsystemVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MajorSubsystemVersion	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"MinorSubsystemVersion\t%d\n"	pointer
,	O
i	pointer
->	O
MinorSubsystemVersion	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"Win32Version\t\t%08x\n"	pointer
,	O
i	pointer
->	O
Reserved1	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"SizeOfImage\t\t%08x\n"	pointer
,	O
i	pointer
->	O
SizeOfImage	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"SizeOfHeaders\t\t%08x\n"	pointer
,	O
i	pointer
->	O
SizeOfHeaders	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"CheckSum\t\t%08x\n"	pointer
,	O
i	pointer
->	O
CheckSum	int
)	O
;	O
switch	O
(	O
i	pointer
->	O
Subsystem	short
)	O
{	O
case	O
IMAGE_SUBSYSTEM_UNKNOWN	int
:	O
subsystem_name	pointer
=	O
"unspecified"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_NATIVE	int
:	O
subsystem_name	pointer
=	O
"NT native"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_WINDOWS_GUI	int
:	O
subsystem_name	pointer
=	O
"Windows GUI"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_WINDOWS_CUI	int
:	O
subsystem_name	pointer
=	O
"Windows CUI"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_POSIX_CUI	int
:	O
subsystem_name	pointer
=	O
"POSIX CUI"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_WINDOWS_CE_GUI	int
:	O
subsystem_name	pointer
=	O
"Wince CUI"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_EFI_APPLICATION	int
:	O
subsystem_name	pointer
=	O
"EFI application"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER	int
:	O
subsystem_name	pointer
=	O
"EFI boot service driver"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER	int
:	O
subsystem_name	pointer
=	O
"EFI runtime driver"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER	int
:	O
subsystem_name	pointer
=	O
"SAL runtime driver"	pointer
;	O
break	O
;	O
case	O
IMAGE_SUBSYSTEM_XBOX	int
:	O
subsystem_name	pointer
=	O
"XBOX"	pointer
;	O
break	O
;	O
default	O
:	O
subsystem_name	pointer
=	O
NULL	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"Subsystem\t\t%08x"	pointer
,	O
i	pointer
->	O
Subsystem	short
)	O
;	O
if	O
(	O
subsystem_name	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
"\t(%s)"	pointer
,	O
subsystem_name	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nDllCharacteristics\t%08x\n"	pointer
,	O
i	pointer
->	O
DllCharacteristics	short
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"SizeOfStackReserve\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfStackReserve	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nSizeOfStackCommit\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfStackCommit	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nSizeOfHeapReserve\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfHeapReserve	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nSizeOfHeapCommit\t"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
SizeOfHeapCommit	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nLoaderFlags\t\t%08lx\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
->	O
LoaderFlags	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"NumberOfRvaAndSizes\t%08lx\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
->	O
NumberOfRvaAndSizes	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\nThe Data Directory\n"	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
IMAGE_NUMBEROF_DIRECTORY_ENTRIES	int
;	O
j	long
++	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"Entry %1x "	pointer
,	O
j	long
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
i	pointer
->	O
DataDirectory	array
[	O
j	long
]	O
.	O
VirtualAddress	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %08lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
->	O
DataDirectory	array
[	O
j	long
]	O
.	O
Size	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%s\n"	pointer
,	O
dir_names	array
[	O
j	long
]	O
)	O
;	O
}	O
pe_print_idata	function
(	O
abfd	pointer
,	O
vfile	pointer
)	O
;	O
pe_print_edata	function
(	O
abfd	pointer
,	O
vfile	pointer
)	O
;	O
if	O
(	O
bfd_coff_have_print_pdata	O
(	O
abfd	pointer
)	O
)	O
bfd_coff_print_pdata	O
(	O
abfd	pointer
,	O
vfile	pointer
)	O
;	O
else	O
pe_print_pdata	function
(	O
abfd	pointer
,	O
vfile	pointer
)	O
;	O
pe_print_reloc	function
(	O
abfd	pointer
,	O
vfile	pointer
)	O
;	O
pe_print_debugdata	function
(	O
abfd	pointer
,	O
file	pointer
)	O
;	O
rsrc_print_section	function
(	O
abfd	pointer
,	O
vfile	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
is_vma_in_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sect	pointer
,	O
void	O
*	O
obj	pointer
)	O
{	O
bfd_vma	long
addr	pointer
=	O
*	O
(	O
bfd_vma	long
*	O
)	O
obj	pointer
;	O
return	O
(	O
addr	pointer
>=	O
sect	pointer
->	O
vma	long
)	O
&&	O
(	O
addr	pointer
<	O
(	O
sect	pointer
->	O
vma	long
+	O
sect	pointer
->	O
size	long
)	O
)	O
;	O
}	O
static	O
asection	struct
*	O
find_section_by_vma	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
addr	pointer
)	O
{	O
return	O
bfd_sections_find_if	function
(	O
abfd	pointer
,	O
is_vma_in_section	function
,	O
(	O
void	O
*	O
)	O
&	O
addr	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_pe_bfd_copy_private_bfd_data_common	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
pe_data_type	struct
*	O
ipe	pointer
,	O
*	O
ope	pointer
;	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_coff_flavour	int
||	O
obfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_coff_flavour	int
)	O
return	O
TRUE	int
;	O
ipe	pointer
=	O
pe_data	O
(	O
ibfd	pointer
)	O
;	O
ope	pointer
=	O
pe_data	O
(	O
obfd	pointer
)	O
;	O
ope	pointer
->	O
dll	int
=	O
ipe	pointer
->	O
dll	int
;	O
if	O
(	O
obfd	pointer
->	O
xvec	pointer
!=	O
ibfd	pointer
->	O
xvec	pointer
)	O
ope	pointer
->	O
pe_opthdr	struct
.	O
Subsystem	short
=	O
IMAGE_SUBSYSTEM_UNKNOWN	int
;	O
if	O
(	O
!	O
pe_data	O
(	O
obfd	pointer
)	O
->	O
has_reloc_section	int
)	O
{	O
pe_data	O
(	O
obfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_BASE_RELOCATION_TABLE	int
]	O
.	O
VirtualAddress	long
=	O
0	int
;	O
pe_data	O
(	O
obfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_BASE_RELOCATION_TABLE	int
]	O
.	O
Size	long
=	O
0	int
;	O
}	O
if	O
(	O
!	O
pe_data	O
(	O
ibfd	pointer
)	O
->	O
has_reloc_section	int
&&	O
!	O
(	O
pe_data	O
(	O
ibfd	pointer
)	O
->	O
real_flags	int
&	O
IMAGE_FILE_RELOCS_STRIPPED	int
)	O
)	O
pe_data	O
(	O
obfd	pointer
)	O
->	O
dont_strip_reloc	int
=	O
1	int
;	O
memcpy	function
(	O
ope	pointer
->	O
dos_message	array
,	O
ipe	pointer
->	O
dos_message	array
,	O
sizeof	O
(	O
ope	pointer
->	O
dos_message	array
)	O
)	O
;	O
if	O
(	O
ope	pointer
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
Size	long
!=	O
0	int
)	O
{	O
bfd_vma	long
addr	pointer
=	O
ope	pointer
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
VirtualAddress	long
+	O
ope	pointer
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
asection	struct
*	O
section	pointer
=	O
find_section_by_vma	function
(	O
obfd	pointer
,	O
addr	pointer
)	O
;	O
bfd_byte	char
*	O
data	pointer
;	O
if	O
(	O
section	pointer
&&	O
bfd_malloc_and_get_section	function
(	O
obfd	pointer
,	O
section	pointer
,	O
&	O
data	pointer
)	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
dd	pointer
=	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
)	O
(	O
data	pointer
+	O
(	O
addr	pointer
-	O
section	pointer
->	O
vma	long
)	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
ope	pointer
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
Size	long
>	O
section	pointer
->	O
size	long
-	O
(	O
addr	pointer
-	O
section	pointer
->	O
vma	long
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: Data Directory size (%lx) "	pointer
"exceeds space left in section (%"	pointer
PRIx64	O
")"	pointer
)	O
,	O
obfd	pointer
,	O
ope	pointer
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
Size	long
,	O
(	O
uint64_t	long
)	O
(	O
section	pointer
->	O
size	long
-	O
(	O
addr	pointer
-	O
section	pointer
->	O
vma	long
)	O
)	O
)	O
;	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ope	pointer
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_DEBUG_DATA	int
]	O
.	O
Size	long
/	O
sizeof	O
(	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
)	O
;	O
i	pointer
++	O
)	O
{	O
asection	struct
*	O
ddsection	pointer
;	O
struct	O
external_IMAGE_DEBUG_DIRECTORY	struct
*	O
edd	pointer
=	O
&	O
(	O
dd	pointer
[	O
i	pointer
]	O
)	O
;	O
struct	O
internal_IMAGE_DEBUG_DIRECTORY	struct
idd	struct
;	O
_bfd_pei_swap_debugdir_in	function
(	O
obfd	pointer
,	O
edd	pointer
,	O
&	O
idd	struct
)	O
;	O
if	O
(	O
idd	struct
.	O
AddressOfRawData	long
==	O
0	int
)	O
continue	O
;	O
ddsection	pointer
=	O
find_section_by_vma	function
(	O
obfd	pointer
,	O
idd	struct
.	O
AddressOfRawData	long
+	O
ope	pointer
->	O
pe_opthdr	struct
.	O
ImageBase	long
)	O
;	O
if	O
(	O
!	O
ddsection	pointer
)	O
continue	O
;	O
idd	struct
.	O
PointerToRawData	long
=	O
ddsection	pointer
->	O
filepos	long
+	O
(	O
idd	struct
.	O
AddressOfRawData	long
+	O
ope	pointer
->	O
pe_opthdr	struct
.	O
ImageBase	long
)	O
-	O
ddsection	pointer
->	O
vma	long
;	O
_bfd_pei_swap_debugdir_out	function
(	O
obfd	pointer
,	O
&	O
idd	struct
,	O
edd	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
section	pointer
,	O
data	pointer
,	O
0	int
,	O
section	pointer
->	O
size	long
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"failed to update file offsets in debug directory"	pointer
)	O
)	O
;	O
free	function
(	O
data	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
free	function
(	O
data	pointer
)	O
;	O
}	O
else	O
if	O
(	O
section	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: failed to read debug data section"	pointer
)	O
,	O
obfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_pe_bfd_copy_private_section_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
asection	struct
*	O
isec	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
asection	struct
*	O
osec	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_coff_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_coff_flavour	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
coff_section_data	O
(	O
ibfd	pointer
,	O
isec	pointer
)	O
!=	O
NULL	O
&&	O
pei_section_data	O
(	O
ibfd	pointer
,	O
isec	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
coff_section_data	O
(	O
obfd	pointer
,	O
osec	pointer
)	O
==	O
NULL	O
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
coff_section_tdata	struct
)	O
;	O
osec	pointer
->	O
used_by_bfd	pointer
=	O
bfd_zalloc	function
(	O
obfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
osec	pointer
->	O
used_by_bfd	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
pei_section_data	O
(	O
obfd	pointer
,	O
osec	pointer
)	O
==	O
NULL	O
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
pei_section_tdata	struct
)	O
;	O
coff_section_data	O
(	O
obfd	pointer
,	O
osec	pointer
)	O
->	O
tdata	union
=	O
bfd_zalloc	function
(	O
obfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
coff_section_data	O
(	O
obfd	pointer
,	O
osec	pointer
)	O
->	O
tdata	union
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
pei_section_data	O
(	O
obfd	pointer
,	O
osec	pointer
)	O
->	O
virt_size	long
=	O
pei_section_data	O
(	O
ibfd	pointer
,	O
isec	pointer
)	O
->	O
virt_size	long
;	O
pei_section_data	O
(	O
obfd	pointer
,	O
osec	pointer
)	O
->	O
pe_flags	long
=	O
pei_section_data	O
(	O
ibfd	pointer
,	O
isec	pointer
)	O
->	O
pe_flags	long
;	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_pe_get_symbol_info	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
symbol_info	struct
*	O
ret	pointer
)	O
{	O
coff_get_symbol_info	function
(	O
abfd	pointer
,	O
symbol	pointer
,	O
ret	pointer
)	O
;	O
}	O
static	O
unsigned	O
int	O
sizeof_leaves	int
;	O
static	O
unsigned	O
int	O
sizeof_strings	int
;	O
static	O
unsigned	O
int	O
sizeof_tables_and_entries	int
;	O
static	O
bfd_byte	char
*	O
rsrc_count_directory	function
(	O
bfd	struct
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_byte	char
*	O
rsrc_count_entries	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_name	int
,	O
bfd_byte	char
*	O
datastart	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_byte	char
*	O
dataend	pointer
,	O
bfd_vma	long
rva_bias	long
)	O
{	O
unsigned	O
long	O
entry	pointer
,	O
addr	pointer
,	O
size	long
;	O
if	O
(	O
data	pointer
+	O
8	int
>=	O
dataend	pointer
)	O
return	O
dataend	pointer
+	O
1	int
;	O
if	O
(	O
is_name	int
)	O
{	O
bfd_byte	char
*	O
name	pointer
;	O
entry	pointer
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
if	O
(	O
HighBitSet	O
(	O
entry	pointer
)	O
)	O
name	pointer
=	O
datastart	pointer
+	O
WithoutHighBit	O
(	O
entry	pointer
)	O
;	O
else	O
name	pointer
=	O
datastart	pointer
+	O
entry	pointer
-	O
rva_bias	long
;	O
if	O
(	O
name	pointer
+	O
2	int
>=	O
dataend	pointer
||	O
name	pointer
<	O
datastart	pointer
)	O
return	O
dataend	pointer
+	O
1	int
;	O
unsigned	O
int	O
len	long
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
len	long
==	O
0	int
||	O
len	long
>	O
256	int
)	O
return	O
dataend	pointer
+	O
1	int
;	O
}	O
entry	pointer
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
;	O
if	O
(	O
HighBitSet	O
(	O
entry	pointer
)	O
)	O
{	O
data	pointer
=	O
datastart	pointer
+	O
WithoutHighBit	O
(	O
entry	pointer
)	O
;	O
if	O
(	O
data	pointer
<=	O
datastart	pointer
||	O
data	pointer
>=	O
dataend	pointer
)	O
return	O
dataend	pointer
+	O
1	int
;	O
return	O
rsrc_count_directory	function
(	O
abfd	pointer
,	O
datastart	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
)	O
;	O
}	O
if	O
(	O
datastart	pointer
+	O
entry	pointer
+	O
16	int
>=	O
dataend	pointer
)	O
return	O
dataend	pointer
+	O
1	int
;	O
addr	pointer
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
datastart	pointer
+	O
entry	pointer
)	O
;	O
size	long
=	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
datastart	pointer
+	O
entry	pointer
+	O
4	int
)	O
;	O
return	O
datastart	pointer
+	O
addr	pointer
-	O
rva_bias	long
+	O
size	long
;	O
}	O
static	O
bfd_byte	char
*	O
rsrc_count_directory	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
datastart	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_byte	char
*	O
dataend	pointer
,	O
bfd_vma	long
rva_bias	long
)	O
{	O
unsigned	O
int	O
num_entries	int
,	O
num_ids	int
;	O
bfd_byte	char
*	O
highest_data	pointer
=	O
data	pointer
;	O
if	O
(	O
data	pointer
+	O
16	int
>=	O
dataend	pointer
)	O
return	O
dataend	pointer
+	O
1	int
;	O
num_entries	int
=	O
(	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
12	int
)	O
;	O
num_ids	int
=	O
(	O
int	O
)	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
14	int
)	O
;	O
num_entries	int
+=	O
num_ids	int
;	O
data	pointer
+=	O
16	int
;	O
while	O
(	O
num_entries	int
--	O
)	O
{	O
bfd_byte	char
*	O
entry_end	pointer
;	O
entry_end	pointer
=	O
rsrc_count_entries	function
(	O
abfd	pointer
,	O
num_entries	int
>=	O
num_ids	int
,	O
datastart	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
)	O
;	O
data	pointer
+=	O
8	int
;	O
highest_data	pointer
=	O
max	O
(	O
highest_data	pointer
,	O
entry_end	pointer
)	O
;	O
if	O
(	O
entry_end	pointer
>=	O
dataend	pointer
)	O
break	O
;	O
}	O
return	O
max	O
(	O
highest_data	pointer
,	O
data	pointer
)	O
;	O
}	O
typedef	O
struct	O
rsrc_dir_chain	struct
{	O
unsigned	O
int	O
num_entries	int
;	O
struct	O
rsrc_entry	struct
*	O
first_entry	pointer
;	O
struct	O
rsrc_entry	struct
*	O
last_entry	pointer
;	O
}	O
rsrc_dir_chain	struct
;	O
typedef	O
struct	O
rsrc_directory	struct
{	O
unsigned	O
int	O
characteristics	int
;	O
unsigned	O
int	O
time	struct
;	O
unsigned	O
int	O
major	int
;	O
unsigned	O
int	O
minor	int
;	O
rsrc_dir_chain	struct
names	struct
;	O
rsrc_dir_chain	struct
ids	struct
;	O
struct	O
rsrc_entry	struct
*	O
entry	pointer
;	O
}	O
rsrc_directory	struct
;	O
typedef	O
struct	O
rsrc_string	struct
{	O
unsigned	O
int	O
len	long
;	O
bfd_byte	char
*	O
string	pointer
;	O
}	O
rsrc_string	struct
;	O
typedef	O
struct	O
rsrc_leaf	struct
{	O
unsigned	O
int	O
size	long
;	O
unsigned	O
int	O
codepage	int
;	O
bfd_byte	char
*	O
data	pointer
;	O
}	O
rsrc_leaf	struct
;	O
typedef	O
struct	O
rsrc_entry	struct
{	O
bfd_boolean	int
is_name	int
;	O
union	O
{	O
unsigned	O
int	O
id	int
;	O
struct	O
rsrc_string	struct
name	pointer
;	O
}	O
name_id	union
;	O
bfd_boolean	int
is_dir	int
;	O
union	O
{	O
struct	O
rsrc_directory	struct
*	O
directory	pointer
;	O
struct	O
rsrc_leaf	struct
*	O
leaf	pointer
;	O
}	O
value	long
;	O
struct	O
rsrc_entry	struct
*	O
next_entry	pointer
;	O
struct	O
rsrc_directory	struct
*	O
parent	pointer
;	O
}	O
rsrc_entry	struct
;	O
static	O
bfd_byte	char
*	O
rsrc_parse_directory	function
(	O
bfd	struct
*	O
,	O
rsrc_directory	struct
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_vma	long
,	O
rsrc_entry	struct
*	O
)	O
;	O
static	O
bfd_byte	char
*	O
rsrc_parse_entry	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_name	int
,	O
rsrc_entry	struct
*	O
entry	pointer
,	O
bfd_byte	char
*	O
datastart	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_byte	char
*	O
dataend	pointer
,	O
bfd_vma	long
rva_bias	long
,	O
rsrc_directory	struct
*	O
parent	pointer
)	O
{	O
unsigned	O
long	O
val	array
,	O
addr	pointer
,	O
size	long
;	O
val	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
entry	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
entry	pointer
->	O
is_name	int
=	O
is_name	int
;	O
if	O
(	O
is_name	int
)	O
{	O
bfd_byte	char
*	O
address	long
;	O
if	O
(	O
HighBitSet	O
(	O
val	array
)	O
)	O
{	O
val	array
=	O
WithoutHighBit	O
(	O
val	array
)	O
;	O
address	long
=	O
datastart	pointer
+	O
val	array
;	O
}	O
else	O
{	O
address	long
=	O
datastart	pointer
+	O
val	array
-	O
rva_bias	long
;	O
}	O
if	O
(	O
address	long
+	O
3	int
>	O
dataend	pointer
)	O
return	O
dataend	pointer
;	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
.	O
len	long
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
address	long
)	O
;	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
.	O
string	pointer
=	O
address	long
+	O
2	int
;	O
}	O
else	O
entry	pointer
->	O
name_id	union
.	O
id	int
=	O
val	array
;	O
val	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
;	O
if	O
(	O
HighBitSet	O
(	O
val	array
)	O
)	O
{	O
entry	pointer
->	O
is_dir	int
=	O
TRUE	int
;	O
entry	pointer
->	O
value	long
.	O
directory	pointer
=	O
bfd_malloc	function
(	O
sizeof	O
*	O
entry	pointer
->	O
value	long
.	O
directory	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
value	long
.	O
directory	pointer
==	O
NULL	O
)	O
return	O
dataend	pointer
;	O
return	O
rsrc_parse_directory	function
(	O
abfd	pointer
,	O
entry	pointer
->	O
value	long
.	O
directory	pointer
,	O
datastart	pointer
,	O
datastart	pointer
+	O
WithoutHighBit	O
(	O
val	array
)	O
,	O
dataend	pointer
,	O
rva_bias	long
,	O
entry	pointer
)	O
;	O
}	O
entry	pointer
->	O
is_dir	int
=	O
FALSE	int
;	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
=	O
bfd_malloc	function
(	O
sizeof	O
*	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
==	O
NULL	O
)	O
return	O
dataend	pointer
;	O
data	pointer
=	O
datastart	pointer
+	O
val	array
;	O
if	O
(	O
data	pointer
<	O
datastart	pointer
||	O
data	pointer
>=	O
dataend	pointer
)	O
return	O
dataend	pointer
;	O
addr	pointer
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
size	long
=	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
->	O
size	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
;	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
->	O
codepage	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
8	int
)	O
;	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
=	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
==	O
NULL	O
)	O
return	O
dataend	pointer
;	O
memcpy	function
(	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
,	O
datastart	pointer
+	O
addr	pointer
-	O
rva_bias	long
,	O
size	long
)	O
;	O
return	O
datastart	pointer
+	O
(	O
addr	pointer
-	O
rva_bias	long
)	O
+	O
size	long
;	O
}	O
static	O
bfd_byte	char
*	O
rsrc_parse_entries	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
rsrc_dir_chain	struct
*	O
chain	pointer
,	O
bfd_boolean	int
is_name	int
,	O
bfd_byte	char
*	O
highest_data	pointer
,	O
bfd_byte	char
*	O
datastart	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_byte	char
*	O
dataend	pointer
,	O
bfd_vma	long
rva_bias	long
,	O
rsrc_directory	struct
*	O
parent	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
rsrc_entry	struct
*	O
entry	pointer
;	O
if	O
(	O
chain	pointer
->	O
num_entries	int
==	O
0	int
)	O
{	O
chain	pointer
->	O
first_entry	pointer
=	O
chain	pointer
->	O
last_entry	pointer
=	O
NULL	O
;	O
return	O
highest_data	pointer
;	O
}	O
entry	pointer
=	O
bfd_malloc	function
(	O
sizeof	O
*	O
entry	pointer
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
dataend	pointer
;	O
chain	pointer
->	O
first_entry	pointer
=	O
entry	pointer
;	O
for	O
(	O
i	pointer
=	O
chain	pointer
->	O
num_entries	int
;	O
i	pointer
--	O
;	O
)	O
{	O
bfd_byte	char
*	O
entry_end	pointer
;	O
entry_end	pointer
=	O
rsrc_parse_entry	function
(	O
abfd	pointer
,	O
is_name	int
,	O
entry	pointer
,	O
datastart	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
,	O
parent	pointer
)	O
;	O
data	pointer
+=	O
8	int
;	O
highest_data	pointer
=	O
max	O
(	O
entry_end	pointer
,	O
highest_data	pointer
)	O
;	O
if	O
(	O
entry_end	pointer
>	O
dataend	pointer
)	O
return	O
dataend	pointer
;	O
if	O
(	O
i	pointer
)	O
{	O
entry	pointer
->	O
next_entry	pointer
=	O
bfd_malloc	function
(	O
sizeof	O
*	O
entry	pointer
)	O
;	O
entry	pointer
=	O
entry	pointer
->	O
next_entry	pointer
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
dataend	pointer
;	O
}	O
else	O
entry	pointer
->	O
next_entry	pointer
=	O
NULL	O
;	O
}	O
chain	pointer
->	O
last_entry	pointer
=	O
entry	pointer
;	O
return	O
highest_data	pointer
;	O
}	O
static	O
bfd_byte	char
*	O
rsrc_parse_directory	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
rsrc_directory	struct
*	O
table	pointer
,	O
bfd_byte	char
*	O
datastart	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_byte	char
*	O
dataend	pointer
,	O
bfd_vma	long
rva_bias	long
,	O
rsrc_entry	struct
*	O
entry	pointer
)	O
{	O
bfd_byte	char
*	O
highest_data	pointer
=	O
data	pointer
;	O
if	O
(	O
table	pointer
==	O
NULL	O
)	O
return	O
dataend	pointer
;	O
table	pointer
->	O
characteristics	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
table	pointer
->	O
time	struct
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
+	O
4	int
)	O
;	O
table	pointer
->	O
major	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
8	int
)	O
;	O
table	pointer
->	O
minor	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
10	int
)	O
;	O
table	pointer
->	O
names	struct
.	O
num_entries	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
12	int
)	O
;	O
table	pointer
->	O
ids	struct
.	O
num_entries	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
+	O
14	int
)	O
;	O
table	pointer
->	O
entry	pointer
=	O
entry	pointer
;	O
data	pointer
+=	O
16	int
;	O
highest_data	pointer
=	O
rsrc_parse_entries	function
(	O
abfd	pointer
,	O
&	O
table	pointer
->	O
names	struct
,	O
TRUE	int
,	O
data	pointer
,	O
datastart	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
,	O
table	pointer
)	O
;	O
data	pointer
+=	O
table	pointer
->	O
names	struct
.	O
num_entries	int
*	O
8	int
;	O
highest_data	pointer
=	O
rsrc_parse_entries	function
(	O
abfd	pointer
,	O
&	O
table	pointer
->	O
ids	struct
,	O
FALSE	int
,	O
highest_data	pointer
,	O
datastart	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
,	O
table	pointer
)	O
;	O
data	pointer
+=	O
table	pointer
->	O
ids	struct
.	O
num_entries	int
*	O
8	int
;	O
return	O
max	O
(	O
highest_data	pointer
,	O
data	pointer
)	O
;	O
}	O
typedef	O
struct	O
rsrc_write_data	struct
{	O
bfd	struct
*	O
abfd	pointer
;	O
bfd_byte	char
*	O
datastart	pointer
;	O
bfd_byte	char
*	O
next_table	pointer
;	O
bfd_byte	char
*	O
next_leaf	pointer
;	O
bfd_byte	char
*	O
next_string	pointer
;	O
bfd_byte	char
*	O
next_data	pointer
;	O
bfd_vma	long
rva_bias	long
;	O
}	O
rsrc_write_data	struct
;	O
static	O
void	O
rsrc_write_string	function
(	O
rsrc_write_data	struct
*	O
data	pointer
,	O
rsrc_string	struct
*	O
string	pointer
)	O
{	O
bfd_put_16	O
(	O
data	pointer
->	O
abfd	pointer
,	O
string	pointer
->	O
len	long
,	O
data	pointer
->	O
next_string	pointer
)	O
;	O
memcpy	function
(	O
data	pointer
->	O
next_string	pointer
+	O
2	int
,	O
string	pointer
->	O
string	pointer
,	O
string	pointer
->	O
len	long
*	O
2	int
)	O
;	O
data	pointer
->	O
next_string	pointer
+=	O
(	O
string	pointer
->	O
len	long
+	O
1	int
)	O
*	O
2	int
;	O
}	O
static	O
inline	O
unsigned	O
int	O
rsrc_compute_rva	function
(	O
rsrc_write_data	struct
*	O
data	pointer
,	O
bfd_byte	char
*	O
addr	pointer
)	O
{	O
return	O
(	O
addr	pointer
-	O
data	pointer
->	O
datastart	pointer
)	O
+	O
data	pointer
->	O
rva_bias	long
;	O
}	O
static	O
void	O
rsrc_write_leaf	function
(	O
rsrc_write_data	struct
*	O
data	pointer
,	O
rsrc_leaf	struct
*	O
leaf	pointer
)	O
{	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
rsrc_compute_rva	function
(	O
data	pointer
,	O
data	pointer
->	O
next_data	pointer
)	O
,	O
data	pointer
->	O
next_leaf	pointer
)	O
;	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
leaf	pointer
->	O
size	long
,	O
data	pointer
->	O
next_leaf	pointer
+	O
4	int
)	O
;	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
leaf	pointer
->	O
codepage	int
,	O
data	pointer
->	O
next_leaf	pointer
+	O
8	int
)	O
;	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
0	int
,	O
data	pointer
->	O
next_leaf	pointer
+	O
12	int
)	O
;	O
data	pointer
->	O
next_leaf	pointer
+=	O
16	int
;	O
memcpy	function
(	O
data	pointer
->	O
next_data	pointer
,	O
leaf	pointer
->	O
data	pointer
,	O
leaf	pointer
->	O
size	long
)	O
;	O
data	pointer
->	O
next_data	pointer
+=	O
(	O
(	O
leaf	pointer
->	O
size	long
+	O
7	int
)	O
&	O
~	O
7	int
)	O
;	O
}	O
static	O
void	O
rsrc_write_directory	function
(	O
rsrc_write_data	struct
*	O
,	O
rsrc_directory	struct
*	O
)	O
;	O
static	O
void	O
rsrc_write_entry	function
(	O
rsrc_write_data	struct
*	O
data	pointer
,	O
bfd_byte	char
*	O
where	long
,	O
rsrc_entry	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
is_name	int
)	O
{	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
SetHighBit	O
(	O
data	pointer
->	O
next_string	pointer
-	O
data	pointer
->	O
datastart	pointer
)	O
,	O
where	long
)	O
;	O
rsrc_write_string	function
(	O
data	pointer
,	O
&	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
)	O
;	O
}	O
else	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
entry	pointer
->	O
name_id	union
.	O
id	int
,	O
where	long
)	O
;	O
if	O
(	O
entry	pointer
->	O
is_dir	int
)	O
{	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
SetHighBit	O
(	O
data	pointer
->	O
next_table	pointer
-	O
data	pointer
->	O
datastart	pointer
)	O
,	O
where	long
+	O
4	int
)	O
;	O
rsrc_write_directory	function
(	O
data	pointer
,	O
entry	pointer
->	O
value	long
.	O
directory	pointer
)	O
;	O
}	O
else	O
{	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
data	pointer
->	O
next_leaf	pointer
-	O
data	pointer
->	O
datastart	pointer
,	O
where	long
+	O
4	int
)	O
;	O
rsrc_write_leaf	function
(	O
data	pointer
,	O
entry	pointer
->	O
value	long
.	O
leaf	pointer
)	O
;	O
}	O
}	O
static	O
void	O
rsrc_compute_region_sizes	function
(	O
rsrc_directory	struct
*	O
dir	pointer
)	O
{	O
struct	O
rsrc_entry	struct
*	O
entry	pointer
;	O
if	O
(	O
dir	pointer
==	O
NULL	O
)	O
return	O
;	O
sizeof_tables_and_entries	int
+=	O
16	int
;	O
for	O
(	O
entry	pointer
=	O
dir	pointer
->	O
names	struct
.	O
first_entry	pointer
;	O
entry	pointer
!=	O
NULL	O
;	O
entry	pointer
=	O
entry	pointer
->	O
next_entry	pointer
)	O
{	O
sizeof_tables_and_entries	int
+=	O
8	int
;	O
sizeof_strings	int
+=	O
(	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
.	O
len	long
+	O
1	int
)	O
*	O
2	int
;	O
if	O
(	O
entry	pointer
->	O
is_dir	int
)	O
rsrc_compute_region_sizes	function
(	O
entry	pointer
->	O
value	long
.	O
directory	pointer
)	O
;	O
else	O
sizeof_leaves	int
+=	O
16	int
;	O
}	O
for	O
(	O
entry	pointer
=	O
dir	pointer
->	O
ids	struct
.	O
first_entry	pointer
;	O
entry	pointer
!=	O
NULL	O
;	O
entry	pointer
=	O
entry	pointer
->	O
next_entry	pointer
)	O
{	O
sizeof_tables_and_entries	int
+=	O
8	int
;	O
if	O
(	O
entry	pointer
->	O
is_dir	int
)	O
rsrc_compute_region_sizes	function
(	O
entry	pointer
->	O
value	long
.	O
directory	pointer
)	O
;	O
else	O
sizeof_leaves	int
+=	O
16	int
;	O
}	O
}	O
static	O
void	O
rsrc_write_directory	function
(	O
rsrc_write_data	struct
*	O
data	pointer
,	O
rsrc_directory	struct
*	O
dir	pointer
)	O
{	O
rsrc_entry	struct
*	O
entry	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_byte	char
*	O
next_entry	pointer
;	O
bfd_byte	char
*	O
nt	pointer
;	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
dir	pointer
->	O
characteristics	int
,	O
data	pointer
->	O
next_table	pointer
)	O
;	O
bfd_put_32	O
(	O
data	pointer
->	O
abfd	pointer
,	O
0	int
,	O
data	pointer
->	O
next_table	pointer
+	O
4	int
)	O
;	O
bfd_put_16	O
(	O
data	pointer
->	O
abfd	pointer
,	O
dir	pointer
->	O
major	int
,	O
data	pointer
->	O
next_table	pointer
+	O
8	int
)	O
;	O
bfd_put_16	O
(	O
data	pointer
->	O
abfd	pointer
,	O
dir	pointer
->	O
minor	int
,	O
data	pointer
->	O
next_table	pointer
+	O
10	int
)	O
;	O
bfd_put_16	O
(	O
data	pointer
->	O
abfd	pointer
,	O
dir	pointer
->	O
names	struct
.	O
num_entries	int
,	O
data	pointer
->	O
next_table	pointer
+	O
12	int
)	O
;	O
bfd_put_16	O
(	O
data	pointer
->	O
abfd	pointer
,	O
dir	pointer
->	O
ids	struct
.	O
num_entries	int
,	O
data	pointer
->	O
next_table	pointer
+	O
14	int
)	O
;	O
next_entry	pointer
=	O
data	pointer
->	O
next_table	pointer
+	O
16	int
;	O
data	pointer
->	O
next_table	pointer
=	O
next_entry	pointer
+	O
(	O
dir	pointer
->	O
names	struct
.	O
num_entries	int
*	O
8	int
)	O
+	O
(	O
dir	pointer
->	O
ids	struct
.	O
num_entries	int
*	O
8	int
)	O
;	O
nt	pointer
=	O
data	pointer
->	O
next_table	pointer
;	O
for	O
(	O
i	pointer
=	O
dir	pointer
->	O
names	struct
.	O
num_entries	int
,	O
entry	pointer
=	O
dir	pointer
->	O
names	struct
.	O
first_entry	pointer
;	O
i	pointer
>	O
0	int
&&	O
entry	pointer
!=	O
NULL	O
;	O
i	pointer
--	O
,	O
entry	pointer
=	O
entry	pointer
->	O
next_entry	pointer
)	O
{	O
BFD_ASSERT	O
(	O
entry	pointer
->	O
is_name	int
)	O
;	O
rsrc_write_entry	function
(	O
data	pointer
,	O
next_entry	pointer
,	O
entry	pointer
)	O
;	O
next_entry	pointer
+=	O
8	int
;	O
}	O
BFD_ASSERT	O
(	O
i	pointer
==	O
0	int
)	O
;	O
BFD_ASSERT	O
(	O
entry	pointer
==	O
NULL	O
)	O
;	O
for	O
(	O
i	pointer
=	O
dir	pointer
->	O
ids	struct
.	O
num_entries	int
,	O
entry	pointer
=	O
dir	pointer
->	O
ids	struct
.	O
first_entry	pointer
;	O
i	pointer
>	O
0	int
&&	O
entry	pointer
!=	O
NULL	O
;	O
i	pointer
--	O
,	O
entry	pointer
=	O
entry	pointer
->	O
next_entry	pointer
)	O
{	O
BFD_ASSERT	O
(	O
!	O
entry	pointer
->	O
is_name	int
)	O
;	O
rsrc_write_entry	function
(	O
data	pointer
,	O
next_entry	pointer
,	O
entry	pointer
)	O
;	O
next_entry	pointer
+=	O
8	int
;	O
}	O
BFD_ASSERT	O
(	O
i	pointer
==	O
0	int
)	O
;	O
BFD_ASSERT	O
(	O
entry	pointer
==	O
NULL	O
)	O
;	O
BFD_ASSERT	O
(	O
nt	pointer
==	O
next_entry	pointer
)	O
;	O
}	O
static	O
unsigned	O
int	O
u16_mbtouc	function
(	O
wint_t	int
*	O
puc	pointer
,	O
const	O
unsigned	O
short	O
*	O
s	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
short	O
c	struct
=	O
*	O
s	pointer
;	O
if	O
(	O
c	struct
<	O
0xd800	int
||	O
c	struct
>=	O
0xe000	int
)	O
{	O
*	O
puc	pointer
=	O
c	struct
;	O
return	O
1	int
;	O
}	O
if	O
(	O
c	struct
<	O
0xdc00	int
)	O
{	O
if	O
(	O
n	long
>=	O
2	int
)	O
{	O
if	O
(	O
s	pointer
[	O
1	int
]	O
>=	O
0xdc00	int
&&	O
s	pointer
[	O
1	int
]	O
<	O
0xe000	int
)	O
{	O
*	O
puc	pointer
=	O
0x10000	int
+	O
(	O
(	O
c	struct
-	O
0xd800	int
)	O
<<	O
10	int
)	O
+	O
(	O
s	pointer
[	O
1	int
]	O
-	O
0xdc00	int
)	O
;	O
return	O
2	int
;	O
}	O
}	O
else	O
{	O
*	O
puc	pointer
=	O
0xfffd	int
;	O
return	O
n	long
;	O
}	O
}	O
*	O
puc	pointer
=	O
0xfffd	int
;	O
return	O
1	int
;	O
}	O
static	O
signed	O
int	O
rsrc_cmp	function
(	O
bfd_boolean	int
is_name	int
,	O
rsrc_entry	struct
*	O
a	pointer
,	O
rsrc_entry	struct
*	O
b	pointer
)	O
{	O
signed	O
int	O
res	int
;	O
bfd_byte	char
*	O
astring	pointer
;	O
unsigned	O
int	O
alen	int
;	O
bfd_byte	char
*	O
bstring	pointer
;	O
unsigned	O
int	O
blen	int
;	O
if	O
(	O
!	O
is_name	int
)	O
return	O
a	pointer
->	O
name_id	union
.	O
id	int
-	O
b	pointer
->	O
name_id	union
.	O
id	int
;	O
astring	pointer
=	O
a	pointer
->	O
name_id	union
.	O
name	pointer
.	O
string	pointer
;	O
alen	int
=	O
a	pointer
->	O
name_id	union
.	O
name	pointer
.	O
len	long
;	O
bstring	pointer
=	O
b	pointer
->	O
name_id	union
.	O
name	pointer
.	O
string	pointer
;	O
blen	int
=	O
b	pointer
->	O
name_id	union
.	O
name	pointer
.	O
len	long
;	O
{	O
unsigned	O
int	O
i	pointer
;	O
res	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
min	O
(	O
alen	int
,	O
blen	int
)	O
;	O
i	pointer
--	O
;	O
astring	pointer
+=	O
2	int
,	O
bstring	pointer
+=	O
2	int
)	O
{	O
wint_t	int
awc	int
;	O
wint_t	int
bwc	int
;	O
unsigned	O
int	O
Alen	int
=	O
u16_mbtouc	function
(	O
&	O
awc	int
,	O
(	O
const	O
unsigned	O
short	O
*	O
)	O
astring	pointer
,	O
2	int
)	O
;	O
unsigned	O
int	O
Blen	int
=	O
u16_mbtouc	function
(	O
&	O
bwc	int
,	O
(	O
const	O
unsigned	O
short	O
*	O
)	O
bstring	pointer
,	O
2	int
)	O
;	O
if	O
(	O
Alen	int
!=	O
Blen	int
)	O
return	O
Alen	int
-	O
Blen	int
;	O
awc	int
=	O
towlower	function
(	O
awc	int
)	O
;	O
bwc	int
=	O
towlower	function
(	O
bwc	int
)	O
;	O
res	int
=	O
awc	int
-	O
bwc	int
;	O
if	O
(	O
res	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
res	int
==	O
0	int
)	O
res	int
=	O
alen	int
-	O
blen	int
;	O
return	O
res	int
;	O
}	O
static	O
void	O
rsrc_print_name	function
(	O
char	O
*	O
buffer	pointer
,	O
rsrc_string	struct
string	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
bfd_byte	char
*	O
name	pointer
=	O
string	pointer
.	O
string	pointer
;	O
for	O
(	O
i	pointer
=	O
string	pointer
.	O
len	long
;	O
i	pointer
--	O
;	O
name	pointer
+=	O
2	int
)	O
sprintf	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
"%.1s"	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
rsrc_resource_name	function
(	O
rsrc_entry	struct
*	O
entry	pointer
,	O
rsrc_directory	struct
*	O
dir	pointer
)	O
{	O
static	O
char	O
buffer	pointer
[	O
256	int
]	O
;	O
bfd_boolean	int
is_string	int
=	O
FALSE	int
;	O
buffer	pointer
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
dir	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
!=	O
NULL	O
)	O
{	O
strcpy	function
(	O
buffer	pointer
,	O
"type: "	pointer
)	O
;	O
if	O
(	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
is_name	int
)	O
rsrc_print_name	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
)	O
;	O
else	O
{	O
unsigned	O
int	O
id	int
=	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
;	O
sprintf	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
"%x"	pointer
,	O
id	int
)	O
;	O
switch	O
(	O
id	int
)	O
{	O
case	O
1	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (CURSOR)"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (BITMAP)"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (ICON)"	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (MENU)"	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (DIALOG)"	pointer
)	O
;	O
break	O
;	O
case	O
6	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (STRING)"	pointer
)	O
;	O
is_string	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
7	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (FONTDIR)"	pointer
)	O
;	O
break	O
;	O
case	O
8	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (FONT)"	pointer
)	O
;	O
break	O
;	O
case	O
9	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (ACCELERATOR)"	pointer
)	O
;	O
break	O
;	O
case	O
10	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (RCDATA)"	pointer
)	O
;	O
break	O
;	O
case	O
11	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (MESSAGETABLE)"	pointer
)	O
;	O
break	O
;	O
case	O
12	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (GROUP_CURSOR)"	pointer
)	O
;	O
break	O
;	O
case	O
14	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (GROUP_ICON)"	pointer
)	O
;	O
break	O
;	O
case	O
16	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (VERSION)"	pointer
)	O
;	O
break	O
;	O
case	O
17	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (DLGINCLUDE)"	pointer
)	O
;	O
break	O
;	O
case	O
19	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (PLUGPLAY)"	pointer
)	O
;	O
break	O
;	O
case	O
20	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (VXD)"	pointer
)	O
;	O
break	O
;	O
case	O
21	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (ANICURSOR)"	pointer
)	O
;	O
break	O
;	O
case	O
22	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (ANIICON)"	pointer
)	O
;	O
break	O
;	O
case	O
23	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (HTML)"	pointer
)	O
;	O
break	O
;	O
case	O
24	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (MANIFEST)"	pointer
)	O
;	O
break	O
;	O
case	O
240	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (DLGINIT)"	pointer
)	O
;	O
break	O
;	O
case	O
241	int
:	O
strcat	function
(	O
buffer	pointer
,	O
" (TOOLBAR)"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
dir	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
!=	O
NULL	O
)	O
{	O
strcat	function
(	O
buffer	pointer
,	O
" name: "	pointer
)	O
;	O
if	O
(	O
dir	pointer
->	O
entry	pointer
->	O
is_name	int
)	O
rsrc_print_name	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
dir	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
)	O
;	O
else	O
{	O
unsigned	O
int	O
id	int
=	O
dir	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
;	O
sprintf	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
"%x"	pointer
,	O
id	int
)	O
;	O
if	O
(	O
is_string	int
)	O
sprintf	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
" (resource id range: %d - %d)"	pointer
,	O
(	O
id	int
-	O
1	int
)	O
<<	O
4	int
,	O
(	O
id	int
<<	O
4	int
)	O
-	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
entry	pointer
!=	O
NULL	O
)	O
{	O
strcat	function
(	O
buffer	pointer
,	O
" lang: "	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
is_name	int
)	O
rsrc_print_name	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
entry	pointer
->	O
name_id	union
.	O
name	pointer
)	O
;	O
else	O
sprintf	function
(	O
buffer	pointer
+	O
strlen	function
(	O
buffer	pointer
)	O
,	O
"%x"	pointer
,	O
entry	pointer
->	O
name_id	union
.	O
id	int
)	O
;	O
}	O
return	O
buffer	pointer
;	O
}	O
static	O
bfd_boolean	int
rsrc_merge_string_entries	function
(	O
rsrc_entry	struct
*	O
a	pointer
ATTRIBUTE_UNUSED	O
,	O
rsrc_entry	struct
*	O
b	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
copy_needed	int
=	O
0	int
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_byte	char
*	O
astring	pointer
;	O
bfd_byte	char
*	O
bstring	pointer
;	O
bfd_byte	char
*	O
new_data	pointer
;	O
bfd_byte	char
*	O
nstring	pointer
;	O
BFD_ASSERT	O
(	O
!	O
a	pointer
->	O
is_dir	int
)	O
;	O
astring	pointer
=	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
;	O
BFD_ASSERT	O
(	O
!	O
b	pointer
->	O
is_dir	int
)	O
;	O
bstring	pointer
=	O
b	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
16	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
alen	int
=	O
astring	pointer
[	O
0	int
]	O
+	O
(	O
astring	pointer
[	O
1	int
]	O
<<	O
8	int
)	O
;	O
unsigned	O
int	O
blen	int
=	O
bstring	pointer
[	O
0	int
]	O
+	O
(	O
bstring	pointer
[	O
1	int
]	O
<<	O
8	int
)	O
;	O
if	O
(	O
alen	int
==	O
0	int
)	O
{	O
copy_needed	int
+=	O
blen	int
*	O
2	int
;	O
}	O
else	O
if	O
(	O
blen	int
==	O
0	int
)	O
;	O
else	O
if	O
(	O
alen	int
!=	O
blen	int
)	O
break	O
;	O
else	O
if	O
(	O
memcmp	function
(	O
astring	pointer
+	O
2	int
,	O
bstring	pointer
+	O
2	int
,	O
alen	int
*	O
2	int
)	O
!=	O
0	int
)	O
break	O
;	O
astring	pointer
+=	O
(	O
alen	int
+	O
1	int
)	O
*	O
2	int
;	O
bstring	pointer
+=	O
(	O
blen	int
+	O
1	int
)	O
*	O
2	int
;	O
}	O
if	O
(	O
i	pointer
!=	O
16	int
)	O
{	O
if	O
(	O
a	pointer
->	O
parent	pointer
!=	O
NULL	O
&&	O
a	pointer
->	O
parent	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
!	O
a	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
is_name	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: duplicate string resource: %d"	pointer
)	O
,	O
(	O
(	O
a	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
-	O
1	int
)	O
<<	O
4	int
)	O
+	O
i	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
copy_needed	int
==	O
0	int
)	O
return	O
TRUE	int
;	O
new_data	pointer
=	O
bfd_malloc	function
(	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
size	long
+	O
copy_needed	int
)	O
;	O
if	O
(	O
new_data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
nstring	pointer
=	O
new_data	pointer
;	O
astring	pointer
=	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
;	O
bstring	pointer
=	O
b	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
16	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
alen	int
=	O
astring	pointer
[	O
0	int
]	O
+	O
(	O
astring	pointer
[	O
1	int
]	O
<<	O
8	int
)	O
;	O
unsigned	O
int	O
blen	int
=	O
bstring	pointer
[	O
0	int
]	O
+	O
(	O
bstring	pointer
[	O
1	int
]	O
<<	O
8	int
)	O
;	O
if	O
(	O
alen	int
!=	O
0	int
)	O
{	O
memcpy	function
(	O
nstring	pointer
,	O
astring	pointer
,	O
(	O
alen	int
+	O
1	int
)	O
*	O
2	int
)	O
;	O
nstring	pointer
+=	O
(	O
alen	int
+	O
1	int
)	O
*	O
2	int
;	O
}	O
else	O
if	O
(	O
blen	int
!=	O
0	int
)	O
{	O
memcpy	function
(	O
nstring	pointer
,	O
bstring	pointer
,	O
(	O
blen	int
+	O
1	int
)	O
*	O
2	int
)	O
;	O
nstring	pointer
+=	O
(	O
blen	int
+	O
1	int
)	O
*	O
2	int
;	O
}	O
else	O
{	O
*	O
nstring	pointer
++	O
=	O
0	int
;	O
*	O
nstring	pointer
++	O
=	O
0	int
;	O
}	O
astring	pointer
+=	O
(	O
alen	int
+	O
1	int
)	O
*	O
2	int
;	O
bstring	pointer
+=	O
(	O
blen	int
+	O
1	int
)	O
*	O
2	int
;	O
}	O
BFD_ASSERT	O
(	O
nstring	pointer
-	O
new_data	pointer
==	O
(	O
signed	O
)	O
(	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
size	long
+	O
copy_needed	int
)	O
)	O
;	O
free	function
(	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
)	O
;	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
data	pointer
=	O
new_data	pointer
;	O
a	pointer
->	O
value	long
.	O
leaf	pointer
->	O
size	long
+=	O
copy_needed	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
rsrc_merge	function
(	O
rsrc_entry	struct
*	O
,	O
rsrc_entry	struct
*	O
)	O
;	O
static	O
void	O
rsrc_sort_entries	function
(	O
rsrc_dir_chain	struct
*	O
chain	pointer
,	O
bfd_boolean	int
is_name	int
,	O
rsrc_directory	struct
*	O
dir	pointer
)	O
{	O
rsrc_entry	struct
*	O
entry	pointer
;	O
rsrc_entry	struct
*	O
next	pointer
;	O
rsrc_entry	struct
*	O
*	O
points_to_entry	pointer
;	O
bfd_boolean	int
swapped	int
;	O
if	O
(	O
chain	pointer
->	O
num_entries	int
<	O
2	int
)	O
return	O
;	O
do	O
{	O
swapped	int
=	O
FALSE	int
;	O
points_to_entry	pointer
=	O
&	O
chain	pointer
->	O
first_entry	pointer
;	O
entry	pointer
=	O
*	O
points_to_entry	pointer
;	O
next	pointer
=	O
entry	pointer
->	O
next_entry	pointer
;	O
do	O
{	O
signed	O
int	O
cmp	int
=	O
rsrc_cmp	function
(	O
is_name	int
,	O
entry	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
entry	pointer
->	O
next_entry	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
next	pointer
->	O
next_entry	pointer
=	O
entry	pointer
;	O
*	O
points_to_entry	pointer
=	O
next	pointer
;	O
points_to_entry	pointer
=	O
&	O
next	pointer
->	O
next_entry	pointer
;	O
next	pointer
=	O
entry	pointer
->	O
next_entry	pointer
;	O
swapped	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
cmp	int
==	O
0	int
)	O
{	O
if	O
(	O
entry	pointer
->	O
is_dir	int
&&	O
next	pointer
->	O
is_dir	int
)	O
{	O
if	O
(	O
!	O
entry	pointer
->	O
is_name	int
&&	O
entry	pointer
->	O
name_id	union
.	O
id	int
==	O
1	int
&&	O
dir	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
!	O
dir	pointer
->	O
entry	pointer
->	O
is_name	int
&&	O
dir	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
==	O
0x18	int
)	O
{	O
if	O
(	O
next	pointer
->	O
value	long
.	O
directory	pointer
->	O
names	struct
.	O
num_entries	int
==	O
0	int
&&	O
next	pointer
->	O
value	long
.	O
directory	pointer
->	O
ids	struct
.	O
num_entries	int
==	O
1	int
&&	O
!	O
next	pointer
->	O
value	long
.	O
directory	pointer
->	O
ids	struct
.	O
first_entry	pointer
->	O
is_name	int
&&	O
next	pointer
->	O
value	long
.	O
directory	pointer
->	O
ids	struct
.	O
first_entry	pointer
->	O
name_id	union
.	O
id	int
==	O
0	int
)	O
;	O
else	O
if	O
(	O
entry	pointer
->	O
value	long
.	O
directory	pointer
->	O
names	struct
.	O
num_entries	int
==	O
0	int
&&	O
entry	pointer
->	O
value	long
.	O
directory	pointer
->	O
ids	struct
.	O
num_entries	int
==	O
1	int
&&	O
!	O
entry	pointer
->	O
value	long
.	O
directory	pointer
->	O
ids	struct
.	O
first_entry	pointer
->	O
is_name	int
&&	O
entry	pointer
->	O
value	long
.	O
directory	pointer
->	O
ids	struct
.	O
first_entry	pointer
->	O
name_id	union
.	O
id	int
==	O
0	int
)	O
{	O
entry	pointer
->	O
next_entry	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
next	pointer
->	O
next_entry	pointer
=	O
entry	pointer
;	O
*	O
points_to_entry	pointer
=	O
next	pointer
;	O
points_to_entry	pointer
=	O
&	O
next	pointer
->	O
next_entry	pointer
;	O
next	pointer
=	O
entry	pointer
->	O
next_entry	pointer
;	O
swapped	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: multiple non-default manifests"	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
;	O
}	O
entry	pointer
->	O
next_entry	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
chain	pointer
->	O
num_entries	int
--	O
;	O
if	O
(	O
chain	pointer
->	O
num_entries	int
<	O
2	int
)	O
return	O
;	O
next	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
}	O
else	O
rsrc_merge	function
(	O
entry	pointer
,	O
next	pointer
)	O
;	O
}	O
else	O
if	O
(	O
entry	pointer
->	O
is_dir	int
!=	O
next	pointer
->	O
is_dir	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: a directory matches a leaf"	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
entry	pointer
->	O
is_name	int
&&	O
entry	pointer
->	O
name_id	union
.	O
id	int
==	O
0	int
&&	O
dir	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
!	O
dir	pointer
->	O
entry	pointer
->	O
is_name	int
&&	O
dir	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
==	O
1	int
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
!	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
is_name	int
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
==	O
0x18	int
)	O
;	O
else	O
if	O
(	O
dir	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
!=	O
NULL	O
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
!=	O
NULL	O
&&	O
!	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
is_name	int
&&	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
->	O
name_id	union
.	O
id	int
==	O
0x6	int
)	O
{	O
if	O
(	O
!	O
rsrc_merge_string_entries	function
(	O
entry	pointer
,	O
next	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
dir	pointer
==	O
NULL	O
||	O
dir	pointer
->	O
entry	pointer
==	O
NULL	O
||	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
==	O
NULL	O
||	O
dir	pointer
->	O
entry	pointer
->	O
parent	pointer
->	O
entry	pointer
==	O
NULL	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: duplicate leaf"	pointer
)	O
)	O
;	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: duplicate leaf: %s"	pointer
)	O
,	O
rsrc_resource_name	function
(	O
entry	pointer
,	O
dir	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
;	O
}	O
}	O
entry	pointer
->	O
next_entry	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
chain	pointer
->	O
num_entries	int
--	O
;	O
if	O
(	O
chain	pointer
->	O
num_entries	int
<	O
2	int
)	O
return	O
;	O
next	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
}	O
else	O
{	O
points_to_entry	pointer
=	O
&	O
entry	pointer
->	O
next_entry	pointer
;	O
entry	pointer
=	O
next	pointer
;	O
next	pointer
=	O
next	pointer
->	O
next_entry	pointer
;	O
}	O
}	O
while	O
(	O
next	pointer
)	O
;	O
chain	pointer
->	O
last_entry	pointer
=	O
entry	pointer
;	O
}	O
while	O
(	O
swapped	int
)	O
;	O
}	O
static	O
void	O
rsrc_attach_chain	function
(	O
rsrc_dir_chain	struct
*	O
achain	pointer
,	O
rsrc_dir_chain	struct
*	O
bchain	pointer
)	O
{	O
if	O
(	O
bchain	pointer
->	O
num_entries	int
==	O
0	int
)	O
return	O
;	O
achain	pointer
->	O
num_entries	int
+=	O
bchain	pointer
->	O
num_entries	int
;	O
if	O
(	O
achain	pointer
->	O
first_entry	pointer
==	O
NULL	O
)	O
{	O
achain	pointer
->	O
first_entry	pointer
=	O
bchain	pointer
->	O
first_entry	pointer
;	O
achain	pointer
->	O
last_entry	pointer
=	O
bchain	pointer
->	O
last_entry	pointer
;	O
}	O
else	O
{	O
achain	pointer
->	O
last_entry	pointer
->	O
next_entry	pointer
=	O
bchain	pointer
->	O
first_entry	pointer
;	O
achain	pointer
->	O
last_entry	pointer
=	O
bchain	pointer
->	O
last_entry	pointer
;	O
}	O
bchain	pointer
->	O
num_entries	int
=	O
0	int
;	O
bchain	pointer
->	O
first_entry	pointer
=	O
bchain	pointer
->	O
last_entry	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
rsrc_merge	function
(	O
struct	O
rsrc_entry	struct
*	O
a	pointer
,	O
struct	O
rsrc_entry	struct
*	O
b	pointer
)	O
{	O
rsrc_directory	struct
*	O
adir	pointer
;	O
rsrc_directory	struct
*	O
bdir	pointer
;	O
BFD_ASSERT	O
(	O
a	pointer
->	O
is_dir	int
)	O
;	O
BFD_ASSERT	O
(	O
b	pointer
->	O
is_dir	int
)	O
;	O
adir	pointer
=	O
a	pointer
->	O
value	long
.	O
directory	pointer
;	O
bdir	pointer
=	O
b	pointer
->	O
value	long
.	O
directory	pointer
;	O
if	O
(	O
adir	pointer
->	O
characteristics	int
!=	O
bdir	pointer
->	O
characteristics	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: dirs with differing characteristics"	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
adir	pointer
->	O
major	int
!=	O
bdir	pointer
->	O
major	int
||	O
adir	pointer
->	O
minor	int
!=	O
bdir	pointer
->	O
minor	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
".rsrc merge failure: differing directory versions"	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
return	O
;	O
}	O
rsrc_attach_chain	function
(	O
&	O
adir	pointer
->	O
names	struct
,	O
&	O
bdir	pointer
->	O
names	struct
)	O
;	O
rsrc_attach_chain	function
(	O
&	O
adir	pointer
->	O
ids	struct
,	O
&	O
bdir	pointer
->	O
ids	struct
)	O
;	O
rsrc_sort_entries	function
(	O
&	O
adir	pointer
->	O
names	struct
,	O
TRUE	int
,	O
adir	pointer
)	O
;	O
rsrc_sort_entries	function
(	O
&	O
adir	pointer
->	O
ids	struct
,	O
FALSE	int
,	O
adir	pointer
)	O
;	O
}	O
static	O
void	O
rsrc_process_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
coff_final_link_info	struct
*	O
pfinfo	pointer
)	O
{	O
rsrc_directory	struct
new_table	struct
;	O
bfd_size_type	long
size	long
;	O
asection	struct
*	O
sec	pointer
;	O
pe_data_type	struct
*	O
pe	struct
;	O
bfd_vma	long
rva_bias	long
;	O
bfd_byte	char
*	O
data	pointer
;	O
bfd_byte	char
*	O
datastart	pointer
;	O
bfd_byte	char
*	O
dataend	pointer
;	O
bfd_byte	char
*	O
new_data	pointer
;	O
unsigned	O
int	O
num_resource_sets	int
;	O
rsrc_directory	struct
*	O
type_tables	pointer
;	O
rsrc_write_data	struct
write_data	struct
;	O
unsigned	O
int	O
indx	long
;	O
bfd	struct
*	O
input	pointer
;	O
unsigned	O
int	O
num_input_rsrc	int
=	O
0	int
;	O
unsigned	O
int	O
max_num_input_rsrc	int
=	O
4	int
;	O
ptrdiff_t	long
*	O
rsrc_sizes	pointer
=	O
NULL	O
;	O
new_table	struct
.	O
names	struct
.	O
num_entries	int
=	O
0	int
;	O
new_table	struct
.	O
ids	struct
.	O
num_entries	int
=	O
0	int
;	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".rsrc"	pointer
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
(	O
size	long
=	O
sec	pointer
->	O
rawsize	long
)	O
==	O
0	int
)	O
return	O
;	O
pe	struct
=	O
pe_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
pe	struct
==	O
NULL	O
)	O
return	O
;	O
rva_bias	long
=	O
sec	pointer
->	O
vma	long
-	O
pe	struct
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
data	pointer
=	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
return	O
;	O
datastart	pointer
=	O
data	pointer
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
data	pointer
,	O
0	int
,	O
size	long
)	O
)	O
goto	O
end	pointer
;	O
rsrc_sizes	pointer
=	O
bfd_malloc	function
(	O
max_num_input_rsrc	int
*	O
sizeof	O
*	O
rsrc_sizes	pointer
)	O
;	O
if	O
(	O
rsrc_sizes	pointer
==	O
NULL	O
)	O
goto	O
end	pointer
;	O
for	O
(	O
input	pointer
=	O
pfinfo	pointer
->	O
info	pointer
->	O
input_bfds	pointer
;	O
input	pointer
!=	O
NULL	O
;	O
input	pointer
=	O
input	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
rsrc_sec	pointer
=	O
bfd_get_section_by_name	function
(	O
input	pointer
,	O
".rsrc"	pointer
)	O
;	O
if	O
(	O
rsrc_sec	pointer
!=	O
NULL	O
&&	O
!	O
discarded_section	function
(	O
rsrc_sec	pointer
)	O
)	O
{	O
if	O
(	O
num_input_rsrc	int
==	O
max_num_input_rsrc	int
)	O
{	O
max_num_input_rsrc	int
+=	O
10	int
;	O
rsrc_sizes	pointer
=	O
bfd_realloc	function
(	O
rsrc_sizes	pointer
,	O
max_num_input_rsrc	int
*	O
sizeof	O
*	O
rsrc_sizes	pointer
)	O
;	O
if	O
(	O
rsrc_sizes	pointer
==	O
NULL	O
)	O
goto	O
end	pointer
;	O
}	O
BFD_ASSERT	O
(	O
rsrc_sec	pointer
->	O
size	long
>	O
0	int
)	O
;	O
rsrc_sizes	pointer
[	O
num_input_rsrc	int
++	O
]	O
=	O
rsrc_sec	pointer
->	O
size	long
;	O
}	O
}	O
if	O
(	O
num_input_rsrc	int
<	O
2	int
)	O
goto	O
end	pointer
;	O
dataend	pointer
=	O
data	pointer
+	O
size	long
;	O
num_resource_sets	int
=	O
0	int
;	O
while	O
(	O
data	pointer
<	O
dataend	pointer
)	O
{	O
bfd_byte	char
*	O
p	pointer
=	O
data	pointer
;	O
data	pointer
=	O
rsrc_count_directory	function
(	O
abfd	pointer
,	O
data	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
)	O
;	O
if	O
(	O
data	pointer
>	O
dataend	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: .rsrc merge failure: corrupt .rsrc section"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
goto	O
end	pointer
;	O
}	O
if	O
(	O
(	O
data	pointer
-	O
p	pointer
)	O
>	O
rsrc_sizes	pointer
[	O
num_resource_sets	int
]	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: .rsrc merge failure: unexpected .rsrc size"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
goto	O
end	pointer
;	O
}	O
data	pointer
=	O
p	pointer
+	O
rsrc_sizes	pointer
[	O
num_resource_sets	int
]	O
;	O
rva_bias	long
+=	O
data	pointer
-	O
p	pointer
;	O
++	O
num_resource_sets	int
;	O
}	O
BFD_ASSERT	O
(	O
num_resource_sets	int
==	O
num_input_rsrc	int
)	O
;	O
data	pointer
=	O
datastart	pointer
;	O
rva_bias	long
=	O
sec	pointer
->	O
vma	long
-	O
pe	struct
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
type_tables	pointer
=	O
bfd_malloc	function
(	O
num_resource_sets	int
*	O
sizeof	O
*	O
type_tables	pointer
)	O
;	O
if	O
(	O
type_tables	pointer
==	O
NULL	O
)	O
goto	O
end	pointer
;	O
indx	long
=	O
0	int
;	O
while	O
(	O
data	pointer
<	O
dataend	pointer
)	O
{	O
bfd_byte	char
*	O
p	pointer
=	O
data	pointer
;	O
(	O
void	O
)	O
rsrc_parse_directory	function
(	O
abfd	pointer
,	O
type_tables	pointer
+	O
indx	long
,	O
data	pointer
,	O
data	pointer
,	O
dataend	pointer
,	O
rva_bias	long
,	O
NULL	O
)	O
;	O
data	pointer
=	O
p	pointer
+	O
rsrc_sizes	pointer
[	O
indx	long
]	O
;	O
rva_bias	long
+=	O
data	pointer
-	O
p	pointer
;	O
++	O
indx	long
;	O
}	O
BFD_ASSERT	O
(	O
indx	long
==	O
num_resource_sets	int
)	O
;	O
new_table	struct
.	O
characteristics	int
=	O
type_tables	pointer
[	O
0	int
]	O
.	O
characteristics	int
;	O
new_table	struct
.	O
time	struct
=	O
type_tables	pointer
[	O
0	int
]	O
.	O
time	struct
;	O
new_table	struct
.	O
major	int
=	O
type_tables	pointer
[	O
0	int
]	O
.	O
major	int
;	O
new_table	struct
.	O
minor	int
=	O
type_tables	pointer
[	O
0	int
]	O
.	O
minor	int
;	O
new_table	struct
.	O
names	struct
.	O
first_entry	pointer
=	O
NULL	O
;	O
new_table	struct
.	O
names	struct
.	O
last_entry	pointer
=	O
NULL	O
;	O
for	O
(	O
indx	long
=	O
0	int
;	O
indx	long
<	O
num_resource_sets	int
;	O
indx	long
++	O
)	O
rsrc_attach_chain	function
(	O
&	O
new_table	struct
.	O
names	struct
,	O
&	O
type_tables	pointer
[	O
indx	long
]	O
.	O
names	struct
)	O
;	O
rsrc_sort_entries	function
(	O
&	O
new_table	struct
.	O
names	struct
,	O
TRUE	int
,	O
&	O
new_table	struct
)	O
;	O
new_table	struct
.	O
ids	struct
.	O
first_entry	pointer
=	O
NULL	O
;	O
new_table	struct
.	O
ids	struct
.	O
last_entry	pointer
=	O
NULL	O
;	O
for	O
(	O
indx	long
=	O
0	int
;	O
indx	long
<	O
num_resource_sets	int
;	O
indx	long
++	O
)	O
rsrc_attach_chain	function
(	O
&	O
new_table	struct
.	O
ids	struct
,	O
&	O
type_tables	pointer
[	O
indx	long
]	O
.	O
ids	struct
)	O
;	O
rsrc_sort_entries	function
(	O
&	O
new_table	struct
.	O
ids	struct
,	O
FALSE	int
,	O
&	O
new_table	struct
)	O
;	O
sizeof_leaves	int
=	O
sizeof_strings	int
=	O
sizeof_tables_and_entries	int
=	O
0	int
;	O
rsrc_compute_region_sizes	function
(	O
&	O
new_table	struct
)	O
;	O
sizeof_strings	int
=	O
(	O
sizeof_strings	int
+	O
7	int
)	O
&	O
~	O
7	int
;	O
new_data	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
size	long
)	O
;	O
if	O
(	O
new_data	pointer
==	O
NULL	O
)	O
goto	O
end	pointer
;	O
write_data	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
write_data	struct
.	O
datastart	pointer
=	O
new_data	pointer
;	O
write_data	struct
.	O
next_table	pointer
=	O
new_data	pointer
;	O
write_data	struct
.	O
next_leaf	pointer
=	O
new_data	pointer
+	O
sizeof_tables_and_entries	int
;	O
write_data	struct
.	O
next_string	pointer
=	O
write_data	struct
.	O
next_leaf	pointer
+	O
sizeof_leaves	int
;	O
write_data	struct
.	O
next_data	pointer
=	O
write_data	struct
.	O
next_string	pointer
+	O
sizeof_strings	int
;	O
write_data	struct
.	O
rva_bias	long
=	O
sec	pointer
->	O
vma	long
-	O
pe	struct
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
rsrc_write_directory	function
(	O
&	O
write_data	struct
,	O
&	O
new_table	struct
)	O
;	O
bfd_set_section_contents	function
(	O
pfinfo	pointer
->	O
output_bfd	pointer
,	O
sec	pointer
,	O
new_data	pointer
,	O
0	int
,	O
size	long
)	O
;	O
sec	pointer
->	O
size	long
=	O
sec	pointer
->	O
rawsize	long
=	O
size	long
;	O
end	pointer
:	O
free	function
(	O
datastart	pointer
)	O
;	O
free	function
(	O
rsrc_sizes	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_pei_final_link_postscript	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
coff_final_link_info	struct
*	O
pfinfo	pointer
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h1	pointer
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
pfinfo	pointer
->	O
info	pointer
;	O
bfd_boolean	int
result	int
=	O
TRUE	int
;	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
".idata$2"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
.	O
VirtualAddress	long
=	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to fill in DataDictionary[1] because .idata$2 is missing"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
".idata$4"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
&&	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
.	O
Size	long
=	O
(	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_TABLE	int
]	O
.	O
VirtualAddress	long
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to fill in DataDictionary[1] because .idata$4 is missing"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
".idata$5"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
&&	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
.	O
VirtualAddress	long
=	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to fill in DataDictionary[12] because .idata$5 is missing"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
".idata$6"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
&&	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
.	O
Size	long
=	O
(	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
.	O
VirtualAddress	long
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE (12)] because .idata$6 is missing"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
"__IAT_start__"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
&&	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
iat_va	long
;	O
iat_va	long
=	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
"__IAT_end__"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
&&	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
.	O
Size	long
=	O
(	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
-	O
iat_va	long
)	O
;	O
if	O
(	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
.	O
Size	long
!=	O
0	int
)	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_IMPORT_ADDRESS_TABLE	int
]	O
.	O
VirtualAddress	long
=	O
iat_va	long
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
}	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE(12)]"	pointer
" because .idata$6 is missing"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
}	O
}	O
h1	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
(	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
!=	O
0	int
?	O
"__tls_used"	pointer
:	O
"_tls_used"	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h1	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h1	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_TLS_TABLE	int
]	O
.	O
VirtualAddress	long
=	O
(	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h1	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to fill in DataDictionary[9] because __tls_used is missing"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
DataDirectory	array
[	O
PE_TLS_TABLE	int
]	O
.	O
Size	long
=	O
0x18	int
;	O
}	O
rsrc_process_section	function
(	O
abfd	pointer
,	O
pfinfo	pointer
)	O
;	O
return	O
result	int
;	O
}	O
