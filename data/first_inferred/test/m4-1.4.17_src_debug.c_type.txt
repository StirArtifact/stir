FILE	struct
*	O
debug	pointer
=	O
NULL	O
;	O
static	O
struct	O
obstack	struct
trace	struct
;	O
static	O
void	O
debug_set_file	function
(	O
FILE	struct
*	O
)	O
;	O
void	O
debug_init	function
(	O
void	O
)	O
{	O
debug_set_file	function
(	O
stderr	pointer
)	O
;	O
obstack_init	O
(	O
&	O
trace	struct
)	O
;	O
}	O
int	O
debug_decode	function
(	O
const	O
char	O
*	O
opts	pointer
)	O
{	O
int	O
level	int
;	O
if	O
(	O
opts	pointer
==	O
NULL	O
||	O
*	O
opts	pointer
==	O
'\0'	O
)	O
level	int
=	O
DEBUG_TRACE_DEFAULT	int
;	O
else	O
{	O
for	O
(	O
level	int
=	O
0	int
;	O
*	O
opts	pointer
;	O
opts	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
opts	pointer
)	O
{	O
case	O
'a'	O
:	O
level	int
|=	O
DEBUG_TRACE_ARGS	int
;	O
break	O
;	O
case	O
'e'	O
:	O
level	int
|=	O
DEBUG_TRACE_EXPANSION	int
;	O
break	O
;	O
case	O
'q'	O
:	O
level	int
|=	O
DEBUG_TRACE_QUOTE	int
;	O
break	O
;	O
case	O
't'	O
:	O
level	int
|=	O
DEBUG_TRACE_ALL	int
;	O
break	O
;	O
case	O
'l'	O
:	O
level	int
|=	O
DEBUG_TRACE_LINE	int
;	O
break	O
;	O
case	O
'f'	O
:	O
level	int
|=	O
DEBUG_TRACE_FILE	int
;	O
break	O
;	O
case	O
'p'	O
:	O
level	int
|=	O
DEBUG_TRACE_PATH	int
;	O
break	O
;	O
case	O
'c'	O
:	O
level	int
|=	O
DEBUG_TRACE_CALL	int
;	O
break	O
;	O
case	O
'i'	O
:	O
level	int
|=	O
DEBUG_TRACE_INPUT	int
;	O
break	O
;	O
case	O
'x'	O
:	O
level	int
|=	O
DEBUG_TRACE_CALLID	int
;	O
break	O
;	O
case	O
'V'	O
:	O
level	int
|=	O
DEBUG_TRACE_VERBOSE	int
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
obstack_free	function
(	O
&	O
trace	struct
,	O
obstack_finish	O
(	O
&	O
trace	struct
)	O
)	O
;	O
return	O
level	int
;	O
}	O
static	O
void	O
debug_set_file	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
struct	O
stat	struct
stdout_stat	struct
,	O
debug_stat	struct
;	O
if	O
(	O
debug	pointer
!=	O
NULL	O
&&	O
debug	pointer
!=	O
stderr	pointer
&&	O
debug	pointer
!=	O
stdout	pointer
&&	O
close_stream	function
(	O
debug	pointer
)	O
!=	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"error writing to debug stream"	pointer
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
debug	pointer
=	O
fp	pointer
;	O
if	O
(	O
debug	pointer
!=	O
NULL	O
&&	O
debug	pointer
!=	O
stdout	pointer
)	O
{	O
if	O
(	O
fstat	function
(	O
STDOUT_FILENO	int
,	O
&	O
stdout_stat	struct
)	O
<	O
0	int
)	O
return	O
;	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
debug	pointer
)	O
,	O
&	O
debug_stat	struct
)	O
<	O
0	int
)	O
return	O
;	O
if	O
(	O
stdout_stat	struct
.	O
st_ino	long
==	O
debug_stat	struct
.	O
st_ino	long
&&	O
stdout_stat	struct
.	O
st_dev	long
==	O
debug_stat	struct
.	O
st_dev	long
&&	O
stdout_stat	struct
.	O
st_ino	long
!=	O
0	int
)	O
{	O
if	O
(	O
debug	pointer
!=	O
stderr	pointer
&&	O
close_stream	function
(	O
debug	pointer
)	O
!=	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"error writing to debug stream"	pointer
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
debug	pointer
=	O
stdout	pointer
;	O
}	O
}	O
}	O
void	O
debug_flush_files	function
(	O
void	O
)	O
{	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
if	O
(	O
debug	pointer
!=	O
NULL	O
&&	O
debug	pointer
!=	O
stdout	pointer
&&	O
debug	pointer
!=	O
stderr	pointer
)	O
fflush	function
(	O
debug	pointer
)	O
;	O
if	O
(	O
lseek	function
(	O
STDIN_FILENO	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
>=	O
0	int
&&	O
fflush	function
(	O
stdin	pointer
)	O
==	O
0	int
)	O
{	O
fseeko	function
(	O
stdin	pointer
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
}	O
}	O
bool	bool
debug_set_output	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
debug_set_file	function
(	O
stderr	pointer
)	O
;	O
else	O
if	O
(	O
*	O
name	pointer
==	O
'\0'	O
)	O
debug_set_file	function
(	O
NULL	O
)	O
;	O
else	O
{	O
fp	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"a"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
if	O
(	O
set_cloexec_flag	function
(	O
fileno	function
(	O
fp	pointer
)	O
,	O
true	int
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"Warning: cannot protect debug file across forks"	pointer
)	O
)	O
;	O
debug_set_file	function
(	O
fp	pointer
)	O
;	O
}	O
return	O
true	int
;	O
}	O
void	O
debug_message_prefix	function
(	O
void	O
)	O
{	O
xfprintf	function
(	O
debug	pointer
,	O
"m4debug:"	pointer
)	O
;	O
if	O
(	O
current_line	int
)	O
{	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_FILE	int
)	O
xfprintf	function
(	O
debug	pointer
,	O
"%s:"	pointer
,	O
current_file	pointer
)	O
;	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_LINE	int
)	O
xfprintf	function
(	O
debug	pointer
,	O
"%d:"	pointer
,	O
current_line	int
)	O
;	O
}	O
putc	function
(	O
' '	O
,	O
debug	pointer
)	O
;	O
}	O
static	O
void	O
trace_format	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
ch	char
;	O
int	O
d	int
;	O
const	O
char	O
*	O
s	long
;	O
int	O
slen	int
;	O
int	O
maxlen	int
;	O
va_start	O
(	O
args	array
,	O
fmt	pointer
)	O
;	O
while	O
(	O
true	int
)	O
{	O
while	O
(	O
(	O
ch	char
=	O
*	O
fmt	pointer
++	O
)	O
!=	O
'\0'	O
&&	O
ch	char
!=	O
'%'	O
)	O
obstack_1grow	O
(	O
&	O
trace	struct
,	O
ch	char
)	O
;	O
if	O
(	O
ch	char
==	O
'\0'	O
)	O
break	O
;	O
maxlen	int
=	O
0	int
;	O
switch	O
(	O
*	O
fmt	pointer
++	O
)	O
{	O
case	O
'S'	O
:	O
maxlen	int
=	O
max_debug_argument_length	int
;	O
case	O
's'	O
:	O
s	long
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
s	long
=	O
(	O
debug_level	int
&	O
DEBUG_TRACE_QUOTE	int
)	O
?	O
lquote	struct
.	O
string	struct
:	O
""	pointer
;	O
break	O
;	O
case	O
'r'	O
:	O
s	long
=	O
(	O
debug_level	int
&	O
DEBUG_TRACE_QUOTE	int
)	O
?	O
rquote	struct
.	O
string	struct
:	O
""	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
d	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
s	long
=	O
ntoa	function
(	O
d	int
,	O
10	int
)	O
;	O
break	O
;	O
default	O
:	O
s	long
=	O
""	pointer
;	O
break	O
;	O
}	O
slen	int
=	O
strlen	function
(	O
s	long
)	O
;	O
if	O
(	O
maxlen	int
==	O
0	int
||	O
maxlen	int
>	O
slen	int
)	O
obstack_grow	O
(	O
&	O
trace	struct
,	O
s	long
,	O
slen	int
)	O
;	O
else	O
{	O
obstack_grow	O
(	O
&	O
trace	struct
,	O
s	long
,	O
maxlen	int
)	O
;	O
obstack_grow	O
(	O
&	O
trace	struct
,	O
"..."	pointer
,	O
3	int
)	O
;	O
}	O
}	O
va_end	O
(	O
args	array
)	O
;	O
}	O
static	O
void	O
trace_header	function
(	O
int	O
id	int
)	O
{	O
trace_format	function
(	O
"m4trace:"	pointer
)	O
;	O
if	O
(	O
current_line	int
)	O
{	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_FILE	int
)	O
trace_format	function
(	O
"%s:"	pointer
,	O
current_file	pointer
)	O
;	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_LINE	int
)	O
trace_format	function
(	O
"%d:"	pointer
,	O
current_line	int
)	O
;	O
}	O
trace_format	function
(	O
" -%d- "	pointer
,	O
expansion_level	int
)	O
;	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_CALLID	int
)	O
trace_format	function
(	O
"id %d: "	pointer
,	O
id	int
)	O
;	O
}	O
static	O
void	O
trace_flush	function
(	O
void	O
)	O
{	O
char	O
*	O
line	pointer
;	O
obstack_1grow	O
(	O
&	O
trace	struct
,	O
'\0'	O
)	O
;	O
line	pointer
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
trace	struct
)	O
;	O
DEBUG_PRINT1	O
(	O
"%s\n"	pointer
,	O
line	pointer
)	O
;	O
obstack_free	function
(	O
&	O
trace	struct
,	O
line	pointer
)	O
;	O
}	O
void	O
trace_prepre	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
id	int
)	O
{	O
trace_header	function
(	O
id	int
)	O
;	O
trace_format	function
(	O
"%s ..."	pointer
,	O
name	pointer
)	O
;	O
trace_flush	function
(	O
)	O
;	O
}	O
void	O
trace_pre	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
id	int
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
const	O
builtin	struct
*	O
bp	pointer
;	O
trace_header	function
(	O
id	int
)	O
;	O
trace_format	function
(	O
"%s"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
argc	int
>	O
1	int
&&	O
(	O
debug_level	int
&	O
DEBUG_TRACE_ARGS	int
)	O
)	O
{	O
trace_format	function
(	O
"("	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
!=	O
1	int
)	O
trace_format	function
(	O
", "	pointer
)	O
;	O
switch	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
trace_format	function
(	O
"%l%S%r"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	pointer
=	O
find_builtin_by_addr	function
(	O
TOKEN_DATA_FUNC	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
bp	pointer
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: builtin not found in builtin table! (trace_pre ())"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
trace_format	function
(	O
"<%s>"	pointer
,	O
bp	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type (trace_pre ())"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
trace_format	function
(	O
")"	pointer
)	O
;	O
}	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_CALL	int
)	O
{	O
trace_format	function
(	O
" -> ???"	pointer
)	O
;	O
trace_flush	function
(	O
)	O
;	O
}	O
}	O
void	O
trace_post	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
id	int
,	O
int	O
argc	int
,	O
const	O
char	O
*	O
expanded	pointer
)	O
{	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_CALL	int
)	O
{	O
trace_header	function
(	O
id	int
)	O
;	O
trace_format	function
(	O
"%s%s"	pointer
,	O
name	pointer
,	O
(	O
argc	int
>	O
1	int
)	O
?	O
"(...)"	pointer
:	O
""	pointer
)	O
;	O
}	O
if	O
(	O
expanded	pointer
&&	O
(	O
debug_level	int
&	O
DEBUG_TRACE_EXPANSION	int
)	O
)	O
trace_format	function
(	O
" -> %l%S%r"	pointer
,	O
expanded	pointer
)	O
;	O
trace_flush	function
(	O
)	O
;	O
}	O