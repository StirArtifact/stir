void	O
vfinfo	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
,	O
bfd_boolean	int
is_warning	int
)	O
{	O
bfd_boolean	int
fatal	int
=	O
FALSE	int
;	O
const	O
char	O
*	O
scan	pointer
;	O
int	O
arg_type	int
;	O
unsigned	O
int	O
arg_count	int
=	O
0	int
;	O
unsigned	O
int	O
arg_no	int
;	O
union	O
vfinfo_args	union
{	O
int	O
i	pointer
;	O
long	O
l	long
;	O
void	O
*	O
p	pointer
;	O
bfd_vma	long
v	long
;	O
struct	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
bfd_vma	long
off	long
;	O
}	O
reladdr	struct
;	O
enum	O
{	O
Bad	int
,	O
Int	int
,	O
Long	int
,	O
Ptr	int
,	O
Vma	int
,	O
RelAddr	int
}	O
type	enum
;	O
}	O
args	int
[	O
9	int
]	O
;	O
for	O
(	O
arg_no	int
=	O
0	int
;	O
arg_no	int
<	O
sizeof	O
(	O
args	int
)	O
/	O
sizeof	O
(	O
args	int
[	O
0	int
]	O
)	O
;	O
arg_no	int
++	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
type	enum
=	O
Bad	int
;	O
arg_count	int
=	O
0	int
;	O
scan	pointer
=	O
fmt	pointer
;	O
while	O
(	O
*	O
scan	pointer
!=	O
'\0'	O
)	O
{	O
while	O
(	O
*	O
scan	pointer
!=	O
'%'	O
&&	O
*	O
scan	pointer
!=	O
'\0'	O
)	O
scan	pointer
++	O
;	O
if	O
(	O
*	O
scan	pointer
==	O
'%'	O
)	O
{	O
scan	pointer
++	O
;	O
arg_no	int
=	O
arg_count	int
;	O
if	O
(	O
*	O
scan	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
scan	pointer
)	O
&&	O
scan	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_no	int
=	O
*	O
scan	pointer
-	O
'1'	O
;	O
scan	pointer
+=	O
2	int
;	O
}	O
arg_type	int
=	O
Bad	int
;	O
switch	O
(	O
*	O
scan	pointer
++	O
)	O
{	O
case	O
'\0'	O
:	O
--	O
scan	pointer
;	O
break	O
;	O
case	O
'V'	O
:	O
case	O
'v'	O
:	O
case	O
'W'	O
:	O
arg_type	int
=	O
Vma	int
;	O
break	O
;	O
case	O
's'	O
:	O
arg_type	int
=	O
Ptr	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
scan	pointer
==	O
'A'	O
||	O
*	O
scan	pointer
==	O
'B'	O
||	O
*	O
scan	pointer
==	O
'I'	O
||	O
*	O
scan	pointer
==	O
'R'	O
||	O
*	O
scan	pointer
==	O
'S'	O
||	O
*	O
scan	pointer
==	O
'T'	O
)	O
scan	pointer
++	O
;	O
arg_type	int
=	O
Ptr	int
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
arg_type	int
=	O
RelAddr	int
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'u'	O
:	O
arg_type	int
=	O
Int	int
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
*	O
scan	pointer
==	O
'd'	O
||	O
*	O
scan	pointer
==	O
'u'	O
)	O
{	O
++	O
scan	pointer
;	O
arg_type	int
=	O
Long	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
arg_type	int
!=	O
Bad	int
)	O
{	O
if	O
(	O
arg_no	int
>=	O
sizeof	O
(	O
args	int
)	O
/	O
sizeof	O
(	O
args	int
[	O
0	int
]	O
)	O
)	O
abort	function
(	O
)	O
;	O
args	int
[	O
arg_no	int
]	O
.	O
type	enum
=	O
arg_type	int
;	O
++	O
arg_count	int
;	O
}	O
}	O
}	O
for	O
(	O
arg_no	int
=	O
0	int
;	O
arg_no	int
<	O
arg_count	int
;	O
arg_no	int
++	O
)	O
{	O
switch	O
(	O
args	int
[	O
arg_no	int
]	O
.	O
type	enum
)	O
{	O
case	O
Int	int
:	O
args	int
[	O
arg_no	int
]	O
.	O
i	pointer
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
Long	int
:	O
args	int
[	O
arg_no	int
]	O
.	O
l	long
=	O
va_arg	O
(	O
ap	array
,	O
long	O
)	O
;	O
break	O
;	O
case	O
Ptr	int
:	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
Vma	int
:	O
args	int
[	O
arg_no	int
]	O
.	O
v	long
=	O
va_arg	O
(	O
ap	array
,	O
bfd_vma	long
)	O
;	O
break	O
;	O
case	O
RelAddr	int
:	O
args	int
[	O
arg_no	int
]	O
.	O
reladdr	struct
.	O
abfd	pointer
=	O
va_arg	O
(	O
ap	array
,	O
bfd	struct
*	O
)	O
;	O
args	int
[	O
arg_no	int
]	O
.	O
reladdr	struct
.	O
sec	pointer
=	O
va_arg	O
(	O
ap	array
,	O
asection	struct
*	O
)	O
;	O
args	int
[	O
arg_no	int
]	O
.	O
reladdr	struct
.	O
off	long
=	O
va_arg	O
(	O
ap	array
,	O
bfd_vma	long
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
arg_count	int
=	O
0	int
;	O
while	O
(	O
*	O
fmt	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
fmt	pointer
;	O
while	O
(	O
*	O
fmt	pointer
!=	O
'%'	O
&&	O
*	O
fmt	pointer
!=	O
'\0'	O
)	O
fmt	pointer
++	O
;	O
if	O
(	O
fmt	pointer
!=	O
str	pointer
)	O
if	O
(	O
fwrite	function
(	O
str	pointer
,	O
1	int
,	O
fmt	pointer
-	O
str	pointer
,	O
fp	pointer
)	O
)	O
{	O
}	O
if	O
(	O
*	O
fmt	pointer
==	O
'%'	O
)	O
{	O
fmt	pointer
++	O
;	O
arg_no	int
=	O
arg_count	int
;	O
if	O
(	O
*	O
fmt	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
fmt	pointer
)	O
&&	O
fmt	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_no	int
=	O
*	O
fmt	pointer
-	O
'1'	O
;	O
fmt	pointer
+=	O
2	int
;	O
}	O
switch	O
(	O
*	O
fmt	pointer
++	O
)	O
{	O
case	O
'\0'	O
:	O
--	O
fmt	pointer
;	O
case	O
'%'	O
:	O
putc	function
(	O
'%'	O
,	O
fp	pointer
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
config	struct
.	O
make_executable	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'V'	O
:	O
{	O
bfd_vma	long
value	long
=	O
args	int
[	O
arg_no	int
]	O
.	O
v	long
;	O
++	O
arg_count	int
;	O
fprintf_vma	O
(	O
fp	pointer
,	O
value	long
)	O
;	O
}	O
break	O
;	O
case	O
'v'	O
:	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
bfd_vma	long
value	long
=	O
args	int
[	O
arg_no	int
]	O
.	O
v	long
;	O
++	O
arg_count	int
;	O
sprintf_vma	O
(	O
p	pointer
,	O
value	long
)	O
;	O
while	O
(	O
*	O
p	pointer
==	O
'0'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
p	pointer
--	O
;	O
fputs	function
(	O
p	pointer
,	O
fp	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'W'	O
:	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
bfd_vma	long
value	long
;	O
char	O
*	O
p	pointer
;	O
int	O
len	long
;	O
value	long
=	O
args	int
[	O
arg_no	int
]	O
.	O
v	long
;	O
++	O
arg_count	int
;	O
sprintf_vma	O
(	O
buf	pointer
,	O
value	long
)	O
;	O
for	O
(	O
p	pointer
=	O
buf	pointer
;	O
*	O
p	pointer
==	O
'0'	O
;	O
++	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
--	O
p	pointer
;	O
len	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
while	O
(	O
len	long
<	O
8	int
)	O
{	O
putc	function
(	O
' '	O
,	O
fp	pointer
)	O
;	O
++	O
len	long
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"0x%s"	pointer
,	O
p	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
fatal	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'P'	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
program_name	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
{	O
static	O
bfd	struct
*	O
last_bfd	pointer
;	O
static	O
char	O
*	O
last_file	pointer
;	O
static	O
char	O
*	O
last_function	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
asection	struct
*	O
section	pointer
;	O
bfd_vma	long
offset	long
;	O
asymbol	struct
*	O
*	O
asymbols	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
char	O
*	O
functionname	pointer
;	O
unsigned	O
int	O
linenumber	int
;	O
bfd_boolean	int
discard_last	int
;	O
bfd_boolean	int
done	int
;	O
bfd_error_type	enum
last_bfd_error	enum
=	O
bfd_get_error	function
(	O
)	O
;	O
abfd	pointer
=	O
args	int
[	O
arg_no	int
]	O
.	O
reladdr	struct
.	O
abfd	pointer
;	O
section	pointer
=	O
args	int
[	O
arg_no	int
]	O
.	O
reladdr	struct
.	O
sec	pointer
;	O
offset	long
=	O
args	int
[	O
arg_no	int
]	O
.	O
reladdr	struct
.	O
off	long
;	O
++	O
arg_count	int
;	O
if	O
(	O
abfd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
bfd_generic_link_read_symbols	function
(	O
abfd	pointer
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: could not read symbols: %E\n"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
asymbols	pointer
=	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
;	O
}	O
discard_last	int
=	O
TRUE	int
;	O
if	O
(	O
abfd	pointer
!=	O
NULL	O
&&	O
bfd_find_nearest_line	O
(	O
abfd	pointer
,	O
section	pointer
,	O
asymbols	pointer
,	O
offset	long
,	O
&	O
filename	pointer
,	O
&	O
functionname	pointer
,	O
&	O
linenumber	int
)	O
)	O
{	O
if	O
(	O
functionname	pointer
!=	O
NULL	O
&&	O
(	O
fmt	pointer
[	O
-	O
1	int
]	O
==	O
'C'	O
||	O
fmt	pointer
[	O
-	O
1	int
]	O
==	O
'H'	O
)	O
)	O
{	O
if	O
(	O
last_bfd	pointer
==	O
NULL	O
||	O
last_function	pointer
==	O
NULL	O
||	O
last_bfd	pointer
!=	O
abfd	pointer
||	O
(	O
last_file	pointer
==	O
NULL	O
)	O
!=	O
(	O
filename	pointer
==	O
NULL	O
)	O
||	O
(	O
filename	pointer
!=	O
NULL	O
&&	O
filename_cmp	function
(	O
last_file	pointer
,	O
filename	pointer
)	O
!=	O
0	int
)	O
||	O
strcmp	function
(	O
last_function	pointer
,	O
functionname	pointer
)	O
!=	O
0	int
)	O
{	O
lfinfo	function
(	O
fp	pointer
,	O
_	O
(	O
"%pB: in function `%pT':\n"	pointer
)	O
,	O
abfd	pointer
,	O
functionname	pointer
)	O
;	O
last_bfd	pointer
=	O
abfd	pointer
;	O
if	O
(	O
last_file	pointer
!=	O
NULL	O
)	O
free	function
(	O
last_file	pointer
)	O
;	O
last_file	pointer
=	O
NULL	O
;	O
if	O
(	O
filename	pointer
)	O
last_file	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
last_function	pointer
!=	O
NULL	O
)	O
free	function
(	O
last_function	pointer
)	O
;	O
last_function	pointer
=	O
xstrdup	function
(	O
functionname	pointer
)	O
;	O
}	O
discard_last	int
=	O
FALSE	int
;	O
}	O
else	O
lfinfo	function
(	O
fp	pointer
,	O
"%pB:"	pointer
,	O
abfd	pointer
)	O
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s:"	pointer
,	O
filename	pointer
)	O
;	O
done	int
=	O
fmt	pointer
[	O
-	O
1	int
]	O
!=	O
'H'	O
;	O
if	O
(	O
functionname	pointer
!=	O
NULL	O
&&	O
fmt	pointer
[	O
-	O
1	int
]	O
==	O
'G'	O
)	O
lfinfo	function
(	O
fp	pointer
,	O
"%pT"	pointer
,	O
functionname	pointer
)	O
;	O
else	O
if	O
(	O
filename	pointer
!=	O
NULL	O
&&	O
linenumber	int
!=	O
0	int
)	O
fprintf	function
(	O
fp	pointer
,	O
"%u%s"	pointer
,	O
linenumber	int
,	O
done	int
?	O
""	pointer
:	O
":"	pointer
)	O
;	O
else	O
done	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
lfinfo	function
(	O
fp	pointer
,	O
"%pB:"	pointer
,	O
abfd	pointer
)	O
;	O
done	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
done	int
)	O
lfinfo	function
(	O
fp	pointer
,	O
"(%pA+0x%v)"	pointer
,	O
section	pointer
,	O
offset	long
)	O
;	O
bfd_set_error	function
(	O
last_bfd_error	enum
)	O
;	O
if	O
(	O
discard_last	int
)	O
{	O
last_bfd	pointer
=	O
NULL	O
;	O
if	O
(	O
last_file	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
last_file	pointer
)	O
;	O
last_file	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
last_function	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
last_function	pointer
)	O
;	O
last_function	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
fmt	pointer
==	O
'A'	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
fmt	pointer
++	O
;	O
sec	pointer
=	O
(	O
asection	struct
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
++	O
arg_count	int
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
sec	pointer
->	O
name	pointer
)	O
;	O
abfd	pointer
=	O
sec	pointer
->	O
owner	pointer
;	O
if	O
(	O
abfd	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
group	pointer
=	O
bfd_group_name	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
group	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"[%s]"	pointer
,	O
group	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'B'	O
)	O
{	O
bfd	struct
*	O
abfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
fmt	pointer
++	O
;	O
++	O
arg_count	int
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s generated"	pointer
,	O
program_name	pointer
)	O
;	O
else	O
if	O
(	O
abfd	pointer
->	O
my_archive	pointer
!=	O
NULL	O
&&	O
!	O
bfd_is_thin_archive	function
(	O
abfd	pointer
->	O
my_archive	pointer
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s(%s)"	pointer
,	O
abfd	pointer
->	O
my_archive	pointer
->	O
filename	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
else	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'I'	O
)	O
{	O
lang_input_statement_type	struct
*	O
i	pointer
;	O
fmt	pointer
++	O
;	O
i	pointer
=	O
(	O
lang_input_statement_type	struct
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
++	O
arg_count	int
;	O
if	O
(	O
i	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
&&	O
i	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
!=	O
NULL	O
&&	O
!	O
bfd_is_thin_archive	function
(	O
i	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"(%s)%s"	pointer
,	O
i	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
->	O
filename	pointer
,	O
i	pointer
->	O
local_sym_name	pointer
)	O
;	O
else	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
i	pointer
->	O
filename	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'R'	O
)	O
{	O
arelent	struct
*	O
relent	struct
=	O
(	O
arelent	struct
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
fmt	pointer
++	O
;	O
++	O
arg_count	int
;	O
lfinfo	function
(	O
fp	pointer
,	O
"%s+0x%v (type %s)"	pointer
,	O
(	O
*	O
(	O
relent	struct
->	O
sym_ptr_ptr	pointer
)	O
)	O
->	O
name	pointer
,	O
relent	struct
->	O
addend	long
,	O
relent	struct
->	O
howto	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'S'	O
)	O
{	O
etree_type	union
node	union
;	O
etree_type	union
*	O
tp	pointer
=	O
(	O
etree_type	union
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
fmt	pointer
++	O
;	O
++	O
arg_count	int
;	O
if	O
(	O
tp	pointer
==	O
NULL	O
)	O
{	O
tp	pointer
=	O
&	O
node	union
;	O
tp	pointer
->	O
type	enum
.	O
filename	pointer
=	O
ldlex_filename	function
(	O
)	O
;	O
tp	pointer
->	O
type	enum
.	O
lineno	pointer
=	O
lineno	pointer
;	O
}	O
if	O
(	O
tp	pointer
->	O
type	enum
.	O
filename	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s:%u"	pointer
,	O
tp	pointer
->	O
type	enum
.	O
filename	pointer
,	O
tp	pointer
->	O
type	enum
.	O
lineno	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'T'	O
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
fmt	pointer
++	O
;	O
++	O
arg_count	int
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
*	O
name	pointer
==	O
0	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"no symbol"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
demangling	int
)	O
{	O
char	O
*	O
demangled	pointer
;	O
demangled	pointer
=	O
bfd_demangle	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
name	pointer
,	O
DMGL_ANSI	O
|	O
DMGL_PARAMS	O
)	O
;	O
if	O
(	O
demangled	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
demangled	pointer
)	O
;	O
free	function
(	O
demangled	pointer
)	O
;	O
break	O
;	O
}	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%p"	pointer
,	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
)	O
;	O
++	O
arg_count	int
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
(	O
char	O
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
)	O
;	O
++	O
arg_count	int
;	O
break	O
;	O
case	O
'd'	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%d"	pointer
,	O
args	int
[	O
arg_no	int
]	O
.	O
i	pointer
)	O
;	O
++	O
arg_count	int
;	O
break	O
;	O
case	O
'u'	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%u"	pointer
,	O
args	int
[	O
arg_no	int
]	O
.	O
i	pointer
)	O
;	O
++	O
arg_count	int
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
*	O
fmt	pointer
==	O
'd'	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%ld"	pointer
,	O
args	int
[	O
arg_no	int
]	O
.	O
l	long
)	O
;	O
++	O
arg_count	int
;	O
++	O
fmt	pointer
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'u'	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%lu"	pointer
,	O
args	int
[	O
arg_no	int
]	O
.	O
l	long
)	O
;	O
++	O
arg_count	int
;	O
++	O
fmt	pointer
;	O
break	O
;	O
}	O
default	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%%%c"	pointer
,	O
fmt	pointer
[	O
-	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
is_warning	int
&&	O
config	struct
.	O
fatal_warnings	int
)	O
config	struct
.	O
make_executable	int
=	O
FALSE	int
;	O
if	O
(	O
fatal	int
)	O
xexit	function
(	O
1	int
)	O
;	O
}	O
void	O
info_msg	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
arg	pointer
;	O
va_start	O
(	O
arg	pointer
,	O
fmt	pointer
)	O
;	O
vfinfo	function
(	O
stdout	pointer
,	O
fmt	pointer
,	O
arg	pointer
,	O
FALSE	int
)	O
;	O
va_end	O
(	O
arg	pointer
)	O
;	O
}	O
void	O
einfo	pointer
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
arg	pointer
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
va_start	O
(	O
arg	pointer
,	O
fmt	pointer
)	O
;	O
vfinfo	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
arg	pointer
,	O
TRUE	int
)	O
;	O
va_end	O
(	O
arg	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
void	O
info_assert	function
(	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
int	O
line	pointer
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: internal error %s %d\n"	pointer
)	O
,	O
file	pointer
,	O
line	pointer
)	O
;	O
}	O
void	O
minfo	pointer
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
config	struct
.	O
map_file	pointer
!=	O
NULL	O
)	O
{	O
va_list	array
arg	pointer
;	O
va_start	O
(	O
arg	pointer
,	O
fmt	pointer
)	O
;	O
if	O
(	O
fmt	pointer
[	O
0	int
]	O
==	O
'%'	O
&&	O
fmt	pointer
[	O
1	int
]	O
==	O
'!'	O
&&	O
fmt	pointer
[	O
2	int
]	O
==	O
0	int
)	O
{	O
struct	O
asneeded_minfo	struct
*	O
m	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
m	pointer
)	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
soname	pointer
=	O
va_arg	O
(	O
arg	pointer
,	O
const	O
char	O
*	O
)	O
;	O
m	pointer
->	O
ref	pointer
=	O
va_arg	O
(	O
arg	pointer
,	O
bfd	struct
*	O
)	O
;	O
m	pointer
->	O
name	pointer
=	O
va_arg	O
(	O
arg	pointer
,	O
const	O
char	O
*	O
)	O
;	O
*	O
asneeded_list_tail	pointer
=	O
m	pointer
;	O
asneeded_list_tail	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
else	O
vfinfo	function
(	O
config	struct
.	O
map_file	pointer
,	O
fmt	pointer
,	O
arg	pointer
,	O
FALSE	int
)	O
;	O
va_end	O
(	O
arg	pointer
)	O
;	O
}	O
}	O
void	O
lfinfo	function
(	O
FILE	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
arg	pointer
;	O
va_start	O
(	O
arg	pointer
,	O
fmt	pointer
)	O
;	O
vfinfo	function
(	O
file	pointer
,	O
fmt	pointer
,	O
arg	pointer
,	O
FALSE	int
)	O
;	O
va_end	O
(	O
arg	pointer
)	O
;	O
}	O
void	O
print_space	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
" "	pointer
)	O
;	O
}	O
void	O
print_nl	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
ld_abort	function
(	O
const	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
const	O
char	O
*	O
fn	pointer
)	O
{	O
if	O
(	O
fn	pointer
!=	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%P: internal error: aborting at %s:%d in %s\n"	pointer
)	O
,	O
file	pointer
,	O
line	pointer
,	O
fn	pointer
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%P: internal error: aborting at %s:%d\n"	pointer
)	O
,	O
file	pointer
,	O
line	pointer
)	O
;	O
einfo	pointer
(	O
_	O
(	O
"%F%P: please report this bug\n"	pointer
)	O
)	O
;	O
xexit	function
(	O
1	int
)	O
;	O
}	O