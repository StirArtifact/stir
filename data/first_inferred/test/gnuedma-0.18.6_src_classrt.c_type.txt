CLASSID	long
EDMAPROC	O
_edma_get_local_class_id	function
(	O
)	O
{	O
ESint32	long
i	long
,	O
j	long
,	O
n	long
,	O
ret	long
;	O
HMEM	long
h	long
;	O
j	long
=	O
0	int
;	O
n	long
=	O
MAX_CLASE	int
+	O
nLocalClasses	long
;	O
for	O
(	O
i	long
=	O
MAX_CLASE	int
;	O
j	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
MAX_CLASE	int
+	O
nMaxLocalClasses	long
)	O
{	O
edma_printf	function
(	O
"[%s] Resizing of local class pool still not implemented"	pointer
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
h	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
CLASE	struct
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_local_class_id] Can't alloc memory "	pointer
"for new local class"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gClass	O
[	O
i	long
]	O
=	O
edma_pget	function
(	O
h	long
)	O
;	O
memset	function
(	O
gClass	O
[	O
i	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
CLASE	struct
)	O
)	O
;	O
ProcMapTable	pointer
[	O
i	long
]	O
=	O
CLASS_TEMP	int
;	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
=	O
CLASS_TEMP	int
;	O
gClass	O
[	O
i	long
]	O
->	O
repo_type	char
=	O
EDMA_LOCAL_REPO	int
;	O
gClass	O
[	O
i	long
]	O
->	O
repo_id	long
=	O
-	O
1	int
;	O
gClass	O
[	O
i	long
]	O
->	O
CurrentVer	long
=	O
i	long
;	O
if	O
(	O
(	O
ret	long
=	O
_edma_class_alloc_priv_data	function
(	O
i	long
)	O
)	O
<	O
0	int
)	O
{	O
edma_pfree	function
(	O
h	long
,	O
gClass	O
[	O
i	long
]	O
)	O
;	O
ProcMapTable	pointer
[	O
i	long
]	O
=	O
CLASS_FREE	int
;	O
return	O
ret	long
;	O
}	O
pClass	pointer
[	O
i	long
]	O
->	O
SysClass	struct
.	O
MySelf	long
=	O
h	long
;	O
gClass	O
[	O
i	long
]	O
->	O
SIUProxy	long
=	O
-	O
1	int
;	O
gClass	O
[	O
i	long
]	O
->	O
IDFParser	long
=	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_property	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
prop_name	pointer
,	O
EUint32	long
type	long
,	O
ESint32	long
access	function
,	O
EUint32	long
nelems	long
)	O
{	O
ESint32	long
n	long
,	O
indx	long
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_method] Invalid Class "	pointer
"Identifier [%d]"	pointer
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
prop_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ProcMapTable	pointer
[	O
class_id	long
]	O
!=	O
CLASS_TEMP	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_property] Class %d "	pointer
"not in definition state"	pointer
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_get_prop_indx	function
(	O
class_id	long
,	O
prop_name	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_set_property] Property '%s' "	pointer
"already defined"	pointer
,	O
prop_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
indx	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
;	O
n	long
++	O
;	O
if	O
(	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hProp	long
=	O
edma_prealloc	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hProp	long
,	O
sizeof	O
(	O
PROP	struct
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_property] Can't alloc memory for "	pointer
" property '%s'"	pointer
,	O
prop_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
=	O
edma_pget	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hProp	long
)	O
;	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
IdProp	array
,	O
prop_name	pointer
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Tipo	long
=	O
type	long
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
ioTipo	char
=	O
access	function
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
nElem	long
=	O
nelems	long
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Off	short
=	O
gClass	O
[	O
class_id	long
]	O
->	O
TamDatos	long
;	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
++	O
;	O
gClass	O
[	O
class_id	long
]	O
->	O
TamDatos	long
+=	O
edma_get_type_size	function
(	O
type	long
)	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_method	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
met_name	pointer
,	O
EPChar	pointer
met_sig	pointer
,	O
PPROC	pointer
*	O
f	pointer
,	O
ESint32	long
mvirtual	long
,	O
ESint32	long
mstatic	long
,	O
ESint32	long
mabstract	long
)	O
{	O
ESint32	long
n	long
,	O
indx	long
;	O
PROCMET	struct
aux	struct
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_method] Invalid "	pointer
"Class Identifier [%d]"	pointer
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
met_name	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_local_class_add_method] Invalid "	pointer
"method name"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
met_sig	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_local_class_add_method] Invalid "	pointer
"method signature"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_local_class_add_method] Invalid function"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ProcMapTable	pointer
[	O
class_id	long
]	O
!=	O
CLASS_TEMP	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_method] Class %d "	pointer
"not in definition state"	pointer
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_get_met_indx	function
(	O
class_id	long
,	O
met_name	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_method] Method '%s:%s' "	pointer
"already defined"	pointer
,	O
met_name	pointer
,	O
met_sig	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
indx	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
n	long
++	O
;	O
if	O
(	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hMet	long
=	O
edma_prealloc	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hMet	long
,	O
sizeof	O
(	O
MET	struct
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_method] Can't alloc memory "	pointer
"for method '%s:%s'"	pointer
,	O
met_name	pointer
,	O
met_sig	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hMetFunc	long
=	O
edma_prealloc	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hMetFunc	long
,	O
sizeof	O
(	O
PROCMET	struct
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_method] Can't alloc memory "	pointer
"for method '%s:%s'"	pointer
,	O
met_name	pointer
,	O
met_sig	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
=	O
edma_pget	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hMet	long
)	O
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
met_func	pointer
=	O
edma_pget	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hMetFunc	long
)	O
;	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
IdMet	array
,	O
met_name	pointer
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Sign	array
,	O
met_sig	pointer
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Virtual	char
=	O
mvirtual	long
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Abstract	char
=	O
mabstract	long
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Static	char
=	O
mstatic	long
;	O
aux	struct
.	O
Func	pointer
=	O
f	pointer
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
met_func	pointer
[	O
indx	long
]	O
=	O
aux	struct
;	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
++	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_superclass	function
(	O
CLASSID	long
class_id	long
,	O
CLASSID	long
superclass_id	long
,	O
EPChar	pointer
pap	pointer
,	O
EPChar	pointer
pap1	pointer
)	O
{	O
ESint32	long
n	long
,	O
indx	long
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_add_local_class_superclass] Invalid "	pointer
"Class Identifier [%d]"	pointer
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pap	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_add_local_class_superclass] Invalid "	pointer
"first preferer anchor point"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pap1	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_add_local_class_superclass] Invalid "	pointer
"second preferer anchor point"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
indx	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
;	O
n	long
++	O
;	O
if	O
(	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSCList	long
=	O
edma_prealloc	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSCList	long
,	O
sizeof	O
(	O
CLASSID	long
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_superclass] Can't alloc "	pointer
"memory for superclass %d:'%s'"	pointer
,	O
class_id	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSCIdList	long
=	O
edma_prealloc	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSCIdList	long
,	O
n	long
*	O
sizeof	O
(	O
ID	array
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_superclass] Can't alloc "	pointer
"memory for superclass %d:'%s'"	pointer
,	O
class_id	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSubCIdList	long
=	O
edma_prealloc	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSubCIdList	long
,	O
n	long
*	O
sizeof	O
(	O
ID	array
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_superclass] Can't alloc memory "	pointer
"for superclass %d:'%s'"	pointer
,	O
class_id	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCList	pointer
=	O
edma_pget	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSCList	long
)	O
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCIdList	pointer
=	O
edma_pget	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSCIdList	long
)	O
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SubCIdList	pointer
=	O
edma_pget	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
hSubCIdList	long
)	O
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCList	pointer
[	O
indx	long
]	O
=	O
superclass_id	long
;	O
if	O
(	O
pap	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
edma_get_class_id	function
(	O
pap	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
edma_printf	function
(	O
"[edma_add_local_class_add_superclass] WARNNING: "	pointer
"Uplink Anchor Point '%s' matches "	pointer
"a classname this may crash your application"	pointer
,	O
pap	pointer
)	O
;	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCIdList	pointer
[	O
indx	long
]	O
,	O
pap	pointer
,	O
sizeof	O
(	O
ID	array
)	O
)	O
;	O
}	O
else	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCIdList	pointer
[	O
indx	long
]	O
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
sizeof	O
(	O
ID	array
)	O
)	O
;	O
if	O
(	O
pap1	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
edma_get_class_id	function
(	O
pap1	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
edma_printf	function
(	O
"[edma_add_local_class_add_superclass] WARNNING: "	pointer
"Downlink Anchor Point '%s' matches "	pointer
"a classname this may crash your application"	pointer
,	O
pap1	pointer
)	O
;	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SubCIdList	pointer
[	O
indx	long
]	O
,	O
pap1	pointer
,	O
sizeof	O
(	O
ID	array
)	O
)	O
;	O
}	O
else	O
strncpy	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SubCIdList	pointer
[	O
indx	long
]	O
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
sizeof	O
(	O
ID	array
)	O
)	O
;	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
++	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_superclass_by_name	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
class_name	pointer
,	O
EPChar	pointer
pap	pointer
,	O
EPChar	pointer
pap1	pointer
)	O
{	O
CLASSID	long
super_cid	long
;	O
if	O
(	O
class_name	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_local_class_add_superclass_by_name] "	pointer
"Invalid class_name"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
super_cid	long
=	O
edma_get_class_id	function
(	O
class_name	pointer
)	O
;	O
if	O
(	O
super_cid	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_local_class_add_superclass_by_name] Class %s "	pointer
"doesn't exist"	pointer
,	O
class_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
edma_add_local_class_superclass	function
(	O
class_id	long
,	O
super_cid	long
,	O
pap1	pointer
,	O
pap	pointer
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_local_class_finish	function
(	O
CLASSID	long
class_id	long
)	O
{	O
ProcMapTable	pointer
[	O
class_id	long
]	O
=	O
CLASS_LOADED	int
;	O
nLocalClasses	long
++	O
;	O
edma_idf_set_class_id	function
(	O
class_id	long
)	O
;	O
return	O
0	int
;	O
}	O