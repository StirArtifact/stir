char	O
*	O
netfs_server_name	pointer
=	O
"nfs"	pointer
;	O
char	O
*	O
netfs_server_version	pointer
=	O
HURD_VERSION	O
;	O
extern	O
char	O
*	O
localhost	function
(	O
)	O
;	O
int	O
stat_timeout	int
=	O
DEFAULT_STAT_TIMEOUT	int
;	O
int	O
cache_timeout	int
=	O
DEFAULT_CACHE_TIMEOUT	int
;	O
int	O
name_cache_timeout	int
=	O
DEFAULT_NAME_CACHE_TIMEOUT	int
;	O
int	O
name_cache_neg_timeout	int
=	O
DEFAULT_NAME_CACHE_NEG_TIMEOUT	int
;	O
int	O
initial_transmit_timeout	int
=	O
1	int
;	O
int	O
max_transmit_timeout	int
=	O
30	int
;	O
int	O
soft_retries	int
=	O
DEFAULT_SOFT_RETRIES	int
;	O
int	O
mounted_soft	int
=	O
0	int
;	O
int	O
read_size	int
=	O
DEFAULT_READ_SIZE	int
;	O
int	O
write_size	int
=	O
DEFAULT_WRITE_SIZE	int
;	O
const	O
char	O
*	O
argp_program_version	pointer
=	O
STANDARD_HURD_VERSION	function
(	O
nfs	O
)	O
;	O
static	O
const	O
struct	O
argp_option	O
common_options	int
[	O
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
"soft"	pointer
,	O
OPT_SOFT	char
,	O
"RETRIES"	pointer
,	O
OPTION_ARG_OPTIONAL	O
,	O
"File system requests will eventually fail, after RETRIES tries"	pointer
" (default "	pointer
_D	O
(	O
SOFT_RETRIES	O
)	O
")"	pointer
}	O
,	O
{	O
"hard"	pointer
,	O
OPT_HARD	char
,	O
0	int
,	O
0	int
,	O
"Retry file systems requests until they succeed"	pointer
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
}	O
,	O
{	O
"read-size"	pointer
,	O
OPT_RSIZE	char
,	O
"BYTES"	pointer
,	O
0	int
,	O
"Max packet size for reads (default "	pointer
_D	O
(	O
READ_SIZE	O
)	O
")"	pointer
}	O
,	O
{	O
"rsize"	pointer
,	O
0	int
,	O
0	int
,	O
OPTION_ALIAS	O
}	O
,	O
{	O
"write-size"	pointer
,	O
OPT_WSIZE	char
,	O
"BYTES"	pointer
,	O
0	int
,	O
"Max packet size for writes (default "	pointer
_D	O
(	O
WRITE_SIZE	O
)	O
")"	pointer
}	O
,	O
{	O
"wsize"	pointer
,	O
0	int
,	O
0	int
,	O
OPTION_ALIAS	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"Timeouts:"	pointer
,	O
3	int
}	O
,	O
{	O
"stat-timeout"	pointer
,	O
OPT_STAT_TO	O
,	O
"SEC"	pointer
,	O
0	int
,	O
"Timeout for cached stat information (default "	pointer
_D	O
(	O
STAT_TIMEOUT	O
)	O
")"	pointer
}	O
,	O
{	O
"cache-timeout"	pointer
,	O
OPT_CACHE_TO	O
,	O
"SEC"	pointer
,	O
0	int
,	O
"Timeout for cached file data (default "	pointer
_D	O
(	O
CACHE_TIMEOUT	O
)	O
")"	pointer
}	O
,	O
{	O
"name-cache-timeout"	pointer
,	O
OPT_NCACHE_TO	O
,	O
"SEC"	pointer
,	O
0	int
,	O
"Timeout for positive directory cache entries (default "	pointer
_D	O
(	O
NAME_CACHE_TIMEOUT	O
)	O
")"	pointer
}	O
,	O
{	O
"name-cache-neg-timeout"	pointer
,	O
OPT_NCACHE_NEG_TO	O
,	O
"SEC"	pointer
,	O
0	int
,	O
"Timeout for negative directory cache entires (default "	pointer
_D	O
(	O
NAME_CACHE_NEG_TIMEOUT	O
)	O
")"	pointer
}	O
,	O
{	O
"init-transmit-timeout"	pointer
,	O
OPT_INIT_TR_TO	O
,	O
"SEC"	pointer
,	O
0	int
}	O
,	O
{	O
"max-transmit-timeout"	pointer
,	O
OPT_MAX_TR_TO	O
,	O
"SEC"	pointer
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
error_t	O
parse_common_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	O
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
OPT_SOFT	char
:	O
mounted_soft	int
=	O
1	int
;	O
if	O
(	O
arg	pointer
)	O
soft_retries	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_HARD	char
:	O
mounted_soft	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_RSIZE	char
:	O
read_size	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_WSIZE	char
:	O
write_size	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_STAT_TO	O
:	O
stat_timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_CACHE_TO	O
:	O
cache_timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_INIT_TR_TO	O
:	O
initial_transmit_timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_MAX_TR_TO	O
:	O
max_transmit_timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NCACHE_TO	O
:	O
name_cache_timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NCACHE_NEG_TO	O
:	O
name_cache_neg_timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
argp_option	O
startup_options	int
[	O
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"Server specification:"	pointer
,	O
10	int
}	O
,	O
{	O
"mount-port"	pointer
,	O
OPT_MNT_PORT	O
,	O
"PORT"	pointer
,	O
0	int
,	O
"Port for mount server"	pointer
}	O
,	O
{	O
"default-mount-port"	pointer
,	O
OPT_MNT_PORT_D	O
,	O
"PORT"	pointer
,	O
0	int
,	O
"Port for mount server, if none can be found automatically"	pointer
}	O
,	O
{	O
"mount-program"	pointer
,	O
OPT_MNT_PROG	O
,	O
"ID[.VERS]"	pointer
}	O
,	O
{	O
"nfs-port"	pointer
,	O
OPT_NFS_PORT	O
,	O
"PORT"	pointer
,	O
0	int
,	O
"Port for nfs operations"	pointer
}	O
,	O
{	O
"default-nfs-port"	pointer
,	O
OPT_NFS_PORT_D	O
,	O
"PORT"	pointer
,	O
0	int
,	O
"Port for nfs operations, if none can be found automatically"	pointer
}	O
,	O
{	O
"nfs-program"	pointer
,	O
OPT_NFS_PROG	O
,	O
"ID[.VERS]"	pointer
}	O
,	O
{	O
"pmap-port"	pointer
,	O
OPT_PMAP_PORT	O
,	O
"SVC|PORT"	pointer
}	O
,	O
{	O
"hold"	pointer
,	O
OPT_HOLD	O
,	O
0	int
,	O
OPTION_HIDDEN	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
char	O
*	O
args_doc	pointer
=	O
"REMOTE_FS [HOST]"	pointer
;	O
static	O
char	O
*	O
doc	pointer
=	O
"Hurd nfs translator"	pointer
"\vIf HOST is not specified, an attempt is made to extract"	pointer
" it from REMOTE_FS using either the `HOST:FS' or `FS@HOST' notations."	pointer
;	O
static	O
const	O
struct	O
argp_child	O
runtime_argp_children	int
[	O
]	O
=	O
{	O
{	O
&	O
netfs_std_runtime_argp	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
struct	O
argp	struct
runtime_argp	struct
=	O
{	O
common_options	int
,	O
parse_common_opt	function
,	O
0	int
,	O
0	int
,	O
runtime_argp_children	int
}	O
;	O
struct	O
argp	struct
*	O
netfs_runtime_argp	pointer
=	O
&	O
runtime_argp	struct
;	O
static	O
char	O
*	O
remote_fs	pointer
;	O
static	O
char	O
*	O
host	pointer
;	O
error_t	O
netfs_append_args	function
(	O
char	O
*	O
*	O
argz	pointer
,	O
size_t	long
*	O
argz_len	pointer
)	O
{	O
char	O
buf	array
[	O
80	int
]	O
;	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
mounted_soft	int
)	O
FOPT	O
(	O
"--soft=%d"	pointer
,	O
soft_retries	int
)	O
;	O
else	O
err	O
=	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
"--hard"	pointer
)	O
;	O
FOPT	O
(	O
"--read-size=%d"	pointer
,	O
read_size	int
)	O
;	O
FOPT	O
(	O
"--write-size=%d"	pointer
,	O
write_size	int
)	O
;	O
FOPT	O
(	O
"--stat-timeout=%d"	pointer
,	O
stat_timeout	int
)	O
;	O
FOPT	O
(	O
"--cache-timeout=%d"	pointer
,	O
cache_timeout	int
)	O
;	O
FOPT	O
(	O
"--init-transmit-timeout=%d"	pointer
,	O
initial_transmit_timeout	int
)	O
;	O
FOPT	O
(	O
"--max-transmit-timeout=%d"	pointer
,	O
max_transmit_timeout	int
)	O
;	O
FOPT	O
(	O
"--name-cache-timeout=%d"	pointer
,	O
name_cache_timeout	int
)	O
;	O
FOPT	O
(	O
"--name-cache-neg-timeout=%d"	pointer
,	O
name_cache_neg_timeout	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
netfs_append_std_options	function
(	O
argz	pointer
,	O
argz_len	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
char	O
*	O
fs	pointer
;	O
if	O
(	O
asprintf	function
(	O
&	O
fs	pointer
,	O
"%s:%s"	pointer
,	O
host	pointer
,	O
remote_fs	pointer
)	O
)	O
{	O
err	O
=	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
fs	pointer
)	O
;	O
free	function
(	O
fs	pointer
)	O
;	O
}	O
else	O
err	O
=	O
ENOMEM	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
netfs_get_source	function
(	O
struct	O
protid	O
*	O
cred	pointer
,	O
char	O
*	O
source	pointer
,	O
size_t	long
source_len	long
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
snprintf	O
(	O
source	pointer
,	O
source_len	long
,	O
"%s:%s"	pointer
,	O
host	pointer
,	O
remote_fs	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
extract_nfs_args	function
(	O
char	O
*	O
spec	pointer
,	O
char	O
*	O
*	O
remote_fs	pointer
,	O
char	O
*	O
*	O
host	pointer
)	O
{	O
char	O
*	O
sep	pointer
;	O
spec	pointer
=	O
strdup	O
(	O
spec	pointer
)	O
;	O
if	O
(	O
!	O
spec	pointer
)	O
return	O
NULL	O
;	O
sep	pointer
=	O
index	O
(	O
spec	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
sep	pointer
)	O
{	O
*	O
sep	pointer
++	O
=	O
'\0'	O
;	O
*	O
host	pointer
=	O
spec	pointer
;	O
*	O
remote_fs	pointer
=	O
sep	pointer
;	O
return	O
spec	pointer
;	O
}	O
sep	pointer
=	O
index	O
(	O
spec	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
sep	pointer
)	O
{	O
*	O
sep	pointer
++	O
=	O
'\0'	O
;	O
*	O
host	pointer
=	O
sep	pointer
;	O
*	O
remote_fs	pointer
=	O
spec	pointer
;	O
return	O
spec	pointer
;	O
}	O
free	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
parse_startup_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	O
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
OPT_MNT_PORT	O
:	O
mount_port_override	O
=	O
1	int
;	O
case	O
OPT_MNT_PORT_D	O
:	O
mount_port	O
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NFS_PORT	O
:	O
nfs_port_override	O
=	O
1	int
;	O
case	O
OPT_NFS_PORT_D	O
:	O
nfs_port	O
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	O
:	O
if	O
(	O
state	pointer
->	O
arg_num	O
==	O
0	int
)	O
remote_fs	pointer
=	O
arg	pointer
;	O
else	O
if	O
(	O
state	pointer
->	O
arg_num	O
==	O
1	int
)	O
host	pointer
=	O
arg	pointer
;	O
else	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
break	O
;	O
case	O
ARGP_KEY_END	O
:	O
if	O
(	O
!	O
host	pointer
&&	O
!	O
extract_nfs_args	function
(	O
remote_fs	pointer
,	O
&	O
remote_fs	pointer
,	O
&	O
host	pointer
)	O
)	O
argp_error	function
(	O
state	pointer
,	O
"No HOST specified"	pointer
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_NO_ARGS	O
:	O
argp_error	function
(	O
state	pointer
,	O
"No REMOTE_FS specified"	pointer
)	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
pthread_t	long
thread	long
;	O
error_t	O
err	O
;	O
struct	O
argp	struct
common_argp	struct
=	O
{	O
common_options	int
,	O
parse_common_opt	function
}	O
;	O
const	O
struct	O
argp_child	O
argp_children	int
[	O
]	O
=	O
{	O
{	O
&	O
common_argp	struct
}	O
,	O
{	O
&	O
netfs_std_startup_argp	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
startup_options	int
,	O
parse_startup_opt	function
,	O
args_doc	pointer
,	O
doc	pointer
,	O
argp_children	int
}	O
;	O
mach_port_t	O
bootstrap	O
;	O
struct	O
sockaddr_in	O
addr	struct
;	O
int	O
ret	int
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
netfs_init	function
(	O
)	O
;	O
main_udp_socket	O
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_DGRAM	O
,	O
0	int
)	O
;	O
addr	struct
.	O
sin_family	O
=	O
AF_INET	O
;	O
addr	struct
.	O
sin_addr	O
.	O
s_addr	O
=	O
INADDR_ANY	O
;	O
addr	struct
.	O
sin_port	O
=	O
htons	function
(	O
IPPORT_RESERVED	O
)	O
;	O
do	O
{	O
addr	struct
.	O
sin_port	O
=	O
htons	function
(	O
ntohs	function
(	O
addr	struct
.	O
sin_port	O
)	O
-	O
1	int
)	O
;	O
ret	int
=	O
bind	function
(	O
main_udp_socket	O
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
addr	struct
,	O
sizeof	O
(	O
struct	O
sockaddr_in	O
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EACCES	O
)	O
{	O
ret	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
while	O
(	O
(	O
ret	int
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
==	O
EADDRINUSE	O
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
"binding main udp socket"	pointer
)	O
;	O
err	O
=	O
maptime_map	function
(	O
0	int
,	O
0	int
,	O
&	O
mapped_time	O
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
2	int
,	O
err	O
,	O
"mapping time"	pointer
)	O
;	O
err	O
=	O
pthread_create	function
(	O
&	O
thread	long
,	O
NULL	O
,	O
timeout_service_thread	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_detach	function
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	O
;	O
perror	function
(	O
"pthread_create"	pointer
)	O
;	O
}	O
err	O
=	O
pthread_create	function
(	O
&	O
thread	long
,	O
NULL	O
,	O
rpc_receive_thread	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_detach	function
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	O
;	O
perror	function
(	O
"pthread_create"	pointer
)	O
;	O
}	O
hostname	O
=	O
localhost	function
(	O
)	O
;	O
netfs_root_node	O
=	O
mount_root	function
(	O
remote_fs	pointer
,	O
host	pointer
)	O
;	O
if	O
(	O
!	O
netfs_root_node	O
)	O
exit	O
(	O
1	int
)	O
;	O
netfs_startup	function
(	O
bootstrap	O
,	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
netfs_server_loop	function
(	O
)	O
;	O
}	O