unsigned	O
int	O
num_files	int
;	O
static	O
unsigned	O
int	O
gen	int
;	O
struct	O
node	pointer
*	O
all_nodes	pointer
;	O
static	O
size_t	long
all_nodes_nr_items	long
;	O
pthread_rwlock_t	union
all_nodes_lock	union
=	O
PTHREAD_RWLOCK_INITIALIZER	O
;	O
error_t	function
diskfs_alloc_node	function
(	O
struct	O
node	pointer
*	O
dp	pointer
,	O
mode_t	int
mode	int
,	O
struct	O
node	pointer
*	O
*	O
npp	pointer
)	O
{	O
struct	O
disknode	struct
*	O
dn	pointer
;	O
dn	pointer
=	O
calloc	O
(	O
1	int
,	O
sizeof	O
*	O
dn	pointer
)	O
;	O
if	O
(	O
dn	pointer
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
if	O
(	O
round_page	function
(	O
get_used	function
(	O
)	O
+	O
sizeof	O
*	O
dn	pointer
)	O
/	O
vm_page_size	O
>	O
tmpfs_page_limit	long
)	O
{	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
free	function
(	O
dn	pointer
)	O
;	O
return	O
ENOSPC	O
;	O
}	O
dn	pointer
->	O
gen	int
=	O
gen	int
++	O
;	O
__atomic_add_fetch	O
(	O
&	O
num_files	int
,	O
1	int
,	O
__ATOMIC_RELAXED	int
)	O
;	O
adjust_used	function
(	O
sizeof	O
*	O
dn	pointer
)	O
;	O
dn	pointer
->	O
type	int
=	O
IFTODT	function
(	O
mode	int
&	O
S_IFMT	O
)	O
;	O
return	O
diskfs_cached_lookup	function
(	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dn	pointer
,	O
npp	pointer
)	O
;	O
}	O
void	O
diskfs_free_node	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
mode_t	int
mode	int
)	O
{	O
switch	O
(	O
np	pointer
->	O
dn	pointer
->	O
type	int
)	O
{	O
case	O
DT_REG	O
:	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memref	int
,	O
4096	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
)	O
;	O
}	O
break	O
;	O
case	O
DT_DIR	O
:	O
assert	function
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
dir	struct
.	O
entries	pointer
==	O
0	int
)	O
;	O
break	O
;	O
case	O
DT_LNK	O
:	O
free	function
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
)	O
;	O
break	O
;	O
}	O
pthread_rwlock_wrlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
*	O
np	pointer
->	O
dn	pointer
->	O
hprevp	pointer
=	O
np	pointer
->	O
dn	pointer
->	O
hnext	pointer
;	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
hnext	pointer
!=	O
0	int
)	O
np	pointer
->	O
dn	pointer
->	O
hnext	pointer
->	O
dn	pointer
->	O
hprevp	pointer
=	O
np	pointer
->	O
dn	pointer
->	O
hprevp	pointer
;	O
all_nodes_nr_items	long
-=	O
1	int
;	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
free	function
(	O
np	pointer
->	O
dn	pointer
)	O
;	O
np	pointer
->	O
dn	pointer
=	O
0	int
;	O
__atomic_sub_fetch	O
(	O
&	O
num_files	int
,	O
1	int
,	O
__ATOMIC_RELAXED	int
)	O
;	O
adjust_used	function
(	O
-	O
sizeof	O
*	O
np	pointer
->	O
dn	pointer
)	O
;	O
}	O
void	O
diskfs_node_norefs	function
(	O
struct	O
node	pointer
*	O
np	pointer
)	O
{	O
if	O
(	O
np	pointer
->	O
dn	pointer
!=	O
0	int
)	O
{	O
np	pointer
->	O
dn	pointer
->	O
size	long
=	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
;	O
np	pointer
->	O
dn	pointer
->	O
mode	int
=	O
np	pointer
->	O
dn_stat	O
.	O
st_mode	O
;	O
np	pointer
->	O
dn	pointer
->	O
nlink	long
=	O
np	pointer
->	O
dn_stat	O
.	O
st_nlink	O
;	O
np	pointer
->	O
dn	pointer
->	O
uid	int
=	O
np	pointer
->	O
dn_stat	O
.	O
st_uid	O
;	O
np	pointer
->	O
dn	pointer
->	O
author	int
=	O
np	pointer
->	O
dn_stat	O
.	O
st_author	O
;	O
np	pointer
->	O
dn	pointer
->	O
gid	int
=	O
np	pointer
->	O
dn_stat	O
.	O
st_gid	O
;	O
np	pointer
->	O
dn	pointer
->	O
atime	struct
=	O
np	pointer
->	O
dn_stat	O
.	O
st_atim	O
;	O
np	pointer
->	O
dn	pointer
->	O
mtime	struct
=	O
np	pointer
->	O
dn_stat	O
.	O
st_mtim	O
;	O
np	pointer
->	O
dn	pointer
->	O
ctime	struct
=	O
np	pointer
->	O
dn_stat	O
.	O
st_ctim	O
;	O
np	pointer
->	O
dn	pointer
->	O
flags	int
=	O
np	pointer
->	O
dn_stat	O
.	O
st_flags	O
;	O
switch	O
(	O
np	pointer
->	O
dn	pointer
->	O
type	int
)	O
{	O
case	O
DT_REG	O
:	O
assert	function
(	O
np	pointer
->	O
allocsize	O
%	O
vm_page_size	O
==	O
0	int
)	O
;	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
allocpages	int
=	O
np	pointer
->	O
allocsize	O
/	O
vm_page_size	O
;	O
break	O
;	O
case	O
DT_CHR	O
:	O
case	O
DT_BLK	O
:	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
chr	long
=	O
np	pointer
->	O
dn_stat	O
.	O
st_rdev	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
np	pointer
)	O
;	O
}	O
static	O
void	O
recompute_blocks	function
(	O
struct	O
node	pointer
*	O
np	pointer
)	O
{	O
struct	O
disknode	struct
*	O
const	O
dn	pointer
=	O
np	pointer
->	O
dn	pointer
;	O
struct	O
stat	O
*	O
const	O
st	pointer
=	O
&	O
np	pointer
->	O
dn_stat	O
;	O
st	pointer
->	O
st_blocks	O
=	O
sizeof	O
*	O
dn	pointer
+	O
dn	pointer
->	O
translen	long
;	O
switch	O
(	O
dn	pointer
->	O
type	int
)	O
{	O
case	O
DT_REG	O
:	O
np	pointer
->	O
allocsize	O
=	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
allocpages	int
*	O
vm_page_size	O
;	O
st	pointer
->	O
st_blocks	O
+=	O
np	pointer
->	O
allocsize	O
;	O
break	O
;	O
case	O
DT_LNK	O
:	O
st	pointer
->	O
st_blocks	O
+=	O
st	pointer
->	O
st_size	O
+	O
1	int
;	O
break	O
;	O
case	O
DT_CHR	O
:	O
case	O
DT_BLK	O
:	O
st	pointer
->	O
st_rdev	O
=	O
dn	pointer
->	O
u	union
.	O
chr	long
;	O
break	O
;	O
case	O
DT_DIR	O
:	O
st	pointer
->	O
st_blocks	O
+=	O
dn	pointer
->	O
size	long
;	O
break	O
;	O
}	O
st	pointer
->	O
st_blocks	O
=	O
(	O
st	pointer
->	O
st_blocks	O
+	O
511	int
)	O
/	O
512	int
;	O
}	O
error_t	function
diskfs_cached_lookup	function
(	O
ino_t	long
inum	long
,	O
struct	O
node	pointer
*	O
*	O
npp	pointer
)	O
{	O
struct	O
disknode	struct
*	O
dn	pointer
=	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	O
)	O
inum	long
;	O
struct	O
node	pointer
*	O
np	pointer
;	O
assert	function
(	O
npp	pointer
)	O
;	O
pthread_rwlock_rdlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
if	O
(	O
dn	pointer
->	O
hprevp	pointer
!=	O
0	int
)	O
goto	O
gotit	O
;	O
else	O
{	O
struct	O
stat	O
*	O
st	pointer
;	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
np	pointer
=	O
diskfs_make_node	function
(	O
dn	pointer
)	O
;	O
np	pointer
->	O
cache_id	O
=	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dn	pointer
;	O
pthread_rwlock_wrlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
if	O
(	O
dn	pointer
->	O
hprevp	pointer
!=	O
NULL	O
)	O
{	O
diskfs_nrele	function
(	O
np	pointer
)	O
;	O
goto	O
gotit	O
;	O
}	O
dn	pointer
->	O
hnext	pointer
=	O
all_nodes	pointer
;	O
if	O
(	O
dn	pointer
->	O
hnext	pointer
)	O
dn	pointer
->	O
hnext	pointer
->	O
dn	pointer
->	O
hprevp	pointer
=	O
&	O
dn	pointer
->	O
hnext	pointer
;	O
dn	pointer
->	O
hprevp	pointer
=	O
&	O
all_nodes	pointer
;	O
all_nodes	pointer
=	O
np	pointer
;	O
all_nodes_nr_items	long
+=	O
1	int
;	O
diskfs_nref_light	function
(	O
np	pointer
)	O
;	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
st	pointer
=	O
&	O
np	pointer
->	O
dn_stat	O
;	O
memset	O
(	O
st	pointer
,	O
0	int
,	O
sizeof	O
*	O
st	pointer
)	O
;	O
st	pointer
->	O
st_fstype	O
=	O
FSTYPE_MEMFS	O
;	O
st	pointer
->	O
st_fsid	O
=	O
getpid	function
(	O
)	O
;	O
st	pointer
->	O
st_blksize	O
=	O
vm_page_size	O
;	O
st	pointer
->	O
st_ino	O
=	O
(	O
ino_t	long
)	O
(	O
uintptr_t	O
)	O
dn	pointer
;	O
st	pointer
->	O
st_gen	O
=	O
dn	pointer
->	O
gen	int
;	O
st	pointer
->	O
st_size	O
=	O
dn	pointer
->	O
size	long
;	O
st	pointer
->	O
st_mode	O
=	O
dn	pointer
->	O
mode	int
;	O
st	pointer
->	O
st_nlink	O
=	O
dn	pointer
->	O
nlink	long
;	O
st	pointer
->	O
st_uid	O
=	O
dn	pointer
->	O
uid	int
;	O
st	pointer
->	O
st_author	O
=	O
dn	pointer
->	O
author	int
;	O
st	pointer
->	O
st_gid	O
=	O
dn	pointer
->	O
gid	int
;	O
st	pointer
->	O
st_atim	O
=	O
dn	pointer
->	O
atime	struct
;	O
st	pointer
->	O
st_mtim	O
=	O
dn	pointer
->	O
mtime	struct
;	O
st	pointer
->	O
st_ctim	O
=	O
dn	pointer
->	O
ctime	struct
;	O
st	pointer
->	O
st_flags	O
=	O
dn	pointer
->	O
flags	int
;	O
st	pointer
->	O
st_rdev	O
=	O
0	int
;	O
np	pointer
->	O
allocsize	O
=	O
0	int
;	O
recompute_blocks	function
(	O
np	pointer
)	O
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
*	O
npp	pointer
=	O
np	pointer
;	O
return	O
0	int
;	O
gotit	O
:	O
np	pointer
=	O
*	O
dn	pointer
->	O
hprevp	pointer
;	O
assert	function
(	O
np	pointer
->	O
dn	pointer
==	O
dn	pointer
)	O
;	O
assert	function
(	O
*	O
dn	pointer
->	O
hprevp	pointer
==	O
np	pointer
)	O
;	O
diskfs_nref	function
(	O
np	pointer
)	O
;	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
*	O
npp	pointer
=	O
np	pointer
;	O
return	O
0	int
;	O
}	O
error_t	function
diskfs_node_iterate	function
(	O
error_t	function
(	O
*	O
fun	pointer
)	O
(	O
struct	O
node	pointer
*	O
)	O
)	O
{	O
error_t	function
err	O
=	O
0	int
;	O
size_t	long
num_nodes	long
;	O
struct	O
node	pointer
*	O
node	pointer
,	O
*	O
*	O
node_list	pointer
,	O
*	O
*	O
p	pointer
;	O
pthread_rwlock_rdlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
num_nodes	long
=	O
all_nodes_nr_items	long
;	O
p	pointer
=	O
node_list	pointer
=	O
alloca	O
(	O
num_nodes	long
*	O
sizeof	O
(	O
struct	O
node	pointer
*	O
)	O
)	O
;	O
for	O
(	O
node	pointer
=	O
all_nodes	pointer
;	O
node	pointer
!=	O
0	int
;	O
node	pointer
=	O
node	pointer
->	O
dn	pointer
->	O
hnext	pointer
)	O
{	O
*	O
p	pointer
++	O
=	O
node	pointer
;	O
refcounts_ref	function
(	O
&	O
node	pointer
->	O
refcounts	O
,	O
NULL	O
)	O
;	O
}	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
p	pointer
=	O
node_list	pointer
;	O
while	O
(	O
num_nodes	long
--	O
>	O
0	int
)	O
{	O
node	pointer
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
node	pointer
->	O
lock	O
)	O
;	O
err	O
=	O
(	O
*	O
fun	pointer
)	O
(	O
node	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
node	pointer
->	O
lock	O
)	O
;	O
}	O
diskfs_nrele	function
(	O
node	pointer
)	O
;	O
}	O
return	O
err	O
;	O
}	O
void	O
diskfs_try_dropping_softrefs	function
(	O
struct	O
node	pointer
*	O
np	pointer
)	O
{	O
pthread_rwlock_wrlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
if	O
(	O
np	pointer
->	O
cache_id	O
!=	O
0	int
)	O
{	O
struct	O
references	O
result	struct
;	O
refcounts_references	function
(	O
&	O
np	pointer
->	O
refcounts	O
,	O
&	O
result	struct
)	O
;	O
if	O
(	O
result	struct
.	O
hard	O
>	O
0	int
)	O
{	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
return	O
;	O
}	O
np	pointer
->	O
cache_id	O
=	O
0	int
;	O
diskfs_nrele_light	function
(	O
np	pointer
)	O
;	O
}	O
pthread_rwlock_unlock	function
(	O
&	O
all_nodes_lock	union
)	O
;	O
}	O
void	O
diskfs_lost_hardrefs	function
(	O
struct	O
node	pointer
*	O
np	pointer
)	O
{	O
}	O
void	O
diskfs_new_hardrefs	function
(	O
struct	O
node	pointer
*	O
np	pointer
)	O
{	O
}	O
error_t	function
diskfs_get_translator	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
char	O
*	O
*	O
namep	pointer
,	O
u_int	int
*	O
namelen	int
)	O
{	O
*	O
namelen	int
=	O
np	pointer
->	O
dn	pointer
->	O
translen	long
;	O
if	O
(	O
*	O
namelen	int
==	O
0	int
)	O
return	O
0	int
;	O
*	O
namep	pointer
=	O
malloc	O
(	O
*	O
namelen	int
)	O
;	O
if	O
(	O
*	O
namep	pointer
==	O
0	int
)	O
return	O
ENOMEM	O
;	O
memcpy	O
(	O
*	O
namep	pointer
,	O
np	pointer
->	O
dn	pointer
->	O
trans	pointer
,	O
*	O
namelen	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	function
diskfs_set_translator	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
const	O
char	O
*	O
name	array
,	O
u_int	int
namelen	int
,	O
struct	O
protid	O
*	O
cred	pointer
)	O
{	O
char	O
*	O
new	pointer
;	O
if	O
(	O
namelen	int
==	O
0	int
)	O
{	O
free	function
(	O
np	pointer
->	O
dn	pointer
->	O
trans	pointer
)	O
;	O
new	pointer
=	O
0	int
;	O
np	pointer
->	O
dn_stat	O
.	O
st_mode	O
&=	O
~	O
S_IPTRANS	O
;	O
}	O
else	O
{	O
new	pointer
=	O
realloc	O
(	O
np	pointer
->	O
dn	pointer
->	O
trans	pointer
,	O
namelen	int
)	O
;	O
if	O
(	O
new	pointer
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
memcpy	O
(	O
new	pointer
,	O
name	array
,	O
namelen	int
)	O
;	O
np	pointer
->	O
dn_stat	O
.	O
st_mode	O
|=	O
S_IPTRANS	O
;	O
}	O
adjust_used	function
(	O
namelen	int
-	O
np	pointer
->	O
dn	pointer
->	O
translen	long
)	O
;	O
np	pointer
->	O
dn	pointer
->	O
trans	pointer
=	O
new	pointer
;	O
np	pointer
->	O
dn	pointer
->	O
translen	long
=	O
namelen	int
;	O
recompute_blocks	function
(	O
np	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	function
create_symlink_hook	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
const	O
char	O
*	O
target	pointer
)	O
{	O
assert	function
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
==	O
0	int
)	O
;	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
=	O
strlen	O
(	O
target	pointer
)	O
;	O
if	O
(	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
>	O
0	int
)	O
{	O
const	O
size_t	long
size	long
=	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
+	O
1	int
;	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
=	O
malloc	O
(	O
size	long
)	O
;	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
==	O
0	int
)	O
return	O
ENOSPC	O
;	O
memcpy	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
,	O
target	pointer
,	O
size	long
)	O
;	O
np	pointer
->	O
dn	pointer
->	O
type	int
=	O
DT_LNK	O
;	O
adjust_used	function
(	O
size	long
)	O
;	O
recompute_blocks	function
(	O
np	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
error_t	function
(	O
*	O
diskfs_create_symlink_hook	pointer
)	O
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
const	O
char	O
*	O
target	pointer
)	O
=	O
create_symlink_hook	function
;	O
static	O
error_t	function
read_symlink_hook	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
char	O
*	O
target	pointer
)	O
{	O
memcpy	O
(	O
target	pointer
,	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
,	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
+	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	function
(	O
*	O
diskfs_read_symlink_hook	pointer
)	O
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
char	O
*	O
target	pointer
)	O
=	O
read_symlink_hook	function
;	O
void	O
diskfs_write_disknode	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
int	O
wait	int
)	O
{	O
}	O
void	O
diskfs_file_update	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
int	O
wait	int
)	O
{	O
diskfs_node_update	function
(	O
np	pointer
,	O
wait	int
)	O
;	O
}	O
error_t	function
diskfs_node_reload	function
(	O
struct	O
node	pointer
*	O
node	pointer
)	O
{	O
return	O
0	int
;	O
}	O
error_t	function
diskfs_truncate	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
off_t	long
size	long
)	O
{	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
type	int
==	O
DT_LNK	O
)	O
{	O
free	function
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
)	O
;	O
adjust_used	function
(	O
size	long
-	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
)	O
;	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
lnk	pointer
=	O
0	int
;	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
=	O
size	long
;	O
return	O
0	int
;	O
}	O
if	O
(	O
np	pointer
->	O
allocsize	O
<=	O
size	long
)	O
return	O
0	int
;	O
assert	function
(	O
np	pointer
->	O
dn	pointer
->	O
type	int
==	O
DT_REG	O
)	O
;	O
if	O
(	O
default_pager	int
==	O
MACH_PORT_NULL	O
)	O
return	O
EIO	O
;	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
=	O
size	long
;	O
off_t	long
set_size	long
=	O
size	long
;	O
size	long
=	O
round_page	function
(	O
size	long
)	O
;	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
error_t	function
err	O
=	O
default_pager_object_set_size	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
,	O
set_size	long
)	O
;	O
if	O
(	O
err	O
==	O
MIG_BAD_ID	O
)	O
return	O
0	int
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
adjust_used	function
(	O
size	long
-	O
np	pointer
->	O
allocsize	O
)	O
;	O
np	pointer
->	O
dn_stat	O
.	O
st_blocks	O
+=	O
(	O
size	long
-	O
np	pointer
->	O
allocsize	O
)	O
/	O
512	int
;	O
np	pointer
->	O
allocsize	O
=	O
size	long
;	O
return	O
0	int
;	O
}	O
error_t	function
diskfs_grow	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
off_t	long
size	long
,	O
struct	O
protid	O
*	O
cred	pointer
)	O
{	O
assert	function
(	O
np	pointer
->	O
dn	pointer
->	O
type	int
==	O
DT_REG	O
)	O
;	O
if	O
(	O
np	pointer
->	O
allocsize	O
>=	O
size	long
)	O
return	O
0	int
;	O
off_t	long
set_size	long
=	O
size	long
;	O
size	long
=	O
round_page	function
(	O
size	long
)	O
;	O
if	O
(	O
round_page	function
(	O
get_used	function
(	O
)	O
+	O
size	long
-	O
np	pointer
->	O
allocsize	O
)	O
/	O
vm_page_size	O
>	O
tmpfs_page_limit	long
)	O
return	O
ENOSPC	O
;	O
if	O
(	O
default_pager	int
==	O
MACH_PORT_NULL	O
)	O
return	O
EIO	O
;	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
error_t	function
err	O
=	O
default_pager_object_set_size	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
,	O
set_size	long
)	O
;	O
if	O
(	O
err	O
==	O
MIG_BAD_ID	O
)	O
err	O
=	O
0	int
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
adjust_used	function
(	O
size	long
-	O
np	pointer
->	O
allocsize	O
)	O
;	O
np	pointer
->	O
dn_stat	O
.	O
st_blocks	O
+=	O
(	O
size	long
-	O
np	pointer
->	O
allocsize	O
)	O
/	O
512	int
;	O
np	pointer
->	O
allocsize	O
=	O
size	long
;	O
return	O
0	int
;	O
}	O
mach_port_t	O
diskfs_get_filemap	function
(	O
struct	O
node	pointer
*	O
np	pointer
,	O
vm_prot_t	O
prot	int
)	O
{	O
error_t	function
err	O
;	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
type	int
!=	O
DT_REG	O
)	O
{	O
errno	O
=	O
EOPNOTSUPP	O
;	O
return	O
MACH_PORT_NULL	O
;	O
}	O
if	O
(	O
default_pager	int
==	O
MACH_PORT_NULL	O
)	O
{	O
errno	O
=	O
EIO	O
;	O
return	O
MACH_PORT_NULL	O
;	O
}	O
if	O
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
==	O
MACH_PORT_NULL	O
)	O
{	O
error_t	function
err	O
=	O
default_pager_object_create	O
(	O
default_pager	int
,	O
&	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
,	O
np	pointer
->	O
allocsize	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
errno	O
=	O
err	O
;	O
return	O
MACH_PORT_NULL	O
;	O
}	O
assert	function
(	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
!=	O
MACH_PORT_NULL	O
)	O
;	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memref	int
=	O
0	int
;	O
vm_map	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memref	int
,	O
4096	int
,	O
0	int
,	O
1	int
,	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
,	O
0	int
,	O
0	int
,	O
VM_PROT_NONE	O
,	O
VM_PROT_NONE	O
,	O
VM_INHERIT_NONE	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
err	O
=	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
return	O
np	pointer
->	O
dn	pointer
->	O
u	union
.	O
reg	struct
.	O
memobj	int
;	O
}	O
struct	O
pager	O
*	O
diskfs_get_filemap_pager_struct	function
(	O
struct	O
node	pointer
*	O
np	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
diskfs_pager_users	function
(	O
)	O
{	O
return	O
0	int
;	O
}	O
void	O
diskfs_shutdown_pager	function
(	O
)	O
{	O
}	O
vm_prot_t	O
diskfs_max_user_pager_prot	function
(	O
)	O
{	O
return	O
VM_PROT_READ	O
;	O
}	O
error_t	function
diskfs_S_file_get_storage_info	function
(	O
struct	O
protid	O
*	O
cred	pointer
,	O
mach_port_t	O
*	O
*	O
ports	pointer
,	O
mach_msg_type_name_t	O
*	O
ports_type	pointer
,	O
mach_msg_type_number_t	O
*	O
num_ports	pointer
,	O
int	O
*	O
*	O
ints	pointer
,	O
mach_msg_type_number_t	O
*	O
num_ints	pointer
,	O
off_t	long
*	O
*	O
offsets	pointer
,	O
mach_msg_type_number_t	O
*	O
num_offsets	pointer
,	O
char	O
*	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
*	O
data_len	pointer
)	O
{	O
mach_port_t	O
memobj	int
=	O
diskfs_get_filemap	function
(	O
cred	pointer
->	O
po	O
->	O
np	pointer
,	O
VM_PROT_ALL	O
)	O
;	O
if	O
(	O
memobj	int
==	O
MACH_PORT_NULL	O
)	O
return	O
errno	O
;	O
assert	function
(	O
*	O
num_ports	pointer
>=	O
1	int
)	O
;	O
*	O
num_ports	pointer
=	O
1	int
;	O
*	O
ports_type	pointer
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
(	O
*	O
ports	pointer
)	O
[	O
0	int
]	O
=	O
(	O
cred	pointer
->	O
po	O
->	O
openstat	O
&	O
O_RDWR	O
)	O
==	O
O_RDWR	O
?	O
memobj	int
:	O
MACH_PORT_NULL	O
;	O
assert	function
(	O
*	O
num_offsets	pointer
>=	O
2	int
)	O
;	O
*	O
num_offsets	pointer
=	O
2	int
;	O
(	O
*	O
offsets	pointer
)	O
[	O
0	int
]	O
=	O
0	int
;	O
(	O
*	O
offsets	pointer
)	O
[	O
1	int
]	O
=	O
cred	pointer
->	O
po	O
->	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
;	O
assert	function
(	O
*	O
num_ints	pointer
>=	O
6	int
)	O
;	O
*	O
num_ints	pointer
=	O
6	int
;	O
(	O
*	O
ints	pointer
)	O
[	O
0	int
]	O
=	O
STORAGE_MEMORY	O
;	O
(	O
*	O
ints	pointer
)	O
[	O
1	int
]	O
=	O
(	O
cred	pointer
->	O
po	O
->	O
openstat	O
&	O
O_WRITE	O
)	O
?	O
0	int
:	O
STORE_READONLY	O
;	O
(	O
*	O
ints	pointer
)	O
[	O
2	int
]	O
=	O
1	int
;	O
(	O
*	O
ints	pointer
)	O
[	O
3	int
]	O
=	O
1	int
;	O
(	O
*	O
ints	pointer
)	O
[	O
4	int
]	O
=	O
0	int
;	O
(	O
*	O
ints	pointer
)	O
[	O
5	int
]	O
=	O
0	int
;	O
*	O
data_len	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O