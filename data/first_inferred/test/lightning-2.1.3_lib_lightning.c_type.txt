static	O
jit_word_t	long
hash_data	function
(	O
const	O
void	O
*	O
,	O
jit_word_t	long
)	O
;	O
static	O
void	O
_new_pool	function
(	O
jit_state_t	struct
*	O
)	O
;	O
static	O
jit_node_t	struct
*	O
_new_node	function
(	O
jit_state_t	struct
*	O
,	O
jit_code_t	enum
)	O
;	O
static	O
inline	O
jit_node_t	struct
*	O
_link_node	function
(	O
jit_state_t	struct
*	O
,	O
jit_node_t	struct
*	O
)	O
;	O
static	O
inline	O
void	O
_del_node	function
(	O
jit_state_t	struct
*	O
,	O
jit_node_t	struct
*	O
,	O
jit_node_t	struct
*	O
)	O
;	O
static	O
inline	O
void	O
_free_node	function
(	O
jit_state_t	struct
*	O
,	O
jit_node_t	struct
*	O
)	O
;	O
static	O
void	O
_del_label	function
(	O
jit_state_t	struct
*	O
,	O
jit_node_t	struct
*	O
,	O
jit_node_t	struct
*	O
)	O
;	O
static	O
void	O
_jit_dataset	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
;	O
static	O
void	O
_jit_setup	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_block_t	struct
*	O
block	pointer
)	O
;	O
static	O
void	O
_jit_follow	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_block_t	struct
*	O
block	pointer
,	O
jit_bool_t	int
*	O
todo	pointer
)	O
;	O
static	O
void	O
_jit_update	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_regset_t	long
*	O
live	pointer
,	O
jit_regset_t	long
*	O
mask	pointer
)	O
;	O
static	O
void	O
_thread_jumps	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
;	O
static	O
void	O
_sequential_labels	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
;	O
static	O
jit_bool_t	int
_shortcut_jump	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
;	O
static	O
jit_bool_t	int
_redundant_jump	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
;	O
static	O
jit_code_t	enum
reverse_jump_code	function
(	O
jit_code_t	enum
code	pointer
)	O
;	O
static	O
jit_bool_t	int
_reverse_jump	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
;	O
static	O
void	O
_redundant_store	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_bool_t	int
jump	int
)	O
;	O
static	O
jit_bool_t	int
_simplify_movr	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
kind	int
,	O
jit_int32_t	int
size	long
)	O
;	O
static	O
jit_bool_t	int
_simplify_movi	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
kind	int
,	O
jit_int32_t	int
size	long
)	O
;	O
static	O
jit_bool_t	int
_simplify_ldxi	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
;	O
static	O
jit_bool_t	int
_simplify_stxi	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
;	O
static	O
void	O
_simplify_spill	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
regno	int
)	O
;	O
static	O
void	O
_simplify	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
;	O
static	O
jit_int32_t	int
_register_change_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_node_t	struct
*	O
link	function
,	O
jit_int32_t	int
regno	int
)	O
;	O
static	O
jit_bool_t	int
_spill_reglive_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
regno	int
)	O
;	O
static	O
void	O
_patch_registers	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
;	O
static	O
void	O
_patch_register	function
(	O
jit_state_t	struct
*	O
jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_node_t	struct
*	O
link	function
,	O
jit_int32_t	int
regno	int
,	O
jit_int32_t	int
patch	int
)	O
;	O
void	O
init_jit	function
(	O
const	O
char	O
*	O
progname	pointer
)	O
{	O
jit_get_cpu	function
(	O
)	O
;	O
jit_init_debug	function
(	O
progname	pointer
)	O
;	O
jit_init_size	function
(	O
)	O
;	O
}	O
void	O
finish_jit	function
(	O
void	O
)	O
{	O
jit_finish_debug	function
(	O
)	O
;	O
jit_finish_size	function
(	O
)	O
;	O
}	O
jit_int32_t	int
_jit_get_reg	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
regspec	int
)	O
{	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
regno	int
;	O
spec	enum
=	O
regspec	int
&	O
~	O
(	O
jit_class_chk	int
|	O
jit_class_nospill	int
)	O
;	O
if	O
(	O
spec	enum
&	O
jit_class_named	int
)	O
{	O
regno	int
=	O
jit_regno	O
(	O
spec	enum
)	O
;	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
regno	int
)	O
)	O
{	O
if	O
(	O
regspec	int
&	O
jit_class_nospill	int
)	O
goto	O
fail	O
;	O
goto	O
spill	pointer
;	O
}	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
;	O
return	O
(	O
regno	int
)	O
;	O
}	O
else	O
assert	O
(	O
jit_class	O
(	O
spec	enum
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
_jitc	O
->	O
emit	int
)	O
{	O
for	O
(	O
regno	int
=	O
0	int
;	O
regno	int
<	O
_jitc	O
->	O
reglen	int
;	O
regno	int
++	O
)	O
{	O
if	O
(	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
spec	enum
)	O
==	O
spec	enum
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
regno	int
)	O
)	O
goto	O
regarg	long
;	O
}	O
for	O
(	O
regno	int
=	O
0	int
;	O
regno	int
<	O
_jitc	O
->	O
reglen	int
;	O
regno	int
++	O
)	O
{	O
if	O
(	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
spec	enum
)	O
==	O
spec	enum
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
&&	O
!	O
(	O
regspec	int
&	O
jit_class_nospill	int
)	O
)	O
{	O
spill	pointer
:	O
assert	O
(	O
_jitc	O
->	O
function	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
spec	enum
&	O
jit_class_gpr	int
)	O
{	O
if	O
(	O
!	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
)	O
{	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
=	O
jit_allocai	O
(	O
sizeof	O
(	O
jit_word_t	long
)	O
)	O
;	O
_jitc	O
->	O
again	int
=	O
1	int
;	O
}	O
emit_stxi	O
(	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
,	O
JIT_FP	O
,	O
regno	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
)	O
{	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
=	O
jit_allocai	O
(	O
sizeof	O
(	O
jit_float64_t	double
)	O
)	O
;	O
_jitc	O
->	O
again	int
=	O
1	int
;	O
}	O
emit_stxi_d	O
(	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
,	O
JIT_FP	O
,	O
regno	int
)	O
;	O
}	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
;	O
regarg	long
:	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
;	O
if	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
jit_class_sav	int
)	O
{	O
assert	O
(	O
_jitc	O
->	O
function	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
regno	int
)	O
)	O
{	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
regno	int
)	O
;	O
_jitc	O
->	O
again	int
=	O
1	int
;	O
}	O
}	O
return	O
(	O
regno	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
assert	O
(	O
!	O
(	O
regspec	int
&	O
jit_class_nospill	int
)	O
)	O
;	O
for	O
(	O
regno	int
=	O
0	int
;	O
regno	int
<	O
_jitc	O
->	O
reglen	int
;	O
regno	int
++	O
)	O
{	O
if	O
(	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
spec	enum
)	O
==	O
spec	enum
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
)	O
{	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
;	O
jit_save	O
(	O
regno	int
)	O
;	O
return	O
(	O
jit_regno_patch	int
|	O
regno	int
)	O
;	O
}	O
}	O
}	O
fail	O
:	O
assert	O
(	O
regspec	int
&	O
jit_class_chk	int
)	O
;	O
return	O
(	O
JIT_NOREG	O
)	O
;	O
}	O
void	O
_jit_unget_reg	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
regno	int
)	O
{	O
regno	int
=	O
jit_regno	O
(	O
regno	int
)	O
;	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
)	O
{	O
if	O
(	O
_jitc	O
->	O
emit	int
)	O
{	O
if	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
jit_class_gpr	int
)	O
emit_ldxi	O
(	O
regno	int
,	O
JIT_FP	O
,	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
)	O
;	O
else	O
emit_ldxi_d	O
(	O
regno	int
,	O
JIT_FP	O
,	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
)	O
;	O
}	O
else	O
jit_load	O
(	O
regno	int
)	O
;	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regsav	long
,	O
regno	int
)	O
;	O
}	O
assert	O
(	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
!=	O
0	int
)	O
;	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
regno	int
)	O
;	O
}	O
jit_bool_t	int
_jit_callee_save_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
regno	int
)	O
{	O
assert	O
(	O
regno	int
>=	O
0	int
&&	O
regno	int
<	O
JIT_NOREG	O
)	O
;	O
return	O
(	O
!	O
!	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
&	O
jit_class_sav	int
)	O
)	O
;	O
}	O
extern	O
jit_bool_t	int
_jit_pointer_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_pointer_t	pointer
address	pointer
)	O
{	O
return	O
(	O
(	O
jit_uint8_t	char
*	O
)	O
address	pointer
>=	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
&&	O
(	O
jit_word_t	long
)	O
address	pointer
<	O
_jit	pointer
->	O
pc	union
.	O
w	long
)	O
;	O
}	O
unsigned	O
long	O
jit_regset_scan1	function
(	O
jit_regset_t	long
*	O
set	pointer
,	O
jit_int32_t	int
offset	short
)	O
{	O
jit_regset_t	long
mask	pointer
;	O
assert	O
(	O
offset	short
>=	O
0	int
&&	O
offset	short
<=	O
63	int
)	O
;	O
if	O
(	O
(	O
mask	pointer
=	O
*	O
set	pointer
>>	O
offset	short
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
mask	pointer
&	O
1	int
)	O
return	O
(	O
offset	short
)	O
;	O
mask	pointer
>>=	O
1	int
;	O
++	O
offset	short
;	O
}	O
}	O
return	O
(	O
ULONG_MAX	O
)	O
;	O
}	O
void	O
_jit_save	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
reg	int
)	O
{	O
reg	int
=	O
jit_regno	O
(	O
reg	int
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
_jitc	O
->	O
spill	pointer
[	O
reg	int
]	O
=	O
jit_new_node_w	O
(	O
jit_code_save	int
,	O
reg	int
)	O
;	O
}	O
void	O
_jit_load	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
reg	int
)	O
{	O
jit_node_t	struct
*	O
node	pointer
;	O
reg	int
=	O
jit_regno	O
(	O
reg	int
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
assert	O
(	O
_jitc	O
->	O
spill	pointer
[	O
reg	int
]	O
!=	O
NULL	O
)	O
;	O
node	pointer
=	O
jit_new_node_w	O
(	O
jit_code_load	int
,	O
reg	int
)	O
;	O
node	pointer
->	O
link	function
=	O
_jitc	O
->	O
spill	pointer
[	O
reg	int
]	O
;	O
node	pointer
->	O
link	function
->	O
link	function
=	O
node	pointer
;	O
_jitc	O
->	O
spill	pointer
[	O
reg	int
]	O
=	O
NULL	O
;	O
}	O
static	O
jit_word_t	long
hash_data	function
(	O
const	O
void	O
*	O
data	struct
,	O
jit_word_t	long
length	long
)	O
{	O
const	O
jit_uint8_t	char
*	O
ptr	pointer
;	O
jit_word_t	long
i	long
,	O
key	long
;	O
for	O
(	O
i	long
=	O
key	long
=	O
0	int
,	O
ptr	pointer
=	O
data	struct
;	O
i	long
<	O
length	long
;	O
i	long
++	O
)	O
key	long
=	O
(	O
key	long
<<	O
(	O
key	long
&	O
1	int
)	O
)	O
^	O
ptr	pointer
[	O
i	long
]	O
;	O
return	O
(	O
key	long
)	O
;	O
}	O
jit_pointer_t	pointer
_jit_address	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
assert	O
(	O
_jitc	O
->	O
done	int
)	O
;	O
assert	O
(	O
node	pointer
!=	O
NULL	O
&&	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_note	int
||	O
node	pointer
->	O
code	pointer
==	O
jit_code_name	int
||	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
&&	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_use	int
)	O
!=	O
0	int
)	O
)	O
)	O
;	O
return	O
(	O
(	O
jit_pointer_t	pointer
)	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_data	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
const	O
void	O
*	O
data	struct
,	O
jit_word_t	long
length	long
,	O
jit_int32_t	int
align	int
)	O
{	O
jit_word_t	long
key	long
;	O
jit_node_t	struct
*	O
node	pointer
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
if	O
(	O
(	O
(	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
7	int
)	O
&	O
-	O
8	int
)	O
+	O
length	long
>	O
_jit	pointer
->	O
data	struct
.	O
length	long
)	O
{	O
jit_word_t	long
size	long
;	O
size	long
=	O
(	O
_jit	pointer
->	O
data	struct
.	O
length	long
+	O
length	long
+	O
4096	int
)	O
&	O
-	O
4095	int
;	O
assert	O
(	O
size	long
>=	O
_jit	pointer
->	O
data	struct
.	O
length	long
)	O
;	O
if	O
(	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
==	O
NULL	O
)	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
,	O
size	long
)	O
;	O
else	O
jit_realloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
,	O
_jit	pointer
->	O
data	struct
.	O
length	long
,	O
size	long
)	O
;	O
_jit	pointer
->	O
data	struct
.	O
length	long
=	O
size	long
;	O
}	O
if	O
(	O
_jitc	O
->	O
data	struct
.	O
table	pointer
==	O
NULL	O
)	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
table	pointer
,	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
=	O
16	int
)	O
*	O
sizeof	O
(	O
jit_node_t	struct
*	O
)	O
)	O
;	O
key	long
=	O
hash_data	function
(	O
data	struct
,	O
length	long
)	O
&	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
-	O
1	int
)	O
;	O
node	pointer
=	O
_jitc	O
->	O
data	struct
.	O
table	pointer
[	O
key	long
]	O
;	O
for	O
(	O
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
node	pointer
->	O
v	union
.	O
w	long
==	O
length	long
&&	O
memcmp	function
(	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
u	union
.	O
w	long
,	O
data	struct
,	O
length	long
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
node	pointer
)	O
{	O
node	pointer
=	O
jit_new_node_no_link	O
(	O
jit_code_data	int
)	O
;	O
if	O
(	O
!	O
align	int
)	O
align	int
=	O
length	long
;	O
switch	O
(	O
align	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
break	O
;	O
case	O
2	int
:	O
_jitc	O
->	O
data	struct
.	O
offset	short
=	O
(	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
1	int
)	O
&	O
-	O
2	int
;	O
break	O
;	O
case	O
3	int
:	O
case	O
4	int
:	O
_jitc	O
->	O
data	struct
.	O
offset	short
=	O
(	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
3	int
)	O
&	O
-	O
4	int
;	O
break	O
;	O
default	O
:	O
_jitc	O
->	O
data	struct
.	O
offset	short
=	O
(	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
7	int
)	O
&	O
-	O
8	int
;	O
break	O
;	O
}	O
node	pointer
->	O
u	union
.	O
w	long
=	O
_jitc	O
->	O
data	struct
.	O
offset	short
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
length	long
;	O
jit_memcpy	function
(	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
+	O
_jitc	O
->	O
data	struct
.	O
offset	short
,	O
data	struct
,	O
length	long
)	O
;	O
_jitc	O
->	O
data	struct
.	O
offset	short
+=	O
length	long
;	O
node	pointer
->	O
next	pointer
=	O
_jitc	O
->	O
data	struct
.	O
table	pointer
[	O
key	long
]	O
;	O
_jitc	O
->	O
data	struct
.	O
table	pointer
[	O
key	long
]	O
=	O
node	pointer
;	O
++	O
_jitc	O
->	O
data	struct
.	O
count	long
;	O
if	O
(	O
_jitc	O
->	O
data	struct
.	O
count	long
>	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
>>	O
1	int
)	O
+	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
>>	O
2	int
)	O
&&	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
<<	O
1	int
)	O
>	O
_jitc	O
->	O
data	struct
.	O
size	long
)	O
{	O
jit_word_t	long
i	long
;	O
jit_node_t	struct
*	O
*	O
hash	pointer
;	O
jit_node_t	struct
*	O
next	pointer
;	O
jit_node_t	struct
*	O
temp	pointer
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
hash	pointer
,	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
<<	O
1	int
)	O
*	O
sizeof	O
(	O
jit_node_t	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
_jitc	O
->	O
data	struct
.	O
size	long
;	O
i	long
++	O
)	O
{	O
temp	pointer
=	O
_jitc	O
->	O
data	struct
.	O
table	pointer
[	O
i	long
]	O
;	O
for	O
(	O
;	O
temp	pointer
;	O
temp	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
temp	pointer
->	O
next	pointer
;	O
key	long
=	O
hash_data	function
(	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
+	O
temp	pointer
->	O
u	union
.	O
w	long
,	O
temp	pointer
->	O
v	union
.	O
w	long
)	O
&	O
(	O
(	O
_jitc	O
->	O
data	struct
.	O
size	long
<<	O
1	int
)	O
-	O
1	int
)	O
;	O
temp	pointer
->	O
next	pointer
=	O
hash	pointer
[	O
key	long
]	O
;	O
hash	pointer
[	O
key	long
]	O
=	O
temp	pointer
;	O
}	O
}	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
table	pointer
)	O
;	O
_jitc	O
->	O
data	struct
.	O
table	pointer
=	O
hash	pointer
;	O
_jitc	O
->	O
data	struct
.	O
size	long
<<=	O
1	int
;	O
}	O
}	O
return	O
(	O
node	pointer
)	O
;	O
}	O
static	O
void	O
_new_pool	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
list	pointer
;	O
jit_int32_t	int
offset	short
;	O
if	O
(	O
_jitc	O
->	O
pool	struct
.	O
offset	short
>=	O
_jitc	O
->	O
pool	struct
.	O
length	long
)	O
{	O
jit_int32_t	int
length	long
;	O
length	long
=	O
_jitc	O
->	O
pool	struct
.	O
length	long
+	O
16	int
;	O
jit_realloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
,	O
_jitc	O
->	O
pool	struct
.	O
length	long
*	O
sizeof	O
(	O
jit_node_t	struct
*	O
)	O
,	O
length	long
*	O
sizeof	O
(	O
jit_node_t	struct
*	O
)	O
)	O
;	O
_jitc	O
->	O
pool	struct
.	O
length	long
=	O
length	long
;	O
}	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
(	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
+	O
_jitc	O
->	O
pool	struct
.	O
offset	short
)	O
,	O
sizeof	O
(	O
jit_node_t	struct
)	O
*	O
1024	int
)	O
;	O
list	pointer
=	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
[	O
_jitc	O
->	O
pool	struct
.	O
offset	short
]	O
;	O
for	O
(	O
offset	short
=	O
1	int
;	O
offset	short
<	O
1024	int
;	O
offset	short
++	O
,	O
list	pointer
++	O
)	O
list	pointer
->	O
next	pointer
=	O
list	pointer
+	O
1	int
;	O
list	pointer
->	O
next	pointer
=	O
_jitc	O
->	O
list	pointer
;	O
_jitc	O
->	O
list	pointer
=	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
[	O
_jitc	O
->	O
pool	struct
.	O
offset	short
]	O
;	O
++	O
_jitc	O
->	O
pool	struct
.	O
offset	short
;	O
}	O
static	O
jit_node_t	struct
*	O
_new_node	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
)	O
{	O
jit_node_t	struct
*	O
node	pointer
;	O
if	O
(	O
_jitc	O
->	O
list	pointer
==	O
NULL	O
)	O
new_pool	O
(	O
)	O
;	O
node	pointer
=	O
_jitc	O
->	O
list	pointer
;	O
_jitc	O
->	O
list	pointer
=	O
node	pointer
->	O
next	pointer
;	O
if	O
(	O
_jitc	O
->	O
synth	int
)	O
node	pointer
->	O
flag	short
|=	O
jit_flag_synth	int
;	O
node	pointer
->	O
next	pointer
=	O
NULL	O
;	O
node	pointer
->	O
code	pointer
=	O
code	pointer
;	O
return	O
(	O
node	pointer
)	O
;	O
}	O
static	O
inline	O
jit_node_t	struct
*	O
_link_node	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
_jitc	O
->	O
tail	pointer
)	O
_jitc	O
->	O
tail	pointer
->	O
next	pointer
=	O
node	pointer
;	O
else	O
_jitc	O
->	O
head	pointer
=	O
node	pointer
;	O
return	O
(	O
_jitc	O
->	O
tail	pointer
=	O
node	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
_del_node	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
prev	pointer
==	O
node	pointer
)	O
{	O
assert	O
(	O
prev	pointer
==	O
_jitc	O
->	O
head	pointer
)	O
;	O
_jitc	O
->	O
head	pointer
=	O
node	pointer
->	O
next	pointer
;	O
}	O
else	O
prev	pointer
->	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
memset	function
(	O
node	pointer
,	O
0	int
,	O
sizeof	O
(	O
jit_node_t	struct
)	O
)	O
;	O
node	pointer
->	O
next	pointer
=	O
_jitc	O
->	O
list	pointer
;	O
_jitc	O
->	O
list	pointer
=	O
node	pointer
;	O
}	O
static	O
inline	O
void	O
_free_node	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
memset	function
(	O
node	pointer
,	O
0	int
,	O
sizeof	O
(	O
jit_node_t	struct
)	O
)	O
;	O
node	pointer
->	O
next	pointer
=	O
_jitc	O
->	O
list	pointer
;	O
_jitc	O
->	O
list	pointer
=	O
node	pointer
;	O
}	O
static	O
void	O
_del_label	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_block_t	struct
*	O
block	pointer
;	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
v	union
.	O
w	long
;	O
assert	O
(	O
block	pointer
->	O
label	pointer
==	O
node	pointer
)	O
;	O
jit_regset_del	O
(	O
&	O
block	pointer
->	O
reglive	long
)	O
;	O
jit_regset_del	O
(	O
&	O
block	pointer
->	O
regmask	long
)	O
;	O
block	pointer
->	O
label	pointer
=	O
NULL	O
;	O
assert	O
(	O
node	pointer
->	O
link	function
==	O
NULL	O
)	O
;	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
}	O
jit_state_t	struct
*	O
jit_new_state	function
(	O
void	O
)	O
{	O
jit_state_t	struct
*	O
_jit	pointer
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jit	pointer
,	O
sizeof	O
(	O
jit_state_t	struct
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
,	O
sizeof	O
(	O
jit_compiler_t	struct
)	O
)	O
;	O
jit_regset_new	O
(	O
&	O
_jitc	O
->	O
regarg	long
)	O
;	O
jit_regset_new	O
(	O
&	O
_jitc	O
->	O
regsav	long
)	O
;	O
jit_regset_new	O
(	O
&	O
_jitc	O
->	O
reglive	long
)	O
;	O
jit_regset_new	O
(	O
&	O
_jitc	O
->	O
regmask	long
)	O
;	O
jit_init	O
(	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
spill	pointer
,	O
_jitc	O
->	O
reglen	int
*	O
sizeof	O
(	O
jit_node_t	struct
*	O
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
gen	pointer
,	O
_jitc	O
->	O
reglen	int
*	O
sizeof	O
(	O
jit_int32_t	int
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
values	pointer
,	O
_jitc	O
->	O
reglen	int
*	O
sizeof	O
(	O
jit_value_t	struct
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
patches	struct
.	O
ptr	pointer
,	O
(	O
_jitc	O
->	O
patches	struct
.	O
length	long
=	O
1024	int
)	O
*	O
sizeof	O
(	O
jit_patch_t	struct
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
functions	struct
.	O
ptr	pointer
,	O
(	O
_jitc	O
->	O
functions	struct
.	O
length	long
=	O
16	int
)	O
*	O
sizeof	O
(	O
jit_function_t	struct
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
,	O
(	O
_jitc	O
->	O
pool	struct
.	O
length	long
=	O
16	int
)	O
*	O
sizeof	O
(	O
jit_node_t	struct
*	O
)	O
)	O
;	O
jit_alloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
,	O
(	O
_jitc	O
->	O
blocks	struct
.	O
length	long
=	O
16	int
)	O
*	O
sizeof	O
(	O
jit_block_t	struct
)	O
)	O
;	O
_jit	pointer
->	O
note	pointer
.	O
length	long
=	O
1	int
;	O
_jitc	O
->	O
note	pointer
.	O
size	long
=	O
sizeof	O
(	O
jit_note_t	struct
)	O
;	O
return	O
(	O
_jit	pointer
)	O
;	O
}	O
void	O
_jit_clear_state	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_word_t	long
offset	short
;	O
jit_function_t	struct
*	O
function	pointer
;	O
_jitc	O
->	O
head	pointer
=	O
_jitc	O
->	O
tail	pointer
=	O
NULL	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
table	pointer
)	O
;	O
_jitc	O
->	O
data	struct
.	O
size	long
=	O
_jitc	O
->	O
data	struct
.	O
count	long
=	O
0	int
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
spill	pointer
)	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
gen	pointer
)	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
values	pointer
)	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
)	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
patches	struct
.	O
ptr	pointer
)	O
;	O
_jitc	O
->	O
patches	struct
.	O
offset	short
=	O
_jitc	O
->	O
patches	struct
.	O
length	long
=	O
0	int
;	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
functions	struct
.	O
offset	short
;	O
offset	short
++	O
)	O
{	O
function	pointer
=	O
_jitc	O
->	O
functions	struct
.	O
ptr	pointer
+	O
offset	short
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
function	pointer
->	O
regoff	pointer
)	O
;	O
}	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
functions	struct
.	O
ptr	pointer
)	O
;	O
_jitc	O
->	O
functions	struct
.	O
offset	short
=	O
_jitc	O
->	O
functions	struct
.	O
length	long
=	O
0	int
;	O
_jitc	O
->	O
function	pointer
=	O
NULL	O
;	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
pool	struct
.	O
offset	short
;	O
offset	short
++	O
)	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
(	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
+	O
offset	short
)	O
)	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
pool	struct
.	O
ptr	pointer
)	O
;	O
_jitc	O
->	O
pool	struct
.	O
offset	short
=	O
_jitc	O
->	O
pool	struct
.	O
length	long
=	O
0	int
;	O
_jitc	O
->	O
list	pointer
=	O
NULL	O
;	O
_jitc	O
->	O
note	pointer
.	O
head	pointer
=	O
_jitc	O
->	O
note	pointer
.	O
tail	pointer
=	O
_jitc	O
->	O
note	pointer
.	O
name	pointer
=	O
_jitc	O
->	O
note	pointer
.	O
note	pointer
=	O
NULL	O
;	O
_jitc	O
->	O
note	pointer
.	O
base	union
=	O
NULL	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
)	O
;	O
}	O
void	O
_jit_destroy_state	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
if	O
(	O
!	O
_jit	pointer
->	O
user_code	int
)	O
munmap	function
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
,	O
_jit	pointer
->	O
code	pointer
.	O
length	long
)	O
;	O
if	O
(	O
!	O
_jit	pointer
->	O
user_data	int
)	O
munmap	function
(	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
,	O
_jit	pointer
->	O
data	struct
.	O
length	long
)	O
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jit	pointer
)	O
;	O
}	O
void	O
_jit_synth_inc	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
assert	O
(	O
_jitc	O
->	O
synth	int
<	O
8	int
)	O
;	O
++	O
_jitc	O
->	O
synth	int
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
)	O
{	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
return	O
(	O
link_node	O
(	O
new_node	O
(	O
code	pointer
)	O
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_no_link	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
)	O
{	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
return	O
(	O
new_node	O
(	O
code	pointer
)	O
)	O
;	O
}	O
void	O
_jit_link_node	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
link_node	O
(	O
node	pointer
)	O
;	O
}	O
void	O
_jit_synth_dec	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
assert	O
(	O
_jitc	O
->	O
synth	int
>	O
0	int
)	O
;	O
--	O
_jitc	O
->	O
synth	int
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_w	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_f	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_float32_t	float
u	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
f	float
=	O
u	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_d	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_float64_t	double
u	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
d	double
=	O
u	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_pointer_t	pointer
u	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
p	pointer
=	O
u	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_ww	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_word_t	long
v	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_wp	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_pointer_t	pointer
v	union
)	O
{	O
return	O
(	O
jit_new_node_ww	O
(	O
code	pointer
,	O
u	union
,	O
(	O
jit_word_t	long
)	O
v	union
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_fp	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_float32_t	float
u	union
,	O
jit_pointer_t	pointer
v	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
f	float
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
(	O
jit_word_t	long
)	O
v	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_dp	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_float64_t	double
u	union
,	O
jit_pointer_t	pointer
v	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
d	double
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
(	O
jit_word_t	long
)	O
v	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_pw	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_pointer_t	pointer
u	union
,	O
jit_word_t	long
v	union
)	O
{	O
return	O
(	O
jit_new_node_ww	O
(	O
code	pointer
,	O
(	O
jit_word_t	long
)	O
u	union
,	O
v	union
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_wf	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_float32_t	float
v	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
f	float
=	O
v	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_wd	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_float64_t	double
v	union
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
d	double
=	O
v	union
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_www	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_word_t	long
v	union
,	O
jit_word_t	long
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
w	long
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_qww	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_int32_t	int
l	int
,	O
jit_int32_t	int
h	int
,	O
jit_word_t	long
v	union
,	O
jit_word_t	long
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
assert	O
(	O
l	int
!=	O
h	int
)	O
;	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
=	O
l	int
;	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
=	O
h	int
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
w	long
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_wwf	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_word_t	long
v	union
,	O
jit_float32_t	float
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
f	float
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_wwd	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_word_t	long
u	union
,	O
jit_word_t	long
v	union
,	O
jit_float64_t	double
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
d	double
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_pww	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_pointer_t	pointer
u	union
,	O
jit_word_t	long
v	union
,	O
jit_word_t	long
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
p	pointer
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
w	long
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_pwf	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_pointer_t	pointer
u	union
,	O
jit_word_t	long
v	union
,	O
jit_float32_t	float
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
p	pointer
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
f	float
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_new_node_pwd	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
,	O
jit_pointer_t	pointer
u	union
,	O
jit_word_t	long
v	union
,	O
jit_float64_t	double
w	long
)	O
{	O
jit_node_t	struct
*	O
node	pointer
=	O
new_node	O
(	O
code	pointer
)	O
;	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
node	pointer
->	O
u	union
.	O
p	pointer
=	O
u	union
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
v	union
;	O
node	pointer
->	O
w	long
.	O
d	double
=	O
w	long
;	O
return	O
(	O
link_node	O
(	O
node	pointer
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_label	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
node	pointer
;	O
if	O
(	O
!	O
(	O
node	pointer
=	O
_jitc	O
->	O
tail	pointer
)	O
||	O
node	pointer
->	O
code	pointer
!=	O
jit_code_label	int
)	O
{	O
node	pointer
=	O
jit_forward	O
(	O
)	O
;	O
jit_link	O
(	O
node	pointer
)	O
;	O
}	O
return	O
(	O
node	pointer
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_forward	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
return	O
(	O
jit_new_node_no_link	O
(	O
jit_code_label	int
)	O
)	O
;	O
}	O
jit_node_t	struct
*	O
_jit_indirect	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
node	pointer
;	O
node	pointer
=	O
jit_label	O
(	O
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_use	int
;	O
return	O
(	O
node	pointer
)	O
;	O
}	O
void	O
_jit_link	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_block_t	struct
*	O
block	pointer
;	O
assert	O
(	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
||	O
node	pointer
->	O
code	pointer
==	O
jit_code_prolog	int
||	O
node	pointer
->	O
code	pointer
==	O
jit_code_epilog	int
)	O
&&	O
!	O
node	pointer
->	O
next	pointer
)	O
;	O
jit_link_node	O
(	O
node	pointer
)	O
;	O
if	O
(	O
_jitc	O
->	O
blocks	struct
.	O
offset	short
>=	O
_jitc	O
->	O
blocks	struct
.	O
length	long
)	O
{	O
jit_word_t	long
length	long
;	O
length	long
=	O
_jitc	O
->	O
blocks	struct
.	O
length	long
+	O
16	int
;	O
jit_realloc	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
,	O
_jitc	O
->	O
blocks	struct
.	O
length	long
*	O
sizeof	O
(	O
jit_block_t	struct
)	O
,	O
length	long
*	O
sizeof	O
(	O
jit_block_t	struct
)	O
)	O
;	O
_jitc	O
->	O
blocks	struct
.	O
length	long
=	O
length	long
;	O
}	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
_jitc	O
->	O
blocks	struct
.	O
offset	short
;	O
block	pointer
->	O
label	pointer
=	O
node	pointer
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
_jitc	O
->	O
blocks	struct
.	O
offset	short
;	O
jit_regset_new	O
(	O
&	O
block	pointer
->	O
reglive	long
)	O
;	O
jit_regset_new	O
(	O
&	O
block	pointer
->	O
regmask	long
)	O
;	O
++	O
_jitc	O
->	O
blocks	struct
.	O
offset	short
;	O
}	O
jit_bool_t	int
_jit_forward_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
return	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
&&	O
!	O
node	pointer
->	O
next	pointer
&&	O
node	pointer
!=	O
_jitc	O
->	O
tail	pointer
)	O
;	O
}	O
jit_bool_t	int
_jit_indirect_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
return	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
&&	O
!	O
!	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_use	int
)	O
)	O
;	O
}	O
jit_bool_t	int
_jit_target_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
return	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
&&	O
!	O
!	O
node	pointer
->	O
link	function
)	O
;	O
}	O
void	O
_jit_prepare	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
assert	O
(	O
_jitc	O
->	O
function	pointer
!=	O
NULL	O
)	O
;	O
_jitc	O
->	O
function	pointer
->	O
call	int
.	O
call	int
=	O
jit_call_default	int
;	O
_jitc	O
->	O
function	pointer
->	O
call	int
.	O
argi	int
=	O
_jitc	O
->	O
function	pointer
->	O
call	int
.	O
argf	int
=	O
_jitc	O
->	O
function	pointer
->	O
call	int
.	O
size	long
=	O
0	int
;	O
_jitc	O
->	O
prepare	pointer
=	O
jit_new_node	O
(	O
jit_code_prepare	int
)	O
;	O
}	O
void	O
_jit_patch	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
instr	pointer
)	O
{	O
jit_node_t	struct
*	O
label	pointer
;	O
if	O
(	O
!	O
(	O
label	pointer
=	O
_jitc	O
->	O
tail	pointer
)	O
||	O
label	pointer
->	O
code	pointer
!=	O
jit_code_label	int
)	O
label	pointer
=	O
jit_label	O
(	O
)	O
;	O
jit_patch_at	O
(	O
instr	pointer
,	O
label	pointer
)	O
;	O
}	O
jit_int32_t	int
_jit_classify	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_code_t	enum
code	pointer
)	O
{	O
jit_int32_t	int
mask	pointer
;	O
switch	O
(	O
code	pointer
)	O
{	O
case	O
jit_code_data	int
:	O
case	O
jit_code_save	int
:	O
case	O
jit_code_load	int
:	O
case	O
jit_code_name	int
:	O
case	O
jit_code_label	int
:	O
case	O
jit_code_note	int
:	O
case	O
jit_code_prolog	int
:	O
case	O
jit_code_ellipsis	int
:	O
case	O
jit_code_va_push	int
:	O
case	O
jit_code_epilog	int
:	O
case	O
jit_code_ret	int
:	O
case	O
jit_code_prepare	int
:	O
mask	pointer
=	O
0	int
;	O
break	O
;	O
case	O
jit_code_live	int
:	O
case	O
jit_code_va_end	int
:	O
case	O
jit_code_retr	int
:	O
case	O
jit_code_retr_f	int
:	O
case	O
jit_code_retr_d	int
:	O
case	O
jit_code_pushargr	int
:	O
case	O
jit_code_pushargr_f	int
:	O
case	O
jit_code_pushargr_d	int
:	O
case	O
jit_code_finishr	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
;	O
break	O
;	O
case	O
jit_code_align	int
:	O
case	O
jit_code_reti	int
:	O
case	O
jit_code_pushargi	int
:	O
case	O
jit_code_finishi	int
:	O
mask	pointer
=	O
jit_cc_a0_int	int
;	O
break	O
;	O
case	O
jit_code_reti_f	int
:	O
case	O
jit_code_pushargi_f	int
:	O
mask	pointer
=	O
jit_cc_a0_flt	int
;	O
break	O
;	O
case	O
jit_code_reti_d	int
:	O
case	O
jit_code_pushargi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_dbl	int
;	O
break	O
;	O
case	O
jit_code_allocai	int
:	O
mask	pointer
=	O
jit_cc_a0_int	int
|	O
jit_cc_a1_int	int
;	O
break	O
;	O
case	O
jit_code_arg	int
:	O
case	O
jit_code_arg_f	int
:	O
case	O
jit_code_arg_d	int
:	O
mask	pointer
=	O
jit_cc_a0_int	int
|	O
jit_cc_a0_arg	int
;	O
break	O
;	O
case	O
jit_code_calli	int
:	O
case	O
jit_code_jmpi	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
;	O
break	O
;	O
case	O
jit_code_callr	int
:	O
case	O
jit_code_jmpr	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_jmp	int
;	O
break	O
;	O
case	O
jit_code_retval_c	int
:	O
case	O
jit_code_retval_uc	int
:	O
case	O
jit_code_retval_s	int
:	O
case	O
jit_code_retval_us	int
:	O
case	O
jit_code_retval_i	int
:	O
case	O
jit_code_retval_ui	int
:	O
case	O
jit_code_retval_l	int
:	O
case	O
jit_code_retval_f	int
:	O
case	O
jit_code_retval_d	int
:	O
case	O
jit_code_va_start	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
;	O
break	O
;	O
case	O
jit_code_getarg_c	int
:	O
case	O
jit_code_getarg_uc	int
:	O
case	O
jit_code_getarg_s	int
:	O
case	O
jit_code_getarg_us	int
:	O
case	O
jit_code_getarg_i	int
:	O
case	O
jit_code_getarg_ui	int
:	O
case	O
jit_code_getarg_l	int
:	O
case	O
jit_code_getarg_f	int
:	O
case	O
jit_code_getarg_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_arg	int
;	O
break	O
;	O
case	O
jit_code_putargr	int
:	O
case	O
jit_code_putargr_f	int
:	O
case	O
jit_code_putargr_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a1_arg	int
;	O
break	O
;	O
case	O
jit_code_putargi	int
:	O
mask	pointer
=	O
jit_cc_a0_int	int
|	O
jit_cc_a1_arg	int
;	O
break	O
;	O
case	O
jit_code_putargi_f	int
:	O
mask	pointer
=	O
jit_cc_a0_flt	int
|	O
jit_cc_a1_arg	int
;	O
break	O
;	O
case	O
jit_code_putargi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_dbl	int
|	O
jit_cc_a1_arg	int
;	O
break	O
;	O
case	O
jit_code_movi	int
:	O
case	O
jit_code_ldi_c	int
:	O
case	O
jit_code_ldi_uc	int
:	O
case	O
jit_code_ldi_s	int
:	O
case	O
jit_code_ldi_us	int
:	O
case	O
jit_code_ldi_i	int
:	O
case	O
jit_code_ldi_ui	int
:	O
case	O
jit_code_ldi_l	int
:	O
case	O
jit_code_ldi_f	int
:	O
case	O
jit_code_ldi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_int	int
;	O
break	O
;	O
case	O
jit_code_movi_f	int
:	O
case	O
jit_code_movi_f_w	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_flt	int
;	O
break	O
;	O
case	O
jit_code_movi_d	int
:	O
case	O
jit_code_movi_d_w	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_dbl	int
;	O
break	O
;	O
case	O
jit_code_movi_d_ww	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
|	O
jit_cc_a2_dbl	int
;	O
break	O
;	O
case	O
jit_code_negr	int
:	O
case	O
jit_code_comr	int
:	O
case	O
jit_code_movr	int
:	O
case	O
jit_code_extr_c	int
:	O
case	O
jit_code_extr_uc	int
:	O
case	O
jit_code_extr_s	int
:	O
case	O
jit_code_extr_us	int
:	O
case	O
jit_code_extr_i	int
:	O
case	O
jit_code_extr_ui	int
:	O
case	O
jit_code_truncr_f_i	int
:	O
case	O
jit_code_truncr_f_l	int
:	O
case	O
jit_code_truncr_d_i	int
:	O
case	O
jit_code_truncr_d_l	int
:	O
case	O
jit_code_htonr_us	int
:	O
case	O
jit_code_htonr_ui	int
:	O
case	O
jit_code_htonr_ul	int
:	O
case	O
jit_code_ldr_c	int
:	O
case	O
jit_code_ldr_uc	int
:	O
case	O
jit_code_ldr_s	int
:	O
case	O
jit_code_ldr_us	int
:	O
case	O
jit_code_ldr_i	int
:	O
case	O
jit_code_ldr_ui	int
:	O
case	O
jit_code_ldr_l	int
:	O
case	O
jit_code_negr_f	int
:	O
case	O
jit_code_absr_f	int
:	O
case	O
jit_code_sqrtr_f	int
:	O
case	O
jit_code_movr_f	int
:	O
case	O
jit_code_extr_f	int
:	O
case	O
jit_code_extr_d_f	int
:	O
case	O
jit_code_ldr_f	int
:	O
case	O
jit_code_negr_d	int
:	O
case	O
jit_code_absr_d	int
:	O
case	O
jit_code_sqrtr_d	int
:	O
case	O
jit_code_movr_d	int
:	O
case	O
jit_code_extr_d	int
:	O
case	O
jit_code_extr_f_d	int
:	O
case	O
jit_code_ldr_d	int
:	O
case	O
jit_code_movr_w_f	int
:	O
case	O
jit_code_movr_f_w	int
:	O
case	O
jit_code_movr_w_d	int
:	O
case	O
jit_code_movr_d_w	int
:	O
case	O
jit_code_va_arg	int
:	O
case	O
jit_code_va_arg_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
;	O
break	O
;	O
case	O
jit_code_movr_d_ww	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
case	O
jit_code_addi	int
:	O
case	O
jit_code_addxi	int
:	O
case	O
jit_code_addci	int
:	O
case	O
jit_code_subi	int
:	O
case	O
jit_code_subxi	int
:	O
case	O
jit_code_subci	int
:	O
case	O
jit_code_rsbi	int
:	O
case	O
jit_code_muli	int
:	O
case	O
jit_code_divi	int
:	O
case	O
jit_code_divi_u	int
:	O
case	O
jit_code_remi	int
:	O
case	O
jit_code_remi_u	int
:	O
case	O
jit_code_andi	int
:	O
case	O
jit_code_ori	int
:	O
case	O
jit_code_xori	int
:	O
case	O
jit_code_lshi	int
:	O
case	O
jit_code_rshi	int
:	O
case	O
jit_code_rshi_u	int
:	O
case	O
jit_code_lti	int
:	O
case	O
jit_code_lti_u	int
:	O
case	O
jit_code_lei	int
:	O
case	O
jit_code_lei_u	int
:	O
case	O
jit_code_eqi	int
:	O
case	O
jit_code_gei	int
:	O
case	O
jit_code_gei_u	int
:	O
case	O
jit_code_gti	int
:	O
case	O
jit_code_gti_u	int
:	O
case	O
jit_code_nei	int
:	O
case	O
jit_code_ldxi_c	int
:	O
case	O
jit_code_ldxi_uc	int
:	O
case	O
jit_code_ldxi_s	int
:	O
case	O
jit_code_ldxi_us	int
:	O
case	O
jit_code_ldxi_i	int
:	O
case	O
jit_code_ldxi_ui	int
:	O
case	O
jit_code_ldxi_l	int
:	O
case	O
jit_code_ldxi_f	int
:	O
case	O
jit_code_ldxi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_int	int
;	O
break	O
;	O
case	O
jit_code_qmuli	int
:	O
case	O
jit_code_qmuli_u	int
:	O
case	O
jit_code_qdivi	int
:	O
case	O
jit_code_qdivi_u	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_rlh	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_int	int
;	O
break	O
;	O
case	O
jit_code_addi_f	int
:	O
case	O
jit_code_subi_f	int
:	O
case	O
jit_code_rsbi_f	int
:	O
case	O
jit_code_muli_f	int
:	O
case	O
jit_code_divi_f	int
:	O
case	O
jit_code_lti_f	int
:	O
case	O
jit_code_lei_f	int
:	O
case	O
jit_code_eqi_f	int
:	O
case	O
jit_code_gei_f	int
:	O
case	O
jit_code_gti_f	int
:	O
case	O
jit_code_nei_f	int
:	O
case	O
jit_code_unlti_f	int
:	O
case	O
jit_code_unlei_f	int
:	O
case	O
jit_code_uneqi_f	int
:	O
case	O
jit_code_ungei_f	int
:	O
case	O
jit_code_ungti_f	int
:	O
case	O
jit_code_ltgti_f	int
:	O
case	O
jit_code_ordi_f	int
:	O
case	O
jit_code_unordi_f	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_flt	int
;	O
break	O
;	O
case	O
jit_code_addi_d	int
:	O
case	O
jit_code_subi_d	int
:	O
case	O
jit_code_rsbi_d	int
:	O
case	O
jit_code_muli_d	int
:	O
case	O
jit_code_divi_d	int
:	O
case	O
jit_code_lti_d	int
:	O
case	O
jit_code_lei_d	int
:	O
case	O
jit_code_eqi_d	int
:	O
case	O
jit_code_gei_d	int
:	O
case	O
jit_code_gti_d	int
:	O
case	O
jit_code_nei_d	int
:	O
case	O
jit_code_unlti_d	int
:	O
case	O
jit_code_unlei_d	int
:	O
case	O
jit_code_uneqi_d	int
:	O
case	O
jit_code_ungei_d	int
:	O
case	O
jit_code_ungti_d	int
:	O
case	O
jit_code_ltgti_d	int
:	O
case	O
jit_code_ordi_d	int
:	O
case	O
jit_code_unordi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_dbl	int
;	O
break	O
;	O
case	O
jit_code_addr	int
:	O
case	O
jit_code_addxr	int
:	O
case	O
jit_code_addcr	int
:	O
case	O
jit_code_subr	int
:	O
case	O
jit_code_subxr	int
:	O
case	O
jit_code_subcr	int
:	O
case	O
jit_code_mulr	int
:	O
case	O
jit_code_divr	int
:	O
case	O
jit_code_divr_u	int
:	O
case	O
jit_code_remr	int
:	O
case	O
jit_code_remr_u	int
:	O
case	O
jit_code_andr	int
:	O
case	O
jit_code_orr	int
:	O
case	O
jit_code_xorr	int
:	O
case	O
jit_code_lshr	int
:	O
case	O
jit_code_rshr	int
:	O
case	O
jit_code_rshr_u	int
:	O
case	O
jit_code_ltr	int
:	O
case	O
jit_code_ltr_u	int
:	O
case	O
jit_code_ler	int
:	O
case	O
jit_code_ler_u	int
:	O
case	O
jit_code_eqr	int
:	O
case	O
jit_code_ger	int
:	O
case	O
jit_code_ger_u	int
:	O
case	O
jit_code_gtr	int
:	O
case	O
jit_code_gtr_u	int
:	O
case	O
jit_code_ner	int
:	O
case	O
jit_code_ldxr_c	int
:	O
case	O
jit_code_ldxr_uc	int
:	O
case	O
jit_code_ldxr_s	int
:	O
case	O
jit_code_ldxr_us	int
:	O
case	O
jit_code_ldxr_i	int
:	O
case	O
jit_code_ldxr_ui	int
:	O
case	O
jit_code_ldxr_l	int
:	O
case	O
jit_code_addr_f	int
:	O
case	O
jit_code_subr_f	int
:	O
case	O
jit_code_mulr_f	int
:	O
case	O
jit_code_divr_f	int
:	O
case	O
jit_code_ltr_f	int
:	O
case	O
jit_code_ler_f	int
:	O
case	O
jit_code_eqr_f	int
:	O
case	O
jit_code_ger_f	int
:	O
case	O
jit_code_gtr_f	int
:	O
case	O
jit_code_ner_f	int
:	O
case	O
jit_code_unltr_f	int
:	O
case	O
jit_code_unler_f	int
:	O
case	O
jit_code_uneqr_f	int
:	O
case	O
jit_code_unger_f	int
:	O
case	O
jit_code_ungtr_f	int
:	O
case	O
jit_code_ltgtr_f	int
:	O
case	O
jit_code_ordr_f	int
:	O
case	O
jit_code_unordr_f	int
:	O
case	O
jit_code_ldxr_f	int
:	O
case	O
jit_code_addr_d	int
:	O
case	O
jit_code_subr_d	int
:	O
case	O
jit_code_mulr_d	int
:	O
case	O
jit_code_divr_d	int
:	O
case	O
jit_code_ltr_d	int
:	O
case	O
jit_code_ler_d	int
:	O
case	O
jit_code_eqr_d	int
:	O
case	O
jit_code_ger_d	int
:	O
case	O
jit_code_gtr_d	int
:	O
case	O
jit_code_ner_d	int
:	O
case	O
jit_code_unltr_d	int
:	O
case	O
jit_code_unler_d	int
:	O
case	O
jit_code_uneqr_d	int
:	O
case	O
jit_code_unger_d	int
:	O
case	O
jit_code_ungtr_d	int
:	O
case	O
jit_code_ltgtr_d	int
:	O
case	O
jit_code_ordr_d	int
:	O
case	O
jit_code_unordr_d	int
:	O
case	O
jit_code_ldxr_d	int
:	O
case	O
jit_code_movr_ww_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
case	O
jit_code_qmulr	int
:	O
case	O
jit_code_qmulr_u	int
:	O
case	O
jit_code_qdivr	int
:	O
case	O
jit_code_qdivr_u	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_rlh	int
|	O
jit_cc_a0_chg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
case	O
jit_code_sti_c	int
:	O
case	O
jit_code_sti_s	int
:	O
case	O
jit_code_sti_i	int
:	O
case	O
jit_code_sti_l	int
:	O
case	O
jit_code_sti_f	int
:	O
case	O
jit_code_sti_d	int
:	O
mask	pointer
=	O
jit_cc_a0_int	int
|	O
jit_cc_a1_reg	int
;	O
break	O
;	O
case	O
jit_code_blti	int
:	O
case	O
jit_code_blti_u	int
:	O
case	O
jit_code_blei	int
:	O
case	O
jit_code_blei_u	int
:	O
case	O
jit_code_beqi	int
:	O
case	O
jit_code_bgei	int
:	O
case	O
jit_code_bgei_u	int
:	O
case	O
jit_code_bgti	int
:	O
case	O
jit_code_bgti_u	int
:	O
case	O
jit_code_bnei	int
:	O
case	O
jit_code_bmsi	int
:	O
case	O
jit_code_bmci	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_int	int
;	O
break	O
;	O
case	O
jit_code_blti_f	int
:	O
case	O
jit_code_blei_f	int
:	O
case	O
jit_code_beqi_f	int
:	O
case	O
jit_code_bgei_f	int
:	O
case	O
jit_code_bgti_f	int
:	O
case	O
jit_code_bnei_f	int
:	O
case	O
jit_code_bunlti_f	int
:	O
case	O
jit_code_bunlei_f	int
:	O
case	O
jit_code_buneqi_f	int
:	O
case	O
jit_code_bungei_f	int
:	O
case	O
jit_code_bungti_f	int
:	O
case	O
jit_code_bltgti_f	int
:	O
case	O
jit_code_bordi_f	int
:	O
case	O
jit_code_bunordi_f	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_flt	int
;	O
break	O
;	O
case	O
jit_code_blti_d	int
:	O
case	O
jit_code_blei_d	int
:	O
case	O
jit_code_beqi_d	int
:	O
case	O
jit_code_bgei_d	int
:	O
case	O
jit_code_bgti_d	int
:	O
case	O
jit_code_bnei_d	int
:	O
case	O
jit_code_bunlti_d	int
:	O
case	O
jit_code_bunlei_d	int
:	O
case	O
jit_code_buneqi_d	int
:	O
case	O
jit_code_bungei_d	int
:	O
case	O
jit_code_bungti_d	int
:	O
case	O
jit_code_bltgti_d	int
:	O
case	O
jit_code_bordi_d	int
:	O
case	O
jit_code_bunordi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_dbl	int
;	O
break	O
;	O
case	O
jit_code_allocar	int
:	O
case	O
jit_code_str_c	int
:	O
case	O
jit_code_str_s	int
:	O
case	O
jit_code_str_i	int
:	O
case	O
jit_code_str_l	int
:	O
case	O
jit_code_str_f	int
:	O
case	O
jit_code_str_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a1_reg	int
;	O
break	O
;	O
case	O
jit_code_stxi_c	int
:	O
case	O
jit_code_stxi_s	int
:	O
case	O
jit_code_stxi_i	int
:	O
case	O
jit_code_stxi_l	int
:	O
case	O
jit_code_stxi_f	int
:	O
case	O
jit_code_stxi_d	int
:	O
mask	pointer
=	O
jit_cc_a0_int	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
case	O
jit_code_bltr	int
:	O
case	O
jit_code_bltr_u	int
:	O
case	O
jit_code_bler	int
:	O
case	O
jit_code_bler_u	int
:	O
case	O
jit_code_beqr	int
:	O
case	O
jit_code_bger	int
:	O
case	O
jit_code_bger_u	int
:	O
case	O
jit_code_bgtr	int
:	O
case	O
jit_code_bgtr_u	int
:	O
case	O
jit_code_bner	int
:	O
case	O
jit_code_bmsr	int
:	O
case	O
jit_code_bmcr	int
:	O
case	O
jit_code_bltr_f	int
:	O
case	O
jit_code_bler_f	int
:	O
case	O
jit_code_beqr_f	int
:	O
case	O
jit_code_bger_f	int
:	O
case	O
jit_code_bgtr_f	int
:	O
case	O
jit_code_bner_f	int
:	O
case	O
jit_code_bunltr_f	int
:	O
case	O
jit_code_bunler_f	int
:	O
case	O
jit_code_buneqr_f	int
:	O
case	O
jit_code_bunger_f	int
:	O
case	O
jit_code_bungtr_f	int
:	O
case	O
jit_code_bltgtr_f	int
:	O
case	O
jit_code_bordr_f	int
:	O
case	O
jit_code_bunordr_f	int
:	O
case	O
jit_code_bltr_d	int
:	O
case	O
jit_code_bler_d	int
:	O
case	O
jit_code_beqr_d	int
:	O
case	O
jit_code_bger_d	int
:	O
case	O
jit_code_bgtr_d	int
:	O
case	O
jit_code_bner_d	int
:	O
case	O
jit_code_bunltr_d	int
:	O
case	O
jit_code_bunler_d	int
:	O
case	O
jit_code_buneqr_d	int
:	O
case	O
jit_code_bunger_d	int
:	O
case	O
jit_code_bungtr_d	int
:	O
case	O
jit_code_bltgtr_d	int
:	O
case	O
jit_code_bordr_d	int
:	O
case	O
jit_code_bunordr_d	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
case	O
jit_code_boaddi	int
:	O
case	O
jit_code_boaddi_u	int
:	O
case	O
jit_code_bxaddi	int
:	O
case	O
jit_code_bxaddi_u	int
:	O
case	O
jit_code_bosubi	int
:	O
case	O
jit_code_bosubi_u	int
:	O
case	O
jit_code_bxsubi	int
:	O
case	O
jit_code_bxsubi_u	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
|	O
jit_cc_a2_int	int
;	O
break	O
;	O
case	O
jit_code_stxr_c	int
:	O
case	O
jit_code_stxr_s	int
:	O
case	O
jit_code_stxr_i	int
:	O
case	O
jit_code_stxr_l	int
:	O
case	O
jit_code_stxr_f	int
:	O
case	O
jit_code_stxr_d	int
:	O
mask	pointer
=	O
jit_cc_a0_reg	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
case	O
jit_code_boaddr	int
:	O
case	O
jit_code_boaddr_u	int
:	O
case	O
jit_code_bxaddr	int
:	O
case	O
jit_code_bxaddr_u	int
:	O
case	O
jit_code_bosubr	int
:	O
case	O
jit_code_bosubr_u	int
:	O
case	O
jit_code_bxsubr	int
:	O
case	O
jit_code_bxsubr_u	int
:	O
mask	pointer
=	O
jit_cc_a0_jmp	int
|	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
|	O
jit_cc_a2_reg	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
return	O
(	O
mask	pointer
)	O
;	O
}	O
void	O
_jit_patch_abs	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
instr	pointer
,	O
jit_pointer_t	pointer
address	pointer
)	O
{	O
jit_int32_t	int
mask	pointer
;	O
switch	O
(	O
instr	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_movi	int
:	O
case	O
jit_code_ldi_c	int
:	O
case	O
jit_code_ldi_uc	int
:	O
case	O
jit_code_ldi_s	int
:	O
case	O
jit_code_ldi_us	int
:	O
case	O
jit_code_ldi_i	int
:	O
case	O
jit_code_ldi_ui	int
:	O
case	O
jit_code_ldi_l	int
:	O
case	O
jit_code_ldi_f	int
:	O
case	O
jit_code_ldi_d	int
:	O
instr	pointer
->	O
v	union
.	O
p	pointer
=	O
address	pointer
;	O
break	O
;	O
case	O
jit_code_sti_c	int
:	O
case	O
jit_code_sti_s	int
:	O
case	O
jit_code_sti_i	int
:	O
case	O
jit_code_sti_l	int
:	O
case	O
jit_code_sti_f	int
:	O
case	O
jit_code_sti_d	int
:	O
instr	pointer
->	O
u	union
.	O
p	pointer
=	O
address	pointer
;	O
break	O
;	O
default	O
:	O
mask	pointer
=	O
jit_classify	O
(	O
instr	pointer
->	O
code	pointer
)	O
;	O
assert	O
(	O
(	O
mask	pointer
&	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_jmp	int
)	O
)	O
==	O
jit_cc_a0_jmp	int
)	O
;	O
instr	pointer
->	O
u	union
.	O
p	pointer
=	O
address	pointer
;	O
}	O
}	O
void	O
_jit_patch_at	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
instr	pointer
,	O
jit_node_t	struct
*	O
label	pointer
)	O
{	O
jit_int32_t	int
mask	pointer
;	O
assert	O
(	O
!	O
(	O
instr	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
)	O
;	O
instr	pointer
->	O
flag	short
|=	O
jit_flag_node	int
;	O
switch	O
(	O
instr	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_movi	int
:	O
assert	O
(	O
label	pointer
->	O
code	pointer
==	O
jit_code_label	int
||	O
label	pointer
->	O
code	pointer
==	O
jit_code_data	int
)	O
;	O
instr	pointer
->	O
v	union
.	O
n	pointer
=	O
label	pointer
;	O
if	O
(	O
label	pointer
->	O
code	pointer
==	O
jit_code_data	int
)	O
instr	pointer
->	O
flag	short
|=	O
jit_flag_data	int
;	O
break	O
;	O
case	O
jit_code_jmpi	int
:	O
assert	O
(	O
label	pointer
->	O
code	pointer
==	O
jit_code_label	int
||	O
label	pointer
->	O
code	pointer
==	O
jit_code_epilog	int
)	O
;	O
instr	pointer
->	O
u	union
.	O
n	pointer
=	O
label	pointer
;	O
break	O
;	O
default	O
:	O
mask	pointer
=	O
jit_classify	O
(	O
instr	pointer
->	O
code	pointer
)	O
;	O
assert	O
(	O
(	O
mask	pointer
&	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_jmp	int
)	O
)	O
==	O
jit_cc_a0_jmp	int
)	O
;	O
assert	O
(	O
label	pointer
->	O
code	pointer
==	O
jit_code_label	int
)	O
;	O
instr	pointer
->	O
u	union
.	O
n	pointer
=	O
label	pointer
;	O
break	O
;	O
}	O
instr	pointer
->	O
link	function
=	O
label	pointer
->	O
link	function
;	O
label	pointer
->	O
link	function
=	O
instr	pointer
;	O
}	O
void	O
_jit_optimize	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_bool_t	int
jump	int
;	O
jit_bool_t	int
todo	pointer
;	O
jit_int32_t	int
mask	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_block_t	struct
*	O
block	pointer
;	O
jit_word_t	long
offset	short
;	O
_jitc	O
->	O
function	pointer
=	O
NULL	O
;	O
thread_jumps	O
(	O
)	O
;	O
sequential_labels	O
(	O
)	O
;	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
blocks	struct
.	O
offset	short
;	O
offset	short
++	O
)	O
{	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
offset	short
;	O
if	O
(	O
!	O
block	pointer
->	O
label	pointer
)	O
continue	O
;	O
if	O
(	O
block	pointer
->	O
label	pointer
->	O
code	pointer
!=	O
jit_code_epilog	int
)	O
jit_setup	O
(	O
block	pointer
)	O
;	O
}	O
do	O
{	O
todo	pointer
=	O
0	int
;	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
blocks	struct
.	O
offset	short
;	O
offset	short
++	O
)	O
{	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
offset	short
;	O
if	O
(	O
!	O
block	pointer
->	O
label	pointer
)	O
continue	O
;	O
if	O
(	O
block	pointer
->	O
label	pointer
->	O
code	pointer
!=	O
jit_code_epilog	int
)	O
jit_follow	O
(	O
block	pointer
,	O
&	O
todo	pointer
)	O
;	O
}	O
}	O
while	O
(	O
todo	pointer
)	O
;	O
patch_registers	O
(	O
)	O
;	O
simplify	O
(	O
)	O
;	O
jump	int
=	O
1	int
;	O
for	O
(	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
if	O
(	O
!	O
jump	int
)	O
node	pointer
->	O
flag	short
|=	O
jit_flag_head	int
;	O
break	O
;	O
case	O
jit_code_jmpi	int
:	O
case	O
jit_code_jmpr	int
:	O
case	O
jit_code_epilog	int
:	O
jump	int
=	O
1	int
;	O
break	O
;	O
case	O
jit_code_data	int
:	O
case	O
jit_code_note	int
:	O
break	O
;	O
default	O
:	O
jump	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
for	O
(	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
mask	pointer
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
mask	pointer
&	O
jit_cc_a0_reg	int
)	O
node	pointer
->	O
u	union
.	O
w	long
&=	O
~	O
jit_regno_patch	int
;	O
if	O
(	O
mask	pointer
&	O
jit_cc_a1_reg	int
)	O
node	pointer
->	O
v	union
.	O
w	long
&=	O
~	O
jit_regno_patch	int
;	O
if	O
(	O
mask	pointer
&	O
jit_cc_a2_reg	int
)	O
node	pointer
->	O
w	long
.	O
w	long
&=	O
~	O
jit_regno_patch	int
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_prolog	int
:	O
_jitc	O
->	O
function	pointer
=	O
_jitc	O
->	O
functions	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
w	long
.	O
w	long
;	O
break	O
;	O
case	O
jit_code_epilog	int
:	O
_jitc	O
->	O
function	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
jit_code_beqi	int
:	O
redundant_store	O
(	O
node	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
jit_code_bnei	int
:	O
redundant_store	O
(	O
node	pointer
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
mask	pointer
&	O
jit_cc_a0_flt	int
)	O
{	O
node	pointer
->	O
u	union
.	O
p	pointer
=	O
jit_data	union
(	O
&	O
node	pointer
->	O
u	union
.	O
f	float
,	O
sizeof	O
(	O
jit_float32_t	float
)	O
,	O
4	int
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_node	int
|	O
jit_flag_data	int
;	O
}	O
else	O
if	O
(	O
mask	pointer
&	O
jit_cc_a0_dbl	int
)	O
{	O
node	pointer
->	O
u	union
.	O
p	pointer
=	O
jit_data	union
(	O
&	O
node	pointer
->	O
u	union
.	O
d	double
,	O
sizeof	O
(	O
jit_float64_t	double
)	O
,	O
8	int
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_node	int
|	O
jit_flag_data	int
;	O
}	O
else	O
if	O
(	O
mask	pointer
&	O
jit_cc_a1_flt	int
)	O
{	O
node	pointer
->	O
v	union
.	O
p	pointer
=	O
jit_data	union
(	O
&	O
node	pointer
->	O
v	union
.	O
f	float
,	O
sizeof	O
(	O
jit_float32_t	float
)	O
,	O
4	int
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_node	int
|	O
jit_flag_data	int
;	O
}	O
else	O
if	O
(	O
mask	pointer
&	O
jit_cc_a1_dbl	int
)	O
{	O
node	pointer
->	O
v	union
.	O
p	pointer
=	O
jit_data	union
(	O
&	O
node	pointer
->	O
v	union
.	O
d	double
,	O
sizeof	O
(	O
jit_float64_t	double
)	O
,	O
8	int
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_node	int
|	O
jit_flag_data	int
;	O
}	O
else	O
if	O
(	O
mask	pointer
&	O
jit_cc_a2_flt	int
)	O
{	O
node	pointer
->	O
w	long
.	O
p	pointer
=	O
jit_data	union
(	O
&	O
node	pointer
->	O
w	long
.	O
f	float
,	O
sizeof	O
(	O
jit_float32_t	float
)	O
,	O
4	int
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_node	int
|	O
jit_flag_data	int
;	O
}	O
else	O
if	O
(	O
mask	pointer
&	O
jit_cc_a2_dbl	int
)	O
{	O
node	pointer
->	O
w	long
.	O
p	pointer
=	O
jit_data	union
(	O
&	O
node	pointer
->	O
w	long
.	O
d	double
,	O
sizeof	O
(	O
jit_float64_t	double
)	O
,	O
8	int
)	O
;	O
node	pointer
->	O
flag	short
|=	O
jit_flag_node	int
|	O
jit_flag_data	int
;	O
}	O
if	O
(	O
_jitc	O
->	O
function	pointer
)	O
{	O
if	O
(	O
(	O
mask	pointer
&	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
)	O
)	O
==	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
)	O
)	O
{	O
if	O
(	O
mask	pointer
&	O
jit_cc_a0_rlh	int
)	O
{	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
)	O
;	O
}	O
if	O
(	O
(	O
mask	pointer
&	O
(	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
)	O
)	O
==	O
(	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
)	O
;	O
if	O
(	O
(	O
mask	pointer
&	O
(	O
jit_cc_a2_reg	int
|	O
jit_cc_a2_chg	int
)	O
)	O
==	O
(	O
jit_cc_a2_reg	int
|	O
jit_cc_a2_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
jit_regno	O
(	O
node	pointer
->	O
w	long
.	O
w	long
)	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
void	O
_jit_reglive	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
value	int
;	O
jit_block_t	struct
*	O
block	pointer
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_prolog	int
:	O
case	O
jit_code_epilog	int
:	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
v	union
.	O
w	long
;	O
jit_regset_set	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
&	O
block	pointer
->	O
reglive	long
)	O
;	O
break	O
;	O
case	O
jit_code_callr	int
:	O
value	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
value	int
)	O
;	O
}	O
case	O
jit_code_calli	int
:	O
for	O
(	O
value	int
=	O
0	int
;	O
value	int
<	O
_jitc	O
->	O
reglen	int
;	O
value	int
++	O
)	O
{	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
value	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
(	O
spec	enum
&	O
jit_class_arg	int
)	O
&&	O
jit_regarg_p	O
(	O
node	pointer
,	O
value	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
value	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
spec	enum
&	O
jit_class_sav	int
)	O
)	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
value	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
value	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
&&	O
!	O
(	O
node	pointer
->	O
v	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a1_chg	int
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
}	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
&&	O
!	O
(	O
node	pointer
->	O
w	long
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a2_chg	int
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
}	O
if	O
(	O
jit_regset_set_p	O
(	O
&	O
_jitc	O
->	O
regmask	long
)	O
)	O
{	O
jit_update	O
(	O
node	pointer
->	O
next	pointer
,	O
&	O
_jitc	O
->	O
reglive	long
,	O
&	O
_jitc	O
->	O
regmask	long
)	O
;	O
if	O
(	O
jit_regset_set_p	O
(	O
&	O
_jitc	O
->	O
regmask	long
)	O
)	O
{	O
jit_regset_ior	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
&	O
_jitc	O
->	O
reglive	long
,	O
&	O
_jitc	O
->	O
regmask	long
)	O
;	O
jit_regset_set_ui	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
0	int
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
void	O
_jit_regarg_set	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
value	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
;	O
}	O
else	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
)	O
;	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
w	long
.	O
w	long
)	O
)	O
;	O
}	O
void	O
_jit_regarg_clr	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
value	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
)	O
;	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
;	O
}	O
else	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
)	O
;	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
jit_regno	O
(	O
node	pointer
->	O
w	long
.	O
w	long
)	O
)	O
;	O
}	O
void	O
_jit_realize	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
assert	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
;	O
if	O
(	O
_jitc	O
->	O
function	pointer
)	O
jit_epilog	O
(	O
)	O
;	O
jit_optimize	O
(	O
)	O
;	O
_jitc	O
->	O
realize	int
=	O
1	int
;	O
_jitc	O
->	O
data	struct
.	O
offset	short
=	O
(	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
7	int
)	O
&	O
-	O
8	int
;	O
_jit	pointer
->	O
code	pointer
.	O
length	long
=	O
jit_get_size	O
(	O
)	O
;	O
}	O
void	O
_jit_dataset	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_uint8_t	char
*	O
ptr	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_word_t	long
offset	short
;	O
assert	O
(	O
!	O
_jitc	O
->	O
dataset	int
)	O
;	O
if	O
(	O
!	O
_jit	pointer
->	O
user_data	int
)	O
{	O
_jit	pointer
->	O
data	struct
.	O
length	long
=	O
(	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
_jitc	O
->	O
note	pointer
.	O
size	long
+	O
4095	int
)	O
&	O
-	O
4096	int
;	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
=	O
mmap	function
(	O
NULL	O
,	O
_jit	pointer
->	O
data	struct
.	O
length	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_PRIVATE	int
|	O
MAP_ANON	O
,	O
mmap_fd	O
,	O
0	int
)	O
;	O
assert	O
(	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
!=	O
MAP_FAILED	O
)	O
;	O
}	O
if	O
(	O
!	O
_jitc	O
->	O
no_data	int
)	O
jit_memcpy	function
(	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
,	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
,	O
_jitc	O
->	O
data	struct
.	O
offset	short
)	O
;	O
if	O
(	O
_jitc	O
->	O
no_note	int
)	O
{	O
_jit	pointer
->	O
note	pointer
.	O
length	long
=	O
0	int
;	O
_jitc	O
->	O
note	pointer
.	O
size	long
=	O
0	int
;	O
}	O
else	O
{	O
_jitc	O
->	O
note	pointer
.	O
base	union
=	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
;	O
if	O
(	O
!	O
_jitc	O
->	O
no_data	int
)	O
_jitc	O
->	O
note	pointer
.	O
base	union
+=	O
_jitc	O
->	O
data	struct
.	O
offset	short
;	O
memset	function
(	O
_jitc	O
->	O
note	pointer
.	O
base	union
,	O
0	int
,	O
_jitc	O
->	O
note	pointer
.	O
size	long
)	O
;	O
}	O
if	O
(	O
_jit	pointer
->	O
user_data	int
)	O
ptr	pointer
=	O
_jitc	O
->	O
no_data	int
?	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
:	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
;	O
else	O
{	O
ptr	pointer
=	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
;	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
)	O
;	O
}	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
data	struct
.	O
size	long
;	O
offset	short
++	O
)	O
{	O
for	O
(	O
node	pointer
=	O
_jitc	O
->	O
data	struct
.	O
table	pointer
[	O
offset	short
]	O
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
node	pointer
->	O
flag	short
|=	O
jit_flag_patch	int
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
(	O
jit_word_t	long
)	O
(	O
ptr	pointer
+	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
}	O
_jitc	O
->	O
dataset	int
=	O
1	int
;	O
}	O
jit_pointer_t	pointer
_jit_get_code	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_word_t	long
*	O
length	long
)	O
{	O
assert	O
(	O
_jitc	O
->	O
realize	int
)	O
;	O
if	O
(	O
length	long
)	O
{	O
if	O
(	O
_jitc	O
->	O
done	int
)	O
*	O
length	long
=	O
_jit	pointer
->	O
pc	union
.	O
uc	pointer
-	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
;	O
else	O
*	O
length	long
=	O
_jit	pointer
->	O
code	pointer
.	O
length	long
;	O
}	O
return	O
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
)	O
;	O
}	O
void	O
_jit_set_code	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_pointer_t	pointer
ptr	pointer
,	O
jit_word_t	long
length	long
)	O
{	O
assert	O
(	O
_jitc	O
->	O
realize	int
)	O
;	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
=	O
ptr	pointer
;	O
_jit	pointer
->	O
code	pointer
.	O
length	long
=	O
length	long
;	O
_jit	pointer
->	O
user_code	int
=	O
1	int
;	O
}	O
jit_pointer_t	pointer
_jit_get_data	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_word_t	long
*	O
data_size	pointer
,	O
jit_word_t	long
*	O
note_size	pointer
)	O
{	O
assert	O
(	O
_jitc	O
->	O
realize	int
)	O
;	O
if	O
(	O
data_size	pointer
)	O
*	O
data_size	pointer
=	O
_jitc	O
->	O
data	struct
.	O
offset	short
;	O
if	O
(	O
note_size	pointer
)	O
*	O
note_size	pointer
=	O
_jitc	O
->	O
note	pointer
.	O
size	long
;	O
return	O
(	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
)	O
;	O
}	O
void	O
_jit_set_data	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_pointer_t	pointer
ptr	pointer
,	O
jit_word_t	long
length	long
,	O
jit_word_t	long
flags	long
)	O
{	O
assert	O
(	O
_jitc	O
->	O
realize	int
)	O
;	O
if	O
(	O
flags	long
&	O
JIT_DISABLE_DATA	int
)	O
_jitc	O
->	O
no_data	int
=	O
1	int
;	O
else	O
assert	O
(	O
length	long
>=	O
_jitc	O
->	O
data	struct
.	O
offset	short
)	O
;	O
if	O
(	O
flags	long
&	O
JIT_DISABLE_NOTE	int
)	O
_jitc	O
->	O
no_note	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
flags	long
&	O
JIT_DISABLE_DATA	int
)	O
assert	O
(	O
length	long
>=	O
_jitc	O
->	O
note	pointer
.	O
size	long
)	O
;	O
else	O
assert	O
(	O
length	long
>=	O
_jitc	O
->	O
data	struct
.	O
offset	short
+	O
_jitc	O
->	O
note	pointer
.	O
size	long
)	O
;	O
}	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
=	O
ptr	pointer
;	O
_jit	pointer
->	O
data	struct
.	O
length	long
=	O
length	long
;	O
_jit	pointer
->	O
user_data	int
=	O
1	int
;	O
}	O
jit_pointer_t	pointer
_jit_emit	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_pointer_t	pointer
code	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
size_t	long
length	long
;	O
int	O
result	int
;	O
if	O
(	O
!	O
_jitc	O
->	O
realize	int
)	O
jit_realize	O
(	O
)	O
;	O
if	O
(	O
!	O
_jitc	O
->	O
dataset	int
)	O
jit_dataset	O
(	O
)	O
;	O
_jitc	O
->	O
emit	int
=	O
1	int
;	O
if	O
(	O
!	O
_jit	pointer
->	O
user_code	int
)	O
{	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
=	O
mmap	function
(	O
NULL	O
,	O
_jit	pointer
->	O
code	pointer
.	O
length	long
,	O
PROT_EXEC	int
|	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_PRIVATE	int
|	O
MAP_ANON	O
,	O
mmap_fd	O
,	O
0	int
)	O
;	O
assert	O
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
!=	O
MAP_FAILED	O
)	O
;	O
}	O
_jitc	O
->	O
code	pointer
.	O
end	pointer
=	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
+	O
_jit	pointer
->	O
code	pointer
.	O
length	long
-	O
jit_get_max_instr	function
(	O
)	O
;	O
_jit	pointer
->	O
pc	union
.	O
uc	pointer
=	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
code	pointer
=	O
emit_code	O
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
_jitc	O
->	O
patches	struct
.	O
offset	short
=	O
0	int
;	O
for	O
(	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
node	pointer
->	O
link	function
&&	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
||	O
node	pointer
->	O
code	pointer
==	O
jit_code_epilog	int
)	O
)	O
node	pointer
->	O
flag	short
&=	O
~	O
jit_flag_patch	int
;	O
}	O
if	O
(	O
_jit	pointer
->	O
user_code	int
)	O
goto	O
fail	O
;	O
length	long
=	O
_jit	pointer
->	O
code	pointer
.	O
length	long
+	O
4096	int
;	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
=	O
mremap	function
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
,	O
_jit	pointer
->	O
code	pointer
.	O
length	long
,	O
length	long
,	O
MREMAP_MAYMOVE	int
,	O
NULL	O
)	O
;	O
assert	O
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
!=	O
MAP_FAILED	O
)	O
;	O
_jit	pointer
->	O
code	pointer
.	O
length	long
=	O
length	long
;	O
_jitc	O
->	O
code	pointer
.	O
end	pointer
=	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
+	O
_jit	pointer
->	O
code	pointer
.	O
length	long
-	O
jit_get_max_instr	function
(	O
)	O
;	O
_jit	pointer
->	O
pc	union
.	O
uc	pointer
=	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
;	O
}	O
else	O
break	O
;	O
}	O
_jitc	O
->	O
done	int
=	O
1	int
;	O
if	O
(	O
!	O
_jitc	O
->	O
no_note	int
)	O
jit_annotate	O
(	O
)	O
;	O
if	O
(	O
_jit	pointer
->	O
user_data	int
)	O
jit_free	function
(	O
(	O
jit_pointer_t	pointer
*	O
)	O
&	O
_jitc	O
->	O
data	struct
.	O
ptr	pointer
)	O
;	O
else	O
{	O
result	int
=	O
mprotect	function
(	O
_jit	pointer
->	O
data	struct
.	O
ptr	pointer
,	O
_jit	pointer
->	O
data	struct
.	O
length	long
,	O
PROT_READ	int
)	O
;	O
assert	O
(	O
result	int
==	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
_jit	pointer
->	O
user_code	int
)	O
{	O
result	int
=	O
mprotect	function
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
,	O
_jit	pointer
->	O
code	pointer
.	O
length	long
,	O
PROT_READ	int
|	O
PROT_EXEC	int
)	O
;	O
assert	O
(	O
result	int
==	O
0	int
)	O
;	O
}	O
return	O
(	O
_jit	pointer
->	O
code	pointer
.	O
ptr	pointer
)	O
;	O
fail	O
:	O
return	O
(	O
NULL	O
)	O
;	O
}	O
void	O
_jit_frame	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
frame	int
)	O
{	O
jit_trampoline	O
(	O
frame	int
,	O
1	int
)	O
;	O
}	O
void	O
_jit_tramp	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
frame	int
)	O
{	O
jit_trampoline	O
(	O
frame	int
,	O
0	int
)	O
;	O
}	O
void	O
_jit_trampoline	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_int32_t	int
frame	int
,	O
jit_bool_t	int
prolog	pointer
)	O
{	O
jit_int32_t	int
regno	int
;	O
assert	O
(	O
_jitc	O
->	O
tail	pointer
&&	O
_jitc	O
->	O
tail	pointer
->	O
code	pointer
==	O
jit_code_prolog	int
)	O
;	O
frame	int
+=	O
24	int
;	O
frame	int
-=	O
_jitc	O
->	O
function	pointer
->	O
self	struct
.	O
aoff	int
;	O
_jitc	O
->	O
function	pointer
->	O
frame	int
=	O
frame	int
;	O
if	O
(	O
prolog	pointer
)	O
_jitc	O
->	O
function	pointer
->	O
define_frame	int
=	O
1	int
;	O
else	O
_jitc	O
->	O
function	pointer
->	O
assume_frame	int
=	O
1	int
;	O
for	O
(	O
regno	int
=	O
0	int
;	O
regno	int
<	O
_jitc	O
->	O
reglen	int
;	O
regno	int
++	O
)	O
if	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
jit_class_sav	int
)	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
function	pointer
->	O
regset	long
,	O
regno	int
)	O
;	O
}	O
static	O
void	O
_jit_setup	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_block_t	struct
*	O
block	pointer
)	O
{	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_bool_t	int
live	pointer
;	O
unsigned	O
long	O
value	int
;	O
jit_regset_set_mask	O
(	O
&	O
regmask	long
,	O
_jitc	O
->	O
reglen	int
)	O
;	O
for	O
(	O
value	int
=	O
0	int
;	O
value	int
<	O
_jitc	O
->	O
reglen	int
;	O
++	O
value	int
)	O
if	O
(	O
!	O
(	O
jit_class	O
(	O
_rvs	array
[	O
value	int
]	O
.	O
spec	enum
)	O
&	O
(	O
jit_class_gpr	int
|	O
jit_class_fpr	int
)	O
)	O
)	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
value	int
)	O
;	O
for	O
(	O
node	pointer
=	O
block	pointer
->	O
label	pointer
->	O
next	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_prolog	int
:	O
case	O
jit_code_epilog	int
:	O
return	O
;	O
default	O
:	O
value	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
&&	O
!	O
(	O
node	pointer
->	O
w	long
.	O
w	long
&	O
jit_regno_patch	int
)	O
&&	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
)	O
{	O
live	pointer
=	O
!	O
(	O
value	int
&	O
jit_cc_a2_chg	int
)	O
;	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
if	O
(	O
live	pointer
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
}	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
&&	O
!	O
(	O
node	pointer
->	O
v	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
&&	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
)	O
{	O
live	pointer
=	O
!	O
(	O
value	int
&	O
jit_cc_a1_chg	int
)	O
;	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
if	O
(	O
live	pointer
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
live	pointer
=	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
&	O
jit_regno_patch	int
)	O
&&	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
if	O
(	O
live	pointer
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
&	O
jit_regno_patch	int
)	O
&&	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
if	O
(	O
live	pointer
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
&&	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
live	pointer
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
_jit_follow	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_block_t	struct
*	O
block	pointer
,	O
jit_bool_t	int
*	O
todo	pointer
)	O
{	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_block_t	struct
*	O
next	pointer
;	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
regno	int
;	O
unsigned	O
long	O
value	int
;	O
jit_node_t	struct
*	O
label	pointer
;	O
jit_regset_t	long
reglive	long
;	O
jit_regset_t	long
regmask	long
;	O
jit_regset_t	long
regtemp	long
;	O
jit_regset_set	O
(	O
&	O
reglive	long
,	O
&	O
block	pointer
->	O
reglive	long
)	O
;	O
jit_regset_set	O
(	O
&	O
regmask	long
,	O
&	O
block	pointer
->	O
regmask	long
)	O
;	O
for	O
(	O
node	pointer
=	O
block	pointer
->	O
label	pointer
->	O
next	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
next	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
v	union
.	O
w	long
;	O
jit_regset_and	O
(	O
&	O
regtemp	long
,	O
&	O
regmask	long
,	O
&	O
next	pointer
->	O
reglive	long
)	O
;	O
if	O
(	O
jit_regset_set_p	O
(	O
&	O
regtemp	long
)	O
)	O
{	O
jit_regset_ior	O
(	O
&	O
block	pointer
->	O
reglive	long
,	O
&	O
block	pointer
->	O
reglive	long
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_com	O
(	O
&	O
regtemp	long
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_and	O
(	O
&	O
block	pointer
->	O
regmask	long
,	O
&	O
block	pointer
->	O
regmask	long
,	O
&	O
regtemp	long
)	O
;	O
*	O
todo	pointer
=	O
1	int
;	O
}	O
case	O
jit_code_prolog	int
:	O
case	O
jit_code_epilog	int
:	O
return	O
;	O
case	O
jit_code_callr	int
:	O
value	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
value	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
value	int
)	O
;	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
value	int
)	O
;	O
}	O
}	O
case	O
jit_code_calli	int
:	O
for	O
(	O
value	int
=	O
0	int
;	O
value	int
<	O
_jitc	O
->	O
reglen	int
;	O
++	O
value	int
)	O
{	O
value	int
=	O
jit_regset_scan1	function
(	O
&	O
regmask	long
,	O
value	int
)	O
;	O
if	O
(	O
value	int
>=	O
_jitc	O
->	O
reglen	int
)	O
break	O
;	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
value	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
!	O
(	O
spec	enum
&	O
jit_class_sav	int
)	O
)	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
value	int
)	O
;	O
if	O
(	O
(	O
spec	enum
&	O
jit_class_arg	int
)	O
&&	O
jit_regarg_p	O
(	O
node	pointer
,	O
value	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
value	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
value	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
w	long
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a2_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
v	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a1_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
&	O
reglive	long
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a0_jmp	int
)	O
{	O
if	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
{	O
label	pointer
=	O
node	pointer
->	O
u	union
.	O
n	pointer
;	O
next	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
label	pointer
->	O
v	union
.	O
w	long
;	O
jit_regset_and	O
(	O
&	O
regtemp	long
,	O
&	O
regmask	long
,	O
&	O
next	pointer
->	O
reglive	long
)	O
;	O
if	O
(	O
jit_regset_set_p	O
(	O
&	O
regtemp	long
)	O
)	O
{	O
jit_regset_ior	O
(	O
&	O
block	pointer
->	O
reglive	long
,	O
&	O
block	pointer
->	O
reglive	long
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_com	O
(	O
&	O
regtemp	long
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_and	O
(	O
&	O
block	pointer
->	O
regmask	long
,	O
&	O
block	pointer
->	O
regmask	long
,	O
&	O
regtemp	long
)	O
;	O
*	O
todo	pointer
=	O
1	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
regno	int
=	O
0	int
;	O
regno	int
<	O
_jitc	O
->	O
reglen	int
;	O
regno	int
++	O
)	O
{	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
jit_regset_tstbit	O
(	O
&	O
regmask	long
,	O
regno	int
)	O
&&	O
(	O
spec	enum
&	O
(	O
jit_class_gpr	int
|	O
jit_class_fpr	int
)	O
)	O
&&	O
!	O
(	O
spec	enum
&	O
jit_class_sav	int
)	O
)	O
jit_regset_clrbit	O
(	O
&	O
regmask	long
,	O
regno	int
)	O
;	O
}	O
jit_regset_ior	O
(	O
&	O
reglive	long
,	O
&	O
reglive	long
,	O
&	O
regmask	long
)	O
;	O
jit_regset_set_ui	O
(	O
&	O
regmask	long
,	O
0	int
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
_jit_update	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_regset_t	long
*	O
live	pointer
,	O
jit_regset_t	long
*	O
mask	pointer
)	O
{	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
regno	int
;	O
unsigned	O
long	O
value	int
;	O
jit_block_t	struct
*	O
block	pointer
;	O
jit_node_t	struct
*	O
label	pointer
;	O
jit_regset_t	long
regtemp	long
;	O
for	O
(	O
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
jit_regset_set_p	O
(	O
mask	pointer
)	O
==	O
0	int
)	O
break	O
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
v	union
.	O
w	long
;	O
jit_regset_and	O
(	O
&	O
regtemp	long
,	O
mask	pointer
,	O
&	O
block	pointer
->	O
reglive	long
)	O
;	O
if	O
(	O
jit_regset_set_p	O
(	O
&	O
regtemp	long
)	O
)	O
{	O
jit_regset_ior	O
(	O
live	pointer
,	O
live	pointer
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_com	O
(	O
&	O
regtemp	long
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_and	O
(	O
mask	pointer
,	O
mask	pointer
,	O
&	O
regtemp	long
)	O
;	O
}	O
return	O
;	O
case	O
jit_code_prolog	int
:	O
jit_regset_set_ui	O
(	O
mask	pointer
,	O
0	int
)	O
;	O
return	O
;	O
case	O
jit_code_epilog	int
:	O
jit_regset_set_ui	O
(	O
mask	pointer
,	O
0	int
)	O
;	O
return	O
;	O
case	O
jit_code_callr	int
:	O
value	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
value	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
value	int
)	O
;	O
jit_regset_setbit	O
(	O
live	pointer
,	O
value	int
)	O
;	O
}	O
}	O
case	O
jit_code_calli	int
:	O
for	O
(	O
value	int
=	O
0	int
;	O
value	int
<	O
_jitc	O
->	O
reglen	int
;	O
++	O
value	int
)	O
{	O
value	int
=	O
jit_regset_scan1	function
(	O
mask	pointer
,	O
value	int
)	O
;	O
if	O
(	O
value	int
>=	O
_jitc	O
->	O
reglen	int
)	O
break	O
;	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
value	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
!	O
(	O
spec	enum
&	O
jit_class_sav	int
)	O
)	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
value	int
)	O
;	O
if	O
(	O
(	O
spec	enum
&	O
jit_class_arg	int
)	O
&&	O
jit_regarg_p	O
(	O
node	pointer
,	O
value	int
)	O
)	O
jit_regset_setbit	O
(	O
live	pointer
,	O
value	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
value	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
w	long
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a2_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
live	pointer
,	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
v	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a1_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
live	pointer
,	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
live	pointer
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
live	pointer
,	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
node	pointer
->	O
u	union
.	O
w	long
&	O
jit_regno_patch	int
)	O
)	O
{	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
)	O
{	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_chg	int
)	O
)	O
jit_regset_setbit	O
(	O
live	pointer
,	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
value	int
&	O
jit_cc_a0_jmp	int
)	O
{	O
if	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
{	O
label	pointer
=	O
node	pointer
->	O
u	union
.	O
n	pointer
;	O
block	pointer
=	O
_jitc	O
->	O
blocks	struct
.	O
ptr	pointer
+	O
label	pointer
->	O
v	union
.	O
w	long
;	O
jit_regset_and	O
(	O
&	O
regtemp	long
,	O
mask	pointer
,	O
&	O
block	pointer
->	O
reglive	long
)	O
;	O
if	O
(	O
jit_regset_set_p	O
(	O
&	O
regtemp	long
)	O
)	O
{	O
jit_regset_ior	O
(	O
live	pointer
,	O
live	pointer
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_com	O
(	O
&	O
regtemp	long
,	O
&	O
regtemp	long
)	O
;	O
jit_regset_and	O
(	O
mask	pointer
,	O
mask	pointer
,	O
&	O
regtemp	long
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
regno	int
=	O
0	int
;	O
regno	int
<	O
_jitc	O
->	O
reglen	int
;	O
regno	int
++	O
)	O
{	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
jit_regset_tstbit	O
(	O
mask	pointer
,	O
regno	int
)	O
&&	O
(	O
spec	enum
&	O
(	O
jit_class_gpr	int
|	O
jit_class_fpr	int
)	O
)	O
&&	O
!	O
(	O
spec	enum
&	O
jit_class_sav	int
)	O
)	O
jit_regset_clrbit	O
(	O
mask	pointer
,	O
regno	int
)	O
;	O
}	O
jit_regset_ior	O
(	O
live	pointer
,	O
live	pointer
,	O
mask	pointer
)	O
;	O
jit_regset_set_ui	O
(	O
mask	pointer
,	O
0	int
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
_thread_jumps	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
prev	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_node_t	struct
*	O
next	pointer
;	O
jit_int32_t	int
mask	pointer
;	O
for	O
(	O
prev	pointer
=	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
)	O
{	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_jmpi	int
:	O
if	O
(	O
redundant_jump	O
(	O
prev	pointer
,	O
node	pointer
)	O
)	O
{	O
node	pointer
=	O
prev	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
shortcut_jump	O
(	O
prev	pointer
,	O
node	pointer
)	O
)	O
continue	O
;	O
break	O
;	O
case	O
jit_code_jmpr	int
:	O
case	O
jit_code_callr	int
:	O
case	O
jit_code_calli	int
:	O
break	O
;	O
default	O
:	O
mask	pointer
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
mask	pointer
&	O
jit_cc_a0_jmp	int
)	O
{	O
if	O
(	O
reverse_jump	O
(	O
prev	pointer
,	O
node	pointer
)	O
||	O
shortcut_jump	O
(	O
prev	pointer
,	O
node	pointer
)	O
)	O
continue	O
;	O
}	O
break	O
;	O
}	O
prev	pointer
=	O
node	pointer
;	O
node	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
void	O
_sequential_labels	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
jump	int
;	O
jit_node_t	struct
*	O
link	function
;	O
jit_node_t	struct
*	O
prev	pointer
;	O
jit_node_t	struct
*	O
next	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
for	O
(	O
prev	pointer
=	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
node	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
if	O
(	O
node	pointer
->	O
code	pointer
==	O
jit_code_label	int
)	O
{	O
if	O
(	O
!	O
node	pointer
->	O
flag	short
)	O
{	O
if	O
(	O
!	O
node	pointer
->	O
link	function
)	O
{	O
del_label	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
prev	pointer
!=	O
node	pointer
&&	O
prev	pointer
->	O
code	pointer
==	O
jit_code_label	int
)	O
{	O
if	O
(	O
(	O
jump	int
=	O
node	pointer
->	O
link	function
)	O
)	O
{	O
for	O
(	O
;	O
jump	int
;	O
jump	int
=	O
link	function
)	O
{	O
link	function
=	O
jump	int
->	O
link	function
;	O
jump	int
->	O
u	union
.	O
n	pointer
=	O
prev	pointer
;	O
jump	int
->	O
link	function
=	O
prev	pointer
->	O
link	function
;	O
prev	pointer
->	O
link	function
=	O
jump	int
;	O
}	O
node	pointer
->	O
link	function
=	O
NULL	O
;	O
}	O
del_label	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
next	pointer
&&	O
next	pointer
->	O
code	pointer
==	O
jit_code_label	int
&&	O
!	O
next	pointer
->	O
flag	short
)	O
{	O
if	O
(	O
(	O
jump	int
=	O
next	pointer
->	O
link	function
)	O
)	O
{	O
for	O
(	O
;	O
jump	int
;	O
jump	int
=	O
link	function
)	O
{	O
link	function
=	O
jump	int
->	O
link	function
;	O
jump	int
->	O
u	union
.	O
n	pointer
=	O
node	pointer
;	O
jump	int
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
node	pointer
->	O
link	function
=	O
jump	int
;	O
}	O
next	pointer
->	O
link	function
=	O
NULL	O
;	O
}	O
del_label	O
(	O
node	pointer
,	O
next	pointer
)	O
;	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
continue	O
;	O
}	O
}	O
prev	pointer
=	O
node	pointer
;	O
}	O
}	O
static	O
jit_bool_t	int
_shortcut_jump	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_bool_t	int
cond	int
;	O
jit_node_t	struct
*	O
jump	int
;	O
jit_node_t	struct
*	O
next	pointer
;	O
jit_node_t	struct
*	O
temp	pointer
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
assert	O
(	O
node	pointer
->	O
code	pointer
!=	O
jit_code_jmpr	int
)	O
;	O
cond	int
=	O
node	pointer
->	O
code	pointer
!=	O
jit_code_jmpi	int
;	O
jump	int
=	O
node	pointer
->	O
u	union
.	O
n	pointer
;	O
for	O
(	O
next	pointer
=	O
jump	int
->	O
next	pointer
;	O
next	pointer
;	O
next	pointer
=	O
next	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
next	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_jmpi	int
:	O
if	O
(	O
!	O
(	O
next	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
jump	int
->	O
link	function
==	O
node	pointer
)	O
jump	int
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
else	O
{	O
for	O
(	O
temp	pointer
=	O
jump	int
->	O
link	function
;	O
temp	pointer
->	O
link	function
!=	O
node	pointer
;	O
temp	pointer
=	O
temp	pointer
->	O
link	function
)	O
assert	O
(	O
temp	pointer
!=	O
NULL	O
)	O
;	O
temp	pointer
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
}	O
jump	int
=	O
next	pointer
->	O
u	union
.	O
n	pointer
;	O
node	pointer
->	O
u	union
.	O
n	pointer
=	O
jump	int
;	O
node	pointer
->	O
link	function
=	O
jump	int
->	O
link	function
;	O
jump	int
->	O
link	function
=	O
node	pointer
;	O
return	O
(	O
1	int
)	O
;	O
case	O
jit_code_jmpr	int
:	O
if	O
(	O
cond	int
)	O
return	O
(	O
0	int
)	O
;	O
node	pointer
->	O
code	pointer
=	O
jit_code_jmpr	int
;	O
node	pointer
->	O
u	union
.	O
w	long
=	O
next	pointer
->	O
u	union
.	O
w	long
;	O
node	pointer
->	O
link	function
=	O
NULL	O
;	O
node	pointer
->	O
flag	short
&=	O
~	O
jit_flag_node	int
;	O
return	O
(	O
1	int
)	O
;	O
case	O
jit_code_note	int
:	O
case	O
jit_code_label	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
jit_bool_t	int
_redundant_jump	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_node_t	struct
*	O
local_prev	pointer
;	O
jit_node_t	struct
*	O
local_next	pointer
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
local_prev	pointer
=	O
node	pointer
,	O
local_next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
local_next	pointer
;	O
local_prev	pointer
=	O
local_next	pointer
,	O
local_next	pointer
=	O
local_next	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
local_next	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_epilog	int
:	O
if	O
(	O
node	pointer
->	O
u	union
.	O
n	pointer
==	O
local_next	pointer
)	O
{	O
if	O
(	O
local_next	pointer
->	O
link	function
==	O
node	pointer
)	O
local_next	pointer
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
else	O
{	O
for	O
(	O
local_prev	pointer
=	O
local_next	pointer
->	O
link	function
;	O
local_prev	pointer
->	O
link	function
!=	O
node	pointer
;	O
local_prev	pointer
=	O
local_prev	pointer
->	O
link	function
)	O
assert	O
(	O
local_prev	pointer
!=	O
NULL	O
)	O
;	O
local_prev	pointer
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
}	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
jit_code_name	int
:	O
case	O
jit_code_note	int
:	O
case	O
jit_code_align	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
jit_code_t	enum
reverse_jump_code	function
(	O
jit_code_t	enum
code	pointer
)	O
{	O
switch	O
(	O
code	pointer
)	O
{	O
case	O
jit_code_bltr	int
:	O
return	O
(	O
jit_code_bger	int
)	O
;	O
case	O
jit_code_blti	int
:	O
return	O
(	O
jit_code_bgei	int
)	O
;	O
case	O
jit_code_bltr_u	int
:	O
return	O
(	O
jit_code_bger_u	int
)	O
;	O
case	O
jit_code_blti_u	int
:	O
return	O
(	O
jit_code_bgei_u	int
)	O
;	O
case	O
jit_code_bler	int
:	O
return	O
(	O
jit_code_bgtr	int
)	O
;	O
case	O
jit_code_blei	int
:	O
return	O
(	O
jit_code_bgti	int
)	O
;	O
case	O
jit_code_bler_u	int
:	O
return	O
(	O
jit_code_bgtr_u	int
)	O
;	O
case	O
jit_code_blei_u	int
:	O
return	O
(	O
jit_code_bgti_u	int
)	O
;	O
case	O
jit_code_beqr	int
:	O
return	O
(	O
jit_code_bner	int
)	O
;	O
case	O
jit_code_beqi	int
:	O
return	O
(	O
jit_code_bnei	int
)	O
;	O
case	O
jit_code_bger	int
:	O
return	O
(	O
jit_code_bltr	int
)	O
;	O
case	O
jit_code_bgei	int
:	O
return	O
(	O
jit_code_blti	int
)	O
;	O
case	O
jit_code_bger_u	int
:	O
return	O
(	O
jit_code_bltr_u	int
)	O
;	O
case	O
jit_code_bgei_u	int
:	O
return	O
(	O
jit_code_blti_u	int
)	O
;	O
case	O
jit_code_bgtr	int
:	O
return	O
(	O
jit_code_bler	int
)	O
;	O
case	O
jit_code_bgti	int
:	O
return	O
(	O
jit_code_blei	int
)	O
;	O
case	O
jit_code_bgtr_u	int
:	O
return	O
(	O
jit_code_bler_u	int
)	O
;	O
case	O
jit_code_bgti_u	int
:	O
return	O
(	O
jit_code_blei_u	int
)	O
;	O
case	O
jit_code_bner	int
:	O
return	O
(	O
jit_code_beqr	int
)	O
;	O
case	O
jit_code_bnei	int
:	O
return	O
(	O
jit_code_beqi	int
)	O
;	O
case	O
jit_code_bmsr	int
:	O
return	O
(	O
jit_code_bmcr	int
)	O
;	O
case	O
jit_code_bmsi	int
:	O
return	O
(	O
jit_code_bmci	int
)	O
;	O
case	O
jit_code_bmcr	int
:	O
return	O
(	O
jit_code_bmsr	int
)	O
;	O
case	O
jit_code_bmci	int
:	O
return	O
(	O
jit_code_bmsi	int
)	O
;	O
case	O
jit_code_bltr_f	int
:	O
return	O
(	O
jit_code_bunger_f	int
)	O
;	O
case	O
jit_code_blti_f	int
:	O
return	O
(	O
jit_code_bungei_f	int
)	O
;	O
case	O
jit_code_bler_f	int
:	O
return	O
(	O
jit_code_bungtr_f	int
)	O
;	O
case	O
jit_code_blei_f	int
:	O
return	O
(	O
jit_code_bungti_f	int
)	O
;	O
case	O
jit_code_beqr_f	int
:	O
return	O
(	O
jit_code_bner_f	int
)	O
;	O
case	O
jit_code_beqi_f	int
:	O
return	O
(	O
jit_code_bnei_f	int
)	O
;	O
case	O
jit_code_bger_f	int
:	O
return	O
(	O
jit_code_bunltr_f	int
)	O
;	O
case	O
jit_code_bgei_f	int
:	O
return	O
(	O
jit_code_bunlti_f	int
)	O
;	O
case	O
jit_code_bgtr_f	int
:	O
return	O
(	O
jit_code_bunler_f	int
)	O
;	O
case	O
jit_code_bgti_f	int
:	O
return	O
(	O
jit_code_bunlei_f	int
)	O
;	O
case	O
jit_code_bner_f	int
:	O
return	O
(	O
jit_code_beqr_f	int
)	O
;	O
case	O
jit_code_bnei_f	int
:	O
return	O
(	O
jit_code_beqr_f	int
)	O
;	O
case	O
jit_code_bunltr_f	int
:	O
return	O
(	O
jit_code_bger_f	int
)	O
;	O
case	O
jit_code_bunlti_f	int
:	O
return	O
(	O
jit_code_bgei_f	int
)	O
;	O
case	O
jit_code_bunler_f	int
:	O
return	O
(	O
jit_code_bgtr_f	int
)	O
;	O
case	O
jit_code_bunlei_f	int
:	O
return	O
(	O
jit_code_bgti_f	int
)	O
;	O
case	O
jit_code_buneqr_f	int
:	O
return	O
(	O
jit_code_bltgtr_f	int
)	O
;	O
case	O
jit_code_buneqi_f	int
:	O
return	O
(	O
jit_code_bltgti_f	int
)	O
;	O
case	O
jit_code_bunger_f	int
:	O
return	O
(	O
jit_code_bltr_f	int
)	O
;	O
case	O
jit_code_bungei_f	int
:	O
return	O
(	O
jit_code_blti_f	int
)	O
;	O
case	O
jit_code_bungtr_f	int
:	O
return	O
(	O
jit_code_bler_f	int
)	O
;	O
case	O
jit_code_bungti_f	int
:	O
return	O
(	O
jit_code_blei_f	int
)	O
;	O
case	O
jit_code_bltgtr_f	int
:	O
return	O
(	O
jit_code_buneqr_f	int
)	O
;	O
case	O
jit_code_bltgti_f	int
:	O
return	O
(	O
jit_code_buneqi_f	int
)	O
;	O
case	O
jit_code_bordr_f	int
:	O
return	O
(	O
jit_code_bunordr_f	int
)	O
;	O
case	O
jit_code_bordi_f	int
:	O
return	O
(	O
jit_code_bunordi_f	int
)	O
;	O
case	O
jit_code_bunordr_f	int
:	O
return	O
(	O
jit_code_bordr_f	int
)	O
;	O
case	O
jit_code_bunordi_f	int
:	O
return	O
(	O
jit_code_bordi_f	int
)	O
;	O
case	O
jit_code_bltr_d	int
:	O
return	O
(	O
jit_code_bunger_d	int
)	O
;	O
case	O
jit_code_blti_d	int
:	O
return	O
(	O
jit_code_bungei_d	int
)	O
;	O
case	O
jit_code_bler_d	int
:	O
return	O
(	O
jit_code_bungtr_d	int
)	O
;	O
case	O
jit_code_blei_d	int
:	O
return	O
(	O
jit_code_bungti_d	int
)	O
;	O
case	O
jit_code_beqr_d	int
:	O
return	O
(	O
jit_code_bner_d	int
)	O
;	O
case	O
jit_code_beqi_d	int
:	O
return	O
(	O
jit_code_bnei_d	int
)	O
;	O
case	O
jit_code_bger_d	int
:	O
return	O
(	O
jit_code_bunltr_d	int
)	O
;	O
case	O
jit_code_bgei_d	int
:	O
return	O
(	O
jit_code_bunlti_d	int
)	O
;	O
case	O
jit_code_bgtr_d	int
:	O
return	O
(	O
jit_code_bunler_d	int
)	O
;	O
case	O
jit_code_bgti_d	int
:	O
return	O
(	O
jit_code_bunlei_d	int
)	O
;	O
case	O
jit_code_bner_d	int
:	O
return	O
(	O
jit_code_beqr_d	int
)	O
;	O
case	O
jit_code_bnei_d	int
:	O
return	O
(	O
jit_code_beqi_d	int
)	O
;	O
case	O
jit_code_bunltr_d	int
:	O
return	O
(	O
jit_code_bger_d	int
)	O
;	O
case	O
jit_code_bunlti_d	int
:	O
return	O
(	O
jit_code_bgei_d	int
)	O
;	O
case	O
jit_code_bunler_d	int
:	O
return	O
(	O
jit_code_bgtr_d	int
)	O
;	O
case	O
jit_code_bunlei_d	int
:	O
return	O
(	O
jit_code_bgti_d	int
)	O
;	O
case	O
jit_code_buneqr_d	int
:	O
return	O
(	O
jit_code_bltgtr_d	int
)	O
;	O
case	O
jit_code_buneqi_d	int
:	O
return	O
(	O
jit_code_bltgti_d	int
)	O
;	O
case	O
jit_code_bunger_d	int
:	O
return	O
(	O
jit_code_bltr_d	int
)	O
;	O
case	O
jit_code_bungei_d	int
:	O
return	O
(	O
jit_code_blti_d	int
)	O
;	O
case	O
jit_code_bungtr_d	int
:	O
return	O
(	O
jit_code_bler_d	int
)	O
;	O
case	O
jit_code_bungti_d	int
:	O
return	O
(	O
jit_code_blei_d	int
)	O
;	O
case	O
jit_code_bltgtr_d	int
:	O
return	O
(	O
jit_code_buneqr_d	int
)	O
;	O
case	O
jit_code_bltgti_d	int
:	O
return	O
(	O
jit_code_buneqi_d	int
)	O
;	O
case	O
jit_code_bordr_d	int
:	O
return	O
(	O
jit_code_bunordr_d	int
)	O
;	O
case	O
jit_code_bordi_d	int
:	O
return	O
(	O
jit_code_bunordi_d	int
)	O
;	O
case	O
jit_code_bunordr_d	int
:	O
return	O
(	O
jit_code_bordr_d	int
)	O
;	O
case	O
jit_code_bunordi_d	int
:	O
return	O
(	O
jit_code_bordi_d	int
)	O
;	O
case	O
jit_code_boaddr	int
:	O
return	O
(	O
jit_code_bxaddr	int
)	O
;	O
case	O
jit_code_boaddi	int
:	O
return	O
(	O
jit_code_bxaddi	int
)	O
;	O
case	O
jit_code_boaddr_u	int
:	O
return	O
(	O
jit_code_bxaddr_u	int
)	O
;	O
case	O
jit_code_boaddi_u	int
:	O
return	O
(	O
jit_code_bxaddi_u	int
)	O
;	O
case	O
jit_code_bxaddr	int
:	O
return	O
(	O
jit_code_boaddr	int
)	O
;	O
case	O
jit_code_bxaddi	int
:	O
return	O
(	O
jit_code_boaddi	int
)	O
;	O
case	O
jit_code_bxaddr_u	int
:	O
return	O
(	O
jit_code_boaddr_u	int
)	O
;	O
case	O
jit_code_bxaddi_u	int
:	O
return	O
(	O
jit_code_boaddi_u	int
)	O
;	O
case	O
jit_code_bosubr	int
:	O
return	O
(	O
jit_code_bxsubr	int
)	O
;	O
case	O
jit_code_bosubi	int
:	O
return	O
(	O
jit_code_bxsubi	int
)	O
;	O
case	O
jit_code_bosubr_u	int
:	O
return	O
(	O
jit_code_bxsubr_u	int
)	O
;	O
case	O
jit_code_bosubi_u	int
:	O
return	O
(	O
jit_code_bxsubi_u	int
)	O
;	O
case	O
jit_code_bxsubr	int
:	O
return	O
(	O
jit_code_bosubr	int
)	O
;	O
case	O
jit_code_bxsubi	int
:	O
return	O
(	O
jit_code_bosubi	int
)	O
;	O
case	O
jit_code_bxsubr_u	int
:	O
return	O
(	O
jit_code_bosubr_u	int
)	O
;	O
case	O
jit_code_bxsubi_u	int
:	O
return	O
(	O
jit_code_bosubi_u	int
)	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
jit_bool_t	int
_reverse_jump	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_node_t	struct
*	O
local_prev	pointer
;	O
jit_node_t	struct
*	O
local_next	pointer
;	O
jit_node_t	struct
*	O
local_jump	pointer
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
local_next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
if	O
(	O
local_next	pointer
->	O
code	pointer
!=	O
jit_code_jmpi	int
||	O
!	O
(	O
local_next	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
local_jump	pointer
=	O
local_next	pointer
->	O
u	union
.	O
n	pointer
;	O
for	O
(	O
local_prev	pointer
=	O
local_next	pointer
,	O
local_next	pointer
=	O
local_next	pointer
->	O
next	pointer
;	O
local_next	pointer
;	O
local_prev	pointer
=	O
local_next	pointer
,	O
local_next	pointer
=	O
local_next	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
local_next	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_epilog	int
:	O
if	O
(	O
node	pointer
->	O
u	union
.	O
n	pointer
==	O
local_next	pointer
)	O
{	O
if	O
(	O
local_next	pointer
->	O
link	function
==	O
node	pointer
)	O
local_next	pointer
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
else	O
{	O
for	O
(	O
local_prev	pointer
=	O
local_next	pointer
->	O
link	function
;	O
local_prev	pointer
->	O
link	function
!=	O
node	pointer
;	O
local_prev	pointer
=	O
local_prev	pointer
->	O
link	function
)	O
assert	O
(	O
local_prev	pointer
!=	O
NULL	O
)	O
;	O
local_prev	pointer
->	O
link	function
=	O
node	pointer
->	O
link	function
;	O
}	O
del_node	O
(	O
node	pointer
,	O
node	pointer
->	O
next	pointer
)	O
;	O
node	pointer
->	O
code	pointer
=	O
reverse_jump_code	function
(	O
node	pointer
->	O
code	pointer
)	O
;	O
node	pointer
->	O
u	union
.	O
n	pointer
=	O
local_jump	pointer
;	O
node	pointer
->	O
link	function
=	O
local_jump	pointer
->	O
link	function
;	O
local_jump	pointer
->	O
link	function
=	O
node	pointer
;	O
return	O
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
jit_code_note	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_redundant_store	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_bool_t	int
jump	int
)	O
{	O
jit_node_t	struct
*	O
iter	pointer
;	O
jit_node_t	struct
*	O
prev	pointer
;	O
jit_word_t	long
word	long
;	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
regno	int
;	O
if	O
(	O
jump	int
)	O
{	O
prev	pointer
=	O
node	pointer
->	O
u	union
.	O
n	pointer
;	O
if	O
(	O
prev	pointer
->	O
code	pointer
==	O
jit_code_epilog	int
)	O
return	O
;	O
assert	O
(	O
prev	pointer
->	O
code	pointer
==	O
jit_code_label	int
)	O
;	O
if	O
(	O
(	O
prev	pointer
->	O
flag	short
&	O
jit_flag_head	int
)	O
||	O
node	pointer
->	O
link	function
||	O
prev	pointer
->	O
link	function
!=	O
node	pointer
)	O
return	O
;	O
}	O
else	O
prev	pointer
=	O
node	pointer
;	O
word	long
=	O
node	pointer
->	O
w	long
.	O
w	long
;	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
for	O
(	O
iter	pointer
=	O
prev	pointer
->	O
next	pointer
;	O
iter	pointer
;	O
prev	pointer
=	O
iter	pointer
,	O
iter	pointer
=	O
iter	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
iter	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_prolog	int
:	O
case	O
jit_code_epilog	int
:	O
return	O
;	O
case	O
jit_code_movi	int
:	O
if	O
(	O
regno	int
==	O
jit_regno	O
(	O
iter	pointer
->	O
u	union
.	O
w	long
)	O
)	O
{	O
if	O
(	O
iter	pointer
->	O
flag	short
||	O
iter	pointer
->	O
v	union
.	O
w	long
!=	O
word	long
)	O
return	O
;	O
del_node	O
(	O
prev	pointer
,	O
iter	pointer
)	O
;	O
iter	pointer
=	O
prev	pointer
;	O
}	O
break	O
;	O
default	O
:	O
spec	enum
=	O
jit_classify	O
(	O
iter	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
spec	enum
&	O
jit_cc_a0_jmp	int
)	O
return	O
;	O
if	O
(	O
(	O
spec	enum
&	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
)	O
)	O
==	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
)	O
)	O
{	O
if	O
(	O
spec	enum
&	O
jit_cc_a0_rlh	int
)	O
{	O
if	O
(	O
regno	int
==	O
jit_regno	O
(	O
iter	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
||	O
regno	int
==	O
jit_regno	O
(	O
iter	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
regno	int
==	O
jit_regno	O
(	O
iter	pointer
->	O
u	union
.	O
w	long
)	O
)	O
return	O
;	O
}	O
}	O
if	O
(	O
(	O
spec	enum
&	O
(	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
)	O
)	O
==	O
(	O
jit_cc_a1_reg	int
|	O
jit_cc_a1_chg	int
)	O
)	O
{	O
if	O
(	O
regno	int
==	O
jit_regno	O
(	O
iter	pointer
->	O
v	union
.	O
w	long
)	O
)	O
return	O
;	O
}	O
if	O
(	O
(	O
spec	enum
&	O
(	O
jit_cc_a2_reg	int
|	O
jit_cc_a2_chg	int
)	O
)	O
==	O
(	O
jit_cc_a2_reg	int
|	O
jit_cc_a2_chg	int
)	O
)	O
{	O
if	O
(	O
regno	int
==	O
jit_regno	O
(	O
iter	pointer
->	O
w	long
.	O
w	long
)	O
)	O
return	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
static	O
jit_bool_t	int
_simplify_movr	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
kind	int
,	O
jit_int32_t	int
size	long
)	O
{	O
jit_int32_t	int
regno	int
;	O
jit_int32_t	int
right	int
;	O
jit_value_t	struct
*	O
value	int
;	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
right	int
=	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
value	int
=	O
_jitc	O
->	O
values	pointer
+	O
regno	int
;	O
if	O
(	O
(	O
value	int
->	O
kind	int
==	O
jit_kind_register	int
&&	O
jit_regno	O
(	O
value	int
->	O
base	union
.	O
q	struct
.	O
l	int
)	O
==	O
right	int
&&	O
value	int
->	O
base	union
.	O
q	struct
.	O
h	int
==	O
_jitc	O
->	O
gen	pointer
[	O
right	int
]	O
)	O
||	O
(	O
value	int
->	O
kind	int
==	O
kind	int
&&	O
_jitc	O
->	O
values	pointer
[	O
right	int
]	O
.	O
kind	int
==	O
kind	int
&&	O
memcmp	function
(	O
&	O
value	int
->	O
base	union
.	O
w	long
,	O
&	O
_jitc	O
->	O
values	pointer
[	O
right	int
]	O
.	O
base	union
.	O
w	long
,	O
size	long
)	O
==	O
0	int
)	O
)	O
{	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
_jitc	O
->	O
values	pointer
[	O
right	int
]	O
.	O
kind	int
==	O
jit_kind_word	int
)	O
jit_memcpy	function
(	O
value	int
,	O
_jitc	O
->	O
values	pointer
+	O
right	int
,	O
sizeof	O
(	O
jit_value_t	struct
)	O
)	O
;	O
else	O
{	O
value	int
->	O
kind	int
=	O
jit_kind_register	int
;	O
value	int
->	O
base	union
.	O
q	struct
.	O
l	int
=	O
right	int
;	O
value	int
->	O
base	union
.	O
q	struct
.	O
h	int
=	O
_jitc	O
->	O
gen	pointer
[	O
right	int
]	O
;	O
}	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
jit_bool_t	int
_simplify_movi	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
kind	int
,	O
jit_int32_t	int
size	long
)	O
{	O
jit_value_t	struct
*	O
value	int
;	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
regno	int
;	O
jit_int32_t	int
offset	short
;	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
value	int
=	O
_jitc	O
->	O
values	pointer
+	O
regno	int
;	O
if	O
(	O
node	pointer
->	O
flag	short
&	O
jit_flag_node	int
)	O
{	O
value	int
->	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
value	int
->	O
kind	int
==	O
kind	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
&	O
node	pointer
->	O
v	union
.	O
w	long
,	O
&	O
value	int
->	O
base	union
.	O
w	long
,	O
size	long
)	O
==	O
0	int
)	O
{	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
kind	int
==	O
jit_kind_word	int
)	O
spec	enum
&=	O
jit_class_gpr	int
;	O
else	O
spec	enum
&=	O
(	O
jit_class_xpr	int
|	O
jit_class_fpr	int
)	O
;	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
reglen	int
;	O
offset	short
++	O
)	O
{	O
if	O
(	O
_jitc	O
->	O
values	pointer
[	O
offset	short
]	O
.	O
kind	int
==	O
kind	int
&&	O
memcmp	function
(	O
&	O
node	pointer
->	O
v	union
.	O
w	long
,	O
&	O
_jitc	O
->	O
values	pointer
[	O
offset	short
]	O
.	O
base	union
.	O
w	long
,	O
size	long
)	O
==	O
0	int
&&	O
(	O
jit_class	O
(	O
_rvs	array
[	O
offset	short
]	O
.	O
spec	enum
)	O
&	O
spec	enum
)	O
==	O
spec	enum
)	O
{	O
if	O
(	O
kind	int
==	O
jit_kind_word	int
)	O
node	pointer
->	O
code	pointer
=	O
jit_code_movr	int
;	O
else	O
if	O
(	O
kind	int
==	O
jit_kind_float32	int
)	O
node	pointer
->	O
code	pointer
=	O
jit_code_movr_f	int
;	O
else	O
node	pointer
->	O
code	pointer
=	O
jit_code_movr_d	int
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
offset	short
;	O
jit_memcpy	function
(	O
value	int
,	O
_jitc	O
->	O
values	pointer
+	O
offset	short
,	O
sizeof	O
(	O
jit_value_t	struct
)	O
)	O
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
value	int
->	O
kind	int
=	O
kind	int
;	O
jit_memcpy	function
(	O
&	O
value	int
->	O
base	union
.	O
w	long
,	O
&	O
node	pointer
->	O
v	union
.	O
w	long
,	O
size	long
)	O
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
jit_bool_t	int
_simplify_ldxi	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_value_t	struct
*	O
value	int
;	O
jit_int32_t	int
regno	int
;	O
jit_int32_t	int
right	int
;	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
right	int
=	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
value	int
=	O
_jitc	O
->	O
values	pointer
+	O
regno	int
;	O
if	O
(	O
regno	int
!=	O
right	int
&&	O
value	int
->	O
kind	int
==	O
jit_kind_code	int
&&	O
value	int
->	O
code	pointer
==	O
node	pointer
->	O
code	pointer
&&	O
value	int
->	O
base	union
.	O
q	struct
.	O
l	int
==	O
right	int
&&	O
value	int
->	O
base	union
.	O
q	struct
.	O
h	int
==	O
_jitc	O
->	O
gen	pointer
[	O
right	int
]	O
&&	O
node	pointer
->	O
w	long
.	O
w	long
==	O
value	int
->	O
disp	union
.	O
w	long
)	O
{	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
value	int
->	O
kind	int
=	O
jit_kind_code	int
;	O
value	int
->	O
code	pointer
=	O
node	pointer
->	O
code	pointer
;	O
value	int
->	O
base	union
.	O
q	struct
.	O
l	int
=	O
right	int
;	O
value	int
->	O
base	union
.	O
q	struct
.	O
h	int
=	O
_jitc	O
->	O
gen	pointer
[	O
right	int
]	O
;	O
value	int
->	O
disp	union
.	O
w	long
=	O
node	pointer
->	O
w	long
.	O
w	long
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
jit_bool_t	int
_simplify_stxi	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
prev	pointer
,	O
jit_node_t	struct
*	O
node	pointer
)	O
{	O
jit_value_t	struct
*	O
value	int
;	O
jit_int32_t	int
regno	int
;	O
jit_int32_t	int
right	int
;	O
jit_int32_t	int
offset	short
;	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
right	int
=	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
value	int
=	O
_jitc	O
->	O
values	pointer
+	O
regno	int
;	O
if	O
(	O
regno	int
!=	O
right	int
&&	O
value	int
->	O
kind	int
==	O
jit_kind_code	int
&&	O
value	int
->	O
code	pointer
==	O
node	pointer
->	O
code	pointer
&&	O
value	int
->	O
base	union
.	O
q	struct
.	O
l	int
==	O
right	int
&&	O
value	int
->	O
base	union
.	O
q	struct
.	O
h	int
==	O
_jitc	O
->	O
gen	pointer
[	O
right	int
]	O
&&	O
node	pointer
->	O
u	union
.	O
w	long
==	O
value	int
->	O
disp	union
.	O
w	long
)	O
{	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
for	O
(	O
offset	short
=	O
0	int
;	O
offset	short
<	O
_jitc	O
->	O
reglen	int
;	O
offset	short
++	O
)	O
{	O
if	O
(	O
_jitc	O
->	O
values	pointer
[	O
offset	short
]	O
.	O
kind	int
==	O
jit_kind_code	int
)	O
{	O
_jitc	O
->	O
values	pointer
[	O
offset	short
]	O
.	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
offset	short
]	O
;	O
}	O
}	O
if	O
(	O
value	int
->	O
kind	int
==	O
0	int
)	O
{	O
value	int
->	O
kind	int
=	O
jit_kind_code	int
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_stxi_c	int
:	O
value	int
->	O
code	pointer
=	O
jit_code_ldxi_c	int
;	O
break	O
;	O
case	O
jit_code_stxi_s	int
:	O
value	int
->	O
code	pointer
=	O
jit_code_ldxi_s	int
;	O
break	O
;	O
case	O
jit_code_stxi_i	int
:	O
value	int
->	O
code	pointer
=	O
jit_code_ldxi_i	int
;	O
break	O
;	O
case	O
jit_code_stxi_l	int
:	O
value	int
->	O
code	pointer
=	O
jit_code_ldxi_l	int
;	O
break	O
;	O
case	O
jit_code_stxi_f	int
:	O
value	int
->	O
code	pointer
=	O
jit_code_ldxi_f	int
;	O
break	O
;	O
case	O
jit_code_stxi_d	int
:	O
value	int
->	O
code	pointer
=	O
jit_code_ldxi_d	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
value	int
->	O
kind	int
=	O
jit_kind_code	int
;	O
value	int
->	O
base	union
.	O
q	struct
.	O
l	int
=	O
right	int
;	O
value	int
->	O
base	union
.	O
q	struct
.	O
h	int
=	O
_jitc	O
->	O
gen	pointer
[	O
right	int
]	O
;	O
value	int
->	O
disp	union
.	O
w	long
=	O
node	pointer
->	O
u	union
.	O
w	long
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_simplify_spill	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
regno	int
)	O
{	O
jit_node_t	struct
*	O
save	pointer
;	O
jit_node_t	struct
*	O
temp	pointer
;	O
if	O
(	O
(	O
temp	pointer
=	O
_jitc	O
->	O
spill	pointer
[	O
regno	int
]	O
)	O
&&	O
(	O
save	pointer
=	O
temp	pointer
->	O
next	pointer
)	O
!=	O
node	pointer
)	O
{	O
temp	pointer
->	O
next	pointer
=	O
save	pointer
->	O
next	pointer
;	O
save	pointer
->	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
node	pointer
->	O
next	pointer
=	O
save	pointer
;	O
_jitc	O
->	O
spill	pointer
[	O
regno	int
]	O
=	O
node	pointer
;	O
}	O
}	O
static	O
void	O
_simplify	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
prev	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_node_t	struct
*	O
next	pointer
;	O
jit_int32_t	int
info	int
;	O
jit_int32_t	int
regno	int
;	O
for	O
(	O
prev	pointer
=	O
NULL	O
,	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
prev	pointer
=	O
node	pointer
,	O
node	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_prolog	int
:	O
case	O
jit_code_callr	int
:	O
case	O
jit_code_calli	int
:	O
reset	O
:	O
memset	function
(	O
_jitc	O
->	O
gen	pointer
,	O
0	int
,	O
sizeof	O
(	O
jit_int32_t	int
)	O
*	O
_jitc	O
->	O
reglen	int
)	O
;	O
memset	function
(	O
_jitc	O
->	O
values	pointer
,	O
0	int
,	O
sizeof	O
(	O
jit_value_t	struct
)	O
*	O
_jitc	O
->	O
reglen	int
)	O
;	O
break	O
;	O
case	O
jit_code_save	int
:	O
_jitc	O
->	O
spill	pointer
[	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
]	O
=	O
prev	pointer
;	O
break	O
;	O
case	O
jit_code_load	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
register_change_p	O
(	O
node	pointer
->	O
link	function
->	O
next	pointer
,	O
node	pointer
,	O
regno	int
)	O
!=	O
jit_reg_change	int
)	O
{	O
patch_register	O
(	O
node	pointer
->	O
link	function
->	O
next	pointer
,	O
node	pointer
,	O
jit_regno_patch	int
|	O
regno	int
,	O
regno	int
)	O
;	O
del_node	O
(	O
_jitc	O
->	O
spill	pointer
[	O
regno	int
]	O
,	O
node	pointer
->	O
link	function
)	O
;	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
node	pointer
=	O
prev	pointer
;	O
}	O
_jitc	O
->	O
spill	pointer
[	O
regno	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
jit_code_movr	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_movr	O
(	O
prev	pointer
,	O
node	pointer
,	O
jit_kind_word	int
,	O
sizeof	O
(	O
jit_word_t	long
)	O
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_movi	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_movi	O
(	O
prev	pointer
,	O
node	pointer
,	O
jit_kind_word	int
,	O
sizeof	O
(	O
jit_word_t	long
)	O
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_movr_f	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_movr	O
(	O
prev	pointer
,	O
node	pointer
,	O
jit_kind_float32	int
,	O
sizeof	O
(	O
jit_float32_t	float
)	O
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_movi_f	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_movi	O
(	O
prev	pointer
,	O
node	pointer
,	O
jit_kind_float32	int
,	O
sizeof	O
(	O
jit_float32_t	float
)	O
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_movr_d	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_movr	O
(	O
prev	pointer
,	O
node	pointer
,	O
jit_kind_float64	int
,	O
sizeof	O
(	O
jit_float64_t	double
)	O
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_movi_d	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_movi	O
(	O
prev	pointer
,	O
node	pointer
,	O
jit_kind_float64	int
,	O
sizeof	O
(	O
jit_float64_t	double
)	O
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_ldxi_c	int
:	O
case	O
jit_code_ldxi_uc	int
:	O
case	O
jit_code_ldxi_s	int
:	O
case	O
jit_code_ldxi_us	int
:	O
case	O
jit_code_ldxi_i	int
:	O
case	O
jit_code_ldxi_ui	int
:	O
case	O
jit_code_ldxi_l	int
:	O
case	O
jit_code_ldxi_f	int
:	O
case	O
jit_code_ldxi_d	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_ldxi	O
(	O
prev	pointer
,	O
node	pointer
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
case	O
jit_code_stxi_c	int
:	O
case	O
jit_code_stxi_s	int
:	O
case	O
jit_code_stxi_i	int
:	O
case	O
jit_code_stxi_l	int
:	O
case	O
jit_code_stxi_f	int
:	O
case	O
jit_code_stxi_d	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
simplify_stxi	O
(	O
prev	pointer
,	O
node	pointer
)	O
)	O
simplify_spill	O
(	O
node	pointer
=	O
prev	pointer
,	O
regno	int
)	O
;	O
break	O
;	O
default	O
:	O
info	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
info	int
&	O
jit_cc_a0_jmp	int
)	O
goto	O
reset	O
;	O
if	O
(	O
info	int
&	O
jit_cc_a0_chg	int
)	O
{	O
if	O
(	O
info	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
)	O
;	O
_jitc	O
->	O
values	pointer
[	O
regno	int
]	O
.	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
)	O
;	O
_jitc	O
->	O
values	pointer
[	O
regno	int
]	O
.	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
}	O
else	O
{	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
_jitc	O
->	O
values	pointer
[	O
regno	int
]	O
.	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
}	O
}	O
if	O
(	O
info	int
&	O
jit_cc_a1_chg	int
)	O
{	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
;	O
_jitc	O
->	O
values	pointer
[	O
regno	int
]	O
.	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
}	O
if	O
(	O
info	int
&	O
jit_cc_a2_chg	int
)	O
{	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
w	long
.	O
w	long
)	O
;	O
_jitc	O
->	O
values	pointer
[	O
regno	int
]	O
.	O
kind	int
=	O
0	int
;	O
++	O
_jitc	O
->	O
gen	pointer
[	O
regno	int
]	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
static	O
jit_int32_t	int
_register_change_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_node_t	struct
*	O
link	function
,	O
jit_int32_t	int
regno	int
)	O
{	O
jit_int32_t	int
value	int
;	O
for	O
(	O
;	O
node	pointer
!=	O
link	function
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_label	int
:	O
case	O
jit_code_prolog	int
:	O
return	O
(	O
jit_reg_change	int
)	O
;	O
case	O
jit_code_callr	int
:	O
case	O
jit_code_calli	int
:	O
if	O
(	O
!	O
(	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
jit_class_sav	int
)	O
)	O
return	O
(	O
jit_reg_undef	O
)	O
;	O
break	O
;	O
default	O
:	O
value	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a0_jmp	int
)	O
return	O
(	O
jit_reg_change	int
)	O
;	O
else	O
if	O
(	O
(	O
value	int
&	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
)	O
)	O
==	O
(	O
jit_cc_a0_reg	int
|	O
jit_cc_a0_chg	int
)	O
&&	O
(	O
(	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
&&	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
==	O
regno	int
||	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
==	O
regno	int
)	O
)	O
||	O
(	O
!	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
&&	O
node	pointer
->	O
u	union
.	O
w	long
==	O
regno	int
)	O
)	O
)	O
return	O
(	O
jit_reg_change	int
)	O
;	O
else	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
&&	O
node	pointer
->	O
v	union
.	O
w	long
==	O
regno	int
&&	O
(	O
value	int
&	O
jit_cc_a1_chg	int
)	O
)	O
return	O
(	O
jit_reg_change	int
)	O
;	O
else	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
&&	O
node	pointer
->	O
w	long
.	O
w	long
==	O
regno	int
&&	O
(	O
value	int
&	O
jit_cc_a2_chg	int
)	O
)	O
return	O
(	O
jit_reg_change	int
)	O
;	O
}	O
}	O
return	O
(	O
jit_reg_static	int
)	O
;	O
}	O
static	O
jit_bool_t	int
_spill_reglive_p	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_int32_t	int
regno	int
)	O
{	O
if	O
(	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
regno	int
)	O
)	O
{	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
regmask	long
,	O
regno	int
)	O
;	O
jit_update	O
(	O
node	pointer
->	O
next	pointer
,	O
&	O
_jitc	O
->	O
reglive	long
,	O
&	O
_jitc	O
->	O
regmask	long
)	O
;	O
if	O
(	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
regno	int
)	O
&&	O
register_change_p	O
(	O
node	pointer
->	O
next	pointer
,	O
node	pointer
->	O
link	function
,	O
regno	int
)	O
!=	O
jit_reg_change	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
void	O
_patch_registers	function
(	O
jit_state_t	struct
*	O
_jit	pointer
)	O
{	O
jit_node_t	struct
*	O
prev	pointer
;	O
jit_node_t	struct
*	O
node	pointer
;	O
jit_node_t	struct
*	O
next	pointer
;	O
jit_int32_t	int
info	int
;	O
jit_int32_t	int
spec	enum
;	O
jit_int32_t	int
regno	int
;	O
jit_int32_t	int
value	int
;	O
_jitc	O
->	O
function	pointer
=	O
NULL	O
;	O
jit_reglive_setup	O
(	O
)	O
;	O
for	O
(	O
prev	pointer
=	O
NULL	O
,	O
node	pointer
=	O
_jitc	O
->	O
head	pointer
;	O
node	pointer
;	O
node	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
info	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
jit_regarg_set	O
(	O
node	pointer
,	O
info	int
)	O
;	O
switch	O
(	O
node	pointer
->	O
code	pointer
)	O
{	O
case	O
jit_code_save	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
!	O
spill_reglive_p	O
(	O
node	pointer
,	O
regno	int
)	O
)	O
{	O
jit_regarg_clr	O
(	O
node	pointer
,	O
info	int
)	O
;	O
node	pointer
->	O
link	function
->	O
v	union
.	O
w	long
=	O
jit_regload_delete	int
;	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
&	O
~	O
jit_class_arg	int
;	O
for	O
(	O
value	int
=	O
0	int
;	O
value	int
<	O
_jitc	O
->	O
reglen	int
;	O
value	int
++	O
)	O
{	O
if	O
(	O
value	int
!=	O
regno	int
&&	O
(	O
(	O
jit_class	O
(	O
_rvs	array
[	O
value	int
]	O
.	O
spec	enum
)	O
&	O
spec	enum
)	O
&	O
~	O
jit_class_arg	int
)	O
==	O
spec	enum
&&	O
!	O
jit_regset_tstbit	O
(	O
&	O
_jitc	O
->	O
regarg	long
,	O
value	int
)	O
&&	O
!	O
spill_reglive_p	O
(	O
node	pointer
,	O
value	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
value	int
<	O
_jitc	O
->	O
reglen	int
)	O
{	O
jit_regarg_clr	O
(	O
node	pointer
,	O
info	int
)	O
;	O
patch_register	O
(	O
node	pointer
->	O
next	pointer
,	O
node	pointer
->	O
link	function
,	O
jit_regno_patch	int
|	O
node	pointer
->	O
u	union
.	O
w	long
,	O
jit_regno_patch	int
|	O
value	int
)	O
;	O
jit_regset_setbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
value	int
)	O
;	O
node	pointer
->	O
link	function
->	O
v	union
.	O
w	long
=	O
jit_regload_isdead	int
;	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
spec	enum
&	O
jit_class_gpr	int
)	O
{	O
if	O
(	O
!	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
)	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
=	O
jit_allocai	O
(	O
sizeof	O
(	O
jit_word_t	long
)	O
)	O
;	O
node	pointer
->	O
code	pointer
=	O
jit_code_stxi_l	int
;	O
}	O
else	O
{	O
node	pointer
->	O
code	pointer
=	O
jit_code_stxi_d	int
;	O
if	O
(	O
!	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
)	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
=	O
jit_allocai	O
(	O
sizeof	O
(	O
jit_float64_t	double
)	O
)	O
;	O
}	O
node	pointer
->	O
u	union
.	O
w	long
=	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
JIT_FP	O
;	O
node	pointer
->	O
w	long
.	O
w	long
=	O
regno	int
;	O
node	pointer
->	O
link	function
=	O
NULL	O
;	O
}	O
}	O
break	O
;	O
case	O
jit_code_load	int
:	O
regno	int
=	O
jit_regno	O
(	O
node	pointer
->	O
u	union
.	O
w	long
)	O
;	O
if	O
(	O
node	pointer
->	O
v	union
.	O
w	long
)	O
{	O
if	O
(	O
node	pointer
->	O
v	union
.	O
w	long
==	O
jit_regload_isdead	int
)	O
jit_regset_clrbit	O
(	O
&	O
_jitc	O
->	O
reglive	long
,	O
regno	int
)	O
;	O
del_node	O
(	O
prev	pointer
,	O
node	pointer
)	O
;	O
continue	O
;	O
}	O
spec	enum
=	O
jit_class	O
(	O
_rvs	array
[	O
regno	int
]	O
.	O
spec	enum
)	O
;	O
if	O
(	O
spec	enum
&	O
jit_class_gpr	int
)	O
{	O
node	pointer
->	O
code	pointer
=	O
jit_code_ldxi_l	int
;	O
}	O
else	O
node	pointer
->	O
code	pointer
=	O
jit_code_ldxi_d	int
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
regno	int
;	O
node	pointer
->	O
v	union
.	O
w	long
=	O
JIT_FP	O
;	O
node	pointer
->	O
w	long
.	O
w	long
=	O
_jitc	O
->	O
function	pointer
->	O
regoff	pointer
[	O
regno	int
]	O
;	O
node	pointer
->	O
link	function
=	O
NULL	O
;	O
break	O
;	O
case	O
jit_code_prolog	int
:	O
_jitc	O
->	O
function	pointer
=	O
_jitc	O
->	O
functions	struct
.	O
ptr	pointer
+	O
node	pointer
->	O
w	long
.	O
w	long
;	O
break	O
;	O
case	O
jit_code_epilog	int
:	O
_jitc	O
->	O
function	pointer
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
jit_regarg_clr	O
(	O
node	pointer
,	O
info	int
)	O
;	O
jit_reglive	O
(	O
node	pointer
)	O
;	O
prev	pointer
=	O
node	pointer
;	O
}	O
}	O
static	O
void	O
_patch_register	function
(	O
jit_state_t	struct
*	O
_jit	pointer
,	O
jit_node_t	struct
*	O
node	pointer
,	O
jit_node_t	struct
*	O
link	function
,	O
jit_int32_t	int
regno	int
,	O
jit_int32_t	int
patch	int
)	O
{	O
jit_int32_t	int
value	int
;	O
for	O
(	O
;	O
node	pointer
!=	O
link	function
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
value	int
=	O
jit_classify	O
(	O
node	pointer
->	O
code	pointer
)	O
;	O
if	O
(	O
value	int
&	O
jit_cc_a0_reg	int
)	O
{	O
if	O
(	O
value	int
&	O
jit_cc_a0_rlh	int
)	O
{	O
if	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
==	O
regno	int
)	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
l	int
=	O
patch	int
;	O
if	O
(	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
==	O
regno	int
)	O
node	pointer
->	O
u	union
.	O
q	struct
.	O
h	int
=	O
patch	int
;	O
}	O
else	O
{	O
if	O
(	O
node	pointer
->	O
u	union
.	O
w	long
==	O
regno	int
)	O
node	pointer
->	O
u	union
.	O
w	long
=	O
patch	int
;	O
}	O
}	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a1_reg	int
)	O
&&	O
node	pointer
->	O
v	union
.	O
w	long
==	O
regno	int
)	O
node	pointer
->	O
v	union
.	O
w	long
=	O
patch	int
;	O
if	O
(	O
(	O
value	int
&	O
jit_cc_a2_reg	int
)	O
&&	O
node	pointer
->	O
w	long
.	O
w	long
==	O
regno	int
)	O
node	pointer
->	O
w	long
.	O
w	long
=	O
patch	int
;	O
}	O
}	O