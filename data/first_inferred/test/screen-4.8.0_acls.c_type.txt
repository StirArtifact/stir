extern	O
struct	O
comm	struct
comms	array
[	O
]	O
;	O
extern	O
struct	O
win	struct
*	O
windows	pointer
,	O
*	O
*	O
wtab	pointer
;	O
extern	O
char	O
NullStr	array
[	O
]	O
;	O
extern	O
char	O
SockPath	array
[	O
]	O
;	O
extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
struct	O
acluser	struct
*	O
users	pointer
;	O
int	O
maxusercount	int
=	O
0	int
;	O
static	O
AclBits	pointer
userbits	array
;	O
static	O
char	O
default_w_bit	array
[	O
ACL_BITS_PER_WIN	int
]	O
=	O
{	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
static	O
char	O
default_c_bit	array
[	O
ACL_BITS_PER_CMD	int
]	O
=	O
{	O
0	int
}	O
;	O
static	O
int	O
GrowBitfield	function
__P	O
(	O
(	O
AclBits	pointer
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
struct	O
aclusergroup	struct
*	O
*	O
FindGroupPtr	function
__P	O
(	O
(	O
struct	O
aclusergroup	struct
*	O
*	O
,	O
struct	O
acluser	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
AclSetPermCmd	function
__P	O
(	O
(	O
struct	O
acluser	struct
*	O
,	O
char	O
*	O
,	O
struct	O
comm	struct
*	O
)	O
)	O
;	O
static	O
int	O
AclSetPermWin	function
__P	O
(	O
(	O
struct	O
acluser	struct
*	O
,	O
struct	O
acluser	struct
*	O
,	O
char	O
*	O
,	O
struct	O
win	struct
*	O
)	O
)	O
;	O
static	O
int	O
UserAcl	function
__P	O
(	O
(	O
struct	O
acluser	struct
*	O
,	O
struct	O
acluser	struct
*	O
*	O
,	O
int	O
,	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
int	O
UserAclCopy	function
__P	O
(	O
(	O
struct	O
acluser	struct
*	O
*	O
,	O
struct	O
acluser	struct
*	O
*	O
)	O
)	O
;	O
static	O
int	O
GrowBitfield	function
(	O
bfp	pointer
,	O
len	int
,	O
delta	int
,	O
defaultbit	int
)	O
AclBits	pointer
*	O
bfp	pointer
;	O
int	O
len	int
,	O
delta	int
,	O
defaultbit	int
;	O
{	O
AclBits	pointer
n	pointer
,	O
o	pointer
=	O
*	O
bfp	pointer
;	O
int	O
i	int
;	O
if	O
(	O
!	O
(	O
n	pointer
=	O
(	O
AclBits	pointer
)	O
calloc	function
(	O
1	int
,	O
(	O
unsigned	O
long	O
)	O
(	O
&	O
ACLBYTE	O
(	O
(	O
char	O
*	O
)	O
0	int
,	O
len	int
+	O
delta	int
+	O
1	int
)	O
)	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
len	int
+	O
delta	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
i	int
<	O
len	int
)	O
&&	O
(	O
ACLBIT	O
(	O
i	int
)	O
&	O
ACLBYTE	O
(	O
o	pointer
,	O
i	int
)	O
)	O
)	O
||	O
(	O
(	O
i	int
>=	O
len	int
)	O
&&	O
(	O
defaultbit	int
)	O
)	O
)	O
ACLBYTE	O
(	O
n	pointer
,	O
i	int
)	O
|=	O
ACLBIT	O
(	O
i	int
)	O
;	O
}	O
if	O
(	O
len	int
)	O
free	function
(	O
(	O
char	O
*	O
)	O
o	pointer
)	O
;	O
*	O
bfp	pointer
=	O
n	pointer
;	O
return	O
0	int
;	O
}	O
struct	O
acluser	struct
*	O
*	O
FindUserPtr	function
(	O
name	pointer
)	O
char	O
*	O
name	pointer
;	O
{	O
struct	O
acluser	struct
*	O
*	O
u	pointer
;	O
for	O
(	O
u	pointer
=	O
&	O
users	pointer
;	O
*	O
u	pointer
;	O
u	pointer
=	O
&	O
(	O
*	O
u	pointer
)	O
->	O
u_next	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
(	O
*	O
u	pointer
)	O
->	O
u_name	array
,	O
name	pointer
)	O
)	O
break	O
;	O
debug3	O
(	O
"FindUserPtr %s %sfound, id %d\n"	pointer
,	O
name	pointer
,	O
(	O
*	O
u	pointer
)	O
?	O
""	pointer
:	O
"not "	pointer
,	O
(	O
*	O
u	pointer
)	O
?	O
(	O
*	O
u	pointer
)	O
->	O
u_id	int
:	O
-	O
1	int
)	O
;	O
return	O
u	pointer
;	O
}	O
int	O
DefaultEsc	int
=	O
-	O
1	int
;	O
int	O
DefaultMetaEsc	int
=	O
-	O
1	int
;	O
int	O
UserAdd	function
(	O
name	pointer
,	O
pass	pointer
,	O
up	pointer
)	O
char	O
*	O
name	pointer
,	O
*	O
pass	pointer
;	O
struct	O
acluser	struct
*	O
*	O
up	pointer
;	O
{	O
int	O
j	int
;	O
if	O
(	O
!	O
up	pointer
)	O
up	pointer
=	O
FindUserPtr	function
(	O
name	pointer
)	O
;	O
if	O
(	O
*	O
up	pointer
)	O
{	O
if	O
(	O
pass	pointer
)	O
(	O
*	O
up	pointer
)	O
->	O
u_password	pointer
=	O
SaveStr	function
(	O
pass	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
"none"	pointer
,	O
name	pointer
)	O
)	O
*	O
up	pointer
=	O
(	O
struct	O
acluser	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
acluser	struct
)	O
)	O
;	O
if	O
(	O
!	O
*	O
up	pointer
)	O
return	O
-	O
1	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_plop	struct
.	O
buf	pointer
=	O
NULL	O
;	O
(	O
*	O
up	pointer
)	O
->	O
u_plop	struct
.	O
len	int
=	O
0	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_plop	struct
.	O
enc	int
=	O
0	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_Esc	int
=	O
DefaultEsc	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_MetaEsc	int
=	O
DefaultMetaEsc	int
;	O
strncpy	function
(	O
(	O
*	O
up	pointer
)	O
->	O
u_name	array
,	O
name	pointer
,	O
MAXLOGINLEN	int
)	O
;	O
(	O
*	O
up	pointer
)	O
->	O
u_password	pointer
=	O
NULL	O
;	O
if	O
(	O
pass	pointer
)	O
(	O
*	O
up	pointer
)	O
->	O
u_password	pointer
=	O
SaveStr	function
(	O
pass	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
up	pointer
)	O
->	O
u_password	pointer
)	O
(	O
*	O
up	pointer
)	O
->	O
u_password	pointer
=	O
NullStr	array
;	O
(	O
*	O
up	pointer
)	O
->	O
u_detachwin	int
=	O
-	O
1	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_detachotherwin	int
=	O
-	O
1	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_group	pointer
=	O
NULL	O
;	O
for	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
=	O
0	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
<	O
maxusercount	int
;	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
++	O
)	O
if	O
(	O
!	O
(	O
ACLBIT	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
&	O
ACLBYTE	O
(	O
userbits	array
,	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
)	O
)	O
break	O
;	O
debug2	O
(	O
"UserAdd %s id %d\n"	pointer
,	O
name	pointer
,	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
;	O
if	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
==	O
maxusercount	int
)	O
{	O
int	O
j	int
;	O
struct	O
win	struct
*	O
w	pointer
;	O
struct	O
acluser	struct
*	O
u	pointer
;	O
debug2	O
(	O
"growing all bitfields %d += %d\n"	pointer
,	O
maxusercount	int
,	O
USER_CHUNK	int
)	O
;	O
if	O
(	O
GrowBitfield	function
(	O
&	O
userbits	array
,	O
maxusercount	int
,	O
USER_CHUNK	int
,	O
0	int
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
*	O
up	pointer
)	O
;	O
*	O
up	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
RC_LAST	int
;	O
j	int
++	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ACL_BITS_PER_CMD	int
;	O
i	int
++	O
)	O
if	O
(	O
GrowBitfield	function
(	O
&	O
comms	array
[	O
j	int
]	O
.	O
userbits	array
[	O
i	int
]	O
,	O
maxusercount	int
,	O
USER_CHUNK	int
,	O
default_c_bit	array
[	O
i	int
]	O
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
*	O
up	pointer
)	O
;	O
*	O
up	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
for	O
(	O
u	pointer
=	O
users	pointer
;	O
u	pointer
!=	O
*	O
up	pointer
;	O
u	pointer
=	O
u	pointer
->	O
u_next	pointer
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ACL_BITS_PER_WIN	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
GrowBitfield	function
(	O
&	O
u	pointer
->	O
u_umask_w_bits	array
[	O
j	int
]	O
,	O
maxusercount	int
,	O
USER_CHUNK	int
,	O
default_w_bit	array
[	O
j	int
]	O
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
*	O
up	pointer
)	O
;	O
*	O
up	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
w	pointer
=	O
windows	pointer
;	O
w	pointer
;	O
w	pointer
=	O
w	pointer
->	O
w_next	pointer
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ACL_BITS_PER_WIN	int
;	O
j	int
++	O
)	O
if	O
(	O
GrowBitfield	function
(	O
&	O
w	pointer
->	O
w_userbits	array
[	O
j	int
]	O
,	O
maxusercount	int
,	O
USER_CHUNK	int
,	O
default_w_bit	array
[	O
j	int
]	O
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
*	O
up	pointer
)	O
;	O
*	O
up	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
GrowBitfield	function
(	O
&	O
w	pointer
->	O
w_mon_notify	pointer
,	O
maxusercount	int
,	O
USER_CHUNK	int
,	O
0	int
)	O
||	O
GrowBitfield	function
(	O
&	O
w	pointer
->	O
w_lio_notify	pointer
,	O
maxusercount	int
,	O
USER_CHUNK	int
,	O
0	int
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
*	O
up	pointer
)	O
;	O
*	O
up	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
maxusercount	int
+=	O
USER_CHUNK	int
;	O
}	O
ACLBYTE	O
(	O
userbits	array
,	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
|=	O
ACLBIT	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
;	O
if	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
==	O
0	int
)	O
AclSetPerm	function
(	O
NULL	O
,	O
*	O
up	pointer
,	O
"+a"	pointer
,	O
"#?"	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
(	O
*	O
up	pointer
)	O
->	O
u_name	array
,	O
"nobody"	pointer
)	O
)	O
{	O
AclSetPerm	function
(	O
NULL	O
,	O
*	O
up	pointer
,	O
"-rwx"	pointer
,	O
"#?"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
*	O
up	pointer
,	O
"+x"	pointer
,	O
"su"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
*	O
up	pointer
,	O
"+x"	pointer
,	O
"detach"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
*	O
up	pointer
,	O
"+x"	pointer
,	O
"displays"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
*	O
up	pointer
,	O
"+x"	pointer
,	O
"version"	pointer
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ACL_BITS_PER_WIN	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
GrowBitfield	function
(	O
&	O
(	O
*	O
up	pointer
)	O
->	O
u_umask_w_bits	array
[	O
j	int
]	O
,	O
0	int
,	O
maxusercount	int
,	O
default_w_bit	array
[	O
j	int
]	O
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
*	O
up	pointer
)	O
;	O
*	O
up	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
ACLBYTE	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_umask_w_bits	array
[	O
j	int
]	O
,	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
|=	O
ACLBIT	O
(	O
(	O
*	O
up	pointer
)	O
->	O
u_id	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
UserDel	function
(	O
name	pointer
,	O
up	pointer
)	O
char	O
*	O
name	pointer
;	O
struct	O
acluser	struct
*	O
*	O
up	pointer
;	O
{	O
struct	O
acluser	struct
*	O
u	pointer
;	O
int	O
i	int
;	O
struct	O
display	struct
*	O
old	pointer
,	O
*	O
next	pointer
;	O
if	O
(	O
!	O
up	pointer
)	O
up	pointer
=	O
FindUserPtr	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
(	O
u	pointer
=	O
*	O
up	pointer
)	O
)	O
return	O
-	O
1	int
;	O
old	pointer
=	O
display	struct
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
next	pointer
)	O
{	O
next	pointer
=	O
display	struct
->	O
d_next	pointer
;	O
if	O
(	O
D_user	O
!=	O
u	pointer
)	O
continue	O
;	O
if	O
(	O
display	struct
==	O
old	pointer
)	O
old	pointer
=	O
NULL	O
;	O
Detach	function
(	O
D_REMOTE	int
)	O
;	O
}	O
display	struct
=	O
old	pointer
;	O
*	O
up	pointer
=	O
u	pointer
->	O
u_next	pointer
;	O
for	O
(	O
up	pointer
=	O
&	O
users	pointer
;	O
*	O
up	pointer
;	O
up	pointer
=	O
&	O
(	O
*	O
up	pointer
)	O
->	O
u_next	pointer
)	O
{	O
struct	O
aclusergroup	struct
*	O
*	O
g	pointer
=	O
&	O
(	O
*	O
up	pointer
)	O
->	O
u_group	pointer
;	O
while	O
(	O
*	O
g	pointer
)	O
{	O
if	O
(	O
(	O
*	O
g	pointer
)	O
->	O
u	pointer
==	O
u	pointer
)	O
{	O
struct	O
aclusergroup	struct
*	O
next	pointer
=	O
(	O
*	O
g	pointer
)	O
->	O
next	pointer
;	O
free	function
(	O
(	O
char	O
*	O
)	O
(	O
*	O
g	pointer
)	O
)	O
;	O
*	O
g	pointer
=	O
next	pointer
;	O
}	O
else	O
g	pointer
=	O
&	O
(	O
*	O
g	pointer
)	O
->	O
next	pointer
;	O
}	O
}	O
ACLBYTE	O
(	O
userbits	array
,	O
u	pointer
->	O
u_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
u	pointer
,	O
default_w_bit	array
[	O
ACL_READ	int
]	O
?	O
"+r"	pointer
:	O
"-r"	pointer
,	O
"#"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
u	pointer
,	O
default_w_bit	array
[	O
ACL_WRITE	int
]	O
?	O
"+w"	pointer
:	O
"-w"	pointer
,	O
"#"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
u	pointer
,	O
default_w_bit	array
[	O
ACL_EXEC	int
]	O
?	O
"+x"	pointer
:	O
"-x"	pointer
,	O
"#"	pointer
)	O
;	O
AclSetPerm	function
(	O
NULL	O
,	O
u	pointer
,	O
default_c_bit	array
[	O
ACL_EXEC	int
]	O
?	O
"+x"	pointer
:	O
"-x"	pointer
,	O
"?"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ACL_BITS_PER_WIN	int
;	O
i	int
++	O
)	O
free	function
(	O
(	O
char	O
*	O
)	O
u	pointer
->	O
u_umask_w_bits	array
[	O
i	int
]	O
)	O
;	O
debug1	O
(	O
"FREEING user structure for %s\n"	pointer
,	O
u	pointer
->	O
u_name	array
)	O
;	O
UserFreeCopyBuffer	function
(	O
u	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
u	pointer
)	O
;	O
if	O
(	O
!	O
users	pointer
)	O
{	O
debug	O
(	O
"Last user deleted. Feierabend.\n"	pointer
)	O
;	O
Finit	function
(	O
0	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
UserFreeCopyBuffer	function
(	O
u	pointer
)	O
struct	O
acluser	struct
*	O
u	pointer
;	O
{	O
struct	O
win	struct
*	O
w	pointer
;	O
struct	O
paster	struct
*	O
pa	pointer
;	O
if	O
(	O
!	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
return	O
1	int
;	O
for	O
(	O
w	pointer
=	O
windows	pointer
;	O
w	pointer
;	O
w	pointer
=	O
w	pointer
->	O
w_next	pointer
)	O
{	O
pa	pointer
=	O
&	O
w	pointer
->	O
w_paster	struct
;	O
if	O
(	O
pa	pointer
->	O
pa_pasteptr	pointer
>=	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
&&	O
pa	pointer
->	O
pa_pasteptr	pointer
-	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
<	O
u	pointer
->	O
u_plop	struct
.	O
len	int
)	O
FreePaster	function
(	O
pa	pointer
)	O
;	O
}	O
free	function
(	O
(	O
char	O
*	O
)	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
;	O
u	pointer
->	O
u_plop	struct
.	O
len	int
=	O
0	int
;	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
aclusergroup	struct
*	O
*	O
FindGroupPtr	function
(	O
gp	pointer
,	O
u	pointer
,	O
recursive	int
)	O
struct	O
aclusergroup	struct
*	O
*	O
gp	pointer
;	O
struct	O
acluser	struct
*	O
u	pointer
;	O
int	O
recursive	int
;	O
{	O
struct	O
aclusergroup	struct
*	O
*	O
g	pointer
;	O
ASSERT	O
(	O
recursive	int
<	O
1000	int
)	O
;	O
while	O
(	O
*	O
gp	pointer
)	O
{	O
if	O
(	O
(	O
*	O
gp	pointer
)	O
->	O
u	pointer
==	O
u	pointer
)	O
return	O
gp	pointer
;	O
if	O
(	O
recursive	int
&&	O
*	O
(	O
g	pointer
=	O
FindGroupPtr	function
(	O
&	O
(	O
*	O
gp	pointer
)	O
->	O
u	pointer
->	O
u_group	pointer
,	O
u	pointer
,	O
recursive	int
+	O
1	int
)	O
)	O
)	O
return	O
g	pointer
;	O
gp	pointer
=	O
&	O
(	O
*	O
gp	pointer
)	O
->	O
next	pointer
;	O
}	O
return	O
gp	pointer
;	O
}	O
static	O
int	O
PasswordMatches	function
(	O
pw	pointer
,	O
password	pointer
)	O
const	O
char	O
*	O
pw	pointer
,	O
*	O
password	pointer
;	O
{	O
if	O
(	O
!	O
*	O
password	pointer
)	O
return	O
0	int
;	O
char	O
*	O
buf	pointer
=	O
crypt	function
(	O
(	O
char	O
*	O
)	O
pw	pointer
,	O
(	O
char	O
*	O
)	O
password	pointer
)	O
;	O
return	O
(	O
buf	pointer
&&	O
!	O
strcmp	function
(	O
buf	pointer
,	O
password	pointer
)	O
)	O
;	O
}	O
int	O
AclLinkUser	function
(	O
from	pointer
,	O
to	pointer
)	O
char	O
*	O
from	pointer
,	O
*	O
to	pointer
;	O
{	O
struct	O
acluser	struct
*	O
*	O
u1	pointer
,	O
*	O
*	O
u2	pointer
;	O
struct	O
aclusergroup	struct
*	O
*	O
g	pointer
;	O
if	O
(	O
!	O
*	O
(	O
u1	pointer
=	O
FindUserPtr	function
(	O
from	pointer
)	O
)	O
&&	O
UserAdd	function
(	O
from	pointer
,	O
NULL	O
,	O
u1	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
*	O
(	O
u2	pointer
=	O
FindUserPtr	function
(	O
to	pointer
)	O
)	O
&&	O
UserAdd	function
(	O
to	pointer
,	O
NULL	O
,	O
u2	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
FindGroupPtr	function
(	O
&	O
(	O
*	O
u2	pointer
)	O
->	O
u_group	pointer
,	O
*	O
u1	pointer
,	O
1	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
*	O
(	O
g	pointer
=	O
FindGroupPtr	function
(	O
&	O
(	O
*	O
u1	pointer
)	O
->	O
u_group	pointer
,	O
*	O
u2	pointer
,	O
0	int
)	O
)	O
)	O
return	O
2	int
;	O
if	O
(	O
!	O
(	O
*	O
g	pointer
=	O
(	O
struct	O
aclusergroup	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
aclusergroup	struct
)	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
(	O
*	O
g	pointer
)	O
->	O
u	pointer
=	O
(	O
*	O
u2	pointer
)	O
;	O
(	O
*	O
g	pointer
)	O
->	O
next	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
DoSu	function
(	O
up	pointer
,	O
name	pointer
,	O
pw1	pointer
,	O
pw2	pointer
)	O
struct	O
acluser	struct
*	O
*	O
up	pointer
;	O
char	O
*	O
name	pointer
,	O
*	O
pw1	pointer
,	O
*	O
pw2	pointer
;	O
{	O
struct	O
acluser	struct
*	O
u	pointer
;	O
int	O
sorry	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
u	pointer
=	O
*	O
FindUserPtr	function
(	O
name	pointer
)	O
)	O
)	O
sorry	int
++	O
;	O
else	O
{	O
struct	O
passwd	struct
*	O
pp	pointer
;	O
struct	O
spwd	struct
*	O
ss	pointer
;	O
int	O
t	int
,	O
c	int
;	O
char	O
*	O
pass	pointer
=	O
""	pointer
;	O
if	O
(	O
!	O
(	O
pp	pointer
=	O
getpwnam	function
(	O
name	pointer
)	O
)	O
)	O
{	O
debug1	O
(	O
"getpwnam(\"%s\") failed\n"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pw1	pointer
&&	O
*	O
pw1	pointer
&&	O
*	O
pw1	pointer
!=	O
'\377'	O
)	O
)	O
{	O
debug	O
(	O
"no unix account, no screen passwd\n"	pointer
)	O
;	O
sorry	int
++	O
;	O
}	O
}	O
else	O
pass	pointer
=	O
pp	pointer
->	O
pw_passwd	pointer
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
13	int
;	O
t	int
++	O
)	O
{	O
c	int
=	O
pass	pointer
[	O
t	int
]	O
;	O
if	O
(	O
!	O
(	O
c	int
==	O
'.'	O
||	O
c	int
==	O
'/'	O
||	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
||	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
t	int
<	O
13	int
)	O
{	O
if	O
(	O
!	O
(	O
ss	pointer
=	O
getspnam	function
(	O
name	pointer
)	O
)	O
)	O
{	O
debug1	O
(	O
"getspnam(\"%s\") failed\n"	pointer
,	O
name	pointer
)	O
;	O
sorry	int
++	O
;	O
}	O
else	O
pass	pointer
=	O
ss	pointer
->	O
sp_pwdp	pointer
;	O
}	O
if	O
(	O
pw2	pointer
&&	O
*	O
pw2	pointer
&&	O
*	O
pw2	pointer
!=	O
'\377'	O
)	O
{	O
if	O
(	O
!	O
PasswordMatches	function
(	O
pw2	pointer
,	O
pass	pointer
)	O
)	O
{	O
debug	O
(	O
"System password mismatch\n"	pointer
)	O
;	O
sorry	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
pass	pointer
)	O
sorry	int
++	O
;	O
if	O
(	O
pw1	pointer
&&	O
*	O
pw1	pointer
&&	O
*	O
pw1	pointer
!=	O
'\377'	O
)	O
{	O
if	O
(	O
!	O
PasswordMatches	function
(	O
pw1	pointer
,	O
u	pointer
->	O
u_password	pointer
)	O
)	O
{	O
debug	O
(	O
"screen password mismatch\n"	pointer
)	O
;	O
sorry	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
u	pointer
->	O
u_password	pointer
)	O
sorry	int
++	O
;	O
}	O
debug2	O
(	O
"syslog(LOG_NOTICE, \"screen %s: \"su %s\" "	pointer
,	O
SockPath	array
,	O
name	pointer
)	O
;	O
debug2	O
(	O
"%s for \"%s\"\n"	pointer
,	O
sorry	int
?	O
"failed"	pointer
:	O
"succeeded"	pointer
,	O
(	O
*	O
up	pointer
)	O
->	O
u_name	array
)	O
;	O
openlog	function
(	O
"screen"	pointer
,	O
LOG_PID	int
,	O
LOG_AUTH	O
)	O
;	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"%s: \"su %s\" %s for \"%s\""	pointer
,	O
SockPath	array
,	O
name	pointer
,	O
sorry	int
?	O
"failed"	pointer
:	O
"succeeded"	pointer
,	O
(	O
*	O
up	pointer
)	O
->	O
u_name	array
)	O
;	O
closelog	function
(	O
)	O
;	O
if	O
(	O
sorry	int
)	O
return	O
"Sorry."	pointer
;	O
else	O
*	O
up	pointer
=	O
u	pointer
;	O
return	O
NULL	O
;	O
}	O
int	O
NewWindowAcl	function
(	O
w	pointer
,	O
u	pointer
)	O
struct	O
win	struct
*	O
w	pointer
;	O
struct	O
acluser	struct
*	O
u	pointer
;	O
{	O
int	O
i	int
,	O
j	int
;	O
debug2	O
(	O
"NewWindowAcl %s's umask_w_bits for window %d\n"	pointer
,	O
u	pointer
?	O
u	pointer
->	O
u_name	array
:	O
"everybody"	pointer
,	O
w	pointer
->	O
w_number	int
)	O
;	O
if	O
(	O
GrowBitfield	function
(	O
&	O
w	pointer
->	O
w_mon_notify	pointer
,	O
0	int
,	O
maxusercount	int
,	O
0	int
)	O
||	O
GrowBitfield	function
(	O
&	O
w	pointer
->	O
w_lio_notify	pointer
,	O
0	int
,	O
maxusercount	int
,	O
0	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ACL_BITS_PER_WIN	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
GrowBitfield	function
(	O
&	O
w	pointer
->	O
w_userbits	array
[	O
j	int
]	O
,	O
0	int
,	O
maxusercount	int
,	O
0	int
)	O
)	O
{	O
while	O
(	O
--	O
j	int
>=	O
0	int
)	O
free	function
(	O
(	O
char	O
*	O
)	O
w	pointer
->	O
w_userbits	array
[	O
j	int
]	O
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
w	pointer
->	O
w_mon_notify	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
w	pointer
->	O
w_lio_notify	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
maxusercount	int
;	O
i	int
++	O
)	O
if	O
(	O
u	pointer
?	O
(	O
ACLBIT	O
(	O
i	int
)	O
&	O
ACLBYTE	O
(	O
u	pointer
->	O
u_umask_w_bits	array
[	O
j	int
]	O
,	O
i	int
)	O
)	O
:	O
default_w_bit	array
[	O
j	int
]	O
)	O
ACLBYTE	O
(	O
w	pointer
->	O
w_userbits	array
[	O
j	int
]	O
,	O
i	int
)	O
|=	O
ACLBIT	O
(	O
i	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
FreeWindowAcl	function
(	O
w	pointer
)	O
struct	O
win	struct
*	O
w	pointer
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ACL_BITS_PER_WIN	int
;	O
i	int
++	O
)	O
free	function
(	O
(	O
char	O
*	O
)	O
w	pointer
->	O
w_userbits	array
[	O
i	int
]	O
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
w	pointer
->	O
w_mon_notify	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
w	pointer
->	O
w_lio_notify	pointer
)	O
;	O
}	O
static	O
int	O
AclSetPermCmd	function
(	O
u	pointer
,	O
mode	struct
,	O
cmd	array
)	O
struct	O
acluser	struct
*	O
u	pointer
;	O
char	O
*	O
mode	struct
;	O
struct	O
comm	struct
*	O
cmd	array
;	O
{	O
int	O
neg	int
=	O
0	int
;	O
char	O
*	O
m	union
=	O
mode	struct
;	O
while	O
(	O
*	O
m	union
)	O
{	O
switch	O
(	O
*	O
m	union
++	O
)	O
{	O
case	O
'-'	O
:	O
neg	int
=	O
1	int
;	O
continue	O
;	O
case	O
'+'	O
:	O
neg	int
=	O
0	int
;	O
continue	O
;	O
case	O
'a'	O
:	O
case	O
'e'	O
:	O
case	O
'x'	O
:	O
if	O
(	O
neg	int
)	O
ACLBYTE	O
(	O
cmd	array
->	O
userbits	array
[	O
ACL_EXEC	int
]	O
,	O
u	pointer
->	O
u_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
else	O
ACLBYTE	O
(	O
cmd	array
->	O
userbits	array
[	O
ACL_EXEC	int
]	O
,	O
u	pointer
->	O
u_id	int
)	O
|=	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'w'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
AclSetPermWin	function
(	O
uu	pointer
,	O
u	pointer
,	O
mode	struct
,	O
win	struct
)	O
struct	O
acluser	struct
*	O
u	pointer
,	O
*	O
uu	pointer
;	O
char	O
*	O
mode	struct
;	O
struct	O
win	struct
*	O
win	struct
;	O
{	O
int	O
neg	int
=	O
0	int
;	O
int	O
bit	int
,	O
bits	int
;	O
AclBits	pointer
*	O
bitarray	pointer
;	O
char	O
*	O
m	union
=	O
mode	struct
;	O
if	O
(	O
uu	pointer
)	O
{	O
debug3	O
(	O
"AclSetPermWin %s UMASK %s %s\n"	pointer
,	O
uu	pointer
->	O
u_name	array
,	O
u	pointer
->	O
u_name	array
,	O
mode	struct
)	O
;	O
bitarray	pointer
=	O
uu	pointer
->	O
u_umask_w_bits	array
;	O
}	O
else	O
{	O
ASSERT	O
(	O
win	struct
)	O
;	O
bitarray	pointer
=	O
win	struct
->	O
w_userbits	array
;	O
debug3	O
(	O
"AclSetPermWin %s %s %d\n"	pointer
,	O
u	pointer
->	O
u_name	array
,	O
mode	struct
,	O
win	struct
->	O
w_number	int
)	O
;	O
}	O
while	O
(	O
*	O
m	union
)	O
{	O
switch	O
(	O
*	O
m	union
++	O
)	O
{	O
case	O
'-'	O
:	O
neg	int
=	O
1	int
;	O
continue	O
;	O
case	O
'+'	O
:	O
neg	int
=	O
0	int
;	O
continue	O
;	O
case	O
'r'	O
:	O
bits	int
=	O
(	O
1	int
<<	O
ACL_READ	int
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
bits	int
=	O
(	O
1	int
<<	O
ACL_WRITE	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
bits	int
=	O
(	O
1	int
<<	O
ACL_EXEC	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
bits	int
=	O
(	O
1	int
<<	O
ACL_BITS_PER_WIN	int
)	O
-	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
bit	int
=	O
0	int
;	O
bit	int
<	O
ACL_BITS_PER_WIN	int
;	O
bit	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
bits	int
&	O
(	O
1	int
<<	O
bit	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
neg	int
)	O
ACLBYTE	O
(	O
bitarray	pointer
[	O
bit	int
]	O
,	O
u	pointer
->	O
u_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
else	O
ACLBYTE	O
(	O
bitarray	pointer
[	O
bit	int
]	O
,	O
u	pointer
->	O
u_id	int
)	O
|=	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
if	O
(	O
!	O
uu	pointer
&&	O
(	O
win	struct
->	O
w_wlockuser	pointer
==	O
u	pointer
)	O
&&	O
neg	int
&&	O
(	O
bit	int
==	O
ACL_WRITE	int
)	O
)	O
{	O
debug2	O
(	O
"%s lost writelock on win %d\n"	pointer
,	O
u	pointer
->	O
u_name	array
,	O
win	struct
->	O
w_number	int
)	O
;	O
win	struct
->	O
w_wlockuser	pointer
=	O
NULL	O
;	O
if	O
(	O
win	struct
->	O
w_wlock	int
==	O
WLOCK_ON	int
)	O
win	struct
->	O
w_wlock	int
=	O
WLOCK_AUTO	int
;	O
}	O
}	O
}	O
if	O
(	O
uu	pointer
&&	O
u	pointer
->	O
u_name	array
[	O
0	int
]	O
==	O
'?'	O
&&	O
u	pointer
->	O
u_name	array
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
win	struct
)	O
{	O
debug1	O
(	O
"AclSetPermWin: default_w_bits '%s'.\n"	pointer
,	O
mode	struct
)	O
;	O
for	O
(	O
bit	int
=	O
0	int
;	O
bit	int
<	O
ACL_BITS_PER_WIN	int
;	O
bit	int
++	O
)	O
default_w_bit	array
[	O
bit	int
]	O
=	O
(	O
ACLBYTE	O
(	O
bitarray	pointer
[	O
bit	int
]	O
,	O
u	pointer
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
)	O
?	O
1	int
:	O
0	int
;	O
}	O
else	O
{	O
debug1	O
(	O
"AclSetPermWin: default_c_bits '%s'.\n"	pointer
,	O
mode	struct
)	O
;	O
for	O
(	O
bit	int
=	O
0	int
;	O
bit	int
<	O
ACL_BITS_PER_CMD	int
;	O
bit	int
++	O
)	O
default_c_bit	array
[	O
bit	int
]	O
=	O
(	O
ACLBYTE	O
(	O
bitarray	pointer
[	O
bit	int
]	O
,	O
u	pointer
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
)	O
?	O
1	int
:	O
0	int
;	O
}	O
UserDel	function
(	O
u	pointer
->	O
u_name	array
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
AclSetPerm	function
(	O
uu	pointer
,	O
u	pointer
,	O
mode	struct
,	O
s	pointer
)	O
struct	O
acluser	struct
*	O
uu	pointer
,	O
*	O
u	pointer
;	O
char	O
*	O
mode	struct
,	O
*	O
s	pointer
;	O
{	O
struct	O
win	struct
*	O
w	pointer
;	O
int	O
i	int
;	O
char	O
*	O
p	pointer
,	O
ch	char
;	O
debug3	O
(	O
"AclSetPerm(uu, user '%s', mode '%s', object '%s')\n"	pointer
,	O
u	pointer
->	O
u_name	array
,	O
mode	struct
,	O
s	pointer
)	O
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'*'	O
:	O
return	O
AclSetPerm	function
(	O
uu	pointer
,	O
u	pointer
,	O
mode	struct
,	O
"#?"	pointer
)	O
;	O
case	O
'#'	O
:	O
if	O
(	O
uu	pointer
)	O
AclSetPermWin	function
(	O
uu	pointer
,	O
u	pointer
,	O
mode	struct
,	O
(	O
struct	O
win	struct
*	O
)	O
1	int
)	O
;	O
else	O
for	O
(	O
w	pointer
=	O
windows	pointer
;	O
w	pointer
;	O
w	pointer
=	O
w	pointer
->	O
w_next	pointer
)	O
AclSetPermWin	function
(	O
(	O
struct	O
acluser	struct
*	O
)	O
0	int
,	O
u	pointer
,	O
mode	struct
,	O
w	pointer
)	O
;	O
s	pointer
++	O
;	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
uu	pointer
)	O
AclSetPermWin	function
(	O
uu	pointer
,	O
u	pointer
,	O
mode	struct
,	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
RC_LAST	int
;	O
i	int
++	O
)	O
AclSetPermCmd	function
(	O
u	pointer
,	O
mode	struct
,	O
&	O
comms	array
[	O
i	int
]	O
)	O
;	O
s	pointer
++	O
;	O
break	O
;	O
default	O
:	O
for	O
(	O
p	pointer
=	O
s	pointer
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
!=	O
','	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
(	O
ch	char
=	O
*	O
p	pointer
)	O
)	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
i	int
=	O
FindCommnr	function
(	O
s	pointer
)	O
)	O
!=	O
RC_ILLEGAL	O
)	O
AclSetPermCmd	function
(	O
u	pointer
,	O
mode	struct
,	O
&	O
comms	array
[	O
i	int
]	O
)	O
;	O
else	O
if	O
(	O
(	O
(	O
i	int
=	O
WindowByNoN	function
(	O
s	pointer
)	O
)	O
>=	O
0	int
)	O
&&	O
wtab	pointer
[	O
i	int
]	O
)	O
AclSetPermWin	function
(	O
(	O
struct	O
acluser	struct
*	O
)	O
0	int
,	O
u	pointer
,	O
mode	struct
,	O
wtab	pointer
[	O
i	int
]	O
)	O
;	O
else	O
return	O
-	O
1	int
;	O
if	O
(	O
ch	char
)	O
p	pointer
[	O
-	O
1	int
]	O
=	O
ch	char
;	O
s	pointer
=	O
p	pointer
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
UserAcl	function
(	O
uu	pointer
,	O
u	pointer
,	O
argc	int
,	O
argv	pointer
)	O
struct	O
acluser	struct
*	O
uu	pointer
,	O
*	O
*	O
u	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
if	O
(	O
(	O
*	O
u	pointer
&&	O
!	O
strcmp	function
(	O
(	O
*	O
u	pointer
)	O
->	O
u_name	array
,	O
"nobody"	pointer
)	O
)	O
||	O
(	O
argc	int
>	O
1	int
&&	O
!	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"nobody"	pointer
)	O
)	O
)	O
return	O
-	O
1	int
;	O
switch	O
(	O
argc	int
)	O
{	O
case	O
1	int
+	O
1	int
+	O
2	int
:	O
debug2	O
(	O
"UserAcl: user '%s', password '%s':"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
(	O
UserAdd	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
,	O
u	pointer
)	O
<	O
0	int
)	O
||	O
AclSetPerm	function
(	O
uu	pointer
,	O
*	O
u	pointer
,	O
argv	pointer
[	O
2	int
]	O
,	O
argv	pointer
[	O
3	int
]	O
)	O
;	O
case	O
1	int
+	O
2	int
:	O
debug1	O
(	O
"UserAcl: user '%s', no password:"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
UserAdd	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
NULL	O
,	O
u	pointer
)	O
<	O
0	int
)	O
||	O
AclSetPerm	function
(	O
uu	pointer
,	O
*	O
u	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
case	O
1	int
+	O
1	int
:	O
debug2	O
(	O
"UserAcl: user '%s', password '%s'\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
UserAdd	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
,	O
u	pointer
)	O
<	O
0	int
;	O
case	O
1	int
:	O
debug1	O
(	O
"UserAcl: user '%s', no password:"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
UserAdd	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
NULL	O
,	O
u	pointer
)	O
<	O
0	int
)	O
||	O
AclSetPerm	function
(	O
uu	pointer
,	O
*	O
u	pointer
,	O
"+a"	pointer
,	O
"#?"	pointer
)	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
static	O
int	O
UserAclCopy	function
(	O
to_up	pointer
,	O
from_up	pointer
)	O
struct	O
acluser	struct
*	O
*	O
to_up	pointer
,	O
*	O
*	O
from_up	pointer
;	O
{	O
struct	O
win	struct
*	O
w	pointer
;	O
int	O
i	int
,	O
j	int
,	O
to_id	int
,	O
from_id	int
;	O
if	O
(	O
!	O
*	O
to_up	pointer
||	O
!	O
*	O
from_up	pointer
)	O
return	O
-	O
1	int
;	O
debug2	O
(	O
"UserAclCopy: from user '%s' to user '%s'\n"	pointer
,	O
(	O
*	O
from_up	pointer
)	O
->	O
u_name	array
,	O
(	O
*	O
to_up	pointer
)	O
->	O
u_name	array
)	O
;	O
if	O
(	O
(	O
to_id	int
=	O
(	O
*	O
to_up	pointer
)	O
->	O
u_id	int
)	O
==	O
(	O
from_id	int
=	O
(	O
*	O
from_up	pointer
)	O
->	O
u_id	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
w	pointer
=	O
windows	pointer
;	O
w	pointer
;	O
w	pointer
=	O
w	pointer
->	O
w_next	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ACL_BITS_PER_WIN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ACLBYTE	O
(	O
w	pointer
->	O
w_userbits	array
[	O
i	int
]	O
,	O
from_id	int
)	O
&	O
ACLBIT	O
(	O
from_id	int
)	O
)	O
ACLBYTE	O
(	O
w	pointer
->	O
w_userbits	array
[	O
i	int
]	O
,	O
to_id	int
)	O
|=	O
ACLBIT	O
(	O
to_id	int
)	O
;	O
else	O
{	O
ACLBYTE	O
(	O
w	pointer
->	O
w_userbits	array
[	O
i	int
]	O
,	O
to_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
to_id	int
)	O
;	O
if	O
(	O
(	O
w	pointer
->	O
w_wlockuser	pointer
==	O
*	O
to_up	pointer
)	O
&&	O
(	O
i	int
==	O
ACL_WRITE	int
)	O
)	O
{	O
debug2	O
(	O
"%s lost wlock on win %d\n"	pointer
,	O
(	O
*	O
to_up	pointer
)	O
->	O
u_name	array
,	O
w	pointer
->	O
w_number	int
)	O
;	O
w	pointer
->	O
w_wlockuser	pointer
=	O
NULL	O
;	O
if	O
(	O
w	pointer
->	O
w_wlock	int
==	O
WLOCK_ON	int
)	O
w	pointer
->	O
w_wlock	int
=	O
WLOCK_AUTO	int
;	O
}	O
}	O
}	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
RC_LAST	int
;	O
j	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ACL_BITS_PER_CMD	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ACLBYTE	O
(	O
comms	array
[	O
j	int
]	O
.	O
userbits	array
[	O
i	int
]	O
,	O
from_id	int
)	O
&	O
ACLBIT	O
(	O
from_id	int
)	O
)	O
ACLBYTE	O
(	O
comms	array
[	O
j	int
]	O
.	O
userbits	array
[	O
i	int
]	O
,	O
to_id	int
)	O
|=	O
ACLBIT	O
(	O
to_id	int
)	O
;	O
else	O
ACLBYTE	O
(	O
comms	array
[	O
j	int
]	O
.	O
userbits	array
[	O
i	int
]	O
,	O
to_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
to_id	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
UsersAcl	function
(	O
uu	pointer
,	O
argc	int
,	O
argv	pointer
)	O
struct	O
acluser	struct
*	O
uu	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
r	int
;	O
struct	O
acluser	struct
*	O
*	O
cf_u	pointer
=	O
NULL	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
s	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
while	O
(	O
*	O
s	pointer
)	O
if	O
(	O
*	O
s	pointer
++	O
==	O
'='	O
)	O
p	pointer
=	O
s	pointer
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
cf_u	pointer
=	O
FindUserPtr	function
(	O
p	pointer
)	O
;	O
}	O
}	O
if	O
(	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'*'	O
&&	O
argv	pointer
[	O
0	int
]	O
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
struct	O
acluser	struct
*	O
*	O
u	pointer
;	O
debug	O
(	O
"all users acls.\n"	pointer
)	O
;	O
for	O
(	O
u	pointer
=	O
&	O
users	pointer
;	O
*	O
u	pointer
;	O
u	pointer
=	O
&	O
(	O
*	O
u	pointer
)	O
->	O
u_next	pointer
)	O
if	O
(	O
strcmp	function
(	O
"nobody"	pointer
,	O
(	O
*	O
u	pointer
)	O
->	O
u_name	array
)	O
&&	O
(	O
(	O
cf_u	pointer
)	O
?	O
(	O
(	O
r	int
=	O
UserAclCopy	function
(	O
u	pointer
,	O
cf_u	pointer
)	O
)	O
<	O
0	int
)	O
:	O
(	O
(	O
r	int
=	O
UserAcl	function
(	O
uu	pointer
,	O
u	pointer
,	O
argc	int
,	O
argv	pointer
)	O
)	O
<	O
0	int
)	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
do	O
{	O
for	O
(	O
s	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
' '	O
&&	O
*	O
s	pointer
!=	O
'\t'	O
&&	O
*	O
s	pointer
!=	O
','	O
&&	O
*	O
s	pointer
!=	O
'='	O
;	O
s	pointer
++	O
)	O
;	O
*	O
s	pointer
?	O
(	O
*	O
s	pointer
++	O
=	O
'\0'	O
)	O
:	O
(	O
*	O
s	pointer
=	O
'\0'	O
)	O
;	O
debug2	O
(	O
"UsersAcl(uu, \"%s\", argc=%d)\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
)	O
;	O
if	O
(	O
(	O
cf_u	pointer
)	O
?	O
(	O
(	O
r	int
=	O
UserAclCopy	function
(	O
FindUserPtr	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
,	O
cf_u	pointer
)	O
)	O
<	O
0	int
)	O
:	O
(	O
(	O
r	int
=	O
UserAcl	function
(	O
uu	pointer
,	O
FindUserPtr	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
,	O
argc	int
,	O
argv	pointer
)	O
)	O
<	O
0	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
while	O
(	O
*	O
(	O
argv	pointer
[	O
0	int
]	O
=	O
s	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
AclUmask	function
(	O
u	pointer
,	O
str	pointer
,	O
errp	pointer
)	O
struct	O
acluser	struct
*	O
u	pointer
;	O
char	O
*	O
str	pointer
;	O
char	O
*	O
*	O
errp	pointer
;	O
{	O
char	O
mode	struct
[	O
16	int
]	O
;	O
char	O
*	O
av	array
[	O
3	int
]	O
;	O
char	O
*	O
p	pointer
,	O
c	int
=	O
'\0'	O
;	O
for	O
(	O
p	pointer
=	O
str	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
(	O
c	int
=	O
*	O
p	pointer
)	O
==	O
'+'	O
||	O
c	int
==	O
'-'	O
)	O
break	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
*	O
errp	pointer
=	O
"Bad argument. Should be ``[user[,user...]{+|-}rwxn''."	pointer
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
mode	struct
,	O
p	pointer
,	O
15	int
)	O
;	O
mode	struct
[	O
15	int
]	O
=	O
'\0'	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
"??"	pointer
,	O
str	pointer
)	O
)	O
{	O
str	pointer
++	O
;	O
av	array
[	O
2	int
]	O
=	O
"?"	pointer
;	O
}	O
else	O
av	array
[	O
2	int
]	O
=	O
"#"	pointer
;	O
av	array
[	O
1	int
]	O
=	O
mode	struct
;	O
av	array
[	O
0	int
]	O
=	O
*	O
str	pointer
?	O
str	pointer
:	O
"*"	pointer
;	O
if	O
(	O
UsersAcl	function
(	O
u	pointer
,	O
3	int
,	O
av	array
)	O
)	O
{	O
*	O
errp	pointer
=	O
"UsersAcl failed. Hmmm."	pointer
;	O
*	O
p	pointer
=	O
c	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
p	pointer
=	O
c	int
;	O
return	O
0	int
;	O
}	O
void	O
AclWinSwap	function
(	O
a	int
,	O
b	int
)	O
int	O
a	int
,	O
b	int
;	O
{	O
debug2	O
(	O
"AclWinSwap(%d, %d) NOP.\n"	pointer
,	O
a	int
,	O
b	int
)	O
;	O
}	O
struct	O
acluser	struct
*	O
EffectiveAclUser	pointer
=	O
NULL	O
;	O
int	O
AclCheckPermWin	function
(	O
u	pointer
,	O
mode	struct
,	O
w	pointer
)	O
struct	O
acluser	struct
*	O
u	pointer
;	O
int	O
mode	struct
;	O
struct	O
win	struct
*	O
w	pointer
;	O
{	O
int	O
ok	int
;	O
if	O
(	O
mode	struct
<	O
0	int
||	O
mode	struct
>=	O
ACL_BITS_PER_WIN	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
EffectiveAclUser	pointer
)	O
{	O
debug1	O
(	O
"AclCheckPermWin: WARNING user %s overridden!\n"	pointer
,	O
u	pointer
->	O
u_name	array
)	O
;	O
u	pointer
=	O
EffectiveAclUser	pointer
;	O
}	O
ok	int
=	O
ACLBYTE	O
(	O
w	pointer
->	O
w_userbits	array
[	O
mode	struct
]	O
,	O
u	pointer
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
debug3	O
(	O
"AclCheckPermWin(%s, %d, %d) = "	pointer
,	O
u	pointer
->	O
u_name	array
,	O
mode	struct
,	O
w	pointer
->	O
w_number	int
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
{	O
struct	O
aclusergroup	struct
*	O
*	O
g	pointer
=	O
&	O
u	pointer
->	O
u_group	pointer
;	O
struct	O
acluser	struct
*	O
saved_eff	pointer
=	O
EffectiveAclUser	pointer
;	O
EffectiveAclUser	pointer
=	O
NULL	O
;	O
while	O
(	O
*	O
g	pointer
)	O
{	O
if	O
(	O
!	O
AclCheckPermWin	function
(	O
(	O
*	O
g	pointer
)	O
->	O
u	pointer
,	O
mode	struct
,	O
w	pointer
)	O
)	O
break	O
;	O
g	pointer
=	O
&	O
(	O
*	O
g	pointer
)	O
->	O
next	pointer
;	O
}	O
EffectiveAclUser	pointer
=	O
saved_eff	pointer
;	O
if	O
(	O
*	O
g	pointer
)	O
ok	int
=	O
1	int
;	O
}	O
debug1	O
(	O
"%d\n"	pointer
,	O
!	O
ok	int
)	O
;	O
return	O
!	O
ok	int
;	O
}	O
int	O
AclCheckPermCmd	function
(	O
u	pointer
,	O
mode	struct
,	O
c	int
)	O
struct	O
acluser	struct
*	O
u	pointer
;	O
int	O
mode	struct
;	O
struct	O
comm	struct
*	O
c	int
;	O
{	O
int	O
ok	int
;	O
if	O
(	O
mode	struct
<	O
0	int
||	O
mode	struct
>=	O
ACL_BITS_PER_CMD	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
EffectiveAclUser	pointer
)	O
{	O
debug1	O
(	O
"AclCheckPermCmd: WARNING user %s overridden!\n"	pointer
,	O
u	pointer
->	O
u_name	array
)	O
;	O
u	pointer
=	O
EffectiveAclUser	pointer
;	O
}	O
ok	int
=	O
ACLBYTE	O
(	O
c	int
->	O
userbits	array
[	O
mode	struct
]	O
,	O
u	pointer
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
u	pointer
->	O
u_id	int
)	O
;	O
debug3	O
(	O
"AclCheckPermCmd(%s %d %s) = "	pointer
,	O
u	pointer
->	O
u_name	array
,	O
mode	struct
,	O
c	int
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
{	O
struct	O
aclusergroup	struct
*	O
*	O
g	pointer
=	O
&	O
u	pointer
->	O
u_group	pointer
;	O
struct	O
acluser	struct
*	O
saved_eff	pointer
=	O
EffectiveAclUser	pointer
;	O
EffectiveAclUser	pointer
=	O
NULL	O
;	O
while	O
(	O
*	O
g	pointer
)	O
{	O
if	O
(	O
!	O
AclCheckPermCmd	function
(	O
(	O
*	O
g	pointer
)	O
->	O
u	pointer
,	O
mode	struct
,	O
c	int
)	O
)	O
break	O
;	O
g	pointer
=	O
&	O
(	O
*	O
g	pointer
)	O
->	O
next	pointer
;	O
}	O
EffectiveAclUser	pointer
=	O
saved_eff	pointer
;	O
if	O
(	O
*	O
g	pointer
)	O
ok	int
=	O
1	int
;	O
}	O
debug1	O
(	O
"%d\n"	pointer
,	O
!	O
ok	int
)	O
;	O
return	O
!	O
ok	int
;	O
}	O
