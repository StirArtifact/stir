int	O
SLtt_Screen_Cols	int
=	O
80	int
;	O
int	O
SLtt_Screen_Rows	int
=	O
24	int
;	O
int	O
SLtt_Term_Cannot_Insert	int
;	O
int	O
SLtt_Term_Cannot_Scroll	int
;	O
int	O
SLtt_Use_Ansi_Colors	int
;	O
int	O
SLtt_Blink_Mode	int
=	O
0	int
;	O
int	O
SLtt_Use_Blink_For_ACS	int
=	O
0	int
;	O
int	O
SLtt_Newline_Ok	int
=	O
0	int
;	O
int	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
int	O
SLtt_Force_Keypad_Init	int
=	O
0	int
;	O
void	O
(	O
*	O
_pSLtt_color_changed_hook	pointer
)	O
(	O
void	O
)	O
;	O
static	O
int	O
Bce_Color_Offset	int
=	O
0	int
;	O
static	O
int	O
Can_Background_Color_Erase	int
=	O
1	int
;	O
int	O
SLtt_Has_Status_Line	int
=	O
-	O
1	int
;	O
int	O
SLang_TT_Write_FD	int
=	O
-	O
1	int
;	O
static	O
int	O
Automatic_Margins	int
;	O
static	O
int	O
Worthless_Highlight	int
;	O
static	O
int	O
Has_HP_Glitch	int
;	O
static	O
char	O
*	O
Reset_Color_String	pointer
;	O
static	O
int	O
Is_Color_Terminal	int
=	O
0	int
;	O
static	O
int	O
Linux_Console	int
;	O
static	O
int	O
QANSI_Console	int
;	O
static	O
int	O
Mouse_Mode	int
=	O
-	O
1	int
;	O
typedef	O
struct	O
{	O
SLtt_Char_Type	long
fgbg	long
;	O
SLtt_Char_Type	long
mono	long
;	O
}	O
Brush_Info_Type	struct
;	O
static	O
Brush_Info_Type	struct
Brush_Table	array
[	O
JMAX_COLORS	int
]	O
;	O
static	O
int	O
Is_Bg_BGR	int
=	O
0	int
;	O
static	O
SLCONST	O
int	O
RGB_to_BGR	array
[	O
]	O
=	O
{	O
0	int
,	O
4	int
,	O
2	int
,	O
6	int
,	O
1	int
,	O
5	int
,	O
3	int
,	O
7	int
}	O
;	O
static	O
char	O
*	O
Color_Fg_Str	pointer
=	O
"\033[3%dm"	pointer
;	O
static	O
char	O
*	O
Color_Bg_Str	pointer
=	O
"\033[4%dm"	pointer
;	O
static	O
char	O
*	O
Default_Color_Fg_Str	pointer
=	O
"\033[39m"	pointer
;	O
static	O
char	O
*	O
Default_Color_Bg_Str	pointer
=	O
"\033[49m"	pointer
;	O
static	O
int	O
Max_Terminfo_Colors	int
=	O
8	int
;	O
char	O
*	O
SLtt_Graphics_Char_Pairs	pointer
;	O
static	O
char	O
*	O
UnderLine_Vid_Str	pointer
;	O
static	O
char	O
*	O
Blink_Vid_Str	pointer
;	O
static	O
char	O
*	O
Bold_Vid_Str	pointer
;	O
static	O
char	O
*	O
Ins_Mode_Str	pointer
;	O
static	O
char	O
*	O
Eins_Mode_Str	pointer
;	O
static	O
char	O
*	O
Scroll_R_Str	pointer
;	O
static	O
char	O
*	O
Cls_Str	pointer
;	O
static	O
char	O
*	O
Rev_Vid_Str	pointer
;	O
static	O
char	O
*	O
Norm_Vid_Str	pointer
;	O
static	O
char	O
*	O
Del_Eol_Str	pointer
;	O
static	O
char	O
*	O
Del_Bol_Str	pointer
;	O
static	O
char	O
*	O
Del_Char_Str	pointer
;	O
static	O
char	O
*	O
Del_N_Lines_Str	pointer
;	O
static	O
char	O
*	O
Add_N_Lines_Str	pointer
;	O
static	O
char	O
*	O
Rev_Scroll_Str	pointer
;	O
static	O
char	O
*	O
Curs_Up_Str	pointer
;	O
static	O
char	O
*	O
Curs_F_Str	pointer
;	O
static	O
char	O
*	O
Cursor_Visible_Str	pointer
;	O
static	O
char	O
*	O
Cursor_Invisible_Str	pointer
;	O
static	O
char	O
*	O
Start_Alt_Chars_Str	pointer
;	O
static	O
char	O
*	O
End_Alt_Chars_Str	pointer
;	O
static	O
char	O
*	O
Enable_Alt_Char_Set	pointer
;	O
static	O
char	O
*	O
Term_Init_Str	pointer
;	O
static	O
char	O
*	O
Keypad_Init_Str	pointer
;	O
static	O
char	O
*	O
Term_Reset_Str	pointer
;	O
static	O
char	O
*	O
Keypad_Reset_Str	pointer
;	O
static	O
char	O
*	O
Disable_Status_line_Str	pointer
;	O
static	O
char	O
*	O
Return_From_Status_Line_Str	pointer
;	O
static	O
char	O
*	O
Goto_Status_Line_Str	pointer
;	O
static	O
int	O
Num_Status_Line_Columns	int
;	O
static	O
char	O
*	O
Curs_Pos_Str	pointer
;	O
static	O
int	O
Scroll_r1	int
=	O
0	int
,	O
Scroll_r2	int
=	O
23	int
;	O
static	O
int	O
Cursor_r	int
,	O
Cursor_c	int
;	O
static	O
SLtt_Char_Type	long
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
static	O
int	O
Cursor_Set	int
;	O
static	O
unsigned	O
char	O
Output_Buffer	array
[	O
MAX_OUTPUT_BUFFER_SIZE	int
]	O
;	O
static	O
unsigned	O
char	O
*	O
Output_Bufferp	pointer
=	O
Output_Buffer	array
;	O
unsigned	O
long	O
SLtt_Num_Chars_Output	long
;	O
int	O
_pSLusleep	function
(	O
unsigned	O
long	O
usecs	long
)	O
{	O
struct	O
timeval	struct
tv	pointer
;	O
tv	pointer
.	O
tv_sec	long
=	O
usecs	long
/	O
1000000	int
;	O
tv	pointer
.	O
tv_usec	long
=	O
usecs	long
%	O
1000000	int
;	O
return	O
select	function
(	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	pointer
)	O
;	O
}	O
int	O
SLtt_flush_output	function
(	O
void	O
)	O
{	O
int	O
nwrite	int
=	O
0	int
;	O
unsigned	O
int	O
total	int
;	O
int	O
n	int
=	O
(	O
int	O
)	O
(	O
Output_Bufferp	pointer
-	O
Output_Buffer	array
)	O
;	O
SLtt_Num_Chars_Output	long
+=	O
n	int
;	O
total	int
=	O
0	int
;	O
while	O
(	O
n	int
>	O
0	int
)	O
{	O
nwrite	int
=	O
write	pointer
(	O
SLang_TT_Write_FD	int
,	O
(	O
char	O
*	O
)	O
Output_Buffer	array
+	O
total	int
,	O
n	int
)	O
;	O
if	O
(	O
nwrite	int
==	O
-	O
1	int
)	O
{	O
nwrite	int
=	O
0	int
;	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
{	O
_pSLusleep	function
(	O
100000	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
_pSLusleep	function
(	O
100000	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
break	O
;	O
}	O
n	int
-=	O
nwrite	int
;	O
total	int
+=	O
nwrite	int
;	O
}	O
Output_Bufferp	pointer
=	O
Output_Buffer	array
;	O
return	O
n	int
;	O
}	O
int	O
SLtt_Baud_Rate	int
;	O
static	O
void	O
tt_write	function
(	O
char	O
*	O
str	pointer
,	O
unsigned	O
int	O
n	int
)	O
{	O
static	O
unsigned	O
long	O
last_time	long
;	O
static	O
int	O
total	int
;	O
unsigned	O
long	O
now	long
;	O
unsigned	O
int	O
ndiff	int
;	O
if	O
(	O
(	O
str	pointer
==	O
NULL	O
)	O
||	O
(	O
n	int
==	O
0	int
)	O
)	O
return	O
;	O
total	int
+=	O
n	int
;	O
while	O
(	O
1	int
)	O
{	O
ndiff	int
=	O
MAX_OUTPUT_BUFFER_SIZE	int
-	O
(	O
int	O
)	O
(	O
Output_Bufferp	pointer
-	O
Output_Buffer	array
)	O
;	O
if	O
(	O
ndiff	int
<	O
n	int
)	O
{	O
SLMEMCPY	O
(	O
(	O
char	O
*	O
)	O
Output_Bufferp	pointer
,	O
str	pointer
,	O
ndiff	int
)	O
;	O
Output_Bufferp	pointer
+=	O
ndiff	int
;	O
SLtt_flush_output	function
(	O
)	O
;	O
n	int
-=	O
ndiff	int
;	O
str	pointer
+=	O
ndiff	int
;	O
}	O
else	O
{	O
SLMEMCPY	O
(	O
(	O
char	O
*	O
)	O
Output_Bufferp	pointer
,	O
str	pointer
,	O
n	int
)	O
;	O
Output_Bufferp	pointer
+=	O
n	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
(	O
SLtt_Baud_Rate	int
>	O
150	int
)	O
&&	O
(	O
SLtt_Baud_Rate	int
<=	O
9600	int
)	O
)	O
&&	O
(	O
10	int
*	O
total	int
>	O
SLtt_Baud_Rate	int
)	O
)	O
{	O
total	int
=	O
0	int
;	O
if	O
(	O
(	O
now	long
=	O
(	O
unsigned	O
long	O
)	O
time	struct
(	O
NULL	O
)	O
)	O
-	O
last_time	long
<=	O
1	int
)	O
{	O
SLtt_flush_output	function
(	O
)	O
;	O
sleep	function
(	O
(	O
unsigned	O
)	O
1	int
)	O
;	O
}	O
last_time	long
=	O
now	long
;	O
}	O
}	O
static	O
void	O
tt_write_string	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
str	pointer
!=	O
NULL	O
)	O
tt_write	function
(	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
}	O
void	O
SLtt_write_string	function
(	O
char	O
*	O
str	pointer
)	O
{	O
tt_write_string	function
(	O
str	pointer
)	O
;	O
Cursor_Set	int
=	O
0	int
;	O
}	O
void	O
SLtt_putchar	function
(	O
char	O
ch	int
)	O
{	O
SLtt_normal_video	function
(	O
)	O
;	O
if	O
(	O
Cursor_Set	int
==	O
1	int
)	O
{	O
if	O
(	O
ch	int
>=	O
' '	O
)	O
Cursor_c	int
++	O
;	O
else	O
if	O
(	O
ch	int
==	O
'\b'	O
)	O
Cursor_c	int
--	O
;	O
else	O
if	O
(	O
ch	int
==	O
'\r'	O
)	O
Cursor_c	int
=	O
0	int
;	O
else	O
Cursor_Set	int
=	O
0	int
;	O
if	O
(	O
(	O
Cursor_c	int
+	O
1	int
==	O
SLtt_Screen_Cols	int
)	O
&&	O
Automatic_Margins	int
)	O
Cursor_Set	int
=	O
0	int
;	O
}	O
if	O
(	O
Output_Bufferp	pointer
<	O
Output_Buffer	array
+	O
MAX_OUTPUT_BUFFER_SIZE	int
)	O
{	O
*	O
Output_Bufferp	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
ch	int
;	O
}	O
else	O
tt_write	function
(	O
&	O
ch	int
,	O
1	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
tt_sprintf	function
(	O
char	O
*	O
buf	pointer
,	O
unsigned	O
int	O
buflen	int
,	O
char	O
*	O
fmt	pointer
,	O
int	O
x	double
,	O
int	O
y	double
)	O
{	O
char	O
*	O
fmt_max	pointer
;	O
unsigned	O
char	O
*	O
b	pointer
,	O
*	O
bmax	pointer
,	O
ch	int
;	O
int	O
offset	long
;	O
int	O
z	int
,	O
z1	int
,	O
parse_level	int
;	O
int	O
zero_pad	int
;	O
int	O
field_width	int
;	O
int	O
variables	array
[	O
26	int
]	O
;	O
int	O
stack	array
[	O
64	int
]	O
;	O
unsigned	O
int	O
stack_len	int
;	O
int	O
parms	array
[	O
10	int
]	O
;	O
if	O
(	O
fmt	pointer
==	O
NULL	O
)	O
{	O
*	O
buf	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
stack	array
[	O
0	int
]	O
=	O
y	double
;	O
stack	array
[	O
1	int
]	O
=	O
x	double
;	O
stack_len	int
=	O
2	int
;	O
parms	array
[	O
1	int
]	O
=	O
x	double
;	O
parms	array
[	O
2	int
]	O
=	O
y	double
;	O
offset	long
=	O
0	int
;	O
zero_pad	int
=	O
0	int
;	O
field_width	int
=	O
0	int
;	O
b	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
;	O
bmax	pointer
=	O
b	pointer
+	O
buflen	int
;	O
fmt_max	pointer
=	O
fmt	pointer
+	O
strlen	function
(	O
fmt	pointer
)	O
;	O
while	O
(	O
(	O
fmt	pointer
<	O
fmt_max	pointer
)	O
&&	O
(	O
b	pointer
<	O
bmax	pointer
)	O
)	O
{	O
ch	int
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
ch	int
!=	O
'%'	O
)	O
{	O
*	O
b	pointer
++	O
=	O
ch	int
;	O
continue	O
;	O
}	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	pointer
++	O
;	O
switch	O
(	O
ch	int
)	O
{	O
default	O
:	O
*	O
b	pointer
++	O
=	O
ch	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
'0'	O
)	O
&&	O
(	O
ch	int
<=	O
'9'	O
)	O
)	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
parms	array
[	O
ch	int
-	O
'0'	O
]	O
;	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
fmt	pointer
<	O
fmt_max	pointer
)	O
fmt	pointer
++	O
;	O
break	O
;	O
case	O
'{'	O
:	O
z	int
=	O
0	int
;	O
while	O
(	O
(	O
fmt	pointer
<	O
fmt_max	pointer
)	O
&&	O
(	O
(	O
ch	int
=	O
*	O
fmt	pointer
)	O
<=	O
'9'	O
)	O
&&	O
(	O
ch	int
>=	O
'0'	O
)	O
)	O
{	O
z	int
=	O
z	int
*	O
10	int
+	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
fmt	pointer
++	O
;	O
}	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
z	int
;	O
if	O
(	O
(	O
ch	int
==	O
'}'	O
)	O
&&	O
(	O
fmt	pointer
<	O
fmt_max	pointer
)	O
)	O
fmt	pointer
++	O
;	O
break	O
;	O
case	O
'0'	O
:	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	pointer
;	O
if	O
(	O
(	O
ch	int
!=	O
'2'	O
)	O
&&	O
(	O
ch	int
!=	O
'3'	O
)	O
)	O
break	O
;	O
zero_pad	int
=	O
1	int
;	O
fmt	pointer
++	O
;	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
if	O
(	O
*	O
fmt	pointer
==	O
'x'	O
)	O
{	O
char	O
x_fmt_buf	array
[	O
4	int
]	O
;	O
char	O
*	O
x_fmt_buf_ptr	pointer
;	O
x_fmt_buf_ptr	pointer
=	O
x_fmt_buf	array
;	O
if	O
(	O
zero_pad	int
)	O
*	O
x_fmt_buf_ptr	pointer
++	O
=	O
'0'	O
;	O
*	O
x_fmt_buf_ptr	pointer
++	O
=	O
ch	int
;	O
*	O
x_fmt_buf_ptr	pointer
++	O
=	O
'X'	O
;	O
*	O
x_fmt_buf_ptr	pointer
=	O
0	int
;	O
z	int
=	O
STACK_POP	O
;	O
z	int
+=	O
offset	long
;	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
b	pointer
,	O
x_fmt_buf	array
,	O
z	int
)	O
;	O
b	pointer
+=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
b	pointer
)	O
;	O
zero_pad	int
=	O
0	int
;	O
break	O
;	O
}	O
field_width	int
=	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
case	O
'd'	O
:	O
z	int
=	O
STACK_POP	O
;	O
z	int
+=	O
offset	long
;	O
if	O
(	O
z	int
>=	O
100	int
)	O
{	O
*	O
b	pointer
++	O
=	O
z	int
/	O
100	int
+	O
'0'	O
;	O
z	int
=	O
z	int
%	O
100	int
;	O
zero_pad	int
=	O
1	int
;	O
field_width	int
=	O
2	int
;	O
}	O
else	O
if	O
(	O
zero_pad	int
&&	O
(	O
field_width	int
==	O
3	int
)	O
)	O
*	O
b	pointer
++	O
=	O
'0'	O
;	O
if	O
(	O
b	pointer
==	O
bmax	pointer
)	O
break	O
;	O
if	O
(	O
z	int
>=	O
10	int
)	O
{	O
*	O
b	pointer
++	O
=	O
z	int
/	O
10	int
+	O
'0'	O
;	O
z	int
=	O
z	int
%	O
10	int
;	O
}	O
else	O
if	O
(	O
zero_pad	int
&&	O
(	O
field_width	int
>=	O
2	int
)	O
)	O
*	O
b	pointer
++	O
=	O
'0'	O
;	O
if	O
(	O
b	pointer
==	O
bmax	pointer
)	O
break	O
;	O
*	O
b	pointer
++	O
=	O
z	int
+	O
'0'	O
;	O
field_width	int
=	O
zero_pad	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
z	int
=	O
STACK_POP	O
;	O
z	int
+=	O
offset	long
;	O
if	O
(	O
b	pointer
+	O
16	int
>=	O
bmax	pointer
)	O
break	O
;	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
b	pointer
,	O
"%X"	pointer
,	O
z	int
)	O
;	O
b	pointer
+=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
b	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
offset	long
=	O
1	int
;	O
break	O
;	O
case	O
'+'	O
:	O
if	O
(	O
stack_len	int
>	O
2	int
)	O
{	O
z	int
=	O
STACK_POP	O
;	O
stack	array
[	O
stack_len	int
-	O
1	int
]	O
+=	O
z	int
;	O
}	O
else	O
if	O
(	O
fmt	pointer
<	O
fmt_max	pointer
)	O
{	O
ch	int
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
ch	int
==	O
128	int
)	O
ch	int
=	O
0	int
;	O
ch	int
=	O
ch	int
+	O
(	O
unsigned	O
char	O
)	O
STACK_POP	O
;	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
ch	int
++	O
;	O
*	O
b	pointer
++	O
=	O
ch	int
;	O
}	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'*'	O
:	O
case	O
'/'	O
:	O
case	O
'm'	O
:	O
case	O
'&'	O
:	O
case	O
'|'	O
:	O
case	O
'^'	O
:	O
case	O
'='	O
:	O
case	O
'>'	O
:	O
case	O
'<'	O
:	O
case	O
'A'	O
:	O
case	O
'O'	O
:	O
z1	int
=	O
STACK_POP	O
;	O
z	int
=	O
STACK_POP	O
;	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'-'	O
:	O
z	int
=	O
(	O
z	int
-	O
z1	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
z	int
=	O
(	O
z	int
*	O
z1	int
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
z	int
=	O
(	O
z	int
/	O
z1	int
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
z	int
=	O
(	O
z	int
%	O
z1	int
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
z	int
=	O
(	O
z	int
&	O
z1	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
z	int
=	O
(	O
z	int
|	O
z1	int
)	O
;	O
break	O
;	O
case	O
'^'	O
:	O
z	int
=	O
(	O
z	int
^	O
z1	int
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
z	int
=	O
(	O
z	int
==	O
z1	int
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
z	int
=	O
(	O
z	int
>	O
z1	int
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
z	int
=	O
(	O
z	int
<	O
z1	int
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
z	int
=	O
(	O
z	int
&&	O
z1	int
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
z	int
=	O
(	O
z	int
||	O
z1	int
)	O
;	O
break	O
;	O
}	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
z	int
;	O
break	O
;	O
case	O
'!'	O
:	O
z	int
=	O
STACK_POP	O
;	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
!	O
z	int
;	O
break	O
;	O
case	O
'~'	O
:	O
z	int
=	O
STACK_POP	O
;	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
~	O
z	int
;	O
break	O
;	O
case	O
'r'	O
:	O
z	int
=	O
stack	array
[	O
0	int
]	O
;	O
stack	array
[	O
0	int
]	O
=	O
stack	array
[	O
1	int
]	O
;	O
stack	array
[	O
1	int
]	O
=	O
z	int
;	O
break	O
;	O
case	O
'.'	O
:	O
case	O
'c'	O
:	O
ch	int
=	O
(	O
unsigned	O
char	O
)	O
STACK_POP	O
;	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
ch	int
++	O
;	O
*	O
b	pointer
++	O
=	O
ch	int
;	O
break	O
;	O
case	O
'g'	O
:	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
'a'	O
)	O
&&	O
(	O
ch	int
<=	O
'z'	O
)	O
)	O
stack	array
[	O
stack_len	int
++	O
]	O
=	O
variables	array
[	O
ch	int
-	O
'a'	O
]	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
'a'	O
)	O
&&	O
(	O
ch	int
<=	O
'z'	O
)	O
)	O
variables	array
[	O
ch	int
-	O
'a'	O
]	O
=	O
STACK_POP	O
;	O
break	O
;	O
case	O
'?'	O
:	O
case	O
';'	O
:	O
break	O
;	O
case	O
't'	O
:	O
z	int
=	O
STACK_POP	O
;	O
if	O
(	O
z	int
!=	O
0	int
)	O
break	O
;	O
case	O
'e'	O
:	O
parse_level	int
=	O
0	int
;	O
while	O
(	O
fmt	pointer
<	O
fmt_max	pointer
)	O
{	O
unsigned	O
char	O
ch1	char
;	O
ch1	char
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
(	O
ch1	char
!=	O
'%'	O
)	O
||	O
(	O
fmt	pointer
==	O
fmt_max	pointer
)	O
)	O
continue	O
;	O
ch1	char
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
ch1	char
==	O
'?'	O
)	O
parse_level	int
++	O
;	O
else	O
if	O
(	O
ch1	char
==	O
'e'	O
)	O
{	O
if	O
(	O
(	O
ch	int
!=	O
'e'	O
)	O
&&	O
(	O
parse_level	int
==	O
0	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
ch1	char
==	O
';'	O
)	O
{	O
if	O
(	O
parse_level	int
==	O
0	int
)	O
break	O
;	O
parse_level	int
--	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
b	pointer
>=	O
bmax	pointer
)	O
b	pointer
=	O
bmax	pointer
-	O
1	int
;	O
*	O
b	pointer
=	O
0	int
;	O
return	O
(	O
unsigned	O
int	O
)	O
(	O
b	pointer
-	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
tt_printf	function
(	O
char	O
*	O
fmt	pointer
,	O
int	O
x	double
,	O
int	O
y	double
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
unsigned	O
int	O
n	int
;	O
if	O
(	O
fmt	pointer
==	O
NULL	O
)	O
return	O
;	O
n	int
=	O
tt_sprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fmt	pointer
,	O
x	double
,	O
y	double
)	O
;	O
tt_write	function
(	O
buf	pointer
,	O
n	int
)	O
;	O
}	O
void	O
SLtt_set_scroll_region	function
(	O
int	O
r1	int
,	O
int	O
r2	int
)	O
{	O
Scroll_r1	int
=	O
r1	int
;	O
Scroll_r2	int
=	O
r2	int
;	O
tt_printf	function
(	O
Scroll_R_Str	pointer
,	O
Scroll_r1	int
,	O
Scroll_r2	int
)	O
;	O
Cursor_Set	int
=	O
0	int
;	O
}	O
void	O
SLtt_reset_scroll_region	function
(	O
void	O
)	O
{	O
SLtt_set_scroll_region	function
(	O
0	int
,	O
SLtt_Screen_Rows	int
-	O
1	int
)	O
;	O
}	O
int	O
SLtt_set_cursor_visibility	function
(	O
int	O
show	int
)	O
{	O
if	O
(	O
(	O
Cursor_Visible_Str	pointer
==	O
NULL	O
)	O
||	O
(	O
Cursor_Invisible_Str	pointer
==	O
NULL	O
)	O
)	O
return	O
-	O
1	int
;	O
tt_write_string	function
(	O
show	int
?	O
Cursor_Visible_Str	pointer
:	O
Cursor_Invisible_Str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_goto_rc	function
(	O
int	O
r	pointer
,	O
int	O
c	int
)	O
{	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
int	O
n	int
;	O
char	O
buf	pointer
[	O
6	int
]	O
;	O
if	O
(	O
(	O
c	int
<	O
0	int
)	O
||	O
(	O
r	pointer
<	O
0	int
)	O
)	O
{	O
Cursor_Set	int
=	O
0	int
;	O
return	O
;	O
}	O
r	pointer
+=	O
Scroll_r1	int
;	O
if	O
(	O
(	O
Cursor_Set	int
>	O
0	int
)	O
||	O
(	O
(	O
Cursor_Set	int
<	O
0	int
)	O
&&	O
!	O
Automatic_Margins	int
)	O
)	O
{	O
n	int
=	O
r	pointer
-	O
Cursor_r	int
;	O
if	O
(	O
(	O
n	int
==	O
-	O
1	int
)	O
&&	O
(	O
Cursor_Set	int
>	O
0	int
)	O
&&	O
(	O
Cursor_c	int
==	O
c	int
)	O
&&	O
(	O
Curs_Up_Str	pointer
!=	O
NULL	O
)	O
)	O
{	O
s	pointer
=	O
Curs_Up_Str	pointer
;	O
}	O
else	O
if	O
(	O
(	O
n	int
>=	O
0	int
)	O
&&	O
(	O
n	int
<=	O
4	int
)	O
)	O
{	O
if	O
(	O
(	O
n	int
==	O
0	int
)	O
&&	O
(	O
Cursor_Set	int
==	O
1	int
)	O
&&	O
(	O
(	O
c	int
>	O
1	int
)	O
||	O
(	O
c	int
==	O
Cursor_c	int
)	O
)	O
)	O
{	O
if	O
(	O
Cursor_c	int
==	O
c	int
)	O
return	O
;	O
if	O
(	O
Cursor_c	int
==	O
c	int
+	O
1	int
)	O
{	O
if	O
(	O
!	O
QANSI_Console	int
)	O
{	O
s	pointer
=	O
buf	pointer
;	O
*	O
s	pointer
++	O
=	O
'\b'	O
;	O
*	O
s	pointer
=	O
0	int
;	O
s	pointer
=	O
buf	pointer
;	O
}	O
else	O
{	O
s	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
0	int
)	O
&&	O
(	O
!	O
QANSI_Console	int
)	O
)	O
{	O
s	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
Cursor_Set	int
!=	O
1	int
)	O
||	O
(	O
Cursor_c	int
!=	O
0	int
)	O
)	O
*	O
s	pointer
++	O
=	O
'\r'	O
;	O
while	O
(	O
n	int
--	O
)	O
*	O
s	pointer
++	O
=	O
'\n'	O
;	O
*	O
s	pointer
=	O
0	int
;	O
s	pointer
=	O
buf	pointer
;	O
}	O
else	O
if	O
(	O
(	O
SLtt_Newline_Ok	int
&&	O
(	O
Cursor_Set	int
==	O
1	int
)	O
&&	O
(	O
Cursor_c	int
>=	O
c	int
)	O
&&	O
(	O
c	int
+	O
3	int
>	O
Cursor_c	int
)	O
)	O
&&	O
(	O
!	O
QANSI_Console	int
)	O
)	O
{	O
s	pointer
=	O
buf	pointer
;	O
while	O
(	O
n	int
--	O
)	O
*	O
s	pointer
++	O
=	O
'\n'	O
;	O
n	int
=	O
Cursor_c	int
-	O
c	int
;	O
while	O
(	O
n	int
--	O
)	O
*	O
s	pointer
++	O
=	O
'\b'	O
;	O
*	O
s	pointer
=	O
0	int
;	O
s	pointer
=	O
buf	pointer
;	O
}	O
}	O
}	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
tt_write_string	function
(	O
s	pointer
)	O
;	O
else	O
tt_printf	function
(	O
Curs_Pos_Str	pointer
,	O
r	pointer
,	O
c	int
)	O
;	O
Cursor_c	int
=	O
c	int
;	O
Cursor_r	int
=	O
r	pointer
;	O
Cursor_Set	int
=	O
1	int
;	O
}	O
void	O
SLtt_begin_insert	function
(	O
void	O
)	O
{	O
tt_write_string	function
(	O
Ins_Mode_Str	pointer
)	O
;	O
}	O
void	O
SLtt_end_insert	function
(	O
void	O
)	O
{	O
tt_write_string	function
(	O
Eins_Mode_Str	pointer
)	O
;	O
}	O
void	O
SLtt_delete_char	function
(	O
void	O
)	O
{	O
SLtt_normal_video	function
(	O
)	O
;	O
tt_write_string	function
(	O
Del_Char_Str	pointer
)	O
;	O
}	O
void	O
SLtt_erase_line	function
(	O
void	O
)	O
{	O
tt_write	function
(	O
"\r"	pointer
,	O
1	int
)	O
;	O
Cursor_Set	int
=	O
1	int
;	O
Cursor_c	int
=	O
0	int
;	O
SLtt_del_eol	function
(	O
)	O
;	O
tt_write	function
(	O
"\r"	pointer
,	O
1	int
)	O
;	O
Cursor_Set	int
=	O
1	int
;	O
Cursor_c	int
=	O
0	int
;	O
}	O
static	O
void	O
delete_line_in_scroll_region	function
(	O
void	O
)	O
{	O
SLtt_goto_rc	function
(	O
Cursor_r	int
-	O
Scroll_r1	int
,	O
0	int
)	O
;	O
SLtt_del_eol	function
(	O
)	O
;	O
}	O
void	O
SLtt_delete_nlines	function
(	O
int	O
nn	int
)	O
{	O
int	O
r1	int
,	O
curs	int
;	O
unsigned	O
int	O
n	int
;	O
if	O
(	O
nn	int
<=	O
0	int
)	O
return	O
;	O
n	int
=	O
(	O
unsigned	O
int	O
)	O
nn	int
;	O
SLtt_normal_video	function
(	O
)	O
;	O
if	O
(	O
Scroll_r1	int
==	O
Scroll_r2	int
)	O
{	O
delete_line_in_scroll_region	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
Del_N_Lines_Str	pointer
!=	O
NULL	O
)	O
tt_printf	function
(	O
Del_N_Lines_Str	pointer
,	O
n	int
,	O
0	int
)	O
;	O
else	O
{	O
char	O
buf	pointer
[	O
80	int
]	O
;	O
unsigned	O
int	O
dn	int
=	O
n	int
;	O
if	O
(	O
dn	int
>	O
sizeof	O
(	O
buf	pointer
)	O
)	O
dn	int
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
SLMEMSET	O
(	O
buf	pointer
,	O
'\n'	O
,	O
dn	int
)	O
;	O
while	O
(	O
n	int
>	O
dn	int
)	O
{	O
tt_write	function
(	O
buf	pointer
,	O
dn	int
)	O
;	O
n	int
-=	O
dn	int
;	O
}	O
tt_write	function
(	O
buf	pointer
,	O
n	int
)	O
;	O
r1	int
=	O
Scroll_r1	int
;	O
curs	int
=	O
Cursor_r	int
;	O
SLtt_set_scroll_region	function
(	O
curs	int
,	O
Scroll_r2	int
)	O
;	O
SLtt_goto_rc	function
(	O
Scroll_r2	int
-	O
Scroll_r1	int
,	O
0	int
)	O
;	O
SLMEMSET	O
(	O
buf	pointer
,	O
'\n'	O
,	O
(	O
unsigned	O
int	O
)	O
n	int
)	O
;	O
tt_write	function
(	O
buf	pointer
,	O
(	O
unsigned	O
int	O
)	O
n	int
)	O
;	O
SLtt_set_scroll_region	function
(	O
r1	int
,	O
Scroll_r2	int
)	O
;	O
SLtt_goto_rc	function
(	O
curs	int
,	O
0	int
)	O
;	O
}	O
}	O
void	O
SLtt_cls	function
(	O
void	O
)	O
{	O
if	O
(	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
&&	O
Is_Color_Terminal	int
)	O
{	O
if	O
(	O
Reset_Color_String	pointer
!=	O
NULL	O
)	O
tt_write_string	function
(	O
Reset_Color_String	pointer
)	O
;	O
else	O
tt_write	function
(	O
"\033[0m\033[m"	pointer
,	O
7	int
)	O
;	O
}	O
SLtt_normal_video	function
(	O
)	O
;	O
SLtt_reset_scroll_region	function
(	O
)	O
;	O
tt_write_string	function
(	O
Cls_Str	pointer
)	O
;	O
}	O
void	O
SLtt_reverse_index	function
(	O
int	O
n	int
)	O
{	O
if	O
(	O
!	O
n	int
)	O
return	O
;	O
SLtt_normal_video	function
(	O
)	O
;	O
if	O
(	O
Scroll_r1	int
==	O
Scroll_r2	int
)	O
{	O
delete_line_in_scroll_region	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
Add_N_Lines_Str	pointer
!=	O
NULL	O
)	O
tt_printf	function
(	O
Add_N_Lines_Str	pointer
,	O
n	int
,	O
0	int
)	O
;	O
else	O
{	O
while	O
(	O
n	int
--	O
)	O
tt_write_string	function
(	O
Rev_Scroll_Str	pointer
)	O
;	O
}	O
}	O
int	O
SLtt_Ignore_Beep	int
=	O
1	int
;	O
static	O
char	O
*	O
Visible_Bell_Str	pointer
;	O
void	O
SLtt_beep	function
(	O
void	O
)	O
{	O
if	O
(	O
SLtt_Ignore_Beep	int
&	O
0x1	int
)	O
SLtt_putchar	function
(	O
'\007'	O
)	O
;	O
if	O
(	O
SLtt_Ignore_Beep	int
&	O
0x2	int
)	O
{	O
if	O
(	O
Visible_Bell_Str	pointer
!=	O
NULL	O
)	O
tt_write_string	function
(	O
Visible_Bell_Str	pointer
)	O
;	O
else	O
if	O
(	O
Linux_Console	int
)	O
{	O
tt_write	function
(	O
"\033[?5h"	pointer
,	O
5	int
)	O
;	O
SLtt_flush_output	function
(	O
)	O
;	O
_pSLusleep	function
(	O
50000	int
)	O
;	O
tt_write	function
(	O
"\033[?5l"	pointer
,	O
5	int
)	O
;	O
}	O
}	O
SLtt_flush_output	function
(	O
)	O
;	O
}	O
static	O
void	O
write_string_with_care	function
(	O
char	O
*	O
)	O
;	O
static	O
void	O
del_eol	function
(	O
void	O
)	O
{	O
if	O
(	O
(	O
Del_Eol_Str	pointer
!=	O
NULL	O
)	O
&&	O
(	O
Can_Background_Color_Erase	int
||	O
(	O
(	O
Current_Fgbg	long
&	O
~	O
0xFF	int
)	O
==	O
0	int
)	O
)	O
)	O
{	O
tt_write_string	function
(	O
Del_Eol_Str	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
Cursor_c	int
<	O
SLtt_Screen_Cols	int
)	O
{	O
write_string_with_care	function
(	O
" "	pointer
)	O
;	O
Cursor_c	int
++	O
;	O
}	O
Cursor_c	int
=	O
SLtt_Screen_Cols	int
-	O
1	int
;	O
Cursor_Set	int
=	O
0	int
;	O
}	O
void	O
SLtt_del_eol	function
(	O
void	O
)	O
{	O
if	O
(	O
Current_Fgbg	long
!=	O
0xFFFFFFFFU	int
)	O
SLtt_normal_video	function
(	O
)	O
;	O
del_eol	function
(	O
)	O
;	O
}	O
typedef	O
SLCONST	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
SLtt_Char_Type	long
color	short
;	O
}	O
Color_Def_Type	struct
;	O
static	O
Color_Def_Type	struct
Color_Defs	array
[	O
MAX_COLOR_NAMES	int
]	O
=	O
{	O
{	O
"black"	pointer
,	O
SLSMG_COLOR_BLACK	int
}	O
,	O
{	O
"red"	pointer
,	O
SLSMG_COLOR_RED	int
}	O
,	O
{	O
"green"	pointer
,	O
SLSMG_COLOR_GREEN	int
}	O
,	O
{	O
"brown"	pointer
,	O
SLSMG_COLOR_BROWN	int
}	O
,	O
{	O
"blue"	pointer
,	O
SLSMG_COLOR_BLUE	int
}	O
,	O
{	O
"magenta"	pointer
,	O
SLSMG_COLOR_MAGENTA	int
}	O
,	O
{	O
"cyan"	pointer
,	O
SLSMG_COLOR_CYAN	int
}	O
,	O
{	O
"lightgray"	pointer
,	O
SLSMG_COLOR_LGRAY	int
}	O
,	O
{	O
"gray"	pointer
,	O
SLSMG_COLOR_GRAY	int
}	O
,	O
{	O
"brightred"	pointer
,	O
SLSMG_COLOR_BRIGHT_RED	int
}	O
,	O
{	O
"brightgreen"	pointer
,	O
SLSMG_COLOR_BRIGHT_GREEN	int
}	O
,	O
{	O
"yellow"	pointer
,	O
SLSMG_COLOR_BRIGHT_BROWN	int
}	O
,	O
{	O
"brightblue"	pointer
,	O
SLSMG_COLOR_BRIGHT_BLUE	int
}	O
,	O
{	O
"brightmagenta"	pointer
,	O
SLSMG_COLOR_BRIGHT_CYAN	int
}	O
,	O
{	O
"brightcyan"	pointer
,	O
SLSMG_COLOR_BRIGHT_MAGENTA	int
}	O
,	O
{	O
"white"	pointer
,	O
SLSMG_COLOR_BRIGHT_WHITE	int
}	O
,	O
{	O
"default"	pointer
,	O
SLSMG_COLOR_DEFAULT	int
}	O
}	O
;	O
static	O
int	O
Brushes_Initialized	int
=	O
0	int
;	O
static	O
int	O
initialize_brushes	function
(	O
void	O
)	O
{	O
int	O
fg	int
,	O
bg	int
;	O
Brush_Info_Type	struct
*	O
b	pointer
,	O
*	O
bmax	pointer
;	O
b	pointer
=	O
Brush_Table	array
;	O
bmax	pointer
=	O
b	pointer
+	O
JMAX_COLORS	int
;	O
bg	int
=	O
0	int
;	O
while	O
(	O
b	pointer
<	O
bmax	pointer
)	O
{	O
fg	int
=	O
7	int
;	O
while	O
(	O
b	pointer
<	O
bmax	pointer
)	O
{	O
if	O
(	O
fg	int
!=	O
bg	int
)	O
{	O
b	pointer
->	O
fgbg	long
=	O
MAKE_COLOR	O
(	O
fg	int
,	O
bg	int
)	O
;	O
b	pointer
->	O
mono	long
=	O
SLTT_REV_MASK	int
;	O
b	pointer
++	O
;	O
}	O
if	O
(	O
fg	int
==	O
0	int
)	O
break	O
;	O
fg	int
--	O
;	O
}	O
bg	int
++	O
;	O
if	O
(	O
bg	int
==	O
8	int
)	O
bg	int
=	O
0	int
;	O
}	O
Brush_Table	array
[	O
0	int
]	O
.	O
mono	long
=	O
0	int
;	O
Brushes_Initialized	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
Brush_Info_Type	struct
*	O
get_brush_info	function
(	O
unsigned	O
int	O
color	short
)	O
{	O
if	O
(	O
Brushes_Initialized	int
==	O
0	int
)	O
initialize_brushes	function
(	O
)	O
;	O
color	short
&=	O
SLSMG_COLOR_MASK	int
;	O
if	O
(	O
color	short
>=	O
JMAX_COLORS	int
)	O
color	short
=	O
0	int
;	O
return	O
Brush_Table	array
+	O
color	short
;	O
}	O
static	O
SLtt_Char_Type	long
get_brush_attr	function
(	O
unsigned	O
int	O
color	short
)	O
{	O
Brush_Info_Type	struct
*	O
b	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
b	pointer
=	O
get_brush_info	function
(	O
color	short
)	O
)	O
)	O
return	O
(	O
SLtt_Char_Type	long
)	O
-	O
1	int
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
return	O
b	pointer
->	O
fgbg	long
;	O
return	O
b	pointer
->	O
mono	long
;	O
}	O
static	O
SLtt_Char_Type	long
get_brush_fgbg	function
(	O
unsigned	O
int	O
color	short
)	O
{	O
return	O
get_brush_info	function
(	O
color	short
)	O
->	O
fgbg	long
;	O
}	O
int	O
SLtt_set_mono	function
(	O
int	O
obj	struct
,	O
char	O
*	O
what	pointer
,	O
SLtt_Char_Type	long
mask	long
)	O
{	O
Brush_Info_Type	struct
*	O
b	pointer
;	O
(	O
void	O
)	O
what	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
b	pointer
=	O
get_brush_info	function
(	O
obj	struct
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	pointer
->	O
mono	long
=	O
mask	long
&	O
ATTR_MASK	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
check_color_for_digit_form	function
(	O
char	O
*	O
color	short
)	O
{	O
unsigned	O
int	O
i	array
,	O
ich	int
;	O
unsigned	O
char	O
*	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
color	short
;	O
i	array
=	O
0	int
;	O
while	O
(	O
(	O
ich	int
=	O
(	O
unsigned	O
int	O
)	O
*	O
s	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ich	int
<	O
'0'	O
)	O
||	O
(	O
ich	int
>	O
'9'	O
)	O
)	O
return	O
color	short
;	O
i	array
=	O
i	array
*	O
10	int
+	O
(	O
ich	int
-	O
'0'	O
)	O
;	O
s	pointer
++	O
;	O
}	O
if	O
(	O
i	array
<	O
MAX_COLOR_NAMES	int
)	O
color	short
=	O
Color_Defs	array
[	O
i	array
]	O
.	O
name	pointer
;	O
return	O
color	short
;	O
}	O
static	O
int	O
get_default_colors	function
(	O
char	O
*	O
*	O
fgp	pointer
,	O
char	O
*	O
*	O
bgp	pointer
)	O
{	O
static	O
char	O
fg_buf	array
[	O
16	int
]	O
,	O
bg_buf	array
[	O
16	int
]	O
,	O
*	O
bg	int
,	O
*	O
fg	int
;	O
static	O
int	O
already_parsed	int
;	O
char	O
*	O
p	pointer
,	O
*	O
pmax	pointer
;	O
if	O
(	O
already_parsed	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
already_parsed	int
)	O
{	O
*	O
fgp	pointer
=	O
fg	int
;	O
*	O
bgp	pointer
=	O
bg	int
;	O
return	O
0	int
;	O
}	O
already_parsed	int
=	O
-	O
1	int
;	O
bg	int
=	O
getenv	function
(	O
"COLORFGBG"	pointer
)	O
;	O
if	O
(	O
bg	int
==	O
NULL	O
)	O
{	O
bg	int
=	O
getenv	function
(	O
"DEFAULT_COLORS"	pointer
)	O
;	O
if	O
(	O
bg	int
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
p	pointer
=	O
fg_buf	array
;	O
pmax	pointer
=	O
p	pointer
+	O
(	O
sizeof	O
(	O
fg_buf	array
)	O
-	O
1	int
)	O
;	O
while	O
(	O
(	O
*	O
bg	int
!=	O
0	int
)	O
&&	O
(	O
*	O
bg	int
!=	O
';'	O
)	O
)	O
{	O
if	O
(	O
p	pointer
<	O
pmax	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
bg	int
;	O
bg	int
++	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
*	O
bg	int
)	O
bg	int
++	O
;	O
p	pointer
=	O
bg_buf	array
;	O
pmax	pointer
=	O
p	pointer
+	O
(	O
sizeof	O
(	O
bg_buf	array
)	O
-	O
1	int
)	O
;	O
while	O
(	O
(	O
*	O
bg	int
!=	O
0	int
)	O
&&	O
(	O
*	O
bg	int
!=	O
';'	O
)	O
)	O
{	O
if	O
(	O
p	pointer
<	O
pmax	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
bg	int
;	O
bg	int
++	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
fg_buf	array
,	O
"default"	pointer
)	O
||	O
!	O
strcmp	function
(	O
bg_buf	array
,	O
"default"	pointer
)	O
)	O
{	O
*	O
fgp	pointer
=	O
*	O
bgp	pointer
=	O
fg	int
=	O
bg	int
=	O
"default"	pointer
;	O
}	O
else	O
{	O
*	O
fgp	pointer
=	O
fg	int
=	O
check_color_for_digit_form	function
(	O
fg_buf	array
)	O
;	O
*	O
bgp	pointer
=	O
bg	int
=	O
check_color_for_digit_form	function
(	O
bg_buf	array
)	O
;	O
}	O
already_parsed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
Color_0_Modified	int
=	O
0	int
;	O
int	O
SLtt_set_color_object	function
(	O
int	O
obj	struct
,	O
SLtt_Char_Type	long
attr	long
)	O
{	O
Brush_Info_Type	struct
*	O
b	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
b	pointer
=	O
get_brush_info	function
(	O
obj	struct
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	pointer
->	O
fgbg	long
=	O
attr	long
;	O
if	O
(	O
obj	struct
==	O
0	int
)	O
Color_0_Modified	int
=	O
1	int
;	O
if	O
(	O
_pSLtt_color_changed_hook	pointer
!=	O
NULL	O
)	O
(	O
*	O
_pSLtt_color_changed_hook	pointer
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
SLtt_Char_Type	long
SLtt_get_color_object	function
(	O
int	O
obj	struct
)	O
{	O
return	O
get_brush_fgbg	function
(	O
obj	struct
)	O
;	O
}	O
int	O
SLtt_add_color_attribute	function
(	O
int	O
obj	struct
,	O
SLtt_Char_Type	long
attr	long
)	O
{	O
Brush_Info_Type	struct
*	O
b	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
b	pointer
=	O
get_brush_info	function
(	O
obj	struct
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	pointer
->	O
fgbg	long
|=	O
(	O
attr	long
&	O
ATTR_MASK	int
)	O
;	O
if	O
(	O
obj	struct
==	O
0	int
)	O
Color_0_Modified	int
=	O
1	int
;	O
if	O
(	O
_pSLtt_color_changed_hook	pointer
!=	O
NULL	O
)	O
(	O
*	O
_pSLtt_color_changed_hook	pointer
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
SLtt_Char_Type	long
fb_to_fgbg	function
(	O
SLtt_Char_Type	long
f	float
,	O
SLtt_Char_Type	long
b	pointer
)	O
{	O
SLtt_Char_Type	long
attr	long
;	O
if	O
(	O
Max_Terminfo_Colors	int
!=	O
8	int
)	O
{	O
if	O
(	O
f	float
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
f	float
%=	O
Max_Terminfo_Colors	int
;	O
if	O
(	O
b	pointer
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
b	pointer
%=	O
Max_Terminfo_Colors	int
;	O
return	O
(	O
(	O
f	float
<<	O
8	int
)	O
|	O
(	O
b	pointer
<<	O
16	int
)	O
)	O
;	O
}	O
attr	long
=	O
0	int
;	O
if	O
(	O
f	float
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
{	O
if	O
(	O
f	float
&	O
0x8	int
)	O
attr	long
=	O
SLTT_BOLD_MASK	int
;	O
f	float
&=	O
0x7	int
;	O
}	O
if	O
(	O
b	pointer
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
{	O
if	O
(	O
b	pointer
&	O
0x8	int
)	O
attr	long
|=	O
SLTT_BLINK_MASK	int
;	O
b	pointer
&=	O
0x7	int
;	O
}	O
return	O
(	O
(	O
f	float
<<	O
8	int
)	O
|	O
(	O
b	pointer
<<	O
16	int
)	O
|	O
attr	long
)	O
;	O
}	O
static	O
int	O
parse_color_digit_name	function
(	O
char	O
*	O
color	short
,	O
SLtt_Char_Type	long
*	O
f	float
)	O
{	O
unsigned	O
int	O
i	array
;	O
unsigned	O
char	O
ch	int
;	O
if	O
(	O
strncmp	function
(	O
color	short
,	O
"color"	pointer
,	O
5	int
)	O
)	O
return	O
-	O
1	int
;	O
color	short
+=	O
5	int
;	O
if	O
(	O
*	O
color	short
==	O
0	int
)	O
return	O
-	O
1	int
;	O
i	array
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
ch	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
color	short
++	O
;	O
if	O
(	O
ch	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
ch	int
>	O
'9'	O
)	O
||	O
(	O
ch	int
<	O
'0'	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
i	array
>	O
0xFFFFFFFFU	int
/	O
10	int
)	O
return	O
-	O
1	int
;	O
j	int
=	O
(	O
i	array
*=	O
10	int
)	O
;	O
i	array
+=	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
if	O
(	O
i	array
<	O
j	int
)	O
return	O
-	O
1	int
;	O
}	O
*	O
f	float
=	O
(	O
SLtt_Char_Type	long
)	O
i	array
;	O
return	O
0	int
;	O
}	O
static	O
int	O
make_color_fgbg	function
(	O
char	O
*	O
fg	int
,	O
char	O
*	O
bg	int
,	O
SLtt_Char_Type	long
*	O
fgbg	long
)	O
{	O
SLtt_Char_Type	long
f	float
=	O
0xFFFFFFFFU	int
,	O
b	pointer
=	O
0xFFFFFFFFU	int
;	O
char	O
*	O
dfg	pointer
,	O
*	O
dbg	pointer
;	O
unsigned	O
int	O
i	array
;	O
if	O
(	O
(	O
fg	int
!=	O
NULL	O
)	O
&&	O
(	O
*	O
fg	int
==	O
0	int
)	O
)	O
fg	int
=	O
NULL	O
;	O
if	O
(	O
(	O
bg	int
!=	O
NULL	O
)	O
&&	O
(	O
*	O
bg	int
==	O
0	int
)	O
)	O
bg	int
=	O
NULL	O
;	O
if	O
(	O
(	O
fg	int
==	O
NULL	O
)	O
||	O
(	O
bg	int
==	O
NULL	O
)	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
get_default_colors	function
(	O
&	O
dfg	pointer
,	O
&	O
dbg	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fg	int
==	O
NULL	O
)	O
fg	int
=	O
dfg	pointer
;	O
if	O
(	O
bg	int
==	O
NULL	O
)	O
bg	int
=	O
dbg	pointer
;	O
}	O
if	O
(	O
-	O
1	int
==	O
parse_color_digit_name	function
(	O
fg	int
,	O
&	O
f	float
)	O
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
MAX_COLOR_NAMES	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
fg	int
,	O
Color_Defs	array
[	O
i	array
]	O
.	O
name	pointer
)	O
)	O
continue	O
;	O
f	float
=	O
Color_Defs	array
[	O
i	array
]	O
.	O
color	short
;	O
break	O
;	O
}	O
}	O
if	O
(	O
-	O
1	int
==	O
parse_color_digit_name	function
(	O
bg	int
,	O
&	O
b	pointer
)	O
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
MAX_COLOR_NAMES	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
bg	int
,	O
Color_Defs	array
[	O
i	array
]	O
.	O
name	pointer
)	O
)	O
continue	O
;	O
b	pointer
=	O
Color_Defs	array
[	O
i	array
]	O
.	O
color	short
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
f	float
==	O
0xFFFFFFFFU	int
)	O
||	O
(	O
b	pointer
==	O
0xFFFFFFFFU	int
)	O
)	O
return	O
-	O
1	int
;	O
*	O
fgbg	long
=	O
fb_to_fgbg	function
(	O
f	float
,	O
b	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
SLtt_set_color	function
(	O
int	O
obj	struct
,	O
char	O
*	O
what	pointer
,	O
char	O
*	O
fg	int
,	O
char	O
*	O
bg	int
)	O
{	O
SLtt_Char_Type	long
fgbg	long
;	O
(	O
void	O
)	O
what	pointer
;	O
if	O
(	O
-	O
1	int
==	O
make_color_fgbg	function
(	O
fg	int
,	O
bg	int
,	O
&	O
fgbg	long
)	O
)	O
return	O
-	O
1	int
;	O
return	O
SLtt_set_color_object	function
(	O
obj	struct
,	O
fgbg	long
)	O
;	O
}	O
int	O
SLtt_set_color_fgbg	function
(	O
int	O
obj	struct
,	O
SLtt_Char_Type	long
f	float
,	O
SLtt_Char_Type	long
b	pointer
)	O
{	O
return	O
SLtt_set_color_object	function
(	O
obj	struct
,	O
fb_to_fgbg	function
(	O
f	float
,	O
b	pointer
)	O
)	O
;	O
}	O
void	O
SLtt_set_alt_char_set	function
(	O
int	O
i	array
)	O
{	O
static	O
int	O
last_i	int
;	O
if	O
(	O
SLtt_Has_Alt_Charset	int
==	O
0	int
)	O
return	O
;	O
i	array
=	O
(	O
i	array
!=	O
0	int
)	O
;	O
if	O
(	O
i	array
==	O
last_i	int
)	O
return	O
;	O
tt_write_string	function
(	O
i	array
?	O
Start_Alt_Chars_Str	pointer
:	O
End_Alt_Chars_Str	pointer
)	O
;	O
last_i	int
=	O
i	array
;	O
}	O
static	O
void	O
write_attributes	function
(	O
SLtt_Char_Type	long
fgbg	long
)	O
{	O
int	O
bg0	int
,	O
fg0	int
;	O
int	O
unknown_attributes	int
;	O
if	O
(	O
Worthless_Highlight	int
)	O
return	O
;	O
if	O
(	O
fgbg	long
==	O
Current_Fgbg	long
)	O
return	O
;	O
unknown_attributes	int
=	O
0	int
;	O
if	O
(	O
(	O
fgbg	long
&	O
ATTR_MASK	int
)	O
!=	O
(	O
Current_Fgbg	long
&	O
ATTR_MASK	int
)	O
)	O
{	O
if	O
(	O
Current_Fgbg	long
&	O
ATTR_MASK	int
)	O
{	O
tt_write_string	function
(	O
Norm_Vid_Str	pointer
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
Current_Fgbg	long
&=	O
~	O
SLTT_ALTC_MASK	int
;	O
SLtt_set_alt_char_set	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
!=	O
(	O
Current_Fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
)	O
{	O
SLtt_set_alt_char_set	function
(	O
(	O
int	O
)	O
(	O
fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
)	O
;	O
}	O
if	O
(	O
fgbg	long
&	O
SLTT_ULINE_MASK	int
)	O
tt_write_string	function
(	O
UnderLine_Vid_Str	pointer
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_BOLD_MASK	int
)	O
SLtt_bold_video	function
(	O
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_REV_MASK	int
)	O
tt_write_string	function
(	O
Rev_Vid_Str	pointer
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_BLINK_MASK	int
)	O
{	O
if	O
(	O
SLtt_Blink_Mode	int
)	O
tt_write_string	function
(	O
Blink_Vid_Str	pointer
)	O
;	O
}	O
unknown_attributes	int
=	O
1	int
;	O
}	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
fg0	int
=	O
(	O
int	O
)	O
GET_FG	O
(	O
fgbg	long
)	O
;	O
bg0	int
=	O
(	O
int	O
)	O
GET_BG	O
(	O
fgbg	long
)	O
;	O
if	O
(	O
unknown_attributes	int
||	O
(	O
fg0	int
!=	O
(	O
int	O
)	O
GET_FG	O
(	O
Current_Fgbg	long
)	O
)	O
)	O
{	O
if	O
(	O
fg0	int
==	O
SLSMG_COLOR_DEFAULT	int
)	O
tt_write_string	function
(	O
Default_Color_Fg_Str	pointer
)	O
;	O
else	O
tt_printf	function
(	O
Color_Fg_Str	pointer
,	O
COLOR_ARG	O
(	O
fg0	int
,	O
Is_Bg_BGR	int
)	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
unknown_attributes	int
||	O
(	O
bg0	int
!=	O
(	O
int	O
)	O
GET_BG	O
(	O
Current_Fgbg	long
)	O
)	O
)	O
{	O
if	O
(	O
bg0	int
==	O
SLSMG_COLOR_DEFAULT	int
)	O
tt_write_string	function
(	O
Default_Color_Bg_Str	pointer
)	O
;	O
else	O
tt_printf	function
(	O
Color_Bg_Str	pointer
,	O
COLOR_ARG	O
(	O
bg0	int
,	O
Is_Bg_BGR	int
)	O
,	O
0	int
)	O
;	O
}	O
}	O
Current_Fgbg	long
=	O
fgbg	long
;	O
}	O
static	O
int	O
Video_Initialized	int
;	O
void	O
SLtt_reverse_video	function
(	O
int	O
color	short
)	O
{	O
SLtt_Char_Type	long
fgbg	long
;	O
if	O
(	O
Worthless_Highlight	int
)	O
return	O
;	O
if	O
(	O
Video_Initialized	int
==	O
0	int
)	O
{	O
if	O
(	O
color	short
==	O
JNORMAL_COLOR	int
)	O
{	O
tt_write_string	function
(	O
Norm_Vid_Str	pointer
)	O
;	O
}	O
else	O
tt_write_string	function
(	O
Rev_Vid_Str	pointer
)	O
;	O
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
return	O
;	O
}	O
fgbg	long
=	O
get_brush_attr	function
(	O
color	short
)	O
;	O
if	O
(	O
fgbg	long
==	O
Current_Fgbg	long
)	O
return	O
;	O
write_attributes	function
(	O
fgbg	long
)	O
;	O
}	O
void	O
SLtt_normal_video	function
(	O
void	O
)	O
{	O
SLtt_reverse_video	function
(	O
JNORMAL_COLOR	int
)	O
;	O
}	O
void	O
SLtt_narrow_width	function
(	O
void	O
)	O
{	O
tt_write	function
(	O
"\033[?3l"	pointer
,	O
5	int
)	O
;	O
}	O
void	O
SLtt_wide_width	function
(	O
void	O
)	O
{	O
tt_write	function
(	O
"\033[?3h"	pointer
,	O
5	int
)	O
;	O
}	O
static	O
int	O
bce_color_eqs	function
(	O
SLsmg_Char_Type	struct
*	O
a	pointer
,	O
SLsmg_Char_Type	struct
*	O
b	pointer
)	O
{	O
SLsmg_Color_Type	short
ca	short
,	O
cb	short
;	O
Brush_Info_Type	struct
*	O
ba	pointer
,	O
*	O
bb	pointer
;	O
ca	short
=	O
COLOR_OF	O
(	O
a	pointer
)	O
;	O
cb	short
=	O
COLOR_OF	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ca	short
==	O
cb	short
)	O
return	O
1	int
;	O
ba	pointer
=	O
get_brush_info	function
(	O
ca	short
)	O
;	O
bb	pointer
=	O
get_brush_info	function
(	O
cb	short
)	O
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
return	O
ba	pointer
->	O
mono	long
==	O
bb	pointer
->	O
mono	long
;	O
if	O
(	O
Bce_Color_Offset	int
==	O
0	int
)	O
return	O
ba	pointer
->	O
fgbg	long
==	O
bb	pointer
->	O
fgbg	long
;	O
if	O
(	O
(	O
ca	short
==	O
0	int
)	O
||	O
(	O
cb	short
==	O
0	int
)	O
)	O
return	O
0	int
;	O
return	O
get_brush_fgbg	function
(	O
ca	short
-	O
1	int
)	O
==	O
get_brush_fgbg	function
(	O
cb	short
-	O
1	int
)	O
;	O
}	O
static	O
void	O
write_string_with_care	function
(	O
char	O
*	O
str	pointer
)	O
{	O
unsigned	O
int	O
len	int
;	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
return	O
;	O
len	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
Automatic_Margins	int
&&	O
(	O
Cursor_r	int
+	O
1	int
==	O
SLtt_Screen_Rows	int
)	O
)	O
{	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
0	int
)	O
{	O
if	O
(	O
len	int
+	O
(	O
unsigned	O
int	O
)	O
Cursor_c	int
>=	O
(	O
unsigned	O
int	O
)	O
SLtt_Screen_Cols	int
)	O
{	O
if	O
(	O
SLtt_Screen_Cols	int
>	O
Cursor_c	int
)	O
len	int
=	O
SLtt_Screen_Cols	int
-	O
Cursor_c	int
-	O
1	int
;	O
else	O
len	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
nchars	int
=	O
SLutf8_strlen	function
(	O
(	O
SLuchar_Type	char
*	O
)	O
str	pointer
,	O
1	int
)	O
;	O
if	O
(	O
nchars	int
+	O
(	O
unsigned	O
int	O
)	O
Cursor_c	int
>=	O
(	O
unsigned	O
int	O
)	O
SLtt_Screen_Cols	int
)	O
{	O
if	O
(	O
SLtt_Screen_Cols	int
>	O
Cursor_c	int
)	O
{	O
char	O
*	O
p	pointer
;	O
nchars	int
=	O
SLtt_Screen_Cols	int
-	O
Cursor_c	int
-	O
1	int
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
SLutf8_skip_chars	function
(	O
(	O
SLuchar_Type	char
*	O
)	O
str	pointer
,	O
(	O
SLuchar_Type	char
*	O
)	O
(	O
str	pointer
+	O
len	int
)	O
,	O
nchars	int
,	O
NULL	O
,	O
1	int
)	O
;	O
len	int
=	O
p	pointer
-	O
str	pointer
;	O
}	O
else	O
len	int
=	O
0	int
;	O
}	O
}	O
}	O
tt_write	function
(	O
str	pointer
,	O
len	int
)	O
;	O
}	O
static	O
void	O
send_attr_str	function
(	O
SLsmg_Char_Type	struct
*	O
s	pointer
,	O
SLsmg_Char_Type	struct
*	O
smax	pointer
)	O
{	O
unsigned	O
char	O
out	pointer
[	O
1	int
+	O
SLUTF8_MAX_MBLEN	int
*	O
SLSMG_MAX_CHARS_PER_CELL	int
*	O
SLTT_MAX_SCREEN_COLS	int
]	O
;	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
pmax	pointer
;	O
register	O
SLtt_Char_Type	long
attr	long
;	O
SLsmg_Color_Type	short
color	short
,	O
last_color	short
=	O
(	O
SLsmg_Color_Type	short
)	O
-	O
1	int
;	O
int	O
dcursor_c	int
;	O
p	pointer
=	O
out	pointer
;	O
pmax	pointer
=	O
p	pointer
+	O
(	O
sizeof	O
(	O
out	pointer
)	O
-	O
1	int
)	O
;	O
dcursor_c	int
=	O
0	int
;	O
while	O
(	O
s	pointer
<	O
smax	pointer
)	O
{	O
SLwchar_Type	int
wch	int
;	O
unsigned	O
int	O
nchars	int
;	O
if	O
(	O
0	int
==	O
(	O
nchars	int
=	O
s	pointer
->	O
nchars	int
)	O
)	O
{	O
s	pointer
++	O
;	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
0	int
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
dcursor_c	int
++	O
;	O
continue	O
;	O
}	O
color	short
=	O
s	pointer
->	O
color	short
;	O
if	O
(	O
Bce_Color_Offset	int
&&	O
(	O
color	short
>=	O
Bce_Color_Offset	int
)	O
)	O
color	short
-=	O
Bce_Color_Offset	int
;	O
wch	int
=	O
s	pointer
->	O
wchars	array
[	O
0	int
]	O
;	O
if	O
(	O
color	short
!=	O
last_color	short
)	O
{	O
attr	long
=	O
get_brush_attr	function
(	O
color	short
)	O
;	O
if	O
(	O
color	short
&	O
SLSMG_ACS_MASK	int
)	O
{	O
if	O
(	O
SLtt_Use_Blink_For_ACS	int
)	O
{	O
if	O
(	O
SLtt_Blink_Mode	int
)	O
attr	long
|=	O
SLTT_BLINK_MASK	int
;	O
}	O
else	O
attr	long
|=	O
SLTT_ALTC_MASK	int
;	O
}	O
if	O
(	O
attr	long
!=	O
Current_Fgbg	long
)	O
{	O
if	O
(	O
(	O
wch	int
!=	O
' '	O
)	O
||	O
(	O
nchars	int
>	O
1	int
)	O
||	O
(	O
attr	long
!=	O
Current_Fgbg	long
)	O
)	O
{	O
if	O
(	O
p	pointer
!=	O
out	pointer
)	O
{	O
*	O
p	pointer
=	O
0	int
;	O
write_string_with_care	function
(	O
(	O
char	O
*	O
)	O
out	pointer
)	O
;	O
p	pointer
=	O
out	pointer
;	O
Cursor_c	int
+=	O
dcursor_c	int
;	O
dcursor_c	int
=	O
0	int
;	O
}	O
write_attributes	function
(	O
attr	long
)	O
;	O
last_color	short
=	O
color	short
;	O
}	O
}	O
}	O
if	O
(	O
(	O
wch	int
<	O
0x80	int
)	O
&&	O
(	O
nchars	int
==	O
1	int
)	O
)	O
*	O
p	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
wch	int
;	O
else	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
0	int
)	O
{	O
if	O
(	O
wch	int
>	O
255	int
)	O
wch	int
=	O
'?'	O
;	O
else	O
if	O
(	O
wch	int
<	O
(	O
SLwchar_Type	int
)	O
SLsmg_Display_Eight_Bit	int
)	O
wch	int
=	O
'?'	O
;	O
*	O
p	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
wch	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
nchars	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
p	pointer
=	O
SLutf8_encode	function
(	O
s	pointer
->	O
wchars	array
[	O
i	array
]	O
,	O
p	pointer
,	O
pmax	pointer
-	O
p	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"*** send_attr_str: buffer too small\n"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
dcursor_c	int
++	O
;	O
s	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
p	pointer
!=	O
out	pointer
)	O
write_string_with_care	function
(	O
(	O
char	O
*	O
)	O
out	pointer
)	O
;	O
Cursor_c	int
+=	O
dcursor_c	int
;	O
}	O
static	O
void	O
forward_cursor	function
(	O
unsigned	O
int	O
n	int
,	O
int	O
row	int
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
if	O
(	O
n	int
<=	O
4	int
)	O
{	O
SLtt_normal_video	function
(	O
)	O
;	O
SLMEMSET	O
(	O
buf	pointer
,	O
' '	O
,	O
n	int
)	O
;	O
buf	pointer
[	O
n	int
]	O
=	O
0	int
;	O
write_string_with_care	function
(	O
buf	pointer
)	O
;	O
Cursor_c	int
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
Curs_F_Str	pointer
!=	O
NULL	O
)	O
{	O
Cursor_c	int
+=	O
n	int
;	O
n	int
=	O
tt_sprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
Curs_F_Str	pointer
,	O
(	O
int	O
)	O
n	int
,	O
0	int
)	O
;	O
tt_write	function
(	O
buf	pointer
,	O
n	int
)	O
;	O
}	O
else	O
SLtt_goto_rc	function
(	O
row	int
,	O
(	O
int	O
)	O
(	O
Cursor_c	int
+	O
n	int
)	O
)	O
;	O
}	O
void	O
SLtt_smart_puts	function
(	O
SLsmg_Char_Type	struct
*	O
neww	pointer
,	O
SLsmg_Char_Type	struct
*	O
oldd	pointer
,	O
int	O
len	int
,	O
int	O
row	int
)	O
{	O
register	O
SLsmg_Char_Type	struct
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
qmax	pointer
,	O
*	O
pmax	pointer
,	O
*	O
buf	pointer
;	O
SLsmg_Char_Type	struct
buffer	pointer
[	O
SLTT_MAX_SCREEN_COLS	int
+	O
1	int
]	O
;	O
unsigned	O
int	O
n_spaces	int
;	O
SLsmg_Char_Type	struct
*	O
space_match	pointer
,	O
*	O
last_buffered_match	pointer
;	O
int	O
handle_hp_glitch	int
=	O
0	int
;	O
SLsmg_Char_Type	struct
*	O
space_char	pointer
;	O
SLsmg_Char_Type	struct
space_char_buf	struct
;	O
SLsmg_Char_Type	struct
*	O
insert_hack_prev	pointer
=	O
NULL	O
;	O
SLsmg_Char_Type	struct
*	O
insert_hack_char	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
row	int
+	O
1	int
==	O
SLtt_Screen_Rows	int
)	O
&&	O
(	O
len	int
==	O
SLtt_Screen_Cols	int
)	O
&&	O
(	O
len	int
>	O
1	int
)	O
&&	O
(	O
SLtt_Term_Cannot_Insert	int
==	O
0	int
)	O
&&	O
Automatic_Margins	int
)	O
{	O
SLsmg_Char_Type	struct
*	O
a	pointer
,	O
*	O
b	pointer
;	O
insert_hack_char	pointer
=	O
&	O
neww	pointer
[	O
len	int
-	O
1	int
]	O
;	O
a	pointer
=	O
oldd	pointer
+	O
(	O
len	int
-	O
1	int
)	O
;	O
b	pointer
=	O
neww	pointer
+	O
(	O
len	int
-	O
1	int
)	O
;	O
if	O
(	O
CHAR_EQS	O
(	O
a	pointer
,	O
b	pointer
)	O
)	O
insert_hack_char	pointer
=	O
NULL	O
;	O
else	O
insert_hack_prev	pointer
=	O
&	O
neww	pointer
[	O
len	int
-	O
2	int
]	O
;	O
}	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
space_char_buf	struct
,	O
0	int
,	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
)	O
;	O
space_char	pointer
=	O
&	O
space_char_buf	struct
;	O
space_char	pointer
->	O
nchars	int
=	O
1	int
;	O
space_char	pointer
->	O
wchars	array
[	O
0	int
]	O
=	O
' '	O
;	O
if	O
(	O
len	int
>	O
SLTT_MAX_SCREEN_COLS	int
)	O
len	int
=	O
SLTT_MAX_SCREEN_COLS	int
;	O
q	pointer
=	O
oldd	pointer
;	O
p	pointer
=	O
neww	pointer
;	O
qmax	pointer
=	O
oldd	pointer
+	O
len	int
;	O
pmax	pointer
=	O
p	pointer
+	O
len	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
q	pointer
==	O
qmax	pointer
)	O
return	O
;	O
if	O
(	O
!	O
CHAR_EQS	O
(	O
q	pointer
,	O
p	pointer
)	O
)	O
break	O
;	O
q	pointer
++	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
Has_HP_Glitch	int
)	O
{	O
SLsmg_Char_Type	struct
*	O
qq	pointer
=	O
q	pointer
;	O
SLtt_goto_rc	function
(	O
row	int
,	O
(	O
int	O
)	O
(	O
p	pointer
-	O
neww	pointer
)	O
)	O
;	O
while	O
(	O
qq	pointer
<	O
qmax	pointer
)	O
{	O
if	O
(	O
qq	pointer
->	O
color	short
)	O
{	O
SLtt_normal_video	function
(	O
)	O
;	O
SLtt_del_eol	function
(	O
)	O
;	O
qmax	pointer
=	O
q	pointer
;	O
handle_hp_glitch	int
=	O
1	int
;	O
break	O
;	O
}	O
qq	pointer
++	O
;	O
}	O
}	O
if	O
(	O
CHAR_EQS_SPACE	O
(	O
pmax	pointer
-	O
1	int
)	O
)	O
{	O
if	O
(	O
(	O
Can_Background_Color_Erase	int
)	O
&&	O
SLtt_Use_Ansi_Colors	int
)	O
space_char	pointer
=	O
pmax	pointer
-	O
1	int
;	O
while	O
(	O
pmax	pointer
>	O
p	pointer
)	O
{	O
pmax	pointer
--	O
;	O
if	O
(	O
!	O
CHAR_EQS	O
(	O
pmax	pointer
,	O
space_char	pointer
)	O
)	O
{	O
pmax	pointer
++	O
;	O
break	O
;	O
}	O
}	O
}	O
while	O
(	O
qmax	pointer
>	O
q	pointer
)	O
{	O
qmax	pointer
--	O
;	O
if	O
(	O
!	O
CHAR_EQS	O
(	O
qmax	pointer
,	O
space_char	pointer
)	O
)	O
{	O
qmax	pointer
++	O
;	O
break	O
;	O
}	O
}	O
last_buffered_match	pointer
=	O
buf	pointer
=	O
buffer	pointer
;	O
if	O
(	O
handle_hp_glitch	int
)	O
{	O
while	O
(	O
p	pointer
<	O
pmax	pointer
)	O
{	O
*	O
buf	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
}	O
if	O
(	O
Has_HP_Glitch	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
Del_Bol_Str	pointer
!=	O
NULL	O
)	O
&&	O
(	O
CHAR_EQS_SPACE	O
(	O
neww	pointer
)	O
)	O
)	O
{	O
SLsmg_Char_Type	struct
*	O
p1	pointer
;	O
SLsmg_Color_Type	short
blank_color	short
=	O
0	int
;	O
p1	pointer
=	O
neww	pointer
;	O
if	O
(	O
(	O
Can_Background_Color_Erase	int
)	O
&&	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
SLsmg_Char_Type	struct
*	O
blank	pointer
=	O
p1	pointer
;	O
blank_color	short
=	O
COLOR_OF	O
(	O
blank	pointer
)	O
;	O
while	O
(	O
(	O
p1	pointer
<	O
pmax	pointer
)	O
&&	O
(	O
CHAR_EQS	O
(	O
p1	pointer
,	O
blank	pointer
)	O
)	O
)	O
p1	pointer
++	O
;	O
}	O
else	O
{	O
while	O
(	O
(	O
p1	pointer
<	O
pmax	pointer
)	O
&&	O
(	O
CHAR_EQS_SPACE	O
(	O
p1	pointer
)	O
)	O
)	O
p1	pointer
++	O
;	O
}	O
if	O
(	O
(	O
p1	pointer
>	O
neww	pointer
+	O
13	int
)	O
&&	O
(	O
p1	pointer
>=	O
p	pointer
)	O
&&	O
(	O
(	O
p1	pointer
!=	O
pmax	pointer
)	O
||	O
(	O
pmax	pointer
<	O
neww	pointer
+	O
len	int
)	O
)	O
)	O
{	O
int	O
ofs	int
=	O
(	O
int	O
)	O
(	O
p1	pointer
-	O
neww	pointer
)	O
;	O
q	pointer
=	O
oldd	pointer
+	O
ofs	int
;	O
p	pointer
=	O
p1	pointer
;	O
SLtt_goto_rc	function
(	O
row	int
,	O
ofs	int
-	O
1	int
)	O
;	O
SLtt_reverse_video	function
(	O
blank_color	short
)	O
;	O
tt_write_string	function
(	O
Del_Bol_Str	pointer
)	O
;	O
tt_write	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
Cursor_c	int
+=	O
1	int
;	O
}	O
else	O
SLtt_goto_rc	function
(	O
row	int
,	O
(	O
int	O
)	O
(	O
p	pointer
-	O
neww	pointer
)	O
)	O
;	O
}	O
else	O
SLtt_goto_rc	function
(	O
row	int
,	O
(	O
int	O
)	O
(	O
p	pointer
-	O
neww	pointer
)	O
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
n_spaces	int
=	O
0	int
;	O
while	O
(	O
p	pointer
<	O
pmax	pointer
)	O
{	O
if	O
(	O
CHAR_EQS_SPACE	O
(	O
q	pointer
)	O
&&	O
CHAR_EQS_SPACE	O
(	O
p	pointer
)	O
)	O
{	O
space_match	pointer
=	O
p	pointer
;	O
p	pointer
++	O
;	O
q	pointer
++	O
;	O
while	O
(	O
(	O
p	pointer
<	O
pmax	pointer
)	O
&&	O
CHAR_EQS_SPACE	O
(	O
q	pointer
)	O
&&	O
CHAR_EQS_SPACE	O
(	O
p	pointer
)	O
)	O
{	O
p	pointer
++	O
;	O
q	pointer
++	O
;	O
}	O
n_spaces	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
p	pointer
-	O
space_match	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
CHAR_EQS	O
(	O
q	pointer
,	O
p	pointer
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
nchars	int
||	O
q	pointer
->	O
nchars	int
)	O
break	O
;	O
}	O
*	O
buf	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
q	pointer
++	O
;	O
}	O
if	O
(	O
buf	pointer
!=	O
buffer	pointer
)	O
send_attr_str	function
(	O
buffer	pointer
,	O
buf	pointer
)	O
;	O
buf	pointer
=	O
buffer	pointer
;	O
if	O
(	O
n_spaces	int
&&	O
(	O
(	O
p	pointer
<	O
pmax	pointer
)	O
||	O
(	O
!	O
CHAR_EQS_SPACE	O
(	O
space_char	pointer
)	O
)	O
)	O
)	O
{	O
forward_cursor	function
(	O
n_spaces	int
,	O
row	int
)	O
;	O
}	O
while	O
(	O
(	O
p	pointer
<	O
pmax	pointer
)	O
&&	O
CHAR_EQS	O
(	O
p	pointer
,	O
q	pointer
)	O
)	O
{	O
*	O
buf	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
q	pointer
++	O
;	O
}	O
last_buffered_match	pointer
=	O
buf	pointer
;	O
if	O
(	O
p	pointer
>=	O
pmax	pointer
)	O
break	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
buf	pointer
-	O
buffer	pointer
)	O
>=	O
5	int
)	O
{	O
forward_cursor	function
(	O
(	O
unsigned	O
int	O
)	O
(	O
buf	pointer
-	O
buffer	pointer
)	O
,	O
row	int
)	O
;	O
last_buffered_match	pointer
=	O
buf	pointer
=	O
buffer	pointer
;	O
}	O
}	O
if	O
(	O
buf	pointer
!=	O
buffer	pointer
)	O
{	O
if	O
(	O
q	pointer
<	O
qmax	pointer
)	O
{	O
if	O
(	O
(	O
buf	pointer
==	O
last_buffered_match	pointer
)	O
&&	O
(	O
(	O
int	O
)	O
(	O
buf	pointer
-	O
buffer	pointer
)	O
>=	O
5	int
)	O
)	O
{	O
forward_cursor	function
(	O
(	O
unsigned	O
int	O
)	O
(	O
buf	pointer
-	O
buffer	pointer
)	O
,	O
row	int
)	O
;	O
}	O
else	O
{	O
send_attr_str	function
(	O
buffer	pointer
,	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
q	pointer
<	O
qmax	pointer
)	O
{	O
SLtt_reverse_video	function
(	O
COLOR_OF	O
(	O
space_char	pointer
)	O
)	O
;	O
del_eol	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
insert_hack_char	pointer
!=	O
NULL	O
)	O
{	O
SLtt_goto_rc	function
(	O
SLtt_Screen_Rows	int
-	O
1	int
,	O
SLtt_Screen_Cols	int
-	O
2	int
)	O
;	O
send_attr_str	function
(	O
insert_hack_char	pointer
,	O
insert_hack_char	pointer
+	O
1	int
)	O
;	O
SLtt_goto_rc	function
(	O
SLtt_Screen_Rows	int
-	O
1	int
,	O
SLtt_Screen_Cols	int
-	O
2	int
)	O
;	O
SLtt_begin_insert	function
(	O
)	O
;	O
send_attr_str	function
(	O
insert_hack_prev	pointer
,	O
insert_hack_prev	pointer
+	O
1	int
)	O
;	O
SLtt_end_insert	function
(	O
)	O
;	O
}	O
if	O
(	O
Automatic_Margins	int
&&	O
(	O
Cursor_c	int
+	O
1	int
>=	O
SLtt_Screen_Cols	int
)	O
)	O
Cursor_Set	int
=	O
0	int
;	O
}	O
static	O
void	O
get_color_info	function
(	O
void	O
)	O
{	O
char	O
*	O
fg	int
,	O
*	O
bg	int
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
SLtt_Use_Ansi_Colors	int
=	O
(	O
NULL	O
!=	O
getenv	function
(	O
"COLORTERM"	pointer
)	O
)	O
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
Is_Color_Terminal	int
=	O
1	int
;	O
if	O
(	O
Can_Background_Color_Erase	int
==	O
0	int
)	O
Can_Background_Color_Erase	int
=	O
(	O
NULL	O
!=	O
getenv	function
(	O
"COLORTERM_BCE"	pointer
)	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
get_default_colors	function
(	O
&	O
fg	int
,	O
&	O
bg	int
)	O
)	O
return	O
;	O
if	O
(	O
Color_0_Modified	int
)	O
return	O
;	O
SLtt_set_color	function
(	O
0	int
,	O
NULL	O
,	O
fg	int
,	O
bg	int
)	O
;	O
SLtt_set_color	function
(	O
1	int
,	O
NULL	O
,	O
bg	int
,	O
fg	int
)	O
;	O
}	O
static	O
int	O
Termcap_Initalized	int
=	O
0	int
;	O
static	O
SLterminfo_Type	struct
*	O
Terminfo	pointer
;	O
static	O
char	O
*	O
fixup_tgetstr	function
(	O
char	O
*	O
what	pointer
)	O
{	O
register	O
char	O
*	O
w	pointer
,	O
*	O
w1	pointer
;	O
char	O
*	O
wsave	pointer
;	O
if	O
(	O
what	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
*	O
what	pointer
==	O
'@'	O
)	O
return	O
NULL	O
;	O
while	O
(	O
(	O
*	O
what	pointer
==	O
'.'	O
)	O
||	O
(	O
(	O
*	O
what	pointer
>=	O
'0'	O
)	O
&&	O
(	O
*	O
what	pointer
<=	O
'9'	O
)	O
)	O
)	O
what	pointer
++	O
;	O
if	O
(	O
*	O
what	pointer
==	O
'*'	O
)	O
what	pointer
++	O
;	O
w	pointer
=	O
what	pointer
;	O
while	O
(	O
*	O
w	pointer
)	O
if	O
(	O
(	O
*	O
w	pointer
++	O
==	O
'$'	O
)	O
&&	O
(	O
*	O
w	pointer
==	O
'<'	O
)	O
)	O
{	O
w1	pointer
=	O
w	pointer
-	O
1	int
;	O
while	O
(	O
*	O
w	pointer
&&	O
(	O
*	O
w	pointer
!=	O
'>'	O
)	O
)	O
w	pointer
++	O
;	O
if	O
(	O
*	O
w	pointer
==	O
0	int
)	O
break	O
;	O
w	pointer
++	O
;	O
wsave	pointer
=	O
w1	pointer
;	O
while	O
(	O
(	O
*	O
w1	pointer
++	O
=	O
*	O
w	pointer
++	O
)	O
!=	O
0	int
)	O
;	O
w	pointer
=	O
wsave	pointer
;	O
}	O
if	O
(	O
*	O
what	pointer
==	O
0	int
)	O
what	pointer
=	O
NULL	O
;	O
return	O
what	pointer
;	O
}	O
char	O
*	O
SLtt_tgetstr	function
(	O
char	O
*	O
cap	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
Termcap_Initalized	int
==	O
0	int
)	O
return	O
NULL	O
;	O
s	pointer
=	O
_pSLtt_tigetstr	function
(	O
Terminfo	pointer
,	O
cap	pointer
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
cap	pointer
,	O
"ac"	pointer
)	O
)	O
return	O
s	pointer
;	O
s	pointer
=	O
fixup_tgetstr	function
(	O
s	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
int	O
SLtt_tgetnum	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
Termcap_Initalized	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
_pSLtt_tigetnum	function
(	O
Terminfo	pointer
,	O
s	pointer
)	O
;	O
}	O
int	O
SLtt_tgetflag	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
Termcap_Initalized	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
_pSLtt_tigetflag	function
(	O
Terminfo	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
int	O
Vt100_Like	int
=	O
0	int
;	O
void	O
SLtt_get_terminfo	function
(	O
void	O
)	O
{	O
char	O
*	O
term	pointer
;	O
int	O
status	int
;	O
term	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
if	O
(	O
term	pointer
==	O
NULL	O
)	O
SLang_exit_error	function
(	O
"TERM environment variable needs set."	pointer
)	O
;	O
if	O
(	O
0	int
==	O
(	O
status	int
=	O
SLtt_initialize	function
(	O
term	pointer
)	O
)	O
)	O
return	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
SLang_exit_error	function
(	O
"Unknown terminal: %s\nCheck the TERM environment variable.\nAlso make sure that the terminal is defined in the terminfo database.\nAlternatively, set the TERMCAP environment variable to the desired\ntermcap entry."	pointer
,	O
term	pointer
)	O
;	O
}	O
if	O
(	O
status	int
==	O
-	O
2	int
)	O
{	O
SLang_exit_error	function
(	O
"Your terminal lacks the ability to clear the screen or position the cursor.\n"	pointer
)	O
;	O
}	O
}	O
int	O
SLtt_initialize	function
(	O
char	O
*	O
term	pointer
)	O
{	O
char	O
*	O
t	long
,	O
ch	int
;	O
int	O
is_xterm	int
;	O
int	O
almost_vtxxx	int
;	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
-	O
1	int
)	O
_pSLtt_UTF8_Mode	int
=	O
_pSLutf8_mode	int
;	O
if	O
(	O
SLang_TT_Write_FD	int
==	O
-	O
1	int
)	O
{	O
SLang_TT_Write_FD	int
=	O
fileno	function
(	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
term	pointer
==	O
NULL	O
)	O
{	O
term	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
if	O
(	O
term	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_pSLsecure_issetugid	function
(	O
)	O
&&	O
(	O
(	O
term	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
term	pointer
,	O
'/'	O
)	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
Linux_Console	int
=	O
(	O
!	O
strncmp	function
(	O
term	pointer
,	O
"linux"	pointer
,	O
5	int
)	O
||	O
!	O
strncmp	function
(	O
term	pointer
,	O
"con"	pointer
,	O
3	int
)	O
)	O
;	O
QANSI_Console	int
=	O
!	O
strncmp	function
(	O
term	pointer
,	O
"qansi-m"	pointer
,	O
7	int
)	O
;	O
t	long
=	O
term	pointer
;	O
if	O
(	O
strcmp	function
(	O
t	long
,	O
"vt52"	pointer
)	O
&&	O
(	O
*	O
t	long
++	O
==	O
'v'	O
)	O
&&	O
(	O
*	O
t	long
++	O
==	O
't'	O
)	O
&&	O
(	O
ch	int
=	O
*	O
t	long
,	O
(	O
ch	int
>=	O
'1'	O
)	O
&&	O
(	O
ch	int
<=	O
'9'	O
)	O
)	O
)	O
Vt100_Like	int
=	O
1	int
;	O
is_xterm	int
=	O
(	O
(	O
0	int
==	O
strncmp	function
(	O
term	pointer
,	O
"xterm"	pointer
,	O
5	int
)	O
)	O
||	O
(	O
0	int
==	O
strncmp	function
(	O
term	pointer
,	O
"rxvt"	pointer
,	O
4	int
)	O
)	O
||	O
(	O
0	int
==	O
strncmp	function
(	O
term	pointer
,	O
"Eterm"	pointer
,	O
5	int
)	O
)	O
)	O
;	O
almost_vtxxx	int
=	O
(	O
Vt100_Like	int
||	O
Linux_Console	int
||	O
is_xterm	int
||	O
!	O
strcmp	function
(	O
term	pointer
,	O
"screen"	pointer
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
Terminfo	pointer
=	O
_pSLtt_tigetent	function
(	O
term	pointer
)	O
)	O
)	O
{	O
if	O
(	O
almost_vtxxx	int
)	O
{	O
int	O
vt102	int
=	O
1	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
term	pointer
,	O
"vt100"	pointer
)	O
)	O
vt102	int
=	O
0	int
;	O
get_color_info	function
(	O
)	O
;	O
SLtt_set_term_vtxxx	function
(	O
&	O
vt102	int
)	O
;	O
(	O
void	O
)	O
SLtt_get_screen_size	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
Termcap_Initalized	int
=	O
1	int
;	O
Cls_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"cl"	pointer
)	O
;	O
Curs_Pos_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"cm"	pointer
)	O
;	O
if	O
(	O
(	O
NULL	O
==	O
(	O
Ins_Mode_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"im"	pointer
)	O
)	O
)	O
||	O
(	O
NULL	O
==	O
(	O
Eins_Mode_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ei"	pointer
)	O
)	O
)	O
||	O
(	O
NULL	O
==	O
(	O
Del_Char_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"dc"	pointer
)	O
)	O
)	O
)	O
SLtt_Term_Cannot_Insert	int
=	O
1	int
;	O
Visible_Bell_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"vb"	pointer
)	O
;	O
Curs_Up_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"up"	pointer
)	O
;	O
Rev_Scroll_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"sr"	pointer
)	O
;	O
Del_N_Lines_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"DL"	pointer
)	O
;	O
Add_N_Lines_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"AL"	pointer
)	O
;	O
Term_Init_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ti"	pointer
)	O
;	O
Term_Reset_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"te"	pointer
)	O
;	O
if	O
(	O
(	O
almost_vtxxx	int
==	O
0	int
)	O
||	O
SLtt_Force_Keypad_Init	int
)	O
{	O
Keypad_Init_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ks"	pointer
)	O
;	O
Keypad_Reset_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ke"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
Vt100_Like	int
&&	O
(	O
term	pointer
[	O
2	int
]	O
!=	O
'1'	O
)	O
)	O
||	O
Linux_Console	int
||	O
is_xterm	int
)	O
{	O
if	O
(	O
Del_N_Lines_Str	pointer
==	O
NULL	O
)	O
Del_N_Lines_Str	pointer
=	O
"\033[%dM"	pointer
;	O
if	O
(	O
Add_N_Lines_Str	pointer
==	O
NULL	O
)	O
Add_N_Lines_Str	pointer
=	O
"\033[%dL"	pointer
;	O
}	O
Scroll_R_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"cs"	pointer
)	O
;	O
SLtt_get_screen_size	function
(	O
)	O
;	O
if	O
(	O
(	O
Scroll_R_Str	pointer
==	O
NULL	O
)	O
||	O
(	O
(	O
(	O
NULL	O
==	O
Del_N_Lines_Str	pointer
)	O
||	O
(	O
NULL	O
==	O
Add_N_Lines_Str	pointer
)	O
)	O
&&	O
(	O
NULL	O
==	O
Rev_Scroll_Str	pointer
)	O
)	O
)	O
{	O
if	O
(	O
is_xterm	int
||	O
Linux_Console	int
)	O
{	O
SLtt_set_term_vtxxx	function
(	O
NULL	O
)	O
;	O
}	O
else	O
SLtt_Term_Cannot_Scroll	int
=	O
1	int
;	O
}	O
Del_Eol_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ce"	pointer
)	O
;	O
Del_Bol_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"cb"	pointer
)	O
;	O
if	O
(	O
is_xterm	int
&&	O
(	O
Del_Bol_Str	pointer
==	O
NULL	O
)	O
)	O
Del_Bol_Str	pointer
=	O
"\033[1K"	pointer
;	O
if	O
(	O
is_xterm	int
&&	O
(	O
Del_Eol_Str	pointer
==	O
NULL	O
)	O
)	O
Del_Eol_Str	pointer
=	O
"\033[K"	pointer
;	O
Rev_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"mr"	pointer
)	O
;	O
if	O
(	O
Rev_Vid_Str	pointer
==	O
NULL	O
)	O
Rev_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"so"	pointer
)	O
;	O
Bold_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"md"	pointer
)	O
;	O
if	O
(	O
(	O
NULL	O
==	O
(	O
Blink_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"mb"	pointer
)	O
)	O
)	O
&&	O
is_xterm	int
)	O
Blink_Vid_Str	pointer
=	O
"\033[5m"	pointer
;	O
UnderLine_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"us"	pointer
)	O
;	O
Start_Alt_Chars_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"as"	pointer
)	O
;	O
End_Alt_Chars_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ae"	pointer
)	O
;	O
Enable_Alt_Char_Set	pointer
=	O
SLtt_tgetstr	function
(	O
"eA"	pointer
)	O
;	O
SLtt_Graphics_Char_Pairs	pointer
=	O
SLtt_tgetstr	function
(	O
"ac"	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
SLtt_Graphics_Char_Pairs	pointer
)	O
{	O
if	O
(	O
Vt100_Like	int
)	O
{	O
Start_Alt_Chars_Str	pointer
=	O
"\016"	pointer
;	O
End_Alt_Chars_Str	pointer
=	O
"\017"	pointer
;	O
Enable_Alt_Char_Set	pointer
=	O
"\033)0"	pointer
;	O
}	O
}	O
if	O
(	O
is_xterm	int
||	O
!	O
strncmp	function
(	O
term	pointer
,	O
"aixterm"	pointer
,	O
7	int
)	O
)	O
{	O
Start_Alt_Chars_Str	pointer
=	O
"\033(0"	pointer
;	O
End_Alt_Chars_Str	pointer
=	O
"\033(B"	pointer
;	O
Enable_Alt_Char_Set	pointer
=	O
""	pointer
;	O
}	O
if	O
(	O
(	O
SLtt_Graphics_Char_Pairs	pointer
==	O
NULL	O
)	O
&&	O
(	O
(	O
Start_Alt_Chars_Str	pointer
==	O
NULL	O
)	O
||	O
(	O
End_Alt_Chars_Str	pointer
==	O
NULL	O
)	O
)	O
)	O
{	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
Enable_Alt_Char_Set	pointer
=	O
NULL	O
;	O
}	O
else	O
SLtt_Has_Alt_Charset	int
=	O
1	int
;	O
if	O
(	O
(	O
SLtt_Has_Status_Line	int
==	O
-	O
1	int
)	O
&&	O
(	O
0	int
!=	O
(	O
SLtt_Has_Status_Line	int
=	O
TGETFLAG	O
(	O
"hs"	pointer
)	O
)	O
)	O
)	O
{	O
Disable_Status_line_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ds"	pointer
)	O
;	O
Return_From_Status_Line_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"fs"	pointer
)	O
;	O
Goto_Status_Line_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ts"	pointer
)	O
;	O
Num_Status_Line_Columns	int
=	O
SLtt_tgetnum	function
(	O
"ws"	pointer
)	O
;	O
if	O
(	O
Num_Status_Line_Columns	int
<	O
0	int
)	O
Num_Status_Line_Columns	int
=	O
0	int
;	O
}	O
if	O
(	O
NULL	O
==	O
(	O
Norm_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"me"	pointer
)	O
)	O
)	O
{	O
Norm_Vid_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"se"	pointer
)	O
;	O
}	O
Cursor_Invisible_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"vi"	pointer
)	O
;	O
Cursor_Visible_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"ve"	pointer
)	O
;	O
Curs_F_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"RI"	pointer
)	O
;	O
Automatic_Margins	int
=	O
TGETFLAG	O
(	O
"am"	pointer
)	O
;	O
Has_HP_Glitch	int
=	O
TGETFLAG	O
(	O
"xs"	pointer
)	O
;	O
if	O
(	O
Worthless_Highlight	int
==	O
0	int
)	O
{	O
Worthless_Highlight	int
=	O
(	O
SLtt_tgetnum	function
(	O
"sg"	pointer
)	O
>	O
0	int
)	O
;	O
}	O
if	O
(	O
Worthless_Highlight	int
)	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
Reset_Color_String	pointer
=	O
SLtt_tgetstr	function
(	O
"op"	pointer
)	O
;	O
Color_Fg_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"AF"	pointer
)	O
;	O
if	O
(	O
Color_Fg_Str	pointer
==	O
NULL	O
)	O
{	O
Color_Fg_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"Sf"	pointer
)	O
;	O
}	O
Color_Bg_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"AB"	pointer
)	O
;	O
if	O
(	O
Color_Bg_Str	pointer
==	O
NULL	O
)	O
{	O
Color_Bg_Str	pointer
=	O
SLtt_tgetstr	function
(	O
"Sb"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
Max_Terminfo_Colors	int
=	O
SLtt_tgetnum	function
(	O
"Co"	pointer
)	O
)	O
<	O
0	int
)	O
Max_Terminfo_Colors	int
=	O
8	int
;	O
if	O
(	O
(	O
Color_Bg_Str	pointer
!=	O
NULL	O
)	O
&&	O
(	O
Color_Fg_Str	pointer
!=	O
NULL	O
)	O
)	O
SLtt_Use_Ansi_Colors	int
=	O
1	int
;	O
else	O
{	O
Color_Fg_Str	pointer
=	O
"\033[3%dm"	pointer
;	O
Color_Bg_Str	pointer
=	O
"\033[4%dm"	pointer
;	O
Max_Terminfo_Colors	int
=	O
8	int
;	O
}	O
Can_Background_Color_Erase	int
=	O
TGETFLAG	O
(	O
"ut"	pointer
)	O
;	O
if	O
(	O
Can_Background_Color_Erase	int
==	O
0	int
)	O
{	O
Can_Background_Color_Erase	int
=	O
(	O
Linux_Console	int
)	O
;	O
}	O
get_color_info	function
(	O
)	O
;	O
if	O
(	O
(	O
Cls_Str	pointer
==	O
NULL	O
)	O
||	O
(	O
Curs_Pos_Str	pointer
==	O
NULL	O
)	O
)	O
return	O
-	O
2	int
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_enable_cursor_keys	function
(	O
void	O
)	O
{	O
if	O
(	O
Vt100_Like	int
)	O
tt_write_string	function
(	O
"\033=\033[?1l"	pointer
)	O
;	O
}	O
void	O
SLtt_set_term_vtxxx	function
(	O
int	O
*	O
vt100	pointer
)	O
{	O
Norm_Vid_Str	pointer
=	O
"\033[m"	pointer
;	O
Scroll_R_Str	pointer
=	O
"\033[%i%d;%dr"	pointer
;	O
Cls_Str	pointer
=	O
"\033[2J\033[H"	pointer
;	O
Rev_Vid_Str	pointer
=	O
"\033[7m"	pointer
;	O
Bold_Vid_Str	pointer
=	O
"\033[1m"	pointer
;	O
Blink_Vid_Str	pointer
=	O
"\033[5m"	pointer
;	O
UnderLine_Vid_Str	pointer
=	O
"\033[4m"	pointer
;	O
Del_Eol_Str	pointer
=	O
"\033[K"	pointer
;	O
Del_Bol_Str	pointer
=	O
"\033[1K"	pointer
;	O
Rev_Scroll_Str	pointer
=	O
"\033M"	pointer
;	O
Curs_F_Str	pointer
=	O
"\033[%dC"	pointer
;	O
Curs_Pos_Str	pointer
=	O
"\033[%i%d;%dH"	pointer
;	O
if	O
(	O
(	O
vt100	pointer
==	O
NULL	O
)	O
||	O
(	O
*	O
vt100	pointer
==	O
0	int
)	O
)	O
{	O
Ins_Mode_Str	pointer
=	O
"\033[4h"	pointer
;	O
Eins_Mode_Str	pointer
=	O
"\033[4l"	pointer
;	O
Del_Char_Str	pointer
=	O
"\033[P"	pointer
;	O
Del_N_Lines_Str	pointer
=	O
"\033[%dM"	pointer
;	O
Add_N_Lines_Str	pointer
=	O
"\033[%dL"	pointer
;	O
SLtt_Term_Cannot_Insert	int
=	O
0	int
;	O
}	O
else	O
{	O
Del_N_Lines_Str	pointer
=	O
NULL	O
;	O
Add_N_Lines_Str	pointer
=	O
NULL	O
;	O
SLtt_Term_Cannot_Insert	int
=	O
1	int
;	O
}	O
SLtt_Term_Cannot_Scroll	int
=	O
0	int
;	O
}	O
int	O
SLtt_init_video	function
(	O
void	O
)	O
{	O
tt_write_string	function
(	O
Term_Init_Str	pointer
)	O
;	O
tt_write_string	function
(	O
Keypad_Init_Str	pointer
)	O
;	O
SLtt_reset_scroll_region	function
(	O
)	O
;	O
SLtt_end_insert	function
(	O
)	O
;	O
tt_write_string	function
(	O
Enable_Alt_Char_Set	pointer
)	O
;	O
Video_Initialized	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
SLtt_reset_video	function
(	O
void	O
)	O
{	O
SLtt_goto_rc	function
(	O
SLtt_Screen_Rows	int
-	O
1	int
,	O
0	int
)	O
;	O
Cursor_Set	int
=	O
0	int
;	O
SLtt_normal_video	function
(	O
)	O
;	O
tt_write_string	function
(	O
Norm_Vid_Str	pointer
)	O
;	O
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
SLtt_set_alt_char_set	function
(	O
0	int
)	O
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
if	O
(	O
Reset_Color_String	pointer
==	O
NULL	O
)	O
{	O
SLtt_Char_Type	long
attr	long
;	O
if	O
(	O
-	O
1	int
!=	O
make_color_fgbg	function
(	O
NULL	O
,	O
NULL	O
,	O
&	O
attr	long
)	O
)	O
write_attributes	function
(	O
attr	long
)	O
;	O
else	O
tt_write_string	function
(	O
"\033[0m\033[m"	pointer
)	O
;	O
}	O
else	O
tt_write_string	function
(	O
Reset_Color_String	pointer
)	O
;	O
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
}	O
SLtt_erase_line	function
(	O
)	O
;	O
tt_write_string	function
(	O
Keypad_Reset_Str	pointer
)	O
;	O
tt_write_string	function
(	O
Term_Reset_Str	pointer
)	O
;	O
if	O
(	O
Mouse_Mode	int
==	O
1	int
)	O
SLtt_set_mouse_mode	function
(	O
0	int
,	O
1	int
)	O
;	O
SLtt_flush_output	function
(	O
)	O
;	O
Video_Initialized	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_bold_video	function
(	O
void	O
)	O
{	O
tt_write_string	function
(	O
Bold_Vid_Str	pointer
)	O
;	O
}	O
int	O
SLtt_set_mouse_mode	function
(	O
int	O
mode	int
,	O
int	O
force	int
)	O
{	O
char	O
*	O
term	pointer
;	O
if	O
(	O
force	int
==	O
0	int
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
term	pointer
=	O
(	O
char	O
*	O
)	O
getenv	function
(	O
"TERM"	pointer
)	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
"xterm"	pointer
,	O
term	pointer
,	O
5	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
Mouse_Mode	int
=	O
(	O
mode	int
!=	O
0	int
)	O
;	O
if	O
(	O
mode	int
)	O
tt_write_string	function
(	O
"\033[?9h"	pointer
)	O
;	O
else	O
tt_write_string	function
(	O
"\033[?9l"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_disable_status_line	function
(	O
void	O
)	O
{	O
if	O
(	O
SLtt_Has_Status_Line	int
>	O
0	int
)	O
{	O
tt_write_string	function
(	O
Disable_Status_line_Str	pointer
)	O
;	O
SLtt_flush_output	function
(	O
)	O
;	O
}	O
}	O
int	O
SLtt_write_to_status_line	function
(	O
char	O
*	O
s	pointer
,	O
int	O
col	int
)	O
{	O
if	O
(	O
(	O
SLtt_Has_Status_Line	int
<=	O
0	int
)	O
||	O
(	O
Goto_Status_Line_Str	pointer
==	O
NULL	O
)	O
||	O
(	O
Return_From_Status_Line_Str	pointer
==	O
NULL	O
)	O
)	O
return	O
-	O
1	int
;	O
tt_printf	function
(	O
Goto_Status_Line_Str	pointer
,	O
col	int
,	O
0	int
)	O
;	O
tt_write_string	function
(	O
s	pointer
)	O
;	O
tt_write_string	function
(	O
Return_From_Status_Line_Str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_get_screen_size	function
(	O
void	O
)	O
{	O
int	O
r	pointer
=	O
0	int
,	O
c	int
=	O
0	int
;	O
struct	O
winsize	struct
wind_struct	struct
;	O
do	O
{	O
if	O
(	O
(	O
ioctl	function
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
&	O
wind_struct	struct
)	O
==	O
0	int
)	O
||	O
(	O
ioctl	function
(	O
0	int
,	O
TIOCGWINSZ	int
,	O
&	O
wind_struct	struct
)	O
==	O
0	int
)	O
||	O
(	O
ioctl	function
(	O
2	int
,	O
TIOCGWINSZ	int
,	O
&	O
wind_struct	struct
)	O
==	O
0	int
)	O
)	O
{	O
c	int
=	O
(	O
int	O
)	O
wind_struct	struct
.	O
ws_col	short
;	O
r	pointer
=	O
(	O
int	O
)	O
wind_struct	struct
.	O
ws_row	short
;	O
break	O
;	O
}	O
}	O
while	O
(	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
r	pointer
<=	O
0	int
)	O
{	O
char	O
*	O
s	pointer
=	O
getenv	function
(	O
"LINES"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
r	pointer
=	O
atoi	function
(	O
s	pointer
)	O
;	O
}	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
char	O
*	O
s	pointer
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
c	int
=	O
atoi	function
(	O
s	pointer
)	O
;	O
}	O
if	O
(	O
(	O
r	pointer
<=	O
0	int
)	O
||	O
(	O
r	pointer
>	O
SLTT_MAX_SCREEN_ROWS	int
)	O
)	O
r	pointer
=	O
24	int
;	O
if	O
(	O
(	O
c	int
<=	O
0	int
)	O
||	O
(	O
c	int
>	O
SLTT_MAX_SCREEN_COLS	int
)	O
)	O
c	int
=	O
80	int
;	O
SLtt_Screen_Rows	int
=	O
r	pointer
;	O
SLtt_Screen_Cols	int
=	O
c	int
;	O
}	O
int	O
_pSLtt_get_bce_color_offset	function
(	O
void	O
)	O
{	O
if	O
(	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
||	O
Can_Background_Color_Erase	int
||	O
SLtt_Use_Blink_For_ACS	int
)	O
Bce_Color_Offset	int
=	O
0	int
;	O
else	O
{	O
SLtt_Char_Type	long
fgbg	long
=	O
get_brush_fgbg	function
(	O
0	int
)	O
;	O
if	O
(	O
GET_BG	O
(	O
fgbg	long
)	O
==	O
SLSMG_COLOR_DEFAULT	int
)	O
Bce_Color_Offset	int
=	O
0	int
;	O
else	O
Bce_Color_Offset	int
=	O
1	int
;	O
}	O
return	O
Bce_Color_Offset	int
;	O
}	O
int	O
SLtt_utf8_enable	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
_pSLtt_UTF8_Mode	int
=	O
mode	int
;	O
}	O
int	O
SLtt_is_utf8_mode	function
(	O
void	O
)	O
{	O
int	O
mode	int
=	O
_pSLtt_UTF8_Mode	int
;	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
mode	int
;	O
}	O