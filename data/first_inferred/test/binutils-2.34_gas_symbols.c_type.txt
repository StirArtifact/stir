struct	O
symbol_flags	struct
{	O
unsigned	O
int	O
sy_local_symbol	int
:	O
1	int
;	O
unsigned	O
int	O
sy_written	int
:	O
1	int
;	O
unsigned	O
int	O
sy_resolved	int
:	O
1	int
;	O
unsigned	O
int	O
sy_resolving	int
:	O
1	int
;	O
unsigned	O
int	O
sy_used_in_reloc	int
:	O
1	int
;	O
unsigned	O
int	O
sy_used	int
:	O
1	int
;	O
unsigned	O
int	O
sy_volatile	int
:	O
1	int
;	O
unsigned	O
int	O
sy_forward_ref	int
:	O
1	int
;	O
unsigned	O
int	O
sy_mri_common	int
:	O
1	int
;	O
unsigned	O
int	O
sy_weakrefr	int
:	O
1	int
;	O
unsigned	O
int	O
sy_weakrefd	int
:	O
1	int
;	O
}	O
;	O
struct	O
symbol	pointer
{	O
struct	O
symbol_flags	struct
sy_flags	struct
;	O
asymbol	struct
*	O
bsym	pointer
;	O
expressionS	struct
sy_value	struct
;	O
struct	O
symbol	pointer
*	O
sy_next	pointer
;	O
struct	O
symbol	pointer
*	O
sy_previous	pointer
;	O
struct	O
frag	struct
*	O
sy_frag	pointer
;	O
OBJ_SYMFIELD_TYPE	O
sy_obj	struct
;	O
}	O
;	O
struct	O
local_symbol	struct
{	O
struct	O
symbol_flags	struct
lsy_flags	struct
;	O
segT	pointer
lsy_section	pointer
;	O
const	O
char	O
*	O
lsy_name	pointer
;	O
union	O
{	O
fragS	struct
*	O
lsy_frag	pointer
;	O
symbolS	struct
*	O
lsy_sym	pointer
;	O
}	O
u	union
;	O
valueT	long
lsy_value	long
;	O
}	O
;	O
int	O
symbols_case_sensitive	int
=	O
1	int
;	O
static	O
struct	O
hash_control	O
*	O
sy_hash	pointer
;	O
static	O
struct	O
hash_control	O
*	O
local_hash	pointer
;	O
symbolS	struct
*	O
symbol_rootP	pointer
;	O
symbolS	struct
*	O
symbol_lastP	pointer
;	O
symbolS	struct
abs_symbol	struct
;	O
symbolS	struct
dot_symbol	struct
;	O
struct	O
obstack	struct
notes	struct
;	O
static	O
const	O
char	O
*	O
save_symbol_name	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
fb_label_init	function
(	O
void	O
)	O
;	O
static	O
long	O
dollar_label_instance	function
(	O
long	O
)	O
;	O
static	O
long	O
fb_label_instance	function
(	O
long	O
)	O
;	O
static	O
void	O
print_binary	function
(	O
FILE	struct
*	O
,	O
const	O
char	O
*	O
,	O
expressionS	struct
*	O
)	O
;	O
symbolS	struct
*	O
symbol_new	function
(	O
const	O
char	O
*	O
name	pointer
,	O
segT	pointer
segment	pointer
,	O
valueT	long
valu	long
,	O
fragS	struct
*	O
frag	struct
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
=	O
symbol_create	function
(	O
name	pointer
,	O
segment	pointer
,	O
valu	long
,	O
frag	struct
)	O
;	O
{	O
extern	O
int	O
symbol_table_frozen	int
;	O
if	O
(	O
symbol_table_frozen	int
)	O
abort	function
(	O
)	O
;	O
}	O
symbol_append	function
(	O
symbolP	pointer
,	O
symbol_lastP	pointer
,	O
&	O
symbol_rootP	pointer
,	O
&	O
symbol_lastP	pointer
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
static	O
const	O
char	O
*	O
save_symbol_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
size_t	long
name_length	long
;	O
char	O
*	O
ret	pointer
;	O
gas_assert	O
(	O
name	pointer
!=	O
NULL	O
)	O
;	O
name_length	long
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
obstack_grow	O
(	O
&	O
notes	struct
,	O
name	pointer
,	O
name_length	long
)	O
;	O
ret	pointer
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	struct
)	O
;	O
if	O
(	O
!	O
symbols_case_sensitive	int
)	O
{	O
char	O
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
ret	pointer
;	O
*	O
s	pointer
!=	O
'\0'	O
;	O
s	pointer
++	O
)	O
*	O
s	pointer
=	O
TOUPPER	O
(	O
*	O
s	pointer
)	O
;	O
}	O
return	O
ret	pointer
;	O
}	O
symbolS	struct
*	O
symbol_create	function
(	O
const	O
char	O
*	O
name	pointer
,	O
segT	pointer
segment	pointer
,	O
valueT	long
valu	long
,	O
fragS	struct
*	O
frag	struct
)	O
{	O
const	O
char	O
*	O
preserved_copy_of_name	pointer
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
preserved_copy_of_name	pointer
=	O
save_symbol_name	function
(	O
name	pointer
)	O
;	O
symbolP	pointer
=	O
(	O
symbolS	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
notes	struct
,	O
sizeof	O
(	O
symbolS	struct
)	O
)	O
;	O
memset	function
(	O
symbolP	pointer
,	O
0	int
,	O
sizeof	O
(	O
symbolS	struct
)	O
)	O
;	O
symbolP	pointer
->	O
bsym	pointer
=	O
bfd_make_empty_symbol	O
(	O
stdoutput	pointer
)	O
;	O
if	O
(	O
symbolP	pointer
->	O
bsym	pointer
==	O
NULL	O
)	O
as_fatal	function
(	O
"bfd_make_empty_symbol: %s"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
S_SET_NAME	function
(	O
symbolP	pointer
,	O
preserved_copy_of_name	pointer
)	O
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
segment	pointer
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
valu	long
)	O
;	O
symbol_clear_list_pointers	function
(	O
symbolP	pointer
)	O
;	O
symbolP	pointer
->	O
sy_frag	pointer
=	O
frag	struct
;	O
obj_symbol_new_hook	O
(	O
symbolP	pointer
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
static	O
symbolS	struct
*	O
local_symbol_convert	function
(	O
struct	O
local_symbol	struct
*	O
)	O
;	O
static	O
unsigned	O
long	O
local_symbol_count	long
;	O
static	O
unsigned	O
long	O
local_symbol_conversion_count	long
;	O
struct	O
local_symbol	struct
*	O
local_symbol_make	function
(	O
const	O
char	O
*	O
name	pointer
,	O
segT	pointer
section	pointer
,	O
valueT	long
val	int
,	O
fragS	struct
*	O
frag	struct
)	O
{	O
const	O
char	O
*	O
name_copy	pointer
;	O
struct	O
local_symbol	struct
*	O
ret	pointer
;	O
++	O
local_symbol_count	long
;	O
name_copy	pointer
=	O
save_symbol_name	function
(	O
name	pointer
)	O
;	O
ret	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
notes	struct
,	O
sizeof	O
*	O
ret	pointer
)	O
;	O
ret	pointer
->	O
lsy_flags	struct
.	O
sy_local_symbol	int
=	O
1	int
;	O
ret	pointer
->	O
lsy_flags	struct
.	O
sy_resolved	int
=	O
0	int
;	O
ret	pointer
->	O
lsy_name	pointer
=	O
name_copy	pointer
;	O
ret	pointer
->	O
lsy_section	pointer
=	O
section	pointer
;	O
local_symbol_set_frag	O
(	O
ret	pointer
,	O
frag	struct
)	O
;	O
ret	pointer
->	O
lsy_value	long
=	O
val	int
;	O
hash_jam	function
(	O
local_hash	pointer
,	O
name_copy	pointer
,	O
(	O
void	O
*	O
)	O
ret	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
symbolS	struct
*	O
local_symbol_convert	function
(	O
struct	O
local_symbol	struct
*	O
locsym	pointer
)	O
{	O
symbolS	struct
*	O
ret	pointer
;	O
gas_assert	O
(	O
locsym	pointer
->	O
lsy_flags	struct
.	O
sy_local_symbol	int
)	O
;	O
if	O
(	O
local_symbol_converted_p	O
(	O
locsym	pointer
)	O
)	O
return	O
local_symbol_get_real_symbol	O
(	O
locsym	pointer
)	O
;	O
++	O
local_symbol_conversion_count	long
;	O
ret	pointer
=	O
symbol_new	function
(	O
locsym	pointer
->	O
lsy_name	pointer
,	O
locsym	pointer
->	O
lsy_section	pointer
,	O
locsym	pointer
->	O
lsy_value	long
,	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
)	O
;	O
if	O
(	O
local_symbol_resolved_p	O
(	O
locsym	pointer
)	O
)	O
ret	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
=	O
1	int
;	O
ret	pointer
->	O
sy_flags	struct
.	O
sy_used	int
=	O
1	int
;	O
symbol_table_insert	function
(	O
ret	pointer
)	O
;	O
local_symbol_mark_converted	O
(	O
locsym	pointer
)	O
;	O
local_symbol_set_real_symbol	O
(	O
locsym	pointer
,	O
ret	pointer
)	O
;	O
hash_jam	function
(	O
local_hash	pointer
,	O
locsym	pointer
->	O
lsy_name	pointer
,	O
NULL	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
define_sym_at_dot	function
(	O
symbolS	struct
*	O
symbolP	pointer
)	O
{	O
symbolP	pointer
->	O
sy_frag	pointer
=	O
frag_now	pointer
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
(	O
valueT	long
)	O
frag_now_fix	function
(	O
)	O
)	O
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
now_seg	pointer
)	O
;	O
}	O
symbolS	struct
*	O
colon	function
(	O
const	O
char	O
*	O
sym_name	pointer
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
;	O
if	O
(	O
LOCAL_LABELS_DOLLAR	int
&&	O
!	O
bfd_is_local_label_name	function
(	O
stdoutput	pointer
,	O
sym_name	pointer
)	O
)	O
dollar_label_clear	function
(	O
)	O
;	O
if	O
(	O
(	O
symbolP	pointer
=	O
symbol_find	function
(	O
sym_name	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
S_CLEAR_WEAKREFR	function
(	O
symbolP	pointer
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
{	O
struct	O
local_symbol	struct
*	O
locsym	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
symbolP	pointer
;	O
if	O
(	O
locsym	pointer
->	O
lsy_section	pointer
!=	O
undefined_section	O
&&	O
(	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
!=	O
frag_now	pointer
||	O
locsym	pointer
->	O
lsy_section	pointer
!=	O
now_seg	pointer
||	O
locsym	pointer
->	O
lsy_value	long
!=	O
frag_now_fix	function
(	O
)	O
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
sym_name	pointer
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
locsym	pointer
->	O
lsy_section	pointer
=	O
now_seg	pointer
;	O
local_symbol_set_frag	O
(	O
locsym	pointer
,	O
frag_now	pointer
)	O
;	O
locsym	pointer
->	O
lsy_value	long
=	O
frag_now_fix	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
||	O
symbol_equated_p	function
(	O
symbolP	pointer
)	O
)	O
||	O
S_IS_COMMON	function
(	O
symbolP	pointer
)	O
||	O
S_IS_VOLATILE	function
(	O
symbolP	pointer
)	O
)	O
{	O
if	O
(	O
S_IS_VOLATILE	function
(	O
symbolP	pointer
)	O
)	O
{	O
symbolP	pointer
=	O
symbol_clone	function
(	O
symbolP	pointer
,	O
1	int
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
0	int
)	O
;	O
S_CLEAR_VOLATILE	function
(	O
symbolP	pointer
)	O
;	O
}	O
if	O
(	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
==	O
0	int
)	O
{	O
define_sym_at_dot	function
(	O
symbolP	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
(	O
!	O
S_IS_DEBUG	function
(	O
symbolP	pointer
)	O
&&	O
(	O
!	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
||	O
S_IS_COMMON	function
(	O
symbolP	pointer
)	O
)	O
&&	O
S_IS_EXTERNAL	function
(	O
symbolP	pointer
)	O
)	O
||	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
bss_section	pointer
)	O
&&	O
(	O
now_seg	pointer
==	O
data_section	pointer
||	O
now_seg	pointer
==	O
bss_section	pointer
||	O
now_seg	pointer
==	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
)	O
)	O
{	O
if	O
(	O
now_seg	pointer
!=	O
data_section	pointer
)	O
{	O
if	O
(	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
<	O
(	O
(	O
unsigned	O
)	O
frag_now_fix	function
(	O
)	O
)	O
)	O
{	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
(	O
valueT	long
)	O
frag_now_fix	function
(	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
define_sym_at_dot	function
(	O
symbolP	pointer
)	O
;	O
}	O
}	O
else	O
{	O
static	O
const	O
char	O
*	O
od_buf	pointer
=	O
""	pointer
;	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined as \"%s\"/%s%ld"	pointer
)	O
,	O
sym_name	pointer
,	O
segment_name	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
)	O
,	O
od_buf	pointer
,	O
(	O
long	O
)	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
frag_now	pointer
==	O
symbolP	pointer
->	O
sy_frag	pointer
&&	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
==	O
frag_now_fix	function
(	O
)	O
&&	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
now_seg	pointer
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
sym_name	pointer
)	O
;	O
symbolP	pointer
=	O
symbol_clone	function
(	O
symbolP	pointer
,	O
0	int
)	O
;	O
define_sym_at_dot	function
(	O
symbolP	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
!	O
flag_keep_locals	int
&&	O
bfd_is_local_label_name	function
(	O
stdoutput	pointer
,	O
sym_name	pointer
)	O
)	O
{	O
symbolP	pointer
=	O
(	O
symbolS	struct
*	O
)	O
local_symbol_make	function
(	O
sym_name	pointer
,	O
now_seg	pointer
,	O
(	O
valueT	long
)	O
frag_now_fix	function
(	O
)	O
,	O
frag_now	pointer
)	O
;	O
}	O
else	O
{	O
symbolP	pointer
=	O
symbol_new	function
(	O
sym_name	pointer
,	O
now_seg	pointer
,	O
(	O
valueT	long
)	O
frag_now_fix	function
(	O
)	O
,	O
frag_now	pointer
)	O
;	O
symbol_table_insert	function
(	O
symbolP	pointer
)	O
;	O
}	O
if	O
(	O
mri_common_symbol	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
symbolP	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
symbolP	pointer
)	O
;	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_op	enum
=	O
O_symbol	int
;	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
=	O
mri_common_symbol	pointer
;	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_add_number	long
=	O
S_GET_VALUE	function
(	O
mri_common_symbol	pointer
)	O
;	O
symbolP	pointer
->	O
sy_frag	pointer
=	O
&	O
zero_address_frag	struct
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
expr_section	pointer
)	O
;	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_mri_common	int
=	O
1	int
;	O
}	O
obj_frob_label	O
(	O
symbolP	pointer
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
void	O
symbol_table_insert	function
(	O
symbolS	struct
*	O
symbolP	pointer
)	O
{	O
const	O
char	O
*	O
error_string	pointer
;	O
know	O
(	O
symbolP	pointer
)	O
;	O
know	O
(	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
{	O
error_string	pointer
=	O
hash_jam	function
(	O
local_hash	pointer
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
(	O
void	O
*	O
)	O
symbolP	pointer
)	O
;	O
if	O
(	O
error_string	pointer
!=	O
NULL	O
)	O
as_fatal	function
(	O
_	O
(	O
"inserting \"%s\" into symbol table failed: %s"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
error_string	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
error_string	pointer
=	O
hash_jam	function
(	O
sy_hash	pointer
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
(	O
void	O
*	O
)	O
symbolP	pointer
)	O
)	O
)	O
{	O
as_fatal	function
(	O
_	O
(	O
"inserting \"%s\" into symbol table failed: %s"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
error_string	pointer
)	O
;	O
}	O
}	O
symbolS	struct
*	O
symbol_find_or_make	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
;	O
symbolP	pointer
=	O
symbol_find	function
(	O
name	pointer
)	O
;	O
if	O
(	O
symbolP	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
flag_keep_locals	int
&&	O
bfd_is_local_label_name	function
(	O
stdoutput	pointer
,	O
name	pointer
)	O
)	O
{	O
symbolP	pointer
=	O
md_undefined_symbol	function
(	O
(	O
char	O
*	O
)	O
name	pointer
)	O
;	O
if	O
(	O
symbolP	pointer
!=	O
NULL	O
)	O
return	O
symbolP	pointer
;	O
symbolP	pointer
=	O
(	O
symbolS	struct
*	O
)	O
local_symbol_make	function
(	O
name	pointer
,	O
undefined_section	O
,	O
(	O
valueT	long
)	O
0	int
,	O
&	O
zero_address_frag	struct
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
symbolP	pointer
=	O
symbol_make	function
(	O
name	pointer
)	O
;	O
symbol_table_insert	function
(	O
symbolP	pointer
)	O
;	O
}	O
return	O
(	O
symbolP	pointer
)	O
;	O
}	O
symbolS	struct
*	O
symbol_make	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
;	O
symbolP	pointer
=	O
md_undefined_symbol	function
(	O
(	O
char	O
*	O
)	O
name	pointer
)	O
;	O
if	O
(	O
!	O
symbolP	pointer
)	O
symbolP	pointer
=	O
symbol_new	function
(	O
name	pointer
,	O
undefined_section	O
,	O
(	O
valueT	long
)	O
0	int
,	O
&	O
zero_address_frag	struct
)	O
;	O
return	O
(	O
symbolP	pointer
)	O
;	O
}	O
symbolS	struct
*	O
symbol_clone	function
(	O
symbolS	struct
*	O
orgsymP	pointer
,	O
int	O
replace	int
)	O
{	O
symbolS	struct
*	O
newsymP	pointer
;	O
asymbol	struct
*	O
bsymorg	pointer
,	O
*	O
bsymnew	pointer
;	O
gas_assert	O
(	O
orgsymP	pointer
!=	O
&	O
dot_symbol	struct
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
orgsymP	pointer
)	O
)	O
orgsymP	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
orgsymP	pointer
)	O
;	O
bsymorg	pointer
=	O
orgsymP	pointer
->	O
bsym	pointer
;	O
newsymP	pointer
=	O
(	O
symbolS	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
notes	struct
,	O
sizeof	O
(	O
*	O
newsymP	pointer
)	O
)	O
;	O
*	O
newsymP	pointer
=	O
*	O
orgsymP	pointer
;	O
bsymnew	pointer
=	O
bfd_make_empty_symbol	O
(	O
bfd_asymbol_bfd	function
(	O
bsymorg	pointer
)	O
)	O
;	O
if	O
(	O
bsymnew	pointer
==	O
NULL	O
)	O
as_fatal	function
(	O
"bfd_make_empty_symbol: %s"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
newsymP	pointer
->	O
bsym	pointer
=	O
bsymnew	pointer
;	O
bsymnew	pointer
->	O
name	pointer
=	O
bsymorg	pointer
->	O
name	pointer
;	O
bsymnew	pointer
->	O
flags	int
=	O
bsymorg	pointer
->	O
flags	int
&	O
~	O
BSF_SECTION_SYM	O
;	O
bsymnew	pointer
->	O
section	pointer
=	O
bsymorg	pointer
->	O
section	pointer
;	O
bfd_copy_private_symbol_data	function
(	O
bfd_asymbol_bfd	function
(	O
bsymorg	pointer
)	O
,	O
bsymorg	pointer
,	O
bfd_asymbol_bfd	function
(	O
bsymnew	pointer
)	O
,	O
bsymnew	pointer
)	O
;	O
if	O
(	O
replace	int
)	O
{	O
if	O
(	O
symbol_rootP	pointer
==	O
orgsymP	pointer
)	O
symbol_rootP	pointer
=	O
newsymP	pointer
;	O
else	O
if	O
(	O
orgsymP	pointer
->	O
sy_previous	pointer
)	O
{	O
orgsymP	pointer
->	O
sy_previous	pointer
->	O
sy_next	pointer
=	O
newsymP	pointer
;	O
orgsymP	pointer
->	O
sy_previous	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
symbol_lastP	pointer
==	O
orgsymP	pointer
)	O
symbol_lastP	pointer
=	O
newsymP	pointer
;	O
else	O
if	O
(	O
orgsymP	pointer
->	O
sy_next	pointer
)	O
orgsymP	pointer
->	O
sy_next	pointer
->	O
sy_previous	pointer
=	O
newsymP	pointer
;	O
S_CLEAR_EXTERNAL	function
(	O
orgsymP	pointer
)	O
;	O
orgsymP	pointer
->	O
sy_previous	pointer
=	O
orgsymP	pointer
->	O
sy_next	pointer
=	O
orgsymP	pointer
;	O
debug_verify_symchain	O
(	O
symbol_rootP	pointer
,	O
symbol_lastP	pointer
)	O
;	O
symbol_table_insert	function
(	O
newsymP	pointer
)	O
;	O
}	O
else	O
{	O
S_CLEAR_EXTERNAL	function
(	O
newsymP	pointer
)	O
;	O
newsymP	pointer
->	O
sy_previous	pointer
=	O
newsymP	pointer
->	O
sy_next	pointer
=	O
newsymP	pointer
;	O
}	O
return	O
newsymP	pointer
;	O
}	O
static	O
inline	O
symbolS	struct
*	O
get_real_sym	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
sy_flags	struct
.	O
sy_local_symbol	int
&&	O
local_symbol_converted_p	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_get_real_symbol	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
symbolS	struct
*	O
symbol_clone_if_forward_ref	function
(	O
symbolS	struct
*	O
symbolP	pointer
,	O
int	O
is_forward	int
)	O
{	O
if	O
(	O
symbolP	pointer
&&	O
!	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
{	O
symbolS	struct
*	O
orig_add_symbol	pointer
=	O
get_real_sym	function
(	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
)	O
;	O
symbolS	struct
*	O
orig_op_symbol	pointer
=	O
get_real_sym	function
(	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_op_symbol	pointer
)	O
;	O
symbolS	struct
*	O
add_symbol	pointer
=	O
orig_add_symbol	pointer
;	O
symbolS	struct
*	O
op_symbol	pointer
=	O
orig_op_symbol	pointer
;	O
if	O
(	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_forward_ref	int
)	O
is_forward	int
=	O
1	int
;	O
if	O
(	O
is_forward	int
)	O
{	O
if	O
(	O
add_symbol	pointer
&&	O
S_IS_VOLATILE	function
(	O
add_symbol	pointer
)	O
)	O
add_symbol	pointer
=	O
symbol_find_exact	function
(	O
S_GET_NAME	function
(	O
add_symbol	pointer
)	O
)	O
;	O
if	O
(	O
op_symbol	pointer
&&	O
S_IS_VOLATILE	function
(	O
op_symbol	pointer
)	O
)	O
op_symbol	pointer
=	O
symbol_find_exact	function
(	O
S_GET_NAME	function
(	O
op_symbol	pointer
)	O
)	O
;	O
}	O
if	O
(	O
(	O
symbolP	pointer
->	O
bsym	pointer
->	O
section	pointer
==	O
expr_section	pointer
||	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_forward_ref	int
)	O
&&	O
!	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
)	O
{	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
1	int
;	O
add_symbol	pointer
=	O
symbol_clone_if_forward_ref	function
(	O
add_symbol	pointer
,	O
is_forward	int
)	O
;	O
op_symbol	pointer
=	O
symbol_clone_if_forward_ref	function
(	O
op_symbol	pointer
,	O
is_forward	int
)	O
;	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
0	int
;	O
}	O
if	O
(	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_forward_ref	int
||	O
add_symbol	pointer
!=	O
orig_add_symbol	pointer
||	O
op_symbol	pointer
!=	O
orig_op_symbol	pointer
)	O
{	O
if	O
(	O
symbolP	pointer
!=	O
&	O
dot_symbol	struct
)	O
{	O
symbolP	pointer
=	O
symbol_clone	function
(	O
symbolP	pointer
,	O
0	int
)	O
;	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
0	int
;	O
}	O
else	O
{	O
symbolP	pointer
=	O
symbol_temp_new_now	function
(	O
)	O
;	O
}	O
}	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
=	O
add_symbol	pointer
;	O
symbolP	pointer
->	O
sy_value	struct
.	O
X_op_symbol	pointer
=	O
op_symbol	pointer
;	O
}	O
return	O
symbolP	pointer
;	O
}	O
symbolS	struct
*	O
symbol_temp_new	function
(	O
segT	pointer
seg	pointer
,	O
valueT	long
ofs	long
,	O
fragS	struct
*	O
frag	struct
)	O
{	O
return	O
symbol_new	function
(	O
FAKE_LABEL_NAME	pointer
,	O
seg	pointer
,	O
ofs	long
,	O
frag	struct
)	O
;	O
}	O
symbolS	struct
*	O
symbol_temp_new_now	function
(	O
void	O
)	O
{	O
return	O
symbol_temp_new	function
(	O
now_seg	pointer
,	O
frag_now_fix	function
(	O
)	O
,	O
frag_now	pointer
)	O
;	O
}	O
symbolS	struct
*	O
symbol_temp_new_now_octets	function
(	O
void	O
)	O
{	O
return	O
symbol_temp_new	function
(	O
now_seg	pointer
,	O
frag_now_fix_octets	function
(	O
)	O
,	O
frag_now	pointer
)	O
;	O
}	O
symbolS	struct
*	O
symbol_temp_make	function
(	O
void	O
)	O
{	O
return	O
symbol_make	function
(	O
FAKE_LABEL_NAME	pointer
)	O
;	O
}	O
symbolS	struct
*	O
symbol_find_exact	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
symbol_find_exact_noref	function
(	O
name	pointer
,	O
0	int
)	O
;	O
}	O
symbolS	struct
*	O
symbol_find_exact_noref	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
noref	int
)	O
{	O
struct	O
local_symbol	struct
*	O
locsym	pointer
;	O
symbolS	struct
*	O
sym	pointer
;	O
locsym	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
hash_find	function
(	O
local_hash	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
locsym	pointer
!=	O
NULL	O
)	O
return	O
(	O
symbolS	struct
*	O
)	O
locsym	pointer
;	O
sym	pointer
=	O
(	O
(	O
symbolS	struct
*	O
)	O
hash_find	function
(	O
sy_hash	pointer
,	O
name	pointer
)	O
)	O
;	O
if	O
(	O
sym	pointer
&&	O
!	O
noref	int
)	O
S_CLEAR_WEAKREFD	function
(	O
sym	pointer
)	O
;	O
return	O
sym	pointer
;	O
}	O
symbolS	struct
*	O
symbol_find	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
symbol_find_noref	function
(	O
name	pointer
,	O
0	int
)	O
;	O
}	O
symbolS	struct
*	O
symbol_find_noref	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
noref	int
)	O
{	O
symbolS	struct
*	O
result	pointer
;	O
char	O
*	O
copy	int
=	O
NULL	O
;	O
if	O
(	O
!	O
symbols_case_sensitive	int
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
char	O
*	O
copy2	pointer
=	O
NULL	O
;	O
unsigned	O
char	O
c	struct
;	O
orig	pointer
=	O
name	pointer
;	O
if	O
(	O
copy	int
!=	O
NULL	O
)	O
copy2	pointer
=	O
copy	int
;	O
name	pointer
=	O
copy	int
=	O
XNEWVEC	O
(	O
char	O
,	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
while	O
(	O
(	O
c	struct
=	O
*	O
orig	pointer
++	O
)	O
!=	O
'\0'	O
)	O
*	O
copy	int
++	O
=	O
TOUPPER	O
(	O
c	struct
)	O
;	O
*	O
copy	int
=	O
'\0'	O
;	O
if	O
(	O
copy2	pointer
!=	O
NULL	O
)	O
free	function
(	O
copy2	pointer
)	O
;	O
copy	int
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
}	O
result	pointer
=	O
symbol_find_exact_noref	function
(	O
name	pointer
,	O
noref	int
)	O
;	O
if	O
(	O
copy	int
!=	O
NULL	O
)	O
free	function
(	O
copy	int
)	O
;	O
return	O
result	pointer
;	O
}	O
void	O
symbol_append	function
(	O
symbolS	struct
*	O
addme	pointer
,	O
symbolS	struct
*	O
target	pointer
,	O
symbolS	struct
*	O
*	O
rootPP	pointer
,	O
symbolS	struct
*	O
*	O
lastPP	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
addme	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
&&	O
LOCAL_SYMBOL_CHECK	O
(	O
target	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
target	pointer
==	O
NULL	O
)	O
{	O
know	O
(	O
*	O
rootPP	pointer
==	O
NULL	O
)	O
;	O
know	O
(	O
*	O
lastPP	pointer
==	O
NULL	O
)	O
;	O
addme	pointer
->	O
sy_next	pointer
=	O
NULL	O
;	O
addme	pointer
->	O
sy_previous	pointer
=	O
NULL	O
;	O
*	O
rootPP	pointer
=	O
addme	pointer
;	O
*	O
lastPP	pointer
=	O
addme	pointer
;	O
return	O
;	O
}	O
if	O
(	O
target	pointer
->	O
sy_next	pointer
!=	O
NULL	O
)	O
{	O
target	pointer
->	O
sy_next	pointer
->	O
sy_previous	pointer
=	O
addme	pointer
;	O
}	O
else	O
{	O
know	O
(	O
*	O
lastPP	pointer
==	O
target	pointer
)	O
;	O
*	O
lastPP	pointer
=	O
addme	pointer
;	O
}	O
addme	pointer
->	O
sy_next	pointer
=	O
target	pointer
->	O
sy_next	pointer
;	O
target	pointer
->	O
sy_next	pointer
=	O
addme	pointer
;	O
addme	pointer
->	O
sy_previous	pointer
=	O
target	pointer
;	O
debug_verify_symchain	O
(	O
symbol_rootP	pointer
,	O
symbol_lastP	pointer
)	O
;	O
}	O
void	O
symbol_clear_list_pointers	function
(	O
symbolS	struct
*	O
symbolP	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
symbolP	pointer
->	O
sy_next	pointer
=	O
NULL	O
;	O
symbolP	pointer
->	O
sy_previous	pointer
=	O
NULL	O
;	O
}	O
void	O
symbol_remove	function
(	O
symbolS	struct
*	O
symbolP	pointer
,	O
symbolS	struct
*	O
*	O
rootPP	pointer
,	O
symbolS	struct
*	O
*	O
lastPP	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
symbolP	pointer
==	O
*	O
rootPP	pointer
)	O
{	O
*	O
rootPP	pointer
=	O
symbolP	pointer
->	O
sy_next	pointer
;	O
}	O
if	O
(	O
symbolP	pointer
==	O
*	O
lastPP	pointer
)	O
{	O
*	O
lastPP	pointer
=	O
symbolP	pointer
->	O
sy_previous	pointer
;	O
}	O
if	O
(	O
symbolP	pointer
->	O
sy_next	pointer
!=	O
NULL	O
)	O
{	O
symbolP	pointer
->	O
sy_next	pointer
->	O
sy_previous	pointer
=	O
symbolP	pointer
->	O
sy_previous	pointer
;	O
}	O
if	O
(	O
symbolP	pointer
->	O
sy_previous	pointer
!=	O
NULL	O
)	O
{	O
symbolP	pointer
->	O
sy_previous	pointer
->	O
sy_next	pointer
=	O
symbolP	pointer
->	O
sy_next	pointer
;	O
}	O
debug_verify_symchain	O
(	O
*	O
rootPP	pointer
,	O
*	O
lastPP	pointer
)	O
;	O
}	O
void	O
symbol_insert	function
(	O
symbolS	struct
*	O
addme	pointer
,	O
symbolS	struct
*	O
target	pointer
,	O
symbolS	struct
*	O
*	O
rootPP	pointer
,	O
symbolS	struct
*	O
*	O
lastPP	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
addme	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
target	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
target	pointer
->	O
sy_previous	pointer
!=	O
NULL	O
)	O
{	O
target	pointer
->	O
sy_previous	pointer
->	O
sy_next	pointer
=	O
addme	pointer
;	O
}	O
else	O
{	O
know	O
(	O
*	O
rootPP	pointer
==	O
target	pointer
)	O
;	O
*	O
rootPP	pointer
=	O
addme	pointer
;	O
}	O
addme	pointer
->	O
sy_previous	pointer
=	O
target	pointer
->	O
sy_previous	pointer
;	O
target	pointer
->	O
sy_previous	pointer
=	O
addme	pointer
;	O
addme	pointer
->	O
sy_next	pointer
=	O
target	pointer
;	O
debug_verify_symchain	O
(	O
*	O
rootPP	pointer
,	O
*	O
lastPP	pointer
)	O
;	O
}	O
void	O
verify_symbol_chain	function
(	O
symbolS	struct
*	O
rootP	pointer
,	O
symbolS	struct
*	O
lastP	pointer
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
=	O
rootP	pointer
;	O
if	O
(	O
symbolP	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
;	O
symbol_next	function
(	O
symbolP	pointer
)	O
!=	O
NULL	O
;	O
symbolP	pointer
=	O
symbol_next	function
(	O
symbolP	pointer
)	O
)	O
{	O
gas_assert	O
(	O
symbolP	pointer
->	O
bsym	pointer
!=	O
NULL	O
)	O
;	O
gas_assert	O
(	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_local_symbol	int
==	O
0	int
)	O
;	O
gas_assert	O
(	O
symbolP	pointer
->	O
sy_next	pointer
->	O
sy_previous	pointer
==	O
symbolP	pointer
)	O
;	O
}	O
gas_assert	O
(	O
lastP	pointer
==	O
symbolP	pointer
)	O
;	O
}	O
int	O
symbol_on_chain	function
(	O
symbolS	struct
*	O
s	pointer
,	O
symbolS	struct
*	O
rootPP	pointer
,	O
symbolS	struct
*	O
lastPP	pointer
)	O
{	O
return	O
(	O
!	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
&&	O
(	O
(	O
s	pointer
->	O
sy_next	pointer
!=	O
s	pointer
&&	O
s	pointer
->	O
sy_next	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
sy_next	pointer
->	O
sy_previous	pointer
==	O
s	pointer
)	O
||	O
s	pointer
==	O
lastPP	pointer
)	O
&&	O
(	O
(	O
s	pointer
->	O
sy_previous	pointer
!=	O
s	pointer
&&	O
s	pointer
->	O
sy_previous	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
sy_previous	pointer
->	O
sy_next	pointer
==	O
s	pointer
)	O
||	O
s	pointer
==	O
rootPP	pointer
)	O
)	O
;	O
}	O
static	O
void	O
report_op_error	function
(	O
symbolS	struct
*	O
symp	pointer
,	O
symbolS	struct
*	O
left	pointer
,	O
operatorT	enum
op	enum
,	O
symbolS	struct
*	O
right	pointer
)	O
{	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
segT	pointer
seg_left	pointer
=	O
left	pointer
?	O
S_GET_SEGMENT	function
(	O
left	pointer
)	O
:	O
0	int
;	O
segT	pointer
seg_right	pointer
=	O
S_GET_SEGMENT	function
(	O
right	pointer
)	O
;	O
const	O
char	O
*	O
opname	pointer
;	O
switch	O
(	O
op	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
return	O
;	O
case	O
O_uminus	int
:	O
opname	pointer
=	O
"-"	pointer
;	O
break	O
;	O
case	O
O_bit_not	int
:	O
opname	pointer
=	O
"~"	pointer
;	O
break	O
;	O
case	O
O_logical_not	int
:	O
opname	pointer
=	O
"!"	pointer
;	O
break	O
;	O
case	O
O_multiply	int
:	O
opname	pointer
=	O
"*"	pointer
;	O
break	O
;	O
case	O
O_divide	int
:	O
opname	pointer
=	O
"/"	pointer
;	O
break	O
;	O
case	O
O_modulus	int
:	O
opname	pointer
=	O
"%"	pointer
;	O
break	O
;	O
case	O
O_left_shift	int
:	O
opname	pointer
=	O
"<<"	pointer
;	O
break	O
;	O
case	O
O_right_shift	int
:	O
opname	pointer
=	O
">>"	pointer
;	O
break	O
;	O
case	O
O_bit_inclusive_or	int
:	O
opname	pointer
=	O
"|"	pointer
;	O
break	O
;	O
case	O
O_bit_or_not	int
:	O
opname	pointer
=	O
"|~"	pointer
;	O
break	O
;	O
case	O
O_bit_exclusive_or	int
:	O
opname	pointer
=	O
"^"	pointer
;	O
break	O
;	O
case	O
O_bit_and	int
:	O
opname	pointer
=	O
"&"	pointer
;	O
break	O
;	O
case	O
O_add	int
:	O
opname	pointer
=	O
"+"	pointer
;	O
break	O
;	O
case	O
O_subtract	int
:	O
opname	pointer
=	O
"-"	pointer
;	O
break	O
;	O
case	O
O_eq	int
:	O
opname	pointer
=	O
"=="	pointer
;	O
break	O
;	O
case	O
O_ne	int
:	O
opname	pointer
=	O
"!="	pointer
;	O
break	O
;	O
case	O
O_lt	int
:	O
opname	pointer
=	O
"<"	pointer
;	O
break	O
;	O
case	O
O_le	int
:	O
opname	pointer
=	O
"<="	pointer
;	O
break	O
;	O
case	O
O_ge	int
:	O
opname	pointer
=	O
">="	pointer
;	O
break	O
;	O
case	O
O_gt	int
:	O
opname	pointer
=	O
">"	pointer
;	O
break	O
;	O
case	O
O_logical_and	int
:	O
opname	pointer
=	O
"&&"	pointer
;	O
break	O
;	O
case	O
O_logical_or	int
:	O
opname	pointer
=	O
"||"	pointer
;	O
break	O
;	O
}	O
if	O
(	O
expr_symbol_where	function
(	O
symp	pointer
,	O
&	O
file	pointer
,	O
&	O
line	int
)	O
)	O
{	O
if	O
(	O
left	pointer
)	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"invalid operands (%s and %s sections) for `%s'"	pointer
)	O
,	O
seg_left	pointer
->	O
name	pointer
,	O
seg_right	pointer
->	O
name	pointer
,	O
opname	pointer
)	O
;	O
else	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"invalid operand (%s section) for `%s'"	pointer
)	O
,	O
seg_right	pointer
->	O
name	pointer
,	O
opname	pointer
)	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
S_GET_NAME	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
left	pointer
)	O
as_bad	function
(	O
_	O
(	O
"invalid operands (%s and %s sections) for `%s' when setting `%s'"	pointer
)	O
,	O
seg_left	pointer
->	O
name	pointer
,	O
seg_right	pointer
->	O
name	pointer
,	O
opname	pointer
,	O
sname	pointer
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"invalid operand (%s section) for `%s' when setting `%s'"	pointer
)	O
,	O
seg_right	pointer
->	O
name	pointer
,	O
opname	pointer
,	O
sname	pointer
)	O
;	O
}	O
}	O
valueT	long
resolve_symbol_value	function
(	O
symbolS	struct
*	O
symp	pointer
)	O
{	O
int	O
resolved	int
;	O
valueT	long
final_val	long
;	O
segT	pointer
final_seg	pointer
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symp	pointer
)	O
)	O
{	O
struct	O
local_symbol	struct
*	O
locsym	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
symp	pointer
;	O
final_val	long
=	O
locsym	pointer
->	O
lsy_value	long
;	O
if	O
(	O
local_symbol_resolved_p	O
(	O
locsym	pointer
)	O
)	O
return	O
final_val	long
;	O
if	O
(	O
locsym	pointer
->	O
lsy_section	pointer
->	O
flags	int
&	O
SEC_OCTETS	O
)	O
final_val	long
+=	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
->	O
fr_address	long
;	O
else	O
final_val	long
+=	O
(	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
->	O
fr_address	long
/	O
OCTETS_PER_BYTE	O
)	O
;	O
if	O
(	O
finalize_syms	int
)	O
{	O
locsym	pointer
->	O
lsy_value	long
=	O
final_val	long
;	O
local_symbol_mark_resolved	O
(	O
locsym	pointer
)	O
;	O
}	O
return	O
final_val	long
;	O
}	O
if	O
(	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
)	O
{	O
final_val	long
=	O
0	int
;	O
while	O
(	O
symp	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_symbol	int
&&	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
)	O
{	O
final_val	long
+=	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_number	long
;	O
symp	pointer
=	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
;	O
}	O
if	O
(	O
symp	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_constant	int
)	O
final_val	long
+=	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_number	long
;	O
else	O
final_val	long
=	O
0	int
;	O
return	O
final_val	long
;	O
}	O
resolved	int
=	O
0	int
;	O
final_seg	pointer
=	O
S_GET_SEGMENT	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
)	O
{	O
if	O
(	O
finalize_syms	int
)	O
as_bad	function
(	O
_	O
(	O
"symbol definition loop encountered at `%s'"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symp	pointer
)	O
)	O
;	O
final_val	long
=	O
0	int
;	O
resolved	int
=	O
1	int
;	O
}	O
else	O
{	O
symbolS	struct
*	O
add_symbol	pointer
,	O
*	O
op_symbol	pointer
;	O
offsetT	long
left	pointer
,	O
right	pointer
;	O
segT	pointer
seg_left	pointer
,	O
seg_right	pointer
;	O
operatorT	enum
op	enum
;	O
int	O
move_seg_ok	int
;	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
1	int
;	O
add_symbol	pointer
=	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
;	O
op_symbol	pointer
=	O
symp	pointer
->	O
sy_value	struct
.	O
X_op_symbol	pointer
;	O
final_val	long
=	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_number	long
;	O
op	enum
=	O
symp	pointer
->	O
sy_value	struct
.	O
X_op	enum
;	O
switch	O
(	O
op	enum
)	O
{	O
default	O
:	O
BAD_CASE	O
(	O
op	enum
)	O
;	O
break	O
;	O
case	O
O_absent	int
:	O
final_val	long
=	O
0	int
;	O
case	O
O_constant	int
:	O
if	O
(	O
symp	pointer
->	O
bsym	pointer
->	O
section	pointer
->	O
flags	int
&	O
SEC_OCTETS	O
)	O
final_val	long
+=	O
symp	pointer
->	O
sy_frag	pointer
->	O
fr_address	long
;	O
else	O
final_val	long
+=	O
symp	pointer
->	O
sy_frag	pointer
->	O
fr_address	long
/	O
OCTETS_PER_BYTE	O
;	O
if	O
(	O
final_seg	pointer
==	O
expr_section	pointer
)	O
final_seg	pointer
=	O
absolute_section	O
;	O
case	O
O_register	int
:	O
resolved	int
=	O
1	int
;	O
break	O
;	O
case	O
O_symbol	int
:	O
case	O
O_symbol_rva	int
:	O
left	pointer
=	O
resolve_symbol_value	function
(	O
add_symbol	pointer
)	O
;	O
seg_left	pointer
=	O
S_GET_SEGMENT	function
(	O
add_symbol	pointer
)	O
;	O
if	O
(	O
finalize_syms	int
)	O
symp	pointer
->	O
sy_value	struct
.	O
X_op_symbol	pointer
=	O
NULL	O
;	O
do_symbol	O
:	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
symp	pointer
)	O
)	O
{	O
gas_assert	O
(	O
final_val	long
==	O
0	int
)	O
;	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
add_symbol	pointer
)	O
)	O
{	O
gas_assert	O
(	O
add_symbol	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_symbol	int
&&	O
add_symbol	pointer
->	O
sy_value	struct
.	O
X_add_number	long
==	O
0	int
)	O
;	O
add_symbol	pointer
=	O
add_symbol	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
;	O
gas_assert	O
(	O
!	O
S_IS_WEAKREFR	function
(	O
add_symbol	pointer
)	O
)	O
;	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
=	O
add_symbol	pointer
;	O
}	O
}	O
if	O
(	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_mri_common	int
)	O
{	O
resolved	int
=	O
symbol_resolved_p	function
(	O
add_symbol	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
finalize_syms	int
&&	O
final_val	long
==	O
0	int
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
add_symbol	pointer
)	O
)	O
add_symbol	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
add_symbol	pointer
)	O
;	O
copy_symbol_attributes	function
(	O
symp	pointer
,	O
add_symbol	pointer
)	O
;	O
}	O
if	O
(	O
seg_left	pointer
==	O
undefined_section	O
||	O
bfd_is_com_section	function
(	O
seg_left	pointer
)	O
||	O
(	O
finalize_syms	int
&&	O
(	O
(	O
final_seg	pointer
==	O
expr_section	pointer
&&	O
seg_left	pointer
!=	O
expr_section	pointer
&&	O
seg_left	pointer
!=	O
absolute_section	O
)	O
||	O
symbol_shadow_p	function
(	O
symp	pointer
)	O
)	O
)	O
)	O
{	O
if	O
(	O
finalize_syms	int
)	O
{	O
symp	pointer
->	O
sy_value	struct
.	O
X_op	enum
=	O
O_symbol	int
;	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
=	O
add_symbol	pointer
;	O
symp	pointer
->	O
sy_value	struct
.	O
X_add_number	long
=	O
final_val	long
;	O
symp	pointer
->	O
sy_value	struct
.	O
X_op_symbol	pointer
=	O
add_symbol	pointer
;	O
}	O
final_seg	pointer
=	O
seg_left	pointer
;	O
final_val	long
+=	O
symp	pointer
->	O
sy_frag	pointer
->	O
fr_address	long
+	O
left	pointer
;	O
resolved	int
=	O
symbol_resolved_p	function
(	O
add_symbol	pointer
)	O
;	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
0	int
;	O
goto	O
exit_dont_set_value	O
;	O
}	O
else	O
{	O
final_val	long
+=	O
symp	pointer
->	O
sy_frag	pointer
->	O
fr_address	long
+	O
left	pointer
;	O
if	O
(	O
final_seg	pointer
==	O
expr_section	pointer
||	O
final_seg	pointer
==	O
undefined_section	O
)	O
final_seg	pointer
=	O
seg_left	pointer
;	O
}	O
resolved	int
=	O
symbol_resolved_p	function
(	O
add_symbol	pointer
)	O
;	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
symp	pointer
)	O
)	O
{	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
0	int
;	O
goto	O
exit_dont_set_value	O
;	O
}	O
break	O
;	O
case	O
O_uminus	int
:	O
case	O
O_bit_not	int
:	O
case	O
O_logical_not	int
:	O
left	pointer
=	O
resolve_symbol_value	function
(	O
add_symbol	pointer
)	O
;	O
seg_left	pointer
=	O
S_GET_SEGMENT	function
(	O
add_symbol	pointer
)	O
;	O
if	O
(	O
op	enum
!=	O
O_logical_not	int
&&	O
seg_left	pointer
!=	O
absolute_section	O
&&	O
finalize_syms	int
)	O
report_op_error	function
(	O
symp	pointer
,	O
NULL	O
,	O
op	enum
,	O
add_symbol	pointer
)	O
;	O
if	O
(	O
final_seg	pointer
==	O
expr_section	pointer
||	O
final_seg	pointer
==	O
undefined_section	O
)	O
final_seg	pointer
=	O
absolute_section	O
;	O
if	O
(	O
op	enum
==	O
O_uminus	int
)	O
left	pointer
=	O
-	O
left	pointer
;	O
else	O
if	O
(	O
op	enum
==	O
O_logical_not	int
)	O
left	pointer
=	O
!	O
left	pointer
;	O
else	O
left	pointer
=	O
~	O
left	pointer
;	O
final_val	long
+=	O
left	pointer
+	O
symp	pointer
->	O
sy_frag	pointer
->	O
fr_address	long
;	O
resolved	int
=	O
symbol_resolved_p	function
(	O
add_symbol	pointer
)	O
;	O
break	O
;	O
case	O
O_multiply	int
:	O
case	O
O_divide	int
:	O
case	O
O_modulus	int
:	O
case	O
O_left_shift	int
:	O
case	O
O_right_shift	int
:	O
case	O
O_bit_inclusive_or	int
:	O
case	O
O_bit_or_not	int
:	O
case	O
O_bit_exclusive_or	int
:	O
case	O
O_bit_and	int
:	O
case	O
O_add	int
:	O
case	O
O_subtract	int
:	O
case	O
O_eq	int
:	O
case	O
O_ne	int
:	O
case	O
O_lt	int
:	O
case	O
O_le	int
:	O
case	O
O_ge	int
:	O
case	O
O_gt	int
:	O
case	O
O_logical_and	int
:	O
case	O
O_logical_or	int
:	O
left	pointer
=	O
resolve_symbol_value	function
(	O
add_symbol	pointer
)	O
;	O
right	pointer
=	O
resolve_symbol_value	function
(	O
op_symbol	pointer
)	O
;	O
seg_left	pointer
=	O
S_GET_SEGMENT	function
(	O
add_symbol	pointer
)	O
;	O
seg_right	pointer
=	O
S_GET_SEGMENT	function
(	O
op_symbol	pointer
)	O
;	O
if	O
(	O
op	enum
==	O
O_add	int
)	O
{	O
if	O
(	O
seg_right	pointer
==	O
absolute_section	O
)	O
{	O
final_val	long
+=	O
right	pointer
;	O
goto	O
do_symbol	O
;	O
}	O
else	O
if	O
(	O
seg_left	pointer
==	O
absolute_section	O
)	O
{	O
final_val	long
+=	O
left	pointer
;	O
add_symbol	pointer
=	O
op_symbol	pointer
;	O
left	pointer
=	O
right	pointer
;	O
seg_left	pointer
=	O
seg_right	pointer
;	O
goto	O
do_symbol	O
;	O
}	O
}	O
else	O
if	O
(	O
op	enum
==	O
O_subtract	int
)	O
{	O
if	O
(	O
seg_right	pointer
==	O
absolute_section	O
)	O
{	O
final_val	long
-=	O
right	pointer
;	O
goto	O
do_symbol	O
;	O
}	O
}	O
move_seg_ok	int
=	O
1	int
;	O
if	O
(	O
!	O
(	O
seg_left	pointer
==	O
absolute_section	O
&&	O
seg_right	pointer
==	O
absolute_section	O
)	O
&&	O
!	O
(	O
op	enum
==	O
O_eq	int
||	O
op	enum
==	O
O_ne	int
)	O
&&	O
!	O
(	O
(	O
op	enum
==	O
O_subtract	int
||	O
op	enum
==	O
O_lt	int
||	O
op	enum
==	O
O_le	int
||	O
op	enum
==	O
O_ge	int
||	O
op	enum
==	O
O_gt	int
)	O
&&	O
seg_left	pointer
==	O
seg_right	pointer
&&	O
(	O
seg_left	pointer
!=	O
undefined_section	O
||	O
add_symbol	pointer
==	O
op_symbol	pointer
)	O
)	O
)	O
{	O
if	O
(	O
finalize_syms	int
)	O
report_op_error	function
(	O
symp	pointer
,	O
add_symbol	pointer
,	O
op	enum
,	O
op_symbol	pointer
)	O
;	O
else	O
move_seg_ok	int
=	O
0	int
;	O
}	O
if	O
(	O
move_seg_ok	int
&&	O
(	O
final_seg	pointer
==	O
expr_section	pointer
||	O
final_seg	pointer
==	O
undefined_section	O
)	O
)	O
final_seg	pointer
=	O
absolute_section	O
;	O
if	O
(	O
(	O
op	enum
==	O
O_divide	int
||	O
op	enum
==	O
O_modulus	int
)	O
&&	O
right	pointer
==	O
0	int
)	O
{	O
if	O
(	O
seg_right	pointer
==	O
absolute_section	O
&&	O
finalize_syms	int
)	O
{	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
if	O
(	O
expr_symbol_where	function
(	O
symp	pointer
,	O
&	O
file	pointer
,	O
&	O
line	int
)	O
)	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"division by zero"	pointer
)	O
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"division by zero when setting `%s'"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symp	pointer
)	O
)	O
;	O
}	O
right	pointer
=	O
1	int
;	O
}	O
switch	O
(	O
symp	pointer
->	O
sy_value	struct
.	O
X_op	enum
)	O
{	O
case	O
O_multiply	int
:	O
left	pointer
*=	O
right	pointer
;	O
break	O
;	O
case	O
O_divide	int
:	O
left	pointer
/=	O
right	pointer
;	O
break	O
;	O
case	O
O_modulus	int
:	O
left	pointer
%=	O
right	pointer
;	O
break	O
;	O
case	O
O_left_shift	int
:	O
left	pointer
<<=	O
right	pointer
;	O
break	O
;	O
case	O
O_right_shift	int
:	O
left	pointer
>>=	O
right	pointer
;	O
break	O
;	O
case	O
O_bit_inclusive_or	int
:	O
left	pointer
|=	O
right	pointer
;	O
break	O
;	O
case	O
O_bit_or_not	int
:	O
left	pointer
|=	O
~	O
right	pointer
;	O
break	O
;	O
case	O
O_bit_exclusive_or	int
:	O
left	pointer
^=	O
right	pointer
;	O
break	O
;	O
case	O
O_bit_and	int
:	O
left	pointer
&=	O
right	pointer
;	O
break	O
;	O
case	O
O_add	int
:	O
left	pointer
+=	O
right	pointer
;	O
break	O
;	O
case	O
O_subtract	int
:	O
left	pointer
-=	O
right	pointer
;	O
break	O
;	O
case	O
O_eq	int
:	O
case	O
O_ne	int
:	O
left	pointer
=	O
(	O
left	pointer
==	O
right	pointer
&&	O
seg_left	pointer
==	O
seg_right	pointer
&&	O
(	O
seg_left	pointer
!=	O
undefined_section	O
||	O
add_symbol	pointer
==	O
op_symbol	pointer
)	O
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
)	O
;	O
if	O
(	O
symp	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_ne	int
)	O
left	pointer
=	O
~	O
left	pointer
;	O
break	O
;	O
case	O
O_lt	int
:	O
left	pointer
=	O
left	pointer
<	O
right	pointer
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_le	int
:	O
left	pointer
=	O
left	pointer
<=	O
right	pointer
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ge	int
:	O
left	pointer
=	O
left	pointer
>=	O
right	pointer
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_gt	int
:	O
left	pointer
=	O
left	pointer
>	O
right	pointer
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_logical_and	int
:	O
left	pointer
=	O
left	pointer
&&	O
right	pointer
;	O
break	O
;	O
case	O
O_logical_or	int
:	O
left	pointer
=	O
left	pointer
||	O
right	pointer
;	O
break	O
;	O
case	O
O_illegal	int
:	O
case	O
O_absent	int
:	O
case	O
O_constant	int
:	O
as_bad	function
(	O
_	O
(	O
"Invalid operation on symbol"	pointer
)	O
)	O
;	O
goto	O
exit_dont_set_value	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
final_val	long
+=	O
symp	pointer
->	O
sy_frag	pointer
->	O
fr_address	long
+	O
left	pointer
;	O
if	O
(	O
final_seg	pointer
==	O
expr_section	pointer
||	O
final_seg	pointer
==	O
undefined_section	O
)	O
{	O
if	O
(	O
seg_left	pointer
==	O
undefined_section	O
||	O
seg_right	pointer
==	O
undefined_section	O
)	O
final_seg	pointer
=	O
undefined_section	O
;	O
else	O
if	O
(	O
seg_left	pointer
==	O
absolute_section	O
)	O
final_seg	pointer
=	O
seg_right	pointer
;	O
else	O
final_seg	pointer
=	O
seg_left	pointer
;	O
}	O
resolved	int
=	O
(	O
symbol_resolved_p	function
(	O
add_symbol	pointer
)	O
&&	O
symbol_resolved_p	function
(	O
op_symbol	pointer
)	O
)	O
;	O
break	O
;	O
case	O
O_big	int
:	O
case	O
O_illegal	int
:	O
break	O
;	O
}	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
0	int
;	O
}	O
if	O
(	O
finalize_syms	int
)	O
S_SET_VALUE	function
(	O
symp	pointer
,	O
final_val	long
)	O
;	O
exit_dont_set_value	O
:	O
S_SET_SEGMENT	function
(	O
symp	pointer
,	O
final_seg	pointer
)	O
;	O
if	O
(	O
finalize_syms	int
)	O
{	O
if	O
(	O
resolved	int
)	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
=	O
1	int
;	O
else	O
if	O
(	O
S_GET_SEGMENT	function
(	O
symp	pointer
)	O
!=	O
expr_section	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"can't resolve value for symbol `%s'"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symp	pointer
)	O
)	O
;	O
symp	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
=	O
1	int
;	O
}	O
}	O
return	O
final_val	long
;	O
}	O
static	O
void	O
resolve_local_symbol	function
(	O
const	O
char	O
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
resolve_local_symbol	function
(	O
const	O
char	O
*	O
key	pointer
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
value	long
)	O
{	O
if	O
(	O
value	long
!=	O
NULL	O
)	O
resolve_symbol_value	function
(	O
(	O
symbolS	struct
*	O
)	O
value	long
)	O
;	O
}	O
void	O
resolve_local_symbol_values	function
(	O
void	O
)	O
{	O
hash_traverse	function
(	O
local_hash	pointer
,	O
resolve_local_symbol	function
)	O
;	O
}	O
int	O
snapshot_symbol	function
(	O
symbolS	struct
*	O
*	O
symbolPP	pointer
,	O
valueT	long
*	O
valueP	pointer
,	O
segT	pointer
*	O
segP	pointer
,	O
fragS	struct
*	O
*	O
fragPP	pointer
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
=	O
*	O
symbolPP	pointer
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
{	O
struct	O
local_symbol	struct
*	O
locsym	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
symbolP	pointer
;	O
*	O
valueP	pointer
=	O
locsym	pointer
->	O
lsy_value	long
;	O
*	O
segP	pointer
=	O
locsym	pointer
->	O
lsy_section	pointer
;	O
*	O
fragPP	pointer
=	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
;	O
}	O
else	O
{	O
expressionS	struct
exp	pointer
=	O
symbolP	pointer
->	O
sy_value	struct
;	O
if	O
(	O
!	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
&&	O
exp	pointer
.	O
X_op	enum
!=	O
O_illegal	int
)	O
{	O
int	O
resolved	int
;	O
if	O
(	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
)	O
return	O
0	int
;	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
1	int
;	O
resolved	int
=	O
resolve_expression	function
(	O
&	O
exp	pointer
)	O
;	O
symbolP	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
=	O
0	int
;	O
if	O
(	O
!	O
resolved	int
)	O
return	O
0	int
;	O
switch	O
(	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_constant	int
:	O
case	O
O_register	int
:	O
if	O
(	O
!	O
symbol_equated_p	function
(	O
symbolP	pointer
)	O
)	O
break	O
;	O
case	O
O_symbol	int
:	O
case	O
O_symbol_rva	int
:	O
symbolP	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
break	O
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
*	O
symbolPP	pointer
=	O
symbolP	pointer
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
symbolP	pointer
)	O
)	O
{	O
struct	O
local_symbol	struct
*	O
locsym	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
symbolP	pointer
;	O
*	O
valueP	pointer
=	O
locsym	pointer
->	O
lsy_value	long
;	O
*	O
segP	pointer
=	O
locsym	pointer
->	O
lsy_section	pointer
;	O
*	O
fragPP	pointer
=	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
;	O
}	O
else	O
{	O
*	O
valueP	pointer
=	O
exp	pointer
.	O
X_add_number	long
;	O
*	O
segP	pointer
=	O
symbolP	pointer
->	O
bsym	pointer
->	O
section	pointer
;	O
*	O
fragPP	pointer
=	O
symbolP	pointer
->	O
sy_frag	pointer
;	O
}	O
if	O
(	O
*	O
segP	pointer
==	O
expr_section	pointer
)	O
switch	O
(	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_constant	int
:	O
*	O
segP	pointer
=	O
absolute_section	O
;	O
break	O
;	O
case	O
O_register	int
:	O
*	O
segP	pointer
=	O
reg_section	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
long	O
*	O
dollar_labels	pointer
;	O
static	O
long	O
*	O
dollar_label_instances	pointer
;	O
static	O
char	O
*	O
dollar_label_defines	pointer
;	O
static	O
unsigned	O
long	O
dollar_label_count	long
;	O
static	O
unsigned	O
long	O
dollar_label_max	long
;	O
int	O
dollar_label_defined	function
(	O
long	O
label	long
)	O
{	O
long	O
*	O
i	pointer
;	O
know	O
(	O
(	O
dollar_labels	pointer
!=	O
NULL	O
)	O
||	O
(	O
dollar_label_count	long
==	O
0	int
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
dollar_labels	pointer
;	O
i	pointer
<	O
dollar_labels	pointer
+	O
dollar_label_count	long
;	O
++	O
i	pointer
)	O
if	O
(	O
*	O
i	pointer
==	O
label	long
)	O
return	O
dollar_label_defines	pointer
[	O
i	pointer
-	O
dollar_labels	pointer
]	O
;	O
return	O
0	int
;	O
}	O
static	O
long	O
dollar_label_instance	function
(	O
long	O
label	long
)	O
{	O
long	O
*	O
i	pointer
;	O
know	O
(	O
(	O
dollar_labels	pointer
!=	O
NULL	O
)	O
||	O
(	O
dollar_label_count	long
==	O
0	int
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
dollar_labels	pointer
;	O
i	pointer
<	O
dollar_labels	pointer
+	O
dollar_label_count	long
;	O
++	O
i	pointer
)	O
if	O
(	O
*	O
i	pointer
==	O
label	long
)	O
return	O
(	O
dollar_label_instances	pointer
[	O
i	pointer
-	O
dollar_labels	pointer
]	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
dollar_label_clear	function
(	O
void	O
)	O
{	O
memset	function
(	O
dollar_label_defines	pointer
,	O
'\0'	O
,	O
(	O
unsigned	O
int	O
)	O
dollar_label_count	long
)	O
;	O
}	O
void	O
define_dollar_label	function
(	O
long	O
label	long
)	O
{	O
long	O
*	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
dollar_labels	pointer
;	O
i	pointer
<	O
dollar_labels	pointer
+	O
dollar_label_count	long
;	O
++	O
i	pointer
)	O
if	O
(	O
*	O
i	pointer
==	O
label	long
)	O
{	O
++	O
dollar_label_instances	pointer
[	O
i	pointer
-	O
dollar_labels	pointer
]	O
;	O
dollar_label_defines	pointer
[	O
i	pointer
-	O
dollar_labels	pointer
]	O
=	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
dollar_labels	pointer
==	O
NULL	O
)	O
{	O
dollar_labels	pointer
=	O
XNEWVEC	O
(	O
long	O
,	O
DOLLAR_LABEL_BUMP_BY	int
)	O
;	O
dollar_label_instances	pointer
=	O
XNEWVEC	O
(	O
long	O
,	O
DOLLAR_LABEL_BUMP_BY	int
)	O
;	O
dollar_label_defines	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
DOLLAR_LABEL_BUMP_BY	int
)	O
;	O
dollar_label_max	long
=	O
DOLLAR_LABEL_BUMP_BY	int
;	O
dollar_label_count	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
dollar_label_count	long
==	O
dollar_label_max	long
)	O
{	O
dollar_label_max	long
+=	O
DOLLAR_LABEL_BUMP_BY	int
;	O
dollar_labels	pointer
=	O
XRESIZEVEC	O
(	O
long	O
,	O
dollar_labels	pointer
,	O
dollar_label_max	long
)	O
;	O
dollar_label_instances	pointer
=	O
XRESIZEVEC	O
(	O
long	O
,	O
dollar_label_instances	pointer
,	O
dollar_label_max	long
)	O
;	O
dollar_label_defines	pointer
=	O
XRESIZEVEC	O
(	O
char	O
,	O
dollar_label_defines	pointer
,	O
dollar_label_max	long
)	O
;	O
}	O
dollar_labels	pointer
[	O
dollar_label_count	long
]	O
=	O
label	long
;	O
dollar_label_instances	pointer
[	O
dollar_label_count	long
]	O
=	O
1	int
;	O
dollar_label_defines	pointer
[	O
dollar_label_count	long
]	O
=	O
1	int
;	O
++	O
dollar_label_count	long
;	O
}	O
char	O
*	O
dollar_label_name	function
(	O
long	O
n	int
,	O
int	O
augend	int
)	O
{	O
long	O
i	pointer
;	O
static	O
char	O
symbol_name_build	array
[	O
24	int
]	O
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
char	O
symbol_name_temporary	array
[	O
20	int
]	O
;	O
know	O
(	O
n	int
>=	O
0	int
)	O
;	O
know	O
(	O
augend	int
==	O
0	int
||	O
augend	int
==	O
1	int
)	O
;	O
p	pointer
=	O
symbol_name_build	array
;	O
*	O
p	pointer
++	O
=	O
LOCAL_LABEL_PREFIX	char
;	O
*	O
p	pointer
++	O
=	O
'L'	O
;	O
q	pointer
=	O
symbol_name_temporary	array
;	O
for	O
(	O
*	O
q	pointer
++	O
=	O
0	int
,	O
i	pointer
=	O
n	int
;	O
i	pointer
;	O
++	O
q	pointer
)	O
{	O
*	O
q	pointer
=	O
i	pointer
%	O
10	int
+	O
'0'	O
;	O
i	pointer
/=	O
10	int
;	O
}	O
while	O
(	O
(	O
*	O
p	pointer
=	O
*	O
--	O
q	pointer
)	O
!=	O
'\0'	O
)	O
++	O
p	pointer
;	O
*	O
p	pointer
++	O
=	O
DOLLAR_LABEL_CHAR	char
;	O
q	pointer
=	O
symbol_name_temporary	array
;	O
for	O
(	O
*	O
q	pointer
++	O
=	O
0	int
,	O
i	pointer
=	O
dollar_label_instance	function
(	O
n	int
)	O
+	O
augend	int
;	O
i	pointer
;	O
++	O
q	pointer
)	O
{	O
*	O
q	pointer
=	O
i	pointer
%	O
10	int
+	O
'0'	O
;	O
i	pointer
/=	O
10	int
;	O
}	O
while	O
(	O
(	O
*	O
p	pointer
++	O
=	O
*	O
--	O
q	pointer
)	O
!=	O
'\0'	O
)	O
;	O
return	O
symbol_name_build	array
;	O
}	O
static	O
long	O
fb_low_counter	array
[	O
FB_LABEL_SPECIAL	O
]	O
;	O
static	O
long	O
*	O
fb_labels	pointer
;	O
static	O
long	O
*	O
fb_label_instances	pointer
;	O
static	O
long	O
fb_label_count	long
;	O
static	O
long	O
fb_label_max	long
;	O
static	O
void	O
fb_label_init	function
(	O
void	O
)	O
{	O
memset	function
(	O
(	O
void	O
*	O
)	O
fb_low_counter	array
,	O
'\0'	O
,	O
sizeof	O
(	O
fb_low_counter	array
)	O
)	O
;	O
}	O
void	O
fb_label_instance_inc	function
(	O
long	O
label	long
)	O
{	O
long	O
*	O
i	pointer
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
label	long
<	O
FB_LABEL_SPECIAL	O
)	O
{	O
++	O
fb_low_counter	array
[	O
label	long
]	O
;	O
return	O
;	O
}	O
if	O
(	O
fb_labels	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
fb_labels	pointer
+	O
FB_LABEL_SPECIAL	O
;	O
i	pointer
<	O
fb_labels	pointer
+	O
fb_label_count	long
;	O
++	O
i	pointer
)	O
{	O
if	O
(	O
*	O
i	pointer
==	O
label	long
)	O
{	O
++	O
fb_label_instances	pointer
[	O
i	pointer
-	O
fb_labels	pointer
]	O
;	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
fb_labels	pointer
==	O
NULL	O
)	O
{	O
fb_labels	pointer
=	O
XNEWVEC	O
(	O
long	O
,	O
FB_LABEL_BUMP_BY	O
)	O
;	O
fb_label_instances	pointer
=	O
XNEWVEC	O
(	O
long	O
,	O
FB_LABEL_BUMP_BY	O
)	O
;	O
fb_label_max	long
=	O
FB_LABEL_BUMP_BY	O
;	O
fb_label_count	long
=	O
FB_LABEL_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
fb_label_count	long
==	O
fb_label_max	long
)	O
{	O
fb_label_max	long
+=	O
FB_LABEL_BUMP_BY	O
;	O
fb_labels	pointer
=	O
XRESIZEVEC	O
(	O
long	O
,	O
fb_labels	pointer
,	O
fb_label_max	long
)	O
;	O
fb_label_instances	pointer
=	O
XRESIZEVEC	O
(	O
long	O
,	O
fb_label_instances	pointer
,	O
fb_label_max	long
)	O
;	O
}	O
fb_labels	pointer
[	O
fb_label_count	long
]	O
=	O
label	long
;	O
fb_label_instances	pointer
[	O
fb_label_count	long
]	O
=	O
1	int
;	O
++	O
fb_label_count	long
;	O
}	O
static	O
long	O
fb_label_instance	function
(	O
long	O
label	long
)	O
{	O
long	O
*	O
i	pointer
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
label	long
<	O
FB_LABEL_SPECIAL	O
)	O
{	O
return	O
(	O
fb_low_counter	array
[	O
label	long
]	O
)	O
;	O
}	O
if	O
(	O
fb_labels	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
fb_labels	pointer
+	O
FB_LABEL_SPECIAL	O
;	O
i	pointer
<	O
fb_labels	pointer
+	O
fb_label_count	long
;	O
++	O
i	pointer
)	O
{	O
if	O
(	O
*	O
i	pointer
==	O
label	long
)	O
{	O
return	O
(	O
fb_label_instances	pointer
[	O
i	pointer
-	O
fb_labels	pointer
]	O
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
fb_label_name	function
(	O
long	O
n	int
,	O
long	O
augend	int
)	O
{	O
long	O
i	pointer
;	O
static	O
char	O
symbol_name_build	array
[	O
24	int
]	O
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
char	O
symbol_name_temporary	array
[	O
20	int
]	O
;	O
know	O
(	O
n	int
>=	O
0	int
)	O
;	O
know	O
(	O
(	O
unsigned	O
long	O
)	O
augend	int
<=	O
1	int
)	O
;	O
p	pointer
=	O
symbol_name_build	array
;	O
*	O
p	pointer
++	O
=	O
LOCAL_LABEL_PREFIX	char
;	O
*	O
p	pointer
++	O
=	O
'L'	O
;	O
q	pointer
=	O
symbol_name_temporary	array
;	O
for	O
(	O
*	O
q	pointer
++	O
=	O
0	int
,	O
i	pointer
=	O
n	int
;	O
i	pointer
;	O
++	O
q	pointer
)	O
{	O
*	O
q	pointer
=	O
i	pointer
%	O
10	int
+	O
'0'	O
;	O
i	pointer
/=	O
10	int
;	O
}	O
while	O
(	O
(	O
*	O
p	pointer
=	O
*	O
--	O
q	pointer
)	O
!=	O
'\0'	O
)	O
++	O
p	pointer
;	O
*	O
p	pointer
++	O
=	O
LOCAL_LABEL_CHAR	char
;	O
q	pointer
=	O
symbol_name_temporary	array
;	O
for	O
(	O
*	O
q	pointer
++	O
=	O
0	int
,	O
i	pointer
=	O
fb_label_instance	function
(	O
n	int
)	O
+	O
augend	int
;	O
i	pointer
;	O
++	O
q	pointer
)	O
{	O
*	O
q	pointer
=	O
i	pointer
%	O
10	int
+	O
'0'	O
;	O
i	pointer
/=	O
10	int
;	O
}	O
while	O
(	O
(	O
*	O
p	pointer
++	O
=	O
*	O
--	O
q	pointer
)	O
!=	O
'\0'	O
)	O
;	O
return	O
(	O
symbol_name_build	array
)	O
;	O
}	O
char	O
*	O
decode_local_label_name	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
symbol_decode	pointer
;	O
int	O
label_number	int
;	O
int	O
instance_number	int
;	O
const	O
char	O
*	O
type	char
;	O
const	O
char	O
*	O
message_format	pointer
;	O
int	O
lindex	int
=	O
0	int
;	O
if	O
(	O
s	pointer
[	O
lindex	int
]	O
==	O
LOCAL_LABEL_PREFIX	char
)	O
++	O
lindex	int
;	O
if	O
(	O
s	pointer
[	O
lindex	int
]	O
!=	O
'L'	O
)	O
return	O
s	pointer
;	O
for	O
(	O
label_number	int
=	O
0	int
,	O
p	pointer
=	O
s	pointer
+	O
lindex	int
+	O
1	int
;	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
;	O
++	O
p	pointer
)	O
label_number	int
=	O
(	O
10	int
*	O
label_number	int
)	O
+	O
*	O
p	pointer
-	O
'0'	O
;	O
if	O
(	O
*	O
p	pointer
==	O
DOLLAR_LABEL_CHAR	char
)	O
type	char
=	O
"dollar"	pointer
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
LOCAL_LABEL_CHAR	char
)	O
type	char
=	O
"fb"	pointer
;	O
else	O
return	O
s	pointer
;	O
for	O
(	O
instance_number	int
=	O
0	int
,	O
p	pointer
++	O
;	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
;	O
++	O
p	pointer
)	O
instance_number	int
=	O
(	O
10	int
*	O
instance_number	int
)	O
+	O
*	O
p	pointer
-	O
'0'	O
;	O
message_format	pointer
=	O
_	O
(	O
"\"%d\" (instance number %d of a %s label)"	pointer
)	O
;	O
symbol_decode	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
notes	struct
,	O
strlen	function
(	O
message_format	pointer
)	O
+	O
30	int
)	O
;	O
sprintf	function
(	O
symbol_decode	pointer
,	O
message_format	pointer
,	O
label_number	int
,	O
instance_number	int
,	O
type	char
)	O
;	O
return	O
symbol_decode	pointer
;	O
}	O
valueT	long
S_GET_VALUE	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
resolve_symbol_value	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
)	O
{	O
valueT	long
val	int
=	O
resolve_symbol_value	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
finalize_syms	int
)	O
return	O
val	int
;	O
}	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
s	pointer
)	O
)	O
return	O
S_GET_VALUE	function
(	O
s	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
sy_value	struct
.	O
X_op	enum
!=	O
O_constant	int
)	O
{	O
if	O
(	O
!	O
s	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
||	O
s	pointer
->	O
sy_value	struct
.	O
X_op	enum
!=	O
O_symbol	int
||	O
(	O
S_IS_DEFINED	function
(	O
s	pointer
)	O
&&	O
!	O
S_IS_COMMON	function
(	O
s	pointer
)	O
)	O
)	O
as_bad	function
(	O
_	O
(	O
"attempt to get value of unresolved symbol `%s'"	pointer
)	O
,	O
S_GET_NAME	function
(	O
s	pointer
)	O
)	O
;	O
}	O
return	O
(	O
valueT	long
)	O
s	pointer
->	O
sy_value	struct
.	O
X_add_number	long
;	O
}	O
void	O
S_SET_VALUE	function
(	O
symbolS	struct
*	O
s	pointer
,	O
valueT	long
val	int
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
{	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_value	long
=	O
val	int
;	O
return	O
;	O
}	O
s	pointer
->	O
sy_value	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
s	pointer
->	O
sy_value	struct
.	O
X_add_number	long
=	O
(	O
offsetT	long
)	O
val	int
;	O
s	pointer
->	O
sy_value	struct
.	O
X_unsigned	int
=	O
0	int
;	O
S_CLEAR_WEAKREFR	function
(	O
s	pointer
)	O
;	O
}	O
void	O
copy_symbol_attributes	function
(	O
symbolS	struct
*	O
dest	pointer
,	O
symbolS	struct
*	O
src	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
dest	pointer
)	O
)	O
dest	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
dest	pointer
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
src	pointer
)	O
)	O
src	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
src	pointer
)	O
;	O
dest	pointer
->	O
bsym	pointer
->	O
flags	int
|=	O
src	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
COPIED_SYMFLAGS	O
;	O
OBJ_COPY_SYMBOL_ATTRIBUTES	O
(	O
dest	pointer
,	O
src	pointer
)	O
;	O
}	O
int	O
S_IS_FUNCTION	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
flagword	int
flags	int
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
flags	int
=	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
;	O
return	O
(	O
flags	int
&	O
BSF_FUNCTION	O
)	O
!=	O
0	int
;	O
}	O
int	O
S_IS_EXTERNAL	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
flagword	int
flags	int
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
flags	int
=	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
flags	int
&	O
BSF_LOCAL	O
)	O
&&	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
)	O
abort	function
(	O
)	O
;	O
return	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
!=	O
0	int
;	O
}	O
int	O
S_IS_WEAK	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
s	pointer
)	O
)	O
return	O
S_IS_WEAK	function
(	O
s	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
)	O
;	O
return	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
;	O
}	O
int	O
S_IS_WEAKREFR	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefr	int
!=	O
0	int
;	O
}	O
int	O
S_IS_WEAKREFD	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefd	int
!=	O
0	int
;	O
}	O
int	O
S_IS_COMMON	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
bfd_is_com_section	function
(	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
)	O
;	O
}	O
int	O
S_IS_DEFINED	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_section	pointer
!=	O
undefined_section	O
;	O
return	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
!=	O
undefined_section	O
;	O
}	O
int	O
S_FORCE_RELOC	function
(	O
symbolS	struct
*	O
s	pointer
,	O
int	O
strict	int
)	O
{	O
segT	pointer
sec	pointer
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
sec	pointer
=	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_section	pointer
;	O
else	O
{	O
if	O
(	O
(	O
strict	int
&&	O
(	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
||	O
(	O
EXTERN_FORCE_RELOC	O
&&	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_GLOBAL	O
)	O
!=	O
0	int
)	O
)	O
)	O
||	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_GNU_INDIRECT_FUNCTION	O
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
sec	pointer
=	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
;	O
}	O
return	O
bfd_is_und_section	function
(	O
sec	pointer
)	O
||	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
;	O
}	O
int	O
S_IS_DEBUG	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
S_IS_LOCAL	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
flagword	int
flags	int
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
1	int
;	O
flags	int
=	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
flags	int
&	O
BSF_LOCAL	O
)	O
&&	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
bfd_asymbol_section	function
(	O
s	pointer
->	O
bsym	pointer
)	O
==	O
reg_section	pointer
)	O
return	O
1	int
;	O
if	O
(	O
flag_strip_local_absolute	int
&&	O
(	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_FILE	O
)	O
)	O
==	O
0	int
&&	O
bfd_asymbol_section	function
(	O
s	pointer
->	O
bsym	pointer
)	O
==	O
absolute_section	O
)	O
return	O
1	int
;	O
name	pointer
=	O
S_GET_NAME	function
(	O
s	pointer
)	O
;	O
return	O
(	O
name	pointer
!=	O
NULL	O
&&	O
!	O
S_IS_DEBUG	function
(	O
s	pointer
)	O
&&	O
(	O
strchr	function
(	O
name	pointer
,	O
DOLLAR_LABEL_CHAR	char
)	O
||	O
strchr	function
(	O
name	pointer
,	O
LOCAL_LABEL_CHAR	char
)	O
||	O
TC_LABEL_IS_LOCAL	int
(	O
name	pointer
)	O
||	O
(	O
!	O
flag_keep_locals	int
&&	O
(	O
bfd_is_local_label	function
(	O
stdoutput	pointer
,	O
s	pointer
->	O
bsym	pointer
)	O
||	O
(	O
flag_mri	int
&&	O
name	pointer
[	O
0	int
]	O
==	O
'?'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'?'	O
)	O
)	O
)	O
)	O
)	O
;	O
}	O
int	O
S_IS_STABD	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
return	O
S_GET_NAME	function
(	O
s	pointer
)	O
==	O
0	int
;	O
}	O
int	O
S_CAN_BE_REDEFINED	function
(	O
const	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
(	O
local_symbol_get_frag	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
==	O
&	O
predefined_address_frag	struct
)	O
;	O
return	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
==	O
reg_section	pointer
;	O
}	O
int	O
S_IS_VOLATILE	function
(	O
const	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_volatile	int
;	O
}	O
int	O
S_IS_FORWARD_REF	function
(	O
const	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_forward_ref	int
;	O
}	O
const	O
char	O
*	O
S_GET_NAME	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_name	pointer
;	O
return	O
s	pointer
->	O
bsym	pointer
->	O
name	pointer
;	O
}	O
segT	pointer
S_GET_SEGMENT	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_section	pointer
;	O
return	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
;	O
}	O
void	O
S_SET_SEGMENT	function
(	O
symbolS	struct
*	O
s	pointer
,	O
segT	pointer
seg	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
{	O
if	O
(	O
seg	pointer
==	O
reg_section	pointer
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
else	O
{	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_section	pointer
=	O
seg	pointer
;	O
return	O
;	O
}	O
}	O
if	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
{	O
if	O
(	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
!=	O
seg	pointer
)	O
abort	function
(	O
)	O
;	O
}	O
else	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
=	O
seg	pointer
;	O
}	O
void	O
S_SET_EXTERNAL	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"section symbols are already global"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
S_GET_SEGMENT	function
(	O
s	pointer
)	O
==	O
reg_section	pointer
)	O
{	O
as_bad	function
(	O
"can't make register symbol `%s' global"	pointer
,	O
S_GET_NAME	function
(	O
s	pointer
)	O
)	O
;	O
return	O
;	O
}	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&=	O
~	O
(	O
BSF_LOCAL	O
|	O
BSF_WEAK	O
)	O
;	O
}	O
void	O
S_CLEAR_EXTERNAL	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
if	O
(	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
)	O
{	O
return	O
;	O
}	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
|=	O
BSF_LOCAL	O
;	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&=	O
~	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
;	O
}	O
void	O
S_SET_WEAK	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
|=	O
BSF_WEAK	O
;	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&=	O
~	O
(	O
BSF_GLOBAL	O
|	O
BSF_LOCAL	O
)	O
;	O
}	O
void	O
S_SET_WEAKREFR	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefr	int
=	O
1	int
;	O
if	O
(	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used	int
)	O
symbol_mark_used	function
(	O
s	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
)	O
;	O
}	O
void	O
S_CLEAR_WEAKREFR	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefr	int
=	O
0	int
;	O
}	O
void	O
S_SET_WEAKREFD	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefd	int
=	O
1	int
;	O
S_SET_WEAK	function
(	O
s	pointer
)	O
;	O
}	O
void	O
S_CLEAR_WEAKREFD	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
if	O
(	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefd	int
)	O
{	O
s	pointer
->	O
sy_flags	struct
.	O
sy_weakrefd	int
=	O
0	int
;	O
if	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
{	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&=	O
~	O
BSF_WEAK	O
;	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
|=	O
BSF_LOCAL	O
;	O
}	O
}	O
}	O
void	O
S_SET_THREAD_LOCAL	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
if	O
(	O
bfd_is_com_section	function
(	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
)	O
&&	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_THREAD_LOCAL	O
)	O
!=	O
0	int
)	O
return	O
;	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
|=	O
BSF_THREAD_LOCAL	O
;	O
if	O
(	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_FUNCTION	O
)	O
!=	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"Accessing function `%s' as thread-local object"	pointer
)	O
,	O
S_GET_NAME	function
(	O
s	pointer
)	O
)	O
;	O
else	O
if	O
(	O
!	O
bfd_is_und_section	function
(	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
)	O
&&	O
(	O
s	pointer
->	O
bsym	pointer
->	O
section	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
==	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"Accessing `%s' as thread-local object"	pointer
)	O
,	O
S_GET_NAME	function
(	O
s	pointer
)	O
)	O
;	O
}	O
void	O
S_SET_NAME	function
(	O
symbolS	struct
*	O
s	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
{	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_name	pointer
=	O
name	pointer
;	O
return	O
;	O
}	O
s	pointer
->	O
bsym	pointer
->	O
name	pointer
=	O
name	pointer
;	O
}	O
void	O
S_SET_VOLATILE	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_volatile	int
=	O
1	int
;	O
}	O
void	O
S_CLEAR_VOLATILE	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
->	O
sy_flags	struct
.	O
sy_volatile	int
=	O
0	int
;	O
}	O
void	O
S_SET_FORWARD_REF	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_forward_ref	int
=	O
1	int
;	O
}	O
symbolS	struct
*	O
symbol_previous	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
return	O
s	pointer
->	O
sy_previous	pointer
;	O
}	O
symbolS	struct
*	O
symbol_next	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
return	O
s	pointer
->	O
sy_next	pointer
;	O
}	O
expressionS	struct
*	O
symbol_get_value_expression	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
&	O
s	pointer
->	O
sy_value	struct
;	O
}	O
void	O
symbol_set_value_expression	function
(	O
symbolS	struct
*	O
s	pointer
,	O
const	O
expressionS	struct
*	O
exp	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_value	struct
=	O
*	O
exp	pointer
;	O
S_CLEAR_WEAKREFR	function
(	O
s	pointer
)	O
;	O
}	O
int	O
symbol_same_p	function
(	O
symbolS	struct
*	O
s1	pointer
,	O
symbolS	struct
*	O
s2	pointer
)	O
{	O
s1	pointer
=	O
get_real_sym	function
(	O
s1	pointer
)	O
;	O
s2	pointer
=	O
get_real_sym	function
(	O
s2	pointer
)	O
;	O
return	O
s1	pointer
==	O
s2	pointer
;	O
}	O
offsetT	long
*	O
symbol_X_add_number	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
(	O
offsetT	long
*	O
)	O
&	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
->	O
lsy_value	long
;	O
return	O
&	O
s	pointer
->	O
sy_value	struct
.	O
X_add_number	long
;	O
}	O
void	O
symbol_set_value_now	function
(	O
symbolS	struct
*	O
sym	pointer
)	O
{	O
S_SET_SEGMENT	function
(	O
sym	pointer
,	O
now_seg	pointer
)	O
;	O
S_SET_VALUE	function
(	O
sym	pointer
,	O
frag_now_fix	function
(	O
)	O
)	O
;	O
symbol_set_frag	function
(	O
sym	pointer
,	O
frag_now	pointer
)	O
;	O
}	O
void	O
symbol_set_frag	function
(	O
symbolS	struct
*	O
s	pointer
,	O
fragS	struct
*	O
f	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
{	O
local_symbol_set_frag	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
,	O
f	pointer
)	O
;	O
return	O
;	O
}	O
s	pointer
->	O
sy_frag	pointer
=	O
f	pointer
;	O
S_CLEAR_WEAKREFR	function
(	O
s	pointer
)	O
;	O
}	O
fragS	struct
*	O
symbol_get_frag	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
local_symbol_get_frag	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
s	pointer
->	O
sy_frag	pointer
;	O
}	O
void	O
symbol_mark_used	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used	int
=	O
1	int
;	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
s	pointer
)	O
)	O
symbol_mark_used	function
(	O
s	pointer
->	O
sy_value	struct
.	O
X_add_symbol	pointer
)	O
;	O
}	O
void	O
symbol_clear_used	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used	int
=	O
0	int
;	O
}	O
int	O
symbol_used_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
1	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used	int
;	O
}	O
void	O
symbol_mark_used_in_reloc	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used_in_reloc	int
=	O
1	int
;	O
}	O
void	O
symbol_clear_used_in_reloc	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used_in_reloc	int
=	O
0	int
;	O
}	O
int	O
symbol_used_in_reloc_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_used_in_reloc	int
;	O
}	O
void	O
symbol_mark_mri_common	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_mri_common	int
=	O
1	int
;	O
}	O
void	O
symbol_clear_mri_common	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_mri_common	int
=	O
0	int
;	O
}	O
int	O
symbol_mri_common_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_mri_common	int
;	O
}	O
void	O
symbol_mark_written	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_written	int
=	O
1	int
;	O
}	O
void	O
symbol_clear_written	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
;	O
s	pointer
->	O
sy_flags	struct
.	O
sy_written	int
=	O
0	int
;	O
}	O
int	O
symbol_written_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_written	int
;	O
}	O
void	O
symbol_mark_resolved	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
{	O
local_symbol_mark_resolved	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
;	O
}	O
s	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
=	O
1	int
;	O
}	O
int	O
symbol_resolved_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
local_symbol_resolved_p	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
s	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
;	O
}	O
int	O
symbol_section_p	function
(	O
symbolS	struct
*	O
s	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
!=	O
0	int
;	O
}	O
int	O
symbol_equated_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_symbol	int
;	O
}	O
int	O
symbol_equated_reloc_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
(	O
s	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_symbol	int
&&	O
(	O
(	O
s	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
&&	O
s	pointer
->	O
sy_value	struct
.	O
X_op_symbol	pointer
!=	O
NULL	O
)	O
||	O
!	O
S_IS_DEFINED	function
(	O
s	pointer
)	O
||	O
S_IS_COMMON	function
(	O
s	pointer
)	O
)	O
)	O
;	O
}	O
int	O
symbol_constant_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
1	int
;	O
return	O
s	pointer
->	O
sy_value	struct
.	O
X_op	enum
==	O
O_constant	int
;	O
}	O
int	O
symbol_shadow_p	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
s	pointer
->	O
sy_next	pointer
==	O
s	pointer
;	O
}	O
symbolS	struct
*	O
symbol_symbolS	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
return	O
NULL	O
;	O
return	O
s	pointer
;	O
}	O
asymbol	struct
*	O
symbol_get_bfdsym	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
s	pointer
->	O
bsym	pointer
;	O
}	O
void	O
symbol_set_bfdsym	function
(	O
symbolS	struct
*	O
s	pointer
,	O
asymbol	struct
*	O
bsym	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
->	O
bsym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
==	O
0	int
)	O
s	pointer
->	O
bsym	pointer
=	O
bsym	pointer
;	O
}	O
OBJ_SYMFIELD_TYPE	O
*	O
symbol_get_obj	function
(	O
symbolS	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
return	O
&	O
s	pointer
->	O
sy_obj	struct
;	O
}	O
void	O
symbol_set_obj	function
(	O
symbolS	struct
*	O
s	pointer
,	O
OBJ_SYMFIELD_TYPE	O
*	O
o	pointer
)	O
{	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
s	pointer
)	O
)	O
s	pointer
=	O
local_symbol_convert	function
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
s	pointer
)	O
;	O
s	pointer
->	O
sy_obj	struct
=	O
*	O
o	pointer
;	O
}	O
void	O
symbol_begin	function
(	O
void	O
)	O
{	O
symbol_lastP	pointer
=	O
NULL	O
;	O
symbol_rootP	pointer
=	O
NULL	O
;	O
sy_hash	pointer
=	O
hash_new	function
(	O
)	O
;	O
local_hash	pointer
=	O
hash_new	function
(	O
)	O
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
(	O
&	O
abs_symbol	struct
)	O
,	O
'\0'	O
,	O
sizeof	O
(	O
abs_symbol	struct
)	O
)	O
;	O
abs_symbol	struct
.	O
bsym	pointer
=	O
bfd_abs_section_ptr	O
->	O
symbol	pointer
;	O
abs_symbol	struct
.	O
sy_value	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
abs_symbol	struct
.	O
sy_frag	pointer
=	O
&	O
zero_address_frag	struct
;	O
if	O
(	O
LOCAL_LABELS_FB	int
)	O
fb_label_init	function
(	O
)	O
;	O
}	O
void	O
dot_symbol_init	function
(	O
void	O
)	O
{	O
dot_symbol	struct
.	O
bsym	pointer
=	O
bfd_make_empty_symbol	O
(	O
stdoutput	pointer
)	O
;	O
if	O
(	O
dot_symbol	struct
.	O
bsym	pointer
==	O
NULL	O
)	O
as_fatal	function
(	O
"bfd_make_empty_symbol: %s"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
dot_symbol	struct
.	O
bsym	pointer
->	O
name	pointer
=	O
"."	pointer
;	O
dot_symbol	struct
.	O
sy_flags	struct
.	O
sy_forward_ref	int
=	O
1	int
;	O
dot_symbol	struct
.	O
sy_value	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
}	O
int	O
indent_level	int
;	O
static	O
int	O
max_indent_level	int
=	O
8	int
;	O
void	O
print_symbol_value_1	function
(	O
FILE	struct
*	O
file	pointer
,	O
symbolS	struct
*	O
sym	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
S_GET_NAME	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
||	O
!	O
name	pointer
[	O
0	int
]	O
)	O
name	pointer
=	O
"(unnamed)"	pointer
;	O
fprintf	function
(	O
file	pointer
,	O
"sym "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
sym	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %s"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
sym	pointer
)	O
)	O
{	O
struct	O
local_symbol	struct
*	O
locsym	pointer
=	O
(	O
struct	O
local_symbol	struct
*	O
)	O
sym	pointer
;	O
if	O
(	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
!=	O
&	O
zero_address_frag	struct
&&	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
" frag "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
local_symbol_get_frag	O
(	O
locsym	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
local_symbol_resolved_p	O
(	O
locsym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" resolved"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" local"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sym	pointer
->	O
sy_frag	pointer
!=	O
&	O
zero_address_frag	struct
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
" frag "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
sym	pointer
->	O
sy_frag	pointer
)	O
)	O
;	O
}	O
if	O
(	O
sym	pointer
->	O
sy_flags	struct
.	O
sy_written	int
)	O
fprintf	function
(	O
file	pointer
,	O
" written"	pointer
)	O
;	O
if	O
(	O
sym	pointer
->	O
sy_flags	struct
.	O
sy_resolved	int
)	O
fprintf	function
(	O
file	pointer
,	O
" resolved"	pointer
)	O
;	O
else	O
if	O
(	O
sym	pointer
->	O
sy_flags	struct
.	O
sy_resolving	int
)	O
fprintf	function
(	O
file	pointer
,	O
" resolving"	pointer
)	O
;	O
if	O
(	O
sym	pointer
->	O
sy_flags	struct
.	O
sy_used_in_reloc	int
)	O
fprintf	function
(	O
file	pointer
,	O
" used-in-reloc"	pointer
)	O
;	O
if	O
(	O
sym	pointer
->	O
sy_flags	struct
.	O
sy_used	int
)	O
fprintf	function
(	O
file	pointer
,	O
" used"	pointer
)	O
;	O
if	O
(	O
S_IS_LOCAL	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" local"	pointer
)	O
;	O
if	O
(	O
S_IS_EXTERNAL	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" extern"	pointer
)	O
;	O
if	O
(	O
S_IS_WEAK	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" weak"	pointer
)	O
;	O
if	O
(	O
S_IS_DEBUG	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" debug"	pointer
)	O
;	O
if	O
(	O
S_IS_DEFINED	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" defined"	pointer
)	O
;	O
}	O
if	O
(	O
S_IS_WEAKREFR	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" weakrefr"	pointer
)	O
;	O
if	O
(	O
S_IS_WEAKREFD	function
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" weakrefd"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %s"	pointer
,	O
segment_name	O
(	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
)	O
)	O
;	O
if	O
(	O
symbol_resolved_p	function
(	O
sym	pointer
)	O
)	O
{	O
segT	pointer
s	pointer
=	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
undefined_section	O
&&	O
s	pointer
!=	O
expr_section	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
" %lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
S_GET_VALUE	function
(	O
sym	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
indent_level	int
<	O
max_indent_level	int
&&	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
!=	O
undefined_section	O
)	O
{	O
indent_level	int
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
if	O
(	O
LOCAL_SYMBOL_CHECK	O
(	O
sym	pointer
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
"constant %lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
struct	O
local_symbol	struct
*	O
)	O
sym	pointer
)	O
->	O
lsy_value	long
)	O
;	O
else	O
print_expr_1	function
(	O
file	pointer
,	O
&	O
sym	pointer
->	O
sy_value	struct
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">"	pointer
)	O
;	O
indent_level	int
--	O
;	O
}	O
fflush	function
(	O
file	pointer
)	O
;	O
}	O
void	O
print_symbol_value	function
(	O
symbolS	struct
*	O
sym	pointer
)	O
{	O
indent_level	int
=	O
0	int
;	O
print_symbol_value_1	function
(	O
stderr	pointer
,	O
sym	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
print_binary	function
(	O
FILE	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
expressionS	struct
*	O
exp	pointer
)	O
{	O
indent_level	int
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%s\n%*s<"	pointer
,	O
name	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">"	pointer
)	O
;	O
indent_level	int
--	O
;	O
}	O
void	O
print_expr_1	function
(	O
FILE	struct
*	O
file	pointer
,	O
expressionS	struct
*	O
exp	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"expr "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
exp	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" "	pointer
)	O
;	O
switch	O
(	O
exp	pointer
->	O
X_op	enum
)	O
{	O
case	O
O_illegal	int
:	O
fprintf	function
(	O
file	pointer
,	O
"illegal"	pointer
)	O
;	O
break	O
;	O
case	O
O_absent	int
:	O
fprintf	function
(	O
file	pointer
,	O
"absent"	pointer
)	O
;	O
break	O
;	O
case	O
O_constant	int
:	O
fprintf	function
(	O
file	pointer
,	O
"constant %lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
exp	pointer
->	O
X_add_number	long
)	O
;	O
break	O
;	O
case	O
O_symbol	int
:	O
indent_level	int
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"symbol\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">"	pointer
)	O
;	O
maybe_print_addnum	O
:	O
if	O
(	O
exp	pointer
->	O
X_add_number	long
)	O
fprintf	function
(	O
file	pointer
,	O
"\n%*s%lx"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
,	O
(	O
unsigned	O
long	O
)	O
exp	pointer
->	O
X_add_number	long
)	O
;	O
indent_level	int
--	O
;	O
break	O
;	O
case	O
O_register	int
:	O
fprintf	function
(	O
file	pointer
,	O
"register #%d"	pointer
,	O
(	O
int	O
)	O
exp	pointer
->	O
X_add_number	long
)	O
;	O
break	O
;	O
case	O
O_big	int
:	O
fprintf	function
(	O
file	pointer
,	O
"big"	pointer
)	O
;	O
break	O
;	O
case	O
O_uminus	int
:	O
fprintf	function
(	O
file	pointer
,	O
"uminus -<"	pointer
)	O
;	O
indent_level	int
++	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">"	pointer
)	O
;	O
goto	O
maybe_print_addnum	O
;	O
case	O
O_bit_not	int
:	O
fprintf	function
(	O
file	pointer
,	O
"bit_not"	pointer
)	O
;	O
break	O
;	O
case	O
O_multiply	int
:	O
print_binary	function
(	O
file	pointer
,	O
"multiply"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_divide	int
:	O
print_binary	function
(	O
file	pointer
,	O
"divide"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_modulus	int
:	O
print_binary	function
(	O
file	pointer
,	O
"modulus"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_left_shift	int
:	O
print_binary	function
(	O
file	pointer
,	O
"lshift"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_right_shift	int
:	O
print_binary	function
(	O
file	pointer
,	O
"rshift"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_bit_inclusive_or	int
:	O
print_binary	function
(	O
file	pointer
,	O
"bit_ior"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_bit_exclusive_or	int
:	O
print_binary	function
(	O
file	pointer
,	O
"bit_xor"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_bit_and	int
:	O
print_binary	function
(	O
file	pointer
,	O
"bit_and"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_eq	int
:	O
print_binary	function
(	O
file	pointer
,	O
"eq"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_ne	int
:	O
print_binary	function
(	O
file	pointer
,	O
"ne"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_lt	int
:	O
print_binary	function
(	O
file	pointer
,	O
"lt"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_le	int
:	O
print_binary	function
(	O
file	pointer
,	O
"le"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_ge	int
:	O
print_binary	function
(	O
file	pointer
,	O
"ge"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_gt	int
:	O
print_binary	function
(	O
file	pointer
,	O
"gt"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_logical_and	int
:	O
print_binary	function
(	O
file	pointer
,	O
"logical_and"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_logical_or	int
:	O
print_binary	function
(	O
file	pointer
,	O
"logical_or"	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
O_add	int
:	O
indent_level	int
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"add\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">"	pointer
)	O
;	O
goto	O
maybe_print_addnum	O
;	O
case	O
O_subtract	int
:	O
indent_level	int
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"subtract\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">\n%*s<"	pointer
,	O
indent_level	int
*	O
4	int
,	O
""	pointer
)	O
;	O
print_symbol_value_1	function
(	O
file	pointer
,	O
exp	pointer
->	O
X_op_symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
">"	pointer
)	O
;	O
goto	O
maybe_print_addnum	O
;	O
default	O
:	O
fprintf	function
(	O
file	pointer
,	O
"{unknown opcode %d}"	pointer
,	O
(	O
int	O
)	O
exp	pointer
->	O
X_op	enum
)	O
;	O
break	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
print_expr	function
(	O
expressionS	struct
*	O
exp	pointer
)	O
{	O
print_expr_1	function
(	O
stderr	pointer
,	O
exp	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
symbol_print_statistics	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
hash_print_statistics	function
(	O
file	pointer
,	O
"symbol table"	pointer
,	O
sy_hash	pointer
)	O
;	O
hash_print_statistics	function
(	O
file	pointer
,	O
"mini local symbol table"	pointer
,	O
local_hash	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%lu mini local symbols created, %lu converted\n"	pointer
,	O
local_symbol_count	long
,	O
local_symbol_conversion_count	long
)	O
;	O
}	O
