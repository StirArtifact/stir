static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_recno.c,v 1.4 2014/04/17 20:27:25 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__ram_add	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
void	O
__ram_ca	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
,	O
ca_recno_arg	enum
)	O
)	O
;	O
static	O
int	O
__ram_delete	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ram_fmap	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
)	O
)	O
;	O
static	O
int	O
__ram_put	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ram_source	function
__P	O
(	O
(	O
DB	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ram_update	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
,	O
int	O
)	O
)	O
;	O
static	O
int	O
__ram_vmap	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
)	O
)	O
;	O
int	O
CDB___ram_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
base_pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
db_pgno_t	int
base_pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
dbp	pointer
->	O
del	pointer
=	O
__ram_delete	function
;	O
dbp	pointer
->	O
put	pointer
=	O
__ram_put	function
;	O
dbp	pointer
->	O
stat	pointer
=	O
CDB___bam_stat	function
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_read_root	function
(	O
dbp	pointer
,	O
name	pointer
,	O
base_pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
t	pointer
->	O
re_source	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
__ram_source	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_SNAPSHOT	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
NULL	O
,	O
&	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__ram_update	function
(	O
dbc	pointer
,	O
DB_MAX_RECORDS	int
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
DB_NOTFOUND	O
)	O
ret	int
=	O
0	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
t	pointer
->	O
re_smap	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___os_unmapfile	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_smap	pointer
,	O
t	pointer
->	O
re_msize	long
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
t	pointer
->	O
re_fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
t	pointer
->	O
re_fh	struct
)	O
;	O
if	O
(	O
t	pointer
->	O
re_source	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
t	pointer
->	O
re_source	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ram_delete	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	struct
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
recno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_delchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
txn	pointer
,	O
&	O
dbc	pointer
,	O
DB_WRITELOCK	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc	pointer
,	O
txn	pointer
,	O
"ram_delete"	pointer
,	O
key	struct
,	O
NULL	O
,	O
flags	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ram_getno	function
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
recno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
cp	pointer
->	O
recno	int
=	O
recno	int
;	O
ret	int
=	O
CDB___ram_c_del	function
(	O
dbc	pointer
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ram_put	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
recno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_putchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
txn	pointer
,	O
&	O
dbc	pointer
,	O
DB_WRITELOCK	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc	pointer
,	O
txn	pointer
,	O
"ram_put"	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
flags	int
==	O
DB_APPEND	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__ram_update	function
(	O
dbc	pointer
,	O
DB_MAX_RECORDS	int
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
DB_NOTFOUND	O
)	O
ret	int
=	O
0	int
;	O
}	O
else	O
ret	int
=	O
CDB___ram_getno	function
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
recno	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
__ram_add	function
(	O
dbc	pointer
,	O
&	O
recno	int
,	O
data	pointer
,	O
flags	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
flags	int
==	O
DB_APPEND	int
)	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
recno	int
,	O
sizeof	O
(	O
recno	int
)	O
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ram_c_del	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BKEYDATA	struct
bk	struct
;	O
BTREE	struct
*	O
t	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
hdr	struct
,	O
data	pointer
;	O
EPG	struct
*	O
epg	pointer
;	O
int	O
exact	int
,	O
ret	int
,	O
stack	array
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
stack	array
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
S_DELETE	O
,	O
1	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
stack	array
=	O
1	int
;	O
cp	pointer
->	O
page	pointer
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
;	O
cp	pointer
->	O
pgno	int
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
->	O
pgno	int
;	O
cp	pointer
->	O
indx	short
=	O
cp	pointer
->	O
csp	pointer
->	O
indx	short
;	O
if	O
(	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
->	O
type	enum
)	O
)	O
{	O
ret	int
=	O
DB_KEYEMPTY	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RENUMBER	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_ditem	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___bam_adjust	function
(	O
dbc	pointer
,	O
-	O
1	int
)	O
;	O
__ram_ca	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
recno	int
,	O
CA_DELETE	int
)	O
;	O
if	O
(	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
0	int
&&	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
!=	O
cp	pointer
->	O
root	int
)	O
{	O
for	O
(	O
epg	pointer
=	O
cp	pointer
->	O
sp	pointer
;	O
epg	pointer
<=	O
cp	pointer
->	O
csp	pointer
;	O
++	O
epg	pointer
)	O
if	O
(	O
NUM_ENT	O
(	O
epg	pointer
->	O
page	pointer
)	O
<=	O
1	int
)	O
break	O
;	O
ret	int
=	O
CDB___bam_dpages	function
(	O
dbc	pointer
,	O
--	O
epg	pointer
)	O
;	O
stack	array
=	O
0	int
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_ditem	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
B_TSET	O
(	O
bk	struct
.	O
type	enum
,	O
B_KEYDATA	int
,	O
1	int
)	O
;	O
bk	struct
.	O
len	short
=	O
0	int
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
bk	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BKEYDATA	struct
,	O
data	pointer
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
data	pointer
.	O
data	pointer
=	O
(	O
void	O
*	O
)	O
""	pointer
;	O
data	pointer
.	O
size	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
,	O
BKEYDATA_SIZE	O
(	O
0	int
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
F_SET	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
err	pointer
:	O
if	O
(	O
stack	array
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ram_c_get	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
if	O
(	O
pgnop	pointer
==	O
NULL	O
)	O
{	O
pgnop	pointer
=	O
NULL	O
;	O
}	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int	O
cmp	int
,	O
exact	int
,	O
ret	int
;	O
COMPQUIET	O
(	O
pgnop	pointer
,	O
NULL	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
retry	O
:	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_CURRENT	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
&&	O
F_ISSET	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
)	O
return	O
(	O
DB_KEYEMPTY	O
)	O
;	O
break	O
;	O
case	O
DB_NEXT_DUP	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
case	O
DB_NEXT_NODUP	int
:	O
case	O
DB_NEXT	int
:	O
flags	int
=	O
DB_NEXT	int
;	O
if	O
(	O
CD_ISSET	O
(	O
dbp	pointer
,	O
cp	pointer
)	O
)	O
break	O
;	O
if	O
(	O
cp	pointer
->	O
recno	int
!=	O
RECNO_OOB	int
)	O
{	O
++	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
}	O
case	O
DB_FIRST	int
:	O
flags	int
=	O
DB_NEXT	int
;	O
cp	pointer
->	O
recno	int
=	O
1	int
;	O
break	O
;	O
case	O
DB_PREV_NODUP	int
:	O
case	O
DB_PREV	int
:	O
flags	int
=	O
DB_PREV	int
;	O
if	O
(	O
cp	pointer
->	O
recno	int
!=	O
RECNO_OOB	int
)	O
{	O
if	O
(	O
cp	pointer
->	O
recno	int
==	O
1	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
--	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
}	O
case	O
DB_LAST	int
:	O
flags	int
=	O
DB_PREV	int
;	O
if	O
(	O
(	O
(	O
ret	int
=	O
__ram_update	function
(	O
dbc	pointer
,	O
DB_MAX_RECORDS	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
cp	pointer
->	O
recno	int
==	O
0	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_GET_BOTHC	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
cp	pointer
->	O
recno	int
++	O
;	O
break	O
;	O
}	O
else	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
case	O
DB_GET_BOTH	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
cp	pointer
->	O
recno	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RANGE	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ram_getno	function
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___ram_c_get"	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
flags	int
==	O
DB_NEXT	int
||	O
flags	int
==	O
DB_CURRENT	int
)	O
&&	O
(	O
(	O
ret	int
=	O
__ram_update	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
recno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
goto	O
err	pointer
;	O
for	O
(	O
;	O
;	O
++	O
cp	pointer
->	O
recno	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
S_FIND_WR	O
:	O
S_FIND	O
,	O
1	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
cp	pointer
->	O
page	pointer
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
;	O
cp	pointer
->	O
pgno	int
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
->	O
pgno	int
;	O
cp	pointer
->	O
indx	short
=	O
cp	pointer
->	O
csp	pointer
->	O
indx	short
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
cp	pointer
->	O
lock	struct
=	O
cp	pointer
->	O
csp	pointer
->	O
lock	struct
;	O
cp	pointer
->	O
lock_mode	enum
=	O
cp	pointer
->	O
csp	pointer
->	O
lock_mode	enum
;	O
if	O
(	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
->	O
type	enum
)	O
)	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_NEXT	int
:	O
case	O
DB_PREV	int
:	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
goto	O
retry	O
;	O
case	O
DB_GET_BOTH	int
:	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
continue	O
;	O
default	O
:	O
ret	int
=	O
DB_KEYEMPTY	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
flags	int
==	O
DB_GET_BOTH	int
||	O
flags	int
==	O
DB_GET_BOTHC	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
,	O
CDB___bam_defcmp	function
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
if	O
(	O
flags	int
!=	O
DB_SET	int
&&	O
flags	int
!=	O
DB_SET_RANGE	int
)	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
,	O
sizeof	O
(	O
cp	pointer
->	O
recno	int
)	O
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
;	O
F_SET	O
(	O
key	struct
,	O
DB_DBT_ISSET	int
)	O
;	O
}	O
err	pointer
:	O
CD_CLR	O
(	O
dbp	pointer
,	O
cp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ram_c_put	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
if	O
(	O
pgnop	pointer
==	O
NULL	O
)	O
{	O
pgnop	pointer
=	O
NULL	O
;	O
}	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int	O
exact	int
,	O
ret	int
,	O
t_ret	int
;	O
void	O
*	O
arg	pointer
;	O
COMPQUIET	O
(	O
pgnop	pointer
,	O
NULL	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_KEYFIRST	int
:	O
cp	pointer
->	O
recno	int
=	O
1	int
;	O
flags	int
=	O
DB_BEFORE	int
;	O
break	O
;	O
case	O
DB_KEYLAST	int
:	O
return	O
(	O
__ram_add	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
data	pointer
,	O
DB_APPEND	int
,	O
0	int
)	O
)	O
;	O
}	O
split	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
S_INSERT	O
,	O
1	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
cp	pointer
->	O
page	pointer
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
;	O
cp	pointer
->	O
pgno	int
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
->	O
pgno	int
;	O
cp	pointer
->	O
indx	short
=	O
cp	pointer
->	O
csp	pointer
->	O
indx	short
;	O
ret	int
=	O
CDB___bam_iitem	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
0	int
)	O
;	O
t_ret	int
=	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
if	O
(	O
t_ret	int
!=	O
0	int
&&	O
(	O
ret	int
==	O
0	int
||	O
ret	int
==	O
DB_NEEDSPLIT	O
)	O
)	O
ret	int
=	O
t_ret	int
;	O
else	O
if	O
(	O
ret	int
==	O
DB_NEEDSPLIT	O
)	O
{	O
arg	pointer
=	O
&	O
cp	pointer
->	O
recno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_split	function
(	O
dbc	pointer
,	O
arg	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
goto	O
split	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_AFTER	int
:	O
__ram_ca	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
recno	int
,	O
CA_IAFTER	int
)	O
;	O
++	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
case	O
DB_BEFORE	int
:	O
__ram_ca	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
recno	int
,	O
CA_IBEFORE	int
)	O
;	O
--	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
&&	O
(	O
flags	int
==	O
DB_AFTER	int
||	O
flags	int
==	O
DB_BEFORE	int
)	O
)	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
,	O
sizeof	O
(	O
cp	pointer
->	O
recno	int
)	O
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
;	O
err	pointer
:	O
CD_CLR	O
(	O
dbp	pointer
,	O
cp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
void	O
__ram_ca	function
(	O
dbc_arg	pointer
,	O
recno	int
,	O
op	enum
)	O
DBC	struct
*	O
dbc_arg	pointer
;	O
db_recno_t	int
recno	int
;	O
ca_recno_arg	enum
op	enum
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
nrecs	int
;	O
dbp	pointer
=	O
dbc_arg	pointer
->	O
dbp	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
dbc	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
;	O
dbc	pointer
!=	O
NULL	O
;	O
dbc	pointer
=	O
TAILQ_NEXT	O
(	O
dbc	pointer
,	O
links	struct
)	O
)	O
{	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
dbc_arg	pointer
->	O
internal	pointer
->	O
root	int
!=	O
cp	pointer
->	O
root	int
)	O
continue	O
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
CA_DELETE	int
:	O
if	O
(	O
recno	int
<	O
cp	pointer
->	O
recno	int
)	O
--	O
cp	pointer
->	O
recno	int
;	O
if	O
(	O
recno	int
==	O
cp	pointer
->	O
recno	int
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
&&	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
&	O
nrecs	int
)	O
==	O
0	int
&&	O
recno	int
>	O
nrecs	int
)	O
--	O
cp	pointer
->	O
recno	int
;	O
else	O
CD_SET	O
(	O
dbp	pointer
,	O
cp	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CA_IAFTER	int
:	O
if	O
(	O
recno	int
<	O
cp	pointer
->	O
recno	int
)	O
++	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
case	O
CA_IBEFORE	int
:	O
if	O
(	O
recno	int
<=	O
cp	pointer
->	O
recno	int
)	O
++	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
}	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
}	O
int	O
CDB___ram_getno	function
(	O
dbc	pointer
,	O
key	struct
,	O
rep	pointer
,	O
can_create	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
db_recno_t	int
*	O
rep	pointer
;	O
int	O
can_create	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
db_recno_t	int
recno	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
(	O
recno	int
=	O
*	O
(	O
db_recno_t	int
*	O
)	O
key	struct
->	O
data	pointer
)	O
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"illegal record number of 0"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
rep	pointer
!=	O
NULL	O
)	O
*	O
rep	pointer
=	O
recno	int
;	O
return	O
(	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_RECNO	int
?	O
__ram_update	function
(	O
dbc	pointer
,	O
recno	int
,	O
can_create	int
)	O
:	O
0	int
)	O
;	O
}	O
static	O
int	O
__ram_update	function
(	O
dbc	pointer
,	O
recno	int
,	O
can_create	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
recno	int
;	O
int	O
can_create	int
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
db_recno_t	int
nrecs	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
if	O
(	O
!	O
can_create	int
&&	O
!	O
F_ISSET	O
(	O
t	pointer
,	O
RECNO_READFILE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
&	O
nrecs	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
t	pointer
,	O
RECNO_READFILE	int
)	O
&&	O
recno	int
>	O
nrecs	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
t	pointer
->	O
re_irec	pointer
(	O
dbc	pointer
,	O
recno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
&	O
nrecs	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
!	O
can_create	int
||	O
recno	int
<=	O
nrecs	int
+	O
1	int
)	O
return	O
(	O
0	int
)	O
;	O
dbc	pointer
->	O
rdata	struct
.	O
dlen	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
doff	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
flags	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
)	O
{	O
if	O
(	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
<	O
t	pointer
->	O
re_len	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_len	int
,	O
NULL	O
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
=	O
t	pointer
->	O
re_len	int
;	O
}	O
dbc	pointer
->	O
rdata	struct
.	O
size	int
=	O
t	pointer
->	O
re_len	int
;	O
memset	function
(	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
t	pointer
->	O
re_pad	int
,	O
t	pointer
->	O
re_len	int
)	O
;	O
}	O
else	O
dbc	pointer
->	O
rdata	struct
.	O
size	int
=	O
0	int
;	O
while	O
(	O
recno	int
>	O
++	O
nrecs	int
)	O
if	O
(	O
(	O
ret	int
=	O
__ram_add	function
(	O
dbc	pointer
,	O
&	O
nrecs	int
,	O
&	O
dbc	pointer
->	O
rdata	struct
,	O
0	int
,	O
BI_DELETED	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ram_source	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
size_t	long
size	int
;	O
u_int32_t	int
bytes	long
,	O
mbytes	int
;	O
char	O
*	O
source	pointer
;	O
int	O
ret	int
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
source	pointer
=	O
t	pointer
->	O
re_source	pointer
;	O
ret	int
=	O
CDB___db_appname	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
source	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
t	pointer
->	O
re_source	pointer
)	O
;	O
CDB___os_freestr	function
(	O
source	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
ret	int
=	O
CDB___os_open	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
?	O
DB_OSO_RDONLY	int
:	O
0	int
,	O
0	int
,	O
&	O
t	pointer
->	O
re_fh	struct
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
&&	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
)	O
ret	int
=	O
CDB___os_open	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
DB_OSO_RDONLY	int
,	O
0	int
,	O
&	O
t	pointer
->	O
re_fh	struct
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_ioinfo	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
&	O
t	pointer
->	O
re_fh	struct
,	O
&	O
mbytes	int
,	O
&	O
bytes	long
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
mbytes	int
==	O
0	int
&&	O
bytes	long
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
size	int
=	O
mbytes	int
*	O
MEGABYTE	int
+	O
bytes	long
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_mapfile	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
&	O
t	pointer
->	O
re_fh	struct
,	O
(	O
size_t	long
)	O
size	int
,	O
1	int
,	O
&	O
t	pointer
->	O
re_smap	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
t	pointer
->	O
re_cmap	pointer
=	O
t	pointer
->	O
re_smap	pointer
;	O
t	pointer
->	O
re_emap	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
t	pointer
->	O
re_smap	pointer
+	O
(	O
t	pointer
->	O
re_msize	long
=	O
size	int
)	O
;	O
t	pointer
->	O
re_irec	pointer
=	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
?	O
__ram_fmap	function
:	O
__ram_vmap	function
;	O
F_SET	O
(	O
t	pointer
,	O
RECNO_READFILE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ram_writeback	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
fh	struct
;	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
key	struct
,	O
data	pointer
;	O
db_recno_t	int
keyno	int
;	O
size_t	long
nw	long
;	O
int	O
ret	int
,	O
t_ret	int
;	O
u_int8_t	char
delim	char
,	O
*	O
pad	long
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
t	pointer
->	O
re_source	pointer
==	O
NULL	O
)	O
{	O
F_CLR	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
NULL	O
,	O
&	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__ram_update	function
(	O
dbc	pointer
,	O
DB_MAX_RECORDS	int
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
t	pointer
->	O
re_smap	pointer
!=	O
NULL	O
)	O
{	O
(	O
void	O
)	O
CDB___os_unmapfile	function
(	O
dbenv	pointer
,	O
t	pointer
->	O
re_smap	pointer
,	O
t	pointer
->	O
re_msize	long
)	O
;	O
t	pointer
->	O
re_smap	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
t	pointer
->	O
re_fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
t	pointer
->	O
re_fh	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
DB_OSO_SEQ	int
|	O
DB_OSO_TRUNC	int
,	O
0	int
,	O
&	O
fh	struct
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
t	pointer
->	O
re_source	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
memset	function
(	O
&	O
key	struct
,	O
0	int
,	O
sizeof	O
(	O
key	struct
)	O
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
key	struct
.	O
size	int
=	O
sizeof	O
(	O
db_recno_t	int
)	O
;	O
key	struct
.	O
data	pointer
=	O
&	O
keyno	int
;	O
delim	char
=	O
t	pointer
->	O
re_delim	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
t	pointer
->	O
re_len	int
,	O
NULL	O
,	O
&	O
pad	long
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memset	function
(	O
pad	long
,	O
t	pointer
->	O
re_pad	int
,	O
t	pointer
->	O
re_len	int
)	O
;	O
}	O
else	O
COMPQUIET	O
(	O
pad	long
,	O
NULL	O
)	O
;	O
for	O
(	O
keyno	int
=	O
1	int
;	O
;	O
++	O
keyno	int
)	O
{	O
switch	O
(	O
ret	int
=	O
dbp	pointer
->	O
get	pointer
(	O
dbp	pointer
,	O
NULL	O
,	O
&	O
key	struct
,	O
&	O
data	pointer
,	O
0	int
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
&	O
fh	struct
,	O
data	pointer
.	O
data	pointer
,	O
data	pointer
.	O
size	int
,	O
&	O
nw	long
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
nw	long
!=	O
(	O
size_t	long
)	O
data	pointer
.	O
size	int
)	O
{	O
ret	int
=	O
EIO	int
;	O
goto	O
write_err	O
;	O
}	O
break	O
;	O
case	O
DB_KEYEMPTY	O
:	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
&	O
fh	struct
,	O
pad	long
,	O
t	pointer
->	O
re_len	int
,	O
&	O
nw	long
)	O
)	O
!=	O
0	int
)	O
goto	O
write_err	O
;	O
if	O
(	O
nw	long
!=	O
(	O
size_t	long
)	O
t	pointer
->	O
re_len	int
)	O
{	O
ret	int
=	O
EIO	int
;	O
goto	O
write_err	O
;	O
}	O
}	O
break	O
;	O
case	O
DB_NOTFOUND	O
:	O
ret	int
=	O
0	int
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
&	O
fh	struct
,	O
&	O
delim	char
,	O
1	int
,	O
&	O
nw	long
)	O
)	O
!=	O
0	int
)	O
goto	O
write_err	O
;	O
if	O
(	O
nw	long
!=	O
1	int
)	O
{	O
ret	int
=	O
EIO	int
;	O
write_err	O
:	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Write failed to backing file"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
}	O
err	pointer
:	O
done	O
:	O
if	O
(	O
F_ISSET	O
(	O
&	O
fh	struct
,	O
DB_FH_VALID	int
)	O
&&	O
(	O
t_ret	int
=	O
CDB___os_closehandle	function
(	O
&	O
fh	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
F_CLR	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ram_fmap	function
(	O
dbc	pointer
,	O
top	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
top	int
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
data	pointer
;	O
db_recno_t	int
recno	int
;	O
u_int32_t	int
len	short
;	O
u_int8_t	char
*	O
sp	pointer
,	O
*	O
ep	pointer
,	O
*	O
p	pointer
;	O
int	O
is_modified	int
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
&	O
recno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
<	O
t	pointer
->	O
re_len	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_len	int
,	O
NULL	O
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
=	O
0	int
;	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
=	O
t	pointer
->	O
re_len	int
;	O
}	O
is_modified	int
=	O
F_ISSET	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
data	pointer
.	O
data	pointer
=	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
;	O
data	pointer
.	O
size	int
=	O
t	pointer
->	O
re_len	int
;	O
sp	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
t	pointer
->	O
re_cmap	pointer
;	O
ep	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
t	pointer
->	O
re_emap	pointer
;	O
while	O
(	O
recno	int
<	O
top	int
)	O
{	O
if	O
(	O
sp	pointer
>=	O
ep	pointer
)	O
{	O
F_CLR	O
(	O
t	pointer
,	O
RECNO_READFILE	int
)	O
;	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
len	short
=	O
t	pointer
->	O
re_len	int
;	O
for	O
(	O
p	pointer
=	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
;	O
sp	pointer
<	O
ep	pointer
&&	O
len	short
>	O
0	int
;	O
*	O
p	pointer
++	O
=	O
*	O
sp	pointer
++	O
,	O
--	O
len	short
)	O
;	O
if	O
(	O
t	pointer
->	O
re_last	int
>=	O
recno	int
)	O
{	O
if	O
(	O
len	short
!=	O
0	int
)	O
memset	function
(	O
p	pointer
,	O
t	pointer
->	O
re_pad	int
,	O
len	short
)	O
;	O
++	O
recno	int
;	O
if	O
(	O
(	O
ret	int
=	O
__ram_add	function
(	O
dbc	pointer
,	O
&	O
recno	int
,	O
&	O
data	pointer
,	O
0	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
++	O
t	pointer
->	O
re_last	int
;	O
}	O
t	pointer
->	O
re_cmap	pointer
=	O
sp	pointer
;	O
err	pointer
:	O
if	O
(	O
!	O
is_modified	int
)	O
F_CLR	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ram_vmap	function
(	O
dbc	pointer
,	O
top	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
top	int
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
DBT	struct
data	pointer
;	O
db_recno_t	int
recno	int
;	O
u_int8_t	char
*	O
sp	pointer
,	O
*	O
ep	pointer
;	O
int	O
delim	char
,	O
is_modified	int
,	O
ret	int
;	O
t	pointer
=	O
dbc	pointer
->	O
dbp	pointer
->	O
bt_internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
&	O
recno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
delim	char
=	O
t	pointer
->	O
re_delim	int
;	O
is_modified	int
=	O
F_ISSET	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
sp	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
t	pointer
->	O
re_cmap	pointer
;	O
ep	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
t	pointer
->	O
re_emap	pointer
;	O
while	O
(	O
recno	int
<	O
top	int
)	O
{	O
if	O
(	O
sp	pointer
>=	O
ep	pointer
)	O
{	O
F_CLR	O
(	O
t	pointer
,	O
RECNO_READFILE	int
)	O
;	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
for	O
(	O
data	pointer
.	O
data	pointer
=	O
sp	pointer
;	O
sp	pointer
<	O
ep	pointer
&&	O
*	O
sp	pointer
!=	O
delim	char
;	O
++	O
sp	pointer
)	O
;	O
if	O
(	O
t	pointer
->	O
re_last	int
>=	O
recno	int
)	O
{	O
data	pointer
.	O
size	int
=	O
sp	pointer
-	O
(	O
u_int8_t	char
*	O
)	O
data	pointer
.	O
data	pointer
;	O
++	O
recno	int
;	O
if	O
(	O
(	O
ret	int
=	O
__ram_add	function
(	O
dbc	pointer
,	O
&	O
recno	int
,	O
&	O
data	pointer
,	O
0	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
++	O
t	pointer
->	O
re_last	int
;	O
++	O
sp	pointer
;	O
}	O
t	pointer
->	O
re_cmap	pointer
=	O
sp	pointer
;	O
err	pointer
:	O
if	O
(	O
!	O
is_modified	int
)	O
F_CLR	O
(	O
t	pointer
,	O
RECNO_MODIFIED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ram_add	function
(	O
dbc	pointer
,	O
recnop	pointer
,	O
data	pointer
,	O
flags	int
,	O
bi_flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
,	O
bi_flags	int
;	O
{	O
BKEYDATA	struct
*	O
bk	struct
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
int	O
exact	int
,	O
ret	int
,	O
stack	array
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
retry	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
recnop	pointer
,	O
S_INSERT	O
|	O
(	O
flags	int
==	O
DB_APPEND	int
?	O
S_APPEND	int
:	O
0	int
)	O
,	O
1	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
stack	array
=	O
1	int
;	O
cp	pointer
->	O
page	pointer
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
;	O
cp	pointer
->	O
pgno	int
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
->	O
pgno	int
;	O
cp	pointer
->	O
indx	short
=	O
cp	pointer
->	O
csp	pointer
->	O
indx	short
;	O
if	O
(	O
exact	int
)	O
{	O
bk	struct
=	O
GET_BKEYDATA	O
(	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
!	O
B_DISSET	O
(	O
bk	struct
->	O
type	enum
)	O
&&	O
flags	int
==	O
DB_NOOVERWRITE	int
)	O
{	O
ret	int
=	O
DB_KEYEXIST	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
switch	O
(	O
ret	int
=	O
CDB___bam_iitem	function
(	O
dbc	pointer
,	O
NULL	O
,	O
data	pointer
,	O
exact	int
?	O
DB_CURRENT	int
:	O
DB_BEFORE	int
,	O
bi_flags	int
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
DB_NEEDSPLIT	O
:	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
stack	array
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_split	function
(	O
dbc	pointer
,	O
recnop	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
goto	O
retry	O
;	O
default	O
:	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
stack	array
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
