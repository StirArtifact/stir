static	O
char	O
*	O
rpmpsf_make_dfiles	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
dfiles	pointer
,	O
int	O
len	int
)	O
;	O
static	O
char	O
*	O
de_quote_it	function
(	O
char	O
*	O
src	pointer
)	O
;	O
static	O
void	O
strip_newline	function
(	O
char	O
*	O
s	pointer
)	O
;	O
struct	O
header_lookup_cache	struct
{	O
void	O
*	O
header	struct
;	O
void	O
*	O
data	pointer
;	O
int	O
count	long
;	O
}	O
;	O
static	O
struct	O
header_lookup_cache	struct
HeaderLookupCacheArray	array
[	O
SWMAP_MAX_LENGTH	int
+	O
1	int
]	O
;	O
static	O
int	O
write_object_keyword	function
(	O
char	O
*	O
kw	pointer
,	O
int	O
uxfio_ofd	int
)	O
;	O
static	O
int	O
write_keyword	function
(	O
char	O
*	O
kw	pointer
,	O
int	O
uxfio_ofd	int
)	O
;	O
static	O
int	O
write_keyword	function
(	O
char	O
*	O
kw	pointer
,	O
int	O
uxfio_ofd	int
)	O
;	O
static	O
int	O
write__req	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
count	long
,	O
int	O
NAME_TAG	int
,	O
int	O
VERSION_TAG	int
,	O
int	O
FLAGS_TAG	int
,	O
STROB	struct
*	O
strb	pointer
,	O
STROB	struct
*	O
swreq	pointer
,	O
STROB	struct
*	O
rpmreq	pointer
,	O
char	O
*	O
)	O
;	O
static	O
int	O
get_filetype	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
path	pointer
,	O
mode_t	int
mode	int
,	O
char	O
*	O
*	O
link_s	pointer
)	O
;	O
static	O
int	O
classify_filelist	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
*	O
typevector	pointer
,	O
int	O
length	int
)	O
;	O
static	O
int	O
rpmHeader_get_langNum	function
(	O
Header	pointer
h	pointer
,	O
char	O
*	O
*	O
chptr	pointer
)	O
;	O
static	O
char	O
*	O
get_sense	function
(	O
int	O
flags	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
RPMSENSE_LESS	int
)	O
&&	O
(	O
flags	int
&	O
RPMSENSE_EQUAL	int
)	O
)	O
return	O
"<="	pointer
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
RPMSENSE_GREATER	int
)	O
&&	O
(	O
flags	int
&	O
RPMSENSE_EQUAL	int
)	O
)	O
return	O
">="	pointer
;	O
else	O
if	O
(	O
flags	int
&	O
RPMSENSE_LESS	int
)	O
return	O
"<"	pointer
;	O
else	O
if	O
(	O
flags	int
&	O
RPMSENSE_GREATER	int
)	O
return	O
">"	pointer
;	O
else	O
if	O
(	O
flags	int
&	O
RPMSENSE_EQUAL	int
)	O
return	O
"=="	pointer
;	O
else	O
return	O
"=="	pointer
;	O
}	O
static	O
void	O
ascii_copy	function
(	O
STROB	struct
*	O
dest	pointer
,	O
char	O
*	O
src	pointer
)	O
{	O
int	O
newlen	pointer
;	O
char	O
*	O
pa	pointer
;	O
strob_strcpy	function
(	O
dest	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
*	O
src	pointer
==	O
'<'	O
)	O
{	O
strob_strcat	function
(	O
dest	pointer
,	O
" "	pointer
)	O
;	O
}	O
swlib_expand_escapes	function
(	O
&	O
pa	pointer
,	O
&	O
newlen	pointer
,	O
src	pointer
,	O
NULL	O
)	O
;	O
strob_strcat	function
(	O
dest	pointer
,	O
pa	pointer
)	O
;	O
free	function
(	O
pa	pointer
)	O
;	O
}	O
static	O
int	O
rpmpsf_headerGetRawEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	int
,	O
const	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
)	O
{	O
return	O
headerGetRawEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
p	pointer
,	O
c	int
)	O
;	O
}	O
static	O
int	O
rpmpsf_write_swdef_internal	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
swdef_filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
from_name	pointer
=	O
topsf_get_cwd_prefix	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
name	pointer
,	O
buf	pointer
[	O
200	int
]	O
;	O
STROB	struct
*	O
all_filesets	pointer
;	O
int	O
count	long
,	O
type	int
,	O
filetype	int
;	O
int	O
ret	int
=	O
0	int
;	O
all_filesets	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_SOURCERPM	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
&&	O
topsf	pointer
->	O
single_fileset_	int
==	O
0	int
)	O
{	O
filetype	int
=	O
RPMPSF_FILE_PSF_SRC	int
;	O
}	O
else	O
{	O
filetype	int
=	O
RPMPSF_FILE_PSF_BIN	int
;	O
}	O
if	O
(	O
from_name	pointer
)	O
{	O
int	O
i	int
=	O
strlen	function
(	O
from_name	pointer
)	O
;	O
from_name	pointer
+=	O
strlen	function
(	O
from_name	pointer
)	O
;	O
from_name	pointer
--	O
;	O
while	O
(	O
i	int
&&	O
*	O
from_name	pointer
!=	O
'/'	O
)	O
{	O
from_name	pointer
--	O
;	O
i	int
--	O
;	O
}	O
from_name	pointer
++	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"null value from char * from_name=topsf_get_cwd_prefix(topsf) ...fatal.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
strncpy	function
(	O
buf	pointer
,	O
from_name	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
buf	pointer
[	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
buf	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
buf	pointer
,	O
"PSF"	pointer
)	O
;	O
topsf_add_fl_entry	function
(	O
topsf	pointer
,	O
"PSF"	pointer
,	O
buf	pointer
,	O
SWACFL_SRCCODE_PSF	int
)	O
;	O
if	O
(	O
swdef_filetype	int
==	O
2	int
||	O
swdef_filetype	int
==	O
1	int
)	O
{	O
ret	int
+=	O
rpmpsf_write_distribution	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
filetype	int
,	O
from_name	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_vendor	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
filetype	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_category	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
filetype	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_product	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
all_filesets	pointer
,	O
filetype	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_product_control_files	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
)	O
;	O
}	O
if	O
(	O
swdef_filetype	int
==	O
2	int
||	O
swdef_filetype	int
==	O
0	int
)	O
{	O
ret	int
+=	O
rpmpsf_write_filesets	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
all_filesets	pointer
,	O
filetype	int
,	O
swdef_filetype	int
)	O
;	O
}	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
strob_close	function
(	O
all_filesets	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
rpmpsf_write_machine_name	function
(	O
Header	pointer
h	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
ret	int
;	O
char	O
*	O
machine_type	pointer
;	O
char	O
*	O
os_name	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
ret	int
=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_ARCH	int
,	O
0	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
tmp	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fnmatch	function
(	O
"[ix]*86"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
0	int
)	O
==	O
0	int
)	O
{	O
machine_type	pointer
=	O
"[xi][3-6]86"	pointer
;	O
os_name	pointer
=	O
"Linux"	pointer
;	O
}	O
else	O
if	O
(	O
fnmatch	function
(	O
"x86_64"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
0	int
)	O
==	O
0	int
)	O
{	O
machine_type	pointer
=	O
"[xi]86_64"	pointer
;	O
os_name	pointer
=	O
"Linux"	pointer
;	O
}	O
else	O
if	O
(	O
(	O
fnmatch	function
(	O
"BSD"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
fnmatch	function
(	O
"bsd"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
0	int
)	O
&&	O
(	O
fnmatch	function
(	O
"[ix]*86"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
0	int
)	O
&&	O
1	int
)	O
{	O
os_name	pointer
=	O
"*[bB][sS][dD]*"	pointer
;	O
machine_type	pointer
=	O
"[xi][3-6]86"	pointer
;	O
}	O
else	O
{	O
machine_type	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
os_name	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
}	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_machine_type	pointer
,	O
machine_type	pointer
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_os_name	pointer
,	O
os_name	pointer
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_psf	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
int	O
ret	int
=	O
rpmpsf_write_swdef_internal	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
2	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_info	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
int	O
ret	int
=	O
rpmpsf_write_swdef_internal	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
headerDumpSw	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
FILE	struct
*	O
f	pointer
,	O
int	O
flags	int
,	O
struct_MI_headerTagTableEntry	O
tags	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
i	int
,	O
k	int
=	O
0	int
,	O
c	int
,	O
ct	pointer
;	O
struct	O
indexEntry	struct
*	O
p	pointer
;	O
struct_MI_headerTagTableEntry	O
tage	pointer
;	O
char	O
*	O
dp	pointer
;	O
char	O
*	O
type	int
,	O
*	O
tag	int
;	O
STROB	struct
*	O
strb	pointer
,	O
*	O
strbval	pointer
;	O
struct	O
indexEntry	struct
*	O
table	pointer
;	O
int	O
langNum	int
;	O
char	O
*	O
chptr	pointer
;	O
int	O
holdtagnumber	int
;	O
strb	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
strbval	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"Entry count: %d\n"	pointer
,	O
h	pointer
->	O
indexUsed	int
)	O
;	O
p	pointer
=	O
h	pointer
->	O
index	function
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
p	pointer
->	O
info	struct
.	O
tag	int
<	O
1000	int
)	O
{	O
p	pointer
++	O
;	O
continue	O
;	O
}	O
switch	O
(	O
p	pointer
->	O
info	struct
.	O
type	int
)	O
{	O
case	O
RPM_NULL_TYPE	int
:	O
type	int
=	O
"NULL_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
type	int
=	O
"CHAR_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
type	int
=	O
"BIN_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_INT8_TYPE	int
:	O
type	int
=	O
"INT8_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
type	int
=	O
"INT16_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_INT32_TYPE	int
:	O
type	int
=	O
"INT32_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
type	int
=	O
"STRING_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
type	int
=	O
"STRING_ARRAY_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
type	int
=	O
"I18N_STRING_TYPE"	pointer
;	O
break	O
;	O
default	O
:	O
type	int
=	O
"(unknown)"	pointer
;	O
break	O
;	O
}	O
tage	pointer
=	O
tags	pointer
;	O
while	O
(	O
tage	pointer
->	O
name	pointer
&&	O
tage	pointer
->	O
val	array
!=	O
p	pointer
->	O
info	struct
.	O
tag	int
)	O
tage	pointer
++	O
;	O
if	O
(	O
!	O
tage	pointer
->	O
name	pointer
)	O
{	O
tag	int
=	O
"(unknown)"	pointer
;	O
}	O
else	O
{	O
tag	int
=	O
(	O
char	O
*	O
)	O
(	O
tage	pointer
->	O
name	pointer
)	O
;	O
}	O
fprintf	function
(	O
f	pointer
,	O
"%s \"%s "	pointer
,	O
tag	int
,	O
type	int
)	O
;	O
if	O
(	O
flags	int
&	O
HEADER_DUMP_INLINE	int
)	O
{	O
dp	pointer
=	O
p	pointer
->	O
data	pointer
;	O
c	int
=	O
p	pointer
->	O
info	struct
.	O
count	long
;	O
ct	pointer
=	O
0	int
;	O
strob_strcpy	function
(	O
strbval	pointer
,	O
""	pointer
)	O
;	O
switch	O
(	O
p	pointer
->	O
info	struct
.	O
type	int
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
case	O
RPM_INT16_TYPE	int
:	O
case	O
RPM_INT8_TYPE	int
:	O
case	O
RPM_CHAR_TYPE	int
:	O
k	int
=	O
0	int
;	O
holdtagnumber	int
=	O
p	pointer
->	O
info	struct
.	O
tag	int
;	O
while	O
(	O
!	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
holdtagnumber	int
,	O
k	int
++	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
strbval	pointer
,	O
" "	pointer
)	O
;	O
strob_cat	function
(	O
strbval	pointer
,	O
strb	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
k	int
=	O
0	int
;	O
holdtagnumber	int
=	O
p	pointer
->	O
info	struct
.	O
tag	int
;	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
holdtagnumber	int
,	O
k	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
strob_cat	function
(	O
strbval	pointer
,	O
strb	pointer
)	O
;	O
break	O
;	O
holdtagnumber	int
=	O
p	pointer
->	O
info	struct
.	O
tag	int
;	O
while	O
(	O
!	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
holdtagnumber	int
,	O
k	int
++	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
strbval	pointer
,	O
"Data: "	pointer
)	O
;	O
strob_cat	function
(	O
strbval	pointer
,	O
strb	pointer
)	O
;	O
strob_strcat	function
(	O
strbval	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
if	O
(	O
p	pointer
->	O
info	struct
.	O
tag	int
==	O
RPMTAG_FILELANGS	int
)	O
{	O
table	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
;	O
if	O
(	O
table	pointer
)	O
{	O
chptr	pointer
=	O
table	pointer
->	O
data	pointer
;	O
for	O
(	O
langNum	int
=	O
0	int
;	O
langNum	int
<	O
table	pointer
->	O
info	struct
.	O
count	long
;	O
langNum	int
++	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"{%s} "	pointer
,	O
chptr	pointer
)	O
;	O
chptr	pointer
+=	O
strlen	function
(	O
chptr	pointer
)	O
+	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
k	int
=	O
0	int
;	O
holdtagnumber	int
=	O
p	pointer
->	O
info	struct
.	O
tag	int
;	O
while	O
(	O
!	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
holdtagnumber	int
,	O
k	int
++	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
strbval	pointer
,	O
" {"	pointer
)	O
;	O
strob_cat	function
(	O
strbval	pointer
,	O
strb	pointer
)	O
;	O
strob_strcat	function
(	O
strbval	pointer
,	O
"}"	pointer
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"headerDumpSw: Data type %d not supported\n"	pointer
,	O
(	O
int	O
)	O
p	pointer
->	O
info	struct
.	O
type	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fprintf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
strob_str	function
(	O
strbval	pointer
)	O
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\"\n"	pointer
)	O
;	O
}	O
p	pointer
++	O
;	O
}	O
strob_close	function
(	O
strbval	pointer
)	O
;	O
strob_close	function
(	O
strb	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_get_rpmtagvalue	function
(	O
Header	pointer
h	pointer
,	O
int	O
tagnumber	int
,	O
int	O
index	function
,	O
int	O
*	O
pcount	pointer
,	O
STROB	struct
*	O
strb	pointer
)	O
{	O
int	O
count	long
,	O
type	int
,	O
ct	pointer
=	O
0	int
,	O
j	int
,	O
c	int
;	O
int	O
arrindex	int
=	O
tagnumber	int
-	O
1000	int
;	O
char	O
*	O
entry	pointer
,	O
*	O
dp	pointer
;	O
char	O
buf1	array
[	O
100	int
]	O
,	O
*	O
bufp	pointer
;	O
void	O
*	O
da	pointer
;	O
struct	O
header_lookup_cache	struct
*	O
hap	pointer
=	O
HeaderLookupCacheArray	array
;	O
if	O
(	O
tagnumber	int
<	O
1000	int
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
pcount	pointer
)	O
{	O
if	O
(	O
!	O
rpmpsf_headerGetRawEntry	function
(	O
h	pointer
,	O
tagnumber	int
,	O
&	O
type	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
da	pointer
,	O
pcount	pointer
)	O
)	O
{	O
*	O
pcount	pointer
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
type	int
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
type	int
==	O
RPM_I18NSTRING_TYPE	int
)	O
&&	O
da	pointer
)	O
{	O
swbis_free	O
(	O
da	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
arrindex	int
<	O
0	int
||	O
arrindex	int
>	O
SWMAP_MAX_LENGTH	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"get_rpmtagvalue() invalid tag array index %d.\n"	pointer
,	O
arrindex	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
header	struct
==	O
h	pointer
&&	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
!=	O
0	int
&&	O
(	O
swdef_pkg_maptable	array
[	O
arrindex	int
]	O
.	O
rpmtag_type	int
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
swdef_pkg_maptable	array
[	O
arrindex	int
]	O
.	O
rpmtag_type	int
==	O
RPM_I18NSTRING_TYPE	int
)	O
)	O
{	O
if	O
(	O
index	function
>=	O
hap	pointer
[	O
arrindex	int
]	O
.	O
count	long
||	O
index	function
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
entry	pointer
=	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
)	O
)	O
[	O
index	function
]	O
;	O
if	O
(	O
!	O
entry	pointer
||	O
(	O
(	O
entry	pointer
-	O
(	O
char	O
*	O
)	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
)	O
)	O
<	O
0	int
)	O
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
}	O
else	O
{	O
ascii_copy	function
(	O
strb	pointer
,	O
entry	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
swdef_pkg_maptable	array
[	O
arrindex	int
]	O
.	O
rpmtag_type	int
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
swdef_pkg_maptable	array
[	O
arrindex	int
]	O
.	O
rpmtag_type	int
==	O
RPM_I18NSTRING_TYPE	int
)	O
{	O
if	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
!=	O
0	int
)	O
{	O
swbis_free	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
)	O
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
rpmpsf_headerGetRawEntry	function
(	O
h	pointer
,	O
tagnumber	int
,	O
&	O
type	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
da	pointer
,	O
&	O
count	long
)	O
)	O
{	O
hap	pointer
[	O
arrindex	int
]	O
.	O
header	struct
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
count	long
<=	O
index	function
||	O
index	function
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
type	int
==	O
RPM_STRING_ARRAY_TYPE	int
)	O
{	O
hap	pointer
[	O
arrindex	int
]	O
.	O
header	struct
=	O
h	pointer
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
=	O
da	pointer
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
count	long
=	O
count	long
;	O
entry	pointer
=	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
da	pointer
)	O
)	O
[	O
index	function
]	O
;	O
if	O
(	O
!	O
entry	pointer
||	O
(	O
(	O
entry	pointer
-	O
(	O
char	O
*	O
)	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
)	O
)	O
<	O
0	int
)	O
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
}	O
else	O
{	O
ascii_copy	function
(	O
strb	pointer
,	O
entry	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
type	int
==	O
RPM_I18NSTRING_TYPE	int
)	O
{	O
if	O
(	O
count	long
==	O
1	int
)	O
{	O
ct	pointer
=	O
0	int
;	O
entry	pointer
=	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
da	pointer
)	O
)	O
[	O
0	int
]	O
;	O
while	O
(	O
ct	pointer
++	O
<	O
index	function
)	O
entry	pointer
+=	O
strlen	function
(	O
entry	pointer
)	O
+	O
1	int
;	O
ascii_copy	function
(	O
strb	pointer
,	O
entry	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
hap	pointer
[	O
arrindex	int
]	O
.	O
header	struct
=	O
h	pointer
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
=	O
da	pointer
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
count	long
=	O
count	long
;	O
entry	pointer
=	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
da	pointer
)	O
)	O
[	O
index	function
]	O
;	O
if	O
(	O
!	O
entry	pointer
||	O
(	O
(	O
entry	pointer
-	O
(	O
char	O
*	O
)	O
(	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
)	O
)	O
<	O
0	int
)	O
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
}	O
else	O
{	O
ascii_copy	function
(	O
strb	pointer
,	O
entry	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
type	int
==	O
RPM_STRING_TYPE	int
)	O
{	O
hap	pointer
[	O
arrindex	int
]	O
.	O
header	struct
=	O
0	int
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
data	pointer
=	O
0	int
;	O
hap	pointer
[	O
arrindex	int
]	O
.	O
count	long
=	O
0	int
;	O
entry	pointer
=	O
(	O
char	O
*	O
)	O
da	pointer
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
}	O
else	O
{	O
ascii_copy	function
(	O
strb	pointer
,	O
entry	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
count	long
<=	O
index	function
||	O
index	function
<	O
0	int
)	O
return	O
-	O
1	int
;	O
dp	pointer
=	O
(	O
char	O
*	O
)	O
da	pointer
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
dp	pointer
+=	O
(	O
index	function
*	O
sizeof	O
(	O
int_32	int
)	O
)	O
;	O
snprintf	function
(	O
buf1	array
,	O
sizeof	O
(	O
buf1	array
)	O
,	O
"%d"	pointer
,	O
(	O
uint_32	int
)	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dp	pointer
)	O
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
buf1	array
)	O
;	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
dp	pointer
+=	O
(	O
index	function
*	O
sizeof	O
(	O
int_16	short
)	O
)	O
;	O
snprintf	function
(	O
buf1	array
,	O
sizeof	O
(	O
buf1	array
)	O
,	O
"%d"	pointer
,	O
(	O
uint_16	short
)	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dp	pointer
)	O
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
buf1	array
)	O
;	O
break	O
;	O
case	O
RPM_INT8_TYPE	int
:	O
dp	pointer
+=	O
(	O
index	function
*	O
sizeof	O
(	O
int_8	char
)	O
)	O
;	O
snprintf	function
(	O
buf1	array
,	O
sizeof	O
(	O
buf1	array
)	O
,	O
"%d"	pointer
,	O
(	O
char	O
)	O
*	O
(	O
(	O
int_8	char
*	O
)	O
dp	pointer
)	O
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
buf1	array
)	O
;	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
bufp	pointer
=	O
buf1	array
;	O
dp	pointer
=	O
da	pointer
;	O
ct	pointer
=	O
0	int
;	O
c	int
=	O
count	long
;	O
j	int
=	O
sprintf	function
(	O
bufp	pointer
,	O
"\n"	pointer
)	O
;	O
bufp	pointer
+=	O
j	int
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
""	pointer
)	O
;	O
while	O
(	O
c	int
>	O
0	int
)	O
{	O
j	int
=	O
sprintf	function
(	O
bufp	pointer
,	O
"   Data: "	pointer
)	O
;	O
bufp	pointer
+=	O
j	int
;	O
while	O
(	O
c	int
--	O
)	O
{	O
j	int
=	O
sprintf	function
(	O
bufp	pointer
,	O
" %02X"	pointer
,	O
(	O
unsigned	O
char	O
)	O
*	O
(	O
int_8	char
*	O
)	O
dp	pointer
)	O
;	O
ct	pointer
++	O
;	O
bufp	pointer
+=	O
j	int
;	O
dp	pointer
+=	O
sizeof	O
(	O
int_8	char
)	O
;	O
if	O
(	O
!	O
(	O
ct	pointer
%	O
8	int
)	O
)	O
{	O
break	O
;	O
}	O
}	O
sprintf	function
(	O
bufp	pointer
,	O
"\n"	pointer
)	O
;	O
strob_strcat	function
(	O
strb	pointer
,	O
buf1	array
)	O
;	O
bufp	pointer
=	O
buf1	array
;	O
}	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
dp	pointer
+=	O
(	O
index	function
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
sprintf	function
(	O
buf1	array
,	O
"%2x"	pointer
,	O
(	O
unsigned	O
char	O
)	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
dp	pointer
)	O
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
buf1	array
)	O
;	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
ascii_copy	function
(	O
strb	pointer
,	O
dp	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"get_rpmtagvalue: Data type %d not supported\n"	pointer
,	O
(	O
int	O
)	O
type	int
)	O
;	O
return	O
-	O
6	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_host	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
ret	int
=	O
0	int
;	O
struct	O
utsname	struct
unamestruct	struct
;	O
uname	function
(	O
&	O
unamestruct	struct
)	O
;	O
write_object_keyword	function
(	O
"host"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"hostname"	pointer
,	O
unamestruct	struct
.	O
nodename	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"os_name"	pointer
,	O
unamestruct	struct
.	O
sysname	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"os_release"	pointer
,	O
unamestruct	struct
.	O
release	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"os_version"	pointer
,	O
unamestruct	struct
.	O
version	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"machine_type"	pointer
,	O
unamestruct	struct
.	O
machine	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_distribution	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
filetype	int
,	O
char	O
*	O
from_name	pointer
)	O
{	O
char	O
dfiles	pointer
[	O
100	int
]	O
;	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
ret	int
=	O
0	int
;	O
write_object_keyword	function
(	O
"distribution"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"layout_version"	pointer
,	O
"1.0"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"dfiles"	pointer
,	O
rpmpsf_make_dfiles	function
(	O
topsf	pointer
,	O
dfiles	pointer
,	O
100	int
)	O
,	O
RPMTAG_DISTRIBUTION	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"pfiles"	pointer
,	O
"pfiles"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
NULL	O
,	O
RPMTAG_NAME	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
if	O
(	O
topsf	pointer
->	O
smart_path_	int
)	O
{	O
if	O
(	O
filetype	int
!=	O
RPMPSF_FILE_PSF_SRC	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
from_name	pointer
,	O
"."	pointer
)	O
)	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
from_name	pointer
,	O
0	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
{	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
strob_str	function
(	O
topsf	pointer
->	O
control_directoryM	pointer
)	O
,	O
0	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
topsf	pointer
->	O
form_	int
==	O
TOPSF_PSF_FORM2	int
||	O
topsf	pointer
->	O
form_	int
==	O
TOPSF_PSF_FORM3	int
)	O
{	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
strob_str	function
(	O
topsf	pointer
->	O
control_directoryM	pointer
)	O
,	O
0	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
{	O
;	O
}	O
ret	int
+=	O
rpmpsf_write_multilang_attribute	function
(	O
"title"	pointer
,	O
RPMTAG_SUMMARY	int
,	O
h	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_multilang_attribute	function
(	O
"description"	pointer
,	O
RPMTAG_DESCRIPTION	int
,	O
h	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"copyright"	pointer
,	O
NULL	O
,	O
RPMTAG_COPYRIGHT	O
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"architecture"	pointer
,	O
NULL	O
,	O
RPMTAG_ARCH	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"url"	pointer
,	O
NULL	O
,	O
RPMTAG_URL	int
,	O
0	int
,	O
h	pointer
,	O
"unknown"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"create_time"	pointer
,	O
NULL	O
,	O
RPMTAG_BUILDTIME	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"rpm_buildarchs"	pointer
,	O
NULL	O
,	O
RPMTAG_BUILDARCHS	int
,	O
-	O
1	int
,	O
h	pointer
,	O
"linux"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"rpm_default_prefix"	pointer
,	O
NULL	O
,	O
RPMTAG_DEFAULTPREFIX	int
,	O
0	int
,	O
h	pointer
,	O
"/"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"rpm_obsoletes"	pointer
,	O
NULL	O
,	O
RPMTAG_OBSOLETES	O
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"rpmversion"	pointer
,	O
NULL	O
,	O
RPMTAG_RPMVERSION	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_multilang_attribute	function
(	O
char	O
*	O
kw	pointer
,	O
int	O
rpmtag	int
,	O
Header	pointer
h	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
int	O
i	int
,	O
lang_num	int
,	O
ret	int
=	O
0	int
;	O
char	O
*	O
lang_string	pointer
,	O
*	O
chptr	pointer
,	O
*	O
language_name	pointer
;	O
char	O
keyw	pointer
[	O
120	int
]	O
;	O
lang_num	int
=	O
rpmHeader_get_langNum	function
(	O
h	pointer
,	O
&	O
lang_string	pointer
)	O
;	O
if	O
(	O
lang_num	int
<	O
1	int
)	O
{	O
lang_num	int
=	O
0	int
;	O
return	O
rpmpsf_write_rpm_attribute	function
(	O
kw	pointer
,	O
NULL	O
,	O
rpmtag	int
,	O
lang_num	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
chptr	pointer
=	O
lang_string	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lang_num	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
chptr	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"rpm lang code is null.\n"	pointer
)	O
;	O
continue	O
;	O
}	O
language_name	pointer
=	O
swintl_get_lang_name	function
(	O
chptr	pointer
)	O
;	O
if	O
(	O
language_name	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"language name for code %s not found. Please fix swintl.c\n"	pointer
,	O
chptr	pointer
)	O
;	O
continue	O
;	O
}	O
strncpy	function
(	O
keyw	pointer
,	O
kw	pointer
,	O
60	int
)	O
;	O
keyw	pointer
[	O
60	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strlen	function
(	O
language_name	pointer
)	O
)	O
strcat	function
(	O
keyw	pointer
,	O
"."	pointer
)	O
;	O
strcat	function
(	O
keyw	pointer
,	O
language_name	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
keyw	pointer
,	O
NULL	O
,	O
rpmtag	int
,	O
i	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
chptr	pointer
+=	O
strlen	function
(	O
chptr	pointer
)	O
+	O
1	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_category	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
write_object_keyword	function
(	O
"category"	pointer
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
"rpm_group"	pointer
,	O
RPMTAG_GROUP	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
return	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
RPMTAG_GROUP	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
int	O
rpmpsf_write_bundle	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
write_object_keyword	function
(	O
"bundle"	pointer
,	O
uxfio_ofd	int
)	O
;	O
return	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
NULL	O
,	O
RPMTAG_GROUP	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
int	O
rpmpsf_write_vendor	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
tagstring	pointer
[	O
65	int
]	O
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
char	O
*	O
name	pointer
,	O
*	O
p1	pointer
;	O
int	O
count	long
,	O
type	int
;	O
int	O
ret	int
=	O
0	int
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_RELEASE	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
write_object_keyword	function
(	O
"vendor"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"the_term_vendor_is_misleading"	pointer
,	O
"true"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
name	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
{	O
switch	O
(	O
0	int
)	O
{	O
case	O
0	int
:	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_NAME	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
break	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"A RPM packaged release of %s-"	pointer
,	O
name	pointer
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_VERSION	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
break	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
"%s\n"	pointer
,	O
name	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
break	O
;	O
}	O
}	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"qualifier"	pointer
,	O
"release"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_VENDOR	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
write_object_keyword	function
(	O
"vendor"	pointer
,	O
uxfio_ofd	int
)	O
;	O
strncpy	function
(	O
tagstring	pointer
,	O
name	pointer
,	O
sizeof	O
(	O
tagstring	pointer
)	O
)	O
;	O
tagstring	pointer
[	O
sizeof	O
(	O
tagstring	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
p1	pointer
=	O
tagstring	pointer
;	O
swlib_tr	function
(	O
tagstring	pointer
,	O
(	O
int	O
)	O
(	O
'_'	O
)	O
,	O
(	O
int	O
)	O
(	O
' '	O
)	O
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"the_term_vendor_is_misleading"	pointer
,	O
"true"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
tagstring	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
RPMTAG_VENDOR	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"qualifier"	pointer
,	O
"seller"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_PACKAGER	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
write_object_keyword	function
(	O
"vendor"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"the_term_vendor_is_misleading"	pointer
,	O
"true"	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
RPMTAG_PACKAGER	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
RPMTAG_PACKAGER	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"qualifier"	pointer
,	O
"packager"	pointer
,	O
0	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_product	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
STROB	struct
*	O
all_filesets	pointer
,	O
int	O
filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
cdir	pointer
;	O
char	O
*	O
name	pointer
,	O
*	O
p1	pointer
;	O
int	O
count	long
,	O
type	int
;	O
int	O
ret	int
=	O
0	int
;	O
STROB	struct
*	O
tagstring	pointer
=	O
strob_open	function
(	O
48	int
)	O
;	O
STROB	struct
*	O
rpmtagname	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
STROB	struct
*	O
rev	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
write_object_keyword	function
(	O
"product"	pointer
,	O
uxfio_ofd	int
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_NAME	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
-	O
1	int
;	O
strob_strcpy	function
(	O
rpmtagname	pointer
,	O
name	pointer
)	O
;	O
strob_strcpy	function
(	O
tagstring	pointer
,	O
name	pointer
)	O
;	O
cdir	pointer
=	O
strob_str	function
(	O
tagstring	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
form_	int
==	O
TOPSF_PSF_FORM3	int
&&	O
filetype	int
!=	O
RPMPSF_FILE_PSF_SRC	int
)	O
{	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
""	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
{	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
cdir	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_VENDOR	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
strob_strcpy	function
(	O
tagstring	pointer
,	O
"unknown"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
tagstring	pointer
,	O
name	pointer
)	O
;	O
}	O
p1	pointer
=	O
strob_str	function
(	O
tagstring	pointer
)	O
;	O
swlib_tr	function
(	O
strob_str	function
(	O
tagstring	pointer
)	O
,	O
(	O
int	O
)	O
(	O
'_'	O
)	O
,	O
(	O
int	O
)	O
(	O
' '	O
)	O
)	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_VERSION	int
,	O
0	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
tmp	pointer
)	O
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"rpmpsf.c error getting RPMTAG_VERSION\n"	pointer
)	O
;	O
strob_strcpy	function
(	O
rev	pointer
,	O
"unknown"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
rev	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
NULL	O
,	O
RPMTAG_NAME	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_revision	pointer
,	O
strob_str	function
(	O
rev	pointer
)	O
,	O
RPMTAG_VERSION	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_number	pointer
,	O
NULL	O
,	O
RPMTAG_RELEASE	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_vendor_tag	pointer
,	O
NULL	O
,	O
RPMTAG_RELEASE	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"source_package"	pointer
,	O
NULL	O
,	O
RPMTAG_SOURCE	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"all_patches"	pointer
,	O
NULL	O
,	O
RPMTAG_PATCH	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"directory"	pointer
,	O
NULL	O
,	O
RPMTAG_INSTALLPREFIX	int
,	O
0	int
,	O
h	pointer
,	O
"/"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"build_host"	pointer
,	O
NULL	O
,	O
RPMTAG_BUILDHOST	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"build_root"	pointer
,	O
NULL	O
,	O
RPMTAG_BUILDROOT	int
,	O
0	int
,	O
h	pointer
,	O
"/"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"mod_time"	pointer
,	O
NULL	O
,	O
RPMTAG_INSTALLTIME	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_machine_name	function
(	O
h	pointer
,	O
uxfio_ofd	int
)	O
;	O
if	O
(	O
filetype	int
==	O
RPMPSF_FILE_PSF_BIN	int
)	O
{	O
strob_strcpy	function
(	O
tagstring	pointer
,	O
strob_str	function
(	O
rpmtagname	pointer
)	O
)	O
;	O
swlib_tr	function
(	O
strob_str	function
(	O
tagstring	pointer
)	O
,	O
(	O
int	O
)	O
(	O
'_'	O
)	O
,	O
(	O
int	O
)	O
(	O
'.'	O
)	O
)	O
;	O
swlib_tr	function
(	O
strob_str	function
(	O
tagstring	pointer
)	O
,	O
(	O
int	O
)	O
(	O
'_'	O
)	O
,	O
(	O
int	O
)	O
(	O
'/'	O
)	O
)	O
;	O
if	O
(	O
swlib_check_clean_path	function
(	O
strob_str	function
(	O
tagstring	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"all_filesets"	pointer
,	O
strob_str	function
(	O
tagstring	pointer
)	O
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
if	O
(	O
filetype	int
==	O
RPMPSF_FILE_PSF_SRC	int
)	O
{	O
strob_strcpy	function
(	O
tagstring	pointer
,	O
RPMPSF_FILESET_SOURCE	pointer
)	O
;	O
strob_strcat	function
(	O
tagstring	pointer
,	O
" "	pointer
)	O
;	O
strob_strcat	function
(	O
tagstring	pointer
,	O
RPMPSF_FILESET_BUILD	pointer
)	O
;	O
strob_strcat	function
(	O
tagstring	pointer
,	O
" "	pointer
)	O
;	O
strob_strcat	function
(	O
tagstring	pointer
,	O
RPMPSF_FILESET_PATCHES	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"all_filesets"	pointer
,	O
strob_str	function
(	O
tagstring	pointer
)	O
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
strob_strcpy	function
(	O
all_filesets	pointer
,	O
strob_str	function
(	O
tagstring	pointer
)	O
)	O
;	O
strob_close	function
(	O
tagstring	pointer
)	O
;	O
strob_close	function
(	O
rpmtagname	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
rev	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_filesets	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
STROB	struct
*	O
all_filesets	pointer
,	O
int	O
filetype	int
,	O
int	O
swdef_filetype	int
)	O
{	O
int	O
ret	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
char	O
*	O
buf	pointer
,	O
*	O
p	pointer
;	O
while	O
(	O
(	O
p	pointer
=	O
rpmpsf_list_iterate	function
(	O
(	O
i	int
++	O
==	O
0	int
)	O
?	O
(	O
&	O
buf	pointer
)	O
:	O
NULL	O
,	O
strob_str	function
(	O
all_filesets	pointer
)	O
,	O
" "	pointer
)	O
)	O
&&	O
p	pointer
)	O
{	O
if	O
(	O
filetype	int
==	O
RPMPSF_FILE_PSF_BIN	int
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s-RUN"	pointer
,	O
p	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
p	pointer
)	O
;	O
}	O
ret	int
+=	O
rpmpsf_write_fileset	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
p	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
filetype	int
,	O
swdef_filetype	int
)	O
;	O
}	O
if	O
(	O
buf	pointer
)	O
swbis_free	O
(	O
buf	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_fileset	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
char	O
*	O
fileset_tag	pointer
,	O
char	O
*	O
fileset_control_dir	pointer
,	O
int	O
filetype	int
,	O
int	O
swdef_filetype	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
cdir	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
char	O
titlestring	array
[	O
256	int
]	O
;	O
char	O
*	O
source_prefix	pointer
=	O
topsf_get_cwd_prefix	function
(	O
topsf	pointer
)	O
;	O
STROB	struct
*	O
strb1	pointer
;	O
char	O
*	O
vendor_tag	pointer
;	O
E_DEBUG	O
(	O
"START"	pointer
)	O
;	O
if	O
(	O
!	O
source_prefix	pointer
)	O
{	O
source_prefix	pointer
=	O
rpmpsf_make_package_prefix	function
(	O
topsf	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
topsf_set_psf_prefix	function
(	O
topsf	pointer
,	O
source_prefix	pointer
)	O
;	O
strb1	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
if	O
(	O
swdef_filetype	int
==	O
2	int
||	O
swdef_filetype	int
==	O
1	int
)	O
{	O
write_object_keyword	function
(	O
"fileset"	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
fileset_tag	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
if	O
(	O
filetype	int
==	O
RPMPSF_FILE_PSF_BIN	int
)	O
cdir	pointer
=	O
""	pointer
;	O
else	O
cdir	pointer
=	O
fileset_tag	pointer
;	O
cdir	pointer
=	O
fileset_control_dir	pointer
;	O
if	O
(	O
topsf	pointer
->	O
form_	int
==	O
TOPSF_PSF_FORM3	int
&&	O
filetype	int
!=	O
RPMPSF_FILE_PSF_SRC	int
)	O
{	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
""	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
{	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_control_directory	pointer
,	O
cdir	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
}	O
swlib_strncpy	function
(	O
titlestring	array
,	O
fileset_tag	pointer
,	O
200	int
)	O
;	O
*	O
titlestring	array
=	O
toupper	function
(	O
(	O
int	O
)	O
(	O
*	O
titlestring	array
)	O
)	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_RELEASE	int
,	O
0	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb1	pointer
)	O
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"rpmpsf.c error getting RPMTAG_RELEASE\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
vendor_tag	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
strb1	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
fileset_tag	pointer
,	O
RPMPSF_FILESET_SOURCE	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"RPMPSF_FILESET_SOURCE"	pointer
)	O
;	O
strcat	function
(	O
titlestring	array
,	O
" (pristine sources)"	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
titlestring	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_psf_files	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
SWPM_SRCFILESET_SOURCE	int
,	O
source_prefix	pointer
,	O
strb1	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
fileset_tag	pointer
,	O
RPMPSF_FILESET_BUILD	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"RPMPSF_FILESET_BUILD"	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"excluded_arch"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUDEARCH	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"exclude_os"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUDEOS	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"exclusive_arch"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUSIVEARCH	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"exclusive_os"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUSIVEOS	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
strcat	function
(	O
titlestring	array
,	O
" (RPM spec file)"	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
titlestring	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_write_changelogs	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_psf_files	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
SWPM_SRCFILESET_BUILD_CONTROL	int
,	O
source_prefix	pointer
,	O
strb1	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
fileset_tag	pointer
,	O
RPMPSF_FILESET_PATCHES	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"RPMPSF_FILESET_PATCHES"	pointer
)	O
;	O
strcat	function
(	O
titlestring	array
,	O
" (patches on the pristine sources)"	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
titlestring	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_psf_files	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
SWPM_SRCFILESET_PATCH	int
,	O
source_prefix	pointer
,	O
strb1	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"BINARY"	pointer
)	O
;	O
if	O
(	O
swdef_filetype	int
==	O
1	int
||	O
swdef_filetype	int
==	O
2	int
)	O
{	O
strncpy	function
(	O
titlestring	array
,	O
"The Packaged Files (the package distribution files)"	pointer
,	O
100	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"title"	pointer
,	O
titlestring	array
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_BUILDROOT	int
,	O
0	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb1	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"excluded_arch"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUDEARCH	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"exclude_os"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUDEOS	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"exclusive_arch"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUSIVEARCH	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_write_rpm_attribute	function
(	O
"exclusive_os"	pointer
,	O
NULL	O
,	O
RPMTAG_EXCLUSIVEOS	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
ret	int
+=	O
rpmpsf_write_requisites	function
(	O
topsf	pointer
,	O
RPMTAG_REQUIRENAME	int
,	O
RPMTAG_REQUIREVERSION	int
,	O
RPMTAG_REQUIREFLAGS	int
,	O
uxfio_ofd	int
,	O
vendor_tag	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
ret	int
+=	O
rpmpsf_write_requisites	function
(	O
topsf	pointer
,	O
RPMTAG_CONFLICTNAME	int
,	O
RPMTAG_CONFLICTVERSION	int
,	O
RPMTAG_CONFLICTFLAGS	int
,	O
uxfio_ofd	int
,	O
vendor_tag	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
ret	int
+=	O
rpmpsf_write_requisites	function
(	O
topsf	pointer
,	O
RPMTAG_PROVIDES	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
uxfio_ofd	int
,	O
vendor_tag	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
rpmpsf_write_changelogs	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
)	O
;	O
}	O
if	O
(	O
swdef_filetype	int
==	O
2	int
||	O
swdef_filetype	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
use_recursive_	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"entering rpmpsf_write_psf_files topsf->use_recursive_ == 0"	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_write_psf_files	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
-	O
1	int
,	O
source_prefix	pointer
,	O
strb1	pointer
)	O
;	O
}	O
else	O
{	O
int	O
nullfd	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
E_DEBUG	O
(	O
"topsf->use_recursive_ is true"	pointer
)	O
;	O
strob_strcpy	function
(	O
strb1	pointer
,	O
"directory .\nfile *\n"	pointer
)	O
;	O
uxfio_write	function
(	O
uxfio_ofd	int
,	O
(	O
void	O
*	O
)	O
strob_str	function
(	O
strb1	pointer
)	O
,	O
strob_strlen	function
(	O
strb1	pointer
)	O
)	O
;	O
ret	int
+=	O
rpmpsf_write_psf_files	function
(	O
topsf	pointer
,	O
nullfd	int
,	O
-	O
1	int
,	O
source_prefix	pointer
,	O
strb1	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
}	O
if	O
(	O
ret	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
}	O
}	O
}	O
strob_close	function
(	O
strb1	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rpmpsf_write_product_control_files	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
name	pointer
;	O
int	O
count	long
,	O
type	int
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_POSTIN	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
rpmpsf_write_product_control_file	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
"postinstall"	pointer
,	O
"RPMTAG_POSTIN"	pointer
,	O
RPMTAG_POSTINPROG	int
,	O
RPMTAG_POSTIN	int
)	O
;	O
}	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_POSTUN	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
rpmpsf_write_product_control_file	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
"unpostinstall"	pointer
,	O
"RPMTAG_POSTUN"	pointer
,	O
RPMTAG_POSTUNPROG	int
,	O
RPMTAG_POSTUN	int
)	O
;	O
}	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_PREIN	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
rpmpsf_write_product_control_file	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
"preinstall"	pointer
,	O
"RPMTAG_PREIN"	pointer
,	O
RPMTAG_PREINPROG	int
,	O
RPMTAG_PREIN	int
)	O
;	O
}	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_PREUN	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
rpmpsf_write_product_control_file	function
(	O
topsf	pointer
,	O
uxfio_ofd	int
,	O
"unpreinstall"	pointer
,	O
"RPMTAG_PREUN"	pointer
,	O
RPMTAG_PREUNPROG	int
,	O
RPMTAG_PREUN	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_product_control_file	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
char	O
*	O
tag	int
,	O
char	O
*	O
rpmtag	int
,	O
int	O
rpm_prog	int
,	O
int	O
rpm_progtag	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
source_prefix	pointer
=	O
topsf_get_cwd_prefix	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
p	pointer
;	O
int	O
len	int
;	O
if	O
(	O
!	O
source_prefix	pointer
)	O
{	O
source_prefix	pointer
=	O
rpmpsf_make_package_prefix	function
(	O
topsf	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
topsf_set_psf_prefix	function
(	O
topsf	pointer
,	O
source_prefix	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
topsf_get_psf_prefix	function
(	O
topsf	pointer
)	O
)	O
+	O
25	int
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
len	int
)	O
;	O
swlib_strncpy	function
(	O
p	pointer
,	O
topsf_get_psf_prefix	function
(	O
topsf	pointer
)	O
,	O
len	int
)	O
;	O
strcat	function
(	O
p	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
p	pointer
,	O
tag	int
)	O
;	O
write_object_keyword	function
(	O
"control_file"	pointer
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
SW_A_tag	pointer
,	O
tag	int
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"interpreter"	pointer
,	O
NULL	O
,	O
rpm_prog	int
,	O
0	int
,	O
h	pointer
,	O
"/bin/sh"	pointer
,	O
uxfio_ofd	int
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"source"	pointer
,	O
p	pointer
,	O
-	O
1	int
,	O
0	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
topsf_add_fl_entry	function
(	O
topsf	pointer
,	O
rpmtag	int
,	O
p	pointer
,	O
SWACFL_SRCCODE_RPMHEADER	int
)	O
;	O
swbis_free	O
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_rpm_attribute	function
(	O
char	O
*	O
kw	pointer
,	O
char	O
*	O
value	int
,	O
int	O
rpmtag	int
,	O
int	O
index	function
,	O
Header	pointer
h	pointer
,	O
char	O
*	O
defstring	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
static	O
STROB	struct
*	O
strb	pointer
;	O
char	O
*	O
towrite	pointer
=	O
NULL	O
;	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
count	long
,	O
i	int
=	O
0	int
;	O
if	O
(	O
!	O
strb	pointer
)	O
strb	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
if	O
(	O
value	int
)	O
{	O
if	O
(	O
!	O
strlen	function
(	O
value	int
)	O
&&	O
!	O
defstring	pointer
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
""	pointer
)	O
;	O
towrite	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
}	O
else	O
{	O
towrite	pointer
=	O
value	int
;	O
}	O
}	O
else	O
if	O
(	O
h	pointer
)	O
{	O
if	O
(	O
index	function
<	O
0	int
)	O
{	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
rpmtag	int
,	O
0	int
,	O
&	O
count	long
,	O
strb	pointer
)	O
)	O
{	O
towrite	pointer
=	O
defstring	pointer
;	O
}	O
else	O
{	O
while	O
(	O
i	int
++	O
<	O
count	long
)	O
{	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
rpmtag	int
,	O
i	int
-	O
1	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"rpm2swpsf error finding value\n"	pointer
)	O
;	O
}	O
if	O
(	O
i	int
<	O
count	long
)	O
{	O
strob_strcat	function
(	O
strb	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
towrite	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
rpmtag	int
,	O
index	function
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
if	O
(	O
defstring	pointer
)	O
{	O
towrite	pointer
=	O
defstring	pointer
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
""	pointer
)	O
;	O
towrite	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
}	O
}	O
else	O
{	O
towrite	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
towrite	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
}	O
if	O
(	O
kw	pointer
&&	O
towrite	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
kw	pointer
,	O
SW_A_tag	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
kw	pointer
,	O
SW_A_vendor_tag	pointer
)	O
==	O
0	int
)	O
{	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
towrite	pointer
)	O
;	O
swlib_tr	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
(	O
int	O
)	O
(	O
'_'	O
)	O
,	O
(	O
int	O
)	O
(	O
'.'	O
)	O
)	O
;	O
write_keyword	function
(	O
kw	pointer
,	O
uxfio_ofd	int
)	O
;	O
swdef_write_value	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
uxfio_ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
write_keyword	function
(	O
kw	pointer
,	O
uxfio_ofd	int
)	O
;	O
swdef_write_value	function
(	O
towrite	pointer
,	O
uxfio_ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_requisites	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
NAME_TAG	int
,	O
int	O
VERSION_TAG	int
,	O
int	O
FLAGS_TAG	int
,	O
int	O
uxfio_ofd	int
,	O
char	O
*	O
vendor_tag	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
count	long
,	O
type	int
;	O
char	O
keyword	pointer
[	O
90	int
]	O
,	O
*	O
val	array
;	O
STROB	struct
*	O
strb	pointer
;	O
STROB	struct
*	O
swreq	pointer
;	O
STROB	struct
*	O
rpmreq	pointer
;	O
strb	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
swreq	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
rpmreq	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
strob_strcpy	function
(	O
swreq	pointer
,	O
""	pointer
)	O
;	O
switch	O
(	O
NAME_TAG	int
)	O
{	O
case	O
RPMTAG_REQUIRENAME	int
:	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_REQUIRENAME	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array
,	O
&	O
count	long
)	O
)	O
return	O
0	int
;	O
strob_strcpy	function
(	O
swreq	pointer
,	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
rpmreq	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
write__req	function
(	O
topsf	pointer
,	O
count	long
,	O
NAME_TAG	int
,	O
VERSION_TAG	int
,	O
FLAGS_TAG	int
,	O
strb	pointer
,	O
swreq	pointer
,	O
rpmreq	pointer
,	O
vendor_tag	pointer
)	O
)	O
return	O
-	O
2000	int
;	O
swlib_strncpy	function
(	O
keyword	pointer
,	O
SW_A_prerequisites	pointer
,	O
sizeof	O
(	O
keyword	pointer
)	O
)	O
;	O
write_keyword	function
(	O
keyword	pointer
,	O
uxfio_ofd	int
)	O
;	O
swdef_write_value	function
(	O
strob_str	function
(	O
swreq	pointer
)	O
,	O
uxfio_ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
swlib_strncpy	function
(	O
keyword	pointer
,	O
SW_A_rpm_requires	pointer
,	O
sizeof	O
(	O
keyword	pointer
)	O
)	O
;	O
write_keyword	function
(	O
keyword	pointer
,	O
uxfio_ofd	int
)	O
;	O
swdef_write_value	function
(	O
strob_str	function
(	O
rpmreq	pointer
)	O
,	O
uxfio_ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
RPMTAG_CONFLICTNAME	int
:	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_CONFLICTNAME	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array
,	O
&	O
count	long
)	O
)	O
return	O
0	int
;	O
if	O
(	O
write__req	function
(	O
topsf	pointer
,	O
count	long
,	O
NAME_TAG	int
,	O
VERSION_TAG	int
,	O
FLAGS_TAG	int
,	O
strb	pointer
,	O
swreq	pointer
,	O
rpmreq	pointer
,	O
vendor_tag	pointer
)	O
)	O
return	O
-	O
2000	int
;	O
swlib_strncpy	function
(	O
keyword	pointer
,	O
SW_A_exrequisites	pointer
,	O
sizeof	O
(	O
keyword	pointer
)	O
)	O
;	O
write_keyword	function
(	O
keyword	pointer
,	O
uxfio_ofd	int
)	O
;	O
swdef_write_value	function
(	O
strob_str	function
(	O
swreq	pointer
)	O
,	O
uxfio_ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
swlib_strncpy	function
(	O
keyword	pointer
,	O
SW_A_rpm_conflicts	pointer
,	O
sizeof	O
(	O
keyword	pointer
)	O
)	O
;	O
write_keyword	function
(	O
keyword	pointer
,	O
uxfio_ofd	int
)	O
;	O
swdef_write_value	function
(	O
strob_str	function
(	O
rpmreq	pointer
)	O
,	O
uxfio_ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
RPMTAG_PROVIDES	O
:	O
rpmpsf_write_rpm_attribute	function
(	O
"rpm_provides"	pointer
,	O
NULL	O
,	O
RPMTAG_PROVIDES	O
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
break	O
;	O
default	O
:	O
strob_close	function
(	O
swreq	pointer
)	O
;	O
strob_close	function
(	O
strb	pointer
)	O
;	O
strob_close	function
(	O
rpmreq	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strob_close	function
(	O
swreq	pointer
)	O
;	O
strob_close	function
(	O
strb	pointer
)	O
;	O
strob_close	function
(	O
rpmreq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
check_is_clean_tag	function
(	O
int	O
flag	int
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
strchr	function
(	O
name	pointer
,	O
' '	O
)	O
||	O
strchr	function
(	O
name	pointer
,	O
'/'	O
)	O
||	O
strchr	function
(	O
name	pointer
,	O
'.'	O
)	O
||	O
strchr	function
(	O
name	pointer
,	O
'('	O
)	O
||	O
strchr	function
(	O
name	pointer
,	O
')'	O
)	O
||	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
flag	int
&	O
RPMSENSE_RPMLIB	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"rpmpsf: %s : RPMSENSE_RPMLIB is set\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
write__req	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
count	long
,	O
int	O
NAME_TAG	int
,	O
int	O
VERSION_TAG	int
,	O
int	O
FLAGS_TAG	int
,	O
STROB	struct
*	O
tmp	pointer
,	O
STROB	struct
*	O
swreq	pointer
,	O
STROB	struct
*	O
rpmreq	pointer
,	O
char	O
*	O
vendor_tag	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
i	int
;	O
int	O
is_rpm_spec	int
;	O
STROB	struct
*	O
spec	pointer
;	O
STROB	struct
*	O
flags	int
;	O
int	O
ret	int
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
v	int
;	O
int	O
flag_value	int
;	O
int	O
res	int
;	O
int	O
did1	int
=	O
0	int
;	O
int	O
did2	int
=	O
0	int
;	O
flags	int
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strcpy	function
(	O
swreq	pointer
,	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
rpmreq	pointer
,	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
""	pointer
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
count	long
&&	O
!	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
NAME_TAG	int
,	O
i	int
++	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
tmp	pointer
)	O
)	O
{	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
FLAGS_TAG	int
,	O
i	int
-	O
1	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
flags	int
)	O
;	O
flag_value	int
=	O
swlib_atoi	function
(	O
strob_str	function
(	O
flags	int
)	O
,	O
&	O
res	int
)	O
;	O
if	O
(	O
res	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error converting %s\n"	pointer
,	O
strob_str	function
(	O
flags	int
)	O
)	O
;	O
flag_value	int
=	O
0	int
;	O
}	O
is_rpm_spec	int
=	O
check_is_clean_tag	function
(	O
flag_value	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
is_rpm_spec	int
)	O
{	O
spec	pointer
=	O
rpmreq	pointer
;	O
if	O
(	O
did1	int
)	O
strob_strcat	function
(	O
spec	pointer
,	O
"\n"	pointer
)	O
;	O
did1	int
++	O
;	O
}	O
else	O
{	O
spec	pointer
=	O
swreq	pointer
;	O
if	O
(	O
did2	int
)	O
strob_strcat	function
(	O
spec	pointer
,	O
"\n"	pointer
)	O
;	O
did2	int
++	O
;	O
}	O
strob_cat	function
(	O
spec	pointer
,	O
tmp	pointer
)	O
;	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
VERSION_TAG	int
,	O
i	int
-	O
1	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
tmp	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
vendor_tag	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
(	O
s	pointer
+	O
strlen	function
(	O
vendor_tag	pointer
)	O
)	O
==	O
'\0'	O
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
if	O
(	O
strob_strlen	function
(	O
tmp	pointer
)	O
>	O
0	int
)	O
{	O
s	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
+	O
strob_strlen	function
(	O
tmp	pointer
)	O
-	O
1	int
;	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
||	O
*	O
s	pointer
==	O
'.'	O
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
}	O
}	O
v	int
=	O
vendor_tag	pointer
;	O
}	O
else	O
{	O
v	int
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
s	pointer
=	O
strchr	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
'-'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>	O
1	int
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
s	pointer
++	O
;	O
v	int
=	O
s	pointer
;	O
}	O
else	O
{	O
v	int
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
}	O
else	O
{	O
v	int
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
{	O
strob_sprintf	function
(	O
spec	pointer
,	O
1	int
,	O
",pr%s%s"	pointer
,	O
get_sense	function
(	O
flag_value	int
)	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
if	O
(	O
v	int
!=	O
NULL	O
&&	O
strlen	function
(	O
v	int
)	O
)	O
{	O
strob_sprintf	function
(	O
spec	pointer
,	O
1	int
,	O
",v=%s"	pointer
,	O
v	int
)	O
;	O
}	O
if	O
(	O
strob_strlen	function
(	O
flags	int
)	O
)	O
{	O
strob_sprintf	function
(	O
spec	pointer
,	O
1	int
,	O
",g=%s"	pointer
,	O
strob_str	function
(	O
flags	int
)	O
)	O
;	O
}	O
}	O
strob_close	function
(	O
flags	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_changelogs	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
numchanges	int
,	O
i	int
;	O
char	O
*	O
ds	pointer
;	O
time_t	long
timeval	struct
;	O
char	O
*	O
pa	pointer
;	O
int	O
newlen	pointer
;	O
STROB	struct
*	O
strb	pointer
;	O
STROB	struct
*	O
strbval	pointer
;	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_CHANGELOGNAME	int
,	O
0	int
,	O
&	O
numchanges	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
numchanges	int
)	O
return	O
0	int
;	O
strb	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
strbval	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numchanges	int
;	O
i	int
++	O
)	O
{	O
strob_strcpy	function
(	O
strbval	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_CHANGELOGTIME	int
,	O
i	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
strob_cat	function
(	O
strbval	pointer
,	O
strb	pointer
)	O
;	O
timeval	struct
=	O
(	O
time_t	long
)	O
atol	function
(	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
ds	pointer
=	O
ctime	function
(	O
&	O
timeval	struct
)	O
;	O
if	O
(	O
ds	pointer
)	O
{	O
strob_strcat	function
(	O
strbval	pointer
,	O
" "	pointer
)	O
;	O
strob_strcat	function
(	O
strbval	pointer
,	O
ds	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
strbval	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_CHANGELOGNAME	int
,	O
i	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ascii_copy	function
(	O
strbval	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_CHANGELOGTEXT	int
,	O
i	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
strob_cat	function
(	O
strbval	pointer
,	O
strb	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"change_log"	pointer
,	O
strob_str	function
(	O
strbval	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
strob_close	function
(	O
strb	pointer
)	O
;	O
strob_close	function
(	O
strbval	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_get_index_by_name	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
filename	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
numfiles	int
,	O
i	int
;	O
char	O
*	O
typevector	pointer
=	O
NULL	O
;	O
STROB	struct
*	O
strb	pointer
;	O
strb	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
rpmpsf_get_rpm_filenames_tagvalue	function
(	O
h	pointer
,	O
0	int
,	O
&	O
numfiles	int
,	O
NULL	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
numfiles	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numfiles	int
;	O
i	int
++	O
)	O
{	O
E_DEBUG3	O
(	O
"numfiles=%d  i=%d"	pointer
,	O
numfiles	int
,	O
i	int
)	O
;	O
rpmpsf_get_rpm_filenames_tagvalue	function
(	O
h	pointer
,	O
i	int
,	O
(	O
NULL	O
)	O
,	O
strb	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
strob_str	function
(	O
strb	pointer
)	O
,	O
filename	pointer
)	O
==	O
0	int
)	O
{	O
strob_close	function
(	O
strb	pointer
)	O
;	O
return	O
i	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
rpmpsf_write_psf_files	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
uxfio_ofd	int
,	O
int	O
typeflag	char
,	O
char	O
*	O
source_prefix	pointer
,	O
STROB	struct
*	O
strb	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
numfiles	int
,	O
i	int
;	O
char	O
*	O
typevector	pointer
=	O
NULL	O
;	O
numfiles	int
=	O
-	O
1	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
rpmpsf_get_rpm_filenames_tagvalue	function
(	O
h	pointer
,	O
0	int
,	O
&	O
numfiles	int
,	O
NULL	O
)	O
)	O
{	O
E_DEBUG2	O
(	O
"numfiles=%d"	pointer
,	O
numfiles	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
numfiles	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
typeflag	char
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"classify"	pointer
)	O
;	O
if	O
(	O
classify_filelist	function
(	O
topsf	pointer
,	O
&	O
typevector	pointer
,	O
numfiles	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numfiles	int
;	O
i	int
++	O
)	O
{	O
E_DEBUG3	O
(	O
"numfiles=%d  i=%d"	pointer
,	O
numfiles	int
,	O
i	int
)	O
;	O
if	O
(	O
typeflag	char
<	O
0	int
||	O
typeflag	char
==	O
typevector	pointer
[	O
i	int
]	O
)	O
{	O
rpmpsf_write_file_psf	function
(	O
topsf	pointer
,	O
i	int
,	O
uxfio_ofd	int
,	O
source_prefix	pointer
,	O
strb	pointer
)	O
;	O
}	O
}	O
if	O
(	O
typeflag	char
>=	O
0	int
&&	O
typevector	pointer
)	O
{	O
swbis_free	O
(	O
typevector	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmpsf_write_file_psf	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
arrayindex	int
,	O
int	O
uxfio_ofd	int
,	O
char	O
*	O
source_prefix	pointer
,	O
STROB	struct
*	O
strb	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
prefix	pointer
[	O
124	int
]	O
,	O
modeval	array
[	O
16	int
]	O
,	O
*	O
pre	pointer
,	O
*	O
sourcename	pointer
,	O
*	O
link_s	pointer
;	O
char	O
*	O
path	pointer
;	O
char	O
*	O
bname	pointer
;	O
int	O
count	long
,	O
type	int
,	O
ret	int
=	O
0	int
,	O
lmode	int
;	O
int	O
is_config_file	int
;	O
int	O
fileflag	int
;	O
mode_t	int
mode	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"source_prefix=[%s]"	pointer
,	O
source_prefix	pointer
)	O
;	O
E_DEBUG2	O
(	O
"strb=[%s]"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
is_config_file	int
=	O
0	int
;	O
swlib_strncpy	function
(	O
prefix	pointer
,	O
""	pointer
,	O
10	int
)	O
;	O
write_object_keyword	function
(	O
"file"	pointer
,	O
uxfio_ofd	int
)	O
;	O
fileflag	int
=	O
0	int
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILEFLAGS	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"rpmpsf_get_rpmtagvalue(h, RPMTAG_FILEFLAGS ... failed\n"	pointer
)	O
;	O
}	O
else	O
{	O
fileflag	int
=	O
swlib_atoi	function
(	O
strob_str	function
(	O
strb	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
ret	int
+=	O
rpmpsf_get_rpm_filenames_tagvalue	function
(	O
h	pointer
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
path	pointer
=	O
swlib_strdup	function
(	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"path"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
strar_add	function
(	O
topsf	pointer
->	O
header_namesM	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
E_DEBUG3	O
(	O
"Adding to header_namesM[%d] = [%s]"	pointer
,	O
arrayindex	int
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
strob_chr_index	function
(	O
topsf	pointer
->	O
file_status_arrayM	pointer
,	O
arrayindex	int
,	O
TOPSF_FILE_STATUS_IN_HEADER	int
)	O
;	O
E_DEBUG2	O
(	O
"(VOLATILE TEST)Searching archive_namesM for [%s]"	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
rpmtag_default_prefixM	pointer
)	O
{	O
bname	pointer
=	O
path	pointer
;	O
if	O
(	O
strstr	function
(	O
bname	pointer
,	O
topsf	pointer
->	O
rpmtag_default_prefixM	pointer
)	O
==	O
path	pointer
)	O
{	O
bname	pointer
=	O
bname	pointer
+	O
strlen	function
(	O
topsf	pointer
->	O
rpmtag_default_prefixM	pointer
)	O
;	O
while	O
(	O
*	O
bname	pointer
==	O
'/'	O
)	O
bname	pointer
++	O
;	O
}	O
}	O
else	O
{	O
bname	pointer
=	O
path	pointer
;	O
}	O
if	O
(	O
fileflag	int
&	O
RPMFILE_CONFIG	O
||	O
topsf_search_list	function
(	O
topsf	pointer
,	O
topsf	pointer
->	O
archive_namesM	pointer
,	O
bname	pointer
)	O
<	O
0	int
)	O
{	O
rpmpsf_write_rpm_attribute	function
(	O
"is_volatile"	pointer
,	O
"true"	pointer
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
{	O
rpmpsf_write_rpm_attribute	function
(	O
"is_volatile"	pointer
,	O
"false"	pointer
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
E_DEBUG2	O
(	O
"source_prefix=[%s]"	pointer
,	O
source_prefix	pointer
)	O
;	O
sourcename	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
prefix	pointer
)	O
+	O
strlen	function
(	O
source_prefix	pointer
)	O
+	O
strlen	function
(	O
strob_str	function
(	O
strb	pointer
)	O
)	O
+	O
20	int
)	O
;	O
swlib_strncpy	function
(	O
sourcename	pointer
,	O
source_prefix	pointer
,	O
strlen	function
(	O
source_prefix	pointer
)	O
+	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"sourcename=[%s]"	pointer
,	O
sourcename	pointer
)	O
;	O
strncat	function
(	O
sourcename	pointer
,	O
prefix	pointer
,	O
strlen	function
(	O
prefix	pointer
)	O
+	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"sourcename=[%s]"	pointer
,	O
sourcename	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
sourcename	pointer
)	O
&&	O
sourcename	pointer
[	O
strlen	function
(	O
sourcename	pointer
)	O
-	O
1	int
]	O
!=	O
'/'	O
&&	O
*	O
(	O
strob_str	function
(	O
strb	pointer
)	O
)	O
!=	O
'/'	O
)	O
strcat	function
(	O
sourcename	pointer
,	O
"/"	pointer
)	O
;	O
E_DEBUG2	O
(	O
"sourcename=[%s]"	pointer
,	O
sourcename	pointer
)	O
;	O
strcat	function
(	O
sourcename	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"sourcename=[%s]"	pointer
,	O
sourcename	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
info_only_	int
==	O
0	int
)	O
rpmpsf_write_rpm_attribute	function
(	O
"source"	pointer
,	O
sourcename	pointer
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
E_DEBUG3	O
(	O
"attribute source: [%s] [%s]"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
sourcename	pointer
)	O
;	O
topsf_add_fl_entry	function
(	O
topsf	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
sourcename	pointer
,	O
SWACFL_SRCCODE_ARCHIVE_STREAM	int
)	O
;	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILEUSERNAME	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"owner"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILEGROUPNAME	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"group"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILEMTIMES	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"mtime"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILEMODES	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
mode	int
=	O
(	O
mode_t	int
)	O
swlib_atoi	function
(	O
strob_str	function
(	O
strb	pointer
)	O
,	O
NULL	O
)	O
;	O
E_DEBUG2	O
(	O
"rpmpsf_get_rpmtagvalue(h, RPMTAG_FILEMODES: mode=[%04o]"	pointer
,	O
mode	int
)	O
;	O
modeval	array
[	O
0	int
]	O
=	O
(	O
char	O
)	O
get_filetype	function
(	O
topsf	pointer
,	O
path	pointer
,	O
mode	int
,	O
&	O
link_s	pointer
)	O
;	O
modeval	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
link_s	pointer
==	O
NULL	O
)	O
{	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILELINKTOS	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
strob_str	function
(	O
strb	pointer
)	O
)	O
)	O
rpmpsf_write_rpm_attribute	function
(	O
"link_source"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
else	O
{	O
rpmpsf_write_rpm_attribute	function
(	O
"link_source"	pointer
,	O
link_s	pointer
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
swbis_free	O
(	O
path	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"type"	pointer
,	O
modeval	array
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
if	O
(	O
*	O
modeval	array
==	O
's'	O
)	O
{	O
mode	int
=	O
0777	int
;	O
if	O
(	O
topsf	pointer
->	O
verboseM	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: setting perms 0777 for symlink in metadata: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
path	pointer
)	O
;	O
}	O
memset	function
(	O
modeval	array
,	O
'\0'	O
,	O
sizeof	O
(	O
modeval	array
)	O
)	O
;	O
mode	int
&=	O
~	O
CP_IFMT	int
;	O
E_DEBUG2	O
(	O
"AFTER &= ~CP_IFMT  mode=[%04o]"	pointer
,	O
mode	int
)	O
;	O
snprintf	function
(	O
modeval	array
,	O
6	int
,	O
"%04o"	pointer
,	O
mode	int
)	O
;	O
E_DEBUG2	O
(	O
"MODEVAL=[%s]"	pointer
,	O
modeval	array
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"mode"	pointer
,	O
modeval	array
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
info_only_	int
)	O
{	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILEMD5S	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"md5sum"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
ret	int
+=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_FILESIZES	int
,	O
arrayindex	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
;	O
rpmpsf_write_rpm_attribute	function
(	O
"size"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
h	pointer
,	O
NULL	O
,	O
uxfio_ofd	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swbis_free	O
(	O
sourcename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
find_last_link	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
key	pointer
,	O
int	O
i	int
)	O
{	O
char	O
*	O
linkname	pointer
=	O
NULL	O
;	O
char	O
*	O
name	pointer
;	O
CPLOB	struct
*	O
node_names	pointer
=	O
topsf	pointer
->	O
hl_node_names_	pointer
,	O
*	O
linkto_names	pointer
=	O
topsf	pointer
->	O
hl_linkto_names_	pointer
;	O
while	O
(	O
(	O
name	pointer
=	O
cplob_val	function
(	O
node_names	pointer
,	O
i	int
)	O
)	O
&&	O
strcmp	function
(	O
key	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
linkname	pointer
=	O
cplob_val	function
(	O
linkto_names	pointer
,	O
i	int
)	O
;	O
i	int
++	O
;	O
}	O
return	O
linkname	pointer
;	O
}	O
static	O
int	O
get_filetype	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
path	pointer
,	O
mode_t	int
mode	int
,	O
char	O
*	O
*	O
linksource	pointer
)	O
{	O
CPLOB	struct
*	O
node_names	pointer
=	O
topsf	pointer
->	O
hl_node_names_	pointer
,	O
*	O
linkto_names	pointer
=	O
topsf	pointer
->	O
hl_linkto_names_	pointer
;	O
char	O
*	O
clinkname	pointer
;	O
char	O
*	O
linkname	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
tmp	pointer
;	O
int	O
i	int
=	O
0	int
;	O
*	O
linksource	pointer
=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
path	pointer
++	O
;	O
while	O
(	O
(	O
name	pointer
=	O
cplob_val	function
(	O
linkto_names	pointer
,	O
i	int
)	O
)	O
)	O
{	O
linkname	pointer
=	O
cplob_val	function
(	O
node_names	pointer
,	O
i	int
)	O
;	O
if	O
(	O
topsf	pointer
->	O
debug_link_	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"GET_TYPE: path=[%s] name=[%s] linkname=[%s]\n"	pointer
,	O
path	pointer
,	O
name	pointer
,	O
linkname	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
name	pointer
,	O
"./"	pointer
)	O
==	O
name	pointer
)	O
name	pointer
+=	O
2	int
;	O
clinkname	pointer
=	O
swlib_return_no_leading	function
(	O
linkname	pointer
)	O
;	O
name	pointer
=	O
swlib_return_no_leading	function
(	O
name	pointer
)	O
;	O
path	pointer
=	O
swlib_return_no_leading	function
(	O
path	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
reverse_links_	int
==	O
0	int
||	O
1	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
clinkname	pointer
)	O
==	O
0	int
)	O
{	O
*	O
linksource	pointer
=	O
NULL	O
;	O
return	O
(	O
int	O
)	O
'f'	O
;	O
}	O
else	O
{	O
*	O
linksource	pointer
=	O
linkname	pointer
;	O
return	O
(	O
int	O
)	O
'h'	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
clinkname	pointer
)	O
==	O
0	int
)	O
{	O
*	O
linksource	pointer
=	O
linkname	pointer
;	O
return	O
(	O
int	O
)	O
'h'	O
;	O
}	O
else	O
{	O
*	O
linksource	pointer
=	O
NULL	O
;	O
return	O
(	O
int	O
)	O
'f'	O
;	O
}	O
}	O
}	O
i	int
++	O
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
return	O
(	O
int	O
)	O
'f'	O
;	O
else	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
return	O
(	O
int	O
)	O
'd'	O
;	O
else	O
if	O
(	O
S_ISCHR	O
(	O
mode	int
)	O
)	O
return	O
(	O
int	O
)	O
'c'	O
;	O
else	O
if	O
(	O
S_ISBLK	O
(	O
mode	int
)	O
)	O
return	O
(	O
int	O
)	O
'b'	O
;	O
else	O
if	O
(	O
S_ISFIFO	O
(	O
mode	int
)	O
)	O
return	O
(	O
int	O
)	O
'p'	O
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
return	O
(	O
int	O
)	O
's'	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
write_object_keyword	function
(	O
char	O
*	O
kw	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
char	O
buf0	array
[	O
100	int
]	O
;	O
snprintf	function
(	O
buf0	array
,	O
sizeof	O
(	O
buf0	array
)	O
,	O
"%s\n"	pointer
,	O
kw	pointer
)	O
;	O
buf0	array
[	O
sizeof	O
(	O
buf0	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
uxfio_write	function
(	O
uxfio_ofd	int
,	O
buf0	array
,	O
strlen	function
(	O
buf0	array
)	O
)	O
;	O
}	O
static	O
int	O
write_keyword	function
(	O
char	O
*	O
kw	pointer
,	O
int	O
uxfio_ofd	int
)	O
{	O
char	O
buf0	array
[	O
100	int
]	O
;	O
snprintf	function
(	O
buf0	array
,	O
sizeof	O
(	O
buf0	array
)	O
,	O
"%s "	pointer
,	O
kw	pointer
)	O
;	O
buf0	array
[	O
sizeof	O
(	O
buf0	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
uxfio_write	function
(	O
uxfio_ofd	int
,	O
buf0	array
,	O
strlen	function
(	O
buf0	array
)	O
)	O
;	O
}	O
char	O
*	O
rpmpsf_list_iterate	function
(	O
char	O
*	O
*	O
buf	pointer
,	O
char	O
*	O
str	pointer
,	O
char	O
*	O
delim	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
p1	pointer
;	O
if	O
(	O
buf	pointer
)	O
{	O
(	O
*	O
buf	pointer
)	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
size_t	long
)	O
(	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
*	O
buf	pointer
)	O
)	O
return	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
p	pointer
=	O
*	O
buf	pointer
;	O
strncpy	function
(	O
p	pointer
,	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
;	O
p1	pointer
=	O
strtok	function
(	O
p	pointer
,	O
delim	pointer
)	O
;	O
}	O
else	O
{	O
p1	pointer
=	O
strtok	function
(	O
NULL	O
,	O
delim	pointer
)	O
;	O
}	O
if	O
(	O
p1	pointer
)	O
{	O
return	O
p1	pointer
;	O
}	O
else	O
{	O
if	O
(	O
buf	pointer
)	O
{	O
if	O
(	O
*	O
buf	pointer
)	O
swbis_free	O
(	O
*	O
buf	pointer
)	O
;	O
*	O
buf	pointer
=	O
NULL	O
;	O
}	O
return	O
NULL	O
;	O
}	O
}	O
static	O
int	O
classify_filelist	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
*	O
typevector	pointer
,	O
int	O
length	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
i	int
;	O
STROB	struct
*	O
strb	pointer
;	O
strb	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
(	O
*	O
typevector	pointer
)	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
size_t	long
)	O
length	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
*	O
typevector	pointer
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
(	O
*	O
typevector	pointer
)	O
[	O
i	int
]	O
=	O
(	O
char	O
)	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
rpmpsf_get_rpm_filenames_tagvalue	function
(	O
h	pointer
,	O
i	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
strb	pointer
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fnmatch	function
(	O
"*patch"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
fnmatch	function
(	O
"*dif"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
fnmatch	function
(	O
"*diff"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
fnmatch	function
(	O
"*.diff*"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
fnmatch	function
(	O
"*.dif*"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
fnmatch	function
(	O
"*.patch*"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
==	O
0	int
||	O
0	int
)	O
{	O
(	O
*	O
typevector	pointer
)	O
[	O
i	int
]	O
=	O
(	O
char	O
)	O
(	O
SWPM_SRCFILESET_PATCH	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
fnmatch	function
(	O
"*spec"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
)	O
{	O
(	O
*	O
typevector	pointer
)	O
[	O
i	int
]	O
=	O
(	O
char	O
)	O
(	O
SWPM_SRCFILESET_BUILD_CONTROL	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
fnmatch	function
(	O
"*tar.gz"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
0	int
)	O
)	O
{	O
(	O
*	O
typevector	pointer
)	O
[	O
i	int
]	O
=	O
(	O
char	O
)	O
(	O
SWPM_SRCFILESET_SOURCE	int
)	O
;	O
}	O
else	O
{	O
(	O
*	O
typevector	pointer
)	O
[	O
i	int
]	O
=	O
(	O
char	O
)	O
(	O
SWPM_SRCFILESET_SOURCE	int
)	O
;	O
}	O
}	O
strob_close	function
(	O
strb	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
strip_newline	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'\n'	O
)	O
)	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
}	O
static	O
char	O
*	O
de_quote_it	function
(	O
char	O
*	O
src	pointer
)	O
{	O
char	O
*	O
c	int
,	O
*	O
c0	pointer
;	O
c	int
=	O
strchr	function
(	O
src	pointer
,	O
'\"'	O
)	O
;	O
if	O
(	O
!	O
c	int
)	O
return	O
src	pointer
;	O
c	int
++	O
;	O
if	O
(	O
!	O
strlen	function
(	O
c	int
)	O
)	O
{	O
return	O
--	O
c	int
;	O
}	O
c0	pointer
=	O
c	int
;	O
c	int
=	O
strchr	function
(	O
c	int
,	O
'\"'	O
)	O
;	O
if	O
(	O
c	int
)	O
{	O
*	O
c	int
=	O
'\0'	O
;	O
}	O
return	O
c0	pointer
;	O
}	O
static	O
char	O
*	O
rpmpsf_make_dfiles	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
dfiles	pointer
,	O
int	O
len	int
)	O
{	O
char	O
*	O
s	pointer
,	O
*	O
s0	pointer
;	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
STROB	struct
*	O
strb	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_DISTRIBUTION	int
,	O
0	int
,	O
(	O
int	O
*	O
)	O
(	O
NULL	O
)	O
,	O
strb	pointer
)	O
)	O
{	O
swlib_strncpy	function
(	O
dfiles	pointer
,	O
RPMPSF_DEF_DFILES	pointer
,	O
100	int
)	O
;	O
return	O
dfiles	pointer
;	O
}	O
swlib_strncpy	function
(	O
dfiles	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
len	int
)	O
;	O
strob_close	function
(	O
strb	pointer
)	O
;	O
dfiles	pointer
[	O
99	int
]	O
=	O
'\0'	O
;	O
strip_newline	function
(	O
dfiles	pointer
)	O
;	O
s	pointer
=	O
s0	pointer
=	O
de_quote_it	function
(	O
dfiles	pointer
)	O
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
isalnum	function
(	O
*	O
s	pointer
)	O
)	O
*	O
s	pointer
=	O
(	O
int	O
)	O
'_'	O
;	O
s	pointer
++	O
;	O
}	O
return	O
s0	pointer
;	O
}	O
char	O
*	O
rpmpsf_make_package_prefix	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
cwdir	pointer
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
mktempbuf	array
[	O
70	int
]	O
;	O
char	O
*	O
tmpstring	pointer
,	O
*	O
s	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
version	array
;	O
char	O
*	O
release	array
;	O
int	O
type	int
,	O
count	long
;	O
if	O
(	O
cwdir	pointer
)	O
{	O
tmpstring	pointer
=	O
cwdir	pointer
;	O
}	O
else	O
{	O
swlib_strncpy	function
(	O
mktempbuf	array
,	O
"/usr/tmp/rpmpsfXXXXXX"	pointer
,	O
70	int
)	O
;	O
tmpstring	pointer
=	O
mktemp	function
(	O
mktempbuf	array
)	O
;	O
}	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_NAME	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	pointer
,	O
&	O
count	long
)	O
;	O
name	pointer
=	O
swlib_strdup	function
(	O
s	pointer
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_VERSION	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	pointer
,	O
&	O
count	long
)	O
;	O
version	array
=	O
swlib_strdup	function
(	O
s	pointer
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_RELEASE	int
,	O
&	O
type	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	pointer
,	O
&	O
count	long
)	O
;	O
release	array
=	O
swlib_strdup	function
(	O
s	pointer
)	O
;	O
s	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
tmpstring	pointer
)	O
+	O
strlen	function
(	O
name	pointer
)	O
+	O
strlen	function
(	O
version	array
)	O
+	O
strlen	function
(	O
release	array
)	O
+	O
10	int
)	O
;	O
strcpy	function
(	O
s	pointer
,	O
tmpstring	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
tmpstring	pointer
)	O
)	O
strcat	function
(	O
s	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
name	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
"-"	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
version	array
)	O
;	O
strcat	function
(	O
s	pointer
,	O
"-"	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
release	array
)	O
;	O
swbis_free	O
(	O
name	pointer
)	O
;	O
swbis_free	O
(	O
release	array
)	O
;	O
swbis_free	O
(	O
version	array
)	O
;	O
return	O
s	pointer
;	O
}	O
static	O
int	O
rpmHeader_get_langNum	function
(	O
Header	pointer
h	pointer
,	O
char	O
*	O
*	O
da	pointer
)	O
{	O
struct	O
indexEntry	struct
*	O
table	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
;	O
if	O
(	O
table	pointer
)	O
{	O
if	O
(	O
da	pointer
!=	O
NULL	O
)	O
*	O
da	pointer
=	O
table	pointer
->	O
data	pointer
;	O
return	O
table	pointer
->	O
info	struct
.	O
count	long
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
rpmpsf_get_psf_size	function
(	O
TOPSF	struct
*	O
topsf	pointer
)	O
{	O
int	O
pid	int
,	O
mpipe	array
[	O
2	int
]	O
,	O
amount	long
;	O
pipe	function
(	O
mpipe	array
)	O
;	O
pid	int
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
mpipe	array
[	O
0	int
]	O
)	O
;	O
rpmpsf_write_beautify_psf	function
(	O
topsf	pointer
,	O
mpipe	array
[	O
1	int
]	O
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
close	pointer
(	O
mpipe	array
[	O
1	int
]	O
)	O
;	O
amount	long
=	O
swlib_read_amount	function
(	O
mpipe	array
[	O
0	int
]	O
,	O
-	O
1	int
)	O
;	O
return	O
amount	long
;	O
}	O
int	O
rpm_tagstring_to_tagno	function
(	O
char	O
*	O
tagstring	pointer
,	O
struct_MI_headerTagTableEntry	O
tags	pointer
)	O
{	O
struct_MI_headerTagTableEntry	O
tage	pointer
;	O
tage	pointer
=	O
tags	pointer
;	O
while	O
(	O
tage	pointer
->	O
name	pointer
&&	O
strcmp	function
(	O
tagstring	pointer
,	O
tage	pointer
->	O
name	pointer
)	O
)	O
tage	pointer
++	O
;	O
if	O
(	O
!	O
tage	pointer
->	O
name	pointer
)	O
return	O
-	O
1	int
;	O
else	O
return	O
tage	pointer
->	O
val	array
;	O
}	O
int	O
rpmpsf_get_rpmtag_length	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
char	O
*	O
tag	int
)	O
{	O
int	O
type	int
,	O
count	long
;	O
void	O
*	O
da	pointer
;	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
int	O
tagnumber	int
;	O
tagnumber	int
=	O
rpm_tagstring_to_tagno	function
(	O
tag	int
,	O
(	O
struct_MI_headerTagTableEntry	O
)	O
rpmTagTable	array
)	O
;	O
if	O
(	O
!	O
rpmpsf_headerGetRawEntry	function
(	O
h	pointer
,	O
tagnumber	int
,	O
&	O
type	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
da	pointer
,	O
&	O
count	long
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"get_rpmtag_length():headerGetRawEntry() failed for tag %d.\n"	pointer
,	O
tagnumber	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
type	int
==	O
RPM_STRING_TYPE	int
)	O
{	O
count	long
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
(	O
da	pointer
)	O
)	O
;	O
}	O
return	O
count	long
;	O
}	O
static	O
int	O
rpmpsf_write_beautify_psf_internal	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
fd_out	int
,	O
int	O
type	int
)	O
{	O
int	O
pid	int
,	O
mpipe	array
[	O
2	int
]	O
;	O
pipe	function
(	O
mpipe	array
)	O
;	O
pid	int
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
mpipe	array
[	O
0	int
]	O
)	O
;	O
rpmpsf_write_swdef_internal	function
(	O
topsf	pointer
,	O
mpipe	array
[	O
1	int
]	O
,	O
type	int
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
close	pointer
(	O
mpipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
type	int
==	O
2	int
)	O
{	O
return	O
sw_yyparse	function
(	O
mpipe	array
[	O
0	int
]	O
,	O
fd_out	int
,	O
"psf"	pointer
,	O
0	int
,	O
SWPARSE_FORM_INDENT	O
)	O
;	O
}	O
else	O
if	O
(	O
type	int
==	O
1	int
)	O
{	O
return	O
sw_yyparse	function
(	O
mpipe	array
[	O
0	int
]	O
,	O
fd_out	int
,	O
"INDEX"	pointer
,	O
0	int
,	O
SWPARSE_FORM_INDENT	O
)	O
;	O
}	O
else	O
if	O
(	O
type	int
==	O
0	int
)	O
{	O
return	O
sw_yyparse	function
(	O
mpipe	array
[	O
0	int
]	O
,	O
fd_out	int
,	O
"INFO"	pointer
,	O
0	int
,	O
SWPARSE_FORM_INDENT	O
)	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
rpmpsf_write_beautify_psf	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
fd_out	int
)	O
{	O
return	O
rpmpsf_write_beautify_psf_internal	function
(	O
topsf	pointer
,	O
fd_out	int
,	O
2	int
)	O
;	O
}	O
int	O
rpmpsf_write_beautify_info	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
fd_out	int
)	O
{	O
return	O
rpmpsf_write_beautify_psf_internal	function
(	O
topsf	pointer
,	O
fd_out	int
,	O
0	int
)	O
;	O
}	O
int	O
rpmpsf_write_out_tag	function
(	O
TOPSF	struct
*	O
topsf	pointer
,	O
int	O
ofd	int
)	O
{	O
Header	pointer
h	pointer
=	O
topsf_get_rpmheader	function
(	O
topsf	pointer
)	O
;	O
char	O
*	O
tagstring	pointer
=	O
topsf	pointer
->	O
user_addr	pointer
;	O
int	O
type	int
,	O
count	long
,	O
i	int
=	O
0	int
,	O
nread	int
=	O
0	int
;	O
void	O
*	O
da	pointer
,	O
*	O
p	pointer
;	O
int	O
tagnumber	int
=	O
rpm_tagstring_to_tagno	function
(	O
tagstring	pointer
,	O
(	O
struct_MI_headerTagTableEntry	O
)	O
rpmTagTable	array
)	O
;	O
if	O
(	O
!	O
rpmpsf_headerGetRawEntry	function
(	O
h	pointer
,	O
tagnumber	int
,	O
&	O
type	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
da	pointer
,	O
&	O
count	long
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"write_out_tag():headerGetRawEntry() failed for tag %d.\n"	pointer
,	O
tagnumber	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
=	O
(	O
char	O
*	O
)	O
da	pointer
;	O
if	O
(	O
type	int
==	O
RPM_STRING_TYPE	int
||	O
type	int
==	O
RPM_BIN_TYPE	int
)	O
{	O
if	O
(	O
type	int
==	O
RPM_STRING_TYPE	int
)	O
{	O
count	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
while	O
(	O
count	long
>	O
512	int
)	O
{	O
nread	int
=	O
uxfio_write	function
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
p	pointer
+	O
i	int
)	O
,	O
512	int
)	O
;	O
if	O
(	O
nread	int
<	O
0	int
)	O
return	O
-	O
i	int
;	O
i	int
+=	O
nread	int
;	O
count	long
-=	O
nread	int
;	O
}	O
nread	int
=	O
uxfio_write	function
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
p	pointer
+	O
i	int
)	O
,	O
count	long
)	O
;	O
i	int
+=	O
nread	int
;	O
return	O
i	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
rpmpsf_get_rpm_filenames_tagvalue	function
(	O
Header	pointer
h	pointer
,	O
int	O
index	function
,	O
int	O
*	O
pcount	pointer
,	O
STROB	struct
*	O
strb	pointer
)	O
{	O
char	O
*	O
p1	pointer
;	O
char	O
basename	function
[	O
124	int
]	O
;	O
int	O
ret	int
;	O
ret	int
=	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_BASENAMES	int
,	O
index	function
,	O
pcount	pointer
,	O
strb	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
if	O
(	O
pcount	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: error from f_get_rpmtagvalue, tag=%d index=%d ret=%d.\n"	pointer
,	O
RPMTAG_BASENAMES	int
,	O
index	function
,	O
ret	int
)	O
;	O
}	O
else	O
{	O
;	O
}	O
return	O
ret	int
;	O
}	O
if	O
(	O
strb	pointer
)	O
{	O
strncpy	function
(	O
basename	function
,	O
strob_str	function
(	O
strb	pointer
)	O
,	O
sizeof	O
(	O
basename	function
)	O
-	O
1	int
)	O
;	O
basename	function
[	O
sizeof	O
(	O
basename	function
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_DIRINDEXES	int
,	O
index	function
,	O
pcount	pointer
,	O
strb	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"rpmpsf_get_rpm_filenames_tagvalue():rpmpsf_get_rpmtagvalue() failed for RPMTAG_DIRINDEXES, index=%d.\n"	pointer
,	O
index	function
)	O
;	O
return	O
-	O
1	int
;	O
}	O
index	function
=	O
swlib_atoi	function
(	O
strob_str	function
(	O
strb	pointer
)	O
,	O
NULL	O
)	O
;	O
strob_setlen	function
(	O
strb	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rpmpsf_get_rpmtagvalue	function
(	O
h	pointer
,	O
RPMTAG_DIRNAMES	int
,	O
index	function
,	O
pcount	pointer
,	O
strb	pointer
)	O
)	O
{	O
strob_strcpy	function
(	O
strb	pointer
,	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strob_strcat	function
(	O
strb	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
strb	pointer
,	O
basename	function
)	O
;	O
while	O
(	O
(	O
p1	pointer
=	O
strstr	function
(	O
strob_str	function
(	O
strb	pointer
)	O
,	O
"//"	pointer
)	O
)	O
!=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
)	O
memmove	function
(	O
p1	pointer
,	O
p1	pointer
+	O
1	int
,	O
strlen	function
(	O
p1	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"strb=[%s]"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O