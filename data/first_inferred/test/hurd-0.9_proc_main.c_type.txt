const	O
char	O
*	O
argp_program_version	*
=	O
STANDARD_HURD_VERSION	function
(	O
proc	int
)	O
;	O
int	O
message_demuxer	function
(	O
mach_msg_header_t	O
*	O
inp	*
,	O
mach_msg_header_t	O
*	O
outp	*
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
process_server_routine	function
(	O
inp	*
)	O
)	O
||	O
(	O
routine	O
=	O
notify_server_routine	function
(	O
inp	*
)	O
)	O
||	O
(	O
routine	O
=	O
ports_interrupt_server_routine	function
(	O
inp	*
)	O
)	O
||	O
(	O
routine	O
=	O
proc_exc_server_routine	function
(	O
inp	*
)	O
)	O
||	O
(	O
routine	O
=	O
task_notify_server_routine	function
(	O
inp	*
)	O
)	O
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
global_lock	*
)	O
;	O
(	O
*	O
routine	O
)	O
(	O
inp	*
,	O
outp	*
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
pthread_mutex_t	enum
global_lock	enum
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
int	O
startup_fallback	int
;	O
error_t	O
increase_priority	function
(	O
void	O
)	O
{	O
mach_port_t	O
pset	int
=	O
MACH_PORT_NULL	O
,	O
psetcntl	int
=	O
MACH_PORT_NULL	O
;	O
error_t	int
err	O
;	O
err	int
=	O
thread_get_assignment	function
(	O
mach_thread_self	function
(	O
)	O
,	O
&	O
pset	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
err	int
=	O
host_processor_set_priv	function
(	O
_hurd_host_priv	*
,	O
pset	*
,	O
&	O
psetcntl	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
err	int
=	O
thread_max_priority	function
(	O
mach_thread_self	function
(	O
)	O
,	O
psetcntl	*
,	O
0	int
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_ARGUMENT	int
)	O
err	O
=	O
EPERM	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
err	O
=	O
task_priority	function
(	O
mach_task_self	function
(	O
)	O
,	O
2	int
,	O
1	int
)	O
;	O
out	O
:	O
if	O
(	O
MACH_PORT_VALID	function
(	O
pset	int
)	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
pset	O
)	O
;	O
if	O
(	O
MACH_PORT_VALID	function
(	O
psetcntl	O
)	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
psetcntl	O
)	O
;	O
return	O
err	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*
,	O
char	O
*	O
*	O
envp	*
)	O
{	O
mach_port_t	O
boot	O
;	O
error_t	O
err	O
;	O
void	O
*	O
genport	*
;	O
process_t	O
startup_port	*
;	O
mach_port_t	O
startup	int
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
"Hurd process server"	int
}	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	*
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
initialize_version_info	function
(	O
)	O
;	O
err	function
=	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
boot	struct
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
if	O
(	O
boot	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
2	int
,	O
0	int
,	O
"proc server can only be run by startup during boot"	*
)	O
;	O
proc_bucket	O
=	O
ports_create_bucket	function
(	O
)	O
;	O
proc_class	O
=	O
ports_create_class	function
(	O
0	int
,	O
0	int
)	O
;	O
generic_port_class	O
=	O
ports_create_class	function
(	O
0	int
,	O
0	int
)	O
;	O
exc_class	O
=	O
ports_create_class	function
(	O
exc_clean	*
,	O
0	int
)	O
;	O
ports_create_port	function
(	O
generic_port_class	*
,	O
proc_bucket	O
,	O
sizeof	O
(	O
struct	O
port_info	struct
)	O
,	O
&	O
genport	O
)	O
;	O
generic_port	O
=	O
ports_get_right	function
(	O
genport	*
)	O
;	O
init_proc	*
=	O
create_init_proc	function
(	O
)	O
;	O
startup_proc	int
=	O
allocate_proc	function
(	O
MACH_PORT_NULL	O
)	O
;	O
startup_proc	*
->	O
p_deadmsg	int
=	O
1	int
;	O
complete_proc	function
(	O
startup_proc	*
,	O
HURD_PID_STARTUP	int
)	O
;	O
self_proc	*
=	O
allocate_proc	function
(	O
mach_task_self	function
(	O
)	O
)	O
;	O
assert	O
(	O
self_proc	int
)	O
;	O
complete_proc	function
(	O
self_proc	*
,	O
HURD_PID_PROC	*
)	O
;	O
startup_port	int
=	O
ports_get_send_right	function
(	O
startup_proc	*
)	O
;	O
err	int
=	O
startup_procinit	function
(	O
boot	struct
,	O
startup_port	*
,	O
&	O
startup_proc	*
->	O
p_task	O
,	O
&	O
authserver	int
,	O
&	O
_hurd_host_priv	O
,	O
&	O
_hurd_device_master	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup_port	O
)	O
;	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
authserver	int
,	O
MACH_PORT_RIGHT_SEND	int
,	O
1	int
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	array
[	O
INIT_PORT_AUTH	O
]	O
,	O
authserver	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
boot	O
)	O
;	O
proc_death_notify	function
(	O
startup_proc	*
)	O
;	O
add_proc_to_hash	function
(	O
startup_proc	*
)	O
;	O
self_proc	*
->	O
p_argv	*
=	O
(	O
vm_address_t	O
)	O
argv	*
;	O
self_proc	*
->	O
p_envp	int
=	O
(	O
vm_address_t	O
)	O
envp	*
;	O
err	int
=	O
increase_priority	function
(	O
)	O
;	O
if	O
(	O
err	O
&&	O
err	O
!=	O
EPERM	O
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"Increasing priority failed"	*
)	O
;	O
err	O
=	O
register_new_task_notification	function
(	O
_hurd_host_priv	*
,	O
generic_port	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
0	int
,	O
err	O
,	O
"Registering task notifications failed"	*
)	O
;	O
{	O
mach_port_t	O
cons	int
;	O
err	int
=	O
device_open	function
(	O
_hurd_device_master	O
,	O
D_READ	O
|	O
D_WRITE	O
,	O
"console"	*
,	O
&	O
cons	O
)	O
;	O
assert_perror	O
(	O
err	O
)	O
;	O
stdin	O
=	O
mach_open_devstream	function
(	O
cons	O
,	O
"r"	*
)	O
;	O
stdout	O
=	O
stderr	O
=	O
mach_open_devstream	function
(	O
cons	O
,	O
"w"	*
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
cons	O
)	O
;	O
}	O
startup	O
=	O
file_name_lookup	function
(	O
_SERVERS_STARTUP	*
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
MACH_PORT_VALID	function
(	O
startup	O
)	O
)	O
{	O
err	int
=	O
startup_essential_task	function
(	O
startup	int
,	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_NULL	O
,	O
"proc"	*
,	O
_hurd_host_priv	*
)	O
;	O
if	O
(	O
err	int
)	O
startup_fallback	int
=	O
1	int
;	O
err	int
=	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
else	O
startup_fallback	int
=	O
1	int
;	O
while	O
(	O
1	int
)	O
ports_manage_port_operations_multithread	function
(	O
proc_bucket	O
,	O
message_demuxer	*
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O