static	O
struct	O
{	O
int	O
code	char
;	O
char	O
*	O
name	pointer
;	O
}	O
enc_7bit_ascii_fise	array
[	O
]	O
=	O
{	O
{	O
'{'	O
,	O
"adieresis"	pointer
}	O
,	O
{	O
'|'	O
,	O
"odieresis"	pointer
}	O
,	O
{	O
'}'	O
,	O
"aring"	pointer
}	O
,	O
{	O
'['	O
,	O
"Adieresis"	pointer
}	O
,	O
{	O
'\\'	O
,	O
"Odieresis"	pointer
}	O
,	O
{	O
']'	O
,	O
"Aring"	pointer
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
struct	O
{	O
int	O
code	char
;	O
char	O
*	O
name	pointer
;	O
}	O
enc_7bit_ascii_dkno	array
[	O
]	O
=	O
{	O
{	O
'{'	O
,	O
"ae"	pointer
}	O
,	O
{	O
'|'	O
,	O
"oslash"	pointer
}	O
,	O
{	O
'}'	O
,	O
"aring"	pointer
}	O
,	O
{	O
'['	O
,	O
"AE"	pointer
}	O
,	O
{	O
'\\'	O
,	O
"Oslash"	pointer
}	O
,	O
{	O
']'	O
,	O
"Aring"	pointer
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
,	O
}	O
;	O
int	O
read_config	function
(	O
char	O
*	O
path	pointer
,	O
char	O
*	O
file	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
Buffer	struct
fname	pointer
;	O
char	O
buf	pointer
[	O
4096	int
]	O
;	O
char	O
*	O
token	pointer
,	O
*	O
token2	pointer
;	O
int	O
line	int
=	O
0	int
;	O
buffer_init	function
(	O
&	O
fname	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
path	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
"/"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
file	pointer
)	O
;	O
fp	pointer
=	O
fopen	function
(	O
buffer_ptr	function
(	O
&	O
fname	pointer
)	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
buffer_uninit	function
(	O
&	O
fname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
)	O
{	O
line	int
++	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
token	pointer
=	O
GET_TOKEN	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
token	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"AcceptCompositeCharacters:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
accept_composites	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"AFMPath:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
afm_path	pointer
)	O
;	O
afm_path	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"AppendCtrlD:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
append_ctrl_D	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"Clean7Bit:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
clean_7bit	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"DefaultEncoding:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
encoding_name	pointer
)	O
;	O
encoding_name	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"DefaultFancyHeader:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
fancy_header_default	pointer
)	O
;	O
fancy_header_default	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"DefaultMedia:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
media_name	pointer
)	O
;	O
media_name	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"DefaultOutputMethod:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
token2	pointer
,	O
"printer"	pointer
)	O
)	O
output_file	pointer
=	O
OUTPUT_FILE_NONE	O
;	O
else	O
if	O
(	O
MATCH	O
(	O
token2	pointer
,	O
"stdout"	pointer
)	O
)	O
output_file	pointer
=	O
OUTPUT_FILE_STDOUT	O
;	O
else	O
CFG_FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal value \"%s\" for option %s"	pointer
)	O
,	O
token2	pointer
,	O
token	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"DownloadFont:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
strhash_put	function
(	O
download_fonts	pointer
,	O
token2	pointer
,	O
strlen	function
(	O
token2	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"EscapeChar:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
escape_char	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
if	O
(	O
escape_char	int
<	O
0	int
||	O
escape_char	int
>	O
255	int
)	O
CFG_FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"invalid value \"%s\" for option %s"	pointer
)	O
,	O
token2	pointer
,	O
token	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"FormFeedType:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
token2	pointer
,	O
"column"	pointer
)	O
)	O
formfeed_type	enum
=	O
FORMFEED_COLUMN	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
token2	pointer
,	O
"page"	pointer
)	O
)	O
formfeed_type	enum
=	O
FORMFEED_PAGE	int
;	O
else	O
CFG_FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal value \"%s\" for option %s"	pointer
)	O
,	O
token2	pointer
,	O
token	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"GeneratePageSize:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
generate_PageSize	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"HighlightBarGray:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
highlight_bar_gray	double
=	O
atof	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"HighlightBars:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
highlight_bars	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"LibraryPath:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
libpath	pointer
)	O
;	O
libpath	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"MarkWrappedLines:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
mark_wrapped_lines_style_name	pointer
)	O
;	O
mark_wrapped_lines_style_name	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"Media:"	pointer
)	O
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
w	int
,	O
h	int
,	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
name	pointer
=	O
token2	pointer
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
w	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
h	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
llx	double
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
lly	double
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
urx	double
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
ury	double
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
add_media	function
(	O
name	pointer
,	O
w	int
,	O
h	int
,	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"NoJobHeaderSwitch:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
no_job_header_switch	pointer
)	O
;	O
no_job_header_switch	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"NonPrintableFormat:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
npf_name	pointer
)	O
;	O
npf_name	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"OutputFirstLine:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
output_first_line	pointer
)	O
;	O
output_first_line	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"PageLabelFormat:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
page_label_format	pointer
)	O
;	O
page_label_format	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"PagePrefeed:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
page_prefeed	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"PostScriptLevel:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
pslevel	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"Printer:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
printer	pointer
)	O
;	O
printer	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"QueueParam:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
queue_param	pointer
)	O
;	O
queue_param	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"SetPageDevice:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
parse_key_value_pair	function
(	O
pagedevice	pointer
,	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"Spooler:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
spooler_command	pointer
)	O
;	O
spooler_command	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"StatesBinary:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
states_binary	pointer
)	O
;	O
states_binary	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"StatesColor:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
states_color	int
=	O
atoi	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"StatesConfigFile:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
states_config_file	pointer
)	O
;	O
states_config_file	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"StatesHighlightStyle:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
states_highlight_style	pointer
)	O
;	O
states_highlight_style	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"StatesPath:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
states_path	pointer
)	O
;	O
states_path	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"StatusDict:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
parse_key_value_pair	function
(	O
statusdict	pointer
,	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"TOCFormat:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
toc_fmt_string	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"Underlay:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
underlay	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
token2	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
underlay	pointer
,	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"UnderlayAngle:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
ul_angle	double
=	O
atof	function
(	O
token2	pointer
)	O
;	O
ul_angle_p	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"UnderlayFont:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
if	O
(	O
!	O
parse_font_spec	function
(	O
token2	pointer
,	O
&	O
ul_font	pointer
,	O
&	O
ul_ptsize	struct
,	O
NULL	O
)	O
)	O
CFG_FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed font spec: %s"	pointer
)	O
,	O
token2	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"UnderlayGray:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
ul_gray	double
=	O
atof	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"UnderlayPosition:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
ul_position	pointer
)	O
;	O
ul_position	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
ul_position_p	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	pointer
,	O
"UnderlayStyle:"	pointer
)	O
)	O
{	O
token2	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	function
(	O
ul_style_str	pointer
)	O
;	O
ul_style_str	pointer
=	O
xstrdup	function
(	O
token2	pointer
)	O
;	O
}	O
else	O
CFG_FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal option: %s"	pointer
)	O
,	O
token	pointer
)	O
)	O
;	O
}	O
buffer_uninit	function
(	O
&	O
fname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
add_media	function
(	O
char	O
*	O
name	pointer
,	O
int	O
w	int
,	O
int	O
h	int
,	O
int	O
llx	double
,	O
int	O
lly	double
,	O
int	O
urx	double
,	O
int	O
ury	double
)	O
{	O
MediaEntry	struct
*	O
entry	pointer
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"add_media: name=%s, w=%d, h=%d, llx=%d, lly=%d, urx=%d, ury=%d\n"	pointer
,	O
name	pointer
,	O
w	int
,	O
h	int
,	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
)	O
)	O
;	O
entry	pointer
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
entry	pointer
)	O
)	O
;	O
entry	pointer
->	O
name	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
entry	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
entry	pointer
->	O
w	int
=	O
w	int
;	O
entry	pointer
->	O
h	int
=	O
h	int
;	O
entry	pointer
->	O
llx	double
=	O
llx	double
;	O
entry	pointer
->	O
lly	double
=	O
lly	double
;	O
entry	pointer
->	O
urx	double
=	O
urx	double
;	O
entry	pointer
->	O
ury	double
=	O
ury	double
;	O
entry	pointer
->	O
next	pointer
=	O
media_names	pointer
;	O
media_names	pointer
=	O
entry	pointer
;	O
}	O
void	O
do_list_missing_characters	function
(	O
int	O
*	O
array	pointer
)	O
{	O
int	O
i	int
;	O
int	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
if	O
(	O
array	pointer
[	O
i	int
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%3d "	pointer
,	O
i	int
)	O
;	O
count	int
++	O
;	O
if	O
(	O
count	int
%	O
15	int
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
count	int
%	O
15	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
int	O
file_existsp	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
suffix	pointer
)	O
{	O
FileLookupCtx	struct
ctx	struct
;	O
int	O
result	int
;	O
ctx	struct
.	O
name	pointer
=	O
name	pointer
;	O
ctx	struct
.	O
suffix	pointer
=	O
suffix	pointer
?	O
suffix	pointer
:	O
""	pointer
;	O
ctx	struct
.	O
fullname	pointer
=	O
buffer_alloc	function
(	O
)	O
;	O
result	int
=	O
pathwalk	function
(	O
libpath	pointer
,	O
file_lookup	function
,	O
&	O
ctx	struct
)	O
;	O
buffer_free	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
;	O
return	O
result	int
;	O
}	O
int	O
paste_file	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
suffix	pointer
)	O
{	O
char	O
buf	pointer
[	O
512	int
]	O
;	O
char	O
resources	array
[	O
512	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
FileLookupCtx	struct
ctx	struct
;	O
int	O
pending_comment	int
=	O
0	int
;	O
int	O
line	int
=	O
0	int
;	O
ctx	struct
.	O
name	pointer
=	O
name	pointer
;	O
ctx	struct
.	O
suffix	pointer
=	O
suffix	pointer
?	O
suffix	pointer
:	O
""	pointer
;	O
ctx	struct
.	O
fullname	pointer
=	O
buffer_alloc	function
(	O
)	O
;	O
if	O
(	O
!	O
pathwalk	function
(	O
libpath	pointer
,	O
file_lookup	function
,	O
&	O
ctx	struct
)	O
)	O
{	O
buffer_free	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
buffer_free	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
)	O
)	O
{	O
line	int
++	O
;	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
HDR_TAG	pointer
,	O
strlen	function
(	O
HDR_TAG	pointer
)	O
)	O
==	O
0	int
)	O
break	O
;	O
}	O
while	O
(	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
)	O
)	O
{	O
line	int
++	O
;	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
RESOURCE_DSC	pointer
,	O
strlen	function
(	O
RESOURCE_DSC	pointer
)	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
;	O
strcpy	function
(	O
resources	array
,	O
buf	pointer
+	O
strlen	function
(	O
RESOURCE_DSC	pointer
)	O
)	O
;	O
pending_comment	int
=	O
1	int
;	O
parse_resources	O
:	O
cp	pointer
=	O
GET_TOKEN	O
(	O
resources	array
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
MATCH	O
(	O
cp	pointer
,	O
"font"	pointer
)	O
)	O
{	O
for	O
(	O
cp	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
cp	pointer
;	O
cp	pointer
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
)	O
if	O
(	O
!	O
strhash_get	function
(	O
res_fonts	pointer
,	O
cp	pointer
,	O
strlen	function
(	O
cp	pointer
)	O
+	O
1	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
)	O
{	O
fprintf	function
(	O
ofp	pointer
,	O
"%%%%IncludeResource: font %s\n"	pointer
,	O
cp	pointer
)	O
;	O
strhash_put	function
(	O
res_fonts	pointer
,	O
cp	pointer
,	O
strlen	function
(	O
cp	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
continue	O
;	O
}	O
else	O
if	O
(	O
pending_comment	int
&&	O
strncmp	function
(	O
buf	pointer
,	O
CONT_DSC	pointer
,	O
strlen	function
(	O
CONT_DSC	pointer
)	O
)	O
==	O
0	int
)	O
{	O
strcpy	function
(	O
resources	array
,	O
buf	pointer
+	O
strlen	function
(	O
CONT_DSC	pointer
)	O
)	O
;	O
goto	O
parse_resources	O
;	O
}	O
else	O
pending_comment	int
=	O
0	int
;	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
DIRECTIVE_FORMAT	pointer
,	O
strlen	function
(	O
DIRECTIVE_FORMAT	pointer
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
name	pointer
[	O
256	int
]	O
;	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
;	O
errno	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
DIRECTIVE_FORMAT	pointer
)	O
;	O
buf	pointer
[	O
i	int
]	O
&&	O
isspace	function
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
buf	pointer
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %%Format: no name"	pointer
)	O
,	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
line	int
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
sizeof	O
(	O
name	pointer
)	O
-	O
1	int
&&	O
buf	pointer
[	O
i	int
]	O
&&	O
!	O
isspace	function
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
name	pointer
[	O
j	int
++	O
]	O
=	O
buf	pointer
[	O
i	int
]	O
;	O
name	pointer
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
j	int
>=	O
sizeof	O
(	O
name	pointer
)	O
-	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %%Format: too long name, maxlen=%d"	pointer
)	O
,	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
line	int
,	O
sizeof	O
(	O
name	pointer
)	O
-	O
1	int
)	O
)	O
;	O
for	O
(	O
;	O
buf	pointer
[	O
i	int
]	O
&&	O
isspace	function
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
j	int
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
for	O
(	O
j	int
--	O
;	O
isspace	function
(	O
buf	pointer
[	O
j	int
]	O
)	O
&&	O
j	int
>	O
i	int
;	O
j	int
--	O
)	O
;	O
j	int
++	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"%%Format: %s %.*s\n"	pointer
,	O
name	pointer
,	O
j	int
-	O
i	int
,	O
buf	pointer
+	O
i	int
)	O
)	O
;	O
cp	pointer
=	O
xmalloc	function
(	O
j	int
-	O
i	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
cp	pointer
,	O
buf	pointer
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
cp	pointer
[	O
j	int
-	O
i	int
]	O
=	O
'\0'	O
;	O
strhash_put	function
(	O
user_strings	pointer
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
,	O
cp	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
;	O
if	O
(	O
cp2	pointer
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %%Format: name \"%s\" is already defined"	pointer
)	O
,	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
line	int
,	O
name	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
DIRECTIVE_HEADERHEIGHT	pointer
,	O
strlen	function
(	O
DIRECTIVE_HEADERHEIGHT	pointer
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
DIRECTIVE_HEADERHEIGHT	pointer
)	O
;	O
buf	pointer
[	O
i	int
]	O
&&	O
!	O
isspace	function
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
buf	pointer
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %%HeaderHeight: no argument"	pointer
)	O
,	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
line	int
)	O
)	O
;	O
d_header_h	int
=	O
atoi	function
(	O
buf	pointer
+	O
i	int
)	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"%%HeaderHeight: %d\n"	pointer
,	O
d_header_h	int
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
DIRECTIVE_FOOTERHEIGHT	pointer
,	O
strlen	function
(	O
DIRECTIVE_FOOTERHEIGHT	pointer
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
DIRECTIVE_FOOTERHEIGHT	pointer
)	O
;	O
buf	pointer
[	O
i	int
]	O
&&	O
!	O
isspace	function
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
buf	pointer
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %%FooterHeight: no argument"	pointer
)	O
,	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
line	int
)	O
)	O
;	O
d_footer_h	int
=	O
atoi	function
(	O
buf	pointer
+	O
i	int
)	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"%%FooterHeight: %d\n"	pointer
,	O
d_footer_h	int
)	O
)	O
;	O
continue	O
;	O
}	O
fputs	function
(	O
buf	pointer
,	O
ofp	pointer
)	O
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
buffer_free	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
parse_font_spec	function
(	O
char	O
*	O
spec_a	pointer
,	O
char	O
*	O
*	O
name_return	pointer
,	O
FontPoint	struct
*	O
size_return	pointer
,	O
InputEncoding	enum
*	O
encoding_return	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
;	O
char	O
*	O
spec	pointer
;	O
char	O
*	O
encp	pointer
;	O
spec	pointer
=	O
xstrdup	function
(	O
spec_a	pointer
)	O
;	O
encp	pointer
=	O
strrchr	function
(	O
spec	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
encp	pointer
)	O
{	O
*	O
encp	pointer
=	O
'\0'	O
;	O
encp	pointer
++	O
;	O
}	O
cp	pointer
=	O
strchr	function
(	O
spec	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
i	int
=	O
cp	pointer
-	O
spec	pointer
;	O
if	O
(	O
cp	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
xfree	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
cp	pointer
++	O
;	O
}	O
else	O
{	O
i	int
=	O
strlen	function
(	O
spec	pointer
)	O
-	O
1	int
;	O
if	O
(	O
i	int
<=	O
0	int
||	O
!	O
ISNUMBERDIGIT	O
(	O
spec	pointer
[	O
i	int
]	O
)	O
)	O
{	O
xfree	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
--	O
;	O
i	int
>=	O
0	int
&&	O
ISNUMBERDIGIT	O
(	O
spec	pointer
[	O
i	int
]	O
)	O
;	O
i	int
--	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
xfree	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
spec	pointer
[	O
i	int
]	O
==	O
'/'	O
)	O
{	O
for	O
(	O
i	int
--	O
;	O
i	int
>=	O
0	int
&&	O
ISNUMBERDIGIT	O
(	O
spec	pointer
[	O
i	int
]	O
)	O
;	O
i	int
--	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
xfree	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
i	int
++	O
;	O
cp	pointer
=	O
spec	pointer
+	O
i	int
;	O
}	O
cp2	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp2	pointer
)	O
{	O
*	O
cp2	pointer
++	O
=	O
'\0'	O
;	O
size_return	pointer
->	O
w	int
=	O
atof	function
(	O
cp	pointer
)	O
;	O
size_return	pointer
->	O
h	int
=	O
atof	function
(	O
cp2	pointer
)	O
;	O
}	O
else	O
size_return	pointer
->	O
w	int
=	O
size_return	pointer
->	O
h	int
=	O
atof	function
(	O
cp	pointer
)	O
;	O
*	O
name_return	pointer
=	O
(	O
char	O
*	O
)	O
xcalloc	function
(	O
1	int
,	O
i	int
+	O
1	int
)	O
;	O
strncpy	function
(	O
*	O
name_return	pointer
,	O
spec	pointer
,	O
i	int
)	O
;	O
if	O
(	O
encp	pointer
)	O
{	O
int	O
found	int
=	O
0	int
;	O
if	O
(	O
encoding_return	pointer
==	O
NULL	O
)	O
{	O
xfree	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
found	int
&&	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
j	int
]	O
!=	O
NULL	O
&&	O
MATCH	O
(	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
j	int
]	O
,	O
encp	pointer
)	O
)	O
{	O
*	O
encoding_return	pointer
=	O
encodings	array
[	O
i	int
]	O
.	O
encoding	array
;	O
encp	pointer
=	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
0	int
]	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
xfree	function
(	O
spec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
encp	pointer
=	O
encoding_name	pointer
;	O
if	O
(	O
encoding_return	pointer
)	O
*	O
encoding_return	pointer
=	O
encoding	array
;	O
}	O
xfree	function
(	O
spec	pointer
)	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"parse_font_spec(): name=%.*s, size=%g/%g, encoding=%s\n"	pointer
,	O
i	int
,	O
*	O
name_return	pointer
,	O
size_return	pointer
->	O
w	int
,	O
size_return	pointer
->	O
h	int
,	O
encp	pointer
)	O
)	O
;	O
if	O
(	O
size_return	pointer
->	O
w	int
<	O
0.0	int
&&	O
size_return	pointer
->	O
h	int
<	O
0.0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: warning: font size is negative\n"	pointer
)	O
,	O
program	pointer
)	O
)	O
;	O
else	O
if	O
(	O
size_return	pointer
->	O
w	int
<	O
0.0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: warning: font width is negative\n"	pointer
)	O
,	O
program	pointer
)	O
)	O
;	O
else	O
if	O
(	O
size_return	pointer
->	O
h	int
<	O
0.0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: warning: font height is negative\n"	pointer
)	O
,	O
program	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
read_font_info	function
(	O
void	O
)	O
{	O
CachedFontInfo	struct
*	O
font_info	pointer
;	O
AFMFont	pointer
font	pointer
;	O
int	O
font_info_cached	int
=	O
1	int
;	O
int	O
font_cached	int
=	O
1	int
;	O
int	O
i	int
;	O
unsigned	O
int	O
enc_flags	int
=	O
0	int
;	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
Buffer	struct
fkey	struct
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"reading AFM info for font \"%s\"\n"	pointer
)	O
,	O
Fname	pointer
)	O
)	O
;	O
if	O
(	O
accept_composites	int
)	O
enc_flags	int
=	O
AFM_ENCODE_ACCEPT_COMPOSITES	int
;	O
buffer_init	function
(	O
&	O
fkey	struct
)	O
;	O
buffer_append	function
(	O
&	O
fkey	struct
,	O
Fname	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"@%f:%d"	pointer
,	O
Fpt	struct
.	O
w	int
,	O
encoding	array
)	O
;	O
buffer_append	function
(	O
&	O
fkey	struct
,	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
strhash_get	function
(	O
afm_info_cache	pointer
,	O
buffer_ptr	function
(	O
&	O
fkey	struct
)	O
,	O
strlen	function
(	O
buffer_ptr	function
(	O
&	O
fkey	struct
)	O
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
font_info	pointer
)	O
)	O
{	O
AFMError	int
error	int
;	O
if	O
(	O
!	O
strhash_get	function
(	O
afm_cache	pointer
,	O
Fname	pointer
,	O
strlen	function
(	O
Fname	pointer
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
font	pointer
)	O
)	O
{	O
error	int
=	O
afm_open_font	function
(	O
afm	pointer
,	O
AFM_I_COMPOSITES	int
,	O
Fname	pointer
,	O
&	O
font	pointer
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
Fname	pointer
,	O
COUR	pointer
,	O
strlen	function
(	O
COUR	pointer
)	O
)	O
!=	O
0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open AFM file for font \"%s\", using default\n"	pointer
)	O
,	O
Fname	pointer
)	O
)	O
;	O
error	int
=	O
afm_open_default_font	function
(	O
afm	pointer
,	O
&	O
font	pointer
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
afm_error_to_string	function
(	O
error	int
,	O
buf	pointer
)	O
;	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open AFM file for the default font: %s"	pointer
)	O
,	O
buf	pointer
)	O
)	O
;	O
}	O
}	O
switch	O
(	O
encoding	array
)	O
{	O
case	O
ENC_ISO_8859_1	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_1	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_2	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_2	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_3	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_3	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_4	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_4	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_5	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_5	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_7	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_7	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_9	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_9	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_10	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_10	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ASCII	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ASCII	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ASCII_FISE	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ASCII	int
,	O
enc_flags	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
enc_7bit_ascii_fise	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
(	O
void	O
)	O
afm_font_encode	function
(	O
font	pointer
,	O
enc_7bit_ascii_fise	array
[	O
i	int
]	O
.	O
code	char
,	O
enc_7bit_ascii_fise	array
[	O
i	int
]	O
.	O
name	pointer
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ASCII_DKNO	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ASCII	int
,	O
enc_flags	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
enc_7bit_ascii_dkno	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
(	O
void	O
)	O
afm_font_encode	function
(	O
font	pointer
,	O
enc_7bit_ascii_dkno	array
[	O
i	int
]	O
.	O
code	char
,	O
enc_7bit_ascii_dkno	array
[	O
i	int
]	O
.	O
name	pointer
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_IBMPC	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_IBMPC	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_MAC	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_MAC	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_VMS	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_VMS	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_HP8	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_HP8	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_KOI8	int
:	O
(	O
void	O
)	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_KOI8	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_PS	int
:	O
break	O
;	O
}	O
if	O
(	O
!	O
strhash_put	function
(	O
afm_cache	pointer
,	O
Fname	pointer
,	O
strlen	function
(	O
Fname	pointer
)	O
,	O
font	pointer
,	O
NULL	O
)	O
)	O
font_cached	int
=	O
0	int
;	O
}	O
font_info	pointer
=	O
(	O
CachedFontInfo	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
font_info	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
{	O
AFMNumber	double
w0x	double
,	O
w0y	double
;	O
(	O
void	O
)	O
afm_font_charwidth	function
(	O
font	pointer
,	O
Fpt	struct
.	O
w	int
,	O
i	int
,	O
&	O
w0x	double
,	O
&	O
w0y	double
)	O
;	O
font_info	pointer
->	O
font_widths	array
[	O
i	int
]	O
=	O
w0x	double
;	O
if	O
(	O
font	pointer
->	O
encoding	array
[	O
i	int
]	O
==	O
AFM_ENC_NONE	O
)	O
font_info	pointer
->	O
font_ctype	array
[	O
i	int
]	O
=	O
' '	O
;	O
else	O
if	O
(	O
font	pointer
->	O
encoding	array
[	O
i	int
]	O
==	O
AFM_ENC_NON_EXISTENT	O
)	O
font_info	pointer
->	O
font_ctype	array
[	O
i	int
]	O
=	O
'.'	O
;	O
else	O
font_info	pointer
->	O
font_ctype	array
[	O
i	int
]	O
=	O
'*'	O
;	O
}	O
font_info	pointer
->	O
font_is_fixed	enum
=	O
font	pointer
->	O
writing_direction_metrics	array
[	O
0	int
]	O
.	O
IsFixedPitch	enum
;	O
font_info	pointer
->	O
font_bbox_lly	double
=	O
font	pointer
->	O
global_info	struct
.	O
FontBBox_lly	double
;	O
if	O
(	O
!	O
font_cached	int
)	O
(	O
void	O
)	O
afm_close_font	function
(	O
font	pointer
)	O
;	O
if	O
(	O
!	O
strhash_put	function
(	O
afm_info_cache	pointer
,	O
buffer_ptr	function
(	O
&	O
fkey	struct
)	O
,	O
strlen	function
(	O
buffer_ptr	function
(	O
&	O
fkey	struct
)	O
)	O
,	O
font_info	pointer
,	O
NULL	O
)	O
)	O
font_info_cached	int
=	O
0	int
;	O
}	O
memcpy	function
(	O
font_widths	array
,	O
font_info	pointer
->	O
font_widths	array
,	O
256	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
memcpy	function
(	O
font_ctype	array
,	O
font_info	pointer
->	O
font_ctype	array
,	O
256	int
)	O
;	O
font_is_fixed	enum
=	O
font_info	pointer
->	O
font_is_fixed	enum
;	O
font_bbox_lly	double
=	O
font_info	pointer
->	O
font_bbox_lly	double
;	O
if	O
(	O
!	O
font_info_cached	int
)	O
xfree	function
(	O
font_info	pointer
)	O
;	O
buffer_uninit	function
(	O
&	O
fkey	struct
)	O
;	O
}	O
void	O
download_font	function
(	O
char	O
*	O
name	pointer
)	O
{	O
AFMError	int
error	int
;	O
const	O
char	O
*	O
prefix	pointer
;	O
struct	O
stat	struct
stat_st	struct
;	O
Buffer	struct
fname	pointer
;	O
unsigned	O
char	O
buf	pointer
[	O
4096	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
int	O
i	int
;	O
char	O
*	O
cp	pointer
;	O
error	int
=	O
afm_font_prefix	function
(	O
afm	pointer
,	O
name	pointer
,	O
&	O
prefix	pointer
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
return	O
;	O
buffer_init	function
(	O
&	O
fname	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
prefix	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
".pfa"	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
buffer_ptr	function
(	O
&	O
fname	pointer
)	O
,	O
&	O
stat_st	struct
)	O
!=	O
0	int
)	O
{	O
buffer_clear	function
(	O
&	O
fname	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
prefix	pointer
)	O
;	O
buffer_append	function
(	O
&	O
fname	pointer
,	O
".pfb"	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
buffer_ptr	function
(	O
&	O
fname	pointer
)	O
,	O
&	O
stat_st	struct
)	O
!=	O
0	int
)	O
{	O
buffer_uninit	function
(	O
&	O
fname	pointer
)	O
;	O
return	O
;	O
}	O
}	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"downloading font \"%s\"\n"	pointer
)	O
,	O
name	pointer
)	O
)	O
;	O
fp	pointer
=	O
fopen	function
(	O
buffer_ptr	function
(	O
&	O
fname	pointer
)	O
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open font description file \"%s\": %s\n"	pointer
)	O
,	O
buffer_ptr	function
(	O
&	O
fname	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
buffer_uninit	function
(	O
&	O
fname	pointer
)	O
;	O
return	O
;	O
}	O
buffer_uninit	function
(	O
&	O
fname	pointer
)	O
;	O
fprintf	function
(	O
ofp	pointer
,	O
"%%%%BeginResource: font %s\n"	pointer
,	O
name	pointer
)	O
;	O
i	int
=	O
fgetc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
i	int
==	O
EOF	O
)	O
{	O
;	O
}	O
else	O
if	O
(	O
i	int
==	O
128	int
)	O
{	O
int	O
done	int
=	O
0	int
;	O
unsigned	O
int	O
chunk	int
;	O
unsigned	O
int	O
to_read	int
;	O
int	O
last_was_cr	int
;	O
int	O
j	int
;	O
ungetc	function
(	O
i	int
,	O
fp	pointer
)	O
;	O
while	O
(	O
!	O
done	int
)	O
{	O
i	int
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
6	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
6	int
)	O
break	O
;	O
chunk	int
=	O
buf	pointer
[	O
2	int
]	O
|	O
(	O
buf	pointer
[	O
3	int
]	O
<<	O
8	int
)	O
|	O
(	O
buf	pointer
[	O
4	int
]	O
<<	O
16	int
)	O
|	O
(	O
buf	pointer
[	O
5	int
]	O
<<	O
24	int
)	O
;	O
switch	O
(	O
buf	pointer
[	O
1	int
]	O
)	O
{	O
case	O
1	int
:	O
last_was_cr	int
=	O
0	int
;	O
while	O
(	O
chunk	int
>	O
0	int
)	O
{	O
to_read	int
=	O
sizeof	O
(	O
buf	pointer
)	O
<	O
chunk	int
?	O
sizeof	O
(	O
buf	pointer
)	O
:	O
chunk	int
;	O
i	int
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
to_read	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
0	int
&&	O
last_was_cr	int
&&	O
buf	pointer
[	O
0	int
]	O
!=	O
'\n'	O
)	O
{	O
fputc	function
(	O
'\n'	O
,	O
ofp	pointer
)	O
;	O
fputc	function
(	O
buf	pointer
[	O
0	int
]	O
,	O
ofp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
buf	pointer
[	O
j	int
]	O
==	O
'\r'	O
&&	O
j	int
+	O
1	int
<	O
i	int
&&	O
buf	pointer
[	O
j	int
+	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
fputc	function
(	O
'\n'	O
,	O
ofp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
buf	pointer
[	O
j	int
]	O
!=	O
'\r'	O
)	O
fputc	function
(	O
buf	pointer
[	O
j	int
]	O
,	O
ofp	pointer
)	O
;	O
}	O
chunk	int
-=	O
i	int
;	O
last_was_cr	int
=	O
(	O
buf	pointer
[	O
i	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
while	O
(	O
chunk	int
>	O
0	int
)	O
{	O
to_read	int
=	O
sizeof	O
(	O
buf	pointer
)	O
<	O
chunk	int
?	O
sizeof	O
(	O
buf	pointer
)	O
:	O
chunk	int
;	O
i	int
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
to_read	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
ofp	pointer
,	O
"%02X"	pointer
,	O
buf	pointer
[	O
j	int
]	O
)	O
;	O
if	O
(	O
(	O
j	int
+	O
1	int
)	O
%	O
32	int
==	O
0	int
)	O
fprintf	function
(	O
ofp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
chunk	int
-=	O
i	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
fprintf	function
(	O
ofp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
ungetc	function
(	O
i	int
,	O
fp	pointer
)	O
;	O
while	O
(	O
(	O
i	int
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
)	O
!=	O
0	int
)	O
fwrite	function
(	O
buf	pointer
,	O
1	int
,	O
i	int
,	O
ofp	pointer
)	O
;	O
}	O
fprintf	function
(	O
ofp	pointer
,	O
"%%%%EndResource\n"	pointer
)	O
;	O
(	O
void	O
)	O
strhash_delete	function
(	O
res_fonts	pointer
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
char	O
*	O
escape_string	function
(	O
char	O
*	O
string	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
len	long
;	O
char	O
*	O
cp	pointer
;	O
for	O
(	O
len	long
=	O
0	int
,	O
i	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
switch	O
(	O
string	pointer
[	O
i	int
]	O
)	O
{	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'\\'	O
:	O
len	long
+=	O
2	int
;	O
break	O
;	O
default	O
:	O
len	long
++	O
;	O
}	O
cp	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
switch	O
(	O
string	pointer
[	O
i	int
]	O
)	O
{	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'\\'	O
:	O
cp	pointer
[	O
j	int
++	O
]	O
=	O
'\\'	O
;	O
default	O
:	O
cp	pointer
[	O
j	int
++	O
]	O
=	O
string	pointer
[	O
i	int
]	O
;	O
break	O
;	O
}	O
cp	pointer
[	O
j	int
++	O
]	O
=	O
'\0'	O
;	O
return	O
cp	pointer
;	O
}	O
char	O
*	O
format_user_string	function
(	O
char	O
*	O
context_name	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
cp	pointer
;	O
char	O
*	O
rbuf	pointer
=	O
NULL	O
;	O
int	O
rbuflen	int
=	O
0	int
;	O
int	O
rbufpos	int
=	O
0	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
j	int
;	O
char	O
buf	pointer
[	O
512	int
]	O
;	O
char	O
buf2	array
[	O
512	int
]	O
;	O
int	O
width	int
=	O
0	int
;	O
int	O
justification	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
str	pointer
[	O
i	int
]	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
{	O
int	O
type	int
;	O
type	int
=	O
str	pointer
[	O
i	int
]	O
;	O
if	O
(	O
type	int
==	O
'%'	O
||	O
type	int
==	O
'$'	O
)	O
{	O
i	int
++	O
;	O
width	int
=	O
0	int
;	O
justification	int
=	O
1	int
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
==	O
'-'	O
)	O
{	O
i	int
++	O
;	O
justification	int
=	O
-	O
1	int
;	O
}	O
while	O
(	O
isdigit	function
(	O
str	pointer
[	O
i	int
]	O
)	O
)	O
width	int
=	O
width	int
*	O
10	int
+	O
str	pointer
[	O
i	int
++	O
]	O
-	O
'0'	O
;	O
if	O
(	O
type	int
==	O
'%'	O
)	O
{	O
switch	O
(	O
str	pointer
[	O
i	int
]	O
)	O
{	O
case	O
'%'	O
:	O
APPEND_CH	O
(	O
'%'	O
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
getcwd	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
cp	pointer
=	O
strrchr	function
(	O
buf	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
cp	pointer
++	O
;	O
else	O
cp	pointer
=	O
buf	pointer
;	O
APPEND_STR	O
(	O
cp	pointer
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%02d:%02d:%02d"	pointer
,	O
run_tm	struct
.	O
tm_hour	int
,	O
run_tm	struct
.	O
tm_min	int
,	O
run_tm	struct
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
getcwd	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
str	pointer
[	O
i	int
+	O
1	int
]	O
==	O
'{'	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
+=	O
2	int
;	O
j	int
<	O
sizeof	O
(	O
buf2	array
)	O
&&	O
str	pointer
[	O
i	int
]	O
&&	O
str	pointer
[	O
i	int
]	O
!=	O
'}'	O
;	O
i	int
++	O
,	O
j	int
++	O
)	O
buf2	array
[	O
j	int
]	O
=	O
str	pointer
[	O
i	int
]	O
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
!=	O
'}'	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: too long format for %%D{} escape"	pointer
)	O
,	O
context_name	pointer
)	O
)	O
;	O
buf2	array
[	O
j	int
]	O
=	O
'\0'	O
;	O
strftime	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
buf2	array
,	O
&	O
run_tm	struct
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"%02d-%02d-%02d"	pointer
,	O
run_tm	struct
.	O
tm_year	int
%	O
100	int
,	O
run_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct
.	O
tm_mday	int
)	O
;	O
}	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%02d/%02d/%02d"	pointer
,	O
run_tm	struct
.	O
tm_year	int
%	O
100	int
,	O
run_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct
.	O
tm_mday	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d.%d.%d"	pointer
,	O
run_tm	struct
.	O
tm_mday	int
,	O
run_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct
.	O
tm_year	int
+	O
1900	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
APPEND_STR	O
(	O
title	pointer
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
(	O
void	O
)	O
gethostname	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
cp	pointer
=	O
strchr	function
(	O
buf	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
*	O
cp	pointer
=	O
'\0'	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
(	O
void	O
)	O
gethostname	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
APPEND_STR	O
(	O
passwd	struct
->	O
pw_name	pointer
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
strcpy	function
(	O
buf	pointer
,	O
passwd	struct
->	O
pw_gecos	pointer
)	O
;	O
cp	pointer
=	O
strchr	function
(	O
buf	pointer
,	O
','	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
*	O
cp	pointer
=	O
'\0'	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d:%d%s"	pointer
,	O
run_tm	struct
.	O
tm_hour	int
>	O
12	int
?	O
run_tm	struct
.	O
tm_hour	int
-	O
12	int
:	O
run_tm	struct
.	O
tm_hour	int
,	O
run_tm	struct
.	O
tm_min	int
,	O
run_tm	struct
.	O
tm_hour	int
>	O
12	int
?	O
"pm"	pointer
:	O
"am"	pointer
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d:%d"	pointer
,	O
run_tm	struct
.	O
tm_hour	int
,	O
run_tm	struct
.	O
tm_min	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d:%d:%d"	pointer
,	O
run_tm	struct
.	O
tm_hour	int
,	O
run_tm	struct
.	O
tm_min	int
,	O
run_tm	struct
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%02d/%02d/%02d"	pointer
,	O
run_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct
.	O
tm_mday	int
,	O
run_tm	struct
.	O
tm_year	int
%	O
100	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
default	O
:	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unknown `%%' escape `%c' (%d)"	pointer
)	O
,	O
context_name	pointer
,	O
str	pointer
[	O
i	int
]	O
,	O
str	pointer
[	O
i	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
str	pointer
[	O
i	int
]	O
)	O
{	O
case	O
'$'	O
:	O
APPEND_CH	O
(	O
'$'	O
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
if	O
(	O
slicing	int
)	O
sprintf	function
(	O
buf	pointer
,	O
"%d%c"	pointer
,	O
current_pagenum	int
,	O
slice	int
-	O
1	int
+	O
'A'	O
)	O
;	O
else	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
current_pagenum	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
APPEND_CH	O
(	O
'\001'	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
total_pages	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'('	O
:	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
++	O
;	O
str	pointer
[	O
i	int
]	O
&&	O
str	pointer
[	O
i	int
]	O
!=	O
')'	O
&&	O
j	int
<	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
;	O
i	int
++	O
)	O
buf	pointer
[	O
j	int
++	O
]	O
=	O
str	pointer
[	O
i	int
]	O
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
==	O
'\0'	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: no closing ')' for $() escape"	pointer
)	O
,	O
context_name	pointer
)	O
)	O
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
!=	O
')'	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: too long variable name for $() escape"	pointer
)	O
,	O
context_name	pointer
)	O
)	O
;	O
buf	pointer
[	O
j	int
]	O
=	O
'\0'	O
;	O
cp	pointer
=	O
getenv	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
cp	pointer
=	O
""	pointer
;	O
APPEND_STR	O
(	O
cp	pointer
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%02d:%02d:%02d"	pointer
,	O
mod_tm	struct
.	O
tm_hour	int
,	O
mod_tm	struct
.	O
tm_min	int
,	O
mod_tm	struct
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
str	pointer
[	O
i	int
+	O
1	int
]	O
==	O
'{'	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
+=	O
2	int
;	O
j	int
<	O
sizeof	O
(	O
buf2	array
)	O
&&	O
str	pointer
[	O
i	int
]	O
&&	O
str	pointer
[	O
i	int
]	O
!=	O
'}'	O
;	O
i	int
++	O
,	O
j	int
++	O
)	O
buf2	array
[	O
j	int
]	O
=	O
str	pointer
[	O
i	int
]	O
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
!=	O
'}'	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: too long format for $D{} escape"	pointer
)	O
,	O
context_name	pointer
)	O
)	O
;	O
buf2	array
[	O
j	int
]	O
=	O
'\0'	O
;	O
strftime	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
buf2	array
,	O
&	O
mod_tm	struct
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"%02d-%02d-%02d"	pointer
,	O
mod_tm	struct
.	O
tm_year	int
%	O
100	int
,	O
mod_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct
.	O
tm_mday	int
)	O
;	O
}	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%02d/%02d/%02d"	pointer
,	O
mod_tm	struct
.	O
tm_year	int
%	O
100	int
,	O
mod_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct
.	O
tm_mday	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d.%d.%d"	pointer
,	O
mod_tm	struct
.	O
tm_mday	int
,	O
mod_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct
.	O
tm_year	int
+	O
1900	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d:%d%s"	pointer
,	O
mod_tm	struct
.	O
tm_hour	int
>	O
12	int
?	O
mod_tm	struct
.	O
tm_hour	int
-	O
12	int
:	O
mod_tm	struct
.	O
tm_hour	int
,	O
mod_tm	struct
.	O
tm_min	int
,	O
mod_tm	struct
.	O
tm_hour	int
>	O
12	int
?	O
"pm"	pointer
:	O
"am"	pointer
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d:%d"	pointer
,	O
mod_tm	struct
.	O
tm_hour	int
,	O
mod_tm	struct
.	O
tm_min	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d:%d:%d"	pointer
,	O
mod_tm	struct
.	O
tm_hour	int
,	O
mod_tm	struct
.	O
tm_min	int
,	O
mod_tm	struct
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
input_filenum	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
if	O
(	O
toc	int
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"%d-"	pointer
,	O
input_filenum	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'W'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%02d/%02d/%02d"	pointer
,	O
mod_tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct
.	O
tm_mday	int
,	O
mod_tm	struct
.	O
tm_year	int
%	O
100	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
APPEND_STR	O
(	O
fname	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
cp	pointer
=	O
strrchr	function
(	O
fname	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
cp	pointer
++	O
;	O
else	O
cp	pointer
=	O
fname	pointer
;	O
APPEND_STR	O
(	O
cp	pointer
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
current_file_linenum	int
-	O
1	int
)	O
;	O
APPEND_STR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
default	O
:	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unknown `$' escape `%c' (%d)"	pointer
)	O
,	O
context_name	pointer
,	O
str	pointer
[	O
i	int
]	O
,	O
str	pointer
[	O
i	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
width	int
=	O
0	int
;	O
justification	int
=	O
1	int
;	O
}	O
else	O
APPEND_CH	O
(	O
str	pointer
[	O
i	int
]	O
)	O
;	O
}	O
APPEND_CH	O
(	O
'\0'	O
)	O
;	O
cp	pointer
=	O
escape_string	function
(	O
rbuf	pointer
)	O
;	O
xfree	function
(	O
rbuf	pointer
)	O
;	O
return	O
cp	pointer
;	O
}	O
void	O
parse_key_value_pair	function
(	O
StringHashPtr	pointer
set	pointer
,	O
char	O
*	O
kv	pointer
)	O
{	O
char	O
*	O
cp	pointer
;	O
Buffer	struct
key	pointer
;	O
cp	pointer
=	O
strchr	function
(	O
kv	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
strhash_delete	function
(	O
set	pointer
,	O
kv	pointer
,	O
strlen	function
(	O
kv	pointer
)	O
+	O
1	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp	pointer
)	O
)	O
xfree	function
(	O
cp	pointer
)	O
;	O
}	O
else	O
{	O
buffer_init	function
(	O
&	O
key	pointer
)	O
;	O
buffer_append_len	function
(	O
&	O
key	pointer
,	O
kv	pointer
,	O
cp	pointer
-	O
kv	pointer
)	O
;	O
strhash_put	function
(	O
set	pointer
,	O
buffer_ptr	function
(	O
&	O
key	pointer
)	O
,	O
strlen	function
(	O
buffer_ptr	function
(	O
&	O
key	pointer
)	O
)	O
+	O
1	int
,	O
xstrdup	function
(	O
cp	pointer
+	O
1	int
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp	pointer
)	O
;	O
if	O
(	O
cp	pointer
)	O
xfree	function
(	O
cp	pointer
)	O
;	O
buffer_uninit	function
(	O
&	O
key	pointer
)	O
;	O
}	O
}	O
int	O
count_key_value_set	function
(	O
StringHashPtr	pointer
set	pointer
)	O
{	O
int	O
i	int
=	O
0	int
,	O
got	int
,	O
j	int
;	O
char	O
*	O
cp	pointer
;	O
void	O
*	O
value	pointer
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
set	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
&	O
value	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
set	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
&	O
value	pointer
)	O
)	O
i	int
++	O
;	O
return	O
i	int
;	O
}	O
int	O
pathwalk	function
(	O
char	O
*	O
path	pointer
,	O
PathWalkProc	pointer
proc	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
char	O
buf	pointer
[	O
512	int
]	O
;	O
char	O
*	O
cp	pointer
;	O
char	O
*	O
cp2	pointer
;	O
int	O
len	long
,	O
i	int
;	O
for	O
(	O
cp	pointer
=	O
path	pointer
;	O
cp	pointer
;	O
cp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
PATH_SEPARATOR	char
)	O
)	O
{	O
if	O
(	O
cp	pointer
!=	O
path	pointer
)	O
cp	pointer
++	O
;	O
cp2	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
PATH_SEPARATOR	char
)	O
;	O
if	O
(	O
cp2	pointer
)	O
len	long
=	O
cp2	pointer
-	O
cp	pointer
;	O
else	O
len	long
=	O
strlen	function
(	O
cp	pointer
)	O
;	O
memcpy	function
(	O
buf	pointer
,	O
cp	pointer
,	O
len	long
)	O
;	O
buf	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
i	int
=	O
(	O
*	O
proc	pointer
)	O
(	O
buf	pointer
,	O
context	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
file_lookup	function
(	O
char	O
*	O
path	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
int	O
len	long
;	O
FileLookupCtx	struct
*	O
ctx	struct
=	O
context	pointer
;	O
struct	O
stat	struct
stat_st	struct
;	O
int	O
i	int
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"file_lookup(): %s/%s%s\t"	pointer
,	O
path	pointer
,	O
ctx	struct
->	O
name	pointer
,	O
ctx	struct
->	O
suffix	pointer
)	O
)	O
;	O
len	long
=	O
strlen	function
(	O
path	pointer
)	O
;	O
if	O
(	O
len	long
&&	O
path	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'/'	O
)	O
len	long
--	O
;	O
buffer_clear	function
(	O
ctx	struct
->	O
fullname	pointer
)	O
;	O
buffer_append_len	function
(	O
ctx	struct
->	O
fullname	pointer
,	O
path	pointer
,	O
len	long
)	O
;	O
buffer_append	function
(	O
ctx	struct
->	O
fullname	pointer
,	O
"/"	pointer
)	O
;	O
buffer_append	function
(	O
ctx	struct
->	O
fullname	pointer
,	O
ctx	struct
->	O
name	pointer
)	O
;	O
buffer_append	function
(	O
ctx	struct
->	O
fullname	pointer
,	O
ctx	struct
->	O
suffix	pointer
)	O
;	O
i	int
=	O
stat	struct
(	O
buffer_ptr	function
(	O
ctx	struct
->	O
fullname	pointer
)	O
,	O
&	O
stat_st	struct
)	O
==	O
0	int
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"#%c\n"	pointer
,	O
i	int
?	O
't'	O
:	O
'f'	O
)	O
)	O
;	O
return	O
i	int
;	O
}	O
char	O
*	O
tilde_subst	function
(	O
char	O
*	O
fname	pointer
)	O
{	O
char	O
*	O
cp	pointer
;	O
int	O
i	int
;	O
struct	O
passwd	struct
*	O
pswd	pointer
;	O
Buffer	struct
buffer	pointer
;	O
char	O
*	O
result	int
;	O
if	O
(	O
fname	pointer
[	O
0	int
]	O
!=	O
'~'	O
)	O
return	O
xstrdup	function
(	O
fname	pointer
)	O
;	O
if	O
(	O
fname	pointer
[	O
1	int
]	O
==	O
'/'	O
||	O
fname	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
cp	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
return	O
xstrdup	function
(	O
fname	pointer
)	O
;	O
buffer_init	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
cp	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
fname	pointer
+	O
1	int
)	O
;	O
result	int
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_uninit	function
(	O
&	O
buffer	pointer
)	O
;	O
return	O
result	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
fname	pointer
[	O
i	int
]	O
&&	O
fname	pointer
[	O
i	int
]	O
!=	O
'/'	O
;	O
i	int
++	O
)	O
;	O
buffer_init	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append_len	function
(	O
&	O
buffer	pointer
,	O
fname	pointer
+	O
1	int
,	O
i	int
-	O
1	int
)	O
;	O
pswd	pointer
=	O
getpwnam	function
(	O
buffer_ptr	function
(	O
&	O
buffer	pointer
)	O
)	O
;	O
buffer_uninit	function
(	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
pswd	pointer
)	O
{	O
buffer_init	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
pswd	pointer
->	O
pw_dir	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
fname	pointer
+	O
i	int
)	O
;	O
result	int
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_uninit	function
(	O
&	O
buffer	pointer
)	O
;	O
return	O
result	int
;	O
}	O
return	O
xstrdup	function
(	O
fname	pointer
)	O
;	O
}	O
double	O
parse_float	function
(	O
char	O
*	O
string	pointer
,	O
int	O
units	int
,	O
int	O
horizontal	int
)	O
{	O
double	O
val	array
;	O
char	O
*	O
end	int
;	O
val	array
=	O
strtod	function
(	O
string	pointer
,	O
&	O
end	int
)	O
;	O
if	O
(	O
end	int
==	O
string	pointer
)	O
malformed_float	O
:	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed float dimension: \"%s\""	pointer
)	O
,	O
string	pointer
)	O
)	O
;	O
if	O
(	O
units	int
)	O
{	O
switch	O
(	O
*	O
end	int
)	O
{	O
case	O
'c'	O
:	O
val	array
*=	O
72	int
/	O
2.54	int
;	O
break	O
;	O
case	O
'p'	O
:	O
break	O
;	O
case	O
'i'	O
:	O
val	array
*=	O
72	int
;	O
break	O
;	O
case	O
'\0'	O
:	O
case	O
'l'	O
:	O
if	O
(	O
horizontal	int
)	O
val	array
*=	O
CHAR_WIDTH	O
(	O
'm'	O
)	O
;	O
else	O
val	array
*=	O
LINESKIP	O
;	O
break	O
;	O
default	O
:	O
goto	O
malformed_float	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
end	int
!=	O
'\0'	O
)	O
goto	O
malformed_float	O
;	O
}	O
return	O
val	array
;	O
}	O
int	O
is_open	function
(	O
InputStream	struct
*	O
is	pointer
,	O
FILE	struct
*	O
fp	pointer
,	O
char	O
*	O
fname	pointer
,	O
char	O
*	O
input_filter	pointer
)	O
{	O
is	pointer
->	O
data_in_buf	int
=	O
0	int
;	O
is	pointer
->	O
bufpos	int
=	O
0	int
;	O
is	pointer
->	O
nreads	int
=	O
0	int
;	O
is	pointer
->	O
unget_ch	pointer
=	O
NULL	O
;	O
is	pointer
->	O
unget_pos	int
=	O
0	int
;	O
is	pointer
->	O
unget_alloc	int
=	O
0	int
;	O
if	O
(	O
input_filter	pointer
)	O
{	O
char	O
*	O
cmd	pointer
=	O
NULL	O
;	O
int	O
cmdlen	int
;	O
int	O
i	int
,	O
pos	int
;	O
char	O
*	O
cp	pointer
;	O
is	pointer
->	O
is_pipe	int
=	O
1	int
;	O
if	O
(	O
fname	pointer
==	O
NULL	O
)	O
fname	pointer
=	O
input_filter_stdin	pointer
;	O
cmdlen	int
=	O
strlen	function
(	O
input_filter	pointer
)	O
+	O
1	int
;	O
cmd	pointer
=	O
xmalloc	function
(	O
cmdlen	int
)	O
;	O
pos	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
input_filter	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
input_filter	pointer
[	O
i	int
]	O
==	O
'%'	O
)	O
{	O
switch	O
(	O
input_filter	pointer
[	O
i	int
+	O
1	int
]	O
)	O
{	O
case	O
's'	O
:	O
if	O
(	O
(	O
cp	pointer
=	O
shell_escape	function
(	O
fname	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmdlen	int
+=	O
strlen	function
(	O
cp	pointer
)	O
;	O
cmd	pointer
=	O
xrealloc	function
(	O
cmd	pointer
,	O
cmdlen	int
)	O
;	O
strcpy	function
(	O
cmd	pointer
+	O
pos	int
,	O
cp	pointer
)	O
;	O
pos	int
+=	O
strlen	function
(	O
cp	pointer
)	O
;	O
free	function
(	O
cp	pointer
)	O
;	O
}	O
i	int
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
cmd	pointer
[	O
pos	int
++	O
]	O
=	O
'%'	O
;	O
i	int
++	O
;	O
break	O
;	O
default	O
:	O
cmd	pointer
[	O
pos	int
++	O
]	O
=	O
input_filter	pointer
[	O
i	int
]	O
;	O
break	O
;	O
}	O
}	O
else	O
cmd	pointer
[	O
pos	int
++	O
]	O
=	O
input_filter	pointer
[	O
i	int
]	O
;	O
}	O
cmd	pointer
[	O
pos	int
++	O
]	O
=	O
'\0'	O
;	O
is	pointer
->	O
fp	pointer
=	O
popen	function
(	O
cmd	pointer
,	O
"r"	pointer
)	O
;	O
xfree	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
is	pointer
->	O
fp	pointer
==	O
NULL	O
)	O
{	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open input filter \"%s\" for file \"%s\": %s"	pointer
)	O
,	O
input_filter	pointer
,	O
fname	pointer
?	O
fname	pointer
:	O
"(stdin)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
is	pointer
->	O
is_pipe	int
=	O
0	int
;	O
if	O
(	O
fp	pointer
)	O
is	pointer
->	O
fp	pointer
=	O
fp	pointer
;	O
else	O
{	O
is	pointer
->	O
fp	pointer
=	O
fopen	function
(	O
fname	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
is	pointer
->	O
fp	pointer
==	O
NULL	O
)	O
{	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open input file \"%s\": %s"	pointer
)	O
,	O
fname	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
is_close	function
(	O
InputStream	struct
*	O
is	pointer
)	O
{	O
if	O
(	O
is	pointer
->	O
is_pipe	int
)	O
pclose	function
(	O
is	pointer
->	O
fp	pointer
)	O
;	O
else	O
fclose	function
(	O
is	pointer
->	O
fp	pointer
)	O
;	O
if	O
(	O
is	pointer
->	O
unget_ch	pointer
)	O
xfree	function
(	O
is	pointer
->	O
unget_ch	pointer
)	O
;	O
}	O
int	O
is_getc	function
(	O
InputStream	struct
*	O
is	pointer
)	O
{	O
int	O
ch	char
;	O
if	O
(	O
is	pointer
->	O
unget_pos	int
>	O
0	int
)	O
{	O
ch	char
=	O
is	pointer
->	O
unget_ch	pointer
[	O
--	O
is	pointer
->	O
unget_pos	int
]	O
;	O
return	O
ch	char
;	O
}	O
retry	O
:	O
if	O
(	O
is	pointer
->	O
bufpos	int
>=	O
is	pointer
->	O
data_in_buf	int
)	O
{	O
if	O
(	O
is	pointer
->	O
nreads	int
>	O
0	int
&&	O
is	pointer
->	O
data_in_buf	int
<	O
sizeof	O
(	O
is	pointer
->	O
buf	pointer
)	O
)	O
return	O
EOF	O
;	O
is	pointer
->	O
data_in_buf	int
=	O
fread	function
(	O
is	pointer
->	O
buf	pointer
,	O
1	int
,	O
sizeof	O
(	O
is	pointer
->	O
buf	pointer
)	O
,	O
is	pointer
->	O
fp	pointer
)	O
;	O
is	pointer
->	O
bufpos	int
=	O
0	int
;	O
is	pointer
->	O
nreads	int
++	O
;	O
goto	O
retry	O
;	O
}	O
return	O
is	pointer
->	O
buf	pointer
[	O
is	pointer
->	O
bufpos	int
++	O
]	O
;	O
}	O
int	O
is_ungetc	function
(	O
int	O
ch	char
,	O
InputStream	struct
*	O
is	pointer
)	O
{	O
if	O
(	O
is	pointer
->	O
unget_pos	int
>=	O
is	pointer
->	O
unget_alloc	int
)	O
{	O
is	pointer
->	O
unget_alloc	int
+=	O
1024	int
;	O
is	pointer
->	O
unget_ch	pointer
=	O
xrealloc	function
(	O
is	pointer
->	O
unget_ch	pointer
,	O
is	pointer
->	O
unget_alloc	int
)	O
;	O
}	O
is	pointer
->	O
unget_ch	pointer
[	O
is	pointer
->	O
unget_pos	int
++	O
]	O
=	O
ch	char
;	O
return	O
1	int
;	O
}	O
void	O
buffer_init	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
buffer	pointer
->	O
allocated	long
=	O
128	int
;	O
buffer	pointer
->	O
data	pointer
=	O
xmalloc	function
(	O
buffer	pointer
->	O
allocated	long
)	O
;	O
buffer	pointer
->	O
data	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
buffer	pointer
->	O
len	long
=	O
0	int
;	O
}	O
void	O
buffer_uninit	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
xfree	function
(	O
buffer	pointer
->	O
data	pointer
)	O
;	O
}	O
Buffer	struct
*	O
buffer_alloc	function
(	O
)	O
{	O
Buffer	struct
*	O
buffer	pointer
=	O
(	O
Buffer	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Buffer	struct
)	O
)	O
;	O
buffer_init	function
(	O
buffer	pointer
)	O
;	O
return	O
buffer	pointer
;	O
}	O
void	O
buffer_free	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
buffer_uninit	function
(	O
buffer	pointer
)	O
;	O
xfree	function
(	O
buffer	pointer
)	O
;	O
}	O
void	O
buffer_append	function
(	O
Buffer	struct
*	O
buffer	pointer
,	O
const	O
char	O
*	O
data	pointer
)	O
{	O
buffer_append_len	function
(	O
buffer	pointer
,	O
data	pointer
,	O
strlen	function
(	O
data	pointer
)	O
)	O
;	O
}	O
void	O
buffer_append_len	function
(	O
Buffer	struct
*	O
buffer	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
buffer	pointer
->	O
len	long
+	O
len	long
+	O
1	int
>=	O
buffer	pointer
->	O
allocated	long
)	O
{	O
buffer	pointer
->	O
allocated	long
=	O
buffer	pointer
->	O
len	long
+	O
len	long
+	O
1024	int
;	O
buffer	pointer
->	O
data	pointer
=	O
xrealloc	function
(	O
buffer	pointer
->	O
data	pointer
,	O
buffer	pointer
->	O
allocated	long
)	O
;	O
}	O
memcpy	function
(	O
buffer	pointer
->	O
data	pointer
+	O
buffer	pointer
->	O
len	long
,	O
data	pointer
,	O
len	long
)	O
;	O
buffer	pointer
->	O
len	long
+=	O
len	long
;	O
buffer	pointer
->	O
data	pointer
[	O
buffer	pointer
->	O
len	long
]	O
=	O
'\0'	O
;	O
}	O
char	O
*	O
buffer_copy	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
char	O
*	O
copy	pointer
=	O
xmalloc	function
(	O
buffer	pointer
->	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
copy	pointer
,	O
buffer	pointer
->	O
data	pointer
,	O
buffer	pointer
->	O
len	long
+	O
1	int
)	O
;	O
return	O
copy	pointer
;	O
}	O
void	O
buffer_clear	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
buffer	pointer
->	O
len	long
=	O
0	int
;	O
buffer	pointer
->	O
data	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
char	O
*	O
buffer_ptr	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
return	O
buffer	pointer
->	O
data	pointer
;	O
}	O
size_t	long
buffer_len	function
(	O
Buffer	struct
*	O
buffer	pointer
)	O
{	O
return	O
buffer	pointer
->	O
len	long
;	O
}	O
char	O
*	O
shell_escape	function
(	O
const	O
char	O
*	O
fn	pointer
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
const	O
char	O
*	O
inp	pointer
;	O
char	O
*	O
retval	pointer
,	O
*	O
outp	pointer
;	O
for	O
(	O
inp	pointer
=	O
fn	pointer
;	O
*	O
inp	pointer
;	O
++	O
inp	pointer
)	O
switch	O
(	O
*	O
inp	pointer
)	O
{	O
case	O
'\''	O
:	O
len	long
+=	O
4	int
;	O
break	O
;	O
default	O
:	O
len	long
+=	O
1	int
;	O
break	O
;	O
}	O
outp	pointer
=	O
retval	pointer
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
outp	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
inp	pointer
=	O
fn	pointer
;	O
*	O
inp	pointer
;	O
++	O
inp	pointer
)	O
switch	O
(	O
*	O
inp	pointer
)	O
{	O
case	O
'\''	O
:	O
*	O
outp	pointer
++	O
=	O
'\''	O
;	O
*	O
outp	pointer
++	O
=	O
'\\'	O
;	O
*	O
outp	pointer
++	O
=	O
'\''	O
,	O
*	O
outp	pointer
++	O
=	O
'\''	O
;	O
break	O
;	O
default	O
:	O
*	O
outp	pointer
++	O
=	O
*	O
inp	pointer
;	O
break	O
;	O
}	O
*	O
outp	pointer
=	O
0	int
;	O
return	O
retval	pointer
;	O
}	O