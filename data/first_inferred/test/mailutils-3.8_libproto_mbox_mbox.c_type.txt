static	O
int	O
mbox_is_updated	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
;	O
static	O
int	O
mbox_expunge0	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
int	O
remove_deleted	int
)	O
;	O
static	O
void	O
mbox_destroy	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
if	O
(	O
mailbox	pointer
->	O
data	pointer
)	O
{	O
size_t	long
i	long
;	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_destroy (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mud	pointer
->	O
umessages_count	long
;	O
i	long
++	O
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
i	long
]	O
;	O
if	O
(	O
mum	pointer
)	O
{	O
mu_message_destroy	function
(	O
&	O
mum	pointer
->	O
message	pointer
,	O
mum	pointer
)	O
;	O
free	function
(	O
mum	pointer
)	O
;	O
}	O
}	O
if	O
(	O
mud	pointer
->	O
umessages	pointer
)	O
free	function
(	O
mud	pointer
->	O
umessages	pointer
)	O
;	O
if	O
(	O
mud	pointer
->	O
name	pointer
)	O
free	function
(	O
mud	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
mud	pointer
)	O
;	O
mailbox	pointer
->	O
data	pointer
=	O
NULL	O
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
}	O
}	O
static	O
int	O
mbox_open	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
int	O
flags	int
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
status	int
=	O
0	int
;	O
if	O
(	O
mud	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mailbox	pointer
->	O
flags	int
=	O
flags	int
;	O
if	O
(	O
mailbox	pointer
->	O
stream	pointer
==	O
NULL	O
)	O
{	O
status	int
=	O
(	O
flags	int
&	O
MU_STREAM_CREAT	int
)	O
||	O
(	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_APPEND	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
status	int
=	O
mu_mapfile_stream_create	function
(	O
&	O
mailbox	pointer
->	O
stream	pointer
,	O
mud	pointer
->	O
name	pointer
,	O
mailbox	pointer
->	O
flags	int
)	O
;	O
}	O
if	O
(	O
status	int
)	O
status	int
=	O
mu_file_stream_create	function
(	O
&	O
mailbox	pointer
->	O
stream	pointer
,	O
mud	pointer
->	O
name	pointer
,	O
mailbox	pointer
->	O
flags	int
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
mu_stream_set_buffer	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
mu_buffer_full	int
,	O
0	int
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_open (%s, 0x%x)"	pointer
,	O
mud	pointer
->	O
name	pointer
,	O
mailbox	pointer
->	O
flags	int
)	O
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
==	O
NULL	O
&&	O
(	O
flags	int
&	O
(	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
)	O
)	O
)	O
status	int
=	O
mu_locker_create	function
(	O
&	O
mailbox	pointer
->	O
locker	pointer
,	O
mud	pointer
->	O
name	pointer
,	O
0	int
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_close	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
mud	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_close (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mud	pointer
->	O
umessages_count	long
;	O
i	long
++	O
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
i	long
]	O
;	O
if	O
(	O
mum	pointer
)	O
{	O
mu_message_destroy	function
(	O
&	O
(	O
mum	pointer
->	O
message	pointer
)	O
,	O
mum	pointer
)	O
;	O
free	function
(	O
mum	pointer
)	O
;	O
}	O
}	O
if	O
(	O
mud	pointer
->	O
umessages	pointer
)	O
free	function
(	O
mud	pointer
->	O
umessages	pointer
)	O
;	O
mud	pointer
->	O
umessages	pointer
=	O
NULL	O
;	O
mud	pointer
->	O
messages_count	long
=	O
mud	pointer
->	O
umessages_count	long
=	O
0	int
;	O
mud	pointer
->	O
size	pointer
=	O
0	int
;	O
mud	pointer
->	O
uidvalidity	long
=	O
0	int
;	O
mud	pointer
->	O
uidnext	long
=	O
0	int
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
return	O
mu_stream_close	function
(	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
}	O
static	O
int	O
mbox_remove	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_remove (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
return	O
unlink	function
(	O
mud	pointer
->	O
name	pointer
)	O
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
}	O
static	O
int	O
mbox_scan	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
msgno	long
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
size_t	long
i	long
;	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_scan (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
!	O
mbox_is_updated	function
(	O
mailbox	pointer
)	O
)	O
return	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
msgno	long
,	O
pcount	pointer
,	O
1	int
)	O
;	O
if	O
(	O
msgno	long
>	O
0	int
)	O
msgno	long
--	O
;	O
for	O
(	O
i	long
=	O
msgno	long
;	O
i	long
<	O
mud	pointer
->	O
messages_count	long
;	O
i	long
++	O
)	O
{	O
size_t	long
tmp	long
=	O
i	long
;	O
if	O
(	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MESSAGE_ADD	int
,	O
&	O
tmp	long
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
(	O
i	long
+	O
1	int
)	O
%	O
50	int
)	O
==	O
0	int
)	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_PROGRESS	int
,	O
NULL	O
)	O
;	O
}	O
*	O
pcount	pointer
=	O
mud	pointer
->	O
messages_count	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_is_updated	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
mu_off_t	long
size	pointer
=	O
0	int
;	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
mu_stream_size	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
&	O
size	pointer
)	O
!=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
size	pointer
<	O
mud	pointer
->	O
size	pointer
)	O
{	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_CORRUPT	int
,	O
mailbox	pointer
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_EMERG	O
,	O
_	O
(	O
"mailbox corrupted, shrank in size"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
(	O
mud	pointer
->	O
size	pointer
==	O
size	pointer
)	O
;	O
}	O
static	O
int	O
mbox_expunge	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
return	O
mbox_expunge0	function
(	O
mailbox	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
mbox_sync	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
return	O
mbox_expunge0	function
(	O
mailbox	pointer
,	O
0	int
)	O
;	O
}	O
static	O
int	O
mbox_message_uid	function
(	O
mu_message_t	pointer
msg	pointer
,	O
size_t	long
*	O
puid	pointer
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
puid	pointer
)	O
*	O
puid	pointer
=	O
mum	pointer
->	O
uid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_message_qid	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mu_message_qid_t	pointer
*	O
pqid	pointer
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
return	O
mu_asprintf	function
(	O
pqid	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
mum	pointer
->	O
envel_from	long
)	O
;	O
}	O
static	O
int	O
_msg_stream_setup	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mbox_message_t	pointer
mum	pointer
)	O
{	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
status	int
;	O
status	int
=	O
mu_streamref_create_abridged	function
(	O
&	O
stream	pointer
,	O
mum	pointer
->	O
mud	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
mum	pointer
->	O
envel_from_end	long
,	O
mum	pointer
->	O
body_end	long
-	O
1	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
status	int
=	O
mu_message_set_stream	function
(	O
msg	pointer
,	O
stream	pointer
,	O
mum	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_body_size	function
(	O
mu_body_t	pointer
body	pointer
,	O
size_t	long
*	O
psize	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_body_get_owner	function
(	O
body	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
mum	pointer
->	O
body_end	long
-	O
mum	pointer
->	O
body	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_body_lines	function
(	O
mu_body_t	pointer
body	pointer
,	O
size_t	long
*	O
plines	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_body_get_owner	function
(	O
body	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
plines	pointer
)	O
*	O
plines	pointer
=	O
mum	pointer
->	O
body_lines	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_msg_body_setup	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mbox_message_t	pointer
mum	pointer
)	O
{	O
mu_body_t	pointer
body	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
status	int
;	O
status	int
=	O
mu_body_create	function
(	O
&	O
body	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_streamref_create_abridged	function
(	O
&	O
stream	pointer
,	O
mum	pointer
->	O
mud	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
mum	pointer
->	O
body	pointer
,	O
mum	pointer
->	O
body_end	long
-	O
1	int
)	O
;	O
if	O
(	O
status	int
)	O
mu_body_destroy	function
(	O
&	O
body	pointer
,	O
msg	pointer
)	O
;	O
else	O
{	O
mu_body_set_stream	function
(	O
body	pointer
,	O
stream	pointer
,	O
msg	pointer
)	O
;	O
mu_body_set_size	function
(	O
body	pointer
,	O
mbox_body_size	function
,	O
msg	pointer
)	O
;	O
mu_body_set_lines	function
(	O
body	pointer
,	O
mbox_body_lines	function
,	O
msg	pointer
)	O
;	O
mu_body_clear_modified	function
(	O
body	pointer
)	O
;	O
mu_message_set_body	function
(	O
msg	pointer
,	O
body	pointer
,	O
mum	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_envelope_date	function
(	O
mu_envelope_t	pointer
envelope	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
pnwrite	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_envelope_get_owner	function
(	O
envelope	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
size_t	long
n	pointer
=	O
0	int
;	O
int	O
status	int
;	O
char	O
buffer	pointer
[	O
512	int
]	O
;	O
char	O
*	O
s	pointer
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
status	int
=	O
mu_stream_seek	function
(	O
mum	pointer
->	O
mud	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
mum	pointer
->	O
envel_from	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_stream_readline	function
(	O
mum	pointer
->	O
mud	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
&	O
n	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
mu_rtrim_class	function
(	O
buffer	pointer
,	O
MU_CTYPE_ENDLN	int
)	O
;	O
if	O
(	O
n	pointer
>	O
5	int
&&	O
(	O
s	pointer
=	O
strchr	function
(	O
buffer	pointer
+	O
5	int
,	O
' '	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
buf	pointer
&&	O
len	long
>	O
0	int
)	O
{	O
len	long
--	O
;	O
strncpy	function
(	O
buf	pointer
,	O
s	pointer
+	O
1	int
,	O
len	long
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
}	O
else	O
len	long
=	O
strlen	function
(	O
s	pointer
+	O
1	int
)	O
;	O
}	O
else	O
len	long
=	O
0	int
;	O
if	O
(	O
pnwrite	pointer
)	O
*	O
pnwrite	pointer
=	O
len	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_envelope_sender	function
(	O
mu_envelope_t	pointer
envelope	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
pnwrite	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_envelope_get_owner	function
(	O
envelope	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
size_t	long
n	pointer
=	O
0	int
;	O
int	O
status	int
;	O
char	O
buffer	pointer
[	O
512	int
]	O
;	O
char	O
*	O
s	pointer
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
status	int
=	O
mu_stream_seek	function
(	O
mum	pointer
->	O
mud	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
mum	pointer
->	O
envel_from	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_stream_readline	function
(	O
mum	pointer
->	O
mud	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
&	O
n	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
n	pointer
>	O
5	int
&&	O
(	O
s	pointer
=	O
strchr	function
(	O
buffer	pointer
+	O
5	int
,	O
' '	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
if	O
(	O
buf	pointer
&&	O
len	long
>	O
0	int
)	O
{	O
len	long
--	O
;	O
strncpy	function
(	O
buf	pointer
,	O
buffer	pointer
+	O
5	int
,	O
len	long
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
}	O
else	O
len	long
=	O
strlen	function
(	O
buffer	pointer
+	O
5	int
)	O
;	O
}	O
else	O
len	long
=	O
0	int
;	O
if	O
(	O
pnwrite	pointer
)	O
*	O
pnwrite	pointer
=	O
len	long
;	O
return	O
0	int
;	O
}	O
int	O
_msg_envelope_setup	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mbox_message_t	pointer
mum	pointer
)	O
{	O
mu_envelope_t	pointer
envelope	pointer
;	O
int	O
status	int
=	O
mu_envelope_create	function
(	O
&	O
envelope	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mu_envelope_set_sender	function
(	O
envelope	pointer
,	O
mbox_envelope_sender	function
,	O
msg	pointer
)	O
;	O
mu_envelope_set_date	function
(	O
envelope	pointer
,	O
mbox_envelope_date	function
,	O
msg	pointer
)	O
;	O
mu_message_set_envelope	function
(	O
msg	pointer
,	O
envelope	pointer
,	O
mum	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_get_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
*	O
pflags	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_attribute_get_owner	function
(	O
attr	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pflags	pointer
)	O
*	O
pflags	pointer
=	O
mum	pointer
->	O
attr_flags	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_set_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
flags	int
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_attribute_get_owner	function
(	O
attr	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mum	pointer
->	O
attr_flags	int
|=	O
flags	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_unset_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
flags	int
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_attribute_get_owner	function
(	O
attr	pointer
)	O
;	O
mbox_message_t	pointer
mum	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mum	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mum	pointer
->	O
attr_flags	int
&=	O
~	O
flags	int
;	O
return	O
0	int
;	O
}	O
int	O
_msg_attribute_setup	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mbox_message_t	pointer
mum	pointer
)	O
{	O
mu_attribute_t	pointer
attribute	pointer
;	O
int	O
status	int
=	O
mu_attribute_create	function
(	O
&	O
attribute	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mu_attribute_set_get_flags	function
(	O
attribute	pointer
,	O
mbox_get_attr_flags	function
,	O
msg	pointer
)	O
;	O
mu_attribute_set_set_flags	function
(	O
attribute	pointer
,	O
mbox_set_attr_flags	function
,	O
msg	pointer
)	O
;	O
mu_attribute_set_unset_flags	function
(	O
attribute	pointer
,	O
mbox_unset_attr_flags	function
,	O
msg	pointer
)	O
;	O
mu_message_set_attribute	function
(	O
msg	pointer
,	O
attribute	pointer
,	O
mum	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
_msg_setup	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mbox_message_t	pointer
mum	pointer
)	O
{	O
int	O
status	int
;	O
status	int
=	O
_msg_stream_setup	function
(	O
msg	pointer
,	O
mum	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
_msg_attribute_setup	function
(	O
msg	pointer
,	O
mum	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
_msg_body_setup	function
(	O
msg	pointer
,	O
mum	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
_msg_envelope_setup	function
(	O
msg	pointer
,	O
mum	pointer
)	O
;	O
}	O
static	O
int	O
new_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mbox_message_t	pointer
mum	pointer
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
status	int
;	O
mu_message_t	pointer
msg	pointer
;	O
status	int
=	O
mu_message_create	function
(	O
&	O
msg	pointer
,	O
mum	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
status	int
=	O
_msg_setup	function
(	O
msg	pointer
,	O
mum	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_message_destroy	function
(	O
&	O
msg	pointer
,	O
mum	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_message_set_uid	function
(	O
msg	pointer
,	O
mbox_message_uid	function
,	O
mum	pointer
)	O
;	O
mu_message_set_qid	function
(	O
msg	pointer
,	O
mbox_message_qid	function
,	O
mum	pointer
)	O
;	O
mum	pointer
->	O
message	pointer
=	O
msg	pointer
;	O
mu_message_set_mailbox	function
(	O
msg	pointer
,	O
mailbox	pointer
,	O
mum	pointer
)	O
;	O
mu_message_clear_modified	function
(	O
msg	pointer
)	O
;	O
*	O
pmsg	pointer
=	O
msg	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
msgno	long
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
status	int
;	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mbox_message_t	pointer
mum	pointer
;	O
if	O
(	O
pmsg	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
mud	pointer
==	O
NULL	O
||	O
msgno	long
<	O
1	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
status	int
=	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
if	O
(	O
!	O
(	O
mud	pointer
->	O
messages_count	long
>	O
0	int
&&	O
msgno	long
>	O
0	int
&&	O
msgno	long
<=	O
mud	pointer
->	O
messages_count	long
)	O
)	O
return	O
MU_ERR_NOENT	O
;	O
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
msgno	long
-	O
1	int
]	O
;	O
if	O
(	O
mum	pointer
->	O
message	pointer
)	O
{	O
if	O
(	O
pmsg	pointer
)	O
*	O
pmsg	pointer
=	O
mum	pointer
->	O
message	pointer
;	O
return	O
0	int
;	O
}	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_get_message (%s, %lu)"	pointer
,	O
mud	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
msgno	long
)	O
)	O
;	O
return	O
new_message	function
(	O
mailbox	pointer
,	O
mum	pointer
,	O
pmsg	pointer
)	O
;	O
}	O
static	O
int	O
qid2off	function
(	O
mu_message_qid_t	pointer
qid	pointer
,	O
mu_off_t	long
*	O
pret	pointer
)	O
{	O
mu_off_t	long
ret	pointer
=	O
0	int
;	O
for	O
(	O
;	O
*	O
qid	pointer
;	O
qid	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
'0'	O
<=	O
*	O
qid	pointer
&&	O
*	O
qid	pointer
<=	O
'9'	O
)	O
)	O
return	O
1	int
;	O
ret	pointer
=	O
ret	pointer
*	O
10	int
+	O
*	O
qid	pointer
-	O
'0'	O
;	O
}	O
*	O
pret	pointer
=	O
ret	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_quick_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_qid_t	pointer
qid	pointer
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
status	int
;	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mbox_message_t	pointer
mum	pointer
;	O
mu_off_t	long
offset	long
;	O
if	O
(	O
mailbox	pointer
==	O
NULL	O
||	O
qid2off	function
(	O
qid	pointer
,	O
&	O
offset	long
)	O
||	O
!	O
(	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_QACCESS	int
)	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
status	int
=	O
mbox_scan1	function
(	O
mailbox	pointer
,	O
offset	long
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
return	O
MU_ERR_NOENT	O
;	O
}	O
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
0	int
]	O
;	O
if	O
(	O
mum	pointer
->	O
message	pointer
)	O
{	O
char	O
*	O
vqid	pointer
;	O
status	int
=	O
mu_message_get_qid	function
(	O
mum	pointer
->	O
message	pointer
,	O
&	O
vqid	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
strcmp	function
(	O
qid	pointer
,	O
vqid	pointer
)	O
;	O
free	function
(	O
vqid	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
MU_ERR_EXISTS	O
;	O
if	O
(	O
pmsg	pointer
)	O
*	O
pmsg	pointer
=	O
mum	pointer
->	O
message	pointer
;	O
return	O
0	int
;	O
}	O
return	O
new_message	function
(	O
mailbox	pointer
,	O
mum	pointer
,	O
pmsg	pointer
)	O
;	O
}	O
static	O
int	O
mbox_get_size	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
mu_off_t	long
size	pointer
;	O
int	O
status	int
;	O
status	int
=	O
mu_stream_size	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
&	O
size	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
size	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_messages_count	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
mud	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
mbox_is_updated	function
(	O
mailbox	pointer
)	O
)	O
return	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
mud	pointer
->	O
messages_count	long
,	O
pcount	pointer
,	O
0	int
)	O
;	O
if	O
(	O
pcount	pointer
)	O
*	O
pcount	pointer
=	O
mud	pointer
->	O
messages_count	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_messages_recent	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mbox_message_t	pointer
mum	pointer
;	O
size_t	long
j	long
,	O
recent	long
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
int	O
status	int
=	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
for	O
(	O
recent	long
=	O
j	long
=	O
0	int
;	O
j	long
<	O
mud	pointer
->	O
messages_count	long
;	O
j	long
++	O
)	O
{	O
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
j	long
]	O
;	O
if	O
(	O
mum	pointer
&&	O
MU_ATTRIBUTE_IS_UNSEEN	O
(	O
mum	pointer
->	O
attr_flags	int
)	O
)	O
recent	long
++	O
;	O
}	O
*	O
pcount	pointer
=	O
recent	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_message_unseen	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pmsgno	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mbox_message_t	pointer
mum	pointer
;	O
size_t	long
j	long
,	O
unseen	long
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
int	O
status	int
=	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
for	O
(	O
unseen	long
=	O
j	long
=	O
0	int
;	O
j	long
<	O
mud	pointer
->	O
messages_count	long
;	O
j	long
++	O
)	O
{	O
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
j	long
]	O
;	O
if	O
(	O
mum	pointer
&&	O
MU_ATTRIBUTE_IS_UNREAD	O
(	O
mum	pointer
->	O
attr_flags	int
)	O
)	O
{	O
unseen	long
=	O
j	long
+	O
1	int
;	O
break	O
;	O
}	O
}	O
*	O
pmsgno	pointer
=	O
unseen	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_uidvalidity	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
unsigned	O
long	O
*	O
puidvalidity	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
status	int
=	O
mbox_messages_count	function
(	O
mailbox	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
status	int
=	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
if	O
(	O
puidvalidity	pointer
)	O
*	O
puidvalidity	pointer
=	O
mud	pointer
->	O
uidvalidity	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mbox_uidnext	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
puidnext	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
status	int
=	O
mbox_messages_count	function
(	O
mailbox	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
status	int
=	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
if	O
(	O
puidnext	pointer
)	O
*	O
puidnext	pointer
=	O
mud	pointer
->	O
uidnext	long
;	O
return	O
0	int
;	O
}	O
void	O
mbox_cleanup	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
mu_mailbox_t	pointer
mailbox	pointer
=	O
arg	pointer
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
}	O
int	O
restore_sender	function
(	O
mu_message_t	pointer
msg	pointer
,	O
char	O
*	O
*	O
pret	pointer
)	O
{	O
mu_header_t	pointer
hdr	pointer
;	O
const	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
char	O
*	O
from	pointer
=	O
NULL	O
;	O
if	O
(	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
==	O
0	int
)	O
mu_header_sget_value	O
(	O
hdr	pointer
,	O
MU_HEADER_FROM	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
status	int
;	O
mu_address_t	pointer
addr	pointer
;	O
status	int
=	O
mu_address_create	function
(	O
&	O
addr	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
mu_address_aget_email	function
(	O
addr	pointer
,	O
1	int
,	O
&	O
from	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
addr	pointer
)	O
;	O
}	O
if	O
(	O
!	O
from	pointer
)	O
{	O
from	pointer
=	O
strdup	function
(	O
PACKAGE	pointer
)	O
;	O
if	O
(	O
!	O
from	pointer
)	O
return	O
ENOMEM	int
;	O
}	O
*	O
pret	pointer
=	O
from	pointer
;	O
return	O
0	int
;	O
}	O
int	O
restore_date	function
(	O
mu_message_t	pointer
msg	pointer
,	O
char	O
*	O
*	O
pret	pointer
)	O
{	O
mu_header_t	pointer
hdr	pointer
;	O
const	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
char	O
*	O
date	struct
=	O
NULL	O
;	O
struct	O
tm	struct
tm	struct
;	O
struct	O
mu_timezone	struct
tz	pointer
;	O
if	O
(	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
mu_header_sget_value	O
(	O
hdr	pointer
,	O
MU_HEADER_DATE	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
return	O
rc	int
;	O
}	O
if	O
(	O
s	pointer
&&	O
mu_scan_datetime	function
(	O
s	pointer
,	O
MU_DATETIME_SCAN_RFC822	pointer
,	O
&	O
tm	struct
,	O
&	O
tz	pointer
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
char	O
datebuf	array
[	O
MU_DATETIME_FROM_LENGTH	int
+	O
1	int
]	O
;	O
mu_strftime	function
(	O
datebuf	array
,	O
sizeof	O
datebuf	array
,	O
MU_DATETIME_FROM	pointer
,	O
&	O
tm	struct
)	O
;	O
date	struct
=	O
strdup	function
(	O
datebuf	array
)	O
;	O
}	O
else	O
{	O
time_t	long
t	long
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
date	struct
=	O
strdup	function
(	O
ctime	function
(	O
&	O
t	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
date	struct
)	O
return	O
ENOMEM	int
;	O
*	O
pret	pointer
=	O
date	struct
;	O
return	O
0	int
;	O
}	O
static	O
int	O
write_array	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
int	O
count	pointer
,	O
const	O
char	O
*	O
*	O
array	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	pointer
;	O
i	long
++	O
)	O
{	O
int	O
status	int
=	O
mu_stream_write	function
(	O
stream	pointer
,	O
array	pointer
[	O
i	long
]	O
,	O
strlen	function
(	O
array	pointer
[	O
i	long
]	O
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
msg_envelope_to_stream	function
(	O
mu_stream_t	pointer
out	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
mu_envelope_t	pointer
env	pointer
;	O
int	O
status	int
;	O
char	O
*	O
sender	pointer
=	O
NULL	O
;	O
char	O
*	O
datestr	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
envarr	array
[	O
5	int
]	O
;	O
status	int
=	O
mu_message_get_envelope	function
(	O
msg	pointer
,	O
&	O
env	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_envelope_aget_sender	function
(	O
env	pointer
,	O
&	O
sender	pointer
)	O
;	O
switch	O
(	O
status	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
status	int
=	O
restore_sender	function
(	O
msg	pointer
,	O
&	O
sender	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
break	O
;	O
default	O
:	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_envelope_aget_date	function
(	O
env	pointer
,	O
&	O
datestr	pointer
)	O
;	O
switch	O
(	O
status	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
status	int
=	O
restore_date	function
(	O
msg	pointer
,	O
&	O
datestr	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
break	O
;	O
free	function
(	O
sender	pointer
)	O
;	O
default	O
:	O
return	O
status	int
;	O
}	O
mu_rtrim_class	function
(	O
datestr	pointer
,	O
MU_CTYPE_ENDLN	int
)	O
;	O
envarr	array
[	O
0	int
]	O
=	O
"From "	pointer
;	O
envarr	array
[	O
1	int
]	O
=	O
sender	pointer
;	O
envarr	array
[	O
2	int
]	O
=	O
" "	pointer
;	O
envarr	array
[	O
3	int
]	O
=	O
datestr	pointer
;	O
envarr	array
[	O
4	int
]	O
=	O
"\n"	pointer
;	O
status	int
=	O
write_array	function
(	O
out	pointer
,	O
5	int
,	O
envarr	array
)	O
;	O
free	function
(	O
sender	pointer
)	O
;	O
free	function
(	O
datestr	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
msg_header_to_stream	function
(	O
mu_stream_t	pointer
ostr	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
int	O
status	int
;	O
mu_header_t	pointer
header	pointer
;	O
mu_iterator_t	pointer
itr	pointer
;	O
const	O
char	O
*	O
harr	array
[	O
4	int
]	O
;	O
status	int
=	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
header	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_header_get_iterator	function
(	O
header	pointer
,	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
harr	array
[	O
1	int
]	O
=	O
": "	pointer
;	O
harr	array
[	O
3	int
]	O
=	O
"\n"	pointer
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
status	int
==	O
0	int
&&	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
mu_iterator_current_kv	function
(	O
itr	pointer
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
harr	array
[	O
0	int
]	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
harr	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
mu_c_strcasecmp	function
(	O
harr	array
[	O
0	int
]	O
,	O
MU_HEADER_STATUS	pointer
)	O
==	O
0	int
||	O
mu_c_strcasecmp	function
(	O
harr	array
[	O
0	int
]	O
,	O
MU_HEADER_X_IMAPBASE	pointer
)	O
==	O
0	int
||	O
mu_c_strcasecmp	function
(	O
harr	array
[	O
0	int
]	O
,	O
MU_HEADER_X_UID	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
status	int
=	O
write_array	function
(	O
ostr	pointer
,	O
4	int
,	O
harr	array
)	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
msg_attr_to_stream	function
(	O
mu_stream_t	pointer
ostr	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
mu_attribute_t	pointer
attr	pointer
;	O
char	O
abuf	array
[	O
MU_STATUS_BUF_SIZE	O
+	O
1	int
]	O
;	O
const	O
char	O
*	O
harr	array
[	O
4	int
]	O
;	O
int	O
status	int
;	O
status	int
=	O
mu_message_get_attribute	function
(	O
msg	pointer
,	O
&	O
attr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_attribute_to_string	function
(	O
attr	pointer
,	O
abuf	array
,	O
sizeof	O
(	O
abuf	array
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
harr	array
[	O
0	int
]	O
=	O
MU_HEADER_STATUS	pointer
;	O
harr	array
[	O
1	int
]	O
=	O
": "	pointer
;	O
harr	array
[	O
2	int
]	O
=	O
abuf	array
;	O
harr	array
[	O
3	int
]	O
=	O
"\n"	pointer
;	O
return	O
write_array	function
(	O
ostr	pointer
,	O
4	int
,	O
harr	array
)	O
;	O
}	O
static	O
int	O
uid_to_stream	function
(	O
mu_stream_t	pointer
ostr	pointer
,	O
mu_message_t	pointer
msg	pointer
,	O
mbox_data_t	pointer
mud	pointer
,	O
int	O
flags	int
)	O
{	O
size_t	long
uid	int
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
MBOX_EXPUNGE	int
)	O
{	O
int	O
status	int
=	O
mu_message_get_uid	function
(	O
msg	pointer
,	O
&	O
uid	int
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
else	O
uid	int
=	O
mud	pointer
->	O
uidnext	long
++	O
;	O
mu_stream_printf	function
(	O
ostr	pointer
,	O
"%s: %u\n"	pointer
,	O
MU_HEADER_X_UID	pointer
,	O
(	O
unsigned	O
)	O
uid	int
)	O
;	O
if	O
(	O
mu_stream_err	function
(	O
ostr	pointer
)	O
)	O
return	O
mu_stream_last_error	function
(	O
ostr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
append_message_to_stream	function
(	O
mu_stream_t	pointer
ostr	pointer
,	O
mu_message_t	pointer
msg	pointer
,	O
mbox_data_t	pointer
mud	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
status	int
;	O
mu_stream_t	pointer
istr	pointer
,	O
flt	pointer
;	O
status	int
=	O
msg_envelope_to_stream	function
(	O
ostr	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
flags	int
&	O
MBOX_EXPUNGE	int
)	O
{	O
mu_body_t	pointer
body	pointer
;	O
status	int
=	O
msg_header_to_stream	function
(	O
ostr	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
flags	int
&	O
MBOX_FIRSTMSG	int
)	O
{	O
mu_stream_printf	function
(	O
ostr	pointer
,	O
"%s: %lu %u\n"	pointer
,	O
MU_HEADER_X_IMAPBASE	pointer
,	O
(	O
unsigned	O
long	O
)	O
mud	pointer
->	O
uidvalidity	long
,	O
(	O
unsigned	O
)	O
mud	pointer
->	O
uidnext	long
)	O
;	O
if	O
(	O
mu_stream_err	function
(	O
ostr	pointer
)	O
)	O
return	O
mu_stream_last_error	function
(	O
ostr	pointer
)	O
;	O
}	O
status	int
=	O
msg_attr_to_stream	function
(	O
ostr	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
uid_to_stream	function
(	O
ostr	pointer
,	O
msg	pointer
,	O
mud	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_stream_write	function
(	O
ostr	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_message_get_body	function
(	O
msg	pointer
,	O
&	O
body	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_body_get_streamref	function
(	O
body	pointer
,	O
&	O
istr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
else	O
{	O
status	int
=	O
mu_message_get_streamref	function
(	O
msg	pointer
,	O
&	O
istr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_filter_create	function
(	O
&	O
flt	pointer
,	O
istr	pointer
,	O
"FROM"	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	function
(	O
istr	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
status	int
=	O
mu_stream_copy	function
(	O
ostr	pointer
,	O
flt	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
flt	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
status	int
=	O
mu_stream_write	function
(	O
ostr	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_append_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
int	O
status	int
=	O
0	int
;	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mu_off_t	long
size	pointer
;	O
if	O
(	O
msg	pointer
==	O
NULL	O
||	O
mud	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_append_message (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
&&	O
(	O
status	int
=	O
mu_locker_lock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_append_message: %s"	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_seek	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_END	int
,	O
&	O
size	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
append_message_to_stream	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
msg	pointer
,	O
mud	pointer
,	O
0	int
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
)	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
int	O
rc	int
=	O
mu_stream_truncate	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
size	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"cannot truncate stream after failed append: %s"	pointer
)	O
,	O
mu_stream_strerror	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
rc	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
if	O
(	O
mailbox	pointer
->	O
observable	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
mu_asprintf	function
(	O
&	O
buf	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
size	pointer
)	O
;	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_MESSAGE_APPEND	int
,	O
buf	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
mbox_reset	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
i	long
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mud	pointer
->	O
messages_count	long
;	O
i	long
++	O
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
i	long
]	O
;	O
mu_message_destroy	function
(	O
&	O
mum	pointer
->	O
message	pointer
,	O
mum	pointer
)	O
;	O
memset	function
(	O
mum	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
mum	pointer
)	O
)	O
;	O
mum	pointer
->	O
envel_from	long
=	O
mum	pointer
->	O
envel_from_end	long
=	O
0	int
;	O
mum	pointer
->	O
body	pointer
=	O
mum	pointer
->	O
body_end	long
=	O
0	int
;	O
mum	pointer
->	O
header_lines	long
=	O
mum	pointer
->	O
body_lines	long
=	O
0	int
;	O
}	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
mbox_expunge_unlocked	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
dirty	long
,	O
int	O
remove_deleted	int
,	O
mu_stream_t	pointer
tempstr	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
status	int
;	O
size_t	long
i	long
;	O
size_t	long
save_imapbase	long
=	O
0	int
;	O
mu_off_t	long
start_off	long
;	O
mu_off_t	long
size	pointer
;	O
size_t	long
expcount	long
=	O
0	int
;	O
start_off	long
=	O
mud	pointer
->	O
umessages	pointer
[	O
dirty	long
]	O
->	O
envel_from	long
;	O
for	O
(	O
i	long
=	O
dirty	long
;	O
i	long
<	O
mud	pointer
->	O
messages_count	long
;	O
i	long
++	O
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
i	long
]	O
;	O
if	O
(	O
remove_deleted	int
&&	O
ATTRIBUTE_IS_DELETED	O
(	O
mum	pointer
->	O
attr_flags	int
)	O
)	O
{	O
size_t	long
expevt	array
[	O
2	int
]	O
=	O
{	O
i	long
+	O
1	int
,	O
expcount	long
}	O
;	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_MESSAGE_EXPUNGE	int
,	O
expevt	array
)	O
;	O
expcount	long
++	O
;	O
mu_message_destroy	function
(	O
&	O
mum	pointer
->	O
message	pointer
,	O
mum	pointer
)	O
;	O
if	O
(	O
i	long
==	O
save_imapbase	long
)	O
{	O
save_imapbase	long
=	O
i	long
+	O
1	int
;	O
if	O
(	O
save_imapbase	long
<	O
mud	pointer
->	O
messages_count	long
)	O
mud	pointer
->	O
umessages	pointer
[	O
save_imapbase	long
]	O
->	O
attr_flags	int
|=	O
MU_ATTRIBUTE_MODIFIED	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
(	O
mum	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_MODIFIED	int
)	O
||	O
(	O
mum	pointer
->	O
message	pointer
&&	O
mu_message_is_modified	function
(	O
mum	pointer
->	O
message	pointer
)	O
)	O
)	O
{	O
int	O
flags	int
=	O
MBOX_EXPUNGE	int
|	O
(	O
(	O
i	long
==	O
save_imapbase	long
)	O
?	O
MBOX_FIRSTMSG	int
:	O
0	int
)	O
;	O
if	O
(	O
mum	pointer
->	O
message	pointer
==	O
0	int
)	O
{	O
mu_message_t	pointer
msg	pointer
;	O
status	int
=	O
mbox_get_message	function
(	O
mailbox	pointer
,	O
i	long
+	O
1	int
,	O
&	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: error expunging: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
}	O
status	int
=	O
append_message_to_stream	function
(	O
tempstr	pointer
,	O
mum	pointer
->	O
message	pointer
,	O
mud	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: error expunging: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
mum	pointer
->	O
attr_flags	int
&=	O
~	O
MU_ATTRIBUTE_MODIFIED	int
;	O
mu_message_clear_modified	function
(	O
mum	pointer
->	O
message	pointer
)	O
;	O
}	O
else	O
{	O
status	int
=	O
mu_stream_seek	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
mum	pointer
->	O
envel_from	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: seek error: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_stream_strerror	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_copy	function
(	O
tempstr	pointer
,	O
mailbox	pointer
->	O
stream	pointer
,	O
mum	pointer
->	O
body_end	long
-	O
mum	pointer
->	O
envel_from	long
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: error copying: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
}	O
}	O
if	O
(	O
mu_stream_size	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
&	O
size	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
size	pointer
>	O
mud	pointer
->	O
size	pointer
)	O
{	O
mu_off_t	long
len	long
=	O
size	pointer
-	O
mud	pointer
->	O
size	pointer
;	O
status	int
=	O
mu_stream_seek	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
mud	pointer
->	O
size	pointer
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: seek error: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_stream_strerror	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_copy	function
(	O
tempstr	pointer
,	O
mailbox	pointer
->	O
stream	pointer
,	O
len	long
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: error writing to temporary stream: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
}	O
else	O
if	O
(	O
size	pointer
<	O
mud	pointer
->	O
size	pointer
)	O
{	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_CORRUPT	int
,	O
mailbox	pointer
)	O
;	O
mu_error	function
(	O
_	O
(	O
"%s:%d: mailbox shrunk while expunging"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
}	O
status	int
=	O
mu_stream_seek	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
start_off	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: seek error: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_stream_strerror	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_size	function
(	O
tempstr	pointer
,	O
&	O
size	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: cannot get size of the temp stream: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_stream_strerror	function
(	O
tempstr	pointer
,	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_seek	function
(	O
tempstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: seek error: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_stream_strerror	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_copy	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
tempstr	pointer
,	O
size	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: copying from the temporary stream: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
mu_stream_truncate	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
start_off	long
+	O
size	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: error truncating stream: %s"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_expunge0	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
int	O
remove_deleted	int
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
dirty	long
;	O
int	O
status	int
;	O
mu_stream_t	pointer
tempstr	pointer
;	O
if	O
(	O
mud	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_expunge (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
{	O
int	O
status	int
;	O
if	O
(	O
(	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_APPEND	int
)	O
&&	O
!	O
(	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_READ	int
)	O
)	O
return	O
mu_stream_flush	function
(	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
status	int
=	O
mbox_scan0	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
mud	pointer
->	O
messages_count	long
==	O
0	int
)	O
return	O
0	int
;	O
}	O
for	O
(	O
dirty	long
=	O
0	int
;	O
dirty	long
<	O
mud	pointer
->	O
messages_count	long
;	O
dirty	long
++	O
)	O
{	O
mbox_message_t	pointer
mum	pointer
=	O
mud	pointer
->	O
umessages	pointer
[	O
dirty	long
]	O
;	O
if	O
(	O
(	O
mum	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_MODIFIED	int
)	O
||	O
(	O
mum	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_DELETED	int
)	O
||	O
(	O
mum	pointer
->	O
message	pointer
&&	O
mu_message_is_modified	function
(	O
mum	pointer
->	O
message	pointer
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
dirty	long
==	O
mud	pointer
->	O
messages_count	long
)	O
return	O
0	int
;	O
if	O
(	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_APPEND	int
)	O
return	O
mu_stream_flush	function
(	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
&&	O
(	O
status	int
=	O
mu_locker_lock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_temp_file_stream_create	function
(	O
&	O
tempstr	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
sigset_t	struct
signalset	struct
;	O
int	O
state	pointer
;	O
pthread_setcancelstate	function
(	O
PTHREAD_CANCEL_DISABLE	int
,	O
&	O
state	pointer
)	O
;	O
sigemptyset	function
(	O
&	O
signalset	struct
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGTERM	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGHUP	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGTSTP	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGWINCH	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
signalset	struct
,	O
0	int
)	O
;	O
status	int
=	O
mbox_expunge_unlocked	function
(	O
mailbox	pointer
,	O
dirty	long
,	O
remove_deleted	int
,	O
tempstr	pointer
)	O
;	O
pthread_setcancelstate	function
(	O
state	pointer
,	O
&	O
state	pointer
)	O
;	O
sigprocmask	function
(	O
SIG_UNBLOCK	int
,	O
&	O
signalset	struct
,	O
0	int
)	O
;	O
mu_stream_destroy	function
(	O
&	O
tempstr	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
mbox_reset	function
(	O
mailbox	pointer
)	O
;	O
}	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
)	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
mbox_get_atime	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
time_t	long
*	O
return_time	pointer
)	O
{	O
mbox_data_t	pointer
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
mud	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
stat	struct
(	O
mud	pointer
->	O
name	pointer
,	O
&	O
st	pointer
)	O
)	O
return	O
errno	O
;	O
*	O
return_time	pointer
=	O
st	pointer
.	O
st_atime	O
;	O
return	O
0	int
;	O
}	O
int	O
_mailbox_mbox_init	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
int	O
status	int
;	O
mbox_data_t	pointer
mud	pointer
;	O
if	O
(	O
mailbox	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mud	pointer
=	O
mailbox	pointer
->	O
data	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
mud	pointer
)	O
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
data	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
mud	pointer
->	O
mailbox	pointer
=	O
mailbox	pointer
;	O
status	int
=	O
mu_url_aget_path	function
(	O
mailbox	pointer
->	O
url	pointer
,	O
&	O
mud	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
mud	pointer
)	O
;	O
mailbox	pointer
->	O
data	pointer
=	O
NULL	O
;	O
return	O
status	int
;	O
}	O
mailbox	pointer
->	O
_destroy	pointer
=	O
mbox_destroy	function
;	O
mailbox	pointer
->	O
_open	pointer
=	O
mbox_open	function
;	O
mailbox	pointer
->	O
_close	pointer
=	O
mbox_close	function
;	O
mailbox	pointer
->	O
_remove	pointer
=	O
mbox_remove	function
;	O
mailbox	pointer
->	O
_get_message	pointer
=	O
mbox_get_message	function
;	O
mailbox	pointer
->	O
_append_message	pointer
=	O
mbox_append_message	function
;	O
mailbox	pointer
->	O
_messages_count	pointer
=	O
mbox_messages_count	function
;	O
mailbox	pointer
->	O
_messages_recent	pointer
=	O
mbox_messages_recent	function
;	O
mailbox	pointer
->	O
_message_unseen	pointer
=	O
mbox_message_unseen	function
;	O
mailbox	pointer
->	O
_expunge	pointer
=	O
mbox_expunge	function
;	O
mailbox	pointer
->	O
_sync	pointer
=	O
mbox_sync	function
;	O
mailbox	pointer
->	O
_uidvalidity	pointer
=	O
mbox_uidvalidity	function
;	O
mailbox	pointer
->	O
_uidnext	pointer
=	O
mbox_uidnext	function
;	O
mailbox	pointer
->	O
_quick_get_message	pointer
=	O
mbox_quick_get_message	function
;	O
mailbox	pointer
->	O
_scan	pointer
=	O
mbox_scan	function
;	O
mailbox	pointer
->	O
_is_updated	pointer
=	O
mbox_is_updated	function
;	O
mailbox	pointer
->	O
_get_size	pointer
=	O
mbox_get_size	function
;	O
mailbox	pointer
->	O
_get_atime	pointer
=	O
mbox_get_atime	function
;	O
{	O
mu_property_t	pointer
property	pointer
=	O
NULL	O
;	O
mu_mailbox_get_property	function
(	O
mailbox	pointer
,	O
&	O
property	pointer
)	O
;	O
mu_property_set_value	function
(	O
property	pointer
,	O
"TYPE"	pointer
,	O
"MBOX"	pointer
,	O
1	int
)	O
;	O
}	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"mbox_init (%s)"	pointer
,	O
mud	pointer
->	O
name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O