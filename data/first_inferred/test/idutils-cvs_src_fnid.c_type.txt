void	O
scan_files	function
(	O
struct	O
idhead	struct
*	O
idhp	*
)	O
;	O
void	O
scan_member_file	function
(	O
struct	O
member_file	struct
const	O
*	O
member	*
)	O
;	O
void	O
usage	function
(	O
void	O
)	O
;	O
char	O
const	O
*	O
program_name	*
;	O
int	O
show_version	int
=	O
0	int
;	O
int	O
show_help	int
=	O
0	int
;	O
struct	O
idhead	struct
idh	struct
;	O
struct	O
file_link	struct
*	O
cw_dlink	*
;	O
int	O
no_id_flag	int
=	O
1	int
;	O
enum	O
separator_style	enum
separator_style	enum
=	O
ss_contextual	int
;	O
void	O
usage	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	*
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	*
)	O
,	O
program_name	*
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"file"	*
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"separator"	*
,	O
required_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"help"	*
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"version"	*
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [PATTERN]...\n"	*
)	O
,	O
program_name	*
)	O
;	O
printf	function
(	O
_	O
(	O
"Print constituent file names that match PATTERN,\nusing shell-style wildcards.\n  -f, --file=FILE        file name of ID database\n  -S, --separator=STYLE  STYLE is one of `braces', `space' or `newline'\n      --help             display this help and exit\n      --version          output version information and exit\n"	*
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nReport bugs to "	*
PACKAGE_BUGREPORT	*
"\n\n"	*
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*
)	O
{	O
program_name	*
=	O
argv	*
[	O
0	int
]	O
;	O
idh	struct
.	O
idh_file_name	int
=	O
0	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	*
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	*
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	*
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	*
,	O
"f:S:"	*
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'f'	O
:	O
idh	struct
.	O
idh_file_name	*
=	O
optarg	*
;	O
break	O
;	O
case	O
'S'	O
:	O
separator_style	*
=	O
parse_separator_style	function
(	O
optarg	*
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
show_version	int
)	O
{	O
printf	function
(	O
"%s - %s\n"	*
,	O
program_name	*
,	O
PACKAGE_VERSION	*
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
help_me	function
(	O
)	O
;	O
if	O
(	O
separator_style	enum
==	O
ss_contextual	int
)	O
{	O
if	O
(	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
)	O
separator_style	double
=	O
DEFAULT_SEPARATOR_STYLE	int
;	O
else	O
separator_style	enum
=	O
ss_newline	int
;	O
}	O
argc	int
-=	O
optind	int
;	O
argv	*
+=	O
optind	int
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
static	O
char	O
star	array
[	O
]	O
=	O
"*"	*
;	O
static	O
char	O
*	O
starp	*
=	O
star	char
;	O
argc	int
=	O
1	int
;	O
argv	*
=	O
&	O
starp	struct
;	O
}	O
idh	struct
.	O
idh_file_name	int
=	O
locate_id_file_name	function
(	O
idh	struct
.	O
idh_file_name	*
)	O
;	O
if	O
(	O
idh	struct
.	O
idh_file_name	int
==	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't locate `ID'"	*
)	O
)	O
;	O
init_idh_obstacks	function
(	O
&	O
idh	struct
)	O
;	O
init_idh_tables	function
(	O
&	O
idh	struct
)	O
;	O
cw_dlink	*
=	O
get_current_dir_link	function
(	O
)	O
;	O
{	O
struct	O
file_link	struct
*	O
*	O
members	*
=	O
read_id_file	function
(	O
idh	struct
.	O
idh_file_name	*
,	O
&	O
idh	struct
)	O
;	O
struct	O
file_link	struct
*	O
*	O
members_N	*
=	O
&	O
members	*
[	O
idh	struct
.	O
idh_files	int
]	O
;	O
struct	O
file_link	struct
*	O
*	O
flinkv_0	*
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
file_link	struct
*	O
)	O
*	O
(	O
idh	struct
.	O
idh_files	long
+	O
1	int
)	O
)	O
;	O
struct	O
file_link	struct
*	O
*	O
flinkv	*
=	O
flinkv_0	*
;	O
char	O
*	O
*	O
patv_0	*
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
*	O
2	int
)	O
)	O
;	O
char	O
*	O
*	O
patv_N	*
;	O
char	O
*	O
*	O
patv	*
=	O
patv_0	*
;	O
char	O
*	O
file_name	*
=	O
alloca	function
(	O
PATH_MAX	int
)	O
;	O
for	O
(	O
;	O
argc	int
;	O
argc	int
--	O
,	O
argv	*
++	O
)	O
{	O
char	O
*	O
arg	*
=	O
*	O
argv	*
;	O
*	O
patv	*
++	O
=	O
arg	*
;	O
if	O
(	O
*	O
arg	*
!=	O
'*'	O
&&	O
*	O
arg	*
!=	O
'/'	O
)	O
{	O
char	O
*	O
pat	*
=	O
xmalloc	function
(	O
strlen	function
(	O
arg	*
)	O
+	O
2	int
)	O
;	O
sprintf	function
(	O
pat	*
,	O
"*/%s"	*
,	O
arg	*
)	O
;	O
*	O
patv	*
++	O
=	O
pat	*
;	O
}	O
}	O
patv_N	enum
=	O
patv	int
;	O
for	O
(	O
;	O
members	*
<	O
members_N	*
;	O
members	*
++	O
)	O
{	O
maybe_relative_file_name	function
(	O
file_name	*
,	O
*	O
members	*
,	O
cw_dlink	*
)	O
;	O
for	O
(	O
patv	*
=	O
patv_0	*
;	O
patv	int
<	O
patv_N	int
;	O
patv	int
++	O
)	O
{	O
if	O
(	O
fnmatch	function
(	O
*	O
patv	*
,	O
file_name	*
,	O
MAYBE_FNM_CASEFOLD	*
)	O
==	O
0	int
)	O
{	O
*	O
flinkv	*
++	O
=	O
*	O
members	*
;	O
break	O
;	O
}	O
}	O
}	O
*	O
flinkv	*
=	O
0	int
;	O
print_filenames	function
(	O
flinkv_0	*
,	O
separator_style	enum
)	O
;	O
}	O
return	O
0	int
;	O
}	O