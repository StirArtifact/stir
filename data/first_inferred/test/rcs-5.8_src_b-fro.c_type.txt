struct	O
fro	struct
*	O
fro_open	function
(	O
char	O
const	O
*	O
name	pointer
,	O
char	O
const	O
*	O
type	enum
,	O
struct	O
stat	struct
*	O
status	int
)	O
{	O
struct	O
fro	struct
*	O
f	pointer
;	O
FILE	struct
*	O
stream	pointer
;	O
struct	O
stat	struct
st	struct
;	O
off_t	long
s	pointer
;	O
int	O
fd	int
=	O
fd_safer	function
(	O
open	pointer
(	O
name	pointer
,	O
O_RDONLY	int
)	O
)	O
;	O
if	O
(	O
PROB	O
(	O
fd	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
status	int
)	O
status	int
=	O
&	O
st	struct
;	O
if	O
(	O
PROB	O
(	O
fstat	function
(	O
fd	int
,	O
status	int
)	O
)	O
)	O
fatal_sys	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
status	int
->	O
st_mode	int
)	O
)	O
{	O
PERR	O
(	O
"`%s' is not a regular file"	pointer
,	O
name	pointer
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
NULL	O
;	O
}	O
s	pointer
=	O
status	int
->	O
st_size	long
;	O
f	pointer
=	O
FZLLOC	O
(	O
struct	O
fro	struct
)	O
;	O
f	pointer
->	O
end	pointer
=	O
s	pointer
;	O
f	pointer
->	O
rm	enum
=	O
status	int
->	O
st_size	long
<	O
1024	int
*	O
BE	O
(	O
mem_limit	long
)	O
?	O
(	O
MMAP_SIGNAL	int
&&	O
status	int
->	O
st_size	long
?	O
RM_MMAP	int
:	O
RM_MEM	int
)	O
:	O
RM_STDIO	int
;	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
if	O
(	O
!	O
s	pointer
)	O
f	pointer
->	O
base	pointer
=	O
NULL	O
;	O
else	O
{	O
ssize_t	long
r	pointer
;	O
char	O
*	O
bufptr	pointer
;	O
size_t	long
bufsiz	long
=	O
s	pointer
;	O
f	pointer
->	O
base	pointer
=	O
alloc	function
(	O
SINGLE	O
,	O
name	pointer
,	O
s	pointer
)	O
;	O
bufptr	pointer
=	O
f	pointer
->	O
base	pointer
;	O
do	O
{	O
if	O
(	O
PROB	O
(	O
r	pointer
=	O
read	pointer
(	O
fd	int
,	O
bufptr	pointer
,	O
bufsiz	long
)	O
)	O
)	O
fatal_sys	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
r	pointer
)	O
{	O
status	int
->	O
st_size	long
=	O
s	pointer
-=	O
bufsiz	long
;	O
bufsiz	long
=	O
0	int
;	O
}	O
else	O
{	O
bufptr	pointer
+=	O
r	pointer
;	O
bufsiz	long
-=	O
r	pointer
;	O
}	O
}	O
while	O
(	O
bufsiz	long
)	O
;	O
if	O
(	O
PROB	O
(	O
lseek	function
(	O
fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
)	O
)	O
fatal_sys	function
(	O
name	pointer
)	O
;	O
}	O
f	pointer
->	O
ptr	pointer
=	O
f	pointer
->	O
base	pointer
;	O
f	pointer
->	O
lim	pointer
=	O
f	pointer
->	O
base	pointer
+	O
s	pointer
;	O
break	O
;	O
case	O
RM_STDIO	int
:	O
if	O
(	O
!	O
(	O
stream	pointer
=	O
fdopen	function
(	O
fd	int
,	O
type	enum
)	O
)	O
)	O
fatal_sys	function
(	O
name	pointer
)	O
;	O
f	pointer
->	O
stream	pointer
=	O
stream	pointer
;	O
break	O
;	O
}	O
f	pointer
->	O
fd	int
=	O
fd	int
;	O
return	O
f	pointer
;	O
}	O
void	O
fro_close	function
(	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
int	O
res	pointer
=	O
-	O
1	int
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
;	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
if	O
(	O
f	pointer
->	O
deallocate	pointer
)	O
(	O
*	O
f	pointer
->	O
deallocate	pointer
)	O
(	O
f	pointer
)	O
;	O
f	pointer
->	O
base	pointer
=	O
NULL	O
;	O
res	pointer
=	O
close	pointer
(	O
f	pointer
->	O
fd	int
)	O
;	O
break	O
;	O
case	O
RM_STDIO	int
:	O
res	pointer
=	O
fclose	function
(	O
f	pointer
->	O
stream	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
res	pointer
)	O
Ierror	function
(	O
)	O
;	O
f	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
}	O
void	O
fro_zclose	function
(	O
struct	O
fro	struct
*	O
*	O
p	pointer
)	O
{	O
fro_close	function
(	O
*	O
p	pointer
)	O
;	O
*	O
p	pointer
=	O
NULL	O
;	O
}	O
off_t	long
fro_tello	function
(	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
off_t	long
rv	long
=	O
0	int
;	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
rv	long
=	O
f	pointer
->	O
ptr	pointer
-	O
f	pointer
->	O
base	pointer
;	O
break	O
;	O
case	O
RM_STDIO	int
:	O
rv	long
=	O
ftello	function
(	O
f	pointer
->	O
stream	pointer
)	O
;	O
break	O
;	O
}	O
return	O
rv	long
;	O
}	O
void	O
fro_move	function
(	O
struct	O
fro	struct
*	O
f	pointer
,	O
off_t	long
change	long
)	O
{	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
f	pointer
->	O
ptr	pointer
=	O
change	long
+	O
(	O
0	int
>	O
change	long
?	O
f	pointer
->	O
ptr	pointer
:	O
f	pointer
->	O
base	pointer
)	O
;	O
break	O
;	O
case	O
RM_STDIO	int
:	O
if	O
(	O
PROB	O
(	O
fseeko	function
(	O
f	pointer
->	O
stream	pointer
,	O
change	long
,	O
0	int
>	O
change	long
?	O
SEEK_CUR	int
:	O
SEEK_SET	int
)	O
)	O
)	O
Ierror	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
bool	bool
fro_try_getbyte	function
(	O
int	O
*	O
c	int
,	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
GETBYTE_BODY	O
(	O
)	O
;	O
return	O
false	int
;	O
}	O
void	O
fro_must_getbyte	function
(	O
int	O
*	O
c	int
,	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
GETBYTE_BODY	O
(	O
)	O
;	O
}	O
void	O
fro_trundling	function
(	O
bool	bool
sequentialp	bool
USED_IF_HAVE_MADVISE	O
,	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
break	O
;	O
case	O
RM_MEM	int
:	O
case	O
RM_STDIO	int
:	O
break	O
;	O
}	O
}	O
void	O
fro_spew_partial	function
(	O
FILE	struct
*	O
to	pointer
,	O
struct	O
fro	struct
*	O
f	pointer
,	O
struct	O
range	struct
*	O
r	pointer
)	O
{	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
awrite	function
(	O
f	pointer
->	O
base	pointer
+	O
r	pointer
->	O
beg	pointer
,	O
r	pointer
->	O
end	pointer
-	O
r	pointer
->	O
beg	pointer
,	O
to	pointer
)	O
;	O
if	O
(	O
f	pointer
->	O
end	pointer
==	O
r	pointer
->	O
end	pointer
)	O
f	pointer
->	O
ptr	pointer
=	O
f	pointer
->	O
lim	pointer
;	O
break	O
;	O
case	O
RM_STDIO	int
:	O
{	O
char	O
buf	pointer
[	O
MEMBUFSIZ	O
]	O
;	O
size_t	long
count	long
;	O
off_t	long
pos	long
=	O
r	pointer
->	O
beg	pointer
;	O
fseeko	function
(	O
f	pointer
->	O
stream	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
pos	long
<	O
r	pointer
->	O
end	pointer
)	O
{	O
if	O
(	O
!	O
(	O
count	long
=	O
fread	function
(	O
buf	pointer
,	O
sizeof	O
(	O
*	O
buf	pointer
)	O
,	O
(	O
pos	long
<	O
r	pointer
->	O
end	pointer
-	O
MEMBUFSIZ	O
?	O
MEMBUFSIZ	O
:	O
r	pointer
->	O
end	pointer
-	O
pos	long
)	O
,	O
f	pointer
->	O
stream	pointer
)	O
)	O
)	O
{	O
testIerror	function
(	O
f	pointer
->	O
stream	pointer
)	O
;	O
return	O
;	O
}	O
awrite	function
(	O
buf	pointer
,	O
count	long
,	O
to	pointer
)	O
;	O
pos	long
+=	O
count	long
;	O
}	O
}	O
break	O
;	O
}	O
}	O
void	O
fro_spew	function
(	O
struct	O
fro	struct
*	O
f	pointer
,	O
FILE	struct
*	O
to	pointer
)	O
{	O
struct	O
range	struct
finish	struct
=	O
{	O
.	O
beg	pointer
=	O
f	pointer
->	O
verbatim	long
,	O
.	O
end	pointer
=	O
f	pointer
->	O
end	pointer
}	O
;	O
fro_spew_partial	function
(	O
to	pointer
,	O
f	pointer
,	O
&	O
finish	struct
)	O
;	O
f	pointer
->	O
verbatim	long
=	O
f	pointer
->	O
end	pointer
;	O
}	O
struct	O
cbuf	struct
string_from_atat	function
(	O
struct	O
divvy	struct
*	O
space	pointer
,	O
struct	O
atat	pointer
const	O
*	O
atat	pointer
)	O
{	O
struct	O
fro	struct
*	O
f	pointer
=	O
atat	pointer
->	O
from	pointer
;	O
size_t	long
count	long
=	O
atat	pointer
->	O
count	long
;	O
struct	O
range	struct
r	pointer
[	O
count	long
]	O
;	O
struct	O
cbuf	struct
cb	pointer
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
r	pointer
[	O
i	int
]	O
.	O
beg	pointer
=	O
1	int
+	O
(	O
i	int
?	O
atat	pointer
->	O
holes	array
[	O
i	int
-	O
1	int
]	O
:	O
atat	pointer
->	O
beg	pointer
)	O
;	O
r	pointer
[	O
i	int
]	O
.	O
end	pointer
=	O
atat	pointer
->	O
holes	array
[	O
i	int
]	O
;	O
}	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
char	O
const	O
*	O
beg	pointer
=	O
f	pointer
->	O
base	pointer
+	O
r	pointer
[	O
i	int
]	O
.	O
beg	pointer
;	O
off_t	long
len	char
=	O
r	pointer
[	O
i	int
]	O
.	O
end	pointer
-	O
r	pointer
[	O
i	int
]	O
.	O
beg	pointer
;	O
while	O
(	O
SSIZE_MAX	O
<	O
len	char
)	O
{	O
accumulate_range	function
(	O
space	pointer
,	O
beg	pointer
,	O
beg	pointer
+	O
SSIZE_MAX	O
)	O
;	O
len	char
-=	O
SSIZE_MAX	O
;	O
beg	pointer
+=	O
SSIZE_MAX	O
;	O
}	O
accumulate_range	function
(	O
space	pointer
,	O
beg	pointer
,	O
beg	pointer
+	O
len	char
)	O
;	O
}	O
break	O
;	O
case	O
RM_STDIO	int
:	O
{	O
FILE	struct
*	O
stream	pointer
=	O
f	pointer
->	O
stream	pointer
;	O
off_t	long
was	long
=	O
ftello	function
(	O
stream	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
off_t	long
pos	long
=	O
r	pointer
[	O
i	int
]	O
.	O
beg	pointer
;	O
fseeko	function
(	O
stream	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
pos	long
++	O
<	O
r	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
accumulate_byte	function
(	O
space	pointer
,	O
getc	function
(	O
f	pointer
->	O
stream	pointer
)	O
)	O
;	O
}	O
fseeko	function
(	O
stream	pointer
,	O
was	long
,	O
SEEK_SET	int
)	O
;	O
}	O
break	O
;	O
}	O
cb	pointer
.	O
string	pointer
=	O
finish_string	function
(	O
space	pointer
,	O
&	O
cb	pointer
.	O
size	long
)	O
;	O
return	O
cb	pointer
;	O
}	O
void	O
atat_put	function
(	O
FILE	struct
*	O
to	pointer
,	O
struct	O
atat	pointer
const	O
*	O
atat	pointer
)	O
{	O
struct	O
range	struct
range	struct
=	O
{	O
.	O
beg	pointer
=	O
atat	pointer
->	O
beg	pointer
,	O
.	O
end	pointer
=	O
ATAT_TEXT_END	O
(	O
atat	pointer
)	O
}	O
;	O
fro_spew_partial	function
(	O
to	pointer
,	O
atat	pointer
->	O
from	pointer
,	O
&	O
range	struct
)	O
;	O
}	O
void	O
atat_display	function
(	O
FILE	struct
*	O
to	pointer
,	O
struct	O
atat	pointer
const	O
*	O
atat	pointer
,	O
bool	bool
ensure_newline_p	bool
)	O
{	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
atat	pointer
->	O
count	long
;	O
i	int
++	O
)	O
{	O
struct	O
range	struct
range	struct
=	O
{	O
.	O
beg	pointer
=	O
1	int
+	O
(	O
i	int
?	O
atat	pointer
->	O
holes	array
[	O
i	int
-	O
1	int
]	O
:	O
atat	pointer
->	O
beg	pointer
)	O
,	O
.	O
end	pointer
=	O
atat	pointer
->	O
holes	array
[	O
i	int
]	O
}	O
;	O
fro_spew_partial	function
(	O
to	pointer
,	O
atat	pointer
->	O
from	pointer
,	O
&	O
range	struct
)	O
;	O
}	O
if	O
(	O
!	O
ensure_newline_p	bool
||	O
(	O
1	int
==	O
atat	pointer
->	O
count	long
&&	O
atat	pointer
->	O
beg	pointer
+	O
1	int
==	O
atat	pointer
->	O
holes	array
[	O
0	int
]	O
)	O
)	O
return	O
;	O
{	O
struct	O
fro	struct
*	O
f	pointer
=	O
atat	pointer
->	O
from	pointer
;	O
off_t	long
pos	long
=	O
atat	pointer
->	O
holes	array
[	O
atat	pointer
->	O
count	long
-	O
1	int
]	O
-	O
1	int
;	O
char	O
lc	char
=	O
'\0'	O
;	O
switch	O
(	O
f	pointer
->	O
rm	enum
)	O
{	O
case	O
RM_MMAP	int
:	O
case	O
RM_MEM	int
:	O
lc	char
=	O
f	pointer
->	O
base	pointer
[	O
pos	long
]	O
;	O
break	O
;	O
case	O
RM_STDIO	int
:	O
{	O
FILE	struct
*	O
stream	pointer
=	O
f	pointer
->	O
stream	pointer
;	O
off_t	long
was	long
=	O
ftello	function
(	O
stream	pointer
)	O
;	O
fseeko	function
(	O
stream	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
;	O
lc	char
=	O
fgetc	function
(	O
stream	pointer
)	O
;	O
fseeko	function
(	O
stream	pointer
,	O
was	long
,	O
SEEK_SET	int
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
'\n'	O
!=	O
lc	char
)	O
aputc	O
(	O
'\n'	O
,	O
to	pointer
)	O
;	O
}	O
}	O