static	O
unsigned	O
char	O
subbuffer	array
[	O
SUBBUFSIZE	int
]	O
,	O
*	O
subpointer	pointer
,	O
*	O
subend	pointer
;	O
char	O
options	array
[	O
256	int
]	O
;	O
char	O
do_dont_resp	array
[	O
256	int
]	O
;	O
char	O
will_wont_resp	array
[	O
256	int
]	O
;	O
int	O
eight	int
=	O
0	int
,	O
autologin	int
=	O
0	int
,	O
skiprc	int
=	O
0	int
,	O
connected	int
,	O
showoptions	int
,	O
In3270	int
,	O
ISend	int
,	O
debug	int
=	O
0	int
,	O
crmod	int
,	O
netdata	int
,	O
crlf	int
,	O
telnetport	int
,	O
SYNCHing	int
,	O
flushout	int
,	O
autoflush	int
=	O
0	int
,	O
autosynch	int
,	O
localflow	int
,	O
restartany	int
,	O
localchars	int
,	O
donelclchars	int
,	O
donebinarytoggle	int
,	O
dontlecho	int
,	O
globalmode	int
;	O
char	O
*	O
prompt	pointer
=	O
0	int
;	O
cc_t	char
escape	char
;	O
cc_t	char
rlogin	char
;	O
cc_t	char
echoc	char
;	O
static	O
int	O
telrcv_state	int
;	O
jmp_buf	array
toplevel	array
;	O
jmp_buf	array
peerdied	array
;	O
int	O
flushline	int
;	O
int	O
linemode	int
;	O
int	O
kludgelinemode	int
=	O
1	int
;	O
Clocks	struct
clocks	struct
;	O
void	O
init_telnet	function
(	O
void	O
)	O
{	O
env_init	function
(	O
)	O
;	O
SB_CLEAR	O
(	O
)	O
;	O
ClearArray	O
(	O
options	array
)	O
;	O
connected	int
=	O
In3270	int
=	O
ISend	int
=	O
localflow	int
=	O
donebinarytoggle	int
=	O
0	int
;	O
restartany	int
=	O
-	O
1	int
;	O
SYNCHing	int
=	O
0	int
;	O
escape	char
=	O
CONTROL	O
(	O
']'	O
)	O
;	O
rlogin	char
=	O
_POSIX_VDISABLE	char
;	O
echoc	char
=	O
CONTROL	O
(	O
'E'	O
)	O
;	O
flushline	int
=	O
1	int
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
}	O
void	O
send_do	function
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
do_dont_resp	array
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_do	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_do	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_do	O
(	O
c	int
)	O
;	O
do_dont_resp	array
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
DO	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
DO	int
,	O
c	int
)	O
;	O
}	O
void	O
send_dont	function
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
do_dont_resp	array
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_dont	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_dont	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_dont	O
(	O
c	int
)	O
;	O
do_dont_resp	array
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
DONT	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
DONT	int
,	O
c	int
)	O
;	O
}	O
void	O
send_will	function
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
will_wont_resp	array
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_will	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_will	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_will	O
(	O
c	int
)	O
;	O
will_wont_resp	array
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
WILL	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
WILL	int
,	O
c	int
)	O
;	O
}	O
void	O
send_wont	function
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
will_wont_resp	array
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_wont	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_wont	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_wont	O
(	O
c	int
)	O
;	O
will_wont_resp	array
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
WONT	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
WONT	int
,	O
c	int
)	O
;	O
}	O
void	O
willoption	function
(	O
int	O
option	int
)	O
{	O
int	O
new_state_ok	int
=	O
0	int
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
)	O
{	O
--	O
do_dont_resp	array
[	O
option	int
]	O
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
&&	O
my_state_is_do	O
(	O
option	int
)	O
)	O
--	O
do_dont_resp	array
[	O
option	int
]	O
;	O
}	O
if	O
(	O
(	O
do_dont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
my_want_state_is_dont	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
case	O
TELOPT_BINARY	int
:	O
case	O
TELOPT_SGA	int
:	O
settimer	O
(	O
modenegotiated	int
)	O
;	O
case	O
TELOPT_STATUS	int
:	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
flushout	int
)	O
flushout	int
=	O
0	int
;	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
set_my_state_dont	O
(	O
option	int
)	O
;	O
return	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
new_state_ok	int
)	O
{	O
set_my_want_state_do	O
(	O
option	int
)	O
;	O
send_do	function
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
do_dont_resp	array
[	O
option	int
]	O
++	O
;	O
send_dont	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
set_my_state_do	O
(	O
option	int
)	O
;	O
}	O
void	O
wontoption	function
(	O
int	O
option	int
)	O
{	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
)	O
{	O
--	O
do_dont_resp	array
[	O
option	int
]	O
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
&&	O
my_state_is_dont	O
(	O
option	int
)	O
)	O
--	O
do_dont_resp	array
[	O
option	int
]	O
;	O
}	O
if	O
(	O
(	O
do_dont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
my_want_state_is_do	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_SGA	int
:	O
if	O
(	O
!	O
kludgelinemode	int
)	O
break	O
;	O
case	O
TELOPT_ECHO	int
:	O
settimer	O
(	O
modenegotiated	int
)	O
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
flushout	int
)	O
flushout	int
=	O
0	int
;	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
set_my_state_dont	O
(	O
option	int
)	O
;	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
if	O
(	O
my_state_is_do	O
(	O
option	int
)	O
)	O
send_dont	function
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
option	int
==	O
TELOPT_TM	int
)	O
{	O
if	O
(	O
flushout	int
)	O
flushout	int
=	O
0	int
;	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
}	O
set_my_state_dont	O
(	O
option	int
)	O
;	O
}	O
static	O
void	O
dooption	function
(	O
int	O
option	int
)	O
{	O
int	O
new_state_ok	int
=	O
0	int
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
)	O
{	O
--	O
will_wont_resp	array
[	O
option	int
]	O
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
&&	O
my_state_is_will	O
(	O
option	int
)	O
)	O
--	O
will_wont_resp	array
[	O
option	int
]	O
;	O
}	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
my_want_state_is_wont	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_TM	int
:	O
send_will	function
(	O
option	int
,	O
0	int
)	O
;	O
set_my_want_state_wont	O
(	O
TELOPT_TM	int
)	O
;	O
set_my_state_wont	O
(	O
TELOPT_TM	int
)	O
;	O
return	O
;	O
case	O
TELOPT_BINARY	int
:	O
case	O
TELOPT_NAWS	int
:	O
case	O
TELOPT_TSPEED	int
:	O
case	O
TELOPT_LFLOW	int
:	O
case	O
TELOPT_TTYPE	int
:	O
case	O
TELOPT_SGA	int
:	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_XDISPLOC	int
:	O
if	O
(	O
env_getvalue	function
(	O
"DISPLAY"	pointer
)	O
)	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
kludgelinemode	int
=	O
0	int
;	O
send_do	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
set_my_want_state_will	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
send_will	function
(	O
option	int
,	O
0	int
)	O
;	O
set_my_state_will	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
slc_init	function
(	O
)	O
;	O
return	O
;	O
case	O
TELOPT_ECHO	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
new_state_ok	int
)	O
{	O
set_my_want_state_will	O
(	O
option	int
)	O
;	O
send_will	function
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
will_wont_resp	array
[	O
option	int
]	O
++	O
;	O
send_wont	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_LINEMODE	int
:	O
kludgelinemode	int
=	O
0	int
;	O
send_do	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
set_my_state_will	O
(	O
option	int
)	O
;	O
slc_init	function
(	O
)	O
;	O
send_do	function
(	O
TELOPT_SGA	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
set_my_state_will	O
(	O
option	int
)	O
;	O
}	O
static	O
void	O
dontoption	function
(	O
int	O
option	int
)	O
{	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
)	O
{	O
--	O
will_wont_resp	array
[	O
option	int
]	O
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
&&	O
my_state_is_wont	O
(	O
option	int
)	O
)	O
--	O
will_wont_resp	array
[	O
option	int
]	O
;	O
}	O
if	O
(	O
(	O
will_wont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
my_want_state_is_will	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_LINEMODE	int
:	O
linemode	int
=	O
0	int
;	O
break	O
;	O
}	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
if	O
(	O
my_state_is_will	O
(	O
option	int
)	O
)	O
send_wont	function
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
set_my_state_wont	O
(	O
option	int
)	O
;	O
}	O
int	O
is_unique	function
(	O
register	O
char	O
*	O
name	pointer
,	O
register	O
char	O
*	O
*	O
as	pointer
,	O
register	O
char	O
*	O
*	O
ae	pointer
)	O
{	O
register	O
char	O
*	O
*	O
ap	pointer
;	O
register	O
int	O
n	int
;	O
n	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
for	O
(	O
ap	pointer
=	O
as	pointer
;	O
ap	pointer
<	O
ae	pointer
;	O
ap	pointer
++	O
)	O
if	O
(	O
strncasecmp	function
(	O
*	O
ap	pointer
,	O
name	pointer
,	O
n	int
)	O
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
char	O
*	O
name_unknown	pointer
=	O
"UNKNOWN"	pointer
;	O
static	O
char	O
*	O
unknown	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
char	O
*	O
*	O
mklist	function
(	O
char	O
*	O
buf	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
register	O
int	O
n	int
;	O
register	O
char	O
c	int
,	O
*	O
cp	pointer
,	O
*	O
*	O
argvp	pointer
,	O
*	O
cp2	pointer
,	O
*	O
*	O
argv	pointer
,	O
*	O
*	O
avt	pointer
;	O
if	O
(	O
name	pointer
)	O
{	O
if	O
(	O
(	O
int	O
)	O
strlen	function
(	O
name	pointer
)	O
>	O
40	int
)	O
{	O
name	pointer
=	O
0	int
;	O
unknown	array
[	O
0	int
]	O
=	O
name_unknown	pointer
;	O
}	O
else	O
{	O
unknown	array
[	O
0	int
]	O
=	O
name	pointer
;	O
upcase	function
(	O
name	pointer
)	O
;	O
}	O
}	O
else	O
unknown	array
[	O
0	int
]	O
=	O
name_unknown	pointer
;	O
for	O
(	O
n	int
=	O
1	int
,	O
cp	pointer
=	O
buf	pointer
;	O
*	O
cp	pointer
&&	O
*	O
cp	pointer
!=	O
':'	O
;	O
cp	pointer
++	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'|'	O
)	O
n	int
++	O
;	O
}	O
argv	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
(	O
n	int
+	O
3	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
argv	pointer
==	O
0	int
)	O
return	O
(	O
unknown	array
)	O
;	O
*	O
argv	pointer
=	O
0	int
;	O
argvp	pointer
=	O
argv	pointer
+	O
1	int
;	O
n	int
=	O
0	int
;	O
for	O
(	O
cp	pointer
=	O
cp2	pointer
=	O
buf	pointer
;	O
(	O
c	int
=	O
*	O
cp	pointer
)	O
;	O
cp	pointer
++	O
)	O
{	O
if	O
(	O
c	int
==	O
'|'	O
||	O
c	int
==	O
':'	O
)	O
{	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
n	int
||	O
(	O
cp	pointer
-	O
cp2	pointer
>	O
41	int
)	O
)	O
;	O
else	O
if	O
(	O
name	pointer
&&	O
(	O
strncasecmp	function
(	O
name	pointer
,	O
cp2	pointer
,	O
cp	pointer
-	O
cp2	pointer
)	O
==	O
0	int
)	O
)	O
*	O
argv	pointer
=	O
cp2	pointer
;	O
else	O
if	O
(	O
is_unique	function
(	O
cp2	pointer
,	O
argv	pointer
+	O
1	int
,	O
argvp	pointer
)	O
)	O
*	O
argvp	pointer
++	O
=	O
cp2	pointer
;	O
if	O
(	O
c	int
==	O
':'	O
)	O
break	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
cp	pointer
)	O
==	O
'|'	O
)	O
cp	pointer
++	O
;	O
cp2	pointer
=	O
cp	pointer
;	O
n	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
c	int
==	O
' '	O
)	O
||	O
!	O
isascii	function
(	O
c	int
)	O
)	O
n	int
=	O
1	int
;	O
else	O
if	O
(	O
islower	function
(	O
c	int
)	O
)	O
*	O
cp	pointer
=	O
toupper	function
(	O
c	int
)	O
;	O
}	O
if	O
(	O
(	O
argv	pointer
[	O
1	int
]	O
==	O
buf	pointer
)	O
&&	O
(	O
strlen	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
==	O
2	int
)	O
)	O
{	O
--	O
argvp	pointer
;	O
for	O
(	O
avt	pointer
=	O
&	O
argv	pointer
[	O
1	int
]	O
;	O
avt	pointer
<	O
argvp	pointer
;	O
avt	pointer
++	O
)	O
*	O
avt	pointer
=	O
*	O
(	O
avt	pointer
+	O
1	int
)	O
;	O
*	O
argvp	pointer
++	O
=	O
buf	pointer
;	O
}	O
cp	pointer
=	O
*	O
(	O
argvp	pointer
-	O
1	int
)	O
;	O
*	O
argvp	pointer
++	O
=	O
cp	pointer
;	O
*	O
argvp	pointer
=	O
0	int
;	O
if	O
(	O
*	O
argv	pointer
==	O
0	int
)	O
{	O
if	O
(	O
name	pointer
)	O
*	O
argv	pointer
=	O
name	pointer
;	O
else	O
{	O
--	O
argvp	pointer
;	O
for	O
(	O
avt	pointer
=	O
argv	pointer
;	O
avt	pointer
<	O
argvp	pointer
;	O
avt	pointer
++	O
)	O
*	O
avt	pointer
=	O
*	O
(	O
avt	pointer
+	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
*	O
argv	pointer
)	O
return	O
(	O
argv	pointer
)	O
;	O
else	O
return	O
(	O
unknown	array
)	O
;	O
}	O
char	O
termbuf	array
[	O
1024	int
]	O
;	O
int	O
init_term	function
(	O
char	O
*	O
tname	pointer
,	O
int	O
fd	int
,	O
int	O
*	O
errp	pointer
)	O
{	O
int	O
err	long
=	O
-	O
1	int
;	O
err	long
=	O
tgetent	function
(	O
termbuf	array
,	O
tname	pointer
)	O
;	O
if	O
(	O
err	long
==	O
1	int
)	O
{	O
termbuf	array
[	O
1023	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
errp	pointer
)	O
*	O
errp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
errp	pointer
)	O
*	O
errp	pointer
=	O
0	int
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
resettermname	int
=	O
1	int
;	O
char	O
*	O
gettermname	function
(	O
void	O
)	O
{	O
char	O
*	O
tname	pointer
;	O
static	O
char	O
*	O
*	O
tnamep	pointer
=	O
0	int
;	O
static	O
char	O
*	O
*	O
next	pointer
;	O
int	O
err	long
;	O
if	O
(	O
resettermname	int
)	O
{	O
resettermname	int
=	O
0	int
;	O
if	O
(	O
tnamep	pointer
&&	O
tnamep	pointer
!=	O
unknown	array
)	O
free	function
(	O
tnamep	pointer
)	O
;	O
if	O
(	O
(	O
tname	pointer
=	O
(	O
char	O
*	O
)	O
env_getvalue	function
(	O
"TERM"	pointer
)	O
)	O
&&	O
(	O
init_term	function
(	O
tname	pointer
,	O
1	int
,	O
&	O
err	long
)	O
==	O
0	int
)	O
)	O
{	O
tnamep	pointer
=	O
mklist	function
(	O
termbuf	array
,	O
tname	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tname	pointer
&&	O
(	O
(	O
int	O
)	O
strlen	function
(	O
tname	pointer
)	O
<=	O
40	int
)	O
)	O
{	O
unknown	array
[	O
0	int
]	O
=	O
tname	pointer
;	O
upcase	function
(	O
tname	pointer
)	O
;	O
}	O
else	O
unknown	array
[	O
0	int
]	O
=	O
name_unknown	pointer
;	O
tnamep	pointer
=	O
unknown	array
;	O
}	O
next	pointer
=	O
tnamep	pointer
;	O
}	O
if	O
(	O
*	O
next	pointer
==	O
0	int
)	O
next	pointer
=	O
tnamep	pointer
;	O
return	O
(	O
*	O
next	pointer
++	O
)	O
;	O
}	O
static	O
void	O
suboption	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
subchar	char
;	O
printsub	function
(	O
'<'	O
,	O
subbuffer	array
,	O
SB_LEN	O
(	O
)	O
+	O
2	int
)	O
;	O
switch	O
(	O
subchar	char
=	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
TELOPT_TTYPE	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_SEND	int
)	O
{	O
return	O
;	O
}	O
else	O
{	O
char	O
*	O
name	pointer
;	O
unsigned	O
char	O
temp	array
[	O
50	int
]	O
;	O
int	O
len	int
;	O
name	pointer
=	O
gettermname	function
(	O
)	O
;	O
len	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
4	int
+	O
2	int
;	O
if	O
(	O
len	int
<	O
NETROOM	O
(	O
)	O
)	O
{	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
temp	array
,	O
"%c%c%c%c%s%c%c"	pointer
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_TTYPE	int
,	O
TELQUAL_IS	int
,	O
name	pointer
,	O
IAC	int
,	O
SE	int
)	O
;	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
temp	array
,	O
len	int
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
temp	array
[	O
2	int
]	O
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
{	O
ExitString	function
(	O
"No room in buffer for terminal type.\n"	pointer
,	O
1	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TELOPT_TSPEED	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_TSPEED	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
if	O
(	O
SB_GET	O
(	O
)	O
==	O
TELQUAL_SEND	int
)	O
{	O
long	O
ospeed	pointer
,	O
ispeed	pointer
;	O
unsigned	O
char	O
temp	array
[	O
50	int
]	O
;	O
int	O
len	int
;	O
TerminalSpeeds	function
(	O
&	O
ispeed	pointer
,	O
&	O
ospeed	pointer
)	O
;	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
temp	array
,	O
"%c%c%c%c%d,%d%c%c"	pointer
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_TSPEED	int
,	O
TELQUAL_IS	int
,	O
(	O
int	O
)	O
ospeed	pointer
,	O
(	O
int	O
)	O
ispeed	pointer
,	O
IAC	int
,	O
SE	int
)	O
;	O
len	int
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
temp	array
+	O
4	int
)	O
+	O
4	int
;	O
if	O
(	O
len	int
<	O
NETROOM	O
(	O
)	O
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
temp	array
,	O
len	int
)	O
;	O
printsub	function
(	O
'>'	O
,	O
temp	array
+	O
2	int
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"lm_will: not enough room in buffer\n"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_LFLOW	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LFLOW	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
switch	O
(	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
LFLOW_RESTART_ANY	int
:	O
restartany	int
=	O
1	int
;	O
break	O
;	O
case	O
LFLOW_RESTART_XON	int
:	O
restartany	int
=	O
0	int
;	O
break	O
;	O
case	O
LFLOW_ON	int
:	O
localflow	int
=	O
1	int
;	O
break	O
;	O
case	O
LFLOW_OFF	int
:	O
localflow	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
setcommandmode	function
(	O
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
switch	O
(	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
WILL	int
:	O
lm_will	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
WONT	int
:	O
lm_wont	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
DO	int
:	O
lm_do	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
DONT	int
:	O
lm_dont	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
LM_SLC	int
:	O
slc	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
LM_MODE	int
:	O
lm_mode	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
switch	O
(	O
SB_PEEK	O
(	O
)	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
case	O
TELQUAL_INFO	int
:	O
if	O
(	O
my_want_state_is_dont	O
(	O
subchar	char
)	O
)	O
return	O
;	O
break	O
;	O
case	O
TELQUAL_SEND	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
subchar	char
)	O
)	O
{	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
env_opt	function
(	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
TELOPT_XDISPLOC	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_XDISPLOC	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
if	O
(	O
SB_GET	O
(	O
)	O
==	O
TELQUAL_SEND	int
)	O
{	O
unsigned	O
char	O
temp	array
[	O
50	int
]	O
,	O
*	O
dp	pointer
;	O
int	O
len	int
;	O
if	O
(	O
(	O
dp	pointer
=	O
env_getvalue	function
(	O
"DISPLAY"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
send_wont	function
(	O
TELOPT_XDISPLOC	int
,	O
1	int
)	O
;	O
break	O
;	O
}	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
temp	array
,	O
"%c%c%c%c%s%c%c"	pointer
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_XDISPLOC	int
,	O
TELQUAL_IS	int
,	O
dp	pointer
,	O
IAC	int
,	O
SE	int
)	O
;	O
len	int
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
temp	array
+	O
4	int
)	O
+	O
4	int
;	O
if	O
(	O
len	int
<	O
NETROOM	O
(	O
)	O
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
temp	array
,	O
len	int
)	O
;	O
printsub	function
(	O
'>'	O
,	O
temp	array
+	O
2	int
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"lm_will: not enough room in buffer\n"	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
str_lm	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
0	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
void	O
lm_will	function
(	O
unsigned	O
char	O
*	O
cmd	pointer
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	function
(	O
"lm_will: no command!!!\n"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	pointer
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
str_lm	array
[	O
3	int
]	O
=	O
DONT	int
;	O
str_lm	array
[	O
4	int
]	O
=	O
cmd	pointer
[	O
0	int
]	O
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
str_lm	array
)	O
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
str_lm	array
,	O
sizeof	O
(	O
str_lm	array
)	O
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
str_lm	array
[	O
2	int
]	O
,	O
sizeof	O
(	O
str_lm	array
)	O
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"lm_will: not enough room in buffer\n"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
lm_wont	function
(	O
unsigned	O
char	O
*	O
cmd	pointer
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	function
(	O
"lm_wont: no command!!!\n"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	pointer
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
return	O
;	O
}	O
}	O
void	O
lm_do	function
(	O
unsigned	O
char	O
*	O
cmd	pointer
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	function
(	O
"lm_do: no command!!!\n"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	pointer
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
str_lm	array
[	O
3	int
]	O
=	O
WONT	int
;	O
str_lm	array
[	O
4	int
]	O
=	O
cmd	pointer
[	O
0	int
]	O
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
str_lm	array
)	O
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
str_lm	array
,	O
sizeof	O
(	O
str_lm	array
)	O
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
str_lm	array
[	O
2	int
]	O
,	O
sizeof	O
(	O
str_lm	array
)	O
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"lm_do: not enough room in buffer\n"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
lm_dont	function
(	O
unsigned	O
char	O
*	O
cmd	pointer
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	function
(	O
"lm_dont: no command!!!\n"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	pointer
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
str_lm_mode	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
LM_MODE	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
void	O
lm_mode	function
(	O
unsigned	O
char	O
*	O
cmd	pointer
,	O
int	O
len	int
,	O
int	O
init	int
)	O
{	O
if	O
(	O
len	int
!=	O
1	int
)	O
return	O
;	O
if	O
(	O
(	O
linemode	int
&	O
MODE_MASK	int
&	O
~	O
MODE_ACK	int
)	O
==	O
*	O
cmd	pointer
)	O
return	O
;	O
if	O
(	O
*	O
cmd	pointer
&	O
MODE_ACK	int
)	O
return	O
;	O
linemode	int
=	O
*	O
cmd	pointer
&	O
(	O
MODE_MASK	int
&	O
~	O
MODE_ACK	int
)	O
;	O
str_lm_mode	array
[	O
4	int
]	O
=	O
linemode	int
;	O
if	O
(	O
!	O
init	int
)	O
str_lm_mode	array
[	O
4	int
]	O
|=	O
MODE_ACK	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
str_lm_mode	array
)	O
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
str_lm_mode	array
,	O
sizeof	O
(	O
str_lm_mode	array
)	O
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
str_lm_mode	array
[	O
2	int
]	O
,	O
sizeof	O
(	O
str_lm_mode	array
)	O
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"lm_mode: not enough room in buffer\n"	pointer
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
struct	O
spc	struct
{	O
cc_t	char
val	char
;	O
cc_t	char
*	O
valp	pointer
;	O
char	O
flags	char
;	O
char	O
mylevel	char
;	O
}	O
spc_data	array
[	O
NSLC	int
+	O
1	int
]	O
;	O
static	O
int	O
slc_mode	int
=	O
SLC_EXPORT	int
;	O
void	O
slc_init	function
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct
*	O
spcp	pointer
;	O
localchars	int
=	O
1	int
;	O
for	O
(	O
spcp	pointer
=	O
spc_data	array
;	O
spcp	pointer
<	O
&	O
spc_data	array
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	pointer
++	O
)	O
{	O
spcp	pointer
->	O
val	char
=	O
0	int
;	O
spcp	pointer
->	O
valp	pointer
=	O
0	int
;	O
spcp	pointer
->	O
flags	char
=	O
spcp	pointer
->	O
mylevel	char
=	O
SLC_NOSUPPORT	int
;	O
}	O
initfunc	O
(	O
SLC_SYNCH	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_AO	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_AYT	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_ABORT	int
,	O
SLC_FLUSHIN	int
|	O
SLC_FLUSHOUT	int
)	O
;	O
initfunc	O
(	O
SLC_EOF	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_SUSP	int
,	O
SLC_FLUSHIN	int
)	O
;	O
initfunc	O
(	O
SLC_EC	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_EL	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_EW	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_RP	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_LNEXT	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_XON	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_XOFF	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_FORW1	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_FORW2	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_IP	int
,	O
SLC_FLUSHIN	int
|	O
SLC_FLUSHOUT	int
)	O
;	O
if	O
(	O
slc_mode	int
==	O
SLC_EXPORT	int
)	O
slc_export	function
(	O
)	O
;	O
else	O
slc_import	function
(	O
1	int
)	O
;	O
}	O
void	O
slcstate	function
(	O
void	O
)	O
{	O
printf	function
(	O
"Special characters are %s values\n"	pointer
,	O
slc_mode	int
==	O
SLC_IMPORT	int
?	O
"remote default"	pointer
:	O
slc_mode	int
==	O
SLC_EXPORT	int
?	O
"local"	pointer
:	O
"remote"	pointer
)	O
;	O
}	O
void	O
slc_mode_export	function
(	O
void	O
)	O
{	O
slc_mode	int
=	O
SLC_EXPORT	int
;	O
if	O
(	O
my_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
slc_export	function
(	O
)	O
;	O
}	O
void	O
slc_mode_import	function
(	O
int	O
def	int
)	O
{	O
slc_mode	int
=	O
def	int
?	O
SLC_IMPORT	int
:	O
SLC_RVALUE	int
;	O
if	O
(	O
my_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
slc_import	function
(	O
def	int
)	O
;	O
}	O
unsigned	O
char	O
slc_import_val	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
LM_SLC	int
,	O
0	int
,	O
SLC_VARIABLE	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
unsigned	O
char	O
slc_import_def	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
LM_SLC	int
,	O
0	int
,	O
SLC_DEFAULT	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
void	O
slc_import	function
(	O
int	O
def	int
)	O
{	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
slc_import_val	array
)	O
)	O
{	O
if	O
(	O
def	int
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
slc_import_def	array
,	O
sizeof	O
(	O
slc_import_def	array
)	O
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
slc_import_def	array
[	O
2	int
]	O
,	O
sizeof	O
(	O
slc_import_def	array
)	O
-	O
2	int
)	O
;	O
}	O
else	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
slc_import_val	array
,	O
sizeof	O
(	O
slc_import_val	array
)	O
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
slc_import_val	array
[	O
2	int
]	O
,	O
sizeof	O
(	O
slc_import_val	array
)	O
-	O
2	int
)	O
;	O
}	O
}	O
else	O
printf	function
(	O
"slc_import: not enough room\n"	pointer
)	O
;	O
}	O
void	O
slc_export	function
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct
*	O
spcp	pointer
;	O
TerminalDefaultChars	function
(	O
)	O
;	O
slc_start_reply	function
(	O
)	O
;	O
for	O
(	O
spcp	pointer
=	O
&	O
spc_data	array
[	O
1	int
]	O
;	O
spcp	pointer
<	O
&	O
spc_data	array
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	pointer
++	O
)	O
{	O
if	O
(	O
spcp	pointer
->	O
mylevel	char
!=	O
SLC_NOSUPPORT	int
)	O
{	O
if	O
(	O
spcp	pointer
->	O
val	char
==	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
spcp	pointer
->	O
flags	char
=	O
SLC_NOSUPPORT	int
;	O
else	O
spcp	pointer
->	O
flags	char
=	O
spcp	pointer
->	O
mylevel	char
;	O
if	O
(	O
spcp	pointer
->	O
valp	pointer
)	O
spcp	pointer
->	O
val	char
=	O
*	O
spcp	pointer
->	O
valp	pointer
;	O
slc_add_reply	function
(	O
spcp	pointer
-	O
spc_data	array
,	O
spcp	pointer
->	O
flags	char
,	O
spcp	pointer
->	O
val	char
)	O
;	O
}	O
}	O
slc_end_reply	function
(	O
)	O
;	O
slc_update	function
(	O
)	O
;	O
setconnmode	function
(	O
1	int
)	O
;	O
}	O
void	O
slc	function
(	O
register	O
unsigned	O
char	O
*	O
cp	pointer
,	O
int	O
len	int
)	O
{	O
register	O
struct	O
spc	struct
*	O
spcp	pointer
;	O
register	O
int	O
func	int
,	O
level	int
;	O
slc_start_reply	function
(	O
)	O
;	O
for	O
(	O
;	O
len	int
>=	O
3	int
;	O
len	int
-=	O
3	int
,	O
cp	pointer
+=	O
3	int
)	O
{	O
func	int
=	O
cp	pointer
[	O
SLC_FUNC	int
]	O
;	O
if	O
(	O
func	int
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
func	int
>	O
NSLC	int
)	O
{	O
if	O
(	O
(	O
cp	pointer
[	O
SLC_FLAGS	int
]	O
&	O
SLC_LEVELBITS	int
)	O
!=	O
SLC_NOSUPPORT	int
)	O
slc_add_reply	function
(	O
func	int
,	O
SLC_NOSUPPORT	int
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
spcp	pointer
=	O
&	O
spc_data	array
[	O
func	int
]	O
;	O
level	int
=	O
cp	pointer
[	O
SLC_FLAGS	int
]	O
&	O
(	O
SLC_LEVELBITS	int
|	O
SLC_ACK	int
)	O
;	O
if	O
(	O
(	O
cp	pointer
[	O
SLC_VALUE	int
]	O
==	O
(	O
unsigned	O
char	O
)	O
spcp	pointer
->	O
val	char
)	O
&&	O
(	O
(	O
level	int
&	O
SLC_LEVELBITS	int
)	O
==	O
(	O
spcp	pointer
->	O
flags	char
&	O
SLC_LEVELBITS	int
)	O
)	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
level	int
==	O
(	O
SLC_DEFAULT	int
|	O
SLC_ACK	int
)	O
)	O
{	O
cp	pointer
[	O
SLC_FLAGS	int
]	O
&=	O
~	O
SLC_ACK	int
;	O
}	O
if	O
(	O
level	int
==	O
(	O
(	O
spcp	pointer
->	O
flags	char
&	O
SLC_LEVELBITS	int
)	O
|	O
SLC_ACK	int
)	O
)	O
{	O
spcp	pointer
->	O
val	char
=	O
(	O
cc_t	char
)	O
cp	pointer
[	O
SLC_VALUE	int
]	O
;	O
spcp	pointer
->	O
flags	char
=	O
cp	pointer
[	O
SLC_FLAGS	int
]	O
;	O
continue	O
;	O
}	O
level	int
&=	O
~	O
SLC_ACK	int
;	O
if	O
(	O
level	int
<=	O
(	O
spcp	pointer
->	O
mylevel	char
&	O
SLC_LEVELBITS	int
)	O
)	O
{	O
spcp	pointer
->	O
flags	char
=	O
cp	pointer
[	O
SLC_FLAGS	int
]	O
|	O
SLC_ACK	int
;	O
spcp	pointer
->	O
val	char
=	O
(	O
cc_t	char
)	O
cp	pointer
[	O
SLC_VALUE	int
]	O
;	O
}	O
if	O
(	O
level	int
==	O
SLC_DEFAULT	int
)	O
{	O
if	O
(	O
(	O
spcp	pointer
->	O
mylevel	char
&	O
SLC_LEVELBITS	int
)	O
!=	O
SLC_DEFAULT	int
)	O
spcp	pointer
->	O
flags	char
=	O
spcp	pointer
->	O
mylevel	char
;	O
else	O
spcp	pointer
->	O
flags	char
=	O
SLC_NOSUPPORT	int
;	O
}	O
slc_add_reply	function
(	O
func	int
,	O
spcp	pointer
->	O
flags	char
,	O
spcp	pointer
->	O
val	char
)	O
;	O
}	O
slc_end_reply	function
(	O
)	O
;	O
if	O
(	O
slc_update	function
(	O
)	O
)	O
setconnmode	function
(	O
1	int
)	O
;	O
}	O
void	O
slc_check	function
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct
*	O
spcp	pointer
;	O
slc_start_reply	function
(	O
)	O
;	O
for	O
(	O
spcp	pointer
=	O
&	O
spc_data	array
[	O
1	int
]	O
;	O
spcp	pointer
<	O
&	O
spc_data	array
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	pointer
++	O
)	O
{	O
if	O
(	O
spcp	pointer
->	O
valp	pointer
&&	O
spcp	pointer
->	O
val	char
!=	O
*	O
spcp	pointer
->	O
valp	pointer
)	O
{	O
spcp	pointer
->	O
val	char
=	O
*	O
spcp	pointer
->	O
valp	pointer
;	O
if	O
(	O
spcp	pointer
->	O
val	char
==	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
spcp	pointer
->	O
flags	char
=	O
SLC_NOSUPPORT	int
;	O
else	O
spcp	pointer
->	O
flags	char
=	O
spcp	pointer
->	O
mylevel	char
;	O
slc_add_reply	function
(	O
spcp	pointer
-	O
spc_data	array
,	O
spcp	pointer
->	O
flags	char
,	O
spcp	pointer
->	O
val	char
)	O
;	O
}	O
}	O
slc_end_reply	function
(	O
)	O
;	O
setconnmode	function
(	O
1	int
)	O
;	O
}	O
unsigned	O
char	O
slc_reply	array
[	O
128	int
]	O
;	O
unsigned	O
char	O
*	O
slc_replyp	pointer
;	O
void	O
slc_start_reply	function
(	O
void	O
)	O
{	O
slc_replyp	pointer
=	O
slc_reply	array
;	O
*	O
slc_replyp	pointer
++	O
=	O
IAC	int
;	O
*	O
slc_replyp	pointer
++	O
=	O
SB	int
;	O
*	O
slc_replyp	pointer
++	O
=	O
TELOPT_LINEMODE	int
;	O
*	O
slc_replyp	pointer
++	O
=	O
LM_SLC	int
;	O
}	O
void	O
slc_add_reply	function
(	O
unsigned	O
char	O
func	int
,	O
unsigned	O
char	O
flags	char
,	O
cc_t	char
value	char
)	O
{	O
if	O
(	O
(	O
*	O
slc_replyp	pointer
++	O
=	O
func	int
)	O
==	O
IAC	int
)	O
*	O
slc_replyp	pointer
++	O
=	O
IAC	int
;	O
if	O
(	O
(	O
*	O
slc_replyp	pointer
++	O
=	O
flags	char
)	O
==	O
IAC	int
)	O
*	O
slc_replyp	pointer
++	O
=	O
IAC	int
;	O
if	O
(	O
(	O
*	O
slc_replyp	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
value	char
)	O
==	O
IAC	int
)	O
*	O
slc_replyp	pointer
++	O
=	O
IAC	int
;	O
}	O
void	O
slc_end_reply	function
(	O
void	O
)	O
{	O
register	O
int	O
len	int
;	O
*	O
slc_replyp	pointer
++	O
=	O
IAC	int
;	O
*	O
slc_replyp	pointer
++	O
=	O
SE	int
;	O
len	int
=	O
slc_replyp	pointer
-	O
slc_reply	array
;	O
if	O
(	O
len	int
<=	O
6	int
)	O
return	O
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
len	int
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
slc_reply	array
,	O
slc_replyp	pointer
-	O
slc_reply	array
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
slc_reply	array
[	O
2	int
]	O
,	O
slc_replyp	pointer
-	O
slc_reply	array
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"slc_end_reply: not enough room\n"	pointer
)	O
;	O
}	O
int	O
slc_update	function
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct
*	O
spcp	pointer
;	O
int	O
need_update	int
=	O
0	int
;	O
for	O
(	O
spcp	pointer
=	O
&	O
spc_data	array
[	O
1	int
]	O
;	O
spcp	pointer
<	O
&	O
spc_data	array
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
spcp	pointer
->	O
flags	char
&	O
SLC_ACK	int
)	O
)	O
continue	O
;	O
spcp	pointer
->	O
flags	char
&=	O
~	O
SLC_ACK	int
;	O
if	O
(	O
spcp	pointer
->	O
valp	pointer
&&	O
(	O
*	O
spcp	pointer
->	O
valp	pointer
!=	O
spcp	pointer
->	O
val	char
)	O
)	O
{	O
*	O
spcp	pointer
->	O
valp	pointer
=	O
spcp	pointer
->	O
val	char
;	O
need_update	int
=	O
1	int
;	O
}	O
}	O
return	O
(	O
need_update	int
)	O
;	O
}	O
void	O
env_opt	function
(	O
register	O
unsigned	O
char	O
*	O
buf	pointer
,	O
register	O
int	O
len	int
)	O
{	O
register	O
unsigned	O
char	O
*	O
ep	pointer
=	O
0	int
,	O
*	O
epc	pointer
=	O
0	int
;	O
register	O
int	O
i	int
;	O
switch	O
(	O
buf	pointer
[	O
0	int
]	O
&	O
0xff	int
)	O
{	O
case	O
TELQUAL_SEND	int
:	O
env_opt_start	function
(	O
)	O
;	O
if	O
(	O
len	int
==	O
1	int
)	O
{	O
env_opt_add	function
(	O
NULL	O
)	O
;	O
}	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
buf	pointer
[	O
i	int
]	O
&	O
0xff	int
)	O
{	O
case	O
NEW_ENV_VAR	int
:	O
case	O
ENV_USERVAR	int
:	O
if	O
(	O
ep	pointer
)	O
{	O
*	O
epc	pointer
=	O
0	int
;	O
env_opt_add	function
(	O
ep	pointer
)	O
;	O
}	O
ep	pointer
=	O
epc	pointer
=	O
&	O
buf	pointer
[	O
i	int
+	O
1	int
]	O
;	O
break	O
;	O
case	O
ENV_ESC	int
:	O
i	int
++	O
;	O
default	O
:	O
if	O
(	O
epc	pointer
)	O
*	O
epc	pointer
++	O
=	O
buf	pointer
[	O
i	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
ep	pointer
)	O
{	O
*	O
epc	pointer
=	O
0	int
;	O
env_opt_add	function
(	O
ep	pointer
)	O
;	O
}	O
env_opt_end	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
TELQUAL_IS	int
:	O
case	O
TELQUAL_INFO	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
unsigned	O
char	O
*	O
opt_reply	pointer
;	O
unsigned	O
char	O
*	O
opt_replyp	pointer
;	O
unsigned	O
char	O
*	O
opt_replyend	pointer
;	O
void	O
env_opt_start	function
(	O
void	O
)	O
{	O
if	O
(	O
opt_reply	pointer
)	O
opt_reply	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
realloc	function
(	O
opt_reply	pointer
,	O
OPT_REPLY_SIZE	int
)	O
;	O
else	O
opt_reply	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	function
(	O
OPT_REPLY_SIZE	int
)	O
;	O
if	O
(	O
opt_reply	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"env_opt_start: malloc()/realloc() failed!!!\n"	pointer
)	O
;	O
opt_reply	pointer
=	O
opt_replyp	pointer
=	O
opt_replyend	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
opt_replyp	pointer
=	O
opt_reply	pointer
;	O
opt_replyend	pointer
=	O
opt_reply	pointer
+	O
OPT_REPLY_SIZE	int
;	O
*	O
opt_replyp	pointer
++	O
=	O
IAC	int
;	O
*	O
opt_replyp	pointer
++	O
=	O
SB	int
;	O
*	O
opt_replyp	pointer
++	O
=	O
telopt_environ	O
;	O
*	O
opt_replyp	pointer
++	O
=	O
TELQUAL_IS	int
;	O
}	O
void	O
env_opt_start_info	function
(	O
void	O
)	O
{	O
env_opt_start	function
(	O
)	O
;	O
if	O
(	O
opt_replyp	pointer
)	O
opt_replyp	pointer
[	O
-	O
1	int
]	O
=	O
TELQUAL_INFO	int
;	O
}	O
void	O
env_opt_add	function
(	O
register	O
unsigned	O
char	O
*	O
ep	pointer
)	O
{	O
register	O
unsigned	O
char	O
*	O
vp	pointer
,	O
c	int
;	O
if	O
(	O
opt_reply	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
ep	pointer
==	O
NULL	O
||	O
*	O
ep	pointer
==	O
'\0'	O
)	O
{	O
env_default	function
(	O
1	int
,	O
0	int
)	O
;	O
while	O
(	O
(	O
ep	pointer
=	O
env_default	function
(	O
0	int
,	O
0	int
)	O
)	O
)	O
env_opt_add	function
(	O
ep	pointer
)	O
;	O
env_default	function
(	O
1	int
,	O
1	int
)	O
;	O
while	O
(	O
(	O
ep	pointer
=	O
env_default	function
(	O
0	int
,	O
1	int
)	O
)	O
)	O
env_opt_add	function
(	O
ep	pointer
)	O
;	O
return	O
;	O
}	O
vp	pointer
=	O
env_getvalue	function
(	O
(	O
char	O
*	O
)	O
ep	pointer
)	O
;	O
if	O
(	O
opt_replyp	pointer
+	O
(	O
vp	pointer
?	O
strlen	function
(	O
(	O
char	O
*	O
)	O
vp	pointer
)	O
:	O
0	int
)	O
+	O
strlen	function
(	O
(	O
char	O
*	O
)	O
ep	pointer
)	O
+	O
6	int
>	O
opt_replyend	pointer
)	O
{	O
register	O
int	O
len	int
;	O
opt_replyend	pointer
+=	O
OPT_REPLY_SIZE	int
;	O
len	int
=	O
opt_replyend	pointer
-	O
opt_reply	pointer
;	O
opt_reply	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
realloc	function
(	O
opt_reply	pointer
,	O
len	int
)	O
;	O
if	O
(	O
opt_reply	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"env_opt_add: realloc() failed!!!\n"	pointer
)	O
;	O
opt_reply	pointer
=	O
opt_replyp	pointer
=	O
opt_replyend	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
opt_replyp	pointer
=	O
opt_reply	pointer
+	O
len	int
-	O
(	O
opt_replyend	pointer
-	O
opt_replyp	pointer
)	O
;	O
opt_replyend	pointer
=	O
opt_reply	pointer
+	O
len	int
;	O
}	O
if	O
(	O
opt_welldefined	function
(	O
(	O
char	O
*	O
)	O
ep	pointer
)	O
)	O
*	O
opt_replyp	pointer
++	O
=	O
NEW_ENV_VAR	int
;	O
else	O
*	O
opt_replyp	pointer
++	O
=	O
ENV_USERVAR	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
*	O
ep	pointer
++	O
)	O
)	O
{	O
switch	O
(	O
c	int
&	O
0xff	int
)	O
{	O
case	O
IAC	int
:	O
*	O
opt_replyp	pointer
++	O
=	O
IAC	int
;	O
break	O
;	O
case	O
NEW_ENV_VAR	int
:	O
case	O
NEW_ENV_VALUE	int
:	O
case	O
ENV_ESC	int
:	O
case	O
ENV_USERVAR	int
:	O
*	O
opt_replyp	pointer
++	O
=	O
ENV_ESC	int
;	O
break	O
;	O
}	O
*	O
opt_replyp	pointer
++	O
=	O
c	int
;	O
}	O
if	O
(	O
(	O
ep	pointer
=	O
vp	pointer
)	O
)	O
{	O
*	O
opt_replyp	pointer
++	O
=	O
NEW_ENV_VALUE	int
;	O
vp	pointer
=	O
NULL	O
;	O
}	O
else	O
break	O
;	O
}	O
}	O
int	O
opt_welldefined	function
(	O
char	O
*	O
ep	pointer
)	O
{	O
if	O
(	O
(	O
strcmp	function
(	O
ep	pointer
,	O
"USER"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	function
(	O
ep	pointer
,	O
"DISPLAY"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	function
(	O
ep	pointer
,	O
"PRINTER"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	function
(	O
ep	pointer
,	O
"SYSTEMTYPE"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	function
(	O
ep	pointer
,	O
"JOB"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	function
(	O
ep	pointer
,	O
"ACCT"	pointer
)	O
==	O
0	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
env_opt_end	function
(	O
register	O
int	O
emptyok	int
)	O
{	O
register	O
int	O
len	int
;	O
len	int
=	O
opt_replyp	pointer
-	O
opt_reply	pointer
+	O
2	int
;	O
if	O
(	O
emptyok	int
||	O
len	int
>	O
6	int
)	O
{	O
*	O
opt_replyp	pointer
++	O
=	O
IAC	int
;	O
*	O
opt_replyp	pointer
++	O
=	O
SE	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
len	int
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
opt_reply	pointer
,	O
len	int
)	O
;	O
printsub	function
(	O
'>'	O
,	O
&	O
opt_reply	pointer
[	O
2	int
]	O
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
printf	function
(	O
"slc_end_reply: not enough room\n"	pointer
)	O
;	O
}	O
if	O
(	O
opt_reply	pointer
)	O
{	O
free	function
(	O
opt_reply	pointer
)	O
;	O
opt_reply	pointer
=	O
opt_replyp	pointer
=	O
opt_replyend	pointer
=	O
NULL	O
;	O
}	O
}	O
int	O
telrcv	function
(	O
void	O
)	O
{	O
register	O
int	O
c	int
;	O
register	O
int	O
scc	int
;	O
register	O
unsigned	O
char	O
*	O
sbp	pointer
;	O
int	O
count	int
;	O
int	O
returnValue	int
=	O
0	int
;	O
scc	int
=	O
0	int
;	O
count	int
=	O
0	int
;	O
while	O
(	O
TTYROOM	O
(	O
)	O
>	O
2	int
)	O
{	O
if	O
(	O
scc	int
==	O
0	int
)	O
{	O
if	O
(	O
count	int
)	O
{	O
ring_consumed	function
(	O
&	O
netiring	struct
,	O
count	int
)	O
;	O
returnValue	int
=	O
1	int
;	O
count	int
=	O
0	int
;	O
}	O
sbp	pointer
=	O
netiring	struct
.	O
consume	pointer
;	O
scc	int
=	O
ring_full_consecutive	function
(	O
&	O
netiring	struct
)	O
;	O
if	O
(	O
scc	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
}	O
c	int
=	O
*	O
sbp	pointer
++	O
&	O
0xff	int
,	O
scc	int
--	O
;	O
count	int
++	O
;	O
switch	O
(	O
telrcv_state	int
)	O
{	O
case	O
TS_CR	int
:	O
telrcv_state	int
=	O
TS_DATA	int
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
'\n'	O
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_ECHO	int
)	O
&&	O
!	O
crmod	int
)	O
{	O
TTYADD	O
(	O
c	int
)	O
;	O
break	O
;	O
}	O
case	O
TS_DATA	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
telrcv_state	int
=	O
TS_IAC	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
c	int
==	O
'\r'	O
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
if	O
(	O
scc	int
>	O
0	int
)	O
{	O
c	int
=	O
*	O
sbp	pointer
&	O
0xff	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
sbp	pointer
++	O
,	O
scc	int
--	O
;	O
count	int
++	O
;	O
TTYADD	O
(	O
'\r'	O
)	O
;	O
}	O
else	O
if	O
(	O
my_want_state_is_dont	O
(	O
TELOPT_ECHO	int
)	O
&&	O
(	O
c	int
==	O
'\n'	O
)	O
)	O
{	O
sbp	pointer
++	O
,	O
scc	int
--	O
;	O
count	int
++	O
;	O
TTYADD	O
(	O
'\n'	O
)	O
;	O
}	O
else	O
{	O
TTYADD	O
(	O
'\r'	O
)	O
;	O
if	O
(	O
crmod	int
)	O
{	O
TTYADD	O
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
telrcv_state	int
=	O
TS_CR	int
;	O
TTYADD	O
(	O
'\r'	O
)	O
;	O
if	O
(	O
crmod	int
)	O
{	O
TTYADD	O
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
TTYADD	O
(	O
c	int
)	O
;	O
}	O
continue	O
;	O
case	O
TS_IAC	int
:	O
process_iac	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
WILL	int
:	O
telrcv_state	int
=	O
TS_WILL	int
;	O
continue	O
;	O
case	O
WONT	int
:	O
telrcv_state	int
=	O
TS_WONT	int
;	O
continue	O
;	O
case	O
DO	int
:	O
telrcv_state	int
=	O
TS_DO	int
;	O
continue	O
;	O
case	O
DONT	int
:	O
telrcv_state	int
=	O
TS_DONT	int
;	O
continue	O
;	O
case	O
DM	int
:	O
printoption	function
(	O
"RCVD"	pointer
,	O
IAC	int
,	O
DM	int
)	O
;	O
SYNCHing	int
=	O
1	int
;	O
ttyflush	function
(	O
1	int
)	O
;	O
SYNCHing	int
=	O
stilloob	function
(	O
)	O
;	O
settimer	O
(	O
gotDM	int
)	O
;	O
break	O
;	O
case	O
SB	int
:	O
SB_CLEAR	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_SB	int
;	O
continue	O
;	O
case	O
IAC	int
:	O
TTYADD	O
(	O
IAC	int
)	O
;	O
break	O
;	O
case	O
NOP	int
:	O
case	O
GA	int
:	O
default	O
:	O
printoption	function
(	O
"RCVD"	pointer
,	O
IAC	int
,	O
c	int
)	O
;	O
break	O
;	O
}	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_WILL	int
:	O
printoption	function
(	O
"RCVD"	pointer
,	O
WILL	int
,	O
c	int
)	O
;	O
willoption	function
(	O
c	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_WONT	int
:	O
printoption	function
(	O
"RCVD"	pointer
,	O
WONT	int
,	O
c	int
)	O
;	O
wontoption	function
(	O
c	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DO	int
:	O
printoption	function
(	O
"RCVD"	pointer
,	O
DO	int
,	O
c	int
)	O
;	O
dooption	function
(	O
c	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
TELOPT_NAWS	int
)	O
{	O
sendnaws	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
TELOPT_LFLOW	int
)	O
{	O
localflow	int
=	O
1	int
;	O
setcommandmode	function
(	O
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DONT	int
:	O
printoption	function
(	O
"RCVD"	pointer
,	O
DONT	int
,	O
c	int
)	O
;	O
dontoption	function
(	O
c	int
)	O
;	O
flushline	int
=	O
1	int
;	O
setconnmode	function
(	O
0	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_SB	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
telrcv_state	int
=	O
TS_SE	int
;	O
}	O
else	O
{	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
}	O
continue	O
;	O
case	O
TS_SE	int
:	O
if	O
(	O
c	int
!=	O
SE	int
)	O
{	O
if	O
(	O
c	int
!=	O
IAC	int
)	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
subpointer	pointer
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
printoption	function
(	O
"In SUBOPTION processing, RCVD"	pointer
,	O
IAC	int
,	O
c	int
)	O
;	O
suboption	function
(	O
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_IAC	int
;	O
goto	O
process_iac	O
;	O
}	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
telrcv_state	int
=	O
TS_SB	int
;	O
}	O
else	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
SE	int
)	O
;	O
subpointer	pointer
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
suboption	function
(	O
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
}	O
}	O
}	O
if	O
(	O
count	int
)	O
ring_consumed	function
(	O
&	O
netiring	struct
,	O
count	int
)	O
;	O
return	O
returnValue	int
||	O
count	int
;	O
}	O
static	O
int	O
bol	int
=	O
1	int
,	O
local	int
=	O
0	int
;	O
int	O
rlogin_susp	function
(	O
void	O
)	O
{	O
if	O
(	O
local	int
)	O
{	O
local	int
=	O
0	int
;	O
bol	int
=	O
1	int
;	O
command	function
(	O
0	int
,	O
"z\n"	pointer
,	O
2	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
telsnd	function
(	O
void	O
)	O
{	O
int	O
tcc	int
;	O
int	O
count	int
;	O
int	O
returnValue	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
tbp	pointer
;	O
tcc	int
=	O
0	int
;	O
count	int
=	O
0	int
;	O
while	O
(	O
NETROOM	O
(	O
)	O
>	O
2	int
)	O
{	O
register	O
int	O
sc	int
;	O
register	O
int	O
c	int
;	O
if	O
(	O
tcc	int
==	O
0	int
)	O
{	O
if	O
(	O
count	int
)	O
{	O
ring_consumed	function
(	O
&	O
ttyiring	struct
,	O
count	int
)	O
;	O
returnValue	int
=	O
1	int
;	O
count	int
=	O
0	int
;	O
}	O
tbp	pointer
=	O
ttyiring	struct
.	O
consume	pointer
;	O
tcc	int
=	O
ring_full_consecutive	function
(	O
&	O
ttyiring	struct
)	O
;	O
if	O
(	O
tcc	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
}	O
c	int
=	O
*	O
tbp	pointer
++	O
&	O
0xff	int
,	O
sc	int
=	O
strip	O
(	O
c	int
)	O
,	O
tcc	int
--	O
;	O
count	int
++	O
;	O
if	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
{	O
if	O
(	O
bol	int
)	O
{	O
bol	int
=	O
0	int
;	O
if	O
(	O
sc	int
==	O
rlogin	char
)	O
{	O
local	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
local	int
)	O
{	O
local	int
=	O
0	int
;	O
if	O
(	O
sc	int
==	O
'.'	O
||	O
c	int
==	O
termEofChar	O
)	O
{	O
bol	int
=	O
1	int
;	O
command	function
(	O
0	int
,	O
"close\n"	pointer
,	O
6	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
sc	int
==	O
termSuspChar	O
)	O
{	O
bol	int
=	O
1	int
;	O
command	function
(	O
0	int
,	O
"z\n"	pointer
,	O
2	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
sc	int
==	O
escape	char
)	O
{	O
command	function
(	O
0	int
,	O
(	O
char	O
*	O
)	O
tbp	pointer
,	O
tcc	int
)	O
;	O
bol	int
=	O
1	int
;	O
count	int
+=	O
tcc	int
;	O
tcc	int
=	O
0	int
;	O
flushline	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
sc	int
!=	O
rlogin	char
)	O
{	O
++	O
tcc	int
;	O
--	O
tbp	pointer
;	O
--	O
count	int
;	O
c	int
=	O
sc	int
=	O
rlogin	char
;	O
}	O
}	O
if	O
(	O
(	O
sc	int
==	O
'\n'	O
)	O
||	O
(	O
sc	int
==	O
'\r'	O
)	O
)	O
bol	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
sc	int
==	O
escape	char
)	O
{	O
if	O
(	O
tcc	int
&&	O
strip	O
(	O
*	O
tbp	pointer
)	O
==	O
escape	char
)	O
{	O
tbp	pointer
++	O
;	O
tcc	int
--	O
;	O
count	int
++	O
;	O
bol	int
=	O
0	int
;	O
}	O
else	O
{	O
command	function
(	O
0	int
,	O
(	O
char	O
*	O
)	O
tbp	pointer
,	O
tcc	int
)	O
;	O
bol	int
=	O
1	int
;	O
count	int
+=	O
tcc	int
;	O
tcc	int
=	O
0	int
;	O
flushline	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
bol	int
=	O
0	int
;	O
if	O
(	O
kludgelinemode	int
&&	O
(	O
globalmode	int
&	O
MODE_EDIT	int
)	O
&&	O
(	O
sc	int
==	O
echoc	char
)	O
)	O
{	O
if	O
(	O
tcc	int
>	O
0	int
&&	O
strip	O
(	O
*	O
tbp	pointer
)	O
==	O
echoc	char
)	O
{	O
tcc	int
--	O
;	O
tbp	pointer
++	O
;	O
count	int
++	O
;	O
}	O
else	O
{	O
dontlecho	int
=	O
!	O
dontlecho	int
;	O
settimer	O
(	O
echotoggle	int
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
flushline	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
MODE_LOCAL_CHARS	O
(	O
globalmode	int
)	O
)	O
{	O
if	O
(	O
TerminalSpecialChars	function
(	O
sc	int
)	O
==	O
0	int
)	O
{	O
bol	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\n'	O
:	O
if	O
(	O
MODE_LOCAL_CHARS	O
(	O
globalmode	int
)	O
)	O
{	O
NETADD	O
(	O
'\r'	O
)	O
;	O
}	O
NETADD	O
(	O
'\n'	O
)	O
;	O
bol	int
=	O
flushline	int
=	O
1	int
;	O
break	O
;	O
case	O
'\r'	O
:	O
if	O
(	O
!	O
crlf	int
)	O
{	O
NET2ADD	O
(	O
'\r'	O
,	O
'\0'	O
)	O
;	O
}	O
else	O
{	O
NET2ADD	O
(	O
'\r'	O
,	O
'\n'	O
)	O
;	O
}	O
bol	int
=	O
flushline	int
=	O
1	int
;	O
break	O
;	O
case	O
IAC	int
:	O
NET2ADD	O
(	O
IAC	int
,	O
IAC	int
)	O
;	O
break	O
;	O
default	O
:	O
NETADD	O
(	O
c	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
IAC	int
)	O
;	O
}	O
else	O
{	O
NETADD	O
(	O
c	int
)	O
;	O
}	O
}	O
if	O
(	O
count	int
)	O
ring_consumed	function
(	O
&	O
ttyiring	struct
,	O
count	int
)	O
;	O
return	O
returnValue	int
||	O
count	int
;	O
}	O
int	O
Scheduler	function
(	O
int	O
block	int
)	O
{	O
int	O
returnValue	int
;	O
int	O
netin	int
,	O
netout	int
,	O
netex	int
,	O
ttyin	int
,	O
ttyout	int
;	O
netout	int
=	O
ring_full_count	function
(	O
&	O
netoring	struct
)	O
&&	O
(	O
flushline	int
||	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
&&	O
(	O
!	O
kludgelinemode	int
||	O
my_want_state_is_do	O
(	O
TELOPT_SGA	int
)	O
)	O
)	O
||	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
)	O
;	O
ttyout	int
=	O
ring_full_count	function
(	O
&	O
ttyoring	struct
)	O
;	O
ttyin	int
=	O
ring_empty_count	function
(	O
&	O
ttyiring	struct
)	O
;	O
netin	int
=	O
!	O
ISend	int
&&	O
ring_empty_count	function
(	O
&	O
netiring	struct
)	O
;	O
netex	int
=	O
!	O
SYNCHing	int
;	O
returnValue	int
=	O
process_rings	function
(	O
netin	int
,	O
netout	int
,	O
netex	int
,	O
ttyin	int
,	O
ttyout	int
,	O
!	O
block	int
)	O
;	O
if	O
(	O
ring_full_count	function
(	O
&	O
ttyiring	struct
)	O
)	O
{	O
returnValue	int
|=	O
telsnd	function
(	O
)	O
;	O
}	O
if	O
(	O
ring_full_count	function
(	O
&	O
netiring	struct
)	O
)	O
{	O
returnValue	int
|=	O
telrcv	function
(	O
)	O
;	O
}	O
return	O
returnValue	int
;	O
}	O
void	O
telnet	function
(	O
char	O
*	O
user	pointer
)	O
{	O
sys_telnet_init	function
(	O
)	O
;	O
if	O
(	O
telnetport	int
)	O
{	O
send_do	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_TTYPE	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_NAWS	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_TSPEED	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_LFLOW	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_NEW_ENVIRON	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_STATUS	int
,	O
1	int
)	O
;	O
if	O
(	O
env_getvalue	function
(	O
"DISPLAY"	pointer
)	O
)	O
send_will	function
(	O
TELOPT_XDISPLOC	int
,	O
1	int
)	O
;	O
if	O
(	O
eight	int
)	O
tel_enter_binary	function
(	O
eight	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
schedValue	int
;	O
while	O
(	O
(	O
schedValue	int
=	O
Scheduler	function
(	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
schedValue	int
==	O
-	O
1	int
)	O
{	O
setcommandmode	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
Scheduler	function
(	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
setcommandmode	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
netclear	function
(	O
void	O
)	O
{	O
}	O
static	O
void	O
doflush	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
DO	int
)	O
;	O
NETADD	O
(	O
TELOPT_TM	int
)	O
;	O
flushline	int
=	O
1	int
;	O
flushout	int
=	O
1	int
;	O
ttyflush	function
(	O
1	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
DO	int
,	O
TELOPT_TM	int
)	O
;	O
}	O
void	O
xmitAO	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
AO	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
AO	int
)	O
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	function
(	O
)	O
;	O
}	O
}	O
void	O
xmitEL	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
EL	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
EL	int
)	O
;	O
}	O
void	O
xmitEC	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
EC	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
EC	int
)	O
;	O
}	O
int	O
dosynch	function
(	O
void	O
)	O
{	O
netclear	function
(	O
)	O
;	O
NETADD	O
(	O
IAC	int
)	O
;	O
setneturg	function
(	O
)	O
;	O
NETADD	O
(	O
DM	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
DM	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
want_status_response	int
=	O
0	int
;	O
int	O
get_status	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
tmp	array
[	O
16	int
]	O
;	O
register	O
unsigned	O
char	O
*	O
cp	pointer
;	O
if	O
(	O
my_want_state_is_dont	O
(	O
TELOPT_STATUS	int
)	O
)	O
{	O
printf	function
(	O
"Remote side does not support STATUS option\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
cp	pointer
=	O
tmp	array
;	O
*	O
cp	pointer
++	O
=	O
IAC	int
;	O
*	O
cp	pointer
++	O
=	O
SB	int
;	O
*	O
cp	pointer
++	O
=	O
TELOPT_STATUS	int
;	O
*	O
cp	pointer
++	O
=	O
TELQUAL_SEND	int
;	O
*	O
cp	pointer
++	O
=	O
IAC	int
;	O
*	O
cp	pointer
++	O
=	O
SE	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>=	O
cp	pointer
-	O
tmp	array
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
tmp	array
,	O
cp	pointer
-	O
tmp	array
)	O
;	O
printsub	function
(	O
'>'	O
,	O
tmp	array
+	O
2	int
,	O
cp	pointer
-	O
tmp	array
-	O
2	int
)	O
;	O
}	O
++	O
want_status_response	int
;	O
return	O
1	int
;	O
}	O
void	O
intp	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
IP	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
IP	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	function
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	function
(	O
)	O
;	O
}	O
}	O
void	O
sendbrk	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
BREAK	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
BREAK	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	function
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	function
(	O
)	O
;	O
}	O
}	O
void	O
sendabort	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
ABORT	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
ABORT	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	function
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	function
(	O
)	O
;	O
}	O
}	O
void	O
sendsusp	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
SUSP	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
SUSP	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	function
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	function
(	O
)	O
;	O
}	O
}	O
void	O
sendeof	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
xEOF	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
xEOF	int
)	O
;	O
}	O
void	O
sendayt	function
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
AYT	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
AYT	int
)	O
;	O
}	O
void	O
sendnaws	function
(	O
void	O
)	O
{	O
long	O
rows	pointer
,	O
cols	pointer
;	O
unsigned	O
char	O
tmp	array
[	O
16	int
]	O
;	O
register	O
unsigned	O
char	O
*	O
cp	pointer
;	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_NAWS	int
)	O
)	O
return	O
;	O
if	O
(	O
TerminalWindowSize	function
(	O
&	O
rows	pointer
,	O
&	O
cols	pointer
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
cp	pointer
=	O
tmp	array
;	O
*	O
cp	pointer
++	O
=	O
IAC	int
;	O
*	O
cp	pointer
++	O
=	O
SB	int
;	O
*	O
cp	pointer
++	O
=	O
TELOPT_NAWS	int
;	O
PUTSHORT	O
(	O
cp	pointer
,	O
cols	pointer
)	O
;	O
PUTSHORT	O
(	O
cp	pointer
,	O
rows	pointer
)	O
;	O
*	O
cp	pointer
++	O
=	O
IAC	int
;	O
*	O
cp	pointer
++	O
=	O
SE	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>=	O
cp	pointer
-	O
tmp	array
)	O
{	O
ring_supply_data	function
(	O
&	O
netoring	struct
,	O
tmp	array
,	O
cp	pointer
-	O
tmp	array
)	O
;	O
printsub	function
(	O
'>'	O
,	O
tmp	array
+	O
2	int
,	O
cp	pointer
-	O
tmp	array
-	O
2	int
)	O
;	O
}	O
}	O
void	O
tel_enter_binary	function
(	O
int	O
rw	int
)	O
{	O
if	O
(	O
rw	int
&	O
1	int
)	O
send_do	function
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
if	O
(	O
rw	int
&	O
2	int
)	O
send_will	function
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
}	O
void	O
tel_leave_binary	function
(	O
int	O
rw	int
)	O
{	O
if	O
(	O
rw	int
&	O
1	int
)	O
send_dont	function
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
if	O
(	O
rw	int
&	O
2	int
)	O
send_wont	function
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
}	O