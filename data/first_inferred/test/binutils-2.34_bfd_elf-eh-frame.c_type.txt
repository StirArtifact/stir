struct	O
cie	struct
{	O
unsigned	O
int	O
length	int
;	O
unsigned	O
int	O
hash	long
;	O
unsigned	O
char	O
version	short
;	O
unsigned	O
char	O
local_personality	char
;	O
char	O
augmentation	array
[	O
20	int
]	O
;	O
bfd_vma	long
code_align	long
;	O
bfd_signed_vma	long
data_align	long
;	O
bfd_vma	long
ra_column	long
;	O
bfd_vma	long
augmentation_size	long
;	O
union	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
{	O
unsigned	O
int	O
bfd_id	int
;	O
unsigned	O
int	O
index	function
;	O
}	O
sym	pointer
;	O
unsigned	O
int	O
reloc_index	int
;	O
}	O
personality	union
;	O
struct	O
eh_cie_fde	struct
*	O
cie_inf	pointer
;	O
unsigned	O
char	O
per_encoding	char
;	O
unsigned	O
char	O
lsda_encoding	int
;	O
unsigned	O
char	O
fde_encoding	int
;	O
unsigned	O
char	O
initial_insn_length	char
;	O
unsigned	O
char	O
can_make_lsda_relative	char
;	O
unsigned	O
char	O
initial_instructions	array
[	O
50	int
]	O
;	O
}	O
;	O
static	O
inline	O
bfd_boolean	int
read_byte	function
(	O
bfd_byte	char
*	O
*	O
iter	pointer
,	O
bfd_byte	char
*	O
end	pointer
,	O
unsigned	O
char	O
*	O
result	pointer
)	O
{	O
if	O
(	O
*	O
iter	pointer
>=	O
end	pointer
)	O
return	O
FALSE	int
;	O
*	O
result	pointer
=	O
*	O
(	O
(	O
*	O
iter	pointer
)	O
++	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
inline	O
bfd_boolean	int
skip_bytes	function
(	O
bfd_byte	char
*	O
*	O
iter	pointer
,	O
bfd_byte	char
*	O
end	pointer
,	O
bfd_size_type	long
length	int
)	O
{	O
if	O
(	O
(	O
bfd_size_type	long
)	O
(	O
end	pointer
-	O
*	O
iter	pointer
)	O
<	O
length	int
)	O
{	O
*	O
iter	pointer
=	O
end	pointer
;	O
return	O
FALSE	int
;	O
}	O
*	O
iter	pointer
+=	O
length	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
skip_leb128	function
(	O
bfd_byte	char
*	O
*	O
iter	pointer
,	O
bfd_byte	char
*	O
end	pointer
)	O
{	O
unsigned	O
char	O
byte	char
;	O
do	O
if	O
(	O
!	O
read_byte	function
(	O
iter	pointer
,	O
end	pointer
,	O
&	O
byte	char
)	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
byte	char
&	O
0x80	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
read_uleb128	function
(	O
bfd_byte	char
*	O
*	O
iter	pointer
,	O
bfd_byte	char
*	O
end	pointer
,	O
bfd_vma	long
*	O
value	long
)	O
{	O
bfd_byte	char
*	O
start	pointer
,	O
*	O
p	pointer
;	O
start	pointer
=	O
*	O
iter	pointer
;	O
if	O
(	O
!	O
skip_leb128	function
(	O
iter	pointer
,	O
end	pointer
)	O
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
*	O
iter	pointer
;	O
*	O
value	long
=	O
*	O
--	O
p	pointer
;	O
while	O
(	O
p	pointer
>	O
start	pointer
)	O
*	O
value	long
=	O
(	O
*	O
value	long
<<	O
7	int
)	O
|	O
(	O
*	O
--	O
p	pointer
&	O
0x7f	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
read_sleb128	function
(	O
bfd_byte	char
*	O
*	O
iter	pointer
,	O
bfd_byte	char
*	O
end	pointer
,	O
bfd_signed_vma	long
*	O
value	long
)	O
{	O
bfd_byte	char
*	O
start	pointer
,	O
*	O
p	pointer
;	O
start	pointer
=	O
*	O
iter	pointer
;	O
if	O
(	O
!	O
skip_leb128	function
(	O
iter	pointer
,	O
end	pointer
)	O
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
*	O
iter	pointer
;	O
*	O
value	long
=	O
(	O
(	O
*	O
--	O
p	pointer
&	O
0x7f	int
)	O
^	O
0x40	int
)	O
-	O
0x40	int
;	O
while	O
(	O
p	pointer
>	O
start	pointer
)	O
*	O
value	long
=	O
(	O
*	O
value	long
<<	O
7	int
)	O
|	O
(	O
*	O
--	O
p	pointer
&	O
0x7f	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
get_DW_EH_PE_width	function
(	O
int	O
encoding	int
,	O
int	O
ptr_size	pointer
)	O
{	O
if	O
(	O
(	O
encoding	int
&	O
0x60	int
)	O
==	O
0x60	int
)	O
return	O
0	int
;	O
switch	O
(	O
encoding	int
&	O
7	int
)	O
{	O
case	O
DW_EH_PE_udata2	int
:	O
return	O
2	int
;	O
case	O
DW_EH_PE_udata4	int
:	O
return	O
4	int
;	O
case	O
DW_EH_PE_udata8	int
:	O
return	O
8	int
;	O
case	O
DW_EH_PE_absptr	int
:	O
return	O
ptr_size	pointer
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
bfd_vma	long
read_value	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
buf	pointer
,	O
int	O
width	int
,	O
int	O
is_signed	int
)	O
{	O
bfd_vma	long
value	long
;	O
switch	O
(	O
width	int
)	O
{	O
case	O
2	int
:	O
if	O
(	O
is_signed	int
)	O
value	long
=	O
bfd_get_signed_16	O
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
else	O
value	long
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
is_signed	int
)	O
value	long
=	O
bfd_get_signed_32	O
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
else	O
value	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
8	int
:	O
if	O
(	O
is_signed	int
)	O
value	long
=	O
bfd_get_signed_64	O
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
else	O
value	long
=	O
bfd_get_64	O
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
default	O
:	O
BFD_FAIL	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
value	long
;	O
}	O
static	O
void	O
write_value	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
buf	pointer
,	O
bfd_vma	long
value	long
,	O
int	O
width	int
)	O
{	O
switch	O
(	O
width	int
)	O
{	O
case	O
2	int
:	O
bfd_put_16	O
(	O
abfd	pointer
,	O
value	long
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
bfd_put_32	O
(	O
abfd	pointer
,	O
value	long
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
8	int
:	O
bfd_put_64	O
(	O
abfd	pointer
,	O
value	long
,	O
buf	pointer
)	O
;	O
break	O
;	O
default	O
:	O
BFD_FAIL	O
(	O
)	O
;	O
}	O
}	O
static	O
int	O
cie_eq	function
(	O
const	O
void	O
*	O
e1	pointer
,	O
const	O
void	O
*	O
e2	pointer
)	O
{	O
const	O
struct	O
cie	struct
*	O
c1	pointer
=	O
(	O
const	O
struct	O
cie	struct
*	O
)	O
e1	pointer
;	O
const	O
struct	O
cie	struct
*	O
c2	pointer
=	O
(	O
const	O
struct	O
cie	struct
*	O
)	O
e2	pointer
;	O
if	O
(	O
c1	pointer
->	O
hash	long
==	O
c2	pointer
->	O
hash	long
&&	O
c1	pointer
->	O
length	int
==	O
c2	pointer
->	O
length	int
&&	O
c1	pointer
->	O
version	short
==	O
c2	pointer
->	O
version	short
&&	O
c1	pointer
->	O
local_personality	char
==	O
c2	pointer
->	O
local_personality	char
&&	O
strcmp	function
(	O
c1	pointer
->	O
augmentation	array
,	O
c2	pointer
->	O
augmentation	array
)	O
==	O
0	int
&&	O
strcmp	function
(	O
c1	pointer
->	O
augmentation	array
,	O
"eh"	pointer
)	O
!=	O
0	int
&&	O
c1	pointer
->	O
code_align	long
==	O
c2	pointer
->	O
code_align	long
&&	O
c1	pointer
->	O
data_align	long
==	O
c2	pointer
->	O
data_align	long
&&	O
c1	pointer
->	O
ra_column	long
==	O
c2	pointer
->	O
ra_column	long
&&	O
c1	pointer
->	O
augmentation_size	long
==	O
c2	pointer
->	O
augmentation_size	long
&&	O
memcmp	function
(	O
&	O
c1	pointer
->	O
personality	union
,	O
&	O
c2	pointer
->	O
personality	union
,	O
sizeof	O
(	O
c1	pointer
->	O
personality	union
)	O
)	O
==	O
0	int
&&	O
(	O
c1	pointer
->	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
sec	pointer
->	O
output_section	pointer
==	O
c2	pointer
->	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
sec	pointer
->	O
output_section	pointer
)	O
&&	O
c1	pointer
->	O
per_encoding	char
==	O
c2	pointer
->	O
per_encoding	char
&&	O
c1	pointer
->	O
lsda_encoding	int
==	O
c2	pointer
->	O
lsda_encoding	int
&&	O
c1	pointer
->	O
fde_encoding	int
==	O
c2	pointer
->	O
fde_encoding	int
&&	O
c1	pointer
->	O
initial_insn_length	char
==	O
c2	pointer
->	O
initial_insn_length	char
&&	O
c1	pointer
->	O
initial_insn_length	char
<=	O
sizeof	O
(	O
c1	pointer
->	O
initial_instructions	array
)	O
&&	O
memcmp	function
(	O
c1	pointer
->	O
initial_instructions	array
,	O
c2	pointer
->	O
initial_instructions	array
,	O
c1	pointer
->	O
initial_insn_length	char
)	O
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
hashval_t	int
cie_hash	function
(	O
const	O
void	O
*	O
e	pointer
)	O
{	O
const	O
struct	O
cie	struct
*	O
c	struct
=	O
(	O
const	O
struct	O
cie	struct
*	O
)	O
e	pointer
;	O
return	O
c	struct
->	O
hash	long
;	O
}	O
static	O
hashval_t	int
cie_compute_hash	function
(	O
struct	O
cie	struct
*	O
c	struct
)	O
{	O
hashval_t	int
h	pointer
=	O
0	int
;	O
size_t	long
len	long
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
length	int
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
version	short
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash	function
(	O
c	struct
->	O
augmentation	array
,	O
strlen	function
(	O
c	struct
->	O
augmentation	array
)	O
+	O
1	int
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
code_align	long
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
data_align	long
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
ra_column	long
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
augmentation_size	long
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
personality	union
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
sec	pointer
->	O
output_section	pointer
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
per_encoding	char
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
lsda_encoding	int
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
fde_encoding	int
,	O
h	pointer
)	O
;	O
h	pointer
=	O
iterative_hash_object	O
(	O
c	struct
->	O
initial_insn_length	char
,	O
h	pointer
)	O
;	O
len	long
=	O
c	struct
->	O
initial_insn_length	char
;	O
if	O
(	O
len	long
>	O
sizeof	O
(	O
c	struct
->	O
initial_instructions	array
)	O
)	O
len	long
=	O
sizeof	O
(	O
c	struct
->	O
initial_instructions	array
)	O
;	O
h	pointer
=	O
iterative_hash	function
(	O
c	struct
->	O
initial_instructions	array
,	O
len	long
,	O
h	pointer
)	O
;	O
c	struct
->	O
hash	long
=	O
h	pointer
;	O
return	O
h	pointer
;	O
}	O
static	O
INLINE	O
unsigned	O
int	O
extra_augmentation_string_bytes	function
(	O
struct	O
eh_cie_fde	struct
*	O
entry	pointer
)	O
{	O
unsigned	O
int	O
size	long
=	O
0	int
;	O
if	O
(	O
entry	pointer
->	O
cie	struct
)	O
{	O
if	O
(	O
entry	pointer
->	O
add_augmentation_size	int
)	O
size	long
++	O
;	O
if	O
(	O
entry	pointer
->	O
u	union
.	O
cie	struct
.	O
add_fde_encoding	int
)	O
size	long
++	O
;	O
}	O
return	O
size	long
;	O
}	O
static	O
INLINE	O
unsigned	O
int	O
extra_augmentation_data_bytes	function
(	O
struct	O
eh_cie_fde	struct
*	O
entry	pointer
)	O
{	O
unsigned	O
int	O
size	long
=	O
0	int
;	O
if	O
(	O
entry	pointer
->	O
add_augmentation_size	int
)	O
size	long
++	O
;	O
if	O
(	O
entry	pointer
->	O
cie	struct
&&	O
entry	pointer
->	O
u	union
.	O
cie	struct
.	O
add_fde_encoding	int
)	O
size	long
++	O
;	O
return	O
size	long
;	O
}	O
static	O
unsigned	O
int	O
size_of_output_cie_fde	function
(	O
struct	O
eh_cie_fde	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
removed	int
)	O
return	O
0	int
;	O
if	O
(	O
entry	pointer
->	O
size	long
==	O
4	int
)	O
return	O
4	int
;	O
return	O
(	O
entry	pointer
->	O
size	long
+	O
extra_augmentation_string_bytes	function
(	O
entry	pointer
)	O
+	O
extra_augmentation_data_bytes	function
(	O
entry	pointer
)	O
)	O
;	O
}	O
static	O
unsigned	O
int	O
next_cie_fde_offset	function
(	O
const	O
struct	O
eh_cie_fde	struct
*	O
ent	pointer
,	O
const	O
struct	O
eh_cie_fde	struct
*	O
last	pointer
,	O
const	O
asection	struct
*	O
sec	pointer
)	O
{	O
while	O
(	O
++	O
ent	pointer
<	O
last	pointer
)	O
{	O
if	O
(	O
!	O
ent	pointer
->	O
removed	int
)	O
return	O
ent	pointer
->	O
new_offset	int
;	O
}	O
return	O
sec	pointer
->	O
size	long
;	O
}	O
static	O
bfd_boolean	int
skip_cfa_op	function
(	O
bfd_byte	char
*	O
*	O
iter	pointer
,	O
bfd_byte	char
*	O
end	pointer
,	O
unsigned	O
int	O
encoded_ptr_width	int
)	O
{	O
bfd_byte	char
op	int
;	O
bfd_vma	long
length	int
;	O
if	O
(	O
!	O
read_byte	function
(	O
iter	pointer
,	O
end	pointer
,	O
&	O
op	int
)	O
)	O
return	O
FALSE	int
;	O
switch	O
(	O
op	int
&	O
0xc0	int
?	O
op	int
&	O
0xc0	int
:	O
op	int
)	O
{	O
case	O
DW_CFA_nop	int
:	O
case	O
DW_CFA_advance_loc	int
:	O
case	O
DW_CFA_restore	int
:	O
case	O
DW_CFA_remember_state	int
:	O
case	O
DW_CFA_restore_state	int
:	O
case	O
DW_CFA_GNU_window_save	int
:	O
return	O
TRUE	int
;	O
case	O
DW_CFA_offset	int
:	O
case	O
DW_CFA_restore_extended	int
:	O
case	O
DW_CFA_undefined	int
:	O
case	O
DW_CFA_same_value	int
:	O
case	O
DW_CFA_def_cfa_register	int
:	O
case	O
DW_CFA_def_cfa_offset	int
:	O
case	O
DW_CFA_def_cfa_offset_sf	int
:	O
case	O
DW_CFA_GNU_args_size	int
:	O
return	O
skip_leb128	function
(	O
iter	pointer
,	O
end	pointer
)	O
;	O
case	O
DW_CFA_val_offset	int
:	O
case	O
DW_CFA_val_offset_sf	int
:	O
case	O
DW_CFA_offset_extended	int
:	O
case	O
DW_CFA_register	int
:	O
case	O
DW_CFA_def_cfa	int
:	O
case	O
DW_CFA_offset_extended_sf	int
:	O
case	O
DW_CFA_GNU_negative_offset_extended	int
:	O
case	O
DW_CFA_def_cfa_sf	int
:	O
return	O
(	O
skip_leb128	function
(	O
iter	pointer
,	O
end	pointer
)	O
&&	O
skip_leb128	function
(	O
iter	pointer
,	O
end	pointer
)	O
)	O
;	O
case	O
DW_CFA_def_cfa_expression	int
:	O
return	O
(	O
read_uleb128	function
(	O
iter	pointer
,	O
end	pointer
,	O
&	O
length	int
)	O
&&	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
length	int
)	O
)	O
;	O
case	O
DW_CFA_expression	int
:	O
case	O
DW_CFA_val_expression	int
:	O
return	O
(	O
skip_leb128	function
(	O
iter	pointer
,	O
end	pointer
)	O
&&	O
read_uleb128	function
(	O
iter	pointer
,	O
end	pointer
,	O
&	O
length	int
)	O
&&	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
length	int
)	O
)	O
;	O
case	O
DW_CFA_set_loc	int
:	O
return	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
encoded_ptr_width	int
)	O
;	O
case	O
DW_CFA_advance_loc1	int
:	O
return	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
1	int
)	O
;	O
case	O
DW_CFA_advance_loc2	int
:	O
return	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
2	int
)	O
;	O
case	O
DW_CFA_advance_loc4	int
:	O
return	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
4	int
)	O
;	O
case	O
DW_CFA_MIPS_advance_loc8	int
:	O
return	O
skip_bytes	function
(	O
iter	pointer
,	O
end	pointer
,	O
8	int
)	O
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_byte	char
*	O
skip_non_nops	function
(	O
bfd_byte	char
*	O
buf	pointer
,	O
bfd_byte	char
*	O
end	pointer
,	O
unsigned	O
int	O
encoded_ptr_width	int
,	O
unsigned	O
int	O
*	O
set_loc_count	pointer
)	O
{	O
bfd_byte	char
*	O
last	pointer
;	O
last	pointer
=	O
buf	pointer
;	O
while	O
(	O
buf	pointer
<	O
end	pointer
)	O
if	O
(	O
*	O
buf	pointer
==	O
DW_CFA_nop	int
)	O
buf	pointer
++	O
;	O
else	O
{	O
if	O
(	O
*	O
buf	pointer
==	O
DW_CFA_set_loc	int
)	O
++	O
*	O
set_loc_count	pointer
;	O
if	O
(	O
!	O
skip_cfa_op	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
encoded_ptr_width	int
)	O
)	O
return	O
0	int
;	O
last	pointer
=	O
buf	pointer
;	O
}	O
return	O
last	pointer
;	O
}	O
static	O
unsigned	O
char	O
make_pc_relative	function
(	O
unsigned	O
char	O
encoding	int
,	O
unsigned	O
int	O
ptr_size	pointer
)	O
{	O
if	O
(	O
(	O
encoding	int
&	O
0x7f	int
)	O
==	O
DW_EH_PE_absptr	int
)	O
switch	O
(	O
ptr_size	pointer
)	O
{	O
case	O
2	int
:	O
encoding	int
|=	O
DW_EH_PE_sdata2	int
;	O
break	O
;	O
case	O
4	int
:	O
encoding	int
|=	O
DW_EH_PE_sdata4	int
;	O
break	O
;	O
case	O
8	int
:	O
encoding	int
|=	O
DW_EH_PE_sdata8	int
;	O
break	O
;	O
}	O
return	O
encoding	int
|	O
DW_EH_PE_pcrel	int
;	O
}	O
static	O
void	O
bfd_elf_discard_eh_frame_entry	function
(	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr_info	pointer
->	O
array_count	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
i	pointer
+	O
1	int
;	O
j	int
<	O
hdr_info	pointer
->	O
array_count	int
;	O
j	int
++	O
)	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
j	int
-	O
1	int
]	O
=	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
j	int
]	O
;	O
hdr_info	pointer
->	O
array_count	int
--	O
;	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
hdr_info	pointer
->	O
array_count	int
]	O
=	O
NULL	O
;	O
i	pointer
--	O
;	O
}	O
}	O
}	O
static	O
void	O
bfd_elf_record_eh_frame_entry	function
(	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
hdr_info	pointer
->	O
array_count	int
==	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
allocated_entries	int
)	O
{	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
allocated_entries	int
==	O
0	int
)	O
{	O
hdr_info	pointer
->	O
frame_hdr_is_compact	int
=	O
TRUE	int
;	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
allocated_entries	int
=	O
2	int
;	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
=	O
bfd_malloc	function
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
allocated_entries	int
*	O
sizeof	O
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
allocated_entries	int
*=	O
2	int
;	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
=	O
bfd_realloc	function
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
,	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
allocated_entries	int
*	O
sizeof	O
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
BFD_ASSERT	O
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
)	O
;	O
}	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
hdr_info	pointer
->	O
array_count	int
++	O
]	O
=	O
sec	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_parse_eh_frame_entry	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
unsigned	O
long	O
r_symndx	long
;	O
asection	struct
*	O
text_sec	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
if	O
(	O
sec	pointer
->	O
size	long
==	O
0	int
||	O
sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_NONE	int
)	O
{	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
sec	pointer
->	O
output_section	pointer
&&	O
bfd_is_abs_section	function
(	O
sec	pointer
->	O
output_section	pointer
)	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
cookie	pointer
->	O
rel	pointer
==	O
cookie	pointer
->	O
relend	pointer
)	O
return	O
FALSE	int
;	O
r_symndx	long
=	O
cookie	pointer
->	O
rel	pointer
->	O
r_info	array
>>	O
cookie	pointer
->	O
r_sym_shift	int
;	O
if	O
(	O
r_symndx	long
==	O
STN_UNDEF	int
)	O
return	O
FALSE	int
;	O
text_sec	pointer
=	O
_bfd_elf_section_for_symbol	function
(	O
cookie	pointer
,	O
r_symndx	long
,	O
FALSE	int
)	O
;	O
if	O
(	O
text_sec	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_section_eh_frame_entry	O
(	O
text_sec	pointer
)	O
=	O
sec	pointer
;	O
if	O
(	O
text_sec	pointer
->	O
output_section	pointer
&&	O
bfd_is_abs_section	function
(	O
text_sec	pointer
->	O
output_section	pointer
)	O
)	O
sec	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
sec	pointer
->	O
sec_info_type	int
=	O
SEC_INFO_TYPE_EH_FRAME_ENTRY	int
;	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
=	O
text_sec	pointer
;	O
bfd_elf_record_eh_frame_entry	function
(	O
hdr_info	pointer
,	O
sec	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_elf_parse_eh_frame	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
bfd_byte	char
*	O
ehbuf	pointer
=	O
NULL	O
,	O
*	O
buf	pointer
,	O
*	O
end	pointer
;	O
bfd_byte	char
*	O
last_fde	pointer
;	O
struct	O
eh_cie_fde	struct
*	O
this_inf	pointer
;	O
unsigned	O
int	O
hdr_length	int
,	O
hdr_id	int
;	O
unsigned	O
int	O
cie_count	int
;	O
struct	O
cie	struct
*	O
cie	struct
,	O
*	O
local_cies	pointer
=	O
NULL	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
struct	O
eh_frame_sec_info	struct
*	O
sec_info	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
ptr_size	pointer
;	O
unsigned	O
int	O
num_cies	int
;	O
unsigned	O
int	O
num_entries	int
;	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
if	O
(	O
sec	pointer
->	O
size	long
==	O
0	int
||	O
sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_NONE	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
bfd_is_abs_section	function
(	O
sec	pointer
->	O
output_section	pointer
)	O
)	O
{	O
return	O
;	O
}	O
REQUIRE	O
(	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
&	O
ehbuf	pointer
)	O
)	O
;	O
REQUIRE	O
(	O
sec	pointer
->	O
size	long
==	O
(	O
unsigned	O
int	O
)	O
sec	pointer
->	O
size	long
)	O
;	O
ptr_size	pointer
=	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_backend_eh_frame_address_size	pointer
(	O
abfd	pointer
,	O
sec	pointer
)	O
)	O
;	O
REQUIRE	O
(	O
ptr_size	pointer
!=	O
0	int
)	O
;	O
buf	pointer
=	O
ehbuf	pointer
;	O
end	pointer
=	O
ehbuf	pointer
+	O
sec	pointer
->	O
size	long
;	O
num_cies	int
=	O
0	int
;	O
num_entries	int
=	O
0	int
;	O
while	O
(	O
buf	pointer
!=	O
end	pointer
)	O
{	O
num_entries	int
++	O
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
4	int
)	O
)	O
;	O
hdr_length	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
buf	pointer
-	O
4	int
)	O
;	O
REQUIRE	O
(	O
hdr_length	int
!=	O
0xffffffff	int
)	O
;	O
if	O
(	O
hdr_length	int
==	O
0	int
)	O
break	O
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
4	int
)	O
)	O
;	O
hdr_id	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
buf	pointer
-	O
4	int
)	O
;	O
if	O
(	O
hdr_id	int
==	O
0	int
)	O
num_cies	int
++	O
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
hdr_length	int
-	O
4	int
)	O
)	O
;	O
}	O
sec_info	pointer
=	O
(	O
struct	O
eh_frame_sec_info	struct
*	O
)	O
bfd_zmalloc	function
(	O
sizeof	O
(	O
struct	O
eh_frame_sec_info	struct
)	O
+	O
(	O
num_entries	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
eh_cie_fde	struct
)	O
)	O
;	O
REQUIRE	O
(	O
sec_info	pointer
)	O
;	O
if	O
(	O
num_cies	int
)	O
{	O
local_cies	pointer
=	O
(	O
struct	O
cie	struct
*	O
)	O
bfd_zmalloc	function
(	O
num_cies	int
*	O
sizeof	O
(	O
*	O
local_cies	pointer
)	O
)	O
;	O
REQUIRE	O
(	O
local_cies	pointer
)	O
;	O
}	O
buf	pointer
=	O
ehbuf	pointer
;	O
cie_count	int
=	O
0	int
;	O
gc_mark_hook	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
gc_mark_hook	pointer
;	O
while	O
(	O
(	O
bfd_size_type	long
)	O
(	O
buf	pointer
-	O
ehbuf	pointer
)	O
!=	O
sec	pointer
->	O
size	long
)	O
{	O
char	O
*	O
aug	pointer
;	O
bfd_byte	char
*	O
start	pointer
,	O
*	O
insns	pointer
,	O
*	O
insns_end	pointer
;	O
bfd_size_type	long
length	int
;	O
unsigned	O
int	O
set_loc_count	pointer
;	O
this_inf	pointer
=	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
last_fde	pointer
=	O
buf	pointer
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
ehbuf	pointer
+	O
sec	pointer
->	O
size	long
,	O
4	int
)	O
)	O
;	O
hdr_length	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
buf	pointer
-	O
4	int
)	O
;	O
REQUIRE	O
(	O
(	O
bfd_size_type	long
)	O
(	O
buf	pointer
-	O
ehbuf	pointer
)	O
+	O
hdr_length	int
<=	O
sec	pointer
->	O
size	long
)	O
;	O
end	pointer
=	O
buf	pointer
+	O
hdr_length	int
;	O
this_inf	pointer
->	O
offset	long
=	O
last_fde	pointer
-	O
ehbuf	pointer
;	O
this_inf	pointer
->	O
size	long
=	O
4	int
+	O
hdr_length	int
;	O
this_inf	pointer
->	O
reloc_index	int
=	O
cookie	pointer
->	O
rel	pointer
-	O
cookie	pointer
->	O
rels	pointer
;	O
if	O
(	O
hdr_length	int
==	O
0	int
)	O
{	O
while	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
ehbuf	pointer
+	O
sec	pointer
->	O
size	long
,	O
4	int
)	O
)	O
REQUIRE	O
(	O
bfd_get_32	O
(	O
abfd	pointer
,	O
buf	pointer
-	O
4	int
)	O
==	O
0	int
)	O
;	O
REQUIRE	O
(	O
(	O
bfd_size_type	long
)	O
(	O
buf	pointer
-	O
ehbuf	pointer
)	O
==	O
sec	pointer
->	O
size	long
)	O
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
sec_info	pointer
->	O
count	int
++	O
;	O
break	O
;	O
}	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
4	int
)	O
)	O
;	O
hdr_id	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
buf	pointer
-	O
4	int
)	O
;	O
if	O
(	O
hdr_id	int
==	O
0	int
)	O
{	O
unsigned	O
int	O
initial_insn_length	char
;	O
this_inf	pointer
->	O
cie	struct
=	O
1	int
;	O
cie	struct
=	O
local_cies	pointer
+	O
cie_count	int
++	O
;	O
cie	struct
->	O
cie_inf	pointer
=	O
this_inf	pointer
;	O
cie	struct
->	O
length	int
=	O
hdr_length	int
;	O
start	pointer
=	O
buf	pointer
;	O
REQUIRE	O
(	O
read_byte	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
version	short
)	O
)	O
;	O
REQUIRE	O
(	O
cie	struct
->	O
version	short
==	O
1	int
||	O
cie	struct
->	O
version	short
==	O
3	int
||	O
cie	struct
->	O
version	short
==	O
4	int
)	O
;	O
REQUIRE	O
(	O
strlen	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
)	O
<	O
sizeof	O
(	O
cie	struct
->	O
augmentation	array
)	O
)	O
;	O
strcpy	function
(	O
cie	struct
->	O
augmentation	array
,	O
(	O
char	O
*	O
)	O
buf	pointer
)	O
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
strchr	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
'\0'	O
)	O
+	O
1	int
;	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
aug_str_len	int
=	O
buf	pointer
-	O
start	pointer
-	O
1	int
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'e'	O
&&	O
buf	pointer
[	O
1	int
]	O
==	O
'h'	O
)	O
{	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
ptr_size	pointer
)	O
)	O
;	O
SKIP_RELOCS	O
(	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
cie	struct
->	O
version	short
>=	O
4	int
)	O
{	O
REQUIRE	O
(	O
buf	pointer
+	O
1	int
<	O
end	pointer
)	O
;	O
REQUIRE	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
ptr_size	pointer
)	O
;	O
REQUIRE	O
(	O
buf	pointer
[	O
1	int
]	O
==	O
0	int
)	O
;	O
buf	pointer
+=	O
2	int
;	O
}	O
REQUIRE	O
(	O
read_uleb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
code_align	long
)	O
)	O
;	O
REQUIRE	O
(	O
read_sleb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
data_align	long
)	O
)	O
;	O
if	O
(	O
cie	struct
->	O
version	short
==	O
1	int
)	O
{	O
REQUIRE	O
(	O
buf	pointer
<	O
end	pointer
)	O
;	O
cie	struct
->	O
ra_column	long
=	O
*	O
buf	pointer
++	O
;	O
}	O
else	O
REQUIRE	O
(	O
read_uleb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
ra_column	long
)	O
)	O
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
cie	struct
->	O
lsda_encoding	int
=	O
DW_EH_PE_omit	int
;	O
cie	struct
->	O
fde_encoding	int
=	O
DW_EH_PE_omit	int
;	O
cie	struct
->	O
per_encoding	char
=	O
DW_EH_PE_omit	int
;	O
aug	pointer
=	O
cie	struct
->	O
augmentation	array
;	O
if	O
(	O
aug	pointer
[	O
0	int
]	O
!=	O
'e'	O
||	O
aug	pointer
[	O
1	int
]	O
!=	O
'h'	O
)	O
{	O
if	O
(	O
*	O
aug	pointer
==	O
'z'	O
)	O
{	O
aug	pointer
++	O
;	O
REQUIRE	O
(	O
read_uleb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
augmentation_size	long
)	O
)	O
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
}	O
while	O
(	O
*	O
aug	pointer
!=	O
'\0'	O
)	O
switch	O
(	O
*	O
aug	pointer
++	O
)	O
{	O
case	O
'B'	O
:	O
break	O
;	O
case	O
'L'	O
:	O
REQUIRE	O
(	O
read_byte	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
lsda_encoding	int
)	O
)	O
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
REQUIRE	O
(	O
get_DW_EH_PE_width	function
(	O
cie	struct
->	O
lsda_encoding	int
,	O
ptr_size	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
REQUIRE	O
(	O
read_byte	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
fde_encoding	int
)	O
)	O
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
REQUIRE	O
(	O
get_DW_EH_PE_width	function
(	O
cie	struct
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
break	O
;	O
case	O
'P'	O
:	O
{	O
int	O
per_width	int
;	O
REQUIRE	O
(	O
read_byte	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
cie	struct
->	O
per_encoding	char
)	O
)	O
;	O
per_width	int
=	O
get_DW_EH_PE_width	function
(	O
cie	struct
->	O
per_encoding	char
,	O
ptr_size	pointer
)	O
;	O
REQUIRE	O
(	O
per_width	int
)	O
;	O
if	O
(	O
(	O
cie	struct
->	O
per_encoding	char
&	O
0x70	int
)	O
==	O
DW_EH_PE_aligned	int
)	O
{	O
length	int
=	O
-	O
(	O
buf	pointer
-	O
ehbuf	pointer
)	O
&	O
(	O
per_width	int
-	O
1	int
)	O
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
length	int
)	O
)	O
;	O
if	O
(	O
per_width	int
==	O
8	int
)	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_aligned8	int
=	O
1	int
;	O
}	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
personality_offset	int
=	O
buf	pointer
-	O
start	pointer
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
REQUIRE	O
(	O
GET_RELOC	O
(	O
buf	pointer
)	O
)	O
;	O
cie	struct
->	O
personality	union
.	O
reloc_index	int
=	O
cookie	pointer
->	O
rel	pointer
-	O
cookie	pointer
->	O
rels	pointer
;	O
do	O
cookie	pointer
->	O
rel	pointer
++	O
;	O
while	O
(	O
GET_RELOC	O
(	O
buf	pointer
)	O
!=	O
NULL	O
)	O
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
per_width	int
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
goto	O
free_no_table	O
;	O
}	O
}	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
aug_data_len	int
=	O
buf	pointer
-	O
start	pointer
-	O
1	int
-	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
aug_str_len	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_backend_can_make_relative_eh_frame	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
)	O
)	O
)	O
{	O
if	O
(	O
(	O
cie	struct
->	O
fde_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_absptr	int
)	O
this_inf	pointer
->	O
make_relative	int
=	O
1	int
;	O
else	O
if	O
(	O
cie	struct
->	O
fde_encoding	int
==	O
DW_EH_PE_omit	int
&&	O
(	O
cie	struct
->	O
per_encoding	char
&	O
0x70	int
)	O
!=	O
DW_EH_PE_aligned	int
)	O
{	O
if	O
(	O
*	O
cie	struct
->	O
augmentation	array
==	O
0	int
)	O
this_inf	pointer
->	O
add_augmentation_size	int
=	O
1	int
;	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
add_fde_encoding	int
=	O
1	int
;	O
this_inf	pointer
->	O
make_relative	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
cie	struct
->	O
lsda_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_absptr	int
)	O
cie	struct
->	O
can_make_lsda_relative	char
=	O
1	int
;	O
}	O
if	O
(	O
cie	struct
->	O
fde_encoding	int
==	O
DW_EH_PE_omit	int
)	O
cie	struct
->	O
fde_encoding	int
=	O
DW_EH_PE_absptr	int
;	O
initial_insn_length	char
=	O
end	pointer
-	O
buf	pointer
;	O
cie	struct
->	O
initial_insn_length	char
=	O
initial_insn_length	char
;	O
memcpy	function
(	O
cie	struct
->	O
initial_instructions	array
,	O
buf	pointer
,	O
initial_insn_length	char
<=	O
sizeof	O
(	O
cie	struct
->	O
initial_instructions	array
)	O
?	O
initial_insn_length	char
:	O
sizeof	O
(	O
cie	struct
->	O
initial_instructions	array
)	O
)	O
;	O
insns	pointer
=	O
buf	pointer
;	O
buf	pointer
+=	O
initial_insn_length	char
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
full_cie	pointer
=	O
cie	struct
;	O
this_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_relative	int
=	O
(	O
cie	struct
->	O
per_encoding	char
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
cie_offset	int
=	O
this_inf	pointer
->	O
offset	long
+	O
4	int
-	O
hdr_id	int
;	O
for	O
(	O
cie	struct
=	O
local_cies	pointer
;	O
cie	struct
<	O
local_cies	pointer
+	O
cie_count	int
;	O
cie	struct
++	O
)	O
if	O
(	O
cie_offset	int
==	O
cie	struct
->	O
cie_inf	pointer
->	O
offset	long
)	O
break	O
;	O
REQUIRE	O
(	O
cie	struct
!=	O
local_cies	pointer
+	O
cie_count	int
)	O
;	O
this_inf	pointer
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
=	O
cie	struct
->	O
cie_inf	pointer
;	O
this_inf	pointer
->	O
make_relative	int
=	O
cie	struct
->	O
cie_inf	pointer
->	O
make_relative	int
;	O
this_inf	pointer
->	O
add_augmentation_size	int
=	O
cie	struct
->	O
cie_inf	pointer
->	O
add_augmentation_size	int
;	O
ENSURE_NO_RELOCS	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
||	O
cookie	pointer
->	O
rels	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
rsec	pointer
;	O
REQUIRE	O
(	O
GET_RELOC	O
(	O
buf	pointer
)	O
)	O
;	O
rsec	pointer
=	O
_bfd_elf_gc_mark_rsec	function
(	O
info	pointer
,	O
sec	pointer
,	O
gc_mark_hook	pointer
,	O
cookie	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rsec	pointer
)	O
{	O
REQUIRE	O
(	O
rsec	pointer
->	O
owner	pointer
==	O
abfd	pointer
)	O
;	O
this_inf	pointer
->	O
u	union
.	O
fde	struct
.	O
next_for_section	pointer
=	O
elf_fde_list	O
(	O
rsec	pointer
)	O
;	O
elf_fde_list	O
(	O
rsec	pointer
)	O
=	O
this_inf	pointer
;	O
}	O
}	O
start	pointer
=	O
buf	pointer
;	O
length	int
=	O
get_DW_EH_PE_width	function
(	O
cie	struct
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
2	int
*	O
length	int
)	O
)	O
;	O
SKIP_RELOCS	O
(	O
buf	pointer
-	O
length	int
)	O
;	O
if	O
(	O
!	O
GET_RELOC	O
(	O
buf	pointer
-	O
length	int
)	O
&&	O
read_value	function
(	O
abfd	pointer
,	O
buf	pointer
-	O
length	int
,	O
length	int
,	O
FALSE	int
)	O
==	O
0	int
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
)	O
(	O
_	O
(	O
"discarding zero address range FDE in %pB(%pA).\n"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
this_inf	pointer
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
cie	struct
->	O
augmentation	array
[	O
0	int
]	O
==	O
'z'	O
)	O
REQUIRE	O
(	O
read_uleb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
&	O
length	int
)	O
)	O
;	O
else	O
length	int
=	O
0	int
;	O
if	O
(	O
cie	struct
->	O
lsda_encoding	int
!=	O
DW_EH_PE_omit	int
)	O
{	O
SKIP_RELOCS	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
cie	struct
->	O
can_make_lsda_relative	char
&&	O
GET_RELOC	O
(	O
buf	pointer
)	O
)	O
cie	struct
->	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
=	O
1	int
;	O
this_inf	pointer
->	O
lsda_offset	int
=	O
buf	pointer
-	O
start	pointer
;	O
if	O
(	O
cie	struct
->	O
augmentation	array
[	O
0	int
]	O
!=	O
'z'	O
)	O
length	int
=	O
end	pointer
-	O
buf	pointer
;	O
}	O
REQUIRE	O
(	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
length	int
)	O
)	O
;	O
insns	pointer
=	O
buf	pointer
;	O
buf	pointer
=	O
last_fde	pointer
+	O
4	int
+	O
hdr_length	int
;	O
SKIP_RELOCS	O
(	O
buf	pointer
)	O
;	O
}	O
length	int
=	O
get_DW_EH_PE_width	function
(	O
cie	struct
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
set_loc_count	pointer
=	O
0	int
;	O
insns_end	pointer
=	O
skip_non_nops	function
(	O
insns	pointer
,	O
end	pointer
,	O
length	int
,	O
&	O
set_loc_count	pointer
)	O
;	O
if	O
(	O
insns_end	pointer
==	O
NULL	O
||	O
(	O
set_loc_count	pointer
&&	O
this_inf	pointer
->	O
cie	struct
)	O
)	O
goto	O
free_no_table	O
;	O
this_inf	pointer
->	O
size	long
-=	O
end	pointer
-	O
insns_end	pointer
;	O
if	O
(	O
insns_end	pointer
!=	O
end	pointer
&&	O
this_inf	pointer
->	O
cie	struct
)	O
{	O
cie	struct
->	O
initial_insn_length	char
-=	O
end	pointer
-	O
insns_end	pointer
;	O
cie	struct
->	O
length	int
-=	O
end	pointer
-	O
insns_end	pointer
;	O
}	O
if	O
(	O
set_loc_count	pointer
&&	O
(	O
(	O
cie	struct
->	O
fde_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
||	O
this_inf	pointer
->	O
make_relative	int
)	O
)	O
{	O
unsigned	O
int	O
cnt	int
;	O
bfd_byte	char
*	O
p	pointer
;	O
this_inf	pointer
->	O
set_loc	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
bfd_malloc	function
(	O
(	O
set_loc_count	pointer
+	O
1	int
)	O
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
REQUIRE	O
(	O
this_inf	pointer
->	O
set_loc	pointer
)	O
;	O
this_inf	pointer
->	O
set_loc	pointer
[	O
0	int
]	O
=	O
set_loc_count	pointer
;	O
p	pointer
=	O
insns	pointer
;	O
cnt	int
=	O
0	int
;	O
while	O
(	O
p	pointer
<	O
end	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
DW_CFA_set_loc	int
)	O
this_inf	pointer
->	O
set_loc	pointer
[	O
++	O
cnt	int
]	O
=	O
p	pointer
+	O
1	int
-	O
start	pointer
;	O
REQUIRE	O
(	O
skip_cfa_op	function
(	O
&	O
p	pointer
,	O
end	pointer
,	O
length	int
)	O
)	O
;	O
}	O
}	O
this_inf	pointer
->	O
removed	int
=	O
1	int
;	O
this_inf	pointer
->	O
fde_encoding	int
=	O
cie	struct
->	O
fde_encoding	int
;	O
this_inf	pointer
->	O
lsda_encoding	int
=	O
cie	struct
->	O
lsda_encoding	int
;	O
sec_info	pointer
->	O
count	int
++	O
;	O
}	O
BFD_ASSERT	O
(	O
sec_info	pointer
->	O
count	int
==	O
num_entries	int
)	O
;	O
BFD_ASSERT	O
(	O
cie_count	int
==	O
num_cies	int
)	O
;	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
=	O
sec_info	pointer
;	O
sec	pointer
->	O
sec_info_type	int
=	O
SEC_INFO_TYPE_EH_FRAME	int
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
sec_info	pointer
->	O
cies	pointer
=	O
local_cies	pointer
;	O
local_cies	pointer
=	O
NULL	O
;	O
}	O
goto	O
success	O
;	O
free_no_table	O
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"error in %pB(%pA); no .eh_frame_hdr table will be created"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
table	pointer
=	O
FALSE	int
;	O
if	O
(	O
sec_info	pointer
)	O
free	function
(	O
sec_info	pointer
)	O
;	O
success	O
:	O
if	O
(	O
ehbuf	pointer
)	O
free	function
(	O
ehbuf	pointer
)	O
;	O
if	O
(	O
local_cies	pointer
)	O
free	function
(	O
local_cies	pointer
)	O
;	O
}	O
static	O
int	O
cmp_eh_frame_hdr	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
bfd_vma	long
text_a	long
;	O
bfd_vma	long
text_b	long
;	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
*	O
(	O
asection	struct
*	O
const	O
*	O
)	O
a	pointer
;	O
sec	pointer
=	O
(	O
asection	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
text_a	long
=	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
;	O
sec	pointer
=	O
*	O
(	O
asection	struct
*	O
const	O
*	O
)	O
b	pointer
;	O
sec	pointer
=	O
(	O
asection	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
text_b	long
=	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
;	O
if	O
(	O
text_a	long
<	O
text_b	long
)	O
return	O
-	O
1	int
;	O
return	O
text_a	long
>	O
text_b	long
;	O
}	O
static	O
void	O
add_eh_frame_hdr_terminator	function
(	O
asection	struct
*	O
sec	pointer
,	O
asection	struct
*	O
next	pointer
)	O
{	O
bfd_vma	long
end	pointer
;	O
bfd_vma	long
next_start	long
;	O
asection	struct
*	O
text_sec	pointer
;	O
if	O
(	O
next	pointer
)	O
{	O
text_sec	pointer
=	O
(	O
asection	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
end	pointer
=	O
text_sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
text_sec	pointer
->	O
output_offset	long
+	O
text_sec	pointer
->	O
size	long
;	O
text_sec	pointer
=	O
(	O
asection	struct
*	O
)	O
elf_section_data	O
(	O
next	pointer
)	O
->	O
sec_info	pointer
;	O
next_start	long
=	O
text_sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
text_sec	pointer
->	O
output_offset	long
;	O
if	O
(	O
end	pointer
==	O
next_start	long
)	O
return	O
;	O
}	O
if	O
(	O
!	O
sec	pointer
->	O
rawsize	long
)	O
sec	pointer
->	O
rawsize	long
=	O
sec	pointer
->	O
size	long
;	O
bfd_set_section_size	function
(	O
sec	pointer
,	O
sec	pointer
->	O
size	long
+	O
8	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_end_eh_frame_parsing	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
hdr_info	pointer
=	O
&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
eh_info	struct
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
!=	O
COMPACT_EH_HDR	int
||	O
hdr_info	pointer
->	O
array_count	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
bfd_elf_discard_eh_frame_entry	function
(	O
hdr_info	pointer
)	O
;	O
qsort	function
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
,	O
hdr_info	pointer
->	O
array_count	int
,	O
sizeof	O
(	O
asection	struct
*	O
)	O
,	O
cmp_eh_frame_hdr	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr_info	pointer
->	O
array_count	int
-	O
1	int
;	O
i	pointer
++	O
)	O
{	O
add_eh_frame_hdr_terminator	function
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
i	pointer
]	O
,	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
i	pointer
+	O
1	int
]	O
)	O
;	O
}	O
add_eh_frame_hdr_terminator	function
(	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
i	pointer
]	O
,	O
NULL	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
mark_entry	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
eh_cie_fde	struct
*	O
ent	pointer
,	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
for	O
(	O
cookie	pointer
->	O
rel	pointer
=	O
cookie	pointer
->	O
rels	pointer
+	O
ent	pointer
->	O
reloc_index	int
;	O
cookie	pointer
->	O
rel	pointer
<	O
cookie	pointer
->	O
relend	pointer
&&	O
cookie	pointer
->	O
rel	pointer
->	O
r_offset	array
<	O
ent	pointer
->	O
offset	long
+	O
ent	pointer
->	O
size	long
;	O
cookie	pointer
->	O
rel	pointer
++	O
)	O
if	O
(	O
!	O
_bfd_elf_gc_mark_reloc	function
(	O
info	pointer
,	O
sec	pointer
,	O
gc_mark_hook	pointer
,	O
cookie	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_gc_mark_fdes	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
asection	struct
*	O
eh_frame	pointer
,	O
elf_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
struct	O
eh_cie_fde	struct
*	O
fde	struct
,	O
*	O
cie	struct
;	O
for	O
(	O
fde	struct
=	O
elf_fde_list	O
(	O
sec	pointer
)	O
;	O
fde	struct
;	O
fde	struct
=	O
fde	struct
->	O
u	union
.	O
fde	struct
.	O
next_for_section	pointer
)	O
{	O
if	O
(	O
!	O
mark_entry	function
(	O
info	pointer
,	O
eh_frame	pointer
,	O
fde	struct
,	O
gc_mark_hook	pointer
,	O
cookie	pointer
)	O
)	O
return	O
FALSE	int
;	O
cie	struct
=	O
fde	struct
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
;	O
if	O
(	O
cie	struct
!=	O
NULL	O
&&	O
!	O
cie	struct
->	O
u	union
.	O
cie	struct
.	O
gc_mark	int
)	O
{	O
cie	struct
->	O
u	union
.	O
cie	struct
.	O
gc_mark	int
=	O
1	int
;	O
if	O
(	O
!	O
mark_entry	function
(	O
info	pointer
,	O
eh_frame	pointer
,	O
cie	struct
,	O
gc_mark_hook	pointer
,	O
cookie	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
struct	O
eh_cie_fde	struct
*	O
find_merged_cie	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
eh_cie_fde	struct
*	O
cie_inf	pointer
)	O
{	O
unsigned	O
long	O
r_symndx	long
;	O
struct	O
cie	struct
*	O
cie	struct
,	O
*	O
new_cie	pointer
;	O
Elf_Internal_Rela	struct
*	O
rel	pointer
;	O
void	O
*	O
*	O
loc	pointer
;	O
if	O
(	O
!	O
cie_inf	pointer
->	O
removed	int
)	O
return	O
cie_inf	pointer
;	O
if	O
(	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
merged	int
)	O
return	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
merged_with	pointer
;	O
cie	struct
=	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
full_cie	pointer
;	O
cie_inf	pointer
->	O
removed	int
=	O
0	int
;	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
sec	pointer
=	O
sec	pointer
;	O
if	O
(	O
cie	struct
==	O
NULL	O
)	O
return	O
cie_inf	pointer
;	O
if	O
(	O
cie	struct
->	O
per_encoding	char
!=	O
DW_EH_PE_omit	int
)	O
{	O
bfd_boolean	int
per_binds_local	int
;	O
rel	pointer
=	O
cookie	pointer
->	O
rels	pointer
+	O
cie	struct
->	O
personality	union
.	O
reloc_index	int
;	O
memset	function
(	O
&	O
cie	struct
->	O
personality	union
,	O
0	int
,	O
sizeof	O
(	O
cie	struct
->	O
personality	union
)	O
)	O
;	O
if	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
)	O
r_symndx	long
=	O
ELF64_R_SYM	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
else	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
>=	O
cookie	pointer
->	O
locsymcount	long
||	O
ELF_ST_BIND	O
(	O
cookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
.	O
st_info	array
)	O
!=	O
STB_LOCAL	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
r_symndx	long
-=	O
cookie	pointer
->	O
extsymoff	long
;	O
h	pointer
=	O
cookie	pointer
->	O
sym_hashes	pointer
[	O
r_symndx	long
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
cie	struct
->	O
personality	union
.	O
h	pointer
=	O
h	pointer
;	O
per_binds_local	int
=	O
SYMBOL_REFERENCES_LOCAL	O
(	O
info	pointer
,	O
h	pointer
)	O
;	O
}	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
asection	struct
*	O
sym_sec	pointer
;	O
sym	pointer
=	O
&	O
cookie	pointer
->	O
locsyms	pointer
[	O
r_symndx	long
]	O
;	O
sym_sec	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
sym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
sym_sec	pointer
==	O
NULL	O
)	O
return	O
cie_inf	pointer
;	O
if	O
(	O
sym_sec	pointer
->	O
kept_section	pointer
!=	O
NULL	O
)	O
sym_sec	pointer
=	O
sym_sec	pointer
->	O
kept_section	pointer
;	O
if	O
(	O
sym_sec	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
return	O
cie_inf	pointer
;	O
cie	struct
->	O
local_personality	char
=	O
1	int
;	O
cie	struct
->	O
personality	union
.	O
sym	pointer
.	O
bfd_id	int
=	O
abfd	pointer
->	O
id	int
;	O
cie	struct
->	O
personality	union
.	O
sym	pointer
.	O
index	function
=	O
r_symndx	long
;	O
per_binds_local	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
per_binds_local	int
&&	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
(	O
cie	struct
->	O
per_encoding	char
&	O
0x70	int
)	O
==	O
DW_EH_PE_absptr	int
&&	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_backend_can_make_relative_eh_frame	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
)	O
)	O
)	O
{	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
make_per_encoding_relative	int
=	O
1	int
;	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_relative	int
=	O
1	int
;	O
}	O
}	O
cie_compute_hash	function
(	O
cie	struct
)	O
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
==	O
NULL	O
)	O
{	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
=	O
htab_try_create	function
(	O
1	int
,	O
cie_hash	function
,	O
cie_eq	function
,	O
free	function
)	O
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
==	O
NULL	O
)	O
return	O
cie_inf	pointer
;	O
}	O
loc	pointer
=	O
htab_find_slot_with_hash	function
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
,	O
cie	struct
,	O
cie	struct
->	O
hash	long
,	O
INSERT	int
)	O
;	O
if	O
(	O
loc	pointer
==	O
NULL	O
)	O
return	O
cie_inf	pointer
;	O
new_cie	pointer
=	O
(	O
struct	O
cie	struct
*	O
)	O
*	O
loc	pointer
;	O
if	O
(	O
new_cie	pointer
==	O
NULL	O
)	O
{	O
new_cie	pointer
=	O
(	O
struct	O
cie	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
cie	struct
)	O
)	O
;	O
if	O
(	O
new_cie	pointer
==	O
NULL	O
)	O
return	O
cie_inf	pointer
;	O
memcpy	function
(	O
new_cie	pointer
,	O
cie	struct
,	O
sizeof	O
(	O
struct	O
cie	struct
)	O
)	O
;	O
*	O
loc	pointer
=	O
new_cie	pointer
;	O
}	O
else	O
{	O
cie_inf	pointer
->	O
removed	int
=	O
1	int
;	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
merged	int
=	O
1	int
;	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
merged_with	pointer
=	O
new_cie	pointer
->	O
cie_inf	pointer
;	O
if	O
(	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
)	O
new_cie	pointer
->	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
=	O
1	int
;	O
}	O
return	O
new_cie	pointer
->	O
cie_inf	pointer
;	O
}	O
static	O
bfd_signed_vma	long
offset_adjust	function
(	O
bfd_vma	long
offset	long
,	O
const	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
eh_frame_sec_info	struct
*	O
sec_info	pointer
=	O
(	O
struct	O
eh_frame_sec_info	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
unsigned	O
int	O
lo	int
,	O
hi	int
,	O
mid	int
;	O
struct	O
eh_cie_fde	struct
*	O
ent	pointer
=	O
NULL	O
;	O
bfd_signed_vma	long
delta	long
;	O
lo	int
=	O
0	int
;	O
hi	int
=	O
sec_info	pointer
->	O
count	int
;	O
if	O
(	O
hi	int
==	O
0	int
)	O
return	O
0	int
;	O
while	O
(	O
lo	int
<	O
hi	int
)	O
{	O
mid	int
=	O
(	O
lo	int
+	O
hi	int
)	O
/	O
2	int
;	O
ent	pointer
=	O
&	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
;	O
if	O
(	O
offset	long
<	O
ent	pointer
->	O
offset	long
)	O
hi	int
=	O
mid	int
;	O
else	O
if	O
(	O
mid	int
+	O
1	int
>=	O
hi	int
)	O
break	O
;	O
else	O
if	O
(	O
offset	long
>=	O
ent	pointer
[	O
1	int
]	O
.	O
offset	long
)	O
lo	int
=	O
mid	int
+	O
1	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
ent	pointer
->	O
removed	int
)	O
delta	long
=	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
new_offset	int
-	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
;	O
else	O
if	O
(	O
ent	pointer
->	O
cie	struct
&&	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
merged	int
)	O
{	O
struct	O
eh_cie_fde	struct
*	O
cie	struct
=	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
merged_with	pointer
;	O
delta	long
=	O
(	O
(	O
bfd_vma	long
)	O
cie	struct
->	O
new_offset	int
+	O
cie	struct
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
sec	pointer
->	O
output_offset	long
-	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
-	O
sec	pointer
->	O
output_offset	long
)	O
;	O
}	O
else	O
{	O
struct	O
eh_cie_fde	struct
*	O
last	pointer
=	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
delta	long
=	O
(	O
(	O
bfd_vma	long
)	O
next_cie_fde_offset	function
(	O
ent	pointer
,	O
last	pointer
,	O
sec	pointer
)	O
-	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
)	O
;	O
return	O
delta	long
;	O
}	O
offset	long
-=	O
ent	pointer
->	O
offset	long
;	O
if	O
(	O
ent	pointer
->	O
cie	struct
)	O
{	O
unsigned	O
int	O
extra	int
=	O
ent	pointer
->	O
add_augmentation_size	int
+	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
add_fde_encoding	int
;	O
if	O
(	O
extra	int
==	O
0	int
||	O
offset	long
<=	O
9u	int
+	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
aug_str_len	int
)	O
return	O
delta	long
;	O
delta	long
+=	O
extra	int
;	O
if	O
(	O
offset	long
<=	O
9u	int
+	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
aug_str_len	int
+	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
aug_data_len	int
)	O
return	O
delta	long
;	O
delta	long
+=	O
extra	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
ptr_size	pointer
,	O
width	int
,	O
extra	int
=	O
ent	pointer
->	O
add_augmentation_size	int
;	O
if	O
(	O
offset	long
<=	O
12	int
||	O
extra	int
==	O
0	int
)	O
return	O
delta	long
;	O
ptr_size	pointer
=	O
(	O
get_elf_backend_data	O
(	O
sec	pointer
->	O
owner	pointer
)	O
->	O
elf_backend_eh_frame_address_size	pointer
(	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
;	O
width	int
=	O
get_DW_EH_PE_width	function
(	O
ent	pointer
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
if	O
(	O
offset	long
<=	O
8	int
+	O
2	int
*	O
width	int
)	O
return	O
delta	long
;	O
delta	long
+=	O
extra	int
;	O
}	O
return	O
delta	long
;	O
}	O
bfd_boolean	int
_bfd_elf_adjust_eh_frame_global_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
arg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
asection	struct
*	O
sym_sec	pointer
;	O
bfd_signed_vma	long
delta	long
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
return	O
TRUE	int
;	O
sym_sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
if	O
(	O
sym_sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_EH_FRAME	int
||	O
elf_section_data	O
(	O
sym_sec	pointer
)	O
->	O
sec_info	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
delta	long
=	O
offset_adjust	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
,	O
sym_sec	pointer
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+=	O
delta	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
adjust_eh_frame_local_symbols	function
(	O
const	O
asection	struct
*	O
sec	pointer
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
unsigned	O
int	O
shndx	int
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
Elf_Internal_Sym	struct
*	O
end_sym	pointer
;	O
int	O
adjusted	int
=	O
0	int
;	O
shndx	int
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_idx	int
;	O
end_sym	pointer
=	O
cookie	pointer
->	O
locsyms	pointer
+	O
cookie	pointer
->	O
locsymcount	long
;	O
for	O
(	O
sym	pointer
=	O
cookie	pointer
->	O
locsyms	pointer
+	O
1	int
;	O
sym	pointer
<	O
end_sym	pointer
;	O
++	O
sym	pointer
)	O
if	O
(	O
sym	pointer
->	O
st_info	array
<=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_OBJECT	int
)	O
&&	O
sym	pointer
->	O
st_shndx	array
==	O
shndx	int
)	O
{	O
bfd_signed_vma	long
delta	long
=	O
offset_adjust	function
(	O
sym	pointer
->	O
st_value	array
,	O
sec	pointer
)	O
;	O
if	O
(	O
delta	long
!=	O
0	int
)	O
{	O
adjusted	int
=	O
1	int
;	O
sym	pointer
->	O
st_value	array
+=	O
delta	long
;	O
}	O
}	O
return	O
adjusted	int
;	O
}	O
bfd_boolean	int
_bfd_elf_discard_section_eh_frame	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_boolean	int
(	O
*	O
reloc_symbol_deleted_p	pointer
)	O
(	O
bfd_vma	long
,	O
void	O
*	O
)	O
,	O
struct	O
elf_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
struct	O
eh_cie_fde	struct
*	O
ent	pointer
;	O
struct	O
eh_frame_sec_info	struct
*	O
sec_info	pointer
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
unsigned	O
int	O
ptr_size	pointer
,	O
offset	long
,	O
eh_alignment	int
;	O
int	O
changed	int
;	O
if	O
(	O
sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_EH_FRAME	int
)	O
return	O
FALSE	int
;	O
sec_info	pointer
=	O
(	O
struct	O
eh_frame_sec_info	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
if	O
(	O
sec_info	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
ptr_size	pointer
=	O
(	O
get_elf_backend_data	O
(	O
sec	pointer
->	O
owner	pointer
)	O
->	O
elf_backend_eh_frame_address_size	pointer
(	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
;	O
hdr_info	pointer
=	O
&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
eh_info	struct
;	O
for	O
(	O
ent	pointer
=	O
sec_info	pointer
->	O
entry	pointer
;	O
ent	pointer
<	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
++	O
ent	pointer
)	O
if	O
(	O
ent	pointer
->	O
size	long
==	O
4	int
)	O
ent	pointer
->	O
removed	int
=	O
sec	pointer
->	O
map_head	union
.	O
s	pointer
!=	O
NULL	O
;	O
else	O
if	O
(	O
!	O
ent	pointer
->	O
cie	struct
&&	O
ent	pointer
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
keep	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
&&	O
cookie	pointer
->	O
rels	pointer
==	O
NULL	O
)	O
{	O
unsigned	O
int	O
width	int
=	O
get_DW_EH_PE_width	function
(	O
ent	pointer
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
bfd_vma	long
value	long
=	O
read_value	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
contents	pointer
+	O
ent	pointer
->	O
offset	long
+	O
8	int
+	O
width	int
,	O
width	int
,	O
get_DW_EH_PE_signed	O
(	O
ent	pointer
->	O
fde_encoding	int
)	O
)	O
;	O
keep	int
=	O
value	long
!=	O
0	int
;	O
}	O
else	O
{	O
cookie	pointer
->	O
rel	pointer
=	O
cookie	pointer
->	O
rels	pointer
+	O
ent	pointer
->	O
reloc_index	int
;	O
BFD_ASSERT	O
(	O
cookie	pointer
->	O
rel	pointer
<	O
cookie	pointer
->	O
relend	pointer
&&	O
cookie	pointer
->	O
rel	pointer
->	O
r_offset	array
==	O
ent	pointer
->	O
offset	long
+	O
8	int
)	O
;	O
keep	int
=	O
!	O
(	O
*	O
reloc_symbol_deleted_p	pointer
)	O
(	O
ent	pointer
->	O
offset	long
+	O
8	int
,	O
cookie	pointer
)	O
;	O
}	O
if	O
(	O
keep	int
)	O
{	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
(	O
(	O
(	O
ent	pointer
->	O
fde_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_absptr	int
&&	O
ent	pointer
->	O
make_relative	int
==	O
0	int
)	O
||	O
(	O
ent	pointer
->	O
fde_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_aligned	int
)	O
)	O
{	O
static	O
int	O
num_warnings_issued	int
=	O
0	int
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
table	pointer
=	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
!=	O
0	int
)	O
{	O
if	O
(	O
num_warnings_issued	int
<	O
10	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"FDE encoding in %pB(%pA) prevents .eh_frame_hdr"	pointer
" table being created"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
num_warnings_issued	int
++	O
;	O
}	O
else	O
if	O
(	O
num_warnings_issued	int
==	O
10	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"further warnings about FDE encoding preventing .eh_frame_hdr generation dropped"	pointer
)	O
)	O
;	O
num_warnings_issued	int
++	O
;	O
}	O
}	O
}	O
ent	pointer
->	O
removed	int
=	O
0	int
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
++	O
;	O
ent	pointer
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
=	O
find_merged_cie	function
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
,	O
hdr_info	pointer
,	O
cookie	pointer
,	O
ent	pointer
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
)	O
;	O
}	O
}	O
if	O
(	O
sec_info	pointer
->	O
cies	pointer
)	O
{	O
free	function
(	O
sec_info	pointer
->	O
cies	pointer
)	O
;	O
sec_info	pointer
->	O
cies	pointer
=	O
NULL	O
;	O
}	O
offset	long
=	O
0	int
;	O
changed	int
=	O
0	int
;	O
for	O
(	O
ent	pointer
=	O
sec_info	pointer
->	O
entry	pointer
;	O
ent	pointer
<	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
++	O
ent	pointer
)	O
if	O
(	O
!	O
ent	pointer
->	O
removed	int
)	O
{	O
eh_alignment	int
=	O
4	int
;	O
if	O
(	O
ent	pointer
->	O
size	long
==	O
4	int
)	O
;	O
else	O
if	O
(	O
ent	pointer
->	O
cie	struct
)	O
{	O
if	O
(	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_aligned8	int
)	O
eh_alignment	int
=	O
8	int
;	O
}	O
else	O
{	O
eh_alignment	int
=	O
get_DW_EH_PE_width	function
(	O
ent	pointer
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
if	O
(	O
eh_alignment	int
<	O
4	int
)	O
eh_alignment	int
=	O
4	int
;	O
}	O
offset	long
=	O
(	O
offset	long
+	O
eh_alignment	int
-	O
1	int
)	O
&	O
-	O
eh_alignment	int
;	O
ent	pointer
->	O
new_offset	int
=	O
offset	long
;	O
if	O
(	O
ent	pointer
->	O
new_offset	int
!=	O
ent	pointer
->	O
offset	long
)	O
changed	int
=	O
1	int
;	O
offset	long
+=	O
size_of_output_cie_fde	function
(	O
ent	pointer
)	O
;	O
}	O
eh_alignment	int
=	O
4	int
;	O
offset	long
=	O
(	O
offset	long
+	O
eh_alignment	int
-	O
1	int
)	O
&	O
-	O
eh_alignment	int
;	O
sec	pointer
->	O
rawsize	long
=	O
sec	pointer
->	O
size	long
;	O
sec	pointer
->	O
size	long
=	O
offset	long
;	O
if	O
(	O
sec	pointer
->	O
size	long
!=	O
sec	pointer
->	O
rawsize	long
)	O
changed	int
=	O
1	int
;	O
if	O
(	O
changed	int
&&	O
adjust_eh_frame_local_symbols	function
(	O
sec	pointer
,	O
cookie	pointer
)	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
symtab_hdr	struct
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
cookie	pointer
->	O
locsyms	pointer
;	O
}	O
return	O
changed	int
;	O
}	O
bfd_boolean	int
_bfd_elf_discard_section_eh_frame_hdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
if	O
(	O
!	O
hdr_info	pointer
->	O
frame_hdr_is_compact	int
&&	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
!=	O
NULL	O
)	O
{	O
htab_delete	function
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
)	O
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
cies	pointer
=	O
NULL	O
;	O
}	O
sec	pointer
=	O
hdr_info	pointer
->	O
hdr_sec	pointer
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
COMPACT_EH_HDR	int
)	O
{	O
sec	pointer
->	O
size	long
=	O
8	int
;	O
}	O
else	O
{	O
sec	pointer
->	O
size	long
=	O
EH_FRAME_HDR_SIZE	int
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
table	pointer
)	O
sec	pointer
->	O
size	long
+=	O
4	int
+	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
*	O
8	int
;	O
}	O
elf_eh_frame_hdr	O
(	O
abfd	pointer
)	O
=	O
sec	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_eh_frame_present	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
eh	pointer
=	O
bfd_get_section_by_name	function
(	O
info	pointer
->	O
output_bfd	pointer
,	O
".eh_frame"	pointer
)	O
;	O
if	O
(	O
eh	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
eh	pointer
=	O
eh	pointer
->	O
map_head	union
.	O
s	pointer
;	O
eh	pointer
!=	O
NULL	O
;	O
eh	pointer
=	O
eh	pointer
->	O
map_head	union
.	O
s	pointer
)	O
if	O
(	O
eh	pointer
->	O
size	long
>	O
8	int
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_eh_frame_entry_present	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
o	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
for	O
(	O
abfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
bfd_section_name	function
(	O
o	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
".eh_frame_entry"	pointer
)	O
&&	O
!	O
bfd_is_abs_section	function
(	O
o	pointer
->	O
output_section	pointer
)	O
)	O
return	O
TRUE	int
;	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_maybe_strip_eh_frame_hdr	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
=	O
NULL	O
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
if	O
(	O
hdr_info	pointer
->	O
hdr_sec	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
hdr_info	pointer
->	O
hdr_sec	pointer
->	O
output_section	pointer
)	O
||	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
0	int
||	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
DWARF2_EH_HDR	int
&&	O
!	O
_bfd_elf_eh_frame_present	function
(	O
info	pointer
)	O
)	O
||	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
COMPACT_EH_HDR	int
&&	O
!	O
_bfd_elf_eh_frame_entry_present	function
(	O
info	pointer
)	O
)	O
)	O
{	O
hdr_info	pointer
->	O
hdr_sec	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
hdr_info	pointer
->	O
hdr_sec	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
info	pointer
->	O
output_bfd	pointer
,	O
"__GNU_EH_FRAME_HDR"	pointer
,	O
BSF_LOCAL	O
,	O
hdr_info	pointer
->	O
hdr_sec	pointer
,	O
0	int
,	O
NULL	O
,	O
FALSE	int
,	O
FALSE	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
other	int
=	O
STV_HIDDEN	int
;	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
->	O
elf_backend_hide_symbol	pointer
(	O
info	pointer
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
!	O
hdr_info	pointer
->	O
frame_hdr_is_compact	int
)	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
table	pointer
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_vma	long
_bfd_elf_eh_frame_section_offset	function
(	O
bfd	struct
*	O
output_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_vma	long
offset	long
)	O
{	O
struct	O
eh_frame_sec_info	struct
*	O
sec_info	pointer
;	O
unsigned	O
int	O
lo	int
,	O
hi	int
,	O
mid	int
;	O
if	O
(	O
sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_EH_FRAME	int
)	O
return	O
offset	long
;	O
sec_info	pointer
=	O
(	O
struct	O
eh_frame_sec_info	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
if	O
(	O
offset	long
>=	O
sec	pointer
->	O
rawsize	long
)	O
return	O
offset	long
-	O
sec	pointer
->	O
rawsize	long
+	O
sec	pointer
->	O
size	long
;	O
lo	int
=	O
0	int
;	O
hi	int
=	O
sec_info	pointer
->	O
count	int
;	O
mid	int
=	O
0	int
;	O
while	O
(	O
lo	int
<	O
hi	int
)	O
{	O
mid	int
=	O
(	O
lo	int
+	O
hi	int
)	O
/	O
2	int
;	O
if	O
(	O
offset	long
<	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
)	O
hi	int
=	O
mid	int
;	O
else	O
if	O
(	O
offset	long
>=	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
size	long
)	O
lo	int
=	O
mid	int
+	O
1	int
;	O
else	O
break	O
;	O
}	O
BFD_ASSERT	O
(	O
lo	int
<	O
hi	int
)	O
;	O
if	O
(	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
removed	int
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
if	O
(	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
cie	struct
&&	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
u	union
.	O
cie	struct
.	O
make_per_encoding_relative	int
&&	O
offset	long
==	O
(	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
8	int
+	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
u	union
.	O
cie	struct
.	O
personality_offset	int
)	O
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
2	int
;	O
if	O
(	O
!	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
cie	struct
&&	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
make_relative	int
&&	O
offset	long
==	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
8	int
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
2	int
;	O
if	O
(	O
!	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
cie	struct
&&	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
&&	O
offset	long
==	O
(	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
8	int
+	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
lsda_offset	int
)	O
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
2	int
;	O
if	O
(	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
set_loc	pointer
&&	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
make_relative	int
&&	O
(	O
offset	long
>=	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
8	int
+	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
set_loc	pointer
[	O
1	int
]	O
)	O
)	O
{	O
unsigned	O
int	O
cnt	int
;	O
for	O
(	O
cnt	int
=	O
1	int
;	O
cnt	int
<=	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
set_loc	pointer
[	O
0	int
]	O
;	O
cnt	int
++	O
)	O
if	O
(	O
offset	long
==	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
8	int
+	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
set_loc	pointer
[	O
cnt	int
]	O
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
2	int
;	O
}	O
return	O
(	O
offset	long
+	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
new_offset	int
-	O
sec_info	pointer
->	O
entry	pointer
[	O
mid	int
]	O
.	O
offset	long
+	O
extra_augmentation_string_bytes	function
(	O
sec_info	pointer
->	O
entry	pointer
+	O
mid	int
)	O
+	O
extra_augmentation_data_bytes	function
(	O
sec_info	pointer
->	O
entry	pointer
+	O
mid	int
)	O
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_write_section_eh_frame_entry	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_byte	char
*	O
contents	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_byte	char
cantunwind	array
[	O
8	int
]	O
;	O
bfd_vma	long
addr	pointer
;	O
bfd_vma	long
last_addr	long
;	O
bfd_vma	long
offset	long
;	O
asection	struct
*	O
text_sec	pointer
=	O
(	O
asection	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
if	O
(	O
!	O
sec	pointer
->	O
rawsize	long
)	O
sec	pointer
->	O
rawsize	long
=	O
sec	pointer
->	O
size	long
;	O
BFD_ASSERT	O
(	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_EH_FRAME_ENTRY	int
)	O
;	O
if	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
||	O
text_sec	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
sec	pointer
->	O
output_offset	long
,	O
sec	pointer
->	O
rawsize	long
)	O
)	O
return	O
FALSE	int
;	O
last_addr	long
=	O
bfd_get_signed_32	O
(	O
abfd	pointer
,	O
contents	pointer
)	O
;	O
for	O
(	O
offset	long
=	O
8	int
;	O
offset	long
<	O
sec	pointer
->	O
rawsize	long
;	O
offset	long
+=	O
8	int
)	O
{	O
addr	pointer
=	O
bfd_get_signed_32	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
)	O
+	O
offset	long
;	O
if	O
(	O
addr	pointer
<=	O
last_addr	long
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %pA not in order"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
last_addr	long
=	O
addr	pointer
;	O
}	O
addr	pointer
=	O
text_sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
text_sec	pointer
->	O
output_offset	long
+	O
text_sec	pointer
->	O
size	long
;	O
addr	pointer
&=	O
~	O
1	int
;	O
addr	pointer
-=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
sec	pointer
->	O
rawsize	long
)	O
;	O
if	O
(	O
addr	pointer
&	O
1	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %pA invalid input section size"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
last_addr	long
>=	O
addr	pointer
+	O
sec	pointer
->	O
rawsize	long
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %pA points past end of text section"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
sec	pointer
->	O
size	long
==	O
sec	pointer
->	O
rawsize	long
)	O
return	O
TRUE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
BFD_ASSERT	O
(	O
sec	pointer
->	O
size	long
==	O
sec	pointer
->	O
rawsize	long
+	O
8	int
)	O
;	O
BFD_ASSERT	O
(	O
(	O
addr	pointer
&	O
1	int
)	O
==	O
0	int
)	O
;	O
BFD_ASSERT	O
(	O
bed	pointer
->	O
cant_unwind_opcode	pointer
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
addr	pointer
,	O
cantunwind	array
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
(	O
*	O
bed	pointer
->	O
cant_unwind_opcode	pointer
)	O
(	O
info	pointer
)	O
,	O
cantunwind	array
+	O
4	int
)	O
;	O
return	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
output_section	pointer
,	O
cantunwind	array
,	O
sec	pointer
->	O
output_offset	long
+	O
sec	pointer
->	O
rawsize	long
,	O
8	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_write_section_eh_frame	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_byte	char
*	O
contents	pointer
)	O
{	O
struct	O
eh_frame_sec_info	struct
*	O
sec_info	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
unsigned	O
int	O
ptr_size	pointer
;	O
struct	O
eh_cie_fde	struct
*	O
ent	pointer
,	O
*	O
last_ent	pointer
;	O
if	O
(	O
sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_EH_FRAME	int
)	O
return	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
sec	pointer
->	O
output_offset	long
,	O
sec	pointer
->	O
size	long
)	O
;	O
ptr_size	pointer
=	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_backend_eh_frame_address_size	pointer
(	O
abfd	pointer
,	O
sec	pointer
)	O
)	O
;	O
BFD_ASSERT	O
(	O
ptr_size	pointer
!=	O
0	int
)	O
;	O
sec_info	pointer
=	O
(	O
struct	O
eh_frame_sec_info	struct
*	O
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
table	pointer
&&	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
==	O
NULL	O
)	O
{	O
hdr_info	pointer
->	O
frame_hdr_is_compact	int
=	O
FALSE	int
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
=	O
(	O
struct	O
eh_frame_array_ent	struct
*	O
)	O
bfd_malloc	function
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
*	O
sizeof	O
(	O
*	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
)	O
)	O
;	O
}	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
==	O
NULL	O
)	O
hdr_info	pointer
=	O
NULL	O
;	O
for	O
(	O
ent	pointer
=	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
ent	pointer
--	O
!=	O
sec_info	pointer
->	O
entry	pointer
;	O
)	O
if	O
(	O
!	O
ent	pointer
->	O
removed	int
&&	O
ent	pointer
->	O
new_offset	int
>	O
ent	pointer
->	O
offset	long
)	O
memmove	function
(	O
contents	pointer
+	O
ent	pointer
->	O
new_offset	int
,	O
contents	pointer
+	O
ent	pointer
->	O
offset	long
,	O
ent	pointer
->	O
size	long
)	O
;	O
for	O
(	O
ent	pointer
=	O
sec_info	pointer
->	O
entry	pointer
;	O
ent	pointer
<	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
++	O
ent	pointer
)	O
if	O
(	O
!	O
ent	pointer
->	O
removed	int
&&	O
ent	pointer
->	O
new_offset	int
<	O
ent	pointer
->	O
offset	long
)	O
memmove	function
(	O
contents	pointer
+	O
ent	pointer
->	O
new_offset	int
,	O
contents	pointer
+	O
ent	pointer
->	O
offset	long
,	O
ent	pointer
->	O
size	long
)	O
;	O
last_ent	pointer
=	O
sec_info	pointer
->	O
entry	pointer
+	O
sec_info	pointer
->	O
count	int
;	O
for	O
(	O
ent	pointer
=	O
sec_info	pointer
->	O
entry	pointer
;	O
ent	pointer
<	O
last_ent	pointer
;	O
++	O
ent	pointer
)	O
{	O
unsigned	O
char	O
*	O
buf	pointer
,	O
*	O
end	pointer
;	O
unsigned	O
int	O
new_size	int
;	O
if	O
(	O
ent	pointer
->	O
removed	int
)	O
continue	O
;	O
if	O
(	O
ent	pointer
->	O
size	long
==	O
4	int
)	O
{	O
BFD_ASSERT	O
(	O
ent	pointer
==	O
last_ent	pointer
-	O
1	int
)	O
;	O
continue	O
;	O
}	O
buf	pointer
=	O
contents	pointer
+	O
ent	pointer
->	O
new_offset	int
;	O
end	pointer
=	O
buf	pointer
+	O
ent	pointer
->	O
size	long
;	O
new_size	int
=	O
next_cie_fde_offset	function
(	O
ent	pointer
,	O
last_ent	pointer
,	O
sec	pointer
)	O
-	O
ent	pointer
->	O
new_offset	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
new_size	int
-	O
4	int
,	O
buf	pointer
)	O
;	O
if	O
(	O
new_size	int
!=	O
ent	pointer
->	O
size	long
)	O
memset	function
(	O
end	pointer
,	O
0	int
,	O
new_size	int
-	O
ent	pointer
->	O
size	long
)	O
;	O
if	O
(	O
ent	pointer
->	O
cie	struct
)	O
{	O
if	O
(	O
ent	pointer
->	O
make_relative	int
||	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
||	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_relative	int
)	O
{	O
char	O
*	O
aug	pointer
;	O
unsigned	O
int	O
version	short
,	O
action	int
,	O
extra_string	int
,	O
extra_data	int
;	O
unsigned	O
int	O
per_width	int
,	O
per_encoding	char
;	O
action	int
=	O
(	O
(	O
ent	pointer
->	O
make_relative	int
?	O
1	int
:	O
0	int
)	O
|	O
(	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
?	O
2	int
:	O
0	int
)	O
|	O
(	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_relative	int
?	O
4	int
:	O
0	int
)	O
)	O
;	O
extra_string	int
=	O
extra_augmentation_string_bytes	function
(	O
ent	pointer
)	O
;	O
extra_data	int
=	O
extra_augmentation_data_bytes	function
(	O
ent	pointer
)	O
;	O
buf	pointer
+=	O
8	int
;	O
version	short
=	O
*	O
buf	pointer
++	O
;	O
aug	pointer
=	O
(	O
char	O
*	O
)	O
buf	pointer
;	O
buf	pointer
+=	O
strlen	function
(	O
aug	pointer
)	O
+	O
1	int
;	O
skip_leb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
)	O
;	O
skip_leb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
version	short
==	O
1	int
)	O
skip_bytes	function
(	O
&	O
buf	pointer
,	O
end	pointer
,	O
1	int
)	O
;	O
else	O
skip_leb128	function
(	O
&	O
buf	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
*	O
aug	pointer
==	O
'z'	O
)	O
{	O
*	O
buf	pointer
++	O
+=	O
extra_data	int
;	O
aug	pointer
++	O
;	O
}	O
memmove	function
(	O
buf	pointer
+	O
extra_string	int
+	O
extra_data	int
,	O
buf	pointer
,	O
end	pointer
-	O
buf	pointer
)	O
;	O
memmove	function
(	O
aug	pointer
+	O
extra_string	int
,	O
aug	pointer
,	O
buf	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
aug	pointer
)	O
;	O
buf	pointer
+=	O
extra_string	int
;	O
end	pointer
+=	O
extra_string	int
+	O
extra_data	int
;	O
if	O
(	O
ent	pointer
->	O
add_augmentation_size	int
)	O
{	O
*	O
aug	pointer
++	O
=	O
'z'	O
;	O
*	O
buf	pointer
++	O
=	O
extra_data	int
-	O
1	int
;	O
}	O
if	O
(	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
add_fde_encoding	int
)	O
{	O
BFD_ASSERT	O
(	O
action	int
&	O
1	int
)	O
;	O
*	O
aug	pointer
++	O
=	O
'R'	O
;	O
*	O
buf	pointer
++	O
=	O
make_pc_relative	function
(	O
DW_EH_PE_absptr	int
,	O
ptr_size	pointer
)	O
;	O
action	int
&=	O
~	O
1	int
;	O
}	O
while	O
(	O
action	int
)	O
switch	O
(	O
*	O
aug	pointer
++	O
)	O
{	O
case	O
'L'	O
:	O
if	O
(	O
action	int
&	O
2	int
)	O
{	O
BFD_ASSERT	O
(	O
*	O
buf	pointer
==	O
ent	pointer
->	O
lsda_encoding	int
)	O
;	O
*	O
buf	pointer
=	O
make_pc_relative	function
(	O
*	O
buf	pointer
,	O
ptr_size	pointer
)	O
;	O
action	int
&=	O
~	O
2	int
;	O
}	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
make_per_encoding_relative	int
)	O
*	O
buf	pointer
=	O
make_pc_relative	function
(	O
*	O
buf	pointer
,	O
ptr_size	pointer
)	O
;	O
per_encoding	char
=	O
*	O
buf	pointer
++	O
;	O
per_width	int
=	O
get_DW_EH_PE_width	function
(	O
per_encoding	char
,	O
ptr_size	pointer
)	O
;	O
BFD_ASSERT	O
(	O
per_width	int
!=	O
0	int
)	O
;	O
BFD_ASSERT	O
(	O
(	O
(	O
per_encoding	char
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
==	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
per_encoding_relative	int
)	O
;	O
if	O
(	O
(	O
per_encoding	char
&	O
0x70	int
)	O
==	O
DW_EH_PE_aligned	int
)	O
buf	pointer
=	O
(	O
contents	pointer
+	O
(	O
(	O
buf	pointer
-	O
contents	pointer
+	O
per_width	int
-	O
1	int
)	O
&	O
~	O
(	O
(	O
bfd_size_type	long
)	O
per_width	int
-	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
action	int
&	O
4	int
)	O
{	O
bfd_vma	long
val	array
;	O
val	array
=	O
read_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
per_width	int
,	O
get_DW_EH_PE_signed	O
(	O
per_encoding	char
)	O
)	O
;	O
if	O
(	O
ent	pointer
->	O
u	union
.	O
cie	struct
.	O
make_per_encoding_relative	int
)	O
val	array
-=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
(	O
buf	pointer
-	O
contents	pointer
)	O
)	O
;	O
else	O
{	O
val	array
+=	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
-	O
ent	pointer
->	O
new_offset	int
;	O
val	array
-=	O
extra_string	int
+	O
extra_data	int
;	O
}	O
write_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
val	array
,	O
per_width	int
)	O
;	O
action	int
&=	O
~	O
4	int
;	O
}	O
buf	pointer
+=	O
per_width	int
;	O
break	O
;	O
case	O
'R'	O
:	O
if	O
(	O
action	int
&	O
1	int
)	O
{	O
BFD_ASSERT	O
(	O
*	O
buf	pointer
==	O
ent	pointer
->	O
fde_encoding	int
)	O
;	O
*	O
buf	pointer
=	O
make_pc_relative	function
(	O
*	O
buf	pointer
,	O
ptr_size	pointer
)	O
;	O
action	int
&=	O
~	O
1	int
;	O
}	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'S'	O
:	O
break	O
;	O
default	O
:	O
BFD_FAIL	O
(	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
bfd_vma	long
value	long
,	O
address	long
;	O
unsigned	O
int	O
width	int
;	O
bfd_byte	char
*	O
start	pointer
;	O
struct	O
eh_cie_fde	struct
*	O
cie	struct
;	O
cie	struct
=	O
ent	pointer
->	O
u	union
.	O
fde	struct
.	O
cie_inf	pointer
;	O
buf	pointer
+=	O
4	int
;	O
value	long
=	O
(	O
(	O
ent	pointer
->	O
new_offset	int
+	O
sec	pointer
->	O
output_offset	long
+	O
4	int
)	O
-	O
(	O
cie	struct
->	O
new_offset	int
+	O
cie	struct
->	O
u	union
.	O
cie	struct
.	O
u	union
.	O
sec	pointer
->	O
output_offset	long
)	O
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
value	long
,	O
buf	pointer
)	O
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
continue	O
;	O
buf	pointer
+=	O
4	int
;	O
width	int
=	O
get_DW_EH_PE_width	function
(	O
ent	pointer
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
value	long
=	O
read_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
width	int
,	O
get_DW_EH_PE_signed	O
(	O
ent	pointer
->	O
fde_encoding	int
)	O
)	O
;	O
address	long
=	O
value	long
;	O
if	O
(	O
value	long
)	O
{	O
switch	O
(	O
ent	pointer
->	O
fde_encoding	int
&	O
0x70	int
)	O
{	O
case	O
DW_EH_PE_textrel	int
:	O
BFD_ASSERT	O
(	O
hdr_info	pointer
==	O
NULL	O
)	O
;	O
break	O
;	O
case	O
DW_EH_PE_datarel	int
:	O
{	O
switch	O
(	O
abfd	pointer
->	O
arch_info	pointer
->	O
arch	enum
)	O
{	O
case	O
bfd_arch_ia64	int
:	O
BFD_ASSERT	O
(	O
elf_gp	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
;	O
address	long
+=	O
elf_gp	O
(	O
abfd	pointer
)	O
;	O
break	O
;	O
default	O
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"DW_EH_PE_datarel unspecified"	pointer
" for this architecture"	pointer
)	O
)	O
;	O
case	O
bfd_arch_frv	int
:	O
case	O
bfd_arch_i386	int
:	O
BFD_ASSERT	O
(	O
htab	struct
->	O
hgot	pointer
!=	O
NULL	O
&&	O
(	O
(	O
htab	struct
->	O
hgot	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
)	O
||	O
(	O
htab	struct
->	O
hgot	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
)	O
;	O
address	long
+=	O
(	O
htab	struct
->	O
hgot	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
htab	struct
->	O
hgot	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
+	O
(	O
htab	struct
->	O
hgot	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
)	O
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
DW_EH_PE_pcrel	int
:	O
value	long
+=	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
-	O
ent	pointer
->	O
new_offset	int
;	O
address	long
+=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
ent	pointer
->	O
offset	long
+	O
8	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ent	pointer
->	O
make_relative	int
)	O
value	long
-=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
ent	pointer
->	O
new_offset	int
+	O
8	int
)	O
;	O
write_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
value	long
,	O
width	int
)	O
;	O
}	O
start	pointer
=	O
buf	pointer
;	O
if	O
(	O
hdr_info	pointer
)	O
{	O
if	O
(	O
sizeof	O
(	O
address	long
)	O
>	O
4	int
&&	O
ptr_size	pointer
==	O
4	int
)	O
address	long
&=	O
0xffffffff	int
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
hdr_info	pointer
->	O
array_count	int
]	O
.	O
initial_loc	long
=	O
address	long
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
hdr_info	pointer
->	O
array_count	int
]	O
.	O
range	long
=	O
read_value	function
(	O
abfd	pointer
,	O
buf	pointer
+	O
width	int
,	O
width	int
,	O
FALSE	int
)	O
;	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
hdr_info	pointer
->	O
array_count	int
++	O
]	O
.	O
fde	struct
=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
ent	pointer
->	O
new_offset	int
)	O
;	O
}	O
if	O
(	O
(	O
ent	pointer
->	O
lsda_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
||	O
cie	struct
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
)	O
{	O
buf	pointer
+=	O
ent	pointer
->	O
lsda_offset	int
;	O
width	int
=	O
get_DW_EH_PE_width	function
(	O
ent	pointer
->	O
lsda_encoding	int
,	O
ptr_size	pointer
)	O
;	O
value	long
=	O
read_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
width	int
,	O
get_DW_EH_PE_signed	O
(	O
ent	pointer
->	O
lsda_encoding	int
)	O
)	O
;	O
if	O
(	O
value	long
)	O
{	O
if	O
(	O
(	O
ent	pointer
->	O
lsda_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
value	long
+=	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
-	O
ent	pointer
->	O
new_offset	int
;	O
else	O
if	O
(	O
cie	struct
->	O
u	union
.	O
cie	struct
.	O
make_lsda_relative	int
)	O
value	long
-=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
ent	pointer
->	O
new_offset	int
+	O
8	int
+	O
ent	pointer
->	O
lsda_offset	int
)	O
;	O
write_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
value	long
,	O
width	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
ent	pointer
->	O
add_augmentation_size	int
)	O
{	O
buf	pointer
+=	O
width	int
*	O
2	int
;	O
memmove	function
(	O
buf	pointer
+	O
1	int
,	O
buf	pointer
,	O
end	pointer
-	O
buf	pointer
)	O
;	O
*	O
buf	pointer
=	O
0	int
;	O
}	O
if	O
(	O
ent	pointer
->	O
set_loc	pointer
)	O
{	O
unsigned	O
int	O
cnt	int
;	O
bfd_vma	long
new_offset	int
;	O
width	int
=	O
get_DW_EH_PE_width	function
(	O
ent	pointer
->	O
fde_encoding	int
,	O
ptr_size	pointer
)	O
;	O
new_offset	int
=	O
ent	pointer
->	O
new_offset	int
+	O
8	int
+	O
extra_augmentation_string_bytes	function
(	O
ent	pointer
)	O
+	O
extra_augmentation_data_bytes	function
(	O
ent	pointer
)	O
;	O
for	O
(	O
cnt	int
=	O
1	int
;	O
cnt	int
<=	O
ent	pointer
->	O
set_loc	pointer
[	O
0	int
]	O
;	O
cnt	int
++	O
)	O
{	O
buf	pointer
=	O
start	pointer
+	O
ent	pointer
->	O
set_loc	pointer
[	O
cnt	int
]	O
;	O
value	long
=	O
read_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
width	int
,	O
get_DW_EH_PE_signed	O
(	O
ent	pointer
->	O
fde_encoding	int
)	O
)	O
;	O
if	O
(	O
!	O
value	long
)	O
continue	O
;	O
if	O
(	O
(	O
ent	pointer
->	O
fde_encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
value	long
+=	O
(	O
bfd_vma	long
)	O
ent	pointer
->	O
offset	long
+	O
8	int
-	O
new_offset	int
;	O
if	O
(	O
ent	pointer
->	O
make_relative	int
)	O
value	long
-=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
new_offset	int
+	O
ent	pointer
->	O
set_loc	pointer
[	O
cnt	int
]	O
)	O
;	O
write_value	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
value	long
,	O
width	int
)	O
;	O
}	O
}	O
}	O
}	O
return	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
(	O
file_ptr	long
)	O
sec	pointer
->	O
output_offset	long
,	O
sec	pointer
->	O
size	long
)	O
;	O
}	O
static	O
int	O
vma_compare	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
eh_frame_array_ent	struct
*	O
p	pointer
=	O
(	O
const	O
struct	O
eh_frame_array_ent	struct
*	O
)	O
a	pointer
;	O
const	O
struct	O
eh_frame_array_ent	struct
*	O
q	pointer
=	O
(	O
const	O
struct	O
eh_frame_array_ent	struct
*	O
)	O
b	pointer
;	O
if	O
(	O
p	pointer
->	O
initial_loc	long
>	O
q	pointer
->	O
initial_loc	long
)	O
return	O
1	int
;	O
if	O
(	O
p	pointer
->	O
initial_loc	long
<	O
q	pointer
->	O
initial_loc	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
p	pointer
->	O
range	long
>	O
q	pointer
->	O
range	long
)	O
return	O
1	int
;	O
if	O
(	O
p	pointer
->	O
range	long
<	O
q	pointer
->	O
range	long
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
bfd_boolean	int
_bfd_elf_fixup_eh_frame_hdr	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
NULL	O
;	O
asection	struct
*	O
osec	pointer
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_vma	long
offset	long
;	O
struct	O
bfd_link_order	struct
*	O
p	pointer
;	O
hdr_info	pointer
=	O
&	O
elf_hash_table	O
(	O
info	pointer
)	O
->	O
eh_info	struct
;	O
if	O
(	O
hdr_info	pointer
->	O
hdr_sec	pointer
==	O
NULL	O
||	O
info	pointer
->	O
eh_frame_hdr_type	int
!=	O
COMPACT_EH_HDR	int
||	O
hdr_info	pointer
->	O
array_count	int
==	O
0	int
)	O
return	O
TRUE	int
;	O
offset	long
=	O
8	int
;	O
osec	pointer
=	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
0	int
]	O
->	O
output_section	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr_info	pointer
->	O
array_count	int
;	O
i	pointer
++	O
)	O
{	O
sec	pointer
=	O
hdr_info	pointer
->	O
u	union
.	O
compact	struct
.	O
entries	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
sec	pointer
->	O
output_section	pointer
!=	O
osec	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"invalid output section for .eh_frame_entry: %pA"	pointer
)	O
,	O
sec	pointer
->	O
output_section	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
sec	pointer
->	O
output_offset	long
=	O
offset	long
;	O
offset	long
+=	O
sec	pointer
->	O
size	long
;	O
}	O
for	O
(	O
p	pointer
=	O
sec	pointer
->	O
output_section	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
!=	O
bfd_indirect_link_order	int
)	O
abort	function
(	O
)	O
;	O
p	pointer
->	O
offset	long
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
output_offset	long
;	O
if	O
(	O
p	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
i	pointer
--	O
;	O
}	O
if	O
(	O
i	pointer
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"invalid contents in %pA section"	pointer
)	O
,	O
osec	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
write_compact_eh_frame_hdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_vma	long
count	int
;	O
bfd_byte	char
contents	pointer
[	O
8	int
]	O
;	O
unsigned	O
int	O
i	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
sec	pointer
=	O
hdr_info	pointer
->	O
hdr_sec	pointer
;	O
if	O
(	O
sec	pointer
->	O
size	long
!=	O
8	int
)	O
abort	function
(	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
contents	pointer
)	O
;	O
i	pointer
++	O
)	O
contents	pointer
[	O
i	pointer
]	O
=	O
0	int
;	O
contents	pointer
[	O
0	int
]	O
=	O
COMPACT_EH_HDR	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
BFD_ASSERT	O
(	O
bed	pointer
->	O
compact_eh_encoding	pointer
)	O
;	O
contents	pointer
[	O
1	int
]	O
=	O
(	O
*	O
bed	pointer
->	O
compact_eh_encoding	pointer
)	O
(	O
info	pointer
)	O
;	O
count	int
=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
size	long
-	O
8	int
)	O
/	O
8	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
count	int
,	O
contents	pointer
+	O
4	int
)	O
;	O
return	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
(	O
file_ptr	long
)	O
sec	pointer
->	O
output_offset	long
,	O
sec	pointer
->	O
size	long
)	O
;	O
}	O
static	O
bfd_boolean	int
write_dwarf_eh_frame_hdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
bfd_boolean	int
retval	pointer
=	O
TRUE	int
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
sec	pointer
=	O
hdr_info	pointer
->	O
hdr_sec	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
asection	struct
*	O
eh_frame_sec	pointer
;	O
bfd_size_type	long
size	long
;	O
bfd_vma	long
encoded_eh_frame	long
;	O
size	long
=	O
EH_FRAME_HDR_SIZE	int
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
&&	O
hdr_info	pointer
->	O
array_count	int
==	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
)	O
size	long
+=	O
4	int
+	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
*	O
8	int
;	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
eh_frame_sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".eh_frame"	pointer
)	O
;	O
if	O
(	O
eh_frame_sec	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
contents	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
memset	function
(	O
contents	pointer
,	O
0	int
,	O
EH_FRAME_HDR_SIZE	int
)	O
;	O
contents	pointer
[	O
0	int
]	O
=	O
1	int
;	O
contents	pointer
[	O
1	int
]	O
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_backend_encode_eh_address	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
eh_frame_sec	pointer
,	O
0	int
,	O
sec	pointer
,	O
4	int
,	O
&	O
encoded_eh_frame	long
)	O
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
&&	O
hdr_info	pointer
->	O
array_count	int
==	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
)	O
{	O
contents	pointer
[	O
2	int
]	O
=	O
DW_EH_PE_udata4	int
;	O
contents	pointer
[	O
3	int
]	O
=	O
DW_EH_PE_datarel	int
|	O
DW_EH_PE_sdata4	int
;	O
}	O
else	O
{	O
contents	pointer
[	O
2	int
]	O
=	O
DW_EH_PE_omit	int
;	O
contents	pointer
[	O
3	int
]	O
=	O
DW_EH_PE_omit	int
;	O
}	O
bfd_put_32	O
(	O
abfd	pointer
,	O
encoded_eh_frame	long
,	O
contents	pointer
+	O
4	int
)	O
;	O
if	O
(	O
contents	pointer
[	O
2	int
]	O
!=	O
DW_EH_PE_omit	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
bfd_boolean	int
overlap	int
,	O
overflow	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
,	O
contents	pointer
+	O
EH_FRAME_HDR_SIZE	int
)	O
;	O
qsort	function
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
,	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
,	O
sizeof	O
(	O
*	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
)	O
,	O
vma_compare	function
)	O
;	O
overlap	int
=	O
FALSE	int
;	O
overflow	int
=	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
fde_count	int
;	O
i	pointer
++	O
)	O
{	O
bfd_vma	long
val	array
;	O
val	array
=	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
]	O
.	O
initial_loc	long
-	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
val	array
=	O
(	O
(	O
val	array
&	O
0xffffffff	int
)	O
^	O
0x80000000	int
)	O
-	O
0x80000000	int
;	O
if	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
&&	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
]	O
.	O
initial_loc	long
!=	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
val	array
)	O
)	O
overflow	int
=	O
TRUE	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
val	array
,	O
contents	pointer
+	O
EH_FRAME_HDR_SIZE	int
+	O
i	pointer
*	O
8	int
+	O
4	int
)	O
;	O
val	array
=	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
]	O
.	O
fde	struct
-	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
val	array
=	O
(	O
(	O
val	array
&	O
0xffffffff	int
)	O
^	O
0x80000000	int
)	O
-	O
0x80000000	int
;	O
if	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
&&	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
]	O
.	O
fde	struct
!=	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
val	array
)	O
)	O
overflow	int
=	O
TRUE	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
val	array
,	O
contents	pointer
+	O
EH_FRAME_HDR_SIZE	int
+	O
i	pointer
*	O
8	int
+	O
8	int
)	O
;	O
if	O
(	O
i	pointer
!=	O
0	int
&&	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
]	O
.	O
initial_loc	long
<	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
-	O
1	int
]	O
.	O
initial_loc	long
+	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
[	O
i	pointer
-	O
1	int
]	O
.	O
range	long
)	O
)	O
)	O
overlap	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
overflow	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
".eh_frame_hdr entry overflow"	pointer
)	O
)	O
;	O
if	O
(	O
overlap	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
".eh_frame_hdr refers to overlapping FDEs"	pointer
)	O
)	O
;	O
if	O
(	O
overflow	int
||	O
overlap	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
retval	pointer
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
(	O
file_ptr	long
)	O
sec	pointer
->	O
output_offset	long
,	O
sec	pointer
->	O
size	long
)	O
)	O
retval	pointer
=	O
FALSE	int
;	O
free	function
(	O
contents	pointer
)	O
;	O
if	O
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
!=	O
NULL	O
)	O
free	function
(	O
hdr_info	pointer
->	O
u	union
.	O
dwarf	struct
.	O
array	pointer
)	O
;	O
return	O
retval	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_write_section_eh_frame_hdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
struct	O
eh_frame_hdr_info	struct
*	O
hdr_info	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
hdr_info	pointer
=	O
&	O
htab	struct
->	O
eh_info	struct
;	O
sec	pointer
=	O
hdr_info	pointer
->	O
hdr_sec	pointer
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
0	int
||	O
sec	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
info	pointer
->	O
eh_frame_hdr_type	int
==	O
COMPACT_EH_HDR	int
)	O
return	O
write_compact_eh_frame_hdr	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
else	O
return	O
write_dwarf_eh_frame_hdr	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
unsigned	O
int	O
_bfd_elf_eh_frame_address_size	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
?	O
8	int
:	O
4	int
;	O
}	O
bfd_boolean	int
_bfd_elf_can_make_relative	function
(	O
bfd	struct
*	O
input_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
eh_frame_section	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
bfd_byte	char
_bfd_elf_encode_eh_address	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
osec	pointer
,	O
bfd_vma	long
offset	long
,	O
asection	struct
*	O
loc_sec	pointer
,	O
bfd_vma	long
loc_offset	long
,	O
bfd_vma	long
*	O
encoded	pointer
)	O
{	O
*	O
encoded	pointer
=	O
osec	pointer
->	O
vma	long
+	O
offset	long
-	O
(	O
loc_sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
loc_sec	pointer
->	O
output_offset	long
+	O
loc_offset	long
)	O
;	O
return	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
;	O
}	O