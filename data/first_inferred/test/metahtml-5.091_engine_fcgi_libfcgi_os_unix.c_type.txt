static	O
const	O
char	O
rcsid	array
[	O
]	O
=	O
"$Id: os_unix.c,v 1.1.1.1 1998/11/07 21:16:23 bfox Exp $"	pointer
;	O
typedef	O
void	O
*	O
ClientData	pointer
;	O
typedef	O
struct	O
{	O
OS_AsyncProc	O
procPtr	int
;	O
ClientData	pointer
clientData	pointer
;	O
int	O
fd	int
;	O
int	O
len	int
;	O
int	O
offset	int
;	O
void	O
*	O
buf	pointer
;	O
int	O
inUse	int
;	O
}	O
AioInfo	struct
;	O
static	O
int	O
asyncIoTableSize	int
=	O
16	int
;	O
static	O
AioInfo	struct
*	O
asyncIoTable	pointer
=	O
NULL	O
;	O
static	O
int	O
isFastCGI	int
=	O
FALSE	O
;	O
static	O
int	O
libInitialized	int
=	O
FALSE	O
;	O
static	O
fd_set	struct
readFdSet	struct
;	O
static	O
fd_set	struct
writeFdSet	struct
;	O
static	O
fd_set	struct
readFdSetPost	struct
;	O
static	O
int	O
numRdPosted	int
=	O
0	int
;	O
static	O
fd_set	struct
writeFdSetPost	struct
;	O
static	O
int	O
numWrPosted	int
=	O
0	int
;	O
static	O
int	O
volatile	O
maxFd	int
=	O
-	O
1	int
;	O
static	O
int	O
fcgiSocket	int
=	O
-	O
1	int
;	O
union	O
u_sockaddr	union
{	O
struct	O
sockaddr_un	O
un	struct
;	O
struct	O
sockaddr_in	O
in	struct
;	O
}	O
static	O
fcgiSa	union
;	O
static	O
int	O
fcgiClilen	int
;	O
int	O
OS_LibInit	function
(	O
int	O
stdioFds	array
[	O
3	int
]	O
)	O
{	O
if	O
(	O
libInitialized	int
)	O
return	O
0	int
;	O
asyncIoTable	pointer
=	O
malloc	O
(	O
asyncIoTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct
)	O
)	O
;	O
if	O
(	O
asyncIoTable	pointer
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
memset	O
(	O
(	O
char	O
*	O
)	O
asyncIoTable	pointer
,	O
0	int
,	O
asyncIoTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct
)	O
)	O
;	O
FD_ZERO	O
(	O
&	O
readFdSet	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
writeFdSet	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
readFdSetPost	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
writeFdSetPost	struct
)	O
;	O
libInitialized	int
=	O
TRUE	O
;	O
return	O
0	int
;	O
}	O
void	O
OS_LibShutdown	function
(	O
)	O
{	O
if	O
(	O
!	O
libInitialized	int
)	O
return	O
;	O
free	function
(	O
asyncIoTable	pointer
)	O
;	O
asyncIoTable	pointer
=	O
NULL	O
;	O
libInitialized	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
static	O
int	O
OS_BuildSockAddrUn	function
(	O
char	O
*	O
bindPath	pointer
,	O
struct	O
sockaddr_un	O
*	O
servAddrPtr	pointer
,	O
int	O
*	O
servAddrLen	pointer
)	O
{	O
int	O
bindPathLen	int
=	O
strlen	O
(	O
bindPath	pointer
)	O
;	O
if	O
(	O
bindPathLen	int
>	O
sizeof	O
(	O
servAddrPtr	pointer
->	O
sun_path	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
memset	O
(	O
(	O
char	O
*	O
)	O
servAddrPtr	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
servAddrPtr	pointer
)	O
)	O
;	O
servAddrPtr	pointer
->	O
sun_family	O
=	O
AF_UNIX	O
;	O
memcpy	O
(	O
servAddrPtr	pointer
->	O
sun_path	O
,	O
bindPath	pointer
,	O
bindPathLen	int
)	O
;	O
*	O
servAddrLen	pointer
=	O
sizeof	O
(	O
servAddrPtr	pointer
->	O
sun_family	O
)	O
+	O
bindPathLen	int
;	O
return	O
0	int
;	O
}	O
union	O
SockAddrUnion	union
{	O
struct	O
sockaddr_un	O
unixVariant	struct
;	O
struct	O
sockaddr_in	O
inetVariant	struct
;	O
}	O
;	O
int	O
OS_CreateLocalIpcFd	function
(	O
char	O
*	O
bindPath	pointer
)	O
{	O
int	O
listenSock	int
,	O
servLen	int
;	O
union	O
SockAddrUnion	union
sa	union
;	O
int	O
tcp	int
=	O
FALSE	O
;	O
char	O
*	O
tp	pointer
;	O
short	O
port	short
;	O
char	O
host	char
[	O
MAXPATHLEN	O
]	O
;	O
strcpy	O
(	O
host	char
,	O
bindPath	pointer
)	O
;	O
if	O
(	O
(	O
tp	pointer
=	O
strchr	O
(	O
host	char
,	O
':'	O
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
tp	pointer
++	O
=	O
0	int
;	O
if	O
(	O
(	O
port	short
=	O
atoi	function
(	O
tp	pointer
)	O
)	O
==	O
0	int
)	O
{	O
*	O
--	O
tp	pointer
=	O
':'	O
;	O
}	O
else	O
{	O
tcp	int
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
tcp	int
&&	O
(	O
*	O
host	char
&&	O
strcmp	O
(	O
host	char
,	O
"localhost"	pointer
)	O
!=	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"To start a service on a TCP port can not "	pointer
"specify a host name.\n"	pointer
"You should either use \"localhost:<port>\" or "	pointer
" just use \":<port>.\"\n"	pointer
)	O
;	O
exit	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
tcp	int
)	O
{	O
listenSock	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
if	O
(	O
listenSock	int
>=	O
0	int
)	O
{	O
int	O
flag	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
listenSock	int
,	O
SOL_SOCKET	O
,	O
SO_REUSEADDR	O
,	O
(	O
char	O
*	O
)	O
&	O
flag	int
,	O
sizeof	O
(	O
flag	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Can't set SO_REUSEADDR.\n"	pointer
)	O
;	O
exit	O
(	O
1001	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
listenSock	int
=	O
socket	function
(	O
AF_UNIX	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
listenSock	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tcp	int
)	O
{	O
memset	O
(	O
(	O
char	O
*	O
)	O
&	O
sa	union
.	O
inetVariant	struct
,	O
0	int
,	O
sizeof	O
(	O
sa	union
.	O
inetVariant	struct
)	O
)	O
;	O
sa	union
.	O
inetVariant	struct
.	O
sin_family	O
=	O
AF_INET	O
;	O
sa	union
.	O
inetVariant	struct
.	O
sin_addr	O
.	O
s_addr	O
=	O
htonl	function
(	O
INADDR_ANY	O
)	O
;	O
sa	union
.	O
inetVariant	struct
.	O
sin_port	O
=	O
htons	function
(	O
port	short
)	O
;	O
servLen	int
=	O
sizeof	O
(	O
sa	union
.	O
inetVariant	struct
)	O
;	O
}	O
else	O
{	O
unlink	function
(	O
bindPath	pointer
)	O
;	O
if	O
(	O
OS_BuildSockAddrUn	function
(	O
bindPath	pointer
,	O
&	O
sa	union
.	O
unixVariant	struct
,	O
&	O
servLen	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Listening socket's path name is too long.\n"	pointer
)	O
;	O
exit	O
(	O
1000	int
)	O
;	O
}	O
}	O
if	O
(	O
bind	function
(	O
listenSock	int
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
sa	union
.	O
unixVariant	struct
,	O
servLen	int
)	O
<	O
0	int
||	O
listen	function
(	O
listenSock	int
,	O
5	int
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"bind/listen"	pointer
)	O
;	O
exit	O
(	O
errno	O
)	O
;	O
}	O
return	O
listenSock	int
;	O
}	O
int	O
OS_FcgiConnect	function
(	O
char	O
*	O
bindPath	pointer
)	O
{	O
union	O
SockAddrUnion	union
sa	union
;	O
int	O
servLen	int
,	O
resultSock	int
;	O
int	O
connectStatus	int
;	O
char	O
*	O
tp	pointer
;	O
char	O
host	char
[	O
MAXPATHLEN	O
]	O
;	O
short	O
port	short
;	O
int	O
tcp	int
=	O
FALSE	O
;	O
strcpy	O
(	O
host	char
,	O
bindPath	pointer
)	O
;	O
if	O
(	O
(	O
tp	pointer
=	O
strchr	O
(	O
host	char
,	O
':'	O
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
tp	pointer
++	O
=	O
0	int
;	O
if	O
(	O
(	O
port	short
=	O
atoi	function
(	O
tp	pointer
)	O
)	O
==	O
0	int
)	O
{	O
*	O
--	O
tp	pointer
=	O
':'	O
;	O
}	O
else	O
{	O
tcp	int
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
tcp	int
==	O
TRUE	O
)	O
{	O
struct	O
hostent	O
*	O
hp	pointer
;	O
if	O
(	O
(	O
hp	pointer
=	O
gethostbyname	function
(	O
(	O
*	O
host	char
?	O
host	char
:	O
"localhost"	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unknown host: %s\n"	pointer
,	O
bindPath	pointer
)	O
;	O
exit	O
(	O
1000	int
)	O
;	O
}	O
sa	union
.	O
inetVariant	struct
.	O
sin_family	O
=	O
AF_INET	O
;	O
memcpy	O
(	O
(	O
caddr_t	pointer
)	O
&	O
sa	union
.	O
inetVariant	struct
.	O
sin_addr	O
,	O
hp	pointer
->	O
h_addr	O
,	O
hp	pointer
->	O
h_length	O
)	O
;	O
sa	union
.	O
inetVariant	struct
.	O
sin_port	O
=	O
htons	function
(	O
port	short
)	O
;	O
servLen	int
=	O
sizeof	O
(	O
sa	union
.	O
inetVariant	struct
)	O
;	O
resultSock	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
OS_BuildSockAddrUn	function
(	O
bindPath	pointer
,	O
&	O
sa	union
.	O
unixVariant	struct
,	O
&	O
servLen	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Listening socket's path name is too long.\n"	pointer
)	O
;	O
exit	O
(	O
1000	int
)	O
;	O
}	O
resultSock	int
=	O
socket	function
(	O
AF_UNIX	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
}	O
assert	function
(	O
resultSock	int
>=	O
0	int
)	O
;	O
connectStatus	int
=	O
connect	function
(	O
resultSock	int
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
sa	union
.	O
unixVariant	struct
,	O
servLen	int
)	O
;	O
if	O
(	O
connectStatus	int
>=	O
0	int
)	O
{	O
return	O
resultSock	int
;	O
}	O
else	O
{	O
close	function
(	O
resultSock	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
OS_Read	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
)	O
{	O
return	O
(	O
read	function
(	O
fd	int
,	O
buf	pointer
,	O
len	int
)	O
)	O
;	O
}	O
int	O
OS_Write	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
)	O
{	O
return	O
(	O
write	function
(	O
fd	int
,	O
buf	pointer
,	O
len	int
)	O
)	O
;	O
}	O
int	O
OS_SpawnChild	function
(	O
char	O
*	O
appPath	pointer
,	O
int	O
listenFd	int
)	O
{	O
int	O
forkResult	int
;	O
forkResult	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
forkResult	int
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
if	O
(	O
forkResult	int
==	O
0	int
)	O
{	O
close	function
(	O
STDIN_FILENO	int
)	O
;	O
if	O
(	O
listenFd	int
!=	O
FCGI_LISTENSOCK_FILENO	O
)	O
{	O
dup2	function
(	O
listenFd	int
,	O
FCGI_LISTENSOCK_FILENO	O
)	O
;	O
close	function
(	O
listenFd	int
)	O
;	O
}	O
close	function
(	O
STDOUT_FILENO	int
)	O
;	O
close	function
(	O
STDERR_FILENO	int
)	O
;	O
execl	function
(	O
appPath	pointer
,	O
appPath	pointer
,	O
NULL	O
)	O
;	O
exit	O
(	O
errno	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
OS_AsyncReadStdin	function
(	O
void	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
OS_AsyncProc	O
procPtr	int
,	O
ClientData	pointer
clientData	pointer
)	O
{	O
int	O
index	int
=	O
AIO_RD_IX	O
(	O
STDIN_FILENO	int
)	O
;	O
ASSERT	O
(	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
==	O
0	int
)	O
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
procPtr	int
=	O
procPtr	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
clientData	pointer
=	O
clientData	pointer
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
fd	int
=	O
STDIN_FILENO	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
len	int
=	O
len	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
offset	int
=	O
0	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
buf	pointer
=	O
buf	pointer
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
=	O
1	int
;	O
FD_SET	O
(	O
STDIN_FILENO	int
,	O
&	O
readFdSet	struct
)	O
;	O
if	O
(	O
STDIN_FILENO	int
>	O
maxFd	int
)	O
maxFd	int
=	O
STDIN_FILENO	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
GrowAsyncTable	function
(	O
void	O
)	O
{	O
int	O
oldTableSize	int
=	O
asyncIoTableSize	int
;	O
asyncIoTableSize	int
=	O
asyncIoTableSize	int
*	O
2	int
;	O
asyncIoTable	pointer
=	O
realloc	O
(	O
asyncIoTable	pointer
,	O
asyncIoTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct
)	O
)	O
;	O
if	O
(	O
asyncIoTable	pointer
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOMEM	O
;	O
exit	O
(	O
errno	O
)	O
;	O
}	O
memset	O
(	O
(	O
char	O
*	O
)	O
&	O
asyncIoTable	pointer
[	O
oldTableSize	int
]	O
,	O
0	int
,	O
oldTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct
)	O
)	O
;	O
}	O
int	O
OS_AsyncRead	function
(	O
int	O
fd	int
,	O
int	O
offset	int
,	O
void	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
OS_AsyncProc	O
procPtr	int
,	O
ClientData	pointer
clientData	pointer
)	O
{	O
int	O
index	int
=	O
AIO_RD_IX	O
(	O
fd	int
)	O
;	O
ASSERT	O
(	O
asyncIoTable	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
fd	int
>	O
maxFd	int
)	O
maxFd	int
=	O
fd	int
;	O
if	O
(	O
index	int
>=	O
asyncIoTableSize	int
)	O
{	O
GrowAsyncTable	function
(	O
)	O
;	O
}	O
ASSERT	O
(	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
==	O
0	int
)	O
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
procPtr	int
=	O
procPtr	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
clientData	pointer
=	O
clientData	pointer
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
fd	int
=	O
fd	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
len	int
=	O
len	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
offset	int
=	O
offset	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
buf	pointer
=	O
buf	pointer
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
=	O
1	int
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
readFdSet	struct
)	O
;	O
return	O
0	int
;	O
}	O
int	O
OS_AsyncWrite	function
(	O
int	O
fd	int
,	O
int	O
offset	int
,	O
void	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
OS_AsyncProc	O
procPtr	int
,	O
ClientData	pointer
clientData	pointer
)	O
{	O
int	O
index	int
=	O
AIO_WR_IX	O
(	O
fd	int
)	O
;	O
if	O
(	O
fd	int
>	O
maxFd	int
)	O
maxFd	int
=	O
fd	int
;	O
if	O
(	O
index	int
>=	O
asyncIoTableSize	int
)	O
{	O
GrowAsyncTable	function
(	O
)	O
;	O
}	O
ASSERT	O
(	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
==	O
0	int
)	O
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
procPtr	int
=	O
procPtr	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
clientData	pointer
=	O
clientData	pointer
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
fd	int
=	O
fd	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
len	int
=	O
len	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
offset	int
=	O
offset	int
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
buf	pointer
=	O
buf	pointer
;	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
=	O
1	int
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
writeFdSet	struct
)	O
;	O
return	O
0	int
;	O
}	O
int	O
OS_Close	function
(	O
int	O
fd	int
)	O
{	O
int	O
index	int
=	O
AIO_RD_IX	O
(	O
fd	int
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSet	struct
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct
)	O
;	O
if	O
(	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
!=	O
0	int
)	O
{	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
=	O
0	int
;	O
}	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSet	struct
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct
)	O
;	O
index	int
=	O
AIO_WR_IX	O
(	O
fd	int
)	O
;	O
if	O
(	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
!=	O
0	int
)	O
{	O
asyncIoTable	pointer
[	O
index	int
]	O
.	O
inUse	int
=	O
0	int
;	O
}	O
if	O
(	O
maxFd	int
==	O
fd	int
)	O
maxFd	int
--	O
;	O
return	O
close	function
(	O
fd	int
)	O
;	O
}	O
int	O
OS_CloseRead	function
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
asyncIoTable	pointer
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
!=	O
0	int
)	O
{	O
asyncIoTable	pointer
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
=	O
0	int
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSet	struct
)	O
;	O
}	O
return	O
shutdown	function
(	O
fd	int
,	O
0	int
)	O
;	O
}	O
int	O
OS_DoIo	function
(	O
struct	O
timeval	struct
*	O
tmo	pointer
)	O
{	O
int	O
fd	int
,	O
len	int
,	O
selectStatus	int
;	O
OS_AsyncProc	O
procPtr	int
;	O
ClientData	pointer
clientData	pointer
;	O
AioInfo	struct
*	O
aioPtr	pointer
;	O
fd_set	struct
readFdSetCpy	struct
;	O
fd_set	struct
writeFdSetCpy	struct
;	O
FD_ZERO	O
(	O
&	O
readFdSetCpy	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
writeFdSetCpy	struct
)	O
;	O
for	O
(	O
fd	int
=	O
0	int
;	O
fd	int
<=	O
maxFd	int
;	O
fd	int
++	O
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readFdSet	struct
)	O
)	O
{	O
FD_SET	O
(	O
fd	int
,	O
&	O
readFdSetCpy	struct
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
writeFdSet	struct
)	O
)	O
{	O
FD_SET	O
(	O
fd	int
,	O
&	O
writeFdSetCpy	struct
)	O
;	O
}	O
}	O
if	O
(	O
numRdPosted	int
==	O
0	int
&&	O
numWrPosted	int
==	O
0	int
)	O
{	O
selectStatus	int
=	O
select	function
(	O
(	O
maxFd	int
+	O
1	int
)	O
,	O
&	O
readFdSetCpy	struct
,	O
&	O
writeFdSetCpy	struct
,	O
NULL	O
,	O
tmo	pointer
)	O
;	O
if	O
(	O
selectStatus	int
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
for	O
(	O
fd	int
=	O
0	int
;	O
fd	int
<=	O
maxFd	int
;	O
fd	int
++	O
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readFdSetCpy	struct
)	O
)	O
{	O
numRdPosted	int
++	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSet	struct
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
writeFdSetCpy	struct
)	O
)	O
{	O
numWrPosted	int
++	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSet	struct
)	O
;	O
}	O
}	O
}	O
if	O
(	O
numRdPosted	int
==	O
0	int
&&	O
numWrPosted	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
fd	int
=	O
0	int
;	O
fd	int
<=	O
maxFd	int
;	O
fd	int
++	O
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct
)	O
&&	O
asyncIoTable	pointer
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
)	O
{	O
numRdPosted	int
--	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct
)	O
;	O
aioPtr	pointer
=	O
&	O
asyncIoTable	pointer
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
;	O
len	int
=	O
read	function
(	O
aioPtr	pointer
->	O
fd	int
,	O
aioPtr	pointer
->	O
buf	pointer
,	O
aioPtr	pointer
->	O
len	int
)	O
;	O
procPtr	int
=	O
aioPtr	pointer
->	O
procPtr	int
;	O
aioPtr	pointer
->	O
procPtr	int
=	O
NULL	O
;	O
clientData	pointer
=	O
aioPtr	pointer
->	O
clientData	pointer
;	O
aioPtr	pointer
->	O
inUse	int
=	O
0	int
;	O
(	O
*	O
procPtr	int
)	O
(	O
clientData	pointer
,	O
len	int
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct
)	O
&&	O
asyncIoTable	pointer
[	O
AIO_WR_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
)	O
{	O
numWrPosted	int
--	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct
)	O
;	O
aioPtr	pointer
=	O
&	O
asyncIoTable	pointer
[	O
AIO_WR_IX	O
(	O
fd	int
)	O
]	O
;	O
len	int
=	O
write	function
(	O
aioPtr	pointer
->	O
fd	int
,	O
aioPtr	pointer
->	O
buf	pointer
,	O
aioPtr	pointer
->	O
len	int
)	O
;	O
procPtr	int
=	O
aioPtr	pointer
->	O
procPtr	int
;	O
aioPtr	pointer
->	O
procPtr	int
=	O
NULL	O
;	O
clientData	pointer
=	O
aioPtr	pointer
->	O
clientData	pointer
;	O
aioPtr	pointer
->	O
inUse	int
=	O
0	int
;	O
(	O
*	O
procPtr	int
)	O
(	O
clientData	pointer
,	O
len	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ClientAddrOK	function
(	O
struct	O
sockaddr_in	O
*	O
saPtr	pointer
,	O
char	O
*	O
clientList	pointer
)	O
{	O
int	O
result	int
=	O
FALSE	O
;	O
char	O
*	O
clientListCopy	pointer
,	O
*	O
cur	pointer
,	O
*	O
next	pointer
;	O
char	O
*	O
newString	pointer
=	O
NULL	O
;	O
int	O
strLen	int
;	O
if	O
(	O
clientList	pointer
==	O
NULL	O
||	O
*	O
clientList	pointer
==	O
'\0'	O
)	O
{	O
return	O
TRUE	O
;	O
}	O
strLen	int
=	O
strlen	O
(	O
clientList	pointer
)	O
;	O
clientListCopy	pointer
=	O
malloc	O
(	O
strLen	int
+	O
1	int
)	O
;	O
assert	function
(	O
newString	pointer
!=	O
NULL	O
)	O
;	O
memcpy	O
(	O
newString	pointer
,	O
clientList	pointer
,	O
strLen	int
)	O
;	O
newString	pointer
[	O
strLen	int
]	O
=	O
'\000'	O
;	O
for	O
(	O
cur	pointer
=	O
clientListCopy	pointer
;	O
cur	pointer
!=	O
NULL	O
;	O
cur	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
strchr	O
(	O
cur	pointer
,	O
','	O
)	O
;	O
if	O
(	O
next	pointer
!=	O
NULL	O
)	O
{	O
*	O
next	pointer
++	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
inet_addr	function
(	O
cur	pointer
)	O
==	O
saPtr	pointer
->	O
sin_addr	O
.	O
s_addr	O
)	O
{	O
result	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
clientListCopy	pointer
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
AcquireLock	function
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
ReleaseLock	function
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
int	O
OS_FcgiIpcAccept	function
(	O
char	O
*	O
clientAddrList	pointer
)	O
{	O
int	O
socket	function
;	O
union	O
u_sockaddr	union
{	O
struct	O
sockaddr_un	O
un	struct
;	O
struct	O
sockaddr_in	O
in	struct
;	O
}	O
sa	union
;	O
int	O
clilen	int
=	O
sizeof	O
(	O
sa	union
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
AcquireLock	function
(	O
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fcgiSocket	int
!=	O
-	O
1	int
)	O
{	O
socket	function
=	O
fcgiSocket	int
;	O
memcpy	O
(	O
&	O
sa	union
,	O
&	O
fcgiSa	union
,	O
fcgiClilen	int
)	O
;	O
clilen	int
=	O
fcgiClilen	int
;	O
fcgiSocket	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
do	O
{	O
socket	function
=	O
accept	function
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
sa	union
.	O
un	struct
,	O
&	O
clilen	int
)	O
;	O
}	O
while	O
(	O
(	O
socket	function
<	O
0	int
)	O
&&	O
(	O
errno	O
==	O
EINTR	O
)	O
)	O
;	O
}	O
if	O
(	O
ReleaseLock	function
(	O
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
socket	function
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
sa	union
.	O
in	struct
.	O
sin_family	O
==	O
AF_INET	O
&&	O
!	O
ClientAddrOK	function
(	O
&	O
sa	union
.	O
in	struct
,	O
clientAddrList	pointer
)	O
)	O
{	O
close	function
(	O
socket	function
)	O
;	O
socket	function
=	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
socket	function
;	O
}	O
}	O
}	O
int	O
OS_IpcClose	function
(	O
int	O
ipcFd	int
)	O
{	O
return	O
OS_Close	function
(	O
ipcFd	int
)	O
;	O
}	O
int	O
OS_IsFcgi	function
(	O
)	O
{	O
int	O
flags	int
,	O
flags1	int
;	O
fcgiClilen	int
=	O
sizeof	O
(	O
fcgiSa	union
)	O
;	O
flags	int
=	O
fcntl	function
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
F_GETFL	O
,	O
0	int
)	O
;	O
flags	int
|=	O
O_NONBLOCK	O
;	O
if	O
(	O
(	O
fcntl	function
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
F_SETFL	O
,	O
flags	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
assert	function
(	O
errno	O
==	O
0	int
)	O
;	O
}	O
fcgiSocket	int
=	O
accept	function
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
fcgiSa	union
.	O
un	struct
,	O
&	O
fcgiClilen	int
)	O
;	O
if	O
(	O
fcgiSocket	int
>=	O
0	int
)	O
{	O
flags1	int
=	O
fcntl	function
(	O
fcgiSocket	int
,	O
F_GETFL	O
,	O
0	int
)	O
;	O
flags1	int
&=	O
~	O
(	O
O_NONBLOCK	O
)	O
;	O
if	O
(	O
(	O
fcntl	function
(	O
fcgiSocket	int
,	O
F_SETFL	O
,	O
flags1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
assert	function
(	O
errno	O
==	O
0	int
)	O
;	O
}	O
isFastCGI	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
isFastCGI	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
isFastCGI	int
=	O
FALSE	O
;	O
}	O
}	O
flags	int
&=	O
~	O
(	O
O_NONBLOCK	O
)	O
;	O
if	O
(	O
(	O
fcntl	function
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
F_SETFL	O
,	O
flags	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
assert	function
(	O
errno	O
==	O
0	int
)	O
;	O
}	O
return	O
isFastCGI	int
;	O
}	O
void	O
OS_SetFlags	function
(	O
int	O
fd	int
,	O
int	O
flags	int
)	O
{	O
int	O
val	int
;	O
if	O
(	O
(	O
val	int
=	O
fcntl	function
(	O
fd	int
,	O
F_GETFL	O
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
val	int
|=	O
flags	int
;	O
if	O
(	O
fcntl	function
(	O
fd	int
,	O
F_SETFL	O
,	O
val	int
)	O
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
}	O