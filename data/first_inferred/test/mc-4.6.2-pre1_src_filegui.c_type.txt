typedef	O
struct	O
{	O
int	O
showing_eta	int
;	O
int	O
showing_bps	int
;	O
int	O
eta_extra	int
;	O
Dlg_head	struct
*	O
op_dlg	pointer
;	O
WLabel	struct
*	O
file_label	array
[	O
2	int
]	O
;	O
WLabel	struct
*	O
file_string	array
[	O
2	int
]	O
;	O
WLabel	struct
*	O
progress_label	array
[	O
3	int
]	O
;	O
WGauge	struct
*	O
progress_gauge	array
[	O
3	int
]	O
;	O
WLabel	struct
*	O
eta_label	pointer
;	O
WLabel	struct
*	O
bps_label	pointer
;	O
WLabel	struct
*	O
stalled_label	pointer
;	O
Dlg_head	struct
*	O
replace_dlg	pointer
;	O
const	O
char	O
*	O
replace_filename	pointer
;	O
int	O
replace_result	int
;	O
struct	O
stat	struct
*	O
s_stat	pointer
,	O
*	O
d_stat	pointer
;	O
}	O
FileOpContextUI	struct
;	O
static	O
int	O
last_hint_line	int
;	O
enum	O
{	O
REPLACE_YES	int
=	O
B_USER	int
,	O
REPLACE_NO	int
,	O
REPLACE_APPEND	int
,	O
REPLACE_ALWAYS	int
,	O
REPLACE_UPDATE	int
,	O
REPLACE_NEVER	int
,	O
REPLACE_ABORT	int
,	O
REPLACE_SIZE	int
,	O
REPLACE_REGET	int
}	O
;	O
static	O
FileProgressStatus	enum
check_progress_buttons	function
(	O
FileOpContext	struct
*	O
ctx	pointer
)	O
{	O
int	O
c	int
;	O
Gpm_Event	struct
event	pointer
;	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
event	pointer
.	O
x	array
=	O
-	O
1	int
;	O
c	int
=	O
get_event	function
(	O
&	O
event	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
c	int
==	O
EV_NONE	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
->	O
op_dlg	pointer
->	O
ret_value	int
=	O
FILE_CONT	int
;	O
dlg_process_event	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
c	int
,	O
&	O
event	pointer
)	O
;	O
switch	O
(	O
ui	pointer
->	O
op_dlg	pointer
->	O
ret_value	int
)	O
{	O
case	O
FILE_SKIP	int
:	O
return	O
FILE_SKIP	int
;	O
break	O
;	O
case	O
B_CANCEL	int
:	O
case	O
FILE_ABORT	int
:	O
return	O
FILE_ABORT	int
;	O
break	O
;	O
default	O
:	O
return	O
FILE_CONT	int
;	O
}	O
}	O
void	O
file_op_context_create_ui	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
int	O
with_eta	int
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
int	O
x_size	int
;	O
int	O
minus	int
;	O
int	O
eta_offset	int
;	O
const	O
char	O
*	O
sixty	pointer
;	O
const	O
char	O
*	O
fifteen	pointer
;	O
g_return_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
)	O
;	O
g_return_if_fail	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
;	O
ui	pointer
=	O
g_new0	O
(	O
FileOpContextUI	struct
,	O
1	int
)	O
;	O
ctx	pointer
->	O
ui	pointer
=	O
ui	pointer
;	O
minus	int
=	O
verbose	int
?	O
0	int
:	O
3	int
;	O
eta_offset	int
=	O
with_eta	int
?	O
(	O
WX_ETA_EXTRA	int
)	O
/	O
2	int
:	O
0	int
;	O
sixty	pointer
=	O
""	pointer
;	O
fifteen	pointer
=	O
""	pointer
;	O
ctx	pointer
->	O
recursive_result	int
=	O
0	int
;	O
ui	pointer
->	O
replace_result	int
=	O
0	int
;	O
ui	pointer
->	O
showing_eta	int
=	O
with_eta	int
;	O
ui	pointer
->	O
showing_bps	int
=	O
with_eta	int
;	O
ui	pointer
->	O
eta_extra	int
=	O
with_eta	int
?	O
WX_ETA_EXTRA	int
:	O
0	int
;	O
x_size	int
=	O
(	O
WX	int
+	O
4	int
)	O
+	O
ui	pointer
->	O
eta_extra	int
;	O
ui	pointer
->	O
op_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
WY	int
-	O
minus	int
+	O
4	int
,	O
x_size	int
,	O
dialog_colors	array
,	O
NULL	O
,	O
NULL	O
,	O
op_names	array
[	O
ctx	pointer
->	O
operation	enum
]	O
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
last_hint_line	int
=	O
the_hint	pointer
->	O
widget	pointer
.	O
y	short
;	O
if	O
(	O
(	O
ui	pointer
->	O
op_dlg	pointer
->	O
y	short
+	O
ui	pointer
->	O
op_dlg	pointer
->	O
lines	pointer
)	O
>	O
last_hint_line	int
)	O
the_hint	pointer
->	O
widget	pointer
.	O
y	short
=	O
ui	pointer
->	O
op_dlg	pointer
->	O
y	short
+	O
ui	pointer
->	O
op_dlg	pointer
->	O
lines	pointer
+	O
1	int
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
button_new	function
(	O
BY	int
-	O
minus	int
,	O
WX	int
-	O
19	int
+	O
eta_offset	int
,	O
FILE_ABORT	int
,	O
NORMAL_BUTTON	int
,	O
_	O
(	O
"&Abort"	pointer
)	O
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
button_new	function
(	O
BY	int
-	O
minus	int
,	O
14	int
+	O
eta_offset	int
,	O
FILE_SKIP	int
,	O
NORMAL_BUTTON	int
,	O
_	O
(	O
"&Skip"	pointer
)	O
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
progress_gauge	array
[	O
2	int
]	O
=	O
gauge_new	function
(	O
7	int
,	O
FCOPY_GAUGE_X	int
,	O
0	int
,	O
100	int
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
progress_label	array
[	O
2	int
]	O
=	O
label_new	function
(	O
7	int
,	O
FCOPY_LABEL_X	int
,	O
fifteen	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
bps_label	pointer
=	O
label_new	function
(	O
7	int
,	O
WX	int
,	O
""	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
progress_gauge	array
[	O
1	int
]	O
=	O
gauge_new	function
(	O
8	int
,	O
FCOPY_GAUGE_X	int
,	O
0	int
,	O
100	int
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
progress_label	array
[	O
1	int
]	O
=	O
label_new	function
(	O
8	int
,	O
FCOPY_LABEL_X	int
,	O
fifteen	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
stalled_label	pointer
=	O
label_new	function
(	O
8	int
,	O
WX	int
,	O
""	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
progress_gauge	array
[	O
0	int
]	O
=	O
gauge_new	function
(	O
6	int
,	O
FCOPY_GAUGE_X	int
,	O
0	int
,	O
100	int
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
progress_label	array
[	O
0	int
]	O
=	O
label_new	function
(	O
6	int
,	O
FCOPY_LABEL_X	int
,	O
fifteen	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
eta_label	pointer
=	O
label_new	function
(	O
6	int
,	O
WX	int
,	O
""	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
file_string	array
[	O
1	int
]	O
=	O
label_new	function
(	O
4	int
,	O
FCOPY_GAUGE_X	int
,	O
sixty	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
file_label	array
[	O
1	int
]	O
=	O
label_new	function
(	O
4	int
,	O
FCOPY_LABEL_X	int
,	O
fifteen	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
file_string	array
[	O
0	int
]	O
=	O
label_new	function
(	O
3	int
,	O
FCOPY_GAUGE_X	int
,	O
sixty	pointer
)	O
)	O
;	O
add_widget	function
(	O
ui	pointer
->	O
op_dlg	pointer
,	O
ui	pointer
->	O
file_label	array
[	O
0	int
]	O
=	O
label_new	function
(	O
3	int
,	O
FCOPY_LABEL_X	int
,	O
fifteen	pointer
)	O
)	O
;	O
init_dlg	function
(	O
ui	pointer
->	O
op_dlg	pointer
)	O
;	O
ui	pointer
->	O
op_dlg	pointer
->	O
running	int
=	O
1	int
;	O
}	O
void	O
file_op_context_destroy_ui	function
(	O
FileOpContext	struct
*	O
ctx	pointer
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
)	O
{	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
dlg_run_done	function
(	O
ui	pointer
->	O
op_dlg	pointer
)	O
;	O
destroy_dlg	function
(	O
ui	pointer
->	O
op_dlg	pointer
)	O
;	O
g_free	function
(	O
ui	pointer
)	O
;	O
}	O
the_hint	pointer
->	O
widget	pointer
.	O
y	short
=	O
last_hint_line	int
;	O
ctx	pointer
->	O
ui	pointer
=	O
NULL	O
;	O
}	O
static	O
FileProgressStatus	enum
show_no_bar	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
int	O
n	long
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
n	long
>=	O
0	int
)	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
progress_label	array
[	O
n	long
]	O
,	O
""	pointer
)	O
;	O
gauge_show	function
(	O
ui	pointer
->	O
progress_gauge	array
[	O
n	long
]	O
,	O
0	int
)	O
;	O
}	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
static	O
FileProgressStatus	enum
show_bar	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
int	O
n	long
,	O
double	O
done	long
,	O
double	O
total	double
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
gauge_set_value	function
(	O
ui	pointer
->	O
progress_gauge	array
[	O
n	long
]	O
,	O
1024	int
,	O
(	O
int	O
)	O
(	O
1024	int
*	O
done	long
/	O
total	double
)	O
)	O
;	O
gauge_show	function
(	O
ui	pointer
->	O
progress_gauge	array
[	O
n	long
]	O
,	O
1	int
)	O
;	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
static	O
void	O
file_eta_show	function
(	O
FileOpContext	struct
*	O
ctx	pointer
)	O
{	O
int	O
eta_hours	int
,	O
eta_mins	int
,	O
eta_s	int
;	O
char	O
eta_buffer	array
[	O
BUF_TINY	int
]	O
;	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
!	O
ui	pointer
->	O
showing_eta	int
)	O
return	O
;	O
if	O
(	O
ctx	pointer
->	O
eta_secs	double
>	O
0.5	int
)	O
{	O
eta_hours	int
=	O
ctx	pointer
->	O
eta_secs	double
/	O
(	O
60	int
*	O
60	int
)	O
;	O
eta_mins	int
=	O
(	O
ctx	pointer
->	O
eta_secs	double
-	O
(	O
eta_hours	int
*	O
60	int
*	O
60	int
)	O
)	O
/	O
60	int
;	O
eta_s	int
=	O
ctx	pointer
->	O
eta_secs	double
-	O
(	O
eta_hours	int
*	O
60	int
*	O
60	int
+	O
eta_mins	int
*	O
60	int
)	O
;	O
g_snprintf	function
(	O
eta_buffer	array
,	O
sizeof	O
(	O
eta_buffer	array
)	O
,	O
_	O
(	O
"ETA %d:%02d.%02d"	pointer
)	O
,	O
eta_hours	int
,	O
eta_mins	int
,	O
eta_s	int
)	O
;	O
}	O
else	O
*	O
eta_buffer	array
=	O
0	int
;	O
label_set_text	function
(	O
ui	pointer
->	O
eta_label	pointer
,	O
eta_buffer	array
)	O
;	O
}	O
static	O
void	O
file_bps_show	function
(	O
FileOpContext	struct
*	O
ctx	pointer
)	O
{	O
char	O
bps_buffer	array
[	O
BUF_TINY	int
]	O
;	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
!	O
ui	pointer
->	O
showing_bps	int
)	O
return	O
;	O
if	O
(	O
ctx	pointer
->	O
bps	long
>	O
1024	int
*	O
1024	int
)	O
{	O
g_snprintf	function
(	O
bps_buffer	array
,	O
sizeof	O
(	O
bps_buffer	array
)	O
,	O
_	O
(	O
"%.2f MB/s"	pointer
)	O
,	O
ctx	pointer
->	O
bps	long
/	O
(	O
1024	int
*	O
1024.0	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ctx	pointer
->	O
bps	long
>	O
1024	int
)	O
{	O
g_snprintf	function
(	O
bps_buffer	array
,	O
sizeof	O
(	O
bps_buffer	array
)	O
,	O
_	O
(	O
"%.2f KB/s"	pointer
)	O
,	O
ctx	pointer
->	O
bps	long
/	O
1024.0	int
)	O
;	O
}	O
else	O
if	O
(	O
ctx	pointer
->	O
bps	long
>	O
1	int
)	O
{	O
g_snprintf	function
(	O
bps_buffer	array
,	O
sizeof	O
(	O
bps_buffer	array
)	O
,	O
_	O
(	O
"%ld B/s"	pointer
)	O
,	O
ctx	pointer
->	O
bps	long
)	O
;	O
}	O
else	O
*	O
bps_buffer	array
=	O
0	int
;	O
label_set_text	function
(	O
ui	pointer
->	O
bps_label	pointer
,	O
bps_buffer	array
)	O
;	O
}	O
FileProgressStatus	enum
file_progress_show	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
off_t	long
done	long
,	O
off_t	long
total	double
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
!	O
verbose	int
)	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
if	O
(	O
total	double
>	O
0	int
)	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
progress_label	array
[	O
0	int
]	O
,	O
_	O
(	O
"File"	pointer
)	O
)	O
;	O
file_eta_show	function
(	O
ctx	pointer
)	O
;	O
file_bps_show	function
(	O
ctx	pointer
)	O
;	O
return	O
show_bar	function
(	O
ctx	pointer
,	O
0	int
,	O
done	long
,	O
total	double
)	O
;	O
}	O
else	O
return	O
show_no_bar	function
(	O
ctx	pointer
,	O
0	int
)	O
;	O
}	O
FileProgressStatus	enum
file_progress_show_count	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
off_t	long
done	long
,	O
off_t	long
total	double
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
!	O
verbose	int
)	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
if	O
(	O
total	double
>	O
0	int
)	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
progress_label	array
[	O
1	int
]	O
,	O
_	O
(	O
"Count"	pointer
)	O
)	O
;	O
return	O
show_bar	function
(	O
ctx	pointer
,	O
1	int
,	O
done	long
,	O
total	double
)	O
;	O
}	O
else	O
return	O
show_no_bar	function
(	O
ctx	pointer
,	O
1	int
)	O
;	O
}	O
FileProgressStatus	enum
file_progress_show_bytes	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
double	O
done	long
,	O
double	O
total	double
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
!	O
verbose	int
)	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
if	O
(	O
total	double
>	O
0	int
)	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
progress_label	array
[	O
2	int
]	O
,	O
_	O
(	O
"Bytes"	pointer
)	O
)	O
;	O
return	O
show_bar	function
(	O
ctx	pointer
,	O
2	int
,	O
done	long
,	O
total	double
)	O
;	O
}	O
else	O
return	O
show_no_bar	function
(	O
ctx	pointer
,	O
2	int
)	O
;	O
}	O
FileProgressStatus	enum
file_progress_show_source	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
int	O
i	array
=	O
strlen	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
current_panel	pointer
->	O
cwd	short
,	O
i	array
)	O
)	O
{	O
if	O
(	O
s	pointer
[	O
i	array
]	O
==	O
PATH_SEP	char
)	O
s	pointer
+=	O
i	array
+	O
1	int
;	O
}	O
label_set_text	function
(	O
ui	pointer
->	O
file_label	array
[	O
0	int
]	O
,	O
_	O
(	O
"Source"	pointer
)	O
)	O
;	O
label_set_text	function
(	O
ui	pointer
->	O
file_string	array
[	O
0	int
]	O
,	O
truncFileString	O
(	O
ui	pointer
,	O
s	pointer
)	O
)	O
;	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
else	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
file_label	array
[	O
0	int
]	O
,	O
""	pointer
)	O
;	O
label_set_text	function
(	O
ui	pointer
->	O
file_string	array
[	O
0	int
]	O
,	O
""	pointer
)	O
;	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
}	O
FileProgressStatus	enum
file_progress_show_target	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
file_label	array
[	O
1	int
]	O
,	O
_	O
(	O
"Target"	pointer
)	O
)	O
;	O
label_set_text	function
(	O
ui	pointer
->	O
file_string	array
[	O
1	int
]	O
,	O
truncFileStringSecure	O
(	O
ui	pointer
,	O
s	pointer
)	O
)	O
;	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
else	O
{	O
label_set_text	function
(	O
ui	pointer
->	O
file_label	array
[	O
1	int
]	O
,	O
""	pointer
)	O
;	O
label_set_text	function
(	O
ui	pointer
->	O
file_string	array
[	O
1	int
]	O
,	O
""	pointer
)	O
;	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
}	O
FileProgressStatus	enum
file_progress_show_deleting	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
FILE_CONT	int
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
label_set_text	function
(	O
ui	pointer
->	O
file_label	array
[	O
0	int
]	O
,	O
_	O
(	O
"Deleting"	pointer
)	O
)	O
;	O
label_set_text	function
(	O
ui	pointer
->	O
file_label	array
[	O
0	int
]	O
,	O
truncFileStringSecure	O
(	O
ui	pointer
,	O
s	pointer
)	O
)	O
;	O
return	O
check_progress_buttons	function
(	O
ctx	pointer
)	O
;	O
}	O
static	O
struct	O
{	O
const	O
char	O
*	O
text	pointer
;	O
int	O
ypos	int
,	O
xpos	int
;	O
int	O
value	pointer
;	O
}	O
rd_widgets	array
[	O
]	O
=	O
{	O
{	O
N_	O
(	O
"Target file \"%s\" already exists!"	pointer
)	O
,	O
3	int
,	O
4	int
,	O
0	int
}	O
,	O
{	O
N_	O
(	O
"&Abort"	pointer
)	O
,	O
BY	int
+	O
3	int
,	O
25	int
,	O
REPLACE_ABORT	int
}	O
,	O
{	O
N_	O
(	O
"If &size differs"	pointer
)	O
,	O
BY	int
+	O
1	int
,	O
28	int
,	O
REPLACE_SIZE	int
}	O
,	O
{	O
N_	O
(	O
"Non&e"	pointer
)	O
,	O
BY	int
,	O
47	int
,	O
REPLACE_NEVER	int
}	O
,	O
{	O
N_	O
(	O
"&Update"	pointer
)	O
,	O
BY	int
,	O
36	int
,	O
REPLACE_UPDATE	int
}	O
,	O
{	O
N_	O
(	O
"A&ll"	pointer
)	O
,	O
BY	int
,	O
28	int
,	O
REPLACE_ALWAYS	int
}	O
,	O
{	O
N_	O
(	O
"Overwrite all targets?"	pointer
)	O
,	O
BY	int
,	O
4	int
,	O
0	int
}	O
,	O
{	O
N_	O
(	O
"&Reget"	pointer
)	O
,	O
BY	int
-	O
1	int
,	O
28	int
,	O
REPLACE_REGET	int
}	O
,	O
{	O
N_	O
(	O
"A&ppend"	pointer
)	O
,	O
BY	int
-	O
2	int
,	O
45	int
,	O
REPLACE_APPEND	int
}	O
,	O
{	O
N_	O
(	O
"&No"	pointer
)	O
,	O
BY	int
-	O
2	int
,	O
37	int
,	O
REPLACE_NO	int
}	O
,	O
{	O
N_	O
(	O
"&Yes"	pointer
)	O
,	O
BY	int
-	O
2	int
,	O
28	int
,	O
REPLACE_YES	int
}	O
,	O
{	O
N_	O
(	O
"Overwrite this target?"	pointer
)	O
,	O
BY	int
-	O
2	int
,	O
4	int
,	O
0	int
}	O
,	O
{	O
N_	O
(	O
"Target date: %s, size %u"	pointer
)	O
,	O
6	int
,	O
4	int
,	O
0	int
}	O
,	O
{	O
N_	O
(	O
"Source date: %s, size %u"	pointer
)	O
,	O
5	int
,	O
4	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
init_replace	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
enum	O
OperationMode	enum
mode	int
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
char	O
buffer	pointer
[	O
BUF_SMALL	int
]	O
;	O
const	O
char	O
*	O
title	pointer
;	O
static	O
int	O
rd_xlen	int
=	O
60	int
,	O
rd_trunc	int
=	O
X_TRUNC	int
;	O
static	O
int	O
i18n_flag	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
int	O
l1	int
,	O
l2	int
,	O
l	pointer
,	O
row	int
;	O
register	O
int	O
i	array
=	O
sizeof	O
(	O
rd_widgets	array
)	O
/	O
sizeof	O
(	O
rd_widgets	array
[	O
0	int
]	O
)	O
;	O
while	O
(	O
i	array
--	O
)	O
rd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
=	O
_	O
(	O
rd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
)	O
;	O
l1	int
=	O
max	long
(	O
strlen	function
(	O
rd_widgets	array
[	O
6	int
]	O
.	O
text	pointer
)	O
,	O
strlen	function
(	O
rd_widgets	array
[	O
11	int
]	O
.	O
text	pointer
)	O
)	O
;	O
i	array
=	O
sizeof	O
(	O
rd_widgets	array
)	O
/	O
sizeof	O
(	O
rd_widgets	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
row	int
=	O
l	pointer
=	O
l2	int
=	O
0	int
;	O
i	array
--	O
;	O
)	O
{	O
if	O
(	O
rd_widgets	array
[	O
i	array
]	O
.	O
value	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
row	int
!=	O
rd_widgets	array
[	O
i	array
]	O
.	O
ypos	int
)	O
{	O
row	int
=	O
rd_widgets	array
[	O
i	array
]	O
.	O
ypos	int
;	O
l2	int
=	O
max	long
(	O
l2	int
,	O
l	pointer
)	O
;	O
l	pointer
=	O
0	int
;	O
}	O
l	pointer
+=	O
strlen	function
(	O
rd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
)	O
+	O
4	int
;	O
}	O
}	O
l2	int
=	O
max	long
(	O
l2	int
,	O
l	pointer
)	O
;	O
rd_xlen	int
=	O
max	long
(	O
rd_xlen	int
,	O
l1	int
+	O
l2	int
+	O
8	int
)	O
;	O
rd_trunc	int
=	O
rd_xlen	int
-	O
6	int
;	O
l1	int
+=	O
5	int
;	O
i	array
=	O
sizeof	O
(	O
rd_widgets	array
)	O
/	O
sizeof	O
(	O
rd_widgets	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
l	pointer
=	O
l1	int
,	O
row	int
=	O
0	int
;	O
--	O
i	array
>	O
1	int
;	O
)	O
{	O
if	O
(	O
rd_widgets	array
[	O
i	array
]	O
.	O
value	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
row	int
!=	O
rd_widgets	array
[	O
i	array
]	O
.	O
ypos	int
)	O
{	O
row	int
=	O
rd_widgets	array
[	O
i	array
]	O
.	O
ypos	int
;	O
l	pointer
=	O
l1	int
;	O
}	O
rd_widgets	array
[	O
i	array
]	O
.	O
xpos	int
=	O
l	pointer
;	O
l	pointer
+=	O
strlen	function
(	O
rd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
)	O
+	O
4	int
;	O
}	O
}	O
rd_widgets	array
[	O
1	int
]	O
.	O
xpos	int
=	O
(	O
rd_xlen	int
-	O
strlen	function
(	O
rd_widgets	array
[	O
1	int
]	O
.	O
text	pointer
)	O
-	O
3	int
)	O
/	O
2	int
;	O
}	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
mode	int
==	O
Foreground	int
)	O
title	pointer
=	O
_	O
(	O
" File exists "	pointer
)	O
;	O
else	O
title	pointer
=	O
_	O
(	O
" Background process: File exists "	pointer
)	O
;	O
ui	pointer
->	O
replace_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
16	int
,	O
rd_xlen	int
,	O
alarm_colors	array
,	O
NULL	O
,	O
"[Replace]"	pointer
,	O
title	pointer
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
ADD_RD_LABEL	O
(	O
ui	pointer
,	O
0	int
,	O
name_trunc	function
(	O
ui	pointer
->	O
replace_filename	pointer
,	O
rd_trunc	int
-	O
strlen	function
(	O
rd_widgets	array
[	O
0	int
]	O
.	O
text	pointer
)	O
)	O
,	O
0	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
1	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
2	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
3	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
4	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
5	int
)	O
;	O
ADD_RD_LABEL	O
(	O
ui	pointer
,	O
6	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
ui	pointer
->	O
d_stat	pointer
->	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
(	O
ctx	pointer
->	O
operation	enum
==	O
OP_COPY	int
)	O
&&	O
(	O
ui	pointer
->	O
d_stat	pointer
->	O
st_size	long
!=	O
0	int
)	O
&&	O
(	O
ui	pointer
->	O
s_stat	pointer
->	O
st_size	long
>	O
ui	pointer
->	O
d_stat	pointer
->	O
st_size	long
)	O
)	O
ADD_RD_BUTTON	O
(	O
7	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
8	int
)	O
;	O
}	O
ADD_RD_BUTTON	O
(	O
9	int
)	O
;	O
ADD_RD_BUTTON	O
(	O
10	int
)	O
;	O
ADD_RD_LABEL	O
(	O
ui	pointer
,	O
11	int
,	O
0	int
,	O
0	int
)	O
;	O
ADD_RD_LABEL	O
(	O
ui	pointer
,	O
12	int
,	O
file_date	function
(	O
ui	pointer
->	O
d_stat	pointer
->	O
st_mtime	O
)	O
,	O
(	O
off_t	long
)	O
ui	pointer
->	O
d_stat	pointer
->	O
st_size	long
)	O
;	O
ADD_RD_LABEL	O
(	O
ui	pointer
,	O
13	int
,	O
file_date	function
(	O
ui	pointer
->	O
s_stat	pointer
->	O
st_mtime	O
)	O
,	O
(	O
off_t	long
)	O
ui	pointer
->	O
s_stat	pointer
->	O
st_size	long
)	O
;	O
}	O
void	O
file_progress_set_stalled_label	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
stalled_msg	pointer
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
ui	pointer
==	O
NULL	O
)	O
return	O
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
label_set_text	function
(	O
ui	pointer
->	O
stalled_label	pointer
,	O
stalled_msg	pointer
)	O
;	O
}	O
FileProgressStatus	enum
file_progress_real_query_replace	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
enum	O
OperationMode	enum
mode	int
,	O
const	O
char	O
*	O
destname	pointer
,	O
struct	O
stat	struct
*	O
_s_stat	pointer
,	O
struct	O
stat	struct
*	O
_d_stat	pointer
)	O
{	O
FileOpContextUI	struct
*	O
ui	pointer
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
->	O
ui	pointer
!=	O
NULL	O
,	O
FILE_CONT	int
)	O
;	O
ui	pointer
=	O
ctx	pointer
->	O
ui	pointer
;	O
if	O
(	O
ui	pointer
->	O
replace_result	int
<	O
REPLACE_ALWAYS	int
)	O
{	O
ui	pointer
->	O
replace_filename	pointer
=	O
destname	pointer
;	O
ui	pointer
->	O
s_stat	pointer
=	O
_s_stat	pointer
;	O
ui	pointer
->	O
d_stat	pointer
=	O
_d_stat	pointer
;	O
init_replace	function
(	O
ctx	pointer
,	O
mode	int
)	O
;	O
run_dlg	function
(	O
ui	pointer
->	O
replace_dlg	pointer
)	O
;	O
ui	pointer
->	O
replace_result	int
=	O
ui	pointer
->	O
replace_dlg	pointer
->	O
ret_value	int
;	O
if	O
(	O
ui	pointer
->	O
replace_result	int
==	O
B_CANCEL	int
)	O
ui	pointer
->	O
replace_result	int
=	O
REPLACE_ABORT	int
;	O
destroy_dlg	function
(	O
ui	pointer
->	O
replace_dlg	pointer
)	O
;	O
}	O
switch	O
(	O
ui	pointer
->	O
replace_result	int
)	O
{	O
case	O
REPLACE_UPDATE	int
:	O
do_refresh	function
(	O
)	O
;	O
if	O
(	O
_s_stat	pointer
->	O
st_mtime	O
>	O
_d_stat	pointer
->	O
st_mtime	O
)	O
return	O
FILE_CONT	int
;	O
else	O
return	O
FILE_SKIP	int
;	O
case	O
REPLACE_SIZE	int
:	O
do_refresh	function
(	O
)	O
;	O
if	O
(	O
_s_stat	pointer
->	O
st_size	long
==	O
_d_stat	pointer
->	O
st_size	long
)	O
return	O
FILE_SKIP	int
;	O
else	O
return	O
FILE_CONT	int
;	O
case	O
REPLACE_REGET	int
:	O
ctx	pointer
->	O
do_reget	long
=	O
_d_stat	pointer
->	O
st_size	long
;	O
case	O
REPLACE_APPEND	int
:	O
ctx	pointer
->	O
do_append	int
=	O
1	int
;	O
case	O
REPLACE_YES	int
:	O
case	O
REPLACE_ALWAYS	int
:	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_CONT	int
;	O
case	O
REPLACE_NO	int
:	O
case	O
REPLACE_NEVER	int
:	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_SKIP	int
;	O
case	O
REPLACE_ABORT	int
:	O
default	O
:	O
return	O
FILE_ABORT	int
;	O
}	O
}	O
extern	O
int	O
fmd_xlen	int
;	O
static	O
QuickWidget	struct
fmd_widgets	array
[	O
]	O
=	O
{	O
{	O
quick_checkbox	int
,	O
3	int
,	O
64	int
,	O
8	int
,	O
FMDY	int
,	O
N_	O
(	O
"preserve &Attributes"	pointer
)	O
,	O
9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
3	int
,	O
64	int
,	O
7	int
,	O
FMDY	int
,	O
N_	O
(	O
"follow &Links"	pointer
)	O
,	O
7	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_label	int
,	O
3	int
,	O
64	int
,	O
5	int
,	O
FMDY	int
,	O
N_	O
(	O
"to:"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
37	int
,	O
64	int
,	O
4	int
,	O
FMDY	int
,	O
N_	O
(	O
"&Using shell patterns"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
64	int
,	O
3	int
,	O
FMDY	int
,	O
""	pointer
,	O
58	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"input-def"	pointer
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
64	int
,	O
6	int
,	O
FMDY	int
,	O
""	pointer
,	O
58	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"input2"	pointer
}	O
,	O
{	O
quick_label	int
,	O
3	int
,	O
64	int
,	O
2	int
,	O
FMDY	int
,	O
""	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
42	int
,	O
64	int
,	O
9	int
,	O
FMDY	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
25	int
,	O
64	int
,	O
9	int
,	O
FMDY	int
,	O
N_	O
(	O
"&Background"	pointer
)	O
,	O
0	int
,	O
B_USER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
14	int
,	O
64	int
,	O
9	int
,	O
FMDY	int
,	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
42	int
,	O
64	int
,	O
8	int
,	O
FMDY	int
,	O
N_	O
(	O
"&Stable Symlinks"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
31	int
,	O
64	int
,	O
7	int
,	O
FMDY	int
,	O
N_	O
(	O
"&Dive into subdir if exists"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
static	O
int	O
is_wildcarded	function
(	O
char	O
*	O
p	pointer
)	O
{	O
for	O
(	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'*'	O
)	O
return	O
1	int
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
&&	O
p	pointer
[	O
1	int
]	O
>=	O
'1'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'9'	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
fmd_init_i18n	function
(	O
int	O
force	int
)	O
{	O
static	O
int	O
initialized	int
=	O
FALSE	O
;	O
register	O
int	O
i	array
;	O
int	O
len	int
;	O
if	O
(	O
initialized	int
&&	O
!	O
force	int
)	O
return	O
;	O
for	O
(	O
i	array
=	O
sizeof	O
(	O
op_names	array
)	O
/	O
sizeof	O
(	O
op_names	array
[	O
0	int
]	O
)	O
;	O
i	array
--	O
;	O
)	O
op_names	array
[	O
i	array
]	O
=	O
_	O
(	O
op_names	array
[	O
i	array
]	O
)	O
;	O
i	array
=	O
sizeof	O
(	O
fmd_widgets	array
)	O
/	O
sizeof	O
(	O
fmd_widgets	array
[	O
0	int
]	O
)	O
-	O
1	int
;	O
while	O
(	O
i	array
--	O
)	O
if	O
(	O
fmd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
fmd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
=	O
_	O
(	O
fmd_widgets	array
[	O
i	array
]	O
.	O
text	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
fmd_widgets	array
[	O
FMCB11	int
]	O
.	O
text	pointer
)	O
+	O
strlen	function
(	O
fmd_widgets	array
[	O
FMCB21	int
]	O
.	O
text	pointer
)	O
+	O
15	int
;	O
fmd_xlen	int
=	O
max	long
(	O
fmd_xlen	int
,	O
len	int
)	O
;	O
len	int
=	O
strlen	function
(	O
fmd_widgets	array
[	O
FMCB12	int
]	O
.	O
text	pointer
)	O
+	O
strlen	function
(	O
fmd_widgets	array
[	O
FMCB22	int
]	O
.	O
text	pointer
)	O
+	O
15	int
;	O
fmd_xlen	int
=	O
max	long
(	O
fmd_xlen	int
,	O
len	int
)	O
;	O
len	int
=	O
strlen	function
(	O
fmd_widgets	array
[	O
FMBRGT	int
]	O
.	O
text	pointer
)	O
+	O
strlen	function
(	O
fmd_widgets	array
[	O
FMBLFT	int
]	O
.	O
text	pointer
)	O
+	O
11	int
;	O
len	int
+=	O
strlen	function
(	O
fmd_widgets	array
[	O
FMBMID	int
]	O
.	O
text	pointer
)	O
+	O
6	int
;	O
fmd_xlen	int
=	O
max	long
(	O
fmd_xlen	int
,	O
len	int
+	O
4	int
)	O
;	O
len	int
=	O
(	O
fmd_xlen	int
-	O
(	O
len	int
+	O
6	int
)	O
)	O
/	O
2	int
;	O
i	array
=	O
fmd_widgets	array
[	O
FMBLFT	int
]	O
.	O
relative_x	int
=	O
len	int
+	O
3	int
;	O
i	array
+=	O
strlen	function
(	O
fmd_widgets	array
[	O
FMBLFT	int
]	O
.	O
text	pointer
)	O
+	O
8	int
;	O
fmd_widgets	array
[	O
FMBMID	int
]	O
.	O
relative_x	int
=	O
i	array
;	O
i	array
+=	O
strlen	function
(	O
fmd_widgets	array
[	O
FMBMID	int
]	O
.	O
text	pointer
)	O
+	O
6	int
;	O
fmd_widgets	array
[	O
FMBRGT	int
]	O
.	O
relative_x	int
=	O
i	array
;	O
chkbox_xpos	O
(	O
FMCB0	O
)	O
;	O
chkbox_xpos	O
(	O
FMCB21	int
)	O
;	O
chkbox_xpos	O
(	O
FMCB22	int
)	O
;	O
if	O
(	O
fmd_xlen	int
!=	O
FMD_XLEN	int
)	O
{	O
i	array
=	O
sizeof	O
(	O
fmd_widgets	array
)	O
/	O
sizeof	O
(	O
fmd_widgets	array
[	O
0	int
]	O
)	O
-	O
1	int
;	O
while	O
(	O
i	array
--	O
)	O
fmd_widgets	array
[	O
i	array
]	O
.	O
x_divisions	int
=	O
fmd_xlen	int
;	O
fmd_widgets	array
[	O
FMDI1	int
]	O
.	O
hotkey_pos	int
=	O
fmd_widgets	array
[	O
FMDI2	int
]	O
.	O
hotkey_pos	int
=	O
fmd_xlen	int
-	O
6	int
;	O
}	O
initialized	int
=	O
TRUE	O
;	O
}	O
char	O
*	O
file_mask_dialog	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
FileOperation	enum
operation	enum
,	O
const	O
char	O
*	O
text	pointer
,	O
const	O
char	O
*	O
def_text	pointer
,	O
int	O
only_one	int
,	O
int	O
*	O
do_background	pointer
)	O
{	O
int	O
source_easy_patterns	int
=	O
easy_patterns	int
;	O
char	O
*	O
source_mask	pointer
,	O
*	O
orig_mask	pointer
,	O
*	O
dest_dir	pointer
,	O
*	O
tmpdest	pointer
;	O
const	O
char	O
*	O
error	pointer
;	O
char	O
*	O
def_text_secure	pointer
;	O
struct	O
stat	struct
buf	pointer
;	O
int	O
val	array
;	O
QuickDialog	struct
Quick_input	struct
;	O
g_return_val_if_fail	O
(	O
ctx	pointer
!=	O
NULL	O
,	O
NULL	O
)	O
;	O
fmd_init_i18n	function
(	O
FALSE	O
)	O
;	O
fmd_widgets	array
[	O
FMCB12	int
]	O
.	O
result	long
=	O
&	O
ctx	pointer
->	O
op_preserve	int
;	O
fmd_widgets	array
[	O
FMCB11	int
]	O
.	O
result	long
=	O
&	O
ctx	pointer
->	O
follow_links	int
;	O
fmd_widgets	array
[	O
FMCB22	int
]	O
.	O
result	long
=	O
&	O
ctx	pointer
->	O
stable_symlinks	int
;	O
fmd_widgets	array
[	O
FMCB21	int
]	O
.	O
result	long
=	O
&	O
ctx	pointer
->	O
dive_into_subdirs	int
;	O
def_text_secure	pointer
=	O
strip_password	function
(	O
g_strdup	function
(	O
def_text	pointer
)	O
,	O
1	int
)	O
;	O
ctx	pointer
->	O
stable_symlinks	int
=	O
0	int
;	O
fmd_widgets	array
[	O
FMDC	int
]	O
.	O
result	long
=	O
&	O
source_easy_patterns	int
;	O
fmd_widgets	array
[	O
FMDI1	int
]	O
.	O
text	pointer
=	O
easy_patterns	int
?	O
"*"	pointer
:	O
"^\\(.*\\)$"	pointer
;	O
Quick_input	struct
.	O
xlen	int
=	O
fmd_xlen	int
;	O
Quick_input	struct
.	O
xpos	int
=	O
-	O
1	int
;	O
Quick_input	struct
.	O
title	pointer
=	O
op_names	array
[	O
operation	enum
]	O
;	O
Quick_input	struct
.	O
help	pointer
=	O
"[Mask Copy/Rename]"	pointer
;	O
Quick_input	struct
.	O
ylen	int
=	O
FMDY	int
;	O
Quick_input	struct
.	O
i18n	int
=	O
1	int
;	O
Quick_input	struct
.	O
widgets	pointer
=	O
fmd_widgets	array
;	O
fmd_widgets	array
[	O
FMDI0	int
]	O
.	O
text	pointer
=	O
text	pointer
;	O
fmd_widgets	array
[	O
FMDI2	int
]	O
.	O
text	pointer
=	O
def_text_secure	pointer
;	O
fmd_widgets	array
[	O
FMDI2	int
]	O
.	O
str_result	pointer
=	O
&	O
dest_dir	pointer
;	O
fmd_widgets	array
[	O
FMDI1	int
]	O
.	O
str_result	pointer
=	O
&	O
source_mask	pointer
;	O
*	O
do_background	pointer
=	O
0	int
;	O
ask_file_mask	O
:	O
if	O
(	O
(	O
val	array
=	O
quick_dialog_skip	function
(	O
&	O
Quick_input	struct
,	O
SKIP	int
)	O
)	O
==	O
B_CANCEL	int
)	O
{	O
g_free	function
(	O
def_text_secure	pointer
)	O
;	O
return	O
0	int
;	O
}	O
g_free	function
(	O
def_text_secure	pointer
)	O
;	O
if	O
(	O
ctx	pointer
->	O
follow_links	int
)	O
ctx	pointer
->	O
stat_func	pointer
=	O
mc_stat	function
;	O
else	O
ctx	pointer
->	O
stat_func	pointer
=	O
mc_lstat	function
;	O
if	O
(	O
ctx	pointer
->	O
op_preserve	int
)	O
{	O
ctx	pointer
->	O
preserve	int
=	O
1	int
;	O
ctx	pointer
->	O
umask_kill	int
=	O
0777777	int
;	O
ctx	pointer
->	O
preserve_uidgid	int
=	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
else	O
{	O
int	O
i	array
;	O
ctx	pointer
->	O
preserve	int
=	O
ctx	pointer
->	O
preserve_uidgid	int
=	O
0	int
;	O
i	array
=	O
umask	function
(	O
0	int
)	O
;	O
umask	function
(	O
i	array
)	O
;	O
ctx	pointer
->	O
umask_kill	int
=	O
i	array
^	O
0777777	int
;	O
}	O
orig_mask	pointer
=	O
source_mask	pointer
;	O
if	O
(	O
!	O
dest_dir	pointer
||	O
!	O
*	O
dest_dir	pointer
)	O
{	O
g_free	function
(	O
source_mask	pointer
)	O
;	O
return	O
dest_dir	pointer
;	O
}	O
if	O
(	O
source_easy_patterns	int
)	O
{	O
source_easy_patterns	int
=	O
easy_patterns	int
;	O
easy_patterns	int
=	O
1	int
;	O
source_mask	pointer
=	O
convert_pattern	function
(	O
source_mask	pointer
,	O
match_file	int
,	O
1	int
)	O
;	O
easy_patterns	int
=	O
source_easy_patterns	int
;	O
error	pointer
=	O
re_compile_pattern	function
(	O
source_mask	pointer
,	O
strlen	function
(	O
source_mask	pointer
)	O
,	O
&	O
ctx	pointer
->	O
rx	struct
)	O
;	O
g_free	function
(	O
source_mask	pointer
)	O
;	O
}	O
else	O
error	pointer
=	O
re_compile_pattern	function
(	O
source_mask	pointer
,	O
strlen	function
(	O
source_mask	pointer
)	O
,	O
&	O
ctx	pointer
->	O
rx	struct
)	O
;	O
if	O
(	O
error	pointer
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Invalid source pattern `%s' \n %s "	pointer
)	O
,	O
orig_mask	pointer
,	O
error	pointer
)	O
;	O
g_free	function
(	O
orig_mask	pointer
)	O
;	O
goto	O
ask_file_mask	O
;	O
}	O
g_free	function
(	O
orig_mask	pointer
)	O
;	O
tmpdest	pointer
=	O
dest_dir	pointer
;	O
dest_dir	pointer
=	O
tilde_expand	function
(	O
tmpdest	pointer
)	O
;	O
g_free	function
(	O
tmpdest	pointer
)	O
;	O
ctx	pointer
->	O
dest_mask	pointer
=	O
strrchr	function
(	O
dest_dir	pointer
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
ctx	pointer
->	O
dest_mask	pointer
==	O
NULL	O
)	O
ctx	pointer
->	O
dest_mask	pointer
=	O
dest_dir	pointer
;	O
else	O
ctx	pointer
->	O
dest_mask	pointer
++	O
;	O
orig_mask	pointer
=	O
ctx	pointer
->	O
dest_mask	pointer
;	O
if	O
(	O
!	O
*	O
ctx	pointer
->	O
dest_mask	pointer
||	O
(	O
!	O
ctx	pointer
->	O
dive_into_subdirs	int
&&	O
!	O
is_wildcarded	function
(	O
ctx	pointer
->	O
dest_mask	pointer
)	O
&&	O
(	O
!	O
only_one	int
||	O
(	O
!	O
mc_stat	function
(	O
dest_dir	pointer
,	O
&	O
buf	pointer
)	O
&&	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
)	O
)	O
||	O
(	O
ctx	pointer
->	O
dive_into_subdirs	int
&&	O
(	O
(	O
!	O
only_one	int
&&	O
!	O
is_wildcarded	function
(	O
ctx	pointer
->	O
dest_mask	pointer
)	O
)	O
||	O
(	O
only_one	int
&&	O
!	O
mc_stat	function
(	O
dest_dir	pointer
,	O
&	O
buf	pointer
)	O
&&	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
)	O
)	O
)	O
ctx	pointer
->	O
dest_mask	pointer
=	O
g_strdup	function
(	O
"*"	pointer
)	O
;	O
else	O
{	O
ctx	pointer
->	O
dest_mask	pointer
=	O
g_strdup	function
(	O
ctx	pointer
->	O
dest_mask	pointer
)	O
;	O
*	O
orig_mask	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
*	O
dest_dir	pointer
)	O
{	O
g_free	function
(	O
dest_dir	pointer
)	O
;	O
dest_dir	pointer
=	O
g_strdup	function
(	O
"./"	pointer
)	O
;	O
}	O
if	O
(	O
val	array
==	O
B_USER	int
)	O
*	O
do_background	pointer
=	O
1	int
;	O
return	O
dest_dir	pointer
;	O
}	O