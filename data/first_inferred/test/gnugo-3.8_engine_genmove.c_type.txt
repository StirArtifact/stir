static	O
int	O
limit_search	int
=	O
0	int
;	O
static	O
int	O
search_mask	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
do_genmove	function
(	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
value	pointer
,	O
int	O
*	O
resign	pointer
)	O
;	O
static	O
int	O
worms_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
initial_influence_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
dragons_examined_without_owl	int
=	O
-	O
1	int
;	O
static	O
int	O
dragons_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
initial_influence2_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
dragons_refinedly_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
revise_semeai	function
(	O
int	O
color	int
)	O
;	O
static	O
int	O
revise_thrashing_dragon	function
(	O
int	O
color	int
,	O
float	O
our_score	float
,	O
float	O
advantage	float
)	O
;	O
static	O
void	O
break_mirror_go	function
(	O
int	O
color	int
)	O
;	O
static	O
int	O
find_mirror_move	function
(	O
int	O
*	O
move	pointer
,	O
int	O
color	int
)	O
;	O
static	O
int	O
should_resign	function
(	O
int	O
color	int
,	O
float	O
optimistic_score	float
,	O
int	O
move	pointer
)	O
;	O
static	O
void	O
compute_scores	function
(	O
int	O
use_chinese_rules	int
)	O
;	O
void	O
reset_engine	function
(	O
)	O
{	O
reuse_random_seed	function
(	O
)	O
;	O
reading_cache_clear	function
(	O
)	O
;	O
hashdata_recalc	function
(	O
&	O
board_hash	struct
,	O
board	pointer
,	O
board_ko_pos	int
)	O
;	O
worms_examined	int
=	O
-	O
1	int
;	O
initial_influence_examined	int
=	O
-	O
1	int
;	O
dragons_examined_without_owl	int
=	O
-	O
1	int
;	O
dragons_examined	int
=	O
-	O
1	int
;	O
initial_influence2_examined	int
=	O
-	O
1	int
;	O
dragons_refinedly_examined	int
=	O
-	O
1	int
;	O
clear_move_reasons	function
(	O
)	O
;	O
clear_break_in_list	function
(	O
)	O
;	O
set_depth_values	function
(	O
get_level	function
(	O
)	O
,	O
0	int
)	O
;	O
clear_unconditionally_meaningless_moves	function
(	O
)	O
;	O
}	O
void	O
examine_position	function
(	O
int	O
how_much	int
,	O
int	O
aftermath_play	int
)	O
{	O
int	O
save_verbose	int
=	O
verbose	int
;	O
purge_persistent_caches	function
(	O
)	O
;	O
if	O
(	O
verbose	int
==	O
1	int
||	O
verbose	int
==	O
2	int
)	O
--	O
verbose	int
;	O
if	O
(	O
NEEDS_UPDATE	O
(	O
worms_examined	int
)	O
)	O
{	O
start_timer	function
(	O
0	int
)	O
;	O
make_worms	function
(	O
)	O
;	O
time_report	function
(	O
0	int
,	O
"  make worms"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_WORMS	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
NEEDS_UPDATE	O
(	O
initial_influence_examined	int
)	O
)	O
compute_worm_influence	function
(	O
)	O
;	O
if	O
(	O
how_much	int
==	O
EXAMINE_INITIAL_INFLUENCE	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
{	O
if	O
(	O
NEEDS_UPDATE	O
(	O
dragons_examined_without_owl	int
)	O
)	O
make_dragons	function
(	O
1	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
NEEDS_UPDATE	O
(	O
dragons_examined	int
)	O
)	O
{	O
make_dragons	function
(	O
0	int
)	O
;	O
compute_scores	function
(	O
chinese_rules	int
||	O
aftermath_play	int
)	O
;	O
dragons_examined_without_owl	int
=	O
position_number	int
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_DRAGONS	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
how_much	int
==	O
EXAMINE_INITIAL_INFLUENCE	int
||	O
how_much	int
==	O
EXAMINE_DRAGONS	int
||	O
how_much	int
==	O
EXAMINE_ALL	int
)	O
{	O
initialize_dragon_data	function
(	O
)	O
;	O
compute_scores	function
(	O
chinese_rules	int
||	O
aftermath_play	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
if	O
(	O
NEEDS_UPDATE	O
(	O
initial_influence2_examined	int
)	O
)	O
{	O
compute_dragon_influence	function
(	O
)	O
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_INITIAL_INFLUENCE2	int
)	O
{	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
NEEDS_UPDATE	O
(	O
dragons_refinedly_examined	int
)	O
)	O
{	O
compute_refined_dragon_weaknesses	function
(	O
)	O
;	O
compute_strategic_sizes	function
(	O
)	O
;	O
}	O
if	O
(	O
how_much	int
==	O
FULL_EXAMINE_DRAGONS	int
)	O
{	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
printworms	int
)	O
show_dragons	function
(	O
)	O
;	O
}	O
void	O
silent_examine_position	function
(	O
int	O
how_much	int
)	O
{	O
int	O
save_verbose	int
=	O
verbose	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
save_debug	int
=	O
debug	int
;	O
int	O
save_printmoyo	int
=	O
printmoyo	int
;	O
verbose	int
=	O
0	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
debug	int
=	O
0	int
;	O
printmoyo	int
=	O
0	int
;	O
examine_position	function
(	O
how_much	int
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
debug	int
=	O
save_debug	int
;	O
printmoyo	int
=	O
save_printmoyo	int
;	O
}	O
int	O
genmove	function
(	O
int	O
color	int
,	O
float	O
*	O
value	pointer
,	O
int	O
*	O
resign	pointer
)	O
{	O
int	O
move	pointer
=	O
PASS_MOVE	int
;	O
if	O
(	O
resign	pointer
)	O
*	O
resign	pointer
=	O
0	int
;	O
if	O
(	O
limit_search	int
)	O
move	pointer
=	O
do_genmove	function
(	O
color	int
,	O
0.4	int
,	O
search_mask	array
,	O
value	pointer
,	O
resign	pointer
)	O
;	O
else	O
move	pointer
=	O
do_genmove	function
(	O
color	int
,	O
0.4	int
,	O
NULL	O
,	O
value	pointer
,	O
resign	pointer
)	O
;	O
gg_assert	O
(	O
move	pointer
==	O
PASS_MOVE	int
||	O
ON_BOARD	O
(	O
move	pointer
)	O
)	O
;	O
return	O
move	pointer
;	O
}	O
int	O
genmove_conservative	function
(	O
int	O
color	int
,	O
float	O
*	O
value	pointer
)	O
{	O
return	O
do_genmove	function
(	O
color	int
,	O
0.0	int
,	O
NULL	O
,	O
value	pointer
,	O
NULL	O
)	O
;	O
}	O
int	O
genmove_restricted	function
(	O
int	O
color	int
,	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
)	O
{	O
return	O
do_genmove	function
(	O
color	int
,	O
0.0	int
,	O
allowed_moves	array
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
collect_move_reasons	function
(	O
int	O
color	int
)	O
{	O
worm_reasons	function
(	O
color	int
)	O
;	O
semeai_move_reasons	function
(	O
color	int
)	O
;	O
owl_reasons	function
(	O
color	int
)	O
;	O
cut_reasons	function
(	O
color	int
)	O
;	O
break_in_move_reasons	function
(	O
color	int
)	O
;	O
unconditional_move_reasons	function
(	O
color	int
)	O
;	O
}	O
static	O
int	O
monte_carlo_genmove	function
(	O
int	O
color	int
,	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
value	pointer
,	O
int	O
*	O
resign	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
best_move	int
=	O
PASS_MOVE	int
;	O
int	O
best_uct_move	int
=	O
PASS_MOVE	int
;	O
int	O
unconditional_territory_black	array
[	O
BOARDMAX	O
]	O
;	O
int	O
unconditional_territory_white	array
[	O
BOARDMAX	O
]	O
;	O
int	O
forbidden_move	array
[	O
BOARDMAX	O
]	O
;	O
float	O
move_values	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
move_frequencies	pointer
[	O
BOARDMAX	O
]	O
;	O
float	O
best_value	float
;	O
int	O
frequency_cutoff	int
;	O
int	O
frequency_cutoff2	int
;	O
int	O
number_of_simulations	int
;	O
memset	function
(	O
move_values	pointer
,	O
0	int
,	O
sizeof	O
(	O
move_values	pointer
)	O
)	O
;	O
memset	function
(	O
move_frequencies	pointer
,	O
0	int
,	O
sizeof	O
(	O
move_frequencies	pointer
)	O
)	O
;	O
if	O
(	O
0	int
)	O
{	O
simple_showboard	function
(	O
stderr	pointer
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
resign	pointer
)	O
*	O
resign	pointer
=	O
0	int
;	O
unconditional_life	function
(	O
unconditional_territory_black	array
,	O
BLACK	int
)	O
;	O
unconditional_life	function
(	O
unconditional_territory_white	array
,	O
WHITE	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
unconditional_territory_black	array
[	O
pos	int
]	O
)	O
forbidden_move	array
[	O
pos	int
]	O
=	O
BLACK	int
;	O
else	O
if	O
(	O
unconditional_territory_white	array
[	O
pos	int
]	O
)	O
forbidden_move	array
[	O
pos	int
]	O
=	O
WHITE	int
;	O
else	O
forbidden_move	array
[	O
pos	int
]	O
=	O
0	int
;	O
number_of_simulations	int
=	O
mc_games_per_level	int
*	O
gg_max	O
(	O
get_level	function
(	O
)	O
,	O
1	int
)	O
;	O
uct_genmove	function
(	O
color	int
,	O
&	O
best_uct_move	int
,	O
forbidden_move	array
,	O
allowed_moves	array
,	O
number_of_simulations	int
,	O
move_values	pointer
,	O
move_frequencies	pointer
)	O
;	O
best_move	int
=	O
best_uct_move	int
;	O
best_value	float
=	O
0.0	int
;	O
frequency_cutoff	int
=	O
move_frequencies	pointer
[	O
best_uct_move	int
]	O
/	O
2	int
;	O
frequency_cutoff2	int
=	O
move_frequencies	pointer
[	O
best_uct_move	int
]	O
/	O
10	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
move_frequencies	pointer
[	O
pos	int
]	O
>	O
frequency_cutoff	int
||	O
(	O
move_values	pointer
[	O
pos	int
]	O
>	O
0.9	int
&&	O
move_frequencies	pointer
[	O
pos	int
]	O
>	O
frequency_cutoff2	int
)	O
||	O
move_values	pointer
[	O
best_uct_move	int
]	O
<	O
0.1	int
)	O
&&	O
(	O
!	O
allowed_moves	array
||	O
allowed_moves	array
[	O
pos	int
]	O
)	O
&&	O
potential_moves	array
[	O
pos	int
]	O
>	O
best_value	float
)	O
{	O
best_move	int
=	O
pos	int
;	O
best_value	float
=	O
potential_moves	array
[	O
pos	int
]	O
;	O
}	O
}	O
unconditionally_meaningless_move	function
(	O
best_move	int
,	O
color	int
,	O
&	O
best_move	int
)	O
;	O
*	O
value	pointer
=	O
1.0	int
;	O
return	O
best_move	int
;	O
}	O
static	O
int	O
do_genmove	function
(	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
value	pointer
,	O
int	O
*	O
resign	pointer
)	O
{	O
float	O
average_score	float
,	O
pessimistic_score	float
,	O
optimistic_score	float
;	O
int	O
save_verbose	int
;	O
int	O
save_depth	int
;	O
int	O
move	pointer
;	O
float	O
dummy_value	float
;	O
int	O
use_thrashing_dragon_heuristics	int
=	O
0	int
;	O
if	O
(	O
!	O
value	pointer
)	O
value	pointer
=	O
&	O
dummy_value	float
;	O
start_timer	function
(	O
0	int
)	O
;	O
clearstats	function
(	O
)	O
;	O
if	O
(	O
resign	pointer
)	O
*	O
resign	pointer
=	O
0	int
;	O
memset	function
(	O
potential_moves	array
,	O
0	int
,	O
sizeof	O
(	O
potential_moves	array
)	O
)	O
;	O
move	pointer
=	O
PASS_MOVE	int
;	O
*	O
value	pointer
=	O
0.0	int
;	O
reset_engine	function
(	O
)	O
;	O
save_depth	int
=	O
depth	int
;	O
if	O
(	O
play_mirror_go	int
&&	O
(	O
mirror_stones_limit	int
<	O
0	int
||	O
stones_on_board	function
(	O
WHITE	int
|	O
BLACK	int
)	O
<=	O
mirror_stones_limit	int
)	O
&&	O
find_mirror_move	function
(	O
&	O
move	pointer
,	O
color	int
)	O
)	O
{	O
TRACE	O
(	O
"genmove() recommends mirror move at %1m\n"	pointer
,	O
move	pointer
)	O
;	O
*	O
value	pointer
=	O
1.0	int
;	O
return	O
move	pointer
;	O
}	O
start_timer	function
(	O
1	int
)	O
;	O
examine_position	function
(	O
EXAMINE_ALL	int
,	O
0	int
)	O
;	O
time_report	function
(	O
1	int
,	O
"examine position"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
pessimistic_score	float
=	O
black_score	float
;	O
optimistic_score	float
=	O
white_score	float
;	O
}	O
else	O
{	O
pessimistic_score	float
=	O
-	O
white_score	float
;	O
optimistic_score	float
=	O
-	O
black_score	float
;	O
}	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
average_score	float
=	O
(	O
white_score	float
+	O
black_score	float
)	O
/	O
2.0	int
;	O
else	O
average_score	float
=	O
-	O
(	O
white_score	float
+	O
black_score	float
)	O
/	O
2.0	int
;	O
choose_strategy	function
(	O
color	int
,	O
average_score	float
,	O
game_status	function
(	O
color	int
)	O
)	O
;	O
if	O
(	O
printboard	int
)	O
{	O
if	O
(	O
printboard	int
==	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\n          dragon_status display:\n\n"	pointer
)	O
;	O
if	O
(	O
printboard	int
==	O
2	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\n          eye display:\n\n"	pointer
)	O
;	O
showboard	function
(	O
printboard	int
)	O
;	O
if	O
(	O
printboard	int
==	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n           owl_status display:\n\n"	pointer
)	O
;	O
showboard	function
(	O
3	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n           matcher_status display:\n\n"	pointer
)	O
;	O
showboard	function
(	O
4	int
)	O
;	O
}	O
}	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
collect_move_reasons	function
(	O
color	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
time_report	function
(	O
1	int
,	O
"generate move reasons"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
fuseki	function
(	O
color	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
break_mirror_go	function
(	O
color	int
)	O
;	O
if	O
(	O
!	O
doing_scoring	int
)	O
use_thrashing_dragon_heuristics	int
=	O
revise_thrashing_dragon	function
(	O
color	int
,	O
pessimistic_score	float
,	O
5.0	int
)	O
;	O
shapes	function
(	O
color	int
)	O
;	O
time_report	function
(	O
1	int
,	O
"shapes"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
combinations	function
(	O
color	int
)	O
;	O
time_report	function
(	O
1	int
,	O
"combinations"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
review_move_reasons	function
(	O
&	O
move	pointer
,	O
value	pointer
,	O
color	int
,	O
pure_threat_value	float
,	O
pessimistic_score	float
,	O
allowed_moves	array
,	O
use_thrashing_dragon_heuristics	int
)	O
)	O
TRACE	O
(	O
"Move generation likes %1m with value %f\n"	pointer
,	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
time_report	function
(	O
1	int
,	O
"review move reasons"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
*	O
value	pointer
<=	O
6.0	int
&&	O
!	O
disable_endgame_patterns	int
)	O
{	O
endgame_shapes	function
(	O
color	int
)	O
;	O
endgame	function
(	O
color	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
review_move_reasons	function
(	O
&	O
move	pointer
,	O
value	pointer
,	O
color	int
,	O
pure_threat_value	float
,	O
pessimistic_score	float
,	O
allowed_moves	array
,	O
use_thrashing_dragon_heuristics	int
)	O
)	O
TRACE	O
(	O
"Move generation likes %1m with value %f\n"	pointer
,	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
time_report	function
(	O
1	int
,	O
"endgame"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
revise_semeai	function
(	O
color	int
)	O
)	O
{	O
shapes	function
(	O
color	int
)	O
;	O
endgame_shapes	function
(	O
color	int
)	O
;	O
if	O
(	O
review_move_reasons	function
(	O
&	O
move	pointer
,	O
value	pointer
,	O
color	int
,	O
pure_threat_value	float
,	O
pessimistic_score	float
,	O
allowed_moves	array
,	O
use_thrashing_dragon_heuristics	int
)	O
)	O
{	O
TRACE	O
(	O
"Upon reconsideration move generation likes %1m with value %f\n"	pointer
,	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
}	O
}	O
time_report	function
(	O
1	int
,	O
"move reasons with revised semeai status"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
use_monte_carlo_genmove	int
&&	O
move	pointer
!=	O
PASS_MOVE	int
&&	O
(	O
*	O
value	pointer
<	O
75.0	int
||	O
*	O
value	pointer
>	O
75.01	int
)	O
&&	O
!	O
doing_scoring	int
)	O
{	O
int	O
allowed_moves2	array
[	O
BOARDMAX	O
]	O
;	O
int	O
num_allowed_moves2	int
=	O
0	int
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
!	O
allowed_moves	array
||	O
allowed_moves	array
[	O
pos	int
]	O
)	O
&&	O
is_allowed_move	function
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
allowed_moves2	array
[	O
pos	int
]	O
=	O
1	int
;	O
num_allowed_moves2	int
++	O
;	O
}	O
else	O
allowed_moves2	array
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
num_allowed_moves2	int
>	O
1	int
)	O
move	pointer
=	O
monte_carlo_genmove	function
(	O
color	int
,	O
allowed_moves2	array
,	O
value	pointer
,	O
resign	pointer
)	O
;	O
}	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
&&	O
fill_liberty	function
(	O
&	O
move	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
!	O
allowed_moves	array
||	O
allowed_moves	array
[	O
move	pointer
]	O
)	O
{	O
*	O
value	pointer
=	O
1.0	int
;	O
TRACE	O
(	O
"Filling a liberty at %1m\n"	pointer
,	O
move	pointer
)	O
;	O
record_top_move	function
(	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
move_considered	function
(	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
time_report	function
(	O
1	int
,	O
"fill liberty"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
else	O
move	pointer
=	O
PASS_MOVE	int
;	O
}	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
play_out_aftermath	int
||	O
capture_all_dead	int
||	O
(	O
!	O
doing_scoring	int
&&	O
thrashing_dragon	int
&&	O
pessimistic_score	float
>	O
15.0	int
)	O
)	O
move	pointer
=	O
aftermath_genmove	function
(	O
color	int
,	O
capture_all_dead	int
,	O
allowed_moves	array
)	O
;	O
if	O
(	O
move	pointer
!=	O
PASS_MOVE	int
)	O
{	O
ASSERT1	O
(	O
is_legal	function
(	O
move	pointer
,	O
color	int
)	O
,	O
move	pointer
)	O
;	O
*	O
value	pointer
=	O
1.0	int
;	O
TRACE	O
(	O
"Aftermath move at %1m\n"	pointer
,	O
move	pointer
)	O
;	O
record_top_move	function
(	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
move_considered	function
(	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
time_report	function
(	O
1	int
,	O
"aftermath_genmove"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
is_allowed_move	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
TRACE	O
(	O
"ILLEGAL MOVE GENERATED. Passing instead.\n"	pointer
)	O
;	O
move	pointer
=	O
PASS_MOVE	int
;	O
*	O
value	pointer
=	O
-	O
1.0	int
;	O
}	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
{	O
TRACE	O
(	O
"I pass.\n"	pointer
)	O
;	O
}	O
else	O
{	O
TRACE	O
(	O
"genmove() recommends %1m with value %f\n"	pointer
,	O
move	pointer
,	O
*	O
value	pointer
)	O
;	O
}	O
if	O
(	O
resign	pointer
&&	O
resign_allowed	int
&&	O
*	O
value	pointer
<	O
10.0	int
&&	O
should_resign	function
(	O
color	int
,	O
optimistic_score	float
,	O
move	pointer
)	O
)	O
{	O
TRACE	O
(	O
"... though, genmove() thinks the position is hopeless\n"	pointer
)	O
;	O
*	O
resign	pointer
=	O
1	int
;	O
}	O
if	O
(	O
showstatistics	int
)	O
showstats	function
(	O
)	O
;	O
if	O
(	O
showtime	int
)	O
{	O
double	O
spent	double
=	O
time_report	function
(	O
0	int
,	O
"TIME to generate move at "	pointer
,	O
move	pointer
,	O
1.0	int
)	O
;	O
total_time	double
+=	O
spent	double
;	O
if	O
(	O
spent	double
>	O
slowest_time	double
)	O
{	O
slowest_time	double
=	O
spent	double
;	O
slowest_move	int
=	O
move	pointer
;	O
slowest_movenum	int
=	O
movenum	int
+	O
1	int
;	O
}	O
}	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
gg_assert	O
(	O
test_gray_border	function
(	O
)	O
<	O
0	int
)	O
;	O
gg_assert	O
(	O
depth	int
==	O
save_depth	int
)	O
;	O
return	O
move	pointer
;	O
}	O
void	O
move_considered	function
(	O
int	O
move	pointer
,	O
float	O
value	pointer
)	O
{	O
if	O
(	O
value	pointer
>	O
potential_moves	array
[	O
move	pointer
]	O
)	O
potential_moves	array
[	O
move	pointer
]	O
=	O
value	pointer
;	O
}	O
static	O
int	O
revise_semeai	function
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
found_one	int
=	O
0	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
doing_scoring	int
)	O
return	O
0	int
;	O
gg_assert	O
(	O
dragon2	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
color	int
==	O
other	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
semeais	int
&&	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
{	O
found_one	int
=	O
1	int
;	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
=	O
UNKNOWN	int
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
)	O
TRACE	O
(	O
"revise_semeai: changed status of dragon %1m from DEAD to UNKNOWN\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
return	O
found_one	int
;	O
}	O
static	O
int	O
revise_thrashing_dragon	function
(	O
int	O
color	int
,	O
float	O
our_score	float
,	O
float	O
advantage	float
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
our_score	float
<	O
advantage	float
)	O
return	O
0	int
;	O
if	O
(	O
disable_threat_computation	int
||	O
!	O
thrashing_dragon	int
||	O
dragon	int
[	O
thrashing_dragon	int
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
return	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
thrashing_stone	array
[	O
pos	int
]	O
&&	O
worm	array
[	O
pos	int
]	O
.	O
unconditional_status	enum
!=	O
DEAD	int
)	O
{	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
=	O
UNKNOWN	int
;	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
=	O
ALIVE	int
;	O
}	O
set_strength_data	function
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
compute_influence	function
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array
,	O
strength	array
,	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
NO_MOVE	O
,	O
"revised thrashing dragon"	pointer
)	O
;	O
compute_refined_dragon_weaknesses	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
find_mirror_move	function
(	O
int	O
*	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
last_move	int
=	O
get_last_move	function
(	O
)	O
;	O
int	O
mirror_move	int
;	O
if	O
(	O
last_move	int
!=	O
NO_MOVE	O
)	O
{	O
mirror_move	int
=	O
MIRROR_MOVE	O
(	O
last_move	int
)	O
;	O
if	O
(	O
test_symmetry_after_move	function
(	O
mirror_move	int
,	O
color	int
,	O
0	int
)	O
)	O
{	O
*	O
move	pointer
=	O
mirror_move	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
mirror_move	int
=	O
BOARDMIN	O
;	O
mirror_move	int
<	O
BOARDMAX	O
;	O
mirror_move	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
mirror_move	int
)	O
&&	O
test_symmetry_after_move	function
(	O
mirror_move	int
,	O
color	int
,	O
0	int
)	O
)	O
{	O
*	O
move	pointer
=	O
mirror_move	int
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
compute_scores	function
(	O
int	O
use_chinese_rules	int
)	O
{	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
;	O
set_strength_data	function
(	O
WHITE	int
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
compute_influence	function
(	O
EMPTY	int
,	O
safe_stones	array
,	O
strength	array
,	O
&	O
move_influence	struct
,	O
NO_MOVE	O
,	O
"White territory estimate"	pointer
)	O
;	O
white_score	float
=	O
influence_score	function
(	O
&	O
move_influence	struct
,	O
use_chinese_rules	int
)	O
;	O
set_strength_data	function
(	O
BLACK	int
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
compute_influence	function
(	O
EMPTY	int
,	O
safe_stones	array
,	O
strength	array
,	O
&	O
move_influence	struct
,	O
NO_MOVE	O
,	O
"White territory estimate"	pointer
)	O
;	O
black_score	float
=	O
influence_score	function
(	O
&	O
move_influence	struct
,	O
use_chinese_rules	int
)	O
;	O
if	O
(	O
verbose	int
||	O
showscore	int
)	O
{	O
if	O
(	O
white_score	float
==	O
black_score	float
)	O
gprintf	function
(	O
"Score estimate: %s %f\n"	pointer
,	O
black_score	float
>	O
0	int
?	O
"W "	pointer
:	O
"B "	pointer
,	O
gg_abs	O
(	O
black_score	float
)	O
)	O
;	O
else	O
gprintf	function
(	O
"Score estimate: %s %f to %s %f\n"	pointer
,	O
black_score	float
>	O
0	int
?	O
"W "	pointer
:	O
"B "	pointer
,	O
gg_abs	O
(	O
black_score	float
)	O
,	O
white_score	float
>	O
0	int
?	O
"W "	pointer
:	O
"B "	pointer
,	O
gg_abs	O
(	O
white_score	float
)	O
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
}	O
static	O
void	O
break_mirror_go	function
(	O
int	O
color	int
)	O
{	O
int	O
tengen	int
=	O
POS	O
(	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
;	O
if	O
(	O
board	pointer
[	O
tengen	int
]	O
==	O
EMPTY	int
&&	O
color	int
==	O
BLACK	int
&&	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
10	int
&&	O
test_symmetry_after_move	function
(	O
tengen	int
,	O
color	int
,	O
1	int
)	O
)	O
{	O
set_minimum_move_value	function
(	O
tengen	int
,	O
30.0	int
)	O
;	O
TRACE	O
(	O
"Play %1m to break mirror go, value 30.\n"	pointer
,	O
tengen	int
)	O
;	O
}	O
}	O
static	O
int	O
should_resign	function
(	O
int	O
color	int
,	O
float	O
optimistic_score	float
,	O
int	O
move	pointer
)	O
{	O
float	O
status	enum
;	O
int	O
d	int
;	O
if	O
(	O
board_size	int
>	O
2	int
&&	O
move	pointer
==	O
PASS_MOVE	int
&&	O
!	O
lively_dragon_exists	function
(	O
color	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
||	O
board_size	int
<	O
19	int
||	O
optimistic_score	float
>	O
-	O
45.0	int
)	O
return	O
0	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
==	O
color	int
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum
==	O
CRITICAL	int
)	O
return	O
0	int
;	O
if	O
(	O
board	pointer
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum
!=	O
DEAD	int
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
effective_size	float
>=	O
10	int
&&	O
dragon_weak	function
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
)	O
)	O
return	O
0	int
;	O
}	O
status	enum
=	O
game_status	function
(	O
color	int
)	O
;	O
if	O
(	O
status	enum
<	O
0.8	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
set_limit_search	function
(	O
int	O
value	pointer
)	O
{	O
limit_search	int
=	O
value	pointer
;	O
}	O
void	O
set_search_diamond	function
(	O
int	O
pos	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
int	O
m	int
,	O
n	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
gg_abs	O
(	O
m	int
-	O
i	int
)	O
+	O
gg_abs	O
(	O
n	int
-	O
j	int
)	O
<=	O
6	int
)	O
search_mask	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
=	O
1	int
;	O
else	O
search_mask	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
=	O
0	int
;	O
}	O
limit_search	int
=	O
pos	int
;	O
if	O
(	O
0	int
)	O
draw_search_area	function
(	O
)	O
;	O
}	O
void	O
reset_search_mask	function
(	O
)	O
{	O
memset	function
(	O
search_mask	array
,	O
0	int
,	O
sizeof	O
(	O
search_mask	array
)	O
)	O
;	O
}	O
void	O
set_search_mask	function
(	O
int	O
pos	int
,	O
int	O
value	pointer
)	O
{	O
search_mask	array
[	O
pos	int
]	O
=	O
value	pointer
;	O
}	O
void	O
draw_search_area	function
(	O
void	O
)	O
{	O
int	O
m	int
,	O
n	int
;	O
start_draw_board	function
(	O
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
int	O
col	int
,	O
c	char
;	O
if	O
(	O
search_mask	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
col	int
=	O
GG_COLOR_RED	int
;	O
else	O
col	int
=	O
GG_COLOR_BLACK	int
;	O
if	O
(	O
board	pointer
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
else	O
if	O
(	O
board	pointer
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
search_mask	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
c	char
=	O
'*'	O
;	O
else	O
c	char
=	O
'.'	O
;	O
draw_color_char	function
(	O
m	int
,	O
n	int
,	O
c	char
,	O
col	int
)	O
;	O
}	O
end_draw_board	function
(	O
)	O
;	O
}	O
int	O
within_search_area	function
(	O
int	O
pos	int
)	O
{	O
if	O
(	O
!	O
limit_search	int
)	O
return	O
1	int
;	O
return	O
search_mask	array
[	O
pos	int
]	O
;	O
}	O
