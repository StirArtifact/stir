static	O
int	O
elf_sort_sections	function
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
assign_file_positions_except_relocs	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
swap_out_syms	function
(	O
bfd	struct
*	O
,	O
struct	O
elf_strtab_hash	O
*	O
*	O
,	O
int	O
)	O
;	O
static	O
bfd_boolean	int
elf_parse_notes	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
file_ptr	long
offset	long
,	O
size_t	long
align	long
)	O
;	O
void	O
_bfd_elf_swap_verdef_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_External_Verdef	struct
*	O
src	pointer
,	O
Elf_Internal_Verdef	struct
*	O
dst	pointer
)	O
{	O
dst	pointer
->	O
vd_version	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_version	array
)	O
;	O
dst	pointer
->	O
vd_flags	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_flags	array
)	O
;	O
dst	pointer
->	O
vd_ndx	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_ndx	array
)	O
;	O
dst	pointer
->	O
vd_cnt	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_cnt	array
)	O
;	O
dst	pointer
->	O
vd_hash	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_hash	array
)	O
;	O
dst	pointer
->	O
vd_aux	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_aux	array
)	O
;	O
dst	pointer
->	O
vd_next	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_verdef_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_Internal_Verdef	struct
*	O
src	pointer
,	O
Elf_External_Verdef	struct
*	O
dst	pointer
)	O
{	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_version	array
,	O
dst	pointer
->	O
vd_version	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_flags	array
,	O
dst	pointer
->	O
vd_flags	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_ndx	array
,	O
dst	pointer
->	O
vd_ndx	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_cnt	array
,	O
dst	pointer
->	O
vd_cnt	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_hash	array
,	O
dst	pointer
->	O
vd_hash	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_aux	array
,	O
dst	pointer
->	O
vd_aux	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vd_next	array
,	O
dst	pointer
->	O
vd_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_verdaux_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_External_Verdaux	struct
*	O
src	pointer
,	O
Elf_Internal_Verdaux	struct
*	O
dst	pointer
)	O
{	O
dst	pointer
->	O
vda_name	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vda_name	array
)	O
;	O
dst	pointer
->	O
vda_next	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vda_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_verdaux_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_Internal_Verdaux	struct
*	O
src	pointer
,	O
Elf_External_Verdaux	struct
*	O
dst	pointer
)	O
{	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vda_name	array
,	O
dst	pointer
->	O
vda_name	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vda_next	array
,	O
dst	pointer
->	O
vda_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_verneed_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_External_Verneed	struct
*	O
src	pointer
,	O
Elf_Internal_Verneed	struct
*	O
dst	pointer
)	O
{	O
dst	pointer
->	O
vn_version	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_version	array
)	O
;	O
dst	pointer
->	O
vn_cnt	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_cnt	array
)	O
;	O
dst	pointer
->	O
vn_file	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_file	array
)	O
;	O
dst	pointer
->	O
vn_aux	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_aux	array
)	O
;	O
dst	pointer
->	O
vn_next	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_verneed_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_Internal_Verneed	struct
*	O
src	pointer
,	O
Elf_External_Verneed	struct
*	O
dst	pointer
)	O
{	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_version	array
,	O
dst	pointer
->	O
vn_version	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_cnt	array
,	O
dst	pointer
->	O
vn_cnt	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_file	array
,	O
dst	pointer
->	O
vn_file	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_aux	array
,	O
dst	pointer
->	O
vn_aux	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vn_next	array
,	O
dst	pointer
->	O
vn_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_vernaux_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_External_Vernaux	struct
*	O
src	pointer
,	O
Elf_Internal_Vernaux	struct
*	O
dst	pointer
)	O
{	O
dst	pointer
->	O
vna_hash	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_hash	array
)	O
;	O
dst	pointer
->	O
vna_flags	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_flags	array
)	O
;	O
dst	pointer
->	O
vna_other	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_other	array
)	O
;	O
dst	pointer
->	O
vna_name	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_name	array
)	O
;	O
dst	pointer
->	O
vna_next	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_vernaux_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_Internal_Vernaux	struct
*	O
src	pointer
,	O
Elf_External_Vernaux	struct
*	O
dst	pointer
)	O
{	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_hash	array
,	O
dst	pointer
->	O
vna_hash	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_flags	array
,	O
dst	pointer
->	O
vna_flags	array
)	O
;	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_other	array
,	O
dst	pointer
->	O
vna_other	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_name	array
,	O
dst	pointer
->	O
vna_name	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vna_next	array
,	O
dst	pointer
->	O
vna_next	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_versym_in	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_External_Versym	struct
*	O
src	pointer
,	O
Elf_Internal_Versym	struct
*	O
dst	pointer
)	O
{	O
dst	pointer
->	O
vs_vers	array
=	O
H_GET_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vs_vers	array
)	O
;	O
}	O
void	O
_bfd_elf_swap_versym_out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
Elf_Internal_Versym	struct
*	O
src	pointer
,	O
Elf_External_Versym	struct
*	O
dst	pointer
)	O
{	O
H_PUT_16	O
(	O
abfd	pointer
,	O
src	pointer
->	O
vs_vers	array
,	O
dst	pointer
->	O
vs_vers	array
)	O
;	O
}	O
unsigned	O
long	O
bfd_elf_hash	function
(	O
const	O
char	O
*	O
namearg	pointer
)	O
{	O
const	O
unsigned	O
char	O
*	O
name	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
namearg	pointer
;	O
unsigned	O
long	O
h	pointer
=	O
0	int
;	O
unsigned	O
long	O
g	long
;	O
int	O
ch	int
;	O
while	O
(	O
(	O
ch	int
=	O
*	O
name	pointer
++	O
)	O
!=	O
'\0'	O
)	O
{	O
h	pointer
=	O
(	O
h	pointer
<<	O
4	int
)	O
+	O
ch	int
;	O
if	O
(	O
(	O
g	long
=	O
(	O
h	pointer
&	O
0xf0000000	int
)	O
)	O
!=	O
0	int
)	O
{	O
h	pointer
^=	O
g	long
>>	O
24	int
;	O
h	pointer
^=	O
g	long
;	O
}	O
}	O
return	O
h	pointer
&	O
0xffffffff	int
;	O
}	O
unsigned	O
long	O
bfd_elf_gnu_hash	function
(	O
const	O
char	O
*	O
namearg	pointer
)	O
{	O
const	O
unsigned	O
char	O
*	O
name	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
namearg	pointer
;	O
unsigned	O
long	O
h	pointer
=	O
5381	int
;	O
unsigned	O
char	O
ch	int
;	O
while	O
(	O
(	O
ch	int
=	O
*	O
name	pointer
++	O
)	O
!=	O
'\0'	O
)	O
h	pointer
=	O
(	O
h	pointer
<<	O
5	int
)	O
+	O
h	pointer
+	O
ch	int
;	O
return	O
h	pointer
&	O
0xffffffff	int
;	O
}	O
bfd_boolean	int
bfd_elf_allocate_object	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
size_t	long
object_size	long
,	O
enum	O
elf_target_id	enum
object_id	enum
)	O
{	O
BFD_ASSERT	O
(	O
object_size	long
>=	O
sizeof	O
(	O
struct	O
elf_obj_tdata	struct
)	O
)	O
;	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
object_size	long
)	O
;	O
if	O
(	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_object_id	O
(	O
abfd	pointer
)	O
=	O
object_id	enum
;	O
if	O
(	O
abfd	pointer
->	O
direction	enum
!=	O
read_direction	int
)	O
{	O
struct	O
output_elf_obj_tdata	struct
*	O
o	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
*	O
o	pointer
)	O
;	O
if	O
(	O
o	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
o	pointer
=	O
o	pointer
;	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
=	O
(	O
bfd_size_type	long
)	O
-	O
1	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_elf_make_object	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
return	O
bfd_elf_allocate_object	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
struct	O
elf_obj_tdata	struct
)	O
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
}	O
bfd_boolean	int
bfd_elf_mkcorefile	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
!	O
abfd	pointer
->	O
xvec	pointer
->	O
_bfd_set_format	array
[	O
(	O
int	O
)	O
bfd_object	int
]	O
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
)	O
)	O
;	O
return	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
!=	O
NULL	O
;	O
}	O
char	O
*	O
bfd_elf_get_str_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
shindex	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
*	O
i_shdrp	pointer
;	O
bfd_byte	char
*	O
shstrtab	pointer
=	O
NULL	O
;	O
file_ptr	long
offset	long
;	O
bfd_size_type	long
shstrtabsize	long
;	O
i_shdrp	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
i_shdrp	pointer
==	O
0	int
||	O
shindex	int
>=	O
elf_numsections	O
(	O
abfd	pointer
)	O
||	O
i_shdrp	pointer
[	O
shindex	int
]	O
==	O
0	int
)	O
return	O
NULL	O
;	O
shstrtab	pointer
=	O
i_shdrp	pointer
[	O
shindex	int
]	O
->	O
contents	pointer
;	O
if	O
(	O
shstrtab	pointer
==	O
NULL	O
)	O
{	O
offset	long
=	O
i_shdrp	pointer
[	O
shindex	int
]	O
->	O
sh_offset	array
;	O
shstrtabsize	long
=	O
i_shdrp	pointer
[	O
shindex	int
]	O
->	O
sh_size	array
;	O
if	O
(	O
shstrtabsize	long
+	O
1	int
<=	O
1	int
||	O
shstrtabsize	long
>	O
bfd_get_file_size	function
(	O
abfd	pointer
)	O
||	O
bfd_seek	function
(	O
abfd	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
(	O
shstrtab	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
shstrtabsize	long
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
shstrtab	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
bfd_bread	function
(	O
shstrtab	pointer
,	O
shstrtabsize	long
,	O
abfd	pointer
)	O
!=	O
shstrtabsize	long
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
shstrtab	pointer
)	O
;	O
shstrtab	pointer
=	O
NULL	O
;	O
i_shdrp	pointer
[	O
shindex	int
]	O
->	O
sh_size	array
=	O
0	int
;	O
}	O
else	O
shstrtab	pointer
[	O
shstrtabsize	long
]	O
=	O
'\0'	O
;	O
i_shdrp	pointer
[	O
shindex	int
]	O
->	O
contents	pointer
=	O
shstrtab	pointer
;	O
}	O
return	O
(	O
char	O
*	O
)	O
shstrtab	pointer
;	O
}	O
char	O
*	O
bfd_elf_string_from_elf_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
shindex	int
,	O
unsigned	O
int	O
strindex	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
if	O
(	O
strindex	int
==	O
0	int
)	O
return	O
""	pointer
;	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
==	O
NULL	O
||	O
shindex	int
>=	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
return	O
NULL	O
;	O
hdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
;	O
if	O
(	O
hdr	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_STRTAB	int
&&	O
hdr	pointer
->	O
sh_type	array
<	O
SHT_LOOS	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: attempt to load strings from"	pointer
" a non-string section (number %d)"	pointer
)	O
,	O
abfd	pointer
,	O
shindex	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
bfd_elf_get_str_section	function
(	O
abfd	pointer
,	O
shindex	int
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_size	array
==	O
0	int
||	O
hdr	pointer
->	O
contents	pointer
[	O
hdr	pointer
->	O
sh_size	array
-	O
1	int
]	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
strindex	int
>=	O
hdr	pointer
->	O
sh_size	array
)	O
{	O
unsigned	O
int	O
shstrndx	int
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_shstrndx	array
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: invalid string offset %u >= %"	pointer
PRIu64	O
" for section `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
strindex	int
,	O
(	O
uint64_t	long
)	O
hdr	pointer
->	O
sh_size	array
,	O
(	O
shindex	int
==	O
shstrndx	int
&&	O
strindex	int
==	O
hdr	pointer
->	O
sh_name	array
?	O
".shstrtab"	pointer
:	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shstrndx	int
,	O
hdr	pointer
->	O
sh_name	array
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
(	O
(	O
char	O
*	O
)	O
hdr	pointer
->	O
contents	pointer
)	O
+	O
strindex	int
;	O
}	O
Elf_Internal_Sym	struct
*	O
bfd_elf_get_elf_syms	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
size_t	long
symcount	int
,	O
size_t	long
symoffset	long
,	O
Elf_Internal_Sym	struct
*	O
intsym_buf	pointer
,	O
void	O
*	O
extsym_buf	pointer
,	O
Elf_External_Sym_Shndx	struct
*	O
extshndx_buf	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
shndx_hdr	pointer
;	O
void	O
*	O
alloc_ext	pointer
;	O
const	O
bfd_byte	char
*	O
esym	pointer
;	O
Elf_External_Sym_Shndx	struct
*	O
alloc_extshndx	pointer
;	O
Elf_External_Sym_Shndx	struct
*	O
shndx	pointer
;	O
Elf_Internal_Sym	struct
*	O
alloc_intsym	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
Elf_Internal_Sym	struct
*	O
isymend	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
size_t	long
extsym_size	long
;	O
bfd_size_type	long
amt	long
;	O
file_ptr	long
pos	long
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
symcount	int
==	O
0	int
)	O
return	O
intsym_buf	pointer
;	O
shndx_hdr	pointer
=	O
NULL	O
;	O
if	O
(	O
elf_symtab_shndx_list	O
(	O
ibfd	pointer
)	O
!=	O
NULL	O
)	O
{	O
elf_section_list	struct
*	O
entry	pointer
;	O
Elf_Internal_Shdr	struct
*	O
*	O
sections	pointer
=	O
elf_elfsections	O
(	O
ibfd	pointer
)	O
;	O
for	O
(	O
entry	pointer
=	O
elf_symtab_shndx_list	O
(	O
ibfd	pointer
)	O
;	O
entry	pointer
!=	O
NULL	O
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
hdr	pointer
.	O
sh_link	array
>=	O
elf_numsections	O
(	O
ibfd	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
sections	pointer
[	O
entry	pointer
->	O
hdr	pointer
.	O
sh_link	array
]	O
==	O
symtab_hdr	struct
)	O
{	O
shndx_hdr	pointer
=	O
&	O
entry	pointer
->	O
hdr	pointer
;	O
break	O
;	O
}	O
;	O
}	O
if	O
(	O
shndx_hdr	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
symtab_hdr	struct
==	O
&	O
elf_symtab_hdr	O
(	O
ibfd	pointer
)	O
)	O
shndx_hdr	pointer
=	O
&	O
elf_symtab_shndx_list	O
(	O
ibfd	pointer
)	O
->	O
hdr	pointer
;	O
}	O
}	O
alloc_ext	pointer
=	O
NULL	O
;	O
alloc_extshndx	pointer
=	O
NULL	O
;	O
alloc_intsym	pointer
=	O
NULL	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
ibfd	pointer
)	O
;	O
extsym_size	long
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
amt	long
=	O
(	O
bfd_size_type	long
)	O
symcount	int
*	O
extsym_size	long
;	O
pos	long
=	O
symtab_hdr	struct
->	O
sh_offset	array
+	O
symoffset	long
*	O
extsym_size	long
;	O
if	O
(	O
extsym_buf	pointer
==	O
NULL	O
)	O
{	O
alloc_ext	pointer
=	O
bfd_malloc2	function
(	O
symcount	int
,	O
extsym_size	long
)	O
;	O
extsym_buf	pointer
=	O
alloc_ext	pointer
;	O
}	O
if	O
(	O
extsym_buf	pointer
==	O
NULL	O
||	O
bfd_seek	function
(	O
ibfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
extsym_buf	pointer
,	O
amt	long
,	O
ibfd	pointer
)	O
!=	O
amt	long
)	O
{	O
intsym_buf	pointer
=	O
NULL	O
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
shndx_hdr	pointer
==	O
NULL	O
||	O
shndx_hdr	pointer
->	O
sh_size	array
==	O
0	int
)	O
extshndx_buf	pointer
=	O
NULL	O
;	O
else	O
{	O
amt	long
=	O
(	O
bfd_size_type	long
)	O
symcount	int
*	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
pos	long
=	O
shndx_hdr	pointer
->	O
sh_offset	array
+	O
symoffset	long
*	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
if	O
(	O
extshndx_buf	pointer
==	O
NULL	O
)	O
{	O
alloc_extshndx	pointer
=	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
bfd_malloc2	function
(	O
symcount	int
,	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
)	O
;	O
extshndx_buf	pointer
=	O
alloc_extshndx	pointer
;	O
}	O
if	O
(	O
extshndx_buf	pointer
==	O
NULL	O
||	O
bfd_seek	function
(	O
ibfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
extshndx_buf	pointer
,	O
amt	long
,	O
ibfd	pointer
)	O
!=	O
amt	long
)	O
{	O
intsym_buf	pointer
=	O
NULL	O
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
intsym_buf	pointer
==	O
NULL	O
)	O
{	O
alloc_intsym	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
bfd_malloc2	function
(	O
symcount	int
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
)	O
;	O
intsym_buf	pointer
=	O
alloc_intsym	pointer
;	O
if	O
(	O
intsym_buf	pointer
==	O
NULL	O
)	O
goto	O
out	O
;	O
}	O
isymend	pointer
=	O
intsym_buf	pointer
+	O
symcount	int
;	O
for	O
(	O
esym	pointer
=	O
(	O
const	O
bfd_byte	char
*	O
)	O
extsym_buf	pointer
,	O
isym	pointer
=	O
intsym_buf	pointer
,	O
shndx	pointer
=	O
extshndx_buf	pointer
;	O
isym	pointer
<	O
isymend	pointer
;	O
esym	pointer
+=	O
extsym_size	long
,	O
isym	pointer
++	O
,	O
shndx	pointer
=	O
shndx	pointer
!=	O
NULL	O
?	O
shndx	pointer
+	O
1	int
:	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_in	pointer
)	O
(	O
ibfd	pointer
,	O
esym	pointer
,	O
shndx	pointer
,	O
isym	pointer
)	O
)	O
{	O
symoffset	long
+=	O
(	O
esym	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
extsym_buf	pointer
)	O
/	O
extsym_size	long
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB symbol number %lu references"	pointer
" nonexistent SHT_SYMTAB_SHNDX section"	pointer
)	O
,	O
ibfd	pointer
,	O
(	O
unsigned	O
long	O
)	O
symoffset	long
)	O
;	O
if	O
(	O
alloc_intsym	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_intsym	pointer
)	O
;	O
intsym_buf	pointer
=	O
NULL	O
;	O
goto	O
out	O
;	O
}	O
out	O
:	O
if	O
(	O
alloc_ext	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_ext	pointer
)	O
;	O
if	O
(	O
alloc_extshndx	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_extshndx	pointer
)	O
;	O
return	O
intsym_buf	pointer
;	O
}	O
const	O
char	O
*	O
bfd_elf_sym_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
Elf_Internal_Sym	struct
*	O
isym	pointer
,	O
asection	struct
*	O
sym_sec	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
iname	int
=	O
isym	pointer
->	O
st_name	array
;	O
unsigned	O
int	O
shindex	int
=	O
symtab_hdr	struct
->	O
sh_link	array
;	O
if	O
(	O
iname	int
==	O
0	int
&&	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_SECTION	int
&&	O
isym	pointer
->	O
st_shndx	array
<	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
{	O
iname	int
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
isym	pointer
->	O
st_shndx	array
]	O
->	O
sh_name	array
;	O
shindex	int
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_shstrndx	array
;	O
}	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shindex	int
,	O
iname	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
"(null)"	pointer
;	O
else	O
if	O
(	O
sym_sec	pointer
&&	O
*	O
name	pointer
==	O
'\0'	O
)	O
name	pointer
=	O
bfd_section_name	function
(	O
sym_sec	pointer
)	O
;	O
return	O
name	pointer
;	O
}	O
typedef	O
union	O
elf_internal_group	union
{	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
;	O
unsigned	O
int	O
flags	int
;	O
}	O
Elf_Internal_Group	union
;	O
static	O
const	O
char	O
*	O
group_signature	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
ghdr	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
unsigned	O
char	O
esym	pointer
[	O
sizeof	O
(	O
Elf64_External_Sym	struct
)	O
]	O
;	O
Elf_External_Sym_Shndx	struct
eshndx	struct
;	O
Elf_Internal_Sym	struct
isym	pointer
;	O
if	O
(	O
ghdr	pointer
->	O
sh_link	array
>=	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
return	O
NULL	O
;	O
hdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
ghdr	pointer
->	O
sh_link	array
]	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_SYMTAB	int
||	O
!	O
bfd_section_from_shdr	function
(	O
abfd	pointer
,	O
ghdr	pointer
->	O
sh_link	array
)	O
)	O
return	O
NULL	O
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
if	O
(	O
bfd_elf_get_elf_syms	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
1	int
,	O
ghdr	pointer
->	O
sh_info	array
,	O
&	O
isym	pointer
,	O
esym	pointer
,	O
&	O
eshndx	struct
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
&	O
isym	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
bfd_boolean	int
setup_group	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
,	O
asection	struct
*	O
newsect	pointer
)	O
{	O
unsigned	O
int	O
num_group	int
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
;	O
if	O
(	O
num_group	int
==	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
,	O
shnum	int
;	O
shnum	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
num_group	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
shnum	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
IS_VALID_GROUP_SECTION_HEADER	O
(	O
shdr	pointer
,	O
2	int
*	O
GRP_ENTRY_SIZE	int
)	O
)	O
num_group	int
+=	O
1	int
;	O
}	O
if	O
(	O
num_group	int
==	O
0	int
)	O
{	O
num_group	int
=	O
(	O
unsigned	O
)	O
-	O
1	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
=	O
num_group	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
bfd_size_type	long
amt	long
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
=	O
num_group	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
=	O
(	O
Elf_Internal_Shdr	struct
*	O
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
num_group	int
,	O
sizeof	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memset	function
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
,	O
0	int
,	O
num_group	int
*	O
sizeof	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
)	O
;	O
num_group	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
shnum	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
IS_VALID_GROUP_SECTION_HEADER	O
(	O
shdr	pointer
,	O
2	int
*	O
GRP_ENTRY_SIZE	int
)	O
)	O
{	O
unsigned	O
char	O
*	O
src	pointer
;	O
Elf_Internal_Group	union
*	O
dest	pointer
;	O
if	O
(	O
!	O
bfd_section_from_shdr	function
(	O
abfd	pointer
,	O
i	pointer
)	O
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
[	O
num_group	int
]	O
=	O
shdr	pointer
;	O
num_group	int
+=	O
1	int
;	O
BFD_ASSERT	O
(	O
sizeof	O
(	O
*	O
dest	pointer
)	O
>=	O
4	int
)	O
;	O
amt	long
=	O
shdr	pointer
->	O
sh_size	array
*	O
sizeof	O
(	O
*	O
dest	pointer
)	O
/	O
4	int
;	O
shdr	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
shdr	pointer
->	O
sh_size	array
,	O
sizeof	O
(	O
*	O
dest	pointer
)	O
/	O
4	int
)	O
;	O
if	O
(	O
shdr	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: corrupt size field in group section"	pointer
" header: %#"	pointer
PRIx64	O
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
shdr	pointer
->	O
sh_size	array
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
--	O
num_group	int
;	O
continue	O
;	O
}	O
memset	function
(	O
shdr	pointer
->	O
contents	pointer
,	O
0	int
,	O
amt	long
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
shdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
(	O
bfd_bread	function
(	O
shdr	pointer
->	O
contents	pointer
,	O
shdr	pointer
->	O
sh_size	array
,	O
abfd	pointer
)	O
!=	O
shdr	pointer
->	O
sh_size	array
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: invalid size field in group section"	pointer
" header: %#"	pointer
PRIx64	O
""	pointer
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
shdr	pointer
->	O
sh_size	array
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
--	O
num_group	int
;	O
memset	function
(	O
shdr	pointer
->	O
contents	pointer
,	O
0	int
,	O
amt	long
)	O
;	O
continue	O
;	O
}	O
src	pointer
=	O
shdr	pointer
->	O
contents	pointer
+	O
shdr	pointer
->	O
sh_size	array
;	O
dest	pointer
=	O
(	O
Elf_Internal_Group	union
*	O
)	O
(	O
shdr	pointer
->	O
contents	pointer
+	O
amt	long
)	O
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
idx	int
;	O
src	pointer
-=	O
4	int
;	O
--	O
dest	pointer
;	O
idx	int
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
src	pointer
)	O
;	O
if	O
(	O
src	pointer
==	O
shdr	pointer
->	O
contents	pointer
)	O
{	O
dest	pointer
->	O
flags	int
=	O
idx	int
;	O
if	O
(	O
shdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
idx	int
&	O
GRP_COMDAT	int
)	O
)	O
shdr	pointer
->	O
bfd_section	struct
->	O
flags	int
|=	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES_DISCARD	int
;	O
break	O
;	O
}	O
if	O
(	O
idx	int
<	O
shnum	int
)	O
{	O
dest	pointer
->	O
shdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
idx	int
]	O
;	O
dest	pointer
->	O
shdr	pointer
->	O
sh_flags	array
|=	O
SHF_GROUP	O
;	O
}	O
if	O
(	O
idx	int
>=	O
shnum	int
||	O
dest	pointer
->	O
shdr	pointer
->	O
sh_type	array
==	O
SHT_GROUP	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: invalid entry in SHT_GROUP section [%u]"	pointer
)	O
,	O
abfd	pointer
,	O
i	pointer
)	O
;	O
dest	pointer
->	O
shdr	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
num_group	int
!=	O
(	O
unsigned	O
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
)	O
{	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
=	O
num_group	int
;	O
if	O
(	O
num_group	int
==	O
0	int
)	O
{	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
=	O
NULL	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
=	O
num_group	int
=	O
-	O
1	int
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: no valid group sections found"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
num_group	int
!=	O
(	O
unsigned	O
)	O
-	O
1	int
)	O
{	O
unsigned	O
int	O
search_offset	int
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_search_offset	int
;	O
unsigned	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_group	int
;	O
j	int
++	O
)	O
{	O
unsigned	O
i	pointer
=	O
(	O
j	int
+	O
search_offset	int
)	O
%	O
num_group	int
;	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
[	O
i	pointer
]	O
;	O
Elf_Internal_Group	union
*	O
idx	int
;	O
bfd_size_type	long
n_elt	long
;	O
if	O
(	O
shdr	pointer
==	O
NULL	O
)	O
continue	O
;	O
idx	int
=	O
(	O
Elf_Internal_Group	union
*	O
)	O
shdr	pointer
->	O
contents	pointer
;	O
if	O
(	O
idx	int
==	O
NULL	O
||	O
shdr	pointer
->	O
sh_size	array
<	O
4	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: group section '%pA' has no contents"	pointer
)	O
,	O
abfd	pointer
,	O
shdr	pointer
->	O
bfd_section	struct
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
[	O
i	pointer
]	O
=	O
NULL	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
n_elt	long
=	O
shdr	pointer
->	O
sh_size	array
/	O
4	int
;	O
while	O
(	O
--	O
n_elt	long
!=	O
0	int
)	O
if	O
(	O
(	O
++	O
idx	int
)	O
->	O
shdr	pointer
==	O
hdr	pointer
)	O
{	O
asection	struct
*	O
s	pointer
=	O
NULL	O
;	O
idx	int
=	O
(	O
Elf_Internal_Group	union
*	O
)	O
shdr	pointer
->	O
contents	pointer
;	O
n_elt	long
=	O
shdr	pointer
->	O
sh_size	array
/	O
4	int
;	O
while	O
(	O
--	O
n_elt	long
!=	O
0	int
)	O
if	O
(	O
(	O
++	O
idx	int
)	O
->	O
shdr	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
=	O
idx	int
->	O
shdr	pointer
->	O
bfd_section	struct
)	O
!=	O
NULL	O
&&	O
elf_next_in_group	O
(	O
s	pointer
)	O
!=	O
NULL	O
)	O
break	O
;	O
if	O
(	O
n_elt	long
!=	O
0	int
)	O
{	O
elf_group_name	O
(	O
newsect	pointer
)	O
=	O
elf_group_name	O
(	O
s	pointer
)	O
;	O
elf_next_in_group	O
(	O
newsect	pointer
)	O
=	O
elf_next_in_group	O
(	O
s	pointer
)	O
;	O
elf_next_in_group	O
(	O
s	pointer
)	O
=	O
newsect	pointer
;	O
}	O
else	O
{	O
const	O
char	O
*	O
gname	pointer
;	O
gname	pointer
=	O
group_signature	function
(	O
abfd	pointer
,	O
shdr	pointer
)	O
;	O
if	O
(	O
gname	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_group_name	O
(	O
newsect	pointer
)	O
=	O
gname	pointer
;	O
elf_next_in_group	O
(	O
newsect	pointer
)	O
=	O
newsect	pointer
;	O
}	O
if	O
(	O
shdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
elf_next_in_group	O
(	O
shdr	pointer
->	O
bfd_section	struct
)	O
=	O
newsect	pointer
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_search_offset	int
=	O
i	pointer
;	O
j	int
=	O
num_group	int
-	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
elf_group_name	O
(	O
newsect	pointer
)	O
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: no group info for section '%pA'"	pointer
)	O
,	O
abfd	pointer
,	O
newsect	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_setup_sections	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
num_group	int
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
num_group	int
;	O
bfd_boolean	int
result	int
=	O
TRUE	int
;	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
this_hdr	struct
=	O
&	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_LINK_ORDER	O
)	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
elfsec	int
=	O
this_hdr	struct
->	O
sh_link	array
;	O
if	O
(	O
elfsec	int
==	O
0	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
link_order_error_handler	pointer
)	O
bed	pointer
->	O
link_order_error_handler	pointer
(	O
_	O
(	O
"%pB: warning: sh_link not set for section `%pA'"	pointer
)	O
,	O
abfd	pointer
,	O
s	pointer
)	O
;	O
}	O
else	O
{	O
asection	struct
*	O
linksec	pointer
=	O
NULL	O
;	O
if	O
(	O
elfsec	int
<	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
{	O
this_hdr	struct
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elfsec	int
]	O
;	O
linksec	pointer
=	O
this_hdr	struct
->	O
bfd_section	struct
;	O
}	O
if	O
(	O
linksec	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: sh_link [%d] in section `%pA' is incorrect"	pointer
)	O
,	O
s	pointer
->	O
owner	pointer
,	O
elfsec	int
,	O
s	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
elf_linked_to_section	O
(	O
s	pointer
)	O
=	O
linksec	pointer
;	O
}	O
}	O
else	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
==	O
SHT_GROUP	int
&&	O
elf_next_in_group	O
(	O
s	pointer
)	O
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: SHT_GROUP section [index %d] has no SHF_GROUP sections"	pointer
)	O
,	O
abfd	pointer
,	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
num_group	int
==	O
(	O
unsigned	O
)	O
-	O
1	int
)	O
return	O
result	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_group	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
group_sect_ptr	pointer
[	O
i	pointer
]	O
;	O
Elf_Internal_Group	union
*	O
idx	int
;	O
unsigned	O
int	O
n_elt	long
;	O
if	O
(	O
shdr	pointer
==	O
NULL	O
||	O
shdr	pointer
->	O
bfd_section	struct
==	O
NULL	O
||	O
shdr	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: section group entry number %u is corrupt"	pointer
)	O
,	O
abfd	pointer
,	O
i	pointer
)	O
;	O
result	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
idx	int
=	O
(	O
Elf_Internal_Group	union
*	O
)	O
shdr	pointer
->	O
contents	pointer
;	O
n_elt	long
=	O
shdr	pointer
->	O
sh_size	array
/	O
4	int
;	O
while	O
(	O
--	O
n_elt	long
!=	O
0	int
)	O
{	O
++	O
idx	int
;	O
if	O
(	O
idx	int
->	O
shdr	pointer
==	O
NULL	O
)	O
continue	O
;	O
else	O
if	O
(	O
idx	int
->	O
shdr	pointer
->	O
bfd_section	struct
)	O
elf_sec_group	O
(	O
idx	int
->	O
shdr	pointer
->	O
bfd_section	struct
)	O
=	O
shdr	pointer
->	O
bfd_section	struct
;	O
else	O
if	O
(	O
idx	int
->	O
shdr	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
&&	O
idx	int
->	O
shdr	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unknown type [%#x] section `%s' in group [%pA]"	pointer
)	O
,	O
abfd	pointer
,	O
idx	int
->	O
shdr	pointer
->	O
sh_type	array
,	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_shstrndx	array
)	O
,	O
idx	int
->	O
shdr	pointer
->	O
sh_name	array
)	O
,	O
shdr	pointer
->	O
bfd_section	struct
)	O
;	O
result	int
=	O
FALSE	int
;	O
}	O
}	O
}	O
return	O
result	int
;	O
}	O
bfd_boolean	int
bfd_elf_is_group_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
asection	struct
*	O
sec	pointer
)	O
{	O
return	O
elf_next_in_group	O
(	O
sec	pointer
)	O
!=	O
NULL	O
;	O
}	O
const	O
char	O
*	O
bfd_elf_group_name	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
elf_sec_group	O
(	O
sec	pointer
)	O
!=	O
NULL	O
)	O
return	O
elf_group_name	O
(	O
sec	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
convert_debug_to_zdebug	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
char	O
*	O
new_name	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
+	O
2	int
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_name	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
new_name	pointer
[	O
1	int
]	O
=	O
'z'	O
;	O
memcpy	function
(	O
new_name	pointer
+	O
2	int
,	O
name	pointer
+	O
1	int
,	O
len	long
)	O
;	O
return	O
new_name	pointer
;	O
}	O
static	O
char	O
*	O
convert_zdebug_to_debug	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
char	O
*	O
new_name	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_name	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
memcpy	function
(	O
new_name	pointer
+	O
1	int
,	O
name	pointer
+	O
2	int
,	O
len	long
-	O
1	int
)	O
;	O
return	O
new_name	pointer
;	O
}	O
struct	O
lto_section	struct
{	O
int16_t	short
major_version	short
;	O
int16_t	short
minor_version	short
;	O
unsigned	O
char	O
slim_object	char
;	O
uint16_t	short
flags	int
;	O
}	O
;	O
bfd_boolean	int
_bfd_elf_make_section_from_shdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
shindex	int
)	O
{	O
asection	struct
*	O
newsect	pointer
;	O
flagword	int
flags	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
hdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
newsect	pointer
=	O
bfd_make_section_anyway	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
newsect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
hdr	pointer
->	O
bfd_section	struct
=	O
newsect	pointer
;	O
elf_section_data	O
(	O
newsect	pointer
)	O
->	O
this_hdr	struct
=	O
*	O
hdr	pointer
;	O
elf_section_data	O
(	O
newsect	pointer
)	O
->	O
this_idx	int
=	O
shindex	int
;	O
elf_section_type	O
(	O
newsect	pointer
)	O
=	O
hdr	pointer
->	O
sh_type	array
;	O
elf_section_flags	O
(	O
newsect	pointer
)	O
=	O
hdr	pointer
->	O
sh_flags	array
;	O
newsect	pointer
->	O
filepos	long
=	O
hdr	pointer
->	O
sh_offset	array
;	O
if	O
(	O
!	O
bfd_set_section_vma	function
(	O
newsect	pointer
,	O
hdr	pointer
->	O
sh_addr	array
)	O
||	O
!	O
bfd_set_section_size	function
(	O
newsect	pointer
,	O
hdr	pointer
->	O
sh_size	array
)	O
||	O
!	O
bfd_set_section_alignment	function
(	O
newsect	pointer
,	O
bfd_log2	function
(	O
hdr	pointer
->	O
sh_addralign	array
)	O
)	O
)	O
return	O
FALSE	int
;	O
flags	int
=	O
SEC_NO_FLAGS	int
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
flags	int
|=	O
SEC_HAS_CONTENTS	int
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_GROUP	int
)	O
flags	int
|=	O
SEC_GROUP	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
{	O
flags	int
|=	O
SEC_ALLOC	int
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
flags	int
|=	O
SEC_LOAD	int
;	O
}	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_WRITE	O
)	O
==	O
0	int
)	O
flags	int
|=	O
SEC_READONLY	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_EXECINSTR	O
)	O
!=	O
0	int
)	O
flags	int
|=	O
SEC_CODE	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
flags	int
|=	O
SEC_DATA	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_MERGE	O
)	O
!=	O
0	int
)	O
{	O
flags	int
|=	O
SEC_MERGE	int
;	O
newsect	pointer
->	O
entsize	int
=	O
hdr	pointer
->	O
sh_entsize	array
;	O
}	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_STRINGS	O
)	O
!=	O
0	int
)	O
flags	int
|=	O
SEC_STRINGS	int
;	O
if	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_GROUP	O
)	O
if	O
(	O
!	O
setup_group	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
newsect	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_TLS	O
)	O
!=	O
0	int
)	O
flags	int
|=	O
SEC_THREAD_LOCAL	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_EXCLUDE	int
)	O
!=	O
0	int
)	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
switch	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
)	O
{	O
case	O
ELFOSABI_NONE	int
:	O
case	O
ELFOSABI_GNU	int
:	O
case	O
ELFOSABI_FREEBSD	int
:	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_GNU_MBIND	int
)	O
!=	O
0	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
|=	O
elf_gnu_osabi_mbind	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
".debug"	pointer
,	O
6	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
name	pointer
,	O
".gnu.linkonce.wi."	pointer
,	O
17	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
name	pointer
,	O
".zdebug"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
flags	int
|=	O
SEC_DEBUGGING	int
|	O
SEC_ELF_OCTETS	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
GNU_BUILD_ATTRS_SECTION_NAME	pointer
,	O
21	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
name	pointer
,	O
".note.gnu"	pointer
,	O
9	int
)	O
==	O
0	int
)	O
flags	int
|=	O
SEC_ELF_OCTETS	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
".line"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
name	pointer
,	O
".stab"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
".gdb_index"	pointer
)	O
==	O
0	int
)	O
flags	int
|=	O
SEC_DEBUGGING	int
;	O
}	O
}	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
".gnu.linkonce"	pointer
)	O
&&	O
elf_next_in_group	O
(	O
newsect	pointer
)	O
==	O
NULL	O
)	O
flags	int
|=	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES_DISCARD	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_section_flags	pointer
)	O
if	O
(	O
!	O
bed	pointer
->	O
elf_backend_section_flags	pointer
(	O
&	O
flags	int
,	O
hdr	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
bfd_set_section_flags	function
(	O
newsect	pointer
,	O
flags	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_NOTE	int
)	O
{	O
bfd_byte	char
*	O
contents	pointer
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
newsect	pointer
,	O
&	O
contents	pointer
)	O
)	O
return	O
FALSE	int
;	O
elf_parse_notes	function
(	O
abfd	pointer
,	O
(	O
char	O
*	O
)	O
contents	pointer
,	O
hdr	pointer
->	O
sh_size	array
,	O
hdr	pointer
->	O
sh_offset	array
,	O
hdr	pointer
->	O
sh_addralign	array
)	O
;	O
free	function
(	O
contents	pointer
)	O
;	O
}	O
if	O
(	O
(	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Phdr	struct
*	O
phdr	pointer
;	O
unsigned	O
int	O
i	pointer
,	O
nload	int
;	O
phdr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
;	O
for	O
(	O
nload	int
=	O
0	int
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
;	O
i	pointer
++	O
,	O
phdr	pointer
++	O
)	O
if	O
(	O
phdr	pointer
->	O
p_paddr	array
!=	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
phdr	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
phdr	pointer
->	O
p_memsz	array
!=	O
0	int
)	O
++	O
nload	int
;	O
if	O
(	O
i	pointer
>=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
&&	O
nload	int
>	O
1	int
)	O
return	O
TRUE	int
;	O
phdr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
;	O
i	pointer
++	O
,	O
phdr	pointer
++	O
)	O
{	O
if	O
(	O
(	O
(	O
phdr	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_TLS	O
)	O
==	O
0	int
)	O
||	O
phdr	pointer
->	O
p_type	array
==	O
PT_TLS	int
)	O
&&	O
ELF_SECTION_IN_SEGMENT	O
(	O
hdr	pointer
,	O
phdr	pointer
)	O
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
)	O
newsect	pointer
->	O
lma	long
=	O
(	O
phdr	pointer
->	O
p_paddr	array
+	O
hdr	pointer
->	O
sh_addr	array
-	O
phdr	pointer
->	O
p_vaddr	array
)	O
;	O
else	O
newsect	pointer
->	O
lma	long
=	O
(	O
phdr	pointer
->	O
p_paddr	array
+	O
hdr	pointer
->	O
sh_offset	array
-	O
phdr	pointer
->	O
p_offset	array
)	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_addr	array
>=	O
phdr	pointer
->	O
p_vaddr	array
&&	O
(	O
hdr	pointer
->	O
sh_addr	array
+	O
hdr	pointer
->	O
sh_size	array
<=	O
phdr	pointer
->	O
p_vaddr	array
+	O
phdr	pointer
->	O
p_memsz	array
)	O
)	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
&&	O
(	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'd'	O
&&	O
name	pointer
[	O
6	int
]	O
==	O
'_'	O
)	O
||	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'z'	O
&&	O
name	pointer
[	O
7	int
]	O
==	O
'_'	O
)	O
)	O
)	O
{	O
enum	O
{	O
nothing	int
,	O
compress	int
,	O
decompress	int
}	O
action	enum
=	O
nothing	int
;	O
int	O
compression_header_size	int
;	O
bfd_size_type	long
uncompressed_size	pointer
;	O
unsigned	O
int	O
uncompressed_align_power	int
;	O
bfd_boolean	int
compressed	int
=	O
bfd_is_section_compressed_with_header	function
(	O
abfd	pointer
,	O
newsect	pointer
,	O
&	O
compression_header_size	int
,	O
&	O
uncompressed_size	pointer
,	O
&	O
uncompressed_align_power	int
)	O
;	O
if	O
(	O
compressed	int
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_DECOMPRESS	int
)	O
)	O
action	enum
=	O
decompress	int
;	O
}	O
if	O
(	O
action	enum
==	O
nothing	int
)	O
{	O
if	O
(	O
newsect	pointer
->	O
size	long
!=	O
0	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS	int
)	O
&&	O
compression_header_size	int
>=	O
0	int
&&	O
uncompressed_size	pointer
>	O
0	int
&&	O
(	O
!	O
compressed	int
||	O
(	O
(	O
compression_header_size	int
>	O
0	int
)	O
!=	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS_GABI	int
)	O
!=	O
0	int
)	O
)	O
)	O
)	O
action	enum
=	O
compress	int
;	O
else	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
action	enum
==	O
compress	int
)	O
{	O
if	O
(	O
!	O
bfd_init_section_compress_status	function
(	O
abfd	pointer
,	O
newsect	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to initialize compress status for section %s"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
bfd_init_section_decompress_status	function
(	O
abfd	pointer
,	O
newsect	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to initialize decompress status for section %s"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
abfd	pointer
->	O
is_linker_input	int
)	O
{	O
if	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'z'	O
&&	O
(	O
action	enum
==	O
decompress	int
||	O
(	O
action	enum
==	O
compress	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS_GABI	int
)	O
!=	O
0	int
)	O
)	O
)	O
{	O
char	O
*	O
new_name	pointer
=	O
convert_zdebug_to_debug	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
bfd_rename_section	function
(	O
newsect	pointer
,	O
new_name	pointer
)	O
;	O
}	O
}	O
else	O
newsect	pointer
->	O
flags	int
|=	O
SEC_ELF_RENAME	int
;	O
}	O
const	O
char	O
*	O
lto_section_name	pointer
=	O
".gnu.lto_.lto."	pointer
;	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
lto_section_name	pointer
,	O
strlen	function
(	O
lto_section_name	pointer
)	O
)	O
==	O
0	int
)	O
{	O
struct	O
lto_section	struct
lsection	struct
;	O
if	O
(	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
newsect	pointer
,	O
&	O
lsection	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
lto_section	struct
)	O
)	O
)	O
abfd	pointer
->	O
lto_slim_object	int
=	O
lsection	struct
.	O
slim_object	char
;	O
}	O
return	O
TRUE	int
;	O
}	O
const	O
char	O
*	O
const	O
bfd_elf_section_type_names	array
[	O
]	O
=	O
{	O
"SHT_NULL"	pointer
,	O
"SHT_PROGBITS"	pointer
,	O
"SHT_SYMTAB"	pointer
,	O
"SHT_STRTAB"	pointer
,	O
"SHT_RELA"	pointer
,	O
"SHT_HASH"	pointer
,	O
"SHT_DYNAMIC"	pointer
,	O
"SHT_NOTE"	pointer
,	O
"SHT_NOBITS"	pointer
,	O
"SHT_REL"	pointer
,	O
"SHT_SHLIB"	pointer
,	O
"SHT_DYNSYM"	pointer
,	O
}	O
;	O
bfd_reloc_status_type	enum
bfd_elf_generic_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
arelent	struct
*	O
reloc_entry	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
void	O
*	O
data	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd	struct
*	O
output_bfd	pointer
,	O
char	O
*	O
*	O
error_message	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
output_bfd	pointer
!=	O
NULL	O
&&	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
==	O
0	int
&&	O
(	O
!	O
reloc_entry	pointer
->	O
howto	pointer
->	O
partial_inplace	int
||	O
reloc_entry	pointer
->	O
addend	long
==	O
0	int
)	O
)	O
{	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
return	O
bfd_reloc_ok	int
;	O
}	O
return	O
bfd_reloc_continue	int
;	O
}	O
static	O
bfd_boolean	int
section_match	function
(	O
const	O
Elf_Internal_Shdr	struct
*	O
a	pointer
,	O
const	O
Elf_Internal_Shdr	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
a	pointer
->	O
sh_type	array
!=	O
b	pointer
->	O
sh_type	array
||	O
(	O
(	O
a	pointer
->	O
sh_flags	array
^	O
b	pointer
->	O
sh_flags	array
)	O
&	O
~	O
SHF_INFO_LINK	O
)	O
!=	O
0	int
||	O
a	pointer
->	O
sh_addralign	array
!=	O
b	pointer
->	O
sh_addralign	array
||	O
a	pointer
->	O
sh_entsize	array
!=	O
b	pointer
->	O
sh_entsize	array
)	O
return	O
FALSE	int
;	O
if	O
(	O
a	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
||	O
a	pointer
->	O
sh_type	array
==	O
SHT_STRTAB	int
)	O
return	O
TRUE	int
;	O
return	O
a	pointer
->	O
sh_size	array
==	O
b	pointer
->	O
sh_size	array
;	O
}	O
static	O
unsigned	O
int	O
find_link	function
(	O
const	O
bfd	struct
*	O
obfd	pointer
,	O
const	O
Elf_Internal_Shdr	struct
*	O
iheader	pointer
,	O
const	O
unsigned	O
int	O
hint	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
*	O
oheaders	pointer
=	O
elf_elfsections	O
(	O
obfd	pointer
)	O
;	O
unsigned	O
int	O
i	pointer
;	O
BFD_ASSERT	O
(	O
iheader	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
hint	int
<	O
elf_numsections	O
(	O
obfd	pointer
)	O
&&	O
oheaders	pointer
[	O
hint	int
]	O
!=	O
NULL	O
&&	O
section_match	function
(	O
oheaders	pointer
[	O
hint	int
]	O
,	O
iheader	pointer
)	O
)	O
return	O
hint	int
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
elf_numsections	O
(	O
obfd	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
oheader	pointer
=	O
oheaders	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
oheader	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
section_match	function
(	O
oheader	pointer
,	O
iheader	pointer
)	O
)	O
return	O
i	pointer
;	O
}	O
return	O
SHN_UNDEF	int
;	O
}	O
static	O
bfd_boolean	int
copy_special_section_fields	function
(	O
const	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
const	O
Elf_Internal_Shdr	struct
*	O
iheader	pointer
,	O
Elf_Internal_Shdr	struct
*	O
oheader	pointer
,	O
const	O
unsigned	O
int	O
secnum	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
;	O
const	O
Elf_Internal_Shdr	struct
*	O
*	O
iheaders	pointer
=	O
(	O
const	O
Elf_Internal_Shdr	struct
*	O
*	O
)	O
elf_elfsections	O
(	O
ibfd	pointer
)	O
;	O
bfd_boolean	int
changed	int
=	O
FALSE	int
;	O
unsigned	O
int	O
sh_link	array
;	O
if	O
(	O
oheader	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
{	O
if	O
(	O
oheader	pointer
->	O
sh_link	array
==	O
0	int
)	O
oheader	pointer
->	O
sh_link	array
=	O
iheader	pointer
->	O
sh_link	array
;	O
if	O
(	O
oheader	pointer
->	O
sh_info	array
==	O
0	int
)	O
oheader	pointer
->	O
sh_info	array
=	O
iheader	pointer
->	O
sh_info	array
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
bed	pointer
->	O
elf_backend_copy_special_section_fields	pointer
!=	O
NULL	O
&&	O
bed	pointer
->	O
elf_backend_copy_special_section_fields	pointer
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
iheader	pointer
,	O
oheader	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
iheader	pointer
->	O
sh_link	array
!=	O
SHN_UNDEF	int
)	O
{	O
if	O
(	O
iheader	pointer
->	O
sh_link	array
>=	O
elf_numsections	O
(	O
ibfd	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: invalid sh_link field (%d) in section number %d"	pointer
)	O
,	O
ibfd	pointer
,	O
iheader	pointer
->	O
sh_link	array
,	O
secnum	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
sh_link	array
=	O
find_link	function
(	O
obfd	pointer
,	O
iheaders	pointer
[	O
iheader	pointer
->	O
sh_link	array
]	O
,	O
iheader	pointer
->	O
sh_link	array
)	O
;	O
if	O
(	O
sh_link	array
!=	O
SHN_UNDEF	int
)	O
{	O
oheader	pointer
->	O
sh_link	array
=	O
sh_link	array
;	O
changed	int
=	O
TRUE	int
;	O
}	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: failed to find link section for section %d"	pointer
)	O
,	O
obfd	pointer
,	O
secnum	int
)	O
;	O
}	O
if	O
(	O
iheader	pointer
->	O
sh_info	array
)	O
{	O
if	O
(	O
iheader	pointer
->	O
sh_flags	array
&	O
SHF_INFO_LINK	O
)	O
{	O
sh_link	array
=	O
find_link	function
(	O
obfd	pointer
,	O
iheaders	pointer
[	O
iheader	pointer
->	O
sh_info	array
]	O
,	O
iheader	pointer
->	O
sh_info	array
)	O
;	O
if	O
(	O
sh_link	array
!=	O
SHN_UNDEF	int
)	O
oheader	pointer
->	O
sh_flags	array
|=	O
SHF_INFO_LINK	O
;	O
}	O
else	O
sh_link	array
=	O
iheader	pointer
->	O
sh_info	array
;	O
if	O
(	O
sh_link	array
!=	O
SHN_UNDEF	int
)	O
{	O
oheader	pointer
->	O
sh_info	array
=	O
sh_link	array
;	O
changed	int
=	O
TRUE	int
;	O
}	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: failed to find info section for section %d"	pointer
)	O
,	O
obfd	pointer
,	O
secnum	int
)	O
;	O
}	O
return	O
changed	int
;	O
}	O
bfd_boolean	int
_bfd_elf_copy_private_bfd_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
const	O
Elf_Internal_Shdr	struct
*	O
*	O
iheaders	pointer
=	O
(	O
const	O
Elf_Internal_Shdr	struct
*	O
*	O
)	O
elf_elfsections	O
(	O
ibfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
*	O
oheaders	pointer
=	O
elf_elfsections	O
(	O
obfd	pointer
)	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
elf_flags_init	O
(	O
obfd	pointer
)	O
)	O
{	O
elf_elfheader	O
(	O
obfd	pointer
)	O
->	O
e_flags	array
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_flags	array
;	O
elf_flags_init	O
(	O
obfd	pointer
)	O
=	O
TRUE	int
;	O
}	O
elf_gp	O
(	O
obfd	pointer
)	O
=	O
elf_gp	O
(	O
ibfd	pointer
)	O
;	O
elf_elfheader	O
(	O
obfd	pointer
)	O
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
;	O
if	O
(	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_ident	array
[	O
EI_ABIVERSION	int
]	O
)	O
elf_elfheader	O
(	O
obfd	pointer
)	O
->	O
e_ident	array
[	O
EI_ABIVERSION	int
]	O
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_ident	array
[	O
EI_ABIVERSION	int
]	O
;	O
_bfd_elf_copy_obj_attributes	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
;	O
if	O
(	O
iheaders	pointer
==	O
NULL	O
||	O
oheaders	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
elf_numsections	O
(	O
obfd	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
j	int
;	O
Elf_Internal_Shdr	struct
*	O
oheader	pointer
=	O
oheaders	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
oheader	pointer
==	O
NULL	O
||	O
(	O
oheader	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
&&	O
oheader	pointer
->	O
sh_type	array
<	O
SHT_LOOS	int
)	O
)	O
continue	O
;	O
if	O
(	O
oheader	pointer
->	O
sh_size	array
==	O
0	int
||	O
(	O
oheader	pointer
->	O
sh_info	array
!=	O
0	int
&&	O
oheader	pointer
->	O
sh_link	array
!=	O
0	int
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
elf_numsections	O
(	O
ibfd	pointer
)	O
;	O
j	int
++	O
)	O
{	O
const	O
Elf_Internal_Shdr	struct
*	O
iheader	pointer
=	O
iheaders	pointer
[	O
j	int
]	O
;	O
if	O
(	O
iheader	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
oheader	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
iheader	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
iheader	pointer
->	O
bfd_section	struct
->	O
output_section	pointer
!=	O
NULL	O
&&	O
iheader	pointer
->	O
bfd_section	struct
->	O
output_section	pointer
==	O
oheader	pointer
->	O
bfd_section	struct
)	O
{	O
if	O
(	O
!	O
copy_special_section_fields	function
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
iheader	pointer
,	O
oheader	pointer
,	O
i	pointer
)	O
)	O
j	int
=	O
elf_numsections	O
(	O
ibfd	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
j	int
<	O
elf_numsections	O
(	O
ibfd	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
elf_numsections	O
(	O
ibfd	pointer
)	O
;	O
j	int
++	O
)	O
{	O
const	O
Elf_Internal_Shdr	struct
*	O
iheader	pointer
=	O
iheaders	pointer
[	O
j	int
]	O
;	O
if	O
(	O
iheader	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
(	O
oheader	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
||	O
iheader	pointer
->	O
sh_type	array
==	O
oheader	pointer
->	O
sh_type	array
)	O
&&	O
(	O
iheader	pointer
->	O
sh_flags	array
&	O
~	O
SHF_INFO_LINK	O
)	O
==	O
(	O
oheader	pointer
->	O
sh_flags	array
&	O
~	O
SHF_INFO_LINK	O
)	O
&&	O
iheader	pointer
->	O
sh_addralign	array
==	O
oheader	pointer
->	O
sh_addralign	array
&&	O
iheader	pointer
->	O
sh_entsize	array
==	O
oheader	pointer
->	O
sh_entsize	array
&&	O
iheader	pointer
->	O
sh_size	array
==	O
oheader	pointer
->	O
sh_size	array
&&	O
iheader	pointer
->	O
sh_addr	array
==	O
oheader	pointer
->	O
sh_addr	array
&&	O
(	O
iheader	pointer
->	O
sh_info	array
!=	O
oheader	pointer
->	O
sh_info	array
||	O
iheader	pointer
->	O
sh_link	array
!=	O
oheader	pointer
->	O
sh_link	array
)	O
)	O
{	O
if	O
(	O
copy_special_section_fields	function
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
iheader	pointer
,	O
oheader	pointer
,	O
i	pointer
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
j	int
==	O
elf_numsections	O
(	O
ibfd	pointer
)	O
&&	O
oheader	pointer
->	O
sh_type	array
>=	O
SHT_LOOS	int
)	O
{	O
if	O
(	O
bed	pointer
->	O
elf_backend_copy_special_section_fields	pointer
!=	O
NULL	O
)	O
bed	pointer
->	O
elf_backend_copy_special_section_fields	pointer
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
NULL	O
,	O
oheader	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_segment_type	function
(	O
unsigned	O
int	O
p_type	array
)	O
{	O
const	O
char	O
*	O
pt	pointer
;	O
switch	O
(	O
p_type	array
)	O
{	O
case	O
PT_NULL	int
:	O
pt	pointer
=	O
"NULL"	pointer
;	O
break	O
;	O
case	O
PT_LOAD	int
:	O
pt	pointer
=	O
"LOAD"	pointer
;	O
break	O
;	O
case	O
PT_DYNAMIC	int
:	O
pt	pointer
=	O
"DYNAMIC"	pointer
;	O
break	O
;	O
case	O
PT_INTERP	int
:	O
pt	pointer
=	O
"INTERP"	pointer
;	O
break	O
;	O
case	O
PT_NOTE	int
:	O
pt	pointer
=	O
"NOTE"	pointer
;	O
break	O
;	O
case	O
PT_SHLIB	int
:	O
pt	pointer
=	O
"SHLIB"	pointer
;	O
break	O
;	O
case	O
PT_PHDR	int
:	O
pt	pointer
=	O
"PHDR"	pointer
;	O
break	O
;	O
case	O
PT_TLS	int
:	O
pt	pointer
=	O
"TLS"	pointer
;	O
break	O
;	O
case	O
PT_GNU_EH_FRAME	O
:	O
pt	pointer
=	O
"EH_FRAME"	pointer
;	O
break	O
;	O
case	O
PT_GNU_STACK	O
:	O
pt	pointer
=	O
"STACK"	pointer
;	O
break	O
;	O
case	O
PT_GNU_RELRO	O
:	O
pt	pointer
=	O
"RELRO"	pointer
;	O
break	O
;	O
default	O
:	O
pt	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
return	O
pt	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_print_private_bfd_data	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
farg	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
=	O
(	O
FILE	struct
*	O
)	O
farg	pointer
;	O
Elf_Internal_Phdr	struct
*	O
p	pointer
;	O
asection	struct
*	O
s	pointer
;	O
bfd_byte	char
*	O
dynbuf	pointer
=	O
NULL	O
;	O
p	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
i	pointer
,	O
c	struct
;	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"\nProgram Header:\n"	pointer
)	O
)	O
;	O
c	struct
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
c	struct
;	O
i	pointer
++	O
,	O
p	pointer
++	O
)	O
{	O
const	O
char	O
*	O
pt	pointer
=	O
get_segment_type	function
(	O
p	pointer
->	O
p_type	array
)	O
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
if	O
(	O
pt	pointer
==	O
NULL	O
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"0x%lx"	pointer
,	O
p	pointer
->	O
p_type	array
)	O
;	O
pt	pointer
=	O
buf	pointer
;	O
}	O
fprintf	function
(	O
f	pointer
,	O
"%8s off    0x"	pointer
,	O
pt	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
f	pointer
,	O
p	pointer
->	O
p_offset	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" vaddr 0x"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
f	pointer
,	O
p	pointer
->	O
p_vaddr	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" paddr 0x"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
f	pointer
,	O
p	pointer
->	O
p_paddr	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" align 2**%u\n"	pointer
,	O
bfd_log2	function
(	O
p	pointer
->	O
p_align	array
)	O
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"         filesz 0x"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
f	pointer
,	O
p	pointer
->	O
p_filesz	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" memsz 0x"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
f	pointer
,	O
p	pointer
->	O
p_memsz	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" flags %c%c%c"	pointer
,	O
(	O
p	pointer
->	O
p_flags	array
&	O
PF_R	O
)	O
!=	O
0	int
?	O
'r'	O
:	O
'-'	O
,	O
(	O
p	pointer
->	O
p_flags	array
&	O
PF_W	O
)	O
!=	O
0	int
?	O
'w'	O
:	O
'-'	O
,	O
(	O
p	pointer
->	O
p_flags	array
&	O
PF_X	O
)	O
!=	O
0	int
?	O
'x'	O
:	O
'-'	O
)	O
;	O
if	O
(	O
(	O
p	pointer
->	O
p_flags	array
&	O
~	O
(	O
unsigned	O
)	O
(	O
PF_R	O
|	O
PF_W	O
|	O
PF_X	O
)	O
)	O
!=	O
0	int
)	O
fprintf	function
(	O
f	pointer
,	O
" %lx"	pointer
,	O
p	pointer
->	O
p_flags	array
&	O
~	O
(	O
unsigned	O
)	O
(	O
PF_R	O
|	O
PF_W	O
|	O
PF_X	O
)	O
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
elfsec	int
;	O
unsigned	O
long	O
shlink	long
;	O
bfd_byte	char
*	O
extdyn	pointer
,	O
*	O
extdynend	pointer
;	O
size_t	long
extdynsize	long
;	O
void	O
(	O
*	O
swap_dyn_in	pointer
)	O
(	O
bfd	struct
*	O
,	O
const	O
void	O
*	O
,	O
Elf_Internal_Dyn	struct
*	O
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"\nDynamic Section:\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
s	pointer
,	O
&	O
dynbuf	pointer
)	O
)	O
goto	O
error_return	O
;	O
elfsec	int
=	O
_bfd_elf_section_from_bfd_section	function
(	O
abfd	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
elfsec	int
==	O
SHN_BAD	O
)	O
goto	O
error_return	O
;	O
shlink	long
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elfsec	int
]	O
->	O
sh_link	array
;	O
extdynsize	long
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
sizeof_dyn	char
;	O
swap_dyn_in	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
swap_dyn_in	pointer
;	O
extdyn	pointer
=	O
dynbuf	pointer
;	O
if	O
(	O
s	pointer
->	O
size	long
<	O
extdynsize	long
)	O
goto	O
error_return	O
;	O
extdynend	pointer
=	O
extdyn	pointer
+	O
s	pointer
->	O
size	long
;	O
for	O
(	O
;	O
extdyn	pointer
<=	O
(	O
extdynend	pointer
-	O
extdynsize	long
)	O
;	O
extdyn	pointer
+=	O
extdynsize	long
)	O
{	O
Elf_Internal_Dyn	struct
dyn	struct
;	O
const	O
char	O
*	O
name	pointer
=	O
""	pointer
;	O
char	O
ab	array
[	O
20	int
]	O
;	O
bfd_boolean	int
stringp	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
(	O
*	O
swap_dyn_in	pointer
)	O
(	O
abfd	pointer
,	O
extdyn	pointer
,	O
&	O
dyn	struct
)	O
;	O
if	O
(	O
dyn	struct
.	O
d_tag	array
==	O
DT_NULL	int
)	O
break	O
;	O
stringp	int
=	O
FALSE	int
;	O
switch	O
(	O
dyn	struct
.	O
d_tag	array
)	O
{	O
default	O
:	O
if	O
(	O
bed	pointer
->	O
elf_backend_get_target_dtag	pointer
)	O
name	pointer
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_get_target_dtag	pointer
)	O
(	O
dyn	struct
.	O
d_tag	array
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
name	pointer
,	O
""	pointer
)	O
)	O
{	O
sprintf	function
(	O
ab	array
,	O
"%#"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
dyn	struct
.	O
d_tag	array
)	O
;	O
name	pointer
=	O
ab	array
;	O
}	O
break	O
;	O
case	O
DT_NEEDED	int
:	O
name	pointer
=	O
"NEEDED"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_PLTRELSZ	int
:	O
name	pointer
=	O
"PLTRELSZ"	pointer
;	O
break	O
;	O
case	O
DT_PLTGOT	int
:	O
name	pointer
=	O
"PLTGOT"	pointer
;	O
break	O
;	O
case	O
DT_HASH	int
:	O
name	pointer
=	O
"HASH"	pointer
;	O
break	O
;	O
case	O
DT_STRTAB	int
:	O
name	pointer
=	O
"STRTAB"	pointer
;	O
break	O
;	O
case	O
DT_SYMTAB	int
:	O
name	pointer
=	O
"SYMTAB"	pointer
;	O
break	O
;	O
case	O
DT_RELA	int
:	O
name	pointer
=	O
"RELA"	pointer
;	O
break	O
;	O
case	O
DT_RELASZ	int
:	O
name	pointer
=	O
"RELASZ"	pointer
;	O
break	O
;	O
case	O
DT_RELAENT	int
:	O
name	pointer
=	O
"RELAENT"	pointer
;	O
break	O
;	O
case	O
DT_STRSZ	int
:	O
name	pointer
=	O
"STRSZ"	pointer
;	O
break	O
;	O
case	O
DT_SYMENT	int
:	O
name	pointer
=	O
"SYMENT"	pointer
;	O
break	O
;	O
case	O
DT_INIT	int
:	O
name	pointer
=	O
"INIT"	pointer
;	O
break	O
;	O
case	O
DT_FINI	int
:	O
name	pointer
=	O
"FINI"	pointer
;	O
break	O
;	O
case	O
DT_SONAME	int
:	O
name	pointer
=	O
"SONAME"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_RPATH	int
:	O
name	pointer
=	O
"RPATH"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_SYMBOLIC	int
:	O
name	pointer
=	O
"SYMBOLIC"	pointer
;	O
break	O
;	O
case	O
DT_REL	int
:	O
name	pointer
=	O
"REL"	pointer
;	O
break	O
;	O
case	O
DT_RELSZ	int
:	O
name	pointer
=	O
"RELSZ"	pointer
;	O
break	O
;	O
case	O
DT_RELENT	int
:	O
name	pointer
=	O
"RELENT"	pointer
;	O
break	O
;	O
case	O
DT_PLTREL	int
:	O
name	pointer
=	O
"PLTREL"	pointer
;	O
break	O
;	O
case	O
DT_DEBUG	int
:	O
name	pointer
=	O
"DEBUG"	pointer
;	O
break	O
;	O
case	O
DT_TEXTREL	int
:	O
name	pointer
=	O
"TEXTREL"	pointer
;	O
break	O
;	O
case	O
DT_JMPREL	int
:	O
name	pointer
=	O
"JMPREL"	pointer
;	O
break	O
;	O
case	O
DT_BIND_NOW	int
:	O
name	pointer
=	O
"BIND_NOW"	pointer
;	O
break	O
;	O
case	O
DT_INIT_ARRAY	int
:	O
name	pointer
=	O
"INIT_ARRAY"	pointer
;	O
break	O
;	O
case	O
DT_FINI_ARRAY	int
:	O
name	pointer
=	O
"FINI_ARRAY"	pointer
;	O
break	O
;	O
case	O
DT_INIT_ARRAYSZ	int
:	O
name	pointer
=	O
"INIT_ARRAYSZ"	pointer
;	O
break	O
;	O
case	O
DT_FINI_ARRAYSZ	int
:	O
name	pointer
=	O
"FINI_ARRAYSZ"	pointer
;	O
break	O
;	O
case	O
DT_RUNPATH	int
:	O
name	pointer
=	O
"RUNPATH"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_FLAGS	int
:	O
name	pointer
=	O
"FLAGS"	pointer
;	O
break	O
;	O
case	O
DT_PREINIT_ARRAY	int
:	O
name	pointer
=	O
"PREINIT_ARRAY"	pointer
;	O
break	O
;	O
case	O
DT_PREINIT_ARRAYSZ	int
:	O
name	pointer
=	O
"PREINIT_ARRAYSZ"	pointer
;	O
break	O
;	O
case	O
DT_CHECKSUM	int
:	O
name	pointer
=	O
"CHECKSUM"	pointer
;	O
break	O
;	O
case	O
DT_PLTPADSZ	int
:	O
name	pointer
=	O
"PLTPADSZ"	pointer
;	O
break	O
;	O
case	O
DT_MOVEENT	int
:	O
name	pointer
=	O
"MOVEENT"	pointer
;	O
break	O
;	O
case	O
DT_MOVESZ	int
:	O
name	pointer
=	O
"MOVESZ"	pointer
;	O
break	O
;	O
case	O
DT_FEATURE	int
:	O
name	pointer
=	O
"FEATURE"	pointer
;	O
break	O
;	O
case	O
DT_POSFLAG_1	int
:	O
name	pointer
=	O
"POSFLAG_1"	pointer
;	O
break	O
;	O
case	O
DT_SYMINSZ	int
:	O
name	pointer
=	O
"SYMINSZ"	pointer
;	O
break	O
;	O
case	O
DT_SYMINENT	int
:	O
name	pointer
=	O
"SYMINENT"	pointer
;	O
break	O
;	O
case	O
DT_CONFIG	int
:	O
name	pointer
=	O
"CONFIG"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_DEPAUDIT	int
:	O
name	pointer
=	O
"DEPAUDIT"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_AUDIT	int
:	O
name	pointer
=	O
"AUDIT"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_PLTPAD	int
:	O
name	pointer
=	O
"PLTPAD"	pointer
;	O
break	O
;	O
case	O
DT_MOVETAB	int
:	O
name	pointer
=	O
"MOVETAB"	pointer
;	O
break	O
;	O
case	O
DT_SYMINFO	int
:	O
name	pointer
=	O
"SYMINFO"	pointer
;	O
break	O
;	O
case	O
DT_RELACOUNT	int
:	O
name	pointer
=	O
"RELACOUNT"	pointer
;	O
break	O
;	O
case	O
DT_RELCOUNT	int
:	O
name	pointer
=	O
"RELCOUNT"	pointer
;	O
break	O
;	O
case	O
DT_FLAGS_1	int
:	O
name	pointer
=	O
"FLAGS_1"	pointer
;	O
break	O
;	O
case	O
DT_VERSYM	int
:	O
name	pointer
=	O
"VERSYM"	pointer
;	O
break	O
;	O
case	O
DT_VERDEF	int
:	O
name	pointer
=	O
"VERDEF"	pointer
;	O
break	O
;	O
case	O
DT_VERDEFNUM	int
:	O
name	pointer
=	O
"VERDEFNUM"	pointer
;	O
break	O
;	O
case	O
DT_VERNEED	int
:	O
name	pointer
=	O
"VERNEED"	pointer
;	O
break	O
;	O
case	O
DT_VERNEEDNUM	int
:	O
name	pointer
=	O
"VERNEEDNUM"	pointer
;	O
break	O
;	O
case	O
DT_AUXILIARY	int
:	O
name	pointer
=	O
"AUXILIARY"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_USED	int
:	O
name	pointer
=	O
"USED"	pointer
;	O
break	O
;	O
case	O
DT_FILTER	int
:	O
name	pointer
=	O
"FILTER"	pointer
;	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
DT_GNU_HASH	int
:	O
name	pointer
=	O
"GNU_HASH"	pointer
;	O
break	O
;	O
}	O
fprintf	function
(	O
f	pointer
,	O
"  %-20s "	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
stringp	int
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"0x"	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
f	pointer
,	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
)	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
string	pointer
;	O
unsigned	O
int	O
tagv	int
=	O
dyn	struct
.	O
d_un	union
.	O
d_val	array
;	O
string	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
shlink	long
,	O
tagv	int
)	O
;	O
if	O
(	O
string	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
fprintf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
string	pointer
)	O
;	O
}	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
free	function
(	O
dynbuf	pointer
)	O
;	O
dynbuf	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
elf_dynverdef	O
(	O
abfd	pointer
)	O
!=	O
0	int
&&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
==	O
NULL	O
)	O
||	O
(	O
elf_dynverref	O
(	O
abfd	pointer
)	O
!=	O
0	int
&&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
==	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_slurp_version_tables	function
(	O
abfd	pointer
,	O
FALSE	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
elf_dynverdef	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Verdef	struct
*	O
t	pointer
;	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"\nVersion definitions:\n"	pointer
)	O
)	O
;	O
for	O
(	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
vd_nextdef	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"%d 0x%2.2x 0x%8.8lx %s\n"	pointer
,	O
t	pointer
->	O
vd_ndx	array
,	O
t	pointer
->	O
vd_flags	array
,	O
t	pointer
->	O
vd_hash	array
,	O
t	pointer
->	O
vd_nodename	pointer
?	O
t	pointer
->	O
vd_nodename	pointer
:	O
"<corrupt>"	pointer
)	O
;	O
if	O
(	O
t	pointer
->	O
vd_auxptr	pointer
!=	O
NULL	O
&&	O
t	pointer
->	O
vd_auxptr	pointer
->	O
vda_nextptr	pointer
!=	O
NULL	O
)	O
{	O
Elf_Internal_Verdaux	struct
*	O
a	pointer
;	O
fprintf	function
(	O
f	pointer
,	O
"\t"	pointer
)	O
;	O
for	O
(	O
a	pointer
=	O
t	pointer
->	O
vd_auxptr	pointer
->	O
vda_nextptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vda_nextptr	pointer
)	O
fprintf	function
(	O
f	pointer
,	O
"%s "	pointer
,	O
a	pointer
->	O
vda_nodename	pointer
?	O
a	pointer
->	O
vda_nodename	pointer
:	O
"<corrupt>"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
elf_dynverref	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Verneed	struct
*	O
t	pointer
;	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"\nVersion References:\n"	pointer
)	O
)	O
;	O
for	O
(	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
vn_nextref	pointer
)	O
{	O
Elf_Internal_Vernaux	struct
*	O
a	pointer
;	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"  required from %s:\n"	pointer
)	O
,	O
t	pointer
->	O
vn_filename	pointer
?	O
t	pointer
->	O
vn_filename	pointer
:	O
"<corrupt>"	pointer
)	O
;	O
for	O
(	O
a	pointer
=	O
t	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
fprintf	function
(	O
f	pointer
,	O
"    0x%8.8lx 0x%2.2x %2.2d %s\n"	pointer
,	O
a	pointer
->	O
vna_hash	array
,	O
a	pointer
->	O
vna_flags	array
,	O
a	pointer
->	O
vna_other	array
,	O
a	pointer
->	O
vna_nodename	pointer
?	O
a	pointer
->	O
vna_nodename	pointer
:	O
"<corrupt>"	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
dynbuf	pointer
!=	O
NULL	O
)	O
free	function
(	O
dynbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
const	O
char	O
*	O
_bfd_elf_get_symbol_version_string	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
bfd_boolean	int
*	O
hidden	pointer
)	O
{	O
const	O
char	O
*	O
version_string	pointer
=	O
NULL	O
;	O
if	O
(	O
elf_dynversym	O
(	O
abfd	pointer
)	O
!=	O
0	int
&&	O
(	O
elf_dynverdef	O
(	O
abfd	pointer
)	O
!=	O
0	int
||	O
elf_dynverref	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
)	O
{	O
unsigned	O
int	O
vernum	int
=	O
(	O
(	O
elf_symbol_type	struct
*	O
)	O
symbol	pointer
)	O
->	O
version	short
;	O
*	O
hidden	pointer
=	O
(	O
vernum	int
&	O
VERSYM_HIDDEN	int
)	O
!=	O
0	int
;	O
vernum	int
&=	O
VERSYM_VERSION	int
;	O
if	O
(	O
vernum	int
==	O
0	int
)	O
version_string	pointer
=	O
""	pointer
;	O
else	O
if	O
(	O
vernum	int
==	O
1	int
&&	O
(	O
vernum	int
>	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
||	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
[	O
0	int
]	O
.	O
vd_flags	array
==	O
VER_FLG_BASE	int
)	O
)	O
)	O
version_string	pointer
=	O
"Base"	pointer
;	O
else	O
if	O
(	O
vernum	int
<=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
)	O
version_string	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
[	O
vernum	int
-	O
1	int
]	O
.	O
vd_nodename	pointer
;	O
else	O
{	O
Elf_Internal_Verneed	struct
*	O
t	pointer
;	O
version_string	pointer
=	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
for	O
(	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
vn_nextref	pointer
)	O
{	O
Elf_Internal_Vernaux	struct
*	O
a	pointer
;	O
for	O
(	O
a	pointer
=	O
t	pointer
->	O
vn_auxptr	pointer
;	O
a	pointer
!=	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
vna_nextptr	pointer
)	O
{	O
if	O
(	O
a	pointer
->	O
vna_other	array
==	O
vernum	int
)	O
{	O
version_string	pointer
=	O
a	pointer
->	O
vna_nodename	pointer
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
version_string	pointer
;	O
}	O
void	O
bfd_elf_print_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
filep	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
bfd_print_symbol_type	enum
how	enum
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
filep	pointer
;	O
switch	O
(	O
how	enum
)	O
{	O
case	O
bfd_print_symbol_name	int
:	O
fprintf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
bfd_print_symbol_more	int
:	O
fprintf	function
(	O
file	pointer
,	O
"elf "	pointer
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
symbol	pointer
->	O
value	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %x"	pointer
,	O
symbol	pointer
->	O
flags	int
)	O
;	O
break	O
;	O
case	O
bfd_print_symbol_all	int
:	O
{	O
const	O
char	O
*	O
section_name	pointer
;	O
const	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
char	O
st_other	array
;	O
bfd_vma	long
val	array
;	O
const	O
char	O
*	O
version_string	pointer
;	O
bfd_boolean	int
hidden	pointer
;	O
section_name	pointer
=	O
symbol	pointer
->	O
section	pointer
?	O
symbol	pointer
->	O
section	pointer
->	O
name	pointer
:	O
"(*none*)"	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_print_symbol_all	pointer
)	O
name	pointer
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_print_symbol_all	pointer
)	O
(	O
abfd	pointer
,	O
filep	pointer
,	O
symbol	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
name	pointer
=	O
symbol	pointer
->	O
name	pointer
;	O
bfd_print_symbol_vandf	function
(	O
abfd	pointer
,	O
file	pointer
,	O
symbol	pointer
)	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
" %s\t"	pointer
,	O
section_name	pointer
)	O
;	O
if	O
(	O
symbol	pointer
->	O
section	pointer
&&	O
bfd_is_com_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
val	array
=	O
(	O
(	O
elf_symbol_type	struct
*	O
)	O
symbol	pointer
)	O
->	O
internal_elf_sym	struct
.	O
st_value	array
;	O
else	O
val	array
=	O
(	O
(	O
elf_symbol_type	struct
*	O
)	O
symbol	pointer
)	O
->	O
internal_elf_sym	struct
.	O
st_size	long
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
val	array
)	O
;	O
version_string	pointer
=	O
_bfd_elf_get_symbol_version_string	function
(	O
abfd	pointer
,	O
symbol	pointer
,	O
&	O
hidden	pointer
)	O
;	O
if	O
(	O
version_string	pointer
)	O
{	O
if	O
(	O
!	O
hidden	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
"  %-11s"	pointer
,	O
version_string	pointer
)	O
;	O
else	O
{	O
int	O
i	pointer
;	O
fprintf	function
(	O
file	pointer
,	O
" (%s)"	pointer
,	O
version_string	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
10	int
-	O
strlen	function
(	O
version_string	pointer
)	O
;	O
i	pointer
>	O
0	int
;	O
--	O
i	pointer
)	O
putc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
}	O
}	O
st_other	array
=	O
(	O
(	O
elf_symbol_type	struct
*	O
)	O
symbol	pointer
)	O
->	O
internal_elf_sym	struct
.	O
st_other	array
;	O
switch	O
(	O
st_other	array
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
STV_INTERNAL	int
:	O
fprintf	function
(	O
file	pointer
,	O
" .internal"	pointer
)	O
;	O
break	O
;	O
case	O
STV_HIDDEN	int
:	O
fprintf	function
(	O
file	pointer
,	O
" .hidden"	pointer
)	O
;	O
break	O
;	O
case	O
STV_PROTECTED	int
:	O
fprintf	function
(	O
file	pointer
,	O
" .protected"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
file	pointer
,	O
" 0x%02x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
st_other	array
)	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
" %s"	pointer
,	O
name	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
bfd_boolean	int
bfd_section_from_shdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
shindex	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
Elf_Internal_Ehdr	struct
*	O
ehdr	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd_boolean	int
ret	pointer
=	O
TRUE	int
;	O
static	O
bfd_boolean	int
*	O
sections_being_created	pointer
=	O
NULL	O
;	O
static	O
bfd	struct
*	O
sections_being_created_abfd	pointer
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
nesting	int
=	O
0	int
;	O
if	O
(	O
shindex	int
>=	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
++	O
nesting	int
>	O
3	int
)	O
{	O
if	O
(	O
sections_being_created_abfd	pointer
!=	O
abfd	pointer
)	O
sections_being_created	pointer
=	O
NULL	O
;	O
if	O
(	O
sections_being_created	pointer
==	O
NULL	O
)	O
{	O
sections_being_created	pointer
=	O
(	O
bfd_boolean	int
*	O
)	O
bfd_zalloc2	function
(	O
abfd	pointer
,	O
elf_numsections	O
(	O
abfd	pointer
)	O
,	O
sizeof	O
(	O
bfd_boolean	int
)	O
)	O
;	O
sections_being_created_abfd	pointer
=	O
abfd	pointer
;	O
}	O
if	O
(	O
sections_being_created	pointer
[	O
shindex	int
]	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: loop in section dependencies detected"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
sections_being_created	pointer
[	O
shindex	int
]	O
=	O
TRUE	int
;	O
}	O
hdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
;	O
ehdr	pointer
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
;	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
ehdr	pointer
->	O
e_shstrndx	array
,	O
hdr	pointer
->	O
sh_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
goto	O
fail	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
switch	O
(	O
hdr	pointer
->	O
sh_type	array
)	O
{	O
case	O
SHT_NULL	int
:	O
goto	O
success	O
;	O
case	O
SHT_PROGBITS	int
:	O
case	O
SHT_NOBITS	int
:	O
case	O
SHT_HASH	int
:	O
case	O
SHT_NOTE	int
:	O
case	O
SHT_INIT_ARRAY	int
:	O
case	O
SHT_FINI_ARRAY	int
:	O
case	O
SHT_PREINIT_ARRAY	int
:	O
case	O
SHT_GNU_LIBLIST	int
:	O
case	O
SHT_GNU_HASH	int
:	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
case	O
SHT_DYNAMIC	int
:	O
if	O
(	O
!	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_link	array
>	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
{	O
switch	O
(	O
bfd_get_arch	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_arch_i386	int
:	O
case	O
bfd_arch_sparc	int
:	O
if	O
(	O
hdr	pointer
->	O
sh_link	array
==	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
||	O
hdr	pointer
->	O
sh_link	array
==	O
(	O
(	O
SHN_LORESERVE	O
+	O
1	int
)	O
&	O
0xffff	int
)	O
)	O
break	O
;	O
default	O
:	O
goto	O
fail	O
;	O
}	O
}	O
else	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_link	array
]	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
else	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_link	array
]	O
->	O
sh_type	array
!=	O
SHT_STRTAB	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
dynsymhdr	pointer
;	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
dynsymhdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
]	O
;	O
hdr	pointer
->	O
sh_link	array
=	O
dynsymhdr	pointer
->	O
sh_link	array
;	O
}	O
else	O
{	O
unsigned	O
int	O
i	pointer
,	O
num_sec	int
;	O
num_sec	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
num_sec	int
;	O
i	pointer
++	O
)	O
{	O
dynsymhdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
dynsymhdr	pointer
->	O
sh_type	array
==	O
SHT_DYNSYM	int
)	O
{	O
hdr	pointer
->	O
sh_link	array
=	O
dynsymhdr	pointer
->	O
sh_link	array
;	O
break	O
;	O
}	O
}	O
}	O
}	O
goto	O
success	O
;	O
case	O
SHT_SYMTAB	int
:	O
if	O
(	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
==	O
shindex	int
)	O
goto	O
success	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_entsize	array
!=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
goto	O
fail	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_info	array
*	O
hdr	pointer
->	O
sh_entsize	array
>	O
hdr	pointer
->	O
sh_size	array
)	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
goto	O
fail	O
;	O
hdr	pointer
->	O
sh_info	array
=	O
0	int
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: multiple symbol tables detected"	pointer
" - ignoring the table in section %u"	pointer
)	O
,	O
abfd	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
=	O
shindex	int
;	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
=	O
*	O
hdr	pointer
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
hdr	pointer
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
;	O
abfd	pointer
->	O
flags	int
|=	O
HAS_SYMS	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
&&	O
!	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
)	O
goto	O
fail	O
;	O
{	O
elf_section_list	struct
*	O
entry	pointer
;	O
unsigned	O
int	O
i	pointer
,	O
num_sec	int
;	O
for	O
(	O
entry	pointer
=	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
;	O
entry	pointer
!=	O
NULL	O
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
if	O
(	O
entry	pointer
->	O
hdr	pointer
.	O
sh_link	array
==	O
shindex	int
)	O
goto	O
success	O
;	O
num_sec	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
shindex	int
+	O
1	int
;	O
i	pointer
<	O
num_sec	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr2	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
hdr2	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB_SHNDX	int
&&	O
hdr2	pointer
->	O
sh_link	array
==	O
shindex	int
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
==	O
num_sec	int
)	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
shindex	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr2	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
hdr2	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB_SHNDX	int
&&	O
hdr2	pointer
->	O
sh_link	array
==	O
shindex	int
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
!=	O
shindex	int
)	O
ret	pointer
=	O
bfd_section_from_shdr	function
(	O
abfd	pointer
,	O
i	pointer
)	O
;	O
goto	O
success	O
;	O
}	O
case	O
SHT_DYNSYM	int
:	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
shindex	int
)	O
goto	O
success	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_entsize	array
!=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
goto	O
fail	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_info	array
*	O
hdr	pointer
->	O
sh_entsize	array
>	O
hdr	pointer
->	O
sh_size	array
)	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
goto	O
fail	O
;	O
hdr	pointer
->	O
sh_info	array
=	O
0	int
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: multiple dynamic symbol tables detected"	pointer
" - ignoring the table in section %u"	pointer
)	O
,	O
abfd	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
=	O
shindex	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynsymtab_hdr	struct
=	O
*	O
hdr	pointer
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynsymtab_hdr	struct
;	O
abfd	pointer
->	O
flags	int
|=	O
HAS_SYMS	int
;	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
case	O
SHT_SYMTAB_SHNDX	int
:	O
{	O
elf_section_list	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
;	O
entry	pointer
!=	O
NULL	O
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
if	O
(	O
entry	pointer
->	O
ndx	int
==	O
shindex	int
)	O
goto	O
success	O
;	O
entry	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
entry	pointer
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
goto	O
fail	O
;	O
entry	pointer
->	O
ndx	int
=	O
shindex	int
;	O
entry	pointer
->	O
hdr	pointer
=	O
*	O
hdr	pointer
;	O
entry	pointer
->	O
next	pointer
=	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
;	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
=	O
entry	pointer
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
&	O
entry	pointer
->	O
hdr	pointer
;	O
goto	O
success	O
;	O
}	O
case	O
SHT_STRTAB	int
:	O
if	O
(	O
hdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
goto	O
success	O
;	O
if	O
(	O
ehdr	pointer
->	O
e_shstrndx	array
==	O
shindex	int
)	O
{	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
shstrtab_hdr	struct
=	O
*	O
hdr	pointer
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
shstrtab_hdr	struct
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
]	O
->	O
sh_link	array
==	O
shindex	int
)	O
{	O
symtab_strtab	O
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
=	O
*	O
hdr	pointer
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
]	O
->	O
sh_link	array
==	O
shindex	int
)	O
{	O
dynsymtab_strtab	O
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynstrtab_hdr	struct
=	O
*	O
hdr	pointer
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynstrtab_hdr	struct
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
hdr	pointer
;	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
||	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
,	O
num_sec	int
;	O
num_sec	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
num_sec	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr2	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
i	pointer
]	O
;	O
if	O
(	O
hdr2	pointer
->	O
sh_link	array
==	O
shindex	int
)	O
{	O
if	O
(	O
i	pointer
==	O
shindex	int
)	O
goto	O
fail	O
;	O
if	O
(	O
!	O
bfd_section_from_shdr	function
(	O
abfd	pointer
,	O
i	pointer
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
==	O
i	pointer
)	O
goto	O
symtab_strtab	O
;	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
i	pointer
)	O
goto	O
dynsymtab_strtab	O
;	O
}	O
}	O
}	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
case	O
SHT_REL	int
:	O
case	O
SHT_RELA	int
:	O
{	O
asection	struct
*	O
target_sect	pointer
;	O
Elf_Internal_Shdr	struct
*	O
hdr2	pointer
,	O
*	O
*	O
p_hdr	pointer
;	O
unsigned	O
int	O
num_sec	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
struct	O
bfd_elf_section_data	struct
*	O
esdt	pointer
;	O
if	O
(	O
hdr	pointer
->	O
sh_entsize	array
!=	O
(	O
bfd_size_type	long
)	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_REL	int
?	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
:	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_link	array
>=	O
num_sec	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: invalid link %u for reloc section %s (index %u)"	pointer
)	O
,	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
name	pointer
,	O
shindex	int
)	O
;	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
)	O
)	O
==	O
0	int
&&	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_link	array
]	O
->	O
sh_type	array
!=	O
SHT_SYMTAB	int
&&	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_link	array
]	O
->	O
sh_type	array
!=	O
SHT_DYNSYM	int
)	O
{	O
unsigned	O
int	O
scan	pointer
;	O
int	O
found	int
;	O
found	int
=	O
0	int
;	O
for	O
(	O
scan	pointer
=	O
1	int
;	O
scan	pointer
<	O
num_sec	int
;	O
scan	pointer
++	O
)	O
{	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
scan	pointer
]	O
->	O
sh_type	array
==	O
SHT_SYMTAB	int
||	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
scan	pointer
]	O
->	O
sh_type	array
==	O
SHT_DYNSYM	int
)	O
{	O
if	O
(	O
found	int
!=	O
0	int
)	O
{	O
found	int
=	O
0	int
;	O
break	O
;	O
}	O
found	int
=	O
scan	pointer
;	O
}	O
}	O
if	O
(	O
found	int
!=	O
0	int
)	O
hdr	pointer
->	O
sh_link	array
=	O
found	int
;	O
}	O
if	O
(	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_link	array
]	O
->	O
sh_type	array
==	O
SHT_SYMTAB	int
||	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_link	array
]	O
->	O
sh_type	array
==	O
SHT_DYNSYM	int
)	O
&&	O
!	O
bfd_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
)	O
)	O
!=	O
0	int
&&	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
||	O
hdr	pointer
->	O
sh_link	array
==	O
SHN_UNDEF	int
||	O
hdr	pointer
->	O
sh_link	array
!=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
||	O
hdr	pointer
->	O
sh_info	array
==	O
SHN_UNDEF	int
||	O
hdr	pointer
->	O
sh_info	array
>=	O
num_sec	int
||	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_info	array
]	O
->	O
sh_type	array
==	O
SHT_REL	int
||	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
hdr	pointer
->	O
sh_info	array
]	O
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
{	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
!	O
bfd_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_info	array
)	O
)	O
goto	O
fail	O
;	O
target_sect	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_info	array
)	O
;	O
if	O
(	O
target_sect	pointer
==	O
NULL	O
)	O
goto	O
fail	O
;	O
esdt	pointer
=	O
elf_section_data	O
(	O
target_sect	pointer
)	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
p_hdr	pointer
=	O
&	O
esdt	pointer
->	O
rela	struct
.	O
hdr	pointer
;	O
else	O
p_hdr	pointer
=	O
&	O
esdt	pointer
->	O
rel	pointer
.	O
hdr	pointer
;	O
if	O
(	O
*	O
p_hdr	pointer
!=	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: multiple relocation sections for section %pA found - ignoring all but the first"	pointer
)	O
,	O
abfd	pointer
,	O
target_sect	pointer
)	O
;	O
goto	O
success	O
;	O
}	O
hdr2	pointer
=	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
hdr2	pointer
)	O
)	O
;	O
if	O
(	O
hdr2	pointer
==	O
NULL	O
)	O
goto	O
fail	O
;	O
*	O
hdr2	pointer
=	O
*	O
hdr	pointer
;	O
*	O
p_hdr	pointer
=	O
hdr2	pointer
;	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
shindex	int
]	O
=	O
hdr2	pointer
;	O
target_sect	pointer
->	O
reloc_count	int
+=	O
(	O
NUM_SHDR_ENTRIES	O
(	O
hdr	pointer
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
;	O
target_sect	pointer
->	O
flags	int
|=	O
SEC_RELOC	int
;	O
target_sect	pointer
->	O
relocation	pointer
=	O
NULL	O
;	O
target_sect	pointer
->	O
rel_filepos	long
=	O
hdr	pointer
->	O
sh_offset	array
;	O
if	O
(	O
hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
target_sect	pointer
->	O
use_rela_p	int
=	O
1	int
;	O
}	O
abfd	pointer
->	O
flags	int
|=	O
HAS_RELOC	int
;	O
goto	O
success	O
;	O
}	O
case	O
SHT_GNU_verdef	O
:	O
elf_dynverdef	O
(	O
abfd	pointer
)	O
=	O
shindex	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynverdef_hdr	struct
=	O
*	O
hdr	pointer
;	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
case	O
SHT_GNU_versym	O
:	O
if	O
(	O
hdr	pointer
->	O
sh_entsize	array
!=	O
sizeof	O
(	O
Elf_External_Versym	struct
)	O
)	O
goto	O
fail	O
;	O
elf_dynversym	O
(	O
abfd	pointer
)	O
=	O
shindex	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynversym_hdr	struct
=	O
*	O
hdr	pointer
;	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
case	O
SHT_GNU_verneed	O
:	O
elf_dynverref	O
(	O
abfd	pointer
)	O
=	O
shindex	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynverref_hdr	struct
=	O
*	O
hdr	pointer
;	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
case	O
SHT_SHLIB	int
:	O
goto	O
success	O
;	O
case	O
SHT_GROUP	int
:	O
if	O
(	O
!	O
IS_VALID_GROUP_SECTION_HEADER	O
(	O
hdr	pointer
,	O
GRP_ENTRY_SIZE	int
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
!	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
)	O
goto	O
fail	O
;	O
goto	O
success	O
;	O
default	O
:	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_GNU_ATTRIBUTES	int
||	O
hdr	pointer
->	O
sh_type	array
==	O
bed	pointer
->	O
obj_attrs_section_type	int
)	O
{	O
if	O
(	O
!	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
)	O
goto	O
fail	O
;	O
_bfd_elf_parse_attributes	function
(	O
abfd	pointer
,	O
hdr	pointer
)	O
;	O
goto	O
success	O
;	O
}	O
if	O
(	O
bed	pointer
->	O
elf_backend_section_from_shdr	pointer
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
)	O
goto	O
success	O
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
>=	O
SHT_LOUSER	int
&&	O
hdr	pointer
->	O
sh_type	array
<=	O
SHT_HIUSER	int
)	O
{	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unknown type [%#x] section `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_type	array
,	O
name	pointer
)	O
;	O
else	O
{	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
}	O
else	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
>=	O
SHT_LOPROC	int
&&	O
hdr	pointer
->	O
sh_type	array
<=	O
SHT_HIPROC	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unknown type [%#x] section `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_type	array
,	O
name	pointer
)	O
;	O
else	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
>=	O
SHT_LOOS	int
&&	O
hdr	pointer
->	O
sh_type	array
<=	O
SHT_HIOS	int
)	O
{	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_OS_NONCONFORMING	O
)	O
!=	O
0	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unknown type [%#x] section `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_type	array
,	O
name	pointer
)	O
;	O
else	O
{	O
ret	pointer
=	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
;	O
goto	O
success	O
;	O
}	O
}	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unknown type [%#x] section `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_type	array
,	O
name	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
fail	O
:	O
ret	pointer
=	O
FALSE	int
;	O
success	O
:	O
if	O
(	O
sections_being_created	pointer
&&	O
sections_being_created_abfd	pointer
==	O
abfd	pointer
)	O
sections_being_created	pointer
[	O
shindex	int
]	O
=	O
FALSE	int
;	O
if	O
(	O
--	O
nesting	int
==	O
0	int
)	O
{	O
sections_being_created	pointer
=	O
NULL	O
;	O
sections_being_created_abfd	pointer
=	O
abfd	pointer
;	O
}	O
return	O
ret	pointer
;	O
}	O
Elf_Internal_Sym	struct
*	O
bfd_sym_from_r_symndx	function
(	O
struct	O
sym_cache	struct
*	O
cache	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
long	O
r_symndx	long
)	O
{	O
unsigned	O
int	O
ent	int
=	O
r_symndx	long
%	O
LOCAL_SYM_CACHE_SIZE	int
;	O
if	O
(	O
cache	pointer
->	O
abfd	pointer
!=	O
abfd	pointer
||	O
cache	pointer
->	O
indx	long
[	O
ent	int
]	O
!=	O
r_symndx	long
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
unsigned	O
char	O
esym	pointer
[	O
sizeof	O
(	O
Elf64_External_Sym	struct
)	O
]	O
;	O
Elf_External_Sym_Shndx	struct
eshndx	struct
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
if	O
(	O
bfd_elf_get_elf_syms	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
1	int
,	O
r_symndx	long
,	O
&	O
cache	pointer
->	O
sym	pointer
[	O
ent	int
]	O
,	O
esym	pointer
,	O
&	O
eshndx	struct
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
cache	pointer
->	O
abfd	pointer
!=	O
abfd	pointer
)	O
{	O
memset	function
(	O
cache	pointer
->	O
indx	long
,	O
-	O
1	int
,	O
sizeof	O
(	O
cache	pointer
->	O
indx	long
)	O
)	O
;	O
cache	pointer
->	O
abfd	pointer
=	O
abfd	pointer
;	O
}	O
cache	pointer
->	O
indx	long
[	O
ent	int
]	O
=	O
r_symndx	long
;	O
}	O
return	O
&	O
cache	pointer
->	O
sym	pointer
[	O
ent	int
]	O
;	O
}	O
asection	struct
*	O
bfd_section_from_elf_index	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
sec_index	int
)	O
{	O
if	O
(	O
sec_index	int
>=	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
return	O
NULL	O
;	O
return	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
sec_index	int
]	O
->	O
bfd_section	struct
;	O
}	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_b	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".bss"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_NOBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_c	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".comment"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".ctf"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_d	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".data"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".data1"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".debug"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".debug_line"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".debug_info"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".debug_abbrev"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".debug_aranges"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".dynamic"	pointer
)	O
,	O
0	int
,	O
SHT_DYNAMIC	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".dynstr"	pointer
)	O
,	O
0	int
,	O
SHT_STRTAB	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".dynsym"	pointer
)	O
,	O
0	int
,	O
SHT_DYNSYM	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_f	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".fini"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_EXECINSTR	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".fini_array"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_FINI_ARRAY	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_g	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.linkonce.b"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_NOBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.lto_"	pointer
)	O
,	O
-	O
1	int
,	O
SHT_PROGBITS	int
,	O
SHF_EXCLUDE	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".got"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.version"	pointer
)	O
,	O
0	int
,	O
SHT_GNU_versym	O
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.version_d"	pointer
)	O
,	O
0	int
,	O
SHT_GNU_verdef	O
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.version_r"	pointer
)	O
,	O
0	int
,	O
SHT_GNU_verneed	O
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.liblist"	pointer
)	O
,	O
0	int
,	O
SHT_GNU_LIBLIST	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.conflict"	pointer
)	O
,	O
0	int
,	O
SHT_RELA	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.hash"	pointer
)	O
,	O
0	int
,	O
SHT_GNU_HASH	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_h	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".hash"	pointer
)	O
,	O
0	int
,	O
SHT_HASH	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_i	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".init"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_EXECINSTR	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".init_array"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_INIT_ARRAY	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".interp"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_l	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".line"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_n	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".note.GNU-stack"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".note"	pointer
)	O
,	O
-	O
1	int
,	O
SHT_NOTE	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_p	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".preinit_array"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PREINIT_ARRAY	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".plt"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_EXECINSTR	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_r	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".rodata"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".rodata1"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".rela"	pointer
)	O
,	O
-	O
1	int
,	O
SHT_RELA	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".rel"	pointer
)	O
,	O
-	O
1	int
,	O
SHT_REL	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_s	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".shstrtab"	pointer
)	O
,	O
0	int
,	O
SHT_STRTAB	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".strtab"	pointer
)	O
,	O
0	int
,	O
SHT_STRTAB	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".symtab"	pointer
)	O
,	O
0	int
,	O
SHT_SYMTAB	int
,	O
0	int
}	O
,	O
{	O
".stabstr"	pointer
,	O
5	int
,	O
3	int
,	O
SHT_STRTAB	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_t	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".text"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_EXECINSTR	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".tbss"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_NOBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
+	O
SHF_TLS	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".tdata"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
+	O
SHF_TLS	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
special_sections_z	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".zdebug_line"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".zdebug_info"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".zdebug_abbrev"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".zdebug_aranges"	pointer
)	O
,	O
0	int
,	O
SHT_PROGBITS	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
*	O
const	O
special_sections	pointer
[	O
]	O
=	O
{	O
special_sections_b	array
,	O
special_sections_c	array
,	O
special_sections_d	array
,	O
NULL	O
,	O
special_sections_f	array
,	O
special_sections_g	array
,	O
special_sections_h	array
,	O
special_sections_i	array
,	O
NULL	O
,	O
NULL	O
,	O
special_sections_l	array
,	O
NULL	O
,	O
special_sections_n	array
,	O
NULL	O
,	O
special_sections_p	array
,	O
NULL	O
,	O
special_sections_r	array
,	O
special_sections_s	array
,	O
special_sections_t	array
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
special_sections_z	array
}	O
;	O
const	O
struct	O
bfd_elf_special_section	struct
*	O
_bfd_elf_get_special_section	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
struct	O
bfd_elf_special_section	struct
*	O
spec	pointer
,	O
unsigned	O
int	O
rela	struct
)	O
{	O
int	O
i	pointer
;	O
int	O
len	long
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
spec	pointer
[	O
i	pointer
]	O
.	O
prefix	pointer
!=	O
NULL	O
;	O
i	pointer
++	O
)	O
{	O
int	O
suffix_len	int
;	O
int	O
prefix_len	int
=	O
spec	pointer
[	O
i	pointer
]	O
.	O
prefix_length	int
;	O
if	O
(	O
len	long
<	O
prefix_len	int
)	O
continue	O
;	O
if	O
(	O
memcmp	function
(	O
name	pointer
,	O
spec	pointer
[	O
i	pointer
]	O
.	O
prefix	pointer
,	O
prefix_len	int
)	O
!=	O
0	int
)	O
continue	O
;	O
suffix_len	int
=	O
spec	pointer
[	O
i	pointer
]	O
.	O
suffix_length	int
;	O
if	O
(	O
suffix_len	int
<=	O
0	int
)	O
{	O
if	O
(	O
name	pointer
[	O
prefix_len	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
suffix_len	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
name	pointer
[	O
prefix_len	int
]	O
!=	O
'.'	O
&&	O
(	O
suffix_len	int
==	O
-	O
2	int
||	O
(	O
rela	struct
&&	O
spec	pointer
[	O
i	pointer
]	O
.	O
type	enum
==	O
SHT_REL	int
)	O
)	O
)	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
len	long
<	O
prefix_len	int
+	O
suffix_len	int
)	O
continue	O
;	O
if	O
(	O
memcmp	function
(	O
name	pointer
+	O
len	long
-	O
suffix_len	int
,	O
spec	pointer
[	O
i	pointer
]	O
.	O
prefix	pointer
+	O
prefix_len	int
,	O
suffix_len	int
)	O
!=	O
0	int
)	O
continue	O
;	O
}	O
return	O
&	O
spec	pointer
[	O
i	pointer
]	O
;	O
}	O
return	O
NULL	O
;	O
}	O
const	O
struct	O
bfd_elf_special_section	struct
*	O
_bfd_elf_get_sec_type_attr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
int	O
i	pointer
;	O
const	O
struct	O
bfd_elf_special_section	struct
*	O
spec	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
if	O
(	O
sec	pointer
->	O
name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
spec	pointer
=	O
bed	pointer
->	O
special_sections	pointer
;	O
if	O
(	O
spec	pointer
)	O
{	O
spec	pointer
=	O
_bfd_elf_get_special_section	function
(	O
sec	pointer
->	O
name	pointer
,	O
bed	pointer
->	O
special_sections	pointer
,	O
sec	pointer
->	O
use_rela_p	int
)	O
;	O
if	O
(	O
spec	pointer
!=	O
NULL	O
)	O
return	O
spec	pointer
;	O
}	O
if	O
(	O
sec	pointer
->	O
name	pointer
[	O
0	int
]	O
!=	O
'.'	O
)	O
return	O
NULL	O
;	O
i	pointer
=	O
sec	pointer
->	O
name	pointer
[	O
1	int
]	O
-	O
'b'	O
;	O
if	O
(	O
i	pointer
<	O
0	int
||	O
i	pointer
>	O
'z'	O
-	O
'b'	O
)	O
return	O
NULL	O
;	O
spec	pointer
=	O
special_sections	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
spec	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
_bfd_elf_get_special_section	function
(	O
sec	pointer
->	O
name	pointer
,	O
spec	pointer
,	O
sec	pointer
->	O
use_rela_p	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_new_section_hook	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
sdata	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
const	O
struct	O
bfd_elf_special_section	struct
*	O
ssect	pointer
;	O
sdata	pointer
=	O
(	O
struct	O
bfd_elf_section_data	struct
*	O
)	O
sec	pointer
->	O
used_by_bfd	pointer
;	O
if	O
(	O
sdata	pointer
==	O
NULL	O
)	O
{	O
sdata	pointer
=	O
(	O
struct	O
bfd_elf_section_data	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
sdata	pointer
)	O
)	O
;	O
if	O
(	O
sdata	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sec	pointer
->	O
used_by_bfd	pointer
=	O
sdata	pointer
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
sec	pointer
->	O
use_rela_p	int
=	O
bed	pointer
->	O
default_use_rela_p	int
;	O
if	O
(	O
abfd	pointer
->	O
direction	enum
!=	O
read_direction	int
||	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
)	O
{	O
ssect	pointer
=	O
(	O
*	O
bed	pointer
->	O
get_sec_type_attr	pointer
)	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
ssect	pointer
!=	O
NULL	O
&&	O
(	O
!	O
sec	pointer
->	O
flags	int
||	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
||	O
ssect	pointer
->	O
type	enum
==	O
SHT_INIT_ARRAY	int
||	O
ssect	pointer
->	O
type	enum
==	O
SHT_FINI_ARRAY	int
)	O
)	O
{	O
elf_section_type	O
(	O
sec	pointer
)	O
=	O
ssect	pointer
->	O
type	enum
;	O
elf_section_flags	O
(	O
sec	pointer
)	O
=	O
ssect	pointer
->	O
attr	long
;	O
}	O
}	O
return	O
_bfd_generic_new_section_hook	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_make_section_from_phdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Phdr	struct
*	O
hdr	pointer
,	O
int	O
hdr_index	int
,	O
const	O
char	O
*	O
type_name	pointer
)	O
{	O
asection	struct
*	O
newsect	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
namebuf	array
[	O
64	int
]	O
;	O
size_t	long
len	long
;	O
int	O
split	int
;	O
split	int
=	O
(	O
(	O
hdr	pointer
->	O
p_memsz	array
>	O
0	int
)	O
&&	O
(	O
hdr	pointer
->	O
p_filesz	array
>	O
0	int
)	O
&&	O
(	O
hdr	pointer
->	O
p_memsz	array
>	O
hdr	pointer
->	O
p_filesz	array
)	O
)	O
;	O
if	O
(	O
hdr	pointer
->	O
p_filesz	array
>	O
0	int
)	O
{	O
sprintf	function
(	O
namebuf	array
,	O
"%s%d%s"	pointer
,	O
type_name	pointer
,	O
hdr_index	int
,	O
split	int
?	O
"a"	pointer
:	O
""	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
namebuf	array
)	O
+	O
1	int
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
name	pointer
,	O
namebuf	array
,	O
len	long
)	O
;	O
newsect	pointer
=	O
bfd_make_section	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
newsect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
newsect	pointer
->	O
vma	long
=	O
hdr	pointer
->	O
p_vaddr	array
;	O
newsect	pointer
->	O
lma	long
=	O
hdr	pointer
->	O
p_paddr	array
;	O
newsect	pointer
->	O
size	long
=	O
hdr	pointer
->	O
p_filesz	array
;	O
newsect	pointer
->	O
filepos	long
=	O
hdr	pointer
->	O
p_offset	array
;	O
newsect	pointer
->	O
flags	int
|=	O
SEC_HAS_CONTENTS	int
;	O
newsect	pointer
->	O
alignment_power	int
=	O
bfd_log2	function
(	O
hdr	pointer
->	O
p_align	array
)	O
;	O
if	O
(	O
hdr	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
{	O
newsect	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
newsect	pointer
->	O
flags	int
|=	O
SEC_LOAD	int
;	O
if	O
(	O
hdr	pointer
->	O
p_flags	array
&	O
PF_X	O
)	O
{	O
newsect	pointer
->	O
flags	int
|=	O
SEC_CODE	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
hdr	pointer
->	O
p_flags	array
&	O
PF_W	O
)	O
)	O
{	O
newsect	pointer
->	O
flags	int
|=	O
SEC_READONLY	int
;	O
}	O
}	O
if	O
(	O
hdr	pointer
->	O
p_memsz	array
>	O
hdr	pointer
->	O
p_filesz	array
)	O
{	O
bfd_vma	long
align	long
;	O
sprintf	function
(	O
namebuf	array
,	O
"%s%d%s"	pointer
,	O
type_name	pointer
,	O
hdr_index	int
,	O
split	int
?	O
"b"	pointer
:	O
""	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
namebuf	array
)	O
+	O
1	int
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
name	pointer
,	O
namebuf	array
,	O
len	long
)	O
;	O
newsect	pointer
=	O
bfd_make_section	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
newsect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
newsect	pointer
->	O
vma	long
=	O
hdr	pointer
->	O
p_vaddr	array
+	O
hdr	pointer
->	O
p_filesz	array
;	O
newsect	pointer
->	O
lma	long
=	O
hdr	pointer
->	O
p_paddr	array
+	O
hdr	pointer
->	O
p_filesz	array
;	O
newsect	pointer
->	O
size	long
=	O
hdr	pointer
->	O
p_memsz	array
-	O
hdr	pointer
->	O
p_filesz	array
;	O
newsect	pointer
->	O
filepos	long
=	O
hdr	pointer
->	O
p_offset	array
+	O
hdr	pointer
->	O
p_filesz	array
;	O
align	long
=	O
newsect	pointer
->	O
vma	long
&	O
-	O
newsect	pointer
->	O
vma	long
;	O
if	O
(	O
align	long
==	O
0	int
||	O
align	long
>	O
hdr	pointer
->	O
p_align	array
)	O
align	long
=	O
hdr	pointer
->	O
p_align	array
;	O
newsect	pointer
->	O
alignment_power	int
=	O
bfd_log2	function
(	O
align	long
)	O
;	O
if	O
(	O
hdr	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
{	O
if	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_core	int
)	O
newsect	pointer
->	O
size	long
=	O
0	int
;	O
newsect	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
if	O
(	O
hdr	pointer
->	O
p_flags	array
&	O
PF_X	O
)	O
newsect	pointer
->	O
flags	int
|=	O
SEC_CODE	int
;	O
}	O
if	O
(	O
!	O
(	O
hdr	pointer
->	O
p_flags	array
&	O
PF_W	O
)	O
)	O
newsect	pointer
->	O
flags	int
|=	O
SEC_READONLY	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_core_find_build_id	function
(	O
bfd	struct
*	O
templ	pointer
,	O
bfd_vma	long
offset	long
)	O
{	O
if	O
(	O
templ	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
return	O
(	O
*	O
get_elf_backend_data	O
(	O
templ	pointer
)	O
->	O
elf_backend_core_find_build_id	pointer
)	O
(	O
templ	pointer
,	O
offset	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
bfd_section_from_phdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Phdr	struct
*	O
hdr	pointer
,	O
int	O
hdr_index	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
switch	O
(	O
hdr	pointer
->	O
p_type	array
)	O
{	O
case	O
PT_NULL	int
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"null"	pointer
)	O
;	O
case	O
PT_LOAD	int
:	O
if	O
(	O
!	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"load"	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_core	int
&&	O
abfd	pointer
->	O
build_id	pointer
==	O
NULL	O
)	O
_bfd_elf_core_find_build_id	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
p_offset	array
)	O
;	O
return	O
TRUE	int
;	O
case	O
PT_DYNAMIC	int
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"dynamic"	pointer
)	O
;	O
case	O
PT_INTERP	int
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"interp"	pointer
)	O
;	O
case	O
PT_NOTE	int
:	O
if	O
(	O
!	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"note"	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
elf_read_notes	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
p_offset	array
,	O
hdr	pointer
->	O
p_filesz	array
,	O
hdr	pointer
->	O
p_align	array
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
case	O
PT_SHLIB	int
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"shlib"	pointer
)	O
;	O
case	O
PT_PHDR	int
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"phdr"	pointer
)	O
;	O
case	O
PT_GNU_EH_FRAME	O
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"eh_frame_hdr"	pointer
)	O
;	O
case	O
PT_GNU_STACK	O
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"stack"	pointer
)	O
;	O
case	O
PT_GNU_RELRO	O
:	O
return	O
_bfd_elf_make_section_from_phdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"relro"	pointer
)	O
;	O
default	O
:	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
return	O
bed	pointer
->	O
elf_backend_section_from_phdr	pointer
(	O
abfd	pointer
,	O
hdr	pointer
,	O
hdr_index	int
,	O
"proc"	pointer
)	O
;	O
}	O
}	O
Elf_Internal_Shdr	struct
*	O
_bfd_elf_single_rel_hdr	function
(	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
rel	pointer
.	O
hdr	pointer
)	O
{	O
BFD_ASSERT	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
rela	struct
.	O
hdr	pointer
==	O
NULL	O
)	O
;	O
return	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
rel	pointer
.	O
hdr	pointer
;	O
}	O
else	O
return	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
rela	struct
.	O
hdr	pointer
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_set_reloc_sh_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
rel_hdr	pointer
,	O
const	O
char	O
*	O
sec_name	pointer
,	O
bfd_boolean	int
use_rela_p	int
)	O
{	O
char	O
*	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
".rela"	pointer
+	O
strlen	function
(	O
sec_name	pointer
)	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sprintf	function
(	O
name	pointer
,	O
"%s%s"	pointer
,	O
use_rela_p	int
?	O
".rela"	pointer
:	O
".rel"	pointer
,	O
sec_name	pointer
)	O
;	O
rel_hdr	pointer
->	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
rel_hdr	pointer
->	O
sh_name	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_init_reloc_shdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_elf_section_reloc_data	struct
*	O
reldata	pointer
,	O
const	O
char	O
*	O
sec_name	pointer
,	O
bfd_boolean	int
use_rela_p	int
,	O
bfd_boolean	int
delay_st_name_p	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
rel_hdr	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
BFD_ASSERT	O
(	O
reldata	pointer
->	O
hdr	pointer
==	O
NULL	O
)	O
;	O
rel_hdr	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
rel_hdr	pointer
)	O
)	O
;	O
reldata	pointer
->	O
hdr	pointer
=	O
rel_hdr	pointer
;	O
if	O
(	O
delay_st_name_p	int
)	O
rel_hdr	pointer
->	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
else	O
if	O
(	O
!	O
_bfd_elf_set_reloc_sh_name	function
(	O
abfd	pointer
,	O
rel_hdr	pointer
,	O
sec_name	pointer
,	O
use_rela_p	int
)	O
)	O
return	O
FALSE	int
;	O
rel_hdr	pointer
->	O
sh_type	array
=	O
use_rela_p	int
?	O
SHT_RELA	int
:	O
SHT_REL	int
;	O
rel_hdr	pointer
->	O
sh_entsize	array
=	O
(	O
use_rela_p	int
?	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
:	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
)	O
;	O
rel_hdr	pointer
->	O
sh_addralign	array
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
rel_hdr	pointer
->	O
sh_flags	array
=	O
0	int
;	O
rel_hdr	pointer
->	O
sh_addr	array
=	O
0	int
;	O
rel_hdr	pointer
->	O
sh_size	array
=	O
0	int
;	O
rel_hdr	pointer
->	O
sh_offset	array
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
int	O
bfd_elf_get_default_section_type	function
(	O
flagword	int
flags	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_IS_COMMON	int
)	O
)	O
!=	O
0	int
&&	O
(	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
==	O
0	int
)	O
return	O
SHT_NOBITS	int
;	O
return	O
SHT_PROGBITS	int
;	O
}	O
struct	O
fake_section_arg	struct
{	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
;	O
bfd_boolean	int
failed	int
;	O
}	O
;	O
static	O
void	O
elf_fake_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
asect	pointer
,	O
void	O
*	O
fsarg	pointer
)	O
{	O
struct	O
fake_section_arg	struct
*	O
arg	pointer
=	O
(	O
struct	O
fake_section_arg	struct
*	O
)	O
fsarg	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
bfd_elf_section_data	struct
*	O
esd	pointer
=	O
elf_section_data	O
(	O
asect	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
this_hdr	struct
;	O
unsigned	O
int	O
sh_type	array
;	O
const	O
char	O
*	O
name	pointer
=	O
asect	pointer
->	O
name	pointer
;	O
bfd_boolean	int
delay_st_name_p	int
=	O
FALSE	int
;	O
if	O
(	O
arg	pointer
->	O
failed	int
)	O
{	O
return	O
;	O
}	O
this_hdr	struct
=	O
&	O
esd	pointer
->	O
this_hdr	struct
;	O
if	O
(	O
arg	pointer
->	O
link_info	pointer
)	O
{	O
if	O
(	O
(	O
arg	pointer
->	O
link_info	pointer
->	O
compress_debug	enum
&	O
COMPRESS_DEBUG	int
)	O
&&	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'd'	O
&&	O
name	pointer
[	O
6	int
]	O
==	O
'_'	O
)	O
{	O
asect	pointer
->	O
flags	int
|=	O
SEC_ELF_COMPRESS	int
;	O
delay_st_name_p	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_ELF_RENAME	int
)	O
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
BFD_DECOMPRESS	int
|	O
BFD_COMPRESS_GABI	int
)	O
)	O
)	O
{	O
if	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'z'	O
)	O
{	O
char	O
*	O
new_name	pointer
=	O
convert_zdebug_to_debug	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
name	pointer
=	O
new_name	pointer
;	O
}	O
}	O
else	O
if	O
(	O
asect	pointer
->	O
compress_status	int
==	O
COMPRESS_SECTION_DONE	int
)	O
{	O
char	O
*	O
new_name	pointer
=	O
convert_debug_to_zdebug	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
BFD_ASSERT	O
(	O
name	pointer
[	O
1	int
]	O
!=	O
'z'	O
)	O
;	O
name	pointer
=	O
new_name	pointer
;	O
}	O
}	O
if	O
(	O
delay_st_name_p	int
)	O
this_hdr	struct
->	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
else	O
{	O
this_hdr	struct
->	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
this_hdr	struct
->	O
sh_name	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
||	O
asect	pointer
->	O
user_set_vma	int
)	O
this_hdr	struct
->	O
sh_addr	array
=	O
asect	pointer
->	O
vma	long
;	O
else	O
this_hdr	struct
->	O
sh_addr	array
=	O
0	int
;	O
this_hdr	struct
->	O
sh_offset	array
=	O
0	int
;	O
this_hdr	struct
->	O
sh_size	array
=	O
asect	pointer
->	O
size	long
;	O
this_hdr	struct
->	O
sh_link	array
=	O
0	int
;	O
if	O
(	O
asect	pointer
->	O
alignment_power	int
>=	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
*	O
8	int
)	O
-	O
1	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: error: alignment power %d of section `%pA' is too big"	pointer
)	O
,	O
abfd	pointer
,	O
asect	pointer
->	O
alignment_power	int
,	O
asect	pointer
)	O
;	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
this_hdr	struct
->	O
sh_addralign	array
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
asect	pointer
->	O
alignment_power	int
;	O
this_hdr	struct
->	O
bfd_section	struct
=	O
asect	pointer
;	O
this_hdr	struct
->	O
contents	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
sh_type	array
=	O
SHT_GROUP	int
;	O
else	O
sh_type	array
=	O
bfd_elf_get_default_section_type	function
(	O
asect	pointer
->	O
flags	int
)	O
;	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
==	O
SHT_NULL	int
)	O
this_hdr	struct
->	O
sh_type	array
=	O
sh_type	array
;	O
else	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
==	O
SHT_NOBITS	int
&&	O
sh_type	array
==	O
SHT_PROGBITS	int
&&	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: section `%pA' type changed to PROGBITS"	pointer
)	O
,	O
asect	pointer
)	O
;	O
this_hdr	struct
->	O
sh_type	array
=	O
sh_type	array
;	O
}	O
switch	O
(	O
this_hdr	struct
->	O
sh_type	array
)	O
{	O
default	O
:	O
break	O
;	O
case	O
SHT_STRTAB	int
:	O
case	O
SHT_NOTE	int
:	O
case	O
SHT_NOBITS	int
:	O
case	O
SHT_PROGBITS	int
:	O
break	O
;	O
case	O
SHT_INIT_ARRAY	int
:	O
case	O
SHT_FINI_ARRAY	int
:	O
case	O
SHT_PREINIT_ARRAY	int
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
/	O
8	int
;	O
break	O
;	O
case	O
SHT_HASH	int
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_hash_entry	char
;	O
break	O
;	O
case	O
SHT_DYNSYM	int
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
break	O
;	O
case	O
SHT_DYNAMIC	int
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_dyn	char
;	O
break	O
;	O
case	O
SHT_RELA	int
:	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
may_use_rela_p	int
)	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
;	O
break	O
;	O
case	O
SHT_REL	int
:	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
may_use_rel_p	int
)	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
;	O
break	O
;	O
case	O
SHT_GNU_versym	O
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
sizeof	O
(	O
Elf_External_Versym	struct
)	O
;	O
break	O
;	O
case	O
SHT_GNU_verdef	O
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
0	int
;	O
if	O
(	O
this_hdr	struct
->	O
sh_info	array
==	O
0	int
)	O
this_hdr	struct
->	O
sh_info	array
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
;	O
else	O
BFD_ASSERT	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
==	O
0	int
||	O
this_hdr	struct
->	O
sh_info	array
==	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
)	O
;	O
break	O
;	O
case	O
SHT_GNU_verneed	O
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
0	int
;	O
if	O
(	O
this_hdr	struct
->	O
sh_info	array
==	O
0	int
)	O
this_hdr	struct
->	O
sh_info	array
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverrefs	int
;	O
else	O
BFD_ASSERT	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverrefs	int
==	O
0	int
||	O
this_hdr	struct
->	O
sh_info	array
==	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverrefs	int
)	O
;	O
break	O
;	O
case	O
SHT_GROUP	int
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
GRP_ENTRY_SIZE	int
;	O
break	O
;	O
case	O
SHT_GNU_HASH	int
:	O
this_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
==	O
64	int
?	O
0	int
:	O
4	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_ALLOC	O
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_WRITE	O
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_EXECINSTR	O
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
)	O
{	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_MERGE	O
;	O
this_hdr	struct
->	O
sh_entsize	array
=	O
asect	pointer
->	O
entsize	int
;	O
}	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_STRINGS	int
)	O
!=	O
0	int
)	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_STRINGS	O
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
==	O
0	int
&&	O
elf_group_name	O
(	O
asect	pointer
)	O
!=	O
NULL	O
)	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_GROUP	O
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
{	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_TLS	O
;	O
if	O
(	O
asect	pointer
->	O
size	long
==	O
0	int
&&	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
)	O
{	O
struct	O
bfd_link_order	struct
*	O
o	pointer
=	O
asect	pointer
->	O
map_tail	union
.	O
link_order	pointer
;	O
this_hdr	struct
->	O
sh_size	array
=	O
0	int
;	O
if	O
(	O
o	pointer
!=	O
NULL	O
)	O
{	O
this_hdr	struct
->	O
sh_size	array
=	O
o	pointer
->	O
offset	long
+	O
o	pointer
->	O
size	long
;	O
if	O
(	O
this_hdr	struct
->	O
sh_size	array
!=	O
0	int
)	O
this_hdr	struct
->	O
sh_type	array
=	O
SHT_NOBITS	int
;	O
}	O
}	O
}	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
(	O
SEC_GROUP	int
|	O
SEC_EXCLUDE	int
)	O
)	O
==	O
SEC_EXCLUDE	int
)	O
this_hdr	struct
->	O
sh_flags	array
|=	O
SHF_EXCLUDE	int
;	O
if	O
(	O
(	O
asect	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
arg	pointer
->	O
link_info	pointer
&&	O
esd	pointer
->	O
rel	pointer
.	O
count	int
+	O
esd	pointer
->	O
rela	struct
.	O
count	int
>	O
0	int
&&	O
(	O
bfd_link_relocatable	O
(	O
arg	pointer
->	O
link_info	pointer
)	O
||	O
arg	pointer
->	O
link_info	pointer
->	O
emitrelocations	int
)	O
)	O
{	O
if	O
(	O
esd	pointer
->	O
rel	pointer
.	O
count	int
&&	O
esd	pointer
->	O
rel	pointer
.	O
hdr	pointer
==	O
NULL	O
&&	O
!	O
_bfd_elf_init_reloc_shdr	function
(	O
abfd	pointer
,	O
&	O
esd	pointer
->	O
rel	pointer
,	O
name	pointer
,	O
FALSE	int
,	O
delay_st_name_p	int
)	O
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
if	O
(	O
esd	pointer
->	O
rela	struct
.	O
count	int
&&	O
esd	pointer
->	O
rela	struct
.	O
hdr	pointer
==	O
NULL	O
&&	O
!	O
_bfd_elf_init_reloc_shdr	function
(	O
abfd	pointer
,	O
&	O
esd	pointer
->	O
rela	struct
,	O
name	pointer
,	O
TRUE	int
,	O
delay_st_name_p	int
)	O
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
_bfd_elf_init_reloc_shdr	function
(	O
abfd	pointer
,	O
(	O
asect	pointer
->	O
use_rela_p	int
?	O
&	O
esd	pointer
->	O
rela	struct
:	O
&	O
esd	pointer
->	O
rel	pointer
)	O
,	O
name	pointer
,	O
asect	pointer
->	O
use_rela_p	int
,	O
delay_st_name_p	int
)	O
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
}	O
sh_type	array
=	O
this_hdr	struct
->	O
sh_type	array
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_fake_sections	pointer
&&	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_fake_sections	pointer
)	O
(	O
abfd	pointer
,	O
this_hdr	struct
,	O
asect	pointer
)	O
)	O
{	O
arg	pointer
->	O
failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
if	O
(	O
sh_type	array
==	O
SHT_NOBITS	int
&&	O
asect	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
this_hdr	struct
->	O
sh_type	array
=	O
sh_type	array
;	O
}	O
}	O
void	O
bfd_elf_set_group_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
failedptrarg	pointer
)	O
{	O
bfd_boolean	int
*	O
failedptr	pointer
=	O
(	O
bfd_boolean	int
*	O
)	O
failedptrarg	pointer
;	O
asection	struct
*	O
elt	pointer
,	O
*	O
first	pointer
;	O
unsigned	O
char	O
*	O
loc	pointer
;	O
bfd_boolean	int
gas	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
(	O
SEC_GROUP	int
|	O
SEC_LINKER_CREATED	int
)	O
)	O
!=	O
SEC_GROUP	int
||	O
sec	pointer
->	O
size	long
==	O
0	int
||	O
*	O
failedptr	pointer
)	O
return	O
;	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
==	O
0	int
)	O
{	O
unsigned	O
long	O
symindx	long
=	O
0	int
;	O
if	O
(	O
elf_group_id	O
(	O
sec	pointer
)	O
!=	O
NULL	O
)	O
symindx	long
=	O
elf_group_id	O
(	O
sec	pointer
)	O
->	O
udata	union
.	O
i	pointer
;	O
if	O
(	O
symindx	long
==	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
elf_section_syms	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
;	O
symindx	long
=	O
elf_section_syms	O
(	O
abfd	pointer
)	O
[	O
sec	pointer
->	O
index	function
]	O
->	O
udata	union
.	O
i	pointer
;	O
}	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
symindx	long
;	O
}	O
else	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
2	int
)	O
{	O
asection	struct
*	O
igroup	pointer
;	O
struct	O
bfd_elf_section_data	struct
*	O
sec_data	pointer
;	O
unsigned	O
long	O
symndx	long
;	O
unsigned	O
long	O
extsymoff	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
igroup	pointer
=	O
elf_sec_group	O
(	O
elf_next_in_group	O
(	O
sec	pointer
)	O
)	O
;	O
sec_data	pointer
=	O
elf_section_data	O
(	O
igroup	pointer
)	O
;	O
symndx	long
=	O
sec_data	pointer
->	O
this_hdr	struct
.	O
sh_info	array
;	O
extsymoff	long
=	O
0	int
;	O
if	O
(	O
!	O
elf_bad_symtab	O
(	O
igroup	pointer
->	O
owner	pointer
)	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
igroup	pointer
->	O
owner	pointer
)	O
->	O
symtab_hdr	struct
;	O
extsymoff	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
}	O
h	pointer
=	O
elf_sym_hashes	O
(	O
igroup	pointer
->	O
owner	pointer
)	O
[	O
symndx	long
-	O
extsymoff	long
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
h	pointer
->	O
indx	long
;	O
}	O
gas	int
=	O
TRUE	int
;	O
if	O
(	O
sec	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
gas	int
=	O
FALSE	int
;	O
sec	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
size	long
)	O
;	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
=	O
sec	pointer
->	O
contents	pointer
;	O
if	O
(	O
sec	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
*	O
failedptr	pointer
=	O
TRUE	int
;	O
return	O
;	O
}	O
}	O
loc	pointer
=	O
sec	pointer
->	O
contents	pointer
+	O
sec	pointer
->	O
size	long
;	O
first	pointer
=	O
elt	pointer
=	O
elf_next_in_group	O
(	O
sec	pointer
)	O
;	O
while	O
(	O
elt	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
s	pointer
=	O
elt	pointer
;	O
if	O
(	O
!	O
gas	int
)	O
s	pointer
=	O
s	pointer
->	O
output_section	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
!	O
bfd_is_abs_section	function
(	O
s	pointer
)	O
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
elf_sec	pointer
=	O
elf_section_data	O
(	O
s	pointer
)	O
;	O
struct	O
bfd_elf_section_data	struct
*	O
input_elf_sec	pointer
=	O
elf_section_data	O
(	O
elt	pointer
)	O
;	O
if	O
(	O
elf_sec	pointer
->	O
rel	pointer
.	O
hdr	pointer
!=	O
NULL	O
&&	O
(	O
gas	int
||	O
(	O
input_elf_sec	pointer
->	O
rel	pointer
.	O
hdr	pointer
!=	O
NULL	O
&&	O
input_elf_sec	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_GROUP	O
)	O
!=	O
0	int
)	O
)	O
{	O
elf_sec	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_flags	array
|=	O
SHF_GROUP	O
;	O
loc	pointer
-=	O
4	int
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
elf_sec	pointer
->	O
rel	pointer
.	O
idx	int
,	O
loc	pointer
)	O
;	O
}	O
if	O
(	O
elf_sec	pointer
->	O
rela	struct
.	O
hdr	pointer
!=	O
NULL	O
&&	O
(	O
gas	int
||	O
(	O
input_elf_sec	pointer
->	O
rela	struct
.	O
hdr	pointer
!=	O
NULL	O
&&	O
input_elf_sec	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_GROUP	O
)	O
!=	O
0	int
)	O
)	O
{	O
elf_sec	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_flags	array
|=	O
SHF_GROUP	O
;	O
loc	pointer
-=	O
4	int
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
elf_sec	pointer
->	O
rela	struct
.	O
idx	int
,	O
loc	pointer
)	O
;	O
}	O
loc	pointer
-=	O
4	int
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
elf_sec	pointer
->	O
this_idx	int
,	O
loc	pointer
)	O
;	O
}	O
elt	pointer
=	O
elf_next_in_group	O
(	O
elt	pointer
)	O
;	O
if	O
(	O
elt	pointer
==	O
first	pointer
)	O
break	O
;	O
}	O
loc	pointer
-=	O
4	int
;	O
BFD_ASSERT	O
(	O
loc	pointer
==	O
sec	pointer
->	O
contents	pointer
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
sec	pointer
->	O
flags	int
&	O
SEC_LINK_ONCE	int
?	O
GRP_COMDAT	int
:	O
0	int
,	O
loc	pointer
)	O
;	O
}	O
asection	struct
*	O
_bfd_elf_plt_get_reloc_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
want_got_plt	int
&&	O
strcmp	function
(	O
name	pointer
,	O
".plt"	pointer
)	O
==	O
0	int
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
name	pointer
=	O
".got.plt"	pointer
;	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
return	O
sec	pointer
;	O
name	pointer
=	O
".got"	pointer
;	O
}	O
return	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
asection	struct
*	O
elf_get_reloc_section	function
(	O
asection	struct
*	O
reloc_sec	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
type	enum
;	O
bfd	struct
*	O
abfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
type	enum
=	O
elf_section_data	O
(	O
reloc_sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
;	O
if	O
(	O
type	enum
!=	O
SHT_REL	int
&&	O
type	enum
!=	O
SHT_RELA	int
)	O
return	O
NULL	O
;	O
name	pointer
=	O
reloc_sec	pointer
->	O
name	pointer
;	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
".rel"	pointer
,	O
4	int
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
name	pointer
+=	O
4	int
;	O
if	O
(	O
type	enum
==	O
SHT_RELA	int
&&	O
*	O
name	pointer
++	O
!=	O
'a'	O
)	O
return	O
NULL	O
;	O
abfd	pointer
=	O
reloc_sec	pointer
->	O
owner	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
return	O
bed	pointer
->	O
get_reloc_section	pointer
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
assign_section_numbers	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
struct	O
elf_obj_tdata	struct
*	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
;	O
asection	struct
*	O
sec	pointer
;	O
unsigned	O
int	O
section_number	int
;	O
Elf_Internal_Shdr	struct
*	O
*	O
i_shdrp	pointer
;	O
struct	O
bfd_elf_section_data	struct
*	O
d	pointer
;	O
bfd_boolean	int
need_symtab	int
;	O
section_number	int
=	O
1	int
;	O
_bfd_elf_strtab_clear_all_refs	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
link_info	pointer
==	O
NULL	O
||	O
!	O
link_info	pointer
->	O
resolve_section_groups	int
)	O
{	O
size_t	long
reloc_count	int
=	O
0	int
;	O
for	O
(	O
sec	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
d	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_GROUP	int
)	O
{	O
if	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
{	O
bfd_section_list_remove	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
abfd	pointer
->	O
section_count	int
--	O
;	O
}	O
else	O
d	pointer
->	O
this_idx	int
=	O
section_number	int
++	O
;	O
}	O
reloc_count	int
+=	O
sec	pointer
->	O
reloc_count	int
;	O
}	O
if	O
(	O
reloc_count	int
==	O
0	int
)	O
abfd	pointer
->	O
flags	int
&=	O
~	O
HAS_RELOC	int
;	O
}	O
for	O
(	O
sec	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
d	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
this_hdr	struct
.	O
sh_type	array
!=	O
SHT_GROUP	int
)	O
d	pointer
->	O
this_idx	int
=	O
section_number	int
++	O
;	O
if	O
(	O
d	pointer
->	O
this_hdr	struct
.	O
sh_name	array
!=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
_bfd_elf_strtab_addref	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
d	pointer
->	O
this_hdr	struct
.	O
sh_name	array
)	O
;	O
if	O
(	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
)	O
{	O
d	pointer
->	O
rel	pointer
.	O
idx	int
=	O
section_number	int
++	O
;	O
if	O
(	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_name	array
!=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
_bfd_elf_strtab_addref	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_name	array
)	O
;	O
}	O
else	O
d	pointer
->	O
rel	pointer
.	O
idx	int
=	O
0	int
;	O
if	O
(	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
)	O
{	O
d	pointer
->	O
rela	struct
.	O
idx	int
=	O
section_number	int
++	O
;	O
if	O
(	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_name	array
!=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
_bfd_elf_strtab_addref	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_name	array
)	O
;	O
}	O
else	O
d	pointer
->	O
rela	struct
.	O
idx	int
=	O
0	int
;	O
}	O
need_symtab	int
=	O
(	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
>	O
0	int
||	O
(	O
link_info	pointer
==	O
NULL	O
&&	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
EXEC_P	int
|	O
DYNAMIC	int
|	O
HAS_RELOC	int
)	O
)	O
==	O
HAS_RELOC	int
)	O
)	O
)	O
;	O
if	O
(	O
need_symtab	int
)	O
{	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
=	O
section_number	int
++	O
;	O
_bfd_elf_strtab_addref	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
t	pointer
->	O
symtab_hdr	struct
.	O
sh_name	array
)	O
;	O
if	O
(	O
section_number	int
>	O
(	O
(	O
SHN_LORESERVE	O
-	O
2	int
)	O
&	O
0xFFFF	int
)	O
)	O
{	O
elf_section_list	struct
*	O
entry	pointer
;	O
BFD_ASSERT	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
==	O
NULL	O
)	O
;	O
entry	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
entry	pointer
)	O
)	O
;	O
entry	pointer
->	O
ndx	int
=	O
section_number	int
++	O
;	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
=	O
entry	pointer
;	O
entry	pointer
->	O
hdr	pointer
.	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
".symtab_shndx"	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
hdr	pointer
.	O
sh_name	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
elf_strtab_sec	O
(	O
abfd	pointer
)	O
=	O
section_number	int
++	O
;	O
_bfd_elf_strtab_addref	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
t	pointer
->	O
strtab_hdr	struct
.	O
sh_name	array
)	O
;	O
}	O
elf_shstrtab_sec	O
(	O
abfd	pointer
)	O
=	O
section_number	int
++	O
;	O
_bfd_elf_strtab_addref	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
t	pointer
->	O
shstrtab_hdr	struct
.	O
sh_name	array
)	O
;	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_shstrndx	array
=	O
elf_shstrtab_sec	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
section_number	int
>=	O
SHN_LORESERVE	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: too many sections: %u"	pointer
)	O
,	O
abfd	pointer
,	O
section_number	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
elf_numsections	O
(	O
abfd	pointer
)	O
=	O
section_number	int
;	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_shnum	array
=	O
section_number	int
;	O
i_shdrp	pointer
=	O
(	O
Elf_Internal_Shdr	struct
*	O
*	O
)	O
bfd_zalloc2	function
(	O
abfd	pointer
,	O
section_number	int
,	O
sizeof	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
)	O
;	O
if	O
(	O
i_shdrp	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
i_shdrp	pointer
[	O
0	int
]	O
=	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
Elf_Internal_Shdr	struct
)	O
)	O
;	O
if	O
(	O
i_shdrp	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
bfd_release	function
(	O
abfd	pointer
,	O
i_shdrp	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
elf_elfsections	O
(	O
abfd	pointer
)	O
=	O
i_shdrp	pointer
;	O
i_shdrp	pointer
[	O
elf_shstrtab_sec	O
(	O
abfd	pointer
)	O
]	O
=	O
&	O
t	pointer
->	O
shstrtab_hdr	struct
;	O
if	O
(	O
need_symtab	int
)	O
{	O
i_shdrp	pointer
[	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
]	O
=	O
&	O
t	pointer
->	O
symtab_hdr	struct
;	O
if	O
(	O
elf_numsections	O
(	O
abfd	pointer
)	O
>	O
(	O
SHN_LORESERVE	O
&	O
0xFFFF	int
)	O
)	O
{	O
elf_section_list	struct
*	O
entry	pointer
=	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
;	O
BFD_ASSERT	O
(	O
entry	pointer
!=	O
NULL	O
)	O
;	O
i_shdrp	pointer
[	O
entry	pointer
->	O
ndx	int
]	O
=	O
&	O
entry	pointer
->	O
hdr	pointer
;	O
entry	pointer
->	O
hdr	pointer
.	O
sh_link	array
=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
;	O
}	O
i_shdrp	pointer
[	O
elf_strtab_sec	O
(	O
abfd	pointer
)	O
]	O
=	O
&	O
t	pointer
->	O
strtab_hdr	struct
;	O
t	pointer
->	O
symtab_hdr	struct
.	O
sh_link	array
=	O
elf_strtab_sec	O
(	O
abfd	pointer
)	O
;	O
}	O
for	O
(	O
sec	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
sec	pointer
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
d	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
i_shdrp	pointer
[	O
d	pointer
->	O
this_idx	int
]	O
=	O
&	O
d	pointer
->	O
this_hdr	struct
;	O
if	O
(	O
d	pointer
->	O
rel	pointer
.	O
idx	int
!=	O
0	int
)	O
i_shdrp	pointer
[	O
d	pointer
->	O
rel	pointer
.	O
idx	int
]	O
=	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
;	O
if	O
(	O
d	pointer
->	O
rela	struct
.	O
idx	int
!=	O
0	int
)	O
i_shdrp	pointer
[	O
d	pointer
->	O
rela	struct
.	O
idx	int
]	O
=	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
;	O
if	O
(	O
d	pointer
->	O
rel	pointer
.	O
idx	int
!=	O
0	int
)	O
{	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_link	array
=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
;	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_info	array
=	O
d	pointer
->	O
this_idx	int
;	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_flags	array
|=	O
SHF_INFO_LINK	O
;	O
}	O
if	O
(	O
d	pointer
->	O
rela	struct
.	O
idx	int
!=	O
0	int
)	O
{	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_link	array
=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
;	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_info	array
=	O
d	pointer
->	O
this_idx	int
;	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_flags	array
|=	O
SHF_INFO_LINK	O
;	O
}	O
if	O
(	O
(	O
d	pointer
->	O
this_hdr	struct
.	O
sh_flags	array
&	O
SHF_LINK_ORDER	O
)	O
!=	O
0	int
)	O
{	O
s	pointer
=	O
elf_linked_to_section	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
link_info	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
discarded_section	function
(	O
s	pointer
)	O
)	O
{	O
asection	struct
*	O
kept	pointer
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: sh_link of section `%pA' points to"	pointer
" discarded section `%pA' of `%pB'"	pointer
)	O
,	O
abfd	pointer
,	O
d	pointer
->	O
this_hdr	struct
.	O
bfd_section	struct
,	O
s	pointer
,	O
s	pointer
->	O
owner	pointer
)	O
;	O
kept	pointer
=	O
_bfd_elf_check_kept_section	function
(	O
s	pointer
,	O
link_info	pointer
)	O
;	O
if	O
(	O
kept	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
kept	pointer
;	O
}	O
s	pointer
=	O
s	pointer
->	O
output_section	pointer
;	O
BFD_ASSERT	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
s	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: sh_link of section `%pA' points to"	pointer
" removed section `%pA' of `%pB'"	pointer
)	O
,	O
abfd	pointer
,	O
d	pointer
->	O
this_hdr	struct
.	O
bfd_section	struct
,	O
s	pointer
,	O
s	pointer
->	O
owner	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
s	pointer
=	O
s	pointer
->	O
output_section	pointer
;	O
}	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
}	O
else	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
link_order_error_handler	pointer
)	O
bed	pointer
->	O
link_order_error_handler	pointer
(	O
_	O
(	O
"%pB: warning: sh_link not set for section `%pA'"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
}	O
}	O
switch	O
(	O
d	pointer
->	O
this_hdr	struct
.	O
sh_type	array
)	O
{	O
case	O
SHT_REL	int
:	O
case	O
SHT_RELA	int
:	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynsym"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
s	pointer
=	O
elf_get_reloc_section	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
d	pointer
->	O
this_hdr	struct
.	O
sh_info	array
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
d	pointer
->	O
this_hdr	struct
.	O
sh_flags	array
|=	O
SHF_INFO_LINK	O
;	O
}	O
break	O
;	O
case	O
SHT_STRTAB	int
:	O
if	O
(	O
CONST_STRNEQ	O
(	O
sec	pointer
->	O
name	pointer
,	O
".stab"	pointer
)	O
&&	O
strcmp	function
(	O
sec	pointer
->	O
name	pointer
+	O
strlen	function
(	O
sec	pointer
->	O
name	pointer
)	O
-	O
3	int
,	O
"str"	pointer
)	O
==	O
0	int
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
alc	pointer
;	O
len	long
=	O
strlen	function
(	O
sec	pointer
->	O
name	pointer
)	O
;	O
alc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
len	long
-	O
2	int
)	O
;	O
if	O
(	O
alc	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
alc	pointer
,	O
sec	pointer
->	O
name	pointer
,	O
len	long
-	O
3	int
)	O
;	O
alc	pointer
[	O
len	long
-	O
3	int
]	O
=	O
'\0'	O
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
alc	pointer
)	O
;	O
free	function
(	O
alc	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_link	array
=	O
d	pointer
->	O
this_idx	int
;	O
if	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
==	O
0	int
)	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
4	int
+	O
2	int
*	O
bfd_get_arch_size	function
(	O
abfd	pointer
)	O
/	O
8	int
;	O
}	O
}	O
break	O
;	O
case	O
SHT_DYNAMIC	int
:	O
case	O
SHT_DYNSYM	int
:	O
case	O
SHT_GNU_verneed	O
:	O
case	O
SHT_GNU_verdef	O
:	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynstr"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
break	O
;	O
case	O
SHT_GNU_LIBLIST	int
:	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
?	O
".dynstr"	pointer
:	O
".gnu.libstr"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
break	O
;	O
case	O
SHT_HASH	int
:	O
case	O
SHT_GNU_HASH	int
:	O
case	O
SHT_GNU_versym	O
:	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynsym"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_idx	int
;	O
break	O
;	O
case	O
SHT_GROUP	int
:	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
sym_is_global	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
sym	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_sym_is_global	pointer
)	O
return	O
(	O
*	O
bed	pointer
->	O
elf_backend_sym_is_global	pointer
)	O
(	O
abfd	pointer
,	O
sym	pointer
)	O
;	O
return	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
|	O
BSF_GNU_UNIQUE	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
;	O
}	O
unsigned	O
int	O
_bfd_elf_filter_global_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asymbol	struct
*	O
*	O
syms	pointer
,	O
long	O
symcount	int
)	O
{	O
long	O
src_count	long
,	O
dst_count	long
=	O
0	int
;	O
for	O
(	O
src_count	long
=	O
0	int
;	O
src_count	long
<	O
symcount	int
;	O
src_count	long
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
syms	pointer
[	O
src_count	long
]	O
;	O
char	O
*	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
;	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
if	O
(	O
!	O
sym_is_global	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
)	O
continue	O
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
continue	O
;	O
if	O
(	O
h	pointer
->	O
linker_def	int
||	O
h	pointer
->	O
ldscript_def	int
)	O
continue	O
;	O
syms	pointer
[	O
dst_count	long
++	O
]	O
=	O
sym	pointer
;	O
}	O
syms	pointer
[	O
dst_count	long
]	O
=	O
NULL	O
;	O
return	O
dst_count	long
;	O
}	O
static	O
bfd_boolean	int
ignore_section_sym	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
sym	pointer
)	O
{	O
elf_symbol_type	struct
*	O
type_ptr	pointer
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
sym	pointer
->	O
section	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
type_ptr	pointer
=	O
elf_symbol_from	O
(	O
abfd	pointer
,	O
sym	pointer
)	O
;	O
return	O
(	O
(	O
type_ptr	pointer
!=	O
NULL	O
&&	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
!=	O
0	int
&&	O
bfd_is_abs_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
||	O
!	O
(	O
sym	pointer
->	O
section	pointer
->	O
owner	pointer
==	O
abfd	pointer
||	O
(	O
sym	pointer
->	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
sym	pointer
->	O
section	pointer
->	O
output_section	pointer
->	O
owner	pointer
==	O
abfd	pointer
&&	O
sym	pointer
->	O
section	pointer
->	O
output_offset	long
==	O
0	int
)	O
||	O
bfd_is_abs_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_map_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
*	O
pnum_locals	pointer
)	O
{	O
unsigned	O
int	O
symcount	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
asymbol	struct
*	O
*	O
syms	pointer
=	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
;	O
asymbol	struct
*	O
*	O
sect_syms	pointer
;	O
unsigned	O
int	O
num_locals	int
=	O
0	int
;	O
unsigned	O
int	O
num_globals	int
=	O
0	int
;	O
unsigned	O
int	O
num_locals2	int
=	O
0	int
;	O
unsigned	O
int	O
num_globals2	int
=	O
0	int
;	O
unsigned	O
int	O
max_index	int
=	O
0	int
;	O
unsigned	O
int	O
idx	int
;	O
asection	struct
*	O
asect	pointer
;	O
asymbol	struct
*	O
*	O
new_syms	pointer
;	O
for	O
(	O
asect	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
asect	pointer
;	O
asect	pointer
=	O
asect	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
max_index	int
<	O
asect	pointer
->	O
index	function
)	O
max_index	int
=	O
asect	pointer
->	O
index	function
;	O
}	O
max_index	int
++	O
;	O
sect_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_zalloc2	function
(	O
abfd	pointer
,	O
max_index	int
,	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
;	O
if	O
(	O
sect_syms	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_section_syms	O
(	O
abfd	pointer
)	O
=	O
sect_syms	pointer
;	O
elf_num_section_syms	O
(	O
abfd	pointer
)	O
=	O
max_index	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
symcount	int
;	O
idx	int
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
syms	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
!=	O
0	int
&&	O
sym	pointer
->	O
value	long
==	O
0	int
&&	O
!	O
ignore_section_sym	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
&&	O
!	O
bfd_is_abs_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
sym	pointer
->	O
section	pointer
;	O
if	O
(	O
sec	pointer
->	O
owner	pointer
!=	O
abfd	pointer
)	O
sec	pointer
=	O
sec	pointer
->	O
output_section	pointer
;	O
sect_syms	pointer
[	O
sec	pointer
->	O
index	function
]	O
=	O
syms	pointer
[	O
idx	int
]	O
;	O
}	O
}	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
symcount	int
;	O
idx	int
++	O
)	O
{	O
if	O
(	O
sym_is_global	function
(	O
abfd	pointer
,	O
syms	pointer
[	O
idx	int
]	O
)	O
)	O
num_globals	int
++	O
;	O
else	O
if	O
(	O
!	O
ignore_section_sym	function
(	O
abfd	pointer
,	O
syms	pointer
[	O
idx	int
]	O
)	O
)	O
num_locals	int
++	O
;	O
}	O
for	O
(	O
asect	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
asect	pointer
;	O
asect	pointer
=	O
asect	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
sect_syms	pointer
[	O
asect	pointer
->	O
index	function
]	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
sym_is_global	function
(	O
abfd	pointer
,	O
asect	pointer
->	O
symbol	pointer
)	O
)	O
num_locals	int
++	O
;	O
else	O
num_globals	int
++	O
;	O
}	O
}	O
new_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
num_locals	int
+	O
num_globals	int
,	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
;	O
if	O
(	O
new_syms	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
symcount	int
;	O
idx	int
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
syms	pointer
[	O
idx	int
]	O
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
sym_is_global	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
)	O
i	pointer
=	O
num_locals	int
+	O
num_globals2	int
++	O
;	O
else	O
if	O
(	O
!	O
ignore_section_sym	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
)	O
i	pointer
=	O
num_locals2	int
++	O
;	O
else	O
continue	O
;	O
new_syms	pointer
[	O
i	pointer
]	O
=	O
sym	pointer
;	O
sym	pointer
->	O
udata	union
.	O
i	pointer
=	O
i	pointer
+	O
1	int
;	O
}	O
for	O
(	O
asect	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
asect	pointer
;	O
asect	pointer
=	O
asect	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
sect_syms	pointer
[	O
asect	pointer
->	O
index	function
]	O
==	O
NULL	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
asect	pointer
->	O
symbol	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
sect_syms	pointer
[	O
asect	pointer
->	O
index	function
]	O
=	O
sym	pointer
;	O
if	O
(	O
!	O
sym_is_global	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
)	O
i	pointer
=	O
num_locals2	int
++	O
;	O
else	O
i	pointer
=	O
num_locals	int
+	O
num_globals2	int
++	O
;	O
new_syms	pointer
[	O
i	pointer
]	O
=	O
sym	pointer
;	O
sym	pointer
->	O
udata	union
.	O
i	pointer
=	O
i	pointer
+	O
1	int
;	O
}	O
}	O
bfd_set_symtab	function
(	O
abfd	pointer
,	O
new_syms	pointer
,	O
num_locals	int
+	O
num_globals	int
)	O
;	O
*	O
pnum_locals	pointer
=	O
num_locals	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
inline	O
file_ptr	long
align_file_position	function
(	O
file_ptr	long
off	long
,	O
int	O
align	long
)	O
{	O
return	O
(	O
off	long
+	O
align	long
-	O
1	int
)	O
&	O
~	O
(	O
align	long
-	O
1	int
)	O
;	O
}	O
file_ptr	long
_bfd_elf_assign_file_position_for_section	function
(	O
Elf_Internal_Shdr	struct
*	O
i_shdrp	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_boolean	int
align	long
)	O
{	O
if	O
(	O
align	long
&&	O
i_shdrp	pointer
->	O
sh_addralign	array
>	O
1	int
)	O
offset	long
=	O
BFD_ALIGN	O
(	O
offset	long
,	O
i_shdrp	pointer
->	O
sh_addralign	array
)	O
;	O
i_shdrp	pointer
->	O
sh_offset	array
=	O
offset	long
;	O
if	O
(	O
i_shdrp	pointer
->	O
bfd_section	struct
!=	O
NULL	O
)	O
i_shdrp	pointer
->	O
bfd_section	struct
->	O
filepos	long
=	O
offset	long
;	O
if	O
(	O
i_shdrp	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
offset	long
+=	O
i_shdrp	pointer
->	O
sh_size	array
;	O
return	O
offset	long
;	O
}	O
bfd_boolean	int
_bfd_elf_compute_section_file_positions	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
fake_section_arg	struct
fsargs	struct
;	O
bfd_boolean	int
failed	int
;	O
struct	O
elf_strtab_hash	O
*	O
strtab	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
shstrtab_hdr	struct
;	O
bfd_boolean	int
need_symtab	int
;	O
if	O
(	O
abfd	pointer
->	O
output_has_begun	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_begin_write_processing	pointer
)	O
(	O
*	O
bed	pointer
->	O
elf_backend_begin_write_processing	pointer
)	O
(	O
abfd	pointer
,	O
link_info	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_init_file_header	pointer
)	O
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
fsargs	struct
.	O
failed	int
=	O
FALSE	int
;	O
fsargs	struct
.	O
link_info	pointer
=	O
link_info	pointer
;	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
elf_fake_sections	function
,	O
&	O
fsargs	struct
)	O
;	O
if	O
(	O
fsargs	struct
.	O
failed	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
assign_section_numbers	function
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
need_symtab	int
=	O
(	O
link_info	pointer
==	O
NULL	O
&&	O
(	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
>	O
0	int
||	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
EXEC_P	int
|	O
DYNAMIC	int
|	O
HAS_RELOC	int
)	O
)	O
==	O
HAS_RELOC	int
)	O
)	O
)	O
;	O
if	O
(	O
need_symtab	int
)	O
{	O
int	O
relocatable_p	int
=	O
!	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
EXEC_P	int
|	O
DYNAMIC	int
)	O
)	O
;	O
if	O
(	O
!	O
swap_out_syms	function
(	O
abfd	pointer
,	O
&	O
strtab	pointer
,	O
relocatable_p	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
failed	int
=	O
FALSE	int
;	O
if	O
(	O
link_info	pointer
==	O
NULL	O
)	O
{	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
bfd_elf_set_group_contents	function
,	O
&	O
failed	int
)	O
;	O
if	O
(	O
failed	int
)	O
return	O
FALSE	int
;	O
}	O
shstrtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
shstrtab_hdr	struct
;	O
shstrtab_hdr	struct
->	O
sh_type	array
=	O
SHT_STRTAB	int
;	O
shstrtab_hdr	struct
->	O
sh_flags	array
=	O
bed	pointer
->	O
elf_strtab_flags	long
;	O
shstrtab_hdr	struct
->	O
sh_addr	array
=	O
0	int
;	O
shstrtab_hdr	struct
->	O
sh_entsize	array
=	O
0	int
;	O
shstrtab_hdr	struct
->	O
sh_link	array
=	O
0	int
;	O
shstrtab_hdr	struct
->	O
sh_info	array
=	O
0	int
;	O
shstrtab_hdr	struct
->	O
sh_addralign	array
=	O
1	int
;	O
if	O
(	O
!	O
assign_file_positions_except_relocs	function
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
need_symtab	int
)	O
{	O
file_ptr	long
off	long
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
off	long
=	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
;	O
hdr	pointer
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
;	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
if	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
{	O
hdr	pointer
=	O
&	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
->	O
hdr	pointer
;	O
if	O
(	O
hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
}	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
;	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
off	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
!	O
_bfd_elf_strtab_emit	function
(	O
abfd	pointer
,	O
strtab	pointer
)	O
)	O
return	O
FALSE	int
;	O
_bfd_elf_strtab_free	function
(	O
strtab	pointer
)	O
;	O
}	O
abfd	pointer
->	O
output_has_begun	int
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_size_type	long
get_program_header_size	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
size_t	long
segs	long
;	O
asection	struct
*	O
s	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
segs	long
=	O
2	int
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".interp"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
s	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
segs	long
+=	O
2	int
;	O
}	O
if	O
(	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynamic"	pointer
)	O
!=	O
NULL	O
)	O
{	O
++	O
segs	long
;	O
}	O
if	O
(	O
info	pointer
!=	O
NULL	O
&&	O
info	pointer
->	O
relro	int
)	O
{	O
++	O
segs	long
;	O
}	O
if	O
(	O
elf_eh_frame_hdr	O
(	O
abfd	pointer
)	O
)	O
{	O
++	O
segs	long
;	O
}	O
if	O
(	O
elf_stack_flags	O
(	O
abfd	pointer
)	O
)	O
{	O
++	O
segs	long
;	O
}	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
NOTE_GNU_PROPERTY_SECTION_NAME	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
++	O
segs	long
;	O
}	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
elf_section_type	O
(	O
s	pointer
)	O
==	O
SHT_NOTE	int
)	O
{	O
unsigned	O
int	O
alignment_power	int
;	O
++	O
segs	long
;	O
alignment_power	int
=	O
s	pointer
->	O
alignment_power	int
;	O
while	O
(	O
s	pointer
->	O
next	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
next	pointer
->	O
alignment_power	int
==	O
alignment_power	int
&&	O
(	O
s	pointer
->	O
next	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
elf_section_type	O
(	O
s	pointer
->	O
next	pointer
)	O
==	O
SHT_NOTE	int
)	O
s	pointer
=	O
s	pointer
->	O
next	pointer
;	O
}	O
}	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
{	O
++	O
segs	long
;	O
break	O
;	O
}	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
&&	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_mbind	int
)	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
page_align_power	int
=	O
bfd_log2	function
(	O
bed	pointer
->	O
commonpagesize	long
)	O
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
elf_section_flags	O
(	O
s	pointer
)	O
&	O
SHF_GNU_MBIND	int
)	O
{	O
if	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
>	O
PT_GNU_MBIND_NUM	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: GNU_MBIND section `%pA' has invalid "	pointer
"sh_info field: %d"	pointer
)	O
,	O
abfd	pointer
,	O
s	pointer
,	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
s	pointer
->	O
alignment_power	int
<	O
page_align_power	int
)	O
s	pointer
->	O
alignment_power	int
=	O
page_align_power	int
;	O
segs	long
++	O
;	O
}	O
}	O
if	O
(	O
bed	pointer
->	O
elf_backend_additional_program_headers	pointer
)	O
{	O
int	O
a	pointer
;	O
a	pointer
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_additional_program_headers	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
a	pointer
==	O
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
segs	long
+=	O
a	pointer
;	O
}	O
return	O
segs	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
}	O
Elf_Internal_Phdr	struct
*	O
_bfd_elf_find_segment_containing_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
)	O
{	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
Elf_Internal_Phdr	struct
*	O
p	pointer
;	O
for	O
(	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
,	O
p	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
,	O
p	pointer
++	O
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
m	pointer
->	O
count	int
-	O
1	int
;	O
i	pointer
>=	O
0	int
;	O
i	pointer
--	O
)	O
if	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
==	O
section	pointer
)	O
return	O
p	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
elf_segment_map	struct
*	O
make_mapping	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
*	O
sections	pointer
,	O
unsigned	O
int	O
from	pointer
,	O
unsigned	O
int	O
to	pointer
,	O
bfd_boolean	int
phdr	pointer
)	O
{	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
asection	struct
*	O
*	O
hdrpp	pointer
;	O
bfd_size_type	long
amt	long
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
-	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
amt	long
+=	O
(	O
to	pointer
-	O
from	pointer
)	O
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_LOAD	int
;	O
for	O
(	O
i	pointer
=	O
from	pointer
,	O
hdrpp	pointer
=	O
sections	pointer
+	O
from	pointer
;	O
i	pointer
<	O
to	pointer
;	O
i	pointer
++	O
,	O
hdrpp	pointer
++	O
)	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
-	O
from	pointer
]	O
=	O
*	O
hdrpp	pointer
;	O
m	pointer
->	O
count	int
=	O
to	pointer
-	O
from	pointer
;	O
if	O
(	O
from	pointer
==	O
0	int
&&	O
phdr	pointer
)	O
{	O
m	pointer
->	O
includes_filehdr	int
=	O
1	int
;	O
m	pointer
->	O
includes_phdrs	int
=	O
1	int
;	O
}	O
return	O
m	pointer
;	O
}	O
struct	O
elf_segment_map	struct
*	O
_bfd_elf_make_dynamic_segment	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
dynsec	pointer
)	O
{	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_DYNAMIC	int
;	O
m	pointer
->	O
count	int
=	O
1	int
;	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
=	O
dynsec	pointer
;	O
return	O
m	pointer
;	O
}	O
static	O
bfd_boolean	int
elf_modify_segment_map	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_boolean	int
remove_empty_load	int
)	O
{	O
struct	O
elf_segment_map	struct
*	O
*	O
m	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
m	pointer
=	O
&	O
elf_seg_map	O
(	O
abfd	pointer
)	O
;	O
while	O
(	O
*	O
m	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
,	O
new_count	int
;	O
for	O
(	O
new_count	int
=	O
0	int
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
(	O
*	O
m	pointer
)	O
->	O
count	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
(	O
(	O
*	O
m	pointer
)	O
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
(	O
(	O
(	O
*	O
m	pointer
)	O
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
||	O
(	O
*	O
m	pointer
)	O
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
)	O
{	O
(	O
*	O
m	pointer
)	O
->	O
sections	pointer
[	O
new_count	int
]	O
=	O
(	O
*	O
m	pointer
)	O
->	O
sections	pointer
[	O
i	pointer
]	O
;	O
new_count	int
++	O
;	O
}	O
}	O
(	O
*	O
m	pointer
)	O
->	O
count	int
=	O
new_count	int
;	O
if	O
(	O
remove_empty_load	int
&&	O
(	O
*	O
m	pointer
)	O
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
(	O
*	O
m	pointer
)	O
->	O
count	int
==	O
0	int
&&	O
!	O
(	O
*	O
m	pointer
)	O
->	O
includes_phdrs	int
)	O
*	O
m	pointer
=	O
(	O
*	O
m	pointer
)	O
->	O
next	pointer
;	O
else	O
m	pointer
=	O
&	O
(	O
*	O
m	pointer
)	O
->	O
next	pointer
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_modify_segment_map	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_modify_segment_map	pointer
)	O
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_map_sections_to_segments	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
unsigned	O
int	O
count	int
;	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
asection	struct
*	O
*	O
sections	pointer
=	O
NULL	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_boolean	int
no_user_phdrs	int
;	O
no_user_phdrs	int
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
==	O
NULL	O
;	O
if	O
(	O
info	pointer
!=	O
NULL	O
)	O
info	pointer
->	O
user_phdrs	int
=	O
!	O
no_user_phdrs	int
;	O
if	O
(	O
no_user_phdrs	int
&&	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
struct	O
elf_segment_map	struct
*	O
mfirst	pointer
;	O
struct	O
elf_segment_map	struct
*	O
*	O
pm	pointer
;	O
asection	struct
*	O
last_hdr	pointer
;	O
bfd_vma	long
last_size	long
;	O
unsigned	O
int	O
hdr_index	int
;	O
bfd_vma	long
maxpagesize	long
;	O
asection	struct
*	O
*	O
hdrpp	pointer
;	O
bfd_boolean	int
phdr_in_segment	int
;	O
bfd_boolean	int
writable	int
;	O
bfd_boolean	int
executable	pointer
;	O
int	O
tls_count	int
=	O
0	int
;	O
asection	struct
*	O
first_tls	pointer
=	O
NULL	O
;	O
asection	struct
*	O
first_mbind	pointer
=	O
NULL	O
;	O
asection	struct
*	O
dynsec	pointer
,	O
*	O
eh_frame_hdr	pointer
;	O
bfd_size_type	long
amt	long
;	O
bfd_vma	long
addr_mask	long
,	O
wrap_to	long
=	O
0	int
;	O
bfd_size_type	long
phdr_size	long
;	O
sections	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
bfd_malloc2	function
(	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
,	O
sizeof	O
(	O
asection	struct
*	O
)	O
)	O
;	O
if	O
(	O
sections	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
addr_mask	long
=	O
(	O
(	O
bfd_vma	long
)	O
1	int
<<	O
(	O
bfd_arch_bits_per_address	function
(	O
abfd	pointer
)	O
-	O
1	int
)	O
)	O
-	O
1	int
;	O
addr_mask	long
=	O
(	O
addr_mask	long
<<	O
1	int
)	O
+	O
1	int
;	O
i	pointer
=	O
0	int
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
s	pointer
->	O
target_index	int
=	O
i	pointer
;	O
sections	pointer
[	O
i	pointer
]	O
=	O
s	pointer
;	O
++	O
i	pointer
;	O
if	O
(	O
(	O
(	O
s	pointer
->	O
lma	long
+	O
s	pointer
->	O
size	long
)	O
&	O
addr_mask	long
)	O
<	O
(	O
s	pointer
->	O
lma	long
&	O
addr_mask	long
)	O
)	O
wrap_to	long
=	O
(	O
s	pointer
->	O
lma	long
+	O
s	pointer
->	O
size	long
)	O
&	O
addr_mask	long
;	O
}	O
}	O
BFD_ASSERT	O
(	O
i	pointer
<=	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
)	O
;	O
count	int
=	O
i	pointer
;	O
qsort	function
(	O
sections	pointer
,	O
(	O
size_t	long
)	O
count	int
,	O
sizeof	O
(	O
asection	struct
*	O
)	O
,	O
elf_sort_sections	function
)	O
;	O
phdr_size	long
=	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
phdr_size	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
phdr_size	long
=	O
get_program_header_size	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
phdr_size	long
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
maxpagesize	long
=	O
bed	pointer
->	O
maxpagesize	long
;	O
if	O
(	O
maxpagesize	long
==	O
0	int
)	O
maxpagesize	long
=	O
1	int
;	O
phdr_in_segment	int
=	O
info	pointer
!=	O
NULL	O
&&	O
info	pointer
->	O
load_phdrs	int
;	O
if	O
(	O
count	int
!=	O
0	int
&&	O
(	O
(	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
&	O
addr_mask	long
)	O
&	O
(	O
maxpagesize	long
-	O
1	int
)	O
)	O
>=	O
(	O
phdr_size	long
&	O
(	O
maxpagesize	long
-	O
1	int
)	O
)	O
)	O
)	O
phdr_in_segment	int
=	O
TRUE	int
;	O
mfirst	pointer
=	O
NULL	O
;	O
pm	pointer
=	O
&	O
mfirst	pointer
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".interp"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
s	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_PHDR	int
;	O
m	pointer
->	O
p_flags	array
=	O
PF_R	O
;	O
m	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
m	pointer
->	O
includes_phdrs	int
=	O
1	int
;	O
phdr_in_segment	int
=	O
TRUE	int
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_INTERP	int
;	O
m	pointer
->	O
count	int
=	O
1	int
;	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
=	O
s	pointer
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
last_hdr	pointer
=	O
NULL	O
;	O
last_size	long
=	O
0	int
;	O
hdr_index	int
=	O
0	int
;	O
writable	int
=	O
FALSE	int
;	O
executable	pointer
=	O
FALSE	int
;	O
dynsec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
dynsec	pointer
!=	O
NULL	O
&&	O
(	O
dynsec	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
)	O
dynsec	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
==	O
0	int
)	O
phdr_in_segment	int
=	O
FALSE	int
;	O
if	O
(	O
phdr_in_segment	int
&&	O
count	int
>	O
0	int
)	O
{	O
bfd_vma	long
phdr_lma	long
;	O
bfd_boolean	int
separate_phdr	int
=	O
FALSE	int
;	O
phdr_lma	long
=	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
-	O
phdr_size	long
)	O
&	O
addr_mask	long
&	O
-	O
maxpagesize	long
;	O
if	O
(	O
info	pointer
!=	O
NULL	O
&&	O
info	pointer
->	O
separate_code	int
&&	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
{	O
separate_phdr	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
(	O
(	O
phdr_lma	long
+	O
phdr_size	long
-	O
1	int
)	O
&	O
addr_mask	long
&	O
-	O
maxpagesize	long
)	O
==	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
&	O
addr_mask	long
&	O
-	O
maxpagesize	long
)	O
)	O
)	O
{	O
if	O
(	O
phdr_lma	long
>=	O
maxpagesize	long
)	O
phdr_lma	long
-=	O
maxpagesize	long
;	O
else	O
separate_phdr	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
&	O
addr_mask	long
)	O
<	O
phdr_lma	long
||	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
&	O
addr_mask	long
)	O
<	O
phdr_size	long
)	O
phdr_in_segment	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
phdr_lma	long
<	O
wrap_to	long
)	O
phdr_in_segment	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
separate_phdr	int
)	O
{	O
m	pointer
=	O
make_mapping	function
(	O
abfd	pointer
,	O
sections	pointer
,	O
0	int
,	O
0	int
,	O
phdr_in_segment	int
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
p_paddr	array
=	O
phdr_lma	long
;	O
m	pointer
->	O
p_vaddr_offset	long
=	O
(	O
sections	pointer
[	O
0	int
]	O
->	O
vma	long
-	O
phdr_size	long
)	O
&	O
addr_mask	long
&	O
-	O
maxpagesize	long
;	O
m	pointer
->	O
p_paddr_valid	int
=	O
1	int
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
phdr_in_segment	int
=	O
FALSE	int
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
hdrpp	pointer
=	O
sections	pointer
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
,	O
hdrpp	pointer
++	O
)	O
{	O
asection	struct
*	O
hdr	pointer
;	O
bfd_boolean	int
new_segment	int
;	O
hdr	pointer
=	O
*	O
hdrpp	pointer
;	O
if	O
(	O
last_hdr	pointer
==	O
NULL	O
)	O
{	O
new_segment	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
last_hdr	pointer
->	O
lma	long
-	O
last_hdr	pointer
->	O
vma	long
!=	O
hdr	pointer
->	O
lma	long
-	O
hdr	pointer
->	O
vma	long
)	O
{	O
new_segment	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
hdr	pointer
->	O
lma	long
<	O
last_hdr	pointer
->	O
lma	long
+	O
last_size	long
||	O
last_hdr	pointer
->	O
lma	long
+	O
last_size	long
<	O
last_hdr	pointer
->	O
lma	long
)	O
{	O
new_segment	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
&&	O
(	O
(	O
(	O
last_hdr	pointer
->	O
lma	long
+	O
last_size	long
-	O
1	int
)	O
&	O
-	O
maxpagesize	long
)	O
==	O
(	O
hdr	pointer
->	O
lma	long
&	O
-	O
maxpagesize	long
)	O
)	O
)	O
{	O
new_segment	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
(	O
BFD_ALIGN	O
(	O
last_hdr	pointer
->	O
lma	long
+	O
last_size	long
,	O
maxpagesize	long
)	O
+	O
maxpagesize	long
>	O
last_hdr	pointer
->	O
lma	long
)	O
&&	O
(	O
BFD_ALIGN	O
(	O
last_hdr	pointer
->	O
lma	long
+	O
last_size	long
,	O
maxpagesize	long
)	O
+	O
maxpagesize	long
<=	O
hdr	pointer
->	O
lma	long
)	O
)	O
{	O
new_segment	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
last_hdr	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
==	O
0	int
&&	O
(	O
hdr	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
!=	O
0	int
)	O
{	O
new_segment	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
==	O
0	int
)	O
{	O
new_segment	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
info	pointer
!=	O
NULL	O
&&	O
info	pointer
->	O
separate_code	int
&&	O
executable	pointer
!=	O
(	O
(	O
hdr	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
)	O
{	O
new_segment	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
!	O
writable	int
&&	O
(	O
hdr	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
{	O
new_segment	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
new_segment	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
last_hdr	pointer
!=	O
NULL	O
&&	O
info	pointer
!=	O
NULL	O
&&	O
info	pointer
->	O
callbacks	pointer
->	O
override_segment_assignment	pointer
!=	O
NULL	O
)	O
new_segment	int
=	O
info	pointer
->	O
callbacks	pointer
->	O
override_segment_assignment	pointer
(	O
info	pointer
,	O
abfd	pointer
,	O
hdr	pointer
,	O
last_hdr	pointer
,	O
new_segment	int
)	O
;	O
if	O
(	O
!	O
new_segment	int
)	O
{	O
if	O
(	O
(	O
hdr	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
writable	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
executable	pointer
=	O
TRUE	int
;	O
last_hdr	pointer
=	O
hdr	pointer
;	O
last_size	long
=	O
!	O
IS_TBSS	O
(	O
hdr	pointer
)	O
?	O
hdr	pointer
->	O
size	long
:	O
0	int
;	O
continue	O
;	O
}	O
m	pointer
=	O
make_mapping	function
(	O
abfd	pointer
,	O
sections	pointer
,	O
hdr_index	int
,	O
i	pointer
,	O
phdr_in_segment	int
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
if	O
(	O
(	O
hdr	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
writable	int
=	O
TRUE	int
;	O
else	O
writable	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
hdr	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
executable	pointer
=	O
FALSE	int
;	O
else	O
executable	pointer
=	O
TRUE	int
;	O
last_hdr	pointer
=	O
hdr	pointer
;	O
last_size	long
=	O
!	O
IS_TBSS	O
(	O
hdr	pointer
)	O
?	O
hdr	pointer
->	O
size	long
:	O
0	int
;	O
hdr_index	int
=	O
i	pointer
;	O
phdr_in_segment	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
last_hdr	pointer
!=	O
NULL	O
&&	O
(	O
i	pointer
-	O
hdr_index	int
!=	O
1	int
||	O
!	O
IS_TBSS	O
(	O
last_hdr	pointer
)	O
)	O
)	O
{	O
m	pointer
=	O
make_mapping	function
(	O
abfd	pointer
,	O
sections	pointer
,	O
hdr_index	int
,	O
i	pointer
,	O
phdr_in_segment	int
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
dynsec	pointer
!=	O
NULL	O
)	O
{	O
m	pointer
=	O
_bfd_elf_make_dynamic_segment	function
(	O
abfd	pointer
,	O
dynsec	pointer
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
elf_section_type	O
(	O
s	pointer
)	O
==	O
SHT_NOTE	int
)	O
{	O
asection	struct
*	O
s2	pointer
;	O
unsigned	O
int	O
alignment_power	int
=	O
s	pointer
->	O
alignment_power	int
;	O
count	int
=	O
1	int
;	O
for	O
(	O
s2	pointer
=	O
s	pointer
;	O
s2	pointer
->	O
next	pointer
!=	O
NULL	O
;	O
s2	pointer
=	O
s2	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s2	pointer
->	O
next	pointer
->	O
alignment_power	int
==	O
alignment_power	int
&&	O
(	O
s2	pointer
->	O
next	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
elf_section_type	O
(	O
s2	pointer
->	O
next	pointer
)	O
==	O
SHT_NOTE	int
&&	O
align_power	int
(	O
s2	pointer
->	O
lma	long
+	O
s2	pointer
->	O
size	long
,	O
alignment_power	int
)	O
==	O
s2	pointer
->	O
next	pointer
->	O
lma	long
)	O
count	int
++	O
;	O
else	O
break	O
;	O
}	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
-	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
amt	long
+=	O
count	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_NOTE	int
;	O
m	pointer
->	O
count	int
=	O
count	int
;	O
while	O
(	O
count	int
>	O
1	int
)	O
{	O
m	pointer
->	O
sections	pointer
[	O
m	pointer
->	O
count	int
-	O
count	int
--	O
]	O
=	O
s	pointer
;	O
BFD_ASSERT	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
==	O
0	int
)	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
;	O
}	O
m	pointer
->	O
sections	pointer
[	O
m	pointer
->	O
count	int
-	O
1	int
]	O
=	O
s	pointer
;	O
BFD_ASSERT	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
==	O
0	int
)	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
{	O
if	O
(	O
!	O
tls_count	int
)	O
first_tls	pointer
=	O
s	pointer
;	O
tls_count	int
++	O
;	O
}	O
if	O
(	O
first_mbind	pointer
==	O
NULL	O
&&	O
(	O
elf_section_flags	O
(	O
s	pointer
)	O
&	O
SHF_GNU_MBIND	int
)	O
!=	O
0	int
)	O
first_mbind	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
tls_count	int
>	O
0	int
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
-	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
amt	long
+=	O
tls_count	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_TLS	int
;	O
m	pointer
->	O
count	int
=	O
tls_count	int
;	O
m	pointer
->	O
p_flags	array
=	O
PF_R	O
;	O
m	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
s	pointer
=	O
first_tls	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
(	O
unsigned	O
int	O
)	O
tls_count	int
;	O
++	O
i	pointer
)	O
{	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
==	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: TLS sections are not adjacent:"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
s	pointer
=	O
first_tls	pointer
;	O
i	pointer
=	O
0	int
;	O
while	O
(	O
i	pointer
<	O
(	O
unsigned	O
int	O
)	O
tls_count	int
)	O
{	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"	    TLS: %pA"	pointer
)	O
,	O
s	pointer
)	O
;	O
i	pointer
++	O
;	O
}	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"	non-TLS: %pA"	pointer
)	O
,	O
s	pointer
)	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
;	O
}	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
=	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
;	O
}	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
first_mbind	pointer
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
&&	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_mbind	int
)	O
!=	O
0	int
)	O
for	O
(	O
s	pointer
=	O
first_mbind	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
elf_section_flags	O
(	O
s	pointer
)	O
&	O
SHF_GNU_MBIND	int
)	O
!=	O
0	int
&&	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
<=	O
PT_GNU_MBIND_NUM	int
)	O
{	O
unsigned	O
long	O
p_flags	array
=	O
PF_R	O
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
p_flags	array
|=	O
PF_W	O
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
p_flags	array
|=	O
PF_X	O
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
+	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
m	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
(	O
PT_GNU_MBIND_LO	O
+	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
)	O
;	O
m	pointer
->	O
count	int
=	O
1	int
;	O
m	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
=	O
s	pointer
;	O
m	pointer
->	O
p_flags	array
=	O
p_flags	array
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
NOTE_GNU_PROPERTY_SECTION_NAME	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
+	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
m	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_GNU_PROPERTY	O
;	O
m	pointer
->	O
count	int
=	O
1	int
;	O
m	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
=	O
s	pointer
;	O
m	pointer
->	O
p_flags	array
=	O
PF_R	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
eh_frame_hdr	pointer
=	O
elf_eh_frame_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
eh_frame_hdr	pointer
!=	O
NULL	O
&&	O
(	O
eh_frame_hdr	pointer
->	O
output_section	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_GNU_EH_FRAME	O
;	O
m	pointer
->	O
count	int
=	O
1	int
;	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
=	O
eh_frame_hdr	pointer
->	O
output_section	pointer
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
elf_stack_flags	O
(	O
abfd	pointer
)	O
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_GNU_STACK	O
;	O
m	pointer
->	O
p_flags	array
=	O
elf_stack_flags	O
(	O
abfd	pointer
)	O
;	O
m	pointer
->	O
p_align	array
=	O
bed	pointer
->	O
stack_align	int
;	O
m	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
m	pointer
->	O
p_align_valid	int
=	O
m	pointer
->	O
p_align	array
!=	O
0	int
;	O
if	O
(	O
info	pointer
->	O
stacksize	long
>	O
0	int
)	O
{	O
m	pointer
->	O
p_size	long
=	O
info	pointer
->	O
stacksize	long
;	O
m	pointer
->	O
p_size_valid	int
=	O
1	int
;	O
}	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
info	pointer
!=	O
NULL	O
&&	O
info	pointer
->	O
relro	int
)	O
{	O
for	O
(	O
m	pointer
=	O
mfirst	pointer
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
m	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
m	pointer
->	O
count	int
!=	O
0	int
&&	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
vma	long
>=	O
info	pointer
->	O
relro_start	long
&&	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
vma	long
<	O
info	pointer
->	O
relro_end	long
)	O
{	O
i	pointer
=	O
m	pointer
->	O
count	int
;	O
while	O
(	O
--	O
i	pointer
!=	O
(	O
unsigned	O
)	O
-	O
1	int
)	O
if	O
(	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
==	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
break	O
;	O
if	O
(	O
i	pointer
!=	O
(	O
unsigned	O
)	O
-	O
1	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
m	pointer
!=	O
NULL	O
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
m	pointer
->	O
next	pointer
=	O
NULL	O
;	O
m	pointer
->	O
p_type	array
=	O
PT_GNU_RELRO	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
pm	pointer
=	O
&	O
m	pointer
->	O
next	pointer
;	O
}	O
}	O
free	function
(	O
sections	pointer
)	O
;	O
elf_seg_map	O
(	O
abfd	pointer
)	O
=	O
mfirst	pointer
;	O
}	O
if	O
(	O
!	O
elf_modify_segment_map	function
(	O
abfd	pointer
,	O
info	pointer
,	O
no_user_phdrs	int
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
count	int
=	O
0	int
,	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
++	O
count	int
;	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
=	O
count	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
sections	pointer
!=	O
NULL	O
)	O
free	function
(	O
sections	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
int	O
elf_sort_sections	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
asection	struct
*	O
sec1	pointer
=	O
*	O
(	O
const	O
asection	struct
*	O
*	O
)	O
arg1	pointer
;	O
const	O
asection	struct
*	O
sec2	pointer
=	O
*	O
(	O
const	O
asection	struct
*	O
*	O
)	O
arg2	pointer
;	O
bfd_size_type	long
size1	long
,	O
size2	long
;	O
if	O
(	O
sec1	pointer
->	O
lma	long
<	O
sec2	pointer
->	O
lma	long
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
lma	long
>	O
sec2	pointer
->	O
lma	long
)	O
return	O
1	int
;	O
if	O
(	O
sec1	pointer
->	O
vma	long
<	O
sec2	pointer
->	O
vma	long
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
sec1	pointer
->	O
vma	long
>	O
sec2	pointer
->	O
vma	long
)	O
return	O
1	int
;	O
if	O
(	O
TOEND	O
(	O
sec1	pointer
)	O
)	O
{	O
if	O
(	O
!	O
TOEND	O
(	O
sec2	pointer
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
TOEND	O
(	O
sec2	pointer
)	O
)	O
return	O
-	O
1	int
;	O
size1	long
=	O
(	O
sec1	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
?	O
sec1	pointer
->	O
size	long
:	O
0	int
;	O
size2	long
=	O
(	O
sec2	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
?	O
sec2	pointer
->	O
size	long
:	O
0	int
;	O
if	O
(	O
size1	long
<	O
size2	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
size1	long
>	O
size2	long
)	O
return	O
1	int
;	O
return	O
sec1	pointer
->	O
target_index	int
-	O
sec2	pointer
->	O
target_index	int
;	O
}	O
static	O
int	O
elf_sort_segments	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
struct	O
elf_segment_map	struct
*	O
m1	pointer
=	O
*	O
(	O
const	O
struct	O
elf_segment_map	struct
*	O
*	O
)	O
arg1	pointer
;	O
const	O
struct	O
elf_segment_map	struct
*	O
m2	pointer
=	O
*	O
(	O
const	O
struct	O
elf_segment_map	struct
*	O
*	O
)	O
arg2	pointer
;	O
if	O
(	O
m1	pointer
->	O
p_type	array
!=	O
m2	pointer
->	O
p_type	array
)	O
{	O
if	O
(	O
m1	pointer
->	O
p_type	array
==	O
PT_NULL	int
)	O
return	O
1	int
;	O
if	O
(	O
m2	pointer
->	O
p_type	array
==	O
PT_NULL	int
)	O
return	O
-	O
1	int
;	O
return	O
m1	pointer
->	O
p_type	array
<	O
m2	pointer
->	O
p_type	array
?	O
-	O
1	int
:	O
1	int
;	O
}	O
if	O
(	O
m1	pointer
->	O
includes_filehdr	int
!=	O
m2	pointer
->	O
includes_filehdr	int
)	O
return	O
m1	pointer
->	O
includes_filehdr	int
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
m1	pointer
->	O
no_sort_lma	int
!=	O
m2	pointer
->	O
no_sort_lma	int
)	O
return	O
m1	pointer
->	O
no_sort_lma	int
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
m1	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
!	O
m1	pointer
->	O
no_sort_lma	int
)	O
{	O
bfd_vma	long
lma1	long
,	O
lma2	long
;	O
lma1	long
=	O
0	int
;	O
if	O
(	O
m1	pointer
->	O
p_paddr_valid	int
)	O
lma1	long
=	O
m1	pointer
->	O
p_paddr	array
;	O
else	O
if	O
(	O
m1	pointer
->	O
count	int
!=	O
0	int
)	O
lma1	long
=	O
m1	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
+	O
m1	pointer
->	O
p_vaddr_offset	long
;	O
lma2	long
=	O
0	int
;	O
if	O
(	O
m2	pointer
->	O
p_paddr_valid	int
)	O
lma2	long
=	O
m2	pointer
->	O
p_paddr	array
;	O
else	O
if	O
(	O
m2	pointer
->	O
count	int
!=	O
0	int
)	O
lma2	long
=	O
m2	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
+	O
m2	pointer
->	O
p_vaddr_offset	long
;	O
if	O
(	O
lma1	long
!=	O
lma2	long
)	O
return	O
lma1	long
<	O
lma2	long
?	O
-	O
1	int
:	O
1	int
;	O
}	O
if	O
(	O
m1	pointer
->	O
idx	int
!=	O
m2	pointer
->	O
idx	int
)	O
return	O
m1	pointer
->	O
idx	int
<	O
m2	pointer
->	O
idx	int
?	O
-	O
1	int
:	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
file_ptr	long
vma_page_aligned_bias	function
(	O
bfd_vma	long
vma	long
,	O
ufile_ptr	long
off	long
,	O
bfd_vma	long
maxpagesize	long
)	O
{	O
if	O
(	O
maxpagesize	long
==	O
0	int
)	O
maxpagesize	long
=	O
1	int
;	O
return	O
(	O
(	O
vma	long
-	O
off	long
)	O
%	O
maxpagesize	long
)	O
;	O
}	O
static	O
void	O
print_segment_map	function
(	O
const	O
struct	O
elf_segment_map	struct
*	O
m	pointer
)	O
{	O
unsigned	O
int	O
j	int
;	O
const	O
char	O
*	O
pt	pointer
=	O
get_segment_type	function
(	O
m	pointer
->	O
p_type	array
)	O
;	O
char	O
buf	pointer
[	O
32	int
]	O
;	O
if	O
(	O
pt	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
m	pointer
->	O
p_type	array
>=	O
PT_LOPROC	int
&&	O
m	pointer
->	O
p_type	array
<=	O
PT_HIPROC	int
)	O
sprintf	function
(	O
buf	pointer
,	O
"LOPROC+%7.7x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
m	pointer
->	O
p_type	array
-	O
PT_LOPROC	int
)	O
)	O
;	O
else	O
if	O
(	O
m	pointer
->	O
p_type	array
>=	O
PT_LOOS	int
&&	O
m	pointer
->	O
p_type	array
<=	O
PT_HIOS	int
)	O
sprintf	function
(	O
buf	pointer
,	O
"LOOS+%7.7x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
m	pointer
->	O
p_type	array
-	O
PT_LOOS	int
)	O
)	O
;	O
else	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%8.8x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
m	pointer
->	O
p_type	array
)	O
;	O
pt	pointer
=	O
buf	pointer
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:"	pointer
,	O
pt	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	pointer
->	O
count	int
;	O
j	int
++	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
" %s"	pointer
,	O
m	pointer
->	O
sections	pointer
[	O
j	int
]	O
->	O
name	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
write_zeros	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
file_ptr	long
pos	long
,	O
bfd_size_type	long
len	long
)	O
{	O
void	O
*	O
buf	pointer
;	O
bfd_boolean	int
ret	pointer
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
buf	pointer
=	O
bfd_zmalloc	function
(	O
len	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
ret	pointer
=	O
bfd_bwrite	function
(	O
buf	pointer
,	O
len	long
,	O
abfd	pointer
)	O
==	O
len	long
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
assign_file_positions_for_load_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
struct	O
elf_segment_map	struct
*	O
phdr_load_seg	pointer
;	O
Elf_Internal_Phdr	struct
*	O
phdrs	pointer
;	O
Elf_Internal_Phdr	struct
*	O
p	pointer
;	O
file_ptr	long
off	long
;	O
bfd_size_type	long
maxpagesize	long
;	O
unsigned	O
int	O
alloc	int
,	O
actual	int
;	O
unsigned	O
int	O
i	pointer
,	O
j	int
;	O
struct	O
elf_segment_map	struct
*	O
*	O
sorted_seg_map	pointer
;	O
if	O
(	O
link_info	pointer
==	O
NULL	O
&&	O
!	O
_bfd_elf_map_sections_to_segments	function
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
alloc	int
=	O
0	int
;	O
for	O
(	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
m	pointer
->	O
idx	int
=	O
alloc	int
++	O
;	O
if	O
(	O
alloc	int
)	O
{	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phoff	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phentsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
}	O
else	O
{	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phoff	array
=	O
0	int
;	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phentsize	array
=	O
0	int
;	O
}	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
=	O
alloc	int
;	O
if	O
(	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
{	O
actual	int
=	O
alloc	int
;	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
=	O
alloc	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
}	O
else	O
{	O
actual	int
=	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
BFD_ASSERT	O
(	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
==	O
actual	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
)	O
;	O
BFD_ASSERT	O
(	O
actual	int
>=	O
alloc	int
)	O
;	O
}	O
if	O
(	O
alloc	int
==	O
0	int
)	O
{	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
return	O
TRUE	int
;	O
}	O
phdrs	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
(	O
actual	int
*	O
sizeof	O
(	O
*	O
phdrs	pointer
)	O
+	O
alloc	int
*	O
sizeof	O
(	O
*	O
sorted_seg_map	pointer
)	O
)	O
)	O
;	O
sorted_seg_map	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
*	O
)	O
(	O
phdrs	pointer
+	O
actual	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
=	O
phdrs	pointer
;	O
if	O
(	O
phdrs	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
,	O
j	int
=	O
0	int
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
,	O
j	int
++	O
)	O
{	O
sorted_seg_map	pointer
[	O
j	int
]	O
=	O
m	pointer
;	O
if	O
(	O
m	pointer
->	O
count	int
>	O
1	int
&&	O
!	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_type	array
==	O
ET_CORE	int
&&	O
m	pointer
->	O
p_type	array
==	O
PT_NOTE	int
)	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
target_index	int
=	O
i	pointer
;	O
qsort	function
(	O
m	pointer
->	O
sections	pointer
,	O
(	O
size_t	long
)	O
m	pointer
->	O
count	int
,	O
sizeof	O
(	O
asection	struct
*	O
)	O
,	O
elf_sort_sections	function
)	O
;	O
}	O
}	O
if	O
(	O
alloc	int
>	O
1	int
)	O
qsort	function
(	O
sorted_seg_map	pointer
,	O
alloc	int
,	O
sizeof	O
(	O
*	O
sorted_seg_map	pointer
)	O
,	O
elf_sort_segments	function
)	O
;	O
maxpagesize	long
=	O
1	int
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
)	O
maxpagesize	long
=	O
bed	pointer
->	O
maxpagesize	long
;	O
off	long
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
phdr_load_seg	pointer
=	O
NULL	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
alloc	int
;	O
j	int
++	O
)	O
{	O
m	pointer
=	O
sorted_seg_map	pointer
[	O
j	int
]	O
;	O
if	O
(	O
m	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
break	O
;	O
if	O
(	O
m	pointer
->	O
includes_phdrs	int
)	O
{	O
phdr_load_seg	pointer
=	O
m	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
phdr_load_seg	pointer
==	O
NULL	O
)	O
off	long
+=	O
actual	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
alloc	int
;	O
j	int
++	O
)	O
{	O
asection	struct
*	O
*	O
secpp	pointer
;	O
bfd_vma	long
off_adjust	long
;	O
bfd_boolean	int
no_contents	int
;	O
m	pointer
=	O
sorted_seg_map	pointer
[	O
j	int
]	O
;	O
p	pointer
=	O
phdrs	pointer
+	O
m	pointer
->	O
idx	int
;	O
p	pointer
->	O
p_type	array
=	O
m	pointer
->	O
p_type	array
;	O
p	pointer
->	O
p_flags	array
=	O
m	pointer
->	O
p_flags	array
;	O
if	O
(	O
m	pointer
->	O
count	int
==	O
0	int
)	O
p	pointer
->	O
p_vaddr	array
=	O
m	pointer
->	O
p_vaddr_offset	long
;	O
else	O
p	pointer
->	O
p_vaddr	array
=	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
vma	long
+	O
m	pointer
->	O
p_vaddr_offset	long
;	O
if	O
(	O
m	pointer
->	O
p_paddr_valid	int
)	O
p	pointer
->	O
p_paddr	array
=	O
m	pointer
->	O
p_paddr	array
;	O
else	O
if	O
(	O
m	pointer
->	O
count	int
==	O
0	int
)	O
p	pointer
->	O
p_paddr	array
=	O
0	int
;	O
else	O
p	pointer
->	O
p_paddr	array
=	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
lma	long
+	O
m	pointer
->	O
p_vaddr_offset	long
;	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
m	pointer
->	O
p_align_valid	int
)	O
maxpagesize	long
=	O
m	pointer
->	O
p_align	array
;	O
p	pointer
->	O
p_align	array
=	O
maxpagesize	long
;	O
}	O
else	O
if	O
(	O
m	pointer
->	O
p_align_valid	int
)	O
p	pointer
->	O
p_align	array
=	O
m	pointer
->	O
p_align	array
;	O
else	O
if	O
(	O
m	pointer
->	O
count	int
==	O
0	int
)	O
p	pointer
->	O
p_align	array
=	O
1	int
<<	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
if	O
(	O
m	pointer
==	O
phdr_load_seg	pointer
)	O
{	O
if	O
(	O
!	O
m	pointer
->	O
includes_filehdr	int
)	O
p	pointer
->	O
p_offset	array
=	O
off	long
;	O
off	long
+=	O
actual	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
}	O
no_contents	int
=	O
FALSE	int
;	O
off_adjust	long
=	O
0	int
;	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
m	pointer
->	O
count	int
>	O
0	int
)	O
{	O
bfd_size_type	long
align	long
;	O
unsigned	O
int	O
align_power	int
=	O
0	int
;	O
if	O
(	O
m	pointer
->	O
p_align_valid	int
)	O
align	long
=	O
p	pointer
->	O
p_align	array
;	O
else	O
{	O
for	O
(	O
i	pointer
=	O
0	int
,	O
secpp	pointer
=	O
m	pointer
->	O
sections	pointer
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
,	O
secpp	pointer
++	O
)	O
{	O
unsigned	O
int	O
secalign	int
;	O
secalign	int
=	O
bfd_section_alignment	function
(	O
*	O
secpp	pointer
)	O
;	O
if	O
(	O
secalign	int
>	O
align_power	int
)	O
align_power	int
=	O
secalign	int
;	O
}	O
align	long
=	O
(	O
bfd_size_type	long
)	O
1	int
<<	O
align_power	int
;	O
if	O
(	O
align	long
<	O
maxpagesize	long
)	O
align	long
=	O
maxpagesize	long
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
==	O
0	int
)	O
elf_section_type	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
)	O
=	O
SHT_NOBITS	int
;	O
no_contents	int
=	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
elf_section_type	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
)	O
!=	O
SHT_NOBITS	int
)	O
{	O
no_contents	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
off_adjust	long
=	O
vma_page_aligned_bias	function
(	O
p	pointer
->	O
p_vaddr	array
,	O
off	long
,	O
align	long
)	O
;	O
if	O
(	O
j	int
!=	O
0	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
&&	O
bed	pointer
->	O
no_page_alias	int
&&	O
(	O
off	long
&	O
(	O
maxpagesize	long
-	O
1	int
)	O
)	O
!=	O
0	int
&&	O
(	O
off	long
&	O
-	O
maxpagesize	long
)	O
==	O
(	O
(	O
off	long
+	O
off_adjust	long
)	O
&	O
-	O
maxpagesize	long
)	O
)	O
off_adjust	long
+=	O
maxpagesize	long
;	O
off	long
+=	O
off_adjust	long
;	O
if	O
(	O
no_contents	int
)	O
{	O
}	O
else	O
off_adjust	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_DYNAMIC	int
&&	O
m	pointer
->	O
count	int
>	O
1	int
&&	O
strcmp	function
(	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
name	pointer
,	O
".dynamic"	pointer
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: The first section in the PT_DYNAMIC segment"	pointer
" is not the .dynamic section"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_NOTE	int
)	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
elf_section_type	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
)	O
=	O
SHT_NOTE	int
;	O
if	O
(	O
m	pointer
->	O
includes_filehdr	int
)	O
{	O
if	O
(	O
!	O
m	pointer
->	O
p_flags_valid	int
)	O
p	pointer
->	O
p_flags	array
|=	O
PF_R	O
;	O
p	pointer
->	O
p_filesz	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
p	pointer
->	O
p_memsz	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
{	O
if	O
(	O
m	pointer
->	O
count	int
>	O
0	int
)	O
{	O
if	O
(	O
p	pointer
->	O
p_vaddr	array
<	O
(	O
bfd_vma	long
)	O
off	long
||	O
(	O
!	O
m	pointer
->	O
p_paddr_valid	int
&&	O
p	pointer
->	O
p_paddr	array
<	O
(	O
bfd_vma	long
)	O
off	long
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: not enough room for program headers,"	pointer
" try linking with -N"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
p	pointer
->	O
p_vaddr	array
-=	O
off	long
;	O
if	O
(	O
!	O
m	pointer
->	O
p_paddr_valid	int
)	O
p	pointer
->	O
p_paddr	array
-=	O
off	long
;	O
}	O
}	O
else	O
if	O
(	O
sorted_seg_map	pointer
[	O
0	int
]	O
->	O
includes_filehdr	int
)	O
{	O
Elf_Internal_Phdr	struct
*	O
filehdr	pointer
=	O
phdrs	pointer
+	O
sorted_seg_map	pointer
[	O
0	int
]	O
->	O
idx	int
;	O
p	pointer
->	O
p_vaddr	array
=	O
filehdr	pointer
->	O
p_vaddr	array
;	O
if	O
(	O
!	O
m	pointer
->	O
p_paddr_valid	int
)	O
p	pointer
->	O
p_paddr	array
=	O
filehdr	pointer
->	O
p_paddr	array
;	O
}	O
}	O
if	O
(	O
m	pointer
->	O
includes_phdrs	int
)	O
{	O
if	O
(	O
!	O
m	pointer
->	O
p_flags_valid	int
)	O
p	pointer
->	O
p_flags	array
|=	O
PF_R	O
;	O
p	pointer
->	O
p_filesz	array
+=	O
actual	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
p	pointer
->	O
p_memsz	array
+=	O
actual	int
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
if	O
(	O
!	O
m	pointer
->	O
includes_filehdr	int
)	O
{	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
{	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phoff	array
=	O
p	pointer
->	O
p_offset	array
;	O
if	O
(	O
m	pointer
->	O
count	int
>	O
0	int
)	O
{	O
p	pointer
->	O
p_vaddr	array
-=	O
off	long
-	O
p	pointer
->	O
p_offset	array
;	O
if	O
(	O
!	O
m	pointer
->	O
p_paddr_valid	int
)	O
p	pointer
->	O
p_paddr	array
-=	O
off	long
-	O
p	pointer
->	O
p_offset	array
;	O
}	O
}	O
else	O
if	O
(	O
phdr_load_seg	pointer
!=	O
NULL	O
)	O
{	O
Elf_Internal_Phdr	struct
*	O
phdr	pointer
=	O
phdrs	pointer
+	O
phdr_load_seg	pointer
->	O
idx	int
;	O
bfd_vma	long
phdr_off	long
=	O
0	int
;	O
if	O
(	O
phdr_load_seg	pointer
->	O
includes_filehdr	int
)	O
phdr_off	long
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
p	pointer
->	O
p_vaddr	array
=	O
phdr	pointer
->	O
p_vaddr	array
+	O
phdr_off	long
;	O
if	O
(	O
!	O
m	pointer
->	O
p_paddr_valid	int
)	O
p	pointer
->	O
p_paddr	array
=	O
phdr	pointer
->	O
p_paddr	array
+	O
phdr_off	long
;	O
p	pointer
->	O
p_offset	array
=	O
phdr	pointer
->	O
p_offset	array
+	O
phdr_off	long
;	O
}	O
else	O
p	pointer
->	O
p_offset	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
}	O
}	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
||	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_NOTE	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_core	int
)	O
)	O
{	O
if	O
(	O
!	O
m	pointer
->	O
includes_filehdr	int
&&	O
!	O
m	pointer
->	O
includes_phdrs	int
)	O
{	O
p	pointer
->	O
p_offset	array
=	O
off	long
;	O
if	O
(	O
no_contents	int
)	O
{	O
bfd_size_type	long
align	long
=	O
maxpagesize	long
;	O
if	O
(	O
align	long
<	O
p	pointer
->	O
p_align	array
)	O
align	long
=	O
p	pointer
->	O
p_align	array
;	O
if	O
(	O
align	long
<	O
1	int
)	O
align	long
=	O
1	int
;	O
p	pointer
->	O
p_offset	array
=	O
off	long
%	O
align	long
;	O
}	O
}	O
else	O
{	O
file_ptr	long
adjust	long
;	O
adjust	long
=	O
off	long
-	O
(	O
p	pointer
->	O
p_offset	array
+	O
p	pointer
->	O
p_filesz	array
)	O
;	O
if	O
(	O
!	O
no_contents	int
)	O
p	pointer
->	O
p_filesz	array
+=	O
adjust	long
;	O
p	pointer
->	O
p_memsz	array
+=	O
adjust	long
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
secpp	pointer
=	O
m	pointer
->	O
sections	pointer
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
,	O
secpp	pointer
++	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
bfd_size_type	long
align	long
;	O
Elf_Internal_Shdr	struct
*	O
this_hdr	struct
;	O
sec	pointer
=	O
*	O
secpp	pointer
;	O
this_hdr	struct
=	O
&	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
;	O
align	long
=	O
(	O
bfd_size_type	long
)	O
1	int
<<	O
bfd_section_alignment	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
||	O
p	pointer
->	O
p_type	array
==	O
PT_TLS	int
)	O
&&	O
(	O
this_hdr	struct
->	O
sh_type	array
!=	O
SHT_NOBITS	int
||	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
&&	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_TLS	O
)	O
==	O
0	int
||	O
p	pointer
->	O
p_type	array
==	O
PT_TLS	int
)	O
)	O
)	O
)	O
{	O
bfd_vma	long
p_start	long
=	O
p	pointer
->	O
p_paddr	array
;	O
bfd_vma	long
p_end	long
=	O
p_start	long
+	O
p	pointer
->	O
p_memsz	array
;	O
bfd_vma	long
s_start	long
=	O
sec	pointer
->	O
lma	long
;	O
bfd_vma	long
adjust	long
=	O
s_start	long
-	O
p_end	long
;	O
if	O
(	O
adjust	long
!=	O
0	int
&&	O
(	O
s_start	long
<	O
p_end	long
||	O
p_end	long
<	O
p_start	long
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: section %pA lma %#"	pointer
PRIx64	O
" adjusted to %#"	pointer
PRIx64	O
)	O
,	O
abfd	pointer
,	O
sec	pointer
,	O
(	O
uint64_t	long
)	O
s_start	long
,	O
(	O
uint64_t	long
)	O
p_end	long
)	O
;	O
adjust	long
=	O
0	int
;	O
sec	pointer
->	O
lma	long
=	O
p_end	long
;	O
}	O
p	pointer
->	O
p_memsz	array
+=	O
adjust	long
;	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
{	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
{	O
if	O
(	O
p	pointer
->	O
p_filesz	array
+	O
adjust	long
<	O
p	pointer
->	O
p_memsz	array
)	O
{	O
adjust	long
=	O
p	pointer
->	O
p_memsz	array
-	O
p	pointer
->	O
p_filesz	array
;	O
if	O
(	O
!	O
write_zeros	function
(	O
abfd	pointer
,	O
off	long
,	O
adjust	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
off	long
+=	O
adjust	long
;	O
}	O
p	pointer
->	O
p_filesz	array
+=	O
adjust	long
;	O
}	O
}	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_NOTE	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_core	int
)	O
{	O
if	O
(	O
i	pointer
==	O
0	int
)	O
{	O
this_hdr	struct
->	O
sh_offset	array
=	O
sec	pointer
->	O
filepos	long
=	O
off	long
;	O
off	long
+=	O
this_hdr	struct
->	O
sh_size	array
;	O
p	pointer
->	O
p_filesz	array
=	O
this_hdr	struct
->	O
sh_size	array
;	O
p	pointer
->	O
p_memsz	array
=	O
0	int
;	O
p	pointer
->	O
p_align	array
=	O
1	int
;	O
}	O
else	O
{	O
sec	pointer
->	O
filepos	long
=	O
0	int
;	O
sec	pointer
->	O
size	long
=	O
0	int
;	O
sec	pointer
->	O
flags	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
{	O
this_hdr	struct
->	O
sh_offset	array
=	O
sec	pointer
->	O
filepos	long
=	O
off	long
;	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
off	long
+=	O
this_hdr	struct
->	O
sh_size	array
;	O
}	O
else	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
==	O
SHT_NOBITS	int
&&	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_TLS	O
)	O
!=	O
0	int
&&	O
this_hdr	struct
->	O
sh_offset	array
==	O
0	int
)	O
{	O
bfd_vma	long
adjust	long
=	O
vma_page_aligned_bias	function
(	O
this_hdr	struct
->	O
sh_addr	array
,	O
off	long
,	O
align	long
)	O
;	O
this_hdr	struct
->	O
sh_offset	array
=	O
sec	pointer
->	O
filepos	long
=	O
off	long
+	O
adjust	long
;	O
}	O
if	O
(	O
this_hdr	struct
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
{	O
p	pointer
->	O
p_filesz	array
+=	O
this_hdr	struct
->	O
sh_size	array
;	O
if	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
p	pointer
->	O
p_memsz	array
+=	O
this_hdr	struct
->	O
sh_size	array
;	O
}	O
else	O
if	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_TLS	int
)	O
p	pointer
->	O
p_memsz	array
+=	O
this_hdr	struct
->	O
sh_size	array
;	O
else	O
if	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_TLS	O
)	O
==	O
0	int
)	O
p	pointer
->	O
p_memsz	array
+=	O
this_hdr	struct
->	O
sh_size	array
;	O
}	O
if	O
(	O
align	long
>	O
p	pointer
->	O
p_align	array
&&	O
!	O
m	pointer
->	O
p_align_valid	int
&&	O
(	O
p	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
||	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
==	O
0	int
)	O
)	O
p	pointer
->	O
p_align	array
=	O
align	long
;	O
}	O
if	O
(	O
!	O
m	pointer
->	O
p_flags_valid	int
)	O
{	O
p	pointer
->	O
p_flags	array
|=	O
PF_R	O
;	O
if	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_EXECINSTR	O
)	O
!=	O
0	int
)	O
p	pointer
->	O
p_flags	array
|=	O
PF_X	O
;	O
if	O
(	O
(	O
this_hdr	struct
->	O
sh_flags	array
&	O
SHF_WRITE	O
)	O
!=	O
0	int
)	O
p	pointer
->	O
p_flags	array
|=	O
PF_W	O
;	O
}	O
}	O
off	long
-=	O
off_adjust	long
;	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_PHDR	int
&&	O
phdr_load_seg	pointer
==	O
NULL	O
&&	O
!	O
(	O
bed	pointer
->	O
elf_backend_allow_non_load_phdr	pointer
!=	O
NULL	O
&&	O
bed	pointer
->	O
elf_backend_allow_non_load_phdr	pointer
(	O
abfd	pointer
,	O
phdrs	pointer
,	O
alloc	int
)	O
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: error: PHDR segment not covered"	pointer
" by LOAD segment"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
!=	O
bfd_core	int
)	O
{	O
bfd_boolean	int
check_vma	int
=	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
vma	long
==	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
-	O
1	int
]	O
->	O
vma	long
&&	O
ELF_SECTION_SIZE	O
(	O
&	O
(	O
elf_section_data	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
)	O
->	O
this_hdr	struct
)	O
,	O
p	pointer
)	O
!=	O
0	int
&&	O
ELF_SECTION_SIZE	O
(	O
&	O
(	O
elf_section_data	O
(	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
-	O
1	int
]	O
)	O
->	O
this_hdr	struct
)	O
,	O
p	pointer
)	O
!=	O
0	int
)	O
{	O
check_vma	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
m	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
this_hdr	struct
;	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
;	O
this_hdr	struct
=	O
&	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
)	O
;	O
if	O
(	O
!	O
ELF_SECTION_IN_SEGMENT_1	O
(	O
this_hdr	struct
,	O
p	pointer
,	O
check_vma	int
,	O
0	int
)	O
&&	O
!	O
ELF_TBSS_SPECIAL	O
(	O
this_hdr	struct
,	O
p	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: section `%pA' can't be allocated in segment %d"	pointer
)	O
,	O
abfd	pointer
,	O
sec	pointer
,	O
j	int
)	O
;	O
print_segment_map	function
(	O
m	pointer
)	O
;	O
}	O
}	O
}	O
}	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
off	long
;	O
if	O
(	O
link_info	pointer
!=	O
NULL	O
&&	O
phdr_load_seg	pointer
!=	O
NULL	O
&&	O
phdr_load_seg	pointer
->	O
includes_filehdr	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
hash	long
=	O
elf_link_hash_lookup	O
(	O
elf_hash_table	O
(	O
link_info	pointer
)	O
,	O
"__ehdr_start"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
hash	long
!=	O
NULL	O
&&	O
(	O
hash	long
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
||	O
hash	long
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
hash	long
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
hash	long
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
)	O
{	O
asection	struct
*	O
s	pointer
=	O
NULL	O
;	O
bfd_vma	long
filehdr_vaddr	long
=	O
phdrs	pointer
[	O
phdr_load_seg	pointer
->	O
idx	int
]	O
.	O
p_vaddr	array
;	O
if	O
(	O
phdr_load_seg	pointer
->	O
count	int
!=	O
0	int
)	O
s	pointer
=	O
phdr_load_seg	pointer
->	O
sections	pointer
[	O
0	int
]	O
;	O
else	O
for	O
(	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
if	O
(	O
m	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
m	pointer
->	O
count	int
!=	O
0	int
)	O
{	O
s	pointer
=	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
;	O
break	O
;	O
}	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
hash	long
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
filehdr_vaddr	long
-	O
s	pointer
->	O
vma	long
;	O
hash	long
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
hash	long
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
filehdr_vaddr	long
;	O
hash	long
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
}	O
hash	long
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
hash	long
->	O
def_regular	int
=	O
1	int
;	O
hash	long
->	O
non_elf	int
=	O
0	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
is_debuginfo_file	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
abfd	pointer
==	O
NULL	O
||	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
FALSE	int
;	O
Elf_Internal_Shdr	struct
*	O
*	O
start_headers	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
*	O
end_headers	pointer
=	O
start_headers	pointer
+	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
*	O
headerp	pointer
;	O
for	O
(	O
headerp	pointer
=	O
start_headers	pointer
;	O
headerp	pointer
<	O
end_headers	pointer
;	O
headerp	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
header	pointer
=	O
*	O
headerp	pointer
;	O
if	O
(	O
(	O
header	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
==	O
SHF_ALLOC	O
&&	O
header	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
&&	O
header	pointer
->	O
sh_type	array
!=	O
SHT_NOTE	int
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
assign_file_positions_for_non_load_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
*	O
i_shdrpp	pointer
;	O
Elf_Internal_Shdr	struct
*	O
*	O
hdrpp	pointer
,	O
*	O
*	O
end_hdrpp	pointer
;	O
Elf_Internal_Phdr	struct
*	O
phdrs	pointer
;	O
Elf_Internal_Phdr	struct
*	O
p	pointer
;	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
file_ptr	long
off	long
;	O
i_shdrpp	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
;	O
end_hdrpp	pointer
=	O
i_shdrpp	pointer
+	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
off	long
=	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
hdrpp	pointer
=	O
i_shdrpp	pointer
+	O
1	int
;	O
hdrpp	pointer
<	O
end_hdrpp	pointer
;	O
hdrpp	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
hdr	pointer
=	O
*	O
hdrpp	pointer
;	O
if	O
(	O
hdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
hdr	pointer
->	O
bfd_section	struct
->	O
filepos	long
!=	O
0	int
||	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
&&	O
hdr	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
)	O
)	O
BFD_ASSERT	O
(	O
hdr	pointer
->	O
sh_offset	array
==	O
hdr	pointer
->	O
bfd_section	struct
->	O
filepos	long
)	O
;	O
else	O
if	O
(	O
(	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_ALLOC	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_size	array
!=	O
0	int
&&	O
!	O
is_debuginfo_file	function
(	O
abfd	pointer
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: allocated section `%s' not in segment"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
hdr	pointer
->	O
bfd_section	struct
==	O
NULL	O
?	O
"*unknown*"	pointer
:	O
hdr	pointer
->	O
bfd_section	struct
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
D_PAGED	int
)	O
!=	O
0	int
&&	O
hdr	pointer
->	O
sh_size	array
!=	O
0	int
)	O
off	long
+=	O
vma_page_aligned_bias	function
(	O
hdr	pointer
->	O
sh_addr	array
,	O
off	long
,	O
bed	pointer
->	O
maxpagesize	long
)	O
;	O
else	O
off	long
+=	O
vma_page_aligned_bias	function
(	O
hdr	pointer
->	O
sh_addr	array
,	O
off	long
,	O
hdr	pointer
->	O
sh_addralign	array
)	O
;	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
hdr	pointer
,	O
off	long
,	O
FALSE	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_REL	int
||	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
&&	O
hdr	pointer
->	O
bfd_section	struct
==	O
NULL	O
)	O
||	O
(	O
hdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
hdr	pointer
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ELF_COMPRESS	int
||	O
(	O
bfd_section_is_ctf	function
(	O
hdr	pointer
->	O
bfd_section	struct
)	O
&&	O
abfd	pointer
->	O
is_linker_output	int
)	O
)	O
)	O
||	O
hdr	pointer
==	O
i_shdrpp	pointer
[	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
]	O
||	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
&&	O
hdr	pointer
==	O
i_shdrpp	pointer
[	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
->	O
ndx	int
]	O
)	O
||	O
hdr	pointer
==	O
i_shdrpp	pointer
[	O
elf_strtab_sec	O
(	O
abfd	pointer
)	O
]	O
||	O
hdr	pointer
==	O
i_shdrpp	pointer
[	O
elf_shstrtab_sec	O
(	O
abfd	pointer
)	O
]	O
)	O
hdr	pointer
->	O
sh_offset	array
=	O
-	O
1	int
;	O
else	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
}	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
off	long
;	O
phdrs	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
;	O
for	O
(	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
,	O
p	pointer
=	O
phdrs	pointer
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
,	O
p	pointer
++	O
)	O
{	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_GNU_RELRO	O
)	O
{	O
bfd_vma	long
start	long
,	O
end	pointer
;	O
bfd_boolean	int
ok	int
;	O
if	O
(	O
link_info	pointer
!=	O
NULL	O
)	O
{	O
start	long
=	O
link_info	pointer
->	O
relro_start	long
;	O
end	pointer
=	O
link_info	pointer
->	O
relro_end	long
;	O
}	O
else	O
if	O
(	O
m	pointer
->	O
count	int
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
m	pointer
->	O
p_size_valid	int
)	O
abort	function
(	O
)	O
;	O
start	long
=	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
vma	long
;	O
end	pointer
=	O
start	long
+	O
m	pointer
->	O
p_size	long
;	O
}	O
else	O
{	O
start	long
=	O
0	int
;	O
end	pointer
=	O
0	int
;	O
}	O
ok	int
=	O
FALSE	int
;	O
if	O
(	O
start	long
<	O
end	pointer
)	O
{	O
struct	O
elf_segment_map	struct
*	O
lm	pointer
;	O
const	O
Elf_Internal_Phdr	struct
*	O
lp	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
lm	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
,	O
lp	pointer
=	O
phdrs	pointer
;	O
lm	pointer
!=	O
NULL	O
;	O
lm	pointer
=	O
lm	pointer
->	O
next	pointer
,	O
lp	pointer
++	O
)	O
{	O
if	O
(	O
lp	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
lm	pointer
->	O
count	int
!=	O
0	int
&&	O
(	O
lm	pointer
->	O
sections	pointer
[	O
lm	pointer
->	O
count	int
-	O
1	int
]	O
->	O
vma	long
+	O
(	O
!	O
IS_TBSS	O
(	O
lm	pointer
->	O
sections	pointer
[	O
lm	pointer
->	O
count	int
-	O
1	int
]	O
)	O
?	O
lm	pointer
->	O
sections	pointer
[	O
lm	pointer
->	O
count	int
-	O
1	int
]	O
->	O
size	long
:	O
0	int
)	O
)	O
>	O
start	long
&&	O
lm	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
vma	long
<	O
end	pointer
)	O
break	O
;	O
}	O
if	O
(	O
lm	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
lm	pointer
->	O
count	int
;	O
i	pointer
++	O
)	O
{	O
asection	struct
*	O
s	pointer
=	O
lm	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
s	pointer
->	O
vma	long
>=	O
start	long
&&	O
s	pointer
->	O
vma	long
<	O
end	pointer
&&	O
s	pointer
->	O
size	long
!=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
<	O
lm	pointer
->	O
count	int
)	O
{	O
p	pointer
->	O
p_vaddr	array
=	O
lm	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
vma	long
;	O
p	pointer
->	O
p_paddr	array
=	O
lm	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
lma	long
;	O
p	pointer
->	O
p_offset	array
=	O
lm	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
->	O
filepos	long
;	O
p	pointer
->	O
p_memsz	array
=	O
end	pointer
-	O
p	pointer
->	O
p_vaddr	array
;	O
p	pointer
->	O
p_filesz	array
=	O
p	pointer
->	O
p_memsz	array
;	O
if	O
(	O
p	pointer
->	O
p_filesz	array
>	O
lp	pointer
->	O
p_vaddr	array
+	O
lp	pointer
->	O
p_filesz	array
-	O
p	pointer
->	O
p_vaddr	array
)	O
p	pointer
->	O
p_filesz	array
=	O
lp	pointer
->	O
p_vaddr	array
+	O
lp	pointer
->	O
p_filesz	array
-	O
p	pointer
->	O
p_vaddr	array
;	O
if	O
(	O
!	O
m	pointer
->	O
p_align_valid	int
)	O
p	pointer
->	O
p_align	array
=	O
1	int
;	O
if	O
(	O
!	O
m	pointer
->	O
p_flags_valid	int
)	O
p	pointer
->	O
p_flags	array
=	O
PF_R	O
;	O
ok	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
if	O
(	O
link_info	pointer
!=	O
NULL	O
)	O
BFD_ASSERT	O
(	O
ok	int
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
sizeof	O
*	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_GNU_STACK	O
)	O
{	O
if	O
(	O
m	pointer
->	O
p_size_valid	int
)	O
p	pointer
->	O
p_memsz	array
=	O
m	pointer
->	O
p_size	long
;	O
}	O
else	O
if	O
(	O
m	pointer
->	O
count	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
p	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
&&	O
(	O
p	pointer
->	O
p_type	array
!=	O
PT_NOTE	int
||	O
bfd_get_format	function
(	O
abfd	pointer
)	O
!=	O
bfd_core	int
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
p_type	array
==	O
PT_PHDR	int
)	O
{	O
m	pointer
->	O
count	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
m	pointer
->	O
includes_filehdr	int
||	O
m	pointer
->	O
includes_phdrs	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: error: non-load segment %d includes file header "	pointer
"and/or program header"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
int	O
)	O
(	O
p	pointer
-	O
phdrs	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
p	pointer
->	O
p_filesz	array
=	O
0	int
;	O
p	pointer
->	O
p_offset	array
=	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
filepos	long
;	O
for	O
(	O
i	pointer
=	O
m	pointer
->	O
count	int
;	O
i	pointer
--	O
!=	O
0	int
;	O
)	O
{	O
asection	struct
*	O
sect	pointer
=	O
m	pointer
->	O
sections	pointer
[	O
i	pointer
]	O
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
=	O
&	O
elf_section_data	O
(	O
sect	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
)	O
{	O
p	pointer
->	O
p_filesz	array
=	O
(	O
sect	pointer
->	O
filepos	long
-	O
m	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
filepos	long
+	O
hdr	pointer
->	O
sh_size	array
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
elf_section_list	struct
*	O
find_section_in_list	function
(	O
unsigned	O
int	O
i	pointer
,	O
elf_section_list	struct
*	O
list	pointer
)	O
{	O
for	O
(	O
;	O
list	pointer
!=	O
NULL	O
;	O
list	pointer
=	O
list	pointer
->	O
next	pointer
)	O
if	O
(	O
list	pointer
->	O
ndx	int
==	O
i	pointer
)	O
break	O
;	O
return	O
list	pointer
;	O
}	O
static	O
bfd_boolean	int
assign_file_positions_except_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
struct	O
elf_obj_tdata	struct
*	O
tdata	union
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Ehdr	struct
*	O
i_ehdrp	pointer
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
unsigned	O
int	O
alloc	int
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
EXEC_P	int
|	O
DYNAMIC	int
)	O
)	O
==	O
0	int
&&	O
bfd_get_format	function
(	O
abfd	pointer
)	O
!=	O
bfd_core	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
*	O
const	O
i_shdrpp	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
;	O
unsigned	O
int	O
num_sec	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
*	O
hdrpp	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
file_ptr	long
off	long
;	O
off	long
=	O
i_ehdrp	pointer
->	O
e_ehsize	array
;	O
for	O
(	O
i	pointer
=	O
1	int
,	O
hdrpp	pointer
=	O
i_shdrpp	pointer
+	O
1	int
;	O
i	pointer
<	O
num_sec	int
;	O
i	pointer
++	O
,	O
hdrpp	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
hdr	pointer
=	O
*	O
hdrpp	pointer
;	O
if	O
(	O
(	O
(	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_REL	int
||	O
hdr	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
&&	O
hdr	pointer
->	O
bfd_section	struct
==	O
NULL	O
)	O
||	O
(	O
hdr	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
hdr	pointer
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ELF_COMPRESS	int
||	O
(	O
bfd_section_is_ctf	function
(	O
hdr	pointer
->	O
bfd_section	struct
)	O
&&	O
abfd	pointer
->	O
is_linker_output	int
)	O
)	O
)	O
||	O
i	pointer
==	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
||	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
&&	O
hdr	pointer
==	O
i_shdrpp	pointer
[	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
->	O
ndx	int
]	O
)	O
||	O
i	pointer
==	O
elf_strtab_sec	O
(	O
abfd	pointer
)	O
||	O
i	pointer
==	O
elf_shstrtab_sec	O
(	O
abfd	pointer
)	O
)	O
{	O
hdr	pointer
->	O
sh_offset	array
=	O
-	O
1	int
;	O
}	O
else	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
hdr	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
}	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
off	long
;	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
assign_file_positions_for_load_sections	function
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
assign_file_positions_for_non_load_sections	function
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_modify_headers	pointer
)	O
(	O
abfd	pointer
,	O
link_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
alloc	int
=	O
i_ehdrp	pointer
->	O
e_phnum	array
;	O
if	O
(	O
alloc	int
!=	O
0	int
)	O
{	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
i_ehdrp	pointer
->	O
e_phoff	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bed	pointer
->	O
s	pointer
->	O
write_out_phdrs	pointer
(	O
abfd	pointer
,	O
tdata	union
->	O
phdr	pointer
,	O
alloc	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_init_file_header	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
i_ehdrp	pointer
;	O
struct	O
elf_strtab_hash	O
*	O
shstrtab	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
i_ehdrp	pointer
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
;	O
shstrtab	pointer
=	O
_bfd_elf_strtab_init	function
(	O
)	O
;	O
if	O
(	O
shstrtab	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
=	O
shstrtab	pointer
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_MAG0	int
]	O
=	O
ELFMAG0	int
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_MAG1	int
]	O
=	O
ELFMAG1	char
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_MAG2	int
]	O
=	O
ELFMAG2	char
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_MAG3	int
]	O
=	O
ELFMAG3	char
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
=	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_DATA	int
]	O
=	O
bfd_big_endian	function
(	O
abfd	pointer
)	O
?	O
ELFDATA2MSB	int
:	O
ELFDATA2LSB	int
;	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_VERSION	int
]	O
=	O
bed	pointer
->	O
s	pointer
->	O
ev_current	char
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
i_ehdrp	pointer
->	O
e_type	array
=	O
ET_DYN	int
;	O
else	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
EXEC_P	int
)	O
!=	O
0	int
)	O
i_ehdrp	pointer
->	O
e_type	array
=	O
ET_EXEC	int
;	O
else	O
if	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_core	int
)	O
i_ehdrp	pointer
->	O
e_type	array
=	O
ET_CORE	int
;	O
else	O
i_ehdrp	pointer
->	O
e_type	array
=	O
ET_REL	int
;	O
switch	O
(	O
bfd_get_arch	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_arch_unknown	int
:	O
i_ehdrp	pointer
->	O
e_machine	array
=	O
EM_NONE	int
;	O
break	O
;	O
default	O
:	O
i_ehdrp	pointer
->	O
e_machine	array
=	O
bed	pointer
->	O
elf_machine_code	int
;	O
}	O
i_ehdrp	pointer
->	O
e_version	array
=	O
bed	pointer
->	O
s	pointer
->	O
ev_current	char
;	O
i_ehdrp	pointer
->	O
e_ehsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
i_ehdrp	pointer
->	O
e_phoff	array
=	O
0	int
;	O
i_ehdrp	pointer
->	O
e_phentsize	array
=	O
0	int
;	O
i_ehdrp	pointer
->	O
e_phnum	array
=	O
0	int
;	O
i_ehdrp	pointer
->	O
e_entry	array
=	O
bfd_get_start_address	function
(	O
abfd	pointer
)	O
;	O
i_ehdrp	pointer
->	O
e_shentsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_shdr	char
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
shstrtab	pointer
,	O
".symtab"	pointer
,	O
FALSE	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
.	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
shstrtab	pointer
,	O
".strtab"	pointer
,	O
FALSE	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
shstrtab_hdr	struct
.	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
shstrtab	pointer
,	O
".shstrtab"	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
.	O
sh_name	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
||	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
.	O
sh_name	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
||	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
shstrtab_hdr	struct
.	O
sh_name	array
==	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_modify_headers	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
if	O
(	O
link_info	pointer
!=	O
NULL	O
&&	O
bfd_link_pie	O
(	O
link_info	pointer
)	O
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
i_ehdrp	pointer
=	O
elf_elfheader	O
(	O
obfd	pointer
)	O
;	O
unsigned	O
int	O
num_segments	int
=	O
i_ehdrp	pointer
->	O
e_phnum	array
;	O
struct	O
elf_obj_tdata	struct
*	O
tdata	union
=	O
elf_tdata	O
(	O
obfd	pointer
)	O
;	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
=	O
tdata	union
->	O
phdr	pointer
;	O
Elf_Internal_Phdr	struct
*	O
end_segment	pointer
=	O
&	O
segment	pointer
[	O
num_segments	int
]	O
;	O
bfd_vma	long
p_vaddr	array
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
for	O
(	O
;	O
segment	pointer
<	O
end_segment	pointer
;	O
segment	pointer
++	O
)	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
p_vaddr	array
>	O
segment	pointer
->	O
p_vaddr	array
)	O
p_vaddr	array
=	O
segment	pointer
->	O
p_vaddr	array
;	O
if	O
(	O
p_vaddr	array
)	O
i_ehdrp	pointer
->	O
e_type	array
=	O
ET_EXEC	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_elf_assign_file_positions_for_non_load	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
file_ptr	long
off	long
;	O
Elf_Internal_Shdr	struct
*	O
*	O
shdrpp	pointer
,	O
*	O
*	O
end_shdrpp	pointer
;	O
Elf_Internal_Shdr	struct
*	O
shdrp	pointer
;	O
Elf_Internal_Ehdr	struct
*	O
i_ehdrp	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
off	long
=	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
;	O
shdrpp	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
;	O
end_shdrpp	pointer
=	O
shdrpp	pointer
+	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
shdrpp	pointer
++	O
;	O
shdrpp	pointer
<	O
end_shdrpp	pointer
;	O
shdrpp	pointer
++	O
)	O
{	O
shdrp	pointer
=	O
*	O
shdrpp	pointer
;	O
if	O
(	O
shdrp	pointer
->	O
sh_offset	array
==	O
-	O
1	int
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
shdrp	pointer
->	O
bfd_section	struct
;	O
bfd_boolean	int
is_rel	int
=	O
(	O
shdrp	pointer
->	O
sh_type	array
==	O
SHT_REL	int
||	O
shdrp	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
;	O
bfd_boolean	int
is_ctf	int
=	O
sec	pointer
&&	O
bfd_section_is_ctf	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
is_rel	int
||	O
is_ctf	int
||	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ELF_COMPRESS	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
is_rel	int
&&	O
!	O
is_ctf	int
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
sec	pointer
->	O
name	pointer
;	O
struct	O
bfd_elf_section_data	struct
*	O
d	pointer
;	O
if	O
(	O
!	O
bfd_compress_section	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
shdrp	pointer
->	O
contents	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
sec	pointer
->	O
compress_status	int
==	O
COMPRESS_SECTION_DONE	int
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS_GABI	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
new_name	pointer
=	O
convert_debug_to_zdebug	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
name	pointer
=	O
new_name	pointer
;	O
}	O
if	O
(	O
shdrp	pointer
->	O
sh_name	array
!=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
shdrp	pointer
->	O
sh_name	array
=	O
(	O
unsigned	O
int	O
)	O
_bfd_elf_strtab_add	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
)	O
;	O
d	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
&&	O
!	O
_bfd_elf_set_reloc_sh_name	function
(	O
abfd	pointer
,	O
d	pointer
->	O
rel	pointer
.	O
hdr	pointer
,	O
name	pointer
,	O
FALSE	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
&&	O
!	O
_bfd_elf_set_reloc_sh_name	function
(	O
abfd	pointer
,	O
d	pointer
->	O
rela	struct
.	O
hdr	pointer
,	O
name	pointer
,	O
TRUE	int
)	O
)	O
return	O
FALSE	int
;	O
shdrp	pointer
->	O
sh_size	array
=	O
sec	pointer
->	O
size	long
;	O
shdrp	pointer
->	O
contents	pointer
=	O
sec	pointer
->	O
contents	pointer
;	O
shdrp	pointer
->	O
bfd_section	struct
->	O
contents	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
is_ctf	int
)	O
{	O
shdrp	pointer
->	O
sh_size	array
=	O
sec	pointer
->	O
size	long
;	O
shdrp	pointer
->	O
contents	pointer
=	O
sec	pointer
->	O
contents	pointer
;	O
}	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
shdrp	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
}	O
}	O
}	O
_bfd_elf_strtab_finalize	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
)	O
;	O
shdrp	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
shstrtab_hdr	struct
;	O
shdrp	pointer
->	O
sh_size	array
=	O
_bfd_elf_strtab_size	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
)	O
;	O
off	long
=	O
_bfd_elf_assign_file_position_for_section	function
(	O
shdrp	pointer
,	O
off	long
,	O
TRUE	int
)	O
;	O
i_ehdrp	pointer
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
off	long
=	O
align_file_position	function
(	O
off	long
,	O
1	int
<<	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
;	O
i_ehdrp	pointer
->	O
e_shoff	array
=	O
off	long
;	O
off	long
+=	O
i_ehdrp	pointer
->	O
e_shnum	array
*	O
i_ehdrp	pointer
->	O
e_shentsize	array
;	O
elf_next_file_pos	O
(	O
abfd	pointer
)	O
=	O
off	long
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_write_object_contents	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
*	O
i_shdrp	pointer
;	O
bfd_boolean	int
failed	int
;	O
unsigned	O
int	O
count	int
,	O
num_sec	int
;	O
struct	O
elf_obj_tdata	struct
*	O
t	pointer
;	O
if	O
(	O
!	O
abfd	pointer
->	O
output_has_begun	int
&&	O
!	O
_bfd_elf_compute_section_file_positions	function
(	O
abfd	pointer
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
else	O
if	O
(	O
abfd	pointer
->	O
direction	enum
==	O
both_direction	int
)	O
{	O
BFD_ASSERT	O
(	O
abfd	pointer
->	O
output_has_begun	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
i_shdrp	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
;	O
failed	int
=	O
FALSE	int
;	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
write_relocs	pointer
,	O
&	O
failed	int
)	O
;	O
if	O
(	O
failed	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_elf_assign_file_positions_for_non_load	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
num_sec	int
=	O
elf_numsections	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
count	int
=	O
1	int
;	O
count	int
<	O
num_sec	int
;	O
count	int
++	O
)	O
{	O
i_shdrp	pointer
[	O
count	int
]	O
->	O
sh_name	array
=	O
_bfd_elf_strtab_offset	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
,	O
i_shdrp	pointer
[	O
count	int
]	O
->	O
sh_name	array
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_section_processing	pointer
)	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_section_processing	pointer
)	O
(	O
abfd	pointer
,	O
i_shdrp	pointer
[	O
count	int
]	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
i_shdrp	pointer
[	O
count	int
]	O
->	O
contents	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
i_shdrp	pointer
[	O
count	int
]	O
->	O
sh_size	array
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
i_shdrp	pointer
[	O
count	int
]	O
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
i_shdrp	pointer
[	O
count	int
]	O
->	O
contents	pointer
,	O
amt	long
,	O
abfd	pointer
)	O
!=	O
amt	long
)	O
return	O
FALSE	int
;	O
}	O
}	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
&&	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
t	pointer
->	O
shstrtab_hdr	struct
.	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
!	O
_bfd_elf_strtab_emit	function
(	O
abfd	pointer
,	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
)	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
(	O
*	O
bed	pointer
->	O
elf_backend_final_write_processing	pointer
)	O
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
bed	pointer
->	O
s	pointer
->	O
write_shdrs_and_ehdr	pointer
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
after_write_object_contents	pointer
!=	O
NULL	O
)	O
return	O
(	O
*	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
after_write_object_contents	pointer
)	O
(	O
abfd	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_write_corefile_contents	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
_bfd_elf_write_object_contents	function
(	O
abfd	pointer
)	O
;	O
}	O
unsigned	O
int	O
_bfd_elf_section_from_bfd_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_section	struct
*	O
asect	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
unsigned	O
int	O
sec_index	int
;	O
if	O
(	O
elf_section_data	O
(	O
asect	pointer
)	O
!=	O
NULL	O
&&	O
elf_section_data	O
(	O
asect	pointer
)	O
->	O
this_idx	int
!=	O
0	int
)	O
return	O
elf_section_data	O
(	O
asect	pointer
)	O
->	O
this_idx	int
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
asect	pointer
)	O
)	O
sec_index	int
=	O
SHN_ABS	O
;	O
else	O
if	O
(	O
bfd_is_com_section	function
(	O
asect	pointer
)	O
)	O
sec_index	int
=	O
SHN_COMMON	O
;	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
asect	pointer
)	O
)	O
sec_index	int
=	O
SHN_UNDEF	int
;	O
else	O
sec_index	int
=	O
SHN_BAD	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_section_from_bfd_section	pointer
)	O
{	O
int	O
retval	pointer
=	O
sec_index	int
;	O
if	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_section_from_bfd_section	pointer
)	O
(	O
abfd	pointer
,	O
asect	pointer
,	O
&	O
retval	pointer
)	O
)	O
return	O
retval	pointer
;	O
}	O
if	O
(	O
sec_index	int
==	O
SHN_BAD	O
)	O
bfd_set_error	function
(	O
bfd_error_nonrepresentable_section	int
)	O
;	O
return	O
sec_index	int
;	O
}	O
int	O
_bfd_elf_symbol_from_bfd_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
asym_ptr_ptr	pointer
)	O
{	O
asymbol	struct
*	O
asym_ptr	pointer
=	O
*	O
asym_ptr_ptr	pointer
;	O
int	O
idx	int
;	O
flagword	int
flags	int
=	O
asym_ptr	pointer
->	O
flags	int
;	O
if	O
(	O
asym_ptr	pointer
->	O
udata	union
.	O
i	pointer
==	O
0	int
&&	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
&&	O
asym_ptr	pointer
->	O
section	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
int	O
indx	long
;	O
sec	pointer
=	O
asym_ptr	pointer
->	O
section	pointer
;	O
if	O
(	O
sec	pointer
->	O
owner	pointer
!=	O
abfd	pointer
&&	O
sec	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
sec	pointer
=	O
sec	pointer
->	O
output_section	pointer
;	O
if	O
(	O
sec	pointer
->	O
owner	pointer
==	O
abfd	pointer
&&	O
(	O
indx	long
=	O
sec	pointer
->	O
index	function
)	O
<	O
elf_num_section_syms	O
(	O
abfd	pointer
)	O
&&	O
elf_section_syms	O
(	O
abfd	pointer
)	O
[	O
indx	long
]	O
!=	O
NULL	O
)	O
asym_ptr	pointer
->	O
udata	union
.	O
i	pointer
=	O
elf_section_syms	O
(	O
abfd	pointer
)	O
[	O
indx	long
]	O
->	O
udata	union
.	O
i	pointer
;	O
}	O
idx	int
=	O
asym_ptr	pointer
->	O
udata	union
.	O
i	pointer
;	O
if	O
(	O
idx	int
==	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: symbol `%s' required but not present"	pointer
)	O
,	O
abfd	pointer
,	O
bfd_asymbol_name	function
(	O
asym_ptr	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_no_symbols	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
idx	int
;	O
}	O
static	O
bfd_boolean	int
rewrite_elf_program_header	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
iehdr	pointer
;	O
struct	O
elf_segment_map	struct
*	O
map	pointer
;	O
struct	O
elf_segment_map	struct
*	O
map_first	pointer
;	O
struct	O
elf_segment_map	struct
*	O
*	O
pointer_to_map	pointer
;	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
;	O
asection	struct
*	O
section	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
num_segments	int
;	O
bfd_boolean	int
phdr_included	int
=	O
FALSE	int
;	O
bfd_boolean	int
p_paddr_valid	int
;	O
bfd_vma	long
maxpagesize	long
;	O
struct	O
elf_segment_map	struct
*	O
phdr_adjust_seg	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
phdr_adjust_num	int
=	O
0	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
ibfd	pointer
)	O
;	O
iehdr	pointer
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
;	O
map_first	pointer
=	O
NULL	O
;	O
pointer_to_map	pointer
=	O
&	O
map_first	pointer
;	O
num_segments	int
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_phnum	array
;	O
maxpagesize	long
=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
->	O
maxpagesize	long
;	O
for	O
(	O
section	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
section	pointer
->	O
segment_mark	int
=	O
FALSE	int
;	O
p_paddr_valid	int
=	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
if	O
(	O
segment	pointer
->	O
p_paddr	array
!=	O
0	int
)	O
{	O
p_paddr_valid	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
{	O
unsigned	O
int	O
j	int
;	O
Elf_Internal_Phdr	struct
*	O
segment2	pointer
;	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_INTERP	int
)	O
for	O
(	O
section	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
if	O
(	O
IS_SOLARIS_PT_INTERP	O
(	O
segment	pointer
,	O
section	pointer
)	O
)	O
{	O
segment	pointer
->	O
p_vaddr	array
=	O
section	pointer
->	O
vma	long
;	O
break	O
;	O
}	O
if	O
(	O
segment	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
{	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_GNU_RELRO	O
)	O
segment	pointer
->	O
p_type	array
=	O
PT_NULL	int
;	O
continue	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
,	O
segment2	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
j	int
<	O
i	pointer
;	O
j	int
++	O
,	O
segment2	pointer
++	O
)	O
{	O
bfd_signed_vma	long
extra_length	long
;	O
if	O
(	O
segment2	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
||	O
!	O
SEGMENT_OVERLAPS	O
(	O
segment	pointer
,	O
segment2	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
segment2	pointer
->	O
p_vaddr	array
<	O
segment	pointer
->	O
p_vaddr	array
)	O
{	O
extra_length	long
=	O
(	O
SEGMENT_END	O
(	O
segment	pointer
,	O
segment	pointer
->	O
p_vaddr	array
)	O
-	O
SEGMENT_END	O
(	O
segment2	pointer
,	O
segment2	pointer
->	O
p_vaddr	array
)	O
)	O
;	O
if	O
(	O
extra_length	long
>	O
0	int
)	O
{	O
segment2	pointer
->	O
p_memsz	array
+=	O
extra_length	long
;	O
segment2	pointer
->	O
p_filesz	array
+=	O
extra_length	long
;	O
}	O
segment	pointer
->	O
p_type	array
=	O
PT_NULL	int
;	O
i	pointer
=	O
0	int
;	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
break	O
;	O
}	O
else	O
{	O
extra_length	long
=	O
(	O
SEGMENT_END	O
(	O
segment2	pointer
,	O
segment2	pointer
->	O
p_vaddr	array
)	O
-	O
SEGMENT_END	O
(	O
segment	pointer
,	O
segment	pointer
->	O
p_vaddr	array
)	O
)	O
;	O
if	O
(	O
extra_length	long
>	O
0	int
)	O
{	O
segment	pointer
->	O
p_memsz	array
+=	O
extra_length	long
;	O
segment	pointer
->	O
p_filesz	array
+=	O
extra_length	long
;	O
}	O
segment2	pointer
->	O
p_type	array
=	O
PT_NULL	int
;	O
}	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
{	O
unsigned	O
int	O
section_count	int
;	O
asection	struct
*	O
*	O
sections	pointer
;	O
asection	struct
*	O
output_section	pointer
;	O
unsigned	O
int	O
isec	pointer
;	O
asection	struct
*	O
matching_lma	pointer
;	O
asection	struct
*	O
suggested_lma	pointer
;	O
unsigned	O
int	O
j	int
;	O
bfd_size_type	long
amt	long
;	O
asection	struct
*	O
first_section	pointer
;	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_NULL	int
)	O
continue	O
;	O
first_section	pointer
=	O
NULL	O
;	O
for	O
(	O
section	pointer
=	O
ibfd	pointer
->	O
sections	pointer
,	O
section_count	int
=	O
0	int
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
IS_SECTION_IN_INPUT_SEGMENT	O
(	O
section	pointer
,	O
segment	pointer
,	O
bed	pointer
)	O
)	O
{	O
if	O
(	O
first_section	pointer
==	O
NULL	O
)	O
first_section	pointer
=	O
section	pointer
;	O
if	O
(	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
++	O
section_count	int
;	O
}	O
}	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
-	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
amt	long
+=	O
(	O
bfd_size_type	long
)	O
section_count	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
map	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
obfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
map	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
map	pointer
->	O
next	pointer
=	O
NULL	O
;	O
map	pointer
->	O
p_type	array
=	O
segment	pointer
->	O
p_type	array
;	O
map	pointer
->	O
p_flags	array
=	O
segment	pointer
->	O
p_flags	array
;	O
map	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
if	O
(	O
!	O
first_section	pointer
||	O
first_section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
map	pointer
->	O
p_paddr	array
=	O
segment	pointer
->	O
p_paddr	array
;	O
map	pointer
->	O
p_paddr_valid	int
=	O
p_paddr_valid	int
;	O
}	O
map	pointer
->	O
includes_filehdr	int
=	O
(	O
segment	pointer
->	O
p_offset	array
==	O
0	int
&&	O
segment	pointer
->	O
p_filesz	array
>=	O
iehdr	pointer
->	O
e_ehsize	array
)	O
;	O
map	pointer
->	O
includes_phdrs	int
=	O
0	int
;	O
if	O
(	O
!	O
phdr_included	int
||	O
segment	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
{	O
map	pointer
->	O
includes_phdrs	int
=	O
(	O
segment	pointer
->	O
p_offset	array
<=	O
(	O
bfd_vma	long
)	O
iehdr	pointer
->	O
e_phoff	array
&&	O
(	O
segment	pointer
->	O
p_offset	array
+	O
segment	pointer
->	O
p_filesz	array
>=	O
(	O
(	O
bfd_vma	long
)	O
iehdr	pointer
->	O
e_phoff	array
+	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
)	O
)	O
)	O
;	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
map	pointer
->	O
includes_phdrs	int
)	O
phdr_included	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
section_count	int
==	O
0	int
)	O
{	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
(	O
segment	pointer
->	O
p_filesz	array
>	O
0	int
||	O
segment	pointer
->	O
p_memsz	array
==	O
0	int
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: empty loadable segment detected"	pointer
" at vaddr=%#"	pointer
PRIx64	O
", is this intentional?"	pointer
)	O
,	O
ibfd	pointer
,	O
(	O
uint64_t	long
)	O
segment	pointer
->	O
p_vaddr	array
)	O
;	O
map	pointer
->	O
p_vaddr_offset	long
=	O
segment	pointer
->	O
p_vaddr	array
;	O
map	pointer
->	O
count	int
=	O
0	int
;	O
*	O
pointer_to_map	pointer
=	O
map	pointer
;	O
pointer_to_map	pointer
=	O
&	O
map	pointer
->	O
next	pointer
;	O
continue	O
;	O
}	O
sections	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
bfd_malloc2	function
(	O
section_count	int
,	O
sizeof	O
(	O
asection	struct
*	O
)	O
)	O
;	O
if	O
(	O
sections	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
isec	pointer
=	O
0	int
;	O
matching_lma	pointer
=	O
NULL	O
;	O
suggested_lma	pointer
=	O
NULL	O
;	O
for	O
(	O
section	pointer
=	O
first_section	pointer
,	O
j	int
=	O
0	int
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
INCLUDE_SECTION_IN_SEGMENT	O
(	O
section	pointer
,	O
segment	pointer
,	O
bed	pointer
)	O
)	O
{	O
output_section	pointer
=	O
section	pointer
->	O
output_section	pointer
;	O
sections	pointer
[	O
j	int
++	O
]	O
=	O
section	pointer
;	O
if	O
(	O
!	O
p_paddr_valid	int
&&	O
segment	pointer
->	O
p_vaddr	array
!=	O
0	int
&&	O
!	O
bed	pointer
->	O
want_p_paddr_set_to_zero	int
&&	O
isec	pointer
==	O
0	int
&&	O
output_section	pointer
->	O
lma	long
!=	O
0	int
&&	O
(	O
align_power	int
(	O
segment	pointer
->	O
p_vaddr	array
+	O
(	O
map	pointer
->	O
includes_filehdr	int
?	O
iehdr	pointer
->	O
e_ehsize	array
:	O
0	int
)	O
+	O
(	O
map	pointer
->	O
includes_phdrs	int
?	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
:	O
0	int
)	O
,	O
output_section	pointer
->	O
alignment_power	int
)	O
==	O
output_section	pointer
->	O
vma	long
)	O
)	O
map	pointer
->	O
p_paddr	array
=	O
segment	pointer
->	O
p_vaddr	array
;	O
if	O
(	O
IS_CONTAINED_BY_LMA	O
(	O
output_section	pointer
,	O
segment	pointer
,	O
map	pointer
->	O
p_paddr	array
)	O
||	O
IS_COREFILE_NOTE	O
(	O
segment	pointer
,	O
section	pointer
)	O
||	O
(	O
bed	pointer
->	O
want_p_paddr_set_to_zero	int
&&	O
IS_CONTAINED_BY_VMA	O
(	O
output_section	pointer
,	O
segment	pointer
)	O
)	O
)	O
{	O
if	O
(	O
matching_lma	pointer
==	O
NULL	O
||	O
output_section	pointer
->	O
lma	long
<	O
matching_lma	pointer
->	O
lma	long
)	O
matching_lma	pointer
=	O
output_section	pointer
;	O
map	pointer
->	O
sections	pointer
[	O
isec	pointer
++	O
]	O
=	O
output_section	pointer
;	O
}	O
else	O
if	O
(	O
suggested_lma	pointer
==	O
NULL	O
)	O
suggested_lma	pointer
=	O
output_section	pointer
;	O
if	O
(	O
j	int
==	O
section_count	int
)	O
break	O
;	O
}	O
}	O
BFD_ASSERT	O
(	O
j	int
==	O
section_count	int
)	O
;	O
if	O
(	O
isec	pointer
==	O
section_count	int
)	O
{	O
map	pointer
->	O
count	int
=	O
section_count	int
;	O
*	O
pointer_to_map	pointer
=	O
map	pointer
;	O
pointer_to_map	pointer
=	O
&	O
map	pointer
->	O
next	pointer
;	O
if	O
(	O
p_paddr_valid	int
&&	O
!	O
bed	pointer
->	O
want_p_paddr_set_to_zero	int
)	O
{	O
bfd_vma	long
hdr_size	long
=	O
0	int
;	O
if	O
(	O
map	pointer
->	O
includes_filehdr	int
)	O
hdr_size	long
=	O
iehdr	pointer
->	O
e_ehsize	array
;	O
if	O
(	O
map	pointer
->	O
includes_phdrs	int
)	O
hdr_size	long
+=	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
;	O
map	pointer
->	O
p_vaddr_offset	long
=	O
map	pointer
->	O
p_paddr	array
+	O
hdr_size	long
-	O
matching_lma	pointer
->	O
lma	long
;	O
}	O
free	function
(	O
sections	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
matching_lma	pointer
==	O
NULL	O
)	O
matching_lma	pointer
=	O
suggested_lma	pointer
;	O
map	pointer
->	O
p_paddr	array
=	O
matching_lma	pointer
->	O
lma	long
;	O
if	O
(	O
map	pointer
->	O
includes_phdrs	int
)	O
{	O
map	pointer
->	O
p_paddr	array
-=	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
;	O
phdr_adjust_num	int
=	O
iehdr	pointer
->	O
e_phnum	array
;	O
phdr_adjust_seg	pointer
=	O
map	pointer
;	O
}	O
if	O
(	O
map	pointer
->	O
includes_filehdr	int
)	O
{	O
bfd_vma	long
align	long
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
matching_lma	pointer
->	O
alignment_power	int
;	O
map	pointer
->	O
p_paddr	array
-=	O
iehdr	pointer
->	O
e_ehsize	array
;	O
if	O
(	O
segment	pointer
->	O
p_align	array
!=	O
0	int
&&	O
segment	pointer
->	O
p_align	array
<	O
align	long
)	O
align	long
=	O
segment	pointer
->	O
p_align	array
;	O
map	pointer
->	O
p_paddr	array
&=	O
-	O
align	long
;	O
}	O
}	O
isec	pointer
=	O
0	int
;	O
do	O
{	O
map	pointer
->	O
count	int
=	O
0	int
;	O
suggested_lma	pointer
=	O
NULL	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
section_count	int
;	O
j	int
++	O
)	O
{	O
section	pointer
=	O
sections	pointer
[	O
j	int
]	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
continue	O
;	O
output_section	pointer
=	O
section	pointer
->	O
output_section	pointer
;	O
BFD_ASSERT	O
(	O
output_section	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
IS_CONTAINED_BY_LMA	O
(	O
output_section	pointer
,	O
segment	pointer
,	O
map	pointer
->	O
p_paddr	array
)	O
||	O
IS_COREFILE_NOTE	O
(	O
segment	pointer
,	O
section	pointer
)	O
)	O
{	O
if	O
(	O
map	pointer
->	O
count	int
==	O
0	int
)	O
{	O
if	O
(	O
align_power	int
(	O
map	pointer
->	O
p_paddr	array
+	O
(	O
map	pointer
->	O
includes_filehdr	int
?	O
iehdr	pointer
->	O
e_ehsize	array
:	O
0	int
)	O
+	O
(	O
map	pointer
->	O
includes_phdrs	int
?	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
:	O
0	int
)	O
,	O
output_section	pointer
->	O
alignment_power	int
)	O
!=	O
output_section	pointer
->	O
lma	long
)	O
goto	O
sorry	O
;	O
}	O
else	O
{	O
asection	struct
*	O
prev_sec	pointer
;	O
prev_sec	pointer
=	O
map	pointer
->	O
sections	pointer
[	O
map	pointer
->	O
count	int
-	O
1	int
]	O
;	O
if	O
(	O
(	O
BFD_ALIGN	O
(	O
prev_sec	pointer
->	O
lma	long
+	O
prev_sec	pointer
->	O
size	long
,	O
maxpagesize	long
)	O
<	O
BFD_ALIGN	O
(	O
output_section	pointer
->	O
lma	long
,	O
maxpagesize	long
)	O
)	O
||	O
(	O
prev_sec	pointer
->	O
lma	long
+	O
prev_sec	pointer
->	O
size	long
>	O
output_section	pointer
->	O
lma	long
)	O
)	O
{	O
if	O
(	O
suggested_lma	pointer
==	O
NULL	O
)	O
suggested_lma	pointer
=	O
output_section	pointer
;	O
continue	O
;	O
}	O
}	O
map	pointer
->	O
sections	pointer
[	O
map	pointer
->	O
count	int
++	O
]	O
=	O
output_section	pointer
;	O
++	O
isec	pointer
;	O
sections	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_LOAD	int
)	O
section	pointer
->	O
segment_mark	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
suggested_lma	pointer
==	O
NULL	O
)	O
suggested_lma	pointer
=	O
output_section	pointer
;	O
}	O
if	O
(	O
map	pointer
->	O
count	int
==	O
0	int
)	O
{	O
sorry	O
:	O
bfd_set_error	function
(	O
bfd_error_sorry	int
)	O
;	O
free	function
(	O
sections	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
pointer_to_map	pointer
=	O
map	pointer
;	O
pointer_to_map	pointer
=	O
&	O
map	pointer
->	O
next	pointer
;	O
if	O
(	O
isec	pointer
<	O
section_count	int
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
-	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
amt	long
+=	O
(	O
bfd_size_type	long
)	O
section_count	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
map	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
obfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
map	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
sections	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
map	pointer
->	O
next	pointer
=	O
NULL	O
;	O
map	pointer
->	O
p_type	array
=	O
segment	pointer
->	O
p_type	array
;	O
map	pointer
->	O
p_flags	array
=	O
segment	pointer
->	O
p_flags	array
;	O
map	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
map	pointer
->	O
p_paddr	array
=	O
suggested_lma	pointer
->	O
lma	long
;	O
map	pointer
->	O
p_paddr_valid	int
=	O
p_paddr_valid	int
;	O
map	pointer
->	O
includes_filehdr	int
=	O
0	int
;	O
map	pointer
->	O
includes_phdrs	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
isec	pointer
<	O
section_count	int
)	O
;	O
free	function
(	O
sections	pointer
)	O
;	O
}	O
elf_seg_map	O
(	O
obfd	pointer
)	O
=	O
map_first	pointer
;	O
if	O
(	O
phdr_adjust_seg	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
count	int
;	O
for	O
(	O
count	int
=	O
0	int
,	O
map	pointer
=	O
map_first	pointer
;	O
map	pointer
!=	O
NULL	O
;	O
map	pointer
=	O
map	pointer
->	O
next	pointer
)	O
count	int
++	O
;	O
if	O
(	O
count	int
>	O
phdr_adjust_num	int
)	O
phdr_adjust_seg	pointer
->	O
p_paddr	array
-=	O
(	O
count	int
-	O
phdr_adjust_num	int
)	O
*	O
iehdr	pointer
->	O
e_phentsize	array
;	O
for	O
(	O
map	pointer
=	O
map_first	pointer
;	O
map	pointer
!=	O
NULL	O
;	O
map	pointer
=	O
map	pointer
->	O
next	pointer
)	O
if	O
(	O
map	pointer
->	O
p_type	array
==	O
PT_PHDR	int
)	O
{	O
bfd_vma	long
adjust	long
=	O
phdr_adjust_seg	pointer
->	O
includes_filehdr	int
?	O
iehdr	pointer
->	O
e_ehsize	array
:	O
0	int
;	O
map	pointer
->	O
p_paddr	array
=	O
phdr_adjust_seg	pointer
->	O
p_paddr	array
+	O
adjust	long
;	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
copy_elf_program_header	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
iehdr	pointer
;	O
struct	O
elf_segment_map	struct
*	O
map	pointer
;	O
struct	O
elf_segment_map	struct
*	O
map_first	pointer
;	O
struct	O
elf_segment_map	struct
*	O
*	O
pointer_to_map	pointer
;	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
num_segments	int
;	O
bfd_boolean	int
phdr_included	int
=	O
FALSE	int
;	O
bfd_boolean	int
p_paddr_valid	int
;	O
iehdr	pointer
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
;	O
map_first	pointer
=	O
NULL	O
;	O
pointer_to_map	pointer
=	O
&	O
map_first	pointer
;	O
p_paddr_valid	int
=	O
FALSE	int
;	O
num_segments	int
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_phnum	array
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
if	O
(	O
segment	pointer
->	O
p_paddr	array
!=	O
0	int
)	O
{	O
p_paddr_valid	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
{	O
asection	struct
*	O
section	pointer
;	O
unsigned	O
int	O
section_count	int
;	O
bfd_size_type	long
amt	long
;	O
Elf_Internal_Shdr	struct
*	O
this_hdr	struct
;	O
asection	struct
*	O
first_section	pointer
=	O
NULL	O
;	O
asection	struct
*	O
lowest_section	pointer
;	O
for	O
(	O
section	pointer
=	O
ibfd	pointer
->	O
sections	pointer
,	O
section_count	int
=	O
0	int
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
this_hdr	struct
=	O
&	O
(	O
elf_section_data	O
(	O
section	pointer
)	O
->	O
this_hdr	struct
)	O
;	O
if	O
(	O
ELF_SECTION_IN_SEGMENT	O
(	O
this_hdr	struct
,	O
segment	pointer
)	O
)	O
{	O
if	O
(	O
first_section	pointer
==	O
NULL	O
)	O
first_section	pointer
=	O
section	pointer
;	O
section_count	int
++	O
;	O
}	O
}	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
-	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
amt	long
+=	O
(	O
bfd_size_type	long
)	O
section_count	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
map	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
obfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
map	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
map	pointer
->	O
next	pointer
=	O
NULL	O
;	O
map	pointer
->	O
p_type	array
=	O
segment	pointer
->	O
p_type	array
;	O
map	pointer
->	O
p_flags	array
=	O
segment	pointer
->	O
p_flags	array
;	O
map	pointer
->	O
p_flags_valid	int
=	O
1	int
;	O
map	pointer
->	O
p_paddr	array
=	O
segment	pointer
->	O
p_paddr	array
;	O
map	pointer
->	O
p_paddr_valid	int
=	O
p_paddr_valid	int
;	O
map	pointer
->	O
p_align	array
=	O
segment	pointer
->	O
p_align	array
;	O
map	pointer
->	O
p_align_valid	int
=	O
1	int
;	O
map	pointer
->	O
p_vaddr_offset	long
=	O
0	int
;	O
if	O
(	O
map	pointer
->	O
p_type	array
==	O
PT_GNU_RELRO	O
||	O
map	pointer
->	O
p_type	array
==	O
PT_GNU_STACK	O
)	O
{	O
map	pointer
->	O
p_size	long
=	O
segment	pointer
->	O
p_memsz	array
;	O
map	pointer
->	O
p_size_valid	int
=	O
1	int
;	O
}	O
map	pointer
->	O
includes_filehdr	int
=	O
(	O
segment	pointer
->	O
p_offset	array
==	O
0	int
&&	O
segment	pointer
->	O
p_filesz	array
>=	O
iehdr	pointer
->	O
e_ehsize	array
)	O
;	O
map	pointer
->	O
includes_phdrs	int
=	O
0	int
;	O
if	O
(	O
!	O
phdr_included	int
||	O
segment	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
{	O
map	pointer
->	O
includes_phdrs	int
=	O
(	O
segment	pointer
->	O
p_offset	array
<=	O
(	O
bfd_vma	long
)	O
iehdr	pointer
->	O
e_phoff	array
&&	O
(	O
segment	pointer
->	O
p_offset	array
+	O
segment	pointer
->	O
p_filesz	array
>=	O
(	O
(	O
bfd_vma	long
)	O
iehdr	pointer
->	O
e_phoff	array
+	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
)	O
)	O
)	O
;	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
map	pointer
->	O
includes_phdrs	int
)	O
phdr_included	int
=	O
TRUE	int
;	O
}	O
lowest_section	pointer
=	O
NULL	O
;	O
if	O
(	O
section_count	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
isec	pointer
=	O
0	int
;	O
for	O
(	O
section	pointer
=	O
first_section	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
this_hdr	struct
=	O
&	O
(	O
elf_section_data	O
(	O
section	pointer
)	O
->	O
this_hdr	struct
)	O
;	O
if	O
(	O
ELF_SECTION_IN_SEGMENT	O
(	O
this_hdr	struct
,	O
segment	pointer
)	O
)	O
{	O
map	pointer
->	O
sections	pointer
[	O
isec	pointer
++	O
]	O
=	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
bfd_vma	long
seg_off	long
;	O
if	O
(	O
lowest_section	pointer
==	O
NULL	O
||	O
section	pointer
->	O
lma	long
<	O
lowest_section	pointer
->	O
lma	long
)	O
lowest_section	pointer
=	O
section	pointer
;	O
if	O
(	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
seg_off	long
=	O
this_hdr	struct
->	O
sh_offset	array
-	O
segment	pointer
->	O
p_offset	array
;	O
else	O
seg_off	long
=	O
this_hdr	struct
->	O
sh_addr	array
-	O
segment	pointer
->	O
p_vaddr	array
;	O
if	O
(	O
section	pointer
->	O
lma	long
-	O
segment	pointer
->	O
p_paddr	array
!=	O
seg_off	long
)	O
map	pointer
->	O
p_paddr_valid	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
isec	pointer
==	O
section_count	int
)	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
section_count	int
==	O
0	int
)	O
map	pointer
->	O
p_vaddr_offset	long
=	O
segment	pointer
->	O
p_vaddr	array
;	O
else	O
if	O
(	O
map	pointer
->	O
p_paddr_valid	int
)	O
{	O
bfd_vma	long
hdr_size	long
=	O
0	int
;	O
if	O
(	O
map	pointer
->	O
includes_filehdr	int
)	O
hdr_size	long
=	O
iehdr	pointer
->	O
e_ehsize	array
;	O
if	O
(	O
map	pointer
->	O
includes_phdrs	int
)	O
hdr_size	long
+=	O
iehdr	pointer
->	O
e_phnum	array
*	O
iehdr	pointer
->	O
e_phentsize	array
;	O
map	pointer
->	O
p_vaddr_offset	long
=	O
(	O
map	pointer
->	O
p_paddr	array
+	O
hdr_size	long
-	O
(	O
lowest_section	pointer
?	O
lowest_section	pointer
->	O
lma	long
:	O
0	int
)	O
)	O
;	O
}	O
map	pointer
->	O
count	int
=	O
section_count	int
;	O
*	O
pointer_to_map	pointer
=	O
map	pointer
;	O
pointer_to_map	pointer
=	O
&	O
map	pointer
->	O
next	pointer
;	O
}	O
elf_seg_map	O
(	O
obfd	pointer
)	O
=	O
map_first	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
copy_private_bfd_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
==	O
obfd	pointer
->	O
xvec	pointer
)	O
{	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
;	O
asection	struct
*	O
section	pointer
,	O
*	O
osec	pointer
;	O
unsigned	O
int	O
i	pointer
,	O
num_segments	int
;	O
Elf_Internal_Shdr	struct
*	O
this_hdr	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
ibfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
want_p_paddr_set_to_zero	int
)	O
goto	O
rewrite	O
;	O
for	O
(	O
section	pointer
=	O
obfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
section	pointer
->	O
segment_mark	int
=	O
FALSE	int
;	O
num_segments	int
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_phnum	array
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
{	O
if	O
(	O
segment	pointer
->	O
p_paddr	array
==	O
0	int
&&	O
segment	pointer
->	O
p_memsz	array
==	O
0	int
&&	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_INTERP	int
||	O
segment	pointer
->	O
p_type	array
==	O
PT_DYNAMIC	int
)	O
)	O
goto	O
rewrite	O
;	O
for	O
(	O
section	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
osec	pointer
=	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
osec	pointer
)	O
osec	pointer
->	O
segment_mark	int
=	O
TRUE	int
;	O
this_hdr	struct
=	O
&	O
(	O
elf_section_data	O
(	O
section	pointer
)	O
->	O
this_hdr	struct
)	O
;	O
if	O
(	O
ELF_SECTION_IN_SEGMENT	O
(	O
this_hdr	struct
,	O
segment	pointer
)	O
)	O
{	O
if	O
(	O
osec	pointer
==	O
NULL	O
||	O
section	pointer
->	O
flags	int
!=	O
osec	pointer
->	O
flags	int
||	O
section	pointer
->	O
lma	long
!=	O
osec	pointer
->	O
lma	long
||	O
section	pointer
->	O
vma	long
!=	O
osec	pointer
->	O
vma	long
||	O
section	pointer
->	O
size	long
!=	O
osec	pointer
->	O
size	long
||	O
section	pointer
->	O
rawsize	long
!=	O
osec	pointer
->	O
rawsize	long
||	O
section	pointer
->	O
alignment_power	int
!=	O
osec	pointer
->	O
alignment_power	int
)	O
goto	O
rewrite	O
;	O
}	O
}	O
}	O
for	O
(	O
section	pointer
=	O
obfd	pointer
->	O
sections	pointer
;	O
section	pointer
!=	O
NULL	O
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
section	pointer
->	O
segment_mark	int
)	O
goto	O
rewrite	O
;	O
else	O
section	pointer
->	O
segment_mark	int
=	O
FALSE	int
;	O
}	O
return	O
copy_elf_program_header	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
;	O
}	O
rewrite	O
:	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
==	O
obfd	pointer
->	O
xvec	pointer
)	O
{	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
num_segments	int
=	O
elf_elfheader	O
(	O
ibfd	pointer
)	O
->	O
e_phnum	array
;	O
bfd_vma	long
maxpagesize	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
;	O
i	pointer
<	O
num_segments	int
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
maxpagesize	long
<	O
segment	pointer
->	O
p_align	array
)	O
{	O
if	O
(	O
segment	pointer
->	O
p_align	array
>	O
(	O
bfd_vma	long
)	O
1	int
<<	O
(	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
*	O
8	int
)	O
-	O
2	int
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: segment alignment of %#"	pointer
PRIx64	O
" is too large"	pointer
)	O
,	O
ibfd	pointer
,	O
(	O
uint64_t	long
)	O
segment	pointer
->	O
p_align	array
)	O
;	O
else	O
maxpagesize	long
=	O
segment	pointer
->	O
p_align	array
;	O
}	O
if	O
(	O
maxpagesize	long
!=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
->	O
maxpagesize	long
)	O
bfd_emul_set_maxpagesize	function
(	O
bfd_get_target	function
(	O
obfd	pointer
)	O
,	O
maxpagesize	long
)	O
;	O
}	O
return	O
rewrite_elf_program_header	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_init_private_section_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
asection	struct
*	O
isec	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
asection	struct
*	O
osec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
ihdr	pointer
,	O
*	O
ohdr	pointer
;	O
bfd_boolean	int
final_link	int
=	O
(	O
link_info	pointer
!=	O
NULL	O
&&	O
!	O
bfd_link_relocatable	O
(	O
link_info	pointer
)	O
)	O
;	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
||	O
obfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
BFD_ASSERT	O
(	O
elf_section_data	O
(	O
osec	pointer
)	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
elf_section_type	O
(	O
osec	pointer
)	O
==	O
SHT_NULL	int
&&	O
(	O
osec	pointer
->	O
flags	int
==	O
isec	pointer
->	O
flags	int
||	O
(	O
final_link	int
&&	O
(	O
(	O
osec	pointer
->	O
flags	int
^	O
isec	pointer
->	O
flags	int
)	O
&	O
~	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES	int
|	O
SEC_RELOC	int
)	O
)	O
==	O
0	int
)	O
)	O
)	O
elf_section_type	O
(	O
osec	pointer
)	O
=	O
elf_section_type	O
(	O
isec	pointer
)	O
;	O
elf_section_flags	O
(	O
osec	pointer
)	O
|=	O
(	O
elf_section_flags	O
(	O
isec	pointer
)	O
&	O
(	O
SHF_MASKOS	int
|	O
SHF_MASKPROC	int
)	O
)	O
;	O
if	O
(	O
(	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_mbind	int
)	O
!=	O
0	int
&&	O
elf_section_flags	O
(	O
isec	pointer
)	O
&	O
SHF_GNU_MBIND	int
)	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
=	O
elf_section_data	O
(	O
isec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
;	O
if	O
(	O
(	O
link_info	pointer
==	O
NULL	O
||	O
!	O
link_info	pointer
->	O
resolve_section_groups	int
)	O
&&	O
(	O
elf_sec_group	O
(	O
isec	pointer
)	O
==	O
NULL	O
||	O
(	O
elf_sec_group	O
(	O
isec	pointer
)	O
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
elf_section_flags	O
(	O
isec	pointer
)	O
&	O
SHF_GROUP	O
)	O
elf_section_flags	O
(	O
osec	pointer
)	O
|=	O
SHF_GROUP	O
;	O
elf_next_in_group	O
(	O
osec	pointer
)	O
=	O
elf_next_in_group	O
(	O
isec	pointer
)	O
;	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
group	pointer
=	O
elf_section_data	O
(	O
isec	pointer
)	O
->	O
group	pointer
;	O
}	O
if	O
(	O
!	O
final_link	int
&&	O
(	O
ibfd	pointer
->	O
flags	int
&	O
BFD_DECOMPRESS	int
)	O
==	O
0	int
)	O
elf_section_flags	O
(	O
osec	pointer
)	O
|=	O
(	O
elf_section_flags	O
(	O
isec	pointer
)	O
&	O
SHF_COMPRESSED	O
)	O
;	O
ihdr	pointer
=	O
&	O
elf_section_data	O
(	O
isec	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
(	O
ihdr	pointer
->	O
sh_flags	array
&	O
SHF_LINK_ORDER	O
)	O
!=	O
0	int
)	O
{	O
ohdr	pointer
=	O
&	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
this_hdr	struct
;	O
ohdr	pointer
->	O
sh_flags	array
|=	O
SHF_LINK_ORDER	O
;	O
elf_linked_to_section	O
(	O
osec	pointer
)	O
=	O
elf_linked_to_section	O
(	O
isec	pointer
)	O
;	O
}	O
osec	pointer
->	O
use_rela_p	int
=	O
isec	pointer
->	O
use_rela_p	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_copy_private_section_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
asection	struct
*	O
isec	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
asection	struct
*	O
osec	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
ihdr	pointer
,	O
*	O
ohdr	pointer
;	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
||	O
obfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
ihdr	pointer
=	O
&	O
elf_section_data	O
(	O
isec	pointer
)	O
->	O
this_hdr	struct
;	O
ohdr	pointer
=	O
&	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
this_hdr	struct
;	O
ohdr	pointer
->	O
sh_entsize	array
=	O
ihdr	pointer
->	O
sh_entsize	array
;	O
if	O
(	O
ihdr	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
||	O
ihdr	pointer
->	O
sh_type	array
==	O
SHT_DYNSYM	int
||	O
ihdr	pointer
->	O
sh_type	array
==	O
SHT_GNU_verneed	O
||	O
ihdr	pointer
->	O
sh_type	array
==	O
SHT_GNU_verdef	O
)	O
ohdr	pointer
->	O
sh_info	array
=	O
ihdr	pointer
->	O
sh_info	array
;	O
return	O
_bfd_elf_init_private_section_data	function
(	O
ibfd	pointer
,	O
isec	pointer
,	O
obfd	pointer
,	O
osec	pointer
,	O
NULL	O
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_fixup_group_sections	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
asection	struct
*	O
discarded	pointer
)	O
{	O
asection	struct
*	O
isec	pointer
;	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
if	O
(	O
elf_section_type	O
(	O
isec	pointer
)	O
==	O
SHT_GROUP	int
)	O
{	O
asection	struct
*	O
first	pointer
=	O
elf_next_in_group	O
(	O
isec	pointer
)	O
;	O
asection	struct
*	O
s	pointer
=	O
first	pointer
;	O
bfd_size_type	long
removed	int
=	O
0	int
;	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
s	pointer
->	O
output_section	pointer
!=	O
discarded	pointer
&&	O
isec	pointer
->	O
output_section	pointer
==	O
discarded	pointer
)	O
{	O
elf_section_flags	O
(	O
s	pointer
->	O
output_section	pointer
)	O
&=	O
~	O
SHF_GROUP	O
;	O
elf_group_name	O
(	O
s	pointer
->	O
output_section	pointer
)	O
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
s	pointer
->	O
output_section	pointer
==	O
discarded	pointer
&&	O
isec	pointer
->	O
output_section	pointer
!=	O
discarded	pointer
)	O
{	O
struct	O
bfd_elf_section_data	struct
*	O
elf_sec	pointer
=	O
elf_section_data	O
(	O
s	pointer
)	O
;	O
removed	int
+=	O
4	int
;	O
if	O
(	O
elf_sec	pointer
->	O
rel	pointer
.	O
hdr	pointer
!=	O
NULL	O
&&	O
(	O
elf_sec	pointer
->	O
rel	pointer
.	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_GROUP	O
)	O
!=	O
0	int
)	O
removed	int
+=	O
4	int
;	O
if	O
(	O
elf_sec	pointer
->	O
rela	struct
.	O
hdr	pointer
!=	O
NULL	O
&&	O
(	O
elf_sec	pointer
->	O
rela	struct
.	O
hdr	pointer
->	O
sh_flags	array
&	O
SHF_GROUP	O
)	O
!=	O
0	int
)	O
removed	int
+=	O
4	int
;	O
}	O
s	pointer
=	O
elf_next_in_group	O
(	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
first	pointer
)	O
break	O
;	O
}	O
if	O
(	O
removed	int
!=	O
0	int
)	O
{	O
if	O
(	O
discarded	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
isec	pointer
->	O
rawsize	long
==	O
0	int
)	O
isec	pointer
->	O
rawsize	long
=	O
isec	pointer
->	O
size	long
;	O
isec	pointer
->	O
size	long
=	O
isec	pointer
->	O
rawsize	long
-	O
removed	int
;	O
if	O
(	O
isec	pointer
->	O
size	long
<=	O
4	int
)	O
{	O
isec	pointer
->	O
size	long
=	O
0	int
;	O
isec	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
}	O
}	O
else	O
{	O
isec	pointer
->	O
output_section	pointer
->	O
size	long
-=	O
removed	int
;	O
if	O
(	O
isec	pointer
->	O
output_section	pointer
->	O
size	long
<=	O
4	int
)	O
{	O
isec	pointer
->	O
output_section	pointer
->	O
size	long
=	O
0	int
;	O
isec	pointer
->	O
output_section	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
}	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_copy_private_header_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
elf_seg_map	O
(	O
obfd	pointer
)	O
==	O
NULL	O
&&	O
elf_tdata	O
(	O
ibfd	pointer
)	O
->	O
phdr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
copy_private_bfd_data	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
_bfd_elf_fixup_group_sections	function
(	O
ibfd	pointer
,	O
NULL	O
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_copy_private_symbol_data	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
asymbol	struct
*	O
isymarg	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
asymbol	struct
*	O
osymarg	pointer
)	O
{	O
elf_symbol_type	struct
*	O
isym	pointer
,	O
*	O
osym	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
isym	pointer
=	O
elf_symbol_from	O
(	O
ibfd	pointer
,	O
isymarg	pointer
)	O
;	O
osym	pointer
=	O
elf_symbol_from	O
(	O
obfd	pointer
,	O
osymarg	pointer
)	O
;	O
if	O
(	O
isym	pointer
!=	O
NULL	O
&&	O
isym	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
!=	O
0	int
&&	O
osym	pointer
!=	O
NULL	O
&&	O
bfd_is_abs_section	function
(	O
isym	pointer
->	O
symbol	pointer
.	O
section	pointer
)	O
)	O
{	O
unsigned	O
int	O
shndx	pointer
;	O
shndx	pointer
=	O
isym	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
;	O
if	O
(	O
shndx	pointer
==	O
elf_onesymtab	O
(	O
ibfd	pointer
)	O
)	O
shndx	pointer
=	O
MAP_ONESYMTAB	O
;	O
else	O
if	O
(	O
shndx	pointer
==	O
elf_dynsymtab	O
(	O
ibfd	pointer
)	O
)	O
shndx	pointer
=	O
MAP_DYNSYMTAB	O
;	O
else	O
if	O
(	O
shndx	pointer
==	O
elf_strtab_sec	O
(	O
ibfd	pointer
)	O
)	O
shndx	pointer
=	O
MAP_STRTAB	O
;	O
else	O
if	O
(	O
shndx	pointer
==	O
elf_shstrtab_sec	O
(	O
ibfd	pointer
)	O
)	O
shndx	pointer
=	O
MAP_SHSTRTAB	O
;	O
else	O
if	O
(	O
find_section_in_list	function
(	O
shndx	pointer
,	O
elf_symtab_shndx_list	O
(	O
ibfd	pointer
)	O
)	O
)	O
shndx	pointer
=	O
MAP_SYM_SHNDX	O
;	O
osym	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
=	O
shndx	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
swap_out_syms	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
elf_strtab_hash	O
*	O
*	O
sttp	pointer
,	O
int	O
relocatable_p	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
int	O
symcount	int
;	O
asymbol	struct
*	O
*	O
syms	pointer
;	O
struct	O
elf_strtab_hash	O
*	O
stt	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
Elf_Internal_Shdr	struct
*	O
symtab_shndx_hdr	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symstrtab_hdr	pointer
;	O
struct	O
elf_sym_strtab	struct
*	O
symstrtab	pointer
;	O
bfd_byte	char
*	O
outbound_syms	pointer
;	O
bfd_byte	char
*	O
outbound_shndx	pointer
;	O
unsigned	O
long	O
outbound_syms_index	long
;	O
unsigned	O
long	O
outbound_shndx_index	long
;	O
int	O
idx	int
;	O
unsigned	O
int	O
num_locals	int
;	O
bfd_size_type	long
amt	long
;	O
bfd_boolean	int
name_local_sections	int
;	O
if	O
(	O
!	O
elf_map_symbols	function
(	O
abfd	pointer
,	O
&	O
num_locals	int
)	O
)	O
return	O
FALSE	int
;	O
stt	pointer
=	O
_bfd_elf_strtab_init	function
(	O
)	O
;	O
if	O
(	O
stt	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
symcount	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
symtab_hdr	struct
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
symtab_hdr	struct
->	O
sh_type	array
=	O
SHT_SYMTAB	int
;	O
symtab_hdr	struct
->	O
sh_entsize	array
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
;	O
symtab_hdr	struct
->	O
sh_size	array
=	O
symtab_hdr	struct
->	O
sh_entsize	array
*	O
(	O
symcount	int
+	O
1	int
)	O
;	O
symtab_hdr	struct
->	O
sh_info	array
=	O
num_locals	int
+	O
1	int
;	O
symtab_hdr	struct
->	O
sh_addralign	array
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
;	O
symstrtab_hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
strtab_hdr	struct
;	O
symstrtab_hdr	pointer
->	O
sh_type	array
=	O
SHT_STRTAB	int
;	O
symstrtab	pointer
=	O
(	O
struct	O
elf_sym_strtab	struct
*	O
)	O
bfd_malloc2	function
(	O
symcount	int
+	O
1	int
,	O
sizeof	O
(	O
*	O
symstrtab	pointer
)	O
)	O
;	O
if	O
(	O
symstrtab	pointer
==	O
NULL	O
)	O
{	O
_bfd_elf_strtab_free	function
(	O
stt	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
outbound_syms	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
1	int
+	O
symcount	int
,	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
;	O
if	O
(	O
outbound_syms	pointer
==	O
NULL	O
)	O
{	O
error_return	O
:	O
_bfd_elf_strtab_free	function
(	O
stt	pointer
)	O
;	O
free	function
(	O
symstrtab	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
symtab_hdr	struct
->	O
contents	pointer
=	O
outbound_syms	pointer
;	O
outbound_syms_index	long
=	O
0	int
;	O
outbound_shndx	pointer
=	O
NULL	O
;	O
outbound_shndx_index	long
=	O
0	int
;	O
if	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
)	O
{	O
symtab_shndx_hdr	pointer
=	O
&	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
->	O
hdr	pointer
;	O
if	O
(	O
symtab_shndx_hdr	pointer
->	O
sh_name	array
!=	O
0	int
)	O
{	O
amt	long
=	O
(	O
bfd_size_type	long
)	O
(	O
1	int
+	O
symcount	int
)	O
*	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
outbound_shndx	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_zalloc2	function
(	O
abfd	pointer
,	O
1	int
+	O
symcount	int
,	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
)	O
;	O
if	O
(	O
outbound_shndx	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
symtab_shndx_hdr	pointer
->	O
contents	pointer
=	O
outbound_shndx	pointer
;	O
symtab_shndx_hdr	pointer
->	O
sh_type	array
=	O
SHT_SYMTAB_SHNDX	int
;	O
symtab_shndx_hdr	pointer
->	O
sh_size	array
=	O
amt	long
;	O
symtab_shndx_hdr	pointer
->	O
sh_addralign	array
=	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
symtab_shndx_hdr	pointer
->	O
sh_entsize	array
=	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
;	O
}	O
}	O
{	O
Elf_Internal_Sym	struct
sym	pointer
;	O
sym	pointer
.	O
st_name	array
=	O
0	int
;	O
sym	pointer
.	O
st_value	array
=	O
0	int
;	O
sym	pointer
.	O
st_size	long
=	O
0	int
;	O
sym	pointer
.	O
st_info	array
=	O
0	int
;	O
sym	pointer
.	O
st_other	array
=	O
0	int
;	O
sym	pointer
.	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
sym	pointer
.	O
st_target_internal	char
=	O
0	int
;	O
symstrtab	pointer
[	O
0	int
]	O
.	O
sym	pointer
=	O
sym	pointer
;	O
symstrtab	pointer
[	O
0	int
]	O
.	O
dest_index	long
=	O
outbound_syms_index	long
;	O
symstrtab	pointer
[	O
0	int
]	O
.	O
destshndx_index	long
=	O
outbound_shndx_index	long
;	O
outbound_syms_index	long
++	O
;	O
if	O
(	O
outbound_shndx	pointer
!=	O
NULL	O
)	O
outbound_shndx_index	long
++	O
;	O
}	O
name_local_sections	int
=	O
(	O
bed	pointer
->	O
elf_backend_name_local_section_symbols	pointer
&&	O
bed	pointer
->	O
elf_backend_name_local_section_symbols	pointer
(	O
abfd	pointer
)	O
)	O
;	O
syms	pointer
=	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
symcount	int
;	O
)	O
{	O
Elf_Internal_Sym	struct
sym	pointer
;	O
bfd_vma	long
value	long
=	O
syms	pointer
[	O
idx	int
]	O
->	O
value	long
;	O
elf_symbol_type	struct
*	O
type_ptr	pointer
;	O
flagword	int
flags	int
=	O
syms	pointer
[	O
idx	int
]	O
->	O
flags	int
;	O
int	O
type	enum
;	O
if	O
(	O
!	O
name_local_sections	int
&&	O
(	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_GLOBAL	O
)	O
)	O
==	O
BSF_SECTION_SYM	O
)	O
{	O
sym	pointer
.	O
st_name	array
=	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
;	O
}	O
else	O
{	O
sym	pointer
.	O
st_name	array
=	O
(	O
unsigned	O
long	O
)	O
_bfd_elf_strtab_add	function
(	O
stt	pointer
,	O
syms	pointer
[	O
idx	int
]	O
->	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
sym	pointer
.	O
st_name	array
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
goto	O
error_return	O
;	O
}	O
type_ptr	pointer
=	O
elf_symbol_from	O
(	O
abfd	pointer
,	O
syms	pointer
[	O
idx	int
]	O
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
==	O
0	int
&&	O
bfd_is_com_section	function
(	O
syms	pointer
[	O
idx	int
]	O
->	O
section	pointer
)	O
)	O
{	O
sym	pointer
.	O
st_size	long
=	O
value	long
;	O
if	O
(	O
type_ptr	pointer
==	O
NULL	O
||	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_value	array
==	O
0	int
)	O
sym	pointer
.	O
st_value	array
=	O
value	long
>=	O
16	int
?	O
16	int
:	O
(	O
1	int
<<	O
bfd_log2	function
(	O
value	long
)	O
)	O
;	O
else	O
sym	pointer
.	O
st_value	array
=	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_value	array
;	O
sym	pointer
.	O
st_shndx	array
=	O
_bfd_elf_section_from_bfd_section	function
(	O
abfd	pointer
,	O
syms	pointer
[	O
idx	int
]	O
->	O
section	pointer
)	O
;	O
}	O
else	O
{	O
asection	struct
*	O
sec	pointer
=	O
syms	pointer
[	O
idx	int
]	O
->	O
section	pointer
;	O
unsigned	O
int	O
shndx	pointer
;	O
if	O
(	O
sec	pointer
->	O
output_section	pointer
)	O
{	O
value	long
+=	O
sec	pointer
->	O
output_offset	long
;	O
sec	pointer
=	O
sec	pointer
->	O
output_section	pointer
;	O
}	O
if	O
(	O
!	O
relocatable_p	int
)	O
value	long
+=	O
sec	pointer
->	O
vma	long
;	O
sym	pointer
.	O
st_value	array
=	O
value	long
;	O
sym	pointer
.	O
st_size	long
=	O
type_ptr	pointer
?	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_size	long
:	O
0	int
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
&&	O
type_ptr	pointer
!=	O
NULL	O
&&	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
!=	O
0	int
)	O
{	O
shndx	pointer
=	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
;	O
switch	O
(	O
shndx	pointer
)	O
{	O
case	O
MAP_ONESYMTAB	O
:	O
shndx	pointer
=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
;	O
break	O
;	O
case	O
MAP_DYNSYMTAB	O
:	O
shndx	pointer
=	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
;	O
break	O
;	O
case	O
MAP_STRTAB	O
:	O
shndx	pointer
=	O
elf_strtab_sec	O
(	O
abfd	pointer
)	O
;	O
break	O
;	O
case	O
MAP_SHSTRTAB	O
:	O
shndx	pointer
=	O
elf_shstrtab_sec	O
(	O
abfd	pointer
)	O
;	O
break	O
;	O
case	O
MAP_SYM_SHNDX	O
:	O
if	O
(	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
)	O
shndx	pointer
=	O
elf_symtab_shndx_list	O
(	O
abfd	pointer
)	O
->	O
ndx	int
;	O
break	O
;	O
default	O
:	O
shndx	pointer
=	O
SHN_ABS	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
shndx	pointer
=	O
_bfd_elf_section_from_bfd_section	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
shndx	pointer
==	O
SHN_BAD	O
)	O
{	O
asection	struct
*	O
sec2	pointer
;	O
sec2	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
sec2	pointer
!=	O
NULL	O
)	O
shndx	pointer
=	O
_bfd_elf_section_from_bfd_section	function
(	O
abfd	pointer
,	O
sec2	pointer
)	O
;	O
if	O
(	O
shndx	pointer
==	O
SHN_BAD	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"unable to find equivalent output section"	pointer
" for symbol '%s' from section '%s'"	pointer
)	O
,	O
syms	pointer
[	O
idx	int
]	O
->	O
name	pointer
?	O
syms	pointer
[	O
idx	int
]	O
->	O
name	pointer
:	O
"<Local sym>"	pointer
,	O
sec	pointer
->	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
}	O
sym	pointer
.	O
st_shndx	array
=	O
shndx	pointer
;	O
}	O
if	O
(	O
(	O
flags	int
&	O
BSF_THREAD_LOCAL	O
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_TLS	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_GNU_INDIRECT_FUNCTION	O
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_GNU_IFUNC	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_FUNCTION	O
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_FUNC	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_OBJECT	O
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_OBJECT	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_RELC	O
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_RELC	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_SRELC	O
)	O
!=	O
0	int
)	O
type	enum
=	O
STT_SRELC	int
;	O
else	O
type	enum
=	O
STT_NOTYPE	int
;	O
if	O
(	O
syms	pointer
[	O
idx	int
]	O
->	O
section	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
type	enum
=	O
STT_TLS	int
;	O
if	O
(	O
type_ptr	pointer
!=	O
NULL	O
&&	O
bed	pointer
->	O
elf_backend_get_symbol_type	pointer
)	O
type	enum
=	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_get_symbol_type	pointer
)	O
(	O
&	O
type_ptr	pointer
->	O
internal_elf_sym	struct
,	O
type	enum
)	O
)	O
;	O
if	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
{	O
if	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_GLOBAL	int
,	O
STT_SECTION	int
)	O
;	O
else	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_SECTION	int
)	O
;	O
}	O
else	O
if	O
(	O
bfd_is_com_section	function
(	O
syms	pointer
[	O
idx	int
]	O
->	O
section	pointer
)	O
)	O
{	O
if	O
(	O
type	enum
!=	O
STT_TLS	int
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_CONVERT_ELF_COMMON	int
)	O
)	O
type	enum
=	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_USE_ELF_STT_COMMON	int
)	O
?	O
STT_COMMON	int
:	O
STT_OBJECT	int
)	O
;	O
else	O
type	enum
=	O
(	O
(	O
flags	int
&	O
BSF_ELF_COMMON	O
)	O
!=	O
0	int
?	O
STT_COMMON	int
:	O
STT_OBJECT	int
)	O
;	O
}	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_GLOBAL	int
,	O
type	enum
)	O
;	O
}	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
syms	pointer
[	O
idx	int
]	O
->	O
section	pointer
)	O
)	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
(	O
(	O
flags	int
&	O
BSF_WEAK	O
)	O
?	O
STB_WEAK	int
:	O
STB_GLOBAL	int
)	O
,	O
type	enum
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
BSF_FILE	O
)	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_LOCAL	int
,	O
STT_FILE	int
)	O
;	O
else	O
{	O
int	O
bind	int
=	O
STB_LOCAL	int
;	O
if	O
(	O
flags	int
&	O
BSF_LOCAL	O
)	O
bind	int
=	O
STB_LOCAL	int
;	O
else	O
if	O
(	O
flags	int
&	O
BSF_GNU_UNIQUE	O
)	O
bind	int
=	O
STB_GNU_UNIQUE	int
;	O
else	O
if	O
(	O
flags	int
&	O
BSF_WEAK	O
)	O
bind	int
=	O
STB_WEAK	int
;	O
else	O
if	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
bind	int
=	O
STB_GLOBAL	int
;	O
sym	pointer
.	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
bind	int
,	O
type	enum
)	O
;	O
}	O
if	O
(	O
type_ptr	pointer
!=	O
NULL	O
)	O
{	O
sym	pointer
.	O
st_other	array
=	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_other	array
;	O
sym	pointer
.	O
st_target_internal	char
=	O
type_ptr	pointer
->	O
internal_elf_sym	struct
.	O
st_target_internal	char
;	O
}	O
else	O
{	O
sym	pointer
.	O
st_other	array
=	O
0	int
;	O
sym	pointer
.	O
st_target_internal	char
=	O
0	int
;	O
}	O
idx	int
++	O
;	O
symstrtab	pointer
[	O
idx	int
]	O
.	O
sym	pointer
=	O
sym	pointer
;	O
symstrtab	pointer
[	O
idx	int
]	O
.	O
dest_index	long
=	O
outbound_syms_index	long
;	O
symstrtab	pointer
[	O
idx	int
]	O
.	O
destshndx_index	long
=	O
outbound_shndx_index	long
;	O
outbound_syms_index	long
++	O
;	O
if	O
(	O
outbound_shndx	pointer
!=	O
NULL	O
)	O
outbound_shndx_index	long
++	O
;	O
}	O
_bfd_elf_strtab_finalize	function
(	O
stt	pointer
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<=	O
symcount	int
;	O
idx	int
++	O
)	O
{	O
struct	O
elf_sym_strtab	struct
*	O
elfsym	pointer
=	O
&	O
symstrtab	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
=	O
0	int
;	O
else	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
=	O
_bfd_elf_strtab_offset	function
(	O
stt	pointer
,	O
elfsym	pointer
->	O
sym	pointer
.	O
st_name	array
)	O
;	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_out	pointer
(	O
abfd	pointer
,	O
&	O
elfsym	pointer
->	O
sym	pointer
,	O
(	O
outbound_syms	pointer
+	O
(	O
elfsym	pointer
->	O
dest_index	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
)	O
,	O
(	O
outbound_shndx	pointer
+	O
(	O
elfsym	pointer
->	O
destshndx_index	long
*	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
)	O
)	O
)	O
;	O
}	O
free	function
(	O
symstrtab	pointer
)	O
;	O
*	O
sttp	pointer
=	O
stt	pointer
;	O
symstrtab_hdr	pointer
->	O
sh_size	array
=	O
_bfd_elf_strtab_size	function
(	O
stt	pointer
)	O
;	O
symstrtab_hdr	pointer
->	O
sh_type	array
=	O
SHT_STRTAB	int
;	O
symstrtab_hdr	pointer
->	O
sh_flags	array
=	O
bed	pointer
->	O
elf_strtab_flags	long
;	O
symstrtab_hdr	pointer
->	O
sh_addr	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_entsize	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_link	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_info	array
=	O
0	int
;	O
symstrtab_hdr	pointer
->	O
sh_addralign	array
=	O
1	int
;	O
return	O
TRUE	int
;	O
}	O
long	O
_bfd_elf_get_symtab_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
symcount	int
;	O
long	O
symtab_size	long
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
symtab_hdr	struct
;	O
symcount	int
=	O
hdr	pointer
->	O
sh_size	array
/	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
symcount	int
>=	O
LONG_MAX	O
/	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_too_big	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
symtab_size	long
=	O
(	O
symcount	int
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
;	O
if	O
(	O
symcount	int
>	O
0	int
)	O
symtab_size	long
-=	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
;	O
return	O
symtab_size	long
;	O
}	O
long	O
_bfd_elf_get_dynamic_symtab_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
symcount	int
;	O
long	O
symtab_size	long
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynsymtab_hdr	struct
;	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
symcount	int
=	O
hdr	pointer
->	O
sh_size	array
/	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
sizeof_sym	char
;	O
if	O
(	O
symcount	int
>=	O
LONG_MAX	O
/	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_too_big	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
symtab_size	long
=	O
(	O
symcount	int
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
;	O
if	O
(	O
symcount	int
>	O
0	int
)	O
symtab_size	long
-=	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
;	O
return	O
symtab_size	long
;	O
}	O
long	O
_bfd_elf_get_reloc_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
sec_ptr	pointer
asect	pointer
)	O
{	O
return	O
(	O
asect	pointer
->	O
reloc_count	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
arelent	struct
*	O
)	O
;	O
}	O
long	O
_bfd_elf_canonicalize_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
section	pointer
,	O
arelent	struct
*	O
*	O
relptr	pointer
,	O
asymbol	struct
*	O
*	O
symbols	pointer
)	O
{	O
arelent	struct
*	O
tblptr	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
bed	pointer
->	O
s	pointer
->	O
slurp_reloc_table	pointer
(	O
abfd	pointer
,	O
section	pointer
,	O
symbols	pointer
,	O
FALSE	int
)	O
)	O
return	O
-	O
1	int
;	O
tblptr	pointer
=	O
section	pointer
->	O
relocation	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
section	pointer
->	O
reloc_count	int
;	O
i	pointer
++	O
)	O
*	O
relptr	pointer
++	O
=	O
tblptr	pointer
++	O
;	O
*	O
relptr	pointer
=	O
NULL	O
;	O
return	O
section	pointer
->	O
reloc_count	int
;	O
}	O
long	O
_bfd_elf_canonicalize_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
allocation	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
long	O
symcount	int
=	O
bed	pointer
->	O
s	pointer
->	O
slurp_symbol_table	pointer
(	O
abfd	pointer
,	O
allocation	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
symcount	int
>=	O
0	int
)	O
abfd	pointer
->	O
symcount	int
=	O
symcount	int
;	O
return	O
symcount	int
;	O
}	O
long	O
_bfd_elf_canonicalize_dynamic_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
allocation	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
long	O
symcount	int
=	O
bed	pointer
->	O
s	pointer
->	O
slurp_symbol_table	pointer
(	O
abfd	pointer
,	O
allocation	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
symcount	int
>=	O
0	int
)	O
abfd	pointer
->	O
dynsymcount	int
=	O
symcount	int
;	O
return	O
symcount	int
;	O
}	O
long	O
_bfd_elf_get_dynamic_reloc_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
count	int
;	O
asection	struct
*	O
s	pointer
;	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
count	int
=	O
1	int
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_link	array
==	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
&&	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_REL	int
||	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_RELA	int
)	O
)	O
{	O
count	int
+=	O
s	pointer
->	O
size	long
/	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
;	O
if	O
(	O
count	int
>	O
LONG_MAX	O
/	O
sizeof	O
(	O
arelent	struct
*	O
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_file_too_big	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
count	int
*	O
sizeof	O
(	O
arelent	struct
*	O
)	O
;	O
}	O
long	O
_bfd_elf_canonicalize_dynamic_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
*	O
storage	pointer
,	O
asymbol	struct
*	O
*	O
syms	pointer
)	O
{	O
bfd_boolean	int
(	O
*	O
slurp_relocs	pointer
)	O
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
asymbol	struct
*	O
*	O
,	O
bfd_boolean	int
)	O
;	O
asection	struct
*	O
s	pointer
;	O
long	O
ret	pointer
;	O
if	O
(	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
slurp_relocs	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
slurp_reloc_table	pointer
;	O
ret	pointer
=	O
0	int
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_link	array
==	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
&&	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_REL	int
||	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_RELA	int
)	O
)	O
{	O
arelent	struct
*	O
p	pointer
;	O
long	O
count	int
,	O
i	pointer
;	O
if	O
(	O
!	O
(	O
*	O
slurp_relocs	pointer
)	O
(	O
abfd	pointer
,	O
s	pointer
,	O
syms	pointer
,	O
TRUE	int
)	O
)	O
return	O
-	O
1	int
;	O
count	int
=	O
s	pointer
->	O
size	long
/	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
;	O
p	pointer
=	O
s	pointer
->	O
relocation	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
*	O
storage	pointer
++	O
=	O
p	pointer
++	O
;	O
ret	pointer
+=	O
count	int
;	O
}	O
}	O
*	O
storage	pointer
=	O
NULL	O
;	O
return	O
ret	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_slurp_version_tables	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
default_imported_symver	int
)	O
{	O
bfd_byte	char
*	O
contents	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
freeidx	int
=	O
0	int
;	O
if	O
(	O
elf_dynverref	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
Elf_External_Verneed	struct
*	O
everneed	pointer
;	O
Elf_Internal_Verneed	struct
*	O
iverneed	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_byte	char
*	O
contents_end	pointer
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynverref_hdr	struct
;	O
if	O
(	O
hdr	pointer
->	O
sh_info	array
==	O
0	int
||	O
hdr	pointer
->	O
sh_info	array
>	O
hdr	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
)	O
{	O
error_return_bad_verref	O
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: .gnu.version_r invalid entry"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
error_return_verref	O
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
=	O
NULL	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverrefs	int
=	O
0	int
;	O
goto	O
error_return	O
;	O
}	O
ufile_ptr	long
filesize	long
=	O
bfd_get_file_size	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
filesize	long
>	O
0	int
&&	O
filesize	long
<	O
hdr	pointer
->	O
sh_size	array
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_memory	int
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"error: %pB version reference section is too large (%#"	pointer
PRIx64	O
" bytes)"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
hdr	pointer
->	O
sh_size	array
)	O
;	O
goto	O
error_return_verref	O
;	O
}	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
hdr	pointer
->	O
sh_size	array
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
goto	O
error_return_verref	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
contents	pointer
,	O
hdr	pointer
->	O
sh_size	array
,	O
abfd	pointer
)	O
!=	O
hdr	pointer
->	O
sh_size	array
)	O
goto	O
error_return_verref	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
=	O
(	O
Elf_Internal_Verneed	struct
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_info	array
,	O
sizeof	O
(	O
Elf_Internal_Verneed	struct
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
==	O
NULL	O
)	O
goto	O
error_return_verref	O
;	O
BFD_ASSERT	O
(	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
==	O
sizeof	O
(	O
Elf_External_Vernaux	struct
)	O
)	O
;	O
contents_end	pointer
=	O
contents	pointer
+	O
hdr	pointer
->	O
sh_size	array
-	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
;	O
everneed	pointer
=	O
(	O
Elf_External_Verneed	struct
*	O
)	O
contents	pointer
;	O
iverneed	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verref	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr	pointer
->	O
sh_info	array
;	O
i	pointer
++	O
,	O
iverneed	pointer
++	O
)	O
{	O
Elf_External_Vernaux	struct
*	O
evernaux	pointer
;	O
Elf_Internal_Vernaux	struct
*	O
ivernaux	pointer
;	O
unsigned	O
int	O
j	int
;	O
_bfd_elf_swap_verneed_in	function
(	O
abfd	pointer
,	O
everneed	pointer
,	O
iverneed	pointer
)	O
;	O
iverneed	pointer
->	O
vn_bfd	pointer
=	O
abfd	pointer
;	O
iverneed	pointer
->	O
vn_filename	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
iverneed	pointer
->	O
vn_file	array
)	O
;	O
if	O
(	O
iverneed	pointer
->	O
vn_filename	pointer
==	O
NULL	O
)	O
goto	O
error_return_bad_verref	O
;	O
if	O
(	O
iverneed	pointer
->	O
vn_cnt	array
==	O
0	int
)	O
iverneed	pointer
->	O
vn_auxptr	pointer
=	O
NULL	O
;	O
else	O
{	O
iverneed	pointer
->	O
vn_auxptr	pointer
=	O
(	O
struct	O
elf_internal_vernaux	struct
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
iverneed	pointer
->	O
vn_cnt	array
,	O
sizeof	O
(	O
Elf_Internal_Vernaux	struct
)	O
)	O
;	O
if	O
(	O
iverneed	pointer
->	O
vn_auxptr	pointer
==	O
NULL	O
)	O
goto	O
error_return_verref	O
;	O
}	O
if	O
(	O
iverneed	pointer
->	O
vn_aux	array
>	O
(	O
size_t	long
)	O
(	O
contents_end	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
everneed	pointer
)	O
)	O
goto	O
error_return_bad_verref	O
;	O
evernaux	pointer
=	O
(	O
(	O
Elf_External_Vernaux	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
everneed	pointer
+	O
iverneed	pointer
->	O
vn_aux	array
)	O
)	O
;	O
ivernaux	pointer
=	O
iverneed	pointer
->	O
vn_auxptr	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
iverneed	pointer
->	O
vn_cnt	array
;	O
j	int
++	O
,	O
ivernaux	pointer
++	O
)	O
{	O
_bfd_elf_swap_vernaux_in	function
(	O
abfd	pointer
,	O
evernaux	pointer
,	O
ivernaux	pointer
)	O
;	O
ivernaux	pointer
->	O
vna_nodename	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
ivernaux	pointer
->	O
vna_name	array
)	O
;	O
if	O
(	O
ivernaux	pointer
->	O
vna_nodename	pointer
==	O
NULL	O
)	O
goto	O
error_return_bad_verref	O
;	O
if	O
(	O
ivernaux	pointer
->	O
vna_other	array
>	O
freeidx	int
)	O
freeidx	int
=	O
ivernaux	pointer
->	O
vna_other	array
;	O
ivernaux	pointer
->	O
vna_nextptr	pointer
=	O
NULL	O
;	O
if	O
(	O
ivernaux	pointer
->	O
vna_next	array
==	O
0	int
)	O
{	O
iverneed	pointer
->	O
vn_cnt	array
=	O
j	int
+	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
j	int
+	O
1	int
<	O
iverneed	pointer
->	O
vn_cnt	array
)	O
ivernaux	pointer
->	O
vna_nextptr	pointer
=	O
ivernaux	pointer
+	O
1	int
;	O
if	O
(	O
ivernaux	pointer
->	O
vna_next	array
>	O
(	O
size_t	long
)	O
(	O
contents_end	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
evernaux	pointer
)	O
)	O
goto	O
error_return_bad_verref	O
;	O
evernaux	pointer
=	O
(	O
(	O
Elf_External_Vernaux	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
evernaux	pointer
+	O
ivernaux	pointer
->	O
vna_next	array
)	O
)	O
;	O
}	O
iverneed	pointer
->	O
vn_nextref	pointer
=	O
NULL	O
;	O
if	O
(	O
iverneed	pointer
->	O
vn_next	array
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	pointer
+	O
1	int
<	O
hdr	pointer
->	O
sh_info	array
)	O
iverneed	pointer
->	O
vn_nextref	pointer
=	O
iverneed	pointer
+	O
1	int
;	O
if	O
(	O
iverneed	pointer
->	O
vn_next	array
>	O
(	O
size_t	long
)	O
(	O
contents_end	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
everneed	pointer
)	O
)	O
goto	O
error_return_bad_verref	O
;	O
everneed	pointer
=	O
(	O
(	O
Elf_External_Verneed	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
everneed	pointer
+	O
iverneed	pointer
->	O
vn_next	array
)	O
)	O
;	O
}	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverrefs	int
=	O
i	pointer
;	O
free	function
(	O
contents	pointer
)	O
;	O
contents	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
elf_dynverdef	O
(	O
abfd	pointer
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
Elf_External_Verdef	struct
*	O
everdef	pointer
;	O
Elf_Internal_Verdef	struct
*	O
iverdef	pointer
;	O
Elf_Internal_Verdef	struct
*	O
iverdefarr	pointer
;	O
Elf_Internal_Verdef	struct
iverdefmem	struct
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
maxidx	int
;	O
bfd_byte	char
*	O
contents_end_def	pointer
,	O
*	O
contents_end_aux	pointer
;	O
hdr	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dynverdef_hdr	struct
;	O
if	O
(	O
hdr	pointer
->	O
sh_info	array
==	O
0	int
||	O
hdr	pointer
->	O
sh_size	array
<	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
)	O
{	O
error_return_bad_verdef	O
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: .gnu.version_d invalid entry"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
error_return_verdef	O
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
=	O
NULL	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
=	O
0	int
;	O
goto	O
error_return	O
;	O
}	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
hdr	pointer
->	O
sh_size	array
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
goto	O
error_return_verdef	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_offset	array
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
contents	pointer
,	O
hdr	pointer
->	O
sh_size	array
,	O
abfd	pointer
)	O
!=	O
hdr	pointer
->	O
sh_size	array
)	O
goto	O
error_return_verdef	O
;	O
BFD_ASSERT	O
(	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
>=	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
)	O
;	O
contents_end_def	pointer
=	O
contents	pointer
+	O
hdr	pointer
->	O
sh_size	array
-	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
;	O
contents_end_aux	pointer
=	O
contents	pointer
+	O
hdr	pointer
->	O
sh_size	array
-	O
sizeof	O
(	O
Elf_External_Verdaux	struct
)	O
;	O
everdef	pointer
=	O
(	O
Elf_External_Verdef	struct
*	O
)	O
contents	pointer
;	O
maxidx	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr	pointer
->	O
sh_info	array
;	O
++	O
i	pointer
)	O
{	O
_bfd_elf_swap_verdef_in	function
(	O
abfd	pointer
,	O
everdef	pointer
,	O
&	O
iverdefmem	struct
)	O
;	O
if	O
(	O
(	O
iverdefmem	struct
.	O
vd_ndx	array
&	O
(	O
(	O
unsigned	O
)	O
VERSYM_VERSION	int
)	O
)	O
==	O
0	int
)	O
goto	O
error_return_bad_verdef	O
;	O
if	O
(	O
(	O
iverdefmem	struct
.	O
vd_ndx	array
&	O
(	O
(	O
unsigned	O
)	O
VERSYM_VERSION	int
)	O
)	O
>	O
maxidx	int
)	O
maxidx	int
=	O
iverdefmem	struct
.	O
vd_ndx	array
&	O
(	O
(	O
unsigned	O
)	O
VERSYM_VERSION	int
)	O
;	O
if	O
(	O
iverdefmem	struct
.	O
vd_next	array
==	O
0	int
)	O
break	O
;	O
if	O
(	O
iverdefmem	struct
.	O
vd_next	array
>	O
(	O
size_t	long
)	O
(	O
contents_end_def	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
everdef	pointer
)	O
)	O
goto	O
error_return_bad_verdef	O
;	O
everdef	pointer
=	O
(	O
(	O
Elf_External_Verdef	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
everdef	pointer
+	O
iverdefmem	struct
.	O
vd_next	array
)	O
)	O
;	O
}	O
if	O
(	O
default_imported_symver	int
)	O
{	O
if	O
(	O
freeidx	int
>	O
maxidx	int
)	O
maxidx	int
=	O
++	O
freeidx	int
;	O
else	O
freeidx	int
=	O
++	O
maxidx	int
;	O
}	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
=	O
(	O
Elf_Internal_Verdef	struct
*	O
)	O
bfd_zalloc2	function
(	O
abfd	pointer
,	O
maxidx	int
,	O
sizeof	O
(	O
Elf_Internal_Verdef	struct
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
==	O
NULL	O
)	O
goto	O
error_return_verdef	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
=	O
maxidx	int
;	O
everdef	pointer
=	O
(	O
Elf_External_Verdef	struct
*	O
)	O
contents	pointer
;	O
iverdefarr	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
hdr	pointer
->	O
sh_info	array
;	O
i	pointer
++	O
)	O
{	O
Elf_External_Verdaux	struct
*	O
everdaux	pointer
;	O
Elf_Internal_Verdaux	struct
*	O
iverdaux	pointer
;	O
unsigned	O
int	O
j	int
;	O
_bfd_elf_swap_verdef_in	function
(	O
abfd	pointer
,	O
everdef	pointer
,	O
&	O
iverdefmem	struct
)	O
;	O
if	O
(	O
(	O
iverdefmem	struct
.	O
vd_ndx	array
&	O
VERSYM_VERSION	int
)	O
==	O
0	int
)	O
goto	O
error_return_bad_verdef	O
;	O
iverdef	pointer
=	O
&	O
iverdefarr	pointer
[	O
(	O
iverdefmem	struct
.	O
vd_ndx	array
&	O
VERSYM_VERSION	int
)	O
-	O
1	int
]	O
;	O
memcpy	function
(	O
iverdef	pointer
,	O
&	O
iverdefmem	struct
,	O
offsetof	O
(	O
Elf_Internal_Verdef	struct
,	O
vd_bfd	pointer
)	O
)	O
;	O
iverdef	pointer
->	O
vd_bfd	pointer
=	O
abfd	pointer
;	O
if	O
(	O
iverdef	pointer
->	O
vd_cnt	array
==	O
0	int
)	O
iverdef	pointer
->	O
vd_auxptr	pointer
=	O
NULL	O
;	O
else	O
{	O
iverdef	pointer
->	O
vd_auxptr	pointer
=	O
(	O
struct	O
elf_internal_verdaux	struct
*	O
)	O
bfd_alloc2	function
(	O
abfd	pointer
,	O
iverdef	pointer
->	O
vd_cnt	array
,	O
sizeof	O
(	O
Elf_Internal_Verdaux	struct
)	O
)	O
;	O
if	O
(	O
iverdef	pointer
->	O
vd_auxptr	pointer
==	O
NULL	O
)	O
goto	O
error_return_verdef	O
;	O
}	O
if	O
(	O
iverdef	pointer
->	O
vd_aux	array
>	O
(	O
size_t	long
)	O
(	O
contents_end_aux	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
everdef	pointer
)	O
)	O
goto	O
error_return_bad_verdef	O
;	O
everdaux	pointer
=	O
(	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
everdef	pointer
+	O
iverdef	pointer
->	O
vd_aux	array
)	O
)	O
;	O
iverdaux	pointer
=	O
iverdef	pointer
->	O
vd_auxptr	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
iverdef	pointer
->	O
vd_cnt	array
;	O
j	int
++	O
,	O
iverdaux	pointer
++	O
)	O
{	O
_bfd_elf_swap_verdaux_in	function
(	O
abfd	pointer
,	O
everdaux	pointer
,	O
iverdaux	pointer
)	O
;	O
iverdaux	pointer
->	O
vda_nodename	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
abfd	pointer
,	O
hdr	pointer
->	O
sh_link	array
,	O
iverdaux	pointer
->	O
vda_name	array
)	O
;	O
if	O
(	O
iverdaux	pointer
->	O
vda_nodename	pointer
==	O
NULL	O
)	O
goto	O
error_return_bad_verdef	O
;	O
iverdaux	pointer
->	O
vda_nextptr	pointer
=	O
NULL	O
;	O
if	O
(	O
iverdaux	pointer
->	O
vda_next	array
==	O
0	int
)	O
{	O
iverdef	pointer
->	O
vd_cnt	array
=	O
j	int
+	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
j	int
+	O
1	int
<	O
iverdef	pointer
->	O
vd_cnt	array
)	O
iverdaux	pointer
->	O
vda_nextptr	pointer
=	O
iverdaux	pointer
+	O
1	int
;	O
if	O
(	O
iverdaux	pointer
->	O
vda_next	array
>	O
(	O
size_t	long
)	O
(	O
contents_end_aux	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
everdaux	pointer
)	O
)	O
goto	O
error_return_bad_verdef	O
;	O
everdaux	pointer
=	O
(	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
everdaux	pointer
+	O
iverdaux	pointer
->	O
vda_next	array
)	O
)	O
;	O
}	O
iverdef	pointer
->	O
vd_nodename	pointer
=	O
NULL	O
;	O
if	O
(	O
iverdef	pointer
->	O
vd_cnt	array
)	O
iverdef	pointer
->	O
vd_nodename	pointer
=	O
iverdef	pointer
->	O
vd_auxptr	pointer
->	O
vda_nodename	pointer
;	O
iverdef	pointer
->	O
vd_nextdef	pointer
=	O
NULL	O
;	O
if	O
(	O
iverdef	pointer
->	O
vd_next	array
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
iverdef	pointer
-	O
iverdefarr	pointer
)	O
+	O
1	int
<	O
maxidx	int
)	O
iverdef	pointer
->	O
vd_nextdef	pointer
=	O
iverdef	pointer
+	O
1	int
;	O
everdef	pointer
=	O
(	O
(	O
Elf_External_Verdef	struct
*	O
)	O
(	O
(	O
bfd_byte	char
*	O
)	O
everdef	pointer
+	O
iverdef	pointer
->	O
vd_next	array
)	O
)	O
;	O
}	O
free	function
(	O
contents	pointer
)	O
;	O
contents	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
default_imported_symver	int
)	O
{	O
if	O
(	O
freeidx	int
<	O
3	int
)	O
freeidx	int
=	O
3	int
;	O
else	O
freeidx	int
++	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
=	O
(	O
Elf_Internal_Verdef	struct
*	O
)	O
bfd_zalloc2	function
(	O
abfd	pointer
,	O
freeidx	int
,	O
sizeof	O
(	O
Elf_Internal_Verdef	struct
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
cverdefs	int
=	O
freeidx	int
;	O
}	O
if	O
(	O
default_imported_symver	int
)	O
{	O
Elf_Internal_Verdef	struct
*	O
iverdef	pointer
;	O
Elf_Internal_Verdaux	struct
*	O
iverdaux	pointer
;	O
iverdef	pointer
=	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
verdef	pointer
[	O
freeidx	int
-	O
1	int
]	O
;	O
iverdef	pointer
->	O
vd_version	array
=	O
VER_DEF_CURRENT	int
;	O
iverdef	pointer
->	O
vd_flags	array
=	O
0	int
;	O
iverdef	pointer
->	O
vd_ndx	array
=	O
freeidx	int
;	O
iverdef	pointer
->	O
vd_cnt	array
=	O
1	int
;	O
iverdef	pointer
->	O
vd_bfd	pointer
=	O
abfd	pointer
;	O
iverdef	pointer
->	O
vd_nodename	pointer
=	O
bfd_elf_get_dt_soname	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
iverdef	pointer
->	O
vd_nodename	pointer
==	O
NULL	O
)	O
goto	O
error_return_verdef	O
;	O
iverdef	pointer
->	O
vd_nextdef	pointer
=	O
NULL	O
;	O
iverdef	pointer
->	O
vd_auxptr	pointer
=	O
(	O
(	O
struct	O
elf_internal_verdaux	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
Elf_Internal_Verdaux	struct
)	O
)	O
)	O
;	O
if	O
(	O
iverdef	pointer
->	O
vd_auxptr	pointer
==	O
NULL	O
)	O
goto	O
error_return_verdef	O
;	O
iverdaux	pointer
=	O
iverdef	pointer
->	O
vd_auxptr	pointer
;	O
iverdaux	pointer
->	O
vda_nodename	pointer
=	O
iverdef	pointer
->	O
vd_nodename	pointer
;	O
}	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
contents	pointer
!=	O
NULL	O
)	O
free	function
(	O
contents	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
asymbol	struct
*	O
_bfd_elf_make_empty_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
elf_symbol_type	struct
*	O
newsym	pointer
;	O
newsym	pointer
=	O
(	O
elf_symbol_type	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
newsym	pointer
)	O
)	O
;	O
if	O
(	O
!	O
newsym	pointer
)	O
return	O
NULL	O
;	O
newsym	pointer
->	O
symbol	pointer
.	O
the_bfd	pointer
=	O
abfd	pointer
;	O
return	O
&	O
newsym	pointer
->	O
symbol	pointer
;	O
}	O
void	O
_bfd_elf_get_symbol_info	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
symbol	pointer
,	O
symbol_info	struct
*	O
ret	pointer
)	O
{	O
bfd_symbol_info	function
(	O
symbol	pointer
,	O
ret	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_is_local_label_name	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'L'	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'.'	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
2	int
]	O
==	O
'L'	O
&&	O
name	pointer
[	O
3	int
]	O
==	O
'_'	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'L'	O
&&	O
ISDIGIT	O
(	O
name	pointer
[	O
1	int
]	O
)	O
)	O
{	O
bfd_boolean	int
ret	pointer
=	O
FALSE	int
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
c	struct
;	O
for	O
(	O
p	pointer
=	O
name	pointer
+	O
2	int
;	O
(	O
c	struct
=	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
c	struct
==	O
1	int
||	O
c	struct
==	O
2	int
)	O
{	O
if	O
(	O
c	struct
==	O
1	int
&&	O
p	pointer
==	O
name	pointer
+	O
2	int
)	O
return	O
TRUE	int
;	O
ret	pointer
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
ISDIGIT	O
(	O
c	struct
)	O
)	O
{	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
return	O
ret	pointer
;	O
}	O
return	O
FALSE	int
;	O
}	O
alent	struct
*	O
_bfd_elf_get_lineno	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
symbol	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
abort	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
bfd_boolean	int
_bfd_elf_set_arch_mach	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
enum	O
bfd_architecture	enum
arch	enum
,	O
unsigned	O
long	O
machine	long
)	O
{	O
if	O
(	O
arch	enum
!=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
arch	enum
&&	O
arch	enum
!=	O
bfd_arch_unknown	int
&&	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
arch	enum
!=	O
bfd_arch_unknown	int
)	O
return	O
FALSE	int
;	O
return	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
arch	enum
,	O
machine	long
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_find_nearest_line	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
symbols	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
offset	long
,	O
const	O
char	O
*	O
*	O
filename_ptr	pointer
,	O
const	O
char	O
*	O
*	O
functionname_ptr	pointer
,	O
unsigned	O
int	O
*	O
line_ptr	pointer
,	O
unsigned	O
int	O
*	O
discriminator_ptr	pointer
)	O
{	O
bfd_boolean	int
found	int
;	O
if	O
(	O
_bfd_dwarf2_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
NULL	O
,	O
section	pointer
,	O
offset	long
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
discriminator_ptr	pointer
,	O
dwarf_debug_sections	array
,	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
_bfd_dwarf1_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
section	pointer
,	O
offset	long
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
)	O
)	O
{	O
if	O
(	O
!	O
*	O
functionname_ptr	pointer
)	O
_bfd_elf_find_function	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
section	pointer
,	O
offset	long
,	O
*	O
filename_ptr	pointer
?	O
NULL	O
:	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
_bfd_stab_section_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
section	pointer
,	O
offset	long
,	O
&	O
found	int
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
line_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
found	int
&&	O
(	O
*	O
functionname_ptr	pointer
||	O
*	O
line_ptr	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
symbols	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_elf_find_function	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
section	pointer
,	O
offset	long
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
)	O
)	O
return	O
FALSE	int
;	O
*	O
line_ptr	pointer
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_find_line	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
symbols	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
const	O
char	O
*	O
*	O
filename_ptr	pointer
,	O
unsigned	O
int	O
*	O
line_ptr	pointer
)	O
{	O
return	O
_bfd_dwarf2_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
symbol	pointer
,	O
NULL	O
,	O
0	int
,	O
filename_ptr	pointer
,	O
NULL	O
,	O
line_ptr	pointer
,	O
NULL	O
,	O
dwarf_debug_sections	array
,	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_find_inliner_info	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
*	O
filename_ptr	pointer
,	O
const	O
char	O
*	O
*	O
functionname_ptr	pointer
,	O
unsigned	O
int	O
*	O
line_ptr	pointer
)	O
{	O
bfd_boolean	int
found	int
;	O
found	int
=	O
_bfd_dwarf2_find_inliner_info	function
(	O
abfd	pointer
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
&	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
;	O
return	O
found	int
;	O
}	O
int	O
_bfd_elf_sizeof_headers	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
int	O
ret	pointer
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_ehdr	char
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
bfd_size_type	long
phdr_size	long
=	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
phdr_size	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
{	O
struct	O
elf_segment_map	struct
*	O
m	pointer
;	O
phdr_size	long
=	O
0	int
;	O
for	O
(	O
m	pointer
=	O
elf_seg_map	O
(	O
abfd	pointer
)	O
;	O
m	pointer
!=	O
NULL	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
)	O
phdr_size	long
+=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_phdr	char
;	O
if	O
(	O
phdr_size	long
==	O
0	int
)	O
phdr_size	long
=	O
get_program_header_size	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
elf_program_header_size	O
(	O
abfd	pointer
)	O
=	O
phdr_size	long
;	O
ret	pointer
+=	O
phdr_size	long
;	O
}	O
return	O
ret	pointer
;	O
}	O
bfd_boolean	int
_bfd_elf_set_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
section	pointer
,	O
const	O
void	O
*	O
location	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
count	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
file_ptr	long
pos	long
;	O
if	O
(	O
!	O
abfd	pointer
->	O
output_has_begun	int
&&	O
!	O
_bfd_elf_compute_section_file_positions	function
(	O
abfd	pointer
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
count	int
)	O
return	O
TRUE	int
;	O
hdr	pointer
=	O
&	O
elf_section_data	O
(	O
section	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
hdr	pointer
->	O
sh_offset	array
==	O
(	O
file_ptr	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
bfd_section_is_ctf	function
(	O
section	pointer
)	O
)	O
return	O
TRUE	int
;	O
unsigned	O
char	O
*	O
contents	pointer
=	O
hdr	pointer
->	O
contents	pointer
;	O
if	O
(	O
(	O
offset	long
+	O
count	int
)	O
>	O
hdr	pointer
->	O
sh_size	array
||	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_ELF_COMPRESS	int
)	O
==	O
0	int
||	O
contents	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
memcpy	function
(	O
contents	pointer
+	O
offset	long
,	O
location	pointer
,	O
count	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
pos	long
=	O
hdr	pointer
->	O
sh_offset	array
+	O
offset	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
location	pointer
,	O
count	int
,	O
abfd	pointer
)	O
!=	O
count	int
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_no_info_to_howto	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
arelent	struct
*	O
cache_ptr	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Rela	struct
*	O
dst	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
abort	function
(	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_validate_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
areloc	pointer
)	O
{	O
if	O
(	O
(	O
*	O
areloc	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
the_bfd	pointer
->	O
xvec	pointer
!=	O
abfd	pointer
->	O
xvec	pointer
)	O
{	O
bfd_reloc_code_real_type	enum
code	int
;	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
if	O
(	O
areloc	pointer
->	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
switch	O
(	O
areloc	pointer
->	O
howto	pointer
->	O
bitsize	int
)	O
{	O
case	O
8	int
:	O
code	int
=	O
BFD_RELOC_8_PCREL	int
;	O
break	O
;	O
case	O
12	int
:	O
code	int
=	O
BFD_RELOC_12_PCREL	int
;	O
break	O
;	O
case	O
16	int
:	O
code	int
=	O
BFD_RELOC_16_PCREL	int
;	O
break	O
;	O
case	O
24	int
:	O
code	int
=	O
BFD_RELOC_24_PCREL	int
;	O
break	O
;	O
case	O
32	int
:	O
code	int
=	O
BFD_RELOC_32_PCREL	int
;	O
break	O
;	O
case	O
64	int
:	O
code	int
=	O
BFD_RELOC_64_PCREL	int
;	O
break	O
;	O
default	O
:	O
goto	O
fail	O
;	O
}	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
abfd	pointer
,	O
code	int
)	O
;	O
if	O
(	O
howto	pointer
&&	O
areloc	pointer
->	O
howto	pointer
->	O
pcrel_offset	int
!=	O
howto	pointer
->	O
pcrel_offset	int
)	O
{	O
if	O
(	O
howto	pointer
->	O
pcrel_offset	int
)	O
areloc	pointer
->	O
addend	long
+=	O
areloc	pointer
->	O
address	long
;	O
else	O
areloc	pointer
->	O
addend	long
-=	O
areloc	pointer
->	O
address	long
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
areloc	pointer
->	O
howto	pointer
->	O
bitsize	int
)	O
{	O
case	O
8	int
:	O
code	int
=	O
BFD_RELOC_8	int
;	O
break	O
;	O
case	O
14	int
:	O
code	int
=	O
BFD_RELOC_14	int
;	O
break	O
;	O
case	O
16	int
:	O
code	int
=	O
BFD_RELOC_16	int
;	O
break	O
;	O
case	O
26	int
:	O
code	int
=	O
BFD_RELOC_26	int
;	O
break	O
;	O
case	O
32	int
:	O
code	int
=	O
BFD_RELOC_32	int
;	O
break	O
;	O
case	O
64	int
:	O
code	int
=	O
BFD_RELOC_64	int
;	O
break	O
;	O
default	O
:	O
goto	O
fail	O
;	O
}	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
abfd	pointer
,	O
code	int
)	O
;	O
}	O
if	O
(	O
howto	pointer
)	O
areloc	pointer
->	O
howto	pointer
=	O
howto	pointer
;	O
else	O
goto	O
fail	O
;	O
}	O
return	O
TRUE	int
;	O
fail	O
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %s unsupported"	pointer
)	O
,	O
abfd	pointer
,	O
areloc	pointer
->	O
howto	pointer
->	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_sorry	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_close_and_cleanup	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
elf_obj_tdata	struct
*	O
tdata	union
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
==	O
bfd_object	int
&&	O
tdata	union
!=	O
NULL	O
)	O
{	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
o	pointer
!=	O
NULL	O
&&	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
_bfd_elf_strtab_free	function
(	O
elf_shstrtab	O
(	O
abfd	pointer
)	O
)	O
;	O
_bfd_dwarf2_cleanup_debug_info	function
(	O
abfd	pointer
,	O
&	O
tdata	union
->	O
dwarf2_find_line_info	pointer
)	O
;	O
}	O
return	O
_bfd_generic_close_and_cleanup	O
(	O
abfd	pointer
)	O
;	O
}	O
bfd_reloc_status_type	enum
_bfd_elf_rel_vtable_reloc_fn	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
arelent	struct
*	O
re	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_symbol	struct
*	O
symbol	pointer
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
data	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
is	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
obfd	pointer
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
*	O
errmsg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
bfd_reloc_ok	int
;	O
}	O
static	O
int	O
elfcore_make_pid	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
int	O
pid	int
;	O
pid	int
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
pid	int
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
;	O
return	O
pid	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_maybe_make_sect	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
name	pointer
,	O
asection	struct
*	O
sect	pointer
)	O
{	O
asection	struct
*	O
sect2	pointer
;	O
if	O
(	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
sect2	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
sect	pointer
->	O
flags	int
)	O
;	O
if	O
(	O
sect2	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect2	pointer
->	O
size	long
=	O
sect	pointer
->	O
size	long
;	O
sect2	pointer
->	O
filepos	long
=	O
sect	pointer
->	O
filepos	long
;	O
sect2	pointer
->	O
alignment_power	int
=	O
sect	pointer
->	O
alignment_power	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elfcore_make_pseudosection	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
name	pointer
,	O
size_t	long
size	long
,	O
ufile_ptr	long
filepos	long
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
char	O
*	O
threaded_name	pointer
;	O
size_t	long
len	long
;	O
asection	struct
*	O
sect	pointer
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s/%d"	pointer
,	O
name	pointer
,	O
elfcore_make_pid	function
(	O
abfd	pointer
)	O
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
;	O
threaded_name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
threaded_name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
threaded_name	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
threaded_name	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
size	long
;	O
sect	pointer
->	O
filepos	long
=	O
filepos	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
2	int
;	O
return	O
elfcore_maybe_make_sect	function
(	O
abfd	pointer
,	O
name	pointer
,	O
sect	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_make_auxv_note_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
,	O
size_t	long
offs	long
)	O
{	O
asection	struct
*	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".auxv"	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
-	O
offs	long
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
+	O
offs	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
1	int
+	O
bfd_get_arch_size	function
(	O
abfd	pointer
)	O
/	O
32	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_prstatus	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
size_t	long
size	long
;	O
int	O
offset	long
;	O
if	O
(	O
note	pointer
->	O
descsz	array
==	O
sizeof	O
(	O
prstatus_t	struct
)	O
)	O
{	O
prstatus_t	struct
prstat	struct
;	O
size	long
=	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
;	O
offset	long
=	O
offsetof	O
(	O
prstatus_t	struct
,	O
pr_reg	array
)	O
;	O
memcpy	function
(	O
&	O
prstat	struct
,	O
note	pointer
->	O
descdata	pointer
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
==	O
0	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
prstat	struct
.	O
pr_cursig	short
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
==	O
0	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
prstat	struct
.	O
pr_pid	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
prstat	struct
.	O
pr_pid	int
;	O
}	O
else	O
if	O
(	O
note	pointer
->	O
descsz	array
==	O
sizeof	O
(	O
prstatus32_t	struct
)	O
)	O
{	O
prstatus32_t	struct
prstat	struct
;	O
size	long
=	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
;	O
offset	long
=	O
offsetof	O
(	O
prstatus32_t	struct
,	O
pr_reg	array
)	O
;	O
memcpy	function
(	O
&	O
prstat	struct
,	O
note	pointer
->	O
descdata	pointer
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
==	O
0	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
prstat	struct
.	O
pr_cursig	short
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
==	O
0	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
prstat	struct
.	O
pr_pid	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
prstat	struct
.	O
pr_pid	int
;	O
}	O
else	O
{	O
return	O
TRUE	int
;	O
}	O
return	O
_bfd_elfcore_make_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
size	long
,	O
note	pointer
->	O
descpos	long
+	O
offset	long
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_make_note_pseudosection	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
name	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
_bfd_elfcore_make_pseudosection	function
(	O
abfd	pointer
,	O
name	pointer
,	O
note	pointer
->	O
descsz	array
,	O
note	pointer
->	O
descpos	long
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_prfpreg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg2"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_prxfpreg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-xfp"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_xstatereg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-xstate"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_vmx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-vmx"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_vsx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-vsx"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tar	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tar"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_ppr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-ppr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_dscr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-dscr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_ebb	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-ebb"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_pmu	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-pmu"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_cgpr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-cgpr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_cfpr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-cfpr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_cvmx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-cvmx"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_cvsx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-cvsx"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_spr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-spr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_ctar	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-ctar"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_cppr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-cppr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_ppc_tm_cdscr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-ppc-tm-cdscr"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_high_gprs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-high-gprs"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_timer	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-timer"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_todcmp	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-todcmp"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_todpreg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-todpreg"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_ctrs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-ctrs"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_prefix	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-prefix"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_last_break	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-last-break"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_system_call	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-system-call"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_tdb	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-tdb"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_vxrs_low	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-vxrs-low"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_vxrs_high	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-vxrs-high"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_gs_cb	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-gs-cb"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_s390_gs_bc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-s390-gs-bc"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_arm_vfp	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-arm-vfp"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_aarch_tls	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-aarch-tls"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_aarch_hw_break	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-aarch-hw-break"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_aarch_hw_watch	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-aarch-hw-watch"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_aarch_sve	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-aarch-sve"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_aarch_pauth	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-aarch-pauth"	pointer
,	O
note	pointer
)	O
;	O
}	O
typedef	O
prpsinfo_t	struct
elfcore_psinfo_t	struct
;	O
typedef	O
prpsinfo32_t	struct
elfcore_psinfo32_t	struct
;	O
char	O
*	O
_bfd_elfcore_strndup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
start	long
,	O
size_t	long
max	long
)	O
{	O
char	O
*	O
dups	pointer
;	O
char	O
*	O
end	pointer
=	O
(	O
char	O
*	O
)	O
memchr	function
(	O
start	long
,	O
'\0'	O
,	O
max	long
)	O
;	O
size_t	long
len	long
;	O
if	O
(	O
end	pointer
==	O
NULL	O
)	O
len	long
=	O
max	long
;	O
else	O
len	long
=	O
end	pointer
-	O
start	long
;	O
dups	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
dups	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dups	pointer
,	O
start	long
,	O
len	long
)	O
;	O
dups	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
dups	pointer
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_psinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
if	O
(	O
note	pointer
->	O
descsz	array
==	O
sizeof	O
(	O
elfcore_psinfo_t	struct
)	O
)	O
{	O
elfcore_psinfo_t	struct
psinfo	struct
;	O
memcpy	function
(	O
&	O
psinfo	struct
,	O
note	pointer
->	O
descdata	pointer
,	O
sizeof	O
(	O
psinfo	struct
)	O
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
psinfo	struct
.	O
pr_pid	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
psinfo	struct
.	O
pr_fname	array
,	O
sizeof	O
(	O
psinfo	struct
.	O
pr_fname	array
)	O
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
psinfo	struct
.	O
pr_psargs	array
,	O
sizeof	O
(	O
psinfo	struct
.	O
pr_psargs	array
)	O
)	O
;	O
}	O
else	O
if	O
(	O
note	pointer
->	O
descsz	array
==	O
sizeof	O
(	O
elfcore_psinfo32_t	struct
)	O
)	O
{	O
elfcore_psinfo32_t	struct
psinfo	struct
;	O
memcpy	function
(	O
&	O
psinfo	struct
,	O
note	pointer
->	O
descdata	pointer
,	O
sizeof	O
(	O
psinfo	struct
)	O
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
psinfo	struct
.	O
pr_pid	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
psinfo	struct
.	O
pr_fname	array
,	O
sizeof	O
(	O
psinfo	struct
.	O
pr_fname	array
)	O
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
psinfo	struct
.	O
pr_psargs	array
,	O
sizeof	O
(	O
psinfo	struct
.	O
pr_psargs	array
)	O
)	O
;	O
}	O
else	O
{	O
return	O
TRUE	int
;	O
}	O
{	O
char	O
*	O
command	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
;	O
int	O
n	long
=	O
strlen	function
(	O
command	pointer
)	O
;	O
if	O
(	O
0	int
<	O
n	long
&&	O
command	pointer
[	O
n	long
-	O
1	int
]	O
==	O
' '	O
)	O
command	pointer
[	O
n	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_win32pstatus	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
char	O
buf	pointer
[	O
30	int
]	O
;	O
char	O
*	O
name	pointer
;	O
size_t	long
len	long
;	O
asection	struct
*	O
sect	pointer
;	O
int	O
type	enum
;	O
int	O
is_active_thread	int
;	O
bfd_vma	long
base_addr	long
;	O
if	O
(	O
note	pointer
->	O
descsz	array
<	O
728	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
CONST_STRNEQ	O
(	O
note	pointer
->	O
namedata	pointer
,	O
"win32"	pointer
)	O
)	O
return	O
TRUE	int
;	O
type	enum
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
)	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
1	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
8	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
12	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
sprintf	function
(	O
buf	pointer
,	O
".reg/%ld"	pointer
,	O
(	O
long	O
)	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
8	int
)	O
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
name	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
716	int
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
+	O
12	int
;	O
sect	pointer
->	O
alignment_power	int
=	O
2	int
;	O
is_active_thread	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
8	int
)	O
;	O
if	O
(	O
is_active_thread	int
)	O
if	O
(	O
!	O
elfcore_maybe_make_sect	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
sect	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
3	int
:	O
base_addr	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
4	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
".module/%08lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
base_addr	long
)	O
;	O
len	long
=	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
name	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
2	int
;	O
break	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
default	O
:	O
return	O
TRUE	int
;	O
case	O
NT_PRSTATUS	int
:	O
if	O
(	O
bed	pointer
->	O
elf_backend_grok_prstatus	pointer
)	O
if	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_grok_prstatus	pointer
)	O
(	O
abfd	pointer
,	O
note	pointer
)	O
)	O
return	O
TRUE	int
;	O
return	O
elfcore_grok_prstatus	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_FPREGSET	int
:	O
return	O
elfcore_grok_prfpreg	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_WIN32PSTATUS	int
:	O
return	O
elfcore_grok_win32pstatus	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_PRXFPREG	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_prxfpreg	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_X86_XSTATE	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_xstatereg	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_VMX	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_vmx	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_VSX	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_vsx	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TAR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tar	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_PPR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_ppr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_DSCR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_dscr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_EBB	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_ebb	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_PMU	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_pmu	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CGPR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_cgpr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CFPR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_cfpr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CVMX	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_cvmx	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CVSX	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_cvsx	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_SPR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_spr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CTAR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_ctar	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CPPR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_cppr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PPC_TM_CDSCR	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_ppc_tm_cdscr	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_HIGH_GPRS	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_high_gprs	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_TIMER	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_timer	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_TODCMP	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_todcmp	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_TODPREG	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_todpreg	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_CTRS	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_ctrs	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_PREFIX	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_prefix	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_LAST_BREAK	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_last_break	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_SYSTEM_CALL	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_system_call	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_TDB	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_tdb	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_VXRS_LOW	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_vxrs_low	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_VXRS_HIGH	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_vxrs_high	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_GS_CB	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_gs_cb	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_S390_GS_BC	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_s390_gs_bc	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_ARM_VFP	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_arm_vfp	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_ARM_TLS	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_aarch_tls	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_ARM_HW_BREAK	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_aarch_hw_break	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_ARM_HW_WATCH	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_aarch_hw_watch	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_ARM_SVE	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_aarch_sve	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_ARM_PAC_MASK	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
6	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"LINUX"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_grok_aarch_pauth	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_PRPSINFO	int
:	O
case	O
NT_PSINFO	int
:	O
if	O
(	O
bed	pointer
->	O
elf_backend_grok_psinfo	pointer
)	O
if	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_grok_psinfo	pointer
)	O
(	O
abfd	pointer
,	O
note	pointer
)	O
)	O
return	O
TRUE	int
;	O
return	O
elfcore_grok_psinfo	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_AUXV	int
:	O
return	O
elfcore_make_auxv_note_section	function
(	O
abfd	pointer
,	O
note	pointer
,	O
0	int
)	O
;	O
case	O
NT_FILE	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.linuxcore.file"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_SIGINFO	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.linuxcore.siginfo"	pointer
,	O
note	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
elfobj_grok_gnu_build_id	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
struct	O
bfd_build_id	struct
*	O
build_id	pointer
;	O
if	O
(	O
note	pointer
->	O
descsz	array
==	O
0	int
)	O
return	O
FALSE	int
;	O
build_id	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
struct	O
bfd_build_id	struct
)	O
-	O
1	int
+	O
note	pointer
->	O
descsz	array
)	O
;	O
if	O
(	O
build_id	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
build_id	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
;	O
memcpy	function
(	O
build_id	pointer
->	O
data	pointer
,	O
note	pointer
->	O
descdata	pointer
,	O
note	pointer
->	O
descsz	array
)	O
;	O
abfd	pointer
->	O
build_id	pointer
=	O
build_id	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfobj_grok_gnu_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
default	O
:	O
return	O
TRUE	int
;	O
case	O
NT_GNU_PROPERTY_TYPE_0	int
:	O
return	O
_bfd_elf_parse_gnu_properties	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_GNU_BUILD_ID	int
:	O
return	O
elfobj_grok_gnu_build_id	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
elfobj_grok_stapsdt_note_1	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
struct	O
sdt_note	struct
*	O
cur	pointer
=	O
(	O
struct	O
sdt_note	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
struct	O
sdt_note	struct
)	O
+	O
note	pointer
->	O
descsz	array
)	O
;	O
cur	pointer
->	O
next	pointer
=	O
(	O
struct	O
sdt_note	struct
*	O
)	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
)	O
->	O
sdt_note_head	pointer
;	O
cur	pointer
->	O
size	long
=	O
(	O
bfd_size_type	long
)	O
note	pointer
->	O
descsz	array
;	O
memcpy	function
(	O
cur	pointer
->	O
data	pointer
,	O
note	pointer
->	O
descdata	pointer
,	O
note	pointer
->	O
descsz	array
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
sdt_note_head	pointer
=	O
cur	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfobj_grok_stapsdt_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
NT_STAPSDT	int
:	O
return	O
elfobj_grok_stapsdt_note_1	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
elfcore_grok_freebsd_psinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
size_t	long
offset	long
;	O
switch	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
)	O
{	O
case	O
ELFCLASS32	int
:	O
if	O
(	O
note	pointer
->	O
descsz	array
<	O
108	int
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
ELFCLASS64	int
:	O
if	O
(	O
note	pointer
->	O
descsz	array
<	O
120	int
)	O
return	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
offset	long
=	O
4	int
;	O
if	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS32	int
)	O
offset	long
+=	O
4	int
;	O
else	O
{	O
offset	long
+=	O
4	int
;	O
offset	long
+=	O
8	int
;	O
}	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
,	O
17	int
)	O
;	O
offset	long
+=	O
17	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
,	O
81	int
)	O
;	O
offset	long
+=	O
81	int
;	O
offset	long
+=	O
2	int
;	O
if	O
(	O
note	pointer
->	O
descsz	array
<	O
offset	long
+	O
4	int
)	O
return	O
TRUE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_freebsd_prstatus	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
size_t	long
offset	long
;	O
size_t	long
size	long
;	O
size_t	long
min_size	long
;	O
switch	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
)	O
{	O
case	O
ELFCLASS32	int
:	O
offset	long
=	O
4	int
+	O
4	int
;	O
min_size	long
=	O
offset	long
+	O
(	O
4	int
*	O
2	int
)	O
+	O
4	int
+	O
4	int
+	O
4	int
;	O
break	O
;	O
case	O
ELFCLASS64	int
:	O
offset	long
=	O
4	int
+	O
4	int
+	O
8	int
;	O
min_size	long
=	O
offset	long
+	O
(	O
8	int
*	O
2	int
)	O
+	O
4	int
+	O
4	int
+	O
4	int
+	O
4	int
;	O
break	O
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
note	pointer
->	O
descsz	array
<	O
min_size	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS32	int
)	O
{	O
size	long
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
)	O
;	O
offset	long
+=	O
4	int
*	O
2	int
;	O
}	O
else	O
{	O
size	long
=	O
bfd_h_get_64	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
)	O
;	O
offset	long
+=	O
8	int
*	O
2	int
;	O
}	O
offset	long
+=	O
4	int
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
==	O
0	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
)	O
;	O
offset	long
+=	O
4	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
offset	long
)	O
;	O
offset	long
+=	O
4	int
;	O
if	O
(	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
)	O
offset	long
+=	O
4	int
;	O
if	O
(	O
(	O
note	pointer
->	O
descsz	array
-	O
offset	long
)	O
<	O
size	long
)	O
return	O
FALSE	int
;	O
return	O
_bfd_elfcore_make_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
size	long
,	O
note	pointer
->	O
descpos	long
+	O
offset	long
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_freebsd_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
NT_PRSTATUS	int
:	O
if	O
(	O
bed	pointer
->	O
elf_backend_grok_freebsd_prstatus	pointer
)	O
if	O
(	O
(	O
*	O
bed	pointer
->	O
elf_backend_grok_freebsd_prstatus	pointer
)	O
(	O
abfd	pointer
,	O
note	pointer
)	O
)	O
return	O
TRUE	int
;	O
return	O
elfcore_grok_freebsd_prstatus	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_FPREGSET	int
:	O
return	O
elfcore_grok_prfpreg	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_PRPSINFO	int
:	O
return	O
elfcore_grok_freebsd_psinfo	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_FREEBSD_THRMISC	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
8	int
)	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".thrmisc"	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_FREEBSD_PROCSTAT_PROC	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.freebsdcore.proc"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_FILES	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.freebsdcore.files"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_VMMAP	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.freebsdcore.vmmap"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_AUXV	int
:	O
return	O
elfcore_make_auxv_note_section	function
(	O
abfd	pointer
,	O
note	pointer
,	O
4	int
)	O
;	O
case	O
NT_X86_XSTATE	int
:	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
8	int
)	O
return	O
elfcore_grok_xstatereg	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
else	O
return	O
TRUE	int
;	O
case	O
NT_FREEBSD_PTLWPINFO	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.freebsdcore.lwpinfo"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_ARM_VFP	int
:	O
return	O
elfcore_grok_arm_vfp	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
elfcore_netbsd_get_lwpid	function
(	O
Elf_Internal_Note	struct
*	O
note	pointer
,	O
int	O
*	O
lwpidp	pointer
)	O
{	O
char	O
*	O
cp	pointer
;	O
cp	pointer
=	O
strchr	function
(	O
note	pointer
->	O
namedata	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
cp	pointer
!=	O
NULL	O
)	O
{	O
*	O
lwpidp	pointer
=	O
atoi	function
(	O
cp	pointer
+	O
1	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_netbsd_procinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
if	O
(	O
note	pointer
->	O
descsz	array
<=	O
0x7c	int
+	O
31	int
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
0x08	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
0x50	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
0x7c	int
,	O
31	int
)	O
;	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".note.netbsdcore.procinfo"	pointer
,	O
note	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_netbsd_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
int	O
lwp	int
;	O
if	O
(	O
elfcore_netbsd_get_lwpid	function
(	O
note	pointer
,	O
&	O
lwp	int
)	O
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
lwp	int
;	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
NT_NETBSDCORE_PROCINFO	int
:	O
return	O
elfcore_grok_netbsd_procinfo	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
note	pointer
->	O
type	enum
<	O
NT_NETBSDCORE_FIRSTMACH	int
)	O
return	O
TRUE	int
;	O
switch	O
(	O
bfd_get_arch	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_arch_alpha	int
:	O
case	O
bfd_arch_sparc	int
:	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
0	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
2	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg2"	pointer
,	O
note	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
case	O
bfd_arch_sh	int
:	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
3	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
5	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg2"	pointer
,	O
note	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
default	O
:	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
1	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
note	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
3	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg2"	pointer
,	O
note	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
elfcore_grok_openbsd_procinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
if	O
(	O
note	pointer
->	O
descsz	array
<=	O
0x48	int
+	O
31	int
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
0x08	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_h_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
->	O
descdata	pointer
+	O
0x20	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
0x48	int
,	O
31	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_openbsd_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
if	O
(	O
note	pointer
->	O
type	enum
==	O
NT_OPENBSD_PROCINFO	int
)	O
return	O
elfcore_grok_openbsd_procinfo	function
(	O
abfd	pointer
,	O
note	pointer
)	O
;	O
if	O
(	O
note	pointer
->	O
type	enum
==	O
NT_OPENBSD_REGS	int
)	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
note	pointer
)	O
;	O
if	O
(	O
note	pointer
->	O
type	enum
==	O
NT_OPENBSD_FPREGS	int
)	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg2"	pointer
,	O
note	pointer
)	O
;	O
if	O
(	O
note	pointer
->	O
type	enum
==	O
NT_OPENBSD_XFPREGS	int
)	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".reg-xfp"	pointer
,	O
note	pointer
)	O
;	O
if	O
(	O
note	pointer
->	O
type	enum
==	O
NT_OPENBSD_AUXV	int
)	O
return	O
elfcore_make_auxv_note_section	function
(	O
abfd	pointer
,	O
note	pointer
,	O
0	int
)	O
;	O
if	O
(	O
note	pointer
->	O
type	enum
==	O
NT_OPENBSD_WCOOKIE	int
)	O
{	O
asection	struct
*	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".wcookie"	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
1	int
+	O
bfd_get_arch_size	function
(	O
abfd	pointer
)	O
/	O
32	int
;	O
return	O
TRUE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_nto_status	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
,	O
long	O
*	O
tid	pointer
)	O
{	O
void	O
*	O
ddata	pointer
=	O
note	pointer
->	O
descdata	pointer
;	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
char	O
*	O
name	pointer
;	O
asection	struct
*	O
sect	pointer
;	O
short	O
sig	short
;	O
unsigned	O
flags	int
;	O
if	O
(	O
note	pointer
->	O
descsz	array
<	O
16	int
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
ddata	pointer
)	O
;	O
*	O
tid	pointer
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
ddata	pointer
+	O
4	int
)	O
;	O
flags	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
ddata	pointer
+	O
8	int
)	O
;	O
if	O
(	O
(	O
sig	short
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
ddata	pointer
+	O
14	int
)	O
)	O
>	O
0	int
)	O
{	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
sig	short
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
*	O
tid	pointer
;	O
}	O
if	O
(	O
flags	int
&	O
0x00000080	int
)	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
*	O
tid	pointer
;	O
sprintf	function
(	O
buf	pointer
,	O
".qnx_core_status/%ld"	pointer
,	O
*	O
tid	pointer
)	O
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
strcpy	function
(	O
name	pointer
,	O
buf	pointer
)	O
;	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
2	int
;	O
return	O
(	O
elfcore_maybe_make_sect	function
(	O
abfd	pointer
,	O
".qnx_core_status"	pointer
,	O
sect	pointer
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_nto_regs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
,	O
long	O
tid	pointer
,	O
char	O
*	O
base	int
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
char	O
*	O
name	pointer
;	O
asection	struct
*	O
sect	pointer
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s/%ld"	pointer
,	O
base	int
,	O
tid	pointer
)	O
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
strcpy	function
(	O
name	pointer
,	O
buf	pointer
)	O
;	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
2	int
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
==	O
tid	pointer
)	O
return	O
elfcore_maybe_make_sect	function
(	O
abfd	pointer
,	O
base	int
,	O
sect	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elfcore_grok_nto_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
static	O
long	O
tid	pointer
=	O
1	int
;	O
switch	O
(	O
note	pointer
->	O
type	enum
)	O
{	O
case	O
BFD_QNT_CORE_INFO	int
:	O
return	O
elfcore_make_note_pseudosection	function
(	O
abfd	pointer
,	O
".qnx_core_info"	pointer
,	O
note	pointer
)	O
;	O
case	O
BFD_QNT_CORE_STATUS	int
:	O
return	O
elfcore_grok_nto_status	function
(	O
abfd	pointer
,	O
note	pointer
,	O
&	O
tid	pointer
)	O
;	O
case	O
BFD_QNT_CORE_GREG	int
:	O
return	O
elfcore_grok_nto_regs	function
(	O
abfd	pointer
,	O
note	pointer
,	O
tid	pointer
,	O
".reg"	pointer
)	O
;	O
case	O
BFD_QNT_CORE_FPREG	int
:	O
return	O
elfcore_grok_nto_regs	function
(	O
abfd	pointer
,	O
note	pointer
,	O
tid	pointer
,	O
".reg2"	pointer
)	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
elfcore_grok_spu_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
asection	struct
*	O
sect	pointer
;	O
size_t	long
len	long
;	O
len	long
=	O
note	pointer
->	O
namesz	array
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
name	pointer
,	O
note	pointer
->	O
namedata	pointer
,	O
len	long
)	O
;	O
name	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
sect	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
sect	pointer
->	O
size	long
=	O
note	pointer
->	O
descsz	array
;	O
sect	pointer
->	O
filepos	long
=	O
note	pointer
->	O
descpos	long
;	O
sect	pointer
->	O
alignment_power	int
=	O
1	int
;	O
return	O
TRUE	int
;	O
}	O
char	O
*	O
elfcore_write_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
type	enum
,	O
const	O
void	O
*	O
input	pointer
,	O
int	O
size	long
)	O
{	O
Elf_External_Note	struct
*	O
xnp	pointer
;	O
size_t	long
namesz	array
;	O
size_t	long
newspace	long
;	O
char	O
*	O
dest	pointer
;	O
namesz	array
=	O
0	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
namesz	array
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
newspace	long
=	O
12	int
+	O
(	O
(	O
namesz	array
+	O
3	int
)	O
&	O
-	O
4	int
)	O
+	O
(	O
(	O
size	long
+	O
3	int
)	O
&	O
-	O
4	int
)	O
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
realloc	function
(	O
buf	pointer
,	O
*	O
bufsiz	pointer
+	O
newspace	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
return	O
buf	pointer
;	O
dest	pointer
=	O
buf	pointer
+	O
*	O
bufsiz	pointer
;	O
*	O
bufsiz	pointer
+=	O
newspace	long
;	O
xnp	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
dest	pointer
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
namesz	array
,	O
xnp	pointer
->	O
namesz	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
size	long
,	O
xnp	pointer
->	O
descsz	array
)	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
type	enum
,	O
xnp	pointer
->	O
type	enum
)	O
;	O
dest	pointer
=	O
xnp	pointer
->	O
name	pointer
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
dest	pointer
,	O
name	pointer
,	O
namesz	array
)	O
;	O
dest	pointer
+=	O
namesz	array
;	O
while	O
(	O
namesz	array
&	O
3	int
)	O
{	O
*	O
dest	pointer
++	O
=	O
'\0'	O
;	O
++	O
namesz	array
;	O
}	O
}	O
memcpy	function
(	O
dest	pointer
,	O
input	pointer
,	O
size	long
)	O
;	O
dest	pointer
+=	O
size	long
;	O
while	O
(	O
size	long
&	O
3	int
)	O
{	O
*	O
dest	pointer
++	O
=	O
'\0'	O
;	O
++	O
size	long
;	O
}	O
return	O
buf	pointer
;	O
}	O
char	O
*	O
elfcore_write_prpsinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
psargs	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_write_core_note	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_write_core_note	pointer
)	O
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
NT_PRPSINFO	int
,	O
fname	pointer
,	O
psargs	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
NULL	O
)	O
return	O
ret	pointer
;	O
}	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
{	O
prpsinfo32_t	struct
data	pointer
;	O
int	O
note_type	int
=	O
NT_PRPSINFO	int
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_fname	array
,	O
fname	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_fname	array
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_psargs	array
,	O
psargs	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_psargs	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
else	O
{	O
prpsinfo_t	struct
data	pointer
;	O
int	O
note_type	int
=	O
NT_PRPSINFO	int
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_fname	array
,	O
fname	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_fname	array
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_psargs	array
,	O
psargs	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_psargs	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
elfcore_write_linux_prpsinfo32	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
struct	O
elf_internal_linux_prpsinfo	struct
*	O
prpsinfo	pointer
)	O
{	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
linux_prpsinfo32_ugid16	int
)	O
{	O
struct	O
elf_external_linux_prpsinfo32_ugid16	struct
data	pointer
;	O
swap_linux_prpsinfo32_ugid16_out	function
(	O
abfd	pointer
,	O
prpsinfo	pointer
,	O
&	O
data	pointer
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
NT_PRPSINFO	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
else	O
{	O
struct	O
elf_external_linux_prpsinfo32_ugid32	struct
data	pointer
;	O
swap_linux_prpsinfo32_ugid32_out	function
(	O
abfd	pointer
,	O
prpsinfo	pointer
,	O
&	O
data	pointer
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
NT_PRPSINFO	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
}	O
char	O
*	O
elfcore_write_linux_prpsinfo64	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
struct	O
elf_internal_linux_prpsinfo	struct
*	O
prpsinfo	pointer
)	O
{	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
linux_prpsinfo64_ugid16	int
)	O
{	O
struct	O
elf_external_linux_prpsinfo64_ugid16	struct
data	pointer
;	O
swap_linux_prpsinfo64_ugid16_out	function
(	O
abfd	pointer
,	O
prpsinfo	pointer
,	O
&	O
data	pointer
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
NT_PRPSINFO	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
else	O
{	O
struct	O
elf_external_linux_prpsinfo64_ugid32	struct
data	pointer
;	O
swap_linux_prpsinfo64_ugid32_out	function
(	O
abfd	pointer
,	O
prpsinfo	pointer
,	O
&	O
data	pointer
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
NT_PRPSINFO	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
}	O
char	O
*	O
elfcore_write_prstatus	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
long	O
pid	int
,	O
int	O
cursig	int
,	O
const	O
void	O
*	O
gregs	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
elf_backend_write_core_note	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
*	O
bed	pointer
->	O
elf_backend_write_core_note	pointer
)	O
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
NT_PRSTATUS	int
,	O
pid	int
,	O
cursig	int
,	O
gregs	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
NULL	O
)	O
return	O
ret	pointer
;	O
}	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
{	O
prstatus32_t	struct
prstat	struct
;	O
memset	function
(	O
&	O
prstat	struct
,	O
0	int
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
prstat	struct
.	O
pr_pid	int
=	O
pid	int
;	O
prstat	struct
.	O
pr_cursig	short
=	O
cursig	int
;	O
memcpy	function
(	O
&	O
prstat	struct
.	O
pr_reg	array
,	O
gregs	pointer
,	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
NT_PRSTATUS	int
,	O
&	O
prstat	struct
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
}	O
else	O
{	O
prstatus_t	struct
prstat	struct
;	O
memset	function
(	O
&	O
prstat	struct
,	O
0	int
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
prstat	struct
.	O
pr_pid	int
=	O
pid	int
;	O
prstat	struct
.	O
pr_cursig	short
=	O
cursig	int
;	O
memcpy	function
(	O
&	O
prstat	struct
.	O
pr_reg	array
,	O
gregs	pointer
,	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
NT_PRSTATUS	int
,	O
&	O
prstat	struct
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
elfcore_write_prfpreg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
fpregs	pointer
,	O
int	O
size	long
)	O
{	O
const	O
char	O
*	O
note_name	pointer
=	O
"CORE"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_FPREGSET	int
,	O
fpregs	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_prxfpreg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
xfpregs	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PRXFPREG	int
,	O
xfpregs	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_xstatereg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
xfpregs	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
;	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_osabi	int
==	O
ELFOSABI_FREEBSD	int
)	O
note_name	pointer
=	O
"FreeBSD"	pointer
;	O
else	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_X86_XSTATE	int
,	O
xfpregs	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_vmx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_vmx	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_VMX	int
,	O
ppc_vmx	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_vsx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_vsx	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_VSX	int
,	O
ppc_vsx	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tar	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tar	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TAR	int
,	O
ppc_tar	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_ppr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_ppr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_PPR	int
,	O
ppc_ppr	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_dscr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_dscr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_DSCR	int
,	O
ppc_dscr	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_ebb	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_ebb	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_EBB	int
,	O
ppc_ebb	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_pmu	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_pmu	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_PMU	int
,	O
ppc_pmu	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_cgpr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_cgpr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CGPR	int
,	O
ppc_tm_cgpr	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_cfpr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_cfpr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CFPR	int
,	O
ppc_tm_cfpr	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_cvmx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_cvmx	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CVMX	int
,	O
ppc_tm_cvmx	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_cvsx	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_cvsx	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CVSX	int
,	O
ppc_tm_cvsx	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_spr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_spr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_SPR	int
,	O
ppc_tm_spr	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_ctar	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_ctar	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CTAR	int
,	O
ppc_tm_ctar	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_cppr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_cppr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CPPR	int
,	O
ppc_tm_cppr	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_ppc_tm_cdscr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
ppc_tm_cdscr	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_PPC_TM_CDSCR	int
,	O
ppc_tm_cdscr	pointer
,	O
size	long
)	O
;	O
}	O
static	O
char	O
*	O
elfcore_write_s390_high_gprs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_high_gprs	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_HIGH_GPRS	int
,	O
s390_high_gprs	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_timer	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_timer	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_TIMER	int
,	O
s390_timer	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_todcmp	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_todcmp	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_TODCMP	int
,	O
s390_todcmp	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_todpreg	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_todpreg	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_TODPREG	int
,	O
s390_todpreg	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_ctrs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_ctrs	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_CTRS	int
,	O
s390_ctrs	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_prefix	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_prefix	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_PREFIX	int
,	O
s390_prefix	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_last_break	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_last_break	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_LAST_BREAK	int
,	O
s390_last_break	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_system_call	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_system_call	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_SYSTEM_CALL	int
,	O
s390_system_call	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_tdb	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_tdb	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_TDB	int
,	O
s390_tdb	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_vxrs_low	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_vxrs_low	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_VXRS_LOW	int
,	O
s390_vxrs_low	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_vxrs_high	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_vxrs_high	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_VXRS_HIGH	int
,	O
s390_vxrs_high	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_gs_cb	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_gs_cb	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_GS_CB	int
,	O
s390_gs_cb	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_s390_gs_bc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
s390_gs_bc	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_S390_GS_BC	int
,	O
s390_gs_bc	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_arm_vfp	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
arm_vfp	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_ARM_VFP	int
,	O
arm_vfp	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_aarch_tls	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
aarch_tls	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_ARM_TLS	int
,	O
aarch_tls	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_aarch_hw_break	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
aarch_hw_break	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_ARM_HW_BREAK	int
,	O
aarch_hw_break	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_aarch_hw_watch	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
aarch_hw_watch	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_ARM_HW_WATCH	int
,	O
aarch_hw_watch	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_aarch_sve	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
aarch_sve	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_ARM_SVE	int
,	O
aarch_sve	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_aarch_pauth	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
void	O
*	O
aarch_pauth	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
note_name	pointer
=	O
"LINUX"	pointer
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
note_name	pointer
,	O
NT_ARM_PAC_MASK	int
,	O
aarch_pauth	pointer
,	O
size	long
)	O
;	O
}	O
char	O
*	O
elfcore_write_register_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
const	O
char	O
*	O
section	pointer
,	O
const	O
void	O
*	O
data	pointer
,	O
int	O
size	long
)	O
{	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg2"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_prfpreg	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-xfp"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_prxfpreg	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-xstate"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_xstatereg	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-vmx"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_vmx	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-vsx"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_vsx	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tar"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tar	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-ppr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_ppr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-dscr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_dscr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-ebb"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_ebb	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-pmu"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_pmu	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-cgpr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_cgpr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-cfpr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_cfpr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-cvmx"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_cvmx	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-cvsx"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_cvsx	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-spr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_spr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-ctar"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_ctar	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-cppr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_cppr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-ppc-tm-cdscr"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_ppc_tm_cdscr	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-high-gprs"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_high_gprs	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-timer"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_timer	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-todcmp"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_todcmp	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-todpreg"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_todpreg	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-ctrs"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_ctrs	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-prefix"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_prefix	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-last-break"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_last_break	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-system-call"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_system_call	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-tdb"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_tdb	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-vxrs-low"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_vxrs_low	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-vxrs-high"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_vxrs_high	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-gs-cb"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_gs_cb	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-s390-gs-bc"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_s390_gs_bc	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-arm-vfp"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_arm_vfp	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-aarch-tls"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_aarch_tls	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-aarch-hw-break"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_aarch_hw_break	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-aarch-hw-watch"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_aarch_hw_watch	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-aarch-sve"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_aarch_sve	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
section	pointer
,	O
".reg-aarch-pauth"	pointer
)	O
==	O
0	int
)	O
return	O
elfcore_write_aarch_pauth	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
elf_parse_notes	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
file_ptr	long
offset	long
,	O
size_t	long
align	long
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
align	long
<	O
4	int
)	O
align	long
=	O
4	int
;	O
if	O
(	O
align	long
!=	O
4	int
&&	O
align	long
!=	O
8	int
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
buf	pointer
;	O
while	O
(	O
p	pointer
<	O
buf	pointer
+	O
size	long
)	O
{	O
Elf_External_Note	struct
*	O
xnp	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
p	pointer
;	O
Elf_Internal_Note	struct
in	struct
;	O
if	O
(	O
offsetof	O
(	O
Elf_External_Note	struct
,	O
name	pointer
)	O
>	O
buf	pointer
-	O
p	pointer
+	O
size	long
)	O
return	O
FALSE	int
;	O
in	struct
.	O
type	enum
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
xnp	pointer
->	O
type	enum
)	O
;	O
in	struct
.	O
namesz	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
xnp	pointer
->	O
namesz	array
)	O
;	O
in	struct
.	O
namedata	pointer
=	O
xnp	pointer
->	O
name	pointer
;	O
if	O
(	O
in	struct
.	O
namesz	array
>	O
buf	pointer
-	O
in	struct
.	O
namedata	pointer
+	O
size	long
)	O
return	O
FALSE	int
;	O
in	struct
.	O
descsz	array
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
xnp	pointer
->	O
descsz	array
)	O
;	O
in	struct
.	O
descdata	pointer
=	O
p	pointer
+	O
ELF_NOTE_DESC_OFFSET	O
(	O
in	struct
.	O
namesz	array
,	O
align	long
)	O
;	O
in	struct
.	O
descpos	long
=	O
offset	long
+	O
(	O
in	struct
.	O
descdata	pointer
-	O
buf	pointer
)	O
;	O
if	O
(	O
in	struct
.	O
descsz	array
!=	O
0	int
&&	O
(	O
in	struct
.	O
descdata	pointer
>=	O
buf	pointer
+	O
size	long
||	O
in	struct
.	O
descsz	array
>	O
buf	pointer
-	O
in	struct
.	O
descdata	pointer
+	O
size	long
)	O
)	O
return	O
FALSE	int
;	O
switch	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
)	O
{	O
default	O
:	O
return	O
TRUE	int
;	O
case	O
bfd_core	int
:	O
{	O
struct	O
{	O
const	O
char	O
*	O
string	pointer
;	O
size_t	long
len	long
;	O
bfd_boolean	int
(	O
*	O
func	pointer
)	O
(	O
bfd	struct
*	O
,	O
Elf_Internal_Note	struct
*	O
)	O
;	O
}	O
grokers	array
[	O
]	O
=	O
{	O
GROKER_ELEMENT	O
(	O
""	pointer
,	O
elfcore_grok_note	function
)	O
,	O
GROKER_ELEMENT	O
(	O
"FreeBSD"	pointer
,	O
elfcore_grok_freebsd_note	function
)	O
,	O
GROKER_ELEMENT	O
(	O
"NetBSD-CORE"	pointer
,	O
elfcore_grok_netbsd_note	function
)	O
,	O
GROKER_ELEMENT	O
(	O
"OpenBSD"	pointer
,	O
elfcore_grok_openbsd_note	function
)	O
,	O
GROKER_ELEMENT	O
(	O
"QNX"	pointer
,	O
elfcore_grok_nto_note	function
)	O
,	O
GROKER_ELEMENT	O
(	O
"SPU/"	pointer
,	O
elfcore_grok_spu_note	function
)	O
,	O
GROKER_ELEMENT	O
(	O
"GNU"	pointer
,	O
elfobj_grok_gnu_note	function
)	O
}	O
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
ARRAY_SIZE	O
(	O
grokers	array
)	O
;	O
i	pointer
--	O
;	O
)	O
{	O
if	O
(	O
in	struct
.	O
namesz	array
>=	O
grokers	array
[	O
i	pointer
]	O
.	O
len	long
&&	O
strncmp	function
(	O
in	struct
.	O
namedata	pointer
,	O
grokers	array
[	O
i	pointer
]	O
.	O
string	pointer
,	O
grokers	array
[	O
i	pointer
]	O
.	O
len	long
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
grokers	array
[	O
i	pointer
]	O
.	O
func	pointer
(	O
abfd	pointer
,	O
&	O
in	struct
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
}	O
case	O
bfd_object	int
:	O
if	O
(	O
in	struct
.	O
namesz	array
==	O
sizeof	O
"GNU"	pointer
&&	O
strcmp	function
(	O
in	struct
.	O
namedata	pointer
,	O
"GNU"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
elfobj_grok_gnu_note	function
(	O
abfd	pointer
,	O
&	O
in	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
in	struct
.	O
namesz	array
==	O
sizeof	O
"stapsdt"	pointer
&&	O
strcmp	function
(	O
in	struct
.	O
namedata	pointer
,	O
"stapsdt"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
elfobj_grok_stapsdt_note	function
(	O
abfd	pointer
,	O
&	O
in	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
}	O
p	pointer
+=	O
ELF_NOTE_NEXT_OFFSET	O
(	O
in	struct
.	O
namesz	array
,	O
in	struct
.	O
descsz	array
,	O
align	long
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
elf_read_notes	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
size	long
,	O
size_t	long
align	long
)	O
{	O
char	O
*	O
buf	pointer
;	O
if	O
(	O
size	long
==	O
0	int
||	O
(	O
size	long
+	O
1	int
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
buf	pointer
[	O
size	long
]	O
=	O
0	int
;	O
if	O
(	O
bfd_bread	function
(	O
buf	pointer
,	O
size	long
,	O
abfd	pointer
)	O
!=	O
size	long
||	O
!	O
elf_parse_notes	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
size	long
,	O
offset	long
,	O
align	long
)	O
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
long	O
bfd_get_elf_phdr_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
*	O
sizeof	O
(	O
Elf_Internal_Phdr	struct
)	O
;	O
}	O
int	O
bfd_get_elf_phdrs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
phdrs	pointer
)	O
{	O
int	O
num_phdrs	int
;	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
!=	O
bfd_target_elf_flavour	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
num_phdrs	int
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_phnum	array
;	O
if	O
(	O
num_phdrs	int
!=	O
0	int
)	O
memcpy	function
(	O
phdrs	pointer
,	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
phdr	pointer
,	O
num_phdrs	int
*	O
sizeof	O
(	O
Elf_Internal_Phdr	struct
)	O
)	O
;	O
return	O
num_phdrs	int
;	O
}	O
enum	O
elf_reloc_type_class	enum
_bfd_elf_reloc_type_class	function
(	O
const	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
asection	struct
*	O
rel_sec	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
Elf_Internal_Rela	struct
*	O
rela	struct
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
reloc_class_normal	int
;	O
}	O
bfd_vma	long
_bfd_elf_rela_local_sym	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
asection	struct
*	O
*	O
psec	pointer
,	O
Elf_Internal_Rela	struct
*	O
rel	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
*	O
psec	pointer
;	O
bfd_vma	long
relocation	pointer
;	O
relocation	pointer
=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
sym	pointer
->	O
st_value	array
)	O
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_SECTION	int
&&	O
sec	pointer
->	O
sec_info_type	int
==	O
SEC_INFO_TYPE_MERGE	int
)	O
{	O
rel	pointer
->	O
r_addend	array
=	O
_bfd_merged_section_offset	function
(	O
abfd	pointer
,	O
psec	pointer
,	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
,	O
sym	pointer
->	O
st_value	array
+	O
rel	pointer
->	O
r_addend	array
)	O
;	O
if	O
(	O
sec	pointer
!=	O
*	O
psec	pointer
)	O
{	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
)	O
sec	pointer
->	O
kept_section	pointer
=	O
*	O
psec	pointer
;	O
sec	pointer
=	O
*	O
psec	pointer
;	O
}	O
rel	pointer
->	O
r_addend	array
-=	O
relocation	pointer
;	O
rel	pointer
->	O
r_addend	array
+=	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
;	O
}	O
return	O
relocation	pointer
;	O
}	O
bfd_vma	long
_bfd_elf_rel_local_sym	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
asection	struct
*	O
*	O
psec	pointer
,	O
bfd_vma	long
addend	long
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
*	O
psec	pointer
;	O
if	O
(	O
sec	pointer
->	O
sec_info_type	int
!=	O
SEC_INFO_TYPE_MERGE	int
)	O
return	O
sym	pointer
->	O
st_value	array
+	O
addend	long
;	O
return	O
_bfd_merged_section_offset	function
(	O
abfd	pointer
,	O
psec	pointer
,	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
,	O
sym	pointer
->	O
st_value	array
+	O
addend	long
)	O
;	O
}	O
bfd_vma	long
_bfd_elf_section_offset	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_vma	long
offset	long
)	O
{	O
switch	O
(	O
sec	pointer
->	O
sec_info_type	int
)	O
{	O
case	O
SEC_INFO_TYPE_STABS	int
:	O
return	O
_bfd_stab_section_offset	function
(	O
sec	pointer
,	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
sec_info	pointer
,	O
offset	long
)	O
;	O
case	O
SEC_INFO_TYPE_EH_FRAME	int
:	O
return	O
_bfd_elf_eh_frame_section_offset	function
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
,	O
offset	long
)	O
;	O
default	O
:	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ELF_REVERSE_COPY	int
)	O
!=	O
0	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_size_type	long
address_size	long
=	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
/	O
8	int
;	O
offset	long
=	O
(	O
(	O
sec	pointer
->	O
size	long
-	O
address_size	long
)	O
/	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
-	O
offset	long
)	O
;	O
}	O
return	O
offset	long
;	O
}	O
}	O
bfd	struct
*	O
bfd_elf_bfd_from_remote_memory	function
(	O
bfd	struct
*	O
templ	pointer
,	O
bfd_vma	long
ehdr_vma	long
,	O
bfd_size_type	long
size	long
,	O
bfd_vma	long
*	O
loadbasep	pointer
,	O
int	O
(	O
*	O
target_read_memory	pointer
)	O
(	O
bfd_vma	long
,	O
bfd_byte	char
*	O
,	O
bfd_size_type	long
)	O
)	O
{	O
return	O
(	O
*	O
get_elf_backend_data	O
(	O
templ	pointer
)	O
->	O
elf_backend_bfd_from_remote_memory	pointer
)	O
(	O
templ	pointer
,	O
ehdr_vma	long
,	O
size	long
,	O
loadbasep	pointer
,	O
target_read_memory	pointer
)	O
;	O
}	O
long	O
_bfd_elf_get_synthetic_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
long	O
symcount	int
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
*	O
syms	pointer
ATTRIBUTE_UNUSED	O
,	O
long	O
dynsymcount	int
,	O
asymbol	struct
*	O
*	O
dynsyms	pointer
,	O
asymbol	struct
*	O
*	O
ret	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
asection	struct
*	O
relplt	pointer
;	O
asymbol	struct
*	O
s	pointer
;	O
const	O
char	O
*	O
relplt_name	pointer
;	O
bfd_boolean	int
(	O
*	O
slurp_relocs	pointer
)	O
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
asymbol	struct
*	O
*	O
,	O
bfd_boolean	int
)	O
;	O
arelent	struct
*	O
p	pointer
;	O
long	O
count	int
,	O
i	pointer
,	O
n	long
;	O
size_t	long
size	long
;	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
char	O
*	O
names	pointer
;	O
asection	struct
*	O
plt	union
;	O
*	O
ret	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
dynsymcount	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
bed	pointer
->	O
plt_sym_val	pointer
)	O
return	O
0	int
;	O
relplt_name	pointer
=	O
bed	pointer
->	O
relplt_name	pointer
;	O
if	O
(	O
relplt_name	pointer
==	O
NULL	O
)	O
relplt_name	pointer
=	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.plt"	pointer
:	O
".rel.plt"	pointer
;	O
relplt	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
relplt_name	pointer
)	O
;	O
if	O
(	O
relplt	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
hdr	pointer
=	O
&	O
elf_section_data	O
(	O
relplt	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
hdr	pointer
->	O
sh_link	array
!=	O
elf_dynsymtab	O
(	O
abfd	pointer
)	O
||	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
&&	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
)	O
)	O
return	O
0	int
;	O
plt	union
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".plt"	pointer
)	O
;	O
if	O
(	O
plt	union
==	O
NULL	O
)	O
return	O
0	int
;	O
slurp_relocs	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
slurp_reloc_table	pointer
;	O
if	O
(	O
!	O
(	O
*	O
slurp_relocs	pointer
)	O
(	O
abfd	pointer
,	O
relplt	pointer
,	O
dynsyms	pointer
,	O
TRUE	int
)	O
)	O
return	O
-	O
1	int
;	O
count	int
=	O
relplt	pointer
->	O
size	long
/	O
hdr	pointer
->	O
sh_entsize	array
;	O
size	long
=	O
count	int
*	O
sizeof	O
(	O
asymbol	struct
)	O
;	O
p	pointer
=	O
relplt	pointer
->	O
relocation	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
,	O
p	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
{	O
size	long
+=	O
strlen	function
(	O
(	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
name	pointer
)	O
+	O
sizeof	O
(	O
"@plt"	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
addend	long
!=	O
0	int
)	O
{	O
size	long
+=	O
sizeof	O
(	O
"+0x"	pointer
)	O
-	O
1	int
+	O
8	int
+	O
8	int
*	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS64	int
)	O
;	O
}	O
}	O
s	pointer
=	O
*	O
ret	pointer
=	O
(	O
asymbol	struct
*	O
)	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
names	pointer
=	O
(	O
char	O
*	O
)	O
(	O
s	pointer
+	O
count	int
)	O
;	O
p	pointer
=	O
relplt	pointer
->	O
relocation	pointer
;	O
n	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
,	O
p	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
{	O
size_t	long
len	long
;	O
bfd_vma	long
addr	pointer
;	O
addr	pointer
=	O
bed	pointer
->	O
plt_sym_val	pointer
(	O
i	pointer
,	O
plt	union
,	O
p	pointer
)	O
;	O
if	O
(	O
addr	pointer
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
continue	O
;	O
*	O
s	pointer
=	O
*	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
;	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
)	O
==	O
0	int
)	O
s	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
s	pointer
->	O
flags	int
|=	O
BSF_SYNTHETIC	O
;	O
s	pointer
->	O
section	pointer
=	O
plt	union
;	O
s	pointer
->	O
value	long
=	O
addr	pointer
-	O
plt	union
->	O
vma	long
;	O
s	pointer
->	O
name	pointer
=	O
names	pointer
;	O
s	pointer
->	O
udata	union
.	O
p	pointer
=	O
NULL	O
;	O
len	long
=	O
strlen	function
(	O
(	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
name	pointer
)	O
;	O
memcpy	function
(	O
names	pointer
,	O
(	O
*	O
p	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
name	pointer
,	O
len	long
)	O
;	O
names	pointer
+=	O
len	long
;	O
if	O
(	O
p	pointer
->	O
addend	long
!=	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
30	int
]	O
,	O
*	O
a	pointer
;	O
memcpy	function
(	O
names	pointer
,	O
"+0x"	pointer
,	O
sizeof	O
(	O
"+0x"	pointer
)	O
-	O
1	int
)	O
;	O
names	pointer
+=	O
sizeof	O
(	O
"+0x"	pointer
)	O
-	O
1	int
;	O
bfd_sprintf_vma	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
p	pointer
->	O
addend	long
)	O
;	O
for	O
(	O
a	pointer
=	O
buf	pointer
;	O
*	O
a	pointer
==	O
'0'	O
;	O
++	O
a	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
a	pointer
)	O
;	O
memcpy	function
(	O
names	pointer
,	O
a	pointer
,	O
len	long
)	O
;	O
names	pointer
+=	O
len	long
;	O
}	O
memcpy	function
(	O
names	pointer
,	O
"@plt"	pointer
,	O
sizeof	O
(	O
"@plt"	pointer
)	O
)	O
;	O
names	pointer
+=	O
sizeof	O
(	O
"@plt"	pointer
)	O
;	O
++	O
s	pointer
,	O
++	O
n	long
;	O
}	O
return	O
n	long
;	O
}	O
static	O
const	O
asymbol	struct
lcomm_sym	struct
=	O
GLOBAL_SYM_INIT	O
(	O
"LARGE_COMMON"	pointer
,	O
&	O
_bfd_elf_large_com_section	struct
)	O
;	O
asection	struct
_bfd_elf_large_com_section	struct
=	O
BFD_FAKE_SECTION	O
(	O
_bfd_elf_large_com_section	struct
,	O
&	O
lcomm_sym	struct
,	O
"LARGE_COMMON"	pointer
,	O
0	int
,	O
SEC_IS_COMMON	int
)	O
;	O
bfd_boolean	int
_bfd_elf_final_write_processing	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
i_ehdrp	pointer
;	O
i_ehdrp	pointer
=	O
elf_elfheader	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_NONE	int
)	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_osabi	int
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
!=	O
0	int
)	O
{	O
if	O
(	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_NONE	int
)	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
=	O
ELFOSABI_GNU	int
;	O
else	O
if	O
(	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
!=	O
ELFOSABI_GNU	int
&&	O
i_ehdrp	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
!=	O
ELFOSABI_FREEBSD	int
)	O
{	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_mbind	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"GNU_MBIND section is unsupported"	pointer
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_ifunc	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"symbol type STT_GNU_IFUNC is unsupported"	pointer
)	O
)	O
;	O
if	O
(	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_unique	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"symbol binding STB_GNU_UNIQUE is unsupported"	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_sorry	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_is_function_type	function
(	O
unsigned	O
int	O
type	enum
)	O
{	O
return	O
(	O
type	enum
==	O
STT_FUNC	int
||	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
;	O
}	O
bfd_size_type	long
_bfd_elf_maybe_function_sym	function
(	O
const	O
asymbol	struct
*	O
sym	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_vma	long
*	O
code_off	pointer
)	O
{	O
bfd_size_type	long
size	long
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_FILE	O
|	O
BSF_OBJECT	O
|	O
BSF_THREAD_LOCAL	O
|	O
BSF_RELC	O
|	O
BSF_SRELC	O
)	O
)	O
!=	O
0	int
||	O
sym	pointer
->	O
section	pointer
!=	O
sec	pointer
)	O
return	O
0	int
;	O
*	O
code_off	pointer
=	O
sym	pointer
->	O
value	long
;	O
size	long
=	O
0	int
;	O
if	O
(	O
!	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_SYNTHETIC	O
)	O
)	O
size	long
=	O
(	O
(	O
elf_symbol_type	struct
*	O
)	O
sym	pointer
)	O
->	O
internal_elf_sym	struct
.	O
st_size	long
;	O
if	O
(	O
size	long
==	O
0	int
)	O
size	long
=	O
1	int
;	O
return	O
size	long
;	O
}	O