int	O
facilities_seen	int
;	O
const	O
char	O
*	O
ConfFile	pointer
=	O
PATH_LOGCONF	O
;	O
const	O
char	O
*	O
PidFile	pointer
=	O
PATH_LOGPID	O
;	O
char	O
ctty	array
[	O
]	O
=	O
PATH_CONSOLE	O
;	O
static	O
int	O
dbg_output	int
;	O
static	O
int	O
restart	int
;	O
struct	O
funix	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
fd	int
;	O
}	O
*	O
funix	struct
;	O
size_t	long
nfunix	long
;	O
struct	O
filed	struct
{	O
struct	O
filed	struct
*	O
f_next	pointer
;	O
short	O
f_type	short
;	O
short	O
f_file	short
;	O
time_t	long
f_time	long
;	O
unsigned	O
char	O
f_pmask	array
[	O
LOG_NFACILITIES	int
+	O
1	int
]	O
;	O
union	O
{	O
struct	O
{	O
int	O
f_nusers	int
;	O
char	O
*	O
*	O
f_unames	pointer
;	O
}	O
f_user	struct
;	O
struct	O
{	O
char	O
*	O
f_hname	pointer
;	O
struct	O
sockaddr_storage	struct
f_addr	struct
;	O
socklen_t	int
f_addrlen	int
;	O
}	O
f_forw	struct
;	O
char	O
*	O
f_fname	pointer
;	O
}	O
f_un	union
;	O
char	O
f_prevline	array
[	O
MAXSVLINE	int
]	O
;	O
char	O
f_lasttime	array
[	O
16	int
]	O
;	O
char	O
*	O
f_prevhost	pointer
;	O
int	O
f_prevpri	int
;	O
int	O
f_prevlen	int
;	O
int	O
f_prevcount	int
;	O
size_t	long
f_repeatcount	long
;	O
int	O
f_flags	int
;	O
}	O
;	O
struct	O
filed	struct
*	O
Files	pointer
;	O
struct	O
filed	struct
consfile	struct
;	O
const	O
char	O
*	O
TypeNames	array
[	O
]	O
=	O
{	O
"UNUSED"	pointer
,	O
"FILE"	pointer
,	O
"TTY"	pointer
,	O
"CONSOLE"	pointer
,	O
"FORW"	pointer
,	O
"USERS"	pointer
,	O
"WALL"	pointer
,	O
"FORW(SUSPENDED)"	pointer
,	O
"FORW(UNKNOWN)"	pointer
,	O
"PIPE"	pointer
}	O
;	O
int	O
repeatinterval	array
[	O
]	O
=	O
{	O
30	int
,	O
60	int
}	O
;	O
extern	O
int	O
waitdaemon	function
(	O
int	O
nochdir	int
,	O
int	O
noclose	int
,	O
int	O
maxwait	int
)	O
;	O
void	O
cfline	function
(	O
const	O
char	O
*	O
,	O
struct	O
filed	struct
*	O
)	O
;	O
const	O
char	O
*	O
cvthname	function
(	O
struct	O
sockaddr	struct
*	O
,	O
socklen_t	int
)	O
;	O
int	O
decode	function
(	O
const	O
char	O
*	O
,	O
CODE	struct
*	O
)	O
;	O
void	O
die	function
(	O
int	O
)	O
;	O
void	O
doexit	function
(	O
int	O
)	O
;	O
void	O
domark	function
(	O
int	O
)	O
;	O
void	O
fprintlog	function
(	O
struct	O
filed	struct
*	O
,	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
)	O
;	O
void	O
init	function
(	O
int	O
)	O
;	O
void	O
logerror	function
(	O
const	O
char	O
*	O
)	O
;	O
void	O
logmsg	function
(	O
int	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
printline	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
void	O
printsys	function
(	O
const	O
char	O
*	O
)	O
;	O
char	O
*	O
ttymsg	function
(	O
struct	O
iovec	struct
*	O
,	O
int	O
,	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
wallmsg	function
(	O
struct	O
filed	struct
*	O
,	O
struct	O
iovec	struct
*	O
)	O
;	O
char	O
*	O
*	O
crunch_list	function
(	O
char	O
*	O
*	O
oldlist	pointer
,	O
char	O
*	O
list	pointer
)	O
;	O
char	O
*	O
textpri	function
(	O
int	O
pri	int
)	O
;	O
void	O
dbg_toggle	function
(	O
int	O
)	O
;	O
static	O
void	O
dbg_printf	function
(	O
const	O
char	O
*	O
,	O
...	O
)	O
;	O
void	O
trigger_restart	function
(	O
int	O
)	O
;	O
static	O
void	O
add_funix	function
(	O
const	O
char	O
*	O
path	pointer
)	O
;	O
static	O
int	O
create_unix_socket	function
(	O
const	O
char	O
*	O
path	pointer
)	O
;	O
static	O
void	O
create_inet_socket	function
(	O
int	O
af	int
,	O
int	O
fd46	array
[	O
2	int
]	O
)	O
;	O
char	O
*	O
LocalHostName	pointer
;	O
char	O
*	O
LocalDomain	pointer
;	O
char	O
*	O
BindAddress	pointer
=	O
NULL	O
;	O
char	O
addrstr	array
[	O
INET6_ADDRSTRLEN	int
]	O
;	O
char	O
addrname	array
[	O
NI_MAXHOST	int
]	O
;	O
int	O
usefamily	int
=	O
AF_INET	O
;	O
int	O
finet	array
[	O
2	int
]	O
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
int	O
fklog	int
=	O
-	O
1	int
;	O
char	O
*	O
LogPortText	pointer
=	O
"syslog"	pointer
;	O
int	O
Initialized	int
;	O
int	O
MarkInterval	int
=	O
20	int
*	O
60	int
;	O
int	O
MarkSeq	int
;	O
int	O
Debug	int
;	O
int	O
AcceptRemote	int
;	O
char	O
*	O
*	O
StripDomains	pointer
;	O
char	O
*	O
*	O
LocalHosts	pointer
;	O
int	O
NoDetach	int
;	O
int	O
NoHops	int
=	O
1	int
;	O
int	O
NoKLog	int
;	O
int	O
NoUnixAF	int
;	O
int	O
NoForward	int
;	O
time_t	long
now	long
;	O
int	O
force_sync	int
;	O
const	O
char	O
args_doc	pointer
[	O
]	O
=	O
""	pointer
;	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"Log system messages."	pointer
;	O
enum	O
{	O
OPT_NO_FORWARD	int
=	O
256	int
,	O
OPT_NO_KLOG	int
,	O
OPT_NO_UNIXAF	int
,	O
OPT_PIDFILE	int
,	O
OPT_IPANY	int
}	O
;	O
static	O
struct	O
argp_option	struct
argp_options	array
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
'a'	O
,	O
"SOCKET"	pointer
,	O
0	int
,	O
"add unix socket to listen to (up to 19)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
'l'	O
,	O
"HOSTLIST"	pointer
,	O
0	int
,	O
"log hosts in HOSTLIST by their hostname"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
's'	O
,	O
"DOMAINLIST"	pointer
,	O
0	int
,	O
"list of domains which should be stripped "	pointer
"from the FQDN of hosts before logging their name"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"print debug information (implies --no-detach)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"hop"	pointer
,	O
'h'	O
,	O
NULL	O
,	O
0	int
,	O
"forward messages from remote hosts"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"inet"	pointer
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
"receive remote messages via internet domain socket"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ipv4"	pointer
,	O
'4'	O
,	O
NULL	O
,	O
0	int
,	O
"restrict to IPv4 transport (default)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ipv6"	pointer
,	O
'6'	O
,	O
NULL	O
,	O
0	int
,	O
"restrict to IPv6 transport"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ipany"	pointer
,	O
OPT_IPANY	int
,	O
NULL	O
,	O
0	int
,	O
"allow transport with IPv4 and IPv6"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"bind"	pointer
,	O
'b'	O
,	O
"ADDR"	pointer
,	O
0	int
,	O
"bind listener to this address/name"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"mark"	pointer
,	O
'm'	O
,	O
"INTVL"	pointer
,	O
0	int
,	O
"specify timestamp interval in logs (0 for no "	pointer
"timestamps)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-detach"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"do not enter daemon mode"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-forward"	pointer
,	O
OPT_NO_FORWARD	int
,	O
NULL	O
,	O
0	int
,	O
"do not forward any messages "	pointer
"(overrides --hop)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-klog"	pointer
,	O
OPT_NO_KLOG	int
,	O
NULL	O
,	O
0	int
,	O
"do not listen to kernel log device "	pointer
PATH_KLOG	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"no-unixaf"	pointer
,	O
OPT_NO_UNIXAF	int
,	O
NULL	O
,	O
0	int
,	O
"do not listen on unix domain "	pointer
"sockets (overrides -a and -p)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"pidfile"	pointer
,	O
OPT_PIDFILE	int
,	O
"FILE"	pointer
,	O
0	int
,	O
"override pidfile (default: "	pointer
PATH_LOGPID	O
")"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"rcfile"	pointer
,	O
'f'	O
,	O
"FILE"	pointer
,	O
0	int
,	O
"override configuration file (default: "	pointer
PATH_LOGCONF	O
")"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"socket"	pointer
,	O
'p'	O
,	O
"FILE"	pointer
,	O
0	int
,	O
"override default unix domain socket "	pointer
PATH_LOG	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"sync"	pointer
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
"force a file sync on every line"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
char	O
*	O
endptr	pointer
;	O
int	O
v	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
add_funix	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
LocalHosts	pointer
=	O
crunch_list	function
(	O
LocalHosts	pointer
,	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
StripDomains	pointer
=	O
crunch_list	function
(	O
StripDomains	pointer
,	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
Debug	int
=	O
1	int
;	O
NoDetach	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
NoHops	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
AcceptRemote	int
=	O
1	int
;	O
break	O
;	O
case	O
'4'	O
:	O
usefamily	int
=	O
AF_INET	O
;	O
break	O
;	O
case	O
'6'	O
:	O
usefamily	int
=	O
AF_INET6	O
;	O
break	O
;	O
case	O
OPT_IPANY	int
:	O
usefamily	int
=	O
AF_UNSPEC	O
;	O
break	O
;	O
case	O
'b'	O
:	O
BindAddress	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'm'	O
:	O
v	int
=	O
strtol	function
(	O
arg	pointer
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endptr	pointer
)	O
argp_error	function
(	O
state	pointer
,	O
"invalid value (`%s' near `%s')"	pointer
,	O
arg	pointer
,	O
endptr	pointer
)	O
;	O
MarkInterval	int
=	O
v	int
*	O
60	int
;	O
break	O
;	O
case	O
'n'	O
:	O
NoDetach	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_FORWARD	int
:	O
NoForward	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_KLOG	int
:	O
NoKLog	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_UNIXAF	int
:	O
NoUnixAF	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_PIDFILE	int
:	O
PidFile	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
ConfFile	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'p'	O
:	O
funix	struct
[	O
0	int
]	O
.	O
name	pointer
=	O
arg	pointer
;	O
funix	struct
[	O
0	int
]	O
.	O
fd	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
force_sync	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
argp_options	array
,	O
parse_opt	function
,	O
args_doc	pointer
,	O
doc	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
p	pointer
;	O
char	O
line	pointer
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
char	O
kline	array
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
int	O
kline_len	int
=	O
0	int
;	O
pid_t	int
ppid	int
=	O
0	int
;	O
struct	O
pollfd	struct
*	O
fdarray	pointer
;	O
unsigned	O
long	O
nfds	long
=	O
0	int
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
add_funix	function
(	O
PATH_LOG	O
)	O
;	O
iu_argp_init	O
(	O
"syslogd"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
NoDetach	int
)	O
{	O
signal	function
(	O
SIGTERM	int
,	O
doexit	function
)	O
;	O
ppid	int
=	O
waitdaemon	function
(	O
0	int
,	O
0	int
,	O
30	int
)	O
;	O
if	O
(	O
ppid	int
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"could not become daemon"	pointer
)	O
;	O
}	O
else	O
{	O
dbg_output	int
=	O
1	int
;	O
setvbuf	function
(	O
stdout	pointer
,	O
0	int
,	O
_IOLBF	int
,	O
0	int
)	O
;	O
}	O
LocalHostName	pointer
=	O
localhost	function
(	O
)	O
;	O
if	O
(	O
LocalHostName	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't get local host name"	pointer
)	O
;	O
p	pointer
=	O
strchr	function
(	O
LocalHostName	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
LocalDomain	pointer
=	O
p	pointer
;	O
}	O
else	O
{	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
rp	pointer
;	O
int	O
err	long
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
AF_UNSPEC	O
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_CANONNAME	int
;	O
err	long
=	O
getaddrinfo	function
(	O
LocalHostName	pointer
,	O
NULL	O
,	O
&	O
hints	struct
,	O
&	O
rp	pointer
)	O
;	O
if	O
(	O
err	long
==	O
0	int
)	O
{	O
free	function
(	O
LocalHostName	pointer
)	O
;	O
LocalHostName	pointer
=	O
strdup	function
(	O
rp	pointer
->	O
ai_canonname	pointer
)	O
;	O
p	pointer
=	O
strchr	function
(	O
LocalHostName	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
LocalDomain	pointer
=	O
p	pointer
;	O
}	O
freeaddrinfo	function
(	O
rp	pointer
)	O
;	O
}	O
if	O
(	O
LocalDomain	pointer
==	O
NULL	O
)	O
LocalDomain	pointer
=	O
strdup	function
(	O
""	pointer
)	O
;	O
}	O
consfile	struct
.	O
f_type	short
=	O
F_CONSOLE	int
;	O
consfile	struct
.	O
f_un	union
.	O
f_fname	pointer
=	O
strdup	function
(	O
ctty	array
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
die	function
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
Debug	int
?	O
die	function
:	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
Debug	int
?	O
die	function
:	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
domark	function
)	O
;	O
signal	function
(	O
SIGUSR1	int
,	O
Debug	int
?	O
dbg_toggle	function
:	O
SIG_IGN	O
)	O
;	O
alarm	function
(	O
TIMERINTVL	int
)	O
;	O
fdarray	pointer
=	O
(	O
struct	O
pollfd	struct
*	O
)	O
malloc	function
(	O
(	O
nfunix	long
+	O
3	int
)	O
*	O
sizeof	O
(	O
*	O
fdarray	pointer
)	O
)	O
;	O
if	O
(	O
fdarray	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate fd table"	pointer
)	O
;	O
init	function
(	O
0	int
)	O
;	O
if	O
(	O
!	O
NoKLog	int
)	O
{	O
fklog	int
=	O
open	function
(	O
PATH_KLOG	O
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fklog	int
>=	O
0	int
)	O
{	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
fd	int
=	O
fklog	int
;	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	function
(	O
"Klog open %s\n"	pointer
,	O
PATH_KLOG	O
)	O
;	O
}	O
else	O
dbg_printf	function
(	O
"Can't open %s: %s\n"	pointer
,	O
PATH_KLOG	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
NoUnixAF	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nfunix	long
;	O
i	long
++	O
)	O
{	O
funix	struct
[	O
i	long
]	O
.	O
fd	int
=	O
create_unix_socket	function
(	O
funix	struct
[	O
i	long
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
funix	struct
[	O
i	long
]	O
.	O
fd	int
>=	O
0	int
)	O
{	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
fd	int
=	O
funix	struct
[	O
i	long
]	O
.	O
fd	int
;	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	function
(	O
"Opened UNIX socket `%s'.\n"	pointer
,	O
funix	struct
[	O
i	long
]	O
.	O
name	pointer
)	O
;	O
}	O
else	O
dbg_printf	function
(	O
"Can't open %s: %s\n"	pointer
,	O
funix	struct
[	O
i	long
]	O
.	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
AcceptRemote	int
)	O
{	O
create_inet_socket	function
(	O
usefamily	int
,	O
finet	array
)	O
;	O
if	O
(	O
finet	array
[	O
IU_FD_IP4	int
]	O
>=	O
0	int
)	O
{	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
fd	int
=	O
finet	array
[	O
IU_FD_IP4	int
]	O
;	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	function
(	O
"Opened syslog UDP/IPv4 port.\n"	pointer
)	O
;	O
}	O
if	O
(	O
finet	array
[	O
IU_FD_IP6	int
]	O
>=	O
0	int
)	O
{	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
fd	int
=	O
finet	array
[	O
IU_FD_IP6	int
]	O
;	O
fdarray	pointer
[	O
nfds	long
]	O
.	O
events	short
=	O
POLLIN	int
|	O
POLLPRI	int
;	O
nfds	long
++	O
;	O
dbg_printf	function
(	O
"Opened syslog UDP/IPv6 port.\n"	pointer
)	O
;	O
}	O
if	O
(	O
finet	array
[	O
IU_FD_IP4	int
]	O
<	O
0	int
&&	O
finet	array
[	O
IU_FD_IP6	int
]	O
<	O
0	int
)	O
dbg_printf	function
(	O
"Can't open UDP port: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
PidFile	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%d\n"	pointer
,	O
getpid	function
(	O
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
dbg_printf	function
(	O
"off & running....\n"	pointer
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
trigger_restart	function
)	O
;	O
if	O
(	O
Debug	int
)	O
{	O
dbg_printf	function
(	O
"Debugging disabled, send SIGUSR1 to turn on debugging.\n"	pointer
)	O
;	O
dbg_output	int
=	O
0	int
;	O
}	O
if	O
(	O
ppid	int
)	O
kill	function
(	O
ppid	int
,	O
SIGTERM	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
nready	int
;	O
nready	int
=	O
poll	function
(	O
fdarray	pointer
,	O
nfds	long
,	O
-	O
1	int
)	O
;	O
if	O
(	O
nready	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
restart	int
)	O
{	O
dbg_printf	function
(	O
"\nReceived SIGHUP, restarting syslogd.\n"	pointer
)	O
;	O
init	function
(	O
0	int
)	O
;	O
restart	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
nready	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
logerror	function
(	O
"poll"	pointer
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nfds	long
;	O
i	long
++	O
)	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
revents	short
&	O
(	O
POLLIN	int
|	O
POLLPRI	int
)	O
)	O
{	O
int	O
result	int
;	O
socklen_t	int
len	int
;	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
==	O
-	O
1	int
)	O
continue	O
;	O
else	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
==	O
fklog	int
)	O
{	O
result	int
=	O
read	pointer
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
,	O
&	O
kline	array
[	O
kline_len	int
]	O
,	O
sizeof	O
(	O
kline	array
)	O
-	O
kline_len	int
-	O
1	int
)	O
;	O
if	O
(	O
result	int
>	O
0	int
)	O
{	O
kline_len	int
+=	O
result	int
;	O
}	O
else	O
if	O
(	O
result	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
{	O
logerror	function
(	O
"klog"	pointer
)	O
;	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
=	O
fklog	int
=	O
-	O
1	int
;	O
}	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
bol	pointer
,	O
*	O
eol	pointer
;	O
kline	array
[	O
kline_len	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
bol	pointer
=	O
kline	array
,	O
eol	pointer
=	O
strchr	function
(	O
kline	array
,	O
'\n'	O
)	O
;	O
eol	pointer
;	O
bol	pointer
=	O
eol	pointer
,	O
eol	pointer
=	O
strchr	function
(	O
bol	pointer
,	O
'\n'	O
)	O
)	O
{	O
*	O
(	O
eol	pointer
++	O
)	O
=	O
'\0'	O
;	O
kline_len	int
-=	O
(	O
eol	pointer
-	O
bol	pointer
)	O
;	O
printsys	function
(	O
bol	pointer
)	O
;	O
}	O
while	O
(	O
kline_len	int
&&	O
!	O
*	O
bol	pointer
)	O
{	O
bol	pointer
++	O
;	O
kline_len	int
--	O
;	O
}	O
if	O
(	O
!	O
kline_len	int
)	O
break	O
;	O
if	O
(	O
bol	pointer
!=	O
kline	array
)	O
{	O
memmove	function
(	O
kline	array
,	O
bol	pointer
,	O
kline_len	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
kline_len	int
<	O
MAXLINE	int
)	O
break	O
;	O
printsys	function
(	O
kline	array
)	O
;	O
if	O
(	O
kline	array
[	O
0	int
]	O
==	O
'<'	O
&&	O
isdigit	function
(	O
kline	array
[	O
1	int
]	O
)	O
&&	O
kline	array
[	O
2	int
]	O
==	O
'>'	O
)	O
kline_len	int
=	O
3	int
;	O
else	O
kline_len	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
==	O
finet	array
[	O
IU_FD_IP4	int
]	O
||	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
==	O
finet	array
[	O
IU_FD_IP6	int
]	O
)	O
{	O
struct	O
sockaddr_storage	struct
frominet	struct
;	O
len	int
=	O
sizeof	O
(	O
frominet	struct
)	O
;	O
memset	function
(	O
line	pointer
,	O
'\0'	O
,	O
sizeof	O
(	O
line	pointer
)	O
)	O
;	O
result	int
=	O
recvfrom	function
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
,	O
line	pointer
,	O
MAXLINE	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
frominet	struct
,	O
&	O
len	int
)	O
;	O
if	O
(	O
result	int
>	O
0	int
)	O
{	O
line	pointer
[	O
result	int
]	O
=	O
'\0'	O
;	O
printline	function
(	O
cvthname	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
frominet	struct
,	O
len	int
)	O
,	O
line	pointer
)	O
;	O
}	O
else	O
if	O
(	O
result	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
logerror	function
(	O
"recvfrom inet"	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
sockaddr_un	struct
fromunix	struct
;	O
len	int
=	O
sizeof	O
(	O
fromunix	struct
)	O
;	O
result	int
=	O
recvfrom	function
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
,	O
line	pointer
,	O
MAXLINE	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
fromunix	struct
,	O
&	O
len	int
)	O
;	O
if	O
(	O
result	int
>	O
0	int
)	O
{	O
line	pointer
[	O
result	int
]	O
=	O
'\0'	O
;	O
printline	function
(	O
LocalHostName	pointer
,	O
line	pointer
)	O
;	O
}	O
else	O
if	O
(	O
result	int
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
logerror	function
(	O
"recvfrom unix"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
revents	short
&	O
POLLNVAL	int
)	O
{	O
logerror	function
(	O
"poll nval\n"	pointer
)	O
;	O
fdarray	pointer
[	O
i	long
]	O
.	O
fd	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
revents	short
&	O
POLLERR	int
)	O
logerror	function
(	O
"poll err\n"	pointer
)	O
;	O
else	O
if	O
(	O
fdarray	pointer
[	O
i	long
]	O
.	O
revents	short
&	O
POLLHUP	int
)	O
logerror	function
(	O
"poll hup\n"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
add_funix	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
funix	struct
=	O
realloc	function
(	O
funix	struct
,	O
(	O
nfunix	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
funix	struct
)	O
)	O
;	O
if	O
(	O
funix	struct
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot allocate space for unix sockets"	pointer
)	O
;	O
funix	struct
[	O
nfunix	long
]	O
.	O
name	pointer
=	O
name	pointer
;	O
funix	struct
[	O
nfunix	long
]	O
.	O
fd	int
=	O
-	O
1	int
;	O
nfunix	long
++	O
;	O
}	O
static	O
int	O
create_unix_socket	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
int	O
fd	int
;	O
struct	O
sockaddr_un	struct
sunx	struct
;	O
char	O
line	pointer
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
if	O
(	O
path	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strlen	function
(	O
path	pointer
)	O
>=	O
sizeof	O
(	O
sunx	struct
.	O
sun_path	array
)	O
)	O
{	O
snprintf	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
"UNIX socket name too long: %s"	pointer
,	O
path	pointer
)	O
;	O
logerror	function
(	O
line	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
unlink	function
(	O
path	pointer
)	O
;	O
memset	function
(	O
&	O
sunx	struct
,	O
0	int
,	O
sizeof	O
(	O
sunx	struct
)	O
)	O
;	O
sunx	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	function
(	O
sunx	struct
.	O
sun_path	array
,	O
path	pointer
,	O
sizeof	O
(	O
sunx	struct
.	O
sun_path	array
)	O
-	O
1	int
)	O
;	O
fd	int
=	O
socket	function
(	O
AF_UNIX	O
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
||	O
bind	function
(	O
fd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sunx	struct
,	O
SUN_LEN	O
(	O
&	O
sunx	struct
)	O
)	O
<	O
0	int
||	O
chmod	function
(	O
path	pointer
,	O
0666	int
)	O
<	O
0	int
)	O
{	O
snprintf	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
"cannot create %s"	pointer
,	O
path	pointer
)	O
;	O
logerror	function
(	O
line	pointer
)	O
;	O
dbg_printf	function
(	O
"cannot create %s: %s\n"	pointer
,	O
path	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
return	O
fd	int
;	O
}	O
static	O
void	O
create_inet_socket	function
(	O
int	O
af	int
,	O
int	O
fd46	array
[	O
2	int
]	O
)	O
{	O
int	O
err	long
,	O
fd	int
=	O
-	O
1	int
;	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
rp	pointer
,	O
*	O
ai	pointer
;	O
fd46	array
[	O
IU_FD_IP4	int
]	O
=	O
fd46	array
[	O
IU_FD_IP6	int
]	O
=	O
-	O
1	int
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
af	int
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_PASSIVE	int
;	O
err	long
=	O
getaddrinfo	function
(	O
BindAddress	pointer
,	O
LogPortText	pointer
,	O
&	O
hints	struct
,	O
&	O
rp	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
logerror	function
(	O
"lookup error, suspending inet service"	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
ai	pointer
=	O
rp	pointer
;	O
ai	pointer
;	O
ai	pointer
=	O
ai	pointer
->	O
ai_next	pointer
)	O
{	O
fd	int
=	O
socket	function
(	O
ai	pointer
->	O
ai_family	int
,	O
ai	pointer
->	O
ai_socktype	int
,	O
ai	pointer
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
ai	pointer
->	O
ai_family	int
==	O
AF_INET6	O
)	O
{	O
int	O
yes	int
=	O
1	int
;	O
(	O
void	O
)	O
setsockopt	function
(	O
fd	int
,	O
IPPROTO_IPV6	int
,	O
IPV6_V6ONLY	int
,	O
&	O
yes	int
,	O
sizeof	O
(	O
yes	int
)	O
)	O
;	O
}	O
if	O
(	O
bind	function
(	O
fd	int
,	O
ai	pointer
->	O
ai_addr	pointer
,	O
ai	pointer
->	O
ai_addrlen	int
)	O
<	O
0	int
)	O
{	O
close	pointer
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
ai	pointer
->	O
ai_family	int
==	O
AF_INET	O
&&	O
fd46	array
[	O
IU_FD_IP4	int
]	O
<	O
0	int
)	O
fd46	array
[	O
IU_FD_IP4	int
]	O
=	O
fd	int
;	O
else	O
if	O
(	O
ai	pointer
->	O
ai_family	int
==	O
AF_INET6	O
&&	O
fd46	array
[	O
IU_FD_IP6	int
]	O
<	O
0	int
)	O
fd46	array
[	O
IU_FD_IP6	int
]	O
=	O
fd	int
;	O
}	O
freeaddrinfo	function
(	O
rp	pointer
)	O
;	O
if	O
(	O
fd46	array
[	O
IU_FD_IP4	int
]	O
<	O
0	int
&&	O
fd46	array
[	O
IU_FD_IP6	int
]	O
<	O
0	int
)	O
{	O
logerror	function
(	O
"inet service, failed lookup."	pointer
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
char	O
*	O
*	O
crunch_list	function
(	O
char	O
*	O
*	O
oldlist	pointer
,	O
char	O
*	O
list	pointer
)	O
{	O
int	O
count	int
,	O
i	long
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
p	pointer
=	O
list	pointer
;	O
while	O
(	O
p	pointer
[	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
]	O
==	O
LIST_DELIMITER	char
)	O
{	O
p	pointer
[	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
p	pointer
[	O
0	int
]	O
==	O
LIST_DELIMITER	char
)	O
{	O
p	pointer
++	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
return	O
oldlist	pointer
;	O
for	O
(	O
count	int
=	O
1	int
,	O
i	long
=	O
0	int
;	O
p	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
p	pointer
[	O
i	long
]	O
==	O
LIST_DELIMITER	char
)	O
count	int
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
oldlist	pointer
&&	O
oldlist	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
;	O
oldlist	pointer
=	O
(	O
char	O
*	O
*	O
)	O
realloc	function
(	O
oldlist	pointer
,	O
(	O
i	long
+	O
count	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
oldlist	pointer
)	O
)	O
;	O
if	O
(	O
oldlist	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate memory"	pointer
)	O
;	O
for	O
(	O
count	int
=	O
i	long
;	O
(	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
LIST_DELIMITER	char
)	O
)	O
!=	O
NULL	O
;	O
count	int
++	O
,	O
p	pointer
=	O
q	pointer
,	O
p	pointer
++	O
)	O
{	O
oldlist	pointer
[	O
count	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
q	pointer
-	O
p	pointer
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
oldlist	pointer
[	O
count	int
]	O
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate memory"	pointer
)	O
;	O
strncpy	function
(	O
oldlist	pointer
[	O
count	int
]	O
,	O
p	pointer
,	O
q	pointer
-	O
p	pointer
)	O
;	O
oldlist	pointer
[	O
count	int
]	O
[	O
q	pointer
-	O
p	pointer
]	O
=	O
'\0'	O
;	O
}	O
oldlist	pointer
[	O
count	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
oldlist	pointer
[	O
count	int
]	O
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"can't allocate memory"	pointer
)	O
;	O
strcpy	function
(	O
oldlist	pointer
[	O
count	int
]	O
,	O
p	pointer
)	O
;	O
oldlist	pointer
[	O
++	O
count	int
]	O
=	O
NULL	O
;	O
if	O
(	O
Debug	int
)	O
{	O
for	O
(	O
count	int
=	O
0	int
;	O
oldlist	pointer
[	O
count	int
]	O
;	O
count	int
++	O
)	O
printf	function
(	O
"#%d: %s\n"	pointer
,	O
count	int
,	O
oldlist	pointer
[	O
count	int
]	O
)	O
;	O
}	O
return	O
oldlist	pointer
;	O
}	O
void	O
printline	function
(	O
const	O
char	O
*	O
hname	pointer
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
int	O
c	int
,	O
pri	int
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
,	O
line	pointer
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
pri	int
=	O
DEFUPRI	O
;	O
p	pointer
=	O
msg	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'<'	O
)	O
{	O
pri	int
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
*	O
++	O
p	pointer
)	O
)	O
pri	int
=	O
10	int
*	O
pri	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'>'	O
)	O
++	O
p	pointer
;	O
}	O
if	O
(	O
pri	int
&	O
~	O
(	O
LOG_FACMASK	int
|	O
LOG_PRIMASK	int
)	O
)	O
pri	int
=	O
DEFUPRI	O
;	O
if	O
(	O
LOG_FAC	O
(	O
pri	int
)	O
==	O
LOG_KERN	O
)	O
pri	int
=	O
LOG_MAKEPRI	O
(	O
LOG_USER	O
,	O
LOG_PRI	O
(	O
pri	int
)	O
)	O
;	O
q	pointer
=	O
line	pointer
;	O
while	O
(	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\0'	O
&&	O
q	pointer
<	O
&	O
line	pointer
[	O
sizeof	O
(	O
line	pointer
)	O
-	O
1	int
]	O
)	O
if	O
(	O
iscntrl	function
(	O
c	int
)	O
)	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
*	O
q	pointer
++	O
=	O
' '	O
;	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
*	O
q	pointer
++	O
=	O
'\t'	O
;	O
else	O
if	O
(	O
c	int
>=	O
0177	int
)	O
*	O
q	pointer
++	O
=	O
c	int
;	O
else	O
{	O
*	O
q	pointer
++	O
=	O
'^'	O
;	O
*	O
q	pointer
++	O
=	O
c	int
^	O
0100	int
;	O
}	O
else	O
*	O
q	pointer
++	O
=	O
c	int
;	O
*	O
q	pointer
=	O
'\0'	O
;	O
if	O
(	O
force_sync	int
)	O
logmsg	function
(	O
pri	int
,	O
line	pointer
,	O
hname	pointer
,	O
SYNC_FILE	int
)	O
;	O
logmsg	function
(	O
pri	int
,	O
line	pointer
,	O
hname	pointer
,	O
0	int
)	O
;	O
}	O
void	O
printsys	function
(	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
int	O
c	int
,	O
pri	int
,	O
flags	int
;	O
char	O
*	O
lp	pointer
,	O
*	O
q	pointer
,	O
line	pointer
[	O
MAXLINE	int
+	O
1	int
]	O
;	O
const	O
char	O
*	O
p	pointer
;	O
strcpy	function
(	O
line	pointer
,	O
"vmunix: "	pointer
)	O
;	O
lp	pointer
=	O
line	pointer
+	O
strlen	function
(	O
line	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
msg	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
)	O
{	O
flags	int
=	O
SYNC_FILE	int
|	O
ADDDATE	int
;	O
pri	int
=	O
DEFSPRI	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'<'	O
)	O
{	O
pri	int
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
*	O
++	O
p	pointer
)	O
)	O
pri	int
=	O
10	int
*	O
pri	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'>'	O
)	O
++	O
p	pointer
;	O
}	O
else	O
{	O
flags	int
|=	O
IGN_CONS	int
;	O
}	O
if	O
(	O
pri	int
&	O
~	O
(	O
LOG_FACMASK	int
|	O
LOG_PRIMASK	int
)	O
)	O
pri	int
=	O
DEFSPRI	O
;	O
q	pointer
=	O
lp	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
&&	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\n'	O
&&	O
q	pointer
<	O
&	O
line	pointer
[	O
MAXLINE	int
]	O
)	O
*	O
q	pointer
++	O
=	O
c	int
;	O
*	O
q	pointer
=	O
'\0'	O
;	O
logmsg	function
(	O
pri	int
,	O
line	pointer
,	O
LocalHostName	pointer
,	O
flags	int
)	O
;	O
}	O
}	O
char	O
*	O
textpri	function
(	O
int	O
pri	int
)	O
{	O
static	O
char	O
res	array
[	O
20	int
]	O
;	O
CODE	struct
*	O
c_pri	pointer
,	O
*	O
c_fac	pointer
;	O
for	O
(	O
c_fac	pointer
=	O
facilitynames	array
;	O
c_fac	pointer
->	O
c_name	pointer
&&	O
!	O
(	O
c_fac	pointer
->	O
c_val	int
==	O
LOG_FAC	O
(	O
pri	int
)	O
<<	O
3	int
)	O
;	O
c_fac	pointer
++	O
)	O
;	O
for	O
(	O
c_pri	pointer
=	O
prioritynames	array
;	O
c_pri	pointer
->	O
c_name	pointer
&&	O
!	O
(	O
c_pri	pointer
->	O
c_val	int
==	O
LOG_PRI	O
(	O
pri	int
)	O
)	O
;	O
c_pri	pointer
++	O
)	O
;	O
snprintf	function
(	O
res	array
,	O
sizeof	O
(	O
res	array
)	O
,	O
"%s.%s"	pointer
,	O
c_fac	pointer
->	O
c_name	pointer
,	O
c_pri	pointer
->	O
c_name	pointer
)	O
;	O
return	O
res	array
;	O
}	O
void	O
logmsg	function
(	O
int	O
pri	int
,	O
const	O
char	O
*	O
msg	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
filed	struct
*	O
f	pointer
;	O
int	O
fac	int
,	O
msglen	int
,	O
prilev	int
;	O
sigset_t	struct
sigs	struct
,	O
osigs	struct
;	O
const	O
char	O
*	O
timestamp	pointer
;	O
dbg_printf	function
(	O
"(logmsg): %s (%d), flags %x, from %s, msg %s\n"	pointer
,	O
textpri	function
(	O
pri	int
)	O
,	O
pri	int
,	O
flags	int
,	O
from	pointer
,	O
msg	pointer
)	O
;	O
sigemptyset	function
(	O
&	O
sigs	struct
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGHUP	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGALRM	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
sigs	struct
,	O
&	O
osigs	struct
)	O
;	O
msglen	int
=	O
strlen	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
msglen	int
<	O
16	int
||	O
msg	pointer
[	O
3	int
]	O
!=	O
' '	O
||	O
msg	pointer
[	O
6	int
]	O
!=	O
' '	O
||	O
msg	pointer
[	O
9	int
]	O
!=	O
':'	O
||	O
msg	pointer
[	O
12	int
]	O
!=	O
':'	O
||	O
msg	pointer
[	O
15	int
]	O
!=	O
' '	O
)	O
flags	int
|=	O
ADDDATE	int
;	O
time	struct
(	O
&	O
now	long
)	O
;	O
if	O
(	O
flags	int
&	O
ADDDATE	int
)	O
timestamp	pointer
=	O
ctime	function
(	O
&	O
now	long
)	O
+	O
4	int
;	O
else	O
{	O
timestamp	pointer
=	O
msg	pointer
;	O
msg	pointer
+=	O
16	int
;	O
msglen	int
-=	O
16	int
;	O
}	O
if	O
(	O
flags	int
&	O
MARK	int
)	O
fac	int
=	O
LOG_NFACILITIES	int
;	O
else	O
fac	int
=	O
LOG_FAC	O
(	O
pri	int
)	O
;	O
prilev	int
=	O
LOG_PRI	O
(	O
pri	int
)	O
;	O
if	O
(	O
!	O
Initialized	int
)	O
{	O
f	pointer
=	O
&	O
consfile	struct
;	O
f	pointer
->	O
f_file	short
=	O
open	function
(	O
ctty	array
,	O
O_WRONLY	int
,	O
0	int
)	O
;	O
f	pointer
->	O
f_prevhost	pointer
=	O
strdup	function
(	O
LocalHostName	pointer
)	O
;	O
if	O
(	O
f	pointer
->	O
f_file	short
>=	O
0	int
)	O
{	O
fprintlog	function
(	O
f	pointer
,	O
from	pointer
,	O
flags	int
,	O
msg	pointer
)	O
;	O
close	pointer
(	O
f	pointer
->	O
f_file	short
)	O
;	O
}	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
osigs	struct
,	O
0	int
)	O
;	O
return	O
;	O
}	O
for	O
(	O
f	pointer
=	O
Files	pointer
;	O
f	pointer
;	O
f	pointer
=	O
f	pointer
->	O
f_next	pointer
)	O
{	O
if	O
(	O
!	O
(	O
f	pointer
->	O
f_pmask	array
[	O
fac	int
]	O
&	O
LOG_MASK	O
(	O
prilev	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
f	pointer
->	O
f_type	short
==	O
F_CONSOLE	int
&&	O
(	O
flags	int
&	O
IGN_CONS	int
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
MARK	int
)	O
&&	O
(	O
now	long
-	O
f	pointer
->	O
f_time	long
)	O
<	O
MarkInterval	int
/	O
2	int
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
MARK	int
)	O
==	O
0	int
&&	O
msglen	int
==	O
f	pointer
->	O
f_prevlen	int
&&	O
f	pointer
->	O
f_prevhost	pointer
&&	O
!	O
strcmp	function
(	O
msg	pointer
,	O
f	pointer
->	O
f_prevline	array
)	O
&&	O
!	O
strcmp	function
(	O
from	pointer
,	O
f	pointer
->	O
f_prevhost	pointer
)	O
)	O
{	O
strncpy	function
(	O
f	pointer
->	O
f_lasttime	array
,	O
timestamp	pointer
,	O
sizeof	O
(	O
f	pointer
->	O
f_lasttime	array
)	O
-	O
1	int
)	O
;	O
f	pointer
->	O
f_prevcount	int
++	O
;	O
dbg_printf	function
(	O
"msg repeated %d times, %ld sec of %d\n"	pointer
,	O
f	pointer
->	O
f_prevcount	int
,	O
now	long
-	O
f	pointer
->	O
f_time	long
,	O
repeatinterval	array
[	O
f	pointer
->	O
f_repeatcount	long
]	O
)	O
;	O
if	O
(	O
now	long
>	O
REPEATTIME	O
(	O
f	pointer
)	O
)	O
{	O
fprintlog	function
(	O
f	pointer
,	O
from	pointer
,	O
flags	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
BACKOFF	O
(	O
f	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
f	pointer
->	O
f_prevcount	int
)	O
fprintlog	function
(	O
f	pointer
,	O
from	pointer
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
f	pointer
->	O
f_repeatcount	long
=	O
0	int
;	O
strncpy	function
(	O
f	pointer
->	O
f_lasttime	array
,	O
timestamp	pointer
,	O
sizeof	O
(	O
f	pointer
->	O
f_lasttime	array
)	O
-	O
1	int
)	O
;	O
free	function
(	O
f	pointer
->	O
f_prevhost	pointer
)	O
;	O
f	pointer
->	O
f_prevhost	pointer
=	O
strdup	function
(	O
from	pointer
)	O
;	O
if	O
(	O
msglen	int
<	O
MAXSVLINE	int
)	O
{	O
f	pointer
->	O
f_prevlen	int
=	O
msglen	int
;	O
f	pointer
->	O
f_prevpri	int
=	O
pri	int
;	O
strcpy	function
(	O
f	pointer
->	O
f_prevline	array
,	O
msg	pointer
)	O
;	O
fprintlog	function
(	O
f	pointer
,	O
from	pointer
,	O
flags	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
f	pointer
->	O
f_prevline	array
[	O
0	int
]	O
=	O
0	int
;	O
f	pointer
->	O
f_prevlen	int
=	O
0	int
;	O
fprintlog	function
(	O
f	pointer
,	O
from	pointer
,	O
flags	int
,	O
msg	pointer
)	O
;	O
}	O
}	O
}	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
osigs	struct
,	O
0	int
)	O
;	O
}	O
void	O
fprintlog	function
(	O
struct	O
filed	struct
*	O
f	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
int	O
flags	int
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
struct	O
iovec	struct
iov	array
[	O
IOVCNT	int
]	O
;	O
struct	O
iovec	struct
*	O
v	int
;	O
int	O
l	int
;	O
char	O
line	pointer
[	O
MAXLINE	int
+	O
1	int
]	O
,	O
repbuf	array
[	O
80	int
]	O
,	O
greetings	array
[	O
200	int
]	O
;	O
time_t	long
fwd_suspend	long
;	O
v	int
=	O
iov	array
;	O
memset	function
(	O
v	int
,	O
0	int
,	O
sizeof	O
(	O
struct	O
iovec	struct
)	O
*	O
IOVCNT	int
)	O
;	O
if	O
(	O
f	pointer
->	O
f_type	short
==	O
F_WALL	int
)	O
{	O
v	int
->	O
iov_base	pointer
=	O
greetings	array
;	O
snprintf	function
(	O
greetings	array
,	O
sizeof	O
(	O
greetings	array
)	O
,	O
"\r\n\7Message from syslogd@%s at %.24s ...\r\n"	pointer
,	O
f	pointer
->	O
f_prevhost	pointer
,	O
ctime	function
(	O
&	O
now	long
)	O
)	O
;	O
v	int
->	O
iov_len	long
=	O
strlen	function
(	O
greetings	array
)	O
;	O
v	int
++	O
;	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
""	pointer
;	O
v	int
->	O
iov_len	long
=	O
0	int
;	O
v	int
++	O
;	O
}	O
else	O
{	O
v	int
->	O
iov_base	pointer
=	O
f	pointer
->	O
f_lasttime	array
;	O
v	int
->	O
iov_len	long
=	O
sizeof	O
(	O
f	pointer
->	O
f_lasttime	array
)	O
-	O
1	int
;	O
v	int
++	O
;	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
" "	pointer
;	O
v	int
->	O
iov_len	long
=	O
1	int
;	O
v	int
++	O
;	O
}	O
if	O
(	O
f	pointer
->	O
f_prevhost	pointer
)	O
{	O
v	int
->	O
iov_base	pointer
=	O
f	pointer
->	O
f_prevhost	pointer
;	O
v	int
->	O
iov_len	long
=	O
strlen	function
(	O
v	int
->	O
iov_base	pointer
)	O
;	O
v	int
++	O
;	O
}	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
" "	pointer
;	O
v	int
->	O
iov_len	long
=	O
1	int
;	O
v	int
++	O
;	O
if	O
(	O
msg	pointer
)	O
{	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
msg	pointer
;	O
v	int
->	O
iov_len	long
=	O
strlen	function
(	O
msg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
f	pointer
->	O
f_prevcount	int
>	O
1	int
)	O
{	O
v	int
->	O
iov_base	pointer
=	O
repbuf	array
;	O
snprintf	function
(	O
repbuf	array
,	O
sizeof	O
(	O
repbuf	array
)	O
,	O
"last message repeated %d times"	pointer
,	O
f	pointer
->	O
f_prevcount	int
)	O
;	O
v	int
->	O
iov_len	long
=	O
strlen	function
(	O
repbuf	array
)	O
;	O
}	O
else	O
{	O
v	int
->	O
iov_base	pointer
=	O
f	pointer
->	O
f_prevline	array
;	O
v	int
->	O
iov_len	long
=	O
f	pointer
->	O
f_prevlen	int
;	O
}	O
v	int
++	O
;	O
dbg_printf	function
(	O
"Logging to %s"	pointer
,	O
TypeNames	array
[	O
f	pointer
->	O
f_type	short
]	O
)	O
;	O
switch	O
(	O
f	pointer
->	O
f_type	short
)	O
{	O
case	O
F_UNUSED	int
:	O
f	pointer
->	O
f_time	long
=	O
now	long
;	O
dbg_printf	function
(	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
F_FORW_SUSP	int
:	O
fwd_suspend	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
-	O
f	pointer
->	O
f_time	long
;	O
if	O
(	O
fwd_suspend	long
>=	O
INET_SUSPEND_TIME	int
)	O
{	O
dbg_printf	function
(	O
"\nForwarding suspension over, retrying FORW "	pointer
)	O
;	O
f	pointer
->	O
f_type	short
=	O
F_FORW	int
;	O
goto	O
f_forw	struct
;	O
}	O
else	O
{	O
dbg_printf	function
(	O
" %s\n"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
dbg_printf	function
(	O
"Forwarding suspension not over, time left: %d.\n"	pointer
,	O
INET_SUSPEND_TIME	int
-	O
fwd_suspend	long
)	O
;	O
}	O
break	O
;	O
case	O
F_FORW_UNKN	int
:	O
dbg_printf	function
(	O
" %s\n"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
fwd_suspend	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
-	O
f	pointer
->	O
f_time	long
;	O
if	O
(	O
fwd_suspend	long
>=	O
INET_SUSPEND_TIME	int
)	O
{	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
rp	pointer
;	O
int	O
err	long
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
usefamily	int
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_ADDRCONFIG	int
;	O
err	long
=	O
getaddrinfo	function
(	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
,	O
LogPortText	pointer
,	O
&	O
hints	struct
,	O
&	O
rp	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	function
(	O
"Failure: %s\n"	pointer
,	O
gai_strerror	function
(	O
err	long
)	O
)	O
;	O
dbg_printf	function
(	O
"Retries: %d\n"	pointer
,	O
f	pointer
->	O
f_prevcount	int
)	O
;	O
if	O
(	O
--	O
f	pointer
->	O
f_prevcount	int
<	O
0	int
)	O
{	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
dbg_printf	function
(	O
"%s found, resuming.\n"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addrlen	int
=	O
rp	pointer
->	O
ai_addrlen	int
;	O
memcpy	function
(	O
&	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
,	O
rp	pointer
->	O
ai_addr	pointer
,	O
rp	pointer
->	O
ai_addrlen	int
)	O
;	O
freeaddrinfo	function
(	O
rp	pointer
)	O
;	O
f	pointer
->	O
f_prevcount	int
=	O
0	int
;	O
f	pointer
->	O
f_type	short
=	O
F_FORW	int
;	O
goto	O
f_forw	struct
;	O
}	O
}	O
else	O
dbg_printf	function
(	O
"Forwarding suspension not over, time left: %d\n"	pointer
,	O
INET_SUSPEND_TIME	int
-	O
fwd_suspend	long
)	O
;	O
break	O
;	O
case	O
F_FORW	int
:	O
f_forw	struct
:	O
dbg_printf	function
(	O
" %s\n"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
if	O
(	O
strcasecmp	function
(	O
from	pointer
,	O
LocalHostName	pointer
)	O
&&	O
NoHops	int
)	O
dbg_printf	function
(	O
"Not forwarding remote message.\n"	pointer
)	O
;	O
else	O
if	O
(	O
NoForward	int
)	O
dbg_printf	function
(	O
"Not forwarding because forwarding is disabled.\n"	pointer
)	O
;	O
else	O
{	O
int	O
temp_finet	int
,	O
*	O
pfinet	pointer
;	O
if	O
(	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
.	O
ss_family	short
==	O
AF_INET	O
)	O
pfinet	pointer
=	O
&	O
finet	array
[	O
IU_FD_IP4	int
]	O
;	O
else	O
pfinet	pointer
=	O
&	O
finet	array
[	O
IU_FD_IP6	int
]	O
;	O
temp_finet	int
=	O
*	O
pfinet	pointer
;	O
if	O
(	O
temp_finet	int
<	O
0	int
)	O
{	O
int	O
err	long
;	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
rp	pointer
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
.	O
ss_family	short
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_PASSIVE	int
;	O
err	long
=	O
getaddrinfo	function
(	O
NULL	O
,	O
LogPortText	pointer
,	O
&	O
hints	struct
,	O
&	O
rp	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	function
(	O
"Not forwarding due to lookup failure: %s.\n"	pointer
,	O
gai_strerror	function
(	O
err	long
)	O
)	O
;	O
break	O
;	O
}	O
temp_finet	int
=	O
socket	function
(	O
rp	pointer
->	O
ai_family	int
,	O
rp	pointer
->	O
ai_socktype	int
,	O
rp	pointer
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
temp_finet	int
<	O
0	int
)	O
{	O
dbg_printf	function
(	O
"Not forwarding due to socket failure.\n"	pointer
)	O
;	O
freeaddrinfo	function
(	O
rp	pointer
)	O
;	O
break	O
;	O
}	O
err	long
=	O
bind	function
(	O
temp_finet	int
,	O
rp	pointer
->	O
ai_addr	pointer
,	O
rp	pointer
->	O
ai_addrlen	int
)	O
;	O
freeaddrinfo	function
(	O
rp	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	function
(	O
"Not forwarding due to bind error: %s.\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
f	pointer
->	O
f_time	long
=	O
now	long
;	O
snprintf	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
"<%d>%.15s %s"	pointer
,	O
f	pointer
->	O
f_prevpri	int
,	O
(	O
char	O
*	O
)	O
iov	array
[	O
0	int
]	O
.	O
iov_base	pointer
,	O
(	O
char	O
*	O
)	O
iov	array
[	O
4	int
]	O
.	O
iov_base	pointer
)	O
;	O
l	int
=	O
strlen	function
(	O
line	pointer
)	O
;	O
if	O
(	O
l	int
>	O
MAXLINE	int
)	O
l	int
=	O
MAXLINE	int
;	O
if	O
(	O
sendto	function
(	O
temp_finet	int
,	O
line	pointer
,	O
l	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
,	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addrlen	int
)	O
!=	O
l	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
dbg_printf	function
(	O
"INET sendto error: %d = %s.\n"	pointer
,	O
e	int
,	O
strerror	function
(	O
e	int
)	O
)	O
;	O
f	pointer
->	O
f_type	short
=	O
F_FORW_SUSP	int
;	O
errno	O
=	O
e	int
;	O
logerror	function
(	O
"sendto"	pointer
)	O
;	O
}	O
if	O
(	O
*	O
pfinet	pointer
<	O
0	int
)	O
close	pointer
(	O
temp_finet	int
)	O
;	O
}	O
break	O
;	O
case	O
F_CONSOLE	int
:	O
f	pointer
->	O
f_time	long
=	O
now	long
;	O
if	O
(	O
flags	int
&	O
IGN_CONS	int
)	O
{	O
dbg_printf	function
(	O
" (ignored)\n"	pointer
)	O
;	O
break	O
;	O
}	O
case	O
F_TTY	int
:	O
case	O
F_FILE	int
:	O
case	O
F_PIPE	int
:	O
f	pointer
->	O
f_time	long
=	O
now	long
;	O
dbg_printf	function
(	O
" %s\n"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
if	O
(	O
f	pointer
->	O
f_type	short
==	O
F_TTY	int
||	O
f	pointer
->	O
f_type	short
==	O
F_CONSOLE	int
)	O
{	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
"\r\n"	pointer
;	O
v	int
->	O
iov_len	long
=	O
2	int
;	O
}	O
else	O
{	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
"\n"	pointer
;	O
v	int
->	O
iov_len	long
=	O
1	int
;	O
}	O
again	O
:	O
if	O
(	O
writev	function
(	O
f	pointer
->	O
f_file	short
,	O
iov	array
,	O
IOVCNT	int
)	O
<	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
if	O
(	O
f	pointer
->	O
f_type	short
==	O
F_PIPE	int
&&	O
e	int
==	O
EAGAIN	int
)	O
break	O
;	O
close	pointer
(	O
f	pointer
->	O
f_file	short
)	O
;	O
if	O
(	O
(	O
e	int
==	O
EIO	int
||	O
e	int
==	O
EBADF	int
)	O
&&	O
(	O
f	pointer
->	O
f_type	short
==	O
F_TTY	int
||	O
f	pointer
->	O
f_type	short
==	O
F_CONSOLE	int
)	O
)	O
{	O
f	pointer
->	O
f_file	short
=	O
open	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
,	O
O_WRONLY	int
|	O
O_APPEND	int
,	O
0	int
)	O
;	O
if	O
(	O
f	pointer
->	O
f_file	short
<	O
0	int
)	O
{	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
=	O
NULL	O
;	O
}	O
else	O
goto	O
again	O
;	O
}	O
else	O
{	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
errno	O
=	O
e	int
;	O
logerror	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
flags	int
&	O
SYNC_FILE	int
)	O
&&	O
!	O
(	O
f	pointer
->	O
f_flags	int
&	O
OMIT_SYNC	int
)	O
)	O
fsync	function
(	O
f	pointer
->	O
f_file	short
)	O
;	O
break	O
;	O
case	O
F_USERS	int
:	O
case	O
F_WALL	int
:	O
f	pointer
->	O
f_time	long
=	O
now	long
;	O
dbg_printf	function
(	O
"\n"	pointer
)	O
;	O
v	int
->	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
"\r\n"	pointer
;	O
v	int
->	O
iov_len	long
=	O
2	int
;	O
wallmsg	function
(	O
f	pointer
,	O
iov	array
)	O
;	O
break	O
;	O
}	O
if	O
(	O
f	pointer
->	O
f_type	short
!=	O
F_FORW_UNKN	int
)	O
f	pointer
->	O
f_prevcount	int
=	O
0	int
;	O
}	O
void	O
wallmsg	function
(	O
struct	O
filed	struct
*	O
f	pointer
,	O
struct	O
iovec	struct
*	O
iov	array
)	O
{	O
static	O
int	O
reenter	int
;	O
STRUCT_UTMP	struct
*	O
utmpbuf	pointer
,	O
*	O
utp	pointer
;	O
size_t	long
utmp_count	long
;	O
int	O
i	long
;	O
char	O
*	O
p	pointer
;	O
char	O
line	pointer
[	O
sizeof	O
(	O
utp	pointer
->	O
ut_line	array
)	O
+	O
1	int
]	O
;	O
if	O
(	O
reenter	int
++	O
)	O
return	O
;	O
read_utmp	function
(	O
PATH_UTMP	O
,	O
&	O
utmp_count	long
,	O
&	O
utmpbuf	pointer
,	O
READ_UTMP_USER_PROCESS	int
|	O
READ_UTMP_CHECK_PIDS	int
)	O
;	O
for	O
(	O
utp	pointer
=	O
utmpbuf	pointer
;	O
utp	pointer
<	O
utmpbuf	pointer
+	O
utmp_count	long
;	O
utp	pointer
++	O
)	O
{	O
strncpy	function
(	O
line	pointer
,	O
utp	pointer
->	O
ut_line	array
,	O
sizeof	O
(	O
utp	pointer
->	O
ut_line	array
)	O
)	O
;	O
line	pointer
[	O
sizeof	O
(	O
utp	pointer
->	O
ut_line	array
)	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
f	pointer
->	O
f_type	short
==	O
F_WALL	int
)	O
{	O
p	pointer
=	O
ttymsg	function
(	O
iov	array
,	O
IOVCNT	int
,	O
line	pointer
,	O
TTYMSGTIME	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
logerror	function
(	O
p	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_nusers	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
strncmp	function
(	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
i	long
]	O
,	O
UT_USER	O
(	O
utp	pointer
)	O
,	O
sizeof	O
(	O
UT_USER	O
(	O
utp	pointer
)	O
)	O
)	O
)	O
{	O
p	pointer
=	O
ttymsg	function
(	O
iov	array
,	O
IOVCNT	int
,	O
line	pointer
,	O
TTYMSGTIME	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
logerror	function
(	O
p	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
free	function
(	O
utmpbuf	pointer
)	O
;	O
reenter	int
=	O
0	int
;	O
}	O
const	O
char	O
*	O
cvthname	function
(	O
struct	O
sockaddr	struct
*	O
f	pointer
,	O
socklen_t	int
len	int
)	O
{	O
int	O
err	long
;	O
char	O
*	O
p	pointer
;	O
err	long
=	O
getnameinfo	function
(	O
f	pointer
,	O
len	int
,	O
addrstr	array
,	O
sizeof	O
(	O
addrstr	array
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	function
(	O
"Malformed from address: %s.\n"	pointer
,	O
gai_strerror	function
(	O
err	long
)	O
)	O
;	O
return	O
"???"	pointer
;	O
}	O
dbg_printf	function
(	O
"cvthname(%s)\n"	pointer
,	O
addrstr	array
)	O
;	O
err	long
=	O
getnameinfo	function
(	O
f	pointer
,	O
len	int
,	O
addrname	array
,	O
sizeof	O
(	O
addrname	array
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NAMEREQD	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
dbg_printf	function
(	O
"Host name for your address (%s) unknown.\n"	pointer
,	O
addrstr	array
)	O
;	O
return	O
addrstr	array
;	O
}	O
p	pointer
=	O
strchr	function
(	O
addrname	array
,	O
'.'	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
p	pointer
+	O
1	int
,	O
LocalDomain	pointer
)	O
==	O
0	int
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
else	O
{	O
int	O
count	int
;	O
if	O
(	O
StripDomains	pointer
)	O
{	O
count	int
=	O
0	int
;	O
while	O
(	O
StripDomains	pointer
[	O
count	int
]	O
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
p	pointer
+	O
1	int
,	O
StripDomains	pointer
[	O
count	int
]	O
)	O
==	O
0	int
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
addrname	array
;	O
}	O
count	int
++	O
;	O
}	O
}	O
if	O
(	O
LocalHosts	pointer
)	O
{	O
count	int
=	O
0	int
;	O
while	O
(	O
LocalHosts	pointer
[	O
count	int
]	O
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
addrname	array
,	O
LocalHosts	pointer
[	O
count	int
]	O
)	O
==	O
0	int
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
addrname	array
;	O
}	O
count	int
++	O
;	O
}	O
}	O
}	O
}	O
return	O
addrname	array
;	O
}	O
void	O
domark	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
struct	O
filed	struct
*	O
f	pointer
;	O
now	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
MarkInterval	int
>	O
0	int
)	O
{	O
MarkSeq	int
+=	O
TIMERINTVL	int
;	O
if	O
(	O
MarkSeq	int
>=	O
MarkInterval	int
)	O
{	O
logmsg	function
(	O
LOG_INFO	int
,	O
"-- MARK --"	pointer
,	O
LocalHostName	pointer
,	O
ADDDATE	int
|	O
MARK	int
)	O
;	O
MarkSeq	int
=	O
0	int
;	O
}	O
}	O
for	O
(	O
f	pointer
=	O
Files	pointer
;	O
f	pointer
;	O
f	pointer
=	O
f	pointer
->	O
f_next	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
f_prevcount	int
&&	O
now	long
>=	O
REPEATTIME	O
(	O
f	pointer
)	O
)	O
{	O
dbg_printf	function
(	O
"flush %s: repeated %d times, %d sec.\n"	pointer
,	O
TypeNames	array
[	O
f	pointer
->	O
f_type	short
]	O
,	O
f	pointer
->	O
f_prevcount	int
,	O
repeatinterval	array
[	O
f	pointer
->	O
f_repeatcount	long
]	O
)	O
;	O
fprintlog	function
(	O
f	pointer
,	O
LocalHostName	pointer
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
BACKOFF	O
(	O
f	pointer
)	O
;	O
}	O
}	O
alarm	function
(	O
TIMERINTVL	int
)	O
;	O
}	O
void	O
logerror	function
(	O
const	O
char	O
*	O
type	enum
)	O
{	O
char	O
buf	array
[	O
100	int
]	O
;	O
if	O
(	O
errno	O
)	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
"syslogd: %s: %s"	pointer
,	O
type	enum
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
"syslogd: %s"	pointer
,	O
type	enum
)	O
;	O
errno	O
=	O
0	int
;	O
dbg_printf	function
(	O
"%s\n"	pointer
,	O
buf	array
)	O
;	O
logmsg	function
(	O
LOG_SYSLOG	O
|	O
LOG_ERR	int
,	O
buf	array
,	O
LocalHostName	pointer
,	O
ADDDATE	int
)	O
;	O
}	O
void	O
doexit	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
_exit	function
(	O
0	int
)	O
;	O
}	O
void	O
die	function
(	O
int	O
signo	int
)	O
{	O
struct	O
filed	struct
*	O
f	pointer
;	O
int	O
was_initialized	int
=	O
Initialized	int
;	O
char	O
buf	array
[	O
100	int
]	O
;	O
size_t	long
i	long
;	O
Initialized	int
=	O
0	int
;	O
for	O
(	O
f	pointer
=	O
Files	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
f_next	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
f_prevcount	int
)	O
fprintlog	function
(	O
f	pointer
,	O
LocalHostName	pointer
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
Initialized	int
=	O
was_initialized	int
;	O
if	O
(	O
signo	int
)	O
{	O
dbg_printf	function
(	O
"%s: exiting on signal %d\n"	pointer
,	O
program_invocation_name	pointer
,	O
signo	int
)	O
;	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
"exiting on signal %d"	pointer
,	O
signo	int
)	O
;	O
errno	O
=	O
0	int
;	O
logerror	function
(	O
buf	array
)	O
;	O
}	O
if	O
(	O
fklog	int
>=	O
0	int
)	O
close	pointer
(	O
fklog	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nfunix	long
;	O
i	long
++	O
)	O
if	O
(	O
funix	struct
[	O
i	long
]	O
.	O
fd	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
funix	struct
[	O
i	long
]	O
.	O
fd	int
)	O
;	O
if	O
(	O
funix	struct
[	O
i	long
]	O
.	O
name	pointer
)	O
unlink	function
(	O
funix	struct
[	O
i	long
]	O
.	O
name	pointer
)	O
;	O
}	O
if	O
(	O
finet	array
[	O
IU_FD_IP4	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
finet	array
[	O
IU_FD_IP4	int
]	O
)	O
;	O
if	O
(	O
finet	array
[	O
IU_FD_IP6	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
finet	array
[	O
IU_FD_IP6	int
]	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
init	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
FILE	struct
*	O
cf	pointer
;	O
struct	O
filed	struct
*	O
f	pointer
,	O
*	O
next	int
,	O
*	O
*	O
nextp	pointer
;	O
char	O
*	O
p	pointer
;	O
size_t	long
line_max	long
=	O
LINE_MAX	O
;	O
char	O
*	O
cbuf	pointer
;	O
char	O
*	O
cline	pointer
;	O
int	O
cont_line	int
=	O
0	int
;	O
dbg_printf	function
(	O
"init\n"	pointer
)	O
;	O
Initialized	int
=	O
0	int
;	O
for	O
(	O
f	pointer
=	O
Files	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
next	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
f	pointer
->	O
f_prevcount	int
)	O
fprintlog	function
(	O
f	pointer
,	O
LocalHostName	pointer
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
switch	O
(	O
f	pointer
->	O
f_type	short
)	O
{	O
case	O
F_FILE	int
:	O
case	O
F_TTY	int
:	O
case	O
F_CONSOLE	int
:	O
case	O
F_PIPE	int
:	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
close	pointer
(	O
f	pointer
->	O
f_file	short
)	O
;	O
break	O
;	O
case	O
F_FORW	int
:	O
case	O
F_FORW_SUSP	int
:	O
case	O
F_FORW_UNKN	int
:	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
break	O
;	O
case	O
F_USERS	int
:	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_nusers	int
;	O
++	O
j	int
)	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
j	int
]	O
)	O
;	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
)	O
;	O
break	O
;	O
}	O
free	function
(	O
f	pointer
->	O
f_prevhost	pointer
)	O
;	O
next	int
=	O
f	pointer
->	O
f_next	pointer
;	O
free	function
(	O
f	pointer
)	O
;	O
}	O
Files	pointer
=	O
NULL	O
;	O
nextp	pointer
=	O
&	O
Files	pointer
;	O
facilities_seen	int
=	O
0	int
;	O
cf	pointer
=	O
fopen	function
(	O
ConfFile	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
cf	pointer
==	O
NULL	O
)	O
{	O
dbg_printf	function
(	O
"cannot open %s\n"	pointer
,	O
ConfFile	pointer
)	O
;	O
*	O
nextp	pointer
=	O
(	O
struct	O
filed	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
f	pointer
)	O
)	O
;	O
cfline	function
(	O
"*.ERR\t"	pointer
PATH_CONSOLE	O
,	O
*	O
nextp	pointer
)	O
;	O
(	O
*	O
nextp	pointer
)	O
->	O
f_next	pointer
=	O
(	O
struct	O
filed	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
f	pointer
)	O
)	O
;	O
cfline	function
(	O
"*.PANIC\t*"	pointer
,	O
(	O
*	O
nextp	pointer
)	O
->	O
f_next	pointer
)	O
;	O
Initialized	int
=	O
1	int
;	O
return	O
;	O
}	O
f	pointer
=	O
NULL	O
;	O
cbuf	pointer
=	O
malloc	function
(	O
line_max	long
)	O
;	O
if	O
(	O
cbuf	pointer
==	O
NULL	O
)	O
{	O
dbg_printf	function
(	O
"cannot allocate space for configuration\n"	pointer
)	O
;	O
fclose	function
(	O
cf	pointer
)	O
;	O
return	O
;	O
}	O
cline	pointer
=	O
cbuf	pointer
;	O
while	O
(	O
fgets	function
(	O
cline	pointer
,	O
line_max	long
-	O
(	O
cline	pointer
-	O
cbuf	pointer
)	O
,	O
cf	pointer
)	O
!=	O
NULL	O
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
cline	pointer
)	O
;	O
if	O
(	O
cont_line	int
)	O
{	O
char	O
*	O
start	pointer
=	O
cline	pointer
;	O
while	O
(	O
*	O
start	pointer
==	O
' '	O
||	O
*	O
start	pointer
==	O
'\t'	O
)	O
start	pointer
++	O
;	O
len	int
=	O
len	int
-	O
(	O
start	pointer
-	O
cline	pointer
)	O
;	O
memmove	function
(	O
cline	pointer
,	O
start	pointer
,	O
len	int
+	O
1	int
)	O
;	O
cont_line	int
=	O
0	int
;	O
}	O
if	O
(	O
strchr	function
(	O
cline	pointer
,	O
'\n'	O
)	O
==	O
NULL	O
)	O
{	O
size_t	long
offset	long
=	O
cline	pointer
-	O
cbuf	pointer
;	O
char	O
*	O
tmp	pointer
;	O
tmp	pointer
=	O
realloc	function
(	O
cbuf	pointer
,	O
line_max	long
*	O
2	int
)	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
{	O
dbg_printf	function
(	O
"cannot allocate space configuration\n"	pointer
)	O
;	O
fclose	function
(	O
cf	pointer
)	O
;	O
free	function
(	O
cbuf	pointer
)	O
;	O
return	O
;	O
}	O
else	O
cbuf	pointer
=	O
tmp	pointer
;	O
line_max	long
*=	O
2	int
;	O
cline	pointer
=	O
cbuf	pointer
+	O
offset	long
+	O
len	int
-	O
1	int
;	O
continue	O
;	O
}	O
else	O
cline	pointer
=	O
cbuf	pointer
;	O
for	O
(	O
p	pointer
=	O
cline	pointer
;	O
isspace	function
(	O
*	O
p	pointer
)	O
;	O
++	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
||	O
*	O
p	pointer
==	O
'#'	O
)	O
continue	O
;	O
strcpy	function
(	O
cline	pointer
,	O
p	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
strchr	function
(	O
cline	pointer
,	O
'\0'	O
)	O
;	O
isspace	function
(	O
*	O
--	O
p	pointer
)	O
;	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
cline	pointer
=	O
p	pointer
;	O
cont_line	int
=	O
1	int
;	O
continue	O
;	O
}	O
*	O
++	O
p	pointer
=	O
'\0'	O
;	O
f	pointer
=	O
(	O
struct	O
filed	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
f	pointer
)	O
)	O
;	O
*	O
nextp	pointer
=	O
f	pointer
;	O
nextp	pointer
=	O
&	O
f	pointer
->	O
f_next	pointer
;	O
cfline	function
(	O
cbuf	pointer
,	O
f	pointer
)	O
;	O
}	O
fclose	function
(	O
cf	pointer
)	O
;	O
free	function
(	O
cbuf	pointer
)	O
;	O
Initialized	int
=	O
1	int
;	O
if	O
(	O
Debug	int
)	O
{	O
for	O
(	O
f	pointer
=	O
Files	pointer
;	O
f	pointer
;	O
f	pointer
=	O
f	pointer
->	O
f_next	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
LOG_NFACILITIES	int
;	O
i	long
++	O
)	O
if	O
(	O
f	pointer
->	O
f_pmask	array
[	O
i	long
]	O
==	O
0	int
)	O
dbg_printf	function
(	O
" X "	pointer
)	O
;	O
else	O
dbg_printf	function
(	O
"%2x "	pointer
,	O
f	pointer
->	O
f_pmask	array
[	O
i	long
]	O
)	O
;	O
dbg_printf	function
(	O
"%s: "	pointer
,	O
TypeNames	array
[	O
f	pointer
->	O
f_type	short
]	O
)	O
;	O
switch	O
(	O
f	pointer
->	O
f_type	short
)	O
{	O
case	O
F_FILE	int
:	O
case	O
F_TTY	int
:	O
case	O
F_CONSOLE	int
:	O
case	O
F_PIPE	int
:	O
dbg_printf	function
(	O
"%s"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
break	O
;	O
case	O
F_FORW	int
:	O
case	O
F_FORW_SUSP	int
:	O
case	O
F_FORW_UNKN	int
:	O
dbg_printf	function
(	O
"%s"	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
)	O
;	O
break	O
;	O
case	O
F_USERS	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_nusers	int
;	O
i	long
++	O
)	O
dbg_printf	function
(	O
"%s, "	pointer
,	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
i	long
]	O
)	O
;	O
break	O
;	O
}	O
dbg_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
AcceptRemote	int
)	O
logmsg	function
(	O
LOG_SYSLOG	O
|	O
LOG_INFO	int
,	O
"syslogd ("	pointer
PACKAGE_NAME	pointer
" "	pointer
PACKAGE_VERSION	pointer
"): restart (remote reception)"	pointer
,	O
LocalHostName	pointer
,	O
ADDDATE	int
)	O
;	O
else	O
logmsg	function
(	O
LOG_SYSLOG	O
|	O
LOG_INFO	int
,	O
"syslogd ("	pointer
PACKAGE_NAME	pointer
" "	pointer
PACKAGE_VERSION	pointer
"): restart"	pointer
,	O
LocalHostName	pointer
,	O
ADDDATE	int
)	O
;	O
dbg_printf	function
(	O
"syslogd: restarted\n"	pointer
)	O
;	O
}	O
void	O
cfline	function
(	O
const	O
char	O
*	O
line	pointer
,	O
struct	O
filed	struct
*	O
f	pointer
)	O
{	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
rp	pointer
;	O
int	O
i	long
,	O
pri	int
,	O
negate_pri	int
,	O
excl_pri	int
,	O
err	long
;	O
unsigned	O
int	O
pri_set	int
,	O
pri_clear	int
;	O
char	O
*	O
bp	pointer
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
char	O
buf	array
[	O
MAXLINE	int
]	O
,	O
ebuf	array
[	O
200	int
]	O
;	O
dbg_printf	function
(	O
"cfline(%s)\n"	pointer
,	O
line	pointer
)	O
;	O
errno	O
=	O
0	int
;	O
memset	function
(	O
f	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
f	pointer
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
LOG_NFACILITIES	int
;	O
i	long
++	O
)	O
{	O
f	pointer
->	O
f_pmask	array
[	O
i	long
]	O
=	O
0	int
;	O
f	pointer
->	O
f_flags	int
=	O
0	int
;	O
}	O
for	O
(	O
p	pointer
=	O
line	pointer
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
!=	O
' '	O
;	O
)	O
{	O
for	O
(	O
q	pointer
=	O
p	pointer
;	O
*	O
q	pointer
&&	O
*	O
q	pointer
!=	O
'\t'	O
&&	O
*	O
q	pointer
++	O
!=	O
'.'	O
;	O
)	O
continue	O
;	O
for	O
(	O
bp	pointer
=	O
buf	array
;	O
*	O
q	pointer
&&	O
!	O
strchr	function
(	O
"\t ,;"	pointer
,	O
*	O
q	pointer
)	O
;	O
)	O
*	O
bp	pointer
++	O
=	O
*	O
q	pointer
++	O
;	O
*	O
bp	pointer
=	O
'\0'	O
;	O
while	O
(	O
*	O
q	pointer
&&	O
strchr	function
(	O
",;"	pointer
,	O
*	O
q	pointer
)	O
)	O
q	pointer
++	O
;	O
bp	pointer
=	O
buf	array
;	O
negate_pri	int
=	O
excl_pri	int
=	O
0	int
;	O
while	O
(	O
*	O
bp	pointer
==	O
'!'	O
||	O
*	O
bp	pointer
==	O
'='	O
)	O
switch	O
(	O
*	O
bp	pointer
++	O
)	O
{	O
case	O
'!'	O
:	O
negate_pri	int
=	O
1	int
;	O
break	O
;	O
case	O
'='	O
:	O
excl_pri	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
bp	pointer
==	O
'*'	O
)	O
{	O
pri_clear	int
=	O
0	int
;	O
pri_set	int
=	O
LOG_UPTO	O
(	O
LOG_PRIMASK	int
)	O
;	O
}	O
else	O
{	O
pri	int
=	O
decode	function
(	O
bp	pointer
,	O
prioritynames	array
)	O
;	O
if	O
(	O
pri	int
<	O
0	int
)	O
{	O
snprintf	function
(	O
ebuf	array
,	O
sizeof	O
(	O
ebuf	array
)	O
,	O
"unknown priority name \"%s\""	pointer
,	O
bp	pointer
)	O
;	O
logerror	function
(	O
ebuf	array
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pri	int
==	O
INTERNAL_NOPRI	int
)	O
{	O
pri_clear	int
=	O
255	int
;	O
pri_set	int
=	O
0	int
;	O
}	O
else	O
{	O
pri_clear	int
=	O
0	int
;	O
pri_set	int
=	O
excl_pri	int
?	O
LOG_MASK	O
(	O
pri	int
)	O
:	O
LOG_UPTO	O
(	O
pri	int
)	O
;	O
}	O
}	O
if	O
(	O
negate_pri	int
)	O
{	O
unsigned	O
int	O
exchange	int
=	O
pri_set	int
;	O
pri_set	int
=	O
pri_clear	int
;	O
pri_clear	int
=	O
exchange	int
;	O
}	O
while	O
(	O
*	O
p	pointer
&&	O
!	O
strchr	function
(	O
"\t .;"	pointer
,	O
*	O
p	pointer
)	O
)	O
{	O
for	O
(	O
bp	pointer
=	O
buf	array
;	O
*	O
p	pointer
&&	O
!	O
strchr	function
(	O
"\t ,;."	pointer
,	O
*	O
p	pointer
)	O
;	O
)	O
*	O
bp	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
*	O
bp	pointer
=	O
'\0'	O
;	O
if	O
(	O
*	O
buf	array
==	O
'*'	O
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
LOG_NFACILITIES	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
buf	array
[	O
1	int
]	O
==	O
'*'	O
&&	O
(	O
(	O
1	int
<<	O
i	long
)	O
&	O
facilities_seen	int
)	O
)	O
continue	O
;	O
f	pointer
->	O
f_pmask	array
[	O
i	long
]	O
&=	O
~	O
pri_clear	int
;	O
f	pointer
->	O
f_pmask	array
[	O
i	long
]	O
|=	O
pri_set	int
;	O
}	O
else	O
{	O
i	long
=	O
decode	function
(	O
buf	array
,	O
facilitynames	array
)	O
;	O
facilities_seen	int
|=	O
(	O
1	int
<<	O
LOG_FAC	O
(	O
i	long
)	O
)	O
;	O
if	O
(	O
i	long
<	O
0	int
)	O
{	O
snprintf	function
(	O
ebuf	array
,	O
sizeof	O
(	O
ebuf	array
)	O
,	O
"unknown facility name \"%s\""	pointer
,	O
buf	array
)	O
;	O
logerror	function
(	O
ebuf	array
)	O
;	O
return	O
;	O
}	O
f	pointer
->	O
f_pmask	array
[	O
LOG_FAC	O
(	O
i	long
)	O
]	O
&=	O
~	O
pri_clear	int
;	O
f	pointer
->	O
f_pmask	array
[	O
LOG_FAC	O
(	O
i	long
)	O
]	O
|=	O
pri_set	int
;	O
}	O
while	O
(	O
*	O
p	pointer
==	O
','	O
||	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
}	O
p	pointer
=	O
q	pointer
;	O
}	O
while	O
(	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
{	O
f	pointer
->	O
f_flags	int
|=	O
OMIT_SYNC	int
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
strlen	function
(	O
p	pointer
)	O
)	O
{	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	function
(	O
"empty action field"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'@'	O
:	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_hname	pointer
=	O
strdup	function
(	O
++	O
p	pointer
)	O
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
usefamily	int
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_ADDRCONFIG	int
;	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addrlen	int
=	O
0	int
;	O
memset	function
(	O
&	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
,	O
0	int
,	O
sizeof	O
(	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
)	O
)	O
;	O
err	long
=	O
getaddrinfo	function
(	O
p	pointer
,	O
LogPortText	pointer
,	O
&	O
hints	struct
,	O
&	O
rp	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
switch	O
(	O
err	long
)	O
{	O
case	O
EAI_AGAIN	O
:	O
case	O
EAI_MEMORY	O
:	O
f	pointer
->	O
f_type	short
=	O
F_FORW_UNKN	int
;	O
f	pointer
->	O
f_prevcount	int
=	O
INET_RETRY_MAX	int
;	O
break	O
;	O
case	O
EAI_NONAME	O
:	O
case	O
EAI_NODATA	O
:	O
case	O
EAI_ADDRFAMILY	O
:	O
default	O
:	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
}	O
f	pointer
->	O
f_time	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
f	pointer
->	O
f_type	short
=	O
F_FORW	int
;	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addrlen	int
=	O
rp	pointer
->	O
ai_addrlen	int
;	O
memcpy	function
(	O
&	O
f	pointer
->	O
f_un	union
.	O
f_forw	struct
.	O
f_addr	struct
,	O
rp	pointer
->	O
ai_addr	pointer
,	O
rp	pointer
->	O
ai_addrlen	int
)	O
;	O
freeaddrinfo	function
(	O
rp	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'|'	O
:	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
=	O
strdup	function
(	O
p	pointer
)	O
;	O
if	O
(	O
(	O
f	pointer
->	O
f_file	short
=	O
open	function
(	O
++	O
p	pointer
,	O
O_RDWR	int
|	O
O_NONBLOCK	int
)	O
)	O
<	O
0	int
)	O
{	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	function
(	O
p	pointer
)	O
;	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
ctty	array
)	O
==	O
0	int
)	O
f	pointer
->	O
f_type	short
=	O
F_CONSOLE	int
;	O
else	O
if	O
(	O
isatty	function
(	O
f	pointer
->	O
f_file	short
)	O
)	O
f	pointer
->	O
f_type	short
=	O
F_TTY	int
;	O
else	O
f	pointer
->	O
f_type	short
=	O
F_PIPE	int
;	O
break	O
;	O
case	O
'/'	O
:	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
=	O
strdup	function
(	O
p	pointer
)	O
;	O
if	O
(	O
(	O
f	pointer
->	O
f_file	short
=	O
open	function
(	O
p	pointer
,	O
O_WRONLY	int
|	O
O_APPEND	int
|	O
O_CREAT	int
,	O
0644	int
)	O
)	O
<	O
0	int
)	O
{	O
f	pointer
->	O
f_type	short
=	O
F_UNUSED	int
;	O
logerror	function
(	O
p	pointer
)	O
;	O
free	function
(	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_fname	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
ctty	array
)	O
==	O
0	int
)	O
f	pointer
->	O
f_type	short
=	O
F_CONSOLE	int
;	O
else	O
if	O
(	O
isatty	function
(	O
f	pointer
->	O
f_file	short
)	O
)	O
f	pointer
->	O
f_type	short
=	O
F_TTY	int
;	O
else	O
f	pointer
->	O
f_type	short
=	O
F_FILE	int
;	O
break	O
;	O
case	O
'*'	O
:	O
f	pointer
->	O
f_type	short
=	O
F_WALL	int
;	O
break	O
;	O
default	O
:	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_nusers	int
=	O
1	int
;	O
for	O
(	O
q	pointer
=	O
p	pointer
;	O
*	O
q	pointer
;	O
q	pointer
++	O
)	O
if	O
(	O
*	O
q	pointer
==	O
','	O
)	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_nusers	int
++	O
;	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_nusers	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
*	O
p	pointer
;	O
i	long
++	O
)	O
{	O
for	O
(	O
q	pointer
=	O
p	pointer
;	O
*	O
q	pointer
&&	O
*	O
q	pointer
!=	O
','	O
;	O
)	O
q	pointer
++	O
;	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
i	long
]	O
=	O
malloc	function
(	O
q	pointer
-	O
p	pointer
+	O
1	int
)	O
;	O
if	O
(	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
i	long
]	O
)	O
{	O
strncpy	function
(	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
i	long
]	O
,	O
p	pointer
,	O
q	pointer
-	O
p	pointer
)	O
;	O
f	pointer
->	O
f_un	union
.	O
f_user	struct
.	O
f_unames	pointer
[	O
i	long
]	O
[	O
q	pointer
-	O
p	pointer
]	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
*	O
q	pointer
==	O
','	O
||	O
*	O
q	pointer
==	O
' '	O
)	O
q	pointer
++	O
;	O
p	pointer
=	O
q	pointer
;	O
}	O
f	pointer
->	O
f_type	short
=	O
F_USERS	int
;	O
break	O
;	O
}	O
}	O
int	O
decode	function
(	O
const	O
char	O
*	O
name	pointer
,	O
CODE	struct
*	O
codetab	pointer
)	O
{	O
CODE	struct
*	O
c	int
;	O
if	O
(	O
isdigit	function
(	O
*	O
name	pointer
)	O
)	O
return	O
atoi	function
(	O
name	pointer
)	O
;	O
for	O
(	O
c	int
=	O
codetab	pointer
;	O
c	int
->	O
c_name	pointer
;	O
c	int
++	O
)	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
c	int
->	O
c_name	pointer
)	O
)	O
return	O
c	int
->	O
c_val	int
;	O
return	O
-	O
1	int
;	O
}	O
void	O
dbg_toggle	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
int	O
dbg_save	int
=	O
dbg_output	int
;	O
dbg_output	int
=	O
1	int
;	O
dbg_printf	function
(	O
"Switching dbg_output to %s.\n"	pointer
,	O
dbg_save	int
==	O
0	int
?	O
"true"	pointer
:	O
"false"	pointer
)	O
;	O
dbg_output	int
=	O
(	O
dbg_save	int
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
static	O
void	O
dbg_printf	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
if	O
(	O
!	O
(	O
Debug	int
&&	O
dbg_output	int
)	O
)	O
return	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stdout	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
trigger_restart	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
restart	int
=	O
1	int
;	O
}	O