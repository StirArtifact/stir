static	O
volatile	O
int	O
_argp_hang	int
;	O
static	O
const	O
struct	O
argp_option	struct
argp_default_options	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
'?'	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"give this help list"	pointer
)	O
,	O
-	O
1	int
}	O
,	O
{	O
"usage"	pointer
,	O
OPT_USAGE	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"give a short usage message"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"program-name"	pointer
,	O
OPT_PROGNAME	O
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
OPTION_HIDDEN	int
,	O
N_	O
(	O
"set the program name"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"HANG"	pointer
,	O
OPT_HANG	O
,	O
N_	O
(	O
"SECS"	pointer
)	O
,	O
OPTION_ARG_OPTIONAL	int
|	O
OPTION_HIDDEN	int
,	O
N_	O
(	O
"hang for SECS seconds (default 3600)"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
error_t	int
argp_default_parser	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'?'	O
:	O
__argp_state_help	function
(	O
state	pointer
,	O
state	pointer
->	O
out_stream	pointer
,	O
ARGP_HELP_STD_HELP	O
)	O
;	O
break	O
;	O
case	O
OPT_USAGE	O
:	O
__argp_state_help	function
(	O
state	pointer
,	O
state	pointer
->	O
out_stream	pointer
,	O
ARGP_HELP_USAGE	int
|	O
ARGP_HELP_EXIT_OK	int
)	O
;	O
break	O
;	O
case	O
OPT_PROGNAME	O
:	O
program_invocation_name	pointer
=	O
arg	pointer
;	O
state	pointer
->	O
name	pointer
=	O
__argp_base_name	function
(	O
arg	pointer
)	O
;	O
program_invocation_short_name	pointer
=	O
state	pointer
->	O
name	pointer
;	O
if	O
(	O
(	O
state	pointer
->	O
flags	int
&	O
(	O
ARGP_PARSE_ARGV0	int
|	O
ARGP_NO_ERRS	int
)	O
)	O
==	O
ARGP_PARSE_ARGV0	int
)	O
state	pointer
->	O
argv	pointer
[	O
0	int
]	O
=	O
arg	pointer
;	O
break	O
;	O
case	O
OPT_HANG	O
:	O
_argp_hang	int
=	O
atoi	function
(	O
arg	pointer
?	O
arg	pointer
:	O
"3600"	pointer
)	O
;	O
while	O
(	O
_argp_hang	int
--	O
>	O
0	int
)	O
__sleep	O
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
EBADKEY	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
argp	struct
argp_default_argp	struct
=	O
{	O
argp_default_options	array
,	O
&	O
argp_default_parser	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"libc"	pointer
}	O
;	O
static	O
const	O
struct	O
argp_option	struct
argp_version_options	array
[	O
]	O
=	O
{	O
{	O
"version"	pointer
,	O
'V'	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"print program version"	pointer
)	O
,	O
-	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
error_t	int
argp_version_parser	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'V'	O
:	O
if	O
(	O
argp_program_version_hook	pointer
)	O
(	O
*	O
argp_program_version_hook	pointer
)	O
(	O
state	pointer
->	O
out_stream	pointer
,	O
state	pointer
)	O
;	O
else	O
if	O
(	O
argp_program_version	pointer
)	O
fprintf	function
(	O
state	pointer
->	O
out_stream	pointer
,	O
"%s\n"	pointer
,	O
argp_program_version	pointer
)	O
;	O
else	O
__argp_error	function
(	O
state	pointer
,	O
dgettext	function
(	O
state	pointer
->	O
root_argp	pointer
->	O
argp_domain	pointer
,	O
"(PROGRAM ERROR) No version known!?"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
state	pointer
->	O
flags	int
&	O
ARGP_NO_EXIT	int
)	O
)	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
EBADKEY	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
argp	struct
argp_version_argp	struct
=	O
{	O
argp_version_options	array
,	O
&	O
argp_version_parser	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"libc"	pointer
}	O
;	O
static	O
int	O
find_long_option	function
(	O
struct	O
option	struct
*	O
long_options	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
option	struct
*	O
l	pointer
=	O
long_options	pointer
;	O
while	O
(	O
l	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
l	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
l	pointer
-	O
long_options	pointer
;	O
else	O
l	pointer
++	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
l	pointer
-	O
long_options	pointer
;	O
else	O
return	O
-	O
1	int
;	O
}	O
struct	O
group	int
{	O
argp_parser_t	pointer
parser	pointer
;	O
const	O
struct	O
argp	struct
*	O
argp	struct
;	O
char	O
*	O
short_end	pointer
;	O
unsigned	O
args_processed	int
;	O
struct	O
group	int
*	O
parent	pointer
;	O
unsigned	O
parent_index	int
;	O
void	O
*	O
input	pointer
,	O
*	O
*	O
child_inputs	pointer
;	O
void	O
*	O
hook	pointer
;	O
}	O
;	O
static	O
error_t	int
group_parse	function
(	O
struct	O
group	int
*	O
group	int
,	O
struct	O
argp_state	struct
*	O
state	pointer
,	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
group	int
->	O
parser	pointer
)	O
{	O
error_t	int
err	int
;	O
state	pointer
->	O
hook	pointer
=	O
group	int
->	O
hook	pointer
;	O
state	pointer
->	O
input	pointer
=	O
group	int
->	O
input	pointer
;	O
state	pointer
->	O
child_inputs	pointer
=	O
group	int
->	O
child_inputs	pointer
;	O
state	pointer
->	O
arg_num	int
=	O
group	int
->	O
args_processed	int
;	O
err	int
=	O
(	O
*	O
group	int
->	O
parser	pointer
)	O
(	O
key	int
,	O
arg	pointer
,	O
state	pointer
)	O
;	O
group	int
->	O
hook	pointer
=	O
state	pointer
->	O
hook	pointer
;	O
return	O
err	int
;	O
}	O
else	O
return	O
EBADKEY	O
;	O
}	O
struct	O
parser	pointer
{	O
const	O
struct	O
argp	struct
*	O
argp	struct
;	O
char	O
*	O
short_opts	pointer
;	O
struct	O
option	struct
*	O
long_opts	pointer
;	O
struct	O
_getopt_data	struct
opt_data	struct
;	O
struct	O
group	int
*	O
groups	pointer
;	O
struct	O
group	int
*	O
egroup	pointer
;	O
void	O
*	O
*	O
child_inputs	pointer
;	O
int	O
try_getopt	int
;	O
struct	O
argp_state	struct
state	pointer
;	O
void	O
*	O
storage	pointer
;	O
}	O
;	O
struct	O
parser_convert_state	struct
{	O
struct	O
parser	pointer
*	O
parser	pointer
;	O
char	O
*	O
short_end	pointer
;	O
struct	O
option	struct
*	O
long_end	pointer
;	O
void	O
*	O
*	O
child_inputs_end	pointer
;	O
}	O
;	O
static	O
struct	O
group	int
*	O
convert_options	function
(	O
const	O
struct	O
argp	struct
*	O
argp	struct
,	O
struct	O
group	int
*	O
parent	pointer
,	O
unsigned	O
parent_index	int
,	O
struct	O
group	int
*	O
group	int
,	O
struct	O
parser_convert_state	struct
*	O
cvt	pointer
)	O
{	O
const	O
struct	O
argp_option	struct
*	O
real	pointer
=	O
argp	struct
->	O
options	pointer
;	O
const	O
struct	O
argp_child	struct
*	O
children	pointer
=	O
argp	struct
->	O
children	pointer
;	O
if	O
(	O
real	pointer
||	O
argp	struct
->	O
parser	pointer
)	O
{	O
const	O
struct	O
argp_option	struct
*	O
opt	pointer
;	O
if	O
(	O
real	pointer
)	O
for	O
(	O
opt	pointer
=	O
real	pointer
;	O
!	O
__option_is_end	O
(	O
opt	pointer
)	O
;	O
opt	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
opt	pointer
->	O
flags	int
&	O
OPTION_ALIAS	int
)	O
)	O
real	pointer
=	O
opt	pointer
;	O
if	O
(	O
!	O
(	O
real	pointer
->	O
flags	int
&	O
OPTION_DOC	int
)	O
)	O
{	O
if	O
(	O
__option_is_short	O
(	O
opt	pointer
)	O
)	O
{	O
*	O
cvt	pointer
->	O
short_end	pointer
++	O
=	O
opt	pointer
->	O
key	int
;	O
if	O
(	O
real	pointer
->	O
arg	pointer
)	O
{	O
*	O
cvt	pointer
->	O
short_end	pointer
++	O
=	O
':'	O
;	O
if	O
(	O
real	pointer
->	O
flags	int
&	O
OPTION_ARG_OPTIONAL	int
)	O
*	O
cvt	pointer
->	O
short_end	pointer
++	O
=	O
':'	O
;	O
}	O
*	O
cvt	pointer
->	O
short_end	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
opt	pointer
->	O
name	pointer
&&	O
find_long_option	function
(	O
cvt	pointer
->	O
parser	pointer
->	O
long_opts	pointer
,	O
opt	pointer
->	O
name	pointer
)	O
<	O
0	int
)	O
{	O
cvt	pointer
->	O
long_end	pointer
->	O
name	pointer
=	O
opt	pointer
->	O
name	pointer
;	O
cvt	pointer
->	O
long_end	pointer
->	O
has_arg	int
=	O
(	O
real	pointer
->	O
arg	pointer
?	O
(	O
real	pointer
->	O
flags	int
&	O
OPTION_ARG_OPTIONAL	int
?	O
optional_argument	int
:	O
required_argument	int
)	O
:	O
no_argument	int
)	O
;	O
cvt	pointer
->	O
long_end	pointer
->	O
flag	pointer
=	O
0	int
;	O
cvt	pointer
->	O
long_end	pointer
->	O
val	int
=	O
(	O
(	O
opt	pointer
->	O
key	int
|	O
real	pointer
->	O
key	int
)	O
&	O
USER_MASK	O
)	O
+	O
(	O
(	O
(	O
group	int
-	O
cvt	pointer
->	O
parser	pointer
->	O
groups	pointer
)	O
+	O
1	int
)	O
<<	O
USER_BITS	O
)	O
;	O
(	O
++	O
cvt	pointer
->	O
long_end	pointer
)	O
->	O
name	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
group	int
->	O
parser	pointer
=	O
argp	struct
->	O
parser	pointer
;	O
group	int
->	O
argp	struct
=	O
argp	struct
;	O
group	int
->	O
short_end	pointer
=	O
cvt	pointer
->	O
short_end	pointer
;	O
group	int
->	O
args_processed	int
=	O
0	int
;	O
group	int
->	O
parent	pointer
=	O
parent	pointer
;	O
group	int
->	O
parent_index	int
=	O
parent_index	int
;	O
group	int
->	O
input	pointer
=	O
0	int
;	O
group	int
->	O
hook	pointer
=	O
0	int
;	O
group	int
->	O
child_inputs	pointer
=	O
0	int
;	O
if	O
(	O
children	pointer
)	O
{	O
unsigned	O
num_children	int
=	O
0	int
;	O
while	O
(	O
children	pointer
[	O
num_children	int
]	O
.	O
argp	struct
)	O
num_children	int
++	O
;	O
group	int
->	O
child_inputs	pointer
=	O
cvt	pointer
->	O
child_inputs_end	pointer
;	O
cvt	pointer
->	O
child_inputs_end	pointer
+=	O
num_children	int
;	O
}	O
parent	pointer
=	O
group	int
++	O
;	O
}	O
else	O
parent	pointer
=	O
0	int
;	O
if	O
(	O
children	pointer
)	O
{	O
unsigned	O
index	function
=	O
0	int
;	O
while	O
(	O
children	pointer
->	O
argp	struct
)	O
group	int
=	O
convert_options	function
(	O
children	pointer
++	O
->	O
argp	struct
,	O
parent	pointer
,	O
index	function
++	O
,	O
group	int
,	O
cvt	pointer
)	O
;	O
}	O
return	O
group	int
;	O
}	O
static	O
void	O
parser_convert	function
(	O
struct	O
parser	pointer
*	O
parser	pointer
,	O
const	O
struct	O
argp	struct
*	O
argp	struct
,	O
int	O
flags	int
)	O
{	O
struct	O
parser_convert_state	struct
cvt	pointer
;	O
cvt	pointer
.	O
parser	pointer
=	O
parser	pointer
;	O
cvt	pointer
.	O
short_end	pointer
=	O
parser	pointer
->	O
short_opts	pointer
;	O
cvt	pointer
.	O
long_end	pointer
=	O
parser	pointer
->	O
long_opts	pointer
;	O
cvt	pointer
.	O
child_inputs_end	pointer
=	O
parser	pointer
->	O
child_inputs	pointer
;	O
if	O
(	O
flags	int
&	O
ARGP_IN_ORDER	int
)	O
*	O
cvt	pointer
.	O
short_end	pointer
++	O
=	O
'-'	O
;	O
else	O
if	O
(	O
flags	int
&	O
ARGP_NO_ARGS	int
)	O
*	O
cvt	pointer
.	O
short_end	pointer
++	O
=	O
'+'	O
;	O
*	O
cvt	pointer
.	O
short_end	pointer
=	O
'\0'	O
;	O
cvt	pointer
.	O
long_end	pointer
->	O
name	pointer
=	O
NULL	O
;	O
parser	pointer
->	O
argp	struct
=	O
argp	struct
;	O
if	O
(	O
argp	struct
)	O
parser	pointer
->	O
egroup	pointer
=	O
convert_options	function
(	O
argp	struct
,	O
0	int
,	O
0	int
,	O
parser	pointer
->	O
groups	pointer
,	O
&	O
cvt	pointer
)	O
;	O
else	O
parser	pointer
->	O
egroup	pointer
=	O
parser	pointer
->	O
groups	pointer
;	O
}	O
struct	O
parser_sizes	struct
{	O
size_t	long
short_len	long
;	O
size_t	long
long_len	long
;	O
size_t	long
num_groups	long
;	O
size_t	long
num_child_inputs	long
;	O
}	O
;	O
static	O
void	O
calc_sizes	function
(	O
const	O
struct	O
argp	struct
*	O
argp	struct
,	O
struct	O
parser_sizes	struct
*	O
szs	pointer
)	O
{	O
const	O
struct	O
argp_child	struct
*	O
child	pointer
=	O
argp	struct
->	O
children	pointer
;	O
const	O
struct	O
argp_option	struct
*	O
opt	pointer
=	O
argp	struct
->	O
options	pointer
;	O
if	O
(	O
opt	pointer
||	O
argp	struct
->	O
parser	pointer
)	O
{	O
szs	pointer
->	O
num_groups	long
++	O
;	O
if	O
(	O
opt	pointer
)	O
{	O
int	O
num_opts	int
=	O
0	int
;	O
while	O
(	O
!	O
__option_is_end	O
(	O
opt	pointer
++	O
)	O
)	O
num_opts	int
++	O
;	O
szs	pointer
->	O
short_len	long
+=	O
num_opts	int
*	O
3	int
;	O
szs	pointer
->	O
long_len	long
+=	O
num_opts	int
;	O
}	O
}	O
if	O
(	O
child	pointer
)	O
while	O
(	O
child	pointer
->	O
argp	struct
)	O
{	O
calc_sizes	function
(	O
(	O
child	pointer
++	O
)	O
->	O
argp	struct
,	O
szs	pointer
)	O
;	O
szs	pointer
->	O
num_child_inputs	long
++	O
;	O
}	O
}	O
static	O
error_t	int
parser_init	function
(	O
struct	O
parser	pointer
*	O
parser	pointer
,	O
const	O
struct	O
argp	struct
*	O
argp	struct
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
flags	int
,	O
void	O
*	O
input	pointer
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
struct	O
group	int
*	O
group	int
;	O
struct	O
parser_sizes	struct
szs	pointer
;	O
struct	O
_getopt_data	struct
opt_data	struct
=	O
_GETOPT_DATA_INITIALIZER	O
;	O
char	O
*	O
storage	pointer
;	O
size_t	long
glen	long
,	O
gsum	long
;	O
size_t	long
clen	long
,	O
csum	long
;	O
size_t	long
llen	long
,	O
lsum	long
;	O
size_t	long
slen	long
,	O
ssum	long
;	O
szs	pointer
.	O
short_len	long
=	O
(	O
flags	int
&	O
ARGP_NO_ARGS	int
)	O
?	O
0	int
:	O
1	int
;	O
szs	pointer
.	O
long_len	long
=	O
0	int
;	O
szs	pointer
.	O
num_groups	long
=	O
0	int
;	O
szs	pointer
.	O
num_child_inputs	long
=	O
0	int
;	O
if	O
(	O
argp	struct
)	O
calc_sizes	function
(	O
argp	struct
,	O
&	O
szs	pointer
)	O
;	O
glen	long
=	O
(	O
szs	pointer
.	O
num_groups	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
group	int
)	O
;	O
clen	long
=	O
szs	pointer
.	O
num_child_inputs	long
*	O
sizeof	O
(	O
void	O
*	O
)	O
;	O
llen	long
=	O
(	O
szs	pointer
.	O
long_len	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
option	struct
)	O
;	O
slen	long
=	O
szs	pointer
.	O
short_len	long
+	O
1	int
;	O
gsum	long
=	O
glen	long
;	O
csum	long
=	O
alignto	O
(	O
gsum	long
+	O
clen	long
,	O
alignof	O
(	O
struct	O
option	struct
)	O
)	O
;	O
lsum	long
=	O
csum	long
+	O
llen	long
;	O
ssum	long
=	O
lsum	long
+	O
slen	long
;	O
parser	pointer
->	O
storage	pointer
=	O
malloc	function
(	O
ssum	long
)	O
;	O
if	O
(	O
!	O
parser	pointer
->	O
storage	pointer
)	O
return	O
ENOMEM	int
;	O
storage	pointer
=	O
parser	pointer
->	O
storage	pointer
;	O
parser	pointer
->	O
groups	pointer
=	O
parser	pointer
->	O
storage	pointer
;	O
parser	pointer
->	O
child_inputs	pointer
=	O
(	O
void	O
*	O
*	O
)	O
(	O
storage	pointer
+	O
gsum	long
)	O
;	O
parser	pointer
->	O
long_opts	pointer
=	O
(	O
struct	O
option	struct
*	O
)	O
(	O
storage	pointer
+	O
csum	long
)	O
;	O
parser	pointer
->	O
short_opts	pointer
=	O
storage	pointer
+	O
lsum	long
;	O
parser	pointer
->	O
opt_data	struct
=	O
opt_data	struct
;	O
memset	function
(	O
parser	pointer
->	O
child_inputs	pointer
,	O
0	int
,	O
clen	long
)	O
;	O
parser_convert	function
(	O
parser	pointer
,	O
argp	struct
,	O
flags	int
)	O
;	O
memset	function
(	O
&	O
parser	pointer
->	O
state	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
argp_state	struct
)	O
)	O
;	O
parser	pointer
->	O
state	pointer
.	O
root_argp	pointer
=	O
parser	pointer
->	O
argp	struct
;	O
parser	pointer
->	O
state	pointer
.	O
argc	int
=	O
argc	int
;	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
=	O
argv	pointer
;	O
parser	pointer
->	O
state	pointer
.	O
flags	int
=	O
flags	int
;	O
parser	pointer
->	O
state	pointer
.	O
err_stream	pointer
=	O
stderr	pointer
;	O
parser	pointer
->	O
state	pointer
.	O
out_stream	pointer
=	O
stdout	pointer
;	O
parser	pointer
->	O
state	pointer
.	O
next	int
=	O
0	int
;	O
parser	pointer
->	O
state	pointer
.	O
pstate	pointer
=	O
parser	pointer
;	O
parser	pointer
->	O
try_getopt	int
=	O
1	int
;	O
if	O
(	O
parser	pointer
->	O
groups	pointer
<	O
parser	pointer
->	O
egroup	pointer
)	O
parser	pointer
->	O
groups	pointer
->	O
input	pointer
=	O
input	pointer
;	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
<	O
parser	pointer
->	O
egroup	pointer
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
++	O
)	O
{	O
if	O
(	O
group	int
->	O
parent	pointer
)	O
group	int
->	O
input	pointer
=	O
group	int
->	O
parent	pointer
->	O
child_inputs	pointer
[	O
group	int
->	O
parent_index	int
]	O
;	O
if	O
(	O
!	O
group	int
->	O
parser	pointer
&&	O
group	int
->	O
argp	struct
->	O
children	pointer
&&	O
group	int
->	O
argp	struct
->	O
children	pointer
->	O
argp	struct
)	O
group	int
->	O
child_inputs	pointer
[	O
0	int
]	O
=	O
group	int
->	O
input	pointer
;	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
ARGP_KEY_INIT	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
0	int
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
flags	int
&	O
ARGP_NO_ERRS	int
)	O
{	O
parser	pointer
->	O
opt_data	struct
.	O
opterr	int
=	O
0	int
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
flags	int
&	O
ARGP_PARSE_ARGV0	int
)	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
--	O
,	O
parser	pointer
->	O
state	pointer
.	O
argc	int
++	O
;	O
}	O
else	O
parser	pointer
->	O
opt_data	struct
.	O
opterr	int
=	O
1	int
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
==	O
argv	pointer
&&	O
argv	pointer
[	O
0	int
]	O
)	O
parser	pointer
->	O
state	pointer
.	O
name	pointer
=	O
__argp_base_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
else	O
parser	pointer
->	O
state	pointer
.	O
name	pointer
=	O
__argp_short_program_name	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
parser_finalize	function
(	O
struct	O
parser	pointer
*	O
parser	pointer
,	O
error_t	int
err	int
,	O
int	O
arg_ebadkey	int
,	O
int	O
*	O
end_index	pointer
)	O
{	O
struct	O
group	int
*	O
group	int
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
&&	O
arg_ebadkey	int
)	O
err	int
=	O
0	int
;	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
next	int
==	O
parser	pointer
->	O
state	pointer
.	O
argc	int
)	O
{	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
<	O
parser	pointer
->	O
egroup	pointer
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
++	O
)	O
if	O
(	O
group	int
->	O
args_processed	int
==	O
0	int
)	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
ARGP_KEY_NO_ARGS	int
,	O
0	int
)	O
;	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
egroup	pointer
-	O
1	int
;	O
group	int
>=	O
parser	pointer
->	O
groups	pointer
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
--	O
)	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
ARGP_KEY_END	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
0	int
;	O
if	O
(	O
end_index	pointer
)	O
*	O
end_index	pointer
=	O
parser	pointer
->	O
state	pointer
.	O
next	int
;	O
}	O
else	O
if	O
(	O
end_index	pointer
)	O
*	O
end_index	pointer
=	O
parser	pointer
->	O
state	pointer
.	O
next	int
;	O
else	O
{	O
if	O
(	O
!	O
(	O
parser	pointer
->	O
state	pointer
.	O
flags	int
&	O
ARGP_NO_ERRS	int
)	O
&&	O
parser	pointer
->	O
state	pointer
.	O
err_stream	pointer
)	O
fprintf	function
(	O
parser	pointer
->	O
state	pointer
.	O
err_stream	pointer
,	O
dgettext	function
(	O
parser	pointer
->	O
argp	struct
->	O
argp_domain	pointer
,	O
"%s: Too many arguments\n"	pointer
)	O
,	O
parser	pointer
->	O
state	pointer
.	O
name	pointer
)	O
;	O
err	int
=	O
EBADKEY	O
;	O
}	O
}	O
if	O
(	O
err	int
)	O
{	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
__argp_state_help	function
(	O
&	O
parser	pointer
->	O
state	pointer
,	O
parser	pointer
->	O
state	pointer
.	O
err_stream	pointer
,	O
ARGP_HELP_STD_ERR	O
)	O
;	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
<	O
parser	pointer
->	O
egroup	pointer
;	O
group	int
++	O
)	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
ARGP_KEY_ERROR	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
egroup	pointer
-	O
1	int
;	O
group	int
>=	O
parser	pointer
->	O
groups	pointer
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
--	O
)	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
ARGP_KEY_SUCCESS	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
0	int
;	O
}	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
egroup	pointer
-	O
1	int
;	O
group	int
>=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
--	O
)	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
ARGP_KEY_FINI	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
EINVAL	int
;	O
free	function
(	O
parser	pointer
->	O
storage	pointer
)	O
;	O
return	O
err	int
;	O
}	O
static	O
error_t	int
parser_parse_arg	function
(	O
struct	O
parser	pointer
*	O
parser	pointer
,	O
char	O
*	O
val	int
)	O
{	O
int	O
index	function
=	O
--	O
parser	pointer
->	O
state	pointer
.	O
next	int
;	O
error_t	int
err	int
=	O
EBADKEY	O
;	O
struct	O
group	int
*	O
group	int
;	O
int	O
key	int
=	O
0	int
;	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
<	O
parser	pointer
->	O
egroup	pointer
&&	O
err	int
==	O
EBADKEY	O
;	O
group	int
++	O
)	O
{	O
parser	pointer
->	O
state	pointer
.	O
next	int
++	O
;	O
key	int
=	O
ARGP_KEY_ARG	int
;	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
key	int
,	O
val	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
{	O
parser	pointer
->	O
state	pointer
.	O
next	int
--	O
;	O
key	int
=	O
ARGP_KEY_ARGS	int
;	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
key	int
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
key	int
==	O
ARGP_KEY_ARGS	int
)	O
parser	pointer
->	O
state	pointer
.	O
next	int
=	O
parser	pointer
->	O
state	pointer
.	O
argc	int
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
next	int
>	O
index	function
)	O
(	O
--	O
group	int
)	O
->	O
args_processed	int
+=	O
(	O
parser	pointer
->	O
state	pointer
.	O
next	int
-	O
index	function
)	O
;	O
else	O
parser	pointer
->	O
try_getopt	int
=	O
1	int
;	O
}	O
return	O
err	int
;	O
}	O
static	O
error_t	int
parser_parse_opt	function
(	O
struct	O
parser	pointer
*	O
parser	pointer
,	O
int	O
opt	pointer
,	O
char	O
*	O
val	int
)	O
{	O
int	O
group_key	int
=	O
opt	pointer
>>	O
USER_BITS	O
;	O
error_t	int
err	int
=	O
EBADKEY	O
;	O
if	O
(	O
group_key	int
==	O
0	int
)	O
{	O
struct	O
group	int
*	O
group	int
;	O
char	O
*	O
short_index	pointer
=	O
strchr	function
(	O
parser	pointer
->	O
short_opts	pointer
,	O
opt	pointer
)	O
;	O
if	O
(	O
short_index	pointer
)	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
<	O
parser	pointer
->	O
egroup	pointer
;	O
group	int
++	O
)	O
if	O
(	O
group	int
->	O
short_end	pointer
>	O
short_index	pointer
)	O
{	O
err	int
=	O
group_parse	function
(	O
group	int
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
opt	pointer
,	O
parser	pointer
->	O
opt_data	struct
.	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
err	int
=	O
group_parse	function
(	O
&	O
parser	pointer
->	O
groups	pointer
[	O
group_key	int
-	O
1	int
]	O
,	O
&	O
parser	pointer
->	O
state	pointer
,	O
(	O
opt	pointer
<<	O
GROUP_BITS	O
)	O
>>	O
GROUP_BITS	O
,	O
parser	pointer
->	O
opt_data	struct
.	O
optarg	pointer
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
{	O
static	O
const	O
char	O
bad_key_err	array
[	O
]	O
=	O
N_	O
(	O
"(PROGRAM ERROR) Option should have been recognized!?"	pointer
)	O
;	O
if	O
(	O
group_key	int
==	O
0	int
)	O
__argp_error	function
(	O
&	O
parser	pointer
->	O
state	pointer
,	O
"-%c: %s"	pointer
,	O
opt	pointer
,	O
dgettext	function
(	O
parser	pointer
->	O
argp	struct
->	O
argp_domain	pointer
,	O
bad_key_err	array
)	O
)	O
;	O
else	O
{	O
struct	O
option	struct
*	O
long_opt	pointer
=	O
parser	pointer
->	O
long_opts	pointer
;	O
while	O
(	O
long_opt	pointer
->	O
val	int
!=	O
opt	pointer
&&	O
long_opt	pointer
->	O
name	pointer
)	O
long_opt	pointer
++	O
;	O
__argp_error	function
(	O
&	O
parser	pointer
->	O
state	pointer
,	O
"--%s: %s"	pointer
,	O
long_opt	pointer
->	O
name	pointer
?	O
long_opt	pointer
->	O
name	pointer
:	O
"???"	pointer
,	O
dgettext	function
(	O
parser	pointer
->	O
argp	struct
->	O
argp_domain	pointer
,	O
bad_key_err	array
)	O
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
static	O
error_t	int
parser_parse_next	function
(	O
struct	O
parser	pointer
*	O
parser	pointer
,	O
int	O
*	O
arg_ebadkey	int
)	O
{	O
int	O
opt	pointer
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
quoted	int
&&	O
parser	pointer
->	O
state	pointer
.	O
next	int
<	O
parser	pointer
->	O
state	pointer
.	O
quoted	int
)	O
parser	pointer
->	O
state	pointer
.	O
quoted	int
=	O
0	int
;	O
if	O
(	O
parser	pointer
->	O
try_getopt	int
&&	O
!	O
parser	pointer
->	O
state	pointer
.	O
quoted	int
)	O
{	O
parser	pointer
->	O
opt_data	struct
.	O
optind	int
=	O
parser	pointer
->	O
state	pointer
.	O
next	int
;	O
parser	pointer
->	O
opt_data	struct
.	O
optopt	int
=	O
KEY_END	O
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
flags	int
&	O
ARGP_LONG_ONLY	int
)	O
opt	pointer
=	O
_getopt_long_only_r	function
(	O
parser	pointer
->	O
state	pointer
.	O
argc	int
,	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
,	O
parser	pointer
->	O
short_opts	pointer
,	O
parser	pointer
->	O
long_opts	pointer
,	O
0	int
,	O
&	O
parser	pointer
->	O
opt_data	struct
)	O
;	O
else	O
opt	pointer
=	O
_getopt_long_r	function
(	O
parser	pointer
->	O
state	pointer
.	O
argc	int
,	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
,	O
parser	pointer
->	O
short_opts	pointer
,	O
parser	pointer
->	O
long_opts	pointer
,	O
0	int
,	O
&	O
parser	pointer
->	O
opt_data	struct
)	O
;	O
parser	pointer
->	O
state	pointer
.	O
next	int
=	O
parser	pointer
->	O
opt_data	struct
.	O
optind	int
;	O
if	O
(	O
opt	pointer
==	O
KEY_END	O
)	O
{	O
parser	pointer
->	O
try_getopt	int
=	O
0	int
;	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
next	int
>	O
1	int
&&	O
strcmp	function
(	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
[	O
parser	pointer
->	O
state	pointer
.	O
next	int
-	O
1	int
]	O
,	O
QUOTE	pointer
)	O
==	O
0	int
)	O
parser	pointer
->	O
state	pointer
.	O
quoted	int
=	O
parser	pointer
->	O
state	pointer
.	O
next	int
;	O
}	O
else	O
if	O
(	O
opt	pointer
==	O
KEY_ERR	char
&&	O
parser	pointer
->	O
opt_data	struct
.	O
optopt	int
!=	O
KEY_END	O
)	O
{	O
*	O
arg_ebadkey	int
=	O
0	int
;	O
return	O
EBADKEY	O
;	O
}	O
}	O
else	O
opt	pointer
=	O
KEY_END	O
;	O
if	O
(	O
opt	pointer
==	O
KEY_END	O
)	O
{	O
if	O
(	O
parser	pointer
->	O
state	pointer
.	O
next	int
>=	O
parser	pointer
->	O
state	pointer
.	O
argc	int
||	O
(	O
parser	pointer
->	O
state	pointer
.	O
flags	int
&	O
ARGP_NO_ARGS	int
)	O
)	O
{	O
*	O
arg_ebadkey	int
=	O
1	int
;	O
return	O
EBADKEY	O
;	O
}	O
else	O
{	O
opt	pointer
=	O
KEY_ARG	int
;	O
parser	pointer
->	O
opt_data	struct
.	O
optarg	pointer
=	O
parser	pointer
->	O
state	pointer
.	O
argv	pointer
[	O
parser	pointer
->	O
state	pointer
.	O
next	int
++	O
]	O
;	O
}	O
}	O
if	O
(	O
opt	pointer
==	O
KEY_ARG	int
)	O
err	int
=	O
parser_parse_arg	function
(	O
parser	pointer
,	O
parser	pointer
->	O
opt_data	struct
.	O
optarg	pointer
)	O
;	O
else	O
err	int
=	O
parser_parse_opt	function
(	O
parser	pointer
,	O
opt	pointer
,	O
parser	pointer
->	O
opt_data	struct
.	O
optarg	pointer
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
*	O
arg_ebadkey	int
=	O
(	O
opt	pointer
==	O
KEY_END	O
||	O
opt	pointer
==	O
KEY_ARG	int
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
__argp_parse	function
(	O
const	O
struct	O
argp	struct
*	O
argp	struct
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
unsigned	O
flags	int
,	O
int	O
*	O
end_index	pointer
,	O
void	O
*	O
input	pointer
)	O
{	O
error_t	int
err	int
;	O
struct	O
parser	pointer
parser	pointer
;	O
int	O
arg_ebadkey	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
ARGP_PARSE_ARGV0	int
)	O
)	O
{	O
if	O
(	O
!	O
program_invocation_name	pointer
)	O
program_invocation_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
if	O
(	O
!	O
program_invocation_short_name	pointer
)	O
program_invocation_short_name	pointer
=	O
__argp_base_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
ARGP_NO_HELP	int
)	O
)	O
{	O
struct	O
argp_child	struct
*	O
child	pointer
=	O
alloca	O
(	O
4	int
*	O
sizeof	O
(	O
struct	O
argp_child	struct
)	O
)	O
;	O
struct	O
argp	struct
*	O
top_argp	pointer
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
argp	struct
)	O
)	O
;	O
memset	function
(	O
top_argp	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
top_argp	pointer
)	O
)	O
;	O
top_argp	pointer
->	O
children	pointer
=	O
child	pointer
;	O
memset	function
(	O
child	pointer
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
struct	O
argp_child	struct
)	O
)	O
;	O
if	O
(	O
argp	struct
)	O
(	O
child	pointer
++	O
)	O
->	O
argp	struct
=	O
argp	struct
;	O
(	O
child	pointer
++	O
)	O
->	O
argp	struct
=	O
&	O
argp_default_argp	struct
;	O
if	O
(	O
argp_program_version	pointer
||	O
argp_program_version_hook	pointer
)	O
(	O
child	pointer
++	O
)	O
->	O
argp	struct
=	O
&	O
argp_version_argp	struct
;	O
child	pointer
->	O
argp	struct
=	O
0	int
;	O
argp	struct
=	O
top_argp	pointer
;	O
}	O
err	int
=	O
parser_init	function
(	O
&	O
parser	pointer
,	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
flags	int
,	O
input	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
while	O
(	O
!	O
err	int
)	O
err	int
=	O
parser_parse_next	function
(	O
&	O
parser	pointer
,	O
&	O
arg_ebadkey	int
)	O
;	O
err	int
=	O
parser_finalize	function
(	O
&	O
parser	pointer
,	O
err	int
,	O
arg_ebadkey	int
,	O
end_index	pointer
)	O
;	O
}	O
return	O
err	int
;	O
}	O
void	O
*	O
__argp_input	function
(	O
const	O
struct	O
argp	struct
*	O
argp	struct
,	O
const	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
if	O
(	O
state	pointer
)	O
{	O
struct	O
group	int
*	O
group	int
;	O
struct	O
parser	pointer
*	O
parser	pointer
=	O
state	pointer
->	O
pstate	pointer
;	O
for	O
(	O
group	int
=	O
parser	pointer
->	O
groups	pointer
;	O
group	int
<	O
parser	pointer
->	O
egroup	pointer
;	O
group	int
++	O
)	O
if	O
(	O
group	int
->	O
argp	struct
==	O
argp	struct
)	O
return	O
group	int
->	O
input	pointer
;	O
}	O
return	O
0	int
;	O
}	O
