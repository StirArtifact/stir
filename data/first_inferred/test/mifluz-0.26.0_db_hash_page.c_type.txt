static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: hash_page.c,v 1.5 2014/04/17 20:27:29 sebdiaz Exp $"	pointer
;	O
int	O
CDB___ham_item	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_pgno_t	int
next_pgno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Attempt to return a deleted item"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
|	O
H_NOMORE	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
mode	enum
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
recheck	O
:	O
if	O
(	O
hcp	pointer
->	O
seek_size	int
&&	O
hcp	pointer
->	O
seek_found_page	int
==	O
PGNO_INVALID	int
&&	O
hcp	pointer
->	O
seek_size	int
<	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
hcp	pointer
->	O
seek_found_page	int
=	O
hcp	pointer
->	O
pgno	int
;	O
if	O
(	O
hcp	pointer
->	O
indx	short
<	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
&&	O
HPAGE_TYPE	O
(	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
==	O
H_OFFDUP	int
)	O
{	O
memcpy	function
(	O
pgnop	pointer
,	O
HOFFDUP_PGNO	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
)	O
memcpy	function
(	O
&	O
hcp	pointer
->	O
dup_len	short
,	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
+	O
hcp	pointer
->	O
dup_off	short
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
if	O
(	O
hcp	pointer
->	O
indx	short
>=	O
(	O
db_indx_t	short
)	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
{	O
if	O
(	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
==	O
PGNO_INVALID	int
)	O
{	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
}	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
hcp	pointer
->	O
indx	short
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_next_cpage	function
(	O
dbc	pointer
,	O
next_pgno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
goto	O
recheck	O
;	O
}	O
F_SET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_item_reset	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int	O
ret	int
;	O
ret	int
=	O
0	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
hcp	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
CDB___ham_item_init	function
(	O
dbc	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___ham_item_init	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
hcp	pointer
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
&&	O
dbc	pointer
->	O
txn	pointer
==	O
NULL	O
)	O
(	O
void	O
)	O
CDB_lock_put	function
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
hcp	pointer
->	O
lock	struct
)	O
;	O
hcp	pointer
->	O
bucket	int
=	O
BUCKET_INVALID	int
;	O
hcp	pointer
->	O
lbucket	int
=	O
BUCKET_INVALID	int
;	O
hcp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
hcp	pointer
->	O
lock_mode	enum
=	O
DB_LOCK_NG	int
;	O
hcp	pointer
->	O
dup_off	short
=	O
0	int
;	O
hcp	pointer
->	O
dup_len	short
=	O
0	int
;	O
hcp	pointer
->	O
dup_tlen	short
=	O
0	int
;	O
hcp	pointer
->	O
seek_size	int
=	O
0	int
;	O
hcp	pointer
->	O
seek_found_page	int
=	O
PGNO_INVALID	int
;	O
hcp	pointer
->	O
flags	int
=	O
0	int
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO_INVALID	int
;	O
hcp	pointer
->	O
indx	short
=	O
NDX_INVALID	int
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
}	O
int	O
CDB___ham_item_last	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
int	O
ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_item_reset	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
bucket	int
=	O
hcp	pointer
->	O
hdr	pointer
->	O
max_bucket	int
;	O
hcp	pointer
->	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
return	O
(	O
CDB___ham_item_prev	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
)	O
;	O
}	O
int	O
CDB___ham_item_first	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
int	O
ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_item_reset	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
hcp	pointer
->	O
bucket	int
=	O
0	int
;	O
hcp	pointer
->	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
return	O
(	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
)	O
;	O
}	O
int	O
CDB___ham_item_prev	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_pgno_t	int
next_pgno	int
;	O
int	O
ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
|	O
H_NOMORE	int
|	O
H_DELETED	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
mode	enum
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_NEXT_NODUP	int
)	O
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
)	O
{	O
if	O
(	O
HPAGE_TYPE	O
(	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
==	O
H_OFFDUP	int
)	O
{	O
memcpy	function
(	O
pgnop	pointer
,	O
HOFFDUP_PGNO	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
hcp	pointer
->	O
dup_off	short
!=	O
0	int
)	O
{	O
memcpy	function
(	O
&	O
hcp	pointer
->	O
dup_len	short
,	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
+	O
hcp	pointer
->	O
dup_off	short
-	O
sizeof	O
(	O
db_indx_t	short
)	O
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
hcp	pointer
->	O
dup_off	short
-=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
return	O
(	O
CDB___ham_item	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
if	O
(	O
hcp	pointer
->	O
indx	short
==	O
0	int
)	O
{	O
hcp	pointer
->	O
pgno	int
=	O
PREV_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
hcp	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_next_cpage	function
(	O
dbc	pointer
,	O
hcp	pointer
->	O
pgno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
else	O
hcp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
}	O
if	O
(	O
hcp	pointer
->	O
indx	short
==	O
NDX_INVALID	int
)	O
{	O
DB_ASSERT	O
(	O
hcp	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
;	O
hcp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
next_pgno	int
!=	O
PGNO_INVALID	int
;	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_next_cpage	function
(	O
dbc	pointer
,	O
next_pgno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
}	O
if	O
(	O
hcp	pointer
->	O
indx	short
==	O
0	int
)	O
{	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
}	O
}	O
hcp	pointer
->	O
indx	short
-=	O
2	int
;	O
return	O
(	O
CDB___ham_item	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
)	O
;	O
}	O
int	O
CDB___ham_item_next	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
int	O
ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
mode	enum
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
)	O
{	O
if	O
(	O
hcp	pointer
->	O
indx	short
!=	O
NDX_INVALID	int
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
&&	O
HPAGE_TYPE	O
(	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
==	O
H_DUPLICATE	int
&&	O
hcp	pointer
->	O
dup_tlen	short
==	O
hcp	pointer
->	O
dup_off	short
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
indx	short
+=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_NEXT_NODUP	int
)	O
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
indx	short
+=	O
2	int
;	O
}	O
F_CLR	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
;	O
}	O
else	O
if	O
(	O
hcp	pointer
->	O
indx	short
==	O
NDX_INVALID	int
)	O
{	O
hcp	pointer
->	O
indx	short
=	O
0	int
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_NEXT_NODUP	int
)	O
)	O
{	O
hcp	pointer
->	O
indx	short
+=	O
2	int
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
&&	O
hcp	pointer
->	O
dup_tlen	short
!=	O
0	int
)	O
{	O
if	O
(	O
hcp	pointer
->	O
dup_off	short
+	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
>=	O
hcp	pointer
->	O
dup_tlen	short
&&	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
hcp	pointer
->	O
dup_off	short
+=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
if	O
(	O
hcp	pointer
->	O
dup_off	short
>=	O
hcp	pointer
->	O
dup_tlen	short
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
indx	short
+=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DUPONLY	int
)	O
)	O
{	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_NOMORE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
hcp	pointer
->	O
indx	short
+=	O
2	int
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
}	O
return	O
(	O
CDB___ham_item	function
(	O
dbc	pointer
,	O
mode	enum
,	O
pgnop	pointer
)	O
)	O
;	O
}	O
void	O
CDB___ham_putitem	function
(	O
p	pointer
,	O
dbt	struct
,	O
type	enum
)	O
PAGE	struct
*	O
p	pointer
;	O
const	O
DBT	struct
*	O
dbt	struct
;	O
int	O
type	enum
;	O
{	O
u_int16_t	short
n	short
,	O
off	long
;	O
n	short
=	O
NUM_ENT	O
(	O
p	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
H_OFFPAGE	int
)	O
{	O
off	long
=	O
HOFFSET	O
(	O
p	pointer
)	O
-	O
dbt	struct
->	O
size	int
;	O
HOFFSET	O
(	O
p	pointer
)	O
=	O
p	pointer
->	O
inp	array
[	O
n	short
]	O
=	O
off	long
;	O
memcpy	function
(	O
P_ENTRY	O
(	O
p	pointer
,	O
n	short
)	O
,	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
;	O
}	O
else	O
{	O
off	long
=	O
HOFFSET	O
(	O
p	pointer
)	O
-	O
HKEYDATA_SIZE	O
(	O
dbt	struct
->	O
size	int
)	O
;	O
HOFFSET	O
(	O
p	pointer
)	O
=	O
p	pointer
->	O
inp	array
[	O
n	short
]	O
=	O
off	long
;	O
PUT_HKEYDATA	O
(	O
P_ENTRY	O
(	O
p	pointer
,	O
n	short
)	O
,	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
,	O
type	enum
)	O
;	O
}	O
NUM_ENT	O
(	O
p	pointer
)	O
+=	O
1	int
;	O
}	O
void	O
CDB___ham_reputpair	function
(	O
p	pointer
,	O
psize	int
,	O
ndx	int
,	O
key	struct
,	O
data	pointer
)	O
PAGE	struct
*	O
p	pointer
;	O
u_int32_t	int
psize	int
,	O
ndx	int
;	O
const	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
{	O
db_indx_t	short
i	short
,	O
movebytes	short
,	O
newbytes	short
;	O
u_int8_t	char
*	O
from	pointer
;	O
movebytes	short
=	O
(	O
ndx	int
==	O
0	int
?	O
psize	int
:	O
p	pointer
->	O
inp	array
[	O
H_DATAINDEX	O
(	O
ndx	int
-	O
2	int
)	O
]	O
)	O
-	O
HOFFSET	O
(	O
p	pointer
)	O
;	O
newbytes	short
=	O
key	struct
->	O
size	int
+	O
data	pointer
->	O
size	int
;	O
from	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
p	pointer
+	O
HOFFSET	O
(	O
p	pointer
)	O
;	O
memmove	function
(	O
from	pointer
-	O
newbytes	short
,	O
from	pointer
,	O
movebytes	short
)	O
;	O
for	O
(	O
i	short
=	O
NUM_ENT	O
(	O
p	pointer
)	O
-	O
1	int
;	O
;	O
i	short
--	O
)	O
{	O
p	pointer
->	O
inp	array
[	O
i	short
+	O
2	int
]	O
=	O
p	pointer
->	O
inp	array
[	O
i	short
]	O
-	O
newbytes	short
;	O
if	O
(	O
i	short
==	O
H_KEYINDEX	O
(	O
ndx	int
)	O
)	O
break	O
;	O
}	O
p	pointer
->	O
inp	array
[	O
H_KEYINDEX	O
(	O
ndx	int
)	O
]	O
=	O
(	O
ndx	int
==	O
0	int
?	O
psize	int
:	O
p	pointer
->	O
inp	array
[	O
H_DATAINDEX	O
(	O
ndx	int
-	O
2	int
)	O
]	O
)	O
-	O
key	struct
->	O
size	int
;	O
p	pointer
->	O
inp	array
[	O
H_DATAINDEX	O
(	O
ndx	int
)	O
]	O
=	O
p	pointer
->	O
inp	array
[	O
H_KEYINDEX	O
(	O
ndx	int
)	O
]	O
-	O
data	pointer
->	O
size	int
;	O
memcpy	function
(	O
P_ENTRY	O
(	O
p	pointer
,	O
H_KEYINDEX	O
(	O
ndx	int
)	O
)	O
,	O
key	struct
->	O
data	pointer
,	O
key	struct
->	O
size	int
)	O
;	O
memcpy	function
(	O
P_ENTRY	O
(	O
p	pointer
,	O
H_DATAINDEX	O
(	O
ndx	int
)	O
)	O
,	O
data	pointer
->	O
data	pointer
,	O
data	pointer
->	O
size	int
)	O
;	O
HOFFSET	O
(	O
p	pointer
)	O
-=	O
newbytes	short
;	O
NUM_ENT	O
(	O
p	pointer
)	O
+=	O
2	int
;	O
}	O
int	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
reclaim_page	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
reclaim_page	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DBT	struct
data_dbt	struct
,	O
key_dbt	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
new_lsn	struct
,	O
*	O
n_lsn	pointer
,	O
tmp_lsn	struct
;	O
PAGE	struct
*	O
p	pointer
;	O
db_indx_t	short
ndx	int
;	O
db_pgno_t	int
chg_pgno	int
,	O
pgno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
ndx	int
=	O
hcp	pointer
->	O
indx	short
;	O
if	O
(	O
hcp	pointer
->	O
page	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
pgno	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
hcp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
p	pointer
=	O
hcp	pointer
->	O
page	pointer
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
H_PAIRKEY	O
(	O
p	pointer
,	O
ndx	int
)	O
)	O
==	O
H_OFFPAGE	int
)	O
{	O
memcpy	function
(	O
&	O
pgno	int
,	O
HOFFPAGE_PGNO	O
(	O
P_ENTRY	O
(	O
p	pointer
,	O
H_KEYINDEX	O
(	O
ndx	int
)	O
)	O
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
ret	int
=	O
CDB___db_doff	function
(	O
dbc	pointer
,	O
pgno	int
)	O
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
switch	O
(	O
HPAGE_PTYPE	O
(	O
H_PAIRDATA	O
(	O
p	pointer
,	O
ndx	int
)	O
)	O
)	O
{	O
case	O
H_OFFPAGE	int
:	O
memcpy	function
(	O
&	O
pgno	int
,	O
HOFFPAGE_PGNO	O
(	O
P_ENTRY	O
(	O
p	pointer
,	O
H_DATAINDEX	O
(	O
ndx	int
)	O
)	O
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
ret	int
=	O
CDB___db_doff	function
(	O
dbc	pointer
,	O
pgno	int
)	O
;	O
break	O
;	O
case	O
H_OFFDUP	int
:	O
case	O
H_DUPLICATE	int
:	O
F_CLR	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ret	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
key_dbt	struct
.	O
data	pointer
=	O
P_ENTRY	O
(	O
p	pointer
,	O
H_KEYINDEX	O
(	O
ndx	int
)	O
)	O
;	O
key_dbt	struct
.	O
size	int
=	O
LEN_HITEM	O
(	O
p	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_KEYINDEX	O
(	O
ndx	int
)	O
)	O
;	O
data_dbt	struct
.	O
data	pointer
=	O
P_ENTRY	O
(	O
p	pointer
,	O
H_DATAINDEX	O
(	O
ndx	int
)	O
)	O
;	O
data_dbt	struct
.	O
size	int
=	O
LEN_HITEM	O
(	O
p	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_DATAINDEX	O
(	O
ndx	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_insdel_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
DELPAIR	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
p	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
ndx	int
,	O
&	O
LSN	O
(	O
p	pointer
)	O
,	O
&	O
key_dbt	struct
,	O
&	O
data_dbt	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
p	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
CDB___ham_dpair	function
(	O
dbp	pointer
,	O
p	pointer
,	O
ndx	int
)	O
;	O
if	O
(	O
!	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
)	O
--	O
hcp	pointer
->	O
hdr	pointer
->	O
nelem	int
;	O
if	O
(	O
reclaim_page	int
&&	O
NUM_ENT	O
(	O
p	pointer
)	O
==	O
0	int
&&	O
PREV_PGNO	O
(	O
p	pointer
)	O
==	O
PGNO_INVALID	int
&&	O
NEXT_PGNO	O
(	O
p	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
PAGE	struct
*	O
n_pagep	pointer
,	O
*	O
nn_pagep	pointer
;	O
db_pgno_t	int
tmp_pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
NEXT_PGNO	O
(	O
p	pointer
)	O
,	O
&	O
n_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
NEXT_PGNO	O
(	O
n_pagep	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
NEXT_PGNO	O
(	O
n_pagep	pointer
)	O
,	O
&	O
nn_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
n_pagep	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
key_dbt	struct
.	O
data	pointer
=	O
n_pagep	pointer
;	O
key_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_copypage_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
p	pointer
)	O
,	O
&	O
LSN	O
(	O
p	pointer
)	O
,	O
PGNO	O
(	O
n_pagep	pointer
)	O
,	O
&	O
LSN	O
(	O
n_pagep	pointer
)	O
,	O
NEXT_PGNO	O
(	O
n_pagep	pointer
)	O
,	O
NEXT_PGNO	O
(	O
n_pagep	pointer
)	O
==	O
PGNO_INVALID	int
?	O
NULL	O
:	O
&	O
LSN	O
(	O
nn_pagep	pointer
)	O
,	O
&	O
key_dbt	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
p	pointer
)	O
=	O
new_lsn	struct
;	O
LSN	O
(	O
n_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
if	O
(	O
NEXT_PGNO	O
(	O
n_pagep	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
LSN	O
(	O
nn_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
if	O
(	O
NEXT_PGNO	O
(	O
n_pagep	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
PREV_PGNO	O
(	O
nn_pagep	pointer
)	O
=	O
PGNO	O
(	O
p	pointer
)	O
;	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
nn_pagep	pointer
,	O
1	int
)	O
;	O
}	O
tmp_pgno	int
=	O
PGNO	O
(	O
p	pointer
)	O
;	O
tmp_lsn	struct
=	O
LSN	O
(	O
p	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
n_pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
PGNO	O
(	O
p	pointer
)	O
=	O
tmp_pgno	int
;	O
LSN	O
(	O
p	pointer
)	O
=	O
tmp_lsn	struct
;	O
PREV_PGNO	O
(	O
p	pointer
)	O
=	O
PGNO_INVALID	int
;	O
CDB___ham_c_update	function
(	O
dbc	pointer
,	O
PGNO	O
(	O
p	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
CDB___ham_c_chgpg	function
(	O
dbc	pointer
,	O
PGNO	O
(	O
n_pagep	pointer
)	O
,	O
NDX_INVALID	int
,	O
PGNO	O
(	O
p	pointer
)	O
,	O
NDX_INVALID	int
)	O
;	O
hcp	pointer
->	O
indx	short
=	O
0	int
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO	O
(	O
p	pointer
)	O
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
p	pointer
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
n_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
if	O
(	O
reclaim_page	int
&&	O
NUM_ENT	O
(	O
p	pointer
)	O
==	O
0	int
&&	O
PREV_PGNO	O
(	O
p	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
PAGE	struct
*	O
n_pagep	pointer
,	O
*	O
p_pagep	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
PREV_PGNO	O
(	O
p	pointer
)	O
,	O
&	O
p_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
NEXT_PGNO	O
(	O
p	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
NEXT_PGNO	O
(	O
p	pointer
)	O
,	O
&	O
n_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
p_pagep	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
n_lsn	pointer
=	O
&	O
LSN	O
(	O
n_pagep	pointer
)	O
;	O
}	O
else	O
{	O
n_pagep	pointer
=	O
NULL	O
;	O
n_lsn	pointer
=	O
NULL	O
;	O
}	O
NEXT_PGNO	O
(	O
p_pagep	pointer
)	O
=	O
NEXT_PGNO	O
(	O
p	pointer
)	O
;	O
if	O
(	O
n_pagep	pointer
!=	O
NULL	O
)	O
PREV_PGNO	O
(	O
n_pagep	pointer
)	O
=	O
PGNO	O
(	O
p_pagep	pointer
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_newpage_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
DELOVFL	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PREV_PGNO	O
(	O
p	pointer
)	O
,	O
&	O
LSN	O
(	O
p_pagep	pointer
)	O
,	O
PGNO	O
(	O
p	pointer
)	O
,	O
&	O
LSN	O
(	O
p	pointer
)	O
,	O
NEXT_PGNO	O
(	O
p	pointer
)	O
,	O
n_lsn	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
p_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
if	O
(	O
n_pagep	pointer
)	O
LSN	O
(	O
n_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
LSN	O
(	O
p	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
hcp	pointer
->	O
pgno	int
=	O
NEXT_PGNO	O
(	O
p	pointer
)	O
;	O
hcp	pointer
->	O
indx	short
=	O
0	int
;	O
hcp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
chg_pgno	int
=	O
PGNO	O
(	O
p	pointer
)	O
;	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
p_pagep	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
n_pagep	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
n_pagep	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
F_SET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
;	O
chg_pgno	int
=	O
hcp	pointer
->	O
pgno	int
;	O
ret	int
=	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
p	pointer
)	O
;	O
}	O
CDB___ham_c_update	function
(	O
dbc	pointer
,	O
chg_pgno	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_OK	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_replpair	function
(	O
dbc	pointer
,	O
dbt	struct
,	O
make_dup	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
dbt	struct
;	O
u_int32_t	int
make_dup	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DBT	struct
old_dbt	struct
,	O
tdata	struct
,	O
tmp	struct
;	O
DB_LSN	struct
new_lsn	struct
;	O
int32_t	int
change	int
;	O
u_int32_t	int
dup	int
,	O
len	short
,	O
memsize	int
;	O
int	O
is_big	int
,	O
ret	int
,	O
type	enum
;	O
u_int8_t	char
*	O
beg	pointer
,	O
*	O
dest	pointer
,	O
*	O
end	pointer
,	O
*	O
hk	pointer
,	O
*	O
src	pointer
;	O
void	O
*	O
memp	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
change	int
=	O
dbt	struct
->	O
size	int
-	O
dbt	struct
->	O
dlen	int
;	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
is_big	int
=	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFPAGE	int
;	O
if	O
(	O
is_big	int
)	O
memcpy	function
(	O
&	O
len	short
,	O
HOFFPAGE_TLEN	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
;	O
else	O
len	short
=	O
LEN_HKEYDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
if	O
(	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
>	O
len	short
)	O
change	int
+=	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
-	O
len	short
;	O
if	O
(	O
change	int
>	O
(	O
int32_t	int
)	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
||	O
is_big	int
)	O
{	O
memset	function
(	O
&	O
tmp	struct
,	O
0	int
,	O
sizeof	O
(	O
tmp	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
H_KEYINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
&	O
tmp	struct
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dup	int
=	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
if	O
(	O
dbt	struct
->	O
doff	int
==	O
0	int
&&	O
dbt	struct
->	O
dlen	int
==	O
len	short
)	O
{	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___ham_add_el	function
(	O
dbc	pointer
,	O
&	O
tmp	struct
,	O
dbt	struct
,	O
dup	int
?	O
H_DUPLICATE	int
:	O
H_KEYDATA	int
)	O
;	O
}	O
else	O
{	O
type	enum
=	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
!=	O
H_OFFPAGE	int
?	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
:	O
H_KEYDATA	int
;	O
memset	function
(	O
&	O
tdata	struct
,	O
0	int
,	O
sizeof	O
(	O
tdata	struct
)	O
)	O
;	O
memp	pointer
=	O
NULL	O
;	O
memsize	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
&	O
tdata	struct
,	O
&	O
memp	pointer
,	O
&	O
memsize	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_free	function
(	O
memp	pointer
,	O
memsize	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
change	int
>	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
tdata	struct
.	O
size	int
+	O
change	int
,	O
NULL	O
,	O
&	O
tdata	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memp	pointer
=	O
tdata	struct
.	O
data	pointer
;	O
memsize	int
=	O
tdata	struct
.	O
size	int
+	O
change	int
;	O
memset	function
(	O
(	O
u_int8_t	char
*	O
)	O
tdata	struct
.	O
data	pointer
+	O
tdata	struct
.	O
size	int
,	O
0	int
,	O
change	int
)	O
;	O
}	O
end	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
tdata	struct
.	O
data	pointer
+	O
tdata	struct
.	O
size	int
;	O
src	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
tdata	struct
.	O
data	pointer
+	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
;	O
if	O
(	O
src	pointer
<	O
end	pointer
&&	O
tdata	struct
.	O
size	int
>	O
dbt	struct
->	O
doff	int
+	O
dbt	struct
->	O
dlen	int
)	O
{	O
len	short
=	O
tdata	struct
.	O
size	int
-	O
dbt	struct
->	O
doff	int
-	O
dbt	struct
->	O
dlen	int
;	O
dest	pointer
=	O
src	pointer
+	O
change	int
;	O
memmove	function
(	O
dest	pointer
,	O
src	pointer
,	O
len	short
)	O
;	O
}	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
tdata	struct
.	O
data	pointer
+	O
dbt	struct
->	O
doff	int
,	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
;	O
tdata	struct
.	O
size	int
+=	O
change	int
;	O
ret	int
=	O
CDB___ham_add_el	function
(	O
dbc	pointer
,	O
&	O
tmp	struct
,	O
&	O
tdata	struct
,	O
type	enum
)	O
;	O
CDB___os_free	function
(	O
memp	pointer
,	O
memsize	int
)	O
;	O
}	O
F_SET	O
(	O
hcp	pointer
,	O
dup	int
)	O
;	O
err	pointer
:	O
return	O
(	O
ret	int
)	O
;	O
}	O
beg	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
beg	pointer
+=	O
dbt	struct
->	O
doff	int
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
old_dbt	struct
.	O
data	pointer
=	O
beg	pointer
;	O
old_dbt	struct
.	O
size	int
=	O
dbt	struct
->	O
dlen	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_replace_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
&	O
LSN	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
dbt	struct
->	O
doff	int
,	O
&	O
old_dbt	struct
,	O
dbt	struct
,	O
make_dup	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
hcp	pointer
->	O
page	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
CDB___ham_onpage_replace	function
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
(	O
u_int32_t	int
)	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
(	O
int32_t	int
)	O
dbt	struct
->	O
doff	int
,	O
change	int
,	O
dbt	struct
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
CDB___ham_onpage_replace	function
(	O
pagep	pointer
,	O
pgsize	int
,	O
ndx	int
,	O
off	long
,	O
change	int
,	O
dbt	struct
)	O
PAGE	struct
*	O
pagep	pointer
;	O
size_t	long
pgsize	int
;	O
u_int32_t	int
ndx	int
;	O
int32_t	int
off	long
;	O
int32_t	int
change	int
;	O
DBT	struct
*	O
dbt	struct
;	O
{	O
db_indx_t	short
i	short
;	O
int32_t	int
len	short
;	O
u_int8_t	char
*	O
src	pointer
,	O
*	O
dest	pointer
;	O
int	O
zero_me	int
;	O
if	O
(	O
change	int
!=	O
0	int
)	O
{	O
zero_me	int
=	O
0	int
;	O
src	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
(	O
pagep	pointer
)	O
+	O
HOFFSET	O
(	O
pagep	pointer
)	O
;	O
if	O
(	O
off	long
<	O
0	int
)	O
len	short
=	O
pagep	pointer
->	O
inp	array
[	O
ndx	int
]	O
-	O
HOFFSET	O
(	O
pagep	pointer
)	O
;	O
else	O
if	O
(	O
(	O
u_int32_t	int
)	O
off	long
>=	O
LEN_HKEYDATA	O
(	O
pagep	pointer
,	O
pgsize	int
,	O
ndx	int
)	O
)	O
{	O
len	short
=	O
HKEYDATA_DATA	O
(	O
P_ENTRY	O
(	O
pagep	pointer
,	O
ndx	int
)	O
)	O
+	O
LEN_HKEYDATA	O
(	O
pagep	pointer
,	O
pgsize	int
,	O
ndx	int
)	O
-	O
src	pointer
;	O
zero_me	int
=	O
1	int
;	O
}	O
else	O
len	short
=	O
(	O
HKEYDATA_DATA	O
(	O
P_ENTRY	O
(	O
pagep	pointer
,	O
ndx	int
)	O
)	O
+	O
off	long
)	O
-	O
src	pointer
;	O
dest	pointer
=	O
src	pointer
-	O
change	int
;	O
memmove	function
(	O
dest	pointer
,	O
src	pointer
,	O
len	short
)	O
;	O
if	O
(	O
zero_me	int
)	O
memset	function
(	O
dest	pointer
+	O
len	short
,	O
0	int
,	O
change	int
)	O
;	O
for	O
(	O
i	short
=	O
ndx	int
;	O
i	short
<	O
NUM_ENT	O
(	O
pagep	pointer
)	O
;	O
i	short
++	O
)	O
pagep	pointer
->	O
inp	array
[	O
i	short
]	O
-=	O
change	int
;	O
HOFFSET	O
(	O
pagep	pointer
)	O
-=	O
change	int
;	O
}	O
if	O
(	O
off	long
>=	O
0	int
)	O
memcpy	function
(	O
HKEYDATA_DATA	O
(	O
P_ENTRY	O
(	O
pagep	pointer
,	O
ndx	int
)	O
)	O
+	O
off	long
,	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
;	O
else	O
memcpy	function
(	O
P_ENTRY	O
(	O
pagep	pointer
,	O
ndx	int
)	O
,	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
;	O
}	O
int	O
CDB___ham_split_page	function
(	O
dbc	pointer
,	O
obucket	int
,	O
nbucket	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
obucket	int
,	O
nbucket	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
*	O
carray	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
,	O
*	O
cp	pointer
;	O
DBT	struct
key	struct
,	O
page_dbt	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
new_lsn	struct
;	O
PAGE	struct
*	O
*	O
pp	pointer
,	O
*	O
old_pagep	pointer
,	O
*	O
temp_pagep	pointer
,	O
*	O
new_pagep	pointer
;	O
db_indx_t	short
n	short
;	O
db_pgno_t	int
bucket_pgno	int
,	O
npgno	int
,	O
next_pgno	int
;	O
u_int32_t	int
big_len	int
,	O
len	short
;	O
int	O
i	short
,	O
ret	int
,	O
t_ret	int
;	O
void	O
*	O
big_buf	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
temp_pagep	pointer
=	O
old_pagep	pointer
=	O
new_pagep	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_clist	function
(	O
dbp	pointer
,	O
obucket	int
,	O
NDX_INVALID	int
,	O
&	O
carray	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
bucket_pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
obucket	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
bucket_pgno	int
,	O
&	O
old_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
npgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
nbucket	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
npgno	int
,	O
&	O
new_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
P_INIT	O
(	O
new_pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
npgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
P_HASH	int
,	O
dbp	pointer
->	O
tags	char
)	O
;	O
temp_pagep	pointer
=	O
hcp	pointer
->	O
split_buf	pointer
;	O
memcpy	function
(	O
temp_pagep	pointer
,	O
old_pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
page_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
page_dbt	struct
.	O
data	pointer
=	O
old_pagep	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_splitdata_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
SPLITOLD	int
,	O
PGNO	O
(	O
old_pagep	pointer
)	O
,	O
&	O
page_dbt	struct
,	O
&	O
LSN	O
(	O
old_pagep	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
P_INIT	O
(	O
old_pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
PGNO	O
(	O
old_pagep	pointer
)	O
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
P_HASH	int
,	O
dbp	pointer
->	O
tags	char
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
LSN	O
(	O
old_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
big_len	int
=	O
0	int
;	O
big_buf	pointer
=	O
NULL	O
;	O
key	struct
.	O
flags	int
=	O
0	int
;	O
while	O
(	O
temp_pagep	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
n	short
=	O
0	int
;	O
n	short
<	O
(	O
db_indx_t	short
)	O
NUM_ENT	O
(	O
temp_pagep	pointer
)	O
;	O
n	short
+=	O
2	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
temp_pagep	pointer
,	O
H_KEYINDEX	O
(	O
n	short
)	O
,	O
&	O
key	struct
,	O
&	O
big_buf	pointer
,	O
&	O
big_len	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
CDB___ham_call_hash	function
(	O
dbc	pointer
,	O
key	struct
.	O
data	pointer
,	O
key	struct
.	O
size	int
)	O
==	O
obucket	int
)	O
pp	pointer
=	O
&	O
old_pagep	pointer
;	O
else	O
pp	pointer
=	O
&	O
new_pagep	pointer
;	O
len	short
=	O
LEN_HITEM	O
(	O
temp_pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_DATAINDEX	O
(	O
n	short
)	O
)	O
+	O
LEN_HITEM	O
(	O
temp_pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_KEYINDEX	O
(	O
n	short
)	O
)	O
+	O
2	int
*	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
*	O
pp	pointer
)	O
<	O
len	short
)	O
{	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
page_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
page_dbt	struct
.	O
data	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_splitdata_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
SPLITNEW	int
,	O
PGNO	O
(	O
*	O
pp	pointer
)	O
,	O
&	O
page_dbt	struct
,	O
&	O
LSN	O
(	O
*	O
pp	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
*	O
pp	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_add_ovflpage	function
(	O
dbc	pointer
,	O
*	O
pp	pointer
,	O
1	int
,	O
pp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
carray	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	short
=	O
0	int
;	O
carray	pointer
[	O
i	short
]	O
!=	O
NULL	O
;	O
i	short
++	O
)	O
{	O
cp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
carray	pointer
[	O
i	short
]	O
->	O
internal	pointer
;	O
if	O
(	O
cp	pointer
->	O
pgno	int
==	O
PGNO	O
(	O
temp_pagep	pointer
)	O
&&	O
cp	pointer
->	O
indx	short
==	O
n	short
)	O
{	O
cp	pointer
->	O
pgno	int
=	O
PGNO	O
(	O
*	O
pp	pointer
)	O
;	O
cp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
*	O
pp	pointer
)	O
;	O
}	O
}	O
}	O
CDB___ham_copy_item	function
(	O
dbp	pointer
->	O
pgsize	int
,	O
temp_pagep	pointer
,	O
H_KEYINDEX	O
(	O
n	short
)	O
,	O
*	O
pp	pointer
)	O
;	O
CDB___ham_copy_item	function
(	O
dbp	pointer
->	O
pgsize	int
,	O
temp_pagep	pointer
,	O
H_DATAINDEX	O
(	O
n	short
)	O
,	O
*	O
pp	pointer
)	O
;	O
}	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
temp_pagep	pointer
)	O
;	O
if	O
(	O
PGNO	O
(	O
temp_pagep	pointer
)	O
!=	O
bucket_pgno	int
&&	O
(	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
temp_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
next_pgno	int
==	O
PGNO_INVALID	int
)	O
temp_pagep	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
next_pgno	int
,	O
&	O
temp_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
temp_pagep	pointer
!=	O
NULL	O
&&	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
page_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
page_dbt	struct
.	O
data	pointer
=	O
temp_pagep	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_splitdata_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
SPLITOLD	int
,	O
PGNO	O
(	O
temp_pagep	pointer
)	O
,	O
&	O
page_dbt	struct
,	O
&	O
LSN	O
(	O
temp_pagep	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
temp_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
}	O
if	O
(	O
big_buf	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
big_buf	pointer
,	O
big_len	int
)	O
;	O
if	O
(	O
temp_pagep	pointer
!=	O
NULL	O
&&	O
PGNO	O
(	O
temp_pagep	pointer
)	O
!=	O
bucket_pgno	int
&&	O
(	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
temp_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
page_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
page_dbt	struct
.	O
data	pointer
=	O
old_pagep	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_splitdata_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
SPLITNEW	int
,	O
PGNO	O
(	O
old_pagep	pointer
)	O
,	O
&	O
page_dbt	struct
,	O
&	O
LSN	O
(	O
old_pagep	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
old_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
page_dbt	struct
.	O
data	pointer
=	O
new_pagep	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_splitdata_log	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
SPLITNEW	int
,	O
PGNO	O
(	O
new_pagep	pointer
)	O
,	O
&	O
page_dbt	struct
,	O
&	O
LSN	O
(	O
new_pagep	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
new_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
old_pagep	pointer
,	O
1	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
new_pagep	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
0	int
)	O
{	O
err	pointer
:	O
if	O
(	O
old_pagep	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
old_pagep	pointer
,	O
1	int
)	O
;	O
if	O
(	O
new_pagep	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
new_pagep	pointer
,	O
1	int
)	O
;	O
if	O
(	O
temp_pagep	pointer
!=	O
NULL	O
&&	O
PGNO	O
(	O
temp_pagep	pointer
)	O
!=	O
bucket_pgno	int
)	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
temp_pagep	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
carray	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
carray	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_add_el	function
(	O
dbc	pointer
,	O
key	struct
,	O
val	pointer
,	O
type	enum
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
DBT	struct
*	O
key	struct
,	O
*	O
val	pointer
;	O
int	O
type	enum
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
const	O
DBT	struct
*	O
pkey	pointer
,	O
*	O
pdata	pointer
;	O
DBT	struct
key_dbt	struct
,	O
data_dbt	struct
;	O
DB_LSN	struct
new_lsn	struct
;	O
HOFFPAGE	struct
doff	int
,	O
koff	struct
;	O
db_pgno_t	int
next_pgno	int
;	O
u_int32_t	int
data_size	int
,	O
key_size	int
,	O
pairsize	int
,	O
rectype	int
;	O
int	O
do_expand	int
,	O
is_keybig	int
,	O
is_databig	int
,	O
ret	int
;	O
int	O
key_type	int
,	O
data_type	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
do_expand	int
=	O
0	int
;	O
if	O
(	O
hcp	pointer
->	O
page	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
seek_found_page	int
!=	O
PGNO_INVALID	int
?	O
hcp	pointer
->	O
seek_found_page	int
:	O
hcp	pointer
->	O
pgno	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
hcp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
key_size	int
=	O
HKEYDATA_PSIZE	O
(	O
key	struct
->	O
size	int
)	O
;	O
data_size	int
=	O
HKEYDATA_PSIZE	O
(	O
val	pointer
->	O
size	int
)	O
;	O
is_keybig	int
=	O
ISBIG	O
(	O
hcp	pointer
,	O
key	struct
->	O
size	int
)	O
;	O
is_databig	int
=	O
ISBIG	O
(	O
hcp	pointer
,	O
val	pointer
->	O
size	int
)	O
;	O
if	O
(	O
is_keybig	int
)	O
key_size	int
=	O
HOFFPAGE_PSIZE	O
;	O
if	O
(	O
is_databig	int
)	O
data_size	int
=	O
HOFFPAGE_PSIZE	O
;	O
pairsize	int
=	O
key_size	int
+	O
data_size	int
;	O
while	O
(	O
H_NUMPAIRS	O
(	O
hcp	pointer
->	O
page	pointer
)	O
&&	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
>=	O
pairsize	int
)	O
break	O
;	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_next_cpage	function
(	O
dbc	pointer
,	O
next_pgno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
<	O
pairsize	int
)	O
{	O
do_expand	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_add_ovflpage	function
(	O
dbc	pointer
,	O
(	O
PAGE	struct
*	O
)	O
hcp	pointer
->	O
page	pointer
,	O
1	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
hcp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
}	O
hcp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
;	O
if	O
(	O
is_keybig	int
)	O
{	O
koff	struct
.	O
type	enum
=	O
H_OFFPAGE	int
;	O
UMRW	O
(	O
koff	struct
.	O
unused	array
[	O
0	int
]	O
)	O
;	O
UMRW	O
(	O
koff	struct
.	O
unused	array
[	O
1	int
]	O
)	O
;	O
UMRW	O
(	O
koff	struct
.	O
unused	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_poff	function
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
koff	struct
.	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
koff	struct
.	O
tlen	int
=	O
key	struct
->	O
size	int
;	O
key_dbt	struct
.	O
data	pointer
=	O
&	O
koff	struct
;	O
key_dbt	struct
.	O
size	int
=	O
sizeof	O
(	O
koff	struct
)	O
;	O
pkey	pointer
=	O
&	O
key_dbt	struct
;	O
key_type	int
=	O
H_OFFPAGE	int
;	O
}	O
else	O
{	O
pkey	pointer
=	O
key	struct
;	O
key_type	int
=	O
H_KEYDATA	int
;	O
}	O
if	O
(	O
is_databig	int
)	O
{	O
doff	int
.	O
type	enum
=	O
H_OFFPAGE	int
;	O
UMRW	O
(	O
doff	int
.	O
unused	array
[	O
0	int
]	O
)	O
;	O
UMRW	O
(	O
doff	int
.	O
unused	array
[	O
1	int
]	O
)	O
;	O
UMRW	O
(	O
doff	int
.	O
unused	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_poff	function
(	O
dbc	pointer
,	O
val	pointer
,	O
&	O
doff	int
.	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
doff	int
.	O
tlen	int
=	O
val	pointer
->	O
size	int
;	O
data_dbt	struct
.	O
data	pointer
=	O
&	O
doff	int
;	O
data_dbt	struct
.	O
size	int
=	O
sizeof	O
(	O
doff	int
)	O
;	O
pdata	pointer
=	O
&	O
data_dbt	struct
;	O
data_type	int
=	O
H_OFFPAGE	int
;	O
}	O
else	O
{	O
pdata	pointer
=	O
val	pointer
;	O
data_type	int
=	O
type	enum
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
rectype	int
=	O
PUTPAIR	int
;	O
if	O
(	O
is_databig	int
)	O
rectype	int
|=	O
PAIR_DATAMASK	int
;	O
if	O
(	O
is_keybig	int
)	O
rectype	int
|=	O
PAIR_KEYMASK	int
;	O
if	O
(	O
type	enum
==	O
H_DUPLICATE	int
)	O
rectype	int
|=	O
PAIR_DUPMASK	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_insdel_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
rectype	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
&	O
LSN	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
pkey	pointer
,	O
pdata	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
hcp	pointer
->	O
page	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
CDB___ham_putitem	function
(	O
hcp	pointer
->	O
page	pointer
,	O
pkey	pointer
,	O
key_type	int
)	O
;	O
CDB___ham_putitem	function
(	O
hcp	pointer
->	O
page	pointer
,	O
pdata	pointer
,	O
data_type	int
)	O
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
!	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
)	O
hcp	pointer
->	O
hdr	pointer
->	O
nelem	int
++	O
;	O
if	O
(	O
do_expand	int
||	O
(	O
hcp	pointer
->	O
hdr	pointer
->	O
ffactor	int
!=	O
0	int
&&	O
(	O
u_int32_t	int
)	O
H_NUMPAIRS	O
(	O
hcp	pointer
->	O
page	pointer
)	O
>	O
hcp	pointer
->	O
hdr	pointer
->	O
ffactor	int
)	O
)	O
F_SET	O
(	O
hcp	pointer
,	O
H_EXPAND	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
CDB___ham_copy_item	function
(	O
pgsize	int
,	O
src_page	pointer
,	O
src_ndx	int
,	O
dest_page	pointer
)	O
size_t	long
pgsize	int
;	O
PAGE	struct
*	O
src_page	pointer
;	O
u_int32_t	int
src_ndx	int
;	O
PAGE	struct
*	O
dest_page	pointer
;	O
{	O
u_int32_t	int
len	short
;	O
void	O
*	O
src	pointer
,	O
*	O
dest	pointer
;	O
src	pointer
=	O
P_ENTRY	O
(	O
src_page	pointer
,	O
src_ndx	int
)	O
;	O
len	short
=	O
LEN_HITEM	O
(	O
src_page	pointer
,	O
pgsize	int
,	O
src_ndx	int
)	O
;	O
HOFFSET	O
(	O
dest_page	pointer
)	O
-=	O
len	short
;	O
dest_page	pointer
->	O
inp	array
[	O
NUM_ENT	O
(	O
dest_page	pointer
)	O
]	O
=	O
HOFFSET	O
(	O
dest_page	pointer
)	O
;	O
dest	pointer
=	O
P_ENTRY	O
(	O
dest_page	pointer
,	O
NUM_ENT	O
(	O
dest_page	pointer
)	O
)	O
;	O
NUM_ENT	O
(	O
dest_page	pointer
)	O
++	O
;	O
memcpy	function
(	O
dest	pointer
,	O
src	pointer
,	O
len	short
)	O
;	O
}	O
int	O
CDB___ham_add_ovflpage	function
(	O
dbc	pointer
,	O
pagep	pointer
,	O
release	int
,	O
pp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
int	O
release	int
;	O
PAGE	struct
*	O
*	O
pp	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_LSN	struct
new_lsn	struct
;	O
PAGE	struct
*	O
new_pagep	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
(	O
P_HASH	int
|	O
dbp	pointer
->	O
tags	char
)	O
,	O
&	O
new_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_newpage_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
PUTOVFL	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
PGNO	O
(	O
new_pagep	pointer
)	O
,	O
&	O
LSN	O
(	O
new_pagep	pointer
)	O
,	O
PGNO_INVALID	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
pagep	pointer
)	O
=	O
LSN	O
(	O
new_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
NEXT_PGNO	O
(	O
pagep	pointer
)	O
=	O
PGNO	O
(	O
new_pagep	pointer
)	O
;	O
PREV_PGNO	O
(	O
new_pagep	pointer
)	O
=	O
PGNO	O
(	O
pagep	pointer
)	O
;	O
if	O
(	O
release	int
)	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
pagep	pointer
,	O
1	int
)	O
;	O
*	O
pp	pointer
=	O
new_pagep	pointer
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
pagep	pointer
,	O
is_dirty	int
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
int32_t	int
is_dirty	int
;	O
{	O
return	O
(	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pagep	pointer
,	O
(	O
is_dirty	int
?	O
DB_MPOOL_DIRTY	int
:	O
0	int
)	O
)	O
)	O
;	O
}	O
int	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
pagep	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
{	O
return	O
(	O
CDB_memp_fset	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pagep	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
;	O
}	O
int	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
addr	pointer
,	O
pagep	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
db_pgno_t	int
addr	pointer
;	O
PAGE	struct
*	O
*	O
pagep	pointer
;	O
{	O
return	O
(	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
addr	pointer
,	O
DB_MPOOL_CREATE	int
,	O
pagep	pointer
)	O
)	O
;	O
}	O
db_pgno_t	int
CDB___bucket_to_page	function
(	O
hcp	pointer
,	O
n	short
)	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
db_pgno_t	int
n	short
;	O
{	O
int	O
ret_val	int
;	O
ret_val	int
=	O
n	short
+	O
1	int
;	O
if	O
(	O
n	short
!=	O
0	int
)	O
ret_val	int
+=	O
hcp	pointer
->	O
hdr	pointer
->	O
spares	array
[	O
CDB___db_log2	function
(	O
n	short
+	O
1	int
)	O
-	O
1	int
]	O
;	O
return	O
(	O
ret_val	int
)	O
;	O
}	O
int	O
CDB___ham_get_cpage	function
(	O
dbc	pointer
,	O
mode	enum
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
tmp_lock	struct
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
tmp_lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
hcp	pointer
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
&&	O
hcp	pointer
->	O
lbucket	int
!=	O
hcp	pointer
->	O
bucket	int
)	O
{	O
if	O
(	O
dbc	pointer
->	O
txn	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB_lock_put	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
hcp	pointer
->	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
}	O
if	O
(	O
(	O
hcp	pointer
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
&&	O
(	O
hcp	pointer
->	O
lock_mode	enum
==	O
DB_LOCK_READ	int
&&	O
mode	enum
==	O
DB_LOCK_WRITE	int
)	O
)	O
)	O
{	O
tmp_lock	struct
=	O
hcp	pointer
->	O
lock	struct
;	O
hcp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
}	O
if	O
(	O
hcp	pointer
->	O
lock	struct
.	O
off	long
==	O
LOCK_INVALID	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_lock_bucket	function
(	O
dbc	pointer
,	O
mode	enum
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
hcp	pointer
->	O
lock_mode	enum
=	O
mode	enum
;	O
hcp	pointer
->	O
lbucket	int
=	O
hcp	pointer
->	O
bucket	int
;	O
if	O
(	O
tmp_lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
ret	int
=	O
CDB_lock_put	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
tmp_lock	struct
)	O
;	O
}	O
else	O
if	O
(	O
tmp_lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
hcp	pointer
->	O
lock	struct
=	O
tmp_lock	struct
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
&&	O
hcp	pointer
->	O
page	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
hcp	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
hcp	pointer
->	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
pgno	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
hcp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_next_cpage	function
(	O
dbc	pointer
,	O
pgno	int
,	O
dirty	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
dirty	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
PAGE	struct
*	O
p	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
hcp	pointer
->	O
page	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
dirty	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hcp	pointer
->	O
page	pointer
=	O
p	pointer
;	O
hcp	pointer
->	O
pgno	int
=	O
pgno	int
;	O
hcp	pointer
->	O
indx	short
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_lock_bucket	function
(	O
dbc	pointer
,	O
mode	enum
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_lockmode_t	enum
mode	enum
;	O
{	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
gotmeta	int
,	O
ret	int
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
gotmeta	int
=	O
hcp	pointer
->	O
hdr	pointer
==	O
NULL	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
gotmeta	int
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbc	pointer
->	O
lock	struct
.	O
pgno	int
=	O
BUCKET_TO_PAGE	O
(	O
hcp	pointer
,	O
hcp	pointer
->	O
bucket	int
)	O
;	O
if	O
(	O
gotmeta	int
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_release_meta	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
flags	int
=	O
0	int
;	O
if	O
(	O
DB_NONBLOCK	O
(	O
dbc	pointer
)	O
)	O
LF_SET	O
(	O
DB_LOCK_NOWAIT	int
)	O
;	O
ret	int
=	O
CDB_lock_get	function
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
locker	int
,	O
flags	int
,	O
&	O
dbc	pointer
->	O
lock_dbt	struct
,	O
mode	enum
,	O
&	O
hcp	pointer
->	O
lock	struct
)	O
;	O
hcp	pointer
->	O
lock_mode	enum
=	O
mode	enum
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___ham_dpair	function
(	O
dbp	pointer
,	O
p	pointer
,	O
indx	short
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
p	pointer
;	O
u_int32_t	int
indx	short
;	O
{	O
db_indx_t	short
delta	short
,	O
n	short
;	O
u_int8_t	char
*	O
dest	pointer
,	O
*	O
src	pointer
;	O
delta	short
=	O
H_PAIRSIZE	O
(	O
p	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
indx	short
)	O
;	O
if	O
(	O
(	O
db_indx_t	short
)	O
indx	short
!=	O
NUM_ENT	O
(	O
p	pointer
)	O
-	O
2	int
)	O
{	O
src	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
p	pointer
+	O
HOFFSET	O
(	O
p	pointer
)	O
;	O
dest	pointer
=	O
src	pointer
+	O
delta	short
;	O
memmove	function
(	O
dest	pointer
,	O
src	pointer
,	O
p	pointer
->	O
inp	array
[	O
H_DATAINDEX	O
(	O
indx	short
)	O
]	O
-	O
HOFFSET	O
(	O
p	pointer
)	O
)	O
;	O
}	O
HOFFSET	O
(	O
p	pointer
)	O
=	O
HOFFSET	O
(	O
p	pointer
)	O
+	O
delta	short
;	O
NUM_ENT	O
(	O
p	pointer
)	O
=	O
NUM_ENT	O
(	O
p	pointer
)	O
-	O
2	int
;	O
for	O
(	O
n	short
=	O
(	O
db_indx_t	short
)	O
indx	short
;	O
n	short
<	O
(	O
db_indx_t	short
)	O
(	O
NUM_ENT	O
(	O
p	pointer
)	O
)	O
;	O
n	short
++	O
)	O
p	pointer
->	O
inp	array
[	O
n	short
]	O
=	O
p	pointer
->	O
inp	array
[	O
n	short
+	O
2	int
]	O
+	O
delta	short
;	O
}	O