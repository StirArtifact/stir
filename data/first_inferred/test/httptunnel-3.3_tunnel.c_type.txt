typedef	O
unsigned	O
char	O
Request	char
;	O
typedef	O
unsigned	O
short	O
Length	short
;	O
enum	O
tunnel_request	enum
{	O
TUNNEL_SIMPLE	int
=	O
0x40	int
,	O
TUNNEL_OPEN	int
=	O
0x01	int
,	O
TUNNEL_DATA	int
=	O
0x02	int
,	O
TUNNEL_PADDING	int
=	O
0x03	int
,	O
TUNNEL_ERROR	int
=	O
0x04	int
,	O
TUNNEL_PAD1	int
=	O
TUNNEL_SIMPLE	int
|	O
0x05	int
,	O
TUNNEL_CLOSE	int
=	O
TUNNEL_SIMPLE	int
|	O
0x06	int
,	O
TUNNEL_DISCONNECT	int
=	O
TUNNEL_SIMPLE	int
|	O
0x07	int
}	O
;	O
static	O
inline	O
const	O
char	O
*	O
REQ_TO_STRING	function
(	O
Request	char
request	pointer
)	O
{	O
switch	O
(	O
request	pointer
)	O
{	O
case	O
TUNNEL_OPEN	int
:	O
return	O
"TUNNEL_OPEN"	pointer
;	O
case	O
TUNNEL_DATA	int
:	O
return	O
"TUNNEL_DATA"	pointer
;	O
case	O
TUNNEL_PADDING	int
:	O
return	O
"TUNNEL_PADDING"	pointer
;	O
case	O
TUNNEL_ERROR	int
:	O
return	O
"TUNNEL_ERROR"	pointer
;	O
case	O
TUNNEL_PAD1	int
:	O
return	O
"TUNNEL_PAD1"	pointer
;	O
case	O
TUNNEL_CLOSE	int
:	O
return	O
"TUNNEL_CLOSE"	pointer
;	O
case	O
TUNNEL_DISCONNECT	int
:	O
return	O
"TUNNEL_DISCONNECT"	pointer
;	O
default	O
:	O
return	O
"(unknown)"	pointer
;	O
}	O
}	O
struct	O
tunnel	pointer
{	O
int	O
in_fd	int
,	O
out_fd	int
;	O
int	O
server_socket	function
;	O
Http_destination	struct
dest	short
;	O
struct	O
sockaddr_in	struct
address	long
;	O
size_t	long
bytes	long
;	O
size_t	long
content_length	long
;	O
char	O
buf	pointer
[	O
65536	int
]	O
;	O
char	O
*	O
buf_ptr	pointer
;	O
size_t	long
buf_len	long
;	O
int	O
padding_only	int
;	O
size_t	long
in_total_raw	long
;	O
size_t	long
in_total_data	long
;	O
size_t	long
out_total_raw	long
;	O
size_t	long
out_total_data	long
;	O
time_t	long
out_connect_time	long
;	O
int	O
strict_content_length	int
;	O
int	O
keep_alive	int
;	O
int	O
max_connection_age	int
;	O
}	O
;	O
static	O
const	O
size_t	long
sizeof_header	long
=	O
sizeof	O
(	O
Request	char
)	O
+	O
sizeof	O
(	O
Length	short
)	O
;	O
static	O
inline	O
int	O
tunnel_is_disconnected	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
return	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
tunnel_is_connected	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
return	O
!	O
tunnel_is_disconnected	function
(	O
tunnel	pointer
)	O
;	O
}	O
static	O
inline	O
int	O
tunnel_is_server	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
return	O
tunnel	pointer
->	O
server_socket	function
!=	O
-	O
1	int
;	O
}	O
static	O
inline	O
int	O
tunnel_is_client	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
return	O
!	O
tunnel_is_server	function
(	O
tunnel	pointer
)	O
;	O
}	O
static	O
int	O
get_proto_number	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
protoent	struct
*	O
p	pointer
;	O
int	O
number	int
;	O
p	pointer
=	O
getprotobyname	function
(	O
name	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
number	int
=	O
-	O
1	int
;	O
else	O
number	int
=	O
p	pointer
->	O
p_proto	int
;	O
endprotoent	function
(	O
)	O
;	O
return	O
number	int
;	O
}	O
static	O
int	O
tunnel_in_setsockopts	function
(	O
int	O
fd	int
)	O
{	O
int	O
tcp	int
=	O
get_proto_number	function
(	O
"tcp"	pointer
)	O
;	O
if	O
(	O
tcp	int
!=	O
-	O
1	int
)	O
{	O
int	O
i	int
,	O
n	long
;	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
fd	int
,	O
tcp	int
,	O
SO_RCVLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"tunnel_in_setsockopts: non-fatal SO_RCVLOWAT error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	function
(	O
fd	int
,	O
tcp	int
,	O
SO_RCVLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	function
(	O
"tunnel_out_setsockopts: SO_RCVLOWAT: %d"	pointer
,	O
i	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
tunnel_out_setsockopts	function
(	O
int	O
fd	int
)	O
{	O
{	O
int	O
tcp	int
=	O
get_proto_number	function
(	O
"tcp"	pointer
)	O
;	O
int	O
i	int
,	O
n	long
;	O
if	O
(	O
tcp	int
!=	O
-	O
1	int
)	O
{	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
fd	int
,	O
tcp	int
,	O
SO_SNDLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"tunnel_out_setsockopts: "	pointer
"non-fatal SO_SNDLOWAT error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	function
(	O
fd	int
,	O
tcp	int
,	O
SO_SNDLOWAT	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	function
(	O
"tunnel_out_setsockopts: non-fatal SO_SNDLOWAT: %d"	pointer
,	O
i	int
)	O
;	O
}	O
}	O
{	O
struct	O
linger	struct
l	struct
;	O
int	O
n	long
;	O
l	struct
.	O
l_onoff	int
=	O
1	int
;	O
l	struct
.	O
l_linger	int
=	O
20	int
*	O
100	int
;	O
if	O
(	O
setsockopt	function
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_LINGER	int
,	O
(	O
void	O
*	O
)	O
&	O
l	struct
,	O
sizeof	O
l	struct
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"tunnel_out_setsockopts: non-fatal SO_LINGER error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
l	struct
;	O
getsockopt	function
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_LINGER	int
,	O
(	O
void	O
*	O
)	O
&	O
l	struct
,	O
&	O
n	long
)	O
;	O
log_debug	function
(	O
"tunnel_out_setsockopts: SO_LINGER: onoff=%d linger=%d"	pointer
,	O
l	struct
.	O
l_onoff	int
,	O
l	struct
.	O
l_linger	int
)	O
;	O
}	O
{	O
int	O
tcp	int
=	O
get_proto_number	function
(	O
"tcp"	pointer
)	O
;	O
int	O
i	int
,	O
n	long
;	O
if	O
(	O
tcp	int
!=	O
-	O
1	int
)	O
{	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
fd	int
,	O
tcp	int
,	O
TCP_NODELAY	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"tunnel_out_setsockopts: "	pointer
"non-fatal TCP_NODELAY error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	function
(	O
fd	int
,	O
tcp	int
,	O
TCP_NODELAY	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	function
(	O
"tunnel_out_setsockopts: non-fatal TCP_NODELAY: %d"	pointer
,	O
i	int
)	O
;	O
}	O
}	O
{	O
int	O
i	int
,	O
n	long
;	O
i	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
sizeof	O
i	int
)	O
==	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"tunnel_out_setsockopts: non-fatal SO_KEEPALIVE error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
n	long
=	O
sizeof	O
i	int
;	O
getsockopt	function
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
void	O
*	O
)	O
&	O
i	int
,	O
&	O
n	long
)	O
;	O
log_debug	function
(	O
"tunnel_out_setsockopts: SO_KEEPALIVE: %d"	pointer
,	O
i	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
tunnel_out_disconnect	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
if	O
(	O
tunnel_is_disconnected	function
(	O
tunnel	pointer
)	O
)	O
return	O
;	O
close	function
(	O
tunnel	pointer
->	O
out_fd	int
)	O
;	O
tunnel	pointer
->	O
out_fd	int
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
bytes	long
=	O
0	int
;	O
tunnel	pointer
->	O
buf_ptr	pointer
=	O
tunnel	pointer
->	O
buf	pointer
;	O
tunnel	pointer
->	O
buf_len	long
=	O
0	int
;	O
log_debug	function
(	O
"tunnel_out_disconnect: output disconnected"	pointer
)	O
;	O
}	O
static	O
void	O
tunnel_in_disconnect	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
)	O
return	O
;	O
close	function
(	O
tunnel	pointer
->	O
in_fd	int
)	O
;	O
tunnel	pointer
->	O
in_fd	int
=	O
-	O
1	int
;	O
log_debug	function
(	O
"tunnel_in_disconnect: input disconnected"	pointer
)	O
;	O
}	O
static	O
int	O
tunnel_out_connect	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
ssize_t	long
n	long
;	O
if	O
(	O
tunnel_is_connected	function
(	O
tunnel	pointer
)	O
)	O
{	O
log_debug	function
(	O
"tunnel_out_connect: already connected"	pointer
)	O
;	O
tunnel_out_disconnect	function
(	O
tunnel	pointer
)	O
;	O
}	O
tunnel	pointer
->	O
out_fd	int
=	O
do_connect	function
(	O
&	O
tunnel	pointer
->	O
address	long
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_out_connect: do_connect (%d.%d.%d.%d:%u) error: %s"	pointer
,	O
ntohl	function
(	O
tunnel	pointer
->	O
address	long
.	O
sin_addr	struct
.	O
s_addr	int
)	O
>>	O
24	int
,	O
(	O
ntohl	function
(	O
tunnel	pointer
->	O
address	long
.	O
sin_addr	struct
.	O
s_addr	int
)	O
>>	O
16	int
)	O
&	O
0xff	int
,	O
(	O
ntohl	function
(	O
tunnel	pointer
->	O
address	long
.	O
sin_addr	struct
.	O
s_addr	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
,	O
ntohl	function
(	O
tunnel	pointer
->	O
address	long
.	O
sin_addr	struct
.	O
s_addr	int
)	O
&	O
0xff	int
,	O
ntohs	function
(	O
tunnel	pointer
->	O
address	long
.	O
sin_port	short
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel_out_setsockopts	function
(	O
tunnel	pointer
->	O
out_fd	int
)	O
;	O
n	long
=	O
http_post	function
(	O
tunnel	pointer
->	O
out_fd	int
,	O
&	O
tunnel	pointer
->	O
dest	short
,	O
tunnel	pointer
->	O
content_length	long
+	O
1	int
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
tunnel	pointer
->	O
bytes	long
=	O
0	int
;	O
tunnel	pointer
->	O
buf_ptr	pointer
=	O
tunnel	pointer
->	O
buf	pointer
;	O
tunnel	pointer
->	O
buf_len	long
=	O
0	int
;	O
tunnel	pointer
->	O
padding_only	int
=	O
TRUE	int
;	O
time	function
(	O
&	O
tunnel	pointer
->	O
out_connect_time	long
)	O
;	O
log_debug	function
(	O
"tunnel_out_connect: output connected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
tunnel_in_connect	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
Http_response	struct
*	O
response	pointer
;	O
ssize_t	long
n	long
;	O
log_verbose	function
(	O
"tunnel_in_connect()"	pointer
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
!=	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_in_connect: already connected"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel	pointer
->	O
in_fd	int
=	O
do_connect	function
(	O
&	O
tunnel	pointer
->	O
address	long
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_in_connect: do_connect() error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel_in_setsockopts	function
(	O
tunnel	pointer
->	O
in_fd	int
)	O
;	O
if	O
(	O
http_get	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
&	O
tunnel	pointer
->	O
dest	short
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
n	long
=	O
http_parse_response	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
&	O
response	pointer
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
0	int
)	O
log_error	function
(	O
"tunnel_in_connect: no response; peer "	pointer
"closed connection"	pointer
)	O
;	O
else	O
log_error	function
(	O
"tunnel_in_connect: no response; error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
response	pointer
->	O
major_version	int
!=	O
1	int
||	O
(	O
response	pointer
->	O
minor_version	int
!=	O
1	int
&&	O
response	pointer
->	O
minor_version	int
!=	O
0	int
)	O
)	O
{	O
log_error	function
(	O
"tunnel_in_connect: unknown HTTP version: %d.%d"	pointer
,	O
response	pointer
->	O
major_version	int
,	O
response	pointer
->	O
minor_version	int
)	O
;	O
n	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
response	pointer
->	O
status_code	int
!=	O
200	int
)	O
{	O
log_error	function
(	O
"tunnel_in_connect: HTTP error %d"	pointer
,	O
response	pointer
->	O
status_code	int
)	O
;	O
errno	O
=	O
http_error_to_errno	function
(	O
-	O
response	pointer
->	O
status_code	int
)	O
;	O
n	long
=	O
-	O
1	int
;	O
}	O
if	O
(	O
response	pointer
)	O
http_destroy_response	function
(	O
response	pointer
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
}	O
else	O
{	O
return	O
n	long
;	O
}	O
log_debug	function
(	O
"tunnel_in_connect: input connected"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
inline	O
ssize_t	long
tunnel_write_data	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
void	O
*	O
data	pointer
,	O
size_t	long
length	int
)	O
{	O
if	O
(	O
write_all	function
(	O
tunnel	pointer
->	O
out_fd	int
,	O
data	pointer
,	O
length	int
)	O
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_write_data: write error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tunnel	pointer
->	O
bytes	long
+=	O
length	int
;	O
return	O
length	int
;	O
}	O
static	O
int	O
tunnel_write_request	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
Request	char
request	pointer
,	O
void	O
*	O
data	pointer
,	O
Length	short
length	int
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
bytes	long
+	O
sizeof	O
request	pointer
+	O
(	O
data	pointer
?	O
sizeof	O
length	int
+	O
length	int
:	O
0	int
)	O
>	O
tunnel	pointer
->	O
content_length	long
)	O
tunnel_padding	function
(	O
tunnel	pointer
,	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
)	O
;	O
{	O
time_t	long
t	long
;	O
time	function
(	O
&	O
t	long
)	O
;	O
if	O
(	O
tunnel_is_client	function
(	O
tunnel	pointer
)	O
&&	O
tunnel_is_connected	function
(	O
tunnel	pointer
)	O
&&	O
t	long
-	O
tunnel	pointer
->	O
out_connect_time	long
>	O
tunnel	pointer
->	O
max_connection_age	int
)	O
{	O
char	O
c	char
=	O
TUNNEL_DISCONNECT	int
;	O
log_debug	function
(	O
"tunnel_write_request: connection > %d seconds old"	pointer
,	O
tunnel	pointer
->	O
max_connection_age	int
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
strict_content_length	int
)	O
{	O
int	O
l	struct
=	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
-	O
1	int
;	O
log_debug	function
(	O
"tunnel_write_request: write padding (%d bytes)"	pointer
,	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
-	O
1	int
)	O
;	O
if	O
(	O
l	struct
>	O
3	int
)	O
{	O
char	O
c	char
;	O
short	O
s	short
;	O
int	O
i	int
;	O
c	char
=	O
TUNNEL_PADDING	int
;	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
s	short
=	O
htons	function
(	O
l	struct
-	O
2	int
)	O
;	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
s	short
,	O
sizeof	O
s	short
)	O
;	O
l	struct
-=	O
2	int
;	O
c	char
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	struct
;	O
i	int
++	O
)	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
}	O
else	O
{	O
char	O
c	char
=	O
TUNNEL_PAD1	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	struct
;	O
i	int
++	O
)	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
}	O
}	O
log_debug	function
(	O
"tunnel_write_request: closing old connection"	pointer
)	O
;	O
if	O
(	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
tunnel_out_disconnect	function
(	O
tunnel	pointer
)	O
;	O
}	O
}	O
if	O
(	O
tunnel_is_disconnected	function
(	O
tunnel	pointer
)	O
)	O
{	O
if	O
(	O
tunnel_is_client	function
(	O
tunnel	pointer
)	O
)	O
{	O
if	O
(	O
tunnel_out_connect	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_accept	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
request	pointer
!=	O
TUNNEL_PADDING	int
&&	O
request	pointer
!=	O
TUNNEL_PAD1	int
)	O
tunnel	pointer
->	O
padding_only	int
=	O
FALSE	int
;	O
if	O
(	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
request	pointer
,	O
sizeof	O
request	pointer
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EPIPE	int
)	O
return	O
-	O
1	int
;	O
tunnel_out_disconnect	function
(	O
tunnel	pointer
)	O
;	O
if	O
(	O
tunnel_is_client	function
(	O
tunnel	pointer
)	O
)	O
tunnel_out_connect	function
(	O
tunnel	pointer
)	O
;	O
else	O
{	O
log_error	function
(	O
"tunnel_write_request: couldn't write request: "	pointer
"output is disconnected"	pointer
)	O
;	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
request	pointer
,	O
sizeof	O
request	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
data	pointer
)	O
{	O
Length	short
network_length	short
=	O
htons	function
(	O
(	O
short	O
)	O
length	int
)	O
;	O
if	O
(	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
network_length	short
,	O
sizeof	O
network_length	short
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
data	pointer
,	O
(	O
size_t	long
)	O
length	int
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
data	pointer
)	O
{	O
tunnel	pointer
->	O
out_total_raw	long
+=	O
3	int
+	O
length	int
;	O
if	O
(	O
request	pointer
==	O
TUNNEL_DATA	int
)	O
log_verbose	function
(	O
"tunnel_write_request: %s (%d)"	pointer
,	O
REQ_TO_STRING	function
(	O
request	pointer
)	O
,	O
length	int
)	O
;	O
else	O
log_debug	function
(	O
"tunnel_write_request: %s (%d)"	pointer
,	O
REQ_TO_STRING	function
(	O
request	pointer
)	O
,	O
length	int
)	O
;	O
}	O
else	O
{	O
tunnel	pointer
->	O
out_total_raw	long
+=	O
1	int
;	O
log_debug	function
(	O
"tunnel_write_request: %s"	pointer
,	O
REQ_TO_STRING	function
(	O
request	pointer
)	O
)	O
;	O
}	O
log_annoying	function
(	O
"tunnel_write_data: out_total_raw = %u"	pointer
,	O
tunnel	pointer
->	O
out_total_raw	long
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
bytes	long
>=	O
tunnel	pointer
->	O
content_length	long
)	O
{	O
char	O
c	char
=	O
TUNNEL_DISCONNECT	int
;	O
tunnel_write_data	function
(	O
tunnel	pointer
,	O
&	O
c	char
,	O
sizeof	O
c	char
)	O
;	O
tunnel_out_disconnect	function
(	O
tunnel	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
tunnel_connect	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
char	O
auth_data	array
[	O
1	int
]	O
=	O
{	O
42	int
}	O
;	O
log_verbose	function
(	O
"tunnel_connect()"	pointer
)	O
;	O
if	O
(	O
tunnel_is_connected	function
(	O
tunnel	pointer
)	O
)	O
{	O
log_error	function
(	O
"tunnel_connect: already connected"	pointer
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel_write_request	function
(	O
tunnel	pointer
,	O
TUNNEL_OPEN	int
,	O
auth_data	array
,	O
sizeof	O
auth_data	array
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
tunnel_in_connect	function
(	O
tunnel	pointer
)	O
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
inline	O
int	O
tunnel_write_or_padding	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
Request	char
request	pointer
,	O
void	O
*	O
data	pointer
,	O
size_t	long
length	int
)	O
{	O
static	O
char	O
padding	array
[	O
65536	int
]	O
;	O
size_t	long
n	long
,	O
remaining	long
;	O
char	O
*	O
wdata	pointer
=	O
data	pointer
;	O
for	O
(	O
remaining	long
=	O
length	int
;	O
remaining	long
>	O
0	int
;	O
remaining	long
-=	O
n	long
,	O
wdata	pointer
+=	O
n	long
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
bytes	long
+	O
remaining	long
>	O
tunnel	pointer
->	O
content_length	long
-	O
sizeof_header	long
&&	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
>	O
sizeof_header	long
)	O
n	long
=	O
tunnel	pointer
->	O
content_length	long
-	O
sizeof_header	long
-	O
tunnel	pointer
->	O
bytes	long
;	O
else	O
if	O
(	O
remaining	long
>	O
tunnel	pointer
->	O
content_length	long
-	O
sizeof_header	long
)	O
n	long
=	O
tunnel	pointer
->	O
content_length	long
-	O
sizeof_header	long
;	O
else	O
n	long
=	O
remaining	long
;	O
if	O
(	O
n	long
>	O
65535	int
)	O
n	long
=	O
65535	int
;	O
if	O
(	O
request	pointer
==	O
TUNNEL_PADDING	int
)	O
{	O
if	O
(	O
n	long
+	O
sizeof_header	long
>	O
remaining	long
)	O
n	long
=	O
remaining	long
-	O
sizeof_header	long
;	O
if	O
(	O
tunnel_write_request	function
(	O
tunnel	pointer
,	O
request	pointer
,	O
padding	array
,	O
n	long
)	O
==	O
-	O
1	int
)	O
break	O
;	O
n	long
+=	O
sizeof_header	long
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_write_request	function
(	O
tunnel	pointer
,	O
request	pointer
,	O
wdata	pointer
,	O
n	long
)	O
==	O
-	O
1	int
)	O
break	O
;	O
}	O
}	O
return	O
length	int
-	O
remaining	long
;	O
}	O
ssize_t	long
tunnel_write	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
void	O
*	O
data	pointer
,	O
size_t	long
length	int
)	O
{	O
ssize_t	long
n	long
;	O
n	long
=	O
tunnel_write_or_padding	function
(	O
tunnel	pointer
,	O
TUNNEL_DATA	int
,	O
data	pointer
,	O
length	int
)	O
;	O
tunnel	pointer
->	O
out_total_data	long
+=	O
length	int
;	O
log_verbose	function
(	O
"tunnel_write: out_total_data = %u"	pointer
,	O
tunnel	pointer
->	O
out_total_data	long
)	O
;	O
return	O
n	long
;	O
}	O
ssize_t	long
tunnel_padding	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
size_t	long
length	int
)	O
{	O
if	O
(	O
length	int
<	O
sizeof_header	long
+	O
1	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
tunnel_write_request	function
(	O
tunnel	pointer
,	O
TUNNEL_PAD1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
return	O
length	int
;	O
}	O
return	O
tunnel_write_or_padding	function
(	O
tunnel	pointer
,	O
TUNNEL_PADDING	int
,	O
NULL	O
,	O
length	int
)	O
;	O
}	O
int	O
tunnel_close	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
struct	O
pollfd	struct
p	pointer
;	O
char	O
buf	pointer
[	O
10240	int
]	O
;	O
ssize_t	long
n	long
;	O
if	O
(	O
tunnel	pointer
->	O
strict_content_length	int
)	O
{	O
log_debug	function
(	O
"tunnel_close: write padding (%d bytes)"	pointer
,	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
-	O
1	int
)	O
;	O
tunnel_padding	function
(	O
tunnel	pointer
,	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
-	O
1	int
)	O
;	O
}	O
log_debug	function
(	O
"tunnel_close: write TUNNEL_CLOSE request"	pointer
)	O
;	O
tunnel_write_request	function
(	O
tunnel	pointer
,	O
TUNNEL_CLOSE	int
,	O
NULL	O
,	O
0	int
)	O
;	O
tunnel_out_disconnect	function
(	O
tunnel	pointer
)	O
;	O
log_debug	function
(	O
"tunnel_close: reading trailing data from input ..."	pointer
)	O
;	O
p	pointer
.	O
fd	int
=	O
tunnel	pointer
->	O
in_fd	int
;	O
p	pointer
.	O
events	short
=	O
POLLIN	int
;	O
while	O
(	O
poll	function
(	O
&	O
p	pointer
,	O
1	int
,	O
READ_TRAIL_TIMEOUT	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
p	pointer
.	O
revents	short
&	O
POLLIN	int
)	O
{	O
n	long
=	O
read	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
log_annoying	function
(	O
"read (%d, %p, %d) = %d"	pointer
,	O
tunnel	pointer
->	O
in_fd	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
n	long
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
n	long
==	O
-	O
1	int
&&	O
errno	O
==	O
EAGAIN	int
)	O
continue	O
;	O
else	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
log_debug	function
(	O
"tunnel_close: ... error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
log_debug	function
(	O
"tunnel_close: ... done (tunnel closed)"	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
.	O
revents	short
&	O
POLLHUP	int
)	O
log_debug	function
(	O
"POLLHUP"	pointer
)	O
;	O
if	O
(	O
p	pointer
.	O
revents	short
&	O
POLLERR	int
)	O
log_debug	function
(	O
"POLLERR"	pointer
)	O
;	O
if	O
(	O
p	pointer
.	O
revents	short
&	O
POLLNVAL	int
)	O
log_debug	function
(	O
"POLLNVAL"	pointer
)	O
;	O
break	O
;	O
}	O
tunnel_in_disconnect	function
(	O
tunnel	pointer
)	O
;	O
tunnel	pointer
->	O
buf_len	long
=	O
0	int
;	O
tunnel	pointer
->	O
in_total_raw	long
=	O
0	int
;	O
tunnel	pointer
->	O
in_total_data	long
=	O
0	int
;	O
tunnel	pointer
->	O
out_total_raw	long
=	O
0	int
;	O
tunnel	pointer
->	O
out_total_data	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
tunnel_read_request	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
enum	O
tunnel_request	enum
*	O
request	pointer
,	O
unsigned	O
char	O
*	O
buf	pointer
,	O
size_t	long
*	O
length	int
)	O
{	O
Request	char
req	char
;	O
Length	short
len	long
;	O
ssize_t	long
n	long
;	O
log_annoying	function
(	O
"read (%d, %p, %d) ..."	pointer
,	O
tunnel	pointer
->	O
in_fd	int
,	O
&	O
req	char
,	O
1	int
)	O
;	O
n	long
=	O
read	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
&	O
req	char
,	O
1	int
)	O
;	O
log_annoying	function
(	O
"... = %d"	pointer
,	O
n	long
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EAGAIN	int
)	O
log_error	function
(	O
"tunnel_read_request: error reading request: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
n	long
;	O
}	O
else	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
log_debug	function
(	O
"tunnel_read_request: connection closed by peer"	pointer
)	O
;	O
tunnel_in_disconnect	function
(	O
tunnel	pointer
)	O
;	O
if	O
(	O
tunnel_is_client	function
(	O
tunnel	pointer
)	O
&&	O
tunnel_in_connect	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
request	pointer
=	O
req	char
;	O
tunnel	pointer
->	O
in_total_raw	long
+=	O
n	long
;	O
log_annoying	function
(	O
"request = 0x%x (%s)"	pointer
,	O
req	char
,	O
REQ_TO_STRING	function
(	O
req	char
)	O
)	O
;	O
if	O
(	O
req	char
&	O
TUNNEL_SIMPLE	int
)	O
{	O
log_annoying	function
(	O
"tunnel_read_request: in_total_raw = %u"	pointer
,	O
tunnel	pointer
->	O
in_total_raw	long
)	O
;	O
log_debug	function
(	O
"tunnel_read_request:  %s"	pointer
,	O
REQ_TO_STRING	function
(	O
req	char
)	O
)	O
;	O
*	O
length	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
n	long
=	O
read_all	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
&	O
len	long
,	O
2	int
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
log_error	function
(	O
"tunnel_read_request: error reading request length: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
len	long
=	O
ntohs	function
(	O
len	long
)	O
;	O
*	O
length	int
=	O
len	long
;	O
tunnel	pointer
->	O
in_total_raw	long
+=	O
n	long
;	O
log_annoying	function
(	O
"length = %d"	pointer
,	O
len	long
)	O
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
n	long
=	O
read_all	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
buf	pointer
,	O
(	O
size_t	long
)	O
len	long
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
log_error	function
(	O
"tunnel_read_request: error reading request data: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
tunnel	pointer
->	O
in_total_raw	long
+=	O
n	long
;	O
log_annoying	function
(	O
"tunnel_read_request: in_total_raw = %u"	pointer
,	O
tunnel	pointer
->	O
in_total_raw	long
)	O
;	O
}	O
if	O
(	O
req	char
==	O
TUNNEL_DATA	int
)	O
log_verbose	function
(	O
"tunnel_read_request:  %s (%d)"	pointer
,	O
REQ_TO_STRING	function
(	O
req	char
)	O
,	O
len	long
)	O
;	O
else	O
log_debug	function
(	O
"tunnel_read_request:  %s (%d)"	pointer
,	O
REQ_TO_STRING	function
(	O
req	char
)	O
,	O
len	long
)	O
;	O
return	O
1	int
;	O
}	O
ssize_t	long
tunnel_read	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
void	O
*	O
data	pointer
,	O
size_t	long
length	int
)	O
{	O
enum	O
tunnel_request	enum
req	char
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
if	O
(	O
tunnel	pointer
->	O
buf_len	long
>	O
0	int
)	O
{	O
n	long
=	O
min	O
(	O
tunnel	pointer
->	O
buf_len	long
,	O
length	int
)	O
;	O
memcpy	function
(	O
data	pointer
,	O
tunnel	pointer
->	O
buf_ptr	pointer
,	O
n	long
)	O
;	O
tunnel	pointer
->	O
buf_ptr	pointer
+=	O
n	long
;	O
tunnel	pointer
->	O
buf_len	long
-=	O
n	long
;	O
return	O
n	long
;	O
}	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
tunnel_is_client	function
(	O
tunnel	pointer
)	O
)	O
{	O
if	O
(	O
tunnel_in_connect	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_accept	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
&&	O
tunnel_is_server	function
(	O
tunnel	pointer
)	O
)	O
{	O
tunnel_accept	function
(	O
tunnel	pointer
)	O
;	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tunnel_read_request	function
(	O
tunnel	pointer
,	O
&	O
req	char
,	O
tunnel	pointer
->	O
buf	pointer
,	O
&	O
len	long
)	O
<=	O
0	int
)	O
{	O
log_annoying	function
(	O
"tunnel_read_request returned <= 0, returning -1"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
req	char
)	O
{	O
case	O
TUNNEL_OPEN	int
:	O
break	O
;	O
case	O
TUNNEL_DATA	int
:	O
tunnel	pointer
->	O
buf_ptr	pointer
=	O
tunnel	pointer
->	O
buf	pointer
;	O
tunnel	pointer
->	O
buf_len	long
=	O
len	long
;	O
tunnel	pointer
->	O
in_total_data	long
+=	O
len	long
;	O
log_verbose	function
(	O
"tunnel_read: in_total_data = %u"	pointer
,	O
tunnel	pointer
->	O
in_total_data	long
)	O
;	O
return	O
tunnel_read	function
(	O
tunnel	pointer
,	O
data	pointer
,	O
length	int
)	O
;	O
case	O
TUNNEL_PADDING	int
:	O
break	O
;	O
case	O
TUNNEL_PAD1	int
:	O
break	O
;	O
case	O
TUNNEL_ERROR	int
:	O
tunnel	pointer
->	O
buf	pointer
[	O
len	long
]	O
=	O
0	int
;	O
log_error	function
(	O
"tunnel_read: received error: %s"	pointer
,	O
tunnel	pointer
->	O
buf	pointer
)	O
;	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
case	O
TUNNEL_CLOSE	int
:	O
return	O
0	int
;	O
case	O
TUNNEL_DISCONNECT	int
:	O
tunnel_in_disconnect	function
(	O
tunnel	pointer
)	O
;	O
if	O
(	O
tunnel_is_client	function
(	O
tunnel	pointer
)	O
&&	O
tunnel_in_connect	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
default	O
:	O
log_error	function
(	O
"tunnel_read: protocol error: unknown request 0x%02x"	pointer
,	O
req	char
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
errno	O
=	O
EAGAIN	int
;	O
return	O
-	O
1	int
;	O
}	O
int	O
tunnel_pollin_fd	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
if	O
(	O
tunnel_is_server	function
(	O
tunnel	pointer
)	O
&&	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
||	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
)	O
log_verbose	function
(	O
"tunnel_pollin_fd: in_fd = -1; returning server_socket = %d"	pointer
,	O
tunnel	pointer
->	O
server_socket	function
)	O
;	O
else	O
log_verbose	function
(	O
"tunnel_pollin_fd: out_fd = -1; returning server_socket = %d"	pointer
,	O
tunnel	pointer
->	O
server_socket	function
)	O
;	O
return	O
tunnel	pointer
->	O
server_socket	function
;	O
}	O
else	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
!=	O
-	O
1	int
)	O
return	O
tunnel	pointer
->	O
in_fd	int
;	O
else	O
{	O
log_error	function
(	O
"tunnel_pollin_fd: returning -1"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
tunnel_maybe_pad	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
size_t	long
length	int
)	O
{	O
size_t	long
padding	array
;	O
if	O
(	O
tunnel_is_disconnected	function
(	O
tunnel	pointer
)	O
||	O
tunnel	pointer
->	O
bytes	long
%	O
length	int
==	O
0	int
||	O
tunnel	pointer
->	O
padding_only	int
)	O
return	O
0	int
;	O
padding	array
=	O
length	int
-	O
tunnel	pointer
->	O
bytes	long
%	O
length	int
;	O
if	O
(	O
padding	array
>	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
)	O
padding	array
=	O
tunnel	pointer
->	O
content_length	long
-	O
tunnel	pointer
->	O
bytes	long
;	O
return	O
tunnel_padding	function
(	O
tunnel	pointer
,	O
padding	array
)	O
;	O
}	O
int	O
tunnel_accept	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
!=	O
-	O
1	int
&&	O
tunnel	pointer
->	O
out_fd	int
!=	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"tunnel_accept: tunnel already established"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
||	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
struct	O
sockaddr_in	struct
addr	struct
;	O
Http_request	struct
*	O
request	pointer
;	O
struct	O
pollfd	struct
p	pointer
;	O
ssize_t	long
m	long
;	O
int	O
len	long
;	O
int	O
n	long
;	O
int	O
s	short
;	O
p	pointer
.	O
fd	int
=	O
tunnel	pointer
->	O
server_socket	function
;	O
p	pointer
.	O
events	short
=	O
POLLIN	int
;	O
n	long
=	O
poll	function
(	O
&	O
p	pointer
,	O
1	int
,	O
(	O
tunnel	pointer
->	O
in_fd	int
!=	O
-	O
1	int
||	O
tunnel	pointer
->	O
out_fd	int
!=	O
-	O
1	int
?	O
ACCEPT_TIMEOUT	int
*	O
1000	int
:	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_accept: poll error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
log_error	function
(	O
"tunnel_accept: poll timed out"	pointer
)	O
;	O
break	O
;	O
}	O
len	long
=	O
sizeof	O
addr	struct
;	O
s	short
=	O
accept	function
(	O
tunnel	pointer
->	O
server_socket	function
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
addr	struct
,	O
&	O
len	long
)	O
;	O
if	O
(	O
s	short
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_accept: accept error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
log_notice	function
(	O
"connection from %d.%d.%d.%d:%u"	pointer
,	O
ntohl	function
(	O
addr	struct
.	O
sin_addr	struct
.	O
s_addr	int
)	O
>>	O
24	int
,	O
(	O
ntohl	function
(	O
addr	struct
.	O
sin_addr	struct
.	O
s_addr	int
)	O
>>	O
16	int
)	O
&	O
0xff	int
,	O
(	O
ntohl	function
(	O
addr	struct
.	O
sin_addr	struct
.	O
s_addr	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
,	O
ntohl	function
(	O
addr	struct
.	O
sin_addr	struct
.	O
s_addr	int
)	O
&	O
0xff	int
,	O
ntohs	function
(	O
addr	struct
.	O
sin_port	short
)	O
)	O
;	O
m	long
=	O
http_parse_request	function
(	O
s	short
,	O
&	O
request	pointer
)	O
;	O
if	O
(	O
m	long
<=	O
0	int
)	O
return	O
m	long
;	O
if	O
(	O
request	pointer
->	O
method	enum
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_accept: error parsing header: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	function
(	O
s	short
)	O
;	O
}	O
else	O
if	O
(	O
request	pointer
->	O
method	enum
==	O
HTTP_POST	int
||	O
request	pointer
->	O
method	enum
==	O
HTTP_PUT	int
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
)	O
{	O
tunnel	pointer
->	O
in_fd	int
=	O
s	short
;	O
fcntl	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
F_SETFL	int
,	O
fcntl	function
(	O
tunnel	pointer
->	O
in_fd	int
,	O
F_GETFL	int
)	O
|	O
O_NONBLOCK	int
)	O
;	O
tunnel_in_setsockopts	function
(	O
tunnel	pointer
->	O
in_fd	int
)	O
;	O
log_debug	function
(	O
"tunnel_accept: input connected"	pointer
)	O
;	O
}	O
else	O
{	O
log_error	function
(	O
"rejected tunnel_in: already got a connection"	pointer
)	O
;	O
close	function
(	O
s	short
)	O
;	O
}	O
}	O
else	O
if	O
(	O
request	pointer
->	O
method	enum
==	O
HTTP_GET	int
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
char	O
str	pointer
[	O
1024	int
]	O
;	O
tunnel	pointer
->	O
out_fd	int
=	O
s	short
;	O
tunnel_out_setsockopts	function
(	O
tunnel	pointer
->	O
out_fd	int
)	O
;	O
sprintf	function
(	O
str	pointer
,	O
"HTTP/1.1 200 OK\r\n"	pointer
"Content-Length: %d\r\n"	pointer
"Connection: close\r\n"	pointer
"Pragma: no-cache\r\n"	pointer
"Cache-Control: no-cache, no-store, must-revalidate\r\n"	pointer
"Expires: 0\r\n"	pointer
"Content-Type: text/html\r\n"	pointer
"\r\n"	pointer
,	O
tunnel	pointer
->	O
content_length	long
+	O
1	int
)	O
;	O
if	O
(	O
write_all	function
(	O
tunnel	pointer
->	O
out_fd	int
,	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
)	O
<=	O
0	int
)	O
{	O
log_error	function
(	O
"tunnel_accept: couldn't write GET header: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	function
(	O
tunnel	pointer
->	O
out_fd	int
)	O
;	O
tunnel	pointer
->	O
out_fd	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
tunnel	pointer
->	O
bytes	long
=	O
0	int
;	O
tunnel	pointer
->	O
buf_len	long
=	O
0	int
;	O
tunnel	pointer
->	O
buf_ptr	pointer
=	O
tunnel	pointer
->	O
buf	pointer
;	O
log_debug	function
(	O
"tunnel_accept: output connected"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
log_error	function
(	O
"tunnel_accept: rejected tunnel_out: "	pointer
"already got a connection"	pointer
)	O
;	O
close	function
(	O
s	short
)	O
;	O
}	O
}	O
else	O
{	O
log_error	function
(	O
"tunnel_accept: unknown header type"	pointer
)	O
;	O
log_debug	function
(	O
"tunnel_accept: closing connection"	pointer
)	O
;	O
close	function
(	O
s	short
)	O
;	O
}	O
http_destroy_request	function
(	O
request	pointer
)	O
;	O
}	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
==	O
-	O
1	int
||	O
tunnel	pointer
->	O
out_fd	int
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_accept: in_fd = %d, out_fd = %d"	pointer
,	O
tunnel	pointer
->	O
in_fd	int
,	O
tunnel	pointer
->	O
out_fd	int
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
in_fd	int
!=	O
-	O
1	int
)	O
close	function
(	O
tunnel	pointer
->	O
in_fd	int
)	O
;	O
tunnel	pointer
->	O
in_fd	int
=	O
-	O
1	int
;	O
log_debug	function
(	O
"tunnel_accept: input disconnected"	pointer
)	O
;	O
tunnel_out_disconnect	function
(	O
tunnel	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
Tunnel	struct
*	O
tunnel_new_server	function
(	O
const	O
char	O
*	O
host	pointer
,	O
int	O
port	int
,	O
size_t	long
content_length	long
)	O
{	O
Tunnel	struct
*	O
tunnel	pointer
;	O
struct	O
in_addr	struct
addr	struct
;	O
struct	O
hostent	struct
*	O
hp	pointer
;	O
if	O
(	O
host	pointer
==	O
NULL	O
)	O
addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
else	O
if	O
(	O
(	O
addr	struct
.	O
s_addr	int
=	O
inet_addr	function
(	O
host	pointer
)	O
)	O
==	O
INADDR_NONE	O
)	O
{	O
hp	pointer
=	O
gethostbyname	function
(	O
host	pointer
)	O
;	O
if	O
(	O
hp	pointer
==	O
NULL	O
||	O
hp	pointer
->	O
h_addrtype	int
!=	O
AF_INET	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
&	O
addr	struct
,	O
hp	pointer
->	O
h_addr	O
,	O
hp	pointer
->	O
h_length	int
)	O
;	O
}	O
tunnel	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
Tunnel	struct
)	O
)	O
;	O
if	O
(	O
tunnel	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
content_length	long
==	O
0	int
)	O
content_length	long
=	O
DEFAULT_CONTENT_LENGTH	O
;	O
tunnel	pointer
->	O
in_fd	int
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
out_fd	int
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
server_socket	function
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
dest	short
.	O
host_name	pointer
=	O
host	pointer
;	O
tunnel	pointer
->	O
dest	short
.	O
host_port	int
=	O
port	int
;	O
tunnel	pointer
->	O
buf_ptr	pointer
=	O
tunnel	pointer
->	O
buf	pointer
;	O
tunnel	pointer
->	O
buf_len	long
=	O
0	int
;	O
tunnel	pointer
->	O
content_length	long
=	O
content_length	long
-	O
1	int
;	O
tunnel	pointer
->	O
in_total_raw	long
=	O
0	int
;	O
tunnel	pointer
->	O
in_total_data	long
=	O
0	int
;	O
tunnel	pointer
->	O
out_total_raw	long
=	O
0	int
;	O
tunnel	pointer
->	O
out_total_data	long
=	O
0	int
;	O
tunnel	pointer
->	O
strict_content_length	int
=	O
FALSE	int
;	O
tunnel	pointer
->	O
bytes	long
=	O
0	int
;	O
tunnel	pointer
->	O
server_socket	function
=	O
server_socket	function
(	O
addr	struct
,	O
tunnel	pointer
->	O
dest	short
.	O
host_port	int
,	O
1	int
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
server_socket	function
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_new_server: server_socket (%d) = -1"	pointer
,	O
tunnel	pointer
->	O
dest	short
.	O
host_port	int
)	O
;	O
tunnel_destroy	function
(	O
tunnel	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
tunnel	pointer
;	O
}	O
Tunnel	struct
*	O
tunnel_new_client	function
(	O
const	O
char	O
*	O
host	pointer
,	O
int	O
host_port	int
,	O
const	O
char	O
*	O
proxy	pointer
,	O
int	O
proxy_port	int
,	O
size_t	long
content_length	long
)	O
{	O
const	O
char	O
*	O
remote	pointer
;	O
int	O
remote_port	int
;	O
Tunnel	struct
*	O
tunnel	pointer
;	O
log_verbose	function
(	O
"tunnel_new_client (\"%s\", %d, \"%s\", %d, %d)"	pointer
,	O
host	pointer
,	O
host_port	int
,	O
proxy	pointer
?	O
proxy	pointer
:	O
"(null)"	pointer
,	O
proxy_port	int
,	O
content_length	long
)	O
;	O
tunnel	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
Tunnel	struct
)	O
)	O
;	O
if	O
(	O
tunnel	pointer
==	O
NULL	O
)	O
{	O
log_error	function
(	O
"tunnel_new_client: out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
tunnel	pointer
->	O
in_fd	int
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
out_fd	int
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
server_socket	function
=	O
-	O
1	int
;	O
tunnel	pointer
->	O
dest	short
.	O
host_name	pointer
=	O
host	pointer
;	O
tunnel	pointer
->	O
dest	short
.	O
host_port	int
=	O
host_port	int
;	O
tunnel	pointer
->	O
dest	short
.	O
proxy_name	pointer
=	O
proxy	pointer
;	O
tunnel	pointer
->	O
dest	short
.	O
proxy_port	int
=	O
proxy_port	int
;	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
=	O
NULL	O
;	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
=	O
NULL	O
;	O
tunnel	pointer
->	O
content_length	long
=	O
content_length	long
-	O
1	int
;	O
tunnel	pointer
->	O
buf_ptr	pointer
=	O
tunnel	pointer
->	O
buf	pointer
;	O
tunnel	pointer
->	O
buf_len	long
=	O
0	int
;	O
tunnel	pointer
->	O
in_total_raw	long
=	O
0	int
;	O
tunnel	pointer
->	O
in_total_data	long
=	O
0	int
;	O
tunnel	pointer
->	O
out_total_raw	long
=	O
0	int
;	O
tunnel	pointer
->	O
out_total_data	long
=	O
0	int
;	O
tunnel	pointer
->	O
strict_content_length	int
=	O
FALSE	int
;	O
tunnel	pointer
->	O
bytes	long
=	O
0	int
;	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
proxy_name	pointer
==	O
NULL	O
)	O
{	O
remote	pointer
=	O
tunnel	pointer
->	O
dest	short
.	O
host_name	pointer
;	O
remote_port	int
=	O
tunnel	pointer
->	O
dest	short
.	O
host_port	int
;	O
}	O
else	O
{	O
remote	pointer
=	O
tunnel	pointer
->	O
dest	short
.	O
proxy_name	pointer
;	O
remote_port	int
=	O
tunnel	pointer
->	O
dest	short
.	O
proxy_port	int
;	O
}	O
if	O
(	O
set_address	function
(	O
&	O
tunnel	pointer
->	O
address	long
,	O
remote	pointer
,	O
remote_port	int
)	O
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"tunnel_new_client: set_address: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
tunnel	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
tunnel	pointer
;	O
}	O
void	O
tunnel_destroy	function
(	O
Tunnel	struct
*	O
tunnel	pointer
)	O
{	O
if	O
(	O
tunnel_is_connected	function
(	O
tunnel	pointer
)	O
||	O
tunnel	pointer
->	O
in_fd	int
!=	O
-	O
1	int
)	O
tunnel_close	function
(	O
tunnel	pointer
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
server_socket	function
!=	O
-	O
1	int
)	O
close	function
(	O
tunnel	pointer
->	O
server_socket	function
)	O
;	O
free	function
(	O
tunnel	pointer
)	O
;	O
}	O
static	O
int	O
tunnel_opt	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
const	O
char	O
*	O
opt	pointer
,	O
void	O
*	O
data	pointer
,	O
int	O
get_flag	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
opt	pointer
,	O
"strict_content_length"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
*	O
(	O
int	O
*	O
)	O
data	pointer
=	O
tunnel	pointer
->	O
strict_content_length	int
;	O
else	O
tunnel	pointer
->	O
strict_content_length	int
=	O
*	O
(	O
int	O
*	O
)	O
data	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
opt	pointer
,	O
"keep_alive"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
*	O
(	O
int	O
*	O
)	O
data	pointer
=	O
tunnel	pointer
->	O
keep_alive	int
;	O
else	O
tunnel	pointer
->	O
keep_alive	int
=	O
*	O
(	O
int	O
*	O
)	O
data	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
opt	pointer
,	O
"max_connection_age"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
*	O
(	O
int	O
*	O
)	O
data	pointer
=	O
tunnel	pointer
->	O
max_connection_age	int
;	O
else	O
tunnel	pointer
->	O
max_connection_age	int
=	O
*	O
(	O
int	O
*	O
)	O
data	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
opt	pointer
,	O
"proxy_authorization"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
==	O
NULL	O
)	O
*	O
(	O
char	O
*	O
*	O
)	O
data	pointer
=	O
NULL	O
;	O
else	O
*	O
(	O
char	O
*	O
*	O
)	O
data	pointer
=	O
strdup	function
(	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
!=	O
NULL	O
)	O
free	function
(	O
(	O
char	O
*	O
)	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
)	O
;	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
=	O
strdup	function
(	O
(	O
char	O
*	O
)	O
data	pointer
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
proxy_authorization	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
opt	pointer
,	O
"user_agent"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
get_flag	int
)	O
{	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
==	O
NULL	O
)	O
*	O
(	O
char	O
*	O
*	O
)	O
data	pointer
=	O
NULL	O
;	O
else	O
*	O
(	O
char	O
*	O
*	O
)	O
data	pointer
=	O
strdup	function
(	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
!=	O
NULL	O
)	O
free	function
(	O
(	O
char	O
*	O
)	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
)	O
;	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
=	O
strdup	function
(	O
(	O
char	O
*	O
)	O
data	pointer
)	O
;	O
if	O
(	O
tunnel	pointer
->	O
dest	short
.	O
user_agent	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
tunnel_setopt	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
const	O
char	O
*	O
opt	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
return	O
tunnel_opt	function
(	O
tunnel	pointer
,	O
opt	pointer
,	O
data	pointer
,	O
FALSE	int
)	O
;	O
}	O
int	O
tunnel_getopt	function
(	O
Tunnel	struct
*	O
tunnel	pointer
,	O
const	O
char	O
*	O
opt	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
return	O
tunnel_opt	function
(	O
tunnel	pointer
,	O
opt	pointer
,	O
data	pointer
,	O
TRUE	int
)	O
;	O
}	O