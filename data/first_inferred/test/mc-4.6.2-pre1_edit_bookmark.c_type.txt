static	O
inline	O
struct	O
_book_mark	struct
*	O
double_marks	function
(	O
WEdit	struct
*	O
edit	*
,	O
struct	O
_book_mark	struct
*	O
p	*
)	O
{	O
(	O
void	O
)	O
edit	O
;	O
if	O
(	O
p	*
->	O
next	*
)	O
while	O
(	O
p	*
->	O
next	*
->	O
line	*
==	O
p	*
->	O
line	*
)	O
p	*
=	O
p	*
->	O
next	*
;	O
return	O
p	*
;	O
}	O
struct	O
_book_mark	struct
*	O
book_mark_find	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
line	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
;	O
if	O
(	O
!	O
edit	*
->	O
book_mark	int
)	O
{	O
edit	*
->	O
book_mark	*
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
_book_mark	struct
)	O
)	O
;	O
edit	*
->	O
book_mark	*
->	O
line	int
=	O
-	O
1	int
;	O
return	O
edit	*
->	O
book_mark	int
;	O
}	O
for	O
(	O
p	*
=	O
edit	*
->	O
book_mark	*
;	O
p	*
;	O
p	*
=	O
p	*
->	O
next	*
)	O
{	O
if	O
(	O
p	*
->	O
line	int
>	O
line	*
)	O
break	O
;	O
if	O
(	O
p	*
->	O
line	int
<=	O
line	*
)	O
{	O
if	O
(	O
p	*
->	O
next	*
)	O
{	O
if	O
(	O
p	*
->	O
next	*
->	O
line	array
>	O
line	array
)	O
{	O
edit	*
->	O
book_mark	*
=	O
p	*
;	O
return	O
double_marks	function
(	O
edit	*
,	O
p	*
)	O
;	O
}	O
}	O
else	O
{	O
edit	*
->	O
book_mark	*
=	O
p	*
;	O
return	O
double_marks	function
(	O
edit	*
,	O
p	*
)	O
;	O
}	O
}	O
}	O
for	O
(	O
p	*
=	O
edit	*
->	O
book_mark	*
;	O
p	*
;	O
p	*
=	O
p	*
->	O
prev	*
)	O
{	O
if	O
(	O
p	*
->	O
next	*
)	O
if	O
(	O
p	*
->	O
next	*
->	O
line	*
<=	O
line	*
)	O
break	O
;	O
if	O
(	O
p	*
->	O
line	int
<=	O
line	*
)	O
{	O
if	O
(	O
p	*
->	O
next	*
)	O
{	O
if	O
(	O
p	*
->	O
next	*
->	O
line	array
>	O
line	array
)	O
{	O
edit	*
->	O
book_mark	*
=	O
p	*
;	O
return	O
double_marks	function
(	O
edit	*
,	O
p	*
)	O
;	O
}	O
}	O
else	O
{	O
edit	*
->	O
book_mark	*
=	O
p	*
;	O
return	O
double_marks	function
(	O
edit	*
,	O
p	*
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
book_mark_query_color	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
line	int
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
;	O
if	O
(	O
!	O
edit	*
->	O
book_mark	*
)	O
return	O
0	int
;	O
for	O
(	O
p	*
=	O
book_mark_find	function
(	O
edit	*
,	O
line	*
)	O
;	O
p	*
;	O
p	*
=	O
p	*
->	O
prev	*
)	O
{	O
if	O
(	O
p	*
->	O
line	int
!=	O
line	*
)	O
return	O
0	int
;	O
if	O
(	O
p	*
->	O
c	int
==	O
c	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
book_mark_insert	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
line	int
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
,	O
*	O
q	*
;	O
p	*
=	O
book_mark_find	function
(	O
edit	*
,	O
line	int
)	O
;	O
edit	*
->	O
force	int
|=	O
REDRAW_LINE	int
;	O
q	int
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
_book_mark	struct
)	O
)	O
;	O
q	*
->	O
line	*
=	O
line	*
;	O
q	*
->	O
c	int
=	O
c	int
;	O
q	*
->	O
next	*
=	O
p	*
->	O
next	*
;	O
q	*
->	O
prev	*
=	O
p	*
;	O
if	O
(	O
p	*
->	O
next	*
)	O
p	*
->	O
next	*
->	O
prev	*
=	O
q	*
;	O
p	*
->	O
next	*
=	O
q	*
;	O
}	O
int	O
book_mark_clear	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
line	int
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
,	O
*	O
q	*
;	O
int	O
r	int
=	O
1	int
;	O
if	O
(	O
!	O
edit	*
->	O
book_mark	*
)	O
return	O
r	int
;	O
for	O
(	O
p	*
=	O
book_mark_find	function
(	O
edit	*
,	O
line	*
)	O
;	O
p	*
;	O
p	*
=	O
q	*
)	O
{	O
q	*
=	O
p	*
->	O
prev	*
;	O
if	O
(	O
p	*
->	O
line	int
==	O
line	*
&&	O
(	O
p	*
->	O
c	int
==	O
c	int
||	O
c	int
==	O
-	O
1	int
)	O
)	O
{	O
r	int
=	O
0	int
;	O
edit	*
->	O
force	enum
|=	O
REDRAW_LINE	int
;	O
edit	*
->	O
book_mark	*
=	O
p	*
->	O
prev	*
;	O
p	*
->	O
prev	*
->	O
next	*
=	O
p	*
->	O
next	*
;	O
if	O
(	O
p	*
->	O
next	*
)	O
p	*
->	O
next	*
->	O
prev	*
=	O
p	*
->	O
prev	*
;	O
g_free	function
(	O
p	*
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
edit	*
->	O
book_mark	*
->	O
line	int
==	O
-	O
1	int
&&	O
!	O
edit	*
->	O
book_mark	*
->	O
next	*
)	O
{	O
g_free	function
(	O
edit	*
->	O
book_mark	*
)	O
;	O
edit	*
->	O
book_mark	int
=	O
0	int
;	O
}	O
return	O
r	*
;	O
}	O
void	O
book_mark_flush	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
,	O
*	O
q	*
;	O
if	O
(	O
!	O
edit	*
->	O
book_mark	*
)	O
return	O
;	O
edit	*
->	O
force	int
|=	O
REDRAW_PAGE	int
;	O
while	O
(	O
edit	*
->	O
book_mark	*
->	O
prev	*
)	O
edit	*
->	O
book_mark	*
=	O
edit	*
->	O
book_mark	*
->	O
prev	*
;	O
for	O
(	O
q	*
=	O
edit	*
->	O
book_mark	*
->	O
next	*
;	O
q	*
;	O
q	*
=	O
p	*
)	O
{	O
p	*
=	O
q	*
->	O
next	*
;	O
if	O
(	O
q	*
->	O
c	char
==	O
c	int
||	O
c	int
==	O
-	O
1	int
)	O
{	O
q	*
->	O
prev	*
->	O
next	*
=	O
q	*
->	O
next	*
;	O
if	O
(	O
p	*
)	O
p	*
->	O
prev	*
=	O
q	*
->	O
prev	*
;	O
g_free	function
(	O
q	*
)	O
;	O
}	O
}	O
if	O
(	O
!	O
edit	*
->	O
book_mark	*
->	O
next	*
)	O
{	O
g_free	function
(	O
edit	*
->	O
book_mark	*
)	O
;	O
edit	*
->	O
book_mark	int
=	O
0	int
;	O
}	O
}	O
void	O
book_mark_inc	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
line	int
)	O
{	O
if	O
(	O
edit	*
->	O
book_mark	*
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
;	O
p	*
=	O
book_mark_find	function
(	O
edit	*
,	O
line	int
)	O
;	O
for	O
(	O
p	*
=	O
p	*
->	O
next	*
;	O
p	*
;	O
p	*
=	O
p	*
->	O
next	*
)	O
{	O
p	*
->	O
line	array
++	O
;	O
}	O
}	O
}	O
void	O
book_mark_dec	function
(	O
WEdit	struct
*	O
edit	*
,	O
int	O
line	int
)	O
{	O
if	O
(	O
edit	*
->	O
book_mark	*
)	O
{	O
struct	O
_book_mark	struct
*	O
p	*
;	O
p	*
=	O
book_mark_find	function
(	O
edit	*
,	O
line	int
)	O
;	O
for	O
(	O
p	*
=	O
p	*
->	O
next	*
;	O
p	*
;	O
p	*
=	O
p	*
->	O
next	*
)	O
{	O
p	*
->	O
line	array
--	O
;	O
}	O
}	O
}	O