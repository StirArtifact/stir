struct	O
key_word	struct
{	O
char	O
*	O
keyword	short
;	O
unsigned	O
char	O
first	pointer
;	O
char	O
*	O
whole_word_chars_left	pointer
;	O
char	O
*	O
whole_word_chars_right	pointer
;	O
int	O
line_start	int
;	O
int	O
color	pointer
;	O
}	O
;	O
struct	O
context_rule	struct
{	O
char	O
*	O
left	pointer
;	O
unsigned	O
char	O
first_left	char
;	O
char	O
*	O
right	pointer
;	O
unsigned	O
char	O
first_right	char
;	O
char	O
line_start_left	char
;	O
char	O
line_start_right	char
;	O
int	O
between_delimiters	int
;	O
char	O
*	O
whole_word_chars_left	pointer
;	O
char	O
*	O
whole_word_chars_right	pointer
;	O
char	O
*	O
keyword_first_chars	pointer
;	O
int	O
spelling	int
;	O
struct	O
key_word	struct
*	O
*	O
keyword	short
;	O
}	O
;	O
struct	O
_syntax_marker	struct
{	O
long	O
offset	long
;	O
struct	O
syntax_rule	struct
rule	struct
;	O
struct	O
_syntax_marker	struct
*	O
next	pointer
;	O
}	O
;	O
int	O
option_syntax_highlighting	int
=	O
1	int
;	O
int	O
option_auto_syntax	int
=	O
1	int
;	O
char	O
*	O
option_syntax_type	pointer
=	O
NULL	O
;	O
static	O
gint	int
mc_defines_destroy	function
(	O
gpointer	pointer
key	pointer
,	O
gpointer	pointer
value	pointer
,	O
gpointer	pointer
data	pointer
)	O
{	O
char	O
*	O
*	O
values	pointer
=	O
value	pointer
;	O
(	O
void	O
)	O
data	pointer
;	O
g_free	function
(	O
key	pointer
)	O
;	O
while	O
(	O
*	O
values	pointer
)	O
g_free	function
(	O
*	O
values	pointer
++	O
)	O
;	O
g_free	function
(	O
value	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
inline	O
void	O
destroy_defines	function
(	O
GTree	struct
*	O
*	O
defines	pointer
)	O
{	O
g_tree_traverse	function
(	O
*	O
defines	pointer
,	O
mc_defines_destroy	function
,	O
G_POST_ORDER	int
,	O
NULL	O
)	O
;	O
g_tree_destroy	function
(	O
*	O
defines	pointer
)	O
;	O
*	O
defines	pointer
=	O
0	int
;	O
}	O
static	O
void	O
subst_defines	function
(	O
GTree	struct
*	O
defines	pointer
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
argv_end	pointer
)	O
{	O
char	O
*	O
*	O
t	long
,	O
*	O
*	O
p	pointer
;	O
int	O
argc	pointer
;	O
while	O
(	O
*	O
argv	pointer
&&	O
argv	pointer
<	O
argv_end	pointer
)	O
{	O
if	O
(	O
(	O
t	long
=	O
g_tree_lookup	function
(	O
defines	pointer
,	O
*	O
argv	pointer
)	O
)	O
)	O
{	O
int	O
count	int
=	O
0	int
;	O
argc	pointer
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
&	O
argv	pointer
[	O
1	int
]	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
argc	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
t	long
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
count	int
++	O
;	O
p	pointer
=	O
&	O
argv	pointer
[	O
count	int
+	O
argc	pointer
]	O
;	O
if	O
(	O
p	pointer
>=	O
argv_end	pointer
)	O
break	O
;	O
while	O
(	O
argc	pointer
>=	O
0	int
)	O
*	O
p	pointer
--	O
=	O
argv	pointer
[	O
argc	pointer
--	O
+	O
1	int
]	O
;	O
for	O
(	O
p	pointer
=	O
argv	pointer
;	O
*	O
t	long
;	O
*	O
p	pointer
++	O
=	O
*	O
t	long
++	O
)	O
;	O
}	O
argv	pointer
++	O
;	O
}	O
}	O
static	O
long	O
compare_word_to_right	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
i	array
,	O
const	O
char	O
*	O
text	pointer
,	O
const	O
char	O
*	O
whole_left	pointer
,	O
const	O
char	O
*	O
whole_right	pointer
,	O
int	O
line_start	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
int	O
c	int
,	O
d	double
,	O
j	int
;	O
if	O
(	O
!	O
*	O
text	pointer
)	O
return	O
-	O
1	int
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
-	O
1	int
)	O
;	O
if	O
(	O
line_start	int
)	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
whole_left	pointer
)	O
if	O
(	O
strchr	function
(	O
whole_left	pointer
,	O
c	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
text	pointer
,	O
q	pointer
=	O
p	pointer
+	O
strlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
<	O
q	pointer
;	O
p	pointer
++	O
,	O
i	array
++	O
)	O
{	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
SYNTAX_TOKEN_STAR	char
:	O
if	O
(	O
++	O
p	pointer
>	O
q	pointer
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
if	O
(	O
whole_right	pointer
)	O
if	O
(	O
!	O
strchr	function
(	O
whole_right	pointer
,	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
*	O
p	pointer
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
return	O
-	O
1	int
;	O
i	array
++	O
;	O
}	O
break	O
;	O
case	O
SYNTAX_TOKEN_PLUS	char
:	O
if	O
(	O
++	O
p	pointer
>	O
q	pointer
)	O
return	O
-	O
1	int
;	O
j	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
if	O
(	O
c	int
==	O
*	O
p	pointer
)	O
{	O
j	int
=	O
i	array
;	O
if	O
(	O
*	O
p	pointer
==	O
*	O
text	pointer
&&	O
!	O
p	pointer
[	O
1	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
&&	O
strchr	function
(	O
(	O
char	O
*	O
)	O
p	pointer
+	O
1	int
,	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
' '	O
)	O
{	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
i	array
--	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
j	int
)	O
return	O
-	O
1	int
;	O
i	array
=	O
j	int
;	O
break	O
;	O
}	O
if	O
(	O
whole_right	pointer
)	O
if	O
(	O
!	O
strchr	function
(	O
whole_right	pointer
,	O
c	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
i	array
--	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
j	int
)	O
return	O
-	O
1	int
;	O
i	array
=	O
j	int
;	O
break	O
;	O
}	O
i	array
++	O
;	O
}	O
break	O
;	O
case	O
SYNTAX_TOKEN_BRACKET	char
:	O
if	O
(	O
++	O
p	pointer
>	O
q	pointer
)	O
return	O
-	O
1	int
;	O
c	int
=	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
i	array
++	O
)	O
{	O
d	double
=	O
c	int
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
p	pointer
[	O
j	int
]	O
!=	O
SYNTAX_TOKEN_BRACKET	char
&&	O
p	pointer
[	O
j	int
]	O
;	O
j	int
++	O
)	O
if	O
(	O
c	int
==	O
p	pointer
[	O
j	int
]	O
)	O
goto	O
found_char2	O
;	O
break	O
;	O
found_char2	O
:	O
;	O
}	O
i	array
--	O
;	O
while	O
(	O
*	O
p	pointer
!=	O
SYNTAX_TOKEN_BRACKET	char
&&	O
p	pointer
<=	O
q	pointer
)	O
p	pointer
++	O
;	O
if	O
(	O
p	pointer
>	O
q	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
d	double
)	O
i	array
--	O
;	O
break	O
;	O
case	O
SYNTAX_TOKEN_BRACE	char
:	O
if	O
(	O
++	O
p	pointer
>	O
q	pointer
)	O
return	O
-	O
1	int
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
for	O
(	O
;	O
*	O
p	pointer
!=	O
SYNTAX_TOKEN_BRACE	char
&&	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
c	int
==	O
*	O
p	pointer
)	O
goto	O
found_char3	O
;	O
return	O
-	O
1	int
;	O
found_char3	O
:	O
while	O
(	O
*	O
p	pointer
!=	O
SYNTAX_TOKEN_BRACE	char
&&	O
p	pointer
<	O
q	pointer
)	O
p	pointer
++	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
*	O
p	pointer
!=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
whole_right	pointer
)	O
if	O
(	O
strchr	function
(	O
whole_right	pointer
,	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
i	array
;	O
}	O
static	O
inline	O
const	O
char	O
*	O
xx_strchr	function
(	O
const	O
unsigned	O
char	O
*	O
s	pointer
,	O
int	O
c	int
)	O
{	O
while	O
(	O
*	O
s	pointer
>=	O
'\005'	O
&&	O
*	O
s	pointer
!=	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
{	O
s	pointer
++	O
;	O
}	O
return	O
(	O
const	O
char	O
*	O
)	O
s	pointer
;	O
}	O
static	O
inline	O
struct	O
syntax_rule	struct
apply_rules_going_right	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
i	array
,	O
struct	O
syntax_rule	struct
rule	struct
)	O
{	O
struct	O
context_rule	struct
*	O
r	pointer
;	O
int	O
contextchanged	int
=	O
0	int
,	O
c	int
;	O
int	O
found_right	int
=	O
0	int
,	O
found_left	int
=	O
0	int
,	O
keyword_foundleft	int
=	O
0	int
,	O
keyword_foundright	int
=	O
0	int
;	O
int	O
is_end	int
;	O
long	O
end	pointer
=	O
0	int
;	O
struct	O
syntax_rule	struct
_rule	struct
=	O
rule	struct
;	O
if	O
(	O
!	O
(	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
)	O
)	O
return	O
rule	struct
;	O
is_end	int
=	O
(	O
rule	struct
.	O
end	pointer
==	O
(	O
unsigned	O
char	O
)	O
i	array
)	O
;	O
if	O
(	O
_rule	struct
.	O
keyword	short
)	O
{	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
-	O
1	int
)	O
==	O
'\n'	O
)	O
_rule	struct
.	O
keyword	short
=	O
0	int
;	O
if	O
(	O
is_end	int
)	O
{	O
_rule	struct
.	O
keyword	short
=	O
0	int
;	O
keyword_foundleft	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
_rule	struct
.	O
context	pointer
&&	O
!	O
_rule	struct
.	O
keyword	short
)	O
{	O
long	O
e	pointer
;	O
r	pointer
=	O
edit	pointer
->	O
rules	pointer
[	O
_rule	struct
.	O
context	pointer
]	O
;	O
if	O
(	O
r	pointer
->	O
first_right	char
==	O
c	int
&&	O
!	O
(	O
rule	struct
.	O
border	char
&	O
RULE_ON_RIGHT_BORDER	int
)	O
&&	O
(	O
e	pointer
=	O
compare_word_to_right	function
(	O
edit	pointer
,	O
i	array
,	O
r	pointer
->	O
right	pointer
,	O
r	pointer
->	O
whole_word_chars_left	pointer
,	O
r	pointer
->	O
whole_word_chars_right	pointer
,	O
r	pointer
->	O
line_start_right	char
)	O
)	O
>	O
0	int
)	O
{	O
_rule	struct
.	O
end	pointer
=	O
e	pointer
;	O
found_right	int
=	O
1	int
;	O
_rule	struct
.	O
border	char
=	O
RULE_ON_RIGHT_BORDER	int
;	O
if	O
(	O
r	pointer
->	O
between_delimiters	int
)	O
_rule	struct
.	O
context	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
is_end	int
&&	O
rule	struct
.	O
border	char
&	O
RULE_ON_RIGHT_BORDER	int
)	O
{	O
found_left	int
=	O
1	int
;	O
_rule	struct
.	O
border	char
=	O
0	int
;	O
if	O
(	O
!	O
keyword_foundleft	int
)	O
_rule	struct
.	O
context	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
is_end	int
&&	O
rule	struct
.	O
border	char
&	O
RULE_ON_LEFT_BORDER	int
)	O
{	O
found_left	int
=	O
1	int
;	O
_rule	struct
.	O
border	char
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
_rule	struct
.	O
keyword	short
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
(	O
r	pointer
=	O
edit	pointer
->	O
rules	pointer
[	O
_rule	struct
.	O
context	pointer
]	O
)	O
->	O
keyword_first_chars	pointer
;	O
if	O
(	O
p	pointer
)	O
while	O
(	O
*	O
(	O
p	pointer
=	O
xx_strchr	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
p	pointer
+	O
1	int
,	O
c	int
)	O
)	O
)	O
{	O
struct	O
key_word	struct
*	O
k	int
;	O
int	O
count	int
;	O
long	O
e	pointer
;	O
count	int
=	O
p	pointer
-	O
r	pointer
->	O
keyword_first_chars	pointer
;	O
k	int
=	O
r	pointer
->	O
keyword	short
[	O
count	int
]	O
;	O
e	pointer
=	O
compare_word_to_right	function
(	O
edit	pointer
,	O
i	array
,	O
k	int
->	O
keyword	short
,	O
k	int
->	O
whole_word_chars_left	pointer
,	O
k	int
->	O
whole_word_chars_right	pointer
,	O
k	int
->	O
line_start	int
)	O
;	O
if	O
(	O
e	pointer
>	O
0	int
)	O
{	O
end	pointer
=	O
e	pointer
;	O
_rule	struct
.	O
end	pointer
=	O
e	pointer
;	O
_rule	struct
.	O
keyword	short
=	O
count	int
;	O
keyword_foundright	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
_rule	struct
.	O
context	pointer
)	O
{	O
if	O
(	O
!	O
found_left	int
&&	O
is_end	int
)	O
{	O
if	O
(	O
rule	struct
.	O
border	char
&	O
RULE_ON_RIGHT_BORDER	int
)	O
{	O
_rule	struct
.	O
border	char
=	O
0	int
;	O
_rule	struct
.	O
context	pointer
=	O
0	int
;	O
contextchanged	int
=	O
1	int
;	O
_rule	struct
.	O
keyword	short
=	O
0	int
;	O
}	O
else	O
if	O
(	O
rule	struct
.	O
border	char
&	O
RULE_ON_LEFT_BORDER	int
)	O
{	O
r	pointer
=	O
edit	pointer
->	O
rules	pointer
[	O
_rule	struct
.	O
_context	char
]	O
;	O
_rule	struct
.	O
border	char
=	O
0	int
;	O
if	O
(	O
r	pointer
->	O
between_delimiters	int
)	O
{	O
long	O
e	pointer
;	O
_rule	struct
.	O
context	pointer
=	O
_rule	struct
.	O
_context	char
;	O
contextchanged	int
=	O
1	int
;	O
_rule	struct
.	O
keyword	short
=	O
0	int
;	O
if	O
(	O
r	pointer
->	O
first_right	char
==	O
c	int
&&	O
(	O
e	pointer
=	O
compare_word_to_right	function
(	O
edit	pointer
,	O
i	array
,	O
r	pointer
->	O
right	pointer
,	O
r	pointer
->	O
whole_word_chars_left	pointer
,	O
r	pointer
->	O
whole_word_chars_right	pointer
,	O
r	pointer
->	O
line_start_right	char
)	O
)	O
>=	O
end	pointer
)	O
{	O
_rule	struct
.	O
end	pointer
=	O
e	pointer
;	O
found_right	int
=	O
1	int
;	O
_rule	struct
.	O
border	char
=	O
RULE_ON_RIGHT_BORDER	int
;	O
_rule	struct
.	O
context	pointer
=	O
0	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
found_right	int
)	O
{	O
int	O
count	int
;	O
struct	O
context_rule	struct
*	O
*	O
rules	pointer
=	O
edit	pointer
->	O
rules	pointer
;	O
for	O
(	O
count	int
=	O
1	int
;	O
rules	pointer
[	O
count	int
]	O
;	O
count	int
++	O
)	O
{	O
r	pointer
=	O
rules	pointer
[	O
count	int
]	O
;	O
if	O
(	O
r	pointer
->	O
first_left	char
==	O
c	int
)	O
{	O
long	O
e	pointer
;	O
e	pointer
=	O
compare_word_to_right	function
(	O
edit	pointer
,	O
i	array
,	O
r	pointer
->	O
left	pointer
,	O
r	pointer
->	O
whole_word_chars_left	pointer
,	O
r	pointer
->	O
whole_word_chars_right	pointer
,	O
r	pointer
->	O
line_start_left	char
)	O
;	O
if	O
(	O
e	pointer
>=	O
end	pointer
&&	O
(	O
!	O
_rule	struct
.	O
keyword	short
||	O
keyword_foundright	int
)	O
)	O
{	O
_rule	struct
.	O
end	pointer
=	O
e	pointer
;	O
found_right	int
=	O
1	int
;	O
_rule	struct
.	O
border	char
=	O
RULE_ON_LEFT_BORDER	int
;	O
_rule	struct
.	O
_context	char
=	O
count	int
;	O
if	O
(	O
!	O
r	pointer
->	O
between_delimiters	int
)	O
if	O
(	O
!	O
_rule	struct
.	O
keyword	short
)	O
{	O
_rule	struct
.	O
context	pointer
=	O
count	int
;	O
contextchanged	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
contextchanged	int
&&	O
!	O
_rule	struct
.	O
keyword	short
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
(	O
r	pointer
=	O
edit	pointer
->	O
rules	pointer
[	O
_rule	struct
.	O
context	pointer
]	O
)	O
->	O
keyword_first_chars	pointer
;	O
while	O
(	O
*	O
(	O
p	pointer
=	O
xx_strchr	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
p	pointer
+	O
1	int
,	O
c	int
)	O
)	O
)	O
{	O
struct	O
key_word	struct
*	O
k	int
;	O
int	O
count	int
;	O
long	O
e	pointer
;	O
count	int
=	O
p	pointer
-	O
r	pointer
->	O
keyword_first_chars	pointer
;	O
k	int
=	O
r	pointer
->	O
keyword	short
[	O
count	int
]	O
;	O
e	pointer
=	O
compare_word_to_right	function
(	O
edit	pointer
,	O
i	array
,	O
k	int
->	O
keyword	short
,	O
k	int
->	O
whole_word_chars_left	pointer
,	O
k	int
->	O
whole_word_chars_right	pointer
,	O
k	int
->	O
line_start	int
)	O
;	O
if	O
(	O
e	pointer
>	O
0	int
)	O
{	O
_rule	struct
.	O
end	pointer
=	O
e	pointer
;	O
_rule	struct
.	O
keyword	short
=	O
count	int
;	O
break	O
;	O
}	O
}	O
}	O
return	O
_rule	struct
;	O
}	O
static	O
struct	O
syntax_rule	struct
edit_get_rule	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
byte_index	long
)	O
{	O
long	O
i	array
;	O
if	O
(	O
byte_index	long
>	O
edit	pointer
->	O
last_get_rule	long
)	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
last_get_rule	long
+	O
1	int
;	O
i	array
<=	O
byte_index	long
;	O
i	array
++	O
)	O
{	O
edit	pointer
->	O
rule	struct
=	O
apply_rules_going_right	function
(	O
edit	pointer
,	O
i	array
,	O
edit	pointer
->	O
rule	struct
)	O
;	O
if	O
(	O
i	array
>	O
(	O
edit	pointer
->	O
syntax_marker	pointer
?	O
edit	pointer
->	O
syntax_marker	pointer
->	O
offset	long
+	O
SYNTAX_MARKER_DENSITY	int
:	O
SYNTAX_MARKER_DENSITY	int
)	O
)	O
{	O
struct	O
_syntax_marker	struct
*	O
s	pointer
;	O
s	pointer
=	O
edit	pointer
->	O
syntax_marker	pointer
;	O
edit	pointer
->	O
syntax_marker	pointer
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
_syntax_marker	struct
)	O
)	O
;	O
edit	pointer
->	O
syntax_marker	pointer
->	O
next	pointer
=	O
s	pointer
;	O
edit	pointer
->	O
syntax_marker	pointer
->	O
offset	long
=	O
i	array
;	O
edit	pointer
->	O
syntax_marker	pointer
->	O
rule	struct
=	O
edit	pointer
->	O
rule	struct
;	O
}	O
}	O
}	O
else	O
if	O
(	O
byte_index	long
<	O
edit	pointer
->	O
last_get_rule	long
)	O
{	O
struct	O
_syntax_marker	struct
*	O
s	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
syntax_marker	pointer
)	O
{	O
memset	function
(	O
&	O
edit	pointer
->	O
rule	struct
,	O
0	int
,	O
sizeof	O
(	O
edit	pointer
->	O
rule	struct
)	O
)	O
;	O
for	O
(	O
i	array
=	O
-	O
1	int
;	O
i	array
<=	O
byte_index	long
;	O
i	array
++	O
)	O
edit	pointer
->	O
rule	struct
=	O
apply_rules_going_right	function
(	O
edit	pointer
,	O
i	array
,	O
edit	pointer
->	O
rule	struct
)	O
;	O
break	O
;	O
}	O
if	O
(	O
byte_index	long
>=	O
edit	pointer
->	O
syntax_marker	pointer
->	O
offset	long
)	O
{	O
edit	pointer
->	O
rule	struct
=	O
edit	pointer
->	O
syntax_marker	pointer
->	O
rule	struct
;	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
syntax_marker	pointer
->	O
offset	long
+	O
1	int
;	O
i	array
<=	O
byte_index	long
;	O
i	array
++	O
)	O
edit	pointer
->	O
rule	struct
=	O
apply_rules_going_right	function
(	O
edit	pointer
,	O
i	array
,	O
edit	pointer
->	O
rule	struct
)	O
;	O
break	O
;	O
}	O
s	pointer
=	O
edit	pointer
->	O
syntax_marker	pointer
->	O
next	pointer
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
syntax_marker	pointer
)	O
;	O
edit	pointer
->	O
syntax_marker	pointer
=	O
s	pointer
;	O
}	O
}	O
edit	pointer
->	O
last_get_rule	long
=	O
byte_index	long
;	O
return	O
edit	pointer
->	O
rule	struct
;	O
}	O
static	O
void	O
translate_rule_to_color	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
struct	O
syntax_rule	struct
rule	struct
,	O
int	O
*	O
color	pointer
)	O
{	O
struct	O
key_word	struct
*	O
k	int
;	O
k	int
=	O
edit	pointer
->	O
rules	pointer
[	O
rule	struct
.	O
context	pointer
]	O
->	O
keyword	short
[	O
rule	struct
.	O
keyword	short
]	O
;	O
*	O
color	pointer
=	O
k	int
->	O
color	pointer
;	O
}	O
void	O
edit_get_syntax_color	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
byte_index	long
,	O
int	O
*	O
color	pointer
)	O
{	O
if	O
(	O
edit	pointer
->	O
rules	pointer
&&	O
byte_index	long
<	O
edit	pointer
->	O
last_byte	long
&&	O
option_syntax_highlighting	int
&&	O
use_colors	int
)	O
{	O
translate_rule_to_color	function
(	O
edit	pointer
,	O
edit_get_rule	function
(	O
edit	pointer
,	O
byte_index	long
)	O
,	O
color	pointer
)	O
;	O
}	O
else	O
{	O
*	O
color	pointer
=	O
use_colors	int
?	O
EDITOR_NORMAL_COLOR_INDEX	int
:	O
0	int
;	O
}	O
}	O
static	O
int	O
read_one_line	function
(	O
char	O
*	O
*	O
line	int
,	O
FILE	struct
*	O
f	pointer
)	O
{	O
GString	struct
*	O
p	pointer
=	O
g_string_new	function
(	O
""	pointer
)	O
;	O
int	O
c	int
,	O
r	pointer
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
fgetc	function
(	O
f	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	function
(	O
f	pointer
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
r	pointer
=	O
0	int
;	O
}	O
break	O
;	O
}	O
r	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
fgetc	function
(	O
f	pointer
)	O
)	O
==	O
'\n'	O
)	O
r	pointer
++	O
;	O
else	O
ungetc	function
(	O
c	int
,	O
f	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
g_string_append_c	function
(	O
p	pointer
,	O
c	int
)	O
;	O
}	O
if	O
(	O
r	pointer
!=	O
0	int
)	O
{	O
*	O
line	int
=	O
p	pointer
->	O
str	pointer
;	O
g_string_free	function
(	O
p	pointer
,	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
g_string_free	function
(	O
p	pointer
,	O
TRUE	O
)	O
;	O
}	O
return	O
r	pointer
;	O
}	O
static	O
char	O
*	O
convert	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
r	pointer
,	O
*	O
p	pointer
;	O
p	pointer
=	O
r	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'\\'	O
:	O
s	pointer
++	O
;	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
' '	O
:	O
*	O
p	pointer
=	O
' '	O
;	O
s	pointer
--	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	pointer
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	pointer
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	pointer
=	O
'\t'	O
;	O
break	O
;	O
case	O
's'	O
:	O
*	O
p	pointer
=	O
' '	O
;	O
break	O
;	O
case	O
'*'	O
:	O
*	O
p	pointer
=	O
'*'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
p	pointer
=	O
'\\'	O
;	O
break	O
;	O
case	O
'['	O
:	O
case	O
']'	O
:	O
*	O
p	pointer
=	O
SYNTAX_TOKEN_BRACKET	char
;	O
break	O
;	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
*	O
p	pointer
=	O
SYNTAX_TOKEN_BRACE	char
;	O
break	O
;	O
case	O
0	int
:	O
*	O
p	pointer
=	O
*	O
s	pointer
;	O
return	O
r	pointer
;	O
default	O
:	O
*	O
p	pointer
=	O
*	O
s	pointer
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'*'	O
:	O
*	O
p	pointer
=	O
SYNTAX_TOKEN_STAR	char
;	O
break	O
;	O
case	O
'+'	O
:	O
*	O
p	pointer
=	O
SYNTAX_TOKEN_PLUS	char
;	O
break	O
;	O
default	O
:	O
*	O
p	pointer
=	O
*	O
s	pointer
;	O
break	O
;	O
}	O
s	pointer
++	O
;	O
p	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
r	pointer
;	O
}	O
static	O
int	O
get_args	function
(	O
char	O
*	O
l	pointer
,	O
char	O
*	O
*	O
args	array
,	O
int	O
args_size	int
)	O
{	O
int	O
argc	pointer
=	O
0	int
;	O
while	O
(	O
argc	pointer
<	O
args_size	int
)	O
{	O
char	O
*	O
p	pointer
=	O
l	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
whiteness	O
(	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
break	O
;	O
for	O
(	O
l	pointer
=	O
p	pointer
+	O
1	int
;	O
*	O
l	pointer
&&	O
!	O
whiteness	O
(	O
*	O
l	pointer
)	O
;	O
l	pointer
++	O
)	O
;	O
if	O
(	O
*	O
l	pointer
)	O
*	O
l	pointer
++	O
=	O
'\0'	O
;	O
args	array
[	O
argc	pointer
++	O
]	O
=	O
convert	function
(	O
p	pointer
)	O
;	O
}	O
args	array
[	O
argc	pointer
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
return	O
argc	pointer
;	O
}	O
static	O
int	O
this_try_alloc_color_pair	function
(	O
const	O
char	O
*	O
fg	pointer
,	O
const	O
char	O
*	O
bg	pointer
)	O
{	O
char	O
f	pointer
[	O
80	int
]	O
,	O
b	pointer
[	O
80	int
]	O
,	O
*	O
p	pointer
;	O
if	O
(	O
bg	pointer
)	O
if	O
(	O
!	O
*	O
bg	pointer
)	O
bg	pointer
=	O
0	int
;	O
if	O
(	O
fg	pointer
)	O
if	O
(	O
!	O
*	O
fg	pointer
)	O
fg	pointer
=	O
0	int
;	O
if	O
(	O
fg	pointer
)	O
{	O
g_strlcpy	function
(	O
f	pointer
,	O
fg	pointer
,	O
sizeof	O
(	O
f	pointer
)	O
)	O
;	O
p	pointer
=	O
strchr	function
(	O
f	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
fg	pointer
=	O
f	pointer
;	O
}	O
if	O
(	O
bg	pointer
)	O
{	O
g_strlcpy	function
(	O
b	pointer
,	O
bg	pointer
,	O
sizeof	O
(	O
b	pointer
)	O
)	O
;	O
p	pointer
=	O
strchr	function
(	O
b	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
bg	pointer
=	O
b	pointer
;	O
}	O
return	O
try_alloc_color_pair	function
(	O
fg	pointer
,	O
bg	pointer
)	O
;	O
}	O
static	O
char	O
*	O
error_file_name	pointer
=	O
0	int
;	O
static	O
FILE	struct
*	O
open_include_file	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
syntax_g_free	O
(	O
error_file_name	pointer
)	O
;	O
error_file_name	pointer
=	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
*	O
filename	pointer
==	O
PATH_SEP	char
)	O
return	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
g_free	function
(	O
error_file_name	pointer
)	O
;	O
error_file_name	pointer
=	O
g_strconcat	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
EDIT_DIR	O
PATH_SEP_STR	pointer
,	O
filename	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
f	pointer
=	O
fopen	function
(	O
error_file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
f	pointer
)	O
return	O
f	pointer
;	O
g_free	function
(	O
error_file_name	pointer
)	O
;	O
error_file_name	pointer
=	O
g_strconcat	function
(	O
mc_home	pointer
,	O
PATH_SEP_STR	pointer
"syntax"	pointer
PATH_SEP_STR	pointer
,	O
filename	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
fopen	function
(	O
error_file_name	pointer
,	O
"r"	pointer
)	O
;	O
}	O
static	O
int	O
edit_read_syntax_rules	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
FILE	struct
*	O
f	pointer
,	O
char	O
*	O
*	O
args	array
,	O
int	O
args_size	int
)	O
{	O
FILE	struct
*	O
g	pointer
=	O
0	int
;	O
char	O
*	O
fg	pointer
,	O
*	O
bg	pointer
;	O
char	O
last_fg	array
[	O
32	int
]	O
=	O
""	pointer
,	O
last_bg	array
[	O
32	int
]	O
=	O
""	pointer
;	O
char	O
whole_right	pointer
[	O
512	int
]	O
;	O
char	O
whole_left	pointer
[	O
512	int
]	O
;	O
char	O
*	O
l	pointer
=	O
0	int
;	O
int	O
save_line	int
=	O
0	int
,	O
line	int
=	O
0	int
;	O
struct	O
context_rule	struct
*	O
*	O
r	pointer
,	O
*	O
c	int
=	O
0	int
;	O
int	O
num_words	int
=	O
-	O
1	int
,	O
num_contexts	int
=	O
-	O
1	int
;	O
int	O
result	long
=	O
0	int
;	O
int	O
argc	pointer
;	O
int	O
i	array
,	O
j	int
;	O
int	O
alloc_contexts	int
=	O
MAX_CONTEXTS	int
,	O
alloc_words_per_context	int
=	O
MAX_WORDS_PER_CONTEXT	int
,	O
max_alloc_words_per_context	int
=	O
MAX_WORDS_PER_CONTEXT	int
;	O
args	array
[	O
0	int
]	O
=	O
0	int
;	O
strcpy	function
(	O
whole_left	pointer
,	O
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_01234567890"	pointer
)	O
;	O
strcpy	function
(	O
whole_right	pointer
,	O
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_01234567890"	pointer
)	O
;	O
r	pointer
=	O
edit	pointer
->	O
rules	pointer
=	O
g_malloc0	function
(	O
alloc_contexts	int
*	O
sizeof	O
(	O
struct	O
context_rule	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
edit	pointer
->	O
defines	pointer
)	O
edit	pointer
->	O
defines	pointer
=	O
g_tree_new	function
(	O
(	O
GCompareFunc	pointer
)	O
strcmp	function
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
*	O
a	pointer
;	O
line	int
++	O
;	O
l	pointer
=	O
0	int
;	O
if	O
(	O
!	O
read_one_line	function
(	O
&	O
l	pointer
,	O
f	pointer
)	O
)	O
{	O
if	O
(	O
g	pointer
)	O
{	O
fclose	function
(	O
f	pointer
)	O
;	O
f	pointer
=	O
g	pointer
;	O
g	pointer
=	O
0	int
;	O
line	int
=	O
save_line	int
+	O
1	int
;	O
syntax_g_free	O
(	O
error_file_name	pointer
)	O
;	O
syntax_g_free	O
(	O
l	pointer
)	O
;	O
if	O
(	O
!	O
read_one_line	function
(	O
&	O
l	pointer
,	O
f	pointer
)	O
)	O
break	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
argc	pointer
=	O
get_args	function
(	O
l	pointer
,	O
args	array
,	O
args_size	int
)	O
;	O
a	pointer
=	O
args	array
+	O
1	int
;	O
if	O
(	O
!	O
args	array
[	O
0	int
]	O
)	O
{	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"include"	pointer
)	O
)	O
{	O
if	O
(	O
g	pointer
||	O
argc	pointer
!=	O
2	int
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
g	pointer
=	O
f	pointer
;	O
f	pointer
=	O
open_include_file	function
(	O
args	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
syntax_g_free	O
(	O
error_file_name	pointer
)	O
;	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
save_line	int
=	O
line	int
;	O
line	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"wholechars"	pointer
)	O
)	O
{	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"left"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
g_strlcpy	function
(	O
whole_left	pointer
,	O
*	O
a	pointer
,	O
sizeof	O
(	O
whole_left	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"right"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
g_strlcpy	function
(	O
whole_right	pointer
,	O
*	O
a	pointer
,	O
sizeof	O
(	O
whole_right	pointer
)	O
)	O
;	O
}	O
else	O
{	O
g_strlcpy	function
(	O
whole_left	pointer
,	O
*	O
a	pointer
,	O
sizeof	O
(	O
whole_left	pointer
)	O
)	O
;	O
g_strlcpy	function
(	O
whole_right	pointer
,	O
*	O
a	pointer
,	O
sizeof	O
(	O
whole_right	pointer
)	O
)	O
;	O
}	O
a	pointer
++	O
;	O
check_not_a	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"context"	pointer
)	O
)	O
{	O
check_a	O
;	O
if	O
(	O
num_contexts	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
a	pointer
,	O
"default"	pointer
)	O
)	O
{	O
break_a	O
;	O
}	O
a	pointer
++	O
;	O
c	int
=	O
r	pointer
[	O
0	int
]	O
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
context_rule	struct
)	O
)	O
;	O
c	int
->	O
left	pointer
=	O
g_strdup	function
(	O
" "	pointer
)	O
;	O
c	int
->	O
right	pointer
=	O
g_strdup	function
(	O
" "	pointer
)	O
;	O
num_contexts	int
=	O
0	int
;	O
}	O
else	O
{	O
r	pointer
[	O
num_contexts	int
-	O
1	int
]	O
->	O
keyword	short
[	O
num_words	int
]	O
=	O
NULL	O
;	O
c	int
=	O
r	pointer
[	O
num_contexts	int
]	O
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
context_rule	struct
)	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"exclusive"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
c	int
->	O
between_delimiters	int
=	O
1	int
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"whole"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
c	int
->	O
whole_word_chars_left	pointer
=	O
g_strdup	function
(	O
whole_left	pointer
)	O
;	O
c	int
->	O
whole_word_chars_right	pointer
=	O
g_strdup	function
(	O
whole_right	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"wholeleft"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
c	int
->	O
whole_word_chars_left	pointer
=	O
g_strdup	function
(	O
whole_left	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"wholeright"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
c	int
->	O
whole_word_chars_right	pointer
=	O
g_strdup	function
(	O
whole_right	pointer
)	O
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"linestart"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
c	int
->	O
line_start_left	char
=	O
1	int
;	O
}	O
check_a	O
;	O
c	int
->	O
left	pointer
=	O
g_strdup	function
(	O
*	O
a	pointer
++	O
)	O
;	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"linestart"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
c	int
->	O
line_start_right	char
=	O
1	int
;	O
}	O
check_a	O
;	O
c	int
->	O
right	pointer
=	O
g_strdup	function
(	O
*	O
a	pointer
++	O
)	O
;	O
c	int
->	O
first_left	char
=	O
*	O
c	int
->	O
left	pointer
;	O
c	int
->	O
first_right	char
=	O
*	O
c	int
->	O
right	pointer
;	O
}	O
c	int
->	O
keyword	short
=	O
g_malloc	function
(	O
alloc_words_per_context	int
*	O
sizeof	O
(	O
struct	O
key_word	struct
*	O
)	O
)	O
;	O
num_words	int
=	O
1	int
;	O
c	int
->	O
keyword	short
[	O
0	int
]	O
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
key_word	struct
)	O
)	O
;	O
subst_defines	function
(	O
edit	pointer
->	O
defines	pointer
,	O
a	pointer
,	O
&	O
args	array
[	O
1024	int
]	O
)	O
;	O
fg	pointer
=	O
*	O
a	pointer
;	O
if	O
(	O
*	O
a	pointer
)	O
a	pointer
++	O
;	O
bg	pointer
=	O
*	O
a	pointer
;	O
if	O
(	O
*	O
a	pointer
)	O
a	pointer
++	O
;	O
g_strlcpy	function
(	O
last_fg	array
,	O
fg	pointer
?	O
fg	pointer
:	O
""	pointer
,	O
sizeof	O
(	O
last_fg	array
)	O
)	O
;	O
g_strlcpy	function
(	O
last_bg	array
,	O
bg	pointer
?	O
bg	pointer
:	O
""	pointer
,	O
sizeof	O
(	O
last_bg	array
)	O
)	O
;	O
c	int
->	O
keyword	short
[	O
0	int
]	O
->	O
color	pointer
=	O
this_try_alloc_color_pair	function
(	O
fg	pointer
,	O
bg	pointer
)	O
;	O
c	int
->	O
keyword	short
[	O
0	int
]	O
->	O
keyword	short
=	O
g_strdup	function
(	O
" "	pointer
)	O
;	O
check_not_a	O
;	O
alloc_words_per_context	int
=	O
MAX_WORDS_PER_CONTEXT	int
;	O
if	O
(	O
++	O
num_contexts	int
>=	O
alloc_contexts	int
)	O
{	O
struct	O
context_rule	struct
*	O
*	O
tmp	pointer
;	O
alloc_contexts	int
+=	O
128	int
;	O
tmp	pointer
=	O
g_realloc	function
(	O
r	pointer
,	O
alloc_contexts	int
*	O
sizeof	O
(	O
struct	O
context_rule	struct
*	O
)	O
)	O
;	O
r	pointer
=	O
tmp	pointer
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"spellcheck"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
c	int
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
c	int
->	O
spelling	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"keyword"	pointer
)	O
)	O
{	O
struct	O
key_word	struct
*	O
k	int
;	O
if	O
(	O
num_words	int
==	O
-	O
1	int
)	O
break_a	O
;	O
check_a	O
;	O
k	int
=	O
r	pointer
[	O
num_contexts	int
-	O
1	int
]	O
->	O
keyword	short
[	O
num_words	int
]	O
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
key_word	struct
)	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"whole"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
k	int
->	O
whole_word_chars_left	pointer
=	O
g_strdup	function
(	O
whole_left	pointer
)	O
;	O
k	int
->	O
whole_word_chars_right	pointer
=	O
g_strdup	function
(	O
whole_right	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"wholeleft"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
k	int
->	O
whole_word_chars_left	pointer
=	O
g_strdup	function
(	O
whole_left	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"wholeright"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
k	int
->	O
whole_word_chars_right	pointer
=	O
g_strdup	function
(	O
whole_right	pointer
)	O
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"linestart"	pointer
)	O
)	O
{	O
a	pointer
++	O
;	O
k	int
->	O
line_start	int
=	O
1	int
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
a	pointer
,	O
"whole"	pointer
)	O
)	O
{	O
break_a	O
;	O
}	O
k	int
->	O
keyword	short
=	O
g_strdup	function
(	O
*	O
a	pointer
++	O
)	O
;	O
k	int
->	O
first	pointer
=	O
*	O
k	int
->	O
keyword	short
;	O
subst_defines	function
(	O
edit	pointer
->	O
defines	pointer
,	O
a	pointer
,	O
&	O
args	array
[	O
1024	int
]	O
)	O
;	O
fg	pointer
=	O
*	O
a	pointer
;	O
if	O
(	O
*	O
a	pointer
)	O
a	pointer
++	O
;	O
bg	pointer
=	O
*	O
a	pointer
;	O
if	O
(	O
*	O
a	pointer
)	O
a	pointer
++	O
;	O
if	O
(	O
!	O
fg	pointer
)	O
fg	pointer
=	O
last_fg	array
;	O
if	O
(	O
!	O
bg	pointer
)	O
bg	pointer
=	O
last_bg	array
;	O
k	int
->	O
color	pointer
=	O
this_try_alloc_color_pair	function
(	O
fg	pointer
,	O
bg	pointer
)	O
;	O
check_not_a	O
;	O
if	O
(	O
++	O
num_words	int
>=	O
alloc_words_per_context	int
)	O
{	O
struct	O
key_word	struct
*	O
*	O
tmp	pointer
;	O
alloc_words_per_context	int
+=	O
1024	int
;	O
if	O
(	O
alloc_words_per_context	int
>	O
max_alloc_words_per_context	int
)	O
max_alloc_words_per_context	int
=	O
alloc_words_per_context	int
;	O
tmp	pointer
=	O
g_realloc	function
(	O
c	int
->	O
keyword	short
,	O
alloc_words_per_context	int
*	O
sizeof	O
(	O
struct	O
key_word	struct
*	O
)	O
)	O
;	O
c	int
->	O
keyword	short
=	O
tmp	pointer
;	O
}	O
}	O
else	O
if	O
(	O
*	O
(	O
args	array
[	O
0	int
]	O
)	O
==	O
'#'	O
)	O
{	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"file"	pointer
)	O
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"define"	pointer
)	O
)	O
{	O
char	O
*	O
key	pointer
=	O
*	O
a	pointer
++	O
;	O
char	O
*	O
*	O
argv	pointer
;	O
if	O
(	O
argc	pointer
<	O
3	int
)	O
break_a	O
;	O
if	O
(	O
(	O
argv	pointer
=	O
g_tree_lookup	function
(	O
edit	pointer
->	O
defines	pointer
,	O
key	pointer
)	O
)	O
)	O
{	O
mc_defines_destroy	function
(	O
NULL	O
,	O
argv	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
key	pointer
=	O
g_strdup	function
(	O
key	pointer
)	O
;	O
}	O
argv	pointer
=	O
g_new	O
(	O
char	O
*	O
,	O
argc	pointer
-	O
1	int
)	O
;	O
g_tree_insert	function
(	O
edit	pointer
->	O
defines	pointer
,	O
key	pointer
,	O
argv	pointer
)	O
;	O
while	O
(	O
*	O
a	pointer
)	O
{	O
*	O
argv	pointer
++	O
=	O
g_strdup	function
(	O
*	O
a	pointer
++	O
)	O
;	O
}	O
;	O
*	O
argv	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
break_a	O
;	O
}	O
free_args	O
(	O
args	array
)	O
;	O
syntax_g_free	O
(	O
l	pointer
)	O
;	O
}	O
free_args	O
(	O
args	array
)	O
;	O
syntax_g_free	O
(	O
l	pointer
)	O
;	O
if	O
(	O
num_contexts	int
>	O
0	int
)	O
{	O
r	pointer
[	O
num_contexts	int
-	O
1	int
]	O
->	O
keyword	short
[	O
num_words	int
]	O
=	O
NULL	O
;	O
r	pointer
[	O
num_contexts	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
edit	pointer
->	O
rules	pointer
[	O
0	int
]	O
)	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
if	O
(	O
num_contexts	int
==	O
-	O
1	int
)	O
{	O
return	O
line	int
;	O
}	O
{	O
char	O
*	O
first_chars	pointer
,	O
*	O
p	pointer
;	O
first_chars	pointer
=	O
g_malloc	function
(	O
max_alloc_words_per_context	int
+	O
2	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
;	O
i	array
++	O
)	O
{	O
c	int
=	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
;	O
p	pointer
=	O
first_chars	pointer
;	O
*	O
p	pointer
++	O
=	O
(	O
char	O
)	O
1	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
c	int
->	O
keyword	short
[	O
j	int
]	O
;	O
j	int
++	O
)	O
*	O
p	pointer
++	O
=	O
c	int
->	O
keyword	short
[	O
j	int
]	O
->	O
first	pointer
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
c	int
->	O
keyword_first_chars	pointer
=	O
g_strdup	function
(	O
first_chars	pointer
)	O
;	O
}	O
g_free	function
(	O
first_chars	pointer
)	O
;	O
}	O
return	O
result	long
;	O
}	O
void	O
edit_free_syntax_rules	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
i	array
,	O
j	int
;	O
if	O
(	O
!	O
edit	pointer
)	O
return	O
;	O
if	O
(	O
edit	pointer
->	O
defines	pointer
)	O
destroy_defines	function
(	O
&	O
edit	pointer
->	O
defines	pointer
)	O
;	O
if	O
(	O
!	O
edit	pointer
->	O
rules	pointer
)	O
return	O
;	O
edit_get_rule	function
(	O
edit	pointer
,	O
-	O
1	int
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
syntax_type	pointer
)	O
;	O
edit	pointer
->	O
syntax_type	pointer
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
;	O
i	array
++	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
[	O
j	int
]	O
;	O
j	int
++	O
)	O
{	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
[	O
j	int
]	O
->	O
keyword	short
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
[	O
j	int
]	O
->	O
whole_word_chars_left	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
[	O
j	int
]	O
->	O
whole_word_chars_right	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
[	O
j	int
]	O
)	O
;	O
}	O
}	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
left	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
right	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
whole_word_chars_left	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
whole_word_chars_right	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword	short
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
->	O
keyword_first_chars	pointer
)	O
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
[	O
i	array
]	O
)	O
;	O
}	O
while	O
(	O
edit	pointer
->	O
syntax_marker	pointer
)	O
{	O
struct	O
_syntax_marker	struct
*	O
s	pointer
=	O
edit	pointer
->	O
syntax_marker	pointer
->	O
next	pointer
;	O
syntax_g_free	O
(	O
edit	pointer
->	O
syntax_marker	pointer
)	O
;	O
edit	pointer
->	O
syntax_marker	pointer
=	O
s	pointer
;	O
}	O
syntax_g_free	O
(	O
edit	pointer
->	O
rules	pointer
)	O
;	O
}	O
static	O
int	O
edit_read_syntax_file	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
*	O
*	O
pnames	pointer
,	O
const	O
char	O
*	O
syntax_file	pointer
,	O
const	O
char	O
*	O
editor_file	pointer
,	O
const	O
char	O
*	O
first_line	pointer
,	O
const	O
char	O
*	O
type	enum
)	O
{	O
FILE	struct
*	O
f	pointer
,	O
*	O
g	pointer
=	O
NULL	O
;	O
regex_t	struct
r	pointer
;	O
regmatch_t	struct
pmatch	array
[	O
1	int
]	O
;	O
char	O
*	O
args	array
[	O
1024	int
]	O
,	O
*	O
l	pointer
=	O
0	int
;	O
int	O
line	int
=	O
0	int
;	O
int	O
result	long
=	O
0	int
;	O
int	O
count	int
=	O
0	int
;	O
char	O
*	O
lib_file	pointer
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
*	O
tmpnames	pointer
=	O
NULL	O
;	O
f	pointer
=	O
fopen	function
(	O
syntax_file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
lib_file	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"syntax"	pointer
PATH_SEP_STR	pointer
"Syntax"	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
lib_file	pointer
,	O
"r"	pointer
)	O
;	O
g_free	function
(	O
lib_file	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
-	O
1	int
;	O
}	O
args	array
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
line	int
++	O
;	O
syntax_g_free	O
(	O
l	pointer
)	O
;	O
if	O
(	O
!	O
read_one_line	function
(	O
&	O
l	pointer
,	O
f	pointer
)	O
)	O
break	O
;	O
(	O
void	O
)	O
get_args	function
(	O
l	pointer
,	O
args	array
,	O
1023	int
)	O
;	O
if	O
(	O
!	O
args	array
[	O
0	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
found	int
&&	O
!	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"include"	pointer
)	O
)	O
{	O
if	O
(	O
g	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
args	array
[	O
1	int
]	O
||	O
!	O
(	O
g	pointer
=	O
open_include_file	function
(	O
args	array
[	O
1	int
]	O
)	O
)	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
goto	O
found_type	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
args	array
[	O
0	int
]	O
,	O
"file"	pointer
)	O
)	O
{	O
continue	O
;	O
}	O
found	int
=	O
1	int
;	O
if	O
(	O
!	O
args	array
[	O
1	int
]	O
||	O
!	O
args	array
[	O
2	int
]	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
if	O
(	O
pnames	pointer
&&	O
*	O
pnames	pointer
)	O
{	O
if	O
(	O
count	int
%	O
NENTRIES	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
tmpnames	pointer
=	O
(	O
char	O
*	O
*	O
)	O
g_realloc	function
(	O
*	O
pnames	pointer
,	O
(	O
count	int
+	O
NENTRIES	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
pnames	pointer
=	O
tmpnames	pointer
;	O
else	O
abort	function
(	O
)	O
;	O
}	O
(	O
*	O
pnames	pointer
)	O
[	O
count	int
++	O
]	O
=	O
g_strdup	function
(	O
args	array
[	O
2	int
]	O
)	O
;	O
(	O
*	O
pnames	pointer
)	O
[	O
count	int
]	O
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
type	enum
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
type	enum
,	O
args	array
[	O
2	int
]	O
)	O
)	O
goto	O
found_type	O
;	O
}	O
else	O
if	O
(	O
editor_file	pointer
&&	O
edit	pointer
)	O
{	O
int	O
q	pointer
;	O
if	O
(	O
regcomp	function
(	O
&	O
r	pointer
,	O
args	array
[	O
1	int
]	O
,	O
REG_EXTENDED	int
)	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
q	pointer
=	O
!	O
regexec	function
(	O
&	O
r	pointer
,	O
editor_file	pointer
,	O
1	int
,	O
pmatch	array
,	O
0	int
)	O
;	O
regfree	function
(	O
&	O
r	pointer
)	O
;	O
if	O
(	O
!	O
q	pointer
&&	O
args	array
[	O
3	int
]	O
)	O
{	O
if	O
(	O
regcomp	function
(	O
&	O
r	pointer
,	O
args	array
[	O
3	int
]	O
,	O
REG_EXTENDED	int
)	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
q	pointer
=	O
!	O
regexec	function
(	O
&	O
r	pointer
,	O
first_line	pointer
,	O
1	int
,	O
pmatch	array
,	O
0	int
)	O
;	O
regfree	function
(	O
&	O
r	pointer
)	O
;	O
}	O
if	O
(	O
q	pointer
)	O
{	O
int	O
line_error	int
;	O
char	O
*	O
syntax_type	pointer
;	O
found_type	O
:	O
syntax_type	pointer
=	O
args	array
[	O
2	int
]	O
;	O
line_error	int
=	O
edit_read_syntax_rules	function
(	O
edit	pointer
,	O
g	pointer
?	O
g	pointer
:	O
f	pointer
,	O
args	array
,	O
1023	int
)	O
;	O
if	O
(	O
line_error	int
)	O
{	O
if	O
(	O
!	O
error_file_name	pointer
)	O
result	long
=	O
line	int
+	O
line_error	int
;	O
else	O
result	long
=	O
line_error	int
;	O
}	O
else	O
{	O
syntax_g_free	O
(	O
edit	pointer
->	O
syntax_type	pointer
)	O
;	O
edit	pointer
->	O
syntax_type	pointer
=	O
g_strdup	function
(	O
syntax_type	pointer
)	O
;	O
if	O
(	O
!	O
g	pointer
&&	O
!	O
edit	pointer
->	O
rules	pointer
[	O
1	int
]	O
)	O
if	O
(	O
!	O
edit	pointer
->	O
rules	pointer
[	O
0	int
]	O
->	O
keyword	short
[	O
1	int
]	O
&&	O
!	O
edit	pointer
->	O
rules	pointer
[	O
0	int
]	O
->	O
spelling	int
)	O
{	O
edit_free_syntax_rules	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
g	pointer
)	O
{	O
fclose	function
(	O
g	pointer
)	O
;	O
g	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
}	O
}	O
syntax_g_free	O
(	O
l	pointer
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
char	O
*	O
get_first_editor_line	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
i	array
;	O
static	O
char	O
s	pointer
[	O
256	int
]	O
;	O
s	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
edit	pointer
)	O
return	O
s	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
255	int
;	O
i	array
++	O
)	O
{	O
s	pointer
[	O
i	array
]	O
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
if	O
(	O
s	pointer
[	O
i	array
]	O
==	O
'\n'	O
)	O
{	O
s	pointer
[	O
i	array
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
s	pointer
[	O
255	int
]	O
=	O
'\0'	O
;	O
return	O
s	pointer
;	O
}	O
void	O
edit_load_syntax	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
*	O
*	O
pnames	pointer
,	O
const	O
char	O
*	O
type	enum
)	O
{	O
int	O
r	pointer
;	O
char	O
*	O
f	pointer
=	O
NULL	O
;	O
if	O
(	O
option_auto_syntax	int
)	O
type	enum
=	O
NULL	O
;	O
edit_free_syntax_rules	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
!	O
use_colors	int
)	O
return	O
;	O
if	O
(	O
!	O
option_syntax_highlighting	int
&&	O
(	O
!	O
pnames	pointer
||	O
!	O
*	O
pnames	pointer
)	O
)	O
return	O
;	O
if	O
(	O
edit	pointer
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
filename	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
edit	pointer
->	O
filename	pointer
&&	O
!	O
type	enum
)	O
return	O
;	O
}	O
f	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
SYNTAX_FILE	O
)	O
;	O
r	pointer
=	O
edit_read_syntax_file	function
(	O
edit	pointer
,	O
pnames	pointer
,	O
f	pointer
,	O
edit	pointer
?	O
edit	pointer
->	O
filename	pointer
:	O
0	int
,	O
get_first_editor_line	function
(	O
edit	pointer
)	O
,	O
type	enum
)	O
;	O
if	O
(	O
r	pointer
==	O
-	O
1	int
)	O
{	O
edit_free_syntax_rules	function
(	O
edit	pointer
)	O
;	O
message	pointer
(	O
D_ERROR	int
,	O
_	O
(	O
" Load syntax file "	pointer
)	O
,	O
_	O
(	O
" Cannot open file %s \n %s "	pointer
)	O
,	O
f	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
r	pointer
)	O
{	O
edit_free_syntax_rules	function
(	O
edit	pointer
)	O
;	O
message	pointer
(	O
D_ERROR	int
,	O
_	O
(	O
" Load syntax file "	pointer
)	O
,	O
_	O
(	O
" Error in file %s on line %d "	pointer
)	O
,	O
error_file_name	pointer
?	O
error_file_name	pointer
:	O
f	pointer
,	O
r	pointer
)	O
;	O
syntax_g_free	O
(	O
error_file_name	pointer
)	O
;	O
}	O
else	O
{	O
}	O
g_free	function
(	O
f	pointer
)	O
;	O
}	O