static	O
void	O
dotmail_destroy	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
size_t	long
i	long
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s (%s)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
)	O
)	O
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
{	O
mu_dotmail_message_free	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
dmp	pointer
->	O
mesg	pointer
)	O
;	O
free	function
(	O
dmp	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
dmp	pointer
)	O
;	O
mailbox	pointer
->	O
data	pointer
=	O
NULL	O
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
}	O
static	O
int	O
dotmail_mailbox_init_stream	function
(	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
)	O
{	O
int	O
rc	int
;	O
mu_mailbox_t	pointer
mailbox	pointer
=	O
dmp	pointer
->	O
mailbox	pointer
;	O
rc	int
=	O
mu_mapfile_stream_create	function
(	O
&	O
mailbox	pointer
->	O
stream	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mailbox	pointer
->	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_mapfile_stream_create"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
mailbox	pointer
->	O
stream	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mailbox	pointer
->	O
flags	int
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_file_stream_create"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
mu_stream_set_buffer	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
mu_buffer_full	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_open	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s(%s, 0x%x)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
,	O
mailbox	pointer
->	O
flags	int
)	O
)	O
;	O
mailbox	pointer
->	O
flags	int
=	O
flags	int
;	O
rc	int
=	O
dotmail_mailbox_init_stream	function
(	O
dmp	pointer
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
==	O
NULL	O
&&	O
(	O
flags	int
&	O
(	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
)	O
)	O
)	O
{	O
rc	int
=	O
mu_locker_create	function
(	O
&	O
mailbox	pointer
->	O
locker	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_locker_create"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_close	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s (%s)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
)	O
)	O
;	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
{	O
mu_dotmail_message_free	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
dmp	pointer
->	O
mesg	pointer
)	O
;	O
dmp	pointer
->	O
mesg	pointer
=	O
NULL	O
;	O
dmp	pointer
->	O
mesg_count	long
=	O
dmp	pointer
->	O
mesg_max	long
=	O
0	int
;	O
dmp	pointer
->	O
size	long
=	O
0	int
;	O
dmp	pointer
->	O
uidvalidity	long
=	O
0	int
;	O
dmp	pointer
->	O
uidnext	long
=	O
0	int
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_remove	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s (%s)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
unlink	function
(	O
dmp	pointer
->	O
name	pointer
)	O
)	O
return	O
errno	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_is_updated	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mu_off_t	long
size	long
=	O
0	int
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
0	int
;	O
if	O
(	O
mu_stream_size	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
&	O
size	long
)	O
!=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
size	long
<	O
dmp	pointer
->	O
size	long
)	O
{	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_CORRUPT	int
,	O
mailbox	pointer
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_EMERG	O
,	O
_	O
(	O
"mailbox corrupted, shrank in size"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
(	O
dmp	pointer
->	O
size	long
==	O
size	long
)	O
;	O
}	O
void	O
dotmail_cleanup	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
mu_mailbox_t	pointer
mailbox	pointer
=	O
arg	pointer
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
}	O
static	O
int	O
dotmail_alloc_message	function
(	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
,	O
struct	O
mu_dotmail_message	struct
*	O
*	O
dmsg_ptr	pointer
)	O
{	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
;	O
if	O
(	O
dmp	pointer
->	O
mesg_count	long
==	O
dmp	pointer
->	O
mesg_max	long
)	O
{	O
size_t	long
n	int
=	O
dmp	pointer
->	O
mesg_max	long
;	O
void	O
*	O
p	pointer
;	O
if	O
(	O
n	int
==	O
0	int
)	O
n	int
=	O
64	int
;	O
else	O
{	O
if	O
(	O
(	O
size_t	long
)	O
-	O
1	int
/	O
3	int
*	O
2	int
/	O
sizeof	O
(	O
dmp	pointer
->	O
mesg	pointer
[	O
0	int
]	O
)	O
<=	O
n	int
)	O
return	O
ENOMEM	int
;	O
n	int
+=	O
(	O
n	int
+	O
1	int
)	O
/	O
2	int
;	O
}	O
p	pointer
=	O
realloc	function
(	O
dmp	pointer
->	O
mesg	pointer
,	O
n	int
*	O
sizeof	O
(	O
dmp	pointer
->	O
mesg	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ENOMEM	int
;	O
dmp	pointer
->	O
mesg	pointer
=	O
p	pointer
;	O
dmp	pointer
->	O
mesg_max	long
=	O
n	int
;	O
}	O
dmsg	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
dmsg	pointer
)	O
)	O
;	O
if	O
(	O
!	O
dmsg	pointer
)	O
return	O
ENOMEM	int
;	O
dmsg	pointer
->	O
mbox	pointer
=	O
dmp	pointer
;	O
dmsg	pointer
->	O
num	long
=	O
dmp	pointer
->	O
mesg_count	long
;	O
dmp	pointer
->	O
mesg	pointer
[	O
dmp	pointer
->	O
mesg_count	long
++	O
]	O
=	O
dmsg	pointer
;	O
*	O
dmsg_ptr	pointer
=	O
dmsg	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_dispatch	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
int	O
evt	int
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
!	O
mailbox	pointer
->	O
observable	pointer
)	O
return	O
0	int
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
if	O
(	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
evt	int
,	O
data	pointer
)	O
)	O
{	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
)	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
return	O
EINTR	int
;	O
}	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
unsigned	O
long	O
dotmail_alloc_next_uid	function
(	O
struct	O
mu_dotmail_mailbox	struct
*	O
mbox	pointer
)	O
{	O
mbox	pointer
->	O
mesg	pointer
[	O
0	int
]	O
->	O
uid_modified	int
=	O
1	int
;	O
return	O
mbox	pointer
->	O
uidnext	long
++	O
;	O
}	O
static	O
void	O
dotmail_message_alloc_uid	function
(	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
)	O
{	O
free	function
(	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_uid	int
]	O
)	O
;	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_uid	int
]	O
=	O
NULL	O
;	O
dmsg	pointer
->	O
uid	long
=	O
dotmail_alloc_next_uid	function
(	O
dmsg	pointer
->	O
mbox	pointer
)	O
;	O
dmsg	pointer
->	O
uid_modified	int
=	O
1	int
;	O
}	O
static	O
int	O
dotmail_rescan_unlocked	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_off_t	long
offset	long
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
char	O
cur	char
;	O
size_t	long
n	int
;	O
enum	O
dotmail_scan_state	enum
{	O
dotmail_scan_init	int
,	O
dotmail_scan_header	int
,	O
dotmail_scan_header_newline	int
,	O
dotmail_scan_header_expect	int
,	O
dotmail_scan_body	int
,	O
dotmail_scan_body_newline	int
,	O
dotmail_scan_dot	int
}	O
state	pointer
=	O
dotmail_scan_init	int
;	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
;	O
size_t	long
lines	long
=	O
0	int
;	O
int	O
rc	int
;	O
static	O
char	O
*	O
expect	array
[	O
]	O
=	O
{	O
"status:    "	pointer
,	O
"x-imapbase:"	pointer
,	O
"x-uid:     "	pointer
,	O
}	O
;	O
int	O
i	long
,	O
j	int
;	O
int	O
force_init_uids	int
=	O
0	int
;	O
rc	int
=	O
mu_streamref_create	function
(	O
&	O
stream	pointer
,	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_streamref_create"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
offset	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_stream_seek"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_read	function
(	O
stream	pointer
,	O
&	O
cur	char
,	O
1	int
,	O
&	O
n	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
if	O
(	O
state	pointer
!=	O
dotmail_scan_init	int
&&	O
state	pointer
!=	O
dotmail_scan_dot	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s (%s): message %lu ended prematurely"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
dmp	pointer
->	O
mesg_count	long
)	O
)	O
;	O
--	O
dmp	pointer
->	O
mesg_count	long
;	O
}	O
break	O
;	O
}	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
{	O
if	O
(	O
(	O
(	O
lines	long
+	O
1	int
)	O
%	O
1000	int
)	O
==	O
0	int
)	O
dotmail_dispatch	function
(	O
mailbox	pointer
,	O
MU_EVT_MAILBOX_PROGRESS	int
,	O
NULL	O
)	O
;	O
}	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
dotmail_scan_init	int
:	O
rc	int
=	O
dotmail_alloc_message	function
(	O
dmp	pointer
,	O
&	O
dmsg	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"dotmail_alloc_message"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_CUR	int
,	O
&	O
dmsg	pointer
->	O
message_start	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_stream_seek"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
--	O
dmsg	pointer
->	O
message_start	long
;	O
state	pointer
=	O
dotmail_scan_header_newline	int
;	O
i	long
=	O
j	int
=	O
0	int
;	O
break	O
;	O
case	O
dotmail_scan_header	int
:	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
{	O
state	pointer
=	O
dotmail_scan_header_newline	int
;	O
}	O
break	O
;	O
case	O
dotmail_scan_header_newline	int
:	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
{	O
rc	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_CUR	int
,	O
&	O
dmsg	pointer
->	O
body_start	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_stream_seek"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
state	pointer
=	O
dotmail_scan_body_newline	int
;	O
}	O
else	O
{	O
state	pointer
=	O
dotmail_scan_header	int
;	O
j	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
MU_DOTMAIL_HDR_MAX	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
expect	array
[	O
i	long
]	O
[	O
j	int
]	O
==	O
mu_tolower	O
(	O
cur	char
)	O
)	O
{	O
j	int
++	O
;	O
state	pointer
=	O
dotmail_scan_header_expect	int
;	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
dotmail_scan_header_expect	int
:	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
{	O
state	pointer
=	O
dotmail_scan_header_newline	int
;	O
}	O
else	O
{	O
int	O
c	int
=	O
mu_tolower	O
(	O
cur	char
)	O
;	O
if	O
(	O
expect	array
[	O
i	long
]	O
[	O
j	int
]	O
!=	O
c	int
)	O
{	O
if	O
(	O
++	O
i	long
==	O
MU_DOTMAIL_HDR_MAX	int
||	O
memcmp	function
(	O
expect	array
[	O
i	long
-	O
1	int
]	O
,	O
expect	array
[	O
i	long
]	O
,	O
j	int
)	O
||	O
expect	array
[	O
i	long
]	O
[	O
j	int
]	O
!=	O
c	int
)	O
{	O
state	pointer
=	O
dotmail_scan_header	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
c	int
==	O
':'	O
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
size_t	long
n	int
;	O
rc	int
=	O
mu_stream_getline	function
(	O
stream	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_stream_getline"	pointer
,	O
dmsg	pointer
->	O
mbox	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
buf	pointer
[	O
n	int
-	O
1	int
]	O
=	O
0	int
;	O
dmsg	pointer
->	O
hdr	array
[	O
i	long
]	O
=	O
buf	pointer
;	O
}	O
else	O
free	function
(	O
buf	pointer
)	O
;	O
state	pointer
=	O
dotmail_scan_header_newline	int
;	O
}	O
else	O
{	O
j	int
++	O
;	O
if	O
(	O
expect	array
[	O
i	long
]	O
[	O
j	int
]	O
==	O
0	int
)	O
state	pointer
=	O
dotmail_scan_header_newline	int
;	O
}	O
}	O
break	O
;	O
case	O
dotmail_scan_body	int
:	O
dmsg	pointer
->	O
body_size	long
++	O
;	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
{	O
dmsg	pointer
->	O
body_lines	long
++	O
;	O
state	pointer
=	O
dotmail_scan_body_newline	int
;	O
}	O
break	O
;	O
case	O
dotmail_scan_body_newline	int
:	O
dmsg	pointer
->	O
body_size	long
++	O
;	O
if	O
(	O
cur	char
==	O
'.'	O
)	O
state	pointer
=	O
dotmail_scan_dot	int
;	O
else	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
;	O
else	O
state	pointer
=	O
dotmail_scan_body	int
;	O
break	O
;	O
case	O
dotmail_scan_dot	int
:	O
if	O
(	O
cur	char
==	O
'\n'	O
)	O
{	O
size_t	long
count	pointer
;	O
dmsg	pointer
->	O
body_lines_scanned	int
=	O
1	int
;	O
rc	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_CUR	int
,	O
&	O
dmsg	pointer
->	O
message_end	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_stream_seek"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
dmsg	pointer
->	O
message_end	long
-=	O
2	int
;	O
dmsg	pointer
->	O
body_size	long
--	O
;	O
if	O
(	O
dmsg	pointer
->	O
num	long
==	O
0	int
)	O
{	O
if	O
(	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_imapbase	int
]	O
&&	O
sscanf	function
(	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_imapbase	int
]	O
,	O
"%lu %lu"	pointer
,	O
&	O
dmp	pointer
->	O
uidvalidity	long
,	O
&	O
dmp	pointer
->	O
uidnext	long
)	O
==	O
2	int
)	O
dmp	pointer
->	O
uidvalidity_scanned	int
=	O
1	int
;	O
}	O
if	O
(	O
dmp	pointer
->	O
uidvalidity_scanned	int
)	O
{	O
if	O
(	O
!	O
(	O
!	O
force_init_uids	int
&&	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_uid	int
]	O
&&	O
sscanf	function
(	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_uid	int
]	O
,	O
"%lu"	pointer
,	O
&	O
dmsg	pointer
->	O
uid	long
)	O
==	O
1	int
)	O
)	O
force_init_uids	int
=	O
1	int
;	O
if	O
(	O
force_init_uids	int
)	O
dotmail_message_alloc_uid	function
(	O
dmsg	pointer
)	O
;	O
}	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
&&	O
(	O
dmp	pointer
->	O
mesg_count	long
%	O
100	int
)	O
==	O
0	int
)	O
mu_locker_touchlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
count	pointer
=	O
dmp	pointer
->	O
mesg_count	long
;	O
dotmail_dispatch	function
(	O
mailbox	pointer
,	O
MU_EVT_MESSAGE_ADD	int
,	O
&	O
count	pointer
)	O
;	O
state	pointer
=	O
dotmail_scan_init	int
;	O
}	O
else	O
{	O
if	O
(	O
cur	char
==	O
'.'	O
)	O
dmsg	pointer
->	O
body_dot_stuffed	int
=	O
1	int
;	O
else	O
dmsg	pointer
->	O
body_size	long
++	O
;	O
state	pointer
=	O
dotmail_scan_body	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s (%s): %s"	pointer
,	O
__func__	O
,	O
"mu_stream_read"	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
mu_stream_unref	function
(	O
stream	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_rescan	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_off_t	long
offset	long
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
EINVAL	int
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
pthread_cleanup_push	O
(	O
dotmail_cleanup	function
,	O
(	O
void	O
*	O
)	O
mailbox	pointer
)	O
;	O
rc	int
=	O
mu_stream_size	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
&	O
dmp	pointer
->	O
size	long
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
{	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
&&	O
(	O
rc	int
=	O
mu_locker_lock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
)	O
)	O
{	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
dotmail_rescan_unlocked	function
(	O
mailbox	pointer
,	O
offset	long
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
)	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
pthread_cleanup_pop	O
(	O
0	int
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_refresh	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
dotmail_is_updated	function
(	O
mailbox	pointer
)	O
)	O
return	O
0	int
;	O
return	O
dotmail_rescan	function
(	O
mailbox	pointer
,	O
dmp	pointer
->	O
mesg_count	long
==	O
0	int
?	O
0	int
:	O
dmp	pointer
->	O
mesg	pointer
[	O
dmp	pointer
->	O
mesg_count	long
-	O
1	int
]	O
->	O
message_end	long
+	O
2	int
)	O
;	O
}	O
static	O
int	O
dotmail_scan	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
i	long
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
EINVAL	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s (%s)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
i	long
==	O
0	int
||	O
(	O
dmp	pointer
->	O
mesg_count	long
&&	O
i	long
>	O
dmp	pointer
->	O
mesg_count	long
)	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
dotmail_is_updated	function
(	O
mailbox	pointer
)	O
)	O
{	O
int	O
rc	int
;	O
while	O
(	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
)	O
mu_dotmail_message_free	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
dmp	pointer
->	O
mesg_count	long
--	O
]	O
)	O
;	O
rc	int
=	O
dotmail_refresh	function
(	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
else	O
if	O
(	O
mailbox	pointer
->	O
observable	pointer
)	O
{	O
for	O
(	O
;	O
i	long
<=	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
{	O
size_t	long
tmp	long
=	O
i	long
;	O
if	O
(	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MESSAGE_ADD	int
,	O
&	O
tmp	long
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
(	O
i	long
+	O
1	int
)	O
%	O
50	int
)	O
==	O
0	int
)	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_PROGRESS	int
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
pcount	pointer
)	O
*	O
pcount	pointer
=	O
dmp	pointer
->	O
mesg_count	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_messages_recent	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
size_t	long
i	long
;	O
size_t	long
count	pointer
=	O
0	int
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
=	O
dotmail_refresh	function
(	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
{	O
mu_dotmail_message_attr_load	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
MU_ATTRIBUTE_IS_UNSEEN	O
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
->	O
attr_flags	int
)	O
)	O
++	O
count	pointer
;	O
}	O
*	O
pcount	pointer
=	O
count	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_message_unseen	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pmsgno	pointer
)	O
{	O
size_t	long
i	long
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
=	O
dotmail_refresh	function
(	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
{	O
mu_dotmail_message_attr_load	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
MU_ATTRIBUTE_IS_UNREAD	O
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
->	O
attr_flags	int
)	O
)	O
{	O
*	O
pmsgno	pointer
=	O
i	long
+	O
1	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
int	O
mu_dotmail_mailbox_uid_setup	function
(	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
)	O
{	O
if	O
(	O
!	O
dmp	pointer
->	O
uidvalidity_scanned	int
)	O
{	O
size_t	long
i	long
;	O
int	O
rc	int
=	O
dotmail_refresh	function
(	O
dmp	pointer
->	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
||	O
dmp	pointer
->	O
uidvalidity_scanned	int
)	O
return	O
rc	int
;	O
dmp	pointer
->	O
uidvalidity	long
=	O
(	O
unsigned	O
long	O
)	O
time	struct
(	O
NULL	O
)	O
;	O
dmp	pointer
->	O
uidnext	long
=	O
1	int
;	O
dmp	pointer
->	O
uidvalidity_scanned	int
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
dotmail_message_alloc_uid	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_uidvalidity	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
unsigned	O
long	O
*	O
puidvalidity	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
=	O
mu_dotmail_mailbox_uid_setup	function
(	O
dmp	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
puidvalidity	pointer
=	O
dmp	pointer
->	O
uidvalidity	long
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_uidnext	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
puidnext	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
=	O
mu_dotmail_mailbox_uid_setup	function
(	O
dmp	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
puidnext	pointer
=	O
dmp	pointer
->	O
uidnext	long
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
msgno	long
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
dmp	pointer
||	O
msgno	long
<	O
1	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pmsg	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
dmp	pointer
->	O
mesg_count	long
==	O
0	int
)	O
{	O
rc	int
=	O
dotmail_scan	function
(	O
mailbox	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
if	O
(	O
msgno	long
>	O
dmp	pointer
->	O
mesg_count	long
)	O
return	O
MU_ERR_NOENT	O
;	O
return	O
mu_dotmail_message_get	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
msgno	long
-	O
1	int
]	O
,	O
pmsg	pointer
)	O
;	O
}	O
static	O
int	O
qid2off	function
(	O
mu_message_qid_t	pointer
qid	pointer
,	O
mu_off_t	long
*	O
pret	pointer
)	O
{	O
mu_off_t	long
ret	pointer
=	O
0	int
;	O
for	O
(	O
;	O
*	O
qid	pointer
;	O
qid	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
'0'	O
<=	O
*	O
qid	pointer
&&	O
*	O
qid	pointer
<=	O
'9'	O
)	O
)	O
return	O
1	int
;	O
ret	pointer
=	O
ret	pointer
*	O
10	int
+	O
*	O
qid	pointer
-	O
'0'	O
;	O
}	O
*	O
pret	pointer
=	O
ret	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_quick_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_qid_t	pointer
qid	pointer
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
;	O
mu_off_t	long
offset	long
;	O
if	O
(	O
mailbox	pointer
==	O
NULL	O
||	O
qid2off	function
(	O
qid	pointer
,	O
&	O
offset	long
)	O
||	O
!	O
(	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_QACCESS	int
)	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
dmp	pointer
->	O
mesg_count	long
==	O
0	int
)	O
{	O
rc	int
=	O
dotmail_rescan	function
(	O
mailbox	pointer
,	O
offset	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
dmp	pointer
->	O
mesg_count	long
==	O
0	int
)	O
return	O
MU_ERR_NOENT	O
;	O
}	O
dmsg	pointer
=	O
dmp	pointer
->	O
mesg	pointer
[	O
0	int
]	O
;	O
if	O
(	O
dmsg	pointer
->	O
message_start	long
!=	O
offset	long
)	O
return	O
MU_ERR_EXISTS	O
;	O
if	O
(	O
dmsg	pointer
->	O
message	pointer
)	O
{	O
if	O
(	O
pmsg	pointer
)	O
*	O
pmsg	pointer
=	O
dmsg	pointer
->	O
message	pointer
;	O
return	O
0	int
;	O
}	O
return	O
mu_dotmail_message_get	function
(	O
dmsg	pointer
,	O
pmsg	pointer
)	O
;	O
}	O
static	O
int	O
mailbox_append_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
int	O
rc	int
;	O
mu_off_t	long
size	long
;	O
mu_stream_t	pointer
istr	pointer
,	O
flt	pointer
;	O
static	O
char	O
*	O
exclude_headers	array
[	O
]	O
=	O
{	O
MU_HEADER_X_IMAPBASE	pointer
,	O
MU_HEADER_X_UID	pointer
,	O
NULL	O
}	O
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
rc	int
=	O
mu_stream_seek	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_END	int
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_message_get_streamref	function
(	O
msg	pointer
,	O
&	O
istr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
do	O
{	O
rc	int
=	O
mu_stream_header_copy	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
istr	pointer
,	O
exclude_headers	array
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
if	O
(	O
dmp	pointer
->	O
uidvalidity_scanned	int
)	O
{	O
if	O
(	O
dmp	pointer
->	O
mesg_count	long
==	O
0	int
)	O
mu_stream_printf	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
"%s: %lu %lu\n"	pointer
,	O
MU_HEADER_X_IMAPBASE	pointer
,	O
dmp	pointer
->	O
uidvalidity	long
,	O
dmp	pointer
->	O
uidnext	long
)	O
;	O
mu_stream_printf	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
"%s: %lu\n"	pointer
,	O
MU_HEADER_X_UID	pointer
,	O
dotmail_alloc_next_uid	function
(	O
dmp	pointer
)	O
)	O
;	O
}	O
rc	int
=	O
mu_stream_write	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
rc	int
=	O
mu_filter_create	function
(	O
&	O
flt	pointer
,	O
istr	pointer
,	O
"DOT"	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_destroy	function
(	O
&	O
istr	pointer
)	O
;	O
rc	int
=	O
mu_stream_copy	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
flt	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_unref	function
(	O
flt	pointer
)	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_destroy	function
(	O
&	O
istr	pointer
)	O
;	O
rc	int
=	O
mu_stream_truncate	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"cannot truncate stream after failed append: %s"	pointer
)	O
,	O
mu_stream_strerror	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
dotmail_rescan_unlocked	function
(	O
mailbox	pointer
,	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
mailbox	pointer
->	O
observable	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
mu_asprintf	function
(	O
&	O
buf	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_MESSAGE_APPEND	int
,	O
buf	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_append_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
dotmail_refresh	function
(	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
&&	O
(	O
rc	int
=	O
mu_locker_lock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s(%s):%s: %s"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
,	O
"mu_locker_lock"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mailbox_append_message	function
(	O
mailbox	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
)	O
mu_locker_unlock	function
(	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_messages_count	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
dmp	pointer
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
dotmail_refresh	function
(	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
pcount	pointer
)	O
*	O
pcount	pointer
=	O
dmp	pointer
->	O
mesg_count	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_get_size	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
mu_off_t	long
size	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_size	function
(	O
mailbox	pointer
->	O
stream	pointer
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
return	O
rc	int
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
size	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_get_atime	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
time_t	long
*	O
return_time	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
dmp	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
stat	struct
(	O
dmp	pointer
->	O
name	pointer
,	O
&	O
st	pointer
)	O
)	O
return	O
errno	O
;	O
*	O
return_time	pointer
=	O
st	pointer
.	O
st_atime	O
;	O
return	O
0	int
;	O
}	O
struct	O
mu_dotmail_flush_tracker	struct
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
;	O
struct	O
mu_dotmail_message_ref	struct
*	O
ref	pointer
;	O
size_t	long
mesg_count	long
;	O
}	O
;	O
static	O
int	O
tracker_init	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
,	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
)	O
{	O
trk	pointer
->	O
ref	pointer
=	O
calloc	function
(	O
dmp	pointer
->	O
mesg_count	long
,	O
sizeof	O
(	O
trk	pointer
->	O
ref	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
trk	pointer
->	O
ref	pointer
)	O
return	O
ENOMEM	int
;	O
trk	pointer
->	O
dmp	pointer
=	O
dmp	pointer
;	O
trk	pointer
->	O
mesg_count	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
tracker_free	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
)	O
{	O
free	function
(	O
trk	pointer
->	O
ref	pointer
)	O
;	O
}	O
static	O
struct	O
mu_dotmail_message_ref	struct
*	O
tracker_next_ref	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
,	O
size_t	long
orig_num	long
)	O
{	O
struct	O
mu_dotmail_message_ref	struct
*	O
ref	pointer
=	O
&	O
trk	pointer
->	O
ref	pointer
[	O
trk	pointer
->	O
mesg_count	long
++	O
]	O
;	O
ref	pointer
->	O
orig_num	long
=	O
orig_num	long
;	O
return	O
ref	pointer
;	O
}	O
static	O
void	O
dotmail_tracker_sync	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
trk	pointer
->	O
dmp	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
trk	pointer
->	O
mesg_count	long
==	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
mu_dotmail_message_free	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
)	O
;	O
dmp	pointer
->	O
size	long
=	O
0	int
;	O
dmp	pointer
->	O
uidvalidity_scanned	int
=	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
trk	pointer
->	O
mesg_count	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
orig_num	long
!=	O
i	long
)	O
{	O
size_t	long
j	int
;	O
for	O
(	O
j	int
=	O
i	long
;	O
j	int
<	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
orig_num	long
;	O
j	int
++	O
)	O
mu_dotmail_message_free	function
(	O
dmp	pointer
->	O
mesg	pointer
[	O
j	int
]	O
)	O
;	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
=	O
dmp	pointer
->	O
mesg	pointer
[	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
orig_num	long
]	O
;	O
}	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
->	O
message_start	long
=	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
message_start	long
;	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
->	O
body_start	long
=	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
body_start	long
;	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
->	O
message_end	long
=	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
message_end	long
;	O
if	O
(	O
trk	pointer
->	O
ref	pointer
[	O
i	long
]	O
.	O
rescan	int
)	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
->	O
body_lines_scanned	int
=	O
0	int
;	O
}	O
dmp	pointer
->	O
mesg_count	long
=	O
trk	pointer
->	O
mesg_count	long
;	O
dmp	pointer
->	O
size	long
=	O
trk	pointer
->	O
ref	pointer
[	O
trk	pointer
->	O
mesg_count	long
-	O
1	int
]	O
.	O
message_end	long
+	O
2	int
;	O
}	O
}	O
static	O
int	O
dotmail_mailbox_copy_unchanged	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
,	O
size_t	long
from	pointer
,	O
size_t	long
to	pointer
,	O
mu_stream_t	pointer
dest	pointer
)	O
{	O
if	O
(	O
to	pointer
>	O
from	pointer
)	O
{	O
size_t	long
i	long
;	O
mu_off_t	long
off	long
;	O
int	O
rc	int
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
trk	pointer
->	O
dmp	pointer
;	O
rc	int
=	O
mu_stream_seek	function
(	O
dest	pointer
,	O
0	int
,	O
MU_SEEK_CUR	int
,	O
&	O
off	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
off	long
-=	O
trk	pointer
->	O
dmp	pointer
->	O
mesg	pointer
[	O
from	pointer
]	O
->	O
message_start	long
;	O
for	O
(	O
i	long
=	O
from	pointer
;	O
i	long
<	O
to	pointer
;	O
i	long
++	O
)	O
{	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
=	O
trk	pointer
->	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
;	O
struct	O
mu_dotmail_message_ref	struct
*	O
ref	pointer
=	O
tracker_next_ref	function
(	O
trk	pointer
,	O
i	long
)	O
;	O
ref	pointer
->	O
message_start	long
=	O
dmsg	pointer
->	O
message_start	long
+	O
off	long
;	O
ref	pointer
->	O
body_start	long
=	O
dmsg	pointer
->	O
body_start	long
+	O
off	long
;	O
ref	pointer
->	O
message_end	long
=	O
dmsg	pointer
->	O
message_end	long
+	O
off	long
;	O
ref	pointer
->	O
rescan	int
=	O
0	int
;	O
}	O
if	O
(	O
to	pointer
==	O
dmp	pointer
->	O
mesg_count	long
)	O
off	long
=	O
dmp	pointer
->	O
mesg	pointer
[	O
to	pointer
-	O
1	int
]	O
->	O
message_end	long
+	O
2	int
;	O
else	O
off	long
=	O
dmp	pointer
->	O
mesg	pointer
[	O
to	pointer
]	O
->	O
message_start	long
;	O
rc	int
=	O
mu_stream_seek	function
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
dmp	pointer
->	O
mesg	pointer
[	O
from	pointer
]	O
->	O
message_start	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
return	O
mu_stream_copy	function
(	O
dest	pointer
,	O
dmp	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
off	long
-	O
dmp	pointer
->	O
mesg	pointer
[	O
from	pointer
]	O
->	O
message_start	long
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dotmail_flush_temp	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
,	O
size_t	long
i	long
,	O
mu_stream_t	pointer
tempstr	pointer
,	O
int	O
expunge	int
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
trk	pointer
->	O
dmp	pointer
;	O
size_t	long
start	long
=	O
0	int
;	O
size_t	long
save_imapbase	long
=	O
0	int
;	O
size_t	long
expcount	long
=	O
0	int
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	function
(	O
trk	pointer
->	O
dmp	pointer
->	O
mailbox	pointer
->	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
while	O
(	O
i	long
<	O
dmp	pointer
->	O
mesg_count	long
)	O
{	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
=	O
dmp	pointer
->	O
mesg	pointer
[	O
i	long
]	O
;	O
if	O
(	O
expunge	int
&&	O
(	O
dmsg	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_DELETED	int
)	O
)	O
{	O
size_t	long
expevt	array
[	O
2	int
]	O
=	O
{	O
i	long
+	O
1	int
,	O
expcount	long
}	O
;	O
rc	int
=	O
dotmail_mailbox_copy_unchanged	function
(	O
trk	pointer
,	O
start	long
,	O
i	long
,	O
tempstr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_observable_notify	function
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_MESSAGE_EXPUNGE	int
,	O
expevt	array
)	O
;	O
expcount	long
++	O
;	O
mu_message_destroy	function
(	O
&	O
dmsg	pointer
->	O
message	pointer
,	O
dmsg	pointer
)	O
;	O
if	O
(	O
i	long
==	O
save_imapbase	long
)	O
{	O
save_imapbase	long
=	O
i	long
+	O
1	int
;	O
if	O
(	O
save_imapbase	long
<	O
dmp	pointer
->	O
mesg_count	long
)	O
dmp	pointer
->	O
mesg	pointer
[	O
save_imapbase	long
]	O
->	O
attr_flags	int
|=	O
MU_ATTRIBUTE_MODIFIED	int
;	O
}	O
i	long
++	O
;	O
start	long
=	O
i	long
;	O
continue	O
;	O
}	O
if	O
(	O
dmsg	pointer
->	O
uid_modified	int
||	O
(	O
dmsg	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_MODIFIED	int
)	O
||	O
mu_message_is_modified	function
(	O
dmsg	pointer
->	O
message	pointer
)	O
)	O
{	O
rc	int
=	O
dotmail_mailbox_copy_unchanged	function
(	O
trk	pointer
,	O
start	long
,	O
i	long
,	O
tempstr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
free	function
(	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_imapbase	int
]	O
)	O
;	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_imapbase	int
]	O
=	O
NULL	O
;	O
if	O
(	O
save_imapbase	long
==	O
i	long
)	O
{	O
mu_asprintf	function
(	O
&	O
dmsg	pointer
->	O
hdr	array
[	O
mu_dotmail_hdr_x_imapbase	int
]	O
,	O
"%lu %lu"	pointer
,	O
dmp	pointer
->	O
uidvalidity	long
,	O
dmp	pointer
->	O
uidnext	long
)	O
;	O
}	O
rc	int
=	O
mu_dotmail_message_reconstruct	function
(	O
tempstr	pointer
,	O
dmsg	pointer
,	O
tracker_next_ref	function
(	O
trk	pointer
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
i	long
++	O
;	O
start	long
=	O
i	long
;	O
continue	O
;	O
}	O
i	long
++	O
;	O
}	O
rc	int
=	O
dotmail_mailbox_copy_unchanged	function
(	O
trk	pointer
,	O
start	long
,	O
i	long
,	O
tempstr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
return	O
mu_stream_flush	function
(	O
tempstr	pointer
)	O
;	O
}	O
static	O
int	O
dotmail_flush_unlocked	function
(	O
struct	O
mu_dotmail_flush_tracker	struct
*	O
trk	pointer
,	O
int	O
expunge	int
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
trk	pointer
->	O
dmp	pointer
;	O
int	O
rc	int
;	O
size_t	long
dirty	long
;	O
mu_stream_t	pointer
tempstr	pointer
;	O
struct	O
mu_tempfile_hints	struct
hints	pointer
;	O
int	O
tempfd	int
;	O
char	O
*	O
tempname	pointer
;	O
char	O
*	O
p	pointer
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s (%s)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
dmp	pointer
->	O
mesg_count	long
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
flags	int
&	O
MU_STREAM_APPEND	int
)	O
return	O
mu_stream_flush	function
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
rc	int
=	O
dotmail_refresh	function
(	O
dmp	pointer
->	O
mailbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
dirty	long
=	O
0	int
;	O
dirty	long
<	O
dmp	pointer
->	O
mesg_count	long
;	O
dirty	long
++	O
)	O
{	O
struct	O
mu_dotmail_message	struct
*	O
dmsg	pointer
=	O
dmp	pointer
->	O
mesg	pointer
[	O
dirty	long
]	O
;	O
if	O
(	O
dmsg	pointer
->	O
uid_modified	int
)	O
break	O
;	O
mu_dotmail_message_attr_load	function
(	O
dmsg	pointer
)	O
;	O
if	O
(	O
(	O
dmsg	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_MODIFIED	int
)	O
||	O
(	O
dmsg	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_DELETED	int
)	O
||	O
(	O
dmsg	pointer
->	O
message	pointer
&&	O
mu_message_is_modified	function
(	O
dmsg	pointer
->	O
message	pointer
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
dirty	long
+	O
1	int
==	O
dmp	pointer
->	O
mesg_count	long
)	O
return	O
0	int
;	O
p	pointer
=	O
strrchr	function
(	O
dmp	pointer
->	O
name	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
size_t	long
l	long
=	O
p	pointer
-	O
dmp	pointer
->	O
name	pointer
;	O
hints	pointer
.	O
tmpdir	pointer
=	O
malloc	function
(	O
l	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
hints	pointer
.	O
tmpdir	pointer
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
hints	pointer
.	O
tmpdir	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
l	long
)	O
;	O
hints	pointer
.	O
tmpdir	pointer
[	O
l	long
]	O
=	O
0	int
;	O
}	O
else	O
{	O
hints	pointer
.	O
tmpdir	pointer
=	O
mu_getcwd	function
(	O
)	O
;	O
if	O
(	O
!	O
hints	pointer
.	O
tmpdir	pointer
)	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_tempfile	function
(	O
&	O
hints	pointer
,	O
MU_TEMPFILE_TMPDIR	int
,	O
&	O
tempfd	int
,	O
&	O
tempname	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
hints	pointer
.	O
tmpdir	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_fd_stream_create	function
(	O
&	O
tempstr	pointer
,	O
tempname	pointer
,	O
tempfd	int
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
hints	pointer
.	O
tmpdir	pointer
)	O
;	O
close	function
(	O
tempfd	int
)	O
;	O
free	function
(	O
tempname	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
dotmail_flush_temp	function
(	O
trk	pointer
,	O
dirty	long
,	O
tempstr	pointer
,	O
expunge	int
)	O
;	O
mu_stream_unref	function
(	O
tempstr	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
char	O
*	O
backup	pointer
=	O
mu_tempname	function
(	O
hints	pointer
.	O
tmpdir	pointer
)	O
;	O
rc	int
=	O
rename	function
(	O
dmp	pointer
->	O
name	pointer
,	O
backup	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s:%s: failed to rename to backup file %s: %s"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
,	O
tempname	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
unlink	function
(	O
backup	pointer
)	O
;	O
}	O
else	O
{	O
rc	int
=	O
rename	function
(	O
tempname	pointer
,	O
dmp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dotmail_tracker_sync	function
(	O
trk	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
dmp	pointer
->	O
mailbox	pointer
->	O
stream	pointer
)	O
;	O
rc	int
=	O
dotmail_mailbox_init_stream	function
(	O
dmp	pointer
)	O
;	O
}	O
else	O
{	O
int	O
rc1	int
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"%s: failed to rename temporary file %s %s: %s"	pointer
,	O
__func__	O
,	O
tempname	pointer
,	O
dmp	pointer
->	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
rc1	int
=	O
rename	function
(	O
backup	pointer
,	O
dmp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
rc1	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"failed to restore %s from backup %s: %s"	pointer
)	O
,	O
dmp	pointer
->	O
name	pointer
,	O
backup	pointer
,	O
mu_strerror	function
(	O
rc1	int
)	O
)	O
;	O
mu_error	function
(	O
_	O
(	O
"backup left in %s"	pointer
)	O
,	O
backup	pointer
)	O
;	O
free	function
(	O
backup	pointer
)	O
;	O
backup	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
if	O
(	O
backup	pointer
)	O
{	O
unlink	function
(	O
backup	pointer
)	O
;	O
free	function
(	O
backup	pointer
)	O
;	O
}	O
}	O
unlink	function
(	O
tempname	pointer
)	O
;	O
free	function
(	O
tempname	pointer
)	O
;	O
free	function
(	O
hints	pointer
.	O
tmpdir	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_flush	function
(	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
,	O
int	O
expunge	int
)	O
{	O
int	O
rc	int
;	O
sigset_t	struct
signalset	struct
;	O
int	O
state	pointer
;	O
struct	O
mu_dotmail_flush_tracker	struct
trk	pointer
;	O
if	O
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
locker	pointer
&&	O
(	O
rc	int
=	O
mu_locker_lock	function
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
locker	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
rc	int
;	O
pthread_setcancelstate	function
(	O
PTHREAD_CANCEL_DISABLE	int
,	O
&	O
state	pointer
)	O
;	O
sigemptyset	function
(	O
&	O
signalset	struct
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGTERM	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGHUP	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGTSTP	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
signalset	struct
,	O
SIGWINCH	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
signalset	struct
,	O
0	int
)	O
;	O
rc	int
=	O
tracker_init	function
(	O
&	O
trk	pointer
,	O
dmp	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
dotmail_flush_unlocked	function
(	O
&	O
trk	pointer
,	O
expunge	int
)	O
;	O
tracker_free	function
(	O
&	O
trk	pointer
)	O
;	O
}	O
pthread_setcancelstate	function
(	O
state	pointer
,	O
&	O
state	pointer
)	O
;	O
sigprocmask	function
(	O
SIG_UNBLOCK	int
,	O
&	O
signalset	struct
,	O
0	int
)	O
;	O
if	O
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
locker	pointer
)	O
mu_locker_unlock	function
(	O
dmp	pointer
->	O
mailbox	pointer
->	O
locker	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
dotmail_expunge	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
return	O
dotmail_flush	function
(	O
dmp	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
dotmail_sync	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
return	O
dotmail_flush	function
(	O
dmp	pointer
,	O
0	int
)	O
;	O
}	O
int	O
mu_dotmail_mailbox_init	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
mu_dotmail_mailbox	struct
*	O
dmp	pointer
;	O
mu_property_t	pointer
property	pointer
=	O
NULL	O
;	O
if	O
(	O
mailbox	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
dmp	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
dmp	pointer
)	O
)	O
;	O
if	O
(	O
dmp	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
dmp	pointer
->	O
mailbox	pointer
=	O
mailbox	pointer
;	O
status	int
=	O
mu_url_aget_path	function
(	O
mailbox	pointer
->	O
url	pointer
,	O
&	O
dmp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
dmp	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mailbox	pointer
->	O
data	pointer
=	O
dmp	pointer
;	O
mailbox	pointer
->	O
_destroy	pointer
=	O
dotmail_destroy	function
;	O
mailbox	pointer
->	O
_open	pointer
=	O
dotmail_open	function
;	O
mailbox	pointer
->	O
_close	pointer
=	O
dotmail_close	function
;	O
mailbox	pointer
->	O
_remove	pointer
=	O
dotmail_remove	function
;	O
mailbox	pointer
->	O
_scan	pointer
=	O
dotmail_scan	function
;	O
mailbox	pointer
->	O
_is_updated	pointer
=	O
dotmail_is_updated	function
;	O
mailbox	pointer
->	O
_get_message	pointer
=	O
dotmail_get_message	function
;	O
mailbox	pointer
->	O
_quick_get_message	pointer
=	O
dotmail_quick_get_message	function
;	O
mailbox	pointer
->	O
_messages_count	pointer
=	O
dotmail_messages_count	function
;	O
mailbox	pointer
->	O
_messages_recent	pointer
=	O
dotmail_messages_recent	function
;	O
mailbox	pointer
->	O
_message_unseen	pointer
=	O
dotmail_message_unseen	function
;	O
mailbox	pointer
->	O
_append_message	pointer
=	O
dotmail_append_message	function
;	O
mailbox	pointer
->	O
_expunge	pointer
=	O
dotmail_expunge	function
;	O
mailbox	pointer
->	O
_sync	pointer
=	O
dotmail_sync	function
;	O
mailbox	pointer
->	O
_uidvalidity	pointer
=	O
dotmail_uidvalidity	function
;	O
mailbox	pointer
->	O
_uidnext	pointer
=	O
dotmail_uidnext	function
;	O
mailbox	pointer
->	O
_get_size	pointer
=	O
dotmail_get_size	function
;	O
mailbox	pointer
->	O
_get_atime	pointer
=	O
dotmail_get_atime	function
;	O
mu_mailbox_get_property	function
(	O
mailbox	pointer
,	O
&	O
property	pointer
)	O
;	O
mu_property_set_value	function
(	O
property	pointer
,	O
"TYPE"	pointer
,	O
"DOTMAIL"	pointer
,	O
1	int
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"%s (%s)"	pointer
,	O
__func__	O
,	O
dmp	pointer
->	O
name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O