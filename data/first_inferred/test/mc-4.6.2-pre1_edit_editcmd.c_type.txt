struct	O
selection	struct
{	O
unsigned	O
char	O
*	O
text	pointer
;	O
int	O
len	int
;	O
}	O
;	O
static	O
int	O
replace_scanf	int
=	O
0	int
;	O
static	O
int	O
replace_regexp	int
=	O
0	int
;	O
static	O
int	O
replace_all	int
=	O
0	int
;	O
static	O
int	O
replace_prompt	int
=	O
1	int
;	O
static	O
int	O
replace_whole	int
=	O
0	int
;	O
static	O
int	O
replace_case	int
=	O
0	int
;	O
static	O
int	O
replace_backwards	int
=	O
0	int
;	O
static	O
int	O
search_create_bookmark	int
=	O
0	int
;	O
int	O
edit_confirm_save	int
=	O
1	int
;	O
static	O
int	O
edit_save_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
;	O
static	O
unsigned	O
char	O
*	O
edit_get_block	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
start	pointer
,	O
long	O
finish	long
,	O
int	O
*	O
l	pointer
)	O
;	O
static	O
inline	O
int	O
my_lower_case	function
(	O
int	O
c	int
)	O
{	O
return	O
tolower	function
(	O
c	int
&	O
0xFF	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
strcasechr	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
c	int
)	O
{	O
for	O
(	O
c	int
=	O
my_lower_case	function
(	O
c	int
)	O
;	O
my_lower_case	function
(	O
(	O
int	O
)	O
*	O
s	pointer
)	O
!=	O
c	int
;	O
++	O
s	pointer
)	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
return	O
0	int
;	O
return	O
s	pointer
;	O
}	O
static	O
char	O
*	O
MY_itoa	function
(	O
int	O
i	array
)	O
{	O
static	O
char	O
t	long
[	O
14	int
]	O
;	O
char	O
*	O
s	pointer
=	O
t	long
+	O
13	int
;	O
int	O
j	int
=	O
i	array
;	O
*	O
s	pointer
--	O
=	O
0	int
;	O
do	O
{	O
*	O
s	pointer
--	O
=	O
i	array
%	O
10	int
+	O
'0'	O
;	O
}	O
while	O
(	O
(	O
i	array
=	O
i	array
/	O
10	int
)	O
)	O
;	O
if	O
(	O
j	int
<	O
0	int
)	O
*	O
s	pointer
--	O
=	O
'-'	O
;	O
return	O
++	O
s	pointer
;	O
}	O
static	O
char	O
*	O
stacked	array
[	O
16	int
]	O
;	O
static	O
const	O
char	O
*	O
catstrs	function
(	O
const	O
char	O
*	O
first	pointer
,	O
...	O
)	O
{	O
static	O
int	O
i	array
=	O
0	int
;	O
va_list	array
ap	array
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
if	O
(	O
!	O
first	pointer
)	O
return	O
0	int
;	O
len	int
=	O
strlen	function
(	O
first	pointer
)	O
;	O
va_start	O
(	O
ap	array
,	O
first	pointer
)	O
;	O
while	O
(	O
(	O
data	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
0	int
)	O
len	int
+=	O
strlen	function
(	O
data	pointer
)	O
;	O
len	int
++	O
;	O
i	array
=	O
(	O
i	array
+	O
1	int
)	O
%	O
16	int
;	O
g_free	function
(	O
stacked	array
[	O
i	array
]	O
)	O
;	O
stacked	array
[	O
i	array
]	O
=	O
g_malloc	function
(	O
len	int
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
va_start	O
(	O
ap	array
,	O
first	pointer
)	O
;	O
strcpy	function
(	O
stacked	array
[	O
i	array
]	O
,	O
first	pointer
)	O
;	O
while	O
(	O
(	O
data	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
0	int
)	O
strcat	function
(	O
stacked	array
[	O
i	array
]	O
,	O
data	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
stacked	array
[	O
i	array
]	O
;	O
}	O
void	O
freestrs	function
(	O
void	O
)	O
{	O
size_t	long
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
sizeof	O
(	O
stacked	array
)	O
/	O
sizeof	O
(	O
stacked	array
[	O
0	int
]	O
)	O
;	O
i	array
++	O
)	O
{	O
g_free	function
(	O
stacked	array
[	O
i	array
]	O
)	O
;	O
stacked	array
[	O
i	array
]	O
=	O
NULL	O
;	O
}	O
}	O
void	O
edit_help_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
interactive_display	function
(	O
NULL	O
,	O
"[Internal File Editor]"	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
}	O
void	O
edit_refresh_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
{	O
int	O
color	pointer
;	O
edit_get_syntax_color	function
(	O
edit	pointer
,	O
-	O
1	int
,	O
&	O
color	pointer
)	O
;	O
}	O
touchwin	O
(	O
stdscr	O
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
doupdate	O
(	O
)	O
;	O
}	O
static	O
int	O
edit_save_file	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
long	O
filelen	long
=	O
0	int
;	O
char	O
*	O
savename	pointer
=	O
0	int
;	O
int	O
this_save_mode	int
,	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
filename	pointer
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
filename	pointer
)	O
return	O
0	int
;	O
if	O
(	O
*	O
filename	pointer
!=	O
PATH_SEP	char
&&	O
edit	pointer
->	O
dir	pointer
)	O
{	O
savename	pointer
=	O
concat_dir_and_file	function
(	O
edit	pointer
->	O
dir	pointer
,	O
filename	pointer
)	O
;	O
filename	pointer
=	O
catstrs	function
(	O
savename	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
savename	pointer
)	O
;	O
}	O
this_save_mode	int
=	O
option_save_mode	int
;	O
if	O
(	O
this_save_mode	int
!=	O
EDIT_QUICK_SAVE	int
)	O
{	O
if	O
(	O
!	O
vfs_file_is_local	function
(	O
filename	pointer
)	O
||	O
(	O
fd	int
=	O
mc_open	function
(	O
filename	pointer
,	O
O_WRONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
this_save_mode	int
=	O
EDIT_QUICK_SAVE	int
;	O
}	O
if	O
(	O
fd	int
!=	O
-	O
1	int
)	O
mc_close	function
(	O
fd	int
)	O
;	O
}	O
if	O
(	O
this_save_mode	int
==	O
EDIT_QUICK_SAVE	int
&&	O
!	O
edit	pointer
->	O
skip_detach_prompt	int
)	O
{	O
int	O
rv	int
;	O
struct	O
stat	struct
sb	struct
;	O
rv	int
=	O
mc_stat	function
(	O
filename	pointer
,	O
&	O
sb	struct
)	O
;	O
if	O
(	O
rv	int
==	O
0	int
&&	O
sb	struct
.	O
st_nlink	long
>	O
1	int
)	O
{	O
rv	int
=	O
edit_query_dialog3	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" File has hard-links. Detach before saving? "	pointer
)	O
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
;	O
switch	O
(	O
rv	int
)	O
{	O
case	O
0	int
:	O
this_save_mode	int
=	O
EDIT_SAFE_SAVE	int
;	O
case	O
1	int
:	O
edit	pointer
->	O
skip_detach_prompt	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
rv	int
==	O
0	int
&&	O
edit	pointer
->	O
stat1	struct
.	O
st_mtime	O
!=	O
0	int
&&	O
edit	pointer
->	O
stat1	struct
.	O
st_mtime	O
!=	O
sb	struct
.	O
st_mtime	O
)	O
{	O
query_set_sel	function
(	O
1	int
)	O
;	O
rv	int
=	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
"The file has been modified in the meantime. Save anyway?"	pointer
)	O
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
;	O
if	O
(	O
rv	int
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
this_save_mode	int
!=	O
EDIT_QUICK_SAVE	int
)	O
{	O
char	O
*	O
savedir	pointer
,	O
*	O
saveprefix	pointer
;	O
const	O
char	O
*	O
slashpos	pointer
;	O
slashpos	pointer
=	O
strrchr	function
(	O
filename	pointer
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
slashpos	pointer
)	O
{	O
savedir	pointer
=	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
savedir	pointer
[	O
slashpos	pointer
-	O
filename	pointer
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
savedir	pointer
=	O
g_strdup	function
(	O
"."	pointer
)	O
;	O
saveprefix	pointer
=	O
concat_dir_and_file	function
(	O
savedir	pointer
,	O
"cooledit"	pointer
)	O
;	O
g_free	function
(	O
savedir	pointer
)	O
;	O
fd	int
=	O
mc_mkstemps	function
(	O
&	O
savename	pointer
,	O
saveprefix	pointer
,	O
NULL	O
)	O
;	O
g_free	function
(	O
saveprefix	pointer
)	O
;	O
if	O
(	O
!	O
savename	pointer
)	O
return	O
0	int
;	O
close	pointer
(	O
fd	int
)	O
;	O
}	O
else	O
savename	pointer
=	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
mc_chown	function
(	O
savename	pointer
,	O
edit	pointer
->	O
stat1	struct
.	O
st_uid	int
,	O
edit	pointer
->	O
stat1	struct
.	O
st_gid	int
)	O
;	O
mc_chmod	function
(	O
savename	pointer
,	O
edit	pointer
->	O
stat1	struct
.	O
st_mode	int
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
mc_open	function
(	O
savename	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_TRUNC	int
|	O
O_BINARY	int
,	O
edit	pointer
->	O
stat1	struct
.	O
st_mode	int
)	O
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
if	O
(	O
(	O
p	pointer
=	O
edit_get_write_filter	function
(	O
savename	pointer
,	O
filename	pointer
)	O
)	O
)	O
{	O
FILE	struct
*	O
file	pointer
;	O
mc_close	function
(	O
fd	int
)	O
;	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
popen	function
(	O
p	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
file	pointer
)	O
{	O
filelen	long
=	O
edit_write_stream	function
(	O
edit	pointer
,	O
file	pointer
)	O
;	O
pclose	function
(	O
file	pointer
)	O
;	O
}	O
else	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
get_sys_error	O
(	O
catstrs	function
(	O
_	O
(	O
" Cannot open pipe for writing: "	pointer
)	O
,	O
p	pointer
,	O
" "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
goto	O
error_save	O
;	O
}	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
else	O
{	O
long	O
buf	pointer
;	O
buf	pointer
=	O
0	int
;	O
filelen	long
=	O
edit	pointer
->	O
last_byte	long
;	O
while	O
(	O
buf	pointer
<=	O
(	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
)	O
-	O
1	int
)	O
{	O
if	O
(	O
mc_write	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	pointer
->	O
buffers1	array
[	O
buf	pointer
]	O
,	O
EDIT_BUF_SIZE	O
)	O
!=	O
EDIT_BUF_SIZE	O
)	O
{	O
mc_close	function
(	O
fd	int
)	O
;	O
goto	O
error_save	O
;	O
}	O
buf	pointer
++	O
;	O
}	O
if	O
(	O
mc_write	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	pointer
->	O
buffers1	array
[	O
buf	pointer
]	O
,	O
edit	pointer
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
!=	O
(	O
edit	pointer
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
filelen	long
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
edit	pointer
->	O
curs2	long
)	O
{	O
edit	pointer
->	O
curs2	long
--	O
;	O
buf	pointer
=	O
(	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
)	O
;	O
if	O
(	O
mc_write	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	pointer
->	O
buffers2	array
[	O
buf	pointer
]	O
+	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
,	O
1	int
+	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
!=	O
1	int
+	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
filelen	long
=	O
-	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
--	O
buf	pointer
>=	O
0	int
)	O
{	O
if	O
(	O
mc_write	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
edit	pointer
->	O
buffers2	array
[	O
buf	pointer
]	O
,	O
EDIT_BUF_SIZE	O
)	O
!=	O
EDIT_BUF_SIZE	O
)	O
{	O
filelen	long
=	O
-	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
edit	pointer
->	O
curs2	long
++	O
;	O
}	O
if	O
(	O
mc_close	function
(	O
fd	int
)	O
)	O
goto	O
error_save	O
;	O
if	O
(	O
mc_stat	function
(	O
savename	pointer
,	O
&	O
edit	pointer
->	O
stat1	struct
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
}	O
if	O
(	O
filelen	long
!=	O
edit	pointer
->	O
last_byte	long
)	O
goto	O
error_save	O
;	O
if	O
(	O
this_save_mode	int
==	O
EDIT_DO_BACKUP	int
)	O
{	O
assert	O
(	O
option_backup_ext	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
mc_rename	function
(	O
filename	pointer
,	O
catstrs	function
(	O
filename	pointer
,	O
option_backup_ext	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
}	O
if	O
(	O
this_save_mode	int
!=	O
EDIT_QUICK_SAVE	int
)	O
if	O
(	O
mc_rename	function
(	O
savename	pointer
,	O
filename	pointer
)	O
==	O
-	O
1	int
)	O
goto	O
error_save	O
;	O
g_free	function
(	O
savename	pointer
)	O
;	O
return	O
1	int
;	O
error_save	O
:	O
g_free	function
(	O
savename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
menu_save_mode_cmd	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
str_result	pointer
;	O
static	O
int	O
save_mode_new	int
;	O
static	O
const	O
char	O
*	O
str	pointer
[	O
]	O
=	O
{	O
N_	O
(	O
"Quick save "	pointer
)	O
,	O
N_	O
(	O
"Safe save "	pointer
)	O
,	O
N_	O
(	O
"Do backups -->"	pointer
)	O
}	O
;	O
static	O
QuickWidget	struct
widgets	pointer
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
18	int
,	O
DLG_X	int
,	O
7	int
,	O
DLG_Y	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
6	int
,	O
DLG_X	int
,	O
7	int
,	O
DLG_Y	int
,	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
23	int
,	O
DLG_X	int
,	O
5	int
,	O
DLG_Y	int
,	O
0	int
,	O
9	int
,	O
0	int
,	O
0	int
,	O
&	O
str_result	pointer
,	O
"edit-backup-ext"	pointer
}	O
,	O
{	O
quick_label	int
,	O
22	int
,	O
DLG_X	int
,	O
4	int
,	O
DLG_Y	int
,	O
N_	O
(	O
"Extension:"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_radio	int
,	O
4	int
,	O
DLG_X	int
,	O
3	int
,	O
DLG_Y	int
,	O
""	pointer
,	O
3	int
,	O
0	int
,	O
&	O
save_mode_new	int
,	O
(	O
char	O
*	O
*	O
)	O
str	pointer
,	O
NULL	O
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
static	O
QuickDialog	struct
dialog	struct
=	O
{	O
DLG_X	int
,	O
DLG_Y	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
N_	O
(	O
" Edit Save Mode "	pointer
)	O
,	O
"[Edit Save Mode]"	pointer
,	O
widgets	pointer
,	O
0	int
}	O
;	O
static	O
int	O
i18n_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
size_t	long
i	array
;	O
size_t	long
maxlen	long
=	O
0	int
;	O
int	O
dlg_x	int
;	O
size_t	long
l1	long
;	O
l1	long
=	O
strlen	function
(	O
_	O
(	O
widgets	pointer
[	O
0	int
]	O
.	O
text	pointer
)	O
)	O
+	O
strlen	function
(	O
_	O
(	O
widgets	pointer
[	O
1	int
]	O
.	O
text	pointer
)	O
)	O
+	O
5	int
;	O
maxlen	long
=	O
max	long
(	O
maxlen	long
,	O
l1	long
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
3	int
;	O
i	array
++	O
)	O
{	O
str	pointer
[	O
i	array
]	O
=	O
_	O
(	O
str	pointer
[	O
i	array
]	O
)	O
;	O
maxlen	long
=	O
max	long
(	O
maxlen	long
,	O
strlen	function
(	O
str	pointer
[	O
i	array
]	O
)	O
+	O
7	int
)	O
;	O
}	O
i18n_flag	int
=	O
1	int
;	O
dlg_x	int
=	O
maxlen	long
+	O
strlen	function
(	O
_	O
(	O
widgets	pointer
[	O
3	int
]	O
.	O
text	pointer
)	O
)	O
+	O
5	int
+	O
1	int
;	O
widgets	pointer
[	O
2	int
]	O
.	O
hotkey_pos	int
=	O
strlen	function
(	O
_	O
(	O
widgets	pointer
[	O
3	int
]	O
.	O
text	pointer
)	O
)	O
;	O
dlg_x	int
=	O
min	long
(	O
COLS	O
,	O
dlg_x	int
)	O
;	O
dialog	struct
.	O
xlen	int
=	O
dlg_x	int
;	O
i	array
=	O
(	O
dlg_x	int
-	O
l1	long
)	O
/	O
3	int
;	O
widgets	pointer
[	O
1	int
]	O
.	O
relative_x	int
=	O
i	array
;	O
widgets	pointer
[	O
0	int
]	O
.	O
relative_x	int
=	O
i	array
+	O
strlen	function
(	O
_	O
(	O
widgets	pointer
[	O
1	int
]	O
.	O
text	pointer
)	O
)	O
+	O
i	array
+	O
4	int
;	O
widgets	pointer
[	O
2	int
]	O
.	O
relative_x	int
=	O
widgets	pointer
[	O
3	int
]	O
.	O
relative_x	int
=	O
maxlen	long
+	O
2	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
sizeof	O
(	O
widgets	pointer
)	O
/	O
sizeof	O
(	O
widgets	pointer
[	O
0	int
]	O
)	O
;	O
i	array
++	O
)	O
widgets	pointer
[	O
i	array
]	O
.	O
x_divisions	int
=	O
dlg_x	int
;	O
}	O
assert	O
(	O
option_backup_ext	pointer
!=	O
NULL	O
)	O
;	O
widgets	pointer
[	O
2	int
]	O
.	O
text	pointer
=	O
option_backup_ext	pointer
;	O
widgets	pointer
[	O
4	int
]	O
.	O
value	pointer
=	O
option_save_mode	int
;	O
if	O
(	O
quick_dialog	function
(	O
&	O
dialog	struct
)	O
!=	O
B_ENTER	int
)	O
return	O
;	O
option_save_mode	int
=	O
save_mode_new	int
;	O
g_free	function
(	O
option_backup_ext	pointer
)	O
;	O
option_backup_ext	pointer
=	O
str_result	pointer
;	O
str_result	pointer
=	O
NULL	O
;	O
}	O
void	O
edit_set_filename	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
f	pointer
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
f	pointer
=	O
""	pointer
;	O
edit	pointer
->	O
filename	pointer
=	O
g_strdup	function
(	O
f	pointer
)	O
;	O
if	O
(	O
edit	pointer
->	O
dir	pointer
==	O
NULL	O
&&	O
*	O
f	pointer
!=	O
PATH_SEP	char
)	O
edit	pointer
->	O
dir	pointer
=	O
g_strdup	function
(	O
vfs_get_current_dir	function
(	O
)	O
)	O
;	O
}	O
int	O
edit_save_as_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
exp	pointer
;	O
int	O
save_lock	int
=	O
0	int
;	O
int	O
different_filename	int
=	O
0	int
;	O
exp	pointer
=	O
edit_get_save_file	O
(	O
edit	pointer
->	O
filename	pointer
,	O
_	O
(	O
" Save As "	pointer
)	O
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
if	O
(	O
exp	pointer
)	O
{	O
if	O
(	O
!	O
*	O
exp	pointer
)	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
rv	int
;	O
if	O
(	O
strcmp	function
(	O
edit	pointer
->	O
filename	pointer
,	O
exp	pointer
)	O
)	O
{	O
int	O
file	pointer
;	O
different_filename	int
=	O
1	int
;	O
if	O
(	O
(	O
file	pointer
=	O
mc_open	function
(	O
exp	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
mc_close	function
(	O
file	pointer
)	O
;	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" A file already exists with this name. "	pointer
)	O
,	O
_	O
(	O
"&Overwrite"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
)	O
{	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
g_free	function
(	O
exp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
save_lock	int
=	O
edit_lock_file	function
(	O
exp	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
locked	int
&&	O
!	O
edit	pointer
->	O
delete_file	int
)	O
save_lock	int
=	O
edit_lock_file	function
(	O
exp	pointer
)	O
;	O
}	O
rv	int
=	O
edit_save_file	function
(	O
edit	pointer
,	O
exp	pointer
)	O
;	O
switch	O
(	O
rv	int
)	O
{	O
case	O
1	int
:	O
if	O
(	O
different_filename	int
)	O
{	O
if	O
(	O
save_lock	int
)	O
edit_unlock_file	function
(	O
exp	pointer
)	O
;	O
if	O
(	O
edit	pointer
->	O
locked	int
)	O
edit	pointer
->	O
locked	int
=	O
edit_unlock_file	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
edit	pointer
->	O
locked	int
||	O
save_lock	int
)	O
edit	pointer
->	O
locked	int
=	O
edit_unlock_file	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
}	O
edit_set_filename	function
(	O
edit	pointer
,	O
exp	pointer
)	O
;	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit	pointer
->	O
modified	long
=	O
0	int
;	O
edit	pointer
->	O
delete_file	int
=	O
0	int
;	O
if	O
(	O
different_filename	int
)	O
edit_load_syntax	function
(	O
edit	pointer
,	O
NULL	O
,	O
option_syntax_type	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
1	int
;	O
default	O
:	O
edit_error_dialog	O
(	O
_	O
(	O
" Save As "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot save file. "	pointer
)	O
)	O
)	O
;	O
case	O
-	O
1	int
:	O
if	O
(	O
save_lock	int
)	O
edit_unlock_file	function
(	O
exp	pointer
)	O
;	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
static	O
cb_ret_t	enum
raw_callback	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_KEY	int
:	O
h	pointer
->	O
running	int
=	O
0	int
;	O
h	pointer
->	O
ret_value	int
=	O
parm	int
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
int	O
edit_raw_key_query	function
(	O
const	O
char	O
*	O
heading	pointer
,	O
const	O
char	O
*	O
query	pointer
,	O
int	O
cancel	int
)	O
{	O
int	O
w	pointer
=	O
strlen	function
(	O
query	pointer
)	O
+	O
7	int
;	O
struct	O
Dlg_head	struct
*	O
raw_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
7	int
,	O
w	pointer
,	O
dialog_colors	array
,	O
raw_callback	function
,	O
NULL	O
,	O
heading	pointer
,	O
DLG_CENTER	O
|	O
DLG_TRYUP	O
|	O
DLG_WANT_TAB	O
)	O
;	O
add_widget	function
(	O
raw_dlg	pointer
,	O
input_new	function
(	O
3	int
-	O
cancel	int
,	O
w	pointer
-	O
5	int
,	O
INPUT_COLOR	O
,	O
2	int
,	O
""	pointer
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
raw_dlg	pointer
,	O
label_new	function
(	O
3	int
-	O
cancel	int
,	O
2	int
,	O
query	pointer
)	O
)	O
;	O
if	O
(	O
cancel	int
)	O
add_widget	function
(	O
raw_dlg	pointer
,	O
button_new	function
(	O
4	int
,	O
w	pointer
/	O
2	int
-	O
5	int
,	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
_	O
(	O
"Cancel"	pointer
)	O
,	O
0	int
)	O
)	O
;	O
run_dlg	function
(	O
raw_dlg	pointer
)	O
;	O
w	pointer
=	O
raw_dlg	pointer
->	O
ret_value	int
;	O
destroy_dlg	function
(	O
raw_dlg	pointer
)	O
;	O
if	O
(	O
cancel	int
)	O
{	O
if	O
(	O
w	pointer
==	O
XCTRL	O
(	O
'g'	O
)	O
||	O
w	pointer
==	O
XCTRL	O
(	O
'c'	O
)	O
||	O
w	pointer
==	O
ESC_CHAR	char
||	O
w	pointer
==	O
B_CANCEL	int
)	O
return	O
0	int
;	O
}	O
return	O
w	pointer
;	O
}	O
static	O
FILE	struct
*	O
edit_open_macro_file	function
(	O
const	O
char	O
*	O
r	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
file	pointer
;	O
filename	pointer
=	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
MACRO_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
(	O
file	pointer
=	O
open	function
(	O
filename	pointer
,	O
O_CREAT	int
|	O
O_RDWR	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
close	pointer
(	O
file	pointer
)	O
;	O
return	O
fopen	function
(	O
filename	pointer
,	O
r	pointer
)	O
;	O
}	O
static	O
int	O
saved_macro	array
[	O
MAX_MACROS	int
+	O
1	int
]	O
;	O
static	O
int	O
saved_macros_loaded	int
=	O
0	int
;	O
static	O
int	O
macro_exists	function
(	O
int	O
k	int
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
MAX_MACROS	int
&&	O
saved_macro	array
[	O
i	array
]	O
;	O
i	array
++	O
)	O
if	O
(	O
saved_macro	array
[	O
i	array
]	O
==	O
k	int
)	O
return	O
i	array
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
edit_delete_macro	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
k	int
)	O
{	O
struct	O
macro	struct
macro	struct
[	O
MAX_MACRO_LENGTH	int
]	O
;	O
FILE	struct
*	O
f	pointer
,	O
*	O
g	pointer
;	O
int	O
s	pointer
,	O
i	array
,	O
n	long
,	O
j	int
=	O
0	int
;	O
(	O
void	O
)	O
edit	pointer
;	O
if	O
(	O
saved_macros_loaded	int
)	O
if	O
(	O
(	O
j	int
=	O
macro_exists	function
(	O
k	int
)	O
)	O
<	O
0	int
)	O
return	O
0	int
;	O
g	pointer
=	O
fopen	function
(	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
g	pointer
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Delete macro "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open temp file "	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
f	pointer
=	O
edit_open_macro_file	function
(	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Delete macro "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open macro file "	pointer
)	O
)	O
)	O
;	O
fclose	function
(	O
g	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
n	long
=	O
fscanf	function
(	O
f	pointer
,	O
(	O
"key '%d 0': "	pointer
)	O
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
!	O
n	long
||	O
n	long
==	O
EOF	O
)	O
break	O
;	O
n	long
=	O
0	int
;	O
while	O
(	O
fscanf	function
(	O
f	pointer
,	O
"%hd %hd, "	pointer
,	O
&	O
macro	struct
[	O
n	long
]	O
.	O
command	pointer
,	O
&	O
macro	struct
[	O
n	long
]	O
.	O
ch	int
)	O
)	O
n	long
++	O
;	O
fscanf	function
(	O
f	pointer
,	O
";\n"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
k	int
)	O
{	O
fprintf	function
(	O
g	pointer
,	O
(	O
"key '%d 0': "	pointer
)	O
,	O
s	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
n	long
;	O
i	array
++	O
)	O
fprintf	function
(	O
g	pointer
,	O
"%hd %hd, "	pointer
,	O
macro	struct
[	O
i	array
]	O
.	O
command	pointer
,	O
macro	struct
[	O
i	array
]	O
.	O
ch	int
)	O
;	O
fprintf	function
(	O
g	pointer
,	O
";\n"	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
fclose	function
(	O
g	pointer
)	O
;	O
if	O
(	O
rename	function
(	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
MACRO_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Delete macro "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot overwrite macro file "	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
saved_macros_loaded	int
)	O
memmove	function
(	O
saved_macro	array
+	O
j	int
,	O
saved_macro	array
+	O
j	int
+	O
1	int
,	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
MAX_MACROS	int
-	O
j	int
-	O
1	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_save_macro_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
struct	O
macro	struct
macro	struct
[	O
]	O
,	O
int	O
n	long
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
int	O
s	pointer
,	O
i	array
;	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
s	pointer
=	O
edit_raw_key_query	function
(	O
_	O
(	O
" Save macro "	pointer
)	O
,	O
_	O
(	O
" Press the macro's new hotkey: "	pointer
)	O
,	O
1	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
edit_delete_macro	function
(	O
edit	pointer
,	O
s	pointer
)	O
)	O
return	O
0	int
;	O
f	pointer
=	O
edit_open_macro_file	function
(	O
"a+"	pointer
)	O
;	O
if	O
(	O
f	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
(	O
"key '%d 0': "	pointer
)	O
,	O
s	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
n	long
;	O
i	array
++	O
)	O
fprintf	function
(	O
f	pointer
,	O
"%hd %hd, "	pointer
,	O
macro	struct
[	O
i	array
]	O
.	O
command	pointer
,	O
macro	struct
[	O
i	array
]	O
.	O
ch	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
";\n"	pointer
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
if	O
(	O
saved_macros_loaded	int
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
MAX_MACROS	int
&&	O
saved_macro	array
[	O
i	array
]	O
;	O
i	array
++	O
)	O
;	O
saved_macro	array
[	O
i	array
]	O
=	O
s	pointer
;	O
}	O
return	O
1	int
;	O
}	O
else	O
edit_error_dialog	O
(	O
_	O
(	O
" Save macro "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open macro file "	pointer
)	O
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
edit_delete_macro_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
command	pointer
;	O
command	pointer
=	O
edit_raw_key_query	function
(	O
_	O
(	O
" Delete macro "	pointer
)	O
,	O
_	O
(	O
" Press macro hotkey: "	pointer
)	O
,	O
1	int
)	O
;	O
if	O
(	O
!	O
command	pointer
)	O
return	O
;	O
edit_delete_macro	function
(	O
edit	pointer
,	O
command	pointer
)	O
;	O
}	O
int	O
edit_load_macro_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
struct	O
macro	struct
macro	struct
[	O
]	O
,	O
int	O
*	O
n	long
,	O
int	O
k	int
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
int	O
s	pointer
,	O
i	array
=	O
0	int
,	O
found	int
=	O
0	int
;	O
(	O
void	O
)	O
edit	pointer
;	O
if	O
(	O
saved_macros_loaded	int
)	O
if	O
(	O
macro_exists	function
(	O
k	int
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
f	pointer
=	O
edit_open_macro_file	function
(	O
"r"	pointer
)	O
)	O
)	O
{	O
struct	O
macro	struct
dummy	array
;	O
do	O
{	O
int	O
u	union
;	O
u	union
=	O
fscanf	function
(	O
f	pointer
,	O
(	O
"key '%d 0': "	pointer
)	O
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
!	O
u	union
||	O
u	union
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
!	O
saved_macros_loaded	int
)	O
saved_macro	array
[	O
i	array
++	O
]	O
=	O
s	pointer
;	O
if	O
(	O
!	O
found	int
)	O
{	O
*	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
n	long
<	O
MAX_MACRO_LENGTH	int
&&	O
2	int
==	O
fscanf	function
(	O
f	pointer
,	O
"%hd %hd, "	pointer
,	O
&	O
macro	struct
[	O
*	O
n	long
]	O
.	O
command	pointer
,	O
&	O
macro	struct
[	O
*	O
n	long
]	O
.	O
ch	int
)	O
)	O
(	O
*	O
n	long
)	O
++	O
;	O
}	O
else	O
{	O
while	O
(	O
2	int
==	O
fscanf	function
(	O
f	pointer
,	O
"%hd %hd, "	pointer
,	O
&	O
dummy	array
.	O
command	pointer
,	O
&	O
dummy	array
.	O
ch	int
)	O
)	O
;	O
}	O
fscanf	function
(	O
f	pointer
,	O
";\n"	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
k	int
)	O
found	int
=	O
1	int
;	O
}	O
while	O
(	O
!	O
found	int
||	O
!	O
saved_macros_loaded	int
)	O
;	O
if	O
(	O
!	O
saved_macros_loaded	int
)	O
{	O
saved_macro	array
[	O
i	array
]	O
=	O
0	int
;	O
saved_macros_loaded	int
=	O
1	int
;	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
found	int
;	O
}	O
else	O
edit_error_dialog	O
(	O
_	O
(	O
" Load macro "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot open macro file "	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_save_confirm_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
const	O
char	O
*	O
f	pointer
;	O
if	O
(	O
edit_confirm_save	int
)	O
{	O
f	pointer
=	O
catstrs	function
(	O
_	O
(	O
" Confirm save file? : "	pointer
)	O
,	O
edit	pointer
->	O
filename	pointer
,	O
" "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
" Save file "	pointer
)	O
,	O
f	pointer
,	O
_	O
(	O
"&Save"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
)	O
return	O
0	int
;	O
}	O
return	O
edit_save_cmd	function
(	O
edit	pointer
)	O
;	O
}	O
static	O
int	O
edit_save_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
res	int
,	O
save_lock	int
=	O
0	int
;	O
if	O
(	O
!	O
edit	pointer
->	O
locked	int
&&	O
!	O
edit	pointer
->	O
delete_file	int
)	O
save_lock	int
=	O
edit_lock_file	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
res	int
=	O
edit_save_file	function
(	O
edit	pointer
,	O
edit	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
(	O
res	int
>	O
0	int
&&	O
edit	pointer
->	O
locked	int
)	O
||	O
save_lock	int
)	O
edit	pointer
->	O
locked	int
=	O
edit_unlock_file	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
res	int
)	O
return	O
edit_save_as_cmd	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
res	int
>	O
0	int
)	O
{	O
edit	pointer
->	O
delete_file	int
=	O
0	int
;	O
edit	pointer
->	O
modified	long
=	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
edit_new_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
if	O
(	O
edit	pointer
->	O
modified	long
)	O
{	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Current text was modified without a file save. \n Continue discards these changes. "	pointer
)	O
,	O
_	O
(	O
"C&ontinue"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
)	O
{	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
edit_renew	function
(	O
edit	pointer
)	O
;	O
}	O
static	O
int	O
edit_load_file_from_filename	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
exp	pointer
)	O
{	O
int	O
prev_locked	int
=	O
edit	pointer
->	O
locked	int
;	O
char	O
*	O
prev_filename	pointer
=	O
g_strdup	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
edit_reload	function
(	O
edit	pointer
,	O
exp	pointer
)	O
)	O
{	O
g_free	function
(	O
prev_filename	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
prev_locked	int
)	O
edit_unlock_file	function
(	O
prev_filename	pointer
)	O
;	O
g_free	function
(	O
prev_filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_load_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
exp	pointer
;	O
if	O
(	O
edit	pointer
->	O
modified	long
)	O
{	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Current text was modified without a file save. \n"	pointer
" Continue discards these changes. "	pointer
)	O
,	O
_	O
(	O
"C&ontinue"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
)	O
{	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
}	O
exp	pointer
=	O
edit_get_load_file	O
(	O
edit	pointer
->	O
filename	pointer
,	O
_	O
(	O
" Load "	pointer
)	O
)	O
;	O
if	O
(	O
exp	pointer
)	O
{	O
if	O
(	O
*	O
exp	pointer
)	O
edit_load_file_from_filename	function
(	O
edit	pointer
,	O
exp	pointer
)	O
;	O
g_free	function
(	O
exp	pointer
)	O
;	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
int	O
eval_marks	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
*	O
start_mark	pointer
,	O
long	O
*	O
end_mark	pointer
)	O
{	O
if	O
(	O
edit	pointer
->	O
mark1	long
!=	O
edit	pointer
->	O
mark2	long
)	O
{	O
if	O
(	O
edit	pointer
->	O
mark2	long
>=	O
0	int
)	O
{	O
*	O
start_mark	pointer
=	O
min	long
(	O
edit	pointer
->	O
mark1	long
,	O
edit	pointer
->	O
mark2	long
)	O
;	O
*	O
end_mark	pointer
=	O
max	long
(	O
edit	pointer
->	O
mark1	long
,	O
edit	pointer
->	O
mark2	long
)	O
;	O
}	O
else	O
{	O
*	O
start_mark	pointer
=	O
min	long
(	O
edit	pointer
->	O
mark1	long
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
*	O
end_mark	pointer
=	O
max	long
(	O
edit	pointer
->	O
mark1	long
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
column2	int
=	O
edit	pointer
->	O
curs_col	long
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
*	O
start_mark	pointer
=	O
*	O
end_mark	pointer
=	O
0	int
;	O
edit	pointer
->	O
column2	int
=	O
edit	pointer
->	O
column1	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
}	O
static	O
void	O
edit_insert_column_of_text	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
int	O
size	long
,	O
int	O
width	int
)	O
{	O
long	O
cursor	long
;	O
int	O
i	array
,	O
col	int
;	O
cursor	long
=	O
edit	pointer
->	O
curs1	long
;	O
col	int
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
size	long
;	O
i	array
++	O
)	O
{	O
if	O
(	O
data	pointer
[	O
i	array
]	O
==	O
'\n'	O
)	O
{	O
int	O
l	pointer
;	O
long	O
p	pointer
;	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
{	O
l	pointer
=	O
width	int
-	O
(	O
edit_get_col	function
(	O
edit	pointer
)	O
-	O
col	int
)	O
;	O
while	O
(	O
l	pointer
>	O
0	int
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
' '	O
)	O
;	O
l	pointer
-=	O
space_width	int
;	O
}	O
}	O
for	O
(	O
p	pointer
=	O
edit	pointer
->	O
curs1	long
;	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
p	pointer
==	O
edit	pointer
->	O
last_byte	long
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit	pointer
->	O
last_byte	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_insert_ahead	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
p	pointer
++	O
;	O
break	O
;	O
}	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
p	pointer
)	O
==	O
'\n'	O
)	O
{	O
p	pointer
++	O
;	O
break	O
;	O
}	O
}	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward3	function
(	O
edit	pointer
,	O
p	pointer
,	O
col	int
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
l	pointer
=	O
col	int
-	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
while	O
(	O
l	pointer
>=	O
space_width	int
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
' '	O
)	O
;	O
l	pointer
-=	O
space_width	int
;	O
}	O
continue	O
;	O
}	O
edit_insert	function
(	O
edit	pointer
,	O
data	pointer
[	O
i	array
]	O
)	O
;	O
}	O
edit_cursor_move	function
(	O
edit	pointer
,	O
cursor	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_block_copy_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
start_mark	pointer
,	O
end_mark	pointer
,	O
current	long
=	O
edit	pointer
->	O
curs1	long
;	O
int	O
size	long
;	O
unsigned	O
char	O
*	O
copy_buf	pointer
;	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
return	O
;	O
copy_buf	pointer
=	O
edit_get_block	function
(	O
edit	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
,	O
&	O
size	long
)	O
;	O
edit_push_markers	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
edit_insert_column_of_text	function
(	O
edit	pointer
,	O
copy_buf	pointer
,	O
size	long
,	O
abs	function
(	O
edit	pointer
->	O
column2	int
-	O
edit	pointer
->	O
column1	int
)	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
size	long
--	O
)	O
edit_insert_ahead	function
(	O
edit	pointer
,	O
copy_buf	pointer
[	O
size	long
]	O
)	O
;	O
}	O
g_free	function
(	O
copy_buf	pointer
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
edit_set_markers	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
start_mark	pointer
<	O
current	long
&&	O
end_mark	pointer
>	O
current	long
)	O
edit_set_markers	function
(	O
edit	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
+	O
end_mark	pointer
-	O
start_mark	pointer
,	O
0	int
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
void	O
edit_block_move_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
count	int
;	O
long	O
current	long
;	O
unsigned	O
char	O
*	O
copy_buf	pointer
;	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
int	O
deleted	int
=	O
0	int
;	O
int	O
x	array
=	O
0	int
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
return	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
x	array
=	O
edit	pointer
->	O
curs_col	long
;	O
if	O
(	O
start_mark	pointer
<=	O
edit	pointer
->	O
curs1	long
&&	O
end_mark	pointer
>=	O
edit	pointer
->	O
curs1	long
)	O
if	O
(	O
(	O
x	array
>	O
edit	pointer
->	O
column1	int
&&	O
x	array
<	O
edit	pointer
->	O
column2	int
)	O
||	O
(	O
x	array
>	O
edit	pointer
->	O
column2	int
&&	O
x	array
<	O
edit	pointer
->	O
column1	int
)	O
)	O
return	O
;	O
}	O
else	O
if	O
(	O
start_mark	pointer
<=	O
edit	pointer
->	O
curs1	long
&&	O
end_mark	pointer
>=	O
edit	pointer
->	O
curs1	long
)	O
return	O
;	O
if	O
(	O
(	O
end_mark	pointer
-	O
start_mark	pointer
)	O
>	O
option_max_undo	int
/	O
2	int
)	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Block is large, you may not be able to undo this action. "	pointer
)	O
,	O
_	O
(	O
"C&ontinue"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
)	O
return	O
;	O
edit_push_markers	function
(	O
edit	pointer
)	O
;	O
current	long
=	O
edit	pointer
->	O
curs1	long
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
int	O
size	long
,	O
c1	int
,	O
c2	int
,	O
line	int
;	O
line	int
=	O
edit	pointer
->	O
curs_line	long
;	O
if	O
(	O
edit	pointer
->	O
mark2	long
<	O
0	int
)	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
c1	int
=	O
min	long
(	O
edit	pointer
->	O
column1	int
,	O
edit	pointer
->	O
column2	int
)	O
;	O
c2	int
=	O
max	long
(	O
edit	pointer
->	O
column1	int
,	O
edit	pointer
->	O
column2	int
)	O
;	O
copy_buf	pointer
=	O
edit_get_block	function
(	O
edit	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
,	O
&	O
size	long
)	O
;	O
if	O
(	O
x	array
<	O
c2	int
)	O
{	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
;	O
deleted	int
=	O
1	int
;	O
}	O
edit_move_to_line	function
(	O
edit	pointer
,	O
line	int
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
,	O
x	array
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_insert_column_of_text	function
(	O
edit	pointer
,	O
copy_buf	pointer
,	O
size	long
,	O
c2	int
-	O
c1	int
)	O
;	O
if	O
(	O
!	O
deleted	int
)	O
{	O
line	int
=	O
edit	pointer
->	O
curs_line	long
;	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
x	array
=	O
edit	pointer
->	O
curs_col	long
;	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
;	O
edit_move_to_line	function
(	O
edit	pointer
,	O
line	int
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
,	O
x	array
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
edit_set_markers	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
}	O
else	O
{	O
copy_buf	pointer
=	O
g_malloc	function
(	O
end_mark	pointer
-	O
start_mark	pointer
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
start_mark	pointer
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
count	int
=	O
start_mark	pointer
;	O
while	O
(	O
count	int
<	O
end_mark	pointer
)	O
{	O
copy_buf	pointer
[	O
end_mark	pointer
-	O
count	int
-	O
1	int
]	O
=	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
count	int
++	O
;	O
}	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
current	long
-	O
edit	pointer
->	O
curs1	long
-	O
(	O
(	O
(	O
current	long
-	O
edit	pointer
->	O
curs1	long
)	O
>	O
0	int
)	O
?	O
end_mark	pointer
-	O
start_mark	pointer
:	O
0	int
)	O
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
while	O
(	O
count	int
--	O
>	O
start_mark	pointer
)	O
edit_insert_ahead	function
(	O
edit	pointer
,	O
copy_buf	pointer
[	O
end_mark	pointer
-	O
count	int
-	O
1	int
]	O
)	O
;	O
edit_set_markers	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
,	O
edit	pointer
->	O
curs1	long
+	O
end_mark	pointer
-	O
start_mark	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
g_free	function
(	O
copy_buf	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
void	O
edit_delete_column_of_text	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
p	pointer
,	O
q	long
,	O
r	pointer
,	O
m1	long
,	O
m2	long
;	O
int	O
b	pointer
,	O
c	int
,	O
d	double
;	O
int	O
n	long
;	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
m1	long
,	O
&	O
m2	long
)	O
;	O
n	long
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
m1	long
,	O
0	int
,	O
m2	long
)	O
+	O
1	int
;	O
c	int
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
m1	long
)	O
,	O
0	int
,	O
m1	long
)	O
;	O
d	double
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
m2	long
)	O
,	O
0	int
,	O
m2	long
)	O
;	O
b	pointer
=	O
min	long
(	O
c	int
,	O
d	double
)	O
;	O
c	int
=	O
max	long
(	O
c	int
,	O
d	double
)	O
;	O
while	O
(	O
n	long
--	O
)	O
{	O
r	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
p	pointer
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
r	pointer
,	O
b	pointer
,	O
0	int
)	O
;	O
q	long
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
r	pointer
,	O
c	int
,	O
0	int
)	O
;	O
if	O
(	O
p	pointer
<	O
m1	long
)	O
p	pointer
=	O
m1	long
;	O
if	O
(	O
q	long
>	O
m2	long
)	O
q	long
=	O
m2	long
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
p	pointer
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
while	O
(	O
q	long
>	O
p	pointer
)	O
{	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
q	long
--	O
;	O
}	O
if	O
(	O
n	long
)	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
,	O
1	int
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
}	O
static	O
int	O
edit_block_delete	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
count	int
;	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
column_highlighting	int
&&	O
edit	pointer
->	O
mark2	long
<	O
0	int
)	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
end_mark	pointer
-	O
start_mark	pointer
)	O
>	O
option_max_undo	int
/	O
2	int
)	O
{	O
if	O
(	O
edit_query_dialog2	O
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Block is large, you may not be able to undo this action. "	pointer
)	O
,	O
_	O
(	O
"C&ontinue"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
edit_push_markers	function
(	O
edit	pointer
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
start_mark	pointer
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
count	int
=	O
start_mark	pointer
;	O
if	O
(	O
start_mark	pointer
<	O
end_mark	pointer
)	O
{	O
if	O
(	O
column_highlighting	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
mark2	long
<	O
0	int
)	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit_delete_column_of_text	function
(	O
edit	pointer
)	O
;	O
}	O
else	O
{	O
while	O
(	O
count	int
<	O
end_mark	pointer
)	O
{	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
count	int
++	O
;	O
}	O
}	O
}	O
edit_set_markers	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_block_delete_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
{	O
edit_delete_line	function
(	O
edit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
edit_block_delete	function
(	O
edit	pointer
)	O
;	O
}	O
static	O
int	O
edit_replace_prompt	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
replace_text	pointer
,	O
int	O
xpos	int
,	O
int	O
ypos	int
)	O
{	O
QuickWidget	struct
quick_widgets	array
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
63	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
50	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"O&ne"	pointer
)	O
,	O
0	int
,	O
B_REPLACE_ONE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
37	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"A&ll"	pointer
)	O
,	O
0	int
,	O
B_REPLACE_ALL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
21	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"&Skip"	pointer
)	O
,	O
0	int
,	O
B_SKIP_REPLACE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
4	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
3	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
N_	O
(	O
"&Replace"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
CONFIRM_DLG_WIDTH	int
,	O
2	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
GString	struct
*	O
label_text	pointer
=	O
g_string_new	function
(	O
_	O
(	O
" Replace with: "	pointer
)	O
)	O
;	O
if	O
(	O
*	O
replace_text	pointer
)	O
{	O
size_t	long
label_len	long
;	O
label_len	long
=	O
label_text	pointer
->	O
len	int
;	O
g_string_append	function
(	O
label_text	pointer
,	O
replace_text	pointer
)	O
;	O
convert_to_display	O
(	O
label_text	pointer
->	O
str	pointer
+	O
label_len	long
)	O
;	O
}	O
quick_widgets	array
[	O
5	int
]	O
.	O
text	pointer
=	O
label_text	pointer
->	O
str	pointer
;	O
{	O
int	O
retval	pointer
;	O
QuickDialog	struct
Quick_input	struct
=	O
{	O
CONFIRM_DLG_WIDTH	int
,	O
CONFIRM_DLG_HEIGTH	int
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
" Confirm replace "	pointer
)	O
,	O
"[Input Line Keys]"	pointer
,	O
0	int
,	O
0	int
}	O
;	O
Quick_input	struct
.	O
widgets	pointer
=	O
quick_widgets	array
;	O
Quick_input	struct
.	O
xpos	int
=	O
xpos	int
;	O
if	O
(	O
(	O
edit	pointer
->	O
curs_row	long
>=	O
ypos	int
-	O
1	int
)	O
&&	O
(	O
edit	pointer
->	O
curs_row	long
<=	O
ypos	int
+	O
CONFIRM_DLG_HEIGTH	int
-	O
1	int
)	O
)	O
ypos	int
-=	O
CONFIRM_DLG_HEIGTH	int
;	O
Quick_input	struct
.	O
ypos	int
=	O
ypos	int
;	O
retval	pointer
=	O
quick_dialog	function
(	O
&	O
Quick_input	struct
)	O
;	O
g_string_free	function
(	O
label_text	pointer
,	O
TRUE	O
)	O
;	O
return	O
retval	pointer
;	O
}	O
}	O
static	O
void	O
edit_replace_dialog	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
search_default	pointer
,	O
const	O
char	O
*	O
replace_default	pointer
,	O
const	O
char	O
*	O
argorder_default	pointer
,	O
char	O
*	O
*	O
search_text	pointer
,	O
char	O
*	O
*	O
replace_text	pointer
,	O
char	O
*	O
*	O
arg_order	pointer
)	O
{	O
int	O
treplace_scanf	int
=	O
replace_scanf	int
;	O
int	O
treplace_regexp	int
=	O
replace_regexp	int
;	O
int	O
treplace_all	int
=	O
replace_all	int
;	O
int	O
treplace_prompt	int
=	O
replace_prompt	int
;	O
int	O
treplace_backwards	int
=	O
replace_backwards	int
;	O
int	O
treplace_whole	int
=	O
replace_whole	int
;	O
int	O
treplace_case	int
=	O
replace_case	int
;	O
QuickWidget	struct
quick_widgets	array
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
12	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
12	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
REPLACE_DLG_WIDTH	int
,	O
11	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"scanf &Expression"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
REPLACE_DLG_WIDTH	int
,	O
10	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"replace &All"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
REPLACE_DLG_WIDTH	int
,	O
9	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"pro&Mpt on replace"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
11	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Backwards"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
10	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Regular expression"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
9	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Whole words only"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
REPLACE_DLG_WIDTH	int
,	O
8	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
"case &Sensitive"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
REPLACE_DLG_WIDTH	int
,	O
7	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
""	pointer
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-argord"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
REPLACE_DLG_WIDTH	int
,	O
6	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter replacement argument order eg. 3,2,1,4 "	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
REPLACE_DLG_WIDTH	int
,	O
5	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
""	pointer
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-replace"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
REPLACE_DLG_WIDTH	int
,	O
4	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter replacement string:"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
REPLACE_DLG_WIDTH	int
,	O
3	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
""	pointer
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-search"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
REPLACE_DLG_WIDTH	int
,	O
2	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter search string:"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
(	O
void	O
)	O
edit	pointer
;	O
quick_widgets	array
[	O
2	int
]	O
.	O
result	long
=	O
&	O
treplace_scanf	int
;	O
quick_widgets	array
[	O
3	int
]	O
.	O
result	long
=	O
&	O
treplace_all	int
;	O
quick_widgets	array
[	O
4	int
]	O
.	O
result	long
=	O
&	O
treplace_prompt	int
;	O
quick_widgets	array
[	O
5	int
]	O
.	O
result	long
=	O
&	O
treplace_backwards	int
;	O
quick_widgets	array
[	O
6	int
]	O
.	O
result	long
=	O
&	O
treplace_regexp	int
;	O
quick_widgets	array
[	O
7	int
]	O
.	O
result	long
=	O
&	O
treplace_whole	int
;	O
quick_widgets	array
[	O
8	int
]	O
.	O
result	long
=	O
&	O
treplace_case	int
;	O
quick_widgets	array
[	O
9	int
]	O
.	O
str_result	pointer
=	O
arg_order	pointer
;	O
quick_widgets	array
[	O
9	int
]	O
.	O
text	pointer
=	O
argorder_default	pointer
;	O
quick_widgets	array
[	O
11	int
]	O
.	O
str_result	pointer
=	O
replace_text	pointer
;	O
quick_widgets	array
[	O
11	int
]	O
.	O
text	pointer
=	O
replace_default	pointer
;	O
quick_widgets	array
[	O
13	int
]	O
.	O
str_result	pointer
=	O
search_text	pointer
;	O
quick_widgets	array
[	O
13	int
]	O
.	O
text	pointer
=	O
search_default	pointer
;	O
{	O
QuickDialog	struct
Quick_input	struct
=	O
{	O
REPLACE_DLG_WIDTH	int
,	O
REPLACE_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
" Replace "	pointer
)	O
,	O
"[Input Line Keys]"	pointer
,	O
0	int
,	O
0	int
}	O
;	O
Quick_input	struct
.	O
widgets	pointer
=	O
quick_widgets	array
;	O
if	O
(	O
quick_dialog	function
(	O
&	O
Quick_input	struct
)	O
!=	O
B_CANCEL	int
)	O
{	O
replace_scanf	int
=	O
treplace_scanf	int
;	O
replace_backwards	int
=	O
treplace_backwards	int
;	O
replace_regexp	int
=	O
treplace_regexp	int
;	O
replace_all	int
=	O
treplace_all	int
;	O
replace_prompt	int
=	O
treplace_prompt	int
;	O
replace_whole	int
=	O
treplace_whole	int
;	O
replace_case	int
=	O
treplace_case	int
;	O
return	O
;	O
}	O
else	O
{	O
*	O
arg_order	pointer
=	O
NULL	O
;	O
*	O
replace_text	pointer
=	O
NULL	O
;	O
*	O
search_text	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
edit_search_dialog	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
*	O
search_text	pointer
)	O
{	O
int	O
treplace_scanf	int
=	O
replace_scanf	int
;	O
int	O
treplace_regexp	int
=	O
replace_regexp	int
;	O
int	O
treplace_whole	int
=	O
replace_whole	int
;	O
int	O
treplace_case	int
=	O
replace_case	int
;	O
int	O
treplace_backwards	int
=	O
replace_backwards	int
;	O
QuickWidget	struct
quick_widgets	array
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
7	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
7	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
SEARCH_DLG_WIDTH	int
,	O
6	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"scanf &Expression"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
33	int
,	O
SEARCH_DLG_WIDTH	int
,	O
5	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Backwards"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
SEARCH_DLG_WIDTH	int
,	O
6	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Regular expression"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
SEARCH_DLG_WIDTH	int
,	O
5	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Whole words only"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_checkbox	int
,	O
4	int
,	O
SEARCH_DLG_WIDTH	int
,	O
4	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
"case &Sensitive"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
SEARCH_DLG_WIDTH	int
,	O
3	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
""	pointer
,	O
52	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"edit-search"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
SEARCH_DLG_WIDTH	int
,	O
2	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
N_	O
(	O
" Enter search string:"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
(	O
void	O
)	O
edit	pointer
;	O
quick_widgets	array
[	O
2	int
]	O
.	O
result	long
=	O
&	O
treplace_scanf	int
;	O
quick_widgets	array
[	O
3	int
]	O
.	O
result	long
=	O
&	O
treplace_backwards	int
;	O
quick_widgets	array
[	O
4	int
]	O
.	O
result	long
=	O
&	O
treplace_regexp	int
;	O
quick_widgets	array
[	O
5	int
]	O
.	O
result	long
=	O
&	O
treplace_whole	int
;	O
quick_widgets	array
[	O
6	int
]	O
.	O
result	long
=	O
&	O
treplace_case	int
;	O
quick_widgets	array
[	O
7	int
]	O
.	O
str_result	pointer
=	O
search_text	pointer
;	O
quick_widgets	array
[	O
7	int
]	O
.	O
text	pointer
=	O
*	O
search_text	pointer
;	O
{	O
QuickDialog	struct
Quick_input	struct
=	O
{	O
SEARCH_DLG_WIDTH	int
,	O
SEARCH_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
"Search"	pointer
)	O
,	O
"[Input Line Keys]"	pointer
,	O
0	int
,	O
0	int
}	O
;	O
Quick_input	struct
.	O
widgets	pointer
=	O
quick_widgets	array
;	O
if	O
(	O
quick_dialog	function
(	O
&	O
Quick_input	struct
)	O
!=	O
B_CANCEL	int
)	O
{	O
replace_scanf	int
=	O
treplace_scanf	int
;	O
replace_backwards	int
=	O
treplace_backwards	int
;	O
replace_regexp	int
=	O
treplace_regexp	int
;	O
replace_whole	int
=	O
treplace_whole	int
;	O
replace_case	int
=	O
treplace_case	int
;	O
}	O
else	O
{	O
*	O
search_text	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
static	O
long	O
sargs	array
[	O
NUM_REPL_ARGS	int
]	O
[	O
256	int
/	O
sizeof	O
(	O
long	O
)	O
]	O
;	O
static	O
int	O
string_regexp_search	function
(	O
char	O
*	O
pattern	pointer
,	O
char	O
*	O
string	pointer
,	O
int	O
match_type	int
,	O
int	O
match_bol	int
,	O
int	O
icase	int
,	O
int	O
*	O
found_len	int
,	O
void	O
*	O
d	double
)	O
{	O
static	O
regex_t	struct
r	pointer
;	O
static	O
char	O
*	O
old_pattern	pointer
=	O
NULL	O
;	O
static	O
int	O
old_type	int
,	O
old_icase	int
;	O
regmatch_t	struct
*	O
pmatch	pointer
;	O
static	O
regmatch_t	struct
s	pointer
[	O
1	int
]	O
;	O
pmatch	pointer
=	O
(	O
regmatch_t	struct
*	O
)	O
d	double
;	O
if	O
(	O
!	O
pmatch	pointer
)	O
pmatch	pointer
=	O
s	pointer
;	O
if	O
(	O
!	O
old_pattern	pointer
||	O
strcmp	function
(	O
old_pattern	pointer
,	O
pattern	pointer
)	O
||	O
old_type	int
!=	O
match_type	int
||	O
old_icase	int
!=	O
icase	int
)	O
{	O
if	O
(	O
old_pattern	pointer
)	O
{	O
regfree	function
(	O
&	O
r	pointer
)	O
;	O
g_free	function
(	O
old_pattern	pointer
)	O
;	O
old_pattern	pointer
=	O
0	int
;	O
}	O
if	O
(	O
regcomp	function
(	O
&	O
r	pointer
,	O
pattern	pointer
,	O
REG_EXTENDED	int
|	O
(	O
icase	int
?	O
REG_ICASE	O
:	O
0	int
)	O
)	O
)	O
{	O
*	O
found_len	int
=	O
0	int
;	O
return	O
-	O
3	int
;	O
}	O
old_pattern	pointer
=	O
g_strdup	function
(	O
pattern	pointer
)	O
;	O
old_type	int
=	O
match_type	int
;	O
old_icase	int
=	O
icase	int
;	O
}	O
if	O
(	O
regexec	function
(	O
&	O
r	pointer
,	O
string	pointer
,	O
d	double
?	O
NUM_REPL_ARGS	int
:	O
1	int
,	O
pmatch	pointer
,	O
(	O
(	O
match_bol	int
||	O
match_type	int
!=	O
match_normal	int
)	O
?	O
0	int
:	O
REG_NOTBOL	int
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
found_len	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
found_len	int
=	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_eo	int
-	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	int
;	O
return	O
(	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	int
)	O
;	O
}	O
typedef	O
int	O
(	O
*	O
edit_getbyte_fn	pointer
)	O
(	O
WEdit	struct
*	O
,	O
long	O
)	O
;	O
static	O
long	O
edit_find_string	function
(	O
long	O
start	pointer
,	O
unsigned	O
char	O
*	O
exp	pointer
,	O
int	O
*	O
len	int
,	O
long	O
last_byte	long
,	O
edit_getbyte_fn	pointer
get_byte	pointer
,	O
void	O
*	O
data	pointer
,	O
int	O
once_only	int
,	O
void	O
*	O
d	double
)	O
{	O
long	O
p	pointer
,	O
q	long
=	O
0	int
;	O
long	O
l	pointer
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
exp	pointer
)	O
,	O
f	pointer
=	O
0	int
;	O
int	O
n	long
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
0	int
;	O
p	pointer
<	O
l	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
exp	pointer
[	O
p	pointer
]	O
==	O
'%'	O
)	O
if	O
(	O
exp	pointer
[	O
++	O
p	pointer
]	O
!=	O
'%'	O
)	O
n	long
++	O
;	O
if	O
(	O
replace_scanf	int
||	O
replace_regexp	int
)	O
{	O
int	O
c	int
;	O
unsigned	O
char	O
*	O
buf	pointer
;	O
unsigned	O
char	O
mbuf	array
[	O
MAX_REPL_LEN	int
*	O
2	int
+	O
3	int
]	O
;	O
replace_scanf	int
=	O
(	O
!	O
replace_regexp	int
)	O
;	O
buf	pointer
=	O
mbuf	array
;	O
if	O
(	O
replace_scanf	int
)	O
{	O
unsigned	O
char	O
e	pointer
[	O
MAX_REPL_LEN	int
]	O
;	O
if	O
(	O
n	long
>=	O
NUM_REPL_ARGS	int
)	O
return	O
-	O
3	int
;	O
if	O
(	O
replace_case	int
)	O
{	O
for	O
(	O
p	pointer
=	O
start	pointer
;	O
p	pointer
<	O
last_byte	long
&&	O
p	pointer
<	O
start	pointer
+	O
MAX_REPL_LEN	int
;	O
p	pointer
++	O
)	O
buf	pointer
[	O
p	pointer
-	O
start	pointer
]	O
=	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
p	pointer
=	O
0	int
;	O
exp	pointer
[	O
p	pointer
]	O
!=	O
0	int
;	O
p	pointer
++	O
)	O
exp	pointer
[	O
p	pointer
]	O
=	O
my_lower_case	function
(	O
exp	pointer
[	O
p	pointer
]	O
)	O
;	O
for	O
(	O
p	pointer
=	O
start	pointer
;	O
p	pointer
<	O
last_byte	long
&&	O
p	pointer
<	O
start	pointer
+	O
MAX_REPL_LEN	int
;	O
p	pointer
++	O
)	O
{	O
c	int
=	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
)	O
;	O
buf	pointer
[	O
p	pointer
-	O
start	pointer
]	O
=	O
my_lower_case	function
(	O
c	int
)	O
;	O
}	O
}	O
buf	pointer
[	O
(	O
q	long
=	O
p	pointer
-	O
start	pointer
)	O
]	O
=	O
0	int
;	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
e	pointer
,	O
(	O
char	O
*	O
)	O
exp	pointer
)	O
;	O
strcat	function
(	O
(	O
char	O
*	O
)	O
e	pointer
,	O
"%n"	pointer
)	O
;	O
exp	pointer
=	O
e	pointer
;	O
while	O
(	O
q	long
)	O
{	O
*	O
(	O
(	O
int	O
*	O
)	O
sargs	array
[	O
n	long
]	O
)	O
=	O
0	int
;	O
if	O
(	O
n	long
==	O
sscanf	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
(	O
char	O
*	O
)	O
exp	pointer
,	O
SCANF_ARGS	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
(	O
int	O
*	O
)	O
sargs	array
[	O
n	long
]	O
)	O
)	O
{	O
*	O
len	int
=	O
*	O
(	O
(	O
int	O
*	O
)	O
sargs	array
[	O
n	long
]	O
)	O
;	O
return	O
start	pointer
;	O
}	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
if	O
(	O
q	long
+	O
start	pointer
<	O
last_byte	long
)	O
{	O
if	O
(	O
replace_case	int
)	O
{	O
buf	pointer
[	O
q	long
]	O
=	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
q	long
+	O
start	pointer
)	O
;	O
}	O
else	O
{	O
c	int
=	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
q	long
+	O
start	pointer
)	O
;	O
buf	pointer
[	O
q	long
]	O
=	O
my_lower_case	function
(	O
c	int
)	O
;	O
}	O
q	long
++	O
;	O
}	O
buf	pointer
[	O
q	long
]	O
=	O
0	int
;	O
start	pointer
++	O
;	O
buf	pointer
++	O
;	O
if	O
(	O
buf	pointer
==	O
mbuf	array
+	O
MAX_REPL_LEN	int
)	O
{	O
memmove	function
(	O
mbuf	array
,	O
buf	pointer
,	O
strlen	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
)	O
+	O
1	int
)	O
;	O
buf	pointer
=	O
mbuf	array
;	O
}	O
q	long
--	O
;	O
}	O
}	O
else	O
{	O
long	O
offset	long
=	O
0	int
;	O
int	O
found_start	long
,	O
match_bol	int
,	O
move_win	int
=	O
0	int
;	O
while	O
(	O
start	pointer
+	O
offset	long
<	O
last_byte	long
)	O
{	O
match_bol	int
=	O
(	O
offset	long
==	O
0	int
||	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
start	pointer
+	O
offset	long
-	O
1	int
)	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
move_win	int
)	O
{	O
p	pointer
=	O
start	pointer
+	O
offset	long
;	O
q	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
p	pointer
<	O
last_byte	long
&&	O
q	long
<	O
MAX_REPL_LEN	int
;	O
p	pointer
++	O
,	O
q	long
++	O
)	O
{	O
mbuf	array
[	O
q	long
]	O
=	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
mbuf	array
[	O
q	long
]	O
==	O
'\n'	O
)	O
{	O
q	long
++	O
;	O
break	O
;	O
}	O
}	O
offset	long
+=	O
q	long
;	O
mbuf	array
[	O
q	long
]	O
=	O
0	int
;	O
buf	pointer
=	O
mbuf	array
;	O
while	O
(	O
q	long
)	O
{	O
found_start	long
=	O
string_regexp_search	function
(	O
(	O
char	O
*	O
)	O
exp	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
match_normal	int
,	O
match_bol	int
,	O
!	O
replace_case	int
,	O
len	int
,	O
d	double
)	O
;	O
if	O
(	O
found_start	long
<=	O
-	O
2	int
)	O
{	O
*	O
len	int
=	O
0	int
;	O
return	O
-	O
3	int
;	O
}	O
else	O
if	O
(	O
found_start	long
==	O
-	O
1	int
)	O
break	O
;	O
else	O
if	O
(	O
*	O
len	int
==	O
0	int
)	O
{	O
q	long
--	O
;	O
buf	pointer
++	O
;	O
match_bol	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
return	O
(	O
start	pointer
+	O
offset	long
-	O
q	long
+	O
found_start	long
)	O
;	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
if	O
(	O
buf	pointer
[	O
q	long
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
buf	pointer
=	O
mbuf	array
+	O
MAX_REPL_LEN	int
/	O
2	int
;	O
q	long
=	O
strlen	function
(	O
(	O
const	O
char	O
*	O
)	O
buf	pointer
)	O
;	O
memmove	function
(	O
mbuf	array
,	O
buf	pointer
,	O
q	long
)	O
;	O
p	pointer
=	O
start	pointer
+	O
q	long
;	O
move_win	int
=	O
1	int
;	O
}	O
else	O
move_win	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
*	O
len	int
=	O
strlen	function
(	O
(	O
const	O
char	O
*	O
)	O
exp	pointer
)	O
;	O
if	O
(	O
replace_case	int
)	O
{	O
for	O
(	O
p	pointer
=	O
start	pointer
;	O
p	pointer
<=	O
last_byte	long
-	O
l	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
)	O
==	O
(	O
unsigned	O
char	O
)	O
exp	pointer
[	O
0	int
]	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
,	O
q	long
=	O
0	int
;	O
q	long
<	O
l	pointer
&&	O
f	pointer
<	O
1	int
;	O
q	long
++	O
)	O
if	O
(	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
q	long
+	O
p	pointer
)	O
!=	O
(	O
unsigned	O
char	O
)	O
exp	pointer
[	O
q	long
]	O
)	O
f	pointer
=	O
1	int
;	O
if	O
(	O
f	pointer
==	O
0	int
)	O
return	O
p	pointer
;	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
p	pointer
=	O
0	int
;	O
exp	pointer
[	O
p	pointer
]	O
!=	O
0	int
;	O
p	pointer
++	O
)	O
exp	pointer
[	O
p	pointer
]	O
=	O
my_lower_case	function
(	O
exp	pointer
[	O
p	pointer
]	O
)	O
;	O
for	O
(	O
p	pointer
=	O
start	pointer
;	O
p	pointer
<=	O
last_byte	long
-	O
l	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
my_lower_case	function
(	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
)	O
)	O
==	O
(	O
unsigned	O
char	O
)	O
exp	pointer
[	O
0	int
]	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
,	O
q	long
=	O
0	int
;	O
q	long
<	O
l	pointer
&&	O
f	pointer
<	O
1	int
;	O
q	long
++	O
)	O
if	O
(	O
my_lower_case	function
(	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
q	long
+	O
p	pointer
)	O
)	O
!=	O
(	O
unsigned	O
char	O
)	O
exp	pointer
[	O
q	long
]	O
)	O
f	pointer
=	O
1	int
;	O
if	O
(	O
f	pointer
==	O
0	int
)	O
return	O
p	pointer
;	O
}	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
}	O
}	O
}	O
return	O
-	O
2	int
;	O
}	O
static	O
long	O
edit_find_forwards	function
(	O
long	O
search_start	long
,	O
unsigned	O
char	O
*	O
exp	pointer
,	O
int	O
*	O
len	int
,	O
long	O
last_byte	long
,	O
edit_getbyte_fn	pointer
get_byte	pointer
,	O
void	O
*	O
data	pointer
,	O
int	O
once_only	int
,	O
void	O
*	O
d	double
)	O
{	O
long	O
p	pointer
;	O
p	pointer
=	O
search_start	long
;	O
while	O
(	O
(	O
p	pointer
=	O
edit_find_string	function
(	O
p	pointer
,	O
exp	pointer
,	O
len	int
,	O
last_byte	long
,	O
get_byte	pointer
,	O
data	pointer
,	O
once_only	int
,	O
d	double
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
replace_whole	int
)	O
{	O
if	O
(	O
!	O
strcasechr	function
(	O
option_whole_chars_search	pointer
,	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
-	O
1	int
)	O
)	O
&&	O
!	O
strcasechr	function
(	O
option_whole_chars_search	pointer
,	O
(	O
*	O
get_byte	pointer
)	O
(	O
data	pointer
,	O
p	pointer
+	O
*	O
len	int
)	O
)	O
)	O
return	O
p	pointer
;	O
if	O
(	O
once_only	int
)	O
return	O
-	O
2	int
;	O
}	O
else	O
return	O
p	pointer
;	O
if	O
(	O
once_only	int
)	O
break	O
;	O
p	pointer
++	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
long	O
edit_find	function
(	O
long	O
search_start	long
,	O
unsigned	O
char	O
*	O
exp	pointer
,	O
int	O
*	O
len	int
,	O
long	O
last_byte	long
,	O
edit_getbyte_fn	pointer
get_byte	pointer
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
d	double
)	O
{	O
long	O
p	pointer
;	O
if	O
(	O
replace_backwards	int
)	O
{	O
while	O
(	O
search_start	long
>=	O
0	int
)	O
{	O
p	pointer
=	O
edit_find_forwards	function
(	O
search_start	long
,	O
exp	pointer
,	O
len	int
,	O
last_byte	long
,	O
get_byte	pointer
,	O
data	pointer
,	O
1	int
,	O
d	double
)	O
;	O
if	O
(	O
p	pointer
==	O
search_start	long
)	O
return	O
p	pointer
;	O
search_start	long
--	O
;	O
}	O
}	O
else	O
{	O
return	O
edit_find_forwards	function
(	O
search_start	long
,	O
exp	pointer
,	O
len	int
,	O
last_byte	long
,	O
get_byte	pointer
,	O
data	pointer
,	O
0	int
,	O
d	double
)	O
;	O
}	O
return	O
-	O
2	int
;	O
}	O
static	O
int	O
snprintf_p	function
(	O
char	O
*	O
str	pointer
,	O
size_t	long
size	long
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
__attribute__	O
(	O
(	O
format	pointer
(	O
printf	function
,	O
3	int
,	O
4	int
)	O
)	O
)	O
;	O
static	O
int	O
snprintf_p	function
(	O
char	O
*	O
str	pointer
,	O
size_t	long
size	long
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
size_t	long
n	long
;	O
const	O
char	O
*	O
q	long
,	O
*	O
p	pointer
;	O
char	O
*	O
s	pointer
=	O
str	pointer
,	O
*	O
e	pointer
=	O
str	pointer
+	O
size	long
;	O
char	O
q1	array
[	O
40	int
]	O
;	O
char	O
*	O
p1	pointer
;	O
int	O
nargs	int
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
p	pointer
=	O
q	long
=	O
fmt	pointer
;	O
while	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'%'	O
)	O
)	O
)	O
{	O
n	long
=	O
p	pointer
-	O
q	long
;	O
if	O
(	O
n	long
>=	O
(	O
size_t	long
)	O
(	O
e	pointer
-	O
s	pointer
)	O
)	O
goto	O
nospc	O
;	O
memcpy	function
(	O
s	pointer
,	O
q	long
,	O
n	long
)	O
;	O
s	pointer
+=	O
n	long
;	O
q	long
=	O
p	pointer
;	O
p1	pointer
=	O
q1	array
;	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'%'	O
)	O
{	O
p	pointer
++	O
;	O
*	O
s	pointer
++	O
=	O
'%'	O
;	O
if	O
(	O
s	pointer
==	O
e	pointer
)	O
goto	O
nospc	O
;	O
q	long
=	O
p	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'n'	O
)	O
goto	O
err	long
;	O
if	O
(	O
++	O
nargs	int
==	O
16	int
)	O
goto	O
err	long
;	O
if	O
(	O
*	O
p	pointer
==	O
'#'	O
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'0'	O
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'*'	O
)	O
{	O
p	pointer
++	O
;	O
strcpy	function
(	O
p1	pointer
,	O
MY_itoa	function
(	O
*	O
va_arg	O
(	O
ap	array
,	O
int	O
*	O
)	O
)	O
)	O
;	O
p1	pointer
+=	O
strlen	function
(	O
p1	pointer
)	O
;	O
}	O
else	O
{	O
while	O
(	O
is_digit	O
(	O
*	O
p	pointer
)	O
&&	O
p1	pointer
<	O
q1	array
+	O
20	int
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
is_digit	O
(	O
*	O
p	pointer
)	O
)	O
goto	O
err	long
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'.'	O
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'*'	O
)	O
{	O
p	pointer
++	O
;	O
strcpy	function
(	O
p1	pointer
,	O
MY_itoa	function
(	O
*	O
va_arg	O
(	O
ap	array
,	O
int	O
*	O
)	O
)	O
)	O
;	O
p1	pointer
+=	O
strlen	function
(	O
p1	pointer
)	O
;	O
}	O
else	O
{	O
while	O
(	O
is_digit	O
(	O
*	O
p	pointer
)	O
&&	O
p1	pointer
<	O
q1	array
+	O
32	int
)	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
is_digit	O
(	O
*	O
p	pointer
)	O
)	O
goto	O
err	long
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
's'	O
)	O
{	O
snprint	O
(	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'h'	O
)	O
{	O
if	O
(	O
strchr	function
(	O
"diouxX"	pointer
,	O
*	O
p	pointer
)	O
)	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
short	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'l'	O
)	O
{	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
strchr	function
(	O
"diouxX"	pointer
,	O
*	O
p	pointer
)	O
)	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
long	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"cdiouxX"	pointer
,	O
*	O
p	pointer
)	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
int	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'L'	O
)	O
{	O
*	O
p1	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
strchr	function
(	O
"EefgG"	pointer
,	O
*	O
p	pointer
)	O
)	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
double	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"EefgG"	pointer
,	O
*	O
p	pointer
)	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
double	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"DOU"	pointer
,	O
*	O
p	pointer
)	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
long	O
*	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'p'	O
)	O
{	O
snprint	O
(	O
*	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
*	O
)	O
)	O
;	O
}	O
else	O
goto	O
err	long
;	O
q	long
=	O
p	pointer
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
n	long
=	O
strlen	function
(	O
q	long
)	O
;	O
if	O
(	O
n	long
>=	O
(	O
size_t	long
)	O
(	O
e	pointer
-	O
s	pointer
)	O
)	O
return	O
-	O
1	int
;	O
memcpy	function
(	O
s	pointer
,	O
q	long
,	O
n	long
+	O
1	int
)	O
;	O
return	O
s	pointer
+	O
n	long
-	O
str	pointer
;	O
nospc	O
:	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
-	O
1	int
;	O
err	long
:	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
-	O
2	int
;	O
}	O
static	O
void	O
regexp_error	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
(	O
void	O
)	O
edit	pointer
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
_	O
(	O
" Invalid regular expression, or scanf expression with too many conversions "	pointer
)	O
)	O
;	O
}	O
void	O
edit_replace_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
again	int
)	O
{	O
static	O
regmatch_t	struct
pmatch	pointer
[	O
NUM_REPL_ARGS	int
]	O
;	O
static	O
char	O
*	O
saved1	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
saved2	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
saved3	pointer
=	O
NULL	O
;	O
char	O
*	O
input1	pointer
=	O
NULL	O
;	O
char	O
*	O
input2	pointer
=	O
NULL	O
;	O
char	O
*	O
input3	pointer
=	O
NULL	O
;	O
int	O
replace_yes	int
;	O
int	O
replace_continue	int
;	O
int	O
treplace_prompt	int
=	O
0	int
;	O
long	O
times_replaced	long
=	O
0	int
,	O
last_search	long
;	O
int	O
argord	array
[	O
NUM_REPL_ARGS	int
]	O
;	O
if	O
(	O
!	O
edit	pointer
)	O
{	O
g_free	function
(	O
saved1	pointer
)	O
,	O
saved1	pointer
=	O
NULL	O
;	O
g_free	function
(	O
saved2	pointer
)	O
,	O
saved2	pointer
=	O
NULL	O
;	O
g_free	function
(	O
saved3	pointer
)	O
,	O
saved3	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
last_search	long
=	O
edit	pointer
->	O
last_byte	long
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
again	int
&&	O
!	O
saved1	pointer
&&	O
!	O
saved2	pointer
)	O
again	int
=	O
0	int
;	O
if	O
(	O
again	int
)	O
{	O
input1	pointer
=	O
g_strdup	function
(	O
saved1	pointer
?	O
saved1	pointer
:	O
""	pointer
)	O
;	O
input2	pointer
=	O
g_strdup	function
(	O
saved2	pointer
?	O
saved2	pointer
:	O
""	pointer
)	O
;	O
input3	pointer
=	O
g_strdup	function
(	O
saved3	pointer
?	O
saved3	pointer
:	O
""	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
disp1	pointer
=	O
g_strdup	function
(	O
saved1	pointer
?	O
saved1	pointer
:	O
""	pointer
)	O
;	O
char	O
*	O
disp2	pointer
=	O
g_strdup	function
(	O
saved2	pointer
?	O
saved2	pointer
:	O
""	pointer
)	O
;	O
char	O
*	O
disp3	pointer
=	O
g_strdup	function
(	O
saved3	pointer
?	O
saved3	pointer
:	O
""	pointer
)	O
;	O
convert_to_display	O
(	O
disp1	pointer
)	O
;	O
convert_to_display	O
(	O
disp2	pointer
)	O
;	O
convert_to_display	O
(	O
disp3	pointer
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
edit_replace_dialog	function
(	O
edit	pointer
,	O
disp1	pointer
,	O
disp2	pointer
,	O
disp3	pointer
,	O
&	O
input1	pointer
,	O
&	O
input2	pointer
,	O
&	O
input3	pointer
)	O
;	O
g_free	function
(	O
disp1	pointer
)	O
;	O
g_free	function
(	O
disp2	pointer
)	O
;	O
g_free	function
(	O
disp3	pointer
)	O
;	O
convert_from_input	O
(	O
input1	pointer
)	O
;	O
convert_from_input	O
(	O
input2	pointer
)	O
;	O
convert_from_input	O
(	O
input3	pointer
)	O
;	O
treplace_prompt	int
=	O
replace_prompt	int
;	O
if	O
(	O
input1	pointer
==	O
NULL	O
||	O
*	O
input1	pointer
==	O
'\0'	O
)	O
{	O
edit	pointer
->	O
force	int
=	O
REDRAW_COMPLETELY	O
;	O
goto	O
cleanup	O
;	O
}	O
g_free	function
(	O
saved1	pointer
)	O
,	O
saved1	pointer
=	O
g_strdup	function
(	O
input1	pointer
)	O
;	O
g_free	function
(	O
saved2	pointer
)	O
,	O
saved2	pointer
=	O
g_strdup	function
(	O
input2	pointer
)	O
;	O
g_free	function
(	O
saved3	pointer
)	O
,	O
saved3	pointer
=	O
g_strdup	function
(	O
input3	pointer
)	O
;	O
}	O
{	O
const	O
char	O
*	O
s	pointer
;	O
int	O
ord	int
;	O
size_t	long
i	array
;	O
s	pointer
=	O
input3	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
NUM_REPL_ARGS	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
ord	int
=	O
atoi	function
(	O
s	pointer
)	O
;	O
if	O
(	O
(	O
ord	int
>	O
0	int
)	O
&&	O
(	O
ord	int
<=	O
NUM_REPL_ARGS	int
)	O
)	O
argord	array
[	O
i	array
]	O
=	O
ord	int
-	O
1	int
;	O
else	O
argord	array
[	O
i	array
]	O
=	O
i	array
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
','	O
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
s	pointer
++	O
;	O
}	O
else	O
argord	array
[	O
i	array
]	O
=	O
i	array
;	O
}	O
}	O
replace_continue	int
=	O
replace_all	int
;	O
if	O
(	O
edit	pointer
->	O
found_len	int
&&	O
edit	pointer
->	O
search_start	long
==	O
edit	pointer
->	O
found_start	long
+	O
1	int
&&	O
replace_backwards	int
)	O
edit	pointer
->	O
search_start	long
--	O
;	O
if	O
(	O
edit	pointer
->	O
found_len	int
&&	O
edit	pointer
->	O
search_start	long
==	O
edit	pointer
->	O
found_start	long
-	O
1	int
&&	O
!	O
replace_backwards	int
)	O
edit	pointer
->	O
search_start	long
++	O
;	O
do	O
{	O
int	O
len	int
=	O
0	int
;	O
long	O
new_start	long
;	O
new_start	long
=	O
edit_find	function
(	O
edit	pointer
->	O
search_start	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
input1	pointer
,	O
&	O
len	int
,	O
last_search	long
,	O
edit_get_byte	function
,	O
(	O
void	O
*	O
)	O
edit	pointer
,	O
pmatch	pointer
)	O
;	O
if	O
(	O
new_start	long
==	O
-	O
3	int
)	O
{	O
regexp_error	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
}	O
edit	pointer
->	O
search_start	long
=	O
new_start	long
;	O
if	O
(	O
edit	pointer
->	O
search_start	long
>=	O
0	int
)	O
{	O
int	O
i	array
;	O
edit	pointer
->	O
found_start	long
=	O
edit	pointer
->	O
search_start	long
;	O
i	array
=	O
edit	pointer
->	O
found_len	int
=	O
len	int
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit	pointer
->	O
search_start	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
replace_yes	int
=	O
1	int
;	O
if	O
(	O
treplace_prompt	int
)	O
{	O
int	O
l	pointer
;	O
l	pointer
=	O
edit	pointer
->	O
curs_row	long
-	O
edit	pointer
->	O
num_widget_lines	int
/	O
3	int
;	O
if	O
(	O
l	pointer
>	O
0	int
)	O
edit_scroll_downward	function
(	O
edit	pointer
,	O
l	pointer
)	O
;	O
if	O
(	O
l	pointer
<	O
0	int
)	O
edit_scroll_upward	function
(	O
edit	pointer
,	O
-	O
l	pointer
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_render_keypress	function
(	O
edit	pointer
)	O
;	O
edit_push_key_press	function
(	O
edit	pointer
)	O
;	O
switch	O
(	O
edit_replace_prompt	function
(	O
edit	pointer
,	O
input2	pointer
,	O
(	O
edit	pointer
->	O
num_widget_columns	int
-	O
CONFIRM_DLG_WIDTH	int
)	O
/	O
2	int
,	O
edit	pointer
->	O
num_widget_lines	int
*	O
2	int
/	O
3	int
)	O
)	O
{	O
case	O
B_ENTER	int
:	O
break	O
;	O
case	O
B_SKIP_REPLACE	O
:	O
replace_yes	int
=	O
0	int
;	O
break	O
;	O
case	O
B_REPLACE_ALL	O
:	O
treplace_prompt	int
=	O
0	int
;	O
replace_continue	int
=	O
1	int
;	O
break	O
;	O
case	O
B_REPLACE_ONE	O
:	O
replace_continue	int
=	O
0	int
;	O
break	O
;	O
case	O
B_CANCEL	int
:	O
replace_yes	int
=	O
0	int
;	O
replace_continue	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
replace_yes	int
)	O
{	O
if	O
(	O
replace_scanf	int
)	O
{	O
char	O
repl_str	array
[	O
MAX_REPL_LEN	int
+	O
2	int
]	O
;	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
replace_regexp	int
)	O
{	O
int	O
k	int
,	O
j	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
NUM_REPL_ARGS	int
&&	O
pmatch	pointer
[	O
k	int
]	O
.	O
rm_eo	int
>=	O
0	int
;	O
k	int
++	O
)	O
{	O
unsigned	O
char	O
*	O
t	long
;	O
if	O
(	O
pmatch	pointer
[	O
k	int
]	O
.	O
rm_eo	int
-	O
pmatch	pointer
[	O
k	int
]	O
.	O
rm_so	int
>	O
255	int
)	O
{	O
ret	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
t	long
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
sargs	array
[	O
k	int
-	O
1	int
]	O
[	O
0	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
pmatch	pointer
[	O
k	int
]	O
.	O
rm_eo	int
-	O
pmatch	pointer
[	O
k	int
]	O
.	O
rm_so	int
&&	O
j	int
<	O
255	int
;	O
j	int
++	O
,	O
t	long
++	O
)	O
*	O
t	long
=	O
(	O
unsigned	O
char	O
)	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
search_start	long
-	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	int
+	O
pmatch	pointer
[	O
k	int
]	O
.	O
rm_so	int
+	O
j	int
)	O
;	O
*	O
t	long
=	O
'\0'	O
;	O
}	O
for	O
(	O
;	O
k	int
<=	O
NUM_REPL_ARGS	int
;	O
k	int
++	O
)	O
sargs	array
[	O
k	int
-	O
1	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
ret	int
)	O
ret	int
=	O
snprintf_p	function
(	O
repl_str	array
,	O
MAX_REPL_LEN	int
+	O
2	int
,	O
input2	pointer
,	O
PRINTF_ARGS	O
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
)	O
{	O
times_replaced	long
++	O
;	O
while	O
(	O
i	array
--	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
while	O
(	O
repl_str	array
[	O
++	O
i	array
]	O
)	O
edit_insert	function
(	O
edit	pointer
,	O
repl_str	array
[	O
i	array
]	O
)	O
;	O
}	O
else	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Replace "	pointer
)	O
,	O
ret	int
==	O
-	O
2	int
?	O
_	O
(	O
" Error in replacement format string. "	pointer
)	O
:	O
_	O
(	O
" Replacement too long. "	pointer
)	O
)	O
;	O
replace_continue	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
times_replaced	long
++	O
;	O
while	O
(	O
i	array
--	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
while	O
(	O
input2	pointer
[	O
++	O
i	array
]	O
)	O
edit_insert	function
(	O
edit	pointer
,	O
input2	pointer
[	O
i	array
]	O
)	O
;	O
}	O
edit	pointer
->	O
found_len	int
=	O
i	array
;	O
}	O
if	O
(	O
replace_backwards	int
)	O
{	O
last_search	long
=	O
edit	pointer
->	O
search_start	long
;	O
edit	pointer
->	O
search_start	long
--	O
;	O
}	O
else	O
{	O
edit	pointer
->	O
search_start	long
+=	O
i	array
;	O
last_search	long
=	O
edit	pointer
->	O
last_byte	long
;	O
}	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
_	O
(	O
" Replace "	pointer
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_render_keypress	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
times_replaced	long
)	O
{	O
message	pointer
(	O
0	int
,	O
msg	pointer
,	O
_	O
(	O
" %ld replacements made. "	pointer
)	O
,	O
times_replaced	long
)	O
;	O
}	O
else	O
query_dialog	function
(	O
msg	pointer
,	O
_	O
(	O
" Search string not found "	pointer
)	O
,	O
D_NORMAL	int
,	O
1	int
,	O
_	O
(	O
"&OK"	pointer
)	O
)	O
;	O
replace_continue	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
replace_continue	int
)	O
;	O
edit	pointer
->	O
force	int
=	O
REDRAW_COMPLETELY	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
cleanup	O
:	O
g_free	function
(	O
input1	pointer
)	O
;	O
g_free	function
(	O
input2	pointer
)	O
;	O
g_free	function
(	O
input3	pointer
)	O
;	O
}	O
void	O
edit_search_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
again	int
)	O
{	O
static	O
char	O
*	O
old	pointer
=	O
NULL	O
;	O
char	O
*	O
exp	pointer
=	O
""	pointer
;	O
if	O
(	O
!	O
edit	pointer
)	O
{	O
g_free	function
(	O
old	pointer
)	O
;	O
old	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
exp	pointer
=	O
old	pointer
?	O
old	pointer
:	O
exp	pointer
;	O
if	O
(	O
again	int
)	O
{	O
if	O
(	O
!	O
old	pointer
)	O
return	O
;	O
exp	pointer
=	O
g_strdup	function
(	O
old	pointer
)	O
;	O
}	O
else	O
{	O
edit_search_dialog	function
(	O
edit	pointer
,	O
&	O
exp	pointer
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
}	O
if	O
(	O
exp	pointer
)	O
{	O
if	O
(	O
*	O
exp	pointer
)	O
{	O
int	O
len	int
=	O
0	int
;	O
g_free	function
(	O
old	pointer
)	O
;	O
old	pointer
=	O
g_strdup	function
(	O
exp	pointer
)	O
;	O
if	O
(	O
search_create_bookmark	int
)	O
{	O
int	O
found	int
=	O
0	int
,	O
books	int
=	O
0	int
;	O
int	O
l	pointer
=	O
0	int
,	O
l_last	int
=	O
-	O
1	int
;	O
long	O
p	pointer
,	O
q	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	pointer
=	O
edit_find	function
(	O
q	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
exp	pointer
,	O
&	O
len	int
,	O
edit	pointer
->	O
last_byte	long
,	O
edit_get_byte	function
,	O
(	O
void	O
*	O
)	O
edit	pointer
,	O
0	int
)	O
;	O
if	O
(	O
p	pointer
<	O
0	int
)	O
break	O
;	O
found	int
++	O
;	O
l	pointer
+=	O
edit_count_lines	function
(	O
edit	pointer
,	O
q	long
,	O
p	pointer
)	O
;	O
if	O
(	O
l	pointer
!=	O
l_last	int
)	O
{	O
book_mark_insert	function
(	O
edit	pointer
,	O
l	pointer
,	O
BOOK_MARK_FOUND_COLOR	O
)	O
;	O
books	int
++	O
;	O
}	O
l_last	int
=	O
l	pointer
;	O
q	long
=	O
p	pointer
+	O
1	int
;	O
}	O
if	O
(	O
found	int
)	O
{	O
message	pointer
(	O
0	int
,	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
" %d items found, %d bookmarks added "	pointer
)	O
,	O
found	int
,	O
books	int
)	O
;	O
}	O
else	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
" Search string not found "	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
edit	pointer
->	O
found_len	int
&&	O
edit	pointer
->	O
search_start	long
==	O
edit	pointer
->	O
found_start	long
+	O
1	int
&&	O
replace_backwards	int
)	O
edit	pointer
->	O
search_start	long
--	O
;	O
if	O
(	O
edit	pointer
->	O
found_len	int
&&	O
edit	pointer
->	O
search_start	long
==	O
edit	pointer
->	O
found_start	long
-	O
1	int
&&	O
!	O
replace_backwards	int
)	O
edit	pointer
->	O
search_start	long
++	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit_find	function
(	O
edit	pointer
->	O
search_start	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
exp	pointer
,	O
&	O
len	int
,	O
edit	pointer
->	O
last_byte	long
,	O
edit_get_byte	function
,	O
(	O
void	O
*	O
)	O
edit	pointer
,	O
0	int
)	O
;	O
if	O
(	O
edit	pointer
->	O
search_start	long
>=	O
0	int
)	O
{	O
edit	pointer
->	O
found_start	long
=	O
edit	pointer
->	O
search_start	long
;	O
edit	pointer
->	O
found_len	int
=	O
len	int
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit	pointer
->	O
search_start	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
replace_backwards	int
)	O
edit	pointer
->	O
search_start	long
--	O
;	O
else	O
edit	pointer
->	O
search_start	long
++	O
;	O
}	O
else	O
if	O
(	O
edit	pointer
->	O
search_start	long
==	O
-	O
3	int
)	O
{	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
regexp_error	function
(	O
edit	pointer
)	O
;	O
}	O
else	O
{	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Search"	pointer
)	O
,	O
_	O
(	O
" Search string not found "	pointer
)	O
)	O
;	O
}	O
}	O
}	O
g_free	function
(	O
exp	pointer
)	O
;	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_scroll_screen_over_cursor	function
(	O
edit	pointer
)	O
;	O
}	O
int	O
edit_ok_to_exit	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
modified	long
)	O
return	O
1	int
;	O
switch	O
(	O
edit_query_dialog3	O
(	O
_	O
(	O
"Quit"	pointer
)	O
,	O
_	O
(	O
" File was modified, Save with exit? "	pointer
)	O
,	O
_	O
(	O
"&Cancel quit"	pointer
)	O
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
)	O
{	O
case	O
1	int
:	O
edit_push_markers	function
(	O
edit	pointer
)	O
;	O
edit_set_markers	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
edit_save_cmd	function
(	O
edit	pointer
)	O
)	O
return	O
0	int
;	O
break	O
;	O
case	O
2	int
:	O
break	O
;	O
case	O
0	int
:	O
case	O
-	O
1	int
:	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
edit_get_block	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
start	pointer
,	O
long	O
finish	long
,	O
int	O
*	O
l	pointer
)	O
{	O
unsigned	O
char	O
*	O
s	pointer
,	O
*	O
r	pointer
;	O
r	pointer
=	O
s	pointer
=	O
g_malloc	function
(	O
finish	long
-	O
start	pointer
+	O
1	int
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
*	O
l	pointer
=	O
0	int
;	O
while	O
(	O
start	pointer
<	O
finish	long
)	O
{	O
int	O
c	int
,	O
x	array
;	O
x	array
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
start	pointer
)	O
,	O
0	int
,	O
start	pointer
)	O
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
start	pointer
)	O
;	O
if	O
(	O
(	O
x	array
>=	O
edit	pointer
->	O
column1	int
&&	O
x	array
<	O
edit	pointer
->	O
column2	int
)	O
||	O
(	O
x	array
>=	O
edit	pointer
->	O
column2	int
&&	O
x	array
<	O
edit	pointer
->	O
column1	int
)	O
||	O
c	int
==	O
'\n'	O
)	O
{	O
*	O
s	pointer
++	O
=	O
c	int
;	O
(	O
*	O
l	pointer
)	O
++	O
;	O
}	O
start	pointer
++	O
;	O
}	O
}	O
else	O
{	O
*	O
l	pointer
=	O
finish	long
-	O
start	pointer
;	O
while	O
(	O
start	pointer
<	O
finish	long
)	O
*	O
s	pointer
++	O
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
start	pointer
++	O
)	O
;	O
}	O
*	O
s	pointer
=	O
0	int
;	O
return	O
r	pointer
;	O
}	O
int	O
edit_save_block	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
long	O
start	pointer
,	O
long	O
finish	long
)	O
{	O
int	O
len	int
,	O
file	pointer
;	O
if	O
(	O
(	O
file	pointer
=	O
mc_open	function
(	O
filename	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
column_highlighting	int
)	O
{	O
unsigned	O
char	O
*	O
block	int
,	O
*	O
p	pointer
;	O
int	O
r	pointer
;	O
p	pointer
=	O
block	int
=	O
edit_get_block	function
(	O
edit	pointer
,	O
start	pointer
,	O
finish	long
,	O
&	O
len	int
)	O
;	O
while	O
(	O
len	int
)	O
{	O
r	pointer
=	O
mc_write	function
(	O
file	pointer
,	O
p	pointer
,	O
len	int
)	O
;	O
if	O
(	O
r	pointer
<	O
0	int
)	O
break	O
;	O
p	pointer
+=	O
r	pointer
;	O
len	int
-=	O
r	pointer
;	O
}	O
g_free	function
(	O
block	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
*	O
buf	pointer
;	O
int	O
i	array
=	O
start	pointer
,	O
end	pointer
;	O
len	int
=	O
finish	long
-	O
start	pointer
;	O
buf	pointer
=	O
g_malloc	function
(	O
TEMP_BUF_LEN	int
)	O
;	O
while	O
(	O
start	pointer
!=	O
finish	long
)	O
{	O
end	pointer
=	O
min	long
(	O
finish	long
,	O
start	pointer
+	O
TEMP_BUF_LEN	int
)	O
;	O
for	O
(	O
;	O
i	array
<	O
end	pointer
;	O
i	array
++	O
)	O
buf	pointer
[	O
i	array
-	O
start	pointer
]	O
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
len	int
-=	O
mc_write	function
(	O
file	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
end	pointer
-	O
start	pointer
)	O
;	O
start	pointer
=	O
end	pointer
;	O
}	O
g_free	function
(	O
buf	pointer
)	O
;	O
}	O
mc_close	function
(	O
file	pointer
)	O
;	O
if	O
(	O
len	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
edit_save_block_to_clip_file	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
start	pointer
,	O
long	O
finish	long
)	O
{	O
return	O
edit_save_block	function
(	O
edit	pointer
,	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
start	pointer
,	O
finish	long
)	O
;	O
}	O
void	O
edit_paste_from_history	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
(	O
void	O
)	O
edit	pointer
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Error "	pointer
)	O
,	O
_	O
(	O
" This function is not implemented. "	pointer
)	O
)	O
;	O
}	O
int	O
edit_copy_to_X_buf_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
edit_save_block_to_clip_file	function
(	O
edit	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Copy to clipboard "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Unable to save to file. "	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_cut_to_X_buf_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
edit_save_block_to_clip_file	function
(	O
edit	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Cut to clipboard "	pointer
)	O
,	O
_	O
(	O
" Unable to save to file. "	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
;	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
edit_paste_from_X_buf_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_insert_file	function
(	O
edit	pointer
,	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
void	O
edit_goto_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
f	pointer
;	O
static	O
long	O
line	int
=	O
0	int
;	O
long	O
l	pointer
;	O
char	O
*	O
error	pointer
;	O
char	O
s	pointer
[	O
32	int
]	O
;	O
g_snprintf	function
(	O
s	pointer
,	O
sizeof	O
(	O
s	pointer
)	O
,	O
"%ld"	pointer
,	O
line	int
)	O
;	O
f	pointer
=	O
input_dialog	function
(	O
_	O
(	O
" Goto line "	pointer
)	O
,	O
_	O
(	O
" Enter line: "	pointer
)	O
,	O
line	int
?	O
s	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
f	pointer
)	O
{	O
g_free	function
(	O
f	pointer
)	O
;	O
return	O
;	O
}	O
l	pointer
=	O
strtol	function
(	O
f	pointer
,	O
&	O
error	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
error	pointer
)	O
{	O
g_free	function
(	O
f	pointer
)	O
;	O
return	O
;	O
}	O
line	int
=	O
l	pointer
;	O
if	O
(	O
l	pointer
<	O
0	int
)	O
l	pointer
=	O
edit	pointer
->	O
total_lines	long
+	O
l	pointer
+	O
2	int
;	O
edit_move_display	function
(	O
edit	pointer
,	O
l	pointer
-	O
edit	pointer
->	O
num_widget_lines	int
/	O
2	int
-	O
1	int
)	O
;	O
edit_move_to_line	function
(	O
edit	pointer
,	O
l	pointer
-	O
1	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
g_free	function
(	O
f	pointer
)	O
;	O
}	O
int	O
edit_save_block_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
char	O
*	O
exp	pointer
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
return	O
1	int
;	O
exp	pointer
=	O
edit_get_save_file	O
(	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
_	O
(	O
" Save Block "	pointer
)	O
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
if	O
(	O
exp	pointer
)	O
{	O
if	O
(	O
!	O
*	O
exp	pointer
)	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
edit_save_block	function
(	O
edit	pointer
,	O
exp	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
)	O
)	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Save Block "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot save file. "	pointer
)	O
)	O
)	O
;	O
}	O
}	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_insert_file_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
exp	pointer
=	O
edit_get_load_file	O
(	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
CLIP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
_	O
(	O
" Insert File "	pointer
)	O
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
if	O
(	O
exp	pointer
)	O
{	O
if	O
(	O
!	O
*	O
exp	pointer
)	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
edit_insert_file	function
(	O
edit	pointer
,	O
exp	pointer
)	O
)	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
g_free	function
(	O
exp	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Insert File "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot insert file. "	pointer
)	O
)	O
)	O
;	O
}	O
}	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_sort_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
static	O
char	O
*	O
old	pointer
=	O
0	int
;	O
char	O
*	O
exp	pointer
;	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
int	O
e	pointer
;	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Sort block "	pointer
)	O
,	O
_	O
(	O
" You must first highlight a block of text. "	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
edit_save_block	function
(	O
edit	pointer
,	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
BLOCK_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
,	O
start_mark	pointer
,	O
end_mark	pointer
)	O
;	O
exp	pointer
=	O
input_dialog	function
(	O
_	O
(	O
" Run Sort "	pointer
)	O
,	O
_	O
(	O
" Enter sort options (see manpage) separated by whitespace: "	pointer
)	O
,	O
(	O
old	pointer
!=	O
NULL	O
)	O
?	O
old	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
!	O
exp	pointer
)	O
return	O
1	int
;	O
g_free	function
(	O
old	pointer
)	O
;	O
old	pointer
=	O
exp	pointer
;	O
e	pointer
=	O
system	function
(	O
catstrs	function
(	O
" sort "	pointer
,	O
exp	pointer
,	O
" "	pointer
,	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
BLOCK_FILE	O
,	O
" > "	pointer
,	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
if	O
(	O
e	pointer
)	O
{	O
if	O
(	O
e	pointer
==	O
-	O
1	int
||	O
e	pointer
==	O
127	int
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
" Sort "	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
" Cannot execute sort command "	pointer
)	O
)	O
)	O
;	O
}	O
else	O
{	O
char	O
q	long
[	O
8	int
]	O
;	O
sprintf	function
(	O
q	long
,	O
"%d "	pointer
,	O
e	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
" Sort "	pointer
)	O
,	O
catstrs	function
(	O
_	O
(	O
" Sort returned non-zero: "	pointer
)	O
,	O
q	long
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
)	O
return	O
1	int
;	O
edit_insert_file	function
(	O
edit	pointer
,	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_ext_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
exp	pointer
;	O
int	O
e	pointer
;	O
exp	pointer
=	O
input_dialog	function
(	O
_	O
(	O
"Paste output of external command"	pointer
)	O
,	O
_	O
(	O
"Enter shell command(s):"	pointer
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
exp	pointer
)	O
return	O
1	int
;	O
e	pointer
=	O
system	function
(	O
catstrs	function
(	O
exp	pointer
,	O
" > "	pointer
,	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
g_free	function
(	O
exp	pointer
)	O
;	O
if	O
(	O
e	pointer
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"External command"	pointer
)	O
,	O
get_sys_error	O
(	O
_	O
(	O
"Cannot execute command"	pointer
)	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_insert_file	function
(	O
edit	pointer
,	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
TEMP_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
edit_block_process_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
shell_cmd	pointer
,	O
int	O
block	int
)	O
{	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
FILE	struct
*	O
script_home	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
script_src	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
block_file	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
o	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
h	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
b	pointer
=	O
NULL	O
;	O
char	O
*	O
quoted_name	pointer
=	O
NULL	O
;	O
o	pointer
=	O
catstrs	function
(	O
mc_home	pointer
,	O
shell_cmd	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
h	pointer
=	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
EDIT_DIR	O
,	O
shell_cmd	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
b	pointer
=	O
catstrs	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
BLOCK_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
script_home	pointer
=	O
fopen	function
(	O
h	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
script_home	pointer
=	O
fopen	function
(	O
h	pointer
,	O
"w"	pointer
)	O
)	O
)	O
{	O
edit_error_dialog	O
(	O
""	pointer
,	O
get_sys_error	O
(	O
catstrs	function
(	O
_	O
(	O
"Error creating script:"	pointer
)	O
,	O
h	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
script_src	pointer
=	O
fopen	function
(	O
o	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fclose	function
(	O
script_home	pointer
)	O
;	O
unlink	function
(	O
h	pointer
)	O
;	O
edit_error_dialog	O
(	O
""	pointer
,	O
get_sys_error	O
(	O
catstrs	function
(	O
_	O
(	O
"Error reading script:"	pointer
)	O
,	O
o	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
script_src	pointer
)	O
)	O
fputs	function
(	O
buf	pointer
,	O
script_home	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
script_home	pointer
)	O
)	O
{	O
edit_error_dialog	O
(	O
""	pointer
,	O
get_sys_error	O
(	O
catstrs	function
(	O
_	O
(	O
"Error closing script:"	pointer
)	O
,	O
h	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
return	O
;	O
}	O
chmod	function
(	O
h	pointer
,	O
0700	int
)	O
;	O
edit_error_dialog	O
(	O
""	pointer
,	O
get_sys_error	O
(	O
catstrs	function
(	O
_	O
(	O
"Script created:"	pointer
)	O
,	O
h	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
)	O
;	O
}	O
open_error_pipe	function
(	O
)	O
;	O
if	O
(	O
block	int
)	O
{	O
if	O
(	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Process block"	pointer
)	O
,	O
_	O
(	O
" You must first highlight a block of text. "	pointer
)	O
)	O
;	O
return	O
;	O
}	O
edit_save_block	function
(	O
edit	pointer
,	O
b	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
)	O
;	O
quoted_name	pointer
=	O
name_quote	function
(	O
edit	pointer
->	O
filename	pointer
,	O
0	int
)	O
;	O
system	function
(	O
catstrs	function
(	O
" "	pointer
,	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
EDIT_DIR	O
,	O
shell_cmd	pointer
,	O
" "	pointer
,	O
quoted_name	pointer
,	O
" "	pointer
,	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
BLOCK_FILE	O
" /dev/null"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
else	O
{	O
system	function
(	O
catstrs	function
(	O
" "	pointer
,	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
EDIT_DIR	O
,	O
shell_cmd	pointer
,	O
" "	pointer
,	O
quoted_name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
g_free	function
(	O
quoted_name	pointer
)	O
;	O
close_error_pipe	function
(	O
0	int
,	O
0	int
)	O
;	O
edit_refresh_cmd	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
if	O
(	O
block	int
)	O
{	O
if	O
(	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
)	O
return	O
;	O
edit_insert_file	function
(	O
edit	pointer
,	O
b	pointer
)	O
;	O
if	O
(	O
(	O
block_file	pointer
=	O
fopen	function
(	O
b	pointer
,	O
"w"	pointer
)	O
)	O
)	O
fclose	function
(	O
block_file	pointer
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
int	O
edit_print_string	function
(	O
WEdit	struct
*	O
e	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	array
=	O
0	int
;	O
while	O
(	O
s	pointer
[	O
i	array
]	O
)	O
edit_execute_cmd	function
(	O
e	pointer
,	O
-	O
1	int
,	O
(	O
unsigned	O
char	O
)	O
s	pointer
[	O
i	array
++	O
]	O
)	O
;	O
e	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_update_screen	function
(	O
e	pointer
)	O
;	O
return	O
i	array
;	O
}	O
static	O
void	O
pipe_mail	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
char	O
*	O
to	char
,	O
char	O
*	O
subject	pointer
,	O
char	O
*	O
cc	pointer
)	O
{	O
FILE	struct
*	O
p	pointer
=	O
0	int
;	O
char	O
*	O
s	pointer
;	O
to	char
=	O
name_quote	function
(	O
to	char
,	O
0	int
)	O
;	O
subject	pointer
=	O
name_quote	function
(	O
subject	pointer
,	O
0	int
)	O
;	O
cc	pointer
=	O
name_quote	function
(	O
cc	pointer
,	O
0	int
)	O
;	O
s	pointer
=	O
g_strconcat	function
(	O
"mail -s "	pointer
,	O
subject	pointer
,	O
*	O
cc	pointer
?	O
" -c "	pointer
:	O
""	pointer
,	O
cc	pointer
,	O
" "	pointer
,	O
to	char
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
to	char
)	O
;	O
g_free	function
(	O
subject	pointer
)	O
;	O
g_free	function
(	O
cc	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
p	pointer
=	O
popen	function
(	O
s	pointer
,	O
"w"	pointer
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
)	O
{	O
long	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
edit	pointer
->	O
last_byte	long
;	O
i	array
++	O
)	O
fputc	function
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
,	O
p	pointer
)	O
;	O
pclose	function
(	O
p	pointer
)	O
;	O
}	O
}	O
void	O
edit_mail_dialog	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
tmail_to	pointer
;	O
char	O
*	O
tmail_subject	pointer
;	O
char	O
*	O
tmail_cc	pointer
;	O
static	O
char	O
*	O
mail_cc_last	pointer
=	O
0	int
;	O
static	O
char	O
*	O
mail_subject_last	pointer
=	O
0	int
;	O
static	O
char	O
*	O
mail_to_last	pointer
=	O
0	int
;	O
QuickDialog	struct
Quick_input	struct
=	O
{	O
50	int
,	O
MAIL_DLG_HEIGHT	int
,	O
-	O
1	int
,	O
0	int
,	O
N_	O
(	O
" Mail "	pointer
)	O
,	O
"[Input Line Keys]"	pointer
,	O
0	int
,	O
0	int
}	O
;	O
QuickWidget	struct
quick_widgets	array
[	O
]	O
=	O
{	O
{	O
quick_button	int
,	O
6	int
,	O
10	int
,	O
9	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
,	O
0	int
,	O
B_CANCEL	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_button	int
,	O
2	int
,	O
10	int
,	O
9	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
0	int
,	O
B_ENTER	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
50	int
,	O
8	int
,	O
MAIL_DLG_HEIGHT	int
,	O
""	pointer
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"mail-dlg-input"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
7	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" Copies to"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
50	int
,	O
6	int
,	O
MAIL_DLG_HEIGHT	int
,	O
""	pointer
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"mail-dlg-input-2"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
5	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" Subject"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_input	int
,	O
3	int
,	O
50	int
,	O
4	int
,	O
MAIL_DLG_HEIGHT	int
,	O
""	pointer
,	O
44	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
"mail-dlg-input-3"	pointer
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
3	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" To"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
quick_label	int
,	O
2	int
,	O
50	int
,	O
2	int
,	O
MAIL_DLG_HEIGHT	int
,	O
N_	O
(	O
" mail -s <subject> -c <cc> <to>"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
NULL_QuickWidget	O
}	O
;	O
quick_widgets	array
[	O
2	int
]	O
.	O
str_result	pointer
=	O
&	O
tmail_cc	pointer
;	O
quick_widgets	array
[	O
2	int
]	O
.	O
text	pointer
=	O
mail_cc_last	pointer
?	O
mail_cc_last	pointer
:	O
""	pointer
;	O
quick_widgets	array
[	O
4	int
]	O
.	O
str_result	pointer
=	O
&	O
tmail_subject	pointer
;	O
quick_widgets	array
[	O
4	int
]	O
.	O
text	pointer
=	O
mail_subject_last	pointer
?	O
mail_subject_last	pointer
:	O
""	pointer
;	O
quick_widgets	array
[	O
6	int
]	O
.	O
str_result	pointer
=	O
&	O
tmail_to	pointer
;	O
quick_widgets	array
[	O
6	int
]	O
.	O
text	pointer
=	O
mail_to_last	pointer
?	O
mail_to_last	pointer
:	O
""	pointer
;	O
Quick_input	struct
.	O
widgets	pointer
=	O
quick_widgets	array
;	O
if	O
(	O
quick_dialog	function
(	O
&	O
Quick_input	struct
)	O
!=	O
B_CANCEL	int
)	O
{	O
g_free	function
(	O
mail_cc_last	pointer
)	O
;	O
g_free	function
(	O
mail_subject_last	pointer
)	O
;	O
g_free	function
(	O
mail_to_last	pointer
)	O
;	O
mail_cc_last	pointer
=	O
tmail_cc	pointer
;	O
mail_subject_last	pointer
=	O
tmail_subject	pointer
;	O
mail_to_last	pointer
=	O
tmail_to	pointer
;	O
pipe_mail	function
(	O
edit	pointer
,	O
mail_to_last	pointer
,	O
mail_subject_last	pointer
,	O
mail_cc_last	pointer
)	O
;	O
}	O
}	O
static	O
int	O
edit_find_word_start	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
*	O
word_start	pointer
,	O
int	O
*	O
word_len	pointer
)	O
{	O
int	O
i	array
,	O
c	int
,	O
last	int
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
<=	O
0	int
)	O
return	O
0	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
;	O
if	O
(	O
isspace	function
(	O
c	int
)	O
||	O
!	O
(	O
isalnum	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
)	O
return	O
0	int
;	O
for	O
(	O
i	array
=	O
2	int
;	O
;	O
i	array
++	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
curs1	long
-	O
i	array
<	O
0	int
)	O
return	O
0	int
;	O
last	int
=	O
c	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
i	array
)	O
;	O
if	O
(	O
!	O
(	O
isalnum	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
)	O
{	O
if	O
(	O
isdigit	function
(	O
last	int
)	O
)	O
return	O
0	int
;	O
*	O
word_start	pointer
=	O
edit	pointer
->	O
curs1	long
-	O
(	O
i	array
-	O
1	int
)	O
;	O
*	O
word_len	pointer
=	O
i	array
-	O
1	int
;	O
break	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
edit_set_search_parameters	function
(	O
int	O
rs	int
,	O
int	O
rb	int
,	O
int	O
rr	int
,	O
int	O
rw	int
,	O
int	O
rc	pointer
)	O
{	O
replace_scanf	int
=	O
rs	int
;	O
replace_backwards	int
=	O
rb	int
;	O
replace_regexp	int
=	O
rr	int
;	O
replace_whole	int
=	O
rw	int
;	O
replace_case	int
=	O
rc	pointer
;	O
}	O
static	O
int	O
edit_collect_completions	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
start	pointer
,	O
int	O
word_len	pointer
,	O
char	O
*	O
match_expr	pointer
,	O
struct	O
selection	struct
*	O
compl	pointer
,	O
int	O
*	O
num	int
)	O
{	O
int	O
len	int
,	O
max_len	long
=	O
0	int
,	O
i	array
,	O
skip	int
;	O
unsigned	O
char	O
*	O
bufpos	pointer
;	O
while	O
(	O
*	O
num	int
<	O
MAX_WORD_COMPLETIONS	int
)	O
{	O
start	pointer
=	O
edit_find	function
(	O
start	pointer
-	O
1	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
match_expr	pointer
,	O
&	O
len	int
,	O
edit	pointer
->	O
last_byte	long
,	O
edit_get_byte	function
,	O
(	O
void	O
*	O
)	O
edit	pointer
,	O
0	int
)	O
;	O
if	O
(	O
start	pointer
<	O
0	int
)	O
break	O
;	O
bufpos	pointer
=	O
&	O
edit	pointer
->	O
buffers1	array
[	O
start	pointer
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
start	pointer
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
skip	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
*	O
num	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
(	O
char	O
*	O
)	O
&	O
compl	pointer
[	O
i	array
]	O
.	O
text	pointer
[	O
word_len	pointer
]	O
,	O
(	O
char	O
*	O
)	O
&	O
bufpos	pointer
[	O
word_len	pointer
]	O
,	O
max	long
(	O
len	int
,	O
compl	pointer
[	O
i	array
]	O
.	O
len	int
)	O
-	O
word_len	pointer
)	O
==	O
0	int
)	O
{	O
skip	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
skip	int
)	O
continue	O
;	O
compl	pointer
[	O
*	O
num	int
]	O
.	O
text	pointer
=	O
g_malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
compl	pointer
[	O
*	O
num	int
]	O
.	O
len	int
=	O
len	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
len	int
;	O
i	array
++	O
)	O
compl	pointer
[	O
*	O
num	int
]	O
.	O
text	pointer
[	O
i	array
]	O
=	O
*	O
(	O
bufpos	pointer
+	O
i	array
)	O
;	O
compl	pointer
[	O
*	O
num	int
]	O
.	O
text	pointer
[	O
i	array
]	O
=	O
'\0'	O
;	O
(	O
*	O
num	int
)	O
++	O
;	O
if	O
(	O
len	int
>	O
max_len	long
)	O
max_len	long
=	O
len	int
;	O
}	O
return	O
max_len	long
;	O
}	O
static	O
void	O
edit_completion_dialog	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
max_len	long
,	O
int	O
word_len	pointer
,	O
struct	O
selection	struct
*	O
compl	pointer
,	O
int	O
num_compl	int
)	O
{	O
int	O
start_x	int
,	O
start_y	int
,	O
offset	long
,	O
i	array
;	O
char	O
*	O
curr	pointer
=	O
NULL	O
;	O
Dlg_head	struct
*	O
compl_dlg	pointer
;	O
WListbox	struct
*	O
compl_list	pointer
;	O
int	O
compl_dlg_h	int
;	O
int	O
compl_dlg_w	int
;	O
compl_dlg_h	int
=	O
num_compl	int
+	O
2	int
;	O
compl_dlg_w	int
=	O
max_len	long
+	O
4	int
;	O
start_x	int
=	O
edit	pointer
->	O
curs_col	long
+	O
edit	pointer
->	O
start_col	long
-	O
(	O
compl_dlg_w	int
/	O
2	int
)	O
;	O
start_y	int
=	O
edit	pointer
->	O
curs_row	long
+	O
EDIT_TEXT_VERTICAL_OFFSET	int
+	O
1	int
;	O
if	O
(	O
start_x	int
<	O
0	int
)	O
start_x	int
=	O
0	int
;	O
if	O
(	O
compl_dlg_w	int
>	O
COLS	O
)	O
compl_dlg_w	int
=	O
COLS	O
;	O
if	O
(	O
compl_dlg_h	int
>	O
LINES	O
-	O
2	int
)	O
compl_dlg_h	int
=	O
LINES	O
-	O
2	int
;	O
offset	long
=	O
start_x	int
+	O
compl_dlg_w	int
-	O
COLS	O
;	O
if	O
(	O
offset	long
>	O
0	int
)	O
start_x	int
-=	O
offset	long
;	O
offset	long
=	O
start_y	int
+	O
compl_dlg_h	int
-	O
LINES	O
;	O
if	O
(	O
offset	long
>	O
0	int
)	O
start_y	int
-=	O
(	O
offset	long
+	O
1	int
)	O
;	O
compl_dlg	pointer
=	O
create_dlg	function
(	O
start_y	int
,	O
start_x	int
,	O
compl_dlg_h	int
,	O
compl_dlg_w	int
,	O
dialog_colors	array
,	O
NULL	O
,	O
"[Completion]"	pointer
,	O
NULL	O
,	O
DLG_COMPACT	O
)	O
;	O
compl_list	pointer
=	O
listbox_new	function
(	O
1	int
,	O
1	int
,	O
compl_dlg_w	int
-	O
2	int
,	O
compl_dlg_h	int
-	O
2	int
,	O
NULL	O
)	O
;	O
add_widget	function
(	O
compl_dlg	pointer
,	O
compl_list	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
num_compl	int
;	O
i	array
++	O
)	O
listbox_add_item	function
(	O
compl_list	pointer
,	O
LISTBOX_APPEND_AT_END	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
compl	pointer
[	O
i	array
]	O
.	O
text	pointer
,	O
NULL	O
)	O
;	O
run_dlg	function
(	O
compl_dlg	pointer
)	O
;	O
if	O
(	O
compl_dlg	pointer
->	O
ret_value	int
==	O
B_ENTER	int
)	O
{	O
listbox_get_current	function
(	O
compl_list	pointer
,	O
&	O
curr	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
curr	pointer
)	O
for	O
(	O
curr	pointer
+=	O
word_len	pointer
;	O
*	O
curr	pointer
;	O
curr	pointer
++	O
)	O
edit_insert	function
(	O
edit	pointer
,	O
*	O
curr	pointer
)	O
;	O
}	O
destroy_dlg	function
(	O
compl_dlg	pointer
)	O
;	O
}	O
void	O
edit_complete_word_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
word_len	pointer
=	O
0	int
,	O
i	array
,	O
num_compl	int
=	O
0	int
,	O
max_len	long
;	O
long	O
word_start	pointer
=	O
0	int
;	O
unsigned	O
char	O
*	O
bufpos	pointer
;	O
char	O
*	O
match_expr	pointer
;	O
struct	O
selection	struct
compl	pointer
[	O
MAX_WORD_COMPLETIONS	int
]	O
;	O
int	O
old_rs	int
=	O
replace_scanf	int
;	O
int	O
old_rb	int
=	O
replace_backwards	int
;	O
int	O
old_rr	int
=	O
replace_regexp	int
;	O
int	O
old_rw	int
=	O
replace_whole	int
;	O
int	O
old_rc	int
=	O
replace_case	int
;	O
if	O
(	O
!	O
edit_find_word_start	function
(	O
edit	pointer
,	O
&	O
word_start	pointer
,	O
&	O
word_len	pointer
)	O
)	O
return	O
;	O
bufpos	pointer
=	O
&	O
edit	pointer
->	O
buffers1	array
[	O
word_start	pointer
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
word_start	pointer
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
match_expr	pointer
=	O
g_strdup_printf	function
(	O
"%.*s[a-zA-Z_0-9]+"	pointer
,	O
word_len	pointer
,	O
bufpos	pointer
)	O
;	O
edit_set_search_parameters	function
(	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
max_len	long
=	O
edit_collect_completions	function
(	O
edit	pointer
,	O
word_start	pointer
,	O
word_len	pointer
,	O
match_expr	pointer
,	O
(	O
struct	O
selection	struct
*	O
)	O
&	O
compl	pointer
,	O
&	O
num_compl	int
)	O
;	O
if	O
(	O
num_compl	int
>	O
0	int
)	O
{	O
if	O
(	O
num_compl	int
==	O
1	int
)	O
{	O
for	O
(	O
i	array
=	O
word_len	pointer
;	O
i	array
<	O
compl	pointer
[	O
0	int
]	O
.	O
len	int
;	O
i	array
++	O
)	O
edit_insert	function
(	O
edit	pointer
,	O
*	O
(	O
compl	pointer
[	O
0	int
]	O
.	O
text	pointer
+	O
i	array
)	O
)	O
;	O
}	O
else	O
{	O
edit_completion_dialog	function
(	O
edit	pointer
,	O
max_len	long
,	O
word_len	pointer
,	O
(	O
struct	O
selection	struct
*	O
)	O
&	O
compl	pointer
,	O
num_compl	int
)	O
;	O
}	O
}	O
g_free	function
(	O
match_expr	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
num_compl	int
;	O
i	array
++	O
)	O
g_free	function
(	O
compl	pointer
[	O
i	array
]	O
.	O
text	pointer
)	O
;	O
edit_set_search_parameters	function
(	O
old_rs	int
,	O
old_rb	int
,	O
old_rr	int
,	O
old_rw	int
,	O
old_rc	int
)	O
;	O
}	O
void	O
edit_select_codepage_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
}	O
void	O
edit_insert_literal_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
char_for_insertion	int
=	O
edit_raw_key_query	function
(	O
_	O
(	O
" Insert Literal "	pointer
)	O
,	O
_	O
(	O
" Press any key: "	pointer
)	O
,	O
0	int
)	O
;	O
edit_execute_key_command	function
(	O
edit	pointer
,	O
-	O
1	int
,	O
ascii_alpha_to_cntrl	function
(	O
char_for_insertion	int
)	O
)	O
;	O
}	O
void	O
edit_execute_macro_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
command	pointer
=	O
CK_Macro	O
(	O
edit_raw_key_query	function
(	O
_	O
(	O
" Execute Macro "	pointer
)	O
,	O
_	O
(	O
" Press macro hotkey: "	pointer
)	O
,	O
1	int
)	O
)	O
;	O
if	O
(	O
command	pointer
==	O
CK_Macro	O
(	O
0	int
)	O
)	O
command	pointer
=	O
CK_Insert_Char	O
;	O
edit_execute_key_command	function
(	O
edit	pointer
,	O
command	pointer
,	O
-	O
1	int
)	O
;	O
}	O
void	O
edit_begin_end_macro_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
command	pointer
;	O
if	O
(	O
edit	pointer
)	O
{	O
command	pointer
=	O
edit	pointer
->	O
macro_i	int
<	O
0	int
?	O
CK_Begin_Record_Macro	int
:	O
CK_End_Record_Macro	int
;	O
edit_execute_key_command	function
(	O
edit	pointer
,	O
command	pointer
,	O
-	O
1	int
)	O
;	O
}	O
}	O
