thread_t	O
reader_thread	int
=	O
MACH_PORT_NULL	O
;	O
static	O
file_t	O
ioport	int
=	O
MACH_PORT_NULL	O
;	O
unsigned	O
int	O
tioc_caps	int
;	O
thread_t	O
writer_thread	int
=	O
MACH_PORT_NULL	O
;	O
static	O
int	O
output_stopped	int
;	O
static	O
pthread_cond_t	union
hurdio_writer_condition	union
;	O
size_t	long
npending_output	long
;	O
int	O
assert_dtr	int
;	O
static	O
pthread_cond_t	union
hurdio_assert_dtr_condition	union
;	O
static	O
error_t	int
hurdio_desert_dtr	function
(	O
)	O
;	O
static	O
void	O
*	O
hurdio_reader_loop	function
(	O
void	O
*	O
arg	pointer
)	O
;	O
static	O
void	O
*	O
hurdio_writer_loop	function
(	O
void	O
*	O
arg	pointer
)	O
;	O
static	O
error_t	int
hurdio_set_bits	function
(	O
struct	O
termios	struct
*	O
state	pointer
)	O
;	O
static	O
error_t	int
hurdio_init	function
(	O
void	O
)	O
{	O
pthread_t	long
thread	long
;	O
error_t	int
err	int
;	O
pthread_cond_init	function
(	O
&	O
hurdio_writer_condition	union
,	O
NULL	O
)	O
;	O
pthread_cond_init	function
(	O
&	O
hurdio_assert_dtr_condition	union
,	O
NULL	O
)	O
;	O
err	int
=	O
pthread_create	function
(	O
&	O
thread	long
,	O
NULL	O
,	O
hurdio_reader_loop	function
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
pthread_detach	function
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	int
;	O
perror	function
(	O
"pthread_create"	pointer
)	O
;	O
}	O
err	int
=	O
pthread_create	function
(	O
&	O
thread	long
,	O
NULL	O
,	O
hurdio_writer_loop	function
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
pthread_detach	function
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	int
;	O
perror	function
(	O
"pthread_create"	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_fini	function
(	O
void	O
)	O
{	O
hurdio_desert_dtr	function
(	O
)	O
;	O
writer_thread	int
=	O
MACH_PORT_NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_gwinsz	function
(	O
struct	O
winsize	O
*	O
size	pointer
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_GWINSZ	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocgwinsz	function
(	O
ioport	int
,	O
size	pointer
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
{	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_GWINSZ	int
;	O
err	int
=	O
EOPNOTSUPP	int
;	O
}	O
return	O
err	int
;	O
}	O
return	O
EOPNOTSUPP	int
;	O
}	O
static	O
void	O
wait_for_dtr	function
(	O
void	O
)	O
{	O
while	O
(	O
!	O
assert_dtr	int
)	O
pthread_hurd_cond_wait_np	function
(	O
&	O
hurdio_assert_dtr_condition	union
,	O
&	O
global_lock	O
)	O
;	O
assert_dtr	int
=	O
0	int
;	O
if	O
(	O
tty_arg	O
==	O
0	int
)	O
ioport	int
=	O
termctl	O
->	O
underlying	O
;	O
else	O
{	O
ioport	int
=	O
file_name_lookup	function
(	O
tty_arg	O
,	O
O_READ	O
|	O
O_WRITE	O
,	O
0	int
)	O
;	O
if	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
)	O
{	O
report_carrier_error	function
(	O
errno	O
)	O
;	O
return	O
;	O
}	O
}	O
error_t	int
err	int
;	O
struct	O
termios	struct
state	pointer
=	O
termstate	O
;	O
tioc_caps	int
=	O
~	O
0	int
;	O
err	int
=	O
hurdio_set_bits	function
(	O
&	O
state	pointer
)	O
;	O
if	O
(	O
err	int
)	O
report_carrier_error	function
(	O
err	int
)	O
;	O
else	O
{	O
termstate	O
=	O
state	pointer
;	O
report_carrier_on	function
(	O
)	O
;	O
pthread_cond_broadcast	function
(	O
&	O
hurdio_writer_condition	union
)	O
;	O
}	O
}	O
static	O
void	O
*	O
hurdio_reader_loop	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
char	O
buffer	array
[	O
BUFFER_SIZE	int
]	O
;	O
char	O
*	O
data	pointer
;	O
size_t	long
datalen	long
;	O
error_t	int
err	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	O
)	O
;	O
reader_thread	int
=	O
mach_thread_self	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
)	O
wait_for_dtr	function
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	O
)	O
;	O
data	pointer
=	O
buffer	array
;	O
datalen	long
=	O
BUFFER_SIZE	int
;	O
err	int
=	O
io_read	function
(	O
ioport	int
,	O
&	O
data	pointer
,	O
&	O
datalen	long
,	O
-	O
1	int
,	O
BUFFER_SIZE	int
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
err	int
||	O
!	O
datalen	long
)	O
hurdio_desert_dtr	function
(	O
)	O
;	O
else	O
{	O
if	O
(	O
termstate	O
.	O
c_cflag	int
&	O
CREAD	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
datalen	long
;	O
i	int
++	O
)	O
if	O
(	O
input_character	function
(	O
data	pointer
[	O
i	int
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
data	pointer
!=	O
buffer	array
)	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
vm_address_t	O
)	O
data	pointer
,	O
datalen	long
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
*	O
hurdio_writer_loop	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
bufp	pointer
;	O
char	O
pending_output	array
[	O
BUFFER_SIZE	int
]	O
;	O
size_t	long
amount	long
;	O
error_t	int
err	int
;	O
int	O
size	pointer
;	O
int	O
npending_output_copy	int
;	O
mach_port_t	O
ioport_copy	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	O
)	O
;	O
writer_thread	int
=	O
mach_thread_self	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
writer_thread	int
!=	O
MACH_PORT_NULL	O
&&	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
||	O
!	O
qsize	function
(	O
outputq	O
)	O
||	O
output_stopped	int
)	O
)	O
pthread_hurd_cond_wait_np	function
(	O
&	O
hurdio_writer_condition	union
,	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
writer_thread	int
==	O
MACH_PORT_NULL	O
)	O
return	O
0	int
;	O
size	pointer
=	O
qsize	function
(	O
outputq	O
)	O
;	O
if	O
(	O
size	pointer
+	O
npending_output	long
>	O
BUFFER_SIZE	int
)	O
size	pointer
=	O
BUFFER_SIZE	int
-	O
npending_output	long
;	O
bufp	pointer
=	O
pending_output	array
+	O
npending_output	long
;	O
npending_output	long
+=	O
size	pointer
;	O
npending_output_copy	int
=	O
npending_output	long
;	O
ioport_copy	O
=	O
ioport	int
;	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
ioport_copy	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
1	int
)	O
;	O
while	O
(	O
size	pointer
--	O
)	O
*	O
bufp	pointer
++	O
=	O
dequeue	function
(	O
outputq	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	O
)	O
;	O
err	int
=	O
io_write	function
(	O
ioport_copy	O
,	O
pending_output	array
,	O
npending_output_copy	int
,	O
-	O
1	int
,	O
&	O
amount	long
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	O
)	O
;	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
ioport_copy	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
err	int
)	O
hurdio_desert_dtr	function
(	O
)	O
;	O
else	O
{	O
if	O
(	O
amount	long
>=	O
npending_output	long
)	O
{	O
npending_output	long
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
outputq	O
->	O
wait	O
)	O
;	O
pthread_cond_broadcast	function
(	O
&	O
select_alert	O
)	O
;	O
}	O
else	O
{	O
npending_output	long
-=	O
amount	long
;	O
memmove	function
(	O
pending_output	array
,	O
pending_output	array
+	O
amount	long
,	O
npending_output	long
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_start_output	function
(	O
)	O
{	O
if	O
(	O
output_stopped	int
&&	O
!	O
(	O
termflags	O
&	O
USER_OUTPUT_SUSP	O
)	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_START	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocstart	function
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_START	int
;	O
}	O
output_stopped	int
=	O
0	int
;	O
}	O
pthread_cond_broadcast	function
(	O
&	O
hurdio_writer_condition	union
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_set_break	function
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_SBRK	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocsbrk	function
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_SBRK	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_clear_break	function
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_CBRK	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tioccbrk	function
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_CBRK	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_abandon_physical_output	function
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_FLUSH	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocflush	function
(	O
ioport	int
,	O
O_WRITE	O
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_FLUSH	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
npending_output	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_suspend_physical_output	function
(	O
)	O
{	O
if	O
(	O
!	O
output_stopped	int
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_STOP	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocstop	function
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_STOP	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
output_stopped	int
=	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_notice_input_flushed	function
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_FLUSH	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocflush	function
(	O
ioport	int
,	O
O_READ	O
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_FLUSH	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
hurdio_pending_output_size	function
(	O
)	O
{	O
int	O
queue_size	int
=	O
0	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_OUTQ	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocoutq	function
(	O
ioport	int
,	O
&	O
queue_size	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_OUTQ	int
;	O
else	O
if	O
(	O
err	int
)	O
queue_size	int
=	O
0	int
;	O
}	O
return	O
queue_size	int
+	O
npending_output	long
;	O
}	O
static	O
error_t	int
hurdio_desert_dtr	function
(	O
)	O
{	O
if	O
(	O
writer_thread	int
!=	O
MACH_PORT_NULL	O
)	O
hurd_thread_cancel	function
(	O
writer_thread	int
)	O
;	O
if	O
(	O
reader_thread	int
!=	O
MACH_PORT_NULL	O
)	O
hurd_thread_cancel	function
(	O
reader_thread	int
)	O
;	O
if	O
(	O
ioport	int
!=	O
MACH_PORT_NULL	O
&&	O
tty_arg	O
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
ioport	int
)	O
;	O
ioport	int
=	O
MACH_PORT_NULL	O
;	O
}	O
assert_dtr	int
=	O
0	int
;	O
report_carrier_off	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_assert_dtr	function
(	O
)	O
{	O
if	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
)	O
{	O
assert_dtr	int
=	O
1	int
;	O
pthread_cond_signal	function
(	O
&	O
hurdio_assert_dtr_condition	union
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_set_bits	function
(	O
struct	O
termios	struct
*	O
state	pointer
)	O
{	O
error_t	int
err	int
;	O
struct	O
termios	struct
ttystat	struct
;	O
struct	O
hurd_termios	struct
{	O
modes_t	O
modes	int
;	O
ccs_t	O
ccs	int
;	O
speeds_t	O
speeds	int
;	O
}	O
*	O
hurd_ttystat	pointer
=	O
(	O
struct	O
hurd_termios	struct
*	O
)	O
&	O
ttystat	struct
;	O
if	O
(	O
!	O
(	O
state	pointer
->	O
c_cflag	int
&	O
CIGNORE	O
)	O
&&	O
ioport	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
tioc_caps	int
&	O
TIOC_CAP_GETA	int
)	O
)	O
return	O
0	int
;	O
err	int
=	O
tioctl_tiocgeta	function
(	O
ioport	int
,	O
hurd_ttystat	pointer
->	O
modes	int
,	O
hurd_ttystat	pointer
->	O
ccs	int
,	O
hurd_ttystat	pointer
->	O
speeds	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
{	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_GETA	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_SETA	int
)	O
{	O
if	O
(	O
state	pointer
->	O
__ispeed	O
)	O
hurd_ttystat	pointer
->	O
speeds	int
[	O
0	int
]	O
=	O
state	pointer
->	O
__ispeed	O
;	O
if	O
(	O
state	pointer
->	O
__ospeed	O
)	O
hurd_ttystat	pointer
->	O
speeds	int
[	O
1	int
]	O
=	O
state	pointer
->	O
__ospeed	O
;	O
cfmakeraw	function
(	O
&	O
ttystat	struct
)	O
;	O
ttystat	struct
.	O
c_cflag	int
=	O
state	pointer
->	O
c_cflag	int
&	O
~	O
HUPCL	int
;	O
err	int
=	O
tioctl_tiocseta	function
(	O
ioport	int
,	O
hurd_ttystat	pointer
->	O
modes	int
,	O
hurd_ttystat	pointer
->	O
ccs	int
,	O
hurd_ttystat	pointer
->	O
speeds	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_SETA	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
err	int
=	O
tioctl_tiocgeta	function
(	O
ioport	int
,	O
hurd_ttystat	pointer
->	O
modes	int
,	O
hurd_ttystat	pointer
->	O
ccs	int
,	O
hurd_ttystat	pointer
->	O
speeds	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_GETA	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
*	O
state	pointer
=	O
ttystat	struct
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_mdmctl	function
(	O
int	O
how	int
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
int	O
oldbits	int
,	O
newbits	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_MODS	int
)	O
{	O
if	O
(	O
(	O
how	int
==	O
MDMCTL_BIS	O
)	O
||	O
(	O
how	int
==	O
MDMCTL_BIC	O
)	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_MODG	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocmodg	function
(	O
ioport	int
,	O
&	O
oldbits	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
{	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_MODG	int
;	O
return	O
EOPNOTSUPP	int
;	O
}	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
else	O
return	O
EOPNOTSUPP	int
;	O
}	O
if	O
(	O
how	int
==	O
MDMCTL_BIS	O
)	O
newbits	int
=	O
(	O
oldbits	int
|	O
bits	int
)	O
;	O
else	O
if	O
(	O
how	int
==	O
MDMCTL_BIC	O
)	O
newbits	int
=	O
(	O
oldbits	int
&=	O
~	O
bits	int
)	O
;	O
else	O
newbits	int
=	O
bits	int
;	O
err	int
=	O
tioctl_tiocmods	function
(	O
ioport	int
,	O
newbits	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_MODS	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
hurdio_mdmstate	function
(	O
)	O
{	O
int	O
oldbits	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_MODG	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocmodg	function
(	O
ioport	int
,	O
&	O
oldbits	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_MODG	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
const	O
struct	O
bottomhalf	O
hurdio_bottom	struct
=	O
{	O
TERM_ON_HURDIO	O
,	O
hurdio_init	function
,	O
hurdio_fini	function
,	O
hurdio_gwinsz	function
,	O
hurdio_start_output	function
,	O
hurdio_set_break	function
,	O
hurdio_clear_break	function
,	O
hurdio_abandon_physical_output	function
,	O
hurdio_suspend_physical_output	function
,	O
hurdio_pending_output_size	function
,	O
hurdio_notice_input_flushed	function
,	O
hurdio_assert_dtr	function
,	O
hurdio_desert_dtr	function
,	O
hurdio_set_bits	function
,	O
hurdio_mdmctl	function
,	O
hurdio_mdmstate	function
,	O
}	O
;	O