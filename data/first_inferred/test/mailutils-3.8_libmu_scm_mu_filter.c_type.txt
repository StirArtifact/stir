static	O
void	O
argv_free	function
(	O
void	O
*	O
p	*
)	O
{	O
mu_argv_free	function
(	O
(	O
char	O
*	O
*	O
)	O
p	*
)	O
;	O
}	O
static	O
SCM	function
make_filter_port	function
(	O
SCM	function
port	int
,	O
SCM	function
name	*
,	O
SCM	function
args	*
,	O
int	O
filter_mode	int
,	O
char	O
const	O
*	O
func_name	*
)	O
{	O
char	O
*	O
fltname	*
;	O
mu_stream_t	*
filter	*
;	O
mu_stream_t	*
instr	*
;	O
size_t	long
argc	long
=	O
0	int
;	O
char	O
*	O
*	O
argv	*
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
flags	int
=	O
0	int
;	O
char	O
*	O
port_mode	*
;	O
SCM_ASSERT	function
(	O
scm_port_p	O
(	O
port	int
)	O
,	O
port	O
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
name	*
)	O
,	O
name	*
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_VALIDATE_REST_ARGUMENT	function
(	O
args	*
)	O
;	O
port_mode	*
=	O
scm_to_locale_string	function
(	O
scm_port_mode	O
(	O
port	*
)	O
)	O
;	O
if	O
(	O
strchr	function
(	O
port_mode	*
,	O
'r'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_READ	int
;	O
if	O
(	O
strchr	function
(	O
port_mode	*
,	O
'w'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_WRITE	int
;	O
free	function
(	O
port_mode	*
)	O
;	O
if	O
(	O
!	O
flags	int
||	O
(	O
(	O
flags	int
&	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
==	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
)	O
scm_out_of_range	function
(	O
FUNC_NAME	O
,	O
port	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
fltname	*
=	O
scm_to_locale_string	function
(	O
name	*
)	O
;	O
scm_dynwind_free	function
(	O
fltname	*
)	O
;	O
rc	int
=	O
mu_scm_port_stream_create	function
(	O
&	O
instr	*
,	O
port	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to convert transport port ~A"	*
,	O
scm_list_1	function
(	O
port	*
)	O
)	O
;	O
}	O
if	O
(	O
!	O
scm_is_null	function
(	O
args	*
)	O
)	O
{	O
size_t	long
n	long
;	O
argc	int
=	O
scm_to_size_t	function
(	O
scm_length	function
(	O
args	*
)	O
)	O
+	O
1	int
;	O
argv	*
=	O
calloc	function
(	O
argc	long
+	O
1	int
,	O
sizeof	O
(	O
argv	*
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	*
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
ENOMEM	int
,	O
"Cannot allocate memory"	*
,	O
SCM_BOOL_F	O
)	O
;	O
argv	*
[	O
0	int
]	O
=	O
strdup	function
(	O
fltname	*
)	O
;	O
n	long
=	O
1	int
;	O
for	O
(	O
;	O
!	O
scm_is_null	function
(	O
args	*
)	O
;	O
args	*
=	O
SCM_CDR	function
(	O
args	*
)	O
)	O
{	O
SCM	function
arg	O
=	O
SCM_CAR	function
(	O
args	*
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
arg	*
)	O
,	O
arg	*
,	O
SCM_ARGn	O
,	O
FUNC_NAME	O
)	O
;	O
argv	*
[	O
n	int
]	O
=	O
scm_to_locale_string	function
(	O
arg	*
)	O
;	O
n	int
++	O
;	O
}	O
argv	*
[	O
n	int
]	O
=	O
NULL	O
;	O
scm_dynwind_unwind_handler	function
(	O
argv_free	*
,	O
argv	*
,	O
SCM_F_WIND_EXPLICITLY	*
)	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
filter	*
,	O
instr	*
,	O
fltname	*
,	O
argc	long
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	*
,	O
filter_mode	int
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to create filter ~A"	*
,	O
scm_list_1	function
(	O
name	*
)	O
)	O
;	O
}	O
scm_dynwind_end	function
(	O
)	O
;	O
return	O
mu_port_make_from_stream	function
(	O
filter	*
,	O
flags	int
==	O
MU_STREAM_READ	int
?	O
SCM_RDNG	int
:	O
SCM_WRTNG	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_encoder_port	O
,	O
"mu-encoder-port"	*
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	O
,	O
SCM	function
name	*
,	O
SCM	function
args	*
)	O
,	O
"Create encoding port using Mailutils filter @var{name} with optional arguments\n"	*
"@var{args}. The @var{port} argument must be a port opened either for\n"	*
"writing or for reading, but not both. The returned port will have the same\n"	*
"mode as @var{port}."	*
"\n\n"	*
"If @var{port} is open for reading, data will be read from it, passed through the\n"	*
"filter and returned. If it is open for writing, data written to the returned\n"	*
"port will be passed through filter and its output will be written to @var{port}.\n"	*
)	O
{	O
return	O
make_filter_port	function
(	O
port	*
,	O
name	*
,	O
args	*
,	O
MU_FILTER_ENCODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_decoder_port	*
,	O
"mu-decoder-port"	*
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	O
,	O
SCM	function
name	*
,	O
SCM	function
args	*
)	O
,	O
"Create a decoding port using Mailutils filter @var{name} with optional arguments\n"	*
"@var{args}. The @var{port} argument must be a port opened either for\n"	*
"writing or for reading, but not both. The returned port will have the same\n"	*
"mode as @var{port}."	*
"\n\n"	*
"If @var{port} is open for reading, data will be read from it, passed through the\n"	*
"filter and returned. If it is open for writing, data written to the returned\n"	*
"port will be passed through filter and its output will be written to @var{port}.\n"	*
)	O
{	O
return	O
make_filter_port	function
(	O
port	*
,	O
name	*
,	O
args	*
,	O
MU_FILTER_DECODE	O
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_decode	*
,	O
"mu-header-decode"	*
,	O
1	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	function
hdr	*
,	O
SCM	function
charset	*
)	O
,	O
"Decode the header value @var{hdr}, encoded as per RFC 2047.\n"	*
"Optional @var{charset} defaults to @samp{utf-8}.\n"	*
)	O
{	O
char	O
*	O
c_hdr	*
,	O
*	O
c_charset	*
,	O
*	O
c_res	*
;	O
int	O
rc	int
;	O
SCM	function
res	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	*
)	O
,	O
hdr	*
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	*
)	O
)	O
c_charset	*
=	O
"utf-8"	*
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	*
)	O
,	O
charset	*
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	*
=	O
scm_to_locale_string	function
(	O
charset	*
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	*
)	O
;	O
}	O
c_hdr	*
=	O
scm_to_locale_string	function
(	O
hdr	*
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	*
)	O
;	O
rc	int
=	O
mu_rfc2047_decode	function
(	O
c_charset	*
,	O
c_hdr	*
,	O
&	O
c_res	*
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't convert header value"	*
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	*
=	O
scm_from_locale_string	function
(	O
c_res	*
)	O
;	O
free	function
(	O
c_res	*
)	O
;	O
return	O
res	*
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_encode	O
,	O
"mu-header-encode"	*
,	O
1	int
,	O
2	int
,	O
0	int
,	O
(	O
SCM	function
hdr	*
,	O
SCM	function
encoding	*
,	O
SCM	function
charset	*
)	O
,	O
"Encode the string @var{hdr} as per RFC 2047.\n"	*
"Both @var{encoding} and @var{charset} are optional.\n"	*
"Allowed values for @var{encoding} are @samp{base64} and @samp{quoted-printable}.\n"	*
"Default is selected depending on number of printable characters in @var{hdr}.\n"	*
"Optional @var{charset} defaults to @samp{utf-8}.\n"	*
)	O
{	O
char	O
*	O
c_hdr	*
,	O
*	O
c_charset	*
,	O
*	O
c_encoding	*
,	O
*	O
c_res	*
;	O
int	O
rc	int
;	O
SCM	function
res	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	*
)	O
,	O
hdr	*
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
encoding	*
)	O
)	O
c_encoding	*
=	O
NULL	O
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
encoding	*
)	O
,	O
encoding	*
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_encoding	*
=	O
scm_to_locale_string	function
(	O
encoding	*
)	O
;	O
scm_dynwind_free	function
(	O
c_encoding	*
)	O
;	O
}	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	*
)	O
)	O
c_charset	*
=	O
"utf-8"	*
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	*
)	O
,	O
charset	*
,	O
SCM_ARG3	*
,	O
FUNC_NAME	O
)	O
;	O
c_charset	*
=	O
scm_to_locale_string	function
(	O
charset	*
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	*
)	O
;	O
}	O
c_hdr	*
=	O
scm_to_locale_string	function
(	O
hdr	*
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	*
)	O
;	O
if	O
(	O
!	O
c_encoding	*
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
c_hdr	*
)	O
;	O
size_t	long
i	long
,	O
enc	*
;	O
enc	*
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
if	O
(	O
!	O
mu_isprint	O
(	O
c_hdr	*
[	O
i	int
]	O
)	O
)	O
enc	*
++	O
;	O
c_encoding	*
=	O
(	O
enc	*
>	O
len	long
/	O
2	int
)	O
?	O
"base64"	int
:	O
"quoted-printable"	*
;	O
}	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
c_charset	*
,	O
c_encoding	*
,	O
c_hdr	*
,	O
&	O
c_res	*
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't encode header value"	*
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	*
=	O
scm_from_locale_string	function
(	O
c_res	*
)	O
;	O
free	function
(	O
c_res	*
)	O
;	O
return	O
res	*
;	O
}	O
void	O
mu_scm_filter_init	function
(	O
void	O
)	O
{	O
}	O