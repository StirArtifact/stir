static	O
char	O
*	O
dbdir	pointer
;	O
static	O
size_t	long
compare_count	long
;	O
static	O
int	O
sort_index	int
;	O
static	O
int	O
trim_ws	int
;	O
static	O
int	O
show_dictorg_entries	int
;	O
static	O
int	O
is_alnumspace	function
(	O
unsigned	O
c	int
)	O
{	O
return	O
utf8_wc_is_alnum	function
(	O
c	int
)	O
||	O
utf8_wc_is_space	function
(	O
c	int
)	O
;	O
}	O
static	O
inline	O
int	O
headword_compare	function
(	O
char	O
const	O
*	O
a	pointer
,	O
char	O
const	O
*	O
b	pointer
,	O
struct	O
dictdb	struct
*	O
db	pointer
)	O
{	O
return	O
utf8_compare	function
(	O
a	pointer
,	O
b	pointer
,	O
db	pointer
->	O
flag_casesensitive	int
?	O
case_sensitive	int
:	O
case_insensitive	int
,	O
0	int
,	O
db	pointer
->	O
flag_allchars	int
?	O
NULL	O
:	O
is_alnumspace	function
)	O
;	O
}	O
static	O
inline	O
int	O
headword_compare_allchars	function
(	O
char	O
const	O
*	O
a	pointer
,	O
char	O
const	O
*	O
b	pointer
,	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
size_t	long
len	int
)	O
{	O
return	O
utf8_compare	function
(	O
a	pointer
,	O
b	pointer
,	O
db	pointer
->	O
flag_casesensitive	int
?	O
case_sensitive	int
:	O
case_insensitive	int
,	O
len	int
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
compare_index_entry	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
const	O
struct	O
index_entry	struct
*	O
epa	pointer
=	O
a	pointer
;	O
const	O
struct	O
index_entry	struct
*	O
epb	pointer
=	O
b	pointer
;	O
compare_count	long
++	O
;	O
return	O
headword_compare	function
(	O
epa	pointer
->	O
word	pointer
,	O
epb	pointer
->	O
word	pointer
,	O
(	O
struct	O
dictdb	struct
*	O
)	O
closure	pointer
)	O
;	O
}	O
static	O
int	O
get_db_flag	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
;	O
static	O
int	O
register_strategies	function
(	O
void	O
)	O
;	O
static	O
struct	O
dico_option	struct
init_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
dbdir	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
dbdir	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
sort	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
sort_index	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
trim	O
-	O
ws	pointer
)	O
,	O
dico_opt_bool	int
,	O
&	O
trim_ws	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
show	O
-	O
dictorg	O
-	O
entries	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
show_dictorg_entries	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
mod_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
dico_parseopt	function
(	O
init_option	array
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
dbdir	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
dbdir	pointer
,	O
&	O
st	struct
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"mod_init: cannot stat `%s'"	pointer
)	O
,	O
dbdir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: `%s' is not a directory"	pointer
)	O
,	O
dbdir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
access	function
(	O
dbdir	pointer
,	O
R_OK	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: `%s' is not readable"	pointer
)	O
,	O
dbdir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
register_strategies	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
dealloc_index_entry	function
(	O
struct	O
index_entry	struct
*	O
ent	pointer
)	O
{	O
free	function
(	O
ent	pointer
->	O
word	pointer
)	O
;	O
free	function
(	O
ent	pointer
->	O
orig	pointer
)	O
;	O
}	O
static	O
void	O
free_db	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
)	O
{	O
size_t	long
i	long
;	O
dico_stream_close	function
(	O
db	pointer
->	O
stream	pointer
)	O
;	O
dico_stream_destroy	function
(	O
&	O
db	pointer
->	O
stream	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	pointer
->	O
numwords	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
.	O
word	pointer
)	O
break	O
;	O
dealloc_index_entry	function
(	O
&	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
)	O
;	O
}	O
if	O
(	O
db	pointer
->	O
suf_index	pointer
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	pointer
->	O
numwords	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
db	pointer
->	O
suf_index	pointer
[	O
i	long
]	O
.	O
word	pointer
)	O
break	O
;	O
free	function
(	O
db	pointer
->	O
suf_index	pointer
[	O
i	long
]	O
.	O
word	pointer
)	O
;	O
}	O
free	function
(	O
db	pointer
->	O
suf_index	pointer
)	O
;	O
}	O
free	function
(	O
db	pointer
->	O
index	pointer
)	O
;	O
free	function
(	O
db	pointer
->	O
basename	pointer
)	O
;	O
free	function
(	O
db	pointer
)	O
;	O
}	O
static	O
char	O
*	O
mkname	function
(	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
suf	pointer
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
fname	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
suf	pointer
)	O
+	O
1	int
;	O
char	O
*	O
res	pointer
=	O
malloc	function
(	O
len	int
)	O
;	O
if	O
(	O
res	pointer
)	O
{	O
strcpy	function
(	O
res	pointer
,	O
fname	pointer
)	O
;	O
strcat	function
(	O
res	pointer
,	O
"."	pointer
)	O
;	O
strcat	function
(	O
res	pointer
,	O
suf	pointer
)	O
;	O
}	O
return	O
res	pointer
;	O
}	O
static	O
int	O
b64_decode	function
(	O
const	O
char	O
*	O
val	pointer
,	O
size_t	long
len	int
,	O
size_t	long
*	O
presult	pointer
)	O
{	O
size_t	long
v	union
=	O
0	int
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	int
;	O
i	long
++	O
)	O
{	O
int	O
x	int
=	O
dico_base64_input	function
(	O
val	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
x	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
v	union
<<=	O
6	int
;	O
v	union
|=	O
x	int
;	O
}	O
if	O
(	O
i	long
<	O
len	int
)	O
v	union
<<=	O
(	O
len	int
-	O
1	int
)	O
*	O
6	int
;	O
*	O
presult	pointer
=	O
v	union
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_index_entry	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
line	long
,	O
dico_list_t	pointer
list	array
,	O
char	O
*	O
buf	pointer
,	O
int	O
tws	int
)	O
{	O
struct	O
utf8_iterator	struct
itr	pointer
;	O
struct	O
index_entry	struct
idx	struct
,	O
*	O
ep	pointer
;	O
int	O
nfield	int
=	O
0	int
;	O
int	O
rc	int
;	O
memset	function
(	O
&	O
itr	pointer
,	O
0	int
,	O
sizeof	O
(	O
itr	pointer
)	O
)	O
;	O
memset	function
(	O
&	O
idx	struct
,	O
0	int
,	O
sizeof	O
(	O
idx	struct
)	O
)	O
;	O
utf8_iter_first	function
(	O
&	O
itr	pointer
,	O
buf	pointer
)	O
;	O
rc	int
=	O
0	int
;	O
for	O
(	O
nfield	int
=	O
0	int
;	O
nfield	int
<	O
4	int
;	O
nfield	int
++	O
)	O
{	O
char	O
const	O
*	O
start	pointer
;	O
char	O
const	O
*	O
end	int
;	O
size_t	long
len	int
;	O
if	O
(	O
nfield	int
)	O
{	O
for	O
(	O
;	O
!	O
utf8_iter_end_p	function
(	O
&	O
itr	pointer
)	O
&&	O
utf8_iter_isascii	O
(	O
itr	pointer
)	O
&&	O
ISWS	O
(	O
*	O
itr	pointer
.	O
curptr	pointer
)	O
;	O
utf8_iter_next	function
(	O
&	O
itr	pointer
)	O
)	O
;	O
}	O
if	O
(	O
utf8_iter_end_p	function
(	O
&	O
itr	pointer
)	O
)	O
break	O
;	O
start	pointer
=	O
itr	pointer
.	O
curptr	pointer
;	O
for	O
(	O
;	O
!	O
utf8_iter_end_p	function
(	O
&	O
itr	pointer
)	O
&&	O
!	O
(	O
utf8_iter_isascii	O
(	O
itr	pointer
)	O
&&	O
*	O
itr	pointer
.	O
curptr	pointer
==	O
'\t'	O
)	O
;	O
utf8_iter_next	function
(	O
&	O
itr	pointer
)	O
)	O
;	O
end	int
=	O
itr	pointer
.	O
curptr	pointer
;	O
len	int
=	O
end	int
-	O
start	pointer
;	O
if	O
(	O
nfield	int
==	O
0	int
)	O
{	O
if	O
(	O
tws	int
)	O
{	O
while	O
(	O
len	int
>	O
0	int
&&	O
start	pointer
[	O
len	int
-	O
1	int
]	O
==	O
' '	O
)	O
--	O
len	int
;	O
}	O
idx	struct
.	O
word	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
idx	struct
.	O
word	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
memcpy	function
(	O
idx	struct
.	O
word	pointer
,	O
start	pointer
,	O
len	int
)	O
;	O
idx	struct
.	O
word	pointer
[	O
len	int
]	O
=	O
0	int
;	O
idx	struct
.	O
length	long
=	O
len	int
;	O
idx	struct
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
idx	struct
.	O
word	pointer
)	O
;	O
}	O
else	O
if	O
(	O
nfield	int
==	O
3	int
)	O
{	O
idx	struct
.	O
orig	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
idx	struct
.	O
orig	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
memcpy	function
(	O
idx	struct
.	O
orig	pointer
,	O
start	pointer
,	O
len	int
)	O
;	O
idx	struct
.	O
orig	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
size_t	long
n	long
;	O
if	O
(	O
b64_decode	function
(	O
start	pointer
,	O
len	int
,	O
&	O
n	long
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%lu: invalid base64 value: `%.*s'"	pointer
)	O
,	O
filename	pointer
,	O
(	O
unsigned	O
long	O
)	O
line	long
,	O
(	O
int	O
)	O
len	int
,	O
start	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
nfield	int
==	O
1	int
)	O
idx	struct
.	O
offset	long
=	O
n	long
;	O
else	O
idx	struct
.	O
size	long
=	O
n	long
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
utf8_iter_end_p	function
(	O
&	O
itr	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%lu: malformed entry"	pointer
)	O
,	O
filename	pointer
,	O
(	O
unsigned	O
long	O
)	O
line	long
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
ep	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
ep	pointer
)	O
)	O
;	O
if	O
(	O
!	O
ep	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
rc	int
)	O
free	function
(	O
idx	struct
.	O
word	pointer
)	O
;	O
else	O
{	O
*	O
ep	pointer
=	O
idx	struct
;	O
dico_list_append	function
(	O
list	array
,	O
ep	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
free_index_entry	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
index_entry	struct
*	O
ep	pointer
=	O
item	pointer
;	O
dealloc_index_entry	function
(	O
ep	pointer
)	O
;	O
free	function
(	O
ep	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
read_index	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
idxname	pointer
,	O
int	O
tws	int
)	O
{	O
struct	O
stat	struct
st	struct
;	O
int	O
rc	int
;	O
dico_list_t	pointer
list	array
;	O
dico_stream_t	pointer
stream	pointer
;	O
if	O
(	O
stat	struct
(	O
idxname	pointer
,	O
&	O
st	struct
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"open_index: cannot stat `%s'"	pointer
)	O
,	O
idxname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"open_index: `%s' is not a regular file"	pointer
)	O
,	O
idxname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
stream	pointer
=	O
dico_mapfile_stream_create	function
(	O
idxname	pointer
,	O
DICO_STREAM_READ	int
)	O
;	O
if	O
(	O
!	O
stream	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create stream `%s'"	pointer
)	O
,	O
idxname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
dico_stream_open	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open stream `%s': %s"	pointer
)	O
,	O
idxname	pointer
,	O
dico_stream_strerror	function
(	O
stream	pointer
,	O
rc	int
)	O
)	O
;	O
dico_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
}	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
list	array
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
dico_iterator_t	pointer
itr	pointer
;	O
size_t	long
i	long
;	O
struct	O
index_entry	struct
*	O
ep	pointer
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
size_t	long
rdsize	long
;	O
rc	int
=	O
0	int
;	O
i	long
=	O
0	int
;	O
while	O
(	O
!	O
dico_stream_getline	function
(	O
stream	pointer
,	O
&	O
buf	pointer
,	O
&	O
bufsize	long
,	O
&	O
rdsize	long
)	O
)	O
{	O
i	long
++	O
;	O
dico_trim_nl	function
(	O
buf	pointer
)	O
;	O
rc	int
=	O
parse_index_entry	function
(	O
idxname	pointer
,	O
i	long
,	O
list	array
,	O
buf	pointer
,	O
tws	int
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_list_set_free_item	function
(	O
list	array
,	O
free_index_entry	function
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
db	pointer
->	O
numwords	long
=	O
dico_list_count	function
(	O
list	array
)	O
;	O
db	pointer
->	O
index	pointer
=	O
calloc	function
(	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
)	O
;	O
itr	pointer
=	O
dico_list_iterator	function
(	O
list	array
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
ep	pointer
=	O
dico_iterator_first	function
(	O
itr	pointer
)	O
;	O
ep	pointer
;	O
i	long
++	O
,	O
ep	pointer
=	O
dico_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
=	O
*	O
ep	pointer
;	O
free	function
(	O
ep	pointer
)	O
;	O
}	O
dico_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
dico_list_destroy	function
(	O
&	O
list	array
)	O
;	O
}	O
dico_stream_close	function
(	O
stream	pointer
)	O
;	O
dico_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
open_index	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
int	O
tws	int
)	O
{	O
char	O
*	O
idxname	pointer
=	O
mkname	function
(	O
db	pointer
->	O
basename	pointer
,	O
"index"	pointer
)	O
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
idxname	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
read_index	function
(	O
db	pointer
,	O
idxname	pointer
,	O
tws	int
)	O
;	O
free	function
(	O
idxname	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
mod_free_db	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
(	O
struct	O
dictdb	struct
*	O
)	O
hp	pointer
;	O
free_db	function
(	O
db	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
open_stream	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
static	O
char	O
*	O
suff	array
[	O
]	O
=	O
{	O
"dict.dz"	pointer
,	O
"dict"	pointer
}	O
;	O
int	O
i	long
;	O
int	O
rc	int
;	O
dico_stream_t	pointer
str	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
suff	array
)	O
;	O
i	long
++	O
)	O
{	O
name	pointer
=	O
mkname	function
(	O
db	pointer
->	O
basename	pointer
,	O
suff	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
access	function
(	O
name	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
str	pointer
=	O
dict_stream_create	function
(	O
name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create stream `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
rc	int
=	O
dico_stream_open	function
(	O
str	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open stream `%s': %s"	pointer
)	O
,	O
name	pointer
,	O
dico_stream_strerror	function
(	O
str	pointer
,	O
rc	int
)	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
free	function
(	O
name	pointer
)	O
;	O
db	pointer
->	O
stream	pointer
=	O
str	pointer
;	O
return	O
0	int
;	O
}	O
}	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open stream for dictionary `%s'"	pointer
)	O
,	O
db	pointer
->	O
basename	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
dico_handle_t	pointer
mod_init_db	function
(	O
const	O
char	O
*	O
dbname	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
;	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
int	O
sort_option	int
=	O
sort_index	int
;	O
int	O
trimws_option	int
=	O
trim_ws	int
;	O
int	O
show_dictorg_option	int
=	O
show_dictorg_entries	int
;	O
struct	O
dico_option	struct
option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
sort	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
sort_option	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
database	pointer
)	O
,	O
dico_opt_const_string	int
,	O
&	O
filename	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
trim	O
-	O
ws	pointer
)	O
,	O
dico_opt_bool	int
,	O
&	O
trimws_option	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
show	O
-	O
dictorg	O
-	O
entries	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
show_dictorg_option	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	function
(	O
option	array
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
filename	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init_db(%s): database name not given"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
filename	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
if	O
(	O
dbdir	pointer
)	O
{	O
filename	pointer
=	O
dico_full_file_name	function
(	O
dbdir	pointer
,	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init_db: `%s' is not an absolute file name"	pointer
)	O
,	O
filename	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
filename	pointer
=	O
strdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
filename	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
db	pointer
)	O
)	O
;	O
if	O
(	O
!	O
db	pointer
)	O
{	O
free	function
(	O
filename	pointer
)	O
;	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
->	O
dbname	pointer
=	O
dbname	pointer
;	O
db	pointer
->	O
basename	pointer
=	O
filename	pointer
;	O
db	pointer
->	O
show_dictorg_entries	int
=	O
show_dictorg_option	int
;	O
db	pointer
->	O
flag_allchars	int
=	O
1	int
;	O
if	O
(	O
open_index	function
(	O
db	pointer
,	O
trimws_option	int
)	O
)	O
{	O
free_db	function
(	O
db	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
open_stream	function
(	O
db	pointer
)	O
)	O
{	O
free_db	function
(	O
db	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
->	O
flag_allchars	int
=	O
get_db_flag	function
(	O
db	pointer
,	O
DICTORG_FLAG_ALLCHARS	O
)	O
;	O
db	pointer
->	O
flag_casesensitive	int
=	O
get_db_flag	function
(	O
db	pointer
,	O
DICTORG_FLAG_CASESENSITIVE	O
)	O
;	O
db	pointer
->	O
flag_utf8	int
=	O
get_db_flag	function
(	O
db	pointer
,	O
DICTORG_FLAG_UTF8	O
)	O
;	O
db	pointer
->	O
flag_8bit	int
=	O
get_db_flag	function
(	O
db	pointer
,	O
DICTORG_FLAG_8BIT_NEW	O
)	O
;	O
if	O
(	O
get_db_flag	function
(	O
db	pointer
,	O
DICTORG_FLAG_8BIT_OLD	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init_db(%s): index files in old 8-bit format are not supported"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
free_db	function
(	O
db	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
sort_option	int
)	O
{	O
dico_sort	function
(	O
db	pointer
->	O
index	pointer
,	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare_index_entry	function
,	O
db	pointer
)	O
;	O
}	O
return	O
(	O
dico_handle_t	pointer
)	O
db	pointer
;	O
}	O
static	O
void	O
revert_word	function
(	O
char	O
*	O
dst	pointer
,	O
const	O
char	O
*	O
src	pointer
,	O
size_t	long
len	int
)	O
{	O
struct	O
utf8_iterator	struct
itr	pointer
;	O
char	O
*	O
p	pointer
=	O
dst	pointer
+	O
len	int
;	O
*	O
p	pointer
=	O
0	int
;	O
for	O
(	O
utf8_iter_init	function
(	O
&	O
itr	pointer
,	O
(	O
char	O
*	O
)	O
src	pointer
,	O
len	int
)	O
;	O
!	O
utf8_iter_end_p	function
(	O
&	O
itr	pointer
)	O
;	O
utf8_iter_next	function
(	O
&	O
itr	pointer
)	O
)	O
{	O
p	pointer
-=	O
itr	pointer
.	O
curwidth	int
;	O
if	O
(	O
p	pointer
<	O
dst	pointer
)	O
break	O
;	O
memcpy	function
(	O
p	pointer
,	O
itr	pointer
.	O
curptr	pointer
,	O
itr	pointer
.	O
curwidth	int
)	O
;	O
}	O
}	O
static	O
int	O
compare_rev_entry	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
struct	O
rev_entry	struct
const	O
*	O
epa	pointer
=	O
a	pointer
;	O
struct	O
rev_entry	struct
const	O
*	O
epb	pointer
=	O
b	pointer
;	O
return	O
headword_compare_allchars	function
(	O
epa	pointer
->	O
word	pointer
,	O
epb	pointer
->	O
word	pointer
,	O
closure	pointer
,	O
0	int
)	O
;	O
}	O
static	O
int	O
init_suffix_index	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
)	O
{	O
if	O
(	O
!	O
db	pointer
->	O
suf_index	pointer
)	O
{	O
size_t	long
i	long
;	O
db	pointer
->	O
suf_index	pointer
=	O
calloc	function
(	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
suf_index	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
db	pointer
->	O
suf_index	pointer
)	O
return	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	pointer
->	O
numwords	long
;	O
i	long
++	O
)	O
{	O
char	O
*	O
p	pointer
=	O
malloc	function
(	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
while	O
(	O
i	long
>	O
0	int
)	O
free	function
(	O
db	pointer
->	O
suf_index	pointer
[	O
--	O
i	long
]	O
.	O
word	pointer
)	O
;	O
free	function
(	O
db	pointer
->	O
suf_index	pointer
)	O
;	O
return	O
1	int
;	O
}	O
revert_word	function
(	O
p	pointer
,	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
.	O
word	pointer
,	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
.	O
length	long
)	O
;	O
db	pointer
->	O
suf_index	pointer
[	O
i	long
]	O
.	O
word	pointer
=	O
p	pointer
;	O
db	pointer
->	O
suf_index	pointer
[	O
i	long
]	O
.	O
ptr	pointer
=	O
&	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
;	O
}	O
dico_sort	function
(	O
db	pointer
->	O
suf_index	pointer
,	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
suf_index	pointer
[	O
0	int
]	O
)	O
,	O
compare_rev_entry	function
,	O
db	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
exact_match	function
(	O
struct	O
dictdb	struct
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	pointer
*	O
)	O
;	O
static	O
int	O
prefix_match	function
(	O
struct	O
dictdb	struct
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	pointer
*	O
)	O
;	O
static	O
int	O
suffix_match	function
(	O
struct	O
dictdb	struct
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	pointer
*	O
)	O
;	O
static	O
struct	O
strategy_def	struct
strat_tab	array
[	O
]	O
=	O
{	O
{	O
{	O
"exact"	pointer
,	O
"Match words exactly"	pointer
}	O
,	O
exact_match	function
}	O
,	O
{	O
{	O
"prefix"	pointer
,	O
"Match word prefixes"	pointer
}	O
,	O
prefix_match	function
}	O
,	O
{	O
{	O
"suffix"	pointer
,	O
"Match word suffixes"	pointer
}	O
,	O
suffix_match	function
}	O
}	O
;	O
static	O
entry_match_t	pointer
find_matcher	function
(	O
const	O
char	O
*	O
strat	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array
)	O
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
strat	pointer
,	O
strat_tab	array
[	O
i	long
]	O
.	O
strat	pointer
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
strat_tab	array
[	O
i	long
]	O
.	O
match	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
register_strategies	function
(	O
void	O
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array
)	O
;	O
i	long
++	O
)	O
dico_strategy_add	function
(	O
&	O
strat_tab	array
[	O
i	long
]	O
.	O
strat	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
compare_entry_ptr	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
const	O
struct	O
index_entry	struct
*	O
epa	pointer
=	O
*	O
(	O
const	O
struct	O
index_entry	struct
*	O
*	O
)	O
a	pointer
;	O
const	O
struct	O
index_entry	struct
*	O
epb	pointer
=	O
*	O
(	O
const	O
struct	O
index_entry	struct
*	O
*	O
)	O
b	pointer
;	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
closure	pointer
;	O
return	O
headword_compare_allchars	function
(	O
epa	pointer
->	O
word	pointer
,	O
epb	pointer
->	O
word	pointer
,	O
db	pointer
,	O
0	int
)	O
;	O
}	O
static	O
int	O
uniq_comp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
const	O
struct	O
index_entry	struct
*	O
epa	pointer
=	O
a	pointer
;	O
const	O
struct	O
index_entry	struct
*	O
epb	pointer
=	O
b	pointer
;	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
closure	pointer
;	O
return	O
headword_compare	function
(	O
epa	pointer
->	O
orig	pointer
?	O
epa	pointer
->	O
orig	pointer
:	O
epa	pointer
->	O
word	pointer
,	O
epb	pointer
->	O
orig	pointer
?	O
epb	pointer
->	O
orig	pointer
:	O
epb	pointer
->	O
word	pointer
,	O
db	pointer
)	O
;	O
}	O
static	O
int	O
common_match	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
int	O
(	O
*	O
compare	pointer
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
int	O
unique	int
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
struct	O
index_entry	struct
x	int
,	O
*	O
ep	pointer
;	O
x	int
.	O
word	pointer
=	O
(	O
char	O
*	O
)	O
word	pointer
;	O
x	int
.	O
length	long
=	O
strlen	function
(	O
word	pointer
)	O
;	O
x	int
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
word	pointer
)	O
;	O
compare_count	long
=	O
0	int
;	O
ep	pointer
=	O
dico_bsearch	function
(	O
&	O
x	int
,	O
db	pointer
->	O
index	pointer
,	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare	pointer
,	O
db	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
res	pointer
->	O
type	enum
=	O
result_match	int
;	O
res	pointer
->	O
db	pointer
=	O
db	pointer
;	O
res	pointer
->	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
res	pointer
->	O
list	array
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
res	pointer
->	O
itr	pointer
=	O
NULL	O
;	O
if	O
(	O
unique	int
)	O
{	O
dico_list_set_comparator	function
(	O
res	pointer
->	O
list	array
,	O
uniq_comp	function
,	O
db	pointer
)	O
;	O
dico_list_set_flags	function
(	O
res	pointer
->	O
list	array
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
}	O
for	O
(	O
;	O
ep	pointer
<	O
db	pointer
->	O
index	pointer
+	O
db	pointer
->	O
numwords	long
&&	O
compare	pointer
(	O
&	O
x	int
,	O
ep	pointer
,	O
db	pointer
)	O
==	O
0	int
;	O
ep	pointer
++	O
)	O
if	O
(	O
!	O
RESERVED_WORD	O
(	O
db	pointer
,	O
ep	pointer
->	O
word	pointer
)	O
)	O
dico_list_append	function
(	O
res	pointer
->	O
list	array
,	O
ep	pointer
)	O
;	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
exact_match	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
return	O
common_match	function
(	O
db	pointer
,	O
word	pointer
,	O
compare_index_entry	function
,	O
0	int
,	O
res	pointer
)	O
;	O
}	O
static	O
int	O
compare_prefix	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
const	O
struct	O
index_entry	struct
*	O
pkey	pointer
=	O
a	pointer
;	O
const	O
struct	O
index_entry	struct
*	O
pelt	pointer
=	O
b	pointer
;	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
closure	pointer
;	O
size_t	long
wordlen	long
=	O
pkey	pointer
->	O
wordlen	long
;	O
compare_count	long
++	O
;	O
if	O
(	O
pelt	pointer
->	O
wordlen	long
<	O
wordlen	long
)	O
return	O
-	O
1	int
;	O
return	O
headword_compare_allchars	function
(	O
pkey	pointer
->	O
word	pointer
,	O
pelt	pointer
->	O
word	pointer
,	O
db	pointer
,	O
wordlen	long
)	O
;	O
}	O
static	O
int	O
prefix_match	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
return	O
common_match	function
(	O
db	pointer
,	O
word	pointer
,	O
compare_prefix	function
,	O
1	int
,	O
res	pointer
)	O
;	O
}	O
static	O
int	O
compare_rev_prefix	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
const	O
struct	O
rev_entry	struct
*	O
pkey	pointer
=	O
a	pointer
;	O
const	O
struct	O
rev_entry	struct
*	O
pelt	pointer
=	O
b	pointer
;	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
closure	pointer
;	O
size_t	long
wordlen	long
=	O
pkey	pointer
->	O
ptr	pointer
->	O
wordlen	long
;	O
if	O
(	O
pelt	pointer
->	O
ptr	pointer
->	O
wordlen	long
<	O
wordlen	long
)	O
wordlen	long
=	O
pelt	pointer
->	O
ptr	pointer
->	O
wordlen	long
;	O
compare_count	long
++	O
;	O
return	O
headword_compare_allchars	function
(	O
pkey	pointer
->	O
word	pointer
,	O
pelt	pointer
->	O
word	pointer
,	O
db	pointer
,	O
wordlen	long
)	O
;	O
}	O
static	O
int	O
suffix_match	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
struct	O
rev_entry	struct
x	int
,	O
*	O
ep	pointer
;	O
struct	O
index_entry	struct
ent	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
init_suffix_index	function
(	O
db	pointer
)	O
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ent	pointer
.	O
length	long
=	O
strlen	function
(	O
word	pointer
)	O
;	O
x	int
.	O
word	pointer
=	O
malloc	function
(	O
ent	pointer
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
x	int
.	O
word	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ent	pointer
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
word	pointer
)	O
;	O
revert_word	function
(	O
x	int
.	O
word	pointer
,	O
word	pointer
,	O
ent	pointer
.	O
length	long
)	O
;	O
x	int
.	O
ptr	pointer
=	O
&	O
ent	pointer
;	O
compare_count	long
=	O
0	int
;	O
ep	pointer
=	O
dico_bsearch	function
(	O
&	O
x	int
,	O
db	pointer
->	O
suf_index	pointer
,	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
suf_index	pointer
[	O
0	int
]	O
)	O
,	O
compare_rev_prefix	function
,	O
db	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
struct	O
rev_entry	struct
*	O
p	pointer
;	O
struct	O
index_entry	struct
*	O
*	O
tmp	pointer
;	O
size_t	long
i	long
;	O
size_t	long
count	long
=	O
0	int
;	O
dico_list_t	pointer
list	array
;	O
for	O
(	O
p	pointer
=	O
ep	pointer
;	O
p	pointer
<	O
db	pointer
->	O
suf_index	pointer
+	O
db	pointer
->	O
numwords	long
&&	O
compare_rev_prefix	function
(	O
&	O
x	int
,	O
p	pointer
,	O
db	pointer
)	O
==	O
0	int
;	O
p	pointer
++	O
)	O
count	long
++	O
;	O
tmp	pointer
=	O
calloc	function
(	O
count	long
,	O
sizeof	O
(	O
*	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
free	function
(	O
x	int
.	O
word	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
RESERVED_WORD	O
(	O
db	pointer
,	O
ep	pointer
[	O
i	long
]	O
.	O
ptr	pointer
->	O
word	pointer
)	O
)	O
tmp	pointer
[	O
i	long
]	O
=	O
ep	pointer
[	O
i	long
]	O
.	O
ptr	pointer
;	O
count	long
=	O
i	long
;	O
dico_sort	function
(	O
tmp	pointer
,	O
count	long
,	O
sizeof	O
(	O
tmp	pointer
[	O
0	int
]	O
)	O
,	O
compare_entry_ptr	function
,	O
db	pointer
)	O
;	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
list	array
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
free	function
(	O
x	int
.	O
word	pointer
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
dico_list_set_comparator	function
(	O
list	array
,	O
uniq_comp	function
,	O
db	pointer
)	O
;	O
dico_list_set_flags	function
(	O
list	array
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
dico_list_append	function
(	O
list	array
,	O
tmp	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
res	pointer
->	O
type	enum
=	O
result_match	int
;	O
res	pointer
->	O
list	array
=	O
list	array
;	O
res	pointer
->	O
itr	pointer
=	O
NULL	O
;	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
1	int
;	O
free	function
(	O
x	int
.	O
word	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
char	O
*	O
find_db_entry	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
index_entry	struct
x	int
;	O
struct	O
index_entry	struct
*	O
ep	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
rc	int
;	O
x	int
.	O
word	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
x	int
.	O
length	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
x	int
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
name	pointer
)	O
;	O
ep	pointer
=	O
dico_bsearch	function
(	O
&	O
x	int
,	O
db	pointer
->	O
index	pointer
,	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare_index_entry	function
,	O
db	pointer
)	O
;	O
if	O
(	O
!	O
ep	pointer
)	O
return	O
NULL	O
;	O
buf	pointer
=	O
malloc	function
(	O
ep	pointer
->	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_stream_seek	function
(	O
db	pointer
->	O
stream	pointer
,	O
ep	pointer
->	O
offset	long
,	O
DICO_SEEK_SET	int
)	O
;	O
rc	int
=	O
dico_stream_read	function
(	O
db	pointer
->	O
stream	pointer
,	O
buf	pointer
,	O
ep	pointer
->	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: read error: %s"	pointer
)	O
,	O
db	pointer
->	O
basename	pointer
,	O
dico_stream_strerror	function
(	O
db	pointer
->	O
stream	pointer
,	O
rc	int
)	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
buf	pointer
=	O
NULL	O
;	O
}	O
else	O
buf	pointer
[	O
ep	pointer
->	O
size	long
]	O
=	O
0	int
;	O
return	O
buf	pointer
;	O
}	O
static	O
int	O
get_db_flag	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
index_entry	struct
x	int
;	O
x	int
.	O
word	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
x	int
.	O
length	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
x	int
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
name	pointer
)	O
;	O
return	O
dico_bsearch	function
(	O
&	O
x	int
,	O
db	pointer
->	O
index	pointer
,	O
db	pointer
->	O
numwords	long
,	O
sizeof	O
(	O
db	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare_index_entry	function
,	O
db	pointer
)	O
!=	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mod_info	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
(	O
struct	O
dictdb	struct
*	O
)	O
hp	pointer
;	O
return	O
find_db_entry	function
(	O
db	pointer
,	O
DICTORG_INFO_ENTRY_NAME	O
)	O
;	O
}	O
static	O
char	O
*	O
mod_descr	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
(	O
struct	O
dictdb	struct
*	O
)	O
hp	pointer
;	O
char	O
*	O
ptr	pointer
=	O
find_db_entry	function
(	O
db	pointer
,	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
;	O
if	O
(	O
ptr	pointer
)	O
{	O
size_t	long
len	int
=	O
dico_trim_nl	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
len	int
>=	O
sizeof	O
(	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
&&	O
memcmp	function
(	O
ptr	pointer
,	O
DICTORG_SHORT_ENTRY_NAME	O
"\n"	pointer
,	O
sizeof	O
(	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
sizeof	O
(	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
;	O
ptr	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
isspace	function
(	O
ptr	pointer
[	O
i	long
]	O
)	O
)	O
break	O
;	O
memmove	function
(	O
ptr	pointer
,	O
ptr	pointer
+	O
i	long
,	O
len	int
-	O
i	long
+	O
1	int
)	O
;	O
}	O
}	O
return	O
ptr	pointer
;	O
}	O
static	O
char	O
*	O
mod_mime_header	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
(	O
struct	O
dictdb	struct
*	O
)	O
hp	pointer
;	O
return	O
find_db_entry	function
(	O
db	pointer
,	O
DICTORG_ENTRY_MIME_HEADER	O
)	O
;	O
}	O
static	O
dico_result_t	pointer
_match_simple	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
entry_match_t	pointer
match	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
;	O
res	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
NULL	O
;	O
res	pointer
->	O
db	pointer
=	O
db	pointer
;	O
if	O
(	O
match	pointer
(	O
db	pointer
,	O
word	pointer
,	O
res	pointer
)	O
)	O
{	O
free	function
(	O
res	pointer
)	O
;	O
res	pointer
=	O
NULL	O
;	O
}	O
else	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
dico_result_t	pointer
_match_all	function
(	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
dico_list_t	pointer
list	array
;	O
size_t	long
count	long
,	O
i	long
;	O
struct	O
result	pointer
*	O
res	pointer
;	O
struct	O
dico_key	struct
key	pointer
;	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
list	array
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_list_set_comparator	function
(	O
list	array
,	O
uniq_comp	function
,	O
db	pointer
)	O
;	O
dico_list_set_flags	function
(	O
list	array
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
if	O
(	O
dico_key_init	function
(	O
&	O
key	pointer
,	O
strat	pointer
,	O
word	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"_match_all: key initialization failed"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	pointer
->	O
numwords	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
RESERVED_WORD	O
(	O
db	pointer
,	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
.	O
word	pointer
)	O
&&	O
dico_key_match	function
(	O
&	O
key	pointer
,	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
.	O
word	pointer
)	O
)	O
dico_list_append	function
(	O
list	array
,	O
&	O
db	pointer
->	O
index	pointer
[	O
i	long
]	O
)	O
;	O
dico_key_deinit	function
(	O
&	O
key	pointer
)	O
;	O
compare_count	long
=	O
db	pointer
->	O
numwords	long
;	O
count	long
=	O
dico_list_count	function
(	O
list	array
)	O
;	O
if	O
(	O
count	long
==	O
0	int
)	O
{	O
dico_list_destroy	function
(	O
&	O
list	array
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
NULL	O
;	O
res	pointer
->	O
db	pointer
=	O
db	pointer
;	O
res	pointer
->	O
type	enum
=	O
result_match	int
;	O
res	pointer
->	O
list	array
=	O
list	array
;	O
res	pointer
->	O
itr	pointer
=	O
NULL	O
;	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
dico_result_t	pointer
mod_match	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
(	O
struct	O
dictdb	struct
*	O
)	O
hp	pointer
;	O
entry_match_t	pointer
match	pointer
;	O
if	O
(	O
RESERVED_WORD	O
(	O
db	pointer
,	O
word	pointer
)	O
)	O
return	O
NULL	O
;	O
match	pointer
=	O
find_matcher	function
(	O
strat	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
match	pointer
)	O
return	O
_match_simple	function
(	O
db	pointer
,	O
match	pointer
,	O
word	pointer
)	O
;	O
else	O
if	O
(	O
strat	pointer
->	O
sel	pointer
)	O
return	O
_match_all	function
(	O
db	pointer
,	O
strat	pointer
,	O
word	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
dico_result_t	pointer
mod_define	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
dictdb	struct
*	O
db	pointer
=	O
(	O
struct	O
dictdb	struct
*	O
)	O
hp	pointer
;	O
struct	O
result	pointer
res	pointer
,	O
*	O
rp	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
RESERVED_WORD	O
(	O
db	pointer
,	O
word	pointer
)	O
)	O
return	O
NULL	O
;	O
rc	int
=	O
common_match	function
(	O
db	pointer
,	O
word	pointer
,	O
compare_index_entry	function
,	O
0	int
,	O
&	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
NULL	O
;	O
rp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
rp	pointer
)	O
)	O
;	O
if	O
(	O
!	O
rp	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
dico_list_destroy	function
(	O
&	O
res	pointer
.	O
list	array
)	O
;	O
return	O
NULL	O
;	O
}	O
*	O
rp	pointer
=	O
res	pointer
;	O
rp	pointer
->	O
type	enum
=	O
result_define	int
;	O
return	O
(	O
dico_result_t	pointer
)	O
rp	pointer
;	O
}	O
static	O
void	O
printdef	function
(	O
dico_stream_t	pointer
str	pointer
,	O
struct	O
dictdb	struct
*	O
db	pointer
,	O
const	O
struct	O
index_entry	struct
*	O
ep	pointer
)	O
{	O
size_t	long
size	long
=	O
ep	pointer
->	O
size	long
;	O
char	O
buf	pointer
[	O
128	int
]	O
;	O
int	O
rc	int
;	O
if	O
(	O
dico_stream_seek	function
(	O
db	pointer
->	O
stream	pointer
,	O
ep	pointer
->	O
offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: seek error: %s"	pointer
)	O
,	O
db	pointer
->	O
basename	pointer
,	O
dico_stream_strerror	function
(	O
db	pointer
->	O
stream	pointer
,	O
dico_stream_last_error	function
(	O
db	pointer
->	O
stream	pointer
)	O
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
size	long
)	O
{	O
size_t	long
rdsize	long
=	O
size	long
;	O
if	O
(	O
rdsize	long
>	O
sizeof	O
(	O
buf	pointer
)	O
)	O
rdsize	long
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
dico_stream_read	function
(	O
db	pointer
->	O
stream	pointer
,	O
buf	pointer
,	O
rdsize	long
,	O
NULL	O
)	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: read error: %s"	pointer
)	O
,	O
db	pointer
->	O
basename	pointer
,	O
dico_stream_strerror	function
(	O
db	pointer
->	O
stream	pointer
,	O
rc	int
)	O
)	O
;	O
break	O
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
buf	pointer
,	O
rdsize	long
)	O
;	O
size	long
-=	O
rdsize	long
;	O
}	O
}	O
static	O
int	O
mod_output_result	function
(	O
dico_result_t	pointer
rp	pointer
,	O
size_t	long
n	long
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
const	O
struct	O
index_entry	struct
*	O
ep	pointer
;	O
if	O
(	O
!	O
res	pointer
->	O
itr	pointer
)	O
{	O
res	pointer
->	O
itr	pointer
=	O
dico_list_iterator	function
(	O
res	pointer
->	O
list	array
)	O
;	O
if	O
(	O
!	O
res	pointer
->	O
itr	pointer
)	O
return	O
1	int
;	O
}	O
ep	pointer
=	O
dico_iterator_item	function
(	O
res	pointer
->	O
itr	pointer
,	O
n	long
)	O
;	O
switch	O
(	O
res	pointer
->	O
type	enum
)	O
{	O
case	O
result_match	int
:	O
{	O
char	O
*	O
headword	pointer
=	O
ep	pointer
->	O
orig	pointer
?	O
ep	pointer
->	O
orig	pointer
:	O
ep	pointer
->	O
word	pointer
;	O
dico_stream_write	function
(	O
str	pointer
,	O
headword	pointer
,	O
strlen	function
(	O
headword	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
result_define	int
:	O
printdef	function
(	O
str	pointer
,	O
res	pointer
->	O
db	pointer
,	O
ep	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
mod_result_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
return	O
dico_list_count	function
(	O
res	pointer
->	O
list	array
)	O
;	O
}	O
static	O
size_t	long
mod_compare_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
return	O
res	pointer
->	O
compare_count	long
;	O
}	O
static	O
void	O
mod_free_result	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
dico_iterator_destroy	function
(	O
&	O
res	pointer
->	O
itr	pointer
)	O
;	O
dico_list_destroy	function
(	O
&	O
res	pointer
->	O
list	array
)	O
;	O
free	function
(	O
rp	pointer
)	O
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
dictorg	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	int
,	O
.	O
dico_init	pointer
=	O
mod_init	function
,	O
.	O
dico_init_db	pointer
=	O
mod_init_db	function
,	O
.	O
dico_free_db	pointer
=	O
mod_free_db	function
,	O
.	O
dico_db_info	pointer
=	O
mod_info	function
,	O
.	O
dico_db_descr	pointer
=	O
mod_descr	function
,	O
.	O
dico_match	pointer
=	O
mod_match	function
,	O
.	O
dico_define	pointer
=	O
mod_define	function
,	O
.	O
dico_output_result	pointer
=	O
mod_output_result	function
,	O
.	O
dico_result_count	pointer
=	O
mod_result_count	function
,	O
.	O
dico_compare_count	pointer
=	O
mod_compare_count	function
,	O
.	O
dico_free_result	pointer
=	O
mod_free_result	function
,	O
.	O
dico_db_mime_header	pointer
=	O
mod_mime_header	function
}	O
;	O