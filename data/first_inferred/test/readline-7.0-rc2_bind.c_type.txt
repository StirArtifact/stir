Keymap	pointer
rl_binding_keymap	pointer
;	O
static	O
int	O
_rl_skip_to_delim	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_init_file_error	function
(	O
const	O
char	O
*	O
,	O
...	O
)	O
__attribute__	O
(	O
(	O
__format__	O
(	O
printf	function
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
char	O
*	O
_rl_read_file	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
size_t	long
*	O
)	O
)	O
;	O
static	O
int	O
_rl_read_init_file	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
glean_key_from_name	function
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
find_boolean_var	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
find_string_var	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
_rl_get_string_variable_value	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
substring_member_of_array	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
const	O
*	O
)	O
)	O
;	O
static	O
int	O
currently_reading_init_file	int
;	O
static	O
int	O
_rl_prefer_visible_bell	int
=	O
1	int
;	O
int	O
rl_add_defun	function
(	O
name	pointer
,	O
function	pointer
,	O
key	int
)	O
const	O
char	O
*	O
name	pointer
;	O
rl_command_func_t	function
*	O
function	pointer
;	O
int	O
key	int
;	O
{	O
if	O
(	O
key	int
!=	O
-	O
1	int
)	O
rl_bind_key	function
(	O
key	int
,	O
function	pointer
)	O
;	O
rl_add_funmap_entry	function
(	O
name	pointer
,	O
function	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_bind_key	function
(	O
key	int
,	O
function	pointer
)	O
int	O
key	int
;	O
rl_command_func_t	function
*	O
function	pointer
;	O
{	O
char	O
keyseq	array
[	O
3	int
]	O
;	O
int	O
l	int
;	O
if	O
(	O
key	int
<	O
0	int
)	O
return	O
(	O
key	int
)	O
;	O
if	O
(	O
META_CHAR	O
(	O
key	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
if	O
(	O
_rl_keymap	pointer
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
Keymap	pointer
escmap	pointer
;	O
escmap	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
_rl_keymap	pointer
,	O
ESC	O
)	O
;	O
key	int
=	O
UNMETA	O
(	O
key	int
)	O
;	O
escmap	pointer
[	O
key	int
]	O
.	O
type	enum
=	O
ISFUNC	int
;	O
escmap	pointer
[	O
key	int
]	O
.	O
function	pointer
=	O
function	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
key	int
)	O
;	O
}	O
if	O
(	O
_rl_keymap	pointer
[	O
key	int
]	O
.	O
type	enum
!=	O
ISKMAP	int
)	O
{	O
_rl_keymap	pointer
[	O
key	int
]	O
.	O
type	enum
=	O
ISFUNC	int
;	O
_rl_keymap	pointer
[	O
key	int
]	O
.	O
function	pointer
=	O
function	pointer
;	O
}	O
else	O
{	O
l	int
=	O
0	int
;	O
if	O
(	O
key	int
==	O
'\\'	O
)	O
keyseq	array
[	O
l	int
++	O
]	O
=	O
'\\'	O
;	O
keyseq	array
[	O
l	int
++	O
]	O
=	O
key	int
;	O
keyseq	array
[	O
l	int
]	O
=	O
'\0'	O
;	O
rl_bind_keyseq	function
(	O
keyseq	array
,	O
function	pointer
)	O
;	O
}	O
rl_binding_keymap	pointer
=	O
_rl_keymap	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_bind_key_in_map	function
(	O
key	int
,	O
function	pointer
,	O
map	pointer
)	O
int	O
key	int
;	O
rl_command_func_t	function
*	O
function	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
int	O
result	int
;	O
Keymap	pointer
oldmap	pointer
;	O
oldmap	pointer
=	O
_rl_keymap	pointer
;	O
_rl_keymap	pointer
=	O
map	pointer
;	O
result	int
=	O
rl_bind_key	function
(	O
key	int
,	O
function	pointer
)	O
;	O
_rl_keymap	pointer
=	O
oldmap	pointer
;	O
return	O
(	O
result	int
)	O
;	O
}	O
int	O
rl_bind_key_if_unbound_in_map	function
(	O
key	int
,	O
default_func	pointer
,	O
kmap	pointer
)	O
int	O
key	int
;	O
rl_command_func_t	function
*	O
default_func	pointer
;	O
Keymap	pointer
kmap	pointer
;	O
{	O
char	O
keyseq	array
[	O
2	int
]	O
;	O
keyseq	array
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
key	int
;	O
keyseq	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
rl_bind_keyseq_if_unbound_in_map	function
(	O
keyseq	array
,	O
default_func	pointer
,	O
kmap	pointer
)	O
)	O
;	O
}	O
int	O
rl_bind_key_if_unbound	function
(	O
key	int
,	O
default_func	pointer
)	O
int	O
key	int
;	O
rl_command_func_t	function
*	O
default_func	pointer
;	O
{	O
char	O
keyseq	array
[	O
2	int
]	O
;	O
keyseq	array
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
key	int
;	O
keyseq	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
rl_bind_keyseq_if_unbound_in_map	function
(	O
keyseq	array
,	O
default_func	pointer
,	O
_rl_keymap	pointer
)	O
)	O
;	O
}	O
int	O
rl_unbind_key	function
(	O
key	int
)	O
int	O
key	int
;	O
{	O
return	O
(	O
rl_bind_key	function
(	O
key	int
,	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
int	O
rl_unbind_key_in_map	function
(	O
key	int
,	O
map	pointer
)	O
int	O
key	int
;	O
Keymap	pointer
map	pointer
;	O
{	O
return	O
(	O
rl_bind_key_in_map	function
(	O
key	int
,	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
,	O
map	pointer
)	O
)	O
;	O
}	O
int	O
rl_unbind_function_in_map	function
(	O
func	pointer
,	O
map	pointer
)	O
rl_command_func_t	function
*	O
func	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
register	O
int	O
i	int
,	O
rval	int
;	O
for	O
(	O
i	int
=	O
rval	int
=	O
0	int
;	O
i	int
<	O
KEYMAP_SIZE	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
map	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
ISFUNC	int
&&	O
map	pointer
[	O
i	int
]	O
.	O
function	pointer
==	O
func	pointer
)	O
{	O
map	pointer
[	O
i	int
]	O
.	O
function	pointer
=	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
;	O
rval	int
=	O
1	int
;	O
}	O
}	O
return	O
rval	int
;	O
}	O
int	O
rl_unbind_command_in_map	function
(	O
command	pointer
,	O
map	pointer
)	O
const	O
char	O
*	O
command	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
rl_command_func_t	function
*	O
func	pointer
;	O
func	pointer
=	O
rl_named_function	function
(	O
command	pointer
)	O
;	O
if	O
(	O
func	pointer
==	O
0	int
)	O
return	O
0	int
;	O
return	O
(	O
rl_unbind_function_in_map	function
(	O
func	pointer
,	O
map	pointer
)	O
)	O
;	O
}	O
int	O
rl_bind_keyseq	function
(	O
keyseq	array
,	O
function	pointer
)	O
const	O
char	O
*	O
keyseq	array
;	O
rl_command_func_t	function
*	O
function	pointer
;	O
{	O
return	O
(	O
rl_generic_bind	function
(	O
ISFUNC	int
,	O
keyseq	array
,	O
(	O
char	O
*	O
)	O
function	pointer
,	O
_rl_keymap	pointer
)	O
)	O
;	O
}	O
int	O
rl_bind_keyseq_in_map	function
(	O
keyseq	array
,	O
function	pointer
,	O
map	pointer
)	O
const	O
char	O
*	O
keyseq	array
;	O
rl_command_func_t	function
*	O
function	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
return	O
(	O
rl_generic_bind	function
(	O
ISFUNC	int
,	O
keyseq	array
,	O
(	O
char	O
*	O
)	O
function	pointer
,	O
map	pointer
)	O
)	O
;	O
}	O
int	O
rl_set_key	function
(	O
keyseq	array
,	O
function	pointer
,	O
map	pointer
)	O
const	O
char	O
*	O
keyseq	array
;	O
rl_command_func_t	function
*	O
function	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
return	O
(	O
rl_generic_bind	function
(	O
ISFUNC	int
,	O
keyseq	array
,	O
(	O
char	O
*	O
)	O
function	pointer
,	O
map	pointer
)	O
)	O
;	O
}	O
int	O
rl_bind_keyseq_if_unbound_in_map	function
(	O
keyseq	array
,	O
default_func	pointer
,	O
kmap	pointer
)	O
const	O
char	O
*	O
keyseq	array
;	O
rl_command_func_t	function
*	O
default_func	pointer
;	O
Keymap	pointer
kmap	pointer
;	O
{	O
rl_command_func_t	function
*	O
func	pointer
;	O
if	O
(	O
keyseq	array
)	O
{	O
func	pointer
=	O
rl_function_of_keyseq	function
(	O
keyseq	array
,	O
kmap	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
func	pointer
||	O
func	pointer
==	O
rl_do_lowercase_version	function
||	O
func	pointer
==	O
rl_vi_movement_mode	function
)	O
return	O
(	O
rl_bind_keyseq_in_map	function
(	O
keyseq	array
,	O
default_func	pointer
,	O
kmap	pointer
)	O
)	O
;	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_bind_keyseq_if_unbound	function
(	O
keyseq	array
,	O
default_func	pointer
)	O
const	O
char	O
*	O
keyseq	array
;	O
rl_command_func_t	function
*	O
default_func	pointer
;	O
{	O
return	O
(	O
rl_bind_keyseq_if_unbound_in_map	function
(	O
keyseq	array
,	O
default_func	pointer
,	O
_rl_keymap	pointer
)	O
)	O
;	O
}	O
int	O
rl_macro_bind	function
(	O
keyseq	array
,	O
macro	pointer
,	O
map	pointer
)	O
const	O
char	O
*	O
keyseq	array
,	O
*	O
macro	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
char	O
*	O
macro_keys	pointer
;	O
int	O
macro_keys_len	int
;	O
macro_keys	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
(	O
2	int
*	O
strlen	function
(	O
macro	pointer
)	O
)	O
+	O
1	int
)	O
;	O
if	O
(	O
rl_translate_keyseq	function
(	O
macro	pointer
,	O
macro_keys	pointer
,	O
&	O
macro_keys_len	int
)	O
)	O
{	O
xfree	function
(	O
macro_keys	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rl_generic_bind	function
(	O
ISMACR	int
,	O
keyseq	array
,	O
macro_keys	pointer
,	O
map	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_generic_bind	function
(	O
type	enum
,	O
keyseq	array
,	O
data	pointer
,	O
map	pointer
)	O
int	O
type	enum
;	O
const	O
char	O
*	O
keyseq	array
;	O
char	O
*	O
data	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
char	O
*	O
keys	pointer
;	O
int	O
keys_len	int
;	O
register	O
int	O
i	int
;	O
KEYMAP_ENTRY	struct
k	struct
;	O
k	struct
.	O
function	pointer
=	O
0	int
;	O
if	O
(	O
keyseq	array
==	O
0	int
||	O
*	O
keyseq	array
==	O
0	int
)	O
{	O
if	O
(	O
type	enum
==	O
ISMACR	int
)	O
xfree	function
(	O
data	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
keys	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
(	O
2	int
*	O
strlen	function
(	O
keyseq	array
)	O
)	O
)	O
;	O
if	O
(	O
rl_translate_keyseq	function
(	O
keyseq	array
,	O
keys	pointer
,	O
&	O
keys_len	int
)	O
)	O
{	O
xfree	function
(	O
keys	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
keys_len	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
uc	char
=	O
keys	pointer
[	O
i	int
]	O
;	O
int	O
ic	int
;	O
ic	int
=	O
uc	char
;	O
if	O
(	O
ic	int
<	O
0	int
||	O
ic	int
>=	O
KEYMAP_SIZE	int
)	O
{	O
xfree	function
(	O
keys	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
META_CHAR	O
(	O
ic	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
ic	int
=	O
UNMETA	O
(	O
ic	int
)	O
;	O
if	O
(	O
map	pointer
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
map	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
ESC	O
)	O
;	O
}	O
if	O
(	O
(	O
i	int
+	O
1	int
)	O
<	O
keys_len	int
)	O
{	O
if	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
!=	O
ISKMAP	int
)	O
{	O
k	struct
=	O
map	pointer
[	O
ic	int
]	O
;	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
=	O
ISKMAP	int
;	O
map	pointer
[	O
ic	int
]	O
.	O
function	pointer
=	O
KEYMAP_TO_FUNCTION	O
(	O
rl_make_bare_keymap	function
(	O
)	O
)	O
;	O
}	O
map	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
ic	int
)	O
;	O
if	O
(	O
k	struct
.	O
function	pointer
&&	O
(	O
(	O
k	struct
.	O
type	enum
==	O
ISFUNC	int
&&	O
k	struct
.	O
function	pointer
!=	O
rl_do_lowercase_version	function
)	O
||	O
k	struct
.	O
type	enum
==	O
ISMACR	int
)	O
)	O
{	O
map	pointer
[	O
ANYOTHERKEY	O
]	O
=	O
k	struct
;	O
k	struct
.	O
function	pointer
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
==	O
ISMACR	int
)	O
xfree	function
(	O
(	O
char	O
*	O
)	O
map	pointer
[	O
ic	int
]	O
.	O
function	pointer
)	O
;	O
else	O
if	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
map	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
ic	int
)	O
;	O
ic	int
=	O
ANYOTHERKEY	O
;	O
if	O
(	O
type	enum
==	O
ISFUNC	int
&&	O
data	pointer
==	O
0	int
)	O
data	pointer
=	O
(	O
char	O
*	O
)	O
_rl_null_function	function
;	O
}	O
map	pointer
[	O
ic	int
]	O
.	O
function	pointer
=	O
KEYMAP_TO_FUNCTION	O
(	O
data	pointer
)	O
;	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
=	O
type	enum
;	O
}	O
rl_binding_keymap	pointer
=	O
map	pointer
;	O
}	O
xfree	function
(	O
keys	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_translate_keyseq	function
(	O
seq	pointer
,	O
array	pointer
,	O
len	pointer
)	O
const	O
char	O
*	O
seq	pointer
;	O
char	O
*	O
array	pointer
;	O
int	O
*	O
len	pointer
;	O
{	O
register	O
int	O
i	int
,	O
c	int
,	O
l	int
,	O
temp	int
;	O
for	O
(	O
i	int
=	O
l	int
=	O
0	int
;	O
c	int
=	O
seq	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
seq	pointer
[	O
++	O
i	int
]	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
c	int
==	O
'C'	O
||	O
c	int
==	O
'M'	O
)	O
&&	O
seq	pointer
[	O
i	int
+	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
&	O
seq	pointer
[	O
i	int
]	O
,	O
"C-\\M-"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
array	pointer
[	O
l	int
++	O
]	O
=	O
ESC	O
;	O
i	int
+=	O
5	int
;	O
array	pointer
[	O
l	int
++	O
]	O
=	O
CTRL	O
(	O
_rl_to_upper	function
(	O
seq	pointer
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
seq	pointer
[	O
i	int
]	O
==	O
'\0'	O
)	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'M'	O
)	O
{	O
i	int
++	O
;	O
if	O
(	O
_rl_convert_meta_chars_to_ascii	int
&&	O
_rl_keymap	pointer
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
array	pointer
[	O
l	int
++	O
]	O
=	O
ESC	O
;	O
else	O
if	O
(	O
seq	pointer
[	O
i	int
+	O
1	int
]	O
==	O
'\\'	O
&&	O
seq	pointer
[	O
i	int
+	O
2	int
]	O
==	O
'C'	O
&&	O
seq	pointer
[	O
i	int
+	O
3	int
]	O
==	O
'-'	O
)	O
{	O
i	int
+=	O
4	int
;	O
temp	int
=	O
(	O
seq	pointer
[	O
i	int
]	O
==	O
'?'	O
)	O
?	O
RUBOUT	int
:	O
CTRL	O
(	O
_rl_to_upper	function
(	O
seq	pointer
[	O
i	int
]	O
)	O
)	O
;	O
array	pointer
[	O
l	int
++	O
]	O
=	O
META	O
(	O
temp	int
)	O
;	O
}	O
else	O
{	O
i	int
++	O
;	O
array	pointer
[	O
l	int
++	O
]	O
=	O
META	O
(	O
seq	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
'C'	O
)	O
{	O
i	int
+=	O
2	int
;	O
array	pointer
[	O
l	int
++	O
]	O
=	O
(	O
seq	pointer
[	O
i	int
]	O
==	O
'?'	O
)	O
?	O
RUBOUT	int
:	O
CTRL	O
(	O
_rl_to_upper	function
(	O
seq	pointer
[	O
i	int
]	O
)	O
)	O
;	O
}	O
continue	O
;	O
}	O
switch	O
(	O
c	int
)	O
{	O
case	O
'a'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
'\007'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'd'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
RUBOUT	int
;	O
break	O
;	O
case	O
'e'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
ESC	O
;	O
break	O
;	O
case	O
'f'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
NEWLINE	char
;	O
break	O
;	O
case	O
'r'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
RETURN	O
;	O
break	O
;	O
case	O
't'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
TAB	char
;	O
break	O
;	O
case	O
'v'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
0x0B	int
;	O
break	O
;	O
case	O
'\\'	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
'\\'	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
i	int
++	O
;	O
for	O
(	O
temp	int
=	O
2	int
,	O
c	int
-=	O
'0'	O
;	O
ISOCTAL	O
(	O
(	O
unsigned	O
char	O
)	O
seq	pointer
[	O
i	int
]	O
)	O
&&	O
temp	int
--	O
;	O
i	int
++	O
)	O
c	int
=	O
(	O
c	int
*	O
8	int
)	O
+	O
OCTVALUE	O
(	O
seq	pointer
[	O
i	int
]	O
)	O
;	O
i	int
--	O
;	O
array	pointer
[	O
l	int
++	O
]	O
=	O
c	int
&	O
largest_char	int
;	O
break	O
;	O
case	O
'x'	O
:	O
i	int
++	O
;	O
for	O
(	O
temp	int
=	O
2	int
,	O
c	int
=	O
0	int
;	O
ISXDIGIT	O
(	O
(	O
unsigned	O
char	O
)	O
seq	pointer
[	O
i	int
]	O
)	O
&&	O
temp	int
--	O
;	O
i	int
++	O
)	O
c	int
=	O
(	O
c	int
*	O
16	int
)	O
+	O
HEXVALUE	O
(	O
seq	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
temp	int
==	O
2	int
)	O
c	int
=	O
'x'	O
;	O
i	int
--	O
;	O
array	pointer
[	O
l	int
++	O
]	O
=	O
c	int
&	O
largest_char	int
;	O
break	O
;	O
default	O
:	O
array	pointer
[	O
l	int
++	O
]	O
=	O
c	int
;	O
break	O
;	O
}	O
continue	O
;	O
}	O
array	pointer
[	O
l	int
++	O
]	O
=	O
c	int
;	O
}	O
*	O
len	pointer
=	O
l	int
;	O
array	pointer
[	O
l	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_isescape	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\007'	O
:	O
case	O
'\b'	O
:	O
case	O
'\f'	O
:	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
case	O
TAB	char
:	O
case	O
0x0b	int
:	O
return	O
(	O
1	int
)	O
;	O
default	O
:	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
_rl_escchar	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\007'	O
:	O
return	O
(	O
'a'	O
)	O
;	O
case	O
'\b'	O
:	O
return	O
(	O
'b'	O
)	O
;	O
case	O
'\f'	O
:	O
return	O
(	O
'f'	O
)	O
;	O
case	O
'\n'	O
:	O
return	O
(	O
'n'	O
)	O
;	O
case	O
'\r'	O
:	O
return	O
(	O
'r'	O
)	O
;	O
case	O
TAB	char
:	O
return	O
(	O
't'	O
)	O
;	O
case	O
0x0b	int
:	O
return	O
(	O
'v'	O
)	O
;	O
default	O
:	O
return	O
(	O
c	int
)	O
;	O
}	O
}	O
char	O
*	O
rl_untranslate_keyseq	function
(	O
seq	pointer
)	O
int	O
seq	pointer
;	O
{	O
static	O
char	O
kseq	pointer
[	O
16	int
]	O
;	O
int	O
i	int
,	O
c	int
;	O
i	int
=	O
0	int
;	O
c	int
=	O
seq	pointer
;	O
if	O
(	O
META_CHAR	O
(	O
c	int
)	O
)	O
{	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'M'	O
;	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
)	O
{	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'C'	O
;	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
_rl_to_lower	function
(	O
UNCTRL	O
(	O
c	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
RUBOUT	int
)	O
{	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'C'	O
;	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
'?'	O
;	O
}	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
{	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
}	O
kseq	pointer
[	O
i	int
++	O
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
kseq	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
kseq	pointer
;	O
}	O
char	O
*	O
_rl_untranslate_macro_value	function
(	O
seq	pointer
,	O
use_escapes	int
)	O
char	O
*	O
seq	pointer
;	O
int	O
use_escapes	int
;	O
{	O
char	O
*	O
ret	pointer
,	O
*	O
r	pointer
,	O
*	O
s	pointer
;	O
int	O
c	int
;	O
r	pointer
=	O
ret	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
7	int
*	O
strlen	function
(	O
seq	pointer
)	O
+	O
1	int
)	O
;	O
for	O
(	O
s	pointer
=	O
seq	pointer
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
{	O
c	int
=	O
*	O
s	pointer
;	O
if	O
(	O
META_CHAR	O
(	O
c	int
)	O
)	O
{	O
*	O
r	pointer
++	O
=	O
'\\'	O
;	O
*	O
r	pointer
++	O
=	O
'M'	O
;	O
*	O
r	pointer
++	O
=	O
'-'	O
;	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
*	O
r	pointer
++	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
)	O
{	O
*	O
r	pointer
++	O
=	O
'\\'	O
;	O
if	O
(	O
use_escapes	int
&&	O
_rl_isescape	function
(	O
c	int
)	O
)	O
c	int
=	O
_rl_escchar	function
(	O
c	int
)	O
;	O
else	O
{	O
*	O
r	pointer
++	O
=	O
'C'	O
;	O
*	O
r	pointer
++	O
=	O
'-'	O
;	O
c	int
=	O
_rl_to_lower	function
(	O
UNCTRL	O
(	O
c	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
RUBOUT	int
)	O
{	O
*	O
r	pointer
++	O
=	O
'\\'	O
;	O
*	O
r	pointer
++	O
=	O
'C'	O
;	O
*	O
r	pointer
++	O
=	O
'-'	O
;	O
c	int
=	O
'?'	O
;	O
}	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
*	O
r	pointer
++	O
=	O
'\\'	O
;	O
c	int
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
*	O
r	pointer
++	O
=	O
'\\'	O
;	O
*	O
r	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
}	O
*	O
r	pointer
=	O
'\0'	O
;	O
return	O
ret	pointer
;	O
}	O
rl_command_func_t	function
*	O
rl_named_function	function
(	O
string	pointer
)	O
const	O
char	O
*	O
string	pointer
;	O
{	O
register	O
int	O
i	int
;	O
rl_initialize_funmap	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
funmap	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
funmap	pointer
[	O
i	int
]	O
->	O
name	pointer
,	O
string	pointer
)	O
==	O
0	int
)	O
return	O
(	O
funmap	pointer
[	O
i	int
]	O
->	O
function	pointer
)	O
;	O
return	O
(	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
)	O
;	O
}	O
rl_command_func_t	function
*	O
rl_function_of_keyseq	function
(	O
keyseq	array
,	O
map	pointer
,	O
type	enum
)	O
const	O
char	O
*	O
keyseq	array
;	O
Keymap	pointer
map	pointer
;	O
int	O
*	O
type	enum
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
map	pointer
==	O
0	int
)	O
map	pointer
=	O
_rl_keymap	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
keyseq	array
&&	O
keyseq	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
ic	int
=	O
keyseq	array
[	O
i	int
]	O
;	O
if	O
(	O
META_CHAR	O
(	O
ic	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
if	O
(	O
map	pointer
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
map	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
ESC	O
)	O
;	O
ic	int
=	O
UNMETA	O
(	O
ic	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
map	pointer
[	O
ESC	O
]	O
.	O
type	enum
;	O
return	O
(	O
map	pointer
[	O
ESC	O
]	O
.	O
function	pointer
)	O
;	O
}	O
}	O
if	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
if	O
(	O
keyseq	array
[	O
i	int
+	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
ISKMAP	int
;	O
return	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
function	pointer
)	O
;	O
}	O
else	O
map	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
ic	int
)	O
;	O
}	O
else	O
if	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
!=	O
ISKMAP	int
&&	O
keyseq	array
[	O
i	int
+	O
1	int
]	O
)	O
return	O
(	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
map	pointer
[	O
ic	int
]	O
.	O
type	enum
;	O
return	O
(	O
map	pointer
[	O
ic	int
]	O
.	O
function	pointer
)	O
;	O
}	O
}	O
return	O
(	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
)	O
;	O
}	O
static	O
char	O
*	O
last_readline_init_file	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
const	O
char	O
*	O
current_readline_init_file	pointer
;	O
static	O
int	O
current_readline_init_include_level	int
;	O
static	O
int	O
current_readline_init_lineno	int
;	O
static	O
char	O
*	O
_rl_read_file	function
(	O
filename	pointer
,	O
sizep	pointer
)	O
char	O
*	O
filename	pointer
;	O
size_t	long
*	O
sizep	pointer
;	O
{	O
struct	O
stat	struct
finfo	struct
;	O
size_t	long
file_size	long
;	O
char	O
*	O
buffer	pointer
;	O
int	O
i	int
,	O
file	int
;	O
if	O
(	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
finfo	struct
)	O
<	O
0	int
)	O
||	O
(	O
file	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDONLY	int
,	O
0666	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
file_size	long
=	O
(	O
size_t	long
)	O
finfo	struct
.	O
st_size	long
;	O
if	O
(	O
file_size	long
!=	O
finfo	struct
.	O
st_size	long
||	O
file_size	long
+	O
1	int
<	O
file_size	long
)	O
{	O
if	O
(	O
file	int
>=	O
0	int
)	O
close	pointer
(	O
file	int
)	O
;	O
errno	O
=	O
EFBIG	int
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
file_size	long
+	O
1	int
)	O
;	O
i	int
=	O
read	pointer
(	O
file	int
,	O
buffer	pointer
,	O
file_size	long
)	O
;	O
close	pointer
(	O
file	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
xfree	function
(	O
buffer	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
buffer	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
sizep	pointer
)	O
*	O
sizep	pointer
=	O
i	int
;	O
return	O
(	O
buffer	pointer
)	O
;	O
}	O
int	O
rl_re_read_init_file	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
int	O
r	pointer
;	O
r	pointer
=	O
rl_read_init_file	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
rl_set_keymap_from_edit_mode	function
(	O
)	O
;	O
return	O
r	pointer
;	O
}	O
int	O
rl_read_init_file	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
if	O
(	O
filename	pointer
==	O
0	int
)	O
filename	pointer
=	O
last_readline_init_file	pointer
;	O
if	O
(	O
filename	pointer
==	O
0	int
)	O
filename	pointer
=	O
sh_get_env_value	function
(	O
"INPUTRC"	pointer
)	O
;	O
if	O
(	O
filename	pointer
==	O
0	int
||	O
*	O
filename	pointer
==	O
0	int
)	O
{	O
filename	pointer
=	O
DEFAULT_INPUTRC	pointer
;	O
if	O
(	O
_rl_read_init_file	function
(	O
filename	pointer
,	O
0	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
filename	pointer
=	O
SYS_INPUTRC	pointer
;	O
}	O
return	O
(	O
_rl_read_init_file	function
(	O
filename	pointer
,	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_read_init_file	function
(	O
filename	pointer
,	O
include_level	int
)	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
include_level	int
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
buffer	pointer
,	O
*	O
openname	pointer
,	O
*	O
line	pointer
,	O
*	O
end	int
;	O
size_t	long
file_size	long
;	O
current_readline_init_file	pointer
=	O
filename	pointer
;	O
current_readline_init_include_level	int
=	O
include_level	int
;	O
openname	pointer
=	O
tilde_expand	function
(	O
filename	pointer
)	O
;	O
buffer	pointer
=	O
_rl_read_file	function
(	O
openname	pointer
,	O
&	O
file_size	long
)	O
;	O
xfree	function
(	O
openname	pointer
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
if	O
(	O
buffer	pointer
==	O
0	int
)	O
return	O
(	O
errno	O
)	O
;	O
if	O
(	O
include_level	int
==	O
0	int
&&	O
filename	pointer
!=	O
last_readline_init_file	pointer
)	O
{	O
FREE	O
(	O
last_readline_init_file	pointer
)	O
;	O
last_readline_init_file	pointer
=	O
savestring	O
(	O
filename	pointer
)	O
;	O
}	O
currently_reading_init_file	int
=	O
1	int
;	O
current_readline_init_lineno	int
=	O
1	int
;	O
line	pointer
=	O
buffer	pointer
;	O
end	int
=	O
buffer	pointer
+	O
file_size	long
;	O
while	O
(	O
line	pointer
<	O
end	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
line	pointer
+	O
i	int
!=	O
end	int
&&	O
line	pointer
[	O
i	int
]	O
!=	O
'\n'	O
;	O
i	int
++	O
)	O
;	O
line	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
line	pointer
&&	O
whitespace	O
(	O
*	O
line	pointer
)	O
)	O
{	O
line	pointer
++	O
;	O
i	int
--	O
;	O
}	O
if	O
(	O
*	O
line	pointer
&&	O
*	O
line	pointer
!=	O
'#'	O
)	O
rl_parse_and_bind	function
(	O
line	pointer
)	O
;	O
line	pointer
+=	O
i	int
+	O
1	int
;	O
current_readline_init_lineno	int
++	O
;	O
}	O
xfree	function
(	O
buffer	pointer
)	O
;	O
currently_reading_init_file	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_init_file_error	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"readline: "	pointer
)	O
;	O
if	O
(	O
currently_reading_init_file	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: line %d: "	pointer
,	O
current_readline_init_file	pointer
,	O
current_readline_init_lineno	int
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
typedef	O
int	O
_rl_parser_func_t	function
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
const	O
char	O
*	O
const	O
_rl_possible_control_prefixes	array
[	O
]	O
=	O
{	O
"Control-"	pointer
,	O
"C-"	pointer
,	O
"CTRL-"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
}	O
;	O
const	O
char	O
*	O
const	O
_rl_possible_meta_prefixes	array
[	O
]	O
=	O
{	O
"Meta"	pointer
,	O
"M-"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
}	O
;	O
const	O
char	O
*	O
rl_readline_name	pointer
=	O
"other"	pointer
;	O
static	O
unsigned	O
char	O
*	O
if_stack	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
if_stack_depth	int
;	O
static	O
int	O
if_stack_size	int
;	O
static	O
int	O
parser_if	function
(	O
args	array
)	O
char	O
*	O
args	array
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
if_stack_depth	int
+	O
1	int
>=	O
if_stack_size	int
)	O
{	O
if	O
(	O
!	O
if_stack	pointer
)	O
if_stack	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	function
(	O
if_stack_size	int
=	O
20	int
)	O
;	O
else	O
if_stack	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xrealloc	function
(	O
if_stack	pointer
,	O
if_stack_size	int
+=	O
20	int
)	O
;	O
}	O
if_stack	pointer
[	O
if_stack_depth	int
++	O
]	O
=	O
_rl_parsing_conditionalized_out	char
;	O
if	O
(	O
_rl_parsing_conditionalized_out	char
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	array
[	O
i	int
]	O
&&	O
!	O
whitespace	O
(	O
args	array
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
args	array
[	O
i	int
]	O
)	O
args	array
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
rl_terminal_name	pointer
&&	O
_rl_strnicmp	O
(	O
args	array
,	O
"term="	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
tem	pointer
,	O
*	O
tname	pointer
;	O
tname	pointer
=	O
savestring	O
(	O
rl_terminal_name	pointer
)	O
;	O
tem	pointer
=	O
strchr	function
(	O
tname	pointer
,	O
'-'	O
)	O
;	O
if	O
(	O
tem	pointer
)	O
*	O
tem	pointer
=	O
'\0'	O
;	O
_rl_parsing_conditionalized_out	char
=	O
_rl_stricmp	O
(	O
args	array
+	O
5	int
,	O
tname	pointer
)	O
&&	O
_rl_stricmp	O
(	O
args	array
+	O
5	int
,	O
rl_terminal_name	pointer
)	O
;	O
xfree	function
(	O
tname	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_strnicmp	O
(	O
args	array
,	O
"mode="	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
int	O
mode	int
;	O
if	O
(	O
_rl_stricmp	O
(	O
args	array
+	O
5	int
,	O
"emacs"	pointer
)	O
==	O
0	int
)	O
mode	int
=	O
emacs_mode	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
args	array
+	O
5	int
,	O
"vi"	pointer
)	O
==	O
0	int
)	O
mode	int
=	O
vi_mode	int
;	O
else	O
mode	int
=	O
no_mode	O
;	O
_rl_parsing_conditionalized_out	char
=	O
mode	int
!=	O
rl_editing_mode	int
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
args	array
,	O
rl_readline_name	pointer
)	O
==	O
0	int
)	O
_rl_parsing_conditionalized_out	char
=	O
0	int
;	O
else	O
_rl_parsing_conditionalized_out	char
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parser_else	function
(	O
args	array
)	O
char	O
*	O
args	array
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
if_stack_depth	int
==	O
0	int
)	O
{	O
_rl_init_file_error	function
(	O
"$else found without matching $if"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
if_stack_depth	int
;	O
i	int
++	O
)	O
if	O
(	O
if_stack	pointer
[	O
i	int
]	O
==	O
1	int
)	O
return	O
0	int
;	O
_rl_parsing_conditionalized_out	char
=	O
!	O
_rl_parsing_conditionalized_out	char
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parser_endif	function
(	O
args	array
)	O
char	O
*	O
args	array
;	O
{	O
if	O
(	O
if_stack_depth	int
)	O
_rl_parsing_conditionalized_out	char
=	O
if_stack	pointer
[	O
--	O
if_stack_depth	int
]	O
;	O
else	O
_rl_init_file_error	function
(	O
"$endif without matching $if"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parser_include	function
(	O
args	array
)	O
char	O
*	O
args	array
;	O
{	O
const	O
char	O
*	O
old_init_file	pointer
;	O
char	O
*	O
e	pointer
;	O
int	O
old_line_number	int
,	O
old_include_level	int
,	O
r	pointer
;	O
if	O
(	O
_rl_parsing_conditionalized_out	char
)	O
return	O
(	O
0	int
)	O
;	O
old_init_file	pointer
=	O
current_readline_init_file	pointer
;	O
old_line_number	int
=	O
current_readline_init_lineno	int
;	O
old_include_level	int
=	O
current_readline_init_include_level	int
;	O
e	pointer
=	O
strchr	function
(	O
args	array
,	O
'\n'	O
)	O
;	O
if	O
(	O
e	pointer
)	O
*	O
e	pointer
=	O
'\0'	O
;	O
r	pointer
=	O
_rl_read_init_file	function
(	O
(	O
const	O
char	O
*	O
)	O
args	array
,	O
old_include_level	int
+	O
1	int
)	O
;	O
current_readline_init_file	pointer
=	O
old_init_file	pointer
;	O
current_readline_init_lineno	int
=	O
old_line_number	int
;	O
current_readline_init_include_level	int
=	O
old_include_level	int
;	O
return	O
r	pointer
;	O
}	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	pointer
;	O
_rl_parser_func_t	function
*	O
function	pointer
;	O
}	O
parser_directives	array
[	O
]	O
=	O
{	O
{	O
"if"	pointer
,	O
parser_if	function
}	O
,	O
{	O
"endif"	pointer
,	O
parser_endif	function
}	O
,	O
{	O
"else"	pointer
,	O
parser_else	function
}	O
,	O
{	O
"include"	pointer
,	O
parser_include	function
}	O
,	O
{	O
(	O
char	O
*	O
)	O
0x0	int
,	O
(	O
_rl_parser_func_t	function
*	O
)	O
0x0	int
}	O
}	O
;	O
static	O
int	O
handle_parser_directive	function
(	O
statement	pointer
)	O
char	O
*	O
statement	pointer
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
directive	pointer
,	O
*	O
args	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
whitespace	O
(	O
statement	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
directive	pointer
=	O
&	O
statement	pointer
[	O
i	int
]	O
;	O
for	O
(	O
;	O
statement	pointer
[	O
i	int
]	O
&&	O
!	O
whitespace	O
(	O
statement	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
statement	pointer
[	O
i	int
]	O
)	O
statement	pointer
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
statement	pointer
[	O
i	int
]	O
&&	O
whitespace	O
(	O
statement	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
args	array
=	O
&	O
statement	pointer
[	O
i	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
parser_directives	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
directive	pointer
,	O
parser_directives	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
(	O
*	O
parser_directives	array
[	O
i	int
]	O
.	O
function	pointer
)	O
(	O
args	array
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
_rl_init_file_error	function
(	O
"%s: unknown parser directive"	pointer
,	O
directive	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
_rl_skip_to_delim	function
(	O
string	pointer
,	O
start	int
,	O
delim	int
)	O
char	O
*	O
string	pointer
;	O
int	O
start	int
,	O
delim	int
;	O
{	O
int	O
i	int
,	O
c	int
,	O
passc	int
;	O
for	O
(	O
i	int
=	O
start	int
,	O
passc	int
=	O
0	int
;	O
c	int
=	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
passc	int
)	O
{	O
passc	int
=	O
0	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
passc	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
delim	int
)	O
break	O
;	O
}	O
return	O
i	int
;	O
}	O
int	O
rl_parse_and_bind	function
(	O
string	pointer
)	O
char	O
*	O
string	pointer
;	O
{	O
char	O
*	O
funname	pointer
,	O
*	O
kname	pointer
;	O
register	O
int	O
c	int
,	O
i	int
;	O
int	O
key	int
,	O
equivalency	int
,	O
foundmod	int
,	O
foundsep	int
;	O
while	O
(	O
string	pointer
&&	O
whitespace	O
(	O
*	O
string	pointer
)	O
)	O
string	pointer
++	O
;	O
if	O
(	O
string	pointer
==	O
0	int
||	O
*	O
string	pointer
==	O
0	int
||	O
*	O
string	pointer
==	O
'#'	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
string	pointer
==	O
'$'	O
)	O
{	O
handle_parser_directive	function
(	O
&	O
string	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
_rl_parsing_conditionalized_out	char
)	O
return	O
0	int
;	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
string	pointer
==	O
'"'	O
)	O
{	O
i	int
=	O
_rl_skip_to_delim	function
(	O
string	pointer
,	O
1	int
,	O
'"'	O
)	O
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
'\0'	O
)	O
{	O
_rl_init_file_error	function
(	O
"%s: no closing `\"' in key binding"	pointer
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
(	O
c	int
=	O
string	pointer
[	O
i	int
]	O
)	O
&&	O
c	int
!=	O
':'	O
&&	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
'\t'	O
;	O
i	int
++	O
)	O
;	O
equivalency	int
=	O
(	O
c	int
==	O
':'	O
&&	O
string	pointer
[	O
i	int
+	O
1	int
]	O
==	O
'='	O
)	O
;	O
foundsep	int
=	O
c	int
!=	O
0	int
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
)	O
string	pointer
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
equivalency	int
)	O
string	pointer
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
_rl_stricmp	O
(	O
string	pointer
,	O
"set"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
var	pointer
,	O
*	O
value	pointer
,	O
*	O
e	pointer
;	O
int	O
s	pointer
;	O
var	pointer
=	O
string	pointer
+	O
i	int
;	O
while	O
(	O
*	O
var	pointer
&&	O
whitespace	O
(	O
*	O
var	pointer
)	O
)	O
var	pointer
++	O
;	O
value	pointer
=	O
var	pointer
;	O
while	O
(	O
*	O
value	pointer
&&	O
whitespace	O
(	O
*	O
value	pointer
)	O
==	O
0	int
)	O
value	pointer
++	O
;	O
if	O
(	O
*	O
value	pointer
)	O
*	O
value	pointer
++	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
value	pointer
&&	O
whitespace	O
(	O
*	O
value	pointer
)	O
)	O
value	pointer
++	O
;	O
if	O
(	O
find_boolean_var	function
(	O
var	pointer
)	O
>=	O
0	int
)	O
{	O
remove_trailing	O
:	O
e	pointer
=	O
value	pointer
+	O
strlen	function
(	O
value	pointer
)	O
-	O
1	int
;	O
while	O
(	O
e	pointer
>=	O
value	pointer
&&	O
whitespace	O
(	O
*	O
e	pointer
)	O
)	O
e	pointer
--	O
;	O
e	pointer
++	O
;	O
if	O
(	O
*	O
e	pointer
&&	O
e	pointer
>=	O
value	pointer
)	O
*	O
e	pointer
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
(	O
i	int
=	O
find_string_var	function
(	O
var	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
value	pointer
==	O
'"'	O
)	O
{	O
i	int
=	O
_rl_skip_to_delim	function
(	O
value	pointer
,	O
1	int
,	O
*	O
value	pointer
)	O
;	O
value	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
value	pointer
++	O
;	O
}	O
else	O
goto	O
remove_trailing	O
;	O
}	O
rl_variable_bind	function
(	O
var	pointer
,	O
value	pointer
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
;	O
string	pointer
[	O
i	int
]	O
&&	O
whitespace	O
(	O
string	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
funname	pointer
=	O
&	O
string	pointer
[	O
i	int
]	O
;	O
if	O
(	O
*	O
funname	pointer
==	O
'\''	O
||	O
*	O
funname	pointer
==	O
'"'	O
)	O
{	O
i	int
=	O
_rl_skip_to_delim	function
(	O
string	pointer
,	O
i	int
+	O
1	int
,	O
*	O
funname	pointer
)	O
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
)	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
string	pointer
[	O
i	int
]	O
&&	O
whitespace	O
(	O
string	pointer
[	O
i	int
]	O
)	O
==	O
0	int
;	O
i	int
++	O
)	O
;	O
string	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
equivalency	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
foundsep	int
==	O
0	int
)	O
{	O
_rl_init_file_error	function
(	O
"%s: no key sequence terminator"	pointer
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
string	pointer
==	O
'"'	O
)	O
{	O
char	O
*	O
seq	pointer
;	O
register	O
int	O
j	int
,	O
k	struct
,	O
passc	int
;	O
seq	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
string	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
1	int
,	O
k	struct
=	O
passc	int
=	O
0	int
;	O
string	pointer
[	O
j	int
]	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
passc	int
||	O
(	O
string	pointer
[	O
j	int
]	O
==	O
'\\'	O
)	O
)	O
{	O
seq	pointer
[	O
k	struct
++	O
]	O
=	O
string	pointer
[	O
j	int
]	O
;	O
passc	int
=	O
!	O
passc	int
;	O
continue	O
;	O
}	O
if	O
(	O
string	pointer
[	O
j	int
]	O
==	O
'"'	O
)	O
break	O
;	O
seq	pointer
[	O
k	struct
++	O
]	O
=	O
string	pointer
[	O
j	int
]	O
;	O
}	O
seq	pointer
[	O
k	struct
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
funname	pointer
==	O
'\''	O
||	O
*	O
funname	pointer
==	O
'"'	O
)	O
{	O
j	int
=	O
strlen	function
(	O
funname	pointer
)	O
;	O
if	O
(	O
j	int
&&	O
funname	pointer
[	O
j	int
-	O
1	int
]	O
==	O
*	O
funname	pointer
)	O
funname	pointer
[	O
j	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
rl_macro_bind	function
(	O
seq	pointer
,	O
&	O
funname	pointer
[	O
1	int
]	O
,	O
_rl_keymap	pointer
)	O
;	O
}	O
else	O
rl_bind_keyseq	function
(	O
seq	pointer
,	O
rl_named_function	function
(	O
funname	pointer
)	O
)	O
;	O
xfree	function
(	O
seq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kname	pointer
=	O
strrchr	function
(	O
string	pointer
,	O
'-'	O
)	O
;	O
if	O
(	O
kname	pointer
==	O
0	int
)	O
kname	pointer
=	O
string	pointer
;	O
else	O
kname	pointer
++	O
;	O
key	int
=	O
glean_key_from_name	function
(	O
kname	pointer
)	O
;	O
foundmod	int
=	O
0	int
;	O
if	O
(	O
substring_member_of_array	function
(	O
string	pointer
,	O
_rl_possible_control_prefixes	array
)	O
)	O
{	O
key	int
=	O
CTRL	O
(	O
_rl_to_upper	function
(	O
key	int
)	O
)	O
;	O
foundmod	int
=	O
1	int
;	O
}	O
if	O
(	O
substring_member_of_array	function
(	O
string	pointer
,	O
_rl_possible_meta_prefixes	array
)	O
)	O
{	O
key	int
=	O
META	O
(	O
key	int
)	O
;	O
foundmod	int
=	O
1	int
;	O
}	O
if	O
(	O
foundmod	int
==	O
0	int
&&	O
kname	pointer
!=	O
string	pointer
)	O
{	O
_rl_init_file_error	function
(	O
"%s: unknown key modifier"	pointer
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
funname	pointer
==	O
'\''	O
||	O
*	O
funname	pointer
==	O
'"'	O
)	O
{	O
char	O
useq	array
[	O
2	int
]	O
;	O
int	O
fl	int
=	O
strlen	function
(	O
funname	pointer
)	O
;	O
useq	array
[	O
0	int
]	O
=	O
key	int
;	O
useq	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
fl	int
&&	O
funname	pointer
[	O
fl	int
-	O
1	int
]	O
==	O
*	O
funname	pointer
)	O
funname	pointer
[	O
fl	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
rl_macro_bind	function
(	O
useq	array
,	O
&	O
funname	pointer
[	O
1	int
]	O
,	O
_rl_keymap	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
funname	pointer
,	O
"prefix-meta"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
seq	pointer
[	O
2	int
]	O
;	O
seq	pointer
[	O
0	int
]	O
=	O
key	int
;	O
seq	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
rl_generic_bind	function
(	O
ISKMAP	int
,	O
seq	pointer
,	O
(	O
char	O
*	O
)	O
emacs_meta_keymap	array
,	O
_rl_keymap	pointer
)	O
;	O
}	O
else	O
rl_bind_key	function
(	O
key	int
,	O
rl_named_function	function
(	O
funname	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	pointer
;	O
int	O
*	O
value	pointer
;	O
int	O
flags	int
;	O
}	O
boolean_varlist	array
[	O
]	O
=	O
{	O
{	O
"bind-tty-special-chars"	pointer
,	O
&	O
_rl_bind_stty_chars	int
,	O
0	int
}	O
,	O
{	O
"blink-matching-paren"	pointer
,	O
&	O
rl_blink_matching_paren	int
,	O
V_SPECIAL	int
}	O
,	O
{	O
"byte-oriented"	pointer
,	O
&	O
rl_byte_oriented	int
,	O
0	int
}	O
,	O
{	O
"colored-completion-prefix"	pointer
,	O
&	O
_rl_colored_completion_prefix	int
,	O
0	int
}	O
,	O
{	O
"colored-stats"	pointer
,	O
&	O
_rl_colored_stats	int
,	O
0	int
}	O
,	O
{	O
"completion-ignore-case"	pointer
,	O
&	O
_rl_completion_case_fold	int
,	O
0	int
}	O
,	O
{	O
"completion-map-case"	pointer
,	O
&	O
_rl_completion_case_map	int
,	O
0	int
}	O
,	O
{	O
"convert-meta"	pointer
,	O
&	O
_rl_convert_meta_chars_to_ascii	int
,	O
0	int
}	O
,	O
{	O
"disable-completion"	pointer
,	O
&	O
rl_inhibit_completion	int
,	O
0	int
}	O
,	O
{	O
"echo-control-characters"	pointer
,	O
&	O
_rl_echo_control_chars	int
,	O
0	int
}	O
,	O
{	O
"enable-bracketed-paste"	pointer
,	O
&	O
_rl_enable_bracketed_paste	int
,	O
0	int
}	O
,	O
{	O
"enable-keypad"	pointer
,	O
&	O
_rl_enable_keypad	int
,	O
0	int
}	O
,	O
{	O
"enable-meta-key"	pointer
,	O
&	O
_rl_enable_meta	int
,	O
0	int
}	O
,	O
{	O
"expand-tilde"	pointer
,	O
&	O
rl_complete_with_tilde_expansion	int
,	O
0	int
}	O
,	O
{	O
"history-preserve-point"	pointer
,	O
&	O
_rl_history_preserve_point	int
,	O
0	int
}	O
,	O
{	O
"horizontal-scroll-mode"	pointer
,	O
&	O
_rl_horizontal_scroll_mode	int
,	O
0	int
}	O
,	O
{	O
"input-meta"	pointer
,	O
&	O
_rl_meta_flag	int
,	O
0	int
}	O
,	O
{	O
"mark-directories"	pointer
,	O
&	O
_rl_complete_mark_directories	int
,	O
0	int
}	O
,	O
{	O
"mark-modified-lines"	pointer
,	O
&	O
_rl_mark_modified_lines	int
,	O
0	int
}	O
,	O
{	O
"mark-symlinked-directories"	pointer
,	O
&	O
_rl_complete_mark_symlink_dirs	int
,	O
0	int
}	O
,	O
{	O
"match-hidden-files"	pointer
,	O
&	O
_rl_match_hidden_files	int
,	O
0	int
}	O
,	O
{	O
"menu-complete-display-prefix"	pointer
,	O
&	O
_rl_menu_complete_prefix_first	int
,	O
0	int
}	O
,	O
{	O
"meta-flag"	pointer
,	O
&	O
_rl_meta_flag	int
,	O
0	int
}	O
,	O
{	O
"output-meta"	pointer
,	O
&	O
_rl_output_meta_chars	int
,	O
0	int
}	O
,	O
{	O
"page-completions"	pointer
,	O
&	O
_rl_page_completions	int
,	O
0	int
}	O
,	O
{	O
"prefer-visible-bell"	pointer
,	O
&	O
_rl_prefer_visible_bell	int
,	O
V_SPECIAL	int
}	O
,	O
{	O
"print-completions-horizontally"	pointer
,	O
&	O
_rl_print_completions_horizontally	int
,	O
0	int
}	O
,	O
{	O
"revert-all-at-newline"	pointer
,	O
&	O
_rl_revert_all_at_newline	int
,	O
0	int
}	O
,	O
{	O
"show-all-if-ambiguous"	pointer
,	O
&	O
_rl_complete_show_all	int
,	O
0	int
}	O
,	O
{	O
"show-all-if-unmodified"	pointer
,	O
&	O
_rl_complete_show_unmodified	int
,	O
0	int
}	O
,	O
{	O
"show-mode-in-prompt"	pointer
,	O
&	O
_rl_show_mode_in_prompt	int
,	O
0	int
}	O
,	O
{	O
"skip-completed-text"	pointer
,	O
&	O
_rl_skip_completed_text	int
,	O
0	int
}	O
,	O
{	O
"visible-stats"	pointer
,	O
&	O
rl_visible_stats	int
,	O
0	int
}	O
,	O
{	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
int	O
find_boolean_var	function
(	O
name	pointer
)	O
const	O
char	O
*	O
name	pointer
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
boolean_varlist	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
boolean_varlist	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
hack_special_boolean_var	function
(	O
i	int
)	O
int	O
i	int
;	O
{	O
const	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
boolean_varlist	array
[	O
i	int
]	O
.	O
name	pointer
;	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"blink-matching-paren"	pointer
)	O
==	O
0	int
)	O
_rl_enable_paren_matching	function
(	O
rl_blink_matching_paren	int
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"prefer-visible-bell"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
_rl_prefer_visible_bell	int
)	O
_rl_bell_preference	int
=	O
VISIBLE_BELL	int
;	O
else	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"show-mode-in-prompt"	pointer
)	O
==	O
0	int
)	O
_rl_reset_prompt	function
(	O
)	O
;	O
}	O
typedef	O
int	O
_rl_sv_func_t	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_bell_style	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_combegin	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_dispprefix	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_compquery	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_compwidth	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_editmode	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_emacs_modestr	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_histsize	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_isrchterm	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_keymap	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_seqtimeout	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_viins_modestr	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
sv_vicmd_modestr	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	pointer
;	O
int	O
flags	int
;	O
_rl_sv_func_t	function
*	O
set_func	pointer
;	O
}	O
string_varlist	array
[	O
]	O
=	O
{	O
{	O
"bell-style"	pointer
,	O
V_STRING	int
,	O
sv_bell_style	function
}	O
,	O
{	O
"comment-begin"	pointer
,	O
V_STRING	int
,	O
sv_combegin	function
}	O
,	O
{	O
"completion-display-width"	pointer
,	O
V_INT	int
,	O
sv_compwidth	function
}	O
,	O
{	O
"completion-prefix-display-length"	pointer
,	O
V_INT	int
,	O
sv_dispprefix	function
}	O
,	O
{	O
"completion-query-items"	pointer
,	O
V_INT	int
,	O
sv_compquery	function
}	O
,	O
{	O
"editing-mode"	pointer
,	O
V_STRING	int
,	O
sv_editmode	function
}	O
,	O
{	O
"emacs-mode-string"	pointer
,	O
V_STRING	int
,	O
sv_emacs_modestr	function
}	O
,	O
{	O
"history-size"	pointer
,	O
V_INT	int
,	O
sv_histsize	function
}	O
,	O
{	O
"isearch-terminators"	pointer
,	O
V_STRING	int
,	O
sv_isrchterm	function
}	O
,	O
{	O
"keymap"	pointer
,	O
V_STRING	int
,	O
sv_keymap	function
}	O
,	O
{	O
"keyseq-timeout"	pointer
,	O
V_INT	int
,	O
sv_seqtimeout	function
}	O
,	O
{	O
"vi-cmd-mode-string"	pointer
,	O
V_STRING	int
,	O
sv_vicmd_modestr	function
}	O
,	O
{	O
"vi-ins-mode-string"	pointer
,	O
V_STRING	int
,	O
sv_viins_modestr	function
}	O
,	O
{	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
(	O
_rl_sv_func_t	function
*	O
)	O
0	int
}	O
}	O
;	O
static	O
int	O
find_string_var	function
(	O
name	pointer
)	O
const	O
char	O
*	O
name	pointer
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
bool_to_int	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
return	O
(	O
value	pointer
==	O
0	int
||	O
*	O
value	pointer
==	O
'\0'	O
||	O
(	O
_rl_stricmp	O
(	O
value	pointer
,	O
"on"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
value	pointer
[	O
0	int
]	O
==	O
'1'	O
&&	O
value	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
;	O
}	O
char	O
*	O
rl_variable_value	function
(	O
name	pointer
)	O
const	O
char	O
*	O
name	pointer
;	O
{	O
register	O
int	O
i	int
;	O
i	int
=	O
find_boolean_var	function
(	O
name	pointer
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
return	O
(	O
*	O
boolean_varlist	array
[	O
i	int
]	O
.	O
value	pointer
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
i	int
=	O
find_string_var	function
(	O
name	pointer
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
return	O
(	O
_rl_get_string_variable_value	function
(	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_variable_bind	function
(	O
name	pointer
,	O
value	pointer
)	O
const	O
char	O
*	O
name	pointer
,	O
*	O
value	pointer
;	O
{	O
register	O
int	O
i	int
;	O
int	O
v	int
;	O
i	int
=	O
find_boolean_var	function
(	O
name	pointer
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
{	O
*	O
boolean_varlist	array
[	O
i	int
]	O
.	O
value	pointer
=	O
bool_to_int	function
(	O
value	pointer
)	O
;	O
if	O
(	O
boolean_varlist	array
[	O
i	int
]	O
.	O
flags	int
&	O
V_SPECIAL	int
)	O
hack_special_boolean_var	function
(	O
i	int
)	O
;	O
return	O
0	int
;	O
}	O
i	int
=	O
find_string_var	function
(	O
name	pointer
)	O
;	O
if	O
(	O
i	int
<	O
0	int
||	O
string_varlist	array
[	O
i	int
]	O
.	O
set_func	pointer
==	O
0	int
)	O
{	O
if	O
(	O
i	int
<	O
0	int
)	O
_rl_init_file_error	function
(	O
"%s: unknown variable name"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
v	int
=	O
(	O
*	O
string_varlist	array
[	O
i	int
]	O
.	O
set_func	pointer
)	O
(	O
value	pointer
)	O
;	O
return	O
v	int
;	O
}	O
static	O
int	O
sv_editmode	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
if	O
(	O
_rl_strnicmp	O
(	O
value	pointer
,	O
"vi"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
_rl_keymap	pointer
=	O
vi_insertion_keymap	array
;	O
rl_editing_mode	int
=	O
vi_mode	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
_rl_strnicmp	O
(	O
value	pointer
,	O
"emacs"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
_rl_keymap	pointer
=	O
emacs_standard_keymap	array
;	O
rl_editing_mode	int
=	O
emacs_mode	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_combegin	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_comment_begin	pointer
)	O
;	O
_rl_comment_begin	pointer
=	O
savestring	O
(	O
value	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_dispprefix	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
int	O
nval	int
=	O
0	int
;	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
nval	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
nval	int
=	O
0	int
;	O
}	O
_rl_completion_prefix_display_length	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_compquery	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
int	O
nval	int
=	O
100	int
;	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
nval	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
nval	int
=	O
0	int
;	O
}	O
rl_completion_query_items	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_compwidth	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
int	O
nval	int
=	O
-	O
1	int
;	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
nval	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
_rl_completion_columns	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_histsize	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
int	O
nval	int
;	O
nval	int
=	O
500	int
;	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
nval	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
{	O
unstifle_history	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
stifle_history	function
(	O
nval	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_keymap	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
Keymap	pointer
kmap	pointer
;	O
kmap	pointer
=	O
rl_get_keymap_by_name	function
(	O
value	pointer
)	O
;	O
if	O
(	O
kmap	pointer
)	O
{	O
rl_set_keymap	function
(	O
kmap	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_seqtimeout	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
int	O
nval	int
;	O
nval	int
=	O
0	int
;	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
nval	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
if	O
(	O
nval	int
<	O
0	int
)	O
nval	int
=	O
0	int
;	O
}	O
_rl_keyseq_timeout	int
=	O
nval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_bell_style	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
if	O
(	O
value	pointer
==	O
0	int
||	O
*	O
value	pointer
==	O
'\0'	O
)	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
value	pointer
,	O
"none"	pointer
)	O
==	O
0	int
||	O
_rl_stricmp	O
(	O
value	pointer
,	O
"off"	pointer
)	O
==	O
0	int
)	O
_rl_bell_preference	int
=	O
NO_BELL	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
value	pointer
,	O
"audible"	pointer
)	O
==	O
0	int
||	O
_rl_stricmp	O
(	O
value	pointer
,	O
"on"	pointer
)	O
==	O
0	int
)	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
value	pointer
,	O
"visible"	pointer
)	O
==	O
0	int
)	O
_rl_bell_preference	int
=	O
VISIBLE_BELL	int
;	O
else	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sv_isrchterm	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
int	O
beg	int
,	O
end	int
,	O
delim	int
;	O
char	O
*	O
v	int
;	O
if	O
(	O
value	pointer
==	O
0	int
)	O
return	O
1	int
;	O
v	int
=	O
savestring	O
(	O
value	pointer
)	O
;	O
FREE	O
(	O
_rl_isearch_terminators	pointer
)	O
;	O
if	O
(	O
v	int
[	O
0	int
]	O
==	O
'"'	O
||	O
v	int
[	O
0	int
]	O
==	O
'\''	O
)	O
{	O
delim	int
=	O
v	int
[	O
0	int
]	O
;	O
for	O
(	O
beg	int
=	O
end	int
=	O
1	int
;	O
v	int
[	O
end	int
]	O
&&	O
v	int
[	O
end	int
]	O
!=	O
delim	int
;	O
end	int
++	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
beg	int
=	O
end	int
=	O
0	int
;	O
v	int
[	O
end	int
]	O
&&	O
whitespace	O
(	O
v	int
[	O
end	int
]	O
)	O
==	O
0	int
;	O
end	int
++	O
)	O
;	O
}	O
v	int
[	O
end	int
]	O
=	O
'\0'	O
;	O
_rl_isearch_terminators	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
*	O
strlen	function
(	O
v	int
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	function
(	O
v	int
+	O
beg	int
,	O
_rl_isearch_terminators	pointer
,	O
&	O
end	int
)	O
;	O
_rl_isearch_terminators	pointer
[	O
end	int
]	O
=	O
'\0'	O
;	O
xfree	function
(	O
v	int
)	O
;	O
return	O
0	int
;	O
}	O
extern	O
char	O
*	O
_rl_emacs_mode_str	pointer
;	O
static	O
int	O
sv_emacs_modestr	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_emacs_mode_str	pointer
)	O
;	O
_rl_emacs_mode_str	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
*	O
strlen	function
(	O
value	pointer
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	function
(	O
value	pointer
,	O
_rl_emacs_mode_str	pointer
,	O
&	O
_rl_emacs_modestr_len	int
)	O
;	O
_rl_emacs_mode_str	pointer
[	O
_rl_emacs_modestr_len	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_emacs_mode_str	pointer
)	O
;	O
_rl_emacs_mode_str	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
)	O
;	O
_rl_emacs_mode_str	pointer
[	O
_rl_emacs_modestr_len	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	pointer
==	O
0	int
)	O
{	O
FREE	O
(	O
_rl_emacs_mode_str	pointer
)	O
;	O
_rl_emacs_mode_str	pointer
=	O
0	int
;	O
_rl_emacs_modestr_len	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_viins_modestr	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_vi_ins_mode_str	pointer
)	O
;	O
_rl_vi_ins_mode_str	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
*	O
strlen	function
(	O
value	pointer
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	function
(	O
value	pointer
,	O
_rl_vi_ins_mode_str	pointer
,	O
&	O
_rl_vi_ins_modestr_len	int
)	O
;	O
_rl_vi_ins_mode_str	pointer
[	O
_rl_vi_ins_modestr_len	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_vi_ins_mode_str	pointer
)	O
;	O
_rl_vi_ins_mode_str	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
)	O
;	O
_rl_vi_ins_mode_str	pointer
[	O
_rl_vi_ins_modestr_len	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	pointer
==	O
0	int
)	O
{	O
FREE	O
(	O
_rl_vi_ins_mode_str	pointer
)	O
;	O
_rl_vi_ins_mode_str	pointer
=	O
0	int
;	O
_rl_vi_ins_modestr_len	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
sv_vicmd_modestr	function
(	O
value	pointer
)	O
const	O
char	O
*	O
value	pointer
;	O
{	O
if	O
(	O
value	pointer
&&	O
*	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_vi_cmd_mode_str	pointer
)	O
;	O
_rl_vi_cmd_mode_str	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
*	O
strlen	function
(	O
value	pointer
)	O
+	O
1	int
)	O
;	O
rl_translate_keyseq	function
(	O
value	pointer
,	O
_rl_vi_cmd_mode_str	pointer
,	O
&	O
_rl_vi_cmd_modestr_len	int
)	O
;	O
_rl_vi_cmd_mode_str	pointer
[	O
_rl_vi_cmd_modestr_len	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	pointer
)	O
{	O
FREE	O
(	O
_rl_vi_cmd_mode_str	pointer
)	O
;	O
_rl_vi_cmd_mode_str	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
)	O
;	O
_rl_vi_cmd_mode_str	pointer
[	O
_rl_vi_cmd_modestr_len	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
value	pointer
==	O
0	int
)	O
{	O
FREE	O
(	O
_rl_vi_cmd_mode_str	pointer
)	O
;	O
_rl_vi_cmd_mode_str	pointer
=	O
0	int
;	O
_rl_vi_cmd_modestr_len	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	pointer
;	O
int	O
value	pointer
;	O
}	O
assoc_list	struct
;	O
static	O
const	O
assoc_list	struct
name_key_alist	array
[	O
]	O
=	O
{	O
{	O
"DEL"	pointer
,	O
0x7f	int
}	O
,	O
{	O
"ESC"	pointer
,	O
'\033'	O
}	O
,	O
{	O
"Escape"	pointer
,	O
'\033'	O
}	O
,	O
{	O
"LFD"	pointer
,	O
'\n'	O
}	O
,	O
{	O
"Newline"	pointer
,	O
'\n'	O
}	O
,	O
{	O
"RET"	pointer
,	O
'\r'	O
}	O
,	O
{	O
"Return"	pointer
,	O
'\r'	O
}	O
,	O
{	O
"Rubout"	pointer
,	O
0x7f	int
}	O
,	O
{	O
"SPC"	pointer
,	O
' '	O
}	O
,	O
{	O
"Space"	pointer
,	O
' '	O
}	O
,	O
{	O
"Tab"	pointer
,	O
0x09	int
}	O
,	O
{	O
(	O
char	O
*	O
)	O
0x0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
glean_key_from_name	function
(	O
name	pointer
)	O
char	O
*	O
name	pointer
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
name_key_alist	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
name_key_alist	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
(	O
name_key_alist	array
[	O
i	int
]	O
.	O
value	pointer
)	O
;	O
return	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
name	pointer
)	O
;	O
}	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
const	O
name	pointer
;	O
Keymap	pointer
map	pointer
;	O
}	O
keymap_names	array
[	O
]	O
=	O
{	O
{	O
"emacs"	pointer
,	O
emacs_standard_keymap	array
}	O
,	O
{	O
"emacs-standard"	pointer
,	O
emacs_standard_keymap	array
}	O
,	O
{	O
"emacs-meta"	pointer
,	O
emacs_meta_keymap	array
}	O
,	O
{	O
"emacs-ctlx"	pointer
,	O
emacs_ctlx_keymap	array
}	O
,	O
{	O
"vi"	pointer
,	O
vi_movement_keymap	array
}	O
,	O
{	O
"vi-move"	pointer
,	O
vi_movement_keymap	array
}	O
,	O
{	O
"vi-command"	pointer
,	O
vi_movement_keymap	array
}	O
,	O
{	O
"vi-insert"	pointer
,	O
vi_insertion_keymap	array
}	O
,	O
{	O
(	O
char	O
*	O
)	O
0x0	int
,	O
(	O
Keymap	pointer
)	O
0x0	int
}	O
}	O
;	O
Keymap	pointer
rl_get_keymap_by_name	function
(	O
name	pointer
)	O
const	O
char	O
*	O
name	pointer
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
keymap_names	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
keymap_names	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
(	O
keymap_names	array
[	O
i	int
]	O
.	O
map	pointer
)	O
;	O
return	O
(	O
(	O
Keymap	pointer
)	O
NULL	O
)	O
;	O
}	O
char	O
*	O
rl_get_keymap_name	function
(	O
map	pointer
)	O
Keymap	pointer
map	pointer
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
keymap_names	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
map	pointer
==	O
keymap_names	array
[	O
i	int
]	O
.	O
map	pointer
)	O
return	O
(	O
(	O
char	O
*	O
)	O
keymap_names	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
void	O
rl_set_keymap	function
(	O
map	pointer
)	O
Keymap	pointer
map	pointer
;	O
{	O
if	O
(	O
map	pointer
)	O
_rl_keymap	pointer
=	O
map	pointer
;	O
}	O
Keymap	pointer
rl_get_keymap	function
(	O
)	O
{	O
return	O
(	O
_rl_keymap	pointer
)	O
;	O
}	O
void	O
rl_set_keymap_from_edit_mode	function
(	O
)	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
_rl_keymap	pointer
=	O
emacs_standard_keymap	array
;	O
else	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
_rl_keymap	pointer
=	O
vi_insertion_keymap	array
;	O
}	O
char	O
*	O
rl_get_keymap_name_from_edit_mode	function
(	O
)	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
return	O
"emacs"	pointer
;	O
else	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
return	O
"vi"	pointer
;	O
else	O
return	O
"none"	pointer
;	O
}	O
void	O
rl_list_funmap_names	function
(	O
)	O
{	O
register	O
int	O
i	int
;	O
const	O
char	O
*	O
*	O
funmap_names	pointer
;	O
funmap_names	pointer
=	O
rl_funmap_names	function
(	O
)	O
;	O
if	O
(	O
!	O
funmap_names	pointer
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
funmap_names	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"%s\n"	pointer
,	O
funmap_names	pointer
[	O
i	int
]	O
)	O
;	O
xfree	function
(	O
funmap_names	pointer
)	O
;	O
}	O
static	O
char	O
*	O
_rl_get_keyname	function
(	O
key	int
)	O
int	O
key	int
;	O
{	O
char	O
*	O
keyname	pointer
;	O
int	O
i	int
,	O
c	int
;	O
keyname	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
8	int
)	O
;	O
c	int
=	O
key	int
;	O
if	O
(	O
c	int
==	O
ESC	O
)	O
{	O
keyname	pointer
[	O
0	int
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
1	int
]	O
=	O
'e'	O
;	O
keyname	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
return	O
keyname	pointer
;	O
}	O
if	O
(	O
key	int
==	O
RUBOUT	int
)	O
{	O
keyname	pointer
[	O
0	int
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
1	int
]	O
=	O
'C'	O
;	O
keyname	pointer
[	O
2	int
]	O
=	O
'-'	O
;	O
keyname	pointer
[	O
3	int
]	O
=	O
'?'	O
;	O
keyname	pointer
[	O
4	int
]	O
=	O
'\0'	O
;	O
return	O
keyname	pointer
;	O
}	O
i	int
=	O
0	int
;	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
)	O
{	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
'C'	O
;	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
'-'	O
;	O
c	int
=	O
_rl_to_lower	function
(	O
UNCTRL	O
(	O
c	int
)	O
)	O
;	O
}	O
if	O
(	O
c	int
>=	O
128	int
&&	O
c	int
<=	O
159	int
)	O
{	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
'2'	O
;	O
c	int
-=	O
128	int
;	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
(	O
c	int
/	O
8	int
)	O
+	O
'0'	O
;	O
c	int
=	O
(	O
c	int
%	O
8	int
)	O
+	O
'0'	O
;	O
}	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
i	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
keyname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
keyname	pointer
;	O
}	O
char	O
*	O
*	O
rl_invoking_keyseqs_in_map	function
(	O
function	pointer
,	O
map	pointer
)	O
rl_command_func_t	function
*	O
function	pointer
;	O
Keymap	pointer
map	pointer
;	O
{	O
register	O
int	O
key	int
;	O
char	O
*	O
*	O
result	int
;	O
int	O
result_index	int
,	O
result_size	int
;	O
result	int
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
result_index	int
=	O
result_size	int
=	O
0	int
;	O
for	O
(	O
key	int
=	O
0	int
;	O
key	int
<	O
KEYMAP_SIZE	int
;	O
key	int
++	O
)	O
{	O
switch	O
(	O
map	pointer
[	O
key	int
]	O
.	O
type	enum
)	O
{	O
case	O
ISMACR	int
:	O
case	O
ISFUNC	int
:	O
if	O
(	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
==	O
function	pointer
)	O
{	O
char	O
*	O
keyname	pointer
;	O
keyname	pointer
=	O
_rl_get_keyname	function
(	O
key	int
)	O
;	O
if	O
(	O
result_index	int
+	O
2	int
>	O
result_size	int
)	O
{	O
result_size	int
+=	O
10	int
;	O
result	int
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
result	int
,	O
result_size	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
result	int
[	O
result_index	int
++	O
]	O
=	O
keyname	pointer
;	O
result	int
[	O
result_index	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
break	O
;	O
case	O
ISKMAP	int
:	O
{	O
char	O
*	O
*	O
seqs	pointer
;	O
register	O
int	O
i	int
;	O
if	O
(	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
)	O
seqs	pointer
=	O
rl_invoking_keyseqs_in_map	function
(	O
function	pointer
,	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
key	int
)	O
)	O
;	O
else	O
break	O
;	O
if	O
(	O
seqs	pointer
==	O
0	int
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
seqs	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
keyname	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
6	int
+	O
strlen	function
(	O
seqs	pointer
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
key	int
==	O
ESC	O
)	O
{	O
if	O
(	O
_rl_convert_meta_chars_to_ascii	int
&&	O
map	pointer
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
sprintf	function
(	O
keyname	pointer
,	O
"\\M-"	pointer
)	O
;	O
else	O
sprintf	function
(	O
keyname	pointer
,	O
"\\e"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
key	int
)	O
)	O
sprintf	function
(	O
keyname	pointer
,	O
"\\C-%c"	pointer
,	O
_rl_to_lower	function
(	O
UNCTRL	O
(	O
key	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
RUBOUT	int
)	O
sprintf	function
(	O
keyname	pointer
,	O
"\\C-?"	pointer
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'\\'	O
||	O
key	int
==	O
'"'	O
)	O
{	O
keyname	pointer
[	O
0	int
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
1	int
]	O
=	O
(	O
char	O
)	O
key	int
;	O
keyname	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
keyname	pointer
[	O
0	int
]	O
=	O
(	O
char	O
)	O
key	int
;	O
keyname	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
strcat	function
(	O
keyname	pointer
,	O
seqs	pointer
[	O
i	int
]	O
)	O
;	O
xfree	function
(	O
seqs	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
result_index	int
+	O
2	int
>	O
result_size	int
)	O
{	O
result_size	int
+=	O
10	int
;	O
result	int
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
result	int
,	O
result_size	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
result	int
[	O
result_index	int
++	O
]	O
=	O
keyname	pointer
;	O
result	int
[	O
result_index	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
xfree	function
(	O
seqs	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
(	O
result	int
)	O
;	O
}	O
char	O
*	O
*	O
rl_invoking_keyseqs	function
(	O
function	pointer
)	O
rl_command_func_t	function
*	O
function	pointer
;	O
{	O
return	O
(	O
rl_invoking_keyseqs_in_map	function
(	O
function	pointer
,	O
_rl_keymap	pointer
)	O
)	O
;	O
}	O
void	O
rl_function_dumper	function
(	O
print_readably	int
)	O
int	O
print_readably	int
;	O
{	O
register	O
int	O
i	int
;	O
const	O
char	O
*	O
*	O
names	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
names	pointer
=	O
rl_funmap_names	function
(	O
)	O
;	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
name	pointer
=	O
names	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
rl_command_func_t	function
*	O
function	pointer
;	O
char	O
*	O
*	O
invokers	pointer
;	O
function	pointer
=	O
rl_named_function	function
(	O
name	pointer
)	O
;	O
invokers	pointer
=	O
rl_invoking_keyseqs_in_map	function
(	O
function	pointer
,	O
_rl_keymap	pointer
)	O
;	O
if	O
(	O
print_readably	int
)	O
{	O
if	O
(	O
!	O
invokers	pointer
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"# %s (not bound)\n"	pointer
,	O
name	pointer
)	O
;	O
else	O
{	O
register	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
invokers	pointer
[	O
j	int
]	O
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\"%s\": %s\n"	pointer
,	O
invokers	pointer
[	O
j	int
]	O
,	O
name	pointer
)	O
;	O
xfree	function
(	O
invokers	pointer
[	O
j	int
]	O
)	O
;	O
}	O
xfree	function
(	O
invokers	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
invokers	pointer
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"%s is not bound to any keys\n"	pointer
,	O
name	pointer
)	O
;	O
else	O
{	O
register	O
int	O
j	int
;	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"%s can be found on "	pointer
,	O
name	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
invokers	pointer
[	O
j	int
]	O
&&	O
j	int
<	O
5	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\"%s\"%s"	pointer
,	O
invokers	pointer
[	O
j	int
]	O
,	O
invokers	pointer
[	O
j	int
+	O
1	int
]	O
?	O
", "	pointer
:	O
".\n"	pointer
)	O
;	O
}	O
if	O
(	O
j	int
==	O
5	int
&&	O
invokers	pointer
[	O
j	int
]	O
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"...\n"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
invokers	pointer
[	O
j	int
]	O
;	O
j	int
++	O
)	O
xfree	function
(	O
invokers	pointer
[	O
j	int
]	O
)	O
;	O
xfree	function
(	O
invokers	pointer
)	O
;	O
}	O
}	O
}	O
xfree	function
(	O
names	pointer
)	O
;	O
}	O
int	O
rl_dump_functions	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_dispatching	int
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\r\n"	pointer
)	O
;	O
rl_function_dumper	function
(	O
rl_explicit_arg	int
)	O
;	O
rl_on_new_line	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_macro_dumper_internal	function
(	O
print_readably	int
,	O
map	pointer
,	O
prefix	pointer
)	O
int	O
print_readably	int
;	O
Keymap	pointer
map	pointer
;	O
char	O
*	O
prefix	pointer
;	O
{	O
register	O
int	O
key	int
;	O
char	O
*	O
keyname	pointer
,	O
*	O
out	pointer
;	O
int	O
prefix_len	int
;	O
for	O
(	O
key	int
=	O
0	int
;	O
key	int
<	O
KEYMAP_SIZE	int
;	O
key	int
++	O
)	O
{	O
switch	O
(	O
map	pointer
[	O
key	int
]	O
.	O
type	enum
)	O
{	O
case	O
ISMACR	int
:	O
keyname	pointer
=	O
_rl_get_keyname	function
(	O
key	int
)	O
;	O
out	pointer
=	O
_rl_untranslate_macro_value	function
(	O
(	O
char	O
*	O
)	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
,	O
0	int
)	O
;	O
if	O
(	O
print_readably	int
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\"%s%s\": \"%s\"\n"	pointer
,	O
prefix	pointer
?	O
prefix	pointer
:	O
""	pointer
,	O
keyname	pointer
,	O
out	pointer
?	O
out	pointer
:	O
""	pointer
)	O
;	O
else	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"%s%s outputs %s\n"	pointer
,	O
prefix	pointer
?	O
prefix	pointer
:	O
""	pointer
,	O
keyname	pointer
,	O
out	pointer
?	O
out	pointer
:	O
""	pointer
)	O
;	O
xfree	function
(	O
keyname	pointer
)	O
;	O
xfree	function
(	O
out	pointer
)	O
;	O
break	O
;	O
case	O
ISFUNC	int
:	O
break	O
;	O
case	O
ISKMAP	int
:	O
prefix_len	int
=	O
prefix	pointer
?	O
strlen	function
(	O
prefix	pointer
)	O
:	O
0	int
;	O
if	O
(	O
key	int
==	O
ESC	O
)	O
{	O
keyname	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
3	int
+	O
prefix_len	int
)	O
;	O
if	O
(	O
prefix	pointer
)	O
strcpy	function
(	O
keyname	pointer
,	O
prefix	pointer
)	O
;	O
keyname	pointer
[	O
prefix_len	int
]	O
=	O
'\\'	O
;	O
keyname	pointer
[	O
prefix_len	int
+	O
1	int
]	O
=	O
'e'	O
;	O
keyname	pointer
[	O
prefix_len	int
+	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
keyname	pointer
=	O
_rl_get_keyname	function
(	O
key	int
)	O
;	O
if	O
(	O
prefix	pointer
)	O
{	O
out	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
keyname	pointer
)	O
+	O
prefix_len	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
out	pointer
,	O
prefix	pointer
)	O
;	O
strcpy	function
(	O
out	pointer
+	O
prefix_len	int
,	O
keyname	pointer
)	O
;	O
xfree	function
(	O
keyname	pointer
)	O
;	O
keyname	pointer
=	O
out	pointer
;	O
}	O
}	O
_rl_macro_dumper_internal	function
(	O
print_readably	int
,	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
key	int
)	O
,	O
keyname	pointer
)	O
;	O
xfree	function
(	O
keyname	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
rl_macro_dumper	function
(	O
print_readably	int
)	O
int	O
print_readably	int
;	O
{	O
_rl_macro_dumper_internal	function
(	O
print_readably	int
,	O
_rl_keymap	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
int	O
rl_dump_macros	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_dispatching	int
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\r\n"	pointer
)	O
;	O
rl_macro_dumper	function
(	O
rl_explicit_arg	int
)	O
;	O
rl_on_new_line	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
char	O
*	O
_rl_get_string_variable_value	function
(	O
name	pointer
)	O
const	O
char	O
*	O
name	pointer
;	O
{	O
static	O
char	O
numbuf	array
[	O
32	int
]	O
;	O
char	O
*	O
ret	pointer
;	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"bell-style"	pointer
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
_rl_bell_preference	int
)	O
{	O
case	O
NO_BELL	int
:	O
return	O
"none"	pointer
;	O
case	O
VISIBLE_BELL	int
:	O
return	O
"visible"	pointer
;	O
case	O
AUDIBLE_BELL	int
:	O
default	O
:	O
return	O
"audible"	pointer
;	O
}	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"comment-begin"	pointer
)	O
==	O
0	int
)	O
return	O
(	O
_rl_comment_begin	pointer
?	O
_rl_comment_begin	pointer
:	O
RL_COMMENT_BEGIN_DEFAULT	pointer
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"completion-display-width"	pointer
)	O
==	O
0	int
)	O
{	O
sprintf	function
(	O
numbuf	array
,	O
"%d"	pointer
,	O
_rl_completion_columns	int
)	O
;	O
return	O
(	O
numbuf	array
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"completion-prefix-display-length"	pointer
)	O
==	O
0	int
)	O
{	O
sprintf	function
(	O
numbuf	array
,	O
"%d"	pointer
,	O
_rl_completion_prefix_display_length	int
)	O
;	O
return	O
(	O
numbuf	array
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"completion-query-items"	pointer
)	O
==	O
0	int
)	O
{	O
sprintf	function
(	O
numbuf	array
,	O
"%d"	pointer
,	O
rl_completion_query_items	int
)	O
;	O
return	O
(	O
numbuf	array
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"editing-mode"	pointer
)	O
==	O
0	int
)	O
return	O
(	O
rl_get_keymap_name_from_edit_mode	function
(	O
)	O
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"history-size"	pointer
)	O
==	O
0	int
)	O
{	O
sprintf	function
(	O
numbuf	array
,	O
"%d"	pointer
,	O
history_is_stifled	function
(	O
)	O
?	O
history_max_entries	int
:	O
0	int
)	O
;	O
return	O
(	O
numbuf	array
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"isearch-terminators"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
_rl_isearch_terminators	pointer
==	O
0	int
)	O
return	O
0	int
;	O
ret	pointer
=	O
_rl_untranslate_macro_value	function
(	O
_rl_isearch_terminators	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	pointer
)	O
{	O
strncpy	function
(	O
numbuf	array
,	O
ret	pointer
,	O
sizeof	O
(	O
numbuf	array
)	O
-	O
1	int
)	O
;	O
xfree	function
(	O
ret	pointer
)	O
;	O
numbuf	array
[	O
sizeof	O
(	O
numbuf	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
numbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
numbuf	array
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"keymap"	pointer
)	O
==	O
0	int
)	O
{	O
ret	pointer
=	O
rl_get_keymap_name	function
(	O
_rl_keymap	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
0	int
)	O
ret	pointer
=	O
rl_get_keymap_name_from_edit_mode	function
(	O
)	O
;	O
return	O
(	O
ret	pointer
?	O
ret	pointer
:	O
"none"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"keyseq-timeout"	pointer
)	O
==	O
0	int
)	O
{	O
sprintf	function
(	O
numbuf	array
,	O
"%d"	pointer
,	O
_rl_keyseq_timeout	int
)	O
;	O
return	O
(	O
numbuf	array
)	O
;	O
}	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"emacs-mode-string"	pointer
)	O
==	O
0	int
)	O
return	O
(	O
_rl_emacs_mode_str	pointer
?	O
_rl_emacs_mode_str	pointer
:	O
RL_EMACS_MODESTR_DEFAULT	pointer
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"vi-cmd-mode-string"	pointer
)	O
==	O
0	int
)	O
return	O
(	O
_rl_vi_cmd_mode_str	pointer
?	O
_rl_vi_cmd_mode_str	pointer
:	O
RL_VI_CMD_MODESTR_DEFAULT	pointer
)	O
;	O
else	O
if	O
(	O
_rl_stricmp	O
(	O
name	pointer
,	O
"vi-ins-mode-string"	pointer
)	O
==	O
0	int
)	O
return	O
(	O
_rl_vi_ins_mode_str	pointer
?	O
_rl_vi_ins_mode_str	pointer
:	O
RL_VI_INS_MODESTR_DEFAULT	pointer
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
rl_variable_dumper	function
(	O
print_readably	int
)	O
int	O
print_readably	int
;	O
{	O
int	O
i	int
;	O
char	O
*	O
v	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
boolean_varlist	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
{	O
if	O
(	O
print_readably	int
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"set %s %s\n"	pointer
,	O
boolean_varlist	array
[	O
i	int
]	O
.	O
name	pointer
,	O
*	O
boolean_varlist	array
[	O
i	int
]	O
.	O
value	pointer
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
else	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"%s is set to `%s'\n"	pointer
,	O
boolean_varlist	array
[	O
i	int
]	O
.	O
name	pointer
,	O
*	O
boolean_varlist	array
[	O
i	int
]	O
.	O
value	pointer
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
{	O
v	int
=	O
_rl_get_string_variable_value	function
(	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
v	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
print_readably	int
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"set %s %s\n"	pointer
,	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
,	O
v	int
)	O
;	O
else	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"%s is set to `%s'\n"	pointer
,	O
string_varlist	array
[	O
i	int
]	O
.	O
name	pointer
,	O
v	int
)	O
;	O
}	O
}	O
int	O
rl_dump_variables	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_dispatching	int
)	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"\r\n"	pointer
)	O
;	O
rl_variable_dumper	function
(	O
rl_explicit_arg	int
)	O
;	O
rl_on_new_line	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
substring_member_of_array	function
(	O
string	pointer
,	O
array	pointer
)	O
const	O
char	O
*	O
string	pointer
;	O
const	O
char	O
*	O
const	O
*	O
array	pointer
;	O
{	O
while	O
(	O
*	O
array	pointer
)	O
{	O
if	O
(	O
_rl_strindex	function
(	O
string	pointer
,	O
*	O
array	pointer
)	O
)	O
return	O
(	O
1	int
)	O
;	O
array	pointer
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O