int	O
*	O
register_fresh_stat	function
(	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
*	O
p	pointer
)	O
{	O
int	O
*	O
ret	pointer
;	O
ret	pointer
=	O
xdr_decode_fattr	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn_stat	O
)	O
;	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
=	O
mapped_time	pointer
->	O
seconds	O
;	O
switch	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
)	O
{	O
case	O
NOT_POSSIBLE	int
:	O
case	O
POSSIBLE	int
:	O
break	O
;	O
case	O
SYMLINK	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_size	long
=	O
strlen	O
(	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFLNK	O
)	O
;	O
break	O
;	O
case	O
CHRDEV	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_rdev	long
=	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
indexes	long
;	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFCHR	O
)	O
;	O
break	O
;	O
case	O
BLKDEV	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_rdev	long
=	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
indexes	long
;	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFBLK	O
)	O
;	O
break	O
;	O
case	O
FIFO	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFIFO	O
)	O
;	O
break	O
;	O
case	O
SOCK	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
=	O
(	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
~	O
S_IFMT	O
)	O
|	O
S_IFSOCK	O
)	O
;	O
break	O
;	O
}	O
np	pointer
->	O
nn_stat	O
.	O
st_fsid	O
=	O
getpid	function
(	O
)	O
;	O
np	pointer
->	O
nn_stat	O
.	O
st_fstype	O
=	O
FSTYPE_NFS	O
;	O
np	pointer
->	O
nn_stat	O
.	O
st_gen	O
=	O
0	int
;	O
np	pointer
->	O
nn_stat	O
.	O
st_author	O
=	O
np	pointer
->	O
nn_stat	O
.	O
st_uid	int
;	O
np	pointer
->	O
nn_stat	O
.	O
st_flags	O
=	O
0	int
;	O
np	pointer
->	O
nn_translated	O
=	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
S_IFMT	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
*	O
process_returned_stat	function
(	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
mod	int
)	O
{	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
return	O
register_fresh_stat	function
(	O
np	pointer
,	O
p	pointer
)	O
;	O
else	O
{	O
int	O
attrs_exist	int
;	O
attrs_exist	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
attrs_exist	int
)	O
p	pointer
=	O
register_fresh_stat	function
(	O
np	pointer
,	O
p	pointer
)	O
;	O
else	O
if	O
(	O
mod	int
)	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
return	O
p	pointer
;	O
}	O
}	O
int	O
*	O
process_wcc_stat	function
(	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
mod	int
)	O
{	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
return	O
register_fresh_stat	function
(	O
np	pointer
,	O
p	pointer
)	O
;	O
else	O
{	O
int	O
attrs_exist	int
;	O
attrs_exist	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
attrs_exist	int
)	O
{	O
p	pointer
+=	O
2	int
*	O
sizeof	O
(	O
int	O
)	O
;	O
p	pointer
+=	O
2	int
*	O
sizeof	O
(	O
int	O
)	O
;	O
p	pointer
+=	O
2	int
*	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
return	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
mod	int
)	O
;	O
}	O
}	O
error_t	int
netfs_validate_stat	function
(	O
struct	O
node	O
*	O
np	pointer
,	O
struct	O
iouser	O
*	O
cred	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
if	O
(	O
mapped_time	pointer
->	O
seconds	O
-	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
<	O
stat_timeout	int
)	O
return	O
0	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_GETATTR	O
(	O
protocol_version	int
)	O
,	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
register_fresh_stat	function
(	O
np	pointer
,	O
p	pointer
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_chown	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
gid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_sattr_ids	function
(	O
p	pointer
,	O
uid	int
,	O
gid	int
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_chauthor	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
rp	pointer
,	O
uid_t	int
author	int
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
error_t	int
netfs_attempt_chmod	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
mode_t	int
mode	int
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
if	O
(	O
(	O
mode	int
&	O
S_IFMT	O
)	O
!=	O
0	int
)	O
{	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
(	O
mode	int
&	O
S_IFMT	O
)	O
!=	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
{	O
char	O
*	O
f	pointer
=	O
0	int
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
NOT_POSSIBLE	int
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
SYMLINK	int
)	O
f	pointer
=	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
;	O
switch	O
(	O
mode	int
&	O
S_IFMT	O
)	O
{	O
default	O
:	O
return	O
EOPNOTSUPP	int
;	O
case	O
S_IFIFO	O
:	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
FIFO	int
;	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
break	O
;	O
case	O
S_IFSOCK	O
:	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
SOCK	int
;	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
}	O
if	O
(	O
f	pointer
)	O
free	function
(	O
f	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_sattr_mode	function
(	O
p	pointer
,	O
mode	int
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_chflags	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
flags	int
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
error_t	int
netfs_attempt_utimes	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
struct	O
timespec	struct
*	O
atime	pointer
,	O
struct	O
timespec	struct
*	O
mtime	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
struct	O
timeval	struct
tv	struct
;	O
struct	O
timespec	struct
current	struct
;	O
if	O
(	O
!	O
atime	pointer
||	O
!	O
mtime	pointer
)	O
{	O
maptime_read	function
(	O
mapped_time	pointer
,	O
&	O
tv	struct
)	O
;	O
current	struct
.	O
tv_sec	long
=	O
tv	struct
.	O
tv_sec	long
;	O
current	struct
.	O
tv_nsec	long
=	O
tv	struct
.	O
tv_usec	long
*	O
1000	int
;	O
}	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_sattr_times	function
(	O
p	pointer
,	O
atime	pointer
?	O
:	O
&	O
current	struct
,	O
mtime	pointer
?	O
:	O
&	O
current	struct
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_set_size	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
off_t	long
size	long
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_SETATTR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_sattr_size	function
(	O
p	pointer
,	O
size	long
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
if	O
(	O
err	int
==	O
EACCES	int
)	O
{	O
int	O
error	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
np	pointer
->	O
nn_stat	O
.	O
st_size	long
==	O
size	long
)	O
err	int
=	O
0	int
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_statfs	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
struct	O
statfs	O
*	O
st	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFS2PROC_STATFS	int
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
p	pointer
++	O
;	O
st	pointer
->	O
f_bsize	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
st	pointer
->	O
f_blocks	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
st	pointer
->	O
f_bfree	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
st	pointer
->	O
f_bavail	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
st	pointer
->	O
f_type	O
=	O
FSTYPE_NFS	O
;	O
st	pointer
->	O
f_files	O
=	O
0	int
;	O
st	pointer
->	O
f_ffree	O
=	O
0	int
;	O
st	pointer
->	O
f_fsid	O
=	O
getpid	function
(	O
)	O
;	O
st	pointer
->	O
f_namelen	O
=	O
0	int
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_sync	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
wait	int
)	O
{	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_syncfs	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
int	O
wait	int
)	O
{	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_read	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
off_t	long
offset	long
,	O
size_t	long
*	O
len	long
,	O
void	O
*	O
data	array
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
size_t	long
trans_len	long
;	O
error_t	int
err	int
;	O
size_t	long
amt	long
,	O
thisamt	long
;	O
int	O
eof	int
;	O
for	O
(	O
amt	long
=	O
*	O
len	long
;	O
amt	long
;	O
)	O
{	O
thisamt	long
=	O
amt	long
;	O
if	O
(	O
thisamt	long
>	O
read_size	int
)	O
thisamt	long
=	O
read_size	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_READ	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
offset	long
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
thisamt	long
)	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
trans_len	long
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
trans_len	long
>	O
thisamt	long
)	O
trans_len	long
=	O
thisamt	long
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
eof	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
else	O
eof	int
=	O
(	O
trans_len	long
<	O
thisamt	long
)	O
;	O
memcpy	O
(	O
data	array
,	O
p	pointer
,	O
trans_len	long
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
data	array
+=	O
trans_len	long
;	O
offset	long
+=	O
trans_len	long
;	O
amt	long
-=	O
trans_len	long
;	O
if	O
(	O
eof	int
)	O
{	O
*	O
len	long
-=	O
amt	long
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_write	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
off_t	long
offset	long
,	O
size_t	long
*	O
len	long
,	O
void	O
*	O
data	array
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
size_t	long
amt	long
,	O
thisamt	long
;	O
size_t	long
count	long
;	O
for	O
(	O
amt	long
=	O
*	O
len	long
;	O
amt	long
;	O
)	O
{	O
thisamt	long
=	O
amt	long
;	O
if	O
(	O
thisamt	long
>	O
write_size	int
)	O
thisamt	long
=	O
write_size	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_WRITE	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
thisamt	long
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
offset	long
)	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
FILE_SYNC	int
)	O
;	O
p	pointer
=	O
xdr_encode_data	function
(	O
p	pointer
,	O
data	array
,	O
thisamt	long
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
||	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
count	long
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
p	pointer
++	O
;	O
p	pointer
+=	O
NFS3_WRITEVERFSIZE	int
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
else	O
count	long
=	O
thisamt	long
;	O
amt	long
-=	O
count	long
;	O
data	array
+=	O
count	long
;	O
offset	long
+=	O
count	long
;	O
}	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
if	O
(	O
err	int
==	O
EINTR	int
&&	O
amt	long
!=	O
*	O
len	long
)	O
{	O
*	O
len	long
-=	O
amt	long
;	O
return	O
0	int
;	O
}	O
if	O
(	O
err	int
)	O
{	O
*	O
len	long
=	O
0	int
;	O
return	O
err	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	int
verify_nonexistent	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
assert	function
(	O
protocol_version	int
==	O
2	int
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_LOOKUP	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
return	O
EEXIST	int
;	O
else	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_lookup	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
name	pointer
,	O
struct	O
node	O
*	O
*	O
newnp	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
char	O
dirhandle	array
[	O
NFS3_FHSIZE	int
]	O
;	O
size_t	long
dirlen	long
;	O
*	O
newnp	pointer
=	O
check_lookup_cache	function
(	O
np	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
*	O
newnp	pointer
)	O
{	O
if	O
(	O
*	O
newnp	pointer
==	O
(	O
struct	O
node	O
*	O
)	O
-	O
1	int
)	O
{	O
*	O
newnp	pointer
=	O
0	int
;	O
return	O
ENOENT	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_LOOKUP	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
dirlen	long
=	O
np	pointer
->	O
nn	O
->	O
handle	struct
.	O
size	long
;	O
memcpy	O
(	O
dirhandle	array
,	O
np	pointer
->	O
nn	O
->	O
handle	struct
.	O
data	array
,	O
dirlen	long
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
p	pointer
=	O
xdr_decode_fhandle	function
(	O
p	pointer
,	O
newnp	pointer
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
*	O
newnp	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
err	int
)	O
*	O
newnp	pointer
=	O
0	int
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
if	O
(	O
*	O
newnp	pointer
)	O
pthread_mutex_unlock	function
(	O
&	O
(	O
*	O
newnp	pointer
)	O
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
*	O
newnp	pointer
)	O
pthread_mutex_lock	function
(	O
&	O
(	O
*	O
newnp	pointer
)	O
->	O
lock	O
)	O
;	O
}	O
}	O
else	O
*	O
newnp	pointer
=	O
0	int
;	O
enter_lookup_cache	function
(	O
dirhandle	array
,	O
dirlen	long
,	O
*	O
newnp	pointer
,	O
name	pointer
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_mkdir	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
name	pointer
,	O
mode_t	int
mode	int
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
uid_t	int
owner	int
;	O
struct	O
node	O
*	O
newnp	pointer
;	O
if	O
(	O
cred	pointer
->	O
uids	O
->	O
num	O
)	O
owner	int
=	O
cred	pointer
->	O
uids	O
->	O
ids	O
[	O
0	int
]	O
;	O
else	O
{	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
owner	int
=	O
err	int
?	O
0	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_uid	int
;	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
}	O
purge_lookup_cache	function
(	O
np	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_MKDIR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
p	pointer
=	O
xdr_encode_create_state	function
(	O
p	pointer
,	O
mode	int
,	O
owner	int
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
p	pointer
=	O
xdr_decode_fhandle	function
(	O
p	pointer
,	O
&	O
newnp	pointer
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
newnp	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
if	O
(	O
!	O
netfs_validate_stat	function
(	O
newnp	pointer
,	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
)	O
&&	O
newnp	pointer
->	O
nn_stat	O
.	O
st_uid	int
!=	O
owner	int
)	O
netfs_attempt_chown	function
(	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
newnp	pointer
,	O
owner	int
,	O
newnp	pointer
->	O
nn_stat	O
.	O
st_gid	int
)	O
;	O
netfs_nput	function
(	O
newnp	pointer
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_rmdir	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
purge_lookup_cache	function
(	O
np	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_RMDIR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_link	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
dir	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
excl	int
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
excl	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
netfs_attempt_unlink	function
(	O
cred	pointer
,	O
dir	pointer
,	O
name	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
switch	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
)	O
{	O
case	O
POSSIBLE	int
:	O
case	O
NOT_POSSIBLE	int
:	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_LINK	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache	function
(	O
dir	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
break	O
;	O
case	O
SYMLINK	int
:	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_SYMLINK	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
p	pointer
=	O
xdr_encode_sattr_stat	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn_stat	O
)	O
;	O
}	O
else	O
{	O
p	pointer
=	O
xdr_encode_sattr_stat	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn_stat	O
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache	function
(	O
dir	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
protocol_version	int
==	O
2	int
&&	O
!	O
err	int
)	O
{	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_LOOKUP	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
recache_handle	function
(	O
p	pointer
,	O
np	pointer
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
}	O
if	O
(	O
err	int
)	O
err	int
=	O
EGRATUITOUS	O
;	O
}	O
else	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
recache_handle	function
(	O
p	pointer
,	O
np	pointer
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
p	pointer
=	O
process_wcc_stat	function
(	O
dir	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
else	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
else	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
break	O
;	O
case	O
CHRDEV	int
:	O
case	O
BLKDEV	int
:	O
case	O
FIFO	int
:	O
case	O
SOCK	int
:	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
verify_nonexistent	function
(	O
cred	pointer
,	O
dir	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_CREATE	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
p	pointer
=	O
xdr_encode_sattr_stat	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn_stat	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache	function
(	O
dir	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
recache_handle	function
(	O
p	pointer
,	O
np	pointer
)	O
;	O
register_fresh_stat	function
(	O
np	pointer
,	O
p	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
}	O
else	O
{	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFS3PROC_MKNOD	int
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
hurd_mode_to_nfs_type	function
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
)	O
)	O
;	O
p	pointer
=	O
xdr_encode_sattr_stat	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn_stat	O
)	O
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
BLKDEV	int
||	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
CHRDEV	int
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
major	function
(	O
np	pointer
->	O
nn_stat	O
.	O
st_rdev	long
)	O
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
minor	function
(	O
np	pointer
->	O
nn_stat	O
.	O
st_rdev	long
)	O
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache	function
(	O
dir	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
recache_handle	function
(	O
p	pointer
,	O
np	pointer
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
process_wcc_stat	function
(	O
dir	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
SYMLINK	int
)	O
free	function
(	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
NOT_POSSIBLE	int
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dead_dir	pointer
)	O
{	O
struct	O
node	O
*	O
dir	pointer
=	O
np	pointer
->	O
nn	O
->	O
dead_dir	pointer
;	O
char	O
*	O
name	pointer
=	O
np	pointer
->	O
nn	O
->	O
dead_name	pointer
;	O
np	pointer
->	O
nn	O
->	O
dead_dir	pointer
=	O
0	int
;	O
np	pointer
->	O
nn	O
->	O
dead_name	pointer
=	O
0	int
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
netfs_attempt_unlink	function
(	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
dir	pointer
,	O
name	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
else	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_mkfile	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
dir	pointer
,	O
mode_t	int
mode	int
,	O
struct	O
node	O
*	O
*	O
newnp	pointer
)	O
{	O
error_t	int
err	int
;	O
char	O
*	O
name	pointer
;	O
static	O
int	O
n	int
=	O
0	int
;	O
name	pointer
=	O
malloc	O
(	O
50	int
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
ENOMEM	int
;	O
do	O
{	O
sprintf	O
(	O
name	pointer
,	O
".nfstmpgnu.%d"	pointer
,	O
n	int
++	O
)	O
;	O
err	int
=	O
netfs_attempt_create_file	function
(	O
cred	pointer
,	O
dir	pointer
,	O
name	pointer
,	O
mode	int
,	O
newnp	pointer
)	O
;	O
if	O
(	O
err	int
==	O
EEXIST	int
)	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
while	O
(	O
err	int
==	O
EEXIST	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
err	int
;	O
}	O
assert	function
(	O
!	O
(	O
*	O
newnp	pointer
)	O
->	O
nn	O
->	O
dead_dir	pointer
)	O
;	O
assert	function
(	O
!	O
(	O
*	O
newnp	pointer
)	O
->	O
nn	O
->	O
dead_name	pointer
)	O
;	O
netfs_nref	function
(	O
dir	pointer
)	O
;	O
(	O
*	O
newnp	pointer
)	O
->	O
nn	O
->	O
dead_dir	pointer
=	O
dir	pointer
;	O
(	O
*	O
newnp	pointer
)	O
->	O
nn	O
->	O
dead_name	pointer
=	O
name	pointer
;	O
if	O
(	O
(	O
*	O
newnp	pointer
)	O
->	O
nn	O
->	O
dtrans	enum
==	O
NOT_POSSIBLE	int
)	O
(	O
*	O
newnp	pointer
)	O
->	O
nn	O
->	O
dtrans	enum
=	O
POSSIBLE	int
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_create_file	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
name	pointer
,	O
mode_t	int
mode	int
,	O
struct	O
node	O
*	O
*	O
newnp	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
uid_t	int
owner	int
;	O
if	O
(	O
cred	pointer
->	O
uids	O
->	O
num	O
)	O
owner	int
=	O
cred	pointer
->	O
uids	O
->	O
ids	O
[	O
0	int
]	O
;	O
else	O
{	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
owner	int
=	O
err	int
?	O
0	int
:	O
np	pointer
->	O
nn_stat	O
.	O
st_uid	int
;	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
}	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
err	int
=	O
verify_nonexistent	function
(	O
cred	pointer
,	O
np	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
}	O
purge_lookup_cache	function
(	O
np	pointer
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_CREATE	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
int	O
verf	int
=	O
*	O
(	O
int	O
*	O
)	O
rpcbuf	pointer
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
ntohl	function
(	O
EXCLUSIVE	int
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
ntohl	function
(	O
verf	int
)	O
;	O
p	pointer
++	O
;	O
}	O
else	O
p	pointer
=	O
xdr_encode_create_state	function
(	O
p	pointer
,	O
mode	int
,	O
owner	int
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
p	pointer
=	O
xdr_decode_fhandle	function
(	O
p	pointer
,	O
newnp	pointer
)	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
*	O
newnp	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
err	int
)	O
*	O
newnp	pointer
=	O
0	int
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
if	O
(	O
*	O
newnp	pointer
)	O
pthread_mutex_unlock	function
(	O
&	O
(	O
*	O
newnp	pointer
)	O
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
process_wcc_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
*	O
newnp	pointer
)	O
pthread_mutex_lock	function
(	O
&	O
(	O
*	O
newnp	pointer
)	O
->	O
lock	O
)	O
;	O
}	O
if	O
(	O
*	O
newnp	pointer
&&	O
!	O
netfs_validate_stat	function
(	O
*	O
newnp	pointer
,	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
)	O
&&	O
(	O
*	O
newnp	pointer
)	O
->	O
nn_stat	O
.	O
st_uid	int
!=	O
owner	int
)	O
netfs_attempt_chown	function
(	O
(	O
struct	O
iouser	O
*	O
)	O
-	O
1	int
,	O
*	O
newnp	pointer
,	O
owner	int
,	O
(	O
*	O
newnp	pointer
)	O
->	O
nn_stat	O
.	O
st_gid	int
)	O
;	O
}	O
else	O
*	O
newnp	pointer
=	O
0	int
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_unlink	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
struct	O
node	O
*	O
np	pointer
;	O
err	int
=	O
netfs_attempt_lookup	function
(	O
cred	pointer
,	O
dir	pointer
,	O
name	pointer
,	O
&	O
np	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache_node	function
(	O
np	pointer
)	O
;	O
struct	O
references	O
result	struct
;	O
refcounts_references	function
(	O
&	O
np	pointer
->	O
refcounts	O
,	O
&	O
result	struct
)	O
;	O
if	O
(	O
result	struct
.	O
hard	O
>	O
1	int
)	O
{	O
char	O
*	O
newname	pointer
=	O
0	int
;	O
int	O
n	int
=	O
0	int
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
newname	pointer
=	O
malloc	O
(	O
50	int
)	O
;	O
if	O
(	O
!	O
newname	pointer
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
netfs_nrele	function
(	O
np	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
do	O
{	O
sprintf	O
(	O
newname	pointer
,	O
".nfs%txgnu.%d"	pointer
,	O
(	O
ptrdiff_t	long
)	O
np	pointer
,	O
n	int
++	O
)	O
;	O
err	int
=	O
netfs_attempt_link	function
(	O
cred	pointer
,	O
dir	pointer
,	O
np	pointer
,	O
newname	pointer
,	O
1	int
)	O
;	O
}	O
while	O
(	O
err	int
==	O
EEXIST	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
newname	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
netfs_nrele	function
(	O
np	pointer
)	O
;	O
return	O
err	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dead_dir	pointer
)	O
netfs_nrele	function
(	O
np	pointer
->	O
nn	O
->	O
dead_dir	pointer
)	O
;	O
netfs_nref	function
(	O
dir	pointer
)	O
;	O
np	pointer
->	O
nn	O
->	O
dead_dir	pointer
=	O
dir	pointer
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dead_name	pointer
)	O
free	function
(	O
np	pointer
->	O
nn	O
->	O
dead_name	pointer
)	O
;	O
np	pointer
->	O
nn	O
->	O
dead_name	pointer
=	O
newname	pointer
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
NOT_POSSIBLE	int
)	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
POSSIBLE	int
;	O
netfs_nput	function
(	O
np	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
}	O
else	O
netfs_nrele	function
(	O
np	pointer
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_REMOVE	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
name	pointer
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_wcc_stat	function
(	O
dir	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_rename	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
fromdir	pointer
,	O
char	O
*	O
fromname	pointer
,	O
struct	O
node	O
*	O
todir	pointer
,	O
char	O
*	O
toname	pointer
,	O
int	O
excl	int
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
if	O
(	O
excl	int
)	O
{	O
struct	O
node	O
*	O
np	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_attempt_lookup	function
(	O
cred	pointer
,	O
fromdir	pointer
,	O
fromname	pointer
,	O
&	O
np	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
err	int
=	O
netfs_attempt_link	function
(	O
cred	pointer
,	O
todir	pointer
,	O
np	pointer
,	O
toname	pointer
,	O
1	int
)	O
;	O
netfs_nput	function
(	O
np	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
pthread_mutex_lock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
netfs_attempt_unlink	function
(	O
cred	pointer
,	O
fromdir	pointer
,	O
fromname	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
todir	pointer
->	O
lock	O
)	O
;	O
netfs_attempt_unlink	function
(	O
cred	pointer
,	O
todir	pointer
,	O
toname	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
todir	pointer
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache	function
(	O
fromdir	pointer
,	O
fromname	pointer
,	O
strlen	O
(	O
fromname	pointer
)	O
)	O
;	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_RENAME	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
fromdir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
fromdir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
fromname	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
todir	pointer
->	O
lock	O
)	O
;	O
purge_lookup_cache	function
(	O
todir	pointer
,	O
toname	pointer
,	O
strlen	O
(	O
toname	pointer
)	O
)	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
todir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
toname	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
todir	pointer
->	O
lock	O
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
fromdir	pointer
->	O
lock	O
)	O
;	O
p	pointer
=	O
process_wcc_stat	function
(	O
fromdir	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
p	pointer
=	O
process_wcc_stat	function
(	O
todir	pointer
,	O
p	pointer
,	O
!	O
err	int
)	O
;	O
}	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_attempt_readlink	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
SYMLINK	int
)	O
{	O
strcpy	O
(	O
buf	pointer
,	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_READLINK	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
protocol_version	int
==	O
3	int
)	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
p	pointer
=	O
xdr_decode_string	function
(	O
p	pointer
,	O
buf	pointer
)	O
;	O
}	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
netfs_check_open_permissions	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
flags	int
,	O
int	O
newnode	int
)	O
{	O
int	O
modes	int
;	O
if	O
(	O
newnode	int
||	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
|	O
O_EXEC	O
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
netfs_report_access	function
(	O
cred	pointer
,	O
np	pointer
,	O
&	O
modes	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
|	O
O_EXEC	O
)	O
)	O
==	O
(	O
flags	int
&	O
modes	int
)	O
)	O
return	O
0	int
;	O
else	O
return	O
EACCES	int
;	O
}	O
error_t	int
netfs_report_access	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
*	O
types	pointer
)	O
{	O
error_t	int
err	int
;	O
err	int
=	O
netfs_validate_stat	function
(	O
np	pointer
,	O
cred	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
protocol_version	int
==	O
2	int
)	O
{	O
*	O
types	pointer
=	O
0	int
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
np	pointer
->	O
nn_stat	O
,	O
S_IREAD	O
,	O
cred	pointer
)	O
==	O
0	int
)	O
*	O
types	pointer
|=	O
O_READ	O
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
np	pointer
->	O
nn_stat	O
,	O
S_IWRITE	O
,	O
cred	pointer
)	O
==	O
0	int
)	O
*	O
types	pointer
|=	O
O_WRITE	O
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
np	pointer
->	O
nn_stat	O
,	O
S_IEXEC	O
,	O
cred	pointer
)	O
==	O
0	int
)	O
*	O
types	pointer
|=	O
O_EXEC	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
int	O
ret	pointer
;	O
int	O
write_check	int
,	O
execute_check	int
;	O
if	O
(	O
S_ISDIR	O
(	O
np	pointer
->	O
nn_stat	O
.	O
st_mode	int
)	O
)	O
{	O
write_check	int
=	O
ACCESS3_MODIFY	int
|	O
ACCESS3_DELETE	int
|	O
ACCESS3_EXTEND	int
;	O
execute_check	int
=	O
ACCESS3_LOOKUP	int
;	O
}	O
else	O
{	O
write_check	int
=	O
ACCESS3_MODIFY	int
;	O
execute_check	int
=	O
ACCESS3_EXECUTE	int
;	O
}	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFS3PROC_ACCESS	int
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
np	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
np	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
ACCESS3_READ	int
|	O
write_check	int
|	O
execute_check	int
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
p	pointer
=	O
process_returned_stat	function
(	O
np	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
ret	pointer
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
*	O
types	pointer
=	O
(	O
(	O
ret	pointer
&	O
ACCESS3_READ	int
?	O
O_READ	O
:	O
0	int
)	O
|	O
(	O
ret	pointer
&	O
write_check	int
?	O
O_WRITE	O
:	O
0	int
)	O
|	O
(	O
ret	pointer
&	O
execute_check	int
?	O
O_EXEC	O
:	O
0	int
)	O
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
}	O
static	O
error_t	int
fetch_directory	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
dir	pointer
,	O
void	O
*	O
*	O
bufp	pointer
,	O
size_t	long
*	O
bufsizep	pointer
,	O
int	O
*	O
totalentries	pointer
)	O
{	O
void	O
*	O
buf	pointer
;	O
int	O
cookie	int
;	O
int	O
*	O
p	pointer
;	O
void	O
*	O
rpcbuf	pointer
;	O
struct	O
dirent	O
*	O
entry	pointer
;	O
void	O
*	O
bp	pointer
;	O
int	O
bufmalloced	int
;	O
int	O
eof	int
;	O
error_t	int
err	int
;	O
int	O
isnext	int
;	O
bufmalloced	int
=	O
read_size	int
;	O
buf	pointer
=	O
malloc	O
(	O
bufmalloced	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
ENOMEM	int
;	O
bp	pointer
=	O
buf	pointer
;	O
cookie	int
=	O
0	int
;	O
eof	int
=	O
0	int
;	O
*	O
totalentries	pointer
=	O
0	int
;	O
while	O
(	O
!	O
eof	int
)	O
{	O
p	pointer
=	O
nfs_initialize_rpc	function
(	O
NFSPROC_READDIR	O
(	O
protocol_version	int
)	O
,	O
cred	pointer
,	O
0	int
,	O
&	O
rpcbuf	pointer
,	O
dir	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
errno	O
;	O
}	O
p	pointer
=	O
xdr_encode_fhandle	function
(	O
p	pointer
,	O
&	O
dir	pointer
->	O
nn	O
->	O
handle	struct
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
cookie	int
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
ntohl	function
(	O
read_size	int
)	O
;	O
err	int
=	O
conduct_rpc	function
(	O
&	O
rpcbuf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
nfs_error_trans	function
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
err	int
;	O
}	O
isnext	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
while	O
(	O
isnext	int
)	O
{	O
ino_t	long
fileno	long
;	O
int	O
namlen	int
;	O
int	O
reclen	int
;	O
fileno	long
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
namlen	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
reclen	int
=	O
sizeof	O
(	O
struct	O
dirent	O
)	O
+	O
namlen	int
;	O
reclen	int
=	O
(	O
reclen	int
+	O
3	int
)	O
&	O
~	O
3	int
;	O
if	O
(	O
bp	pointer
+	O
reclen	int
>	O
buf	pointer
+	O
bufmalloced	int
)	O
{	O
char	O
*	O
newbuf	pointer
;	O
newbuf	pointer
=	O
realloc	O
(	O
buf	pointer
,	O
bufmalloced	int
*=	O
2	int
)	O
;	O
assert	function
(	O
newbuf	pointer
)	O
;	O
if	O
(	O
newbuf	pointer
!=	O
buf	pointer
)	O
bp	pointer
=	O
newbuf	pointer
+	O
(	O
bp	pointer
-	O
buf	pointer
)	O
;	O
buf	pointer
=	O
newbuf	pointer
;	O
}	O
entry	pointer
=	O
(	O
struct	O
dirent	O
*	O
)	O
bp	pointer
;	O
entry	pointer
->	O
d_fileno	O
=	O
fileno	long
;	O
entry	pointer
->	O
d_reclen	O
=	O
reclen	int
;	O
entry	pointer
->	O
d_type	O
=	O
DT_UNKNOWN	O
;	O
entry	pointer
->	O
d_namlen	O
=	O
namlen	int
;	O
memcpy	O
(	O
entry	pointer
->	O
d_name	O
,	O
p	pointer
,	O
namlen	int
)	O
;	O
entry	pointer
->	O
d_name	O
[	O
namlen	int
]	O
=	O
'\0'	O
;	O
p	pointer
+=	O
INTSIZE	O
(	O
namlen	int
)	O
;	O
bp	pointer
=	O
bp	pointer
+	O
entry	pointer
->	O
d_reclen	O
;	O
++	O
*	O
totalentries	pointer
;	O
cookie	int
=	O
*	O
(	O
p	pointer
++	O
)	O
;	O
isnext	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
eof	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
free	function
(	O
rpcbuf	pointer
)	O
;	O
}	O
*	O
bufp	pointer
=	O
buf	pointer
;	O
*	O
bufsizep	pointer
=	O
bufmalloced	int
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_get_dirents	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
int	O
entry	pointer
,	O
int	O
nentries	int
,	O
char	O
*	O
*	O
data	array
,	O
mach_msg_type_number_t	O
*	O
datacnt	pointer
,	O
vm_size_t	O
bufsiz	int
,	O
int	O
*	O
amt	long
)	O
{	O
void	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
our_bufsiz	long
,	O
allocsize	long
;	O
void	O
*	O
bp	pointer
;	O
char	O
*	O
userdp	pointer
;	O
error_t	int
err	int
;	O
int	O
totalentries	pointer
;	O
int	O
thisentry	int
;	O
err	int
=	O
fetch_directory	function
(	O
cred	pointer
,	O
np	pointer
,	O
&	O
buf	pointer
,	O
&	O
our_bufsiz	long
,	O
&	O
totalentries	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
!	O
bufsiz	int
||	O
bufsiz	int
>	O
our_bufsiz	long
)	O
allocsize	long
=	O
round_page	function
(	O
our_bufsiz	long
)	O
;	O
else	O
allocsize	long
=	O
round_page	function
(	O
bufsiz	int
)	O
;	O
if	O
(	O
allocsize	long
>	O
*	O
datacnt	pointer
)	O
*	O
data	array
=	O
mmap	function
(	O
0	int
,	O
allocsize	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
bp	pointer
=	O
buf	pointer
;	O
for	O
(	O
thisentry	int
=	O
0	int
;	O
thisentry	int
<	O
entry	pointer
;	O
)	O
{	O
struct	O
dirent	O
*	O
entry	pointer
=	O
(	O
struct	O
dirent	O
*	O
)	O
bp	pointer
;	O
bp	pointer
+=	O
entry	pointer
->	O
d_reclen	O
;	O
thisentry	int
++	O
;	O
}	O
{	O
int	O
entries_copied	int
;	O
for	O
(	O
entries_copied	int
=	O
0	int
,	O
userdp	pointer
=	O
*	O
data	array
;	O
(	O
nentries	int
==	O
-	O
1	int
||	O
entries_copied	int
<	O
nentries	int
)	O
&&	O
(	O
!	O
bufsiz	int
||	O
userdp	pointer
-	O
*	O
data	array
<	O
bufsiz	int
)	O
&&	O
thisentry	int
<	O
totalentries	pointer
;	O
)	O
{	O
struct	O
dirent	O
*	O
entry	pointer
=	O
(	O
struct	O
dirent	O
*	O
)	O
bp	pointer
;	O
memcpy	O
(	O
userdp	pointer
,	O
bp	pointer
,	O
entry	pointer
->	O
d_reclen	O
)	O
;	O
bp	pointer
+=	O
entry	pointer
->	O
d_reclen	O
;	O
userdp	pointer
+=	O
entry	pointer
->	O
d_reclen	O
;	O
entries_copied	int
++	O
;	O
thisentry	int
++	O
;	O
}	O
*	O
amt	long
=	O
entries_copied	int
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
allocsize	long
>	O
*	O
datacnt	pointer
&&	O
round_page	function
(	O
userdp	pointer
-	O
*	O
data	array
)	O
<	O
round_page	function
(	O
allocsize	long
)	O
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
round_page	function
(	O
userdp	pointer
)	O
,	O
round_page	function
(	O
allocsize	long
)	O
-	O
round_page	function
(	O
userdp	pointer
-	O
*	O
data	array
)	O
)	O
;	O
*	O
datacnt	pointer
=	O
userdp	pointer
-	O
*	O
data	array
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_mksymlink	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
NOT_POSSIBLE	int
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
SYMLINK	int
)	O
free	function
(	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
=	O
malloc	O
(	O
strlen	O
(	O
arg	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	O
(	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
,	O
arg	pointer
)	O
;	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
SYMLINK	int
;	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	int
netfs_attempt_mkdev	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	O
*	O
np	pointer
,	O
mode_t	int
type	int
,	O
dev_t	long
indexes	long
)	O
{	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
NOT_POSSIBLE	int
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
==	O
SYMLINK	int
)	O
free	function
(	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
name	pointer
)	O
;	O
np	pointer
->	O
nn	O
->	O
transarg	union
.	O
indexes	long
=	O
indexes	long
;	O
if	O
(	O
type	int
==	O
S_IFBLK	O
)	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
BLKDEV	int
;	O
else	O
np	pointer
->	O
nn	O
->	O
dtrans	enum
=	O
CHRDEV	int
;	O
np	pointer
->	O
nn	O
->	O
stat_updated	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
