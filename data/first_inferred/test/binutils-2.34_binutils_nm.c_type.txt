struct	O
size_sym	struct
{	O
const	O
void	O
*	O
minisym	pointer
;	O
bfd_vma	long
size	int
;	O
}	O
;	O
struct	O
get_relocs_info	struct
{	O
asection	struct
*	O
*	O
secs	pointer
;	O
arelent	struct
*	O
*	O
*	O
relocs	pointer
;	O
long	O
*	O
relcount	pointer
;	O
asymbol	struct
*	O
*	O
syms	pointer
;	O
}	O
;	O
struct	O
extended_symbol_info	struct
{	O
symbol_info	struct
*	O
sinfo	pointer
;	O
bfd_vma	long
ssize	long
;	O
elf_symbol_type	struct
*	O
elfinfo	pointer
;	O
coff_symbol_type	struct
*	O
coffinfo	pointer
;	O
}	O
;	O
static	O
void	O
print_object_filename_bsd	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_object_filename_sysv	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_object_filename_posix	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_archive_filename_bsd	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_archive_filename_sysv	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_archive_filename_posix	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_archive_member_bsd	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_archive_member_sysv	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_archive_member_posix	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
print_symbol_filename_bsd	function
(	O
bfd	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
print_symbol_filename_sysv	function
(	O
bfd	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
print_symbol_filename_posix	function
(	O
bfd	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
print_value	function
(	O
bfd	struct
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
void	O
print_symbol_info_bsd	function
(	O
struct	O
extended_symbol_info	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
print_symbol_info_sysv	function
(	O
struct	O
extended_symbol_info	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
print_symbol_info_posix	function
(	O
struct	O
extended_symbol_info	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
struct	O
output_fns	struct
{	O
void	O
(	O
*	O
print_object_filename	pointer
)	O
(	O
const	O
char	O
*	O
)	O
;	O
void	O
(	O
*	O
print_archive_filename	pointer
)	O
(	O
const	O
char	O
*	O
)	O
;	O
void	O
(	O
*	O
print_archive_member	pointer
)	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
void	O
(	O
*	O
print_symbol_filename	pointer
)	O
(	O
bfd	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
void	O
(	O
*	O
print_symbol_info	pointer
)	O
(	O
struct	O
extended_symbol_info	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
}	O
;	O
static	O
struct	O
output_fns	struct
formats	array
[	O
]	O
=	O
{	O
{	O
print_object_filename_bsd	function
,	O
print_archive_filename_bsd	function
,	O
print_archive_member_bsd	function
,	O
print_symbol_filename_bsd	function
,	O
print_symbol_info_bsd	function
}	O
,	O
{	O
print_object_filename_sysv	function
,	O
print_archive_filename_sysv	function
,	O
print_archive_member_sysv	function
,	O
print_symbol_filename_sysv	function
,	O
print_symbol_info_sysv	function
}	O
,	O
{	O
print_object_filename_posix	function
,	O
print_archive_filename_posix	function
,	O
print_archive_member_posix	function
,	O
print_symbol_filename_posix	function
,	O
print_symbol_info_posix	function
}	O
}	O
;	O
static	O
struct	O
output_fns	struct
*	O
format	enum
=	O
&	O
formats	array
[	O
FORMAT_DEFAULT	O
]	O
;	O
static	O
unsigned	O
int	O
print_format	int
=	O
FORMAT_DEFAULT	O
;	O
static	O
const	O
char	O
*	O
print_format_string	pointer
=	O
NULL	O
;	O
static	O
int	O
do_demangle	int
=	O
0	int
;	O
static	O
int	O
external_only	int
=	O
0	int
;	O
static	O
int	O
defined_only	int
=	O
0	int
;	O
static	O
int	O
no_sort	int
=	O
0	int
;	O
static	O
int	O
print_debug_syms	int
=	O
0	int
;	O
static	O
int	O
print_armap	int
=	O
0	int
;	O
static	O
int	O
print_size	int
=	O
0	int
;	O
static	O
int	O
reverse_sort	int
=	O
0	int
;	O
static	O
int	O
sort_numerically	int
=	O
0	int
;	O
static	O
int	O
sort_by_size	int
=	O
0	int
;	O
static	O
int	O
undefined_only	int
=	O
0	int
;	O
static	O
int	O
dynamic	int
=	O
0	int
;	O
static	O
int	O
show_version	int
=	O
0	int
;	O
static	O
int	O
show_synthetic	int
=	O
0	int
;	O
static	O
int	O
line_numbers	int
=	O
0	int
;	O
static	O
int	O
allow_special_symbols	int
=	O
0	int
;	O
static	O
int	O
with_symbol_versions	int
=	O
0	int
;	O
static	O
int	O
demangle_flags	int
=	O
DMGL_ANSI	O
|	O
DMGL_PARAMS	O
;	O
static	O
int	O
filename_per_file	int
=	O
0	int
;	O
static	O
int	O
filename_per_symbol	int
=	O
0	int
;	O
static	O
int	O
print_width	int
=	O
0	int
;	O
static	O
int	O
print_radix	int
=	O
16	int
;	O
static	O
char	O
other_format	array
[	O
]	O
=	O
"%02x"	pointer
;	O
static	O
char	O
desc_format	array
[	O
]	O
=	O
"%04x"	pointer
;	O
static	O
char	O
*	O
target	pointer
=	O
NULL	O
;	O
static	O
const	O
char	O
*	O
plugin_target	pointer
=	O
"plugin"	pointer
;	O
static	O
bfd	struct
*	O
lineno_cache_bfd	pointer
;	O
static	O
bfd	struct
*	O
lineno_cache_rel_bfd	pointer
;	O
enum	O
long_option_values	enum
{	O
OPTION_TARGET	int
=	O
200	int
,	O
OPTION_PLUGIN	int
,	O
OPTION_SIZE_SORT	int
,	O
OPTION_RECURSE_LIMIT	int
,	O
OPTION_NO_RECURSE_LIMIT	int
}	O
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"debug-syms"	pointer
,	O
no_argument	int
,	O
&	O
print_debug_syms	int
,	O
1	int
}	O
,	O
{	O
"demangle"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'C'	O
}	O
,	O
{	O
"dynamic"	pointer
,	O
no_argument	int
,	O
&	O
dynamic	int
,	O
1	int
}	O
,	O
{	O
"extern-only"	pointer
,	O
no_argument	int
,	O
&	O
external_only	int
,	O
1	int
}	O
,	O
{	O
"format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"line-numbers"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"no-cplus"	pointer
,	O
no_argument	int
,	O
&	O
do_demangle	int
,	O
0	int
}	O
,	O
{	O
"no-demangle"	pointer
,	O
no_argument	int
,	O
&	O
do_demangle	int
,	O
0	int
}	O
,	O
{	O
"no-recurse-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_RECURSE_LIMIT	int
}	O
,	O
{	O
"no-recursion-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_RECURSE_LIMIT	int
}	O
,	O
{	O
"no-sort"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"numeric-sort"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"plugin"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_PLUGIN	int
}	O
,	O
{	O
"portability"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'P'	O
}	O
,	O
{	O
"print-armap"	pointer
,	O
no_argument	int
,	O
&	O
print_armap	int
,	O
1	int
}	O
,	O
{	O
"print-file-name"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"print-size"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"radix"	pointer
,	O
required_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"recurse-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_RECURSE_LIMIT	int
}	O
,	O
{	O
"recursion-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_RECURSE_LIMIT	int
}	O
,	O
{	O
"reverse-sort"	pointer
,	O
no_argument	int
,	O
&	O
reverse_sort	int
,	O
1	int
}	O
,	O
{	O
"size-sort"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_SIZE_SORT	int
}	O
,	O
{	O
"special-syms"	pointer
,	O
no_argument	int
,	O
&	O
allow_special_symbols	int
,	O
1	int
}	O
,	O
{	O
"synthetic"	pointer
,	O
no_argument	int
,	O
&	O
show_synthetic	int
,	O
1	int
}	O
,	O
{	O
"target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_TARGET	int
}	O
,	O
{	O
"defined-only"	pointer
,	O
no_argument	int
,	O
&	O
defined_only	int
,	O
1	int
}	O
,	O
{	O
"undefined-only"	pointer
,	O
no_argument	int
,	O
&	O
undefined_only	int
,	O
1	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
"with-symbol-versions"	pointer
,	O
no_argument	int
,	O
&	O
with_symbol_versions	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
no_argument	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
ATTRIBUTE_NORETURN	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
status	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s [option(s)] [file(s)]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" List symbols in [file(s)] (a.out by default).\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" The options are:\n  -a, --debug-syms       Display debugger-only symbols\n  -A, --print-file-name  Print name of the input file before every symbol\n  -B                     Same as --format=bsd\n  -C, --demangle[=STYLE] Decode low-level symbol names into user-level names\n                          The STYLE, if specified, can be `auto' (the default),\n                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n                          or `gnat'\n      --no-demangle      Do not demangle low-level symbol names\n      --recurse-limit    Enable a demangling recursion limit.  This is the default.\n      --no-recurse-limit Disable a demangling recursion limit.\n  -D, --dynamic          Display dynamic symbols instead of normal symbols\n      --defined-only     Display only defined symbols\n  -e                     (ignored)\n  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n                           `sysv' or `posix'.  The default is `bsd'\n  -g, --extern-only      Display only external symbols\n  -l, --line-numbers     Use debugging information to find a filename and\n                           line number for each symbol\n  -n, --numeric-sort     Sort symbols numerically by address\n  -o                     Same as -A\n  -p, --no-sort          Do not sort the symbols\n  -P, --portability      Same as --format=posix\n  -r, --reverse-sort     Reverse the sense of the sort\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"      --plugin NAME      Load the specified plugin\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -S, --print-size       Print size of defined symbols\n  -s, --print-armap      Include index for symbols from archive members\n      --size-sort        Sort symbols by size\n      --special-syms     Include special symbols in the output\n      --synthetic        Display synthetic symbols as well\n  -t, --radix=RADIX      Use RADIX for printing symbol values\n      --target=BFDNAME   Specify the target object format as BFDNAME\n  -u, --undefined-only   Display only undefined symbols\n      --with-symbol-versions  Display version strings after symbol names\n  -X 32_64               (ignored)\n  @FILE                  Read options from FILE\n  -h, --help             Display this information\n  -V, --version          Display this program's version number\n\n"	pointer
)	O
)	O
;	O
list_supported_targets	function
(	O
program_name	pointer
,	O
stream	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
status	int
==	O
0	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Report bugs to %s.\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
set_print_radix	function
(	O
char	O
*	O
radix	pointer
)	O
{	O
switch	O
(	O
*	O
radix	pointer
)	O
{	O
case	O
'x'	O
:	O
print_radix	int
=	O
16	int
;	O
break	O
;	O
case	O
'd'	O
:	O
print_radix	int
=	O
10	int
;	O
break	O
;	O
case	O
'o'	O
:	O
print_radix	int
=	O
8	int
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
_	O
(	O
"%s: invalid radix"	pointer
)	O
,	O
radix	pointer
)	O
;	O
}	O
other_format	array
[	O
3	int
]	O
=	O
desc_format	array
[	O
3	int
]	O
=	O
*	O
radix	pointer
;	O
}	O
static	O
void	O
set_output_format	function
(	O
char	O
*	O
f	pointer
)	O
{	O
int	O
i	pointer
;	O
switch	O
(	O
*	O
f	pointer
)	O
{	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
i	pointer
=	O
FORMAT_BSD	int
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
i	pointer
=	O
FORMAT_POSIX	int
;	O
break	O
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
i	pointer
=	O
FORMAT_SYSV	int
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
_	O
(	O
"%s: invalid output format"	pointer
)	O
,	O
f	pointer
)	O
;	O
}	O
format	enum
=	O
&	O
formats	array
[	O
i	pointer
]	O
;	O
print_format	int
=	O
i	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_elf_symbol_type	function
(	O
unsigned	O
int	O
type	enum
)	O
{	O
static	O
char	O
*	O
bufp	pointer
;	O
int	O
n	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
STT_NOTYPE	int
:	O
return	O
"NOTYPE"	pointer
;	O
case	O
STT_OBJECT	int
:	O
return	O
"OBJECT"	pointer
;	O
case	O
STT_FUNC	int
:	O
return	O
"FUNC"	pointer
;	O
case	O
STT_SECTION	int
:	O
return	O
"SECTION"	pointer
;	O
case	O
STT_FILE	int
:	O
return	O
"FILE"	pointer
;	O
case	O
STT_COMMON	int
:	O
return	O
"COMMON"	pointer
;	O
case	O
STT_TLS	int
:	O
return	O
"TLS"	pointer
;	O
}	O
free	function
(	O
bufp	pointer
)	O
;	O
if	O
(	O
type	enum
>=	O
STT_LOPROC	int
&&	O
type	enum
<=	O
STT_HIPROC	int
)	O
n	int
=	O
asprintf	function
(	O
&	O
bufp	pointer
,	O
_	O
(	O
"<processor specific>: %d"	pointer
)	O
,	O
type	enum
)	O
;	O
else	O
if	O
(	O
type	enum
>=	O
STT_LOOS	int
&&	O
type	enum
<=	O
STT_HIOS	int
)	O
n	int
=	O
asprintf	function
(	O
&	O
bufp	pointer
,	O
_	O
(	O
"<OS specific>: %d"	pointer
)	O
,	O
type	enum
)	O
;	O
else	O
n	int
=	O
asprintf	function
(	O
&	O
bufp	pointer
,	O
_	O
(	O
"<unknown>: %d"	pointer
)	O
,	O
type	enum
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
fatal	function
(	O
"%s"	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
bufp	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_coff_symbol_type	function
(	O
const	O
struct	O
internal_syment	struct
*	O
sym	pointer
)	O
{	O
static	O
char	O
*	O
bufp	pointer
;	O
int	O
n	int
;	O
switch	O
(	O
sym	pointer
->	O
n_sclass	char
)	O
{	O
case	O
C_BLOCK	int
:	O
return	O
"Block"	pointer
;	O
case	O
C_FILE	int
:	O
return	O
"File"	pointer
;	O
case	O
C_LINE	int
:	O
return	O
"Line"	pointer
;	O
}	O
if	O
(	O
!	O
sym	pointer
->	O
n_type	short
)	O
return	O
"None"	pointer
;	O
switch	O
(	O
DTYPE	O
(	O
sym	pointer
->	O
n_type	short
)	O
)	O
{	O
case	O
DT_FCN	O
:	O
return	O
"Function"	pointer
;	O
case	O
DT_PTR	O
:	O
return	O
"Pointer"	pointer
;	O
case	O
DT_ARY	O
:	O
return	O
"Array"	pointer
;	O
}	O
free	function
(	O
bufp	pointer
)	O
;	O
n	int
=	O
asprintf	function
(	O
&	O
bufp	pointer
,	O
_	O
(	O
"<unknown>: %d/%d"	pointer
)	O
,	O
sym	pointer
->	O
n_sclass	char
,	O
sym	pointer
->	O
n_type	short
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
fatal	function
(	O
"%s"	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
bufp	pointer
;	O
}	O
static	O
void	O
print_symname	function
(	O
const	O
char	O
*	O
form	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
do_demangle	int
&&	O
*	O
name	pointer
)	O
{	O
char	O
*	O
res	pointer
=	O
bfd_demangle	function
(	O
abfd	pointer
,	O
name	pointer
,	O
demangle_flags	int
)	O
;	O
if	O
(	O
res	pointer
!=	O
NULL	O
)	O
{	O
printf	function
(	O
form	pointer
,	O
res	pointer
)	O
;	O
free	function
(	O
res	pointer
)	O
;	O
return	O
;	O
}	O
}	O
printf	function
(	O
form	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
void	O
print_symdef_entry	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
symindex	long
idx	int
=	O
BFD_NO_MORE_SYMBOLS	O
;	O
carsym	struct
*	O
thesym	pointer
;	O
bfd_boolean	int
everprinted	int
=	O
FALSE	int
;	O
for	O
(	O
idx	int
=	O
bfd_get_next_mapent	function
(	O
abfd	pointer
,	O
idx	int
,	O
&	O
thesym	pointer
)	O
;	O
idx	int
!=	O
BFD_NO_MORE_SYMBOLS	O
;	O
idx	int
=	O
bfd_get_next_mapent	function
(	O
abfd	pointer
,	O
idx	int
,	O
&	O
thesym	pointer
)	O
)	O
{	O
bfd	struct
*	O
elt	pointer
;	O
if	O
(	O
!	O
everprinted	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nArchive index:\n"	pointer
)	O
)	O
;	O
everprinted	int
=	O
TRUE	int
;	O
}	O
elt	pointer
=	O
bfd_get_elt_at_index	O
(	O
abfd	pointer
,	O
idx	int
)	O
;	O
if	O
(	O
elt	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
"bfd_get_elt_at_index"	pointer
)	O
;	O
if	O
(	O
thesym	pointer
->	O
name	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
print_symname	function
(	O
"%s"	pointer
,	O
thesym	pointer
->	O
name	pointer
,	O
abfd	pointer
)	O
;	O
printf	function
(	O
" in %s\n"	pointer
,	O
bfd_get_filename	function
(	O
elt	pointer
)	O
)	O
;	O
}	O
}	O
}	O
bfd_boolean	int
report_plugin_err	int
=	O
TRUE	int
;	O
static	O
long	O
filter_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_dynamic	int
,	O
void	O
*	O
minisyms	pointer
,	O
long	O
symcount	int
,	O
unsigned	O
int	O
size	int
)	O
{	O
bfd_byte	char
*	O
from	pointer
,	O
*	O
fromend	pointer
,	O
*	O
to	pointer
;	O
asymbol	struct
*	O
store	pointer
;	O
store	pointer
=	O
bfd_make_empty_symbol	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
store	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
from	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
minisyms	pointer
;	O
fromend	pointer
=	O
from	pointer
+	O
symcount	int
*	O
size	int
;	O
to	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
minisyms	pointer
;	O
for	O
(	O
;	O
from	pointer
<	O
fromend	pointer
;	O
from	pointer
+=	O
size	int
)	O
{	O
int	O
keep	int
=	O
0	int
;	O
asymbol	struct
*	O
sym	pointer
;	O
PROGRESS	O
(	O
1	int
)	O
;	O
sym	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
abfd	pointer
,	O
is_dynamic	int
,	O
(	O
const	O
void	O
*	O
)	O
from	pointer
,	O
store	pointer
)	O
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
sym	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
sym	pointer
->	O
name	pointer
[	O
1	int
]	O
==	O
'_'	O
&&	O
strcmp	function
(	O
sym	pointer
->	O
name	pointer
+	O
(	O
sym	pointer
->	O
name	pointer
[	O
2	int
]	O
==	O
'_'	O
)	O
,	O
"__gnu_lto_slim"	pointer
)	O
==	O
0	int
&&	O
report_plugin_err	int
)	O
{	O
report_plugin_err	int
=	O
FALSE	int
;	O
non_fatal	function
(	O
_	O
(	O
"%s: plugin needed to handle lto object"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
if	O
(	O
undefined_only	int
)	O
keep	int
=	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
;	O
else	O
if	O
(	O
external_only	int
)	O
keep	int
=	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
|	O
BSF_GNU_UNIQUE	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
||	O
bfd_is_com_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
;	O
else	O
keep	int
=	O
1	int
;	O
if	O
(	O
keep	int
&&	O
!	O
print_debug_syms	int
&&	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
!=	O
0	int
)	O
keep	int
=	O
0	int
;	O
if	O
(	O
keep	int
&&	O
sort_by_size	int
&&	O
(	O
bfd_is_abs_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
||	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
)	O
keep	int
=	O
0	int
;	O
if	O
(	O
keep	int
&&	O
defined_only	int
)	O
{	O
if	O
(	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
keep	int
=	O
0	int
;	O
}	O
if	O
(	O
keep	int
&&	O
bfd_is_target_special_symbol	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
&&	O
!	O
allow_special_symbols	int
)	O
keep	int
=	O
0	int
;	O
if	O
(	O
keep	int
)	O
{	O
if	O
(	O
to	pointer
!=	O
from	pointer
)	O
memcpy	function
(	O
to	pointer
,	O
from	pointer
,	O
size	int
)	O
;	O
to	pointer
+=	O
size	int
;	O
}	O
}	O
return	O
(	O
to	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
minisyms	pointer
)	O
/	O
size	int
;	O
}	O
static	O
bfd	struct
*	O
sort_bfd	pointer
;	O
static	O
bfd_boolean	int
sort_dynamic	int
;	O
static	O
asymbol	struct
*	O
sort_x	pointer
;	O
static	O
asymbol	struct
*	O
sort_y	pointer
;	O
static	O
int	O
non_numeric_forward	function
(	O
const	O
void	O
*	O
P_x	pointer
,	O
const	O
void	O
*	O
P_y	pointer
)	O
{	O
asymbol	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
const	O
char	O
*	O
xn	pointer
,	O
*	O
yn	pointer
;	O
x	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
sort_bfd	pointer
,	O
sort_dynamic	int
,	O
P_x	pointer
,	O
sort_x	pointer
)	O
;	O
y	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
sort_bfd	pointer
,	O
sort_dynamic	int
,	O
P_y	pointer
,	O
sort_y	pointer
)	O
;	O
if	O
(	O
x	pointer
==	O
NULL	O
||	O
y	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
sort_bfd	pointer
)	O
)	O
;	O
xn	pointer
=	O
bfd_asymbol_name	function
(	O
x	pointer
)	O
;	O
yn	pointer
=	O
bfd_asymbol_name	function
(	O
y	pointer
)	O
;	O
if	O
(	O
yn	pointer
==	O
NULL	O
)	O
return	O
xn	pointer
!=	O
NULL	O
;	O
if	O
(	O
xn	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
yn	pointer
==	O
'\0'	O
)	O
return	O
*	O
xn	pointer
!=	O
'\0'	O
;	O
if	O
(	O
*	O
xn	pointer
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
return	O
strcoll	function
(	O
xn	pointer
,	O
yn	pointer
)	O
;	O
}	O
static	O
int	O
non_numeric_reverse	function
(	O
const	O
void	O
*	O
x	pointer
,	O
const	O
void	O
*	O
y	pointer
)	O
{	O
return	O
-	O
non_numeric_forward	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
static	O
int	O
numeric_forward	function
(	O
const	O
void	O
*	O
P_x	pointer
,	O
const	O
void	O
*	O
P_y	pointer
)	O
{	O
asymbol	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
asection	struct
*	O
xs	pointer
,	O
*	O
ys	pointer
;	O
x	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
sort_bfd	pointer
,	O
sort_dynamic	int
,	O
P_x	pointer
,	O
sort_x	pointer
)	O
;	O
y	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
sort_bfd	pointer
,	O
sort_dynamic	int
,	O
P_y	pointer
,	O
sort_y	pointer
)	O
;	O
if	O
(	O
x	pointer
==	O
NULL	O
||	O
y	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
sort_bfd	pointer
)	O
)	O
;	O
xs	pointer
=	O
bfd_asymbol_section	function
(	O
x	pointer
)	O
;	O
ys	pointer
=	O
bfd_asymbol_section	function
(	O
y	pointer
)	O
;	O
if	O
(	O
bfd_is_und_section	function
(	O
xs	pointer
)	O
)	O
{	O
if	O
(	O
!	O
bfd_is_und_section	function
(	O
ys	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
ys	pointer
)	O
)	O
return	O
1	int
;	O
else	O
if	O
(	O
valueof	O
(	O
x	pointer
)	O
!=	O
valueof	O
(	O
y	pointer
)	O
)	O
return	O
valueof	O
(	O
x	pointer
)	O
<	O
valueof	O
(	O
y	pointer
)	O
?	O
-	O
1	int
:	O
1	int
;	O
return	O
non_numeric_forward	function
(	O
P_x	pointer
,	O
P_y	pointer
)	O
;	O
}	O
static	O
int	O
numeric_reverse	function
(	O
const	O
void	O
*	O
x	pointer
,	O
const	O
void	O
*	O
y	pointer
)	O
{	O
return	O
-	O
numeric_forward	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
static	O
int	O
(	O
*	O
(	O
sorters	array
[	O
2	int
]	O
[	O
2	int
]	O
)	O
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
=	O
{	O
{	O
non_numeric_forward	function
,	O
non_numeric_reverse	function
}	O
,	O
{	O
numeric_forward	function
,	O
numeric_reverse	function
}	O
}	O
;	O
static	O
int	O
size_forward1	function
(	O
const	O
void	O
*	O
P_x	pointer
,	O
const	O
void	O
*	O
P_y	pointer
)	O
{	O
asymbol	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
asection	struct
*	O
xs	pointer
,	O
*	O
ys	pointer
;	O
const	O
char	O
*	O
xn	pointer
,	O
*	O
yn	pointer
;	O
size_t	long
xnl	long
,	O
ynl	long
;	O
int	O
xf	int
,	O
yf	int
;	O
x	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
sort_bfd	pointer
,	O
sort_dynamic	int
,	O
P_x	pointer
,	O
sort_x	pointer
)	O
;	O
y	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
sort_bfd	pointer
,	O
sort_dynamic	int
,	O
P_y	pointer
,	O
sort_y	pointer
)	O
;	O
if	O
(	O
x	pointer
==	O
NULL	O
||	O
y	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
sort_bfd	pointer
)	O
)	O
;	O
xs	pointer
=	O
bfd_asymbol_section	function
(	O
x	pointer
)	O
;	O
ys	pointer
=	O
bfd_asymbol_section	function
(	O
y	pointer
)	O
;	O
if	O
(	O
bfd_is_und_section	function
(	O
xs	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
bfd_is_und_section	function
(	O
ys	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
valueof	O
(	O
x	pointer
)	O
!=	O
valueof	O
(	O
y	pointer
)	O
)	O
return	O
valueof	O
(	O
x	pointer
)	O
<	O
valueof	O
(	O
y	pointer
)	O
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
xs	pointer
->	O
vma	long
!=	O
ys	pointer
->	O
vma	long
)	O
return	O
xs	pointer
->	O
vma	long
<	O
ys	pointer
->	O
vma	long
?	O
-	O
1	int
:	O
1	int
;	O
xn	pointer
=	O
bfd_asymbol_name	function
(	O
x	pointer
)	O
;	O
yn	pointer
=	O
bfd_asymbol_name	function
(	O
y	pointer
)	O
;	O
xnl	long
=	O
strlen	function
(	O
xn	pointer
)	O
;	O
ynl	long
=	O
strlen	function
(	O
yn	pointer
)	O
;	O
xf	int
=	O
(	O
strstr	function
(	O
xn	pointer
,	O
"gnu_compiled"	pointer
)	O
!=	O
NULL	O
||	O
strstr	function
(	O
xn	pointer
,	O
"gcc2_compiled"	pointer
)	O
!=	O
NULL	O
)	O
;	O
yf	int
=	O
(	O
strstr	function
(	O
yn	pointer
,	O
"gnu_compiled"	pointer
)	O
!=	O
NULL	O
||	O
strstr	function
(	O
yn	pointer
,	O
"gcc2_compiled"	pointer
)	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
xf	int
&&	O
!	O
yf	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
xf	int
&&	O
yf	int
)	O
return	O
1	int
;	O
xf	int
=	O
file_symbol	O
(	O
x	pointer
,	O
xn	pointer
,	O
xnl	long
)	O
;	O
yf	int
=	O
file_symbol	O
(	O
y	pointer
,	O
yn	pointer
,	O
ynl	long
)	O
;	O
if	O
(	O
xf	int
&&	O
!	O
yf	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
xf	int
&&	O
yf	int
)	O
return	O
1	int
;	O
return	O
non_numeric_forward	function
(	O
P_x	pointer
,	O
P_y	pointer
)	O
;	O
}	O
static	O
int	O
size_forward2	function
(	O
const	O
void	O
*	O
P_x	pointer
,	O
const	O
void	O
*	O
P_y	pointer
)	O
{	O
const	O
struct	O
size_sym	struct
*	O
x	pointer
=	O
(	O
const	O
struct	O
size_sym	struct
*	O
)	O
P_x	pointer
;	O
const	O
struct	O
size_sym	struct
*	O
y	pointer
=	O
(	O
const	O
struct	O
size_sym	struct
*	O
)	O
P_y	pointer
;	O
if	O
(	O
x	pointer
->	O
size	int
<	O
y	pointer
->	O
size	int
)	O
return	O
reverse_sort	int
?	O
1	int
:	O
-	O
1	int
;	O
else	O
if	O
(	O
x	pointer
->	O
size	int
>	O
y	pointer
->	O
size	int
)	O
return	O
reverse_sort	int
?	O
-	O
1	int
:	O
1	int
;	O
else	O
return	O
sorters	array
[	O
0	int
]	O
[	O
reverse_sort	int
]	O
(	O
x	pointer
->	O
minisym	pointer
,	O
y	pointer
->	O
minisym	pointer
)	O
;	O
}	O
static	O
long	O
sort_symbols_by_size	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_dynamic	int
,	O
void	O
*	O
minisyms	pointer
,	O
long	O
symcount	int
,	O
unsigned	O
int	O
size	int
,	O
struct	O
size_sym	struct
*	O
*	O
symsizesp	pointer
)	O
{	O
struct	O
size_sym	struct
*	O
symsizes	pointer
;	O
bfd_byte	char
*	O
from	pointer
,	O
*	O
fromend	pointer
;	O
asymbol	struct
*	O
sym	pointer
=	O
NULL	O
;	O
asymbol	struct
*	O
store_sym	pointer
,	O
*	O
store_next	pointer
;	O
qsort	function
(	O
minisyms	pointer
,	O
symcount	int
,	O
size	int
,	O
size_forward1	function
)	O
;	O
symsizes	pointer
=	O
(	O
struct	O
size_sym	struct
*	O
)	O
xmalloc	function
(	O
symcount	int
*	O
sizeof	O
(	O
struct	O
size_sym	struct
)	O
)	O
;	O
*	O
symsizesp	pointer
=	O
symsizes	pointer
;	O
from	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
minisyms	pointer
;	O
fromend	pointer
=	O
from	pointer
+	O
symcount	int
*	O
size	int
;	O
store_sym	pointer
=	O
sort_x	pointer
;	O
store_next	pointer
=	O
sort_y	pointer
;	O
if	O
(	O
from	pointer
<	O
fromend	pointer
)	O
{	O
sym	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
abfd	pointer
,	O
is_dynamic	int
,	O
(	O
const	O
void	O
*	O
)	O
from	pointer
,	O
store_sym	pointer
)	O
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
for	O
(	O
;	O
from	pointer
<	O
fromend	pointer
;	O
from	pointer
+=	O
size	int
)	O
{	O
asymbol	struct
*	O
next	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
bfd_vma	long
sz	long
;	O
asymbol	struct
*	O
temp	pointer
;	O
if	O
(	O
from	pointer
+	O
size	int
<	O
fromend	pointer
)	O
{	O
next	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
abfd	pointer
,	O
is_dynamic	int
,	O
(	O
const	O
void	O
*	O
)	O
(	O
from	pointer
+	O
size	int
)	O
,	O
store_next	pointer
)	O
;	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
else	O
next	pointer
=	O
NULL	O
;	O
sec	pointer
=	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_SYNTHETIC	O
)	O
)	O
==	O
0	int
&&	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
sz	long
=	O
(	O
(	O
elf_symbol_type	struct
*	O
)	O
sym	pointer
)	O
->	O
internal_elf_sym	struct
.	O
st_size	long
;	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_SYNTHETIC	O
)	O
)	O
==	O
0	int
&&	O
bfd_is_com_section	function
(	O
sec	pointer
)	O
)	O
sz	long
=	O
sym	pointer
->	O
value	long
;	O
else	O
{	O
if	O
(	O
from	pointer
+	O
size	int
<	O
fromend	pointer
&&	O
sec	pointer
==	O
bfd_asymbol_section	function
(	O
next	pointer
)	O
)	O
sz	long
=	O
valueof	O
(	O
next	pointer
)	O
-	O
valueof	O
(	O
sym	pointer
)	O
;	O
else	O
sz	long
=	O
(	O
bfd_section_vma	function
(	O
sec	pointer
)	O
+	O
bfd_section_size	function
(	O
sec	pointer
)	O
-	O
valueof	O
(	O
sym	pointer
)	O
)	O
;	O
}	O
if	O
(	O
sz	long
!=	O
0	int
)	O
{	O
symsizes	pointer
->	O
minisym	pointer
=	O
(	O
const	O
void	O
*	O
)	O
from	pointer
;	O
symsizes	pointer
->	O
size	int
=	O
sz	long
;	O
++	O
symsizes	pointer
;	O
}	O
sym	pointer
=	O
next	pointer
;	O
temp	pointer
=	O
store_sym	pointer
;	O
store_sym	pointer
=	O
store_next	pointer
;	O
store_next	pointer
=	O
temp	pointer
;	O
}	O
symcount	int
=	O
symsizes	pointer
-	O
*	O
symsizesp	pointer
;	O
qsort	function
(	O
(	O
void	O
*	O
)	O
*	O
symsizesp	pointer
,	O
symcount	int
,	O
sizeof	O
(	O
struct	O
size_sym	struct
)	O
,	O
size_forward2	function
)	O
;	O
return	O
symcount	int
;	O
}	O
static	O
void	O
get_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
dataarg	pointer
)	O
{	O
struct	O
get_relocs_info	struct
*	O
data	pointer
=	O
(	O
struct	O
get_relocs_info	struct
*	O
)	O
dataarg	pointer
;	O
*	O
data	pointer
->	O
secs	pointer
=	O
sec	pointer
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
)	O
{	O
*	O
data	pointer
->	O
relocs	pointer
=	O
NULL	O
;	O
*	O
data	pointer
->	O
relcount	pointer
=	O
0	int
;	O
}	O
else	O
{	O
long	O
relsize	long
;	O
relsize	long
=	O
bfd_get_reloc_upper_bound	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
relsize	long
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
*	O
data	pointer
->	O
relocs	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
xmalloc	function
(	O
relsize	long
)	O
;	O
*	O
data	pointer
->	O
relcount	pointer
=	O
bfd_canonicalize_reloc	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
*	O
data	pointer
->	O
relocs	pointer
,	O
data	pointer
->	O
syms	pointer
)	O
;	O
if	O
(	O
*	O
data	pointer
->	O
relcount	pointer
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
++	O
data	pointer
->	O
secs	pointer
;	O
++	O
data	pointer
->	O
relocs	pointer
;	O
++	O
data	pointer
->	O
relcount	pointer
;	O
}	O
static	O
void	O
print_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
sym	pointer
,	O
bfd_vma	long
ssize	long
,	O
bfd	struct
*	O
archive_bfd	pointer
)	O
{	O
symbol_info	struct
syminfo	struct
;	O
struct	O
extended_symbol_info	struct
info	pointer
;	O
PROGRESS	O
(	O
1	int
)	O
;	O
format	enum
->	O
print_symbol_filename	pointer
(	O
archive_bfd	pointer
,	O
abfd	pointer
)	O
;	O
bfd_get_symbol_info	O
(	O
abfd	pointer
,	O
sym	pointer
,	O
&	O
syminfo	struct
)	O
;	O
info	pointer
.	O
sinfo	pointer
=	O
&	O
syminfo	struct
;	O
info	pointer
.	O
ssize	long
=	O
ssize	long
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_SYNTHETIC	O
)	O
)	O
!=	O
0	int
)	O
{	O
info	pointer
.	O
elfinfo	pointer
=	O
NULL	O
;	O
info	pointer
.	O
coffinfo	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
info	pointer
.	O
elfinfo	pointer
=	O
elf_symbol_from	O
(	O
abfd	pointer
,	O
sym	pointer
)	O
;	O
info	pointer
.	O
coffinfo	pointer
=	O
coff_symbol_from	O
(	O
sym	pointer
)	O
;	O
}	O
format	enum
->	O
print_symbol_info	pointer
(	O
&	O
info	pointer
,	O
abfd	pointer
)	O
;	O
if	O
(	O
with_symbol_versions	int
)	O
{	O
const	O
char	O
*	O
version_string	pointer
=	O
NULL	O
;	O
bfd_boolean	int
hidden	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_SYNTHETIC	O
)	O
)	O
==	O
0	int
)	O
version_string	pointer
=	O
bfd_get_symbol_version_string	O
(	O
abfd	pointer
,	O
sym	pointer
,	O
&	O
hidden	int
)	O
;	O
if	O
(	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
hidden	int
=	O
TRUE	int
;	O
if	O
(	O
version_string	pointer
&&	O
*	O
version_string	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
hidden	int
?	O
"@%s"	pointer
:	O
"@@%s"	pointer
,	O
version_string	pointer
)	O
;	O
}	O
if	O
(	O
line_numbers	int
)	O
{	O
static	O
asymbol	struct
*	O
*	O
syms	pointer
;	O
static	O
long	O
symcount	int
;	O
const	O
char	O
*	O
filename	pointer
,	O
*	O
functionname	pointer
;	O
unsigned	O
int	O
lineno	pointer
;	O
if	O
(	O
abfd	pointer
!=	O
lineno_cache_bfd	pointer
&&	O
syms	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
syms	pointer
)	O
;	O
syms	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
syms	pointer
==	O
NULL	O
)	O
{	O
long	O
symsize	long
;	O
symsize	long
=	O
bfd_get_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
symsize	long
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xmalloc	function
(	O
symsize	long
)	O
;	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
abfd	pointer
,	O
syms	pointer
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
lineno_cache_bfd	pointer
=	O
abfd	pointer
;	O
}	O
if	O
(	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
{	O
static	O
asection	struct
*	O
*	O
secs	pointer
;	O
static	O
arelent	struct
*	O
*	O
*	O
relocs	pointer
;	O
static	O
long	O
*	O
relcount	pointer
;	O
static	O
unsigned	O
int	O
seccount	int
;	O
unsigned	O
int	O
i	pointer
;	O
const	O
char	O
*	O
symname	pointer
;	O
if	O
(	O
abfd	pointer
!=	O
lineno_cache_rel_bfd	pointer
&&	O
relocs	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
seccount	int
;	O
i	pointer
++	O
)	O
if	O
(	O
relocs	pointer
[	O
i	pointer
]	O
!=	O
NULL	O
)	O
free	function
(	O
relocs	pointer
[	O
i	pointer
]	O
)	O
;	O
free	function
(	O
secs	pointer
)	O
;	O
free	function
(	O
relocs	pointer
)	O
;	O
free	function
(	O
relcount	pointer
)	O
;	O
secs	pointer
=	O
NULL	O
;	O
relocs	pointer
=	O
NULL	O
;	O
relcount	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
relocs	pointer
==	O
NULL	O
)	O
{	O
struct	O
get_relocs_info	struct
rinfo	struct
;	O
seccount	int
=	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
;	O
secs	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
xmalloc	function
(	O
seccount	int
*	O
sizeof	O
*	O
secs	pointer
)	O
;	O
relocs	pointer
=	O
(	O
arelent	struct
*	O
*	O
*	O
)	O
xmalloc	function
(	O
seccount	int
*	O
sizeof	O
*	O
relocs	pointer
)	O
;	O
relcount	pointer
=	O
(	O
long	O
*	O
)	O
xmalloc	function
(	O
seccount	int
*	O
sizeof	O
*	O
relcount	pointer
)	O
;	O
rinfo	struct
.	O
secs	pointer
=	O
secs	pointer
;	O
rinfo	struct
.	O
relocs	pointer
=	O
relocs	pointer
;	O
rinfo	struct
.	O
relcount	pointer
=	O
relcount	pointer
;	O
rinfo	struct
.	O
syms	pointer
=	O
syms	pointer
;	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
get_relocs	function
,	O
(	O
void	O
*	O
)	O
&	O
rinfo	struct
)	O
;	O
lineno_cache_rel_bfd	pointer
=	O
abfd	pointer
;	O
}	O
symname	pointer
=	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
seccount	int
;	O
i	pointer
++	O
)	O
{	O
long	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
relcount	pointer
[	O
i	pointer
]	O
;	O
j	long
++	O
)	O
{	O
arelent	struct
*	O
r	pointer
;	O
r	pointer
=	O
relocs	pointer
[	O
i	pointer
]	O
[	O
j	long
]	O
;	O
if	O
(	O
r	pointer
->	O
sym_ptr_ptr	pointer
!=	O
NULL	O
&&	O
(	O
*	O
r	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
section	pointer
==	O
sym	pointer
->	O
section	pointer
&&	O
(	O
*	O
r	pointer
->	O
sym_ptr_ptr	pointer
)	O
->	O
value	long
==	O
sym	pointer
->	O
value	long
&&	O
strcmp	function
(	O
symname	pointer
,	O
bfd_asymbol_name	function
(	O
*	O
r	pointer
->	O
sym_ptr_ptr	pointer
)	O
)	O
==	O
0	int
&&	O
bfd_find_nearest_line	O
(	O
abfd	pointer
,	O
secs	pointer
[	O
i	pointer
]	O
,	O
syms	pointer
,	O
r	pointer
->	O
address	long
,	O
&	O
filename	pointer
,	O
&	O
functionname	pointer
,	O
&	O
lineno	pointer
)	O
&&	O
filename	pointer
!=	O
NULL	O
)	O
{	O
printf	function
(	O
"\t%s:%u"	pointer
,	O
filename	pointer
,	O
lineno	pointer
)	O
;	O
i	pointer
=	O
seccount	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
->	O
owner	pointer
==	O
abfd	pointer
)	O
{	O
if	O
(	O
(	O
bfd_find_line	O
(	O
abfd	pointer
,	O
syms	pointer
,	O
sym	pointer
,	O
&	O
filename	pointer
,	O
&	O
lineno	pointer
)	O
||	O
bfd_find_nearest_line	O
(	O
abfd	pointer
,	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
,	O
syms	pointer
,	O
sym	pointer
->	O
value	long
,	O
&	O
filename	pointer
,	O
&	O
functionname	pointer
,	O
&	O
lineno	pointer
)	O
)	O
&&	O
filename	pointer
!=	O
NULL	O
&&	O
lineno	pointer
!=	O
0	int
)	O
printf	function
(	O
"\t%s:%u"	pointer
,	O
filename	pointer
,	O
lineno	pointer
)	O
;	O
}	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
print_size_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_dynamic	int
,	O
struct	O
size_sym	struct
*	O
symsizes	pointer
,	O
long	O
symcount	int
,	O
bfd	struct
*	O
archive_bfd	pointer
)	O
{	O
asymbol	struct
*	O
store	pointer
;	O
struct	O
size_sym	struct
*	O
from	pointer
;	O
struct	O
size_sym	struct
*	O
fromend	pointer
;	O
store	pointer
=	O
bfd_make_empty_symbol	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
store	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
from	pointer
=	O
symsizes	pointer
;	O
fromend	pointer
=	O
from	pointer
+	O
symcount	int
;	O
for	O
(	O
;	O
from	pointer
<	O
fromend	pointer
;	O
from	pointer
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
;	O
sym	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
abfd	pointer
,	O
is_dynamic	int
,	O
from	pointer
->	O
minisym	pointer
,	O
store	pointer
)	O
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
print_symbol	function
(	O
abfd	pointer
,	O
sym	pointer
,	O
from	pointer
->	O
size	int
,	O
archive_bfd	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
is_dynamic	int
,	O
void	O
*	O
minisyms	pointer
,	O
long	O
symcount	int
,	O
unsigned	O
int	O
size	int
,	O
bfd	struct
*	O
archive_bfd	pointer
)	O
{	O
asymbol	struct
*	O
store	pointer
;	O
bfd_byte	char
*	O
from	pointer
;	O
bfd_byte	char
*	O
fromend	pointer
;	O
store	pointer
=	O
bfd_make_empty_symbol	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
store	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
from	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
minisyms	pointer
;	O
fromend	pointer
=	O
from	pointer
+	O
symcount	int
*	O
size	int
;	O
for	O
(	O
;	O
from	pointer
<	O
fromend	pointer
;	O
from	pointer
+=	O
size	int
)	O
{	O
asymbol	struct
*	O
sym	pointer
;	O
sym	pointer
=	O
bfd_minisymbol_to_symbol	O
(	O
abfd	pointer
,	O
is_dynamic	int
,	O
from	pointer
,	O
store	pointer
)	O
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
print_symbol	function
(	O
abfd	pointer
,	O
sym	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
archive_bfd	pointer
)	O
;	O
}	O
}	O
static	O
void	O
display_rel_file	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd	struct
*	O
archive_bfd	pointer
)	O
{	O
long	O
symcount	int
;	O
void	O
*	O
minisyms	pointer
;	O
unsigned	O
int	O
size	int
;	O
struct	O
size_sym	struct
*	O
symsizes	pointer
;	O
asymbol	struct
*	O
synthsyms	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
dynamic	int
)	O
{	O
if	O
(	O
!	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
HAS_SYMS	int
)	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"%s: no symbols"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
symcount	int
=	O
bfd_read_minisymbols	O
(	O
abfd	pointer
,	O
dynamic	int
,	O
&	O
minisyms	pointer
,	O
&	O
size	int
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
{	O
if	O
(	O
dynamic	int
&&	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_no_symbols	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"%s: no symbols"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
return	O
;	O
}	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
if	O
(	O
symcount	int
==	O
0	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"%s: no symbols"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
show_synthetic	int
&&	O
size	int
==	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
{	O
asymbol	struct
*	O
*	O
static_syms	pointer
=	O
NULL	O
;	O
asymbol	struct
*	O
*	O
dyn_syms	pointer
=	O
NULL	O
;	O
long	O
static_count	long
=	O
0	int
;	O
long	O
dyn_count	long
=	O
0	int
;	O
long	O
synth_count	long
;	O
if	O
(	O
dynamic	int
)	O
{	O
dyn_count	long
=	O
symcount	int
;	O
dyn_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
minisyms	pointer
;	O
}	O
else	O
{	O
long	O
storage	long
=	O
bfd_get_dynamic_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
static_count	long
=	O
symcount	int
;	O
static_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
minisyms	pointer
;	O
if	O
(	O
storage	long
>	O
0	int
)	O
{	O
dyn_syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xmalloc	function
(	O
storage	long
)	O
;	O
dyn_count	long
=	O
bfd_canonicalize_dynamic_symtab	O
(	O
abfd	pointer
,	O
dyn_syms	pointer
)	O
;	O
if	O
(	O
dyn_count	long
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
}	O
synth_count	long
=	O
bfd_get_synthetic_symtab	O
(	O
abfd	pointer
,	O
static_count	long
,	O
static_syms	pointer
,	O
dyn_count	long
,	O
dyn_syms	pointer
,	O
&	O
synthsyms	pointer
)	O
;	O
if	O
(	O
synth_count	long
>	O
0	int
)	O
{	O
asymbol	struct
*	O
*	O
symp	pointer
;	O
long	O
i	pointer
;	O
minisyms	pointer
=	O
xrealloc	function
(	O
minisyms	pointer
,	O
(	O
symcount	int
+	O
synth_count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
symp	pointer
)	O
)	O
;	O
symp	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
minisyms	pointer
+	O
symcount	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
synth_count	long
;	O
i	pointer
++	O
)	O
*	O
symp	pointer
++	O
=	O
synthsyms	pointer
+	O
i	pointer
;	O
*	O
symp	pointer
=	O
0	int
;	O
symcount	int
+=	O
synth_count	long
;	O
}	O
if	O
(	O
!	O
dynamic	int
&&	O
dyn_syms	pointer
!=	O
NULL	O
)	O
free	function
(	O
dyn_syms	pointer
)	O
;	O
}	O
if	O
(	O
abfd	pointer
->	O
lto_slim_object	int
)	O
{	O
report_plugin_err	int
=	O
FALSE	int
;	O
non_fatal	function
(	O
_	O
(	O
"%s: plugin needed to handle lto object"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
symcount	int
=	O
filter_symbols	function
(	O
abfd	pointer
,	O
dynamic	int
,	O
minisyms	pointer
,	O
symcount	int
,	O
size	int
)	O
;	O
symsizes	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
no_sort	int
)	O
{	O
sort_bfd	pointer
=	O
abfd	pointer
;	O
sort_dynamic	int
=	O
dynamic	int
;	O
sort_x	pointer
=	O
bfd_make_empty_symbol	O
(	O
abfd	pointer
)	O
;	O
sort_y	pointer
=	O
bfd_make_empty_symbol	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
sort_x	pointer
==	O
NULL	O
||	O
sort_y	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
!	O
sort_by_size	int
)	O
qsort	function
(	O
minisyms	pointer
,	O
symcount	int
,	O
size	int
,	O
sorters	array
[	O
sort_numerically	int
]	O
[	O
reverse_sort	int
]	O
)	O
;	O
else	O
symcount	int
=	O
sort_symbols_by_size	function
(	O
abfd	pointer
,	O
dynamic	int
,	O
minisyms	pointer
,	O
symcount	int
,	O
size	int
,	O
&	O
symsizes	pointer
)	O
;	O
}	O
if	O
(	O
!	O
sort_by_size	int
)	O
print_symbols	function
(	O
abfd	pointer
,	O
dynamic	int
,	O
minisyms	pointer
,	O
symcount	int
,	O
size	int
,	O
archive_bfd	pointer
)	O
;	O
else	O
print_size_symbols	function
(	O
abfd	pointer
,	O
dynamic	int
,	O
symsizes	pointer
,	O
symcount	int
,	O
archive_bfd	pointer
)	O
;	O
if	O
(	O
synthsyms	pointer
)	O
free	function
(	O
synthsyms	pointer
)	O
;	O
free	function
(	O
minisyms	pointer
)	O
;	O
free	function
(	O
symsizes	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_print_format	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
padding	pointer
;	O
if	O
(	O
print_format	int
==	O
FORMAT_POSIX	int
)	O
{	O
padding	pointer
=	O
""	pointer
;	O
}	O
else	O
if	O
(	O
print_width	int
==	O
32	int
)	O
{	O
padding	pointer
=	O
"08"	pointer
;	O
}	O
else	O
{	O
padding	pointer
=	O
"016"	pointer
;	O
}	O
const	O
char	O
*	O
length	pointer
=	O
"l"	pointer
;	O
if	O
(	O
print_width	int
==	O
64	int
)	O
{	O
;	O
}	O
const	O
char	O
*	O
radix	pointer
=	O
NULL	O
;	O
switch	O
(	O
print_radix	int
)	O
{	O
case	O
8	int
:	O
radix	pointer
=	O
"o"	pointer
;	O
break	O
;	O
case	O
10	int
:	O
radix	pointer
=	O
"d"	pointer
;	O
break	O
;	O
case	O
16	int
:	O
radix	pointer
=	O
"x"	pointer
;	O
break	O
;	O
}	O
return	O
concat	function
(	O
"%"	pointer
,	O
padding	pointer
,	O
length	pointer
,	O
radix	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
set_print_width	function
(	O
bfd	struct
*	O
file	pointer
)	O
{	O
print_width	int
=	O
bfd_get_arch_size	function
(	O
file	pointer
)	O
;	O
if	O
(	O
print_width	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
strstr	function
(	O
bfd_get_target	function
(	O
file	pointer
)	O
,	O
"64"	pointer
)	O
!=	O
NULL	O
||	O
strcmp	function
(	O
bfd_get_target	function
(	O
file	pointer
)	O
,	O
"mmo"	pointer
)	O
==	O
0	int
)	O
print_width	int
=	O
64	int
;	O
else	O
print_width	int
=	O
32	int
;	O
}	O
free	function
(	O
(	O
char	O
*	O
)	O
print_format_string	pointer
)	O
;	O
print_format_string	pointer
=	O
get_print_format	function
(	O
)	O
;	O
}	O
static	O
void	O
display_archive	function
(	O
bfd	struct
*	O
file	pointer
)	O
{	O
bfd	struct
*	O
arfile	pointer
=	O
NULL	O
;	O
bfd	struct
*	O
last_arfile	pointer
=	O
NULL	O
;	O
char	O
*	O
*	O
matching	pointer
;	O
format	enum
->	O
print_archive_filename	pointer
(	O
bfd_get_filename	function
(	O
file	pointer
)	O
)	O
;	O
if	O
(	O
print_armap	int
)	O
print_symdef_entry	function
(	O
file	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
PROGRESS	O
(	O
1	int
)	O
;	O
arfile	pointer
=	O
bfd_openr_next_archived_file	function
(	O
file	pointer
,	O
arfile	pointer
)	O
;	O
if	O
(	O
arfile	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_no_more_archived_files	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
file	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bfd_check_format_matches	function
(	O
arfile	pointer
,	O
bfd_object	int
,	O
&	O
matching	pointer
)	O
)	O
{	O
set_print_width	function
(	O
arfile	pointer
)	O
;	O
format	enum
->	O
print_archive_member	pointer
(	O
bfd_get_filename	function
(	O
file	pointer
)	O
,	O
bfd_get_filename	function
(	O
arfile	pointer
)	O
)	O
;	O
display_rel_file	function
(	O
arfile	pointer
,	O
file	pointer
)	O
;	O
}	O
else	O
{	O
bfd_nonfatal	function
(	O
bfd_get_filename	function
(	O
arfile	pointer
)	O
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
matching	pointer
)	O
;	O
free	function
(	O
matching	pointer
)	O
;	O
}	O
}	O
if	O
(	O
last_arfile	pointer
!=	O
NULL	O
)	O
{	O
bfd_close	function
(	O
last_arfile	pointer
)	O
;	O
lineno_cache_bfd	pointer
=	O
NULL	O
;	O
lineno_cache_rel_bfd	pointer
=	O
NULL	O
;	O
if	O
(	O
arfile	pointer
==	O
last_arfile	pointer
)	O
return	O
;	O
}	O
last_arfile	pointer
=	O
arfile	pointer
;	O
}	O
if	O
(	O
last_arfile	pointer
!=	O
NULL	O
)	O
{	O
bfd_close	function
(	O
last_arfile	pointer
)	O
;	O
lineno_cache_bfd	pointer
=	O
NULL	O
;	O
lineno_cache_rel_bfd	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
bfd_boolean	int
display_file	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
bfd_boolean	int
retval	pointer
=	O
TRUE	int
;	O
bfd	struct
*	O
file	pointer
;	O
char	O
*	O
*	O
matching	pointer
;	O
if	O
(	O
get_file_size	function
(	O
filename	pointer
)	O
<	O
1	int
)	O
return	O
FALSE	int
;	O
file	pointer
=	O
bfd_openr	function
(	O
filename	pointer
,	O
target	pointer
?	O
target	pointer
:	O
plugin_target	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal	function
(	O
filename	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
line_numbers	int
)	O
file	pointer
->	O
flags	int
|=	O
BFD_DECOMPRESS	int
;	O
if	O
(	O
bfd_check_format	function
(	O
file	pointer
,	O
bfd_archive	int
)	O
)	O
{	O
display_archive	function
(	O
file	pointer
)	O
;	O
}	O
else	O
if	O
(	O
bfd_check_format_matches	function
(	O
file	pointer
,	O
bfd_object	int
,	O
&	O
matching	pointer
)	O
)	O
{	O
set_print_width	function
(	O
file	pointer
)	O
;	O
format	enum
->	O
print_object_filename	pointer
(	O
filename	pointer
)	O
;	O
display_rel_file	function
(	O
file	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
bfd_nonfatal	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
matching	pointer
)	O
;	O
free	function
(	O
matching	pointer
)	O
;	O
}	O
retval	pointer
=	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
bfd_close	function
(	O
file	pointer
)	O
)	O
bfd_fatal	function
(	O
filename	pointer
)	O
;	O
lineno_cache_bfd	pointer
=	O
NULL	O
;	O
lineno_cache_rel_bfd	pointer
=	O
NULL	O
;	O
return	O
retval	pointer
;	O
}	O
static	O
void	O
print_object_filename_bsd	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
filename_per_file	int
&&	O
!	O
filename_per_symbol	int
)	O
printf	function
(	O
"\n%s:\n"	pointer
,	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
print_object_filename_sysv	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
undefined_only	int
)	O
printf	function
(	O
_	O
(	O
"\n\nUndefined symbols from %s:\n\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\n\nSymbols from %s:\n\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
if	O
(	O
print_width	int
==	O
32	int
)	O
printf	function
(	O
_	O
(	O
"Name                  Value   Class        Type         Size     Line  Section\n\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"Name                  Value           Class        Type         Size             Line  Section\n\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
print_object_filename_posix	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
filename_per_file	int
&&	O
!	O
filename_per_symbol	int
)	O
printf	function
(	O
"%s:\n"	pointer
,	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
print_archive_filename_bsd	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
filename_per_file	int
)	O
printf	function
(	O
"\n%s:\n"	pointer
,	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
print_archive_filename_sysv	function
(	O
const	O
char	O
*	O
filename	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
static	O
void	O
print_archive_filename_posix	function
(	O
const	O
char	O
*	O
filename	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
static	O
void	O
print_archive_member_bsd	function
(	O
const	O
char	O
*	O
archive	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
!	O
filename_per_symbol	int
)	O
printf	function
(	O
"\n%s:\n"	pointer
,	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
print_archive_member_sysv	function
(	O
const	O
char	O
*	O
archive	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
undefined_only	int
)	O
printf	function
(	O
_	O
(	O
"\n\nUndefined symbols from %s[%s]:\n\n"	pointer
)	O
,	O
archive	pointer
,	O
filename	pointer
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\n\nSymbols from %s[%s]:\n\n"	pointer
)	O
,	O
archive	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
print_width	int
==	O
32	int
)	O
printf	function
(	O
_	O
(	O
"Name                  Value   Class        Type         Size     Line  Section\n\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"Name                  Value           Class        Type         Size             Line  Section\n\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
print_archive_member_posix	function
(	O
const	O
char	O
*	O
archive	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
!	O
filename_per_symbol	int
)	O
printf	function
(	O
"%s[%s]:\n"	pointer
,	O
archive	pointer
,	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
print_symbol_filename_bsd	function
(	O
bfd	struct
*	O
archive_bfd	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
filename_per_symbol	int
)	O
{	O
if	O
(	O
archive_bfd	pointer
)	O
printf	function
(	O
"%s:"	pointer
,	O
bfd_get_filename	function
(	O
archive_bfd	pointer
)	O
)	O
;	O
printf	function
(	O
"%s:"	pointer
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
print_symbol_filename_sysv	function
(	O
bfd	struct
*	O
archive_bfd	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
filename_per_symbol	int
)	O
{	O
if	O
(	O
archive_bfd	pointer
)	O
printf	function
(	O
"%s:"	pointer
,	O
bfd_get_filename	function
(	O
archive_bfd	pointer
)	O
)	O
;	O
printf	function
(	O
"%s:"	pointer
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
print_symbol_filename_posix	function
(	O
bfd	struct
*	O
archive_bfd	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
filename_per_symbol	int
)	O
{	O
if	O
(	O
archive_bfd	pointer
)	O
printf	function
(	O
"%s[%s]: "	pointer
,	O
bfd_get_filename	function
(	O
archive_bfd	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
"%s: "	pointer
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
print_value	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
val	array
)	O
{	O
switch	O
(	O
print_width	int
)	O
{	O
case	O
32	int
:	O
printf	function
(	O
print_format_string	pointer
,	O
(	O
unsigned	O
long	O
)	O
val	array
)	O
;	O
break	O
;	O
case	O
64	int
:	O
printf	function
(	O
print_format_string	pointer
,	O
val	array
)	O
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
_	O
(	O
"Print width has not been initialized (%d)"	pointer
)	O
,	O
print_width	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
print_symbol_info_bsd	function
(	O
struct	O
extended_symbol_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
bfd_is_undefined_symclass	function
(	O
SYM_TYPE	O
(	O
info	pointer
)	O
)	O
)	O
{	O
if	O
(	O
print_width	int
==	O
64	int
)	O
printf	function
(	O
"        "	pointer
)	O
;	O
printf	function
(	O
"        "	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sort_by_size	int
&&	O
!	O
print_size	int
)	O
print_value	function
(	O
abfd	pointer
,	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
;	O
else	O
print_value	function
(	O
abfd	pointer
,	O
SYM_VALUE	O
(	O
info	pointer
)	O
)	O
;	O
if	O
(	O
print_size	int
&&	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
{	O
printf	function
(	O
" "	pointer
)	O
;	O
print_value	function
(	O
abfd	pointer
,	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
;	O
}	O
}	O
printf	function
(	O
" %c"	pointer
,	O
SYM_TYPE	O
(	O
info	pointer
)	O
)	O
;	O
if	O
(	O
SYM_TYPE	O
(	O
info	pointer
)	O
==	O
'-'	O
)	O
{	O
printf	function
(	O
" "	pointer
)	O
;	O
printf	function
(	O
other_format	array
,	O
SYM_STAB_OTHER	O
(	O
info	pointer
)	O
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
printf	function
(	O
desc_format	array
,	O
SYM_STAB_DESC	O
(	O
info	pointer
)	O
)	O
;	O
printf	function
(	O
" %5s"	pointer
,	O
SYM_STAB_NAME	O
(	O
info	pointer
)	O
)	O
;	O
}	O
print_symname	function
(	O
" %s"	pointer
,	O
SYM_NAME	O
(	O
info	pointer
)	O
,	O
abfd	pointer
)	O
;	O
}	O
static	O
void	O
print_symbol_info_sysv	function
(	O
struct	O
extended_symbol_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
print_symname	function
(	O
"%-20s|"	pointer
,	O
SYM_NAME	O
(	O
info	pointer
)	O
,	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_is_undefined_symclass	function
(	O
SYM_TYPE	O
(	O
info	pointer
)	O
)	O
)	O
{	O
if	O
(	O
print_width	int
==	O
32	int
)	O
printf	function
(	O
"        "	pointer
)	O
;	O
else	O
printf	function
(	O
"                "	pointer
)	O
;	O
}	O
else	O
print_value	function
(	O
abfd	pointer
,	O
SYM_VALUE	O
(	O
info	pointer
)	O
)	O
;	O
printf	function
(	O
"|   %c  |"	pointer
,	O
SYM_TYPE	O
(	O
info	pointer
)	O
)	O
;	O
if	O
(	O
SYM_TYPE	O
(	O
info	pointer
)	O
==	O
'-'	O
)	O
{	O
printf	function
(	O
"%18s|  "	pointer
,	O
SYM_STAB_NAME	O
(	O
info	pointer
)	O
)	O
;	O
printf	function
(	O
desc_format	array
,	O
SYM_STAB_DESC	O
(	O
info	pointer
)	O
)	O
;	O
printf	function
(	O
"|     |"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
info	pointer
->	O
elfinfo	pointer
)	O
printf	function
(	O
"%18s|"	pointer
,	O
get_elf_symbol_type	function
(	O
ELF_ST_TYPE	O
(	O
info	pointer
->	O
elfinfo	pointer
->	O
internal_elf_sym	struct
.	O
st_info	array
)	O
)	O
)	O
;	O
else	O
if	O
(	O
info	pointer
->	O
coffinfo	pointer
)	O
printf	function
(	O
"%18s|"	pointer
,	O
get_coff_symbol_type	function
(	O
&	O
info	pointer
->	O
coffinfo	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
)	O
)	O
;	O
else	O
printf	function
(	O
"                  |"	pointer
)	O
;	O
if	O
(	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
print_value	function
(	O
abfd	pointer
,	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
print_width	int
==	O
32	int
)	O
printf	function
(	O
"        "	pointer
)	O
;	O
else	O
printf	function
(	O
"                "	pointer
)	O
;	O
}	O
if	O
(	O
info	pointer
->	O
elfinfo	pointer
)	O
printf	function
(	O
"|     |%s"	pointer
,	O
info	pointer
->	O
elfinfo	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
info	pointer
->	O
coffinfo	pointer
)	O
printf	function
(	O
"|     |%s"	pointer
,	O
info	pointer
->	O
coffinfo	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
name	pointer
)	O
;	O
else	O
printf	function
(	O
"|     |"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_symbol_info_posix	function
(	O
struct	O
extended_symbol_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
print_symname	function
(	O
"%s "	pointer
,	O
SYM_NAME	O
(	O
info	pointer
)	O
,	O
abfd	pointer
)	O
;	O
printf	function
(	O
"%c "	pointer
,	O
SYM_TYPE	O
(	O
info	pointer
)	O
)	O
;	O
if	O
(	O
bfd_is_undefined_symclass	function
(	O
SYM_TYPE	O
(	O
info	pointer
)	O
)	O
)	O
printf	function
(	O
"        "	pointer
)	O
;	O
else	O
{	O
print_value	function
(	O
abfd	pointer
,	O
SYM_VALUE	O
(	O
info	pointer
)	O
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
print_value	function
(	O
abfd	pointer
,	O
SYM_SIZE	O
(	O
info	pointer
)	O
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	struct
;	O
int	O
retval	pointer
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_COLLATE	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
program_name	pointer
=	O
*	O
argv	pointer
;	O
xmalloc_set_program_name	function
(	O
program_name	pointer
)	O
;	O
bfd_set_error_program_name	function
(	O
program_name	pointer
)	O
;	O
bfd_plugin_set_program_name	function
(	O
program_name	pointer
)	O
;	O
START_PROGRESS	O
(	O
program_name	pointer
,	O
0	int
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
bfd_init	function
(	O
)	O
!=	O
BFD_INIT_MAGIC	O
)	O
fatal	function
(	O
_	O
(	O
"fatal error: libbfd ABI mismatch"	pointer
)	O
)	O
;	O
set_default_bfd_target	function
(	O
)	O
;	O
while	O
(	O
(	O
c	struct
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"aABCDef:gHhlnopPrSst:uvVvX:"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	struct
)	O
{	O
case	O
'a'	O
:	O
print_debug_syms	int
=	O
1	int
;	O
break	O
;	O
case	O
'A'	O
:	O
case	O
'o'	O
:	O
filename_per_symbol	int
=	O
1	int
;	O
break	O
;	O
case	O
'B'	O
:	O
set_output_format	function
(	O
"bsd"	pointer
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
do_demangle	int
=	O
1	int
;	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
{	O
enum	O
demangling_styles	enum
style	enum
;	O
style	enum
=	O
cplus_demangle_name_to_style	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
style	enum
==	O
unknown_demangling	int
)	O
fatal	function
(	O
_	O
(	O
"unknown demangling style `%s'"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
cplus_demangle_set_style	function
(	O
style	enum
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_RECURSE_LIMIT	int
:	O
demangle_flags	int
&=	O
~	O
DMGL_NO_RECURSE_LIMIT	O
;	O
break	O
;	O
case	O
OPTION_NO_RECURSE_LIMIT	int
:	O
demangle_flags	int
|=	O
DMGL_NO_RECURSE_LIMIT	O
;	O
break	O
;	O
case	O
'D'	O
:	O
dynamic	int
=	O
1	int
;	O
break	O
;	O
case	O
'e'	O
:	O
break	O
;	O
case	O
'f'	O
:	O
set_output_format	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
external_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
case	O
'h'	O
:	O
usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
case	O
'l'	O
:	O
line_numbers	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'v'	O
:	O
no_sort	int
=	O
0	int
;	O
sort_numerically	int
=	O
1	int
;	O
sort_by_size	int
=	O
0	int
;	O
break	O
;	O
case	O
'p'	O
:	O
no_sort	int
=	O
1	int
;	O
sort_numerically	int
=	O
0	int
;	O
sort_by_size	int
=	O
0	int
;	O
break	O
;	O
case	O
OPTION_SIZE_SORT	int
:	O
no_sort	int
=	O
0	int
;	O
sort_numerically	int
=	O
0	int
;	O
sort_by_size	int
=	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
set_output_format	function
(	O
"posix"	pointer
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
reverse_sort	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
print_armap	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
print_size	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
set_print_radix	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
undefined_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
1	int
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"32_64"	pointer
)	O
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"Only -X 32_64 is supported"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_TARGET	int
:	O
target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_PLUGIN	int
:	O
bfd_plugin_set_plugin	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
show_version	int
)	O
print_version	function
(	O
"nm"	pointer
)	O
;	O
if	O
(	O
sort_by_size	int
&&	O
undefined_only	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"Using the --size-sort and --undefined-only options together"	pointer
)	O
)	O
;	O
non_fatal	function
(	O
_	O
(	O
"will produce no output, since undefined symbols have no size."	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
return	O
!	O
display_file	function
(	O
"a.out"	pointer
)	O
;	O
retval	pointer
=	O
0	int
;	O
if	O
(	O
argc	int
-	O
optind	int
>	O
1	int
)	O
filename_per_file	int
=	O
1	int
;	O
while	O
(	O
optind	int
<	O
argc	int
)	O
{	O
PROGRESS	O
(	O
1	int
)	O
;	O
if	O
(	O
!	O
display_file	function
(	O
argv	pointer
[	O
optind	int
++	O
]	O
)	O
)	O
retval	pointer
++	O
;	O
}	O
END_PROGRESS	O
(	O
program_name	pointer
)	O
;	O
exit	function
(	O
retval	pointer
)	O
;	O
return	O
retval	pointer
;	O
}	O
