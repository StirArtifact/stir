static	O
const	O
int	O
_ai_fill_rule	array
[	O
PL_NUM_FILL_RULES	int
]	O
=	O
{	O
AI_FILL_ODD_WINDING	int
,	O
AI_FILL_NONZERO_WINDING	int
}	O
;	O
static	O
const	O
int	O
_ai_join_style	array
[	O
PL_NUM_JOIN_TYPES	int
]	O
=	O
{	O
AI_LINE_JOIN_MITER	int
,	O
AI_LINE_JOIN_ROUND	int
,	O
AI_LINE_JOIN_BEVEL	int
,	O
AI_LINE_JOIN_ROUND	int
}	O
;	O
static	O
const	O
int	O
_ai_cap_style	array
[	O
PL_NUM_CAP_TYPES	int
]	O
=	O
{	O
AI_LINE_CAP_BUTT	int
,	O
AI_LINE_CAP_ROUND	int
,	O
AI_LINE_CAP_PROJECT	int
,	O
AI_LINE_CAP_ROUND	int
}	O
;	O
void	O
_pl_a_set_attributes	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
bool	enum
changed_width	enum
=	O
false	int
;	O
int	O
desired_fill_rule	int
=	O
_ai_fill_rule	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_rule_type	int
]	O
;	O
double	O
desired_ai_line_width	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
;	O
int	O
desired_ai_cap_style	int
=	O
_ai_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
;	O
int	O
desired_ai_join_style	int
=	O
_ai_join_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
]	O
;	O
double	O
desired_ai_miter_limit	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
;	O
int	O
desired_ai_line_type	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
;	O
int	O
i	int
;	O
double	O
display_size_in_points	double
,	O
min_dash_unit	int
;	O
if	O
(	O
_plotter	pointer
->	O
ai_version	int
>=	O
AI_VERSION_5	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
>	O
0	int
&&	O
_plotter	pointer
->	O
ai_fill_rule_type	int
!=	O
desired_fill_rule	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d XR\n"	pointer
,	O
desired_fill_rule	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_fill_rule_type	int
=	O
desired_fill_rule	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
ai_cap_style	int
!=	O
desired_ai_cap_style	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d J\n"	pointer
,	O
desired_ai_cap_style	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_cap_style	int
=	O
desired_ai_cap_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
ai_join_style	int
!=	O
desired_ai_join_style	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d j\n"	pointer
,	O
desired_ai_join_style	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_join_style	int
=	O
desired_ai_join_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
==	O
PL_JOIN_MITER	int
&&	O
_plotter	pointer
->	O
ai_miter_limit	double
!=	O
desired_ai_miter_limit	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.4g M\n"	pointer
,	O
desired_ai_miter_limit	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_miter_limit	double
=	O
desired_ai_miter_limit	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
ai_line_width	double
!=	O
desired_ai_line_width	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.4f w\n"	pointer
,	O
desired_ai_line_width	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_line_width	double
=	O
desired_ai_line_width	int
;	O
changed_width	enum
=	O
true	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
||	O
_plotter	pointer
->	O
ai_line_type	int
!=	O
desired_ai_line_type	int
||	O
(	O
changed_width	int
&&	O
desired_ai_line_type	int
!=	O
PL_L_SOLID	int
)	O
)	O
{	O
double	O
*	O
dashbuf	pointer
;	O
int	O
num_dashes	int
;	O
double	O
offset	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
)	O
{	O
num_dashes	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_len	int
;	O
if	O
(	O
num_dashes	int
>	O
0	int
)	O
{	O
double	O
min_sing_val	pointer
,	O
max_sing_val	pointer
;	O
_matrix_sing_vals	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
double	O
dashlen	int
;	O
dashlen	int
=	O
min_sing_val	pointer
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
i	int
]	O
;	O
dashbuf	pointer
[	O
i	int
]	O
=	O
dashlen	int
;	O
}	O
offset	double
=	O
min_sing_val	pointer
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_offset	double
;	O
}	O
else	O
{	O
dashbuf	pointer
=	O
NULL	O
;	O
offset	int
=	O
0	int
;	O
}	O
desired_ai_line_type	double
=	O
SPECIAL_AI_LINE_TYPE	int
;	O
}	O
else	O
{	O
if	O
(	O
desired_ai_line_type	int
==	O
PL_L_SOLID	int
)	O
{	O
num_dashes	int
=	O
0	int
;	O
dashbuf	pointer
=	O
NULL	O
;	O
offset	double
=	O
0.0	int
;	O
}	O
else	O
{	O
const	O
int	O
*	O
dash_array	pointer
;	O
double	O
scale	double
;	O
num_dashes	int
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array_len	int
;	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
dash_array	pointer
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array	pointer
;	O
display_size_in_points	double
=	O
DMIN	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
,	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
)	O
;	O
min_dash_unit	int
=	O
(	O
PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE	struct
*	O
display_size_in_points	pointer
)	O
;	O
scale	double
=	O
DMAX	O
(	O
min_dash_unit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
dashbuf	pointer
[	O
i	int
]	O
=	O
scale	double
*	O
dash_array	pointer
[	O
i	int
]	O
;	O
offset	double
=	O
0.0	int
;	O
}	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"["	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.4f"	pointer
,	O
dashbuf	pointer
[	O
i	int
]	O
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
" %.4f"	pointer
,	O
dashbuf	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"] %.4f d\n"	pointer
,	O
offset	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_line_type	pointer
=	O
desired_ai_line_type	pointer
;	O
free	function
(	O
dashbuf	pointer
)	O
;	O
}	O
return	O
;	O
}	O