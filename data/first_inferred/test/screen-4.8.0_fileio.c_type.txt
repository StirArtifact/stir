extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
int	O
ServerSocket	int
;	O
extern	O
int	O
real_uid	int
,	O
eff_uid	int
;	O
extern	O
int	O
real_gid	int
,	O
eff_gid	int
;	O
extern	O
char	O
*	O
extra_incap	pointer
,	O
*	O
extra_outcap	pointer
;	O
extern	O
char	O
*	O
home	pointer
,	O
*	O
RcFileName	pointer
;	O
extern	O
char	O
SockPath	array
[	O
]	O
,	O
*	O
SockName	pointer
;	O
extern	O
char	O
*	O
BufferFile	pointer
;	O
extern	O
int	O
hardcopy_append	int
;	O
extern	O
char	O
*	O
hardcopydir	pointer
;	O
static	O
char	O
*	O
CatExtra	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
findrcfile	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
char	O
*	O
rc_name	pointer
=	O
""	pointer
;	O
int	O
rc_recursion	int
=	O
0	int
;	O
static	O
char	O
*	O
CatExtra	function
(	O
register	O
char	O
*	O
str1	pointer
,	O
register	O
char	O
*	O
str2	pointer
)	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
register	O
int	O
len1	int
,	O
len2	int
,	O
add_colon	int
;	O
len1	int
=	O
strlen	function
(	O
str1	pointer
)	O
;	O
if	O
(	O
len1	int
==	O
0	int
)	O
return	O
str2	pointer
;	O
add_colon	int
=	O
(	O
str1	pointer
[	O
len1	int
-	O
1	int
]	O
!=	O
':'	O
)	O
;	O
if	O
(	O
str2	pointer
)	O
{	O
len2	int
=	O
strlen	function
(	O
str2	pointer
)	O
;	O
if	O
(	O
(	O
cp	pointer
=	O
realloc	function
(	O
str2	pointer
,	O
(	O
unsigned	O
)	O
len1	int
+	O
len2	int
+	O
add_colon	int
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
bcopy	function
(	O
cp	pointer
,	O
cp	pointer
+	O
len1	int
+	O
add_colon	int
,	O
len2	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
cp	pointer
=	O
malloc	function
(	O
(	O
unsigned	O
)	O
len1	int
+	O
add_colon	int
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
cp	pointer
[	O
len1	int
+	O
add_colon	int
]	O
=	O
'\0'	O
;	O
}	O
bcopy	function
(	O
str1	pointer
,	O
cp	pointer
,	O
len1	int
)	O
;	O
if	O
(	O
add_colon	int
)	O
cp	pointer
[	O
len1	int
]	O
=	O
':'	O
;	O
return	O
cp	pointer
;	O
}	O
static	O
char	O
*	O
findrcfile	function
(	O
char	O
*	O
rcfile	pointer
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
rcfile	pointer
&&	O
*	O
rcfile	pointer
==	O
'~'	O
)	O
{	O
static	O
char	O
rcfilename_tilde_exp	array
[	O
MAXPATHLEN	O
+	O
1	int
]	O
;	O
char	O
*	O
slash_position	pointer
=	O
strchr	function
(	O
rcfile	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
slash_position	pointer
==	O
rcfile	pointer
+	O
1	int
)	O
{	O
char	O
*	O
home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
!	O
home	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: source: tilde expansion failed"	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
snprintf	function
(	O
rcfilename_tilde_exp	array
,	O
MAXPATHLEN	O
,	O
"%s/%s"	pointer
,	O
home	pointer
,	O
rcfile	pointer
+	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
slash_position	pointer
)	O
{	O
struct	O
passwd	struct
*	O
p	pointer
;	O
*	O
slash_position	pointer
=	O
0	int
;	O
p	pointer
=	O
getpwnam	function
(	O
rcfile	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: source: tilde expansion failed for user %s"	pointer
,	O
rc_name	pointer
,	O
rcfile	pointer
+	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
snprintf	function
(	O
rcfilename_tilde_exp	array
,	O
MAXPATHLEN	O
,	O
"%s/%s"	pointer
,	O
p	pointer
->	O
pw_dir	pointer
,	O
slash_position	pointer
+	O
1	int
)	O
;	O
}	O
else	O
{	O
Msg	function
(	O
0	int
,	O
"%s: source: illegal tilde expression."	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
rcfile	pointer
=	O
rcfilename_tilde_exp	array
;	O
}	O
if	O
(	O
rcfile	pointer
)	O
{	O
char	O
*	O
rcend	pointer
=	O
rindex	function
(	O
rc_name	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
*	O
rcfile	pointer
!=	O
'/'	O
&&	O
rcend	pointer
&&	O
(	O
rcend	pointer
-	O
rc_name	pointer
)	O
+	O
strlen	function
(	O
rcfile	pointer
)	O
+	O
2	int
<	O
sizeof	O
(	O
buf	pointer
)	O
)	O
{	O
strncpy	function
(	O
buf	pointer
,	O
rc_name	pointer
,	O
rcend	pointer
-	O
rc_name	pointer
+	O
1	int
)	O
;	O
strcpy	function
(	O
buf	pointer
+	O
(	O
rcend	pointer
-	O
rc_name	pointer
)	O
+	O
1	int
,	O
rcfile	pointer
)	O
;	O
if	O
(	O
access	function
(	O
buf	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
SaveStr	function
(	O
buf	pointer
)	O
;	O
}	O
debug1	O
(	O
"findrcfile: you specified '%s'\n"	pointer
,	O
rcfile	pointer
)	O
;	O
return	O
SaveStr	function
(	O
rcfile	pointer
)	O
;	O
}	O
debug	O
(	O
"findrcfile: you specified nothing...\n"	pointer
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
getenv	function
(	O
"SCREENRC"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
debug1	O
(	O
"  $SCREENRC has: '%s'\n"	pointer
,	O
p	pointer
)	O
;	O
return	O
SaveStr	function
(	O
p	pointer
)	O
;	O
}	O
else	O
{	O
debug	O
(	O
"  ...nothing in $SCREENRC, defaulting $HOME/.screenrc\n"	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
home	pointer
)	O
>	O
sizeof	O
(	O
buf	pointer
)	O
-	O
12	int
)	O
Panic	function
(	O
0	int
,	O
"Rc: home too large"	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s/.screenrc"	pointer
,	O
home	pointer
)	O
;	O
return	O
SaveStr	function
(	O
buf	pointer
)	O
;	O
}	O
}	O
int	O
StartRc	function
(	O
char	O
*	O
rcfilename	pointer
,	O
int	O
nopanic	int
)	O
{	O
register	O
int	O
argc	int
,	O
len	int
;	O
register	O
char	O
*	O
p	pointer
,	O
*	O
cp	pointer
;	O
char	O
buf	pointer
[	O
2048	int
]	O
;	O
char	O
*	O
args	pointer
[	O
MAXARGS	int
]	O
;	O
int	O
argl	pointer
[	O
MAXARGS	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
oldrc_name	pointer
=	O
rc_name	pointer
;	O
extra_incap	pointer
=	O
CatExtra	function
(	O
"TF"	pointer
,	O
extra_incap	pointer
)	O
;	O
if	O
(	O
display	struct
&&	O
(	O
!	O
strncmp	function
(	O
D_termname	O
,	O
"vt"	pointer
,	O
2	int
)	O
||	O
!	O
strncmp	function
(	O
D_termname	O
,	O
"xterm"	pointer
,	O
5	int
)	O
)	O
)	O
extra_incap	pointer
=	O
CatExtra	function
(	O
"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX"	pointer
,	O
extra_incap	pointer
)	O
;	O
rc_name	pointer
=	O
findrcfile	function
(	O
rcfilename	pointer
)	O
;	O
if	O
(	O
rc_name	pointer
==	O
NULL	O
||	O
(	O
fp	pointer
=	O
secfopen	function
(	O
rc_name	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
rc_nonnull	pointer
=	O
rc_name	pointer
?	O
rc_name	pointer
:	O
rcfilename	pointer
;	O
if	O
(	O
!	O
rc_recursion	int
&&	O
RcFileName	pointer
&&	O
!	O
strcmp	function
(	O
RcFileName	pointer
,	O
rc_nonnull	pointer
)	O
)	O
{	O
debug3	O
(	O
"StartRc: '%s','%s', '%s'\n"	pointer
,	O
RcFileName	pointer
,	O
rc_name	pointer
?	O
rc_name	pointer
:	O
"(null)"	pointer
,	O
rcfilename	pointer
)	O
;	O
if	O
(	O
!	O
nopanic	int
)	O
Panic	function
(	O
0	int
,	O
"Unable to open \"%s\"."	pointer
,	O
rc_nonnull	pointer
)	O
;	O
}	O
debug1	O
(	O
"StartRc: '%s' no good. ignored\n"	pointer
,	O
rc_nonnull	pointer
)	O
;	O
if	O
(	O
rc_name	pointer
)	O
Free	O
(	O
rc_name	pointer
)	O
;	O
rc_name	pointer
=	O
oldrc_name	pointer
;	O
return	O
1	int
;	O
}	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
fp	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
rindex	function
(	O
buf	pointer
,	O
'\n'	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
argc	int
=	O
Parse	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
args	pointer
,	O
argl	pointer
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"echo"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
continue	O
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
(	O
argc	int
==	O
3	int
&&	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"-n"	pointer
)	O
)	O
||	O
argc	int
>	O
3	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: 'echo [-n] \"string\"' expected."	pointer
,	O
rc_name	pointer
)	O
;	O
continue	O
;	O
}	O
AddStr	function
(	O
args	pointer
[	O
argc	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
argc	int
!=	O
3	int
)	O
{	O
AddStr	function
(	O
"\r\n"	pointer
)	O
;	O
Flush	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"sleep"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
continue	O
;	O
debug	O
(	O
"sleeeeeeep\n"	pointer
)	O
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: sleep: one numeric argument expected."	pointer
,	O
rc_name	pointer
)	O
;	O
continue	O
;	O
}	O
DisplaySleep1000	function
(	O
1000	int
*	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"termcapinfo"	pointer
)	O
||	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"terminfo"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
continue	O
;	O
if	O
(	O
argc	int
<	O
3	int
||	O
argc	int
>	O
4	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: incorrect number of arguments."	pointer
,	O
rc_name	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
p	pointer
=	O
args	pointer
[	O
1	int
]	O
;	O
p	pointer
&&	O
*	O
p	pointer
;	O
p	pointer
=	O
cp	pointer
)	O
{	O
if	O
(	O
(	O
cp	pointer
=	O
index	function
(	O
p	pointer
,	O
'|'	O
)	O
)	O
!=	O
0	int
)	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
len	int
=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'*'	O
)	O
{	O
if	O
(	O
!	O
(	O
len	int
-	O
1	int
)	O
||	O
!	O
strncmp	function
(	O
p	pointer
,	O
D_termname	O
,	O
len	int
-	O
1	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
p	pointer
,	O
D_termname	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
p	pointer
&&	O
*	O
p	pointer
)	O
)	O
continue	O
;	O
extra_incap	pointer
=	O
CatExtra	function
(	O
args	pointer
[	O
2	int
]	O
,	O
extra_incap	pointer
)	O
;	O
if	O
(	O
argc	int
==	O
4	int
)	O
extra_outcap	pointer
=	O
CatExtra	function
(	O
args	pointer
[	O
3	int
]	O
,	O
extra_outcap	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"source"	pointer
)	O
)	O
{	O
if	O
(	O
rc_recursion	int
<=	O
10	int
)	O
{	O
rc_recursion	int
++	O
;	O
(	O
void	O
)	O
StartRc	function
(	O
args	pointer
[	O
1	int
]	O
,	O
0	int
)	O
;	O
rc_recursion	int
--	O
;	O
}	O
}	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
Free	O
(	O
rc_name	pointer
)	O
;	O
rc_name	pointer
=	O
oldrc_name	pointer
;	O
return	O
0	int
;	O
}	O
void	O
FinishRc	function
(	O
char	O
*	O
rcfilename	pointer
)	O
{	O
char	O
buf	pointer
[	O
2048	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
oldrc_name	pointer
=	O
rc_name	pointer
;	O
rc_name	pointer
=	O
findrcfile	function
(	O
rcfilename	pointer
)	O
;	O
if	O
(	O
rc_name	pointer
==	O
NULL	O
||	O
(	O
fp	pointer
=	O
secfopen	function
(	O
rc_name	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
rc_nonnull	pointer
=	O
rc_name	pointer
?	O
rc_name	pointer
:	O
rcfilename	pointer
;	O
if	O
(	O
rc_recursion	int
)	O
Msg	function
(	O
errno	O
,	O
"%s: source %s"	pointer
,	O
oldrc_name	pointer
,	O
rc_nonnull	pointer
)	O
;	O
else	O
if	O
(	O
RcFileName	pointer
&&	O
!	O
strcmp	function
(	O
RcFileName	pointer
,	O
rc_nonnull	pointer
)	O
)	O
{	O
debug3	O
(	O
"FinishRc:'%s','%s','%s'\n"	pointer
,	O
RcFileName	pointer
,	O
rc_name	pointer
?	O
rc_name	pointer
:	O
"(null)"	pointer
,	O
rcfilename	pointer
)	O
;	O
Panic	function
(	O
0	int
,	O
"Unable to open \"%s\"."	pointer
,	O
rc_nonnull	pointer
)	O
;	O
}	O
debug1	O
(	O
"FinishRc: '%s' no good. ignored\n"	pointer
,	O
rc_nonnull	pointer
)	O
;	O
if	O
(	O
rc_name	pointer
)	O
Free	O
(	O
rc_name	pointer
)	O
;	O
rc_name	pointer
=	O
oldrc_name	pointer
;	O
return	O
;	O
}	O
debug	O
(	O
"finishrc is going...\n"	pointer
)	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
fp	pointer
)	O
!=	O
NULL	O
)	O
RcLine	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
(	O
void	O
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
Free	O
(	O
rc_name	pointer
)	O
;	O
rc_name	pointer
=	O
oldrc_name	pointer
;	O
}	O
void	O
do_source	function
(	O
char	O
*	O
rcfilename	pointer
)	O
{	O
if	O
(	O
rc_recursion	int
>	O
10	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: source: recursion limit reached"	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
;	O
}	O
rc_recursion	int
++	O
;	O
FinishRc	function
(	O
rcfilename	pointer
)	O
;	O
rc_recursion	int
--	O
;	O
}	O
void	O
RcLine	function
(	O
char	O
*	O
ubuf	pointer
,	O
int	O
ubufl	int
)	O
{	O
char	O
*	O
args	pointer
[	O
MAXARGS	int
]	O
;	O
int	O
argl	pointer
[	O
MAXARGS	int
]	O
;	O
extern	O
struct	O
acluser	struct
*	O
EffectiveAclUser	pointer
;	O
extern	O
struct	O
acluser	struct
*	O
users	pointer
;	O
if	O
(	O
display	struct
)	O
{	O
fore	pointer
=	O
D_fore	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
}	O
else	O
flayer	pointer
=	O
fore	pointer
?	O
fore	pointer
->	O
w_savelayer	pointer
:	O
0	int
;	O
if	O
(	O
Parse	function
(	O
ubuf	pointer
,	O
ubufl	int
,	O
args	pointer
,	O
argl	pointer
)	O
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
display	struct
)	O
{	O
EffectiveAclUser	pointer
=	O
users	pointer
;	O
debug	O
(	O
"RcLine: WARNING, no display no user! Session owner executes command\n"	pointer
)	O
;	O
}	O
DoCommand	function
(	O
args	pointer
,	O
argl	pointer
)	O
;	O
EffectiveAclUser	pointer
=	O
0	int
;	O
}	O
void	O
WriteFile	function
(	O
struct	O
acluser	struct
*	O
user	pointer
,	O
char	O
*	O
fn	pointer
,	O
int	O
dump	int
)	O
{	O
register	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
register	O
char	O
*	O
p	pointer
;	O
register	O
FILE	struct
*	O
f	pointer
;	O
char	O
fnbuf	array
[	O
1024	int
]	O
;	O
char	O
*	O
mode	struct
=	O
"w"	pointer
;	O
int	O
public	int
=	O
0	int
;	O
struct	O
stat	struct
stb	struct
,	O
stb2	struct
;	O
int	O
fd	int
,	O
exists	int
=	O
0	int
;	O
switch	O
(	O
dump	int
)	O
{	O
case	O
DUMP_TERMCAP	int
:	O
if	O
(	O
fn	pointer
==	O
0	int
)	O
{	O
i	int
=	O
SockName	pointer
-	O
SockPath	array
;	O
if	O
(	O
i	int
>	O
(	O
int	O
)	O
sizeof	O
(	O
fnbuf	array
)	O
-	O
9	int
)	O
i	int
=	O
0	int
;	O
strncpy	function
(	O
fnbuf	array
,	O
SockPath	array
,	O
i	int
)	O
;	O
strcpy	function
(	O
fnbuf	array
+	O
i	int
,	O
".termcap"	pointer
)	O
;	O
fn	pointer
=	O
fnbuf	array
;	O
}	O
break	O
;	O
case	O
DUMP_HARDCOPY	int
:	O
case	O
DUMP_SCROLLBACK	int
:	O
if	O
(	O
fn	pointer
==	O
0	int
)	O
{	O
if	O
(	O
fore	pointer
==	O
0	int
)	O
return	O
;	O
if	O
(	O
hardcopydir	pointer
&&	O
*	O
hardcopydir	pointer
&&	O
strlen	function
(	O
hardcopydir	pointer
)	O
<	O
sizeof	O
(	O
fnbuf	array
)	O
-	O
21	int
)	O
sprintf	function
(	O
fnbuf	array
,	O
"%s/hardcopy.%d"	pointer
,	O
hardcopydir	pointer
,	O
fore	pointer
->	O
w_number	int
)	O
;	O
else	O
sprintf	function
(	O
fnbuf	array
,	O
"hardcopy.%d"	pointer
,	O
fore	pointer
->	O
w_number	int
)	O
;	O
fn	pointer
=	O
fnbuf	array
;	O
}	O
if	O
(	O
hardcopy_append	int
&&	O
!	O
access	function
(	O
fn	pointer
,	O
W_OK	int
)	O
)	O
mode	struct
=	O
"a"	pointer
;	O
break	O
;	O
case	O
DUMP_EXCHANGE	int
:	O
if	O
(	O
fn	pointer
==	O
0	int
)	O
{	O
strncpy	function
(	O
fnbuf	array
,	O
BufferFile	pointer
,	O
sizeof	O
(	O
fnbuf	array
)	O
-	O
1	int
)	O
;	O
fnbuf	array
[	O
sizeof	O
(	O
fnbuf	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
fn	pointer
=	O
fnbuf	array
;	O
}	O
public	int
=	O
!	O
strcmp	function
(	O
fn	pointer
,	O
DEFAULT_BUFFERFILE	pointer
)	O
;	O
exists	int
=	O
!	O
lstat	function
(	O
fn	pointer
,	O
&	O
stb	struct
)	O
;	O
if	O
(	O
public	int
&&	O
exists	int
&&	O
(	O
S_ISLNK	O
(	O
stb	struct
.	O
st_mode	int
)	O
||	O
stb	struct
.	O
st_nlink	long
>	O
1	int
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"No write to links, please."	pointer
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
debug2	O
(	O
"WriteFile(%d) %s\n"	pointer
,	O
dump	int
,	O
fn	pointer
)	O
;	O
if	O
(	O
UserContext	function
(	O
)	O
>	O
0	int
)	O
{	O
debug	O
(	O
"Writefile: usercontext\n"	pointer
)	O
;	O
if	O
(	O
dump	int
==	O
DUMP_EXCHANGE	int
&&	O
public	int
)	O
{	O
if	O
(	O
exists	int
)	O
{	O
if	O
(	O
(	O
fd	int
=	O
open	function
(	O
fn	pointer
,	O
O_WRONLY	int
,	O
0666	int
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
stb2	struct
)	O
==	O
0	int
&&	O
stb	struct
.	O
st_dev	long
==	O
stb2	struct
.	O
st_dev	long
&&	O
stb	struct
.	O
st_ino	long
==	O
stb2	struct
.	O
st_ino	long
)	O
ftruncate	function
(	O
fd	int
,	O
0	int
)	O
;	O
else	O
{	O
close	pointer
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
else	O
fd	int
=	O
open	function
(	O
fn	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_EXCL	int
,	O
0666	int
)	O
;	O
f	pointer
=	O
fd	int
>=	O
0	int
?	O
fdopen	function
(	O
fd	int
,	O
mode	struct
)	O
:	O
0	int
;	O
}	O
else	O
f	pointer
=	O
fopen	function
(	O
fn	pointer
,	O
mode	struct
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
debug2	O
(	O
"WriteFile: fopen(%s,\"%s\") failed\n"	pointer
,	O
fn	pointer
,	O
mode	struct
)	O
;	O
UserReturn	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
dump	int
)	O
{	O
case	O
DUMP_HARDCOPY	int
:	O
case	O
DUMP_SCROLLBACK	int
:	O
if	O
(	O
!	O
fore	pointer
)	O
break	O
;	O
if	O
(	O
*	O
mode	struct
==	O
'a'	O
)	O
{	O
putc	function
(	O
'>'	O
,	O
f	pointer
)	O
;	O
for	O
(	O
j	int
=	O
fore	pointer
->	O
w_width	O
-	O
2	int
;	O
j	int
>	O
0	int
;	O
j	int
--	O
)	O
putc	function
(	O
'='	O
,	O
f	pointer
)	O
;	O
fputs	function
(	O
"<\n"	pointer
,	O
f	pointer
)	O
;	O
}	O
if	O
(	O
dump	int
==	O
DUMP_SCROLLBACK	int
)	O
{	O
for	O
(	O
i	int
=	O
fore	pointer
->	O
w_histheight	int
-	O
fore	pointer
->	O
w_scrollback_height	int
;	O
i	int
<	O
fore	pointer
->	O
w_histheight	int
;	O
i	int
++	O
)	O
{	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
WIN	O
(	O
i	int
)	O
->	O
image	char
)	O
;	O
for	O
(	O
k	int
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
k	int
>=	O
0	int
&&	O
p	pointer
[	O
k	int
]	O
==	O
' '	O
;	O
k	int
--	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
k	int
;	O
j	int
++	O
)	O
putc	function
(	O
p	pointer
[	O
j	int
]	O
,	O
f	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
f	pointer
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fore	pointer
->	O
w_height	O
;	O
i	int
++	O
)	O
{	O
p	pointer
=	O
(	O
char	O
*	O
)	O
fore	pointer
->	O
w_mlines	pointer
[	O
i	int
]	O
.	O
image	char
;	O
for	O
(	O
k	int
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
k	int
>=	O
0	int
&&	O
p	pointer
[	O
k	int
]	O
==	O
' '	O
;	O
k	int
--	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
k	int
;	O
j	int
++	O
)	O
putc	function
(	O
p	pointer
[	O
j	int
]	O
,	O
f	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
f	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DUMP_TERMCAP	int
:	O
DumpTermcap	function
(	O
fore	pointer
->	O
w_aflag	int
,	O
f	pointer
)	O
;	O
break	O
;	O
case	O
DUMP_EXCHANGE	int
:	O
p	pointer
=	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
;	O
for	O
(	O
i	int
=	O
user	pointer
->	O
u_plop	struct
.	O
len	int
;	O
i	int
--	O
>	O
0	int
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'\r'	O
&&	O
(	O
i	int
==	O
0	int
||	O
p	pointer
[	O
1	int
]	O
!=	O
'\n'	O
)	O
)	O
putc	function
(	O
'\n'	O
,	O
f	pointer
)	O
;	O
else	O
putc	function
(	O
*	O
p	pointer
,	O
f	pointer
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
fclose	function
(	O
f	pointer
)	O
;	O
UserReturn	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
UserStatus	function
(	O
)	O
<=	O
0	int
)	O
Msg	function
(	O
0	int
,	O
"Cannot open \"%s\""	pointer
,	O
fn	pointer
)	O
;	O
else	O
if	O
(	O
display	struct
&&	O
!	O
*	O
rc_name	pointer
)	O
{	O
switch	O
(	O
dump	int
)	O
{	O
case	O
DUMP_TERMCAP	int
:	O
Msg	function
(	O
0	int
,	O
"Termcap entry written to \"%s\"."	pointer
,	O
fn	pointer
)	O
;	O
break	O
;	O
case	O
DUMP_HARDCOPY	int
:	O
case	O
DUMP_SCROLLBACK	int
:	O
Msg	function
(	O
0	int
,	O
"Screen image %s to \"%s\"."	pointer
,	O
(	O
*	O
mode	struct
==	O
'a'	O
)	O
?	O
"appended"	pointer
:	O
"written"	pointer
,	O
fn	pointer
)	O
;	O
break	O
;	O
case	O
DUMP_EXCHANGE	int
:	O
Msg	function
(	O
0	int
,	O
"Copybuffer written to \"%s\"."	pointer
,	O
fn	pointer
)	O
;	O
}	O
}	O
}	O
char	O
*	O
ReadFile	function
(	O
char	O
*	O
fn	pointer
,	O
int	O
*	O
lenp	pointer
)	O
{	O
int	O
i	int
,	O
l	int
,	O
size	int
;	O
char	O
c	char
,	O
*	O
bp	pointer
,	O
*	O
buf	pointer
;	O
struct	O
stat	struct
stb	struct
;	O
ASSERT	O
(	O
lenp	pointer
)	O
;	O
debug1	O
(	O
"ReadFile(%s)\n"	pointer
,	O
fn	pointer
)	O
;	O
if	O
(	O
(	O
i	int
=	O
secopen	function
(	O
fn	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"no %s -- no slurp"	pointer
,	O
fn	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fstat	function
(	O
i	int
,	O
&	O
stb	struct
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"no good %s -- no slurp"	pointer
,	O
fn	pointer
)	O
;	O
close	pointer
(	O
i	int
)	O
;	O
return	O
NULL	O
;	O
}	O
size	int
=	O
stb	struct
.	O
st_size	long
;	O
if	O
(	O
(	O
buf	pointer
=	O
malloc	function
(	O
size	int
)	O
)	O
==	O
NULL	O
)	O
{	O
close	pointer
(	O
i	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
NULL	O
;	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
(	O
l	int
=	O
read	pointer
(	O
i	int
,	O
buf	pointer
,	O
size	int
)	O
)	O
!=	O
size	int
)	O
{	O
if	O
(	O
l	int
<	O
0	int
)	O
l	int
=	O
0	int
;	O
Msg	function
(	O
errno	O
,	O
"Got only %d bytes from %s"	pointer
,	O
l	int
,	O
fn	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
read	pointer
(	O
i	int
,	O
&	O
c	char
,	O
1	int
)	O
>	O
0	int
)	O
Msg	function
(	O
0	int
,	O
"Slurped only %d characters (of %d) into buffer - try again"	pointer
,	O
l	int
,	O
size	int
)	O
;	O
else	O
Msg	function
(	O
0	int
,	O
"Slurped %d characters into buffer"	pointer
,	O
l	int
)	O
;	O
}	O
close	pointer
(	O
i	int
)	O
;	O
*	O
lenp	pointer
=	O
l	int
;	O
for	O
(	O
bp	pointer
=	O
buf	pointer
;	O
l	int
--	O
>	O
0	int
;	O
bp	pointer
++	O
)	O
if	O
(	O
*	O
bp	pointer
==	O
'\n'	O
&&	O
(	O
bp	pointer
==	O
buf	pointer
||	O
bp	pointer
[	O
-	O
1	int
]	O
!=	O
'\r'	O
)	O
)	O
*	O
bp	pointer
=	O
'\r'	O
;	O
return	O
buf	pointer
;	O
}	O
void	O
KillBuffers	function
(	O
)	O
{	O
if	O
(	O
UserContext	function
(	O
)	O
>	O
0	int
)	O
UserReturn	function
(	O
unlink	function
(	O
BufferFile	pointer
)	O
?	O
errno	O
:	O
0	int
)	O
;	O
errno	O
=	O
UserStatus	function
(	O
)	O
;	O
Msg	function
(	O
errno	O
,	O
"%s %sremoved"	pointer
,	O
BufferFile	pointer
,	O
errno	O
?	O
"not "	pointer
:	O
""	pointer
)	O
;	O
}	O
FILE	struct
*	O
secfopen	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
mode	struct
)	O
{	O
FILE	struct
*	O
fi	pointer
;	O
debug2	O
(	O
"secfopen(%s, %s)\n"	pointer
,	O
name	pointer
,	O
mode	struct
)	O
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
fi	pointer
=	O
fopen	function
(	O
name	pointer
,	O
mode	struct
)	O
;	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
return	O
fi	pointer
;	O
}	O
int	O
secopen	function
(	O
char	O
*	O
name	pointer
,	O
int	O
flags	int
,	O
int	O
mode	struct
)	O
{	O
int	O
fd	int
;	O
debug3	O
(	O
"secopen(%s, 0x%x, 0%03o)\n"	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	struct
)	O
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
fd	int
=	O
open	function
(	O
name	pointer
,	O
flags	int
,	O
mode	struct
)	O
;	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
return	O
fd	int
;	O
}	O
int	O
printpipe	function
(	O
struct	O
win	struct
*	O
p	pointer
,	O
char	O
*	O
cmd	array
)	O
{	O
int	O
pi	array
[	O
2	int
]	O
;	O
if	O
(	O
pipe	function
(	O
pi	array
)	O
)	O
{	O
WMsg	function
(	O
p	pointer
,	O
errno	O
,	O
"printing pipe"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
WMsg	function
(	O
p	pointer
,	O
errno	O
,	O
"printing fork"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
case	O
0	int
:	O
display	struct
=	O
p	pointer
->	O
w_pdisplay	pointer
;	O
displays	pointer
=	O
0	int
;	O
ServerSocket	int
=	O
-	O
1	int
;	O
close	pointer
(	O
0	int
)	O
;	O
dup	function
(	O
pi	array
[	O
0	int
]	O
)	O
;	O
closeallfiles	function
(	O
0	int
)	O
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
||	O
setuid	function
(	O
real_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"printpipe setuid"	pointer
)	O
;	O
eff_uid	int
=	O
real_uid	int
;	O
eff_gid	int
=	O
real_gid	int
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
execl	function
(	O
"/bin/sh"	pointer
,	O
"sh"	pointer
,	O
"-c"	pointer
,	O
cmd	array
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
Panic	function
(	O
errno	O
,	O
"/bin/sh"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
close	pointer
(	O
pi	array
[	O
0	int
]	O
)	O
;	O
return	O
pi	array
[	O
1	int
]	O
;	O
}	O
int	O
readpipe	function
(	O
char	O
*	O
*	O
cmdv	pointer
)	O
{	O
int	O
pi	array
[	O
2	int
]	O
;	O
if	O
(	O
pipe	function
(	O
pi	array
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"pipe"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
Msg	function
(	O
errno	O
,	O
"fork"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
case	O
0	int
:	O
displays	pointer
=	O
0	int
;	O
ServerSocket	int
=	O
-	O
1	int
;	O
close	pointer
(	O
1	int
)	O
;	O
if	O
(	O
dup	function
(	O
pi	array
[	O
1	int
]	O
)	O
!=	O
1	int
)	O
{	O
close	pointer
(	O
pi	array
[	O
1	int
]	O
)	O
;	O
Panic	function
(	O
0	int
,	O
"dup"	pointer
)	O
;	O
}	O
closeallfiles	function
(	O
1	int
)	O
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
||	O
setuid	function
(	O
real_uid	int
)	O
)	O
{	O
close	pointer
(	O
1	int
)	O
;	O
Panic	function
(	O
errno	O
,	O
"setuid/setgid"	pointer
)	O
;	O
}	O
eff_uid	int
=	O
real_uid	int
;	O
eff_gid	int
=	O
real_gid	int
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
execvp	function
(	O
*	O
cmdv	pointer
,	O
cmdv	pointer
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
Panic	function
(	O
errno	O
,	O
"%s"	pointer
,	O
*	O
cmdv	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
close	pointer
(	O
pi	array
[	O
1	int
]	O
)	O
;	O
return	O
pi	array
[	O
0	int
]	O
;	O
}	O