typedef	O
int	O
bool	int
;	O
FILE	struct
*	O
in	pointer
,	O
*	O
out	pointer
;	O
char	O
filename	array
[	O
BUFSIZ	int
]	O
;	O
int	O
line	int
;	O
int	O
tab	int
;	O
int	O
tab_save	int
;	O
char	O
pool	array
[	O
POOLSIZE	int
]	O
;	O
char	O
*	O
poolp	pointer
;	O
char	O
*	O
function	pointer
;	O
int	O
fstatic	int
;	O
char	O
*	O
required	array
[	O
MAXREQ	int
]	O
;	O
int	O
nreq	int
;	O
struct	O
optional	struct
{	O
char	O
*	O
o_var	pointer
;	O
char	O
*	O
o_init	pointer
;	O
char	O
*	O
o_svar	pointer
;	O
}	O
optional	struct
[	O
MAXOPT	int
]	O
;	O
int	O
nopt	int
;	O
bool	int
rest_flag	int
;	O
bool	int
key_flag	int
;	O
struct	O
keyword	struct
{	O
char	O
*	O
k_key	pointer
;	O
char	O
*	O
k_var	pointer
;	O
char	O
*	O
k_init	pointer
;	O
char	O
*	O
k_svar	pointer
;	O
}	O
keyword	struct
[	O
MAXKEY	int
]	O
;	O
int	O
nkey	int
;	O
bool	int
allow_other_keys_flag	int
;	O
struct	O
aux	struct
{	O
char	O
*	O
a_var	pointer
;	O
char	O
*	O
a_init	pointer
;	O
}	O
aux	struct
[	O
MAXAUX	int
]	O
;	O
int	O
naux	int
;	O
char	O
*	O
result	array
[	O
MAXRES	int
]	O
;	O
int	O
nres	int
;	O
void	O
error	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
printf	function
(	O
"Error in line %d: %s.\n"	pointer
,	O
line	int
,	O
s	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
readc	function
(	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
getc	function
(	O
in	pointer
)	O
;	O
if	O
(	O
feof	function
(	O
in	pointer
)	O
)	O
{	O
if	O
(	O
function	pointer
!=	O
NULL	O
)	O
error	function
(	O
"unexpected end of file"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
line	int
++	O
;	O
tab	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
tab	int
++	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
int	O
nextc	function
(	O
)	O
{	O
int	O
c	int
;	O
while	O
(	O
isspace	O
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
)	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
void	O
unreadc	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
--	O
line	int
;	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
--	O
tab	int
;	O
ungetc	function
(	O
c	int
,	O
in	pointer
)	O
;	O
}	O
void	O
put_tabs	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
putc	function
(	O
'\t'	O
,	O
out	pointer
)	O
;	O
}	O
void	O
pushc	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
poolp	pointer
>=	O
&	O
pool	array
[	O
POOLSIZE	int
]	O
)	O
error	function
(	O
"buffer bool overflow"	pointer
)	O
;	O
*	O
poolp	pointer
++	O
=	O
c	int
;	O
}	O
char	O
*	O
read_token	function
(	O
)	O
{	O
int	O
c	int
;	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
poolp	pointer
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
'`'	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
!=	O
'`'	O
)	O
pushc	function
(	O
c	int
)	O
;	O
pushc	function
(	O
'\0'	O
)	O
;	O
return	O
(	O
p	pointer
)	O
;	O
}	O
do	O
pushc	function
(	O
c	int
)	O
;	O
while	O
(	O
isalphanum	function
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
||	O
c	int
==	O
'_'	O
)	O
;	O
pushc	function
(	O
'\0'	O
)	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
return	O
(	O
p	pointer
)	O
;	O
}	O
void	O
reset	function
(	O
)	O
{	O
int	O
i	int
;	O
poolp	pointer
=	O
pool	array
;	O
function	pointer
=	O
NULL	O
;	O
nreq	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXREQ	int
;	O
i	int
++	O
)	O
required	array
[	O
i	int
]	O
=	O
NULL	O
;	O
nopt	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXOPT	int
;	O
i	int
++	O
)	O
optional	struct
[	O
i	int
]	O
.	O
o_var	pointer
=	O
optional	struct
[	O
i	int
]	O
.	O
o_init	pointer
=	O
optional	struct
[	O
i	int
]	O
.	O
o_svar	pointer
=	O
NULL	O
;	O
rest_flag	int
=	O
FALSE	int
;	O
key_flag	int
=	O
FALSE	int
;	O
nkey	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXKEY	int
;	O
i	int
++	O
)	O
keyword	struct
[	O
i	int
]	O
.	O
k_key	pointer
=	O
keyword	struct
[	O
i	int
]	O
.	O
k_var	pointer
=	O
keyword	struct
[	O
i	int
]	O
.	O
k_init	pointer
=	O
keyword	struct
[	O
i	int
]	O
.	O
k_svar	pointer
=	O
NULL	O
;	O
allow_other_keys_flag	int
=	O
FALSE	int
;	O
naux	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXAUX	int
;	O
i	int
++	O
)	O
aux	struct
[	O
i	int
]	O
.	O
a_var	pointer
=	O
aux	struct
[	O
i	int
]	O
.	O
a_init	pointer
=	O
NULL	O
;	O
}	O
void	O
get_function	function
(	O
)	O
{	O
function	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
void	O
get_lambda_list	function
(	O
)	O
{	O
int	O
c	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
!=	O
'('	O
)	O
error	function
(	O
"( expected"	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
if	O
(	O
c	int
==	O
'&'	O
)	O
{	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
goto	O
OPTIONAL	O
;	O
}	O
unreadc	function
(	O
c	int
)	O
;	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
nreq	int
>=	O
MAXREQ	int
)	O
error	function
(	O
"too many required variables"	pointer
)	O
;	O
required	array
[	O
nreq	int
++	O
]	O
=	O
p	pointer
;	O
}	O
OPTIONAL	O
:	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"optional"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
p	pointer
,	O
"o"	pointer
)	O
!=	O
0	int
)	O
goto	O
REST	O
;	O
for	O
(	O
;	O
;	O
nopt	int
++	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
if	O
(	O
c	int
==	O
'&'	O
)	O
{	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
goto	O
REST	O
;	O
}	O
if	O
(	O
nopt	int
>=	O
MAXOPT	int
)	O
error	function
(	O
"too many optional argument"	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'('	O
)	O
{	O
optional	struct
[	O
nopt	int
]	O
.	O
o_var	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
continue	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
optional	struct
[	O
nopt	int
]	O
.	O
o_init	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
continue	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
optional	struct
[	O
nopt	int
]	O
.	O
o_svar	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
nextc	function
(	O
)	O
!=	O
')'	O
)	O
error	function
(	O
") expected"	pointer
)	O
;	O
}	O
else	O
{	O
unreadc	function
(	O
c	int
)	O
;	O
optional	struct
[	O
nopt	int
]	O
.	O
o_var	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
}	O
REST	O
:	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"rest"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
p	pointer
,	O
"r"	pointer
)	O
!=	O
0	int
)	O
goto	O
KEYWORD	O
;	O
rest_flag	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
if	O
(	O
c	int
!=	O
'&'	O
)	O
error	function
(	O
"& expected"	pointer
)	O
;	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
goto	O
KEYWORD	O
;	O
KEYWORD	O
:	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"key"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
p	pointer
,	O
"k"	pointer
)	O
!=	O
0	int
)	O
goto	O
AUX_L	O
;	O
key_flag	int
=	O
TRUE	int
;	O
for	O
(	O
;	O
;	O
nkey	int
++	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
if	O
(	O
c	int
==	O
'&'	O
)	O
{	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"allow_other_keys"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
,	O
"aok"	pointer
)	O
==	O
0	int
)	O
{	O
allow_other_keys_flag	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
if	O
(	O
c	int
!=	O
'&'	O
)	O
error	function
(	O
"& expected"	pointer
)	O
;	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
goto	O
AUX_L	O
;	O
}	O
if	O
(	O
nkey	int
>=	O
MAXKEY	int
)	O
error	function
(	O
"too many optional argument"	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'('	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
'('	O
)	O
{	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
!=	O
':'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
error	function
(	O
"keyword expected"	pointer
)	O
;	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_key	pointer
=	O
p	pointer
+	O
1	int
;	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_var	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
nextc	function
(	O
)	O
!=	O
')'	O
)	O
error	function
(	O
") expected"	pointer
)	O
;	O
}	O
else	O
{	O
unreadc	function
(	O
c	int
)	O
;	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_key	pointer
=	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_var	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
continue	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_init	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
continue	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_svar	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
nextc	function
(	O
)	O
!=	O
')'	O
)	O
error	function
(	O
") expected"	pointer
)	O
;	O
}	O
else	O
{	O
unreadc	function
(	O
c	int
)	O
;	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_key	pointer
=	O
keyword	struct
[	O
nkey	int
]	O
.	O
k_var	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
}	O
AUX_L	O
:	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"aux"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
p	pointer
,	O
"a"	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
"illegal lambda-list keyword"	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
if	O
(	O
c	int
==	O
'&'	O
)	O
error	function
(	O
"illegal lambda-list keyword"	pointer
)	O
;	O
if	O
(	O
naux	int
>=	O
MAXAUX	int
)	O
error	function
(	O
"too many auxiliary variable"	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'('	O
)	O
{	O
aux	struct
[	O
naux	int
]	O
.	O
a_var	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
continue	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
aux	struct
[	O
naux	int
]	O
.	O
a_init	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
nextc	function
(	O
)	O
!=	O
')'	O
)	O
error	function
(	O
") expected"	pointer
)	O
;	O
}	O
else	O
{	O
unreadc	function
(	O
c	int
)	O
;	O
aux	struct
[	O
naux	int
]	O
.	O
a_var	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
naux	int
++	O
;	O
}	O
}	O
void	O
get_return	function
(	O
)	O
{	O
int	O
c	int
;	O
nres	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
nextc	function
(	O
)	O
)	O
==	O
')'	O
)	O
return	O
;	O
unreadc	function
(	O
c	int
)	O
;	O
result	array
[	O
nres	int
++	O
]	O
=	O
read_token	function
(	O
)	O
;	O
}	O
}	O
void	O
put_fhead	function
(	O
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"%svoid\nL%s()\n{"	pointer
,	O
fstatic	int
?	O
"static "	pointer
:	O
""	pointer
,	O
function	pointer
)	O
;	O
}	O
void	O
put_declaration	function
(	O
)	O
{	O
int	O
i	int
;	O
fprintf	function
(	O
out	pointer
,	O
"\tint narg;\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\tregister object *DPPbase=vs_base;\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nopt	int
;	O
i	int
++	O
)	O
if	O
(	O
optional	struct
[	O
i	int
]	O
.	O
o_svar	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
out	pointer
,	O
"\tbool %s;\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_svar	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nreq	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#define\t%s\tDPPbase[%d]\n"	pointer
,	O
required	array
[	O
i	int
]	O
,	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nopt	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#define\t%s\tDPPbase[%d+%d]\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_var	pointer
,	O
nreq	int
,	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#define\t%s\tDPPbase[%d+%d+%d]\n"	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_var	pointer
,	O
nreq	int
,	O
nopt	int
,	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
if	O
(	O
keyword	struct
[	O
i	int
]	O
.	O
k_svar	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
out	pointer
,	O
"\tbool %s;\n"	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_svar	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
naux	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#define\t%s\tDPPbase[%d+%d+2*%d+%d]\n"	pointer
,	O
aux	struct
[	O
i	int
]	O
.	O
a_var	pointer
,	O
nreq	int
,	O
nopt	int
,	O
nkey	int
,	O
i	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\tnarg = vs_top - vs_base;\n"	pointer
)	O
;	O
if	O
(	O
nopt	int
==	O
0	int
&&	O
!	O
rest_flag	int
&&	O
!	O
key_flag	int
)	O
fprintf	function
(	O
out	pointer
,	O
"\tcheck_arg(%d);\n"	pointer
,	O
nreq	int
)	O
;	O
else	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\tif (narg < %d)\n"	pointer
,	O
nreq	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\ttoo_few_arguments();\n"	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nopt	int
;	O
i	int
++	O
)	O
if	O
(	O
optional	struct
[	O
i	int
]	O
.	O
o_svar	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\tif (narg > %d + %d)\n"	pointer
,	O
nreq	int
,	O
i	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\t%s = TRUE;\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_svar	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\telse {\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\t%s = FALSE;\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_svar	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\tvs_push(%s);\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_init	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\tnarg++;\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t}\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
optional	struct
[	O
i	int
]	O
.	O
o_init	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\tif (narg <= %d + %d) {\n"	pointer
,	O
nreq	int
,	O
i	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\tvs_push(%s);\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_init	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\tnarg++;\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t}\n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\tif (narg <= %d + %d) {\n"	pointer
,	O
nreq	int
,	O
i	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\tvs_push(Cnil);\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\tnarg++;\n"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t}\n"	pointer
)	O
;	O
}	O
if	O
(	O
nopt	int
>	O
0	int
&&	O
!	O
key_flag	int
&&	O
!	O
rest_flag	int
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\tif (narg > %d + %d)\n"	pointer
,	O
nreq	int
,	O
nopt	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\ttoo_many_arguments();\n"	pointer
)	O
;	O
}	O
if	O
(	O
key_flag	int
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\tparse_key(vs_base+%d+%d,FALSE, %s, %d,\n"	pointer
,	O
nreq	int
,	O
nopt	int
,	O
allow_other_keys_flag	int
?	O
"TRUE"	pointer
:	O
"FALSE"	pointer
,	O
nkey	int
)	O
;	O
if	O
(	O
nkey	int
>	O
0	int
)	O
{	O
i	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"\t\tsK%s"	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_key	pointer
)	O
;	O
if	O
(	O
++	O
i	int
==	O
nkey	int
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
");\n"	pointer
)	O
;	O
break	O
;	O
}	O
else	O
fprintf	function
(	O
out	pointer
,	O
",\n"	pointer
)	O
;	O
}	O
}	O
else	O
fprintf	function
(	O
out	pointer
,	O
"\t\tCnil);"	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\tvs_top = vs_base + %d+%d+2*%d;\n"	pointer
,	O
nreq	int
,	O
nopt	int
,	O
nkey	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
keyword	struct
[	O
i	int
]	O
.	O
k_init	pointer
==	O
NULL	O
)	O
continue	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\tif (vs_base[%d+%d+%d+%d]==Cnil)\n"	pointer
,	O
nreq	int
,	O
nopt	int
,	O
nkey	int
,	O
i	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\t\t%s = %s;\n"	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_var	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_init	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
if	O
(	O
keyword	struct
[	O
i	int
]	O
.	O
k_svar	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
out	pointer
,	O
"\t%s = vs_base[%d+%d+%d+%d] != Cnil;\n"	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_svar	pointer
,	O
nreq	int
,	O
nopt	int
,	O
nkey	int
,	O
i	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
naux	int
;	O
i	int
++	O
)	O
if	O
(	O
aux	struct
[	O
i	int
]	O
.	O
a_init	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
out	pointer
,	O
"\tvs_push(%s);\n"	pointer
,	O
aux	struct
[	O
i	int
]	O
.	O
a_init	pointer
)	O
;	O
else	O
fprintf	function
(	O
out	pointer
,	O
"\tvs_push(Cnil);\n"	pointer
)	O
;	O
}	O
void	O
put_ftail	function
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nreq	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#undef %s\n"	pointer
,	O
required	array
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nopt	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#undef %s\n"	pointer
,	O
optional	struct
[	O
i	int
]	O
.	O
o_var	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#undef %s\n"	pointer
,	O
keyword	struct
[	O
i	int
]	O
.	O
k_var	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
naux	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
out	pointer
,	O
"#undef %s\n"	pointer
,	O
aux	struct
[	O
i	int
]	O
.	O
a_var	pointer
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"}"	pointer
)	O
;	O
}	O
void	O
put_return	function
(	O
)	O
{	O
int	O
i	int
,	O
t	int
;	O
t	int
=	O
tab_save	int
+	O
1	int
;	O
if	O
(	O
nres	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"{\n"	pointer
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"vs_top = vs_base;\n"	pointer
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"vs_base[0] = Cnil;\n"	pointer
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"return;\n"	pointer
)	O
;	O
put_tabs	function
(	O
tab_save	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
nres	int
==	O
1	int
)	O
{	O
fprintf	function
(	O
out	pointer
,	O
"{\n"	pointer
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"vs_base[0] = %s;\n"	pointer
,	O
result	array
[	O
0	int
]	O
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"vs_top = vs_base + 1;\n"	pointer
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"return;\n"	pointer
)	O
;	O
put_tabs	function
(	O
tab_save	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"}"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
out	pointer
,	O
"{\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nres	int
;	O
i	int
++	O
)	O
{	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"object R%d;\n"	pointer
,	O
i	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nres	int
;	O
i	int
++	O
)	O
{	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"R%d = %s;\n"	pointer
,	O
i	int
,	O
result	array
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nres	int
;	O
i	int
++	O
)	O
{	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"vs_base[%d] = R%d;\n"	pointer
,	O
i	int
,	O
i	int
)	O
;	O
}	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"vs_top = vs_base + %d;\n"	pointer
,	O
nres	int
)	O
;	O
put_tabs	function
(	O
t	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"return;\n"	pointer
)	O
;	O
put_tabs	function
(	O
tab_save	int
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"}"	pointer
)	O
;	O
}	O
}	O
void	O
main_loop	function
(	O
)	O
{	O
int	O
c	int
;	O
char	O
*	O
p	pointer
;	O
line	int
=	O
1	int
;	O
fprintf	function
(	O
out	pointer
,	O
"# line %d \"%s\"\n"	pointer
,	O
line	int
,	O
filename	array
)	O
;	O
LOOP	O
:	O
reset	function
(	O
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\n# line %d \"%s\"\n"	pointer
,	O
line	int
,	O
filename	array
)	O
;	O
while	O
(	O
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
!=	O
'@'	O
)	O
putc	function
(	O
c	int
,	O
out	pointer
)	O
;	O
if	O
(	O
readc	function
(	O
)	O
!=	O
'('	O
)	O
error	function
(	O
"@( expected"	pointer
)	O
;	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
fstatic	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"static"	pointer
)	O
==	O
0	int
)	O
{	O
fstatic	int
=	O
1	int
;	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"defun"	pointer
)	O
==	O
0	int
)	O
{	O
get_function	function
(	O
)	O
;	O
get_lambda_list	function
(	O
)	O
;	O
put_fhead	function
(	O
)	O
;	O
fprintf	function
(	O
out	pointer
,	O
"\n# line %d \"%s\"\n"	pointer
,	O
line	int
,	O
filename	array
)	O
;	O
while	O
(	O
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
!=	O
'@'	O
)	O
putc	function
(	O
c	int
,	O
out	pointer
)	O
;	O
put_declaration	function
(	O
)	O
;	O
BODY	O
:	O
fprintf	function
(	O
out	pointer
,	O
"\n# line %d \"%s\"\n"	pointer
,	O
line	int
,	O
filename	array
)	O
;	O
while	O
(	O
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
!=	O
'@'	O
)	O
putc	function
(	O
c	int
,	O
out	pointer
)	O
;	O
if	O
(	O
(	O
c	int
=	O
readc	function
(	O
)	O
)	O
==	O
')'	O
)	O
{	O
put_ftail	function
(	O
)	O
;	O
goto	O
LOOP	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
'('	O
)	O
error	function
(	O
"@( expected"	pointer
)	O
;	O
p	pointer
=	O
read_token	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"return"	pointer
)	O
==	O
0	int
)	O
{	O
tab_save	int
=	O
tab	int
;	O
get_return	function
(	O
)	O
;	O
put_return	function
(	O
)	O
;	O
goto	O
BODY	O
;	O
}	O
else	O
error	function
(	O
"illegal symbol"	pointer
)	O
;	O
}	O
else	O
error	function
(	O
"illegal symbol"	pointer
)	O
;	O
}	O
int	O
main	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
error	function
(	O
"arg count"	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
argv	pointer
[	O
1	int
]	O
,	O
q	pointer
=	O
filename	array
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
,	O
q	pointer
++	O
)	O
if	O
(	O
q	pointer
>=	O
&	O
filename	array
[	O
BUFSIZ	int
-	O
3	int
]	O
)	O
error	function
(	O
"too long file name"	pointer
)	O
;	O
else	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
q	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
q	pointer
[	O
1	int
]	O
=	O
'd'	O
;	O
q	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
in	pointer
=	O
fopen	function
(	O
filename	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
in	pointer
==	O
NULL	O
)	O
error	function
(	O
"can't open input file"	pointer
)	O
;	O
q	pointer
[	O
1	int
]	O
=	O
'c'	O
;	O
out	pointer
=	O
fopen	function
(	O
filename	array
,	O
"w"	pointer
)	O
;	O
if	O
(	O
out	pointer
==	O
NULL	O
)	O
error	function
(	O
"can't open output file"	pointer
)	O
;	O
q	pointer
[	O
1	int
]	O
=	O
'd'	O
;	O
printf	function
(	O
"dpp: %s -> "	pointer
,	O
filename	array
)	O
;	O
q	pointer
[	O
1	int
]	O
=	O
'c'	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
filename	array
)	O
;	O
q	pointer
[	O
1	int
]	O
=	O
'd'	O
;	O
main_loop	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O