void	O
fill	function
(	O
HPGL_Pt	struct
polygon	array
[	O
]	O
,	O
int	O
numpoints	int
,	O
HPGL_Pt	struct
point1	struct
,	O
HPGL_Pt	struct
point2	struct
,	O
int	O
scale_flag	int
,	O
int	O
filltype	int
,	O
float	O
spacing	float
,	O
float	O
hatchangle	float
)	O
{	O
typedef	O
struct	O
{	O
double	O
x	int
,	O
y	int
;	O
}	O
HPGL_Pt2	struct
;	O
double	O
pxmin	double
,	O
pxmax	double
,	O
pymin	double
,	O
pymax	double
;	O
double	O
polyxmin	double
,	O
polyymin	double
,	O
polyxmax	double
,	O
polyymax	double
;	O
double	O
scanx1	double
,	O
scanx2	double
,	O
scany1	double
,	O
scany2	double
;	O
HPGL_Pt2	struct
segment	array
[	O
MAXPOLY	int
]	O
,	O
tmp	struct
;	O
double	O
segx	double
,	O
segy	double
;	O
static	O
int	O
i	int
;	O
int	O
j	int
,	O
k	int
,	O
jj	int
,	O
kk	int
;	O
int	O
numlines	int
;	O
double	O
penwidth	double
;	O
HPGL_Pt	struct
p	struct
;	O
double	O
rot_ang	double
;	O
double	O
pxdiff	double
=	O
0.	int
,	O
pydiff	double
=	O
0.	int
;	O
double	O
avx	double
,	O
avy	double
,	O
bvx	double
,	O
bvy	double
,	O
ax	double
,	O
ay	double
,	O
bx	double
,	O
by	double
,	O
atx	double
,	O
aty	double
,	O
btx	double
,	O
bty	double
,	O
mu	double
;	O
PEN_W	float
SafePenW	float
=	O
pt	struct
.	O
width	array
[	O
1	int
]	O
;	O
LineEnds	enum
SafeLineEnd	enum
=	O
CurrentLineEnd	enum
;	O
CurrentLineEnd	enum
=	O
LAE_butt	int
;	O
penwidth	double
=	O
0.1	int
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_PW	int
)	O
;	O
Pen_Width_to_tmpfile	function
(	O
1	int
,	O
penwidth	double
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	function
(	O
LineAttrEnd	int
,	O
LAE_round	int
)	O
;	O
if	O
(	O
filltype	int
>	O
2	int
)	O
penwidth	double
=	O
spacing	float
;	O
polyxmin	double
=	O
100000.	int
;	O
polyymin	double
=	O
100000.	int
;	O
polyxmax	double
=	O
-	O
100000.	int
;	O
polyymax	double
=	O
-	O
100000.	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
numpoints	int
;	O
i	int
++	O
)	O
{	O
polyxmin	double
=	O
MIN	O
(	O
polyxmin	double
,	O
polygon	array
[	O
i	int
]	O
.	O
x	int
)	O
;	O
polyymin	double
=	O
MIN	O
(	O
polyymin	double
,	O
polygon	array
[	O
i	int
]	O
.	O
y	int
)	O
;	O
polyxmax	double
=	O
MAX	O
(	O
polyxmax	double
,	O
polygon	array
[	O
i	int
]	O
.	O
x	int
)	O
;	O
polyymax	double
=	O
MAX	O
(	O
polyymax	double
,	O
polygon	array
[	O
i	int
]	O
.	O
y	int
)	O
;	O
}	O
if	O
(	O
hatchangle	float
>	O
89.9	int
&&	O
hatchangle	float
<	O
180.	int
)	O
{	O
hatchangle	float
=	O
hatchangle	float
-	O
90.	int
;	O
goto	O
FILL_VERT	O
;	O
}	O
pxmin	double
=	O
point1	struct
.	O
x	int
-	O
0.5	int
;	O
pymin	double
=	O
point1	struct
.	O
y	int
-	O
0.5	int
;	O
pxmax	double
=	O
polyxmax	double
;	O
pymax	double
=	O
polyymax	double
;	O
if	O
(	O
polyxmin	double
==	O
polyxmax	double
&&	O
polyymin	double
==	O
polyymax	double
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"zero area polygon\n"	pointer
)	O
;	O
return	O
;	O
}	O
pydiff	double
=	O
pymax	double
-	O
pymin	double
;	O
pxdiff	double
=	O
pxmax	double
-	O
pxmin	double
;	O
if	O
(	O
hatchangle	float
!=	O
0.	int
)	O
{	O
rot_ang	double
=	O
tan	function
(	O
M_PI	int
*	O
hatchangle	float
/	O
180.	int
)	O
;	O
pymin	double
=	O
pymin	double
-	O
rot_ang	double
*	O
pxdiff	double
;	O
pymax	double
=	O
pymax	double
+	O
rot_ang	double
*	O
pxdiff	double
;	O
}	O
numlines	int
=	O
(	O
int	O
)	O
fabs	function
(	O
1.	int
+	O
(	O
pymax	double
-	O
pymin	double
+	O
penwidth	double
)	O
/	O
penwidth	double
)	O
;	O
pydiff	double
=	O
0.	int
;	O
if	O
(	O
hatchangle	float
!=	O
0.	int
)	O
pydiff	double
=	O
tan	function
(	O
M_PI	int
*	O
hatchangle	float
/	O
180.	int
)	O
*	O
pxdiff	double
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
numlines	int
;	O
i	int
++	O
)	O
{	O
k	int
=	O
-	O
1	int
;	O
scany1	double
=	O
pymin	double
+	O
(	O
double	O
)	O
i	int
*	O
penwidth	double
;	O
scany2	double
=	O
scany1	double
+	O
pydiff	double
;	O
if	O
(	O
scany1	double
>=	O
pymax	double
||	O
scany1	double
<=	O
pymin	double
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
scany2	double
<	O
polyymin	double
)	O
continue	O
;	O
bx	double
=	O
pxmin	double
;	O
btx	double
=	O
pxmax	double
;	O
by	double
=	O
scany1	double
;	O
bty	double
=	O
scany2	double
;	O
bvx	double
=	O
btx	double
-	O
bx	double
;	O
bvy	double
=	O
bty	double
-	O
by	double
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
numpoints	int
;	O
j	int
=	O
j	int
+	O
2	int
)	O
{	O
ax	double
=	O
polygon	array
[	O
j	int
]	O
.	O
x	int
;	O
ay	double
=	O
polygon	array
[	O
j	int
]	O
.	O
y	int
;	O
atx	double
=	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
;	O
aty	double
=	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
;	O
avx	double
=	O
atx	double
-	O
ax	double
;	O
avy	double
=	O
aty	double
-	O
ay	double
;	O
if	O
(	O
fabs	function
(	O
bvy	double
*	O
avx	double
-	O
avy	double
*	O
bvx	double
)	O
<	O
1.e-8	int
)	O
continue	O
;	O
mu	double
=	O
(	O
avx	double
*	O
(	O
ay	double
-	O
by	double
)	O
+	O
avy	double
*	O
(	O
bx	double
-	O
ax	double
)	O
)	O
/	O
(	O
bvy	double
*	O
avx	double
-	O
avy	double
*	O
bvx	double
)	O
;	O
if	O
(	O
mu	double
>=	O
0.	int
&&	O
mu	double
<=	O
1.01	int
)	O
{	O
segx	double
=	O
bx	double
+	O
mu	double
*	O
bvx	double
;	O
segy	double
=	O
by	double
+	O
mu	double
*	O
bvy	double
;	O
}	O
else	O
continue	O
;	O
if	O
(	O
(	O
segy	double
<	O
MIN	O
(	O
(	O
double	O
)	O
polygon	array
[	O
j	int
]	O
.	O
y	int
,	O
(	O
double	O
)	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
)	O
-	O
0.0000001	int
)	O
||	O
(	O
segy	double
>	O
MAX	O
(	O
(	O
double	O
)	O
polygon	array
[	O
j	int
]	O
.	O
y	int
,	O
(	O
double	O
)	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
)	O
+	O
0.000000001	int
)	O
||	O
(	O
segx	double
<	O
MIN	O
(	O
(	O
double	O
)	O
polygon	array
[	O
j	int
]	O
.	O
x	int
,	O
(	O
double	O
)	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
)	O
-	O
0.000000001	int
)	O
||	O
(	O
segx	double
>	O
MAX	O
(	O
(	O
double	O
)	O
polygon	array
[	O
j	int
]	O
.	O
x	int
,	O
(	O
double	O
)	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
)	O
)	O
)	O
{	O
}	O
else	O
{	O
for	O
(	O
kk	int
=	O
0	int
;	O
kk	int
<=	O
k	int
;	O
kk	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
segment	array
[	O
kk	int
]	O
.	O
x	int
-	O
segx	double
)	O
<	O
1.e-8	int
)	O
goto	O
BARF	O
;	O
}	O
k	int
++	O
;	O
segment	array
[	O
k	int
]	O
.	O
x	int
=	O
segx	double
;	O
segment	array
[	O
k	int
]	O
.	O
y	int
=	O
segy	double
;	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
k	int
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
segment	array
[	O
k	int
]	O
.	O
x	int
<	O
segment	array
[	O
jj	int
]	O
.	O
x	int
)	O
{	O
tmp	struct
=	O
segment	array
[	O
jj	int
]	O
;	O
segment	array
[	O
jj	int
]	O
=	O
segment	array
[	O
k	int
]	O
;	O
segment	array
[	O
k	int
]	O
=	O
tmp	struct
;	O
}	O
}	O
}	O
}	O
BARF	O
:	O
continue	O
;	O
}	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
k	int
;	O
j	int
=	O
j	int
+	O
2	int
)	O
{	O
p	struct
.	O
x	int
=	O
segment	array
[	O
j	int
]	O
.	O
x	int
;	O
p	struct
.	O
y	int
=	O
segment	array
[	O
j	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
p	struct
.	O
x	int
=	O
segment	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
;	O
p	struct
.	O
y	int
=	O
segment	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
else	O
{	O
}	O
}	O
if	O
(	O
filltype	int
!=	O
4	int
)	O
{	O
CurrentLineEnd	enum
=	O
SafeLineEnd	enum
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_PW	int
)	O
;	O
Pen_Width_to_tmpfile	function
(	O
1	int
,	O
SafePenW	float
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	function
(	O
LineAttrEnd	int
,	O
SafeLineEnd	enum
)	O
;	O
return	O
;	O
}	O
FILL_VERT	O
:	O
pxmin	double
=	O
point1	struct
.	O
x	int
;	O
pymin	double
=	O
point1	struct
.	O
y	int
;	O
pxmax	double
=	O
polyxmax	double
;	O
pymax	double
=	O
polyymax	double
;	O
pydiff	double
=	O
pymax	double
-	O
pymin	double
;	O
if	O
(	O
hatchangle	float
!=	O
0.	int
)	O
{	O
rot_ang	double
=	O
tan	function
(	O
M_PI	int
*	O
hatchangle	float
/	O
180.	int
)	O
;	O
pxmin	double
=	O
pxmin	double
-	O
rot_ang	double
*	O
pydiff	double
;	O
pxmax	double
=	O
pxmax	double
+	O
rot_ang	double
*	O
pydiff	double
;	O
}	O
pymin	double
=	O
pymin	double
-	O
1.	int
;	O
pymax	double
=	O
pymax	double
+	O
1.	int
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	function
(	O
LineAttrEnd	int
,	O
LAE_butt	int
)	O
;	O
numlines	int
=	O
(	O
int	O
)	O
fabs	function
(	O
1.	int
+	O
(	O
pxmax	double
-	O
pxmin	double
+	O
penwidth	double
)	O
/	O
penwidth	double
)	O
;	O
pxdiff	double
=	O
0.	int
;	O
if	O
(	O
hatchangle	float
!=	O
0.	int
)	O
pxdiff	double
=	O
tan	function
(	O
M_PI	int
*	O
hatchangle	float
/	O
180.	int
)	O
*	O
(	O
pymax	double
-	O
pymin	double
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
numlines	int
;	O
++	O
i	int
)	O
{	O
k	int
=	O
-	O
1	int
;	O
scanx1	double
=	O
pxmin	double
+	O
(	O
double	O
)	O
i	int
*	O
penwidth	double
;	O
if	O
(	O
scanx1	double
>=	O
pxmax	double
||	O
scanx1	double
<=	O
pxmin	double
)	O
continue	O
;	O
scanx2	double
=	O
scanx1	double
-	O
pxdiff	double
;	O
bx	double
=	O
scanx1	double
;	O
btx	double
=	O
scanx2	double
;	O
by	double
=	O
pymin	double
;	O
bty	double
=	O
pymax	double
;	O
bvx	double
=	O
btx	double
-	O
bx	double
;	O
bvy	double
=	O
bty	double
-	O
by	double
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
numpoints	int
;	O
j	int
=	O
j	int
+	O
2	int
)	O
{	O
ax	double
=	O
polygon	array
[	O
j	int
]	O
.	O
x	int
;	O
ay	double
=	O
polygon	array
[	O
j	int
]	O
.	O
y	int
;	O
atx	double
=	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
;	O
aty	double
=	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
;	O
avx	double
=	O
atx	double
-	O
ax	double
;	O
avy	double
=	O
aty	double
-	O
ay	double
;	O
if	O
(	O
fabs	function
(	O
bvy	double
*	O
avx	double
-	O
avy	double
*	O
bvx	double
)	O
<	O
1.e-8	int
)	O
continue	O
;	O
mu	double
=	O
(	O
avx	double
*	O
(	O
ay	double
-	O
by	double
)	O
+	O
avy	double
*	O
(	O
bx	double
-	O
ax	double
)	O
)	O
/	O
(	O
bvy	double
*	O
avx	double
-	O
avy	double
*	O
bvx	double
)	O
;	O
if	O
(	O
mu	double
>=	O
0.	int
&&	O
mu	double
<=	O
1.01	int
)	O
{	O
segx	double
=	O
bx	double
+	O
mu	double
*	O
bvx	double
;	O
segy	double
=	O
by	double
+	O
mu	double
*	O
bvy	double
;	O
}	O
else	O
continue	O
;	O
if	O
(	O
(	O
segy	double
<	O
MIN	O
(	O
polygon	array
[	O
j	int
]	O
.	O
y	int
,	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
)	O
-	O
1.	int
)	O
||	O
(	O
segy	double
>	O
MAX	O
(	O
polygon	array
[	O
j	int
]	O
.	O
y	int
,	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
)	O
+	O
1.	int
)	O
||	O
(	O
segx	double
<	O
MIN	O
(	O
polygon	array
[	O
j	int
]	O
.	O
x	int
,	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
)	O
)	O
||	O
(	O
segx	double
>	O
MAX	O
(	O
polygon	array
[	O
j	int
]	O
.	O
x	int
,	O
polygon	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
)	O
)	O
)	O
{	O
}	O
else	O
{	O
for	O
(	O
kk	int
=	O
0	int
;	O
kk	int
<=	O
k	int
;	O
kk	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
segment	array
[	O
kk	int
]	O
.	O
y	int
-	O
segy	double
)	O
<	O
1.e-8	int
)	O
goto	O
BARF2	O
;	O
}	O
k	int
++	O
;	O
segment	array
[	O
k	int
]	O
.	O
x	int
=	O
segx	double
;	O
segment	array
[	O
k	int
]	O
.	O
y	int
=	O
segy	double
;	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
k	int
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
segment	array
[	O
k	int
]	O
.	O
y	int
<	O
segment	array
[	O
jj	int
]	O
.	O
y	int
)	O
{	O
tmp	struct
=	O
segment	array
[	O
jj	int
]	O
;	O
segment	array
[	O
jj	int
]	O
=	O
segment	array
[	O
k	int
]	O
;	O
segment	array
[	O
k	int
]	O
=	O
tmp	struct
;	O
}	O
}	O
}	O
}	O
BARF2	O
:	O
continue	O
;	O
}	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
k	int
;	O
j	int
=	O
j	int
+	O
2	int
)	O
{	O
p	struct
.	O
x	int
=	O
segment	array
[	O
j	int
]	O
.	O
x	int
;	O
p	struct
.	O
y	int
=	O
segment	array
[	O
j	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
p	struct
.	O
x	int
=	O
segment	array
[	O
j	int
+	O
1	int
]	O
.	O
x	int
;	O
p	struct
.	O
y	int
=	O
segment	array
[	O
j	int
+	O
1	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
else	O
{	O
}	O
}	O
CurrentLineEnd	enum
=	O
SafeLineEnd	enum
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_PW	int
)	O
;	O
Pen_Width_to_tmpfile	function
(	O
1	int
,	O
SafePenW	float
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_LA	int
)	O
;	O
Line_Attr_to_tmpfile	function
(	O
LineAttrEnd	int
,	O
SafeLineEnd	enum
)	O
;	O
}	O