static	O
const	O
char	O
*	O
special_terminating_arg	pointer
=	O
"do_not_care"	pointer
;	O
static	O
void	O
bc_args_complete	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
)	O
{	O
bc_push_arg	function
(	O
ctl	pointer
,	O
state	pointer
,	O
special_terminating_arg	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
bc_do_insert	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
,	O
char	O
*	O
arg	pointer
,	O
size_t	long
arglen	long
,	O
const	O
char	O
*	O
prefix	pointer
,	O
size_t	long
pfxlen	long
,	O
const	O
char	O
*	O
linebuf	pointer
,	O
size_t	long
lblen	long
,	O
int	O
initial_args	int
)	O
{	O
static	O
char	O
*	O
insertbuf	pointer
;	O
char	O
*	O
p	pointer
;	O
size_t	long
bytes_left	long
=	O
ctl	pointer
->	O
arg_max	long
-	O
1	int
;	O
if	O
(	O
!	O
insertbuf	pointer
)	O
insertbuf	pointer
=	O
xmalloc	function
(	O
ctl	pointer
->	O
arg_max	long
+	O
1	int
)	O
;	O
p	pointer
=	O
insertbuf	pointer
;	O
do	O
{	O
size_t	long
len	long
;	O
char	O
*	O
s	long
=	O
mbsstr	function
(	O
arg	pointer
,	O
ctl	pointer
->	O
replace_pat	pointer
)	O
;	O
if	O
(	O
s	long
)	O
{	O
len	long
=	O
s	long
-	O
arg	pointer
;	O
}	O
else	O
{	O
len	long
=	O
arglen	long
;	O
}	O
if	O
(	O
bytes_left	long
<=	O
len	long
)	O
break	O
;	O
else	O
bytes_left	long
-=	O
len	long
;	O
strncpy	function
(	O
p	pointer
,	O
arg	pointer
,	O
len	long
)	O
;	O
p	pointer
+=	O
len	long
;	O
arg	pointer
+=	O
len	long
;	O
arglen	long
-=	O
len	long
;	O
if	O
(	O
s	long
)	O
{	O
if	O
(	O
bytes_left	long
<=	O
(	O
lblen	long
+	O
pfxlen	long
)	O
)	O
break	O
;	O
else	O
bytes_left	long
-=	O
(	O
lblen	long
+	O
pfxlen	long
)	O
;	O
if	O
(	O
prefix	pointer
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
prefix	pointer
)	O
;	O
p	pointer
+=	O
pfxlen	long
;	O
}	O
strcpy	function
(	O
p	pointer
,	O
linebuf	pointer
)	O
;	O
p	pointer
+=	O
lblen	long
;	O
arg	pointer
+=	O
ctl	pointer
->	O
rplen	long
;	O
arglen	long
-=	O
ctl	pointer
->	O
rplen	long
;	O
}	O
}	O
while	O
(	O
*	O
arg	pointer
)	O
;	O
if	O
(	O
*	O
arg	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"command too long"	pointer
)	O
)	O
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
bc_push_arg	function
(	O
ctl	pointer
,	O
state	pointer
,	O
insertbuf	pointer
,	O
p	pointer
-	O
insertbuf	pointer
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
}	O
static	O
size_t	long
update_limit	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
,	O
bool	bool
success	bool
,	O
size_t	long
limit	long
)	O
{	O
if	O
(	O
success	bool
)	O
{	O
if	O
(	O
limit	long
>	O
state	pointer
->	O
largest_successful_arg_count	long
)	O
state	pointer
->	O
largest_successful_arg_count	long
=	O
limit	long
;	O
}	O
else	O
{	O
if	O
(	O
limit	long
<	O
state	pointer
->	O
smallest_failed_arg_count	long
||	O
(	O
0	int
==	O
state	pointer
->	O
smallest_failed_arg_count	long
)	O
)	O
state	pointer
->	O
smallest_failed_arg_count	long
=	O
limit	long
;	O
}	O
if	O
(	O
0	int
==	O
(	O
state	pointer
->	O
largest_successful_arg_count	long
)	O
||	O
(	O
state	pointer
->	O
smallest_failed_arg_count	long
<=	O
state	pointer
->	O
largest_successful_arg_count	long
)	O
)	O
{	O
if	O
(	O
success	bool
)	O
{	O
if	O
(	O
limit	long
<	O
SIZE_MAX	O
)	O
++	O
limit	long
;	O
}	O
else	O
{	O
limit	long
/=	O
2	int
;	O
}	O
}	O
else	O
{	O
const	O
size_t	long
shift	long
=	O
(	O
state	pointer
->	O
smallest_failed_arg_count	long
-	O
state	pointer
->	O
largest_successful_arg_count	long
)	O
/	O
2	int
;	O
if	O
(	O
success	bool
)	O
{	O
if	O
(	O
shift	long
)	O
limit	long
+=	O
shift	long
;	O
else	O
++	O
limit	long
;	O
}	O
else	O
{	O
if	O
(	O
shift	long
)	O
limit	long
-=	O
shift	long
;	O
else	O
--	O
limit	long
;	O
}	O
}	O
if	O
(	O
ctl	pointer
->	O
initial_argc	long
&&	O
(	O
limit	long
<=	O
ctl	pointer
->	O
initial_argc	long
+	O
1u	int
)	O
)	O
limit	long
=	O
ctl	pointer
->	O
initial_argc	long
+	O
1u	int
;	O
if	O
(	O
0	int
==	O
limit	long
)	O
limit	long
=	O
1u	int
;	O
return	O
limit	long
;	O
}	O
static	O
size_t	long
copy_args	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
,	O
char	O
*	O
*	O
working_args	pointer
,	O
size_t	long
limit	long
,	O
size_t	long
done	long
)	O
{	O
size_t	long
dst_pos	long
=	O
0	int
;	O
size_t	long
src_pos	long
=	O
0	int
;	O
while	O
(	O
src_pos	long
<	O
ctl	pointer
->	O
initial_argc	long
)	O
{	O
working_args	pointer
[	O
dst_pos	long
++	O
]	O
=	O
state	pointer
->	O
cmd_argv	pointer
[	O
src_pos	long
++	O
]	O
;	O
}	O
src_pos	long
+=	O
done	long
;	O
while	O
(	O
src_pos	long
<	O
state	pointer
->	O
cmd_argc	long
&&	O
dst_pos	long
<	O
limit	long
)	O
{	O
working_args	pointer
[	O
dst_pos	long
++	O
]	O
=	O
state	pointer
->	O
cmd_argv	pointer
[	O
src_pos	long
++	O
]	O
;	O
}	O
assert	O
(	O
dst_pos	long
>=	O
ctl	pointer
->	O
initial_argc	long
)	O
;	O
working_args	pointer
[	O
dst_pos	long
]	O
=	O
NULL	O
;	O
return	O
dst_pos	long
;	O
}	O
void	O
bc_do_exec	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
)	O
{	O
char	O
*	O
*	O
working_args	pointer
;	O
size_t	long
limit	long
,	O
done	long
;	O
bc_args_complete	function
(	O
ctl	pointer
,	O
state	pointer
)	O
;	O
assert	O
(	O
state	pointer
->	O
cmd_argc	long
>	O
0	int
)	O
;	O
assert	O
(	O
state	pointer
->	O
cmd_argv	pointer
[	O
state	pointer
->	O
cmd_argc	long
-	O
1	int
]	O
==	O
NULL	O
)	O
;	O
working_args	pointer
=	O
xmalloc	function
(	O
(	O
1	int
+	O
state	pointer
->	O
cmd_argc	long
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
done	long
=	O
0	int
;	O
limit	long
=	O
state	pointer
->	O
cmd_argc	long
;	O
do	O
{	O
const	O
size_t	long
dst_pos	long
=	O
copy_args	function
(	O
ctl	pointer
,	O
state	pointer
,	O
working_args	pointer
,	O
limit	long
,	O
done	long
)	O
;	O
if	O
(	O
ctl	pointer
->	O
exec_callback	pointer
(	O
ctl	pointer
,	O
state	pointer
->	O
usercontext	pointer
,	O
dst_pos	long
,	O
working_args	pointer
)	O
)	O
{	O
limit	long
=	O
update_limit	function
(	O
ctl	pointer
,	O
state	pointer
,	O
true	int
,	O
limit	long
)	O
;	O
done	long
+=	O
(	O
dst_pos	long
-	O
ctl	pointer
->	O
initial_argc	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
limit	long
<=	O
ctl	pointer
->	O
initial_argc	long
+	O
1	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"can't call exec() due to argument size restrictions"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
limit	long
=	O
update_limit	function
(	O
ctl	pointer
,	O
state	pointer
,	O
false	int
,	O
limit	long
)	O
;	O
}	O
}	O
}	O
while	O
(	O
(	O
done	long
+	O
1	int
)	O
<	O
(	O
state	pointer
->	O
cmd_argc	long
-	O
ctl	pointer
->	O
initial_argc	long
)	O
)	O
;	O
free	function
(	O
working_args	pointer
)	O
;	O
bc_clear_args	function
(	O
ctl	pointer
,	O
state	pointer
)	O
;	O
}	O
static	O
int	O
bc_argc_limit_reached	function
(	O
int	O
initial_args	int
,	O
const	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
)	O
{	O
if	O
(	O
!	O
initial_args	int
&&	O
ctl	pointer
->	O
args_per_exec	long
&&	O
(	O
(	O
state	pointer
->	O
cmd_argc	long
-	O
ctl	pointer
->	O
initial_argc	long
)	O
==	O
ctl	pointer
->	O
args_per_exec	long
)	O
)	O
return	O
1	int
;	O
return	O
state	pointer
->	O
cmd_argc	long
==	O
ctl	pointer
->	O
max_arg_count	long
;	O
}	O
void	O
bc_push_arg	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
prefix	pointer
,	O
size_t	long
pfxlen	long
,	O
int	O
initial_args	int
)	O
{	O
const	O
int	O
terminate	int
=	O
(	O
arg	pointer
==	O
special_terminating_arg	pointer
)	O
;	O
assert	O
(	O
arg	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
initial_args	int
)	O
{	O
state	pointer
->	O
todo	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
terminate	int
)	O
{	O
if	O
(	O
state	pointer
->	O
cmd_argv_chars	long
+	O
len	long
+	O
pfxlen	long
>	O
ctl	pointer
->	O
arg_max	long
)	O
{	O
if	O
(	O
initial_args	int
||	O
state	pointer
->	O
cmd_argc	long
==	O
ctl	pointer
->	O
initial_argc	long
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"cannot fit single argument within argument list size limit"	pointer
)	O
)	O
;	O
if	O
(	O
ctl	pointer
->	O
replace_pat	pointer
||	O
(	O
ctl	pointer
->	O
exit_if_size_exceeded	int
&&	O
(	O
ctl	pointer
->	O
lines_per_exec	long
||	O
ctl	pointer
->	O
args_per_exec	long
)	O
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument list too long"	pointer
)	O
)	O
;	O
bc_do_exec	function
(	O
ctl	pointer
,	O
state	pointer
)	O
;	O
}	O
if	O
(	O
bc_argc_limit_reached	function
(	O
initial_args	int
,	O
ctl	pointer
,	O
state	pointer
)	O
)	O
bc_do_exec	function
(	O
ctl	pointer
,	O
state	pointer
)	O
;	O
}	O
if	O
(	O
state	pointer
->	O
cmd_argc	long
>=	O
state	pointer
->	O
cmd_argv_alloc	long
)	O
{	O
if	O
(	O
!	O
state	pointer
->	O
cmd_argv	pointer
)	O
{	O
state	pointer
->	O
cmd_argv_alloc	long
=	O
64	int
;	O
state	pointer
->	O
cmd_argv	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
state	pointer
->	O
cmd_argv_alloc	long
)	O
;	O
}	O
else	O
{	O
state	pointer
->	O
cmd_argv_alloc	long
*=	O
2	int
;	O
state	pointer
->	O
cmd_argv	pointer
=	O
xrealloc	function
(	O
state	pointer
->	O
cmd_argv	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
state	pointer
->	O
cmd_argv_alloc	long
)	O
;	O
}	O
}	O
if	O
(	O
terminate	int
)	O
state	pointer
->	O
cmd_argv	pointer
[	O
state	pointer
->	O
cmd_argc	long
++	O
]	O
=	O
NULL	O
;	O
else	O
{	O
state	pointer
->	O
cmd_argv	pointer
[	O
state	pointer
->	O
cmd_argc	long
++	O
]	O
=	O
state	pointer
->	O
argbuf	pointer
+	O
state	pointer
->	O
cmd_argv_chars	long
;	O
if	O
(	O
prefix	pointer
)	O
{	O
strcpy	function
(	O
state	pointer
->	O
argbuf	pointer
+	O
state	pointer
->	O
cmd_argv_chars	long
,	O
prefix	pointer
)	O
;	O
state	pointer
->	O
cmd_argv_chars	long
+=	O
pfxlen	long
;	O
}	O
strcpy	function
(	O
state	pointer
->	O
argbuf	pointer
+	O
state	pointer
->	O
cmd_argv_chars	long
,	O
arg	pointer
)	O
;	O
state	pointer
->	O
cmd_argv_chars	long
+=	O
len	long
;	O
if	O
(	O
bc_argc_limit_reached	function
(	O
initial_args	int
,	O
ctl	pointer
,	O
state	pointer
)	O
)	O
{	O
bc_do_exec	function
(	O
ctl	pointer
,	O
state	pointer
)	O
;	O
}	O
}	O
if	O
(	O
initial_args	int
)	O
{	O
state	pointer
->	O
cmd_initial_argv_chars	long
=	O
state	pointer
->	O
cmd_argv_chars	long
;	O
}	O
}	O
size_t	long
bc_get_arg_max	function
(	O
void	O
)	O
{	O
long	O
val	int
;	O
assert	O
(	O
(	O
~	O
(	O
size_t	long
)	O
0	int
)	O
>=	O
LONG_MAX	O
)	O
;	O
val	int
=	O
sysconf	function
(	O
_SC_ARG_MAX	int
)	O
;	O
if	O
(	O
val	int
>	O
0	int
)	O
return	O
val	int
;	O
return	O
LONG_MAX	O
;	O
}	O
static	O
int	O
cb_exec_noop	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
void	O
*	O
usercontext	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
(	O
void	O
)	O
ctl	pointer
;	O
(	O
void	O
)	O
usercontext	pointer
;	O
(	O
void	O
)	O
argc	int
;	O
(	O
void	O
)	O
argv	pointer
;	O
return	O
0	int
;	O
}	O
size_t	long
bc_size_of_environment	function
(	O
void	O
)	O
{	O
size_t	long
len	long
=	O
0u	int
;	O
char	O
*	O
*	O
envp	pointer
=	O
environ	pointer
;	O
while	O
(	O
*	O
envp	pointer
)	O
len	long
+=	O
strlen	function
(	O
*	O
envp	pointer
++	O
)	O
+	O
1	int
;	O
return	O
len	long
;	O
}	O
enum	O
BC_INIT_STATUS	enum
bc_init_controlinfo	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
size_t	long
headroom	long
)	O
{	O
size_t	long
size_of_environment	long
=	O
bc_size_of_environment	function
(	O
)	O
;	O
ctl	pointer
->	O
posix_arg_size_min	long
=	O
_POSIX_ARG_MAX	int
;	O
ctl	pointer
->	O
posix_arg_size_max	long
=	O
bc_get_arg_max	function
(	O
)	O
;	O
ctl	pointer
->	O
exit_if_size_exceeded	int
=	O
0	int
;	O
if	O
(	O
size_of_environment	long
>	O
ctl	pointer
->	O
posix_arg_size_max	long
)	O
{	O
return	O
BC_INIT_ENV_TOO_BIG	int
;	O
}	O
else	O
if	O
(	O
(	O
headroom	long
+	O
size_of_environment	long
)	O
>=	O
ctl	pointer
->	O
posix_arg_size_max	long
)	O
{	O
return	O
BC_INIT_CANNOT_ACCOMODATE_HEADROOM	int
;	O
}	O
else	O
{	O
ctl	pointer
->	O
posix_arg_size_max	long
-=	O
size_of_environment	long
;	O
ctl	pointer
->	O
posix_arg_size_max	long
-=	O
headroom	long
;	O
}	O
ctl	pointer
->	O
max_arg_count	long
=	O
(	O
ctl	pointer
->	O
posix_arg_size_max	long
/	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
-	O
2u	int
;	O
assert	O
(	O
ctl	pointer
->	O
max_arg_count	long
>	O
0	int
)	O
;	O
ctl	pointer
->	O
rplen	long
=	O
0u	int
;	O
ctl	pointer
->	O
replace_pat	pointer
=	O
NULL	O
;	O
ctl	pointer
->	O
initial_argc	long
=	O
0	int
;	O
ctl	pointer
->	O
exec_callback	pointer
=	O
cb_exec_noop	function
;	O
ctl	pointer
->	O
lines_per_exec	long
=	O
0	int
;	O
ctl	pointer
->	O
args_per_exec	long
=	O
0	int
;	O
ctl	pointer
->	O
arg_max	long
=	O
ctl	pointer
->	O
posix_arg_size_max	long
;	O
return	O
BC_INIT_OK	int
;	O
}	O
void	O
bc_use_sensible_arg_max	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
)	O
{	O
enum	O
{	O
arg_size	int
=	O
(	O
128u	int
*	O
1024u	int
)	O
}	O
;	O
if	O
(	O
arg_size	int
>	O
ctl	pointer
->	O
posix_arg_size_max	long
)	O
ctl	pointer
->	O
arg_max	long
=	O
ctl	pointer
->	O
posix_arg_size_max	long
;	O
else	O
if	O
(	O
arg_size	int
<	O
ctl	pointer
->	O
posix_arg_size_min	long
)	O
ctl	pointer
->	O
arg_max	long
=	O
ctl	pointer
->	O
posix_arg_size_min	long
;	O
else	O
ctl	pointer
->	O
arg_max	long
=	O
arg_size	int
;	O
}	O
void	O
bc_init_state	function
(	O
const	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
state	pointer
->	O
cmd_argc	long
=	O
0	int
;	O
state	pointer
->	O
cmd_argv_chars	long
=	O
0	int
;	O
state	pointer
->	O
cmd_argv	pointer
=	O
NULL	O
;	O
state	pointer
->	O
cmd_argv_alloc	long
=	O
0	int
;	O
state	pointer
->	O
largest_successful_arg_count	long
=	O
0	int
;	O
state	pointer
->	O
smallest_failed_arg_count	long
=	O
0	int
;	O
assert	O
(	O
ctl	pointer
->	O
arg_max	long
<=	O
(	O
LONG_MAX	O
-	O
2048L	int
)	O
)	O
;	O
state	pointer
->	O
argbuf	pointer
=	O
xmalloc	function
(	O
ctl	pointer
->	O
arg_max	long
+	O
1u	int
)	O
;	O
state	pointer
->	O
cmd_argv_chars	long
=	O
state	pointer
->	O
cmd_initial_argv_chars	long
=	O
0	int
;	O
state	pointer
->	O
todo	int
=	O
0	int
;	O
state	pointer
->	O
dir_fd	int
=	O
-	O
1	int
;	O
state	pointer
->	O
usercontext	pointer
=	O
context	pointer
;	O
}	O
void	O
bc_clear_args	function
(	O
const	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
struct	O
buildcmd_state	struct
*	O
state	pointer
)	O
{	O
state	pointer
->	O
cmd_argc	long
=	O
ctl	pointer
->	O
initial_argc	long
;	O
state	pointer
->	O
cmd_argv_chars	long
=	O
state	pointer
->	O
cmd_initial_argv_chars	long
;	O
state	pointer
->	O
todo	int
=	O
0	int
;	O
state	pointer
->	O
dir_fd	int
=	O
-	O
1	int
;	O
}	O
static	O
int	O
exceeds	function
(	O
const	O
char	O
*	O
env_var_name	pointer
,	O
size_t	long
quantity	long
)	O
{	O
const	O
char	O
*	O
val	int
=	O
getenv	function
(	O
env_var_name	pointer
)	O
;	O
if	O
(	O
val	int
)	O
{	O
char	O
*	O
tmp	pointer
;	O
unsigned	O
long	O
limit	long
;	O
if	O
(	O
xstrtoul	function
(	O
val	int
,	O
&	O
tmp	pointer
,	O
10	int
,	O
&	O
limit	long
,	O
NULL	O
)	O
==	O
LONGINT_OK	int
)	O
{	O
if	O
(	O
quantity	long
>	O
limit	long
)	O
return	O
1	int
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Environment variable %s is not set to a "	pointer
"valid decimal number"	pointer
)	O
,	O
env_var_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
bool	bool
bc_args_exceed_testing_limit	function
(	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
size_t	long
chars	long
,	O
args	long
;	O
for	O
(	O
chars	long
=	O
args	long
=	O
0	int
;	O
*	O
argv	pointer
;	O
++	O
argv	pointer
)	O
{	O
++	O
args	long
;	O
chars	long
+=	O
strlen	function
(	O
*	O
argv	pointer
)	O
;	O
}	O
return	O
(	O
exceeds	function
(	O
"__GNU_FINDUTILS_EXEC_ARG_COUNT_LIMIT"	pointer
,	O
args	long
)	O
||	O
exceeds	function
(	O
"__GNU_FINDUTILS_EXEC_ARG_LENGTH_LIMIT"	pointer
,	O
chars	long
)	O
)	O
;	O
}	O