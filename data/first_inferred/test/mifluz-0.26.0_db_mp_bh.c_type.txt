static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_bh.c,v 1.9 2014/04/17 20:27:30 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__memp_upgrade	function
__P	O
(	O
(	O
DB_MPOOL	struct
*	O
,	O
DB_MPOOLFILE	struct
*	O
,	O
MPOOLFILE	struct
*	O
)	O
)	O
;	O
int	O
CDB___memp_bhwrite	function
(	O
dbmp	pointer
,	O
mfp	pointer
,	O
bhp	pointer
,	O
restartp	pointer
,	O
wrotep	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
*	O
restartp	pointer
,	O
*	O
wrotep	pointer
;	O
{	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
DB_MPREG	struct
*	O
mpreg	pointer
;	O
int	O
incremented	int
,	O
ret	int
;	O
if	O
(	O
restartp	pointer
!=	O
NULL	O
)	O
*	O
restartp	pointer
=	O
0	int
;	O
if	O
(	O
wrotep	pointer
!=	O
NULL	O
)	O
*	O
wrotep	pointer
=	O
0	int
;	O
incremented	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_DEADFILE	int
)	O
)	O
{	O
dbmfp	pointer
=	O
NULL	O
;	O
goto	O
found	O
;	O
}	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
dbmfp	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbmp	pointer
->	O
dbmfq	struct
)	O
;	O
dbmfp	pointer
!=	O
NULL	O
;	O
dbmfp	pointer
=	O
TAILQ_NEXT	O
(	O
dbmfp	pointer
,	O
q	struct
)	O
)	O
if	O
(	O
dbmfp	pointer
->	O
mfp	pointer
==	O
mfp	pointer
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_READONLY	int
)	O
&&	O
__memp_upgrade	function
(	O
dbmp	pointer
,	O
dbmfp	pointer
,	O
mfp	pointer
)	O
)	O
{	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
++	O
dbmfp	pointer
->	O
ref	int
;	O
incremented	int
=	O
1	int
;	O
break	O
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
dbmfp	pointer
!=	O
NULL	O
)	O
goto	O
found	O
;	O
if	O
(	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_TEMP	int
)	O
)	O
{	O
DB_ASSERT	O
(	O
!	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_DEADFILE	int
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
mfp	pointer
->	O
ftype	int
!=	O
0	int
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
mpreg	pointer
=	O
LIST_FIRST	O
(	O
&	O
dbmp	pointer
->	O
dbregq	struct
)	O
;	O
mpreg	pointer
!=	O
NULL	O
;	O
mpreg	pointer
=	O
LIST_NEXT	O
(	O
mpreg	pointer
,	O
q	struct
)	O
)	O
if	O
(	O
mpreg	pointer
->	O
ftype	int
==	O
mfp	pointer
->	O
ftype	int
)	O
break	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
mpreg	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
CDB___memp_fopen	function
(	O
dbmp	pointer
,	O
mfp	pointer
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
path_off	int
)	O
,	O
0	int
,	O
0	int
,	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
,	O
0	int
,	O
NULL	O
,	O
&	O
dbmfp	pointer
)	O
!=	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
found	O
:	O
ret	int
=	O
CDB___memp_pgwrite	function
(	O
dbmp	pointer
,	O
dbmfp	pointer
,	O
bhp	pointer
,	O
restartp	pointer
,	O
wrotep	pointer
)	O
;	O
if	O
(	O
incremented	int
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
--	O
dbmfp	pointer
->	O
ref	int
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___memp_pgread	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
can_create	int
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
can_create	int
;	O
{	O
DB_IO	struct
db_io	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
size_t	long
len	long
,	O
pagesize	long
;	O
size_t	long
nr	long
;	O
int	O
created	int
,	O
ret	int
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
pagesize	long
=	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
;	O
F_SET	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
|	O
BH_TRASH	int
)	O
;	O
MUTEX_LOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
,	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
nr	long
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
{	O
db_io	struct
.	O
fhp	pointer
=	O
&	O
dbmfp	pointer
->	O
fh	struct
;	O
db_io	struct
.	O
mutexp	pointer
=	O
dbmfp	pointer
->	O
mutexp	pointer
;	O
db_io	struct
.	O
pagesize	long
=	O
db_io	struct
.	O
bytes	long
=	O
pagesize	long
;	O
db_io	struct
.	O
pgno	int
=	O
bhp	pointer
->	O
pgno	int
;	O
db_io	struct
.	O
buf	pointer
=	O
bhp	pointer
->	O
buf	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_CMPR	int
)	O
)	O
{	O
ret	int
=	O
CDB___memp_cmpr	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
&	O
db_io	struct
,	O
DB_IO_READ	int
,	O
(	O
ssize_t	long
*	O
)	O
&	O
nr	long
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
&	O
db_io	struct
,	O
DB_IO_READ	int
,	O
&	O
nr	long
)	O
;	O
}	O
}	O
else	O
ret	int
=	O
0	int
;	O
created	int
=	O
0	int
;	O
if	O
(	O
nr	long
<	O
pagesize	long
)	O
{	O
if	O
(	O
can_create	int
)	O
created	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
EIO	int
;	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
nr	long
!=	O
pagesize	long
)	O
{	O
len	long
=	O
mfp	pointer
->	O
clear_len	int
==	O
0	int
?	O
pagesize	long
:	O
mfp	pointer
->	O
clear_len	int
;	O
if	O
(	O
nr	long
<	O
len	long
)	O
memset	function
(	O
bhp	pointer
->	O
buf	pointer
+	O
nr	long
,	O
0	int
,	O
len	long
-	O
nr	long
)	O
;	O
}	O
ret	int
=	O
mfp	pointer
->	O
ftype	int
==	O
0	int
?	O
0	int
:	O
CDB___memp_pg	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
1	int
)	O
;	O
err	pointer
:	O
MUTEX_UNLOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_TRASH	int
)	O
;	O
if	O
(	O
created	int
)	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_page_create	int
;	O
else	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_page_in	int
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___memp_pgwrite	function
(	O
dbmp	pointer
,	O
dbmfp	pointer
,	O
bhp	pointer
,	O
restartp	pointer
,	O
wrotep	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
*	O
restartp	pointer
,	O
*	O
wrotep	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_IO	struct
db_io	struct
;	O
DB_LSN	struct
lsn	struct
;	O
MPOOL	struct
*	O
c_mp	pointer
,	O
*	O
mp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
size_t	long
nw	long
;	O
int	O
callpgin	int
,	O
dosync	int
,	O
ret	int
,	O
syncfail	int
;	O
const	O
char	O
*	O
fail	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
mfp	pointer
=	O
dbmfp	pointer
==	O
NULL	O
?	O
NULL	O
:	O
dbmfp	pointer
->	O
mfp	pointer
;	O
if	O
(	O
restartp	pointer
!=	O
NULL	O
)	O
*	O
restartp	pointer
=	O
0	int
;	O
if	O
(	O
wrotep	pointer
!=	O
NULL	O
)	O
*	O
wrotep	pointer
=	O
0	int
;	O
callpgin	int
=	O
0	int
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_DIRTY	int
)	O
)	O
{	O
if	O
(	O
wrotep	pointer
!=	O
NULL	O
)	O
*	O
wrotep	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
MUTEX_LOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
,	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_DIRTY	int
)	O
)	O
{	O
MUTEX_UNLOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
wrotep	pointer
!=	O
NULL	O
)	O
*	O
wrotep	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
F_SET	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
restartp	pointer
!=	O
NULL	O
)	O
*	O
restartp	pointer
=	O
1	int
;	O
if	O
(	O
mfp	pointer
==	O
NULL	O
||	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_DEADFILE	int
)	O
)	O
goto	O
file_dead	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
||	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_WRITE	int
)	O
)	O
memcpy	function
(	O
&	O
lsn	struct
,	O
bhp	pointer
->	O
buf	pointer
+	O
mfp	pointer
->	O
lsn_off	int
,	O
sizeof	O
(	O
DB_LSN	struct
)	O
)	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB_log_flush	function
(	O
dbenv	pointer
,	O
&	O
lsn	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
mfp	pointer
->	O
ftype	int
==	O
0	int
)	O
ret	int
=	O
0	int
;	O
else	O
{	O
callpgin	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_pg	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
&&	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_TMP	int
,	O
NULL	O
,	O
NULL	O
,	O
DB_OSO_CREATE	int
|	O
DB_OSO_EXCL	int
|	O
DB_OSO_TEMP	int
,	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
||	O
!	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
)	O
{	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"unable to create temporary backing file"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
}	O
db_io	struct
.	O
fhp	pointer
=	O
&	O
dbmfp	pointer
->	O
fh	struct
;	O
db_io	struct
.	O
mutexp	pointer
=	O
dbmfp	pointer
->	O
mutexp	pointer
;	O
db_io	struct
.	O
pagesize	long
=	O
db_io	struct
.	O
bytes	long
=	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
;	O
db_io	struct
.	O
pgno	int
=	O
bhp	pointer
->	O
pgno	int
;	O
db_io	struct
.	O
buf	pointer
=	O
bhp	pointer
->	O
buf	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_CMPR	int
)	O
)	O
{	O
ret	int
=	O
CDB___memp_cmpr	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
&	O
db_io	struct
,	O
DB_IO_WRITE	int
,	O
(	O
ssize_t	long
*	O
)	O
&	O
nw	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
db_io	struct
.	O
pgno	int
==	O
PGNO_BASE_MD	int
)	O
{	O
size_t	long
required	long
=	O
db_io	struct
.	O
pagesize	long
;	O
size_t	long
orig_bytes	long
=	O
db_io	struct
.	O
bytes	long
;	O
db_io	struct
.	O
bytes	long
=	O
DBMETASIZE	int
;	O
for	O
(	O
db_io	struct
.	O
pagesize	long
=	O
DBMETASIZE	int
;	O
db_io	struct
.	O
pagesize	long
<	O
required	long
;	O
db_io	struct
.	O
pagesize	long
<<=	O
1	int
)	O
{	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
&	O
db_io	struct
,	O
DB_IO_WRITE	int
,	O
&	O
nw	long
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
||	O
nw	long
!=	O
DBMETASIZE	int
)	O
break	O
;	O
}	O
db_io	struct
.	O
bytes	long
=	O
orig_bytes	long
;	O
db_io	struct
.	O
pagesize	long
=	O
required	long
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
&	O
db_io	struct
,	O
DB_IO_WRITE	int
,	O
&	O
nw	long
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
&	O
db_io	struct
,	O
DB_IO_WRITE	int
,	O
&	O
nw	long
)	O
;	O
}	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
fail	pointer
=	O
"write"	pointer
;	O
goto	O
syserr	O
;	O
}	O
if	O
(	O
nw	long
!=	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
{	O
ret	int
=	O
EIO	int
;	O
fail	pointer
=	O
"write"	pointer
;	O
goto	O
syserr	O
;	O
}	O
file_dead	O
:	O
MUTEX_UNLOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
callpgin	int
)	O
F_SET	O
(	O
bhp	pointer
,	O
BH_CALLPGIN	int
)	O
;	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_DIRTY	int
|	O
BH_LOCKED	int
)	O
;	O
dosync	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_WRITE	int
)	O
)	O
{	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_WRITE	int
)	O
;	O
--	O
mp	pointer
->	O
lsn_cnt	int
;	O
if	O
(	O
mfp	pointer
!=	O
NULL	O
)	O
dosync	int
=	O
--	O
mfp	pointer
->	O
lsn_cnt	int
==	O
0	int
?	O
1	int
:	O
0	int
;	O
}	O
c_mp	pointer
=	O
BH_TO_CACHE	O
(	O
dbmp	pointer
,	O
bhp	pointer
)	O
;	O
++	O
c_mp	pointer
->	O
stat	pointer
.	O
st_page_clean	int
;	O
--	O
c_mp	pointer
->	O
stat	pointer
.	O
st_page_dirty	int
;	O
if	O
(	O
mfp	pointer
!=	O
NULL	O
)	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_page_out	int
;	O
if	O
(	O
dosync	int
)	O
{	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
syncfail	int
=	O
CDB___os_fsync	function
(	O
dbenv	pointer
,	O
&	O
dbmfp	pointer
->	O
fh	struct
)	O
!=	O
0	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
syncfail	int
)	O
F_SET	O
(	O
mp	pointer
,	O
MP_LSN_RETRY	int
)	O
;	O
}	O
if	O
(	O
wrotep	pointer
!=	O
NULL	O
)	O
*	O
wrotep	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
syserr	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s failed for page %lu"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
fail	pointer
,	O
(	O
u_long	long
)	O
bhp	pointer
->	O
pgno	int
)	O
;	O
err	pointer
:	O
MUTEX_UNLOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
callpgin	int
)	O
F_SET	O
(	O
bhp	pointer
,	O
BH_CALLPGIN	int
)	O
;	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___memp_pg	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
is_pgin	int
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
is_pgin	int
;	O
{	O
DBT	struct
dbt	struct
,	O
*	O
dbtp	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_MPREG	struct
*	O
mpreg	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
int	O
ftype	int
,	O
ret	int
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
ftype	int
=	O
mfp	pointer
->	O
ftype	int
;	O
for	O
(	O
mpreg	pointer
=	O
LIST_FIRST	O
(	O
&	O
dbmp	pointer
->	O
dbregq	struct
)	O
;	O
mpreg	pointer
!=	O
NULL	O
;	O
mpreg	pointer
=	O
LIST_NEXT	O
(	O
mpreg	pointer
,	O
q	struct
)	O
)	O
{	O
if	O
(	O
ftype	int
!=	O
mpreg	pointer
->	O
ftype	int
)	O
continue	O
;	O
if	O
(	O
mfp	pointer
->	O
pgcookie_len	int
==	O
0	int
)	O
dbtp	pointer
=	O
NULL	O
;	O
else	O
{	O
dbt	struct
.	O
size	int
=	O
mfp	pointer
->	O
pgcookie_len	int
;	O
dbt	struct
.	O
data	pointer
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
pgcookie_off	int
)	O
;	O
dbtp	pointer
=	O
&	O
dbt	struct
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
is_pgin	int
)	O
{	O
if	O
(	O
mpreg	pointer
->	O
pgin	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
mpreg	pointer
->	O
pgin	pointer
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
bhp	pointer
->	O
pgno	int
,	O
bhp	pointer
->	O
buf	pointer
,	O
dbtp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
mpreg	pointer
->	O
pgout	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
mpreg	pointer
->	O
pgout	pointer
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
bhp	pointer
->	O
pgno	int
,	O
bhp	pointer
->	O
buf	pointer
,	O
dbtp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
}	O
if	O
(	O
mpreg	pointer
==	O
NULL	O
)	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
CDB___db_err	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"%s: %s failed for page %lu"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
is_pgin	int
?	O
"pgin"	pointer
:	O
"pgout"	pointer
,	O
(	O
u_long	long
)	O
bhp	pointer
->	O
pgno	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___memp_bhfree	function
(	O
dbmp	pointer
,	O
bhp	pointer
,	O
free_mem	int
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
free_mem	int
;	O
{	O
DB_HASHTAB	struct
*	O
dbht	pointer
;	O
MPOOL	struct
*	O
c_mp	pointer
,	O
*	O
mp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
int	O
n_bucket	int
,	O
n_cache	int
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
c_mp	pointer
=	O
BH_TO_CACHE	O
(	O
dbmp	pointer
,	O
bhp	pointer
)	O
;	O
n_cache	int
=	O
NCACHE	O
(	O
mp	pointer
,	O
bhp	pointer
->	O
pgno	int
)	O
;	O
n_bucket	int
=	O
NBUCKET	O
(	O
c_mp	pointer
,	O
bhp	pointer
->	O
mf_offset	int
,	O
bhp	pointer
->	O
pgno	int
)	O
;	O
dbht	pointer
=	O
R_ADDR	O
(	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	int
]	O
,	O
c_mp	pointer
->	O
htab	int
)	O
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
dbht	pointer
[	O
n_bucket	int
]	O
,	O
bhp	pointer
,	O
hq	struct
,	O
__bh	struct
)	O
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
c_mp	pointer
->	O
bhq	struct
,	O
bhp	pointer
,	O
q	struct
,	O
__bh	struct
)	O
;	O
mfp	pointer
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
bhp	pointer
->	O
mf_offset	int
)	O
;	O
if	O
(	O
--	O
mfp	pointer
->	O
ref_cnt	int
==	O
0	int
)	O
CDB___memp_mf_discard	function
(	O
dbmp	pointer
,	O
mfp	pointer
)	O
;	O
CDB___memp_cmpr_free_chain	function
(	O
dbmp	pointer
,	O
bhp	pointer
)	O
;	O
if	O
(	O
free_mem	int
)	O
{	O
--	O
c_mp	pointer
->	O
stat	pointer
.	O
st_page_clean	int
;	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	int
]	O
.	O
addr	pointer
,	O
bhp	pointer
)	O
;	O
}	O
}	O
static	O
int	O
__memp_upgrade	function
(	O
dbmp	pointer
,	O
dbmfp	pointer
,	O
mfp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
{	O
DB_FH	struct
fh	struct
;	O
int	O
ret	int
;	O
char	O
*	O
rpath	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_UPGRADE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_UPGRADE_FAIL	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
path_off	int
)	O
,	O
0	int
,	O
NULL	O
,	O
&	O
rpath	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
CDB___os_open	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
rpath	pointer
,	O
0	int
,	O
0	int
,	O
&	O
fh	struct
)	O
!=	O
0	int
)	O
{	O
F_SET	O
(	O
dbmfp	pointer
,	O
MP_UPGRADE_FAIL	int
)	O
;	O
ret	int
=	O
1	int
;	O
}	O
else	O
{	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
dbmfp	pointer
->	O
fh	struct
)	O
;	O
dbmfp	pointer
->	O
fh	struct
=	O
fh	struct
;	O
F_SET	O
(	O
dbmfp	pointer
,	O
MP_UPGRADE	int
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
CDB___os_freestr	function
(	O
rpath	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O