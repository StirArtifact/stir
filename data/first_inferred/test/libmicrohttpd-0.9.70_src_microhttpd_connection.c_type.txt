static	O
ssize_t	long
recv_param_adapter	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
void	O
*	O
other	pointer
,	O
size_t	long
i	long
)	O
{	O
ssize_t	long
ret	long
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
connection	pointer
->	O
socket_fd	int
)	O
||	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
)	O
{	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
if	O
(	O
i	long
>	O
MHD_SCKT_SEND_MAX_SIZE_	O
)	O
i	long
=	O
MHD_SCKT_SEND_MAX_SIZE_	O
;	O
ret	long
=	O
MHD_recv_	O
(	O
connection	pointer
->	O
socket_fd	int
,	O
other	pointer
,	O
i	long
)	O
;	O
if	O
(	O
0	int
>	O
ret	long
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_READ_READY	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_ERR_AGAIN_	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_ECONNRESET_	O
)	O
)	O
return	O
MHD_ERR_CONNRESET_	O
;	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
else	O
if	O
(	O
i	long
>	O
(	O
size_t	long
)	O
ret	long
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_READ_READY	int
;	O
return	O
ret	long
;	O
}	O
static	O
ssize_t	long
send_param_adapter	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
const	O
void	O
*	O
other	pointer
,	O
size_t	long
i	long
)	O
{	O
ssize_t	long
ret	long
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
connection	pointer
->	O
socket_fd	int
)	O
||	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
)	O
{	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
if	O
(	O
i	long
>	O
MHD_SCKT_SEND_MAX_SIZE_	O
)	O
i	long
=	O
MHD_SCKT_SEND_MAX_SIZE_	O
;	O
ret	long
=	O
MHD_send_	O
(	O
connection	pointer
->	O
socket_fd	int
,	O
other	pointer
,	O
i	long
)	O
;	O
if	O
(	O
0	int
>	O
ret	long
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_ERR_AGAIN_	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_ECONNRESET_	O
)	O
)	O
return	O
MHD_ERR_CONNRESET_	O
;	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
else	O
if	O
(	O
i	long
>	O
(	O
size_t	long
)	O
ret	long
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
ret	long
;	O
}	O
int	O
MHD_get_connection_values	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
MHD_KeyValueIterator	pointer
iterator	pointer
,	O
void	O
*	O
iterator_cls	pointer
)	O
{	O
int	O
ret	long
;	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
)	O
return	O
-	O
1	int
;	O
ret	long
=	O
0	int
;	O
for	O
(	O
pos	long
=	O
connection	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
if	O
(	O
0	int
!=	O
(	O
pos	long
->	O
kind	enum
&	O
kind	enum
)	O
)	O
{	O
ret	long
++	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
iterator	pointer
)	O
&&	O
(	O
MHD_YES	int
!=	O
iterator	pointer
(	O
iterator_cls	pointer
,	O
pos	long
->	O
kind	enum
,	O
pos	long
->	O
header	pointer
,	O
pos	long
->	O
value	long
)	O
)	O
)	O
return	O
ret	long
;	O
}	O
return	O
ret	long
;	O
}	O
int	O
MHD_get_connection_values_n	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
MHD_KeyValueIteratorN	pointer
iterator	pointer
,	O
void	O
*	O
iterator_cls	pointer
)	O
{	O
int	O
ret	long
;	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
)	O
return	O
-	O
1	int
;	O
ret	long
=	O
0	int
;	O
if	O
(	O
NULL	O
==	O
iterator	pointer
)	O
for	O
(	O
pos	long
=	O
connection	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
kind	enum
&	O
pos	long
->	O
kind	enum
)	O
)	O
ret	long
++	O
;	O
}	O
else	O
for	O
(	O
pos	long
=	O
connection	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
if	O
(	O
0	int
!=	O
(	O
kind	enum
&	O
pos	long
->	O
kind	enum
)	O
)	O
{	O
ret	long
++	O
;	O
if	O
(	O
MHD_NO	int
==	O
iterator	pointer
(	O
iterator_cls	pointer
,	O
pos	long
->	O
kind	enum
,	O
pos	long
->	O
header	pointer
,	O
pos	long
->	O
header_size	long
,	O
pos	long
->	O
value	long
,	O
pos	long
->	O
value_size	long
)	O
)	O
return	O
ret	long
;	O
}	O
return	O
ret	long
;	O
}	O
static	O
int	O
MHD_set_connection_value_n_nocheck_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
,	O
size_t	long
key_size	long
,	O
const	O
char	O
*	O
value	long
,	O
size_t	long
value_size	long
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
pos	long
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
sizeof	O
(	O
struct	O
MHD_HTTP_Header	struct
)	O
,	O
true	int
)	O
;	O
if	O
(	O
NULL	O
==	O
pos	long
)	O
return	O
MHD_NO	int
;	O
pos	long
->	O
header	pointer
=	O
(	O
char	O
*	O
)	O
key	pointer
;	O
pos	long
->	O
header_size	long
=	O
key_size	long
;	O
pos	long
->	O
value	long
=	O
(	O
char	O
*	O
)	O
value	long
;	O
pos	long
->	O
value_size	long
=	O
value_size	long
;	O
pos	long
->	O
kind	enum
=	O
kind	enum
;	O
pos	long
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
->	O
headers_received_tail	pointer
)	O
{	O
connection	pointer
->	O
headers_received	pointer
=	O
pos	long
;	O
connection	pointer
->	O
headers_received_tail	pointer
=	O
pos	long
;	O
}	O
else	O
{	O
connection	pointer
->	O
headers_received_tail	pointer
->	O
next	pointer
=	O
pos	long
;	O
connection	pointer
->	O
headers_received_tail	pointer
=	O
pos	long
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
int	O
MHD_set_connection_value_n	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
,	O
size_t	long
key_size	long
,	O
const	O
char	O
*	O
value	long
,	O
size_t	long
value_size	long
)	O
{	O
if	O
(	O
(	O
MHD_GET_ARGUMENT_KIND	int
!=	O
kind	enum
)	O
&&	O
(	O
(	O
(	O
key	pointer
?	O
strlen	function
(	O
key	pointer
)	O
:	O
0	int
)	O
!=	O
key_size	long
)	O
||	O
(	O
(	O
value	long
?	O
strlen	function
(	O
value	long
)	O
:	O
0	int
)	O
!=	O
value_size	long
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
return	O
MHD_set_connection_value_n_nocheck_	function
(	O
connection	pointer
,	O
kind	enum
,	O
key	pointer
,	O
key_size	long
,	O
value	long
,	O
value_size	long
)	O
;	O
}	O
int	O
MHD_set_connection_value	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
value	long
)	O
{	O
return	O
MHD_set_connection_value_n_nocheck_	function
(	O
connection	pointer
,	O
kind	enum
,	O
key	pointer
,	O
NULL	O
!=	O
key	pointer
?	O
strlen	function
(	O
key	pointer
)	O
:	O
0	int
,	O
value	long
,	O
NULL	O
!=	O
value	long
?	O
strlen	function
(	O
value	long
)	O
:	O
0	int
)	O
;	O
}	O
const	O
char	O
*	O
MHD_lookup_connection_value	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
)	O
{	O
const	O
char	O
*	O
value	long
;	O
value	long
=	O
NULL	O
;	O
(	O
void	O
)	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
kind	enum
,	O
key	pointer
,	O
(	O
NULL	O
==	O
key	pointer
)	O
?	O
0	int
:	O
strlen	function
(	O
key	pointer
)	O
,	O
&	O
value	long
,	O
NULL	O
)	O
;	O
return	O
value	long
;	O
}	O
_MHD_EXTERN	O
int	O
MHD_lookup_connection_value_n	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
,	O
size_t	long
key_size	long
,	O
const	O
char	O
*	O
*	O
value_ptr	pointer
,	O
size_t	long
*	O
value_size_ptr	pointer
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
key	pointer
)	O
{	O
for	O
(	O
pos	long
=	O
connection	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
(	O
kind	enum
&	O
pos	long
->	O
kind	enum
)	O
)	O
&&	O
(	O
NULL	O
==	O
pos	long
->	O
header	pointer
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
pos	long
=	O
connection	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
(	O
kind	enum
&	O
pos	long
->	O
kind	enum
)	O
)	O
&&	O
(	O
key_size	long
==	O
pos	long
->	O
header_size	long
)	O
&&	O
(	O
(	O
key	pointer
==	O
pos	long
->	O
header	pointer
)	O
||	O
(	O
MHD_str_equal_caseless_bin_n_	function
(	O
key	pointer
,	O
pos	long
->	O
header	pointer
,	O
key_size	long
)	O
)	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
NULL	O
==	O
pos	long
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
!=	O
value_ptr	pointer
)	O
*	O
value_ptr	pointer
=	O
pos	long
->	O
value	long
;	O
if	O
(	O
NULL	O
!=	O
value_size_ptr	pointer
)	O
*	O
value_size_ptr	pointer
=	O
pos	long
->	O
value_size	long
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
bool	bool
MHD_lookup_header_token_ci	function
(	O
const	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
const	O
char	O
*	O
header	pointer
,	O
size_t	long
header_len	long
,	O
const	O
char	O
*	O
token	pointer
,	O
size_t	long
token_len	long
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
(	O
NULL	O
==	O
connection	pointer
)	O
||	O
(	O
NULL	O
==	O
header	pointer
)	O
||	O
(	O
0	int
==	O
header	pointer
[	O
0	int
]	O
)	O
||	O
(	O
NULL	O
==	O
token	pointer
)	O
||	O
(	O
0	int
==	O
token	pointer
[	O
0	int
]	O
)	O
)	O
return	O
false	int
;	O
for	O
(	O
pos	long
=	O
connection	pointer
->	O
headers_received	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
(	O
pos	long
->	O
kind	enum
&	O
MHD_HEADER_KIND	int
)	O
)	O
&&	O
(	O
header_len	long
==	O
pos	long
->	O
header_size	long
)	O
&&	O
(	O
(	O
header	pointer
==	O
pos	long
->	O
header	pointer
)	O
||	O
(	O
MHD_str_equal_caseless_bin_n_	function
(	O
header	pointer
,	O
pos	long
->	O
header	pointer
,	O
header_len	long
)	O
)	O
)	O
&&	O
(	O
MHD_str_has_token_caseless_	function
(	O
pos	long
->	O
value	long
,	O
token	pointer
,	O
token_len	long
)	O
)	O
)	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
int	O
need_100_continue	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
const	O
char	O
*	O
expect	pointer
;	O
return	O
(	O
(	O
NULL	O
!=	O
connection	pointer
->	O
version	pointer
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
connection	pointer
->	O
version	pointer
,	O
MHD_HTTP_VERSION_1_1	pointer
)	O
)	O
&&	O
(	O
MHD_NO	int
!=	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_EXPECT	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_EXPECT	pointer
)	O
,	O
&	O
expect	pointer
,	O
NULL	O
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
expect	pointer
,	O
"100-continue"	pointer
)	O
)	O
)	O
;	O
}	O
void	O
MHD_connection_mark_closed_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
const	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CLOSED	int
;	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_TURBO	int
)	O
)	O
{	O
shutdown	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
SHUT_WR	int
)	O
;	O
}	O
}	O
void	O
MHD_connection_close_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_RequestTerminationCode	enum
termination_code	enum
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
struct	O
MHD_Response	struct
*	O
resp	pointer
=	O
connection	pointer
->	O
response	pointer
;	O
MHD_connection_mark_closed_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
resp	pointer
)	O
{	O
connection	pointer
->	O
response	pointer
=	O
NULL	O
;	O
MHD_destroy_response	function
(	O
resp	pointer
)	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_completed	pointer
)	O
&&	O
(	O
connection	pointer
->	O
client_aware	bool
)	O
)	O
daemon	function
->	O
notify_completed	pointer
(	O
daemon	function
->	O
notify_completed_cls	pointer
,	O
connection	pointer
,	O
&	O
connection	pointer
->	O
client_context	pointer
,	O
termination_code	enum
)	O
;	O
connection	pointer
->	O
client_aware	bool
=	O
false	int
;	O
}	O
static	O
void	O
connection_close_error	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
const	O
char	O
*	O
emsg	pointer
)	O
{	O
if	O
(	O
NULL	O
!=	O
emsg	pointer
)	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
emsg	pointer
)	O
;	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_WITH_ERROR	int
)	O
;	O
}	O
static	O
int	O
try_ready_normal_body	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
ssize_t	long
ret	long
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
response	pointer
=	O
connection	pointer
->	O
response	pointer
;	O
if	O
(	O
NULL	O
==	O
response	pointer
->	O
crc	pointer
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
(	O
0	int
==	O
response	pointer
->	O
total_size	long
)	O
||	O
(	O
connection	pointer
->	O
response_write_position	long
==	O
response	pointer
->	O
total_size	long
)	O
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
(	O
response	pointer
->	O
data_start	long
<=	O
connection	pointer
->	O
response_write_position	long
)	O
&&	O
(	O
response	pointer
->	O
data_size	long
+	O
response	pointer
->	O
data_start	long
>	O
connection	pointer
->	O
response_write_position	long
)	O
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
MHD_resp_sender_sendfile	int
==	O
connection	pointer
->	O
resp_sender	enum
)	O
{	O
return	O
MHD_YES	int
;	O
}	O
ret	long
=	O
response	pointer
->	O
crc	pointer
(	O
response	pointer
->	O
crc_cls	pointer
,	O
connection	pointer
->	O
response_write_position	long
,	O
response	pointer
->	O
data	pointer
,	O
(	O
size_t	long
)	O
MHD_MIN	O
(	O
(	O
uint64_t	long
)	O
response	pointer
->	O
data_buffer_size	long
,	O
response	pointer
->	O
total_size	long
-	O
connection	pointer
->	O
response_write_position	long
)	O
)	O
;	O
if	O
(	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_OF_STREAM	O
)	O
==	O
ret	long
)	O
||	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_WITH_ERROR	O
)	O
==	O
ret	long
)	O
)	O
{	O
response	pointer
->	O
total_size	long
=	O
connection	pointer
->	O
response_write_position	long
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_OF_STREAM	O
)	O
==	O
ret	long
)	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
else	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (application reported error generating data)\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
response	pointer
->	O
data_start	long
=	O
connection	pointer
->	O
response_write_position	long
;	O
response	pointer
->	O
data_size	long
=	O
ret	long
;	O
if	O
(	O
0	int
==	O
ret	long
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_NORMAL_BODY_UNREADY	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
try_ready_chunked_body	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
ssize_t	long
ret	long
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
char	O
cbuf	array
[	O
10	int
]	O
;	O
int	O
cblen	int
;	O
response	pointer
=	O
connection	pointer
->	O
response	pointer
;	O
if	O
(	O
NULL	O
==	O
response	pointer
->	O
crc	pointer
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
write_buffer_size	long
)	O
{	O
size_t	long
size	long
;	O
size	long
=	O
MHD_pool_get_free	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
if	O
(	O
size	long
<	O
128	int
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (out of memory)\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
2	int
*	O
(	O
0xFFFFFF	int
+	O
sizeof	O
(	O
cbuf	array
)	O
+	O
2	int
)	O
)	O
<	O
size	long
)	O
size	long
=	O
2	int
*	O
(	O
0xFFFFFF	int
+	O
sizeof	O
(	O
cbuf	array
)	O
+	O
2	int
)	O
;	O
connection	pointer
->	O
write_buffer	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
size	long
,	O
false	int
)	O
;	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
->	O
write_buffer	pointer
)	O
;	O
connection	pointer
->	O
write_buffer_size	long
=	O
size	long
;	O
}	O
if	O
(	O
0	int
==	O
response	pointer
->	O
total_size	long
)	O
ret	long
=	O
0	int
;	O
else	O
if	O
(	O
(	O
response	pointer
->	O
data_start	long
<=	O
connection	pointer
->	O
response_write_position	long
)	O
&&	O
(	O
response	pointer
->	O
data_start	long
+	O
response	pointer
->	O
data_size	long
>	O
connection	pointer
->	O
response_write_position	long
)	O
)	O
{	O
const	O
size_t	long
data_write_offset	long
=	O
(	O
size_t	long
)	O
(	O
connection	pointer
->	O
response_write_position	long
-	O
response	pointer
->	O
data_start	long
)	O
;	O
ret	long
=	O
response	pointer
->	O
data_size	long
-	O
data_write_offset	long
;	O
if	O
(	O
(	O
(	O
size_t	long
)	O
ret	long
)	O
>	O
connection	pointer
->	O
write_buffer_size	long
-	O
sizeof	O
(	O
cbuf	array
)	O
-	O
2	int
)	O
ret	long
=	O
connection	pointer
->	O
write_buffer_size	long
-	O
sizeof	O
(	O
cbuf	array
)	O
-	O
2	int
;	O
memcpy	function
(	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
]	O
,	O
&	O
response	pointer
->	O
data	pointer
[	O
data_write_offset	long
]	O
,	O
ret	long
)	O
;	O
}	O
else	O
{	O
ret	long
=	O
response	pointer
->	O
crc	pointer
(	O
response	pointer
->	O
crc_cls	pointer
,	O
connection	pointer
->	O
response_write_position	long
,	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
]	O
,	O
connection	pointer
->	O
write_buffer_size	long
-	O
sizeof	O
(	O
cbuf	array
)	O
-	O
2	int
)	O
;	O
}	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_WITH_ERROR	O
)	O
==	O
ret	long
)	O
{	O
response	pointer
->	O
total_size	long
=	O
connection	pointer
->	O
response_write_position	long
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (application error generating response)\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
(	O
(	O
ssize_t	long
)	O
MHD_CONTENT_READER_END_OF_STREAM	O
)	O
==	O
ret	long
)	O
||	O
(	O
0	int
==	O
response	pointer
->	O
total_size	long
)	O
)	O
{	O
memcpy	function
(	O
connection	pointer
->	O
write_buffer	pointer
,	O
"0\r\n"	pointer
,	O
3	int
)	O
;	O
connection	pointer
->	O
write_buffer_append_offset	long
=	O
3	int
;	O
connection	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
response	pointer
->	O
total_size	long
=	O
connection	pointer
->	O
response_write_position	long
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
0	int
==	O
ret	long
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CHUNKED_BODY_UNREADY	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
ret	long
>	O
0xFFFFFF	int
)	O
ret	long
=	O
0xFFFFFF	int
;	O
cblen	int
=	O
MHD_snprintf_	O
(	O
cbuf	array
,	O
sizeof	O
(	O
cbuf	array
)	O
,	O
"%X\r\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
ret	long
)	O
;	O
mhd_assert	O
(	O
cblen	int
>	O
0	int
)	O
;	O
mhd_assert	O
(	O
(	O
size_t	long
)	O
cblen	int
<	O
sizeof	O
(	O
cbuf	array
)	O
)	O
;	O
memcpy	function
(	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
-	O
cblen	int
]	O
,	O
cbuf	array
,	O
cblen	int
)	O
;	O
memcpy	function
(	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
sizeof	O
(	O
cbuf	array
)	O
+	O
ret	long
]	O
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
connection	pointer
->	O
response_write_position	long
+=	O
ret	long
;	O
connection	pointer
->	O
write_buffer_send_offset	long
=	O
sizeof	O
(	O
cbuf	array
)	O
-	O
cblen	int
;	O
connection	pointer
->	O
write_buffer_append_offset	long
=	O
sizeof	O
(	O
cbuf	array
)	O
+	O
ret	long
+	O
2	int
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
keepalive_possible	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
if	O
(	O
MHD_CONN_MUST_CLOSE	int
==	O
connection	pointer
->	O
keepalive	enum
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
->	O
version	pointer
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
&&	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
response	pointer
->	O
flags	int
&	O
MHD_RF_HTTP_VERSION_1_0_ONLY	int
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
connection	pointer
->	O
version	pointer
,	O
MHD_HTTP_VERSION_1_1	pointer
)	O
&&	O
(	O
(	O
NULL	O
==	O
connection	pointer
->	O
response	pointer
)	O
||	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
response	pointer
->	O
flags	int
&	O
MHD_RF_HTTP_VERSION_1_0_RESPONSE	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
MHD_lookup_header_s_token_ci	O
(	O
connection	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"upgrade"	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
MHD_lookup_header_s_token_ci	O
(	O
connection	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"close"	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
connection	pointer
->	O
version	pointer
,	O
MHD_HTTP_VERSION_1_0	pointer
)	O
)	O
{	O
if	O
(	O
MHD_lookup_header_s_token_ci	O
(	O
connection	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"Keep-Alive"	pointer
)	O
)	O
return	O
MHD_YES	int
;	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
static	O
void	O
get_date_string	function
(	O
char	O
*	O
date	pointer
,	O
size_t	long
date_len	long
)	O
{	O
static	O
const	O
char	O
*	O
const	O
days	array
[	O
]	O
=	O
{	O
"Sun"	pointer
,	O
"Mon"	pointer
,	O
"Tue"	pointer
,	O
"Wed"	pointer
,	O
"Thu"	pointer
,	O
"Fri"	pointer
,	O
"Sat"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
mons	array
[	O
]	O
=	O
{	O
"Jan"	pointer
,	O
"Feb"	pointer
,	O
"Mar"	pointer
,	O
"Apr"	pointer
,	O
"May"	pointer
,	O
"Jun"	pointer
,	O
"Jul"	pointer
,	O
"Aug"	pointer
,	O
"Sep"	pointer
,	O
"Oct"	pointer
,	O
"Nov"	pointer
,	O
"Dec"	pointer
}	O
;	O
struct	O
tm	struct
now	struct
;	O
time_t	long
t	long
;	O
date	pointer
[	O
0	int
]	O
=	O
0	int
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
if	O
(	O
NULL	O
==	O
gmtime_r	function
(	O
&	O
t	long
,	O
&	O
now	struct
)	O
)	O
return	O
;	O
MHD_snprintf_	O
(	O
date	pointer
,	O
date_len	long
,	O
"Date: %3s, %02u %3s %04u %02u:%02u:%02u GMT\r\n"	pointer
,	O
days	array
[	O
now	struct
.	O
tm_wday	int
%	O
7	int
]	O
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_mday	int
,	O
mons	array
[	O
now	struct
.	O
tm_mon	int
%	O
12	int
]	O
,	O
(	O
unsigned	O
int	O
)	O
(	O
1900	int
+	O
now	struct
.	O
tm_year	int
)	O
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_hour	int
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_min	int
,	O
(	O
unsigned	O
int	O
)	O
now	struct
.	O
tm_sec	int
)	O
;	O
}	O
static	O
bool	bool
try_grow_read_buffer	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
bool	bool
required	bool
)	O
{	O
size_t	long
new_size	long
;	O
size_t	long
avail_size	long
;	O
avail_size	long
=	O
MHD_pool_get_free	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
if	O
(	O
0	int
==	O
avail_size	long
)	O
return	O
false	int
;	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
read_buffer_size	long
)	O
new_size	long
=	O
avail_size	long
/	O
2	int
;	O
else	O
{	O
size_t	long
grow_size	long
;	O
grow_size	long
=	O
avail_size	long
/	O
8	int
;	O
if	O
(	O
MHD_BUF_INC_SIZE	int
>	O
grow_size	long
)	O
{	O
if	O
(	O
!	O
required	bool
)	O
return	O
false	int
;	O
else	O
{	O
static	O
const	O
size_t	long
small_inc	long
=	O
MHD_BUF_INC_SIZE	int
/	O
8	int
;	O
if	O
(	O
small_inc	long
<	O
avail_size	long
)	O
grow_size	long
=	O
small_inc	long
;	O
else	O
grow_size	long
=	O
avail_size	long
;	O
}	O
}	O
new_size	long
=	O
connection	pointer
->	O
read_buffer_size	long
+	O
grow_size	long
;	O
}	O
connection	pointer
->	O
read_buffer	pointer
=	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
connection	pointer
->	O
read_buffer	pointer
,	O
connection	pointer
->	O
read_buffer_size	long
,	O
new_size	long
)	O
;	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
->	O
read_buffer	pointer
)	O
;	O
connection	pointer
->	O
read_buffer_size	long
=	O
new_size	long
;	O
return	O
true	int
;	O
}	O
static	O
int	O
build_header_response	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
connection	pointer
->	O
response	pointer
;	O
size_t	long
size	long
;	O
size_t	long
off	long
;	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
char	O
code	int
[	O
256	int
]	O
;	O
char	O
date	pointer
[	O
128	int
]	O
;	O
size_t	long
datelen	long
;	O
char	O
content_length_buf	array
[	O
128	int
]	O
;	O
size_t	long
content_length_len	long
;	O
char	O
*	O
data	pointer
;	O
enum	O
MHD_ValueKind	enum
kind	enum
;	O
const	O
char	O
*	O
reason_phrase	pointer
;	O
uint32_t	int
rc	int
;	O
bool	bool
client_requested_close	bool
;	O
bool	bool
response_has_close	bool
;	O
bool	bool
response_has_keepalive	bool
;	O
const	O
char	O
*	O
have_encoding	pointer
;	O
bool	bool
must_add_close	bool
;	O
bool	bool
must_add_chunked_encoding	bool
;	O
bool	bool
must_add_keep_alive	bool
;	O
bool	bool
must_add_content_length	bool
;	O
bool	bool
may_add_content_length	bool
;	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
->	O
version	pointer
)	O
;	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
version	pointer
[	O
0	int
]	O
)	O
{	O
data	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
0	int
,	O
true	int
)	O
;	O
connection	pointer
->	O
write_buffer	pointer
=	O
data	pointer
;	O
connection	pointer
->	O
write_buffer_append_offset	long
=	O
0	int
;	O
connection	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
connection	pointer
->	O
write_buffer_size	long
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
rc	int
=	O
connection	pointer
->	O
responseCode	int
&	O
(	O
~	O
MHD_ICY_FLAG	O
)	O
;	O
if	O
(	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
==	O
connection	pointer
->	O
state	pointer
)	O
{	O
reason_phrase	pointer
=	O
MHD_get_reason_phrase_for	function
(	O
rc	int
)	O
;	O
off	long
=	O
MHD_snprintf_	O
(	O
code	int
,	O
sizeof	O
(	O
code	int
)	O
,	O
"%s %u %s\r\n"	pointer
,	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
responseCode	int
&	O
MHD_ICY_FLAG	O
)	O
)	O
?	O
"ICY"	pointer
:	O
(	O
(	O
MHD_str_equal_caseless_	function
(	O
MHD_HTTP_VERSION_1_0	pointer
,	O
connection	pointer
->	O
version	pointer
)	O
||	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
response	pointer
->	O
flags	int
&	O
MHD_RF_HTTP_VERSION_1_0_RESPONSE	int
)	O
)	O
)	O
?	O
MHD_HTTP_VERSION_1_0	pointer
:	O
MHD_HTTP_VERSION_1_1	pointer
)	O
,	O
rc	int
,	O
reason_phrase	pointer
)	O
;	O
size	long
=	O
off	long
+	O
2	int
;	O
kind	enum
=	O
MHD_HEADER_KIND	int
;	O
if	O
(	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
daemon	function
->	O
options	enum
&	O
MHD_USE_SUPPRESS_DATE_NO_CLOCK	int
)	O
)	O
&&	O
(	O
NULL	O
==	O
MHD_get_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_DATE	pointer
)	O
)	O
)	O
get_date_string	function
(	O
date	pointer
,	O
sizeof	O
(	O
date	pointer
)	O
)	O
;	O
else	O
date	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
datelen	long
=	O
strlen	function
(	O
date	pointer
)	O
;	O
size	long
+=	O
datelen	long
;	O
}	O
else	O
{	O
size	long
=	O
2	int
;	O
kind	enum
=	O
MHD_FOOTER_KIND	int
;	O
off	long
=	O
0	int
;	O
datelen	long
=	O
0	int
;	O
}	O
must_add_close	bool
=	O
false	int
;	O
must_add_chunked_encoding	bool
=	O
false	int
;	O
must_add_keep_alive	bool
=	O
false	int
;	O
must_add_content_length	bool
=	O
false	int
;	O
response_has_close	bool
=	O
false	int
;	O
switch	O
(	O
connection	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
:	O
response_has_close	bool
=	O
MHD_check_response_header_s_token_ci	O
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"close"	pointer
)	O
;	O
response_has_keepalive	bool
=	O
MHD_check_response_header_s_token_ci	O
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"Keep-Alive"	pointer
)	O
;	O
client_requested_close	bool
=	O
MHD_lookup_header_s_token_ci	O
(	O
connection	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"close"	pointer
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
response	pointer
->	O
flags	int
&	O
MHD_RF_HTTP_VERSION_1_0_ONLY	int
)	O
)	O
connection	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
else	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
upgrade_handler	pointer
)	O
connection	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
connection	pointer
->	O
have_chunked_upload	bool
=	O
false	int
;	O
have_encoding	pointer
=	O
MHD_get_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_TRANSFER_ENCODING	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
have_encoding	pointer
)	O
may_add_content_length	bool
=	O
true	int
;	O
else	O
may_add_content_length	bool
=	O
false	int
;	O
if	O
(	O
(	O
MHD_SIZE_UNKNOWN	O
==	O
response	pointer
->	O
total_size	long
)	O
&&	O
(	O
NULL	O
==	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
&&	O
(	O
!	O
client_requested_close	bool
)	O
)	O
{	O
if	O
(	O
(	O
MHD_YES	int
==	O
keepalive_possible	function
(	O
connection	pointer
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
MHD_HTTP_VERSION_1_1	pointer
,	O
connection	pointer
->	O
version	pointer
)	O
)	O
)	O
{	O
if	O
(	O
NULL	O
==	O
have_encoding	pointer
)	O
{	O
must_add_chunked_encoding	bool
=	O
true	int
;	O
connection	pointer
->	O
have_chunked_upload	bool
=	O
true	int
;	O
}	O
else	O
{	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
have_encoding	pointer
,	O
"identity"	pointer
)	O
)	O
{	O
must_add_close	bool
=	O
true	int
;	O
}	O
else	O
{	O
connection	pointer
->	O
have_chunked_upload	bool
=	O
true	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
response_has_close	bool
)	O
must_add_close	bool
=	O
true	int
;	O
}	O
}	O
if	O
(	O
(	O
(	O
client_requested_close	bool
)	O
||	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
||	O
(	O
MHD_CONN_MUST_CLOSE	int
==	O
connection	pointer
->	O
keepalive	enum
)	O
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
&&	O
(	O
NULL	O
==	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
response	pointer
->	O
flags	int
&	O
MHD_RF_HTTP_VERSION_1_0_ONLY	int
)	O
)	O
)	O
must_add_close	bool
=	O
true	int
;	O
if	O
(	O
(	O
!	O
may_add_content_length	bool
)	O
&&	O
(	O
!	O
connection	pointer
->	O
have_chunked_upload	bool
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
)	O
must_add_close	bool
=	O
true	int
;	O
if	O
(	O
(	O
MHD_SIZE_UNKNOWN	O
!=	O
response	pointer
->	O
total_size	long
)	O
&&	O
(	O
MHD_HTTP_NO_CONTENT	int
!=	O
rc	int
)	O
&&	O
(	O
MHD_HTTP_NOT_MODIFIED	int
!=	O
rc	int
)	O
&&	O
(	O
MHD_HTTP_OK	int
<=	O
rc	int
)	O
&&	O
(	O
NULL	O
==	O
MHD_get_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
)	O
)	O
&&	O
(	O
may_add_content_length	bool
)	O
&&	O
(	O
(	O
NULL	O
==	O
connection	pointer
->	O
method	pointer
)	O
||	O
(	O
!	O
MHD_str_equal_caseless_	function
(	O
connection	pointer
->	O
method	pointer
,	O
MHD_HTTP_METHOD_CONNECT	pointer
)	O
)	O
)	O
)	O
{	O
content_length_len	long
=	O
MHD_snprintf_	O
(	O
content_length_buf	array
,	O
sizeof	O
(	O
content_length_buf	array
)	O
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
": "	pointer
MHD_UNSIGNED_LONG_LONG_PRINTF	pointer
"\r\n"	pointer
,	O
(	O
MHD_UNSIGNED_LONG_LONG	O
)	O
response	pointer
->	O
total_size	long
)	O
;	O
must_add_content_length	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
!	O
response_has_keepalive	bool
)	O
&&	O
(	O
!	O
response_has_close	bool
)	O
&&	O
(	O
!	O
must_add_close	bool
)	O
&&	O
(	O
MHD_CONN_MUST_CLOSE	int
!=	O
connection	pointer
->	O
keepalive	enum
)	O
&&	O
(	O
NULL	O
==	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
MHD_YES	int
==	O
keepalive_possible	function
(	O
connection	pointer
)	O
)	O
)	O
must_add_keep_alive	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_BODY_SENT	int
:	O
response_has_keepalive	bool
=	O
false	int
;	O
break	O
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
MHD_CONN_MUST_CLOSE	int
!=	O
connection	pointer
->	O
keepalive	enum
)	O
{	O
if	O
(	O
(	O
must_add_close	bool
)	O
||	O
(	O
response_has_close	bool
)	O
)	O
connection	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
else	O
if	O
(	O
(	O
must_add_keep_alive	bool
)	O
||	O
(	O
response_has_keepalive	bool
)	O
)	O
connection	pointer
->	O
keepalive	enum
=	O
MHD_CONN_USE_KEEPALIVE	int
;	O
}	O
if	O
(	O
must_add_close	bool
)	O
size	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: close\r\n"	pointer
)	O
;	O
if	O
(	O
must_add_keep_alive	bool
)	O
size	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: Keep-Alive\r\n"	pointer
)	O
;	O
if	O
(	O
must_add_chunked_encoding	bool
)	O
size	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Transfer-Encoding: chunked\r\n"	pointer
)	O
;	O
if	O
(	O
must_add_content_length	bool
)	O
size	long
+=	O
content_length_len	long
;	O
mhd_assert	O
(	O
!	O
(	O
must_add_close	bool
&&	O
must_add_keep_alive	bool
)	O
)	O
;	O
mhd_assert	O
(	O
!	O
(	O
must_add_chunked_encoding	bool
&&	O
must_add_content_length	bool
)	O
)	O
;	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
kind	enum
==	O
kind	enum
)	O
&&	O
(	O
!	O
(	O
(	O
must_add_close	bool
)	O
&&	O
(	O
response_has_keepalive	bool
)	O
&&	O
(	O
pos	long
->	O
header_size	long
==	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_CONNECTION	pointer
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_bin_n_	function
(	O
pos	long
->	O
header	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_CONNECTION	pointer
)	O
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
value	long
,	O
"Keep-Alive"	pointer
)	O
)	O
)	O
)	O
)	O
size	long
+=	O
pos	long
->	O
header_size	long
+	O
pos	long
->	O
value_size	long
+	O
4	int
;	O
}	O
data	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
size	long
+	O
1	int
,	O
false	int
)	O
;	O
if	O
(	O
NULL	O
==	O
data	pointer
)	O
{	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
"Not enough memory for write!\n"	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
==	O
connection	pointer
->	O
state	pointer
)	O
{	O
memcpy	function
(	O
data	pointer
,	O
code	int
,	O
off	long
)	O
;	O
}	O
if	O
(	O
must_add_close	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"Connection: close\r\n"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: close\r\n"	pointer
)	O
)	O
;	O
off	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: close\r\n"	pointer
)	O
;	O
}	O
if	O
(	O
must_add_keep_alive	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"Connection: Keep-Alive\r\n"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: Keep-Alive\r\n"	pointer
)	O
)	O
;	O
off	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Connection: Keep-Alive\r\n"	pointer
)	O
;	O
}	O
if	O
(	O
must_add_chunked_encoding	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"Transfer-Encoding: chunked\r\n"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Transfer-Encoding: chunked\r\n"	pointer
)	O
)	O
;	O
off	long
+=	O
MHD_STATICSTR_LEN_	O
(	O
"Transfer-Encoding: chunked\r\n"	pointer
)	O
;	O
}	O
if	O
(	O
must_add_content_length	bool
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
content_length_buf	array
,	O
content_length_len	long
)	O
;	O
off	long
+=	O
content_length_len	long
;	O
}	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
kind	enum
==	O
kind	enum
)	O
&&	O
(	O
!	O
(	O
(	O
must_add_close	bool
)	O
&&	O
(	O
response_has_keepalive	bool
)	O
&&	O
(	O
pos	long
->	O
header_size	long
==	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_CONNECTION	pointer
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_bin_n_	function
(	O
pos	long
->	O
header	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_CONNECTION	pointer
)	O
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
pos	long
->	O
value	long
,	O
"Keep-Alive"	pointer
)	O
)	O
)	O
)	O
)	O
off	long
+=	O
MHD_snprintf_	O
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
size	long
-	O
off	long
,	O
"%s: %s\r\n"	pointer
,	O
pos	long
->	O
header	pointer
,	O
pos	long
->	O
value	long
)	O
;	O
}	O
if	O
(	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
==	O
connection	pointer
->	O
state	pointer
)	O
{	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
date	pointer
,	O
datelen	long
)	O
;	O
off	long
+=	O
datelen	long
;	O
}	O
memcpy	function
(	O
&	O
data	pointer
[	O
off	long
]	O
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
off	long
+=	O
2	int
;	O
if	O
(	O
off	long
!=	O
size	long
)	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
NULL	O
)	O
;	O
connection	pointer
->	O
write_buffer	pointer
=	O
data	pointer
;	O
connection	pointer
->	O
write_buffer_append_offset	long
=	O
size	long
;	O
connection	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
connection	pointer
->	O
write_buffer_size	long
=	O
size	long
+	O
1	int
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
transmit_error_response	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
unsigned	O
int	O
status_code	int
,	O
const	O
char	O
*	O
message	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
int	O
iret	int
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
->	O
version	pointer
)	O
{	O
connection	pointer
->	O
version	pointer
=	O
MHD_HTTP_VERSION_1_0	pointer
;	O
}	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
;	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
if	O
(	O
0	int
!=	O
connection	pointer
->	O
read_buffer_size	long
)	O
{	O
connection	pointer
->	O
read_buffer	pointer
=	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
connection	pointer
->	O
read_buffer	pointer
,	O
connection	pointer
->	O
read_buffer_size	long
,	O
0	int
)	O
;	O
connection	pointer
->	O
read_buffer_size	long
=	O
0	int
;	O
}	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
_	O
(	O
"Error processing request (HTTP response code is %u (`%s')). Closing connection.\n"	pointer
)	O
,	O
status_code	int
,	O
message	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
{	O
MHD_destroy_response	function
(	O
connection	pointer
->	O
response	pointer
)	O
;	O
connection	pointer
->	O
response	pointer
=	O
NULL	O
;	O
}	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
message	pointer
)	O
,	O
(	O
void	O
*	O
)	O
message	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
if	O
(	O
NULL	O
==	O
response	pointer
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CLOSED	int
;	O
return	O
;	O
}	O
iret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
status_code	int
,	O
response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
if	O
(	O
MHD_YES	int
!=	O
iret	int
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (failed to queue response)\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
mhd_assert	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
;	O
connection	pointer
->	O
keepalive	enum
=	O
MHD_CONN_MUST_CLOSE	int
;	O
if	O
(	O
MHD_NO	int
==	O
build_header_response	function
(	O
connection	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (failed to create response header)\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADERS_SENDING	int
;	O
}	O
}	O
static	O
void	O
MHD_connection_update_event_loop_info	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
return	O
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
connection	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_CONNECTION_INIT	int
:	O
case	O
MHD_CONNECTION_URL_RECEIVED	int
:	O
case	O
MHD_CONNECTION_HEADER_PART_RECEIVED	int
:	O
if	O
(	O
(	O
connection	pointer
->	O
read_buffer_offset	long
==	O
connection	pointer
->	O
read_buffer_size	long
)	O
&&	O
(	O
!	O
try_grow_read_buffer	function
(	O
connection	pointer
,	O
true	int
)	O
)	O
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
(	O
connection	pointer
->	O
url	pointer
!=	O
NULL	O
)	O
?	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
:	O
MHD_HTTP_URI_TOO_LONG	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
connection	pointer
->	O
read_closed	bool
)	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_READ	int
;	O
else	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_HEADERS_RECEIVED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_CONNECTION_HEADERS_PROCESSED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_CONNECTION_CONTINUE_SENDING	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_CONTINUE_SENT	int
:	O
if	O
(	O
connection	pointer
->	O
read_buffer_offset	long
==	O
connection	pointer
->	O
read_buffer_size	long
)	O
{	O
const	O
bool	bool
internal_poll	bool
=	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
;	O
if	O
(	O
(	O
!	O
try_grow_read_buffer	function
(	O
connection	pointer
,	O
true	int
)	O
)	O
&&	O
internal_poll	bool
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_INTERNAL_SERVER_ERROR	int
,	O
INTERNAL_ERROR	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
(	O
connection	pointer
->	O
read_buffer_offset	long
<	O
connection	pointer
->	O
read_buffer_size	long
)	O
&&	O
(	O
!	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_READ	int
;	O
else	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_BODY_RECEIVED	int
:	O
case	O
MHD_CONNECTION_FOOTER_PART_RECEIVED	int
:	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_READ	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_HEADERS_SENDING	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_HEADERS_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_CONNECTION_NORMAL_BODY_READY	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_NORMAL_BODY_UNREADY	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_CHUNKED_BODY_READY	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_CHUNKED_BODY_UNREADY	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_BLOCK	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_BODY_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_CONNECTION_FOOTERS_SENDING	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_WRITE	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_FOOTERS_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
MHD_CONNECTION_CLOSED	int
:	O
connection	pointer
->	O
event_loop_info	enum
=	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
;	O
return	O
;	O
case	O
MHD_CONNECTION_UPGRADE	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
static	O
char	O
*	O
get_next_header_line	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
size_t	long
*	O
line_len	pointer
)	O
{	O
char	O
*	O
rbuf	pointer
;	O
size_t	long
pos	long
;	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
read_buffer_offset	long
)	O
return	O
NULL	O
;	O
pos	long
=	O
0	int
;	O
rbuf	pointer
=	O
connection	pointer
->	O
read_buffer	pointer
;	O
while	O
(	O
(	O
pos	long
<	O
connection	pointer
->	O
read_buffer_offset	long
-	O
1	int
)	O
&&	O
(	O
'\r'	O
!=	O
rbuf	pointer
[	O
pos	long
]	O
)	O
&&	O
(	O
'\n'	O
!=	O
rbuf	pointer
[	O
pos	long
]	O
)	O
)	O
pos	long
++	O
;	O
if	O
(	O
(	O
pos	long
==	O
connection	pointer
->	O
read_buffer_offset	long
-	O
1	int
)	O
&&	O
(	O
'\n'	O
!=	O
rbuf	pointer
[	O
pos	long
]	O
)	O
)	O
{	O
if	O
(	O
(	O
connection	pointer
->	O
read_buffer_offset	long
==	O
connection	pointer
->	O
read_buffer_size	long
)	O
&&	O
(	O
!	O
try_grow_read_buffer	function
(	O
connection	pointer
,	O
true	int
)	O
)	O
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
(	O
NULL	O
!=	O
connection	pointer
->	O
url	pointer
)	O
?	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
:	O
MHD_HTTP_URI_TOO_LONG	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
}	O
if	O
(	O
line_len	pointer
)	O
*	O
line_len	pointer
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
line_len	pointer
)	O
*	O
line_len	pointer
=	O
pos	long
;	O
if	O
(	O
(	O
'\r'	O
==	O
rbuf	pointer
[	O
pos	long
]	O
)	O
&&	O
(	O
'\n'	O
==	O
rbuf	pointer
[	O
pos	long
+	O
1	int
]	O
)	O
)	O
rbuf	pointer
[	O
pos	long
++	O
]	O
=	O
'\0'	O
;	O
rbuf	pointer
[	O
pos	long
++	O
]	O
=	O
'\0'	O
;	O
connection	pointer
->	O
read_buffer	pointer
+=	O
pos	long
;	O
connection	pointer
->	O
read_buffer_size	long
-=	O
pos	long
;	O
connection	pointer
->	O
read_buffer_offset	long
-=	O
pos	long
;	O
return	O
rbuf	pointer
;	O
}	O
static	O
int	O
connection_add_header	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
size_t	long
key_size	long
,	O
const	O
char	O
*	O
value	long
,	O
size_t	long
value_size	long
,	O
enum	O
MHD_ValueKind	enum
kind	enum
)	O
{	O
if	O
(	O
MHD_NO	int
==	O
MHD_set_connection_value_n	function
(	O
connection	pointer
,	O
kind	enum
,	O
key	pointer
,	O
key_size	long
,	O
value	long
,	O
value_size	long
)	O
)	O
{	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
_	O
(	O
"Not enough memory in pool to allocate header record!\n"	pointer
)	O
)	O
;	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
parse_cookie_header	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
const	O
char	O
*	O
hdr	pointer
;	O
size_t	long
hdr_len	long
;	O
char	O
*	O
cpy	pointer
;	O
char	O
*	O
pos	long
;	O
char	O
*	O
sce	pointer
;	O
char	O
*	O
semicolon	pointer
;	O
char	O
*	O
equals	pointer
;	O
char	O
*	O
ekill	pointer
;	O
char	O
*	O
end	pointer
;	O
char	O
old	pointer
;	O
int	O
quotes	int
;	O
if	O
(	O
MHD_NO	int
==	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_COOKIE	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_COOKIE	pointer
)	O
,	O
&	O
hdr	pointer
,	O
&	O
hdr_len	long
)	O
)	O
return	O
MHD_YES	int
;	O
cpy	pointer
=	O
MHD_pool_allocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
hdr_len	long
+	O
1	int
,	O
true	int
)	O
;	O
if	O
(	O
NULL	O
==	O
cpy	pointer
)	O
{	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
_	O
(	O
"Not enough memory in pool to parse cookies!\n"	pointer
)	O
)	O
;	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
memcpy	function
(	O
cpy	pointer
,	O
hdr	pointer
,	O
hdr_len	long
)	O
;	O
cpy	pointer
[	O
hdr_len	long
]	O
=	O
'\0'	O
;	O
pos	long
=	O
cpy	pointer
;	O
while	O
(	O
NULL	O
!=	O
pos	long
)	O
{	O
while	O
(	O
' '	O
==	O
*	O
pos	long
)	O
pos	long
++	O
;	O
sce	pointer
=	O
pos	long
;	O
while	O
(	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
'\0'	O
)	O
&&	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
','	O
)	O
&&	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
';'	O
)	O
&&	O
(	O
(	O
*	O
sce	pointer
)	O
!=	O
'='	O
)	O
)	O
sce	pointer
++	O
;	O
ekill	pointer
=	O
sce	pointer
-	O
1	int
;	O
while	O
(	O
(	O
*	O
ekill	pointer
==	O
' '	O
)	O
&&	O
(	O
ekill	pointer
>=	O
pos	long
)	O
)	O
*	O
(	O
ekill	pointer
--	O
)	O
=	O
'\0'	O
;	O
old	pointer
=	O
*	O
sce	pointer
;	O
*	O
sce	pointer
=	O
'\0'	O
;	O
if	O
(	O
old	pointer
!=	O
'='	O
)	O
{	O
if	O
(	O
MHD_NO	int
==	O
connection_add_header	function
(	O
connection	pointer
,	O
pos	long
,	O
ekill	pointer
-	O
pos	long
+	O
1	int
,	O
""	pointer
,	O
0	int
,	O
MHD_COOKIE_KIND	int
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
old	pointer
==	O
'\0'	O
)	O
break	O
;	O
pos	long
=	O
sce	pointer
+	O
1	int
;	O
continue	O
;	O
}	O
equals	pointer
=	O
sce	pointer
+	O
1	int
;	O
quotes	int
=	O
0	int
;	O
semicolon	pointer
=	O
equals	pointer
;	O
while	O
(	O
(	O
'\0'	O
!=	O
semicolon	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
0	int
!=	O
quotes	int
)	O
||	O
(	O
(	O
';'	O
!=	O
semicolon	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
','	O
!=	O
semicolon	pointer
[	O
0	int
]	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
'"'	O
==	O
semicolon	pointer
[	O
0	int
]	O
)	O
quotes	int
=	O
(	O
quotes	int
+	O
1	int
)	O
&	O
1	int
;	O
semicolon	pointer
++	O
;	O
}	O
end	pointer
=	O
semicolon	pointer
;	O
if	O
(	O
'\0'	O
==	O
semicolon	pointer
[	O
0	int
]	O
)	O
semicolon	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
!=	O
semicolon	pointer
)	O
{	O
semicolon	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
semicolon	pointer
++	O
;	O
}	O
if	O
(	O
(	O
'"'	O
==	O
equals	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'"'	O
==	O
end	pointer
[	O
-	O
1	int
]	O
)	O
)	O
{	O
equals	pointer
++	O
;	O
end	pointer
--	O
;	O
*	O
end	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
connection_add_header	function
(	O
connection	pointer
,	O
pos	long
,	O
ekill	pointer
-	O
pos	long
+	O
1	int
,	O
equals	pointer
,	O
end	pointer
-	O
equals	pointer
,	O
MHD_COOKIE_KIND	int
)	O
)	O
return	O
MHD_NO	int
;	O
pos	long
=	O
semicolon	pointer
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
parse_initial_message_line	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
char	O
*	O
line	int
,	O
size_t	long
line_len	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
const	O
char	O
*	O
curi	pointer
;	O
char	O
*	O
uri	pointer
;	O
char	O
*	O
http_version	pointer
;	O
char	O
*	O
args	pointer
;	O
unsigned	O
int	O
unused_num_headers	int
;	O
if	O
(	O
NULL	O
==	O
(	O
uri	pointer
=	O
memchr	function
(	O
line	int
,	O
' '	O
,	O
line_len	pointer
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
uri	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
connection	pointer
->	O
method	pointer
=	O
line	int
;	O
uri	pointer
++	O
;	O
while	O
(	O
(	O
' '	O
==	O
uri	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
size_t	long
)	O
(	O
uri	pointer
-	O
line	int
)	O
<	O
line_len	pointer
)	O
)	O
uri	pointer
++	O
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
uri	pointer
-	O
line	int
)	O
==	O
line_len	pointer
)	O
{	O
curi	pointer
=	O
""	pointer
;	O
uri	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
version	pointer
=	O
""	pointer
;	O
args	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
size_t	long
uri_len	long
;	O
curi	pointer
=	O
uri	pointer
;	O
http_version	pointer
=	O
line	int
+	O
line_len	pointer
-	O
1	int
;	O
while	O
(	O
(	O
' '	O
==	O
http_version	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
http_version	pointer
>	O
uri	pointer
)	O
)	O
http_version	pointer
--	O
;	O
while	O
(	O
(	O
' '	O
!=	O
http_version	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
http_version	pointer
>	O
uri	pointer
)	O
)	O
http_version	pointer
--	O
;	O
if	O
(	O
http_version	pointer
>	O
uri	pointer
)	O
{	O
http_version	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
connection	pointer
->	O
version	pointer
=	O
http_version	pointer
+	O
1	int
;	O
uri_len	long
=	O
http_version	pointer
-	O
uri	pointer
;	O
}	O
else	O
{	O
connection	pointer
->	O
version	pointer
=	O
""	pointer
;	O
uri_len	long
=	O
line_len	pointer
-	O
(	O
uri	pointer
-	O
line	int
)	O
;	O
}	O
if	O
(	O
(	O
1	int
<=	O
daemon	function
->	O
strict_for_client	int
)	O
&&	O
(	O
NULL	O
!=	O
memchr	function
(	O
uri	pointer
,	O
' '	O
,	O
uri_len	long
)	O
)	O
)	O
{	O
return	O
MHD_NO	int
;	O
}	O
args	pointer
=	O
memchr	function
(	O
uri	pointer
,	O
'?'	O
,	O
uri_len	long
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
uri_log_callback	pointer
)	O
{	O
connection	pointer
->	O
client_aware	bool
=	O
true	int
;	O
connection	pointer
->	O
client_context	pointer
=	O
daemon	function
->	O
uri_log_callback	pointer
(	O
daemon	function
->	O
uri_log_callback_cls	pointer
,	O
uri	pointer
,	O
connection	pointer
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
args	pointer
)	O
{	O
args	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
args	pointer
++	O
;	O
MHD_parse_arguments_	function
(	O
connection	pointer
,	O
MHD_GET_ARGUMENT_KIND	int
,	O
args	pointer
,	O
&	O
connection_add_header	function
,	O
&	O
unused_num_headers	int
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
uri	pointer
)	O
daemon	function
->	O
unescape_callback	pointer
(	O
daemon	function
->	O
unescape_callback_cls	pointer
,	O
connection	pointer
,	O
uri	pointer
)	O
;	O
connection	pointer
->	O
url	pointer
=	O
curi	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
call_connection_handler	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
size_t	long
processed	long
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
return	O
;	O
processed	long
=	O
0	int
;	O
connection	pointer
->	O
client_aware	bool
=	O
true	int
;	O
if	O
(	O
MHD_NO	int
==	O
daemon	function
->	O
default_handler	pointer
(	O
daemon	function
->	O
default_handler_cls	pointer
,	O
connection	pointer
,	O
connection	pointer
->	O
url	pointer
,	O
connection	pointer
->	O
method	pointer
,	O
connection	pointer
->	O
version	pointer
,	O
NULL	O
,	O
&	O
processed	long
,	O
&	O
connection	pointer
->	O
client_context	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Application reported internal error, closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
static	O
void	O
process_request_body	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
size_t	long
available	long
;	O
int	O
instant_retry	int
;	O
char	O
*	O
buffer_head	pointer
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
{	O
uint64_t	long
purge	long
=	O
MHD_MIN	O
(	O
connection	pointer
->	O
remaining_upload_size	long
,	O
connection	pointer
->	O
read_buffer_offset	long
)	O
;	O
connection	pointer
->	O
remaining_upload_size	long
-=	O
purge	long
;	O
if	O
(	O
connection	pointer
->	O
read_buffer_offset	long
>	O
purge	long
)	O
memmove	function
(	O
connection	pointer
->	O
read_buffer	pointer
,	O
&	O
connection	pointer
->	O
read_buffer	pointer
[	O
purge	long
]	O
,	O
connection	pointer
->	O
read_buffer_offset	long
-	O
purge	long
)	O
;	O
connection	pointer
->	O
read_buffer_offset	long
-=	O
purge	long
;	O
return	O
;	O
}	O
buffer_head	pointer
=	O
connection	pointer
->	O
read_buffer	pointer
;	O
available	long
=	O
connection	pointer
->	O
read_buffer_offset	long
;	O
do	O
{	O
size_t	long
to_be_processed	long
;	O
size_t	long
left_unprocessed	long
;	O
size_t	long
processed_size	long
;	O
instant_retry	int
=	O
MHD_NO	int
;	O
if	O
(	O
(	O
connection	pointer
->	O
have_chunked_upload	bool
)	O
&&	O
(	O
MHD_SIZE_UNKNOWN	O
==	O
connection	pointer
->	O
remaining_upload_size	long
)	O
)	O
{	O
if	O
(	O
(	O
connection	pointer
->	O
current_chunk_offset	long
==	O
connection	pointer
->	O
current_chunk_size	long
)	O
&&	O
(	O
0LLU	int
!=	O
connection	pointer
->	O
current_chunk_offset	long
)	O
&&	O
(	O
available	long
>=	O
2	int
)	O
)	O
{	O
size_t	long
i	long
;	O
i	long
=	O
0	int
;	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
)	O
i	long
++	O
;	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
)	O
i	long
++	O
;	O
if	O
(	O
0	int
==	O
i	long
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Received malformed HTTP request (bad chunked encoding). Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
available	long
-=	O
i	long
;	O
buffer_head	pointer
+=	O
i	long
;	O
connection	pointer
->	O
current_chunk_offset	long
=	O
0	int
;	O
connection	pointer
->	O
current_chunk_size	long
=	O
0	int
;	O
}	O
if	O
(	O
connection	pointer
->	O
current_chunk_offset	long
<	O
connection	pointer
->	O
current_chunk_size	long
)	O
{	O
uint64_t	long
cur_chunk_left	long
;	O
cur_chunk_left	long
=	O
connection	pointer
->	O
current_chunk_size	long
-	O
connection	pointer
->	O
current_chunk_offset	long
;	O
if	O
(	O
cur_chunk_left	long
>	O
available	long
)	O
to_be_processed	long
=	O
available	long
;	O
else	O
{	O
to_be_processed	long
=	O
(	O
size_t	long
)	O
cur_chunk_left	long
;	O
if	O
(	O
available	long
>	O
to_be_processed	long
)	O
instant_retry	int
=	O
MHD_YES	int
;	O
}	O
}	O
else	O
{	O
size_t	long
i	long
;	O
size_t	long
end_size	long
;	O
bool	bool
malformed	bool
;	O
i	long
=	O
0	int
;	O
while	O
(	O
i	long
<	O
available	long
)	O
{	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
||	O
(	O
';'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
)	O
break	O
;	O
i	long
++	O
;	O
if	O
(	O
i	long
>=	O
16	int
)	O
break	O
;	O
}	O
end_size	long
=	O
i	long
;	O
if	O
(	O
';'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
{	O
while	O
(	O
i	long
<	O
available	long
)	O
{	O
if	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
)	O
break	O
;	O
i	long
++	O
;	O
}	O
}	O
if	O
(	O
(	O
i	long
+	O
1	int
>=	O
available	long
)	O
&&	O
!	O
(	O
(	O
1	int
==	O
i	long
)	O
&&	O
(	O
2	int
==	O
available	long
)	O
&&	O
(	O
'0'	O
==	O
buffer_head	pointer
[	O
0	int
]	O
)	O
)	O
)	O
break	O
;	O
i	long
++	O
;	O
malformed	bool
=	O
(	O
end_size	long
>=	O
16	int
)	O
;	O
if	O
(	O
!	O
malformed	bool
)	O
{	O
size_t	long
num_dig	long
=	O
MHD_strx_to_uint64_n_	function
(	O
buffer_head	pointer
,	O
end_size	long
,	O
&	O
connection	pointer
->	O
current_chunk_size	long
)	O
;	O
malformed	bool
=	O
(	O
end_size	long
!=	O
num_dig	long
)	O
;	O
}	O
if	O
(	O
malformed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Received malformed HTTP request (bad chunked encoding). Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
i	long
<	O
available	long
)	O
&&	O
(	O
(	O
'\r'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
||	O
(	O
'\n'	O
==	O
buffer_head	pointer
[	O
i	long
]	O
)	O
)	O
)	O
i	long
++	O
;	O
buffer_head	pointer
+=	O
i	long
;	O
available	long
-=	O
i	long
;	O
connection	pointer
->	O
current_chunk_offset	long
=	O
0	int
;	O
if	O
(	O
available	long
>	O
0	int
)	O
instant_retry	int
=	O
MHD_YES	int
;	O
if	O
(	O
0LLU	int
==	O
connection	pointer
->	O
current_chunk_size	long
)	O
{	O
connection	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
break	O
;	O
}	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
0	int
!=	O
connection	pointer
->	O
remaining_upload_size	long
)	O
&&	O
(	O
MHD_SIZE_UNKNOWN	O
!=	O
connection	pointer
->	O
remaining_upload_size	long
)	O
&&	O
(	O
connection	pointer
->	O
remaining_upload_size	long
<	O
available	long
)	O
)	O
{	O
to_be_processed	long
=	O
(	O
size_t	long
)	O
connection	pointer
->	O
remaining_upload_size	long
;	O
}	O
else	O
{	O
to_be_processed	long
=	O
available	long
;	O
}	O
}	O
left_unprocessed	long
=	O
to_be_processed	long
;	O
connection	pointer
->	O
client_aware	bool
=	O
true	int
;	O
if	O
(	O
MHD_NO	int
==	O
daemon	function
->	O
default_handler	pointer
(	O
daemon	function
->	O
default_handler_cls	pointer
,	O
connection	pointer
,	O
connection	pointer
->	O
url	pointer
,	O
connection	pointer
->	O
method	pointer
,	O
connection	pointer
->	O
version	pointer
,	O
buffer_head	pointer
,	O
&	O
left_unprocessed	long
,	O
&	O
connection	pointer
->	O
client_context	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Application reported internal error, closing connection.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
left_unprocessed	long
>	O
to_be_processed	long
)	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
_	O
(	O
"libmicrohttpd API violation"	pointer
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
left_unprocessed	long
)	O
{	O
instant_retry	int
=	O
MHD_NO	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
&&	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
)	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"WARNING: incomplete upload processing and connection not suspended may result in hung connection.\n"	pointer
)	O
)	O
;	O
}	O
processed_size	long
=	O
to_be_processed	long
-	O
left_unprocessed	long
;	O
if	O
(	O
connection	pointer
->	O
have_chunked_upload	bool
)	O
connection	pointer
->	O
current_chunk_offset	long
+=	O
processed_size	long
;	O
buffer_head	pointer
+=	O
processed_size	long
;	O
available	long
-=	O
processed_size	long
;	O
if	O
(	O
MHD_SIZE_UNKNOWN	O
!=	O
connection	pointer
->	O
remaining_upload_size	long
)	O
connection	pointer
->	O
remaining_upload_size	long
-=	O
processed_size	long
;	O
}	O
while	O
(	O
MHD_YES	int
==	O
instant_retry	int
)	O
;	O
if	O
(	O
(	O
available	long
>	O
0	int
)	O
&&	O
(	O
buffer_head	pointer
!=	O
connection	pointer
->	O
read_buffer	pointer
)	O
)	O
memmove	function
(	O
connection	pointer
->	O
read_buffer	pointer
,	O
buffer_head	pointer
,	O
available	long
)	O
;	O
connection	pointer
->	O
read_buffer_offset	long
=	O
available	long
;	O
}	O
static	O
int	O
check_write_done	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_CONNECTION_STATE	enum
next_state	enum
)	O
{	O
if	O
(	O
connection	pointer
->	O
write_buffer_append_offset	long
!=	O
connection	pointer
->	O
write_buffer_send_offset	long
)	O
return	O
MHD_NO	int
;	O
connection	pointer
->	O
write_buffer_append_offset	long
=	O
0	int
;	O
connection	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
connection	pointer
->	O
state	pointer
=	O
next_state	enum
;	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
connection	pointer
->	O
write_buffer	pointer
,	O
connection	pointer
->	O
write_buffer_size	long
,	O
0	int
)	O
;	O
connection	pointer
->	O
write_buffer	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
write_buffer_size	long
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
process_header_line	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
char	O
*	O
line	int
)	O
{	O
char	O
*	O
colon	pointer
;	O
colon	pointer
=	O
strchr	function
(	O
line	int
,	O
':'	O
)	O
;	O
if	O
(	O
NULL	O
==	O
colon	pointer
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Received malformed line (no colon). Closing connection.\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
-	O
1	int
>=	O
connection	pointer
->	O
daemon	function
->	O
strict_for_client	int
)	O
{	O
const	O
char	O
*	O
white	pointer
;	O
white	pointer
=	O
strchr	function
(	O
line	int
,	O
' '	O
)	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
white	pointer
)	O
&&	O
(	O
white	pointer
<	O
colon	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
white	pointer
=	O
strchr	function
(	O
line	int
,	O
'\t'	O
)	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
white	pointer
)	O
&&	O
(	O
white	pointer
<	O
colon	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
}	O
colon	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
colon	pointer
++	O
;	O
while	O
(	O
(	O
'\0'	O
!=	O
colon	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
colon	pointer
[	O
0	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
colon	pointer
[	O
0	int
]	O
)	O
)	O
)	O
colon	pointer
++	O
;	O
connection	pointer
->	O
last	pointer
=	O
line	int
;	O
connection	pointer
->	O
colon	pointer
=	O
colon	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
process_broken_line	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
char	O
*	O
line	int
,	O
enum	O
MHD_ValueKind	enum
kind	enum
)	O
{	O
char	O
*	O
last	pointer
;	O
char	O
*	O
tmp	pointer
;	O
size_t	long
last_len	long
;	O
size_t	long
tmp_len	long
;	O
last	pointer
=	O
connection	pointer
->	O
last	pointer
;	O
if	O
(	O
(	O
' '	O
==	O
line	int
[	O
0	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
line	int
[	O
0	int
]	O
)	O
)	O
{	O
last_len	long
=	O
strlen	function
(	O
last	pointer
)	O
;	O
tmp	pointer
=	O
line	int
;	O
while	O
(	O
(	O
' '	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
)	O
tmp	pointer
++	O
;	O
tmp_len	long
=	O
strlen	function
(	O
tmp	pointer
)	O
;	O
last	pointer
=	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
last	pointer
,	O
last_len	long
+	O
1	int
,	O
last_len	long
+	O
tmp_len	long
+	O
1	int
)	O
;	O
if	O
(	O
NULL	O
==	O
last	pointer
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
memcpy	function
(	O
&	O
last	pointer
[	O
last_len	long
]	O
,	O
tmp	pointer
,	O
tmp_len	long
+	O
1	int
)	O
;	O
connection	pointer
->	O
last	pointer
=	O
last	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
mhd_assert	O
(	O
(	O
NULL	O
!=	O
last	pointer
)	O
&&	O
(	O
NULL	O
!=	O
connection	pointer
->	O
colon	pointer
)	O
)	O
;	O
if	O
(	O
MHD_NO	int
==	O
connection_add_header	function
(	O
connection	pointer
,	O
last	pointer
,	O
strlen	function
(	O
last	pointer
)	O
,	O
connection	pointer
->	O
colon	pointer
,	O
strlen	function
(	O
connection	pointer
->	O
colon	pointer
)	O
,	O
kind	enum
)	O
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE	int
,	O
REQUEST_TOO_BIG	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
0	int
!=	O
line	int
[	O
0	int
]	O
)	O
{	O
if	O
(	O
MHD_NO	int
==	O
process_header_line	function
(	O
connection	pointer
,	O
line	int
)	O
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
REQUEST_MALFORMED	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
parse_connection_headers	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
const	O
char	O
*	O
clen	pointer
;	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
const	O
char	O
*	O
enc	pointer
;	O
const	O
char	O
*	O
end	pointer
;	O
parse_cookie_header	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
(	O
1	int
<=	O
connection	pointer
->	O
daemon	function
->	O
strict_for_client	int
)	O
&&	O
(	O
NULL	O
!=	O
connection	pointer
->	O
version	pointer
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
MHD_HTTP_VERSION_1_1	pointer
,	O
connection	pointer
->	O
version	pointer
)	O
)	O
&&	O
(	O
MHD_NO	int
==	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_HOST	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_HOST	pointer
)	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
)	O
{	O
int	O
iret	int
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
;	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
_	O
(	O
"Received HTTP 1.1 request without `Host' header.\n"	pointer
)	O
)	O
;	O
mhd_assert	O
(	O
NULL	O
==	O
connection	pointer
->	O
response	pointer
)	O
;	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
MHD_STATICSTR_LEN_	O
(	O
REQUEST_LACKS_HOST	pointer
)	O
,	O
REQUEST_LACKS_HOST	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
if	O
(	O
NULL	O
==	O
response	pointer
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (failed to create response)\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
iret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
if	O
(	O
MHD_YES	int
!=	O
iret	int
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (failed to queue response)\n"	pointer
)	O
)	O
;	O
}	O
return	O
;	O
}	O
connection	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
if	O
(	O
MHD_NO	int
!=	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_TRANSFER_ENCODING	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_TRANSFER_ENCODING	pointer
)	O
,	O
&	O
enc	pointer
,	O
NULL	O
)	O
)	O
{	O
connection	pointer
->	O
remaining_upload_size	long
=	O
MHD_SIZE_UNKNOWN	O
;	O
if	O
(	O
MHD_str_equal_caseless_	function
(	O
enc	pointer
,	O
"chunked"	pointer
)	O
)	O
connection	pointer
->	O
have_chunked_upload	bool
=	O
true	int
;	O
}	O
else	O
{	O
if	O
(	O
MHD_NO	int
!=	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
)	O
,	O
&	O
clen	pointer
,	O
NULL	O
)	O
)	O
{	O
end	pointer
=	O
clen	pointer
+	O
MHD_str_to_uint64_	function
(	O
clen	pointer
,	O
&	O
connection	pointer
->	O
remaining_upload_size	long
)	O
;	O
if	O
(	O
(	O
clen	pointer
==	O
end	pointer
)	O
||	O
(	O
'\0'	O
!=	O
*	O
end	pointer
)	O
)	O
{	O
connection	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
"Failed to parse `Content-Length' header. Closing connection.\n"	pointer
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
void	O
MHD_update_last_activity_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
connection_timeout	int
)	O
return	O
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
return	O
;	O
connection	pointer
->	O
last_activity	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
return	O
;	O
if	O
(	O
connection	pointer
->	O
connection_timeout	int
!=	O
daemon	function
->	O
connection_timeout	int
)	O
return	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
XDLL_insert	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
void	O
MHD_connection_handle_read	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
ssize_t	long
bytes_read	long
;	O
if	O
(	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
||	O
(	O
connection	pointer
->	O
suspended	int
)	O
)	O
return	O
;	O
if	O
(	O
connection	pointer
->	O
read_buffer_offset	long
+	O
connection	pointer
->	O
daemon	function
->	O
pool_increment	long
>	O
connection	pointer
->	O
read_buffer_size	long
)	O
try_grow_read_buffer	function
(	O
connection	pointer
,	O
(	O
connection	pointer
->	O
read_buffer_size	long
==	O
connection	pointer
->	O
read_buffer_offset	long
)	O
)	O
;	O
if	O
(	O
connection	pointer
->	O
read_buffer_size	long
==	O
connection	pointer
->	O
read_buffer_offset	long
)	O
return	O
;	O
bytes_read	long
=	O
connection	pointer
->	O
recv_cls	pointer
(	O
connection	pointer
,	O
&	O
connection	pointer
->	O
read_buffer	pointer
[	O
connection	pointer
->	O
read_buffer_offset	long
]	O
,	O
connection	pointer
->	O
read_buffer_size	long
-	O
connection	pointer
->	O
read_buffer_offset	long
)	O
;	O
if	O
(	O
bytes_read	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
bytes_read	long
)	O
return	O
;	O
if	O
(	O
MHD_ERR_CONNRESET_	O
==	O
bytes_read	long
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
(	O
MHD_CONNECTION_INIT	int
==	O
connection	pointer
->	O
state	pointer
)	O
?	O
NULL	O
:	O
_	O
(	O
"Socket disconnected while reading request.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
(	O
MHD_CONNECTION_INIT	int
==	O
connection	pointer
->	O
state	pointer
)	O
?	O
NULL	O
:	O
_	O
(	O
"Connection socket is closed due to error when reading request.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
0	int
==	O
bytes_read	long
)	O
{	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_CLIENT_ABORT	int
)	O
;	O
return	O
;	O
}	O
connection	pointer
->	O
read_buffer_offset	long
+=	O
bytes_read	long
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
switch	O
(	O
connection	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_CONNECTION_INIT	int
:	O
case	O
MHD_CONNECTION_URL_RECEIVED	int
:	O
case	O
MHD_CONNECTION_HEADER_PART_RECEIVED	int
:	O
case	O
MHD_CONNECTION_HEADERS_RECEIVED	int
:	O
case	O
MHD_CONNECTION_HEADERS_PROCESSED	int
:	O
case	O
MHD_CONNECTION_CONTINUE_SENDING	int
:	O
case	O
MHD_CONNECTION_CONTINUE_SENT	int
:	O
case	O
MHD_CONNECTION_BODY_RECEIVED	int
:	O
case	O
MHD_CONNECTION_FOOTER_PART_RECEIVED	int
:	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_READ_ERROR	int
)	O
;	O
}	O
return	O
;	O
case	O
MHD_CONNECTION_CLOSED	int
:	O
return	O
;	O
case	O
MHD_CONNECTION_UPGRADE	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
default	O
:	O
MHD_pool_reallocate	function
(	O
connection	pointer
->	O
pool	pointer
,	O
connection	pointer
->	O
read_buffer	pointer
,	O
connection	pointer
->	O
read_buffer_size	long
+	O
1	int
,	O
connection	pointer
->	O
read_buffer_offset	long
)	O
;	O
break	O
;	O
}	O
return	O
;	O
}	O
void	O
MHD_connection_handle_write	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
ssize_t	long
ret	long
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
return	O
;	O
switch	O
(	O
connection	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_CONNECTION_INIT	int
:	O
case	O
MHD_CONNECTION_URL_RECEIVED	int
:	O
case	O
MHD_CONNECTION_HEADER_PART_RECEIVED	int
:	O
case	O
MHD_CONNECTION_HEADERS_RECEIVED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_HEADERS_PROCESSED	int
:	O
return	O
;	O
case	O
MHD_CONNECTION_CONTINUE_SENDING	int
:	O
ret	long
=	O
MHD_send_on_connection_	function
(	O
connection	pointer
,	O
&	O
HTTP_100_CONTINUE	pointer
[	O
connection	pointer
->	O
continue_message_write_offset	long
]	O
,	O
MHD_STATICSTR_LEN_	O
(	O
HTTP_100_CONTINUE	pointer
)	O
-	O
connection	pointer
->	O
continue_message_write_offset	long
,	O
MHD_SSO_NO_CORK	int
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
_	O
(	O
"Failed to send data in request for %s.\n"	pointer
)	O
,	O
connection	pointer
->	O
url	pointer
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
connection	pointer
->	O
continue_message_write_offset	long
+=	O
ret	long
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_CONTINUE_SENT	int
:	O
case	O
MHD_CONNECTION_BODY_RECEIVED	int
:	O
case	O
MHD_CONNECTION_FOOTER_PART_RECEIVED	int
:	O
case	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_HEADERS_SENDING	int
:	O
{	O
const	O
size_t	long
wb_ready	long
=	O
connection	pointer
->	O
write_buffer_append_offset	long
-	O
connection	pointer
->	O
write_buffer_send_offset	long
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
{	O
ret	long
=	O
MHD_send_on_connection_	function
(	O
connection	pointer
,	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
connection	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
wb_ready	long
,	O
MHD_SSO_MAY_CORK	int
)	O
;	O
}	O
else	O
{	O
ret	long
=	O
MHD_send_on_connection2_	function
(	O
connection	pointer
,	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
connection	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
wb_ready	long
,	O
connection	pointer
->	O
response	pointer
->	O
data	pointer
,	O
connection	pointer
->	O
response	pointer
->	O
data_buffer_size	long
)	O
;	O
}	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Connection was closed while sending response headers.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ret	long
>	O
wb_ready	long
)	O
{	O
mhd_assert	O
(	O
NULL	O
==	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
;	O
connection	pointer
->	O
write_buffer_send_offset	long
+=	O
wb_ready	long
;	O
ret	long
-=	O
wb_ready	long
;	O
connection	pointer
->	O
response_write_position	long
+=	O
ret	long
;	O
}	O
else	O
connection	pointer
->	O
write_buffer_send_offset	long
+=	O
ret	long
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_CONNECTION_HEADERS_SENDING	int
!=	O
connection	pointer
->	O
state	pointer
)	O
return	O
;	O
check_write_done	function
(	O
connection	pointer
,	O
MHD_CONNECTION_HEADERS_SENT	int
)	O
;	O
return	O
;	O
}	O
case	O
MHD_CONNECTION_HEADERS_SENT	int
:	O
return	O
;	O
case	O
MHD_CONNECTION_NORMAL_BODY_READY	int
:	O
response	pointer
=	O
connection	pointer
->	O
response	pointer
;	O
if	O
(	O
connection	pointer
->	O
response_write_position	long
<	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
)	O
{	O
uint64_t	long
data_write_offset	long
;	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_lock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
MHD_YES	int
!=	O
try_ready_normal_body	function
(	O
connection	pointer
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
MHD_resp_sender_sendfile	int
==	O
connection	pointer
->	O
resp_sender	enum
)	O
{	O
ret	long
=	O
MHD_send_sendfile_	function
(	O
connection	pointer
)	O
;	O
}	O
else	O
{	O
data_write_offset	long
=	O
connection	pointer
->	O
response_write_position	long
-	O
response	pointer
->	O
data_start	long
;	O
if	O
(	O
data_write_offset	long
>	O
(	O
uint64_t	long
)	O
SIZE_MAX	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Data offset exceeds limit"	pointer
)	O
)	O
;	O
ret	long
=	O
MHD_send_on_connection_	function
(	O
connection	pointer
,	O
&	O
response	pointer
->	O
data	pointer
[	O
(	O
size_t	long
)	O
data_write_offset	long
]	O
,	O
response	pointer
->	O
data_size	long
-	O
(	O
size_t	long
)	O
data_write_offset	long
,	O
MHD_SSO_NO_CORK	int
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
MHD_DLOG	function
(	O
connection	pointer
->	O
daemon	function
,	O
_	O
(	O
"Failed to send data in request for `%s'.\n"	pointer
)	O
,	O
connection	pointer
->	O
url	pointer
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
connection	pointer
->	O
response_write_position	long
+=	O
ret	long
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
}	O
if	O
(	O
connection	pointer
->	O
response_write_position	long
==	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
)	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_SENT	int
;	O
return	O
;	O
case	O
MHD_CONNECTION_NORMAL_BODY_UNREADY	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_CHUNKED_BODY_READY	int
:	O
ret	long
=	O
MHD_send_on_connection_	function
(	O
connection	pointer
,	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
connection	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
connection	pointer
->	O
write_buffer_append_offset	long
-	O
connection	pointer
->	O
write_buffer_send_offset	long
,	O
MHD_SSO_NO_CORK	int
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Connection was closed while sending response body.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
connection	pointer
->	O
write_buffer_send_offset	long
+=	O
ret	long
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_CONNECTION_CHUNKED_BODY_READY	int
!=	O
connection	pointer
->	O
state	pointer
)	O
return	O
;	O
check_write_done	function
(	O
connection	pointer
,	O
(	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
==	O
connection	pointer
->	O
response_write_position	long
)	O
?	O
MHD_CONNECTION_BODY_SENT	int
:	O
MHD_CONNECTION_CHUNKED_BODY_UNREADY	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_CHUNKED_BODY_UNREADY	int
:	O
case	O
MHD_CONNECTION_BODY_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_FOOTERS_SENDING	int
:	O
ret	long
=	O
MHD_send_on_connection_	function
(	O
connection	pointer
,	O
&	O
connection	pointer
->	O
write_buffer	pointer
[	O
connection	pointer
->	O
write_buffer_send_offset	long
]	O
,	O
connection	pointer
->	O
write_buffer_append_offset	long
-	O
connection	pointer
->	O
write_buffer_send_offset	long
,	O
MHD_SSO_HDR_CORK	int
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
MHD_ERR_AGAIN_	O
==	O
ret	long
)	O
return	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Connection was closed while sending response body.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
connection	pointer
->	O
write_buffer_send_offset	long
+=	O
ret	long
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_CONNECTION_FOOTERS_SENDING	int
!=	O
connection	pointer
->	O
state	pointer
)	O
return	O
;	O
check_write_done	function
(	O
connection	pointer
,	O
MHD_CONNECTION_FOOTERS_SENT	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_FOOTERS_SENT	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
case	O
MHD_CONNECTION_CLOSED	int
:	O
return	O
;	O
case	O
MHD_CONNECTION_UPGRADE	int
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
return	O
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Internal error\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
cleanup_connection	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
connection	pointer
->	O
in_cleanup	bool
)	O
return	O
;	O
connection	pointer
->	O
in_cleanup	bool
=	O
true	int
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
{	O
MHD_destroy_response	function
(	O
connection	pointer
->	O
response	pointer
)	O
;	O
connection	pointer
->	O
response	pointer
=	O
NULL	O
;	O
}	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
{	O
DLL_remove	O
(	O
daemon	function
->	O
suspended_connections_head	pointer
,	O
daemon	function
->	O
suspended_connections_tail	pointer
,	O
connection	pointer
)	O
;	O
connection	pointer
->	O
suspended	int
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
if	O
(	O
connection	pointer
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_timeout	int
)	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
else	O
XDLL_remove	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_remove	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_insert	O
(	O
daemon	function
->	O
cleanup_head	pointer
,	O
daemon	function
->	O
cleanup_tail	pointer
,	O
connection	pointer
)	O
;	O
connection	pointer
->	O
resuming	bool
=	O
false	int
;	O
connection	pointer
->	O
in_idle	bool
=	O
false	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"c"	pointer
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to signal end of connection via inter-thread communication channel"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
int	O
MHD_connection_handle_idle	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
char	O
*	O
line	int
;	O
size_t	long
line_len	pointer
;	O
int	O
ret	long
;	O
connection	pointer
->	O
in_idle	bool
=	O
true	int
;	O
while	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
{	O
switch	O
(	O
connection	pointer
->	O
state	pointer
)	O
{	O
case	O
MHD_CONNECTION_INIT	int
:	O
line	int
=	O
get_next_header_line	function
(	O
connection	pointer
,	O
&	O
line_len	pointer
)	O
;	O
if	O
(	O
(	O
NULL	O
==	O
line	int
)	O
||	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
)	O
{	O
if	O
(	O
MHD_CONNECTION_INIT	int
!=	O
connection	pointer
->	O
state	pointer
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
parse_initial_message_line	function
(	O
connection	pointer
,	O
line	int
,	O
line_len	pointer
)	O
)	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
else	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_URL_RECEIVED	int
;	O
continue	O
;	O
case	O
MHD_CONNECTION_URL_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
MHD_CONNECTION_URL_RECEIVED	int
!=	O
connection	pointer
->	O
state	pointer
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADERS_RECEIVED	int
;	O
connection	pointer
->	O
header_size	long
=	O
(	O
size_t	long
)	O
(	O
line	int
-	O
connection	pointer
->	O
read_buffer	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_header_line	function
(	O
connection	pointer
,	O
line	int
)	O
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
REQUEST_MALFORMED	pointer
)	O
;	O
break	O
;	O
}	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADER_PART_RECEIVED	int
;	O
continue	O
;	O
case	O
MHD_CONNECTION_HEADER_PART_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
connection	pointer
->	O
state	pointer
!=	O
MHD_CONNECTION_HEADER_PART_RECEIVED	int
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_broken_line	function
(	O
connection	pointer
,	O
line	int
,	O
MHD_HEADER_KIND	int
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADERS_RECEIVED	int
;	O
connection	pointer
->	O
header_size	long
=	O
(	O
size_t	long
)	O
(	O
line	int
-	O
connection	pointer
->	O
read_buffer	pointer
)	O
;	O
continue	O
;	O
}	O
continue	O
;	O
case	O
MHD_CONNECTION_HEADERS_RECEIVED	int
:	O
parse_connection_headers	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
continue	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADERS_PROCESSED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
break	O
;	O
continue	O
;	O
case	O
MHD_CONNECTION_HEADERS_PROCESSED	int
:	O
call_connection_handler	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
continue	O
;	O
if	O
(	O
(	O
NULL	O
==	O
connection	pointer
->	O
response	pointer
)	O
&&	O
(	O
need_100_continue	function
(	O
connection	pointer
)	O
)	O
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CONTINUE_SENDING	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
&&	O
(	O
0	int
!=	O
connection	pointer
->	O
remaining_upload_size	long
)	O
)	O
{	O
connection	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
}	O
connection	pointer
->	O
state	pointer
=	O
(	O
0	int
==	O
connection	pointer
->	O
remaining_upload_size	long
)	O
?	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
:	O
MHD_CONNECTION_CONTINUE_SENT	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
break	O
;	O
continue	O
;	O
case	O
MHD_CONNECTION_CONTINUE_SENDING	int
:	O
if	O
(	O
connection	pointer
->	O
continue_message_write_offset	long
==	O
MHD_STATICSTR_LEN_	O
(	O
HTTP_100_CONTINUE	pointer
)	O
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CONTINUE_SENT	int
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
MHD_CONNECTION_CONTINUE_SENT	int
:	O
if	O
(	O
0	int
!=	O
connection	pointer
->	O
read_buffer_offset	long
)	O
{	O
process_request_body	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
continue	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
connection	pointer
->	O
remaining_upload_size	long
)	O
||	O
(	O
(	O
MHD_SIZE_UNKNOWN	O
==	O
connection	pointer
->	O
remaining_upload_size	long
)	O
&&	O
(	O
0	int
==	O
connection	pointer
->	O
read_buffer_offset	long
)	O
&&	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
)	O
{	O
if	O
(	O
(	O
connection	pointer
->	O
have_chunked_upload	bool
)	O
&&	O
(	O
!	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_BODY_RECEIVED	int
;	O
else	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
break	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
MHD_CONNECTION_BODY_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
connection	pointer
->	O
state	pointer
!=	O
MHD_CONNECTION_BODY_RECEIVED	int
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_header_line	function
(	O
connection	pointer
,	O
line	int
)	O
)	O
{	O
transmit_error_response	function
(	O
connection	pointer
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
REQUEST_MALFORMED	pointer
)	O
;	O
break	O
;	O
}	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTER_PART_RECEIVED	int
;	O
continue	O
;	O
case	O
MHD_CONNECTION_FOOTER_PART_RECEIVED	int
:	O
line	int
=	O
get_next_header_line	function
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
line	int
)	O
{	O
if	O
(	O
connection	pointer
->	O
state	pointer
!=	O
MHD_CONNECTION_FOOTER_PART_RECEIVED	int
)	O
continue	O
;	O
if	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
process_broken_line	function
(	O
connection	pointer
,	O
line	int
,	O
MHD_FOOTER_KIND	int
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
==	O
line	int
[	O
0	int
]	O
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
;	O
if	O
(	O
connection	pointer
->	O
suspended	int
)	O
break	O
;	O
continue	O
;	O
}	O
continue	O
;	O
case	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
:	O
call_connection_handler	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
connection	pointer
->	O
state	pointer
==	O
MHD_CONNECTION_CLOSED	int
)	O
continue	O
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
->	O
response	pointer
)	O
break	O
;	O
if	O
(	O
MHD_NO	int
==	O
build_header_response	function
(	O
connection	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (failed to create response header)\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADERS_SENDING	int
;	O
break	O
;	O
case	O
MHD_CONNECTION_HEADERS_SENDING	int
:	O
break	O
;	O
case	O
MHD_CONNECTION_HEADERS_SENT	int
:	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
upgrade_handler	pointer
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_UPGRADE	int
;	O
if	O
(	O
MHD_YES	int
!=	O
MHD_response_execute_upgrade_	function
(	O
connection	pointer
->	O
response	pointer
,	O
connection	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
{	O
struct	O
MHD_Response	struct
*	O
const	O
resp	pointer
=	O
connection	pointer
->	O
response	pointer
;	O
connection	pointer
->	O
response	pointer
=	O
NULL	O
;	O
MHD_destroy_response	function
(	O
resp	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
connection	pointer
->	O
have_chunked_upload	bool
)	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CHUNKED_BODY_UNREADY	int
;	O
else	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_NORMAL_BODY_UNREADY	int
;	O
continue	O
;	O
case	O
MHD_CONNECTION_NORMAL_BODY_READY	int
:	O
break	O
;	O
case	O
MHD_CONNECTION_NORMAL_BODY_UNREADY	int
:	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_lock_chk_	O
(	O
&	O
connection	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
)	O
{	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
connection	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_BODY_SENT	int
;	O
continue	O
;	O
}	O
if	O
(	O
MHD_YES	int
==	O
try_ready_normal_body	function
(	O
connection	pointer
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
connection	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_NORMAL_BODY_READY	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
MHD_CONNECTION_CHUNKED_BODY_READY	int
:	O
break	O
;	O
case	O
MHD_CONNECTION_CHUNKED_BODY_UNREADY	int
:	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_lock_chk_	O
(	O
&	O
connection	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
(	O
0	int
==	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
)	O
||	O
(	O
connection	pointer
->	O
response_write_position	long
==	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
connection	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_BODY_SENT	int
;	O
continue	O
;	O
}	O
if	O
(	O
MHD_YES	int
==	O
try_ready_chunked_body	function
(	O
connection	pointer
)	O
)	O
{	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
->	O
crc	pointer
)	O
MHD_mutex_unlock_chk_	O
(	O
&	O
connection	pointer
->	O
response	pointer
->	O
mutex	union
)	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CHUNKED_BODY_READY	int
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
MHD_CONNECTION_BODY_SENT	int
:	O
if	O
(	O
MHD_NO	int
==	O
build_header_response	function
(	O
connection	pointer
)	O
)	O
{	O
CONNECTION_CLOSE_ERROR	O
(	O
connection	pointer
,	O
_	O
(	O
"Closing connection (failed to create response header)\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
!	O
connection	pointer
->	O
have_chunked_upload	bool
)	O
||	O
(	O
connection	pointer
->	O
write_buffer_send_offset	long
==	O
connection	pointer
->	O
write_buffer_append_offset	long
)	O
)	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_SENT	int
;	O
else	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_SENDING	int
;	O
continue	O
;	O
case	O
MHD_CONNECTION_FOOTERS_SENDING	int
:	O
break	O
;	O
case	O
MHD_CONNECTION_FOOTERS_SENT	int
:	O
if	O
(	O
MHD_HTTP_PROCESSING	int
==	O
connection	pointer
->	O
responseCode	int
)	O
{	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_HEADERS_PROCESSED	int
;	O
MHD_destroy_response	function
(	O
connection	pointer
->	O
response	pointer
)	O
;	O
connection	pointer
->	O
response	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
MHD_destroy_response	function
(	O
connection	pointer
->	O
response	pointer
)	O
;	O
connection	pointer
->	O
response	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_completed	pointer
)	O
&&	O
(	O
connection	pointer
->	O
client_aware	bool
)	O
)	O
{	O
daemon	function
->	O
notify_completed	pointer
(	O
daemon	function
->	O
notify_completed_cls	pointer
,	O
connection	pointer
,	O
&	O
connection	pointer
->	O
client_context	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
}	O
connection	pointer
->	O
client_aware	bool
=	O
false	int
;	O
if	O
(	O
(	O
MHD_CONN_USE_KEEPALIVE	int
!=	O
connection	pointer
->	O
keepalive	enum
)	O
||	O
(	O
connection	pointer
->	O
read_closed	bool
)	O
)	O
{	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
MHD_pool_destroy	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
connection	pointer
->	O
pool	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
read_buffer	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
read_buffer_size	long
=	O
0	int
;	O
connection	pointer
->	O
read_buffer_offset	long
=	O
0	int
;	O
}	O
else	O
{	O
connection	pointer
->	O
version	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_INIT	int
;	O
connection	pointer
->	O
last	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
colon	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
header_size	long
=	O
0	int
;	O
connection	pointer
->	O
keepalive	enum
=	O
MHD_CONN_KEEPALIVE_UNKOWN	int
;	O
connection	pointer
->	O
read_buffer	pointer
=	O
MHD_pool_reset	function
(	O
connection	pointer
->	O
pool	pointer
,	O
connection	pointer
->	O
read_buffer	pointer
,	O
connection	pointer
->	O
read_buffer_offset	long
,	O
connection	pointer
->	O
daemon	function
->	O
pool_size	long
/	O
2	int
)	O
;	O
connection	pointer
->	O
read_buffer_size	long
=	O
connection	pointer
->	O
daemon	function
->	O
pool_size	long
/	O
2	int
;	O
}	O
connection	pointer
->	O
client_context	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
continue_message_write_offset	long
=	O
0	int
;	O
connection	pointer
->	O
responseCode	int
=	O
0	int
;	O
connection	pointer
->	O
headers_received	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
headers_received_tail	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
response_write_position	long
=	O
0	int
;	O
connection	pointer
->	O
have_chunked_upload	bool
=	O
false	int
;	O
connection	pointer
->	O
current_chunk_size	long
=	O
0	int
;	O
connection	pointer
->	O
current_chunk_offset	long
=	O
0	int
;	O
connection	pointer
->	O
method	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
url	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
write_buffer	pointer
=	O
NULL	O
;	O
connection	pointer
->	O
write_buffer_size	long
=	O
0	int
;	O
connection	pointer
->	O
write_buffer_send_offset	long
=	O
0	int
;	O
connection	pointer
->	O
write_buffer_append_offset	long
=	O
0	int
;	O
continue	O
;	O
case	O
MHD_CONNECTION_CLOSED	int
:	O
cleanup_connection	function
(	O
connection	pointer
)	O
;	O
connection	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
MHD_NO	int
;	O
case	O
MHD_CONNECTION_UPGRADE	int
:	O
connection	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
MHD_YES	int
;	O
default	O
:	O
mhd_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
{	O
time_t	long
timeout	pointer
;	O
timeout	pointer
=	O
connection	pointer
->	O
connection_timeout	int
;	O
if	O
(	O
(	O
0	int
!=	O
timeout	pointer
)	O
&&	O
(	O
timeout	pointer
<	O
(	O
MHD_monotonic_sec_counter	function
(	O
)	O
-	O
connection	pointer
->	O
last_activity	long
)	O
)	O
)	O
{	O
MHD_connection_close_	function
(	O
connection	pointer
,	O
MHD_REQUEST_TERMINATED_TIMEOUT_REACHED	int
)	O
;	O
connection	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
MHD_YES	int
;	O
}	O
}	O
MHD_connection_update_event_loop_info	function
(	O
connection	pointer
)	O
;	O
ret	long
=	O
MHD_YES	int
;	O
if	O
(	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
&&	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
{	O
ret	long
=	O
MHD_connection_epoll_update_	function
(	O
connection	pointer
)	O
;	O
}	O
connection	pointer
->	O
in_idle	bool
=	O
false	int
;	O
return	O
ret	long
;	O
}	O
int	O
MHD_connection_epoll_update_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_SUSPENDED	int
)	O
)	O
&&	O
(	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
connection	pointer
->	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_WRITE_READY	int
)	O
)	O
)	O
||	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
connection	pointer
->	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_READ_READY	int
)	O
)	O
)	O
)	O
)	O
{	O
struct	O
epoll_event	struct
event	struct
;	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
|	O
EPOLLOUT	int
|	O
EPOLLPRI	int
|	O
EPOLLET	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
connection	pointer
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
connection	pointer
->	O
socket_fd	int
,	O
&	O
event	struct
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_ERROR_LOG	int
)	O
)	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_CLOSED	int
;	O
cleanup_connection	function
(	O
connection	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
void	O
MHD_set_http_callbacks_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
connection	pointer
->	O
recv_cls	pointer
=	O
&	O
recv_param_adapter	function
;	O
connection	pointer
->	O
send_cls	pointer
=	O
&	O
send_param_adapter	function
;	O
}	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
MHD_get_connection_info	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ConnectionInfoType	enum
info_type	enum
,	O
...	O
)	O
{	O
switch	O
(	O
info_type	enum
)	O
{	O
case	O
MHD_CONNECTION_INFO_CLIENT_ADDRESS	int
:	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
addr	pointer
;	O
case	O
MHD_CONNECTION_INFO_DAEMON	int
:	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
daemon	function
;	O
case	O
MHD_CONNECTION_INFO_CONNECTION_FD	int
:	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
socket_fd	int
;	O
case	O
MHD_CONNECTION_INFO_SOCKET_CONTEXT	int
:	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
socket_context	pointer
;	O
case	O
MHD_CONNECTION_INFO_CONNECTION_SUSPENDED	int
:	O
connection	pointer
->	O
suspended_dummy	int
=	O
connection	pointer
->	O
suspended	int
?	O
MHD_YES	int
:	O
MHD_NO	int
;	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
suspended_dummy	int
;	O
case	O
MHD_CONNECTION_INFO_CONNECTION_TIMEOUT	int
:	O
connection	pointer
->	O
connection_timeout_dummy	int
=	O
(	O
unsigned	O
int	O
)	O
connection	pointer
->	O
connection_timeout	int
;	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
connection_timeout_dummy	int
;	O
case	O
MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE	int
:	O
if	O
(	O
(	O
MHD_CONNECTION_HEADERS_RECEIVED	int
>	O
connection	pointer
->	O
state	pointer
)	O
||	O
(	O
MHD_CONNECTION_CLOSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
)	O
return	O
NULL	O
;	O
return	O
(	O
const	O
union	O
MHD_ConnectionInfo	union
*	O
)	O
&	O
connection	pointer
->	O
header_size	long
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
int	O
MHD_set_connection_option	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_CONNECTION_OPTION	enum
option	enum
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
;	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
switch	O
(	O
option	enum
)	O
{	O
case	O
MHD_CONNECTION_OPTION_TIMEOUT	int
:	O
if	O
(	O
0	int
==	O
connection	pointer
->	O
connection_timeout	int
)	O
connection	pointer
->	O
last_activity	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
)	O
{	O
if	O
(	O
connection	pointer
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_timeout	int
)	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
else	O
XDLL_remove	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
va_start	O
(	O
ap	array
,	O
option	enum
)	O
;	O
connection	pointer
->	O
connection_timeout	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
)	O
{	O
if	O
(	O
connection	pointer
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_timeout	int
)	O
XDLL_insert	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
else	O
XDLL_insert	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
return	O
MHD_YES	int
;	O
default	O
:	O
return	O
MHD_NO	int
;	O
}	O
}	O
int	O
MHD_queue_response	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
unsigned	O
int	O
status_code	int
,	O
struct	O
MHD_Response	struct
*	O
response	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
;	O
if	O
(	O
(	O
NULL	O
==	O
connection	pointer
)	O
||	O
(	O
NULL	O
==	O
response	pointer
)	O
||	O
(	O
NULL	O
!=	O
connection	pointer
->	O
response	pointer
)	O
||	O
(	O
(	O
MHD_CONNECTION_HEADERS_PROCESSED	int
!=	O
connection	pointer
->	O
state	pointer
)	O
&&	O
(	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
!=	O
connection	pointer
->	O
state	pointer
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
&&	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
&&	O
(	O
!	O
MHD_thread_ID_match_current_	O
(	O
connection	pointer
->	O
pid	int
.	O
ID	long
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Attempted to queue response on wrong thread!\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
response	pointer
->	O
upgrade_handler	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_ALLOW_UPGRADE	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Attempted 'upgrade' connection on daemon without MHD_ALLOW_UPGRADE option!\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
MHD_HTTP_SWITCHING_PROTOCOLS	int
!=	O
status_code	int
)	O
&&	O
(	O
NULL	O
!=	O
response	pointer
->	O
upgrade_handler	pointer
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Application used invalid status code for 'upgrade' response!\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
MHD_increment_response_rc	function
(	O
response	pointer
)	O
;	O
connection	pointer
->	O
response	pointer
=	O
response	pointer
;	O
connection	pointer
->	O
responseCode	int
=	O
status_code	int
;	O
if	O
(	O
(	O
response	pointer
->	O
fd	int
==	O
-	O
1	int
)	O
||	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
daemon	function
->	O
options	enum
&	O
MHD_USE_TLS	int
)	O
)	O
)	O
connection	pointer
->	O
resp_sender	enum
=	O
MHD_resp_sender_std	int
;	O
else	O
connection	pointer
->	O
resp_sender	enum
=	O
MHD_resp_sender_sendfile	int
;	O
if	O
(	O
(	O
(	O
NULL	O
!=	O
connection	pointer
->	O
method	pointer
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
connection	pointer
->	O
method	pointer
,	O
MHD_HTTP_METHOD_HEAD	pointer
)	O
)	O
)	O
||	O
(	O
MHD_HTTP_OK	int
>	O
status_code	int
)	O
||	O
(	O
MHD_HTTP_NO_CONTENT	int
==	O
status_code	int
)	O
||	O
(	O
MHD_HTTP_NOT_MODIFIED	int
==	O
status_code	int
)	O
)	O
{	O
connection	pointer
->	O
response_write_position	long
=	O
response	pointer
->	O
total_size	long
;	O
}	O
if	O
(	O
MHD_CONNECTION_HEADERS_PROCESSED	int
==	O
connection	pointer
->	O
state	pointer
)	O
{	O
connection	pointer
->	O
read_closed	bool
=	O
true	int
;	O
connection	pointer
->	O
state	pointer
=	O
MHD_CONNECTION_FOOTERS_RECEIVED	int
;	O
connection	pointer
->	O
remaining_upload_size	long
=	O
0	int
;	O
}	O
if	O
(	O
!	O
connection	pointer
->	O
in_idle	bool
)	O
(	O
void	O
)	O
MHD_connection_handle_idle	function
(	O
connection	pointer
)	O
;	O
MHD_update_last_activity_	function
(	O
connection	pointer
)	O
;	O
return	O
MHD_YES	int
;	O
}	O