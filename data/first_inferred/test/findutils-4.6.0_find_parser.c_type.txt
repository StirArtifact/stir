static	O
bool	bool
parse_accesscheck	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_amin	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_and	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_anewer	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_cmin	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_cnewer	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_comma	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_daystart	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_delete	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_d	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_depth	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_empty	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_exec	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_execdir	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_false	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_fls	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_fprintf	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_follow	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_fprint	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_fprint0	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_fstype	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_gid	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_group	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_help	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_ilname	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_iname	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_inum	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_ipath	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_iregex	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_iwholename	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_links	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_lname	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_ls	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_maxdepth	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_mindepth	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_mmin	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_name	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_negate	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_newer	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_newerXY	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_noleaf	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_nogroup	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_nouser	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_nowarn	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_ok	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_okdir	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_or	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_path	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_perm	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_print0	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_printf	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_prune	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_regex	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_regextype	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_samefile	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_size	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_time	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_true	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_type	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_uid	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_used	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_user	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_version	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_wholename	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_xdev	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_ignore_race	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_noignore_race	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_warn	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_xtype	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_quit	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
parse_context	function
(	O
const	O
struct	O
parser_table	struct
*	O
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
insert_type	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
PRED_FUNC	pointer
which_pred	pointer
)	O
;	O
static	O
bool	bool
insert_regex	function
(	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
int	O
regex_options	int
)	O
;	O
static	O
bool	bool
insert_exec_ok	function
(	O
const	O
char	O
*	O
action	int
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
bool	bool
get_comp_type	function
(	O
const	O
char	O
*	O
*	O
str	pointer
,	O
enum	O
comparison_type	enum
*	O
comp_type	pointer
)	O
;	O
static	O
bool	bool
get_relative_timestamp	function
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
time_val	struct
*	O
tval	pointer
,	O
struct	O
timespec	struct
origin	struct
,	O
double	O
sec_per_unit	double
,	O
const	O
char	O
*	O
overflowmessage	pointer
)	O
;	O
static	O
bool	bool
get_num	function
(	O
const	O
char	O
*	O
str	pointer
,	O
uintmax_t	long
*	O
num	pointer
,	O
enum	O
comparison_type	enum
*	O
comp_type	pointer
)	O
;	O
static	O
struct	O
predicate	struct
*	O
insert_num	function
(	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
)	O
;	O
static	O
void	O
open_output_file	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
format_val	struct
*	O
p	pointer
)	O
;	O
static	O
void	O
open_stdout	function
(	O
struct	O
format_val	struct
*	O
p	pointer
)	O
;	O
static	O
bool	bool
stream_is_tty	function
(	O
FILE	struct
*	O
fp	pointer
)	O
;	O
static	O
bool	bool
parse_noop	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
;	O
static	O
struct	O
parser_table	struct
const	O
parse_entry_newerXY	struct
=	O
{	O
ARG_SPECIAL_PARSE	int
,	O
"newerXY"	pointer
,	O
parse_newerXY	function
,	O
pred_newerXY	function
}	O
;	O
static	O
struct	O
parser_table	struct
const	O
parse_table	array
[	O
]	O
=	O
{	O
PARSE_PUNCTUATION	O
(	O
"!"	pointer
,	O
negate	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
"not"	pointer
,	O
negate	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
"("	pointer
,	O
openparen	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
")"	pointer
,	O
closeparen	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
","	pointer
,	O
comma	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
"a"	pointer
,	O
and	O
)	O
,	O
PARSE_TEST	O
(	O
"amin"	pointer
,	O
amin	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
"and"	pointer
,	O
and	O
)	O
,	O
PARSE_TEST	O
(	O
"anewer"	pointer
,	O
anewer	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"atime"	pointer
,	O
parse_time	function
,	O
pred_atime	function
}	O
,	O
PARSE_TEST	O
(	O
"cmin"	pointer
,	O
cmin	O
)	O
,	O
PARSE_TEST	O
(	O
"cnewer"	pointer
,	O
cnewer	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"ctime"	pointer
,	O
parse_time	function
,	O
pred_ctime	function
}	O
,	O
PARSE_TEST	O
(	O
"context"	pointer
,	O
context	pointer
)	O
,	O
PARSE_POSOPT	O
(	O
"daystart"	pointer
,	O
daystart	O
)	O
,	O
PARSE_ACTION	O
(	O
"delete"	pointer
,	O
delete	O
)	O
,	O
PARSE_OPTION	O
(	O
"d"	pointer
,	O
d	O
)	O
,	O
PARSE_OPTION	O
(	O
"depth"	pointer
,	O
depth	O
)	O
,	O
PARSE_TEST	O
(	O
"empty"	pointer
,	O
empty	O
)	O
,	O
{	O
ARG_ACTION	int
,	O
"exec"	pointer
,	O
parse_exec	function
,	O
pred_exec	function
}	O
,	O
{	O
ARG_TEST	int
,	O
"executable"	pointer
,	O
parse_accesscheck	function
,	O
pred_executable	function
}	O
,	O
PARSE_ACTION	O
(	O
"execdir"	pointer
,	O
execdir	O
)	O
,	O
PARSE_ACTION	O
(	O
"fls"	pointer
,	O
fls	O
)	O
,	O
PARSE_POSOPT	O
(	O
"follow"	pointer
,	O
follow	O
)	O
,	O
PARSE_ACTION	O
(	O
"fprint"	pointer
,	O
fprint	O
)	O
,	O
PARSE_ACTION	O
(	O
"fprint0"	pointer
,	O
fprint0	O
)	O
,	O
{	O
ARG_ACTION	int
,	O
"fprintf"	pointer
,	O
parse_fprintf	function
,	O
pred_fprintf	function
}	O
,	O
PARSE_TEST	O
(	O
"fstype"	pointer
,	O
fstype	pointer
)	O
,	O
PARSE_TEST	O
(	O
"gid"	pointer
,	O
gid	int
)	O
,	O
PARSE_TEST	O
(	O
"group"	pointer
,	O
group	struct
)	O
,	O
PARSE_OPTION	O
(	O
"ignore_readdir_race"	pointer
,	O
ignore_race	O
)	O
,	O
PARSE_TEST	O
(	O
"ilname"	pointer
,	O
ilname	O
)	O
,	O
PARSE_TEST	O
(	O
"iname"	pointer
,	O
iname	O
)	O
,	O
PARSE_TEST	O
(	O
"inum"	pointer
,	O
inum	O
)	O
,	O
PARSE_TEST	O
(	O
"ipath"	pointer
,	O
ipath	O
)	O
,	O
PARSE_TEST_NP	O
(	O
"iregex"	pointer
,	O
iregex	O
)	O
,	O
PARSE_TEST_NP	O
(	O
"iwholename"	pointer
,	O
iwholename	O
)	O
,	O
PARSE_TEST	O
(	O
"links"	pointer
,	O
links	O
)	O
,	O
PARSE_TEST	O
(	O
"lname"	pointer
,	O
lname	O
)	O
,	O
PARSE_ACTION	O
(	O
"ls"	pointer
,	O
ls	O
)	O
,	O
PARSE_OPTION	O
(	O
"maxdepth"	pointer
,	O
maxdepth	int
)	O
,	O
PARSE_OPTION	O
(	O
"mindepth"	pointer
,	O
mindepth	int
)	O
,	O
PARSE_TEST	O
(	O
"mmin"	pointer
,	O
mmin	O
)	O
,	O
PARSE_OPTION	O
(	O
"mount"	pointer
,	O
xdev	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"mtime"	pointer
,	O
parse_time	function
,	O
pred_mtime	function
}	O
,	O
PARSE_TEST	O
(	O
"name"	pointer
,	O
name	pointer
)	O
,	O
PARSE_TEST	O
(	O
"newer"	pointer
,	O
newer	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"atime"	pointer
,	O
parse_time	function
,	O
pred_atime	function
}	O
,	O
PARSE_OPTION	O
(	O
"noleaf"	pointer
,	O
noleaf	O
)	O
,	O
PARSE_TEST	O
(	O
"nogroup"	pointer
,	O
nogroup	O
)	O
,	O
PARSE_TEST	O
(	O
"nouser"	pointer
,	O
nouser	O
)	O
,	O
PARSE_OPTION	O
(	O
"noignore_readdir_race"	pointer
,	O
noignore_race	O
)	O
,	O
PARSE_POSOPT	O
(	O
"nowarn"	pointer
,	O
nowarn	O
)	O
,	O
PARSE_POSOPT	O
(	O
"warn"	pointer
,	O
warn	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
"o"	pointer
,	O
or	O
)	O
,	O
PARSE_PUNCTUATION	O
(	O
"or"	pointer
,	O
or	O
)	O
,	O
PARSE_ACTION	O
(	O
"ok"	pointer
,	O
ok	O
)	O
,	O
PARSE_ACTION	O
(	O
"okdir"	pointer
,	O
okdir	O
)	O
,	O
PARSE_TEST	O
(	O
"path"	pointer
,	O
path	pointer
)	O
,	O
PARSE_TEST	O
(	O
"perm"	pointer
,	O
perm	int
)	O
,	O
PARSE_ACTION	O
(	O
"print"	pointer
,	O
print	O
)	O
,	O
PARSE_ACTION	O
(	O
"print0"	pointer
,	O
print0	O
)	O
,	O
{	O
ARG_ACTION	int
,	O
"printf"	pointer
,	O
parse_printf	function
,	O
NULL	O
}	O
,	O
PARSE_ACTION	O
(	O
"prune"	pointer
,	O
prune	O
)	O
,	O
PARSE_ACTION	O
(	O
"quit"	pointer
,	O
quit	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"readable"	pointer
,	O
parse_accesscheck	function
,	O
pred_readable	function
}	O
,	O
PARSE_TEST	O
(	O
"regex"	pointer
,	O
regex	pointer
)	O
,	O
PARSE_POSOPT	O
(	O
"regextype"	pointer
,	O
regextype	O
)	O
,	O
PARSE_TEST	O
(	O
"samefile"	pointer
,	O
samefile	O
)	O
,	O
PARSE_TEST	O
(	O
"size"	pointer
,	O
size	pointer
)	O
,	O
PARSE_TEST	O
(	O
"type"	pointer
,	O
type	enum
)	O
,	O
PARSE_TEST	O
(	O
"uid"	pointer
,	O
uid	int
)	O
,	O
PARSE_TEST	O
(	O
"used"	pointer
,	O
used	long
)	O
,	O
PARSE_TEST	O
(	O
"user"	pointer
,	O
user	O
)	O
,	O
PARSE_TEST_NP	O
(	O
"wholename"	pointer
,	O
wholename	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"writable"	pointer
,	O
parse_accesscheck	function
,	O
pred_writable	function
}	O
,	O
PARSE_OPTION	O
(	O
"xdev"	pointer
,	O
xdev	O
)	O
,	O
PARSE_TEST	O
(	O
"xtype"	pointer
,	O
xtype	O
)	O
,	O
{	O
ARG_TEST	int
,	O
"false"	pointer
,	O
parse_false	function
,	O
pred_false	function
}	O
,	O
{	O
ARG_TEST	int
,	O
"true"	pointer
,	O
parse_true	function
,	O
pred_true	function
}	O
,	O
{	O
ARG_NOOP	int
,	O
"noop"	pointer
,	O
NULL	O
,	O
pred_true	function
}	O
,	O
{	O
ARG_TEST	int
,	O
"help"	pointer
,	O
parse_help	function
,	O
NULL	O
}	O
,	O
{	O
ARG_TEST	int
,	O
"-help"	pointer
,	O
parse_help	function
,	O
NULL	O
}	O
,	O
{	O
ARG_TEST	int
,	O
"version"	pointer
,	O
parse_version	function
,	O
NULL	O
}	O
,	O
{	O
ARG_TEST	int
,	O
"-version"	pointer
,	O
parse_version	function
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
*	O
first_nonoption_arg	pointer
=	O
NULL	O
;	O
static	O
const	O
struct	O
parser_table	struct
*	O
noop	pointer
=	O
NULL	O
;	O
static	O
int	O
fallback_getfilecon	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
name	pointer
,	O
security_context_t	pointer
*	O
p	pointer
,	O
int	O
prev_rv	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
ENOENT	int
:	O
case	O
ENOTDIR	int
:	O
return	O
lgetfileconat	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
)	O
;	O
case	O
EACCES	int
:	O
case	O
EIO	int
:	O
case	O
ELOOP	int
:	O
case	O
ENAMETOOLONG	int
:	O
case	O
EOVERFLOW	int
:	O
default	O
:	O
return	O
prev_rv	int
;	O
}	O
}	O
static	O
int	O
optionh_getfilecon	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
name	pointer
,	O
security_context_t	pointer
*	O
p	pointer
)	O
{	O
int	O
rv	int
;	O
if	O
(	O
0	int
==	O
state	pointer
.	O
curdepth	int
)	O
{	O
rv	int
=	O
getfileconat	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
0	int
==	O
rv	int
)	O
return	O
0	int
;	O
else	O
return	O
fallback_getfilecon	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
,	O
rv	int
)	O
;	O
}	O
else	O
{	O
return	O
lgetfileconat	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
static	O
int	O
optionl_getfilecon	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
name	pointer
,	O
security_context_t	pointer
*	O
p	pointer
)	O
{	O
int	O
rv	int
=	O
getfileconat	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
0	int
==	O
rv	int
)	O
return	O
0	int
;	O
else	O
return	O
fallback_getfilecon	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
,	O
rv	int
)	O
;	O
}	O
static	O
int	O
optionp_getfilecon	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
name	pointer
,	O
security_context_t	pointer
*	O
p	pointer
)	O
{	O
return	O
lgetfileconat	function
(	O
fd	int
,	O
name	pointer
,	O
p	pointer
)	O
;	O
}	O
void	O
check_option_combinations	function
(	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
enum	O
{	O
seen_delete	int
=	O
1u	int
,	O
seen_prune	int
=	O
2u	int
}	O
;	O
unsigned	O
int	O
predicates	pointer
=	O
0u	int
;	O
while	O
(	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
pred_func	pointer
==	O
pred_delete	function
)	O
predicates	pointer
|=	O
seen_delete	int
;	O
else	O
if	O
(	O
p	pointer
->	O
pred_func	pointer
==	O
pred_prune	function
)	O
predicates	pointer
|=	O
seen_prune	int
;	O
p	pointer
=	O
p	pointer
->	O
pred_next	pointer
;	O
}	O
if	O
(	O
(	O
predicates	pointer
&	O
seen_prune	int
)	O
&&	O
(	O
predicates	pointer
&	O
seen_delete	int
)	O
)	O
{	O
if	O
(	O
!	O
options	struct
.	O
explicit_depth	bool
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The -delete action automatically turns on -depth, "	pointer
"but -prune does nothing when -depth is in effect.  "	pointer
"If you want to carry on anyway, just explicitly use "	pointer
"the -depth option."	pointer
)	O
)	O
;	O
}	O
}	O
}	O
static	O
const	O
struct	O
parser_table	struct
*	O
get_noop	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
NULL	O
==	O
noop	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
parse_table	array
[	O
i	int
]	O
.	O
parser_name	pointer
!=	O
0	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ARG_NOOP	int
==	O
parse_table	array
[	O
i	int
]	O
.	O
type	enum
)	O
{	O
noop	pointer
=	O
&	O
(	O
parse_table	array
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
noop	pointer
;	O
}	O
static	O
int	O
get_stat_Ytime	function
(	O
const	O
struct	O
stat	struct
*	O
p	pointer
,	O
char	O
what	char
,	O
struct	O
timespec	struct
*	O
ret	pointer
)	O
{	O
switch	O
(	O
what	char
)	O
{	O
case	O
'a'	O
:	O
*	O
ret	pointer
=	O
get_stat_atime	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
case	O
'B'	O
:	O
*	O
ret	pointer
=	O
get_stat_birthtime	function
(	O
p	pointer
)	O
;	O
return	O
(	O
ret	pointer
->	O
tv_nsec	long
>=	O
0	int
)	O
;	O
case	O
'c'	O
:	O
*	O
ret	pointer
=	O
get_stat_ctime	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
case	O
'm'	O
:	O
*	O
ret	pointer
=	O
get_stat_mtime	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
void	O
set_follow_state	function
(	O
enum	O
SymlinkOption	enum
opt	enum
)	O
{	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugStat	int
)	O
{	O
options	struct
.	O
xstat	pointer
=	O
debug_stat	function
;	O
}	O
else	O
{	O
switch	O
(	O
opt	enum
)	O
{	O
case	O
SYMLINK_ALWAYS_DEREF	int
:	O
options	struct
.	O
xstat	pointer
=	O
optionl_stat	function
;	O
options	struct
.	O
x_getfilecon	pointer
=	O
optionl_getfilecon	function
;	O
options	struct
.	O
no_leaf_check	bool
=	O
true	int
;	O
break	O
;	O
case	O
SYMLINK_NEVER_DEREF	int
:	O
options	struct
.	O
xstat	pointer
=	O
optionp_stat	function
;	O
options	struct
.	O
x_getfilecon	pointer
=	O
optionp_getfilecon	function
;	O
break	O
;	O
case	O
SYMLINK_DEREF_ARGSONLY	int
:	O
options	struct
.	O
xstat	pointer
=	O
optionh_stat	function
;	O
options	struct
.	O
x_getfilecon	pointer
=	O
optionh_getfilecon	function
;	O
options	struct
.	O
no_leaf_check	bool
=	O
true	int
;	O
}	O
}	O
options	struct
.	O
symlink_handling	enum
=	O
opt	enum
;	O
}	O
void	O
parse_begin_user_args	function
(	O
char	O
*	O
*	O
args	union
,	O
int	O
argno	int
,	O
const	O
struct	O
predicate	struct
*	O
last	pointer
,	O
const	O
struct	O
predicate	struct
*	O
predicates	pointer
)	O
{	O
(	O
void	O
)	O
args	union
;	O
(	O
void	O
)	O
argno	int
;	O
(	O
void	O
)	O
last	pointer
;	O
(	O
void	O
)	O
predicates	pointer
;	O
first_nonoption_arg	pointer
=	O
NULL	O
;	O
}	O
void	O
parse_end_user_args	function
(	O
char	O
*	O
*	O
args	union
,	O
int	O
argno	int
,	O
const	O
struct	O
predicate	struct
*	O
last	pointer
,	O
const	O
struct	O
predicate	struct
*	O
predicates	pointer
)	O
{	O
(	O
void	O
)	O
args	union
;	O
(	O
void	O
)	O
argno	int
;	O
(	O
void	O
)	O
last	pointer
;	O
(	O
void	O
)	O
predicates	pointer
;	O
}	O
static	O
bool	bool
should_issue_warnings	function
(	O
void	O
)	O
{	O
if	O
(	O
options	struct
.	O
posixly_correct	bool
)	O
return	O
false	int
;	O
else	O
return	O
options	struct
.	O
warnings	bool
;	O
}	O
static	O
const	O
struct	O
parser_table	struct
*	O
found_parser	function
(	O
const	O
char	O
*	O
original_arg	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
type	enum
!=	O
ARG_POSITIONAL_OPTION	int
)	O
{	O
if	O
(	O
entry	pointer
->	O
type	enum
==	O
ARG_OPTION	int
)	O
{	O
if	O
(	O
(	O
first_nonoption_arg	pointer
!=	O
NULL	O
)	O
&&	O
should_issue_warnings	function
(	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: you have specified the %s "	pointer
"option after a non-option argument %s, "	pointer
"but options are not positional (%s affects "	pointer
"tests specified before it as well as those "	pointer
"specified after it).  Please specify options "	pointer
"before other arguments.\n"	pointer
)	O
,	O
original_arg	pointer
,	O
first_nonoption_arg	pointer
,	O
original_arg	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
first_nonoption_arg	pointer
==	O
NULL	O
)	O
{	O
first_nonoption_arg	pointer
=	O
original_arg	pointer
;	O
}	O
}	O
}	O
return	O
entry	pointer
;	O
}	O
const	O
struct	O
parser_table	struct
*	O
find_parser	function
(	O
const	O
char	O
*	O
search_name	pointer
)	O
{	O
int	O
i	int
;	O
const	O
char	O
*	O
original_arg	pointer
=	O
search_name	pointer
;	O
if	O
(	O
0	int
==	O
strncmp	function
(	O
"-newer"	pointer
,	O
search_name	pointer
,	O
6	int
)	O
&&	O
(	O
8	int
==	O
strlen	function
(	O
search_name	pointer
)	O
)	O
)	O
{	O
return	O
found_parser	function
(	O
original_arg	pointer
,	O
&	O
parse_entry_newerXY	struct
)	O
;	O
}	O
if	O
(	O
*	O
search_name	pointer
==	O
'-'	O
)	O
search_name	pointer
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
parse_table	array
[	O
i	int
]	O
.	O
parser_name	pointer
!=	O
0	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
parse_table	array
[	O
i	int
]	O
.	O
parser_name	pointer
,	O
search_name	pointer
)	O
==	O
0	int
)	O
{	O
return	O
found_parser	function
(	O
original_arg	pointer
,	O
&	O
parse_table	array
[	O
i	int
]	O
)	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
float	O
estimate_file_age_success_rate	function
(	O
float	O
num_days	float
)	O
{	O
if	O
(	O
num_days	float
<	O
0.1	int
)	O
{	O
return	O
0.01f	int
;	O
}	O
else	O
if	O
(	O
num_days	float
<	O
1	int
)	O
{	O
return	O
0.3f	int
;	O
}	O
else	O
if	O
(	O
num_days	float
>	O
100	int
)	O
{	O
return	O
0.3f	int
;	O
}	O
else	O
{	O
return	O
0.39f	int
;	O
}	O
}	O
static	O
float	O
estimate_timestamp_success_rate	function
(	O
time_t	long
when	long
)	O
{	O
int	O
num_days	float
=	O
(	O
options	struct
.	O
cur_day_start	struct
.	O
tv_sec	long
-	O
when	long
)	O
/	O
86400	int
;	O
return	O
estimate_file_age_success_rate	function
(	O
num_days	float
)	O
;	O
}	O
static	O
bool	bool
collect_arg_nonconst	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
char	O
*	O
*	O
collected_arg	pointer
)	O
{	O
if	O
(	O
(	O
argv	array
==	O
NULL	O
)	O
||	O
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
==	O
NULL	O
)	O
)	O
{	O
*	O
collected_arg	pointer
=	O
NULL	O
;	O
return	O
false	int
;	O
}	O
else	O
{	O
*	O
collected_arg	pointer
=	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
;	O
(	O
*	O
arg_ptr	pointer
)	O
++	O
;	O
return	O
true	int
;	O
}	O
}	O
static	O
bool	bool
collect_arg	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
char	O
*	O
*	O
collected_arg	pointer
)	O
{	O
char	O
*	O
arg	pointer
;	O
const	O
bool	bool
result	pointer
=	O
collect_arg_nonconst	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
arg	pointer
)	O
;	O
*	O
collected_arg	pointer
=	O
arg	pointer
;	O
return	O
result	pointer
;	O
}	O
static	O
bool	bool
collect_arg_stat_info	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
,	O
const	O
char	O
*	O
*	O
argument	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
filename	pointer
)	O
)	O
{	O
*	O
argument	pointer
=	O
filename	pointer
;	O
if	O
(	O
0	int
==	O
(	O
options	struct
.	O
xstat	pointer
)	O
(	O
filename	pointer
,	O
p	pointer
)	O
)	O
{	O
return	O
true	int
;	O
}	O
else	O
{	O
fatal_target_file_error	function
(	O
errno	O
,	O
filename	pointer
)	O
;	O
}	O
}	O
else	O
{	O
*	O
argument	pointer
=	O
NULL	O
;	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_and	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
get_new_pred_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
pred_func	pointer
=	O
pred_and	function
;	O
our_pred	pointer
->	O
p_type	enum
=	O
BI_OP	int
;	O
our_pred	pointer
->	O
p_prec	enum
=	O
AND_PREC	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_anewer	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
stat	struct
stat_newer	struct
;	O
const	O
char	O
*	O
arg	pointer
;	O
set_stat_placeholders	function
(	O
&	O
stat_newer	struct
)	O
;	O
if	O
(	O
collect_arg_stat_info	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
stat_newer	struct
,	O
&	O
arg	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
arg	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_ATIME	int
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
=	O
get_stat_mtime	function
(	O
&	O
stat_newer	struct
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
kind	enum
=	O
COMP_GT	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_timestamp_success_rate	function
(	O
stat_newer	struct
.	O
st_mtime	O
)	O
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
bool	bool
parse_closeparen	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
get_new_pred_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
pred_func	pointer
=	O
pred_closeparen	function
;	O
our_pred	pointer
->	O
p_type	enum
=	O
CLOSE_PAREN	int
;	O
our_pred	pointer
->	O
p_prec	enum
=	O
NO_PREC	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_cnewer	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
stat	struct
stat_newer	struct
;	O
const	O
char	O
*	O
arg	pointer
;	O
set_stat_placeholders	function
(	O
&	O
stat_newer	struct
)	O
;	O
if	O
(	O
collect_arg_stat_info	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
stat_newer	struct
,	O
&	O
arg	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
arg	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_CTIME	int
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
=	O
get_stat_mtime	function
(	O
&	O
stat_newer	struct
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
kind	enum
=	O
COMP_GT	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_timestamp_success_rate	function
(	O
stat_newer	struct
.	O
st_mtime	O
)	O
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_comma	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
get_new_pred_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
pred_func	pointer
=	O
pred_comma	function
;	O
our_pred	pointer
->	O
p_type	enum
=	O
BI_OP	int
;	O
our_pred	pointer
->	O
p_prec	enum
=	O
COMMA_PREC	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_daystart	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
tm	struct
*	O
local	pointer
;	O
(	O
void	O
)	O
entry	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
if	O
(	O
options	struct
.	O
full_days	bool
==	O
false	int
)	O
{	O
options	struct
.	O
cur_day_start	struct
.	O
tv_sec	long
+=	O
DAYSECS	int
;	O
options	struct
.	O
cur_day_start	struct
.	O
tv_nsec	long
=	O
0	int
;	O
local	pointer
=	O
localtime	function
(	O
&	O
options	struct
.	O
cur_day_start	struct
.	O
tv_sec	long
)	O
;	O
options	struct
.	O
cur_day_start	struct
.	O
tv_sec	long
-=	O
(	O
local	pointer
?	O
(	O
local	pointer
->	O
tm_sec	int
+	O
local	pointer
->	O
tm_min	int
*	O
60	int
+	O
local	pointer
->	O
tm_hour	int
*	O
3600	int
)	O
:	O
options	struct
.	O
cur_day_start	struct
.	O
tv_sec	long
%	O
DAYSECS	int
)	O
;	O
options	struct
.	O
full_days	bool
=	O
true	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_delete	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
options	struct
.	O
do_dir_first	bool
=	O
false	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_depth	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
entry	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
options	struct
.	O
do_dir_first	bool
=	O
false	int
;	O
options	struct
.	O
explicit_depth	bool
=	O
true	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_d	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
if	O
(	O
should_issue_warnings	function
(	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: the -d option is deprecated; please use "	pointer
"-depth instead, because the latter is a "	pointer
"POSIX-compliant feature."	pointer
)	O
)	O
;	O
}	O
return	O
parse_depth	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_empty	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.01f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_exec	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_exec_ok	function
(	O
"-exec"	pointer
,	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_execdir	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_exec_ok	function
(	O
"-execdir"	pointer
,	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
insert_false	function
(	O
void	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
const	O
struct	O
parser_table	struct
*	O
entry_false	pointer
;	O
entry_false	pointer
=	O
find_parser	function
(	O
"false"	pointer
)	O
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry_false	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_false	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
entry	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
return	O
insert_false	function
(	O
)	O
;	O
}	O
static	O
bool	bool
insert_fls	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
filename	pointer
)	O
open_output_file	function
(	O
filename	pointer
,	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
)	O
;	O
else	O
open_stdout	function
(	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_fls	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
filename	pointer
)	O
)	O
{	O
if	O
(	O
insert_fls	function
(	O
entry	pointer
,	O
filename	pointer
)	O
)	O
return	O
true	int
;	O
else	O
--	O
*	O
arg_ptr	pointer
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_follow	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
set_follow_state	function
(	O
SYMLINK_ALWAYS_DEREF	int
)	O
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_fprint	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
filename	pointer
)	O
)	O
{	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
filename	pointer
)	O
;	O
open_output_file	function
(	O
filename	pointer
,	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
insert_fprint	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
filename	pointer
)	O
open_output_file	function
(	O
filename	pointer
,	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
)	O
;	O
else	O
open_stdout	function
(	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_fprint0	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
filename	pointer
)	O
)	O
{	O
if	O
(	O
insert_fprint	function
(	O
entry	pointer
,	O
filename	pointer
)	O
)	O
return	O
true	int
;	O
else	O
--	O
*	O
arg_ptr	pointer
;	O
}	O
return	O
false	int
;	O
}	O
static	O
float	O
estimate_fstype_success_rate	function
(	O
const	O
char	O
*	O
fsname	pointer
)	O
{	O
struct	O
stat	struct
dir_stat	struct
;	O
const	O
char	O
*	O
the_root_dir	pointer
=	O
"/"	pointer
;	O
if	O
(	O
0	int
==	O
stat	struct
(	O
the_root_dir	pointer
,	O
&	O
dir_stat	struct
)	O
)	O
{	O
const	O
char	O
*	O
fstype	pointer
=	O
filesystem_type	function
(	O
&	O
dir_stat	struct
,	O
the_root_dir	pointer
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
fsname	pointer
,	O
fstype	pointer
)	O
)	O
return	O
0.7f	int
;	O
else	O
return	O
0.3f	int
;	O
}	O
return	O
1.0f	int
;	O
}	O
static	O
bool	bool
is_used_fs_type	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"afs"	pointer
,	O
name	pointer
)	O
)	O
{	O
return	O
true	int
;	O
}	O
else	O
{	O
const	O
struct	O
mount_entry	struct
*	O
entries	pointer
=	O
read_file_system_list	function
(	O
false	int
)	O
;	O
if	O
(	O
entries	pointer
)	O
{	O
const	O
struct	O
mount_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
me_next	pointer
)	O
{	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
name	pointer
,	O
entry	pointer
->	O
me_type	pointer
)	O
)	O
return	O
true	int
;	O
}	O
}	O
else	O
{	O
return	O
true	int
;	O
}	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_fstype	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
typename	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
typename	pointer
)	O
)	O
{	O
if	O
(	O
options	struct
.	O
optimisation_level	short
<	O
2	int
||	O
is_used_fs_type	function
(	O
typename	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
typename	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
typename	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_fstype_success_rate	function
(	O
typename	pointer
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"-fstype %s can never succeed, substituting -false\n"	pointer
,	O
typename	pointer
)	O
;	O
}	O
return	O
insert_false	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_gid	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
p	pointer
=	O
insert_num	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
->	O
est_success_rate	float
=	O
(	O
p	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
<	O
100	int
)	O
?	O
0.99	int
:	O
0.2	int
;	O
return	O
true	int
;	O
}	O
else	O
{	O
--	O
*	O
arg_ptr	pointer
;	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_group	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
groupname	pointer
;	O
const	O
int	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
groupname	pointer
)	O
)	O
{	O
gid_t	int
gid	int
;	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
struct	O
group	struct
*	O
cur_gr	pointer
=	O
getgrnam	function
(	O
groupname	pointer
)	O
;	O
endgrent	function
(	O
)	O
;	O
if	O
(	O
cur_gr	pointer
)	O
{	O
gid	int
=	O
cur_gr	pointer
->	O
gr_gid	int
;	O
}	O
else	O
{	O
const	O
int	O
gid_len	int
=	O
strspn	function
(	O
groupname	pointer
,	O
"0123456789"	pointer
)	O
;	O
if	O
(	O
gid_len	int
)	O
{	O
if	O
(	O
groupname	pointer
[	O
gid_len	int
]	O
==	O
0	int
)	O
{	O
gid	int
=	O
safe_atoi	function
(	O
groupname	pointer
,	O
options	struct
.	O
err_quoting_style	enum
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s is not the name of an existing group and"	pointer
" it does not look like a numeric group ID "	pointer
"because it has the unexpected suffix %s"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
groupname	pointer
)	O
,	O
quotearg_n_style	function
(	O
1	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
groupname	pointer
+	O
gid_len	int
)	O
)	O
;	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
return	O
false	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
groupname	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s is not the name of an existing group"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
groupname	pointer
)	O
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument to -group is empty, but should be a group name"	pointer
)	O
)	O
;	O
}	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
return	O
false	int
;	O
}	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
groupname	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
gid	int
=	O
gid	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
(	O
our_pred	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
<	O
100	int
)	O
?	O
0.99	int
:	O
0.2	int
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_help	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
entry	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
usage	function
(	O
stdout	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
puts	function
(	O
_	O
(	O
"\ndefault path is the current directory; default expression is -print\nexpression may consist of: operators, options, tests, and actions:\n"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"operators (decreasing precedence; -and is implicit where no others are given):\n      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"positional options (always true): -daystart -follow -regextype\n\nnormal options (always true, specified before other expressions):\n      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n      --version -xdev -ignore_readdir_race -noignore_readdir_race\n"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"tests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\n      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN\n      -readable -writable -executable\n      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n      -used N -user NAME -xtype [bcdpfls]"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"      -context CONTEXT\n"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"\nactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print \n      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;\n"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"Report (and track progress on fixing) bugs via the findutils bug-reporting\npage at http://savannah.gnu.org/ or, if you have no web access, by sending\nemail to <bug-findutils@gnu.org>."	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
float	O
estimate_pattern_match_rate	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
int	O
is_regex	int
)	O
{	O
if	O
(	O
strpbrk	function
(	O
pattern	pointer
,	O
"*?["	pointer
)	O
||	O
(	O
is_regex	int
&&	O
strpbrk	function
(	O
pattern	pointer
,	O
"."	pointer
)	O
)	O
)	O
{	O
return	O
0.8f	int
;	O
}	O
else	O
{	O
return	O
0.1f	int
;	O
}	O
}	O
static	O
bool	bool
parse_ilname	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
name	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
name	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
name	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.1	int
*	O
estimate_pattern_match_rate	function
(	O
name	pointer
,	O
0	int
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
fnmatch_sanitycheck	function
(	O
void	O
)	O
{	O
static	O
bool	bool
checked	bool
=	O
false	int
;	O
if	O
(	O
!	O
checked	bool
)	O
{	O
if	O
(	O
0	int
!=	O
fnmatch	function
(	O
"foo"	pointer
,	O
"foo"	pointer
,	O
0	int
)	O
||	O
0	int
==	O
fnmatch	function
(	O
"Foo"	pointer
,	O
"foo"	pointer
,	O
0	int
)	O
||	O
0	int
!=	O
fnmatch	function
(	O
"Foo"	pointer
,	O
"foo"	pointer
,	O
FNM_CASEFOLD	O
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"sanity check of the fnmatch() library function failed."	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
checked	bool
=	O
true	int
;	O
}	O
return	O
checked	bool
;	O
}	O
static	O
bool	bool
check_name_arg	function
(	O
const	O
char	O
*	O
pred	pointer
,	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
should_issue_warnings	function
(	O
)	O
&&	O
strchr	function
(	O
arg	pointer
,	O
'/'	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: Unix filenames usually don't contain slashes "	pointer
"(though pathnames do).  That means that '%s %s' will "	pointer
"probably evaluate to false all the time on this system.  "	pointer
"You might find the '-wholename' test more useful, or "	pointer
"perhaps '-samefile'.  Alternatively, if you are using "	pointer
"GNU grep, you could "	pointer
"use 'find ... -print0 | grep -FzZ %s'."	pointer
)	O
,	O
pred	pointer
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
arg	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
1	int
,	O
arg	pointer
)	O
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_iname	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
fnmatch_sanitycheck	function
(	O
)	O
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
name	pointer
)	O
)	O
{	O
if	O
(	O
check_name_arg	function
(	O
"-iname"	pointer
,	O
name	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
name	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
name	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_pattern_match_rate	function
(	O
name	pointer
,	O
0	int
)	O
;	O
return	O
true	int
;	O
}	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_inum	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
p	pointer
=	O
insert_num	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
->	O
est_success_rate	float
=	O
1e-6	int
;	O
p	pointer
->	O
need_inum	bool
=	O
true	int
;	O
p	pointer
->	O
need_stat	bool
=	O
false	int
;	O
p	pointer
->	O
need_type	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
else	O
{	O
--	O
*	O
arg_ptr	pointer
;	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_iregex	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_regex	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
,	O
RE_ICASE	O
|	O
options	struct
.	O
regex_options	int
)	O
;	O
}	O
static	O
bool	bool
parse_links	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
p	pointer
=	O
insert_num	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
==	O
1	int
)	O
p	pointer
->	O
est_success_rate	float
=	O
0.99	int
;	O
else	O
if	O
(	O
p	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
==	O
2	int
)	O
p	pointer
->	O
est_success_rate	float
=	O
0.01	int
;	O
else	O
p	pointer
->	O
est_success_rate	float
=	O
1e-3	int
;	O
return	O
true	int
;	O
}	O
else	O
{	O
--	O
*	O
arg_ptr	pointer
;	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_lname	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
fnmatch_sanitycheck	function
(	O
)	O
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
name	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
name	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
name	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.1	int
*	O
estimate_pattern_match_rate	function
(	O
name	pointer
,	O
0	int
)	O
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_ls	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
&	O
argv	array
;	O
(	O
void	O
)	O
&	O
arg_ptr	pointer
;	O
return	O
insert_fls	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
bool	bool
insert_depthspec	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
int	O
*	O
limitptr	pointer
)	O
{	O
const	O
char	O
*	O
depthstr	pointer
;	O
int	O
depth_len	int
;	O
const	O
char	O
*	O
predicate	struct
=	O
argv	array
[	O
(	O
*	O
arg_ptr	pointer
)	O
-	O
1	int
]	O
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
depthstr	pointer
)	O
)	O
{	O
depth_len	int
=	O
strspn	function
(	O
depthstr	pointer
,	O
"0123456789"	pointer
)	O
;	O
if	O
(	O
(	O
depth_len	int
>	O
0	int
)	O
&&	O
(	O
depthstr	pointer
[	O
depth_len	int
]	O
==	O
0	int
)	O
)	O
{	O
(	O
*	O
limitptr	pointer
)	O
=	O
safe_atoi	function
(	O
depthstr	pointer
,	O
options	struct
.	O
err_quoting_style	enum
)	O
;	O
if	O
(	O
*	O
limitptr	pointer
>=	O
0	int
)	O
{	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
}	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Expected a positive decimal integer argument to %s, but got %s"	pointer
)	O
,	O
predicate	struct
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
depthstr	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_maxdepth	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_depthspec	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
options	struct
.	O
maxdepth	int
)	O
;	O
}	O
static	O
bool	bool
parse_mindepth	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_depthspec	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
options	struct
.	O
mindepth	int
)	O
;	O
}	O
static	O
bool	bool
do_parse_xmin	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
enum	O
xval	enum
xv	enum
)	O
{	O
const	O
char	O
*	O
minutes	pointer
;	O
const	O
int	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
minutes	pointer
)	O
)	O
{	O
struct	O
time_val	struct
tval	pointer
;	O
struct	O
timespec	struct
origin	struct
=	O
options	struct
.	O
cur_day_start	struct
;	O
tval	pointer
.	O
xval	enum
=	O
xv	enum
;	O
origin	struct
.	O
tv_sec	long
+=	O
DAYSECS	int
;	O
if	O
(	O
get_relative_timestamp	function
(	O
minutes	pointer
,	O
&	O
tval	pointer
,	O
origin	struct
,	O
60	int
,	O
"arithmetic overflow while converting %s "	pointer
"minutes to a number of seconds"	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
minutes	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
=	O
tval	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_timestamp_success_rate	function
(	O
tval	pointer
.	O
ts	struct
.	O
tv_sec	long
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
}	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_amin	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
do_parse_xmin	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
XVAL_ATIME	int
)	O
;	O
}	O
static	O
bool	bool
parse_cmin	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
do_parse_xmin	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
XVAL_CTIME	int
)	O
;	O
}	O
static	O
bool	bool
parse_mmin	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
do_parse_xmin	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
XVAL_MTIME	int
)	O
;	O
}	O
static	O
bool	bool
parse_name	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
int	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
name	pointer
)	O
)	O
{	O
fnmatch_sanitycheck	function
(	O
)	O
;	O
if	O
(	O
check_name_arg	function
(	O
"-name"	pointer
,	O
name	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
name	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
name	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_pattern_match_rate	function
(	O
name	pointer
,	O
0	int
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
}	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_negate	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
&	O
argv	array
;	O
(	O
void	O
)	O
&	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
get_new_pred_chk_op	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
our_pred	pointer
->	O
pred_func	pointer
=	O
pred_negate	function
;	O
our_pred	pointer
->	O
p_type	enum
=	O
UNI_OP	int
;	O
our_pred	pointer
->	O
p_prec	enum
=	O
NEGATE_PREC	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_newer	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
struct	O
stat	struct
stat_newer	struct
;	O
const	O
char	O
*	O
arg	pointer
;	O
set_stat_placeholders	function
(	O
&	O
stat_newer	struct
)	O
;	O
if	O
(	O
collect_arg_stat_info	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
stat_newer	struct
,	O
&	O
arg	pointer
)	O
)	O
{	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
arg	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
=	O
get_stat_mtime	function
(	O
&	O
stat_newer	struct
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_MTIME	int
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
kind	enum
=	O
COMP_GT	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_timestamp_success_rate	function
(	O
stat_newer	struct
.	O
st_mtime	O
)	O
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_newerXY	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
if	O
(	O
(	O
argv	array
==	O
NULL	O
)	O
||	O
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
==	O
NULL	O
)	O
)	O
{	O
return	O
false	int
;	O
}	O
else	O
if	O
(	O
8u	int
!=	O
strlen	function
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
)	O
)	O
{	O
return	O
false	int
;	O
}	O
else	O
{	O
char	O
x	char
,	O
y	char
;	O
const	O
char	O
validchars	array
[	O
]	O
=	O
"aBcmt"	pointer
;	O
assert	O
(	O
0	int
==	O
strncmp	function
(	O
"-newer"	pointer
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
,	O
6	int
)	O
)	O
;	O
x	char
=	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
[	O
6	int
]	O
;	O
y	char
=	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
[	O
7	int
]	O
;	O
if	O
(	O
'B'	O
==	O
x	char
||	O
'B'	O
==	O
y	char
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"This system does not provide a way to find the birth time of a file."	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
x	char
==	O
't'	O
||	O
(	O
NULL	O
==	O
strchr	function
(	O
validchars	array
,	O
x	char
)	O
)	O
||	O
(	O
NULL	O
==	O
strchr	function
(	O
validchars	array
,	O
y	char
)	O
)	O
)	O
{	O
return	O
false	int
;	O
}	O
else	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
if	O
(	O
argv	array
[	O
1	int
+	O
*	O
arg_ptr	pointer
]	O
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The %s test needs an argument"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
arg_ptr	pointer
)	O
++	O
;	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
)	O
;	O
switch	O
(	O
x	char
)	O
{	O
case	O
'a'	O
:	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_ATIME	int
;	O
break	O
;	O
case	O
'B'	O
:	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_BIRTHTIME	int
;	O
break	O
;	O
case	O
'c'	O
:	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_CTIME	int
;	O
break	O
;	O
case	O
'm'	O
:	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
xval	enum
=	O
XVAL_MTIME	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
strchr	function
(	O
validchars	array
,	O
x	char
)	O
)	O
;	O
assert	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
't'	O
==	O
y	char
)	O
{	O
if	O
(	O
!	O
parse_datetime	function
(	O
&	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
,	O
&	O
options	struct
.	O
start_time	struct
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"I cannot figure out how to interpret %s as a date or time"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
struct	O
stat	struct
stat_newer	struct
;	O
set_stat_placeholders	function
(	O
&	O
stat_newer	struct
)	O
;	O
if	O
(	O
(	O
*	O
options	struct
.	O
xstat	pointer
)	O
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
,	O
&	O
stat_newer	struct
)	O
)	O
fatal_target_file_error	function
(	O
errno	O
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
)	O
;	O
if	O
(	O
!	O
get_stat_Ytime	function
(	O
&	O
stat_newer	struct
,	O
y	char
,	O
&	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Cannot obtain birth time of file %s"	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
)	O
)	O
;	O
}	O
}	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
kind	enum
=	O
COMP_GT	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_timestamp_success_rate	function
(	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
.	O
tv_sec	long
)	O
;	O
(	O
*	O
arg_ptr	pointer
)	O
++	O
;	O
assert	O
(	O
our_pred	pointer
->	O
pred_func	pointer
!=	O
NULL	O
)	O
;	O
assert	O
(	O
our_pred	pointer
->	O
pred_func	pointer
==	O
pred_newerXY	function
)	O
;	O
assert	O
(	O
our_pred	pointer
->	O
need_stat	bool
)	O
;	O
return	O
true	int
;	O
}	O
}	O
}	O
static	O
bool	bool
parse_noleaf	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
options	struct
.	O
no_leaf_check	bool
=	O
true	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_nogroup	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
&	O
argv	array
;	O
(	O
void	O
)	O
&	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1e-4	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_nouser	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1e-3	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_nowarn	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
options	struct
.	O
warnings	bool
=	O
false	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_ok	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_exec_ok	function
(	O
"-ok"	pointer
,	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_okdir	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_exec_ok	function
(	O
"-okdir"	pointer
,	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
bool	bool
parse_openparen	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
get_new_pred_chk_op	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
our_pred	pointer
->	O
pred_func	pointer
=	O
pred_openparen	function
;	O
our_pred	pointer
->	O
p_type	enum
=	O
OPEN_PAREN	int
;	O
our_pred	pointer
->	O
p_prec	enum
=	O
NO_PREC	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_or	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
get_new_pred_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
pred_func	pointer
=	O
pred_or	function
;	O
our_pred	pointer
->	O
p_type	enum
=	O
BI_OP	int
;	O
our_pred	pointer
->	O
p_prec	enum
=	O
OR_PREC	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
is_feasible_path_argument	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
bool	bool
foldcase	bool
)	O
{	O
const	O
char	O
*	O
last	pointer
=	O
strrchr	function
(	O
arg	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
last	pointer
&&	O
!	O
last	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
matches_start_point	function
(	O
arg	pointer
,	O
foldcase	bool
)	O
)	O
{	O
return	O
true	int
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
insert_path_check	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
char	O
*	O
predicate_name	pointer
,	O
PREDICATEFUNCTION	function
pred	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
bool	bool
foldcase	bool
=	O
false	int
;	O
if	O
(	O
pred	pointer
==	O
pred_ipath	function
)	O
foldcase	bool
=	O
true	int
;	O
fnmatch_sanitycheck	function
(	O
)	O
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
name	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary_withpred	function
(	O
entry	pointer
,	O
pred	pointer
,	O
name	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
name	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_pattern_match_rate	function
(	O
name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
options	struct
.	O
posixly_correct	bool
&&	O
!	O
is_feasible_path_argument	function
(	O
name	pointer
,	O
foldcase	bool
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: -%s %s will not match anything "	pointer
"because it ends with /."	pointer
)	O
,	O
predicate_name	pointer
,	O
name	pointer
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0e-8	int
;	O
}	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_path	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_path_check	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
"path"	pointer
,	O
pred_path	function
)	O
;	O
}	O
static	O
bool	bool
parse_wholename	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_path_check	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
"wholename"	pointer
,	O
pred_path	function
)	O
;	O
}	O
static	O
bool	bool
parse_ipath	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_path_check	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
"ipath"	pointer
,	O
pred_ipath	function
)	O
;	O
}	O
static	O
bool	bool
parse_iwholename	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_path_check	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
,	O
"iwholename"	pointer
,	O
pred_ipath	function
)	O
;	O
}	O
static	O
bool	bool
parse_perm	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
mode_t	int
perm_val	struct
[	O
2	int
]	O
;	O
float	O
rate	float
;	O
int	O
mode_start	int
=	O
0	int
;	O
enum	O
permissions_type	enum
kind	enum
=	O
PERM_EXACT	int
;	O
struct	O
mode_change	O
*	O
change	pointer
;	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
const	O
char	O
*	O
perm_expr	pointer
;	O
if	O
(	O
!	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
perm_expr	pointer
)	O
)	O
return	O
false	int
;	O
switch	O
(	O
perm_expr	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'-'	O
:	O
mode_start	int
=	O
1	int
;	O
kind	enum
=	O
PERM_AT_LEAST	int
;	O
rate	float
=	O
0.2	int
;	O
break	O
;	O
case	O
'/'	O
:	O
mode_start	int
=	O
1	int
;	O
kind	enum
=	O
PERM_ANY	int
;	O
rate	float
=	O
0.3	int
;	O
break	O
;	O
default	O
:	O
mode_start	int
=	O
0	int
;	O
kind	enum
=	O
PERM_EXACT	int
;	O
rate	float
=	O
0.01	int
;	O
break	O
;	O
}	O
change	pointer
=	O
mode_compile	function
(	O
perm_expr	pointer
+	O
mode_start	int
)	O
;	O
if	O
(	O
NULL	O
==	O
change	pointer
||	O
(	O
perm_expr	pointer
[	O
0	int
]	O
==	O
'+'	O
&&	O
'0'	O
<=	O
perm_expr	pointer
[	O
1	int
]	O
&&	O
perm_expr	pointer
[	O
1	int
]	O
<	O
'8'	O
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid mode %s"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
perm_expr	pointer
)	O
)	O
;	O
perm_val	struct
[	O
0	int
]	O
=	O
mode_adjust	function
(	O
0	int
,	O
false	int
,	O
0	int
,	O
change	pointer
,	O
NULL	O
)	O
;	O
perm_val	struct
[	O
1	int
]	O
=	O
mode_adjust	function
(	O
0	int
,	O
true	int
,	O
0	int
,	O
change	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
change	pointer
)	O
;	O
if	O
(	O
(	O
'/'	O
==	O
perm_expr	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
0	int
==	O
perm_val	struct
[	O
0	int
]	O
)	O
&&	O
(	O
0	int
==	O
perm_val	struct
[	O
1	int
]	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: you have specified a mode pattern %s (which is "	pointer
"equivalent to /000). The meaning of -perm /000 has now been "	pointer
"changed to be consistent with -perm -000; that is, while it "	pointer
"used to match no files, it now matches all files."	pointer
)	O
,	O
perm_expr	pointer
)	O
;	O
kind	enum
=	O
PERM_AT_LEAST	int
;	O
rate	float
=	O
0.9986	int
;	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
perm_expr	pointer
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
rate	float
;	O
our_pred	pointer
->	O
args	union
.	O
perm	int
.	O
kind	enum
=	O
kind	enum
;	O
memcpy	function
(	O
our_pred	pointer
->	O
args	union
.	O
perm	int
.	O
val	array
,	O
perm_val	struct
,	O
sizeof	O
perm_val	struct
)	O
;	O
return	O
true	int
;	O
}	O
bool	bool
parse_print	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
open_stdout	function
(	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
)	O
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_print0	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
entry	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
return	O
insert_fprint	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
bool	bool
parse_printf	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
char	O
*	O
format	pointer
;	O
const	O
int	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
collect_arg_nonconst	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
format	pointer
)	O
)	O
{	O
struct	O
format_val	struct
fmt	pointer
;	O
open_stdout	function
(	O
&	O
fmt	pointer
)	O
;	O
if	O
(	O
insert_fprintf	function
(	O
&	O
fmt	pointer
,	O
entry	pointer
,	O
format	pointer
)	O
)	O
{	O
return	O
true	int
;	O
}	O
else	O
{	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
return	O
false	int
;	O
}	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_fprintf	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
format	pointer
;	O
int	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
filename	pointer
)	O
)	O
{	O
if	O
(	O
collect_arg_nonconst	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
format	pointer
)	O
)	O
{	O
struct	O
format_val	struct
fmt	pointer
;	O
open_output_file	function
(	O
filename	pointer
,	O
&	O
fmt	pointer
)	O
;	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
insert_fprintf	function
(	O
&	O
fmt	pointer
,	O
entry	pointer
,	O
format	pointer
)	O
)	O
return	O
true	int
;	O
}	O
}	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_prune	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
options	struct
.	O
do_dir_first	bool
==	O
false	int
)	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
true	int
;	O
our_pred	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_quit	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
true	int
;	O
our_pred	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_regextype	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
type_name	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
type_name	pointer
)	O
)	O
{	O
options	struct
.	O
regex_options	int
=	O
get_regex_type	function
(	O
type_name	pointer
)	O
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_regex	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_regex	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
,	O
options	struct
.	O
regex_options	int
)	O
;	O
}	O
static	O
bool	bool
insert_regex	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
int	O
regex_options	int
)	O
{	O
const	O
char	O
*	O
rx	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
rx	pointer
)	O
)	O
{	O
struct	O
re_pattern_buffer	struct
*	O
re	pointer
;	O
const	O
char	O
*	O
error_message	pointer
;	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary_withpred	function
(	O
entry	pointer
,	O
pred_regex	function
,	O
rx	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
re	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
re_pattern_buffer	struct
)	O
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
regex	pointer
=	O
re	pointer
;	O
re	pointer
->	O
allocated	long
=	O
100	int
;	O
re	pointer
->	O
buffer	pointer
=	O
xmalloc	function
(	O
re	pointer
->	O
allocated	long
)	O
;	O
re	pointer
->	O
fastmap	pointer
=	O
NULL	O
;	O
re_set_syntax	function
(	O
regex_options	int
)	O
;	O
re	pointer
->	O
syntax	long
=	O
regex_options	int
;	O
re	pointer
->	O
translate	pointer
=	O
NULL	O
;	O
error_message	pointer
=	O
re_compile_pattern	function
(	O
rx	pointer
,	O
strlen	function
(	O
rx	pointer
)	O
,	O
re	pointer
)	O
;	O
if	O
(	O
error_message	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"failed to compile regular expression '%s': %s"	pointer
)	O
,	O
rx	pointer
,	O
error_message	pointer
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_pattern_match_rate	function
(	O
rx	pointer
,	O
1	int
)	O
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_size	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
char	O
*	O
arg	pointer
;	O
uintmax_t	long
num	pointer
;	O
char	O
suffix	char
;	O
enum	O
comparison_type	enum
c_type	enum
;	O
int	O
blksize	int
=	O
512	int
;	O
int	O
len	long
;	O
if	O
(	O
(	O
argv	array
==	O
NULL	O
)	O
||	O
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
==	O
NULL	O
)	O
)	O
return	O
false	int
;	O
arg	pointer
=	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
;	O
len	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid null argument to -size"	pointer
)	O
)	O
;	O
suffix	char
=	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
;	O
switch	O
(	O
suffix	char
)	O
{	O
case	O
'b'	O
:	O
blksize	int
=	O
512	int
;	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'c'	O
:	O
blksize	int
=	O
1	int
;	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'k'	O
:	O
blksize	int
=	O
1024	int
;	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'M'	O
:	O
blksize	int
=	O
1024	int
*	O
1024	int
;	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'G'	O
:	O
blksize	int
=	O
1024	int
*	O
1024	int
*	O
1024	int
;	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'w'	O
:	O
blksize	int
=	O
2	int
;	O
arg	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
suffix	char
=	O
0	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid -size type `%c'"	pointer
)	O
,	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
[	O
len	long
-	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
get_num	function
(	O
arg	pointer
,	O
&	O
num	pointer
,	O
&	O
c_type	enum
)	O
)	O
{	O
char	O
tail	array
[	O
2	int
]	O
;	O
tail	array
[	O
0	int
]	O
=	O
suffix	char
;	O
tail	array
[	O
1	int
]	O
=	O
0	int
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid argument `%s%s' to -size"	pointer
)	O
,	O
arg	pointer
,	O
tail	array
)	O
;	O
return	O
false	int
;	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
arg	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
size	pointer
.	O
kind	enum
=	O
c_type	enum
;	O
our_pred	pointer
->	O
args	union
.	O
size	pointer
.	O
blocksize	int
=	O
blksize	int
;	O
our_pred	pointer
->	O
args	union
.	O
size	pointer
.	O
size	pointer
=	O
num	pointer
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
if	O
(	O
COMP_GT	int
==	O
c_type	enum
)	O
our_pred	pointer
->	O
est_success_rate	float
=	O
(	O
num	pointer
*	O
blksize	int
>	O
20480	int
)	O
?	O
0.1	int
:	O
0.9	int
;	O
else	O
if	O
(	O
COMP_LT	int
==	O
c_type	enum
)	O
our_pred	pointer
->	O
est_success_rate	float
=	O
(	O
num	pointer
*	O
blksize	int
>	O
20480	int
)	O
?	O
0.9	int
:	O
0.1	int
;	O
else	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.01	int
;	O
(	O
*	O
arg_ptr	pointer
)	O
++	O
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_samefile	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
struct	O
stat	struct
st	pointer
,	O
fst	struct
;	O
int	O
fd	int
,	O
openflags	int
;	O
const	O
char	O
*	O
filename	pointer
;	O
set_stat_placeholders	function
(	O
&	O
st	pointer
)	O
;	O
if	O
(	O
!	O
collect_arg_stat_info	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
st	pointer
,	O
&	O
filename	pointer
)	O
)	O
return	O
false	int
;	O
set_stat_placeholders	function
(	O
&	O
fst	struct
)	O
;	O
fd	int
=	O
-	O
3	int
;	O
openflags	int
=	O
O_RDONLY	int
;	O
if	O
(	O
options	struct
.	O
symlink_handling	enum
==	O
SYMLINK_NEVER_DEREF	int
)	O
{	O
if	O
(	O
options	struct
.	O
open_nofollow_available	bool
)	O
{	O
assert	O
(	O
O_NOFOLLOW	O
!=	O
0	int
)	O
;	O
openflags	int
|=	O
O_NOFOLLOW	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
fd	int
=	O
-	O
2	int
;	O
}	O
else	O
{	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
fd	int
=	O
-	O
1	int
;	O
}	O
assert	O
(	O
fd	int
!=	O
-	O
3	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
fd	int
=	O
open_cloexec	function
(	O
filename	pointer
,	O
openflags	int
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
0	int
!=	O
fstat	function
(	O
fd	int
,	O
&	O
fst	struct
)	O
)	O
{	O
fatal_target_file_error	function
(	O
errno	O
,	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
options	struct
.	O
xstat	pointer
)	O
(	O
filename	pointer
,	O
&	O
st	pointer
)	O
)	O
fatal_target_file_error	function
(	O
errno	O
,	O
filename	pointer
)	O
;	O
if	O
(	O
(	O
options	struct
.	O
symlink_handling	enum
==	O
SYMLINK_NEVER_DEREF	int
)	O
&&	O
(	O
!	O
options	struct
.	O
open_nofollow_available	bool
)	O
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
close	function
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
st	pointer
.	O
st_dev	long
==	O
fst	struct
.	O
st_dev	long
)	O
&&	O
(	O
st	pointer
.	O
st_ino	long
==	O
fst	struct
.	O
st_ino	long
)	O
)	O
{	O
}	O
else	O
{	O
close	function
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
st	pointer
=	O
fst	struct
;	O
}	O
}	O
}	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
filename	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
samefileid	struct
.	O
ino	long
=	O
st	pointer
.	O
st_ino	long
;	O
our_pred	pointer
->	O
args	union
.	O
samefileid	struct
.	O
dev	long
=	O
st	pointer
.	O
st_dev	long
;	O
our_pred	pointer
->	O
args	union
.	O
samefileid	struct
.	O
fd	int
=	O
fd	int
;	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.01f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_true	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
1.0f	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_noop	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
(	O
void	O
)	O
entry	pointer
;	O
return	O
parse_true	function
(	O
get_noop	function
(	O
)	O
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_accesscheck	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
our_pred	pointer
=	O
insert_primary_noarg	function
(	O
entry	pointer
)	O
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
if	O
(	O
pred_is	O
(	O
our_pred	pointer
,	O
pred_executable	function
)	O
)	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.2	int
;	O
else	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.9	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_type	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_type	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
,	O
pred_type	function
)	O
;	O
}	O
static	O
bool	bool
parse_uid	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
p	pointer
=	O
insert_num	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
->	O
est_success_rate	float
=	O
(	O
p	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
<	O
100	int
)	O
?	O
0.99	int
:	O
0.2	int
;	O
return	O
true	int
;	O
}	O
else	O
{	O
--	O
*	O
arg_ptr	pointer
;	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_used	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
struct	O
time_val	struct
tval	pointer
;	O
const	O
char	O
*	O
offset_str	pointer
;	O
const	O
char	O
*	O
errmsg	pointer
=	O
"arithmetic overflow while converting %s days to a number of seconds"	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
offset_str	pointer
)	O
)	O
{	O
struct	O
timespec	struct
zero	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
get_relative_timestamp	function
(	O
offset_str	pointer
,	O
&	O
tval	pointer
,	O
zero	struct
,	O
DAYSECS	int
,	O
errmsg	pointer
)	O
)	O
{	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
offset_str	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
=	O
tval	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_file_age_success_rate	function
(	O
tval	pointer
.	O
ts	struct
.	O
tv_sec	long
/	O
DAYSECS	int
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid argument %s to -used"	pointer
)	O
,	O
offset_str	pointer
)	O
;	O
return	O
false	int
;	O
}	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_user	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
const	O
char	O
*	O
username	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
username	pointer
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
uid_t	int
uid	int
;	O
struct	O
passwd	struct
*	O
cur_pwd	pointer
=	O
getpwnam	function
(	O
username	pointer
)	O
;	O
endpwent	function
(	O
)	O
;	O
if	O
(	O
cur_pwd	pointer
!=	O
NULL	O
)	O
{	O
uid	int
=	O
cur_pwd	pointer
->	O
pw_uid	int
;	O
}	O
else	O
{	O
const	O
size_t	long
uid_len	long
=	O
strspn	function
(	O
username	pointer
,	O
"0123456789"	pointer
)	O
;	O
if	O
(	O
uid_len	long
&&	O
(	O
username	pointer
[	O
uid_len	long
]	O
==	O
0	int
)	O
)	O
{	O
uid	int
=	O
safe_atoi	function
(	O
username	pointer
,	O
options	struct
.	O
err_quoting_style	enum
)	O
;	O
}	O
else	O
{	O
if	O
(	O
username	pointer
[	O
0	int
]	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s is not the name of a known user"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
username	pointer
)	O
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The argument to -user should not be empty"	pointer
)	O
)	O
;	O
}	O
return	O
false	int
;	O
}	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
username	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
uid	int
=	O
uid	int
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
(	O
our_pred	pointer
->	O
args	union
.	O
uid	int
<	O
100	int
)	O
?	O
0.99	int
:	O
0.2	int
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
parse_version	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
bool	bool
has_features	bool
=	O
false	int
;	O
int	O
flags	int
;	O
(	O
void	O
)	O
argv	array
;	O
(	O
void	O
)	O
arg_ptr	pointer
;	O
(	O
void	O
)	O
entry	pointer
;	O
display_findutils_version	function
(	O
"find"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Features enabled: "	pointer
)	O
)	O
;	O
printf	function
(	O
"D_TYPE "	pointer
)	O
;	O
has_features	bool
=	O
true	int
;	O
printf	function
(	O
"O_NOFOLLOW(%s) "	pointer
,	O
(	O
options	struct
.	O
open_nofollow_available	bool
?	O
"enabled"	pointer
:	O
"disabled"	pointer
)	O
)	O
;	O
has_features	bool
=	O
true	int
;	O
printf	function
(	O
"LEAF_OPTIMISATION "	pointer
)	O
;	O
has_features	bool
=	O
true	int
;	O
if	O
(	O
0	int
<	O
is_selinux_enabled	function
(	O
)	O
)	O
{	O
printf	function
(	O
"SELINUX "	pointer
)	O
;	O
has_features	bool
=	O
true	int
;	O
}	O
flags	int
=	O
0	int
;	O
if	O
(	O
is_fts_enabled	function
(	O
&	O
flags	int
)	O
)	O
{	O
int	O
nflags	int
=	O
0	int
;	O
printf	function
(	O
"FTS("	pointer
)	O
;	O
has_features	bool
=	O
true	int
;	O
if	O
(	O
flags	int
&	O
FTS_CWDFD	int
)	O
{	O
if	O
(	O
nflags	int
)	O
{	O
printf	function
(	O
","	pointer
)	O
;	O
}	O
printf	function
(	O
"FTS_CWDFD"	pointer
)	O
;	O
has_features	bool
=	O
true	int
;	O
}	O
printf	function
(	O
") "	pointer
)	O
;	O
}	O
printf	function
(	O
"CBO(level=%d) "	pointer
,	O
(	O
int	O
)	O
(	O
options	struct
.	O
optimisation_level	short
)	O
)	O
;	O
has_features	bool
=	O
true	int
;	O
if	O
(	O
!	O
has_features	bool
)	O
{	O
printf	function
(	O
"none"	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
bool	bool
parse_context	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
if	O
(	O
(	O
argv	array
==	O
NULL	O
)	O
||	O
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
==	O
NULL	O
)	O
)	O
return	O
false	int
;	O
if	O
(	O
is_selinux_enabled	function
(	O
)	O
<=	O
0	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid predicate -context: SELinux is not enabled."	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
0.01f	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
false	int
;	O
our_pred	pointer
->	O
args	union
.	O
scontext	pointer
=	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
;	O
(	O
*	O
arg_ptr	pointer
)	O
++	O
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_xdev	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
options	struct
.	O
stay_on_filesystem	bool
=	O
true	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_ignore_race	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
options	struct
.	O
ignore_readdir_race	bool
=	O
true	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_noignore_race	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
options	struct
.	O
ignore_readdir_race	bool
=	O
false	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_warn	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
options	struct
.	O
warnings	bool
=	O
true	int
;	O
return	O
parse_noop	function
(	O
entry	pointer
,	O
argv	array
,	O
arg_ptr	pointer
)	O
;	O
}	O
static	O
bool	bool
parse_xtype	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
return	O
insert_type	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
entry	pointer
,	O
pred_xtype	function
)	O
;	O
}	O
static	O
bool	bool
insert_type	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
PRED_FUNC	pointer
which_pred	pointer
)	O
{	O
mode_t	int
type_cell	int
;	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
float	O
rate	float
=	O
0.5	int
;	O
const	O
char	O
*	O
typeletter	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
typeletter	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
typeletter	pointer
)	O
!=	O
1u	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Arguments to -type should contain only one letter"	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
switch	O
(	O
typeletter	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'b'	O
:	O
type_cell	int
=	O
S_IFBLK	O
;	O
rate	float
=	O
0.01f	int
;	O
break	O
;	O
case	O
'c'	O
:	O
type_cell	int
=	O
S_IFCHR	O
;	O
rate	float
=	O
0.01f	int
;	O
break	O
;	O
case	O
'd'	O
:	O
type_cell	int
=	O
S_IFDIR	O
;	O
rate	float
=	O
0.4f	int
;	O
break	O
;	O
case	O
'f'	O
:	O
type_cell	int
=	O
S_IFREG	O
;	O
rate	float
=	O
0.95f	int
;	O
break	O
;	O
case	O
'l'	O
:	O
type_cell	int
=	O
S_IFLNK	O
;	O
rate	float
=	O
0.1f	int
;	O
break	O
;	O
case	O
'p'	O
:	O
type_cell	int
=	O
S_IFIFO	O
;	O
rate	float
=	O
0.01f	int
;	O
break	O
;	O
case	O
's'	O
:	O
type_cell	int
=	O
S_IFSOCK	O
;	O
rate	float
=	O
0.01f	int
;	O
break	O
;	O
case	O
'D'	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"-type %c is not supported because Solaris doors "	pointer
"are not supported on the platform find was compiled on."	pointer
)	O
,	O
(	O
*	O
typeletter	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Unknown argument to -type: %c"	pointer
)	O
,	O
(	O
*	O
typeletter	pointer
)	O
)	O
;	O
return	O
false	int
;	O
}	O
our_pred	pointer
=	O
insert_primary_withpred	function
(	O
entry	pointer
,	O
which_pred	pointer
,	O
typeletter	pointer
)	O
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
rate	float
;	O
if	O
(	O
which_pred	pointer
==	O
pred_xtype	function
)	O
{	O
our_pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
}	O
else	O
{	O
our_pred	pointer
->	O
need_stat	bool
=	O
false	int
;	O
our_pred	pointer
->	O
need_type	bool
=	O
true	int
;	O
}	O
our_pred	pointer
->	O
args	union
.	O
type	enum
=	O
type_cell	int
;	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
stream_is_tty	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
fd	int
=	O
fileno	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
-	O
1	int
==	O
fd	int
)	O
{	O
return	O
false	int
;	O
}	O
else	O
{	O
return	O
isatty	function
(	O
fd	int
)	O
?	O
true	int
:	O
false	int
;	O
}	O
}	O
static	O
void	O
check_path_safety	function
(	O
const	O
char	O
*	O
action	int
)	O
{	O
const	O
char	O
*	O
path	pointer
=	O
getenv	function
(	O
"PATH"	pointer
)	O
;	O
const	O
char	O
*	O
path_separators	pointer
=	O
":"	pointer
;	O
size_t	long
pos	pointer
,	O
len	long
;	O
if	O
(	O
NULL	O
==	O
path	pointer
)	O
{	O
return	O
;	O
}	O
splitstring	function
(	O
path	pointer
,	O
path_separators	pointer
,	O
true	int
,	O
&	O
pos	pointer
,	O
&	O
len	long
)	O
;	O
do	O
{	O
if	O
(	O
0	int
==	O
len	long
||	O
(	O
1	int
==	O
len	long
&&	O
path	pointer
[	O
pos	pointer
]	O
==	O
'.'	O
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The current directory is included in the PATH "	pointer
"environment variable, which is insecure in "	pointer
"combination with the %s action of find.  "	pointer
"Please remove the current directory from your "	pointer
"$PATH (that is, remove \".\", doubled colons, "	pointer
"or leading or trailing colons)"	pointer
)	O
,	O
action	int
)	O
;	O
}	O
else	O
if	O
(	O
path	pointer
[	O
pos	pointer
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
relpath	pointer
=	O
strndup	function
(	O
&	O
path	pointer
[	O
pos	pointer
]	O
,	O
len	long
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The relative path %s is included in the PATH "	pointer
"environment variable, which is insecure in "	pointer
"combination with the %s action of find.  "	pointer
"Please remove that entry from $PATH"	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
relpath	pointer
?	O
relpath	pointer
:	O
&	O
path	pointer
[	O
pos	pointer
]	O
)	O
,	O
action	int
)	O
;	O
free	function
(	O
relpath	pointer
)	O
;	O
}	O
}	O
while	O
(	O
splitstring	function
(	O
path	pointer
,	O
path_separators	pointer
,	O
false	int
,	O
&	O
pos	pointer
,	O
&	O
len	long
)	O
)	O
;	O
}	O
static	O
bool	bool
insert_exec_ok	function
(	O
const	O
char	O
*	O
action	int
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
int	O
start	pointer
,	O
end	pointer
;	O
int	O
i	int
;	O
int	O
saw_braces	int
;	O
bool	bool
allow_plus	bool
;	O
int	O
brace_count	int
;	O
const	O
char	O
*	O
brace_arg	pointer
;	O
PRED_FUNC	pointer
func	pointer
=	O
entry	pointer
->	O
pred_func	pointer
;	O
enum	O
BC_INIT_STATUS	enum
bcstatus	enum
;	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
struct	O
exec_val	struct
*	O
execp	pointer
;	O
if	O
(	O
(	O
argv	array
==	O
NULL	O
)	O
||	O
(	O
argv	array
[	O
*	O
arg_ptr	pointer
]	O
==	O
NULL	O
)	O
)	O
return	O
false	int
;	O
our_pred	pointer
=	O
insert_primary_withpred	function
(	O
entry	pointer
,	O
func	pointer
,	O
"(some -exec* arguments)"	pointer
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
our_pred	pointer
->	O
need_type	bool
=	O
our_pred	pointer
->	O
need_stat	bool
=	O
false	int
;	O
execp	pointer
=	O
&	O
our_pred	pointer
->	O
args	union
.	O
exec_vec	struct
;	O
execp	pointer
->	O
wd_for_exec	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
func	pointer
!=	O
pred_okdir	function
)	O
&&	O
(	O
func	pointer
!=	O
pred_ok	function
)	O
)	O
{	O
allow_plus	bool
=	O
true	int
;	O
execp	pointer
->	O
close_stdin	bool
=	O
false	int
;	O
}	O
else	O
{	O
allow_plus	bool
=	O
false	int
;	O
execp	pointer
->	O
close_stdin	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
func	pointer
==	O
pred_execdir	function
)	O
||	O
(	O
func	pointer
==	O
pred_okdir	function
)	O
)	O
{	O
execp	pointer
->	O
wd_for_exec	pointer
=	O
NULL	O
;	O
options	struct
.	O
ignore_readdir_race	bool
=	O
false	int
;	O
check_path_safety	function
(	O
action	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
NULL	O
!=	O
initial_wd	pointer
)	O
;	O
execp	pointer
->	O
wd_for_exec	pointer
=	O
initial_wd	pointer
;	O
}	O
our_pred	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
=	O
0	int
;	O
start	pointer
=	O
*	O
arg_ptr	pointer
;	O
for	O
(	O
end	pointer
=	O
start	pointer
,	O
saw_braces	int
=	O
0	int
,	O
brace_count	int
=	O
0	int
,	O
brace_arg	pointer
=	O
NULL	O
;	O
(	O
argv	array
[	O
end	pointer
]	O
!=	O
NULL	O
)	O
&&	O
(	O
(	O
argv	array
[	O
end	pointer
]	O
[	O
0	int
]	O
!=	O
';'	O
)	O
||	O
(	O
argv	array
[	O
end	pointer
]	O
[	O
1	int
]	O
!=	O
'\0'	O
)	O
)	O
;	O
end	pointer
++	O
)	O
{	O
if	O
(	O
allow_plus	bool
&&	O
argv	array
[	O
end	pointer
]	O
[	O
0	int
]	O
==	O
'+'	O
&&	O
argv	array
[	O
end	pointer
]	O
[	O
1	int
]	O
==	O
0	int
&&	O
saw_braces	int
)	O
{	O
our_pred	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
=	O
1	int
;	O
break	O
;	O
}	O
saw_braces	int
=	O
0	int
;	O
if	O
(	O
mbsstr	function
(	O
argv	array
[	O
end	pointer
]	O
,	O
"{}"	pointer
)	O
)	O
{	O
saw_braces	int
=	O
1	int
;	O
brace_arg	pointer
=	O
argv	array
[	O
end	pointer
]	O
;	O
++	O
brace_count	int
;	O
if	O
(	O
0	int
==	O
end	pointer
&&	O
(	O
func	pointer
==	O
pred_execdir	function
||	O
func	pointer
==	O
pred_okdir	function
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"You may not use {} within the utility name for "	pointer
"-execdir and -okdir, because this is a potential "	pointer
"security problem."	pointer
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
end	pointer
==	O
start	pointer
)	O
||	O
(	O
argv	array
[	O
end	pointer
]	O
==	O
NULL	O
)	O
)	O
{	O
*	O
arg_ptr	pointer
=	O
end	pointer
;	O
free	function
(	O
our_pred	pointer
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
our_pred	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
)	O
{	O
const	O
char	O
*	O
suffix	char
;	O
if	O
(	O
func	pointer
==	O
pred_execdir	function
)	O
suffix	char
=	O
"dir"	pointer
;	O
else	O
suffix	char
=	O
""	pointer
;	O
if	O
(	O
brace_count	int
>	O
1	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Only one instance of {} is supported with -exec%s ... +"	pointer
)	O
,	O
suffix	char
)	O
;	O
}	O
else	O
if	O
(	O
strlen	function
(	O
brace_arg	pointer
)	O
!=	O
2u	int
)	O
{	O
enum	O
{	O
MsgBufSize	int
=	O
19	int
}	O
;	O
char	O
buf	pointer
[	O
MsgBufSize	int
]	O
;	O
const	O
size_t	long
needed	long
=	O
snprintf	function
(	O
buf	pointer
,	O
MsgBufSize	int
,	O
"-exec%s ... {} +"	pointer
,	O
suffix	char
)	O
;	O
assert	O
(	O
needed	long
<=	O
MsgBufSize	int
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"In %s the %s must appear by itself, but you specified %s"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
buf	pointer
)	O
,	O
quotearg_n_style	function
(	O
1	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
"{}"	pointer
)	O
,	O
quotearg_n_style	function
(	O
2	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
brace_arg	pointer
)	O
)	O
;	O
}	O
}	O
bcstatus	enum
=	O
bc_init_controlinfo	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
2048u	int
)	O
;	O
switch	O
(	O
bcstatus	enum
)	O
{	O
case	O
BC_INIT_ENV_TOO_BIG	int
:	O
case	O
BC_INIT_CANNOT_ACCOMODATE_HEADROOM	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The environment is too large for exec()."	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BC_INIT_OK	int
:	O
break	O
;	O
}	O
bc_use_sensible_arg_max	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
)	O
;	O
execp	pointer
->	O
ctl	pointer
.	O
exec_callback	pointer
=	O
launch	function
;	O
if	O
(	O
our_pred	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
)	O
{	O
execp	pointer
->	O
replace_vec	pointer
=	O
NULL	O
;	O
execp	pointer
->	O
ctl	pointer
.	O
replace_pat	pointer
=	O
NULL	O
;	O
execp	pointer
->	O
ctl	pointer
.	O
rplen	long
=	O
0	int
;	O
execp	pointer
->	O
ctl	pointer
.	O
lines_per_exec	long
=	O
0	int
;	O
execp	pointer
->	O
ctl	pointer
.	O
args_per_exec	long
=	O
0	int
;	O
execp	pointer
->	O
ctl	pointer
.	O
initial_argc	long
=	O
(	O
end	pointer
-	O
start	pointer
)	O
-	O
1	int
;	O
bc_init_state	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
,	O
execp	pointer
)	O
;	O
for	O
(	O
i	int
=	O
start	pointer
;	O
i	int
<	O
end	pointer
-	O
1	int
;	O
++	O
i	int
)	O
{	O
bc_push_arg	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
,	O
argv	array
[	O
i	int
]	O
,	O
strlen	function
(	O
argv	array
[	O
i	int
]	O
)	O
+	O
1	int
,	O
NULL	O
,	O
0	int
,	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
execp	pointer
->	O
num_args	int
=	O
end	pointer
-	O
start	pointer
;	O
execp	pointer
->	O
ctl	pointer
.	O
replace_pat	pointer
=	O
"{}"	pointer
;	O
execp	pointer
->	O
ctl	pointer
.	O
rplen	long
=	O
strlen	function
(	O
execp	pointer
->	O
ctl	pointer
.	O
replace_pat	pointer
)	O
;	O
execp	pointer
->	O
ctl	pointer
.	O
lines_per_exec	long
=	O
0	int
;	O
execp	pointer
->	O
ctl	pointer
.	O
args_per_exec	long
=	O
0	int
;	O
execp	pointer
->	O
replace_vec	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
execp	pointer
->	O
num_args	int
)	O
;	O
bc_init_state	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
,	O
execp	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
execp	pointer
->	O
num_args	int
;	O
++	O
i	int
)	O
{	O
execp	pointer
->	O
replace_vec	pointer
[	O
i	int
]	O
=	O
argv	array
[	O
i	int
+	O
start	pointer
]	O
;	O
}	O
}	O
if	O
(	O
argv	array
[	O
end	pointer
]	O
==	O
NULL	O
)	O
*	O
arg_ptr	pointer
=	O
end	pointer
;	O
else	O
*	O
arg_ptr	pointer
=	O
end	pointer
+	O
1	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
get_relative_timestamp	function
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
time_val	struct
*	O
result	pointer
,	O
struct	O
timespec	struct
origin	struct
,	O
double	O
sec_per_unit	double
,	O
const	O
char	O
*	O
overflowmessage	pointer
)	O
{	O
double	O
offset	long
,	O
seconds	double
,	O
nanosec	double
;	O
static	O
const	O
long	O
nanosec_per_sec	long
=	O
1000000000	int
;	O
if	O
(	O
get_comp_type	function
(	O
&	O
str	pointer
,	O
&	O
result	pointer
->	O
kind	enum
)	O
)	O
{	O
switch	O
(	O
result	pointer
->	O
kind	enum
)	O
{	O
case	O
COMP_LT	int
:	O
result	pointer
->	O
kind	enum
=	O
COMP_GT	int
;	O
break	O
;	O
case	O
COMP_GT	int
:	O
result	pointer
->	O
kind	enum
=	O
COMP_LT	int
;	O
break	O
;	O
case	O
COMP_EQ	int
:	O
break	O
;	O
}	O
if	O
(	O
xstrtod	function
(	O
str	pointer
,	O
NULL	O
,	O
&	O
offset	long
,	O
strtod	function
)	O
)	O
{	O
nanosec	double
=	O
modf	function
(	O
offset	long
*	O
sec_per_unit	double
,	O
&	O
seconds	double
)	O
;	O
nanosec	double
*=	O
1.0e9	int
;	O
assert	O
(	O
nanosec	double
<	O
nanosec_per_sec	long
)	O
;	O
result	pointer
->	O
ts	struct
.	O
tv_sec	long
=	O
origin	struct
.	O
tv_sec	long
-	O
seconds	double
;	O
if	O
(	O
(	O
origin	struct
.	O
tv_sec	long
<	O
result	pointer
->	O
ts	struct
.	O
tv_sec	long
)	O
!=	O
(	O
seconds	double
<	O
0	int
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
overflowmessage	pointer
,	O
str	pointer
)	O
;	O
}	O
result	pointer
->	O
ts	struct
.	O
tv_nsec	long
=	O
origin	struct
.	O
tv_nsec	long
-	O
nanosec	double
;	O
if	O
(	O
origin	struct
.	O
tv_nsec	long
<	O
nanosec	double
)	O
{	O
result	pointer
->	O
ts	struct
.	O
tv_nsec	long
+=	O
nanosec_per_sec	long
;	O
result	pointer
->	O
ts	struct
.	O
tv_sec	long
-=	O
1	int
;	O
}	O
return	O
true	int
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
parse_time	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
*	O
arg_ptr	pointer
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
struct	O
time_val	struct
tval	pointer
;	O
enum	O
comparison_type	enum
comp	enum
;	O
const	O
char	O
*	O
timearg	pointer
,	O
*	O
orig_timearg	pointer
;	O
const	O
char	O
*	O
errmsg	pointer
=	O
_	O
(	O
"arithmetic overflow while converting %s "	pointer
"days to a number of seconds"	pointer
)	O
;	O
struct	O
timespec	struct
origin	struct
;	O
const	O
int	O
saved_argc	int
=	O
*	O
arg_ptr	pointer
;	O
if	O
(	O
!	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
timearg	pointer
)	O
)	O
return	O
false	int
;	O
orig_timearg	pointer
=	O
timearg	pointer
;	O
origin	struct
=	O
options	struct
.	O
cur_day_start	struct
;	O
if	O
(	O
get_comp_type	function
(	O
&	O
timearg	pointer
,	O
&	O
comp	enum
)	O
)	O
{	O
if	O
(	O
COMP_LT	int
==	O
comp	enum
)	O
{	O
uintmax_t	long
expected	long
=	O
origin	struct
.	O
tv_sec	long
+	O
(	O
DAYSECS	int
-	O
1	int
)	O
;	O
origin	struct
.	O
tv_sec	long
+=	O
(	O
DAYSECS	int
-	O
1	int
)	O
;	O
if	O
(	O
origin	struct
.	O
tv_sec	long
!=	O
expected	long
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"arithmetic overflow when trying to calculate the end of today"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
timearg	pointer
=	O
orig_timearg	pointer
;	O
if	O
(	O
!	O
get_relative_timestamp	function
(	O
timearg	pointer
,	O
&	O
tval	pointer
,	O
origin	struct
,	O
DAYSECS	int
,	O
errmsg	pointer
)	O
)	O
{	O
*	O
arg_ptr	pointer
=	O
saved_argc	int
;	O
return	O
false	int
;	O
}	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
orig_timearg	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
=	O
tval	pointer
;	O
our_pred	pointer
->	O
est_success_rate	float
=	O
estimate_timestamp_success_rate	function
(	O
tval	pointer
.	O
ts	struct
.	O
tv_sec	long
)	O
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugExpressionTree	int
)	O
{	O
time_t	long
t	struct
;	O
fprintf	function
(	O
stderr	pointer
,	O
"inserting %s\n"	pointer
,	O
our_pred	pointer
->	O
p_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"    type: %s    %s  "	pointer
,	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_GT	int
)	O
?	O
"gt"	pointer
:	O
(	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_LT	int
)	O
?	O
"lt"	pointer
:	O
(	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_EQ	int
)	O
?	O
"eq"	pointer
:	O
"?"	pointer
)	O
)	O
,	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_GT	int
)	O
?	O
" >"	pointer
:	O
(	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_LT	int
)	O
?	O
" <"	pointer
:	O
(	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_EQ	int
)	O
?	O
">="	pointer
:	O
" ?"	pointer
)	O
)	O
)	O
;	O
t	struct
=	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
.	O
tv_sec	long
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%ju %s"	pointer
,	O
(	O
uintmax_t	long
)	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
.	O
tv_sec	long
,	O
ctime	function
(	O
&	O
t	struct
)	O
)	O
;	O
if	O
(	O
tval	pointer
.	O
kind	enum
==	O
COMP_EQ	int
)	O
{	O
t	struct
=	O
our_pred	pointer
->	O
args	union
.	O
reftime	struct
.	O
ts	struct
.	O
tv_sec	long
+	O
DAYSECS	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                 <  %ju %s"	pointer
,	O
(	O
uintmax_t	long
)	O
t	struct
,	O
ctime	function
(	O
&	O
t	struct
)	O
)	O
;	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
get_comp_type	function
(	O
const	O
char	O
*	O
*	O
str	pointer
,	O
enum	O
comparison_type	enum
*	O
comp_type	pointer
)	O
{	O
switch	O
(	O
*	O
*	O
str	pointer
)	O
{	O
case	O
'+'	O
:	O
*	O
comp_type	pointer
=	O
COMP_GT	int
;	O
(	O
*	O
str	pointer
)	O
++	O
;	O
break	O
;	O
case	O
'-'	O
:	O
*	O
comp_type	pointer
=	O
COMP_LT	int
;	O
(	O
*	O
str	pointer
)	O
++	O
;	O
break	O
;	O
default	O
:	O
*	O
comp_type	pointer
=	O
COMP_EQ	int
;	O
break	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
get_num	function
(	O
const	O
char	O
*	O
str	pointer
,	O
uintmax_t	long
*	O
num	pointer
,	O
enum	O
comparison_type	enum
*	O
comp_type	pointer
)	O
{	O
char	O
*	O
pend	pointer
;	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
if	O
(	O
comp_type	pointer
)	O
{	O
if	O
(	O
!	O
get_comp_type	function
(	O
&	O
str	pointer
,	O
comp_type	pointer
)	O
)	O
return	O
false	int
;	O
}	O
return	O
xstrtoumax	function
(	O
str	pointer
,	O
&	O
pend	pointer
,	O
10	int
,	O
num	pointer
,	O
""	pointer
)	O
==	O
LONGINT_OK	int
;	O
}	O
static	O
struct	O
predicate	struct
*	O
insert_num	function
(	O
char	O
*	O
*	O
argv	array
,	O
int	O
*	O
arg_ptr	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
)	O
{	O
const	O
char	O
*	O
numstr	pointer
;	O
if	O
(	O
collect_arg	function
(	O
argv	array
,	O
arg_ptr	pointer
,	O
&	O
numstr	pointer
)	O
)	O
{	O
uintmax_t	long
num	pointer
;	O
enum	O
comparison_type	enum
c_type	enum
;	O
if	O
(	O
get_num	function
(	O
numstr	pointer
,	O
&	O
num	pointer
,	O
&	O
c_type	enum
)	O
)	O
{	O
struct	O
predicate	struct
*	O
our_pred	pointer
=	O
insert_primary	function
(	O
entry	pointer
,	O
numstr	pointer
)	O
;	O
our_pred	pointer
->	O
args	union
.	O
numinfo	struct
.	O
kind	enum
=	O
c_type	enum
;	O
our_pred	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
=	O
num	pointer
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugExpressionTree	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"inserting %s\n"	pointer
,	O
our_pred	pointer
->	O
p_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"    type: %s    %s  "	pointer
,	O
(	O
c_type	enum
==	O
COMP_GT	int
)	O
?	O
"gt"	pointer
:	O
(	O
(	O
c_type	enum
==	O
COMP_LT	int
)	O
?	O
"lt"	pointer
:	O
(	O
(	O
c_type	enum
==	O
COMP_EQ	int
)	O
?	O
"eq"	pointer
:	O
"?"	pointer
)	O
)	O
,	O
(	O
c_type	enum
==	O
COMP_GT	int
)	O
?	O
" >"	pointer
:	O
(	O
(	O
c_type	enum
==	O
COMP_LT	int
)	O
?	O
" <"	pointer
:	O
(	O
(	O
c_type	enum
==	O
COMP_EQ	int
)	O
?	O
" ="	pointer
:	O
" ?"	pointer
)	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%ju\n"	pointer
,	O
our_pred	pointer
->	O
args	union
.	O
numinfo	struct
.	O
l_val	long
)	O
;	O
}	O
return	O
our_pred	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
open_output_file	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
format_val	struct
*	O
p	pointer
)	O
{	O
p	pointer
->	O
segment	struct
=	O
NULL	O
;	O
p	pointer
->	O
quote_opts	pointer
=	O
clone_quoting_options	function
(	O
NULL	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
path	pointer
,	O
"/dev/stderr"	pointer
)	O
)	O
{	O
p	pointer
->	O
stream	pointer
=	O
stderr	pointer
;	O
p	pointer
->	O
filename	pointer
=	O
_	O
(	O
"standard error"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
path	pointer
,	O
"/dev/stdout"	pointer
)	O
)	O
{	O
p	pointer
->	O
stream	pointer
=	O
stdout	pointer
;	O
p	pointer
->	O
filename	pointer
=	O
_	O
(	O
"standard output"	pointer
)	O
;	O
}	O
else	O
{	O
p	pointer
->	O
stream	pointer
=	O
sharefile_fopen	function
(	O
state	pointer
.	O
shared_files	pointer
,	O
path	pointer
)	O
;	O
p	pointer
->	O
filename	pointer
=	O
path	pointer
;	O
if	O
(	O
p	pointer
->	O
stream	pointer
==	O
NULL	O
)	O
{	O
fatal_nontarget_file_error	function
(	O
errno	O
,	O
path	pointer
)	O
;	O
}	O
}	O
p	pointer
->	O
dest_is_tty	bool
=	O
stream_is_tty	function
(	O
p	pointer
->	O
stream	pointer
)	O
;	O
}	O
static	O
void	O
open_stdout	function
(	O
struct	O
format_val	struct
*	O
p	pointer
)	O
{	O
open_output_file	function
(	O
"/dev/stdout"	pointer
,	O
p	pointer
)	O
;	O
}	O