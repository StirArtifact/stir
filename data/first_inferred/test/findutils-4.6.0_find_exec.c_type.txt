static	O
bool	bool
initialize_wd_for_exec	function
(	O
struct	O
exec_val	struct
*	O
execp	pointer
,	O
int	O
cwd_fd	int
,	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
execp	pointer
->	O
wd_for_exec	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
execp	pointer
->	O
wd_for_exec	pointer
)	O
)	O
;	O
execp	pointer
->	O
wd_for_exec	pointer
->	O
name	pointer
=	O
NULL	O
;	O
execp	pointer
->	O
wd_for_exec	pointer
->	O
desc	int
=	O
openat	function
(	O
cwd_fd	int
,	O
dir	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
execp	pointer
->	O
wd_for_exec	pointer
->	O
desc	int
<	O
0	int
)	O
return	O
false	int
;	O
set_cloexec_flag	function
(	O
execp	pointer
->	O
wd_for_exec	pointer
->	O
desc	int
,	O
true	int
)	O
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
record_exec_dir	function
(	O
struct	O
exec_val	struct
*	O
execp	pointer
)	O
{	O
if	O
(	O
!	O
execp	pointer
->	O
state	pointer
.	O
todo	int
)	O
{	O
assert	O
(	O
!	O
execp	pointer
->	O
state	pointer
.	O
todo	int
)	O
;	O
if	O
(	O
strchr	function
(	O
state	pointer
.	O
rel_pathname	pointer
,	O
'/'	O
)	O
)	O
{	O
char	O
*	O
dir	pointer
=	O
mdir_name	function
(	O
state	pointer
.	O
rel_pathname	pointer
)	O
;	O
bool	bool
result	pointer
=	O
initialize_wd_for_exec	function
(	O
execp	pointer
,	O
state	pointer
.	O
cwd_dir_fd	int
,	O
dir	pointer
)	O
;	O
free	function
(	O
dir	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
else	O
{	O
return	O
initialize_wd_for_exec	function
(	O
execp	pointer
,	O
state	pointer
.	O
cwd_dir_fd	int
,	O
"."	pointer
)	O
;	O
}	O
}	O
return	O
true	int
;	O
}	O
bool	bool
impl_pred_exec	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
struct	O
stat	struct
*	O
stat_buf	pointer
,	O
struct	O
predicate	struct
*	O
pred_ptr	pointer
)	O
{	O
struct	O
exec_val	struct
*	O
execp	pointer
=	O
&	O
pred_ptr	pointer
->	O
args	union
.	O
exec_vec	struct
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
target	pointer
;	O
bool	bool
result	pointer
;	O
const	O
bool	bool
local	bool
=	O
is_exec_in_local_dir	function
(	O
pred_ptr	pointer
->	O
pred_func	pointer
)	O
;	O
char	O
*	O
prefix	pointer
;	O
size_t	long
pfxlen	long
;	O
(	O
void	O
)	O
stat_buf	pointer
;	O
if	O
(	O
local	bool
)	O
{	O
if	O
(	O
!	O
record_exec_dir	function
(	O
execp	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to save working directory in order to "	pointer
"run a command on %s"	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
pathname	pointer
)	O
)	O
;	O
}	O
target	pointer
=	O
buf	pointer
=	O
base_name	function
(	O
state	pointer
.	O
rel_pathname	pointer
)	O
;	O
if	O
(	O
'/'	O
==	O
target	pointer
[	O
0	int
]	O
)	O
{	O
prefix	pointer
=	O
NULL	O
;	O
pfxlen	long
=	O
0	int
;	O
}	O
else	O
{	O
prefix	pointer
=	O
"./"	pointer
;	O
pfxlen	long
=	O
2u	int
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
execp	pointer
->	O
wd_for_exec	pointer
==	O
initial_wd	pointer
)	O
;	O
target	pointer
=	O
pathname	pointer
;	O
prefix	pointer
=	O
NULL	O
;	O
pfxlen	long
=	O
0u	int
;	O
}	O
if	O
(	O
execp	pointer
->	O
multiple	bool
)	O
{	O
bc_push_arg	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
,	O
target	pointer
,	O
strlen	function
(	O
target	pointer
)	O
+	O
1	int
,	O
prefix	pointer
,	O
pfxlen	long
,	O
0	int
)	O
;	O
if	O
(	O
execp	pointer
->	O
state	pointer
.	O
todo	int
)	O
state	pointer
.	O
execdirs_outstanding	bool
=	O
true	int
;	O
result	pointer
=	O
true	int
;	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
execp	pointer
->	O
num_args	int
;	O
++	O
i	int
)	O
{	O
bc_do_insert	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
,	O
execp	pointer
->	O
replace_vec	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
execp	pointer
->	O
replace_vec	pointer
[	O
i	int
]	O
)	O
,	O
prefix	pointer
,	O
pfxlen	long
,	O
target	pointer
,	O
strlen	function
(	O
target	pointer
)	O
,	O
0	int
)	O
;	O
}	O
bc_do_exec	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
execp	pointer
->	O
last_child_status	int
)	O
)	O
{	O
if	O
(	O
0	int
==	O
WEXITSTATUS	O
(	O
execp	pointer
->	O
last_child_status	int
)	O
)	O
result	pointer
=	O
true	int
;	O
else	O
result	pointer
=	O
false	int
;	O
}	O
else	O
{	O
result	pointer
=	O
false	int
;	O
}	O
if	O
(	O
local	bool
)	O
free_cwd	function
(	O
execp	pointer
->	O
wd_for_exec	pointer
)	O
;	O
}	O
if	O
(	O
buf	pointer
)	O
{	O
assert	O
(	O
local	bool
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
bool	bool
prep_child_for_exec	function
(	O
bool	bool
close_stdin	bool
,	O
const	O
struct	O
saved_cwd	struct
*	O
wd	pointer
)	O
{	O
bool	bool
ok	bool
=	O
true	int
;	O
if	O
(	O
close_stdin	bool
)	O
{	O
const	O
char	O
inputfile	array
[	O
]	O
=	O
"/dev/null"	pointer
;	O
if	O
(	O
close	pointer
(	O
0	int
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot close standard input"	pointer
)	O
)	O
;	O
ok	bool
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
open	function
(	O
inputfile	array
,	O
O_RDONLY	int
|	O
O_LARGEFILE	O
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
inputfile	array
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
0	int
!=	O
restore_cwd	function
(	O
wd	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Failed to change directory%s%s"	pointer
)	O
,	O
(	O
wd	pointer
->	O
desc	int
<	O
0	int
&&	O
wd	pointer
->	O
name	pointer
)	O
?	O
": "	pointer
:	O
""	pointer
,	O
(	O
wd	pointer
->	O
desc	int
<	O
0	int
&&	O
wd	pointer
->	O
name	pointer
)	O
?	O
wd	pointer
->	O
name	pointer
:	O
""	pointer
)	O
;	O
ok	bool
=	O
false	int
;	O
}	O
return	O
ok	bool
;	O
}	O
int	O
launch	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
void	O
*	O
usercontext	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
pid_t	int
child_pid	int
;	O
static	O
int	O
first_time	int
=	O
1	int
;	O
struct	O
exec_val	struct
*	O
execp	pointer
=	O
usercontext	pointer
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
if	O
(	O
first_time	int
)	O
{	O
first_time	int
=	O
0	int
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
}	O
child_pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
child_pid	int
==	O
-	O
1	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot fork"	pointer
)	O
)	O
;	O
if	O
(	O
child_pid	int
==	O
0	int
)	O
{	O
assert	O
(	O
NULL	O
!=	O
execp	pointer
->	O
wd_for_exec	pointer
)	O
;	O
if	O
(	O
!	O
prep_child_for_exec	function
(	O
execp	pointer
->	O
close_stdin	bool
,	O
execp	pointer
->	O
wd_for_exec	pointer
)	O
)	O
{	O
_exit	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fd_leak_check_is_enabled	function
(	O
)	O
)	O
{	O
complain_about_leaky_fds	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
bc_args_exceed_testing_limit	function
(	O
argv	pointer
)	O
)	O
errno	O
=	O
E2BIG	int
;	O
else	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
waitpid	function
(	O
child_pid	int
,	O
&	O
(	O
execp	pointer
->	O
last_child_status	int
)	O
,	O
0	int
)	O
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error waiting for %s"	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
state	pointer
.	O
exit_status	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
WIFSIGNALED	O
(	O
execp	pointer
->	O
last_child_status	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s terminated by signal %d"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
argv	pointer
[	O
0	int
]	O
)	O
,	O
WTERMSIG	O
(	O
execp	pointer
->	O
last_child_status	int
)	O
)	O
;	O
if	O
(	O
execp	pointer
->	O
multiple	bool
)	O
{	O
state	pointer
.	O
exit_status	int
=	O
1	int
;	O
}	O
return	O
1	int
;	O
}	O
if	O
(	O
0	int
==	O
WEXITSTATUS	O
(	O
execp	pointer
->	O
last_child_status	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
execp	pointer
->	O
multiple	bool
)	O
{	O
state	pointer
.	O
exit_status	int
=	O
1	int
;	O
}	O
return	O
1	int
;	O
}	O
}	O