ESint32	int
EDMAPROC	O
EDMA_CIDFParseU32	function
(	O
OBJID	int
obj	int
,	O
CLASSID	long
idc	int
)	O
{	O
CIF_CLASS	struct
*	O
the_class	*
;	O
EChar	char
fn	*
[	O
2048	int
]	O
;	O
EChar	char
namespace	array
[	O
1024	int
]	O
;	O
EPChar	*
path	*
;	O
EChar	char
aux	array
[	O
1024	int
]	O
,	O
sig	*
[	O
1024	int
]	O
,	O
*	O
asig	*
;	O
ESint32	int
i	int
,	O
j	int
,	O
repo_type	int
;	O
path	*
=	O
edma_get_class_repo_dir	function
(	O
idc	int
)	O
;	O
edma_get_class_name	function
(	O
idc	int
,	O
aux	array
)	O
;	O
if	O
(	O
(	O
repo_type	int
=	O
edma_get_class_repo_type	function
(	O
idc	int
)	O
)	O
==	O
0	int
)	O
{	O
edma_get_class_namespace	function
(	O
idc	int
,	O
namespace	*
)	O
;	O
sprintf	function
(	O
fn	*
,	O
"%s/share/edma/idf/%s/%s.cidf"	*
,	O
path	*
,	O
namespace	*
,	O
aux	*
)	O
;	O
}	O
else	O
{	O
char	O
*	O
rn	*
=	O
edma_get_class_repo_name	function
(	O
idc	long
)	O
;	O
edma_get_class_namespace	function
(	O
idc	long
,	O
namespace	*
)	O
;	O
sprintf	function
(	O
fn	*
,	O
"%s/%s/idf/%s/%s.cidf"	*
,	O
path	*
,	O
rn	long
,	O
namespace	*
,	O
aux	*
)	O
;	O
}	O
edma_printf_obj	function
(	O
obj	*
,	O
"Parsing Class %d:'%s': Repo: %d. Parser Object: %d"	*
,	O
idc	int
,	O
aux	*
,	O
repo_type	*
,	O
obj	*
)	O
;	O
edma_printf_obj	function
(	O
obj	*
,	O
"Using IDF file : %s"	*
,	O
fn	*
)	O
;	O
the_class	*
=	O
cidf_parse	function
(	O
fn	*
)	O
;	O
edma_idf_set_def	function
(	O
idc	int
,	O
the_class	*
->	O
n_prop	*
,	O
the_class	*
->	O
n_met	*
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*
->	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_idf_set_prop	function
(	O
idc	int
,	O
i	int
,	O
the_class	*
->	O
prop	*
[	O
i	int
]	O
->	O
name	*
,	O
the_class	*
->	O
prop	*
[	O
i	int
]	O
->	O
type	int
,	O
the_class	*
->	O
prop	*
[	O
i	int
]	O
->	O
access	int
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*
->	O
n_met	int
;	O
i	int
++	O
)	O
{	O
memset	function
(	O
sig	int
,	O
0	int
,	O
1024	int
)	O
;	O
asig	*
=	O
sig	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
n_param	int
;	O
j	int
++	O
)	O
{	O
EUint32	long
type_id	long
;	O
EChar	char
type_sig	array
[	O
256	int
]	O
;	O
type_id	int
=	O
edma_get_type_id	function
(	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
param	*
[	O
j	int
]	O
->	O
type	*
)	O
;	O
memset	function
(	O
type_sig	*
,	O
0	int
,	O
256	int
)	O
;	O
edma_get_type_sig	function
(	O
type_id	*
,	O
type_sig	*
)	O
;	O
asig	int
+=	O
sprintf	function
(	O
asig	*
,	O
"%s"	*
,	O
type_sig	*
)	O
;	O
}	O
{	O
EUint32	long
type_id	long
;	O
EChar	char
type_sig	array
[	O
256	int
]	O
;	O
type_id	int
=	O
edma_get_type_id	function
(	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
rtype	*
)	O
;	O
memset	function
(	O
type_sig	*
,	O
0	int
,	O
256	int
)	O
;	O
edma_get_type_sig	function
(	O
type_id	*
,	O
type_sig	*
)	O
;	O
asig	int
+=	O
sprintf	function
(	O
asig	*
,	O
"r%s"	*
,	O
type_sig	*
)	O
;	O
}	O
printf	function
(	O
"Generated signature is: '%s'\n"	*
,	O
sig	int
)	O
;	O
if	O
(	O
!	O
repo_type	*
)	O
edma_idf_set_met	function
(	O
idc	int
,	O
i	int
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
name	*
,	O
sig	int
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
1	int
]	O
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
0	int
]	O
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
2	int
]	O
)	O
;	O
else	O
edma_idf_set_met	function
(	O
idc	long
,	O
i	long
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
name	*
,	O
""	*
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
1	int
]	O
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
0	int
]	O
,	O
the_class	*
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
2	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*
->	O
n_sc	int
;	O
i	int
++	O
)	O
{	O
edma_add_local_class_superclass_by_name	function
(	O
idc	long
,	O
the_class	*
->	O
sc	*
[	O
i	int
]	O
->	O
name	*
,	O
the_class	*
->	O
sc	*
[	O
i	int
]	O
->	O
ap	*
,	O
the_class	*
->	O
sc	*
[	O
i	int
]	O
->	O
ap1	O
)	O
;	O
}	O
edma_printf_obj	function
(	O
obj	int
,	O
"Registering class %d:%s:%s"	*
,	O
idc	int
,	O
the_class	*
->	O
name	*
,	O
aux	int
)	O
;	O
if	O
(	O
repo_type	int
)	O
edma_idf_set_class_id1	function
(	O
idc	int
)	O
;	O
else	O
edma_idf_set_class_id	function
(	O
idc	long
)	O
;	O
cidf_free_data	function
(	O
the_class	*
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMA_CIDF_class_factory	function
(	O
)	O
{	O
CLASSID	int
cid	int
;	O
cid	int
=	O
edma_idf_get_free_class_id	function
(	O
EDMA_LOCAL_CLASS	int
)	O
;	O
edma_idf_set_class_name	function
(	O
cid	int
,	O
"EDMA_CIDF"	*
)	O
;	O
edma_idf_set_class_namespace	function
(	O
cid	int
,	O
""	*
)	O
;	O
edma_idf_set_class_version	function
(	O
cid	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"Parse"	*
,	O
"U32"	*
,	O
(	O
PPROC	*
)	O
EDMA_CIDFParseU32	function
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_idf_set_class_id	function
(	O
cid	int
)	O
;	O
return	O
0	int
;	O
}	O