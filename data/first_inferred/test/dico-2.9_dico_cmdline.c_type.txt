enum	O
{	O
_OPTION_INIT	int
=	O
255	int
,	O
OPTION_HOST	int
,	O
OPTION_SOURCE	int
,	O
OPTION_LEVDIST	int
,	O
OPTION_SASL	int
,	O
OPTION_NOSASL	int
,	O
OPTION_AUTOLOGIN	int
,	O
OPTION_TIME_STAMP	int
,	O
OPTION_SOURCE_INFO	int
,	O
OPTION_USAGE	int
,	O
MAX_OPTION	int
}	O
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"host"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_HOST	int
}	O
,	O
{	O
"port"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"database"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"source"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SOURCE	int
}	O
,	O
{	O
"match"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"strategy"	pointer
,	O
required_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"levdist"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_LEVDIST	int
}	O
,	O
{	O
"dbs"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"strategies"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"serverhelp"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"info"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"serverinfo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"noauth"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"sasl"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_SASL	int
}	O
,	O
{	O
"nosasl"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_NOSASL	int
}	O
,	O
{	O
"user"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"key"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"autologin"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_AUTOLOGIN	int
}	O
,	O
{	O
"client"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"transcript"	pointer
,	O
no_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"time-stamp"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_TIME_STAMP	int
}	O
,	O
{	O
"source-info"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_SOURCE_INFO	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"usage"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_USAGE	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
struct	O
grecs_opthelp	struct
opthelp	pointer
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Server selection"	pointer
)	O
}	O
,	O
{	O
"--host"	pointer
,	O
N_	O
(	O
"SERVER"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"connect to this server"	pointer
)	O
}	O
,	O
{	O
"-p, --port"	pointer
,	O
N_	O
(	O
"SERVICE"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"specify port to connect to"	pointer
)	O
}	O
,	O
{	O
"-d, --database"	pointer
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"select a database to search"	pointer
)	O
}	O
,	O
{	O
"--source"	pointer
,	O
N_	O
(	O
"ADDR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set a source address for TCP connections"	pointer
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Operation modes"	pointer
)	O
}	O
,	O
{	O
"-m, --match"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"match instead of define"	pointer
)	O
}	O
,	O
{	O
"-s, --strategy"	pointer
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"select a strategy for matching; implies --match"	pointer
)	O
}	O
,	O
{	O
"--levdist"	pointer
,	O
N_	O
(	O
"N"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set maximum Levenshtein distance"	pointer
)	O
}	O
,	O
{	O
"-D, --dbs"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show available databases"	pointer
)	O
}	O
,	O
{	O
"-S, --strategies"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show available search strategies"	pointer
)	O
}	O
,	O
{	O
"-H, --serverhelp"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show server help"	pointer
)	O
}	O
,	O
{	O
"-i, --info"	pointer
,	O
N_	O
(	O
"DBNAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"show information about database DBNAME"	pointer
)	O
}	O
,	O
{	O
"-I, --serverinfo"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show information about the server"	pointer
)	O
}	O
,	O
{	O
"-q, --quiet"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"do not print the normal dico welcome"	pointer
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Authentication"	pointer
)	O
}	O
,	O
{	O
"-a, --noauth"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"disable authentication"	pointer
)	O
}	O
,	O
{	O
"--sasl"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"enable SASL authentication (default)"	pointer
)	O
}	O
,	O
{	O
"--nosasl"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"disable SASL authentication"	pointer
)	O
}	O
,	O
{	O
"-u, --user"	pointer
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set user name for authentication"	pointer
)	O
}	O
,	O
{	O
"-k, --key"	pointer
,	O
N_	O
(	O
"STRING"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set shared secret for authentication"	pointer
)	O
}	O
,	O
{	O
"--autologin"	pointer
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set the name of autologin file to use"	pointer
)	O
}	O
,	O
{	O
"-c, --client"	pointer
,	O
N_	O
(	O
"STRING"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"additional text for client command"	pointer
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Debugging"	pointer
)	O
}	O
,	O
{	O
"-t, --transcript"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"enable session transcript"	pointer
)	O
}	O
,	O
{	O
"-v, --verbose"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"increase debugging verbosity level"	pointer
)	O
}	O
,	O
{	O
"--time-stamp"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"include time stamp in the debugging output"	pointer
)	O
}	O
,	O
{	O
"--source-info"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"include source line information in the debugging output"	pointer
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Other options"	pointer
)	O
}	O
,	O
{	O
"-h, --help"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Give this help list"	pointer
)	O
}	O
,	O
{	O
"--usage"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Give a short usage message"	pointer
)	O
}	O
,	O
{	O
"-V, --version"	pointer
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Print program version"	pointer
)	O
}	O
,	O
}	O
;	O
static	O
struct	O
grecs_proginfo	struct
proginfo	struct
=	O
{	O
"dico"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"GNU dictionary client program"	pointer
)	O
,	O
N_	O
(	O
"[URL-or-WORD]"	pointer
)	O
,	O
opthelp	pointer
,	O
sizeof	O
(	O
opthelp	pointer
)	O
/	O
sizeof	O
(	O
opthelp	pointer
[	O
0	int
]	O
)	O
,	O
NULL	O
,	O
NULL	O
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_VERSION	pointer
,	O
NULL	O
,	O
"2005-2017"	pointer
,	O
"Free Software Foundation, Inc."	pointer
,	O
NULL	O
,	O
"<"	pointer
PACKAGE_BUGREPORT	pointer
">"	pointer
,	O
PACKAGE_URL	pointer
,	O
NULL	O
}	O
;	O
void	O
get_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
,	O
int	O
*	O
index	function
)	O
{	O
{	O
int	O
c	int
;	O
optind	int
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"p:d:ms:DSHi:Iqau:k:c:tvhV"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
exit	function
(	O
EX_USAGE	int
)	O
;	O
case	O
OPTION_HOST	int
:	O
{	O
xdico_assign_string	function
(	O
&	O
dico_url	struct
.	O
host	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
case	O
'p'	O
:	O
{	O
xdico_assign_string	function
(	O
&	O
dico_url	struct
.	O
port	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
case	O
'd'	O
:	O
{	O
xdico_assign_string	function
(	O
&	O
dico_url	struct
.	O
req	struct
.	O
database	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_SOURCE	int
:	O
{	O
source_addr	pointer
=	O
optarg	pointer
;	O
break	O
;	O
}	O
case	O
'm'	O
:	O
{	O
mode	int
=	O
mode_match	int
;	O
break	O
;	O
}	O
case	O
's'	O
:	O
{	O
xdico_assign_string	function
(	O
&	O
dico_url	struct
.	O
req	struct
.	O
strategy	pointer
,	O
optarg	pointer
)	O
;	O
mode	int
=	O
mode_match	int
;	O
break	O
;	O
}	O
case	O
OPTION_LEVDIST	int
:	O
{	O
char	O
*	O
p	pointer
;	O
levenshtein_threshold	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
dico_die	function
(	O
1	int
,	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: invalid number"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
case	O
'D'	O
:	O
{	O
mode	int
=	O
mode_dbs	int
;	O
break	O
;	O
}	O
case	O
'S'	O
:	O
{	O
mode	int
=	O
mode_strats	int
;	O
break	O
;	O
}	O
case	O
'H'	O
:	O
{	O
mode	int
=	O
mode_help	int
;	O
break	O
;	O
}	O
case	O
'i'	O
:	O
{	O
mode	int
=	O
mode_info	int
;	O
dico_url	struct
.	O
req	struct
.	O
database	pointer
=	O
optarg	pointer
;	O
break	O
;	O
}	O
case	O
'I'	O
:	O
{	O
mode	int
=	O
mode_server	int
;	O
break	O
;	O
}	O
case	O
'q'	O
:	O
{	O
quiet_option	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
'a'	O
:	O
{	O
noauth_option	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
OPTION_SASL	int
:	O
{	O
sasl_enable	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_NOSASL	int
:	O
{	O
sasl_enable	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
'u'	O
:	O
{	O
default_cred	struct
.	O
user	pointer
=	O
optarg	pointer
;	O
break	O
;	O
}	O
case	O
'k'	O
:	O
{	O
default_cred	struct
.	O
pass	pointer
=	O
optarg	pointer
;	O
break	O
;	O
}	O
case	O
OPTION_AUTOLOGIN	int
:	O
{	O
autologin_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
}	O
case	O
'c'	O
:	O
{	O
client	pointer
=	O
optarg	pointer
;	O
break	O
;	O
}	O
case	O
't'	O
:	O
{	O
transcript	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
'v'	O
:	O
{	O
debug_level	int
++	O
;	O
break	O
;	O
}	O
case	O
OPTION_TIME_STAMP	int
:	O
{	O
int	O
n	long
=	O
1	int
;	O
dico_stream_ioctl	function
(	O
debug_stream	pointer
,	O
DICO_DBG_CTL_SET_TS	int
,	O
&	O
n	long
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_SOURCE_INFO	int
:	O
{	O
debug_source_info	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
'h'	O
:	O
{	O
grecs_print_help	function
(	O
&	O
proginfo	struct
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_USAGE	int
:	O
{	O
grecs_print_usage	function
(	O
&	O
proginfo	struct
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
'V'	O
:	O
{	O
grecs_print_version	function
(	O
&	O
proginfo	struct
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
*	O
index	function
=	O
optind	int
;	O
}	O
}	O
static	O
char	O
gplv3_text	array
[	O
]	O
=	O
"   GNU Dico is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   GNU Dico is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GNU Dico.  If not, see <http://www.gnu.org/licenses/>.\n"	pointer
;	O
void	O
ds_warranty	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
grecs_print_version_only	function
(	O
&	O
proginfo	struct
,	O
stdout	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
gplv3_text	array
)	O
;	O
}	O
void	O
shell_banner	function
(	O
)	O
{	O
grecs_print_version	function
(	O
&	O
proginfo	struct
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
"%s\n\n"	pointer
,	O
_	O
(	O
"Type ? for help summary"	pointer
)	O
)	O
;	O
}	O