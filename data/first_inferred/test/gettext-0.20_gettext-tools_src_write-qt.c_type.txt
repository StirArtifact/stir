static	O
inline	O
void	O
write_u8	function
(	O
FILE	struct
*	O
output_file	pointer
,	O
unsigned	O
char	O
value	pointer
)	O
{	O
putc	function
(	O
value	pointer
,	O
output_file	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
write_u16	function
(	O
FILE	struct
*	O
output_file	pointer
,	O
unsigned	O
short	O
value	pointer
)	O
{	O
unsigned	O
char	O
data	pointer
[	O
2	int
]	O
;	O
data	pointer
[	O
0	int
]	O
=	O
(	O
value	pointer
>>	O
8	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
1	int
]	O
=	O
value	pointer
&	O
0xff	int
;	O
fwrite	function
(	O
data	pointer
,	O
2	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
write_u32	function
(	O
FILE	struct
*	O
output_file	pointer
,	O
unsigned	O
int	O
value	pointer
)	O
{	O
unsigned	O
char	O
data	pointer
[	O
4	int
]	O
;	O
data	pointer
[	O
0	int
]	O
=	O
(	O
value	pointer
>>	O
24	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
1	int
]	O
=	O
(	O
value	pointer
>>	O
16	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
2	int
]	O
=	O
(	O
value	pointer
>>	O
8	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
3	int
]	O
=	O
value	pointer
&	O
0xff	int
;	O
fwrite	function
(	O
data	pointer
,	O
4	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
}	O
static	O
void	O
append_u8	function
(	O
struct	O
obstack	struct
*	O
mempool	pointer
,	O
unsigned	O
char	O
value	pointer
)	O
{	O
unsigned	O
char	O
data	pointer
[	O
1	int
]	O
;	O
data	pointer
[	O
0	int
]	O
=	O
value	pointer
;	O
obstack_grow	O
(	O
mempool	pointer
,	O
data	pointer
,	O
1	int
)	O
;	O
}	O
static	O
void	O
append_u16	function
(	O
struct	O
obstack	struct
*	O
mempool	pointer
,	O
unsigned	O
short	O
value	pointer
)	O
{	O
unsigned	O
char	O
data	pointer
[	O
2	int
]	O
;	O
data	pointer
[	O
0	int
]	O
=	O
(	O
value	pointer
>>	O
8	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
1	int
]	O
=	O
value	pointer
&	O
0xff	int
;	O
obstack_grow	O
(	O
mempool	pointer
,	O
data	pointer
,	O
2	int
)	O
;	O
}	O
static	O
void	O
append_u32	function
(	O
struct	O
obstack	struct
*	O
mempool	pointer
,	O
unsigned	O
int	O
value	pointer
)	O
{	O
unsigned	O
char	O
data	pointer
[	O
4	int
]	O
;	O
data	pointer
[	O
0	int
]	O
=	O
(	O
value	pointer
>>	O
24	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
1	int
]	O
=	O
(	O
value	pointer
>>	O
16	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
2	int
]	O
=	O
(	O
value	pointer
>>	O
8	int
)	O
&	O
0xff	int
;	O
data	pointer
[	O
3	int
]	O
=	O
value	pointer
&	O
0xff	int
;	O
obstack_grow	O
(	O
mempool	pointer
,	O
data	pointer
,	O
4	int
)	O
;	O
}	O
static	O
void	O
append_base_string	function
(	O
struct	O
obstack	struct
*	O
mempool	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
;	O
append_u32	function
(	O
mempool	pointer
,	O
length	long
)	O
;	O
obstack_grow	O
(	O
mempool	pointer
,	O
string	pointer
,	O
length	long
)	O
;	O
}	O
static	O
void	O
append_unicode_string	function
(	O
struct	O
obstack	struct
*	O
mempool	pointer
,	O
const	O
unsigned	O
short	O
*	O
string	pointer
,	O
size_t	long
length	long
)	O
{	O
append_u32	function
(	O
mempool	pointer
,	O
length	long
*	O
2	int
)	O
;	O
for	O
(	O
;	O
length	long
>	O
0	int
;	O
string	pointer
++	O
,	O
length	long
--	O
)	O
append_u16	function
(	O
mempool	pointer
,	O
*	O
string	pointer
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
peek_u32	function
(	O
const	O
unsigned	O
char	O
*	O
p	pointer
)	O
{	O
return	O
(	O
p	pointer
[	O
0	int
]	O
<<	O
24	int
)	O
|	O
(	O
p	pointer
[	O
1	int
]	O
<<	O
16	int
)	O
|	O
(	O
p	pointer
[	O
2	int
]	O
<<	O
8	int
)	O
|	O
p	pointer
[	O
3	int
]	O
;	O
}	O
static	O
char	O
*	O
conv_to_iso_8859_1	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
string	pointer
)	O
;	O
const	O
char	O
*	O
str	pointer
=	O
string	pointer
;	O
const	O
char	O
*	O
str_limit	pointer
=	O
string	pointer
+	O
length	long
;	O
char	O
*	O
result	pointer
=	O
XNMALLOC	O
(	O
length	long
+	O
1	int
,	O
char	O
)	O
;	O
char	O
*	O
q	pointer
=	O
result	pointer
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
ucs4_t	int
uc	int
;	O
str	pointer
+=	O
u8_mbtouc	function
(	O
&	O
uc	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
str_limit	pointer
-	O
str	pointer
)	O
;	O
if	O
(	O
!	O
(	O
uc	int
<	O
0x100	int
)	O
)	O
abort	function
(	O
)	O
;	O
*	O
q	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
uc	int
;	O
}	O
*	O
q	pointer
=	O
'\0'	O
;	O
assert	O
(	O
q	pointer
-	O
result	pointer
<=	O
length	long
)	O
;	O
return	O
result	pointer
;	O
}	O
static	O
unsigned	O
short	O
*	O
conv_to_utf16	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
*	O
sizep	pointer
)	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
string	pointer
)	O
;	O
const	O
char	O
*	O
str	pointer
=	O
string	pointer
;	O
const	O
char	O
*	O
str_limit	pointer
=	O
string	pointer
+	O
length	long
;	O
unsigned	O
short	O
*	O
result	pointer
=	O
XNMALLOC	O
(	O
length	long
,	O
unsigned	O
short	O
)	O
;	O
unsigned	O
short	O
*	O
q	pointer
=	O
result	pointer
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
ucs4_t	int
uc	int
;	O
str	pointer
+=	O
u8_mbtouc	function
(	O
&	O
uc	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
str_limit	pointer
-	O
str	pointer
)	O
;	O
if	O
(	O
uc	int
<	O
0x10000	int
)	O
*	O
q	pointer
++	O
=	O
(	O
unsigned	O
short	O
)	O
uc	int
;	O
else	O
{	O
*	O
q	pointer
++	O
=	O
0xd800	int
+	O
(	O
(	O
uc	int
-	O
0x10000	int
)	O
>>	O
10	int
)	O
;	O
*	O
q	pointer
++	O
=	O
0xdc00	int
+	O
(	O
(	O
uc	int
-	O
0x10000	int
)	O
&	O
0x3ff	int
)	O
;	O
}	O
}	O
assert	O
(	O
q	pointer
-	O
result	pointer
<=	O
2	int
*	O
length	long
)	O
;	O
*	O
sizep	pointer
=	O
q	pointer
-	O
result	pointer
;	O
return	O
result	pointer
;	O
}	O
static	O
unsigned	O
int	O
string_hashcode	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
unsigned	O
int	O
h	int
;	O
h	int
=	O
hash_string	function
(	O
str	pointer
)	O
;	O
if	O
(	O
h	int
==	O
0	int
)	O
h	int
=	O
1	int
;	O
return	O
h	int
;	O
}	O
static	O
int	O
cmp_hashes	function
(	O
const	O
void	O
*	O
va	pointer
,	O
const	O
void	O
*	O
vb	pointer
)	O
{	O
const	O
unsigned	O
char	O
*	O
a	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
va	pointer
;	O
const	O
unsigned	O
char	O
*	O
b	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
vb	pointer
;	O
unsigned	O
int	O
a_hashcode	int
=	O
peek_u32	function
(	O
a	pointer
)	O
;	O
unsigned	O
int	O
b_hashcode	int
=	O
peek_u32	function
(	O
b	pointer
)	O
;	O
if	O
(	O
a_hashcode	int
!=	O
b_hashcode	int
)	O
return	O
(	O
a_hashcode	int
>=	O
b_hashcode	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
else	O
{	O
unsigned	O
int	O
a_offset	int
=	O
peek_u32	function
(	O
a	pointer
+	O
4	int
)	O
;	O
unsigned	O
int	O
b_offset	int
=	O
peek_u32	function
(	O
b	pointer
+	O
4	int
)	O
;	O
if	O
(	O
a_offset	int
!=	O
b_offset	int
)	O
return	O
(	O
a_offset	int
>=	O
b_offset	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
write_section	function
(	O
FILE	struct
*	O
output_file	pointer
,	O
unsigned	O
char	O
tag	char
,	O
void	O
*	O
data	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
>	O
0	int
)	O
{	O
write_u8	function
(	O
output_file	pointer
,	O
tag	char
)	O
;	O
write_u32	function
(	O
output_file	pointer
,	O
size	long
)	O
;	O
fwrite	function
(	O
data	pointer
,	O
size	long
,	O
1	int
,	O
output_file	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_qm	function
(	O
FILE	struct
*	O
output_file	pointer
,	O
message_list_ty	struct
*	O
mlp	pointer
)	O
{	O
static	O
unsigned	O
char	O
magic	array
[	O
16	int
]	O
=	O
{	O
0x3C	int
,	O
0xB8	int
,	O
0x64	int
,	O
0x18	int
,	O
0xCA	int
,	O
0xEF	int
,	O
0x9C	int
,	O
0x95	int
,	O
0xCD	int
,	O
0x21	int
,	O
0x1C	int
,	O
0xBF	int
,	O
0x60	int
,	O
0xA1	int
,	O
0xBD	int
,	O
0xDD	int
}	O
;	O
struct	O
obstack	struct
hashes_pool	struct
;	O
struct	O
obstack	struct
messages_pool	struct
;	O
size_t	long
j	long
;	O
obstack_init	O
(	O
&	O
hashes_pool	struct
)	O
;	O
obstack_init	O
(	O
&	O
messages_pool	struct
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
{	O
char	O
*	O
msgctxt_as_iso_8859_1	pointer
=	O
conv_to_iso_8859_1	function
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
?	O
mp	pointer
->	O
msgctxt	pointer
:	O
""	pointer
)	O
;	O
char	O
*	O
msgid_as_iso_8859_1	pointer
=	O
conv_to_iso_8859_1	function
(	O
mp	pointer
->	O
msgid	pointer
)	O
;	O
size_t	long
msgstr_len	long
;	O
unsigned	O
short	O
*	O
msgstr_as_utf16	pointer
=	O
conv_to_utf16	function
(	O
mp	pointer
->	O
msgstr	pointer
,	O
&	O
msgstr_len	long
)	O
;	O
unsigned	O
int	O
hashcode	int
=	O
string_hashcode	function
(	O
msgid_as_iso_8859_1	pointer
)	O
;	O
unsigned	O
int	O
offset	int
=	O
obstack_object_size	O
(	O
&	O
messages_pool	struct
)	O
;	O
append_u32	function
(	O
&	O
hashes_pool	struct
,	O
hashcode	int
)	O
;	O
append_u32	function
(	O
&	O
hashes_pool	struct
,	O
offset	int
)	O
;	O
append_u8	function
(	O
&	O
messages_pool	struct
,	O
0x03	int
)	O
;	O
append_unicode_string	function
(	O
&	O
messages_pool	struct
,	O
msgstr_as_utf16	pointer
,	O
msgstr_len	long
)	O
;	O
append_u8	function
(	O
&	O
messages_pool	struct
,	O
0x08	int
)	O
;	O
append_base_string	function
(	O
&	O
messages_pool	struct
,	O
""	pointer
)	O
;	O
append_u8	function
(	O
&	O
messages_pool	struct
,	O
0x06	int
)	O
;	O
append_base_string	function
(	O
&	O
messages_pool	struct
,	O
msgid_as_iso_8859_1	pointer
)	O
;	O
append_u8	function
(	O
&	O
messages_pool	struct
,	O
0x07	int
)	O
;	O
append_base_string	function
(	O
&	O
messages_pool	struct
,	O
msgctxt_as_iso_8859_1	pointer
)	O
;	O
append_u8	function
(	O
&	O
messages_pool	struct
,	O
0x05	int
)	O
;	O
append_u32	function
(	O
&	O
messages_pool	struct
,	O
hashcode	int
)	O
;	O
append_u8	function
(	O
&	O
messages_pool	struct
,	O
0x01	int
)	O
;	O
free	function
(	O
msgstr_as_utf16	pointer
)	O
;	O
free	function
(	O
msgid_as_iso_8859_1	pointer
)	O
;	O
free	function
(	O
msgctxt_as_iso_8859_1	pointer
)	O
;	O
}	O
}	O
{	O
size_t	long
nstrings	long
=	O
obstack_object_size	O
(	O
&	O
hashes_pool	struct
)	O
/	O
8	int
;	O
if	O
(	O
nstrings	long
>	O
0	int
)	O
qsort	function
(	O
obstack_base	O
(	O
&	O
hashes_pool	struct
)	O
,	O
nstrings	long
,	O
8	int
,	O
cmp_hashes	function
)	O
;	O
}	O
fwrite	function
(	O
magic	array
,	O
sizeof	O
(	O
magic	array
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
write_section	function
(	O
output_file	pointer
,	O
0x42	int
,	O
obstack_base	O
(	O
&	O
hashes_pool	struct
)	O
,	O
obstack_object_size	O
(	O
&	O
hashes_pool	struct
)	O
)	O
;	O
write_section	function
(	O
output_file	pointer
,	O
0x69	int
,	O
obstack_base	O
(	O
&	O
messages_pool	struct
)	O
,	O
obstack_object_size	O
(	O
&	O
messages_pool	struct
)	O
)	O
;	O
{	O
bool	bool
can_write_contexts	bool
=	O
true	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
if	O
(	O
mp	pointer
->	O
msgctxt	pointer
==	O
NULL	O
||	O
mp	pointer
->	O
msgctxt	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
strlen	function
(	O
mp	pointer
->	O
msgctxt	pointer
)	O
>	O
255	int
)	O
{	O
can_write_contexts	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
can_write_contexts	bool
)	O
{	O
hash_table	struct
all_contexts	struct
;	O
size_t	long
num_contexts	long
;	O
unsigned	O
long	O
table_size	long
;	O
hash_init	function
(	O
&	O
all_contexts	struct
,	O
10	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
hash_insert_entry	function
(	O
&	O
all_contexts	struct
,	O
mp	pointer
->	O
msgctxt	pointer
,	O
strlen	function
(	O
mp	pointer
->	O
msgctxt	pointer
)	O
+	O
1	int
,	O
NULL	O
)	O
;	O
}	O
num_contexts	long
=	O
all_contexts	struct
.	O
size	long
;	O
table_size	long
=	O
next_prime	function
(	O
num_contexts	long
*	O
1.7	int
)	O
;	O
if	O
(	O
table_size	long
>=	O
0x10000	int
)	O
table_size	long
=	O
65521	int
;	O
{	O
struct	O
list_cell	struct
{	O
const	O
char	O
*	O
context	pointer
;	O
struct	O
list_cell	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
list_cell	struct
*	O
list_memory	pointer
=	O
XNMALLOC	O
(	O
table_size	long
,	O
struct	O
list_cell	struct
)	O
;	O
struct	O
list_cell	struct
*	O
freelist	pointer
;	O
struct	O
bucket	struct
{	O
struct	O
list_cell	struct
*	O
head	pointer
;	O
struct	O
list_cell	struct
*	O
*	O
tail	pointer
;	O
}	O
;	O
struct	O
bucket	struct
*	O
buckets	pointer
=	O
XNMALLOC	O
(	O
table_size	long
,	O
struct	O
bucket	struct
)	O
;	O
size_t	long
i	long
;	O
freelist	pointer
=	O
list_memory	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
table_size	long
;	O
i	long
++	O
)	O
{	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
=	O
NULL	O
;	O
buckets	pointer
[	O
i	long
]	O
.	O
tail	pointer
=	O
&	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
;	O
}	O
{	O
void	O
*	O
iter	pointer
;	O
const	O
void	O
*	O
key	pointer
;	O
size_t	long
keylen	long
;	O
void	O
*	O
null	pointer
;	O
iter	pointer
=	O
NULL	O
;	O
while	O
(	O
hash_iterate	function
(	O
&	O
all_contexts	struct
,	O
&	O
iter	pointer
,	O
&	O
key	pointer
,	O
&	O
keylen	long
,	O
&	O
null	pointer
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
context	pointer
=	O
(	O
const	O
char	O
*	O
)	O
key	pointer
;	O
i	long
=	O
string_hashcode	function
(	O
context	pointer
)	O
%	O
table_size	long
;	O
freelist	pointer
->	O
context	pointer
=	O
context	pointer
;	O
freelist	pointer
->	O
next	pointer
=	O
NULL	O
;	O
*	O
buckets	pointer
[	O
i	long
]	O
.	O
tail	pointer
=	O
freelist	pointer
;	O
buckets	pointer
[	O
i	long
]	O
.	O
tail	pointer
=	O
&	O
freelist	pointer
->	O
next	pointer
;	O
freelist	pointer
++	O
;	O
}	O
}	O
{	O
size_t	long
pool_size	long
;	O
pool_size	long
=	O
2	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
const	O
struct	O
list_cell	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
pool_size	long
+=	O
1	int
+	O
strlen	function
(	O
p	pointer
->	O
context	pointer
)	O
;	O
pool_size	long
++	O
;	O
if	O
(	O
(	O
pool_size	long
%	O
2	int
)	O
!=	O
0	int
)	O
pool_size	long
++	O
;	O
}	O
if	O
(	O
pool_size	long
<=	O
0x20000	int
)	O
{	O
struct	O
obstack	struct
contexts_pool	struct
;	O
size_t	long
pool_offset	long
;	O
obstack_init	O
(	O
&	O
contexts_pool	struct
)	O
;	O
append_u16	function
(	O
&	O
contexts_pool	struct
,	O
table_size	long
)	O
;	O
pool_offset	long
=	O
2	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
const	O
struct	O
list_cell	struct
*	O
p	pointer
;	O
append_u16	function
(	O
&	O
contexts_pool	struct
,	O
pool_offset	long
/	O
2	int
)	O
;	O
for	O
(	O
p	pointer
=	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
pool_offset	long
+=	O
1	int
+	O
strlen	function
(	O
p	pointer
->	O
context	pointer
)	O
;	O
pool_offset	long
++	O
;	O
if	O
(	O
(	O
pool_offset	long
%	O
2	int
)	O
!=	O
0	int
)	O
pool_offset	long
++	O
;	O
}	O
else	O
append_u16	function
(	O
&	O
contexts_pool	struct
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
pool_offset	long
==	O
pool_size	long
)	O
)	O
abort	function
(	O
)	O
;	O
append_u16	function
(	O
&	O
contexts_pool	struct
,	O
0	int
)	O
;	O
pool_offset	long
=	O
2	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
!=	O
NULL	O
)	O
{	O
const	O
struct	O
list_cell	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
buckets	pointer
[	O
i	long
]	O
.	O
head	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
append_u8	function
(	O
&	O
contexts_pool	struct
,	O
strlen	function
(	O
p	pointer
->	O
context	pointer
)	O
)	O
;	O
obstack_grow	O
(	O
&	O
contexts_pool	struct
,	O
p	pointer
->	O
context	pointer
,	O
strlen	function
(	O
p	pointer
->	O
context	pointer
)	O
)	O
;	O
pool_offset	long
+=	O
1	int
+	O
strlen	function
(	O
p	pointer
->	O
context	pointer
)	O
;	O
}	O
append_u8	function
(	O
&	O
contexts_pool	struct
,	O
0	int
)	O
;	O
pool_offset	long
++	O
;	O
if	O
(	O
(	O
pool_offset	long
%	O
2	int
)	O
!=	O
0	int
)	O
{	O
append_u8	function
(	O
&	O
contexts_pool	struct
,	O
0	int
)	O
;	O
pool_offset	long
++	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
pool_offset	long
==	O
pool_size	long
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
obstack_object_size	O
(	O
&	O
contexts_pool	struct
)	O
==	O
2	int
+	O
2	int
*	O
table_size	long
+	O
pool_size	long
)	O
)	O
abort	function
(	O
)	O
;	O
write_section	function
(	O
output_file	pointer
,	O
0x2f	int
,	O
obstack_base	O
(	O
&	O
contexts_pool	struct
)	O
,	O
obstack_object_size	O
(	O
&	O
contexts_pool	struct
)	O
)	O
;	O
obstack_free	O
(	O
&	O
contexts_pool	struct
,	O
NULL	O
)	O
;	O
}	O
}	O
free	function
(	O
buckets	pointer
)	O
;	O
free	function
(	O
list_memory	pointer
)	O
;	O
}	O
hash_destroy	function
(	O
&	O
all_contexts	struct
)	O
;	O
}	O
}	O
obstack_free	O
(	O
&	O
messages_pool	struct
,	O
NULL	O
)	O
;	O
obstack_free	O
(	O
&	O
hashes_pool	struct
,	O
NULL	O
)	O
;	O
}	O
int	O
msgdomain_write_qt	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
const	O
char	O
*	O
canon_encoding	pointer
,	O
const	O
char	O
*	O
domain_name	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
FILE	struct
*	O
output_file	pointer
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
!=	O
0	int
)	O
{	O
{	O
bool	bool
has_plural	bool
;	O
size_t	long
j	long
;	O
has_plural	bool
=	O
false	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
has_plural	bool
=	O
true	int
;	O
if	O
(	O
has_plural	bool
)	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"message catalog has plural form translations\nbut the Qt message catalog format doesn't support plural handling\n"	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
iconv_message_list	function
(	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
po_charset_utf8	pointer
,	O
NULL	O
)	O
;	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
const	O
char	O
*	O
string	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgctxt	pointer
;	O
if	O
(	O
string	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
;	O
*	O
string	pointer
;	O
string	pointer
++	O
)	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
string	pointer
>=	O
0xc4	int
)	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"message catalog has msgctxt strings containing characters outside ISO-8859-1\nbut the Qt message catalog format supports Unicode only in the translated\nstrings, not in the context strings\n"	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
const	O
char	O
*	O
string	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid	pointer
;	O
for	O
(	O
;	O
*	O
string	pointer
;	O
string	pointer
++	O
)	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
string	pointer
>=	O
0xc4	int
)	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"message catalog has msgid strings containing characters outside ISO-8859-1\nbut the Qt message catalog format supports Unicode only in the translated\nstrings, not in the untranslated strings\n"	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
message_list_delete_header_field	function
(	O
mlp	pointer
,	O
"POT-Creation-Date:"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
domain_name	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
output_file	pointer
=	O
stdout	pointer
;	O
SET_BINARY	O
(	O
fileno	function
(	O
output_file	pointer
)	O
)	O
;	O
}	O
else	O
{	O
output_file	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
output_file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error while opening \"%s\" for writing"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
output_file	pointer
!=	O
NULL	O
)	O
{	O
write_qm	function
(	O
output_file	pointer
,	O
mlp	pointer
)	O
;	O
if	O
(	O
fwriteerror	function
(	O
output_file	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error while writing \"%s\" file"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O