static	O
bfd_boolean	int
make_a_section_from_file	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
internal_scnhdr	struct
*	O
hdr	pointer
,	O
unsigned	O
int	O
target_index	int
)	O
{	O
asection	struct
*	O
return_section	pointer
;	O
char	O
*	O
name	pointer
;	O
bfd_boolean	int
result	int
=	O
TRUE	int
;	O
flagword	int
flags	int
;	O
name	pointer
=	O
NULL	O
;	O
if	O
(	O
bfd_coff_set_long_section_names	O
(	O
abfd	pointer
,	O
bfd_coff_long_section_names	O
(	O
abfd	pointer
)	O
)	O
&&	O
hdr	pointer
->	O
s_name	array
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
char	O
buf	pointer
[	O
SCNNMLEN	O
]	O
;	O
long	O
strindex	long
;	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
strings	pointer
;	O
bfd_coff_set_long_section_names	O
(	O
abfd	pointer
,	O
TRUE	int
)	O
;	O
memcpy	function
(	O
buf	pointer
,	O
hdr	pointer
->	O
s_name	array
+	O
1	int
,	O
SCNNMLEN	O
-	O
1	int
)	O
;	O
buf	pointer
[	O
SCNNMLEN	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
strindex	long
=	O
strtol	function
(	O
buf	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
&&	O
strindex	long
>=	O
0	int
)	O
{	O
strings	pointer
=	O
_bfd_coff_read_string_table	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
strings	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
(	O
strindex	long
+	O
2	int
)	O
>=	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
strings	pointer
+=	O
strindex	long
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
strlen	function
(	O
strings	pointer
)	O
+	O
1	int
+	O
1	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
strcpy	function
(	O
name	pointer
,	O
strings	pointer
)	O
;	O
}	O
}	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
sizeof	O
(	O
hdr	pointer
->	O
s_name	array
)	O
+	O
1	int
+	O
1	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
strncpy	function
(	O
name	pointer
,	O
(	O
char	O
*	O
)	O
&	O
hdr	pointer
->	O
s_name	array
[	O
0	int
]	O
,	O
sizeof	O
(	O
hdr	pointer
->	O
s_name	array
)	O
)	O
;	O
name	pointer
[	O
sizeof	O
(	O
hdr	pointer
->	O
s_name	array
)	O
]	O
=	O
0	int
;	O
}	O
return_section	pointer
=	O
bfd_make_section_anyway	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
return_section	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
return_section	pointer
->	O
vma	long
=	O
hdr	pointer
->	O
s_vaddr	long
;	O
return_section	pointer
->	O
lma	long
=	O
hdr	pointer
->	O
s_paddr	long
;	O
return_section	pointer
->	O
size	long
=	O
hdr	pointer
->	O
s_size	long
;	O
return_section	pointer
->	O
filepos	long
=	O
hdr	pointer
->	O
s_scnptr	long
;	O
return_section	pointer
->	O
rel_filepos	long
=	O
hdr	pointer
->	O
s_relptr	long
;	O
return_section	pointer
->	O
reloc_count	int
=	O
hdr	pointer
->	O
s_nreloc	long
;	O
bfd_coff_set_alignment_hook	O
(	O
abfd	pointer
,	O
return_section	pointer
,	O
hdr	pointer
)	O
;	O
return_section	pointer
->	O
line_filepos	long
=	O
hdr	pointer
->	O
s_lnnoptr	long
;	O
return_section	pointer
->	O
lineno_count	int
=	O
hdr	pointer
->	O
s_nlnno	long
;	O
return_section	pointer
->	O
userdata	pointer
=	O
NULL	O
;	O
return_section	pointer
->	O
next	pointer
=	O
NULL	O
;	O
return_section	pointer
->	O
target_index	int
=	O
target_index	int
;	O
if	O
(	O
!	O
bfd_coff_styp_to_sec_flags_hook	O
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
return_section	pointer
,	O
&	O
flags	int
)	O
)	O
result	int
=	O
FALSE	int
;	O
return_section	pointer
->	O
flags	int
=	O
flags	int
;	O
if	O
(	O
(	O
return_section	pointer
->	O
flags	int
&	O
SEC_COFF_SHARED_LIBRARY	int
)	O
!=	O
0	int
)	O
return_section	pointer
->	O
lineno_count	int
=	O
0	int
;	O
if	O
(	O
hdr	pointer
->	O
s_nreloc	long
!=	O
0	int
)	O
return_section	pointer
->	O
flags	int
|=	O
SEC_RELOC	int
;	O
if	O
(	O
hdr	pointer
->	O
s_scnptr	long
!=	O
0	int
)	O
return_section	pointer
->	O
flags	int
|=	O
SEC_HAS_CONTENTS	int
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
&&	O
strlen	function
(	O
name	pointer
)	O
>	O
7	int
&&	O
(	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'd'	O
&&	O
name	pointer
[	O
6	int
]	O
==	O
'_'	O
)	O
||	O
(	O
strlen	function
(	O
name	pointer
)	O
>	O
8	int
&&	O
name	pointer
[	O
1	int
]	O
==	O
'z'	O
&&	O
name	pointer
[	O
7	int
]	O
==	O
'_'	O
)	O
)	O
)	O
{	O
enum	O
{	O
nothing	int
,	O
compress	int
,	O
decompress	int
}	O
action	enum
=	O
nothing	int
;	O
char	O
*	O
new_name	pointer
=	O
NULL	O
;	O
if	O
(	O
bfd_is_section_compressed	function
(	O
abfd	pointer
,	O
return_section	pointer
)	O
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_DECOMPRESS	int
)	O
)	O
action	enum
=	O
decompress	int
;	O
}	O
else	O
if	O
(	O
!	O
bfd_is_section_compressed	function
(	O
abfd	pointer
,	O
return_section	pointer
)	O
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS	int
)	O
&&	O
return_section	pointer
->	O
size	long
!=	O
0	int
)	O
action	enum
=	O
compress	int
;	O
}	O
switch	O
(	O
action	enum
)	O
{	O
case	O
nothing	int
:	O
break	O
;	O
case	O
compress	int
:	O
if	O
(	O
!	O
bfd_init_section_compress_status	function
(	O
abfd	pointer
,	O
return_section	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to initialize compress status for section %s"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
return_section	pointer
->	O
compress_status	int
==	O
COMPRESS_SECTION_DONE	int
)	O
{	O
if	O
(	O
name	pointer
[	O
1	int
]	O
!=	O
'z'	O
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
new_name	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
+	O
2	int
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
new_name	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
new_name	pointer
[	O
1	int
]	O
=	O
'z'	O
;	O
memcpy	function
(	O
new_name	pointer
+	O
2	int
,	O
name	pointer
+	O
1	int
,	O
len	long
)	O
;	O
}	O
}	O
break	O
;	O
case	O
decompress	int
:	O
if	O
(	O
!	O
bfd_init_section_decompress_status	function
(	O
abfd	pointer
,	O
return_section	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unable to initialize decompress status for section %s"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'z'	O
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
new_name	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
len	long
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
new_name	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
memcpy	function
(	O
new_name	pointer
+	O
1	int
,	O
name	pointer
+	O
2	int
,	O
len	long
-	O
1	int
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
new_name	pointer
!=	O
NULL	O
)	O
bfd_rename_section	function
(	O
return_section	pointer
,	O
new_name	pointer
)	O
;	O
}	O
return	O
result	int
;	O
}	O
const	O
bfd_target	struct
*	O
coff_real_object_p	function
(	O
bfd	struct
*	O
,	O
unsigned	O
,	O
struct	O
internal_filehdr	struct
*	O
,	O
struct	O
internal_aouthdr	struct
*	O
)	O
;	O
const	O
bfd_target	struct
*	O
coff_real_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
nscns	int
,	O
struct	O
internal_filehdr	struct
*	O
internal_f	pointer
,	O
struct	O
internal_aouthdr	struct
*	O
internal_a	pointer
)	O
{	O
flagword	int
oflags	int
=	O
abfd	pointer
->	O
flags	int
;	O
bfd_vma	long
ostart	long
=	O
bfd_get_start_address	function
(	O
abfd	pointer
)	O
;	O
void	O
*	O
tdata	union
;	O
void	O
*	O
tdata_save	pointer
;	O
bfd_size_type	long
readsize	long
;	O
unsigned	O
int	O
scnhsz	int
;	O
char	O
*	O
external_sections	pointer
;	O
if	O
(	O
!	O
(	O
internal_f	pointer
->	O
f_flags	short
&	O
F_RELFLG	O
)	O
)	O
abfd	pointer
->	O
flags	int
|=	O
HAS_RELOC	int
;	O
if	O
(	O
(	O
internal_f	pointer
->	O
f_flags	short
&	O
F_EXEC	O
)	O
)	O
abfd	pointer
->	O
flags	int
|=	O
EXEC_P	int
;	O
if	O
(	O
!	O
(	O
internal_f	pointer
->	O
f_flags	short
&	O
F_LNNO	O
)	O
)	O
abfd	pointer
->	O
flags	int
|=	O
HAS_LINENO	int
;	O
if	O
(	O
!	O
(	O
internal_f	pointer
->	O
f_flags	short
&	O
F_LSYMS	O
)	O
)	O
abfd	pointer
->	O
flags	int
|=	O
HAS_LOCALS	int
;	O
if	O
(	O
(	O
internal_f	pointer
->	O
f_flags	short
&	O
F_EXEC	O
)	O
!=	O
0	int
)	O
abfd	pointer
->	O
flags	int
|=	O
D_PAGED	int
;	O
abfd	pointer
->	O
symcount	int
=	O
internal_f	pointer
->	O
f_nsyms	long
;	O
if	O
(	O
internal_f	pointer
->	O
f_nsyms	long
)	O
abfd	pointer
->	O
flags	int
|=	O
HAS_SYMS	int
;	O
if	O
(	O
internal_a	pointer
!=	O
(	O
struct	O
internal_aouthdr	struct
*	O
)	O
NULL	O
)	O
abfd	pointer
->	O
start_address	long
=	O
internal_a	pointer
->	O
entry	pointer
;	O
else	O
abfd	pointer
->	O
start_address	long
=	O
0	int
;	O
tdata_save	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
;	O
tdata	union
=	O
bfd_coff_mkobject_hook	O
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
internal_f	pointer
,	O
(	O
void	O
*	O
)	O
internal_a	pointer
)	O
;	O
if	O
(	O
tdata	union
==	O
NULL	O
)	O
goto	O
fail2	O
;	O
scnhsz	int
=	O
bfd_coff_scnhsz	O
(	O
abfd	pointer
)	O
;	O
readsize	long
=	O
(	O
bfd_size_type	long
)	O
nscns	int
*	O
scnhsz	int
;	O
external_sections	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
readsize	long
)	O
;	O
if	O
(	O
!	O
external_sections	pointer
)	O
goto	O
fail	O
;	O
if	O
(	O
bfd_bread	function
(	O
(	O
void	O
*	O
)	O
external_sections	pointer
,	O
readsize	long
,	O
abfd	pointer
)	O
!=	O
readsize	long
)	O
goto	O
fail	O
;	O
if	O
(	O
!	O
bfd_coff_set_arch_mach_hook	O
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
internal_f	pointer
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
nscns	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nscns	int
;	O
i	pointer
++	O
)	O
{	O
struct	O
internal_scnhdr	struct
tmp	struct
;	O
bfd_coff_swap_scnhdr_in	O
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
(	O
external_sections	pointer
+	O
i	pointer
*	O
scnhsz	int
)	O
,	O
(	O
void	O
*	O
)	O
&	O
tmp	struct
)	O
;	O
if	O
(	O
!	O
make_a_section_from_file	function
(	O
abfd	pointer
,	O
&	O
tmp	struct
,	O
i	pointer
+	O
1	int
)	O
)	O
goto	O
fail	O
;	O
}	O
}	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
=	O
FALSE	int
;	O
obj_coff_keep_strings	O
(	O
abfd	pointer
)	O
=	O
FALSE	int
;	O
_bfd_coff_free_symbols	function
(	O
abfd	pointer
)	O
;	O
return	O
abfd	pointer
->	O
xvec	pointer
;	O
fail	O
:	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
=	O
FALSE	int
;	O
obj_coff_keep_strings	O
(	O
abfd	pointer
)	O
=	O
FALSE	int
;	O
_bfd_coff_free_symbols	function
(	O
abfd	pointer
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
tdata	union
)	O
;	O
fail2	O
:	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
=	O
tdata_save	pointer
;	O
abfd	pointer
->	O
flags	int
=	O
oflags	int
;	O
abfd	pointer
->	O
start_address	long
=	O
ostart	long
;	O
return	O
(	O
const	O
bfd_target	struct
*	O
)	O
NULL	O
;	O
}	O
const	O
bfd_target	struct
*	O
coff_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
filhsz	long
;	O
bfd_size_type	long
aoutsz	long
;	O
unsigned	O
int	O
nscns	int
;	O
void	O
*	O
filehdr	pointer
;	O
struct	O
internal_filehdr	struct
internal_f	pointer
;	O
struct	O
internal_aouthdr	struct
internal_a	pointer
;	O
filhsz	long
=	O
bfd_coff_filhsz	O
(	O
abfd	pointer
)	O
;	O
aoutsz	long
=	O
bfd_coff_aoutsz	O
(	O
abfd	pointer
)	O
;	O
filehdr	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
filhsz	long
)	O
;	O
if	O
(	O
filehdr	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
bfd_bread	function
(	O
filehdr	pointer
,	O
filhsz	long
,	O
abfd	pointer
)	O
!=	O
filhsz	long
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_system_call	int
)	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
filehdr	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
bfd_coff_swap_filehdr_in	O
(	O
abfd	pointer
,	O
filehdr	pointer
,	O
&	O
internal_f	pointer
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
filehdr	pointer
)	O
;	O
if	O
(	O
!	O
bfd_coff_bad_format_hook	O
(	O
abfd	pointer
,	O
&	O
internal_f	pointer
)	O
||	O
internal_f	pointer
.	O
f_opthdr	short
>	O
aoutsz	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
NULL	O
;	O
}	O
nscns	int
=	O
internal_f	pointer
.	O
f_nscns	int
;	O
if	O
(	O
internal_f	pointer
.	O
f_opthdr	short
)	O
{	O
void	O
*	O
opthdr	pointer
;	O
opthdr	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
aoutsz	long
)	O
;	O
if	O
(	O
opthdr	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
bfd_bread	function
(	O
opthdr	pointer
,	O
(	O
bfd_size_type	long
)	O
internal_f	pointer
.	O
f_opthdr	short
,	O
abfd	pointer
)	O
!=	O
internal_f	pointer
.	O
f_opthdr	short
)	O
{	O
bfd_release	function
(	O
abfd	pointer
,	O
opthdr	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
internal_f	pointer
.	O
f_opthdr	short
<	O
aoutsz	long
)	O
memset	function
(	O
(	O
(	O
char	O
*	O
)	O
opthdr	pointer
)	O
+	O
internal_f	pointer
.	O
f_opthdr	short
,	O
0	int
,	O
aoutsz	long
-	O
internal_f	pointer
.	O
f_opthdr	short
)	O
;	O
bfd_coff_swap_aouthdr_in	O
(	O
abfd	pointer
,	O
opthdr	pointer
,	O
(	O
void	O
*	O
)	O
&	O
internal_a	pointer
)	O
;	O
bfd_release	function
(	O
abfd	pointer
,	O
opthdr	pointer
)	O
;	O
}	O
return	O
coff_real_object_p	function
(	O
abfd	pointer
,	O
nscns	int
,	O
&	O
internal_f	pointer
,	O
(	O
internal_f	pointer
.	O
f_opthdr	short
!=	O
0	int
?	O
&	O
internal_a	pointer
:	O
(	O
struct	O
internal_aouthdr	struct
*	O
)	O
NULL	O
)	O
)	O
;	O
}	O
asection	struct
*	O
coff_section_from_bfd_index	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
section_index	int
)	O
{	O
struct	O
bfd_section	struct
*	O
answer	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
if	O
(	O
section_index	int
==	O
N_ABS	O
)	O
return	O
bfd_abs_section_ptr	O
;	O
if	O
(	O
section_index	int
==	O
N_UNDEF	O
)	O
return	O
bfd_und_section_ptr	O
;	O
if	O
(	O
section_index	int
==	O
N_DEBUG	O
)	O
return	O
bfd_abs_section_ptr	O
;	O
while	O
(	O
answer	pointer
)	O
{	O
if	O
(	O
answer	pointer
->	O
target_index	int
==	O
section_index	int
)	O
return	O
answer	pointer
;	O
answer	pointer
=	O
answer	pointer
->	O
next	pointer
;	O
}	O
return	O
bfd_und_section_ptr	O
;	O
}	O
long	O
coff_get_symtab_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
!	O
bfd_coff_slurp_symbol_table	O
(	O
abfd	pointer
)	O
)	O
return	O
-	O
1	int
;	O
return	O
(	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
coff_symbol_type	struct
*	O
)	O
)	O
;	O
}	O
long	O
coff_canonicalize_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
alocation	pointer
)	O
{	O
unsigned	O
int	O
counter	int
;	O
coff_symbol_type	struct
*	O
symbase	pointer
;	O
coff_symbol_type	struct
*	O
*	O
location	pointer
=	O
(	O
coff_symbol_type	struct
*	O
*	O
)	O
alocation	pointer
;	O
if	O
(	O
!	O
bfd_coff_slurp_symbol_table	O
(	O
abfd	pointer
)	O
)	O
return	O
-	O
1	int
;	O
symbase	pointer
=	O
obj_symbols	O
(	O
abfd	pointer
)	O
;	O
counter	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
while	O
(	O
counter	int
--	O
>	O
0	int
)	O
*	O
location	pointer
++	O
=	O
symbase	pointer
++	O
;	O
*	O
location	pointer
=	O
NULL	O
;	O
return	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
}	O
const	O
char	O
*	O
_bfd_coff_internal_syment_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
struct	O
internal_syment	struct
*	O
sym	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
!=	O
0	int
||	O
sym	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
==	O
0	int
)	O
{	O
memcpy	function
(	O
buf	pointer
,	O
sym	pointer
->	O
_n	union
.	O
_n_name	array
,	O
SYMNMLEN	int
)	O
;	O
buf	pointer
[	O
SYMNMLEN	int
]	O
=	O
'\0'	O
;	O
return	O
buf	pointer
;	O
}	O
else	O
{	O
const	O
char	O
*	O
strings	pointer
;	O
BFD_ASSERT	O
(	O
sym	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
>=	O
STRING_SIZE_SIZE	int
)	O
;	O
strings	pointer
=	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
strings	pointer
==	O
NULL	O
)	O
{	O
strings	pointer
=	O
_bfd_coff_read_string_table	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
strings	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
>	O
0	int
&&	O
sym	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
>=	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
)	O
return	O
NULL	O
;	O
return	O
strings	pointer
+	O
sym	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
;	O
}	O
}	O
struct	O
internal_reloc	struct
*	O
_bfd_coff_read_internal_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_boolean	int
cache	pointer
,	O
bfd_byte	char
*	O
external_relocs	pointer
,	O
bfd_boolean	int
require_internal	int
,	O
struct	O
internal_reloc	struct
*	O
internal_relocs	pointer
)	O
{	O
bfd_size_type	long
relsz	long
;	O
bfd_byte	char
*	O
free_external	pointer
=	O
NULL	O
;	O
struct	O
internal_reloc	struct
*	O
free_internal	pointer
=	O
NULL	O
;	O
bfd_byte	char
*	O
erel	pointer
;	O
bfd_byte	char
*	O
erel_end	pointer
;	O
struct	O
internal_reloc	struct
*	O
irel	pointer
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
sec	pointer
->	O
reloc_count	int
==	O
0	int
)	O
return	O
internal_relocs	pointer
;	O
if	O
(	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
!=	O
NULL	O
&&	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
relocs	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
require_internal	int
)	O
return	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
relocs	pointer
;	O
memcpy	function
(	O
internal_relocs	pointer
,	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
relocs	pointer
,	O
sec	pointer
->	O
reloc_count	int
*	O
sizeof	O
(	O
struct	O
internal_reloc	struct
)	O
)	O
;	O
return	O
internal_relocs	pointer
;	O
}	O
relsz	long
=	O
bfd_coff_relsz	O
(	O
abfd	pointer
)	O
;	O
amt	long
=	O
sec	pointer
->	O
reloc_count	int
*	O
relsz	long
;	O
if	O
(	O
external_relocs	pointer
==	O
NULL	O
)	O
{	O
free_external	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
free_external	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
external_relocs	pointer
=	O
free_external	pointer
;	O
}	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
sec	pointer
->	O
rel_filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
external_relocs	pointer
,	O
amt	long
,	O
abfd	pointer
)	O
!=	O
amt	long
)	O
goto	O
error_return	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
)	O
{	O
amt	long
=	O
sec	pointer
->	O
reloc_count	int
;	O
amt	long
*=	O
sizeof	O
(	O
struct	O
internal_reloc	struct
)	O
;	O
free_internal	pointer
=	O
(	O
struct	O
internal_reloc	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
free_internal	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
internal_relocs	pointer
=	O
free_internal	pointer
;	O
}	O
erel	pointer
=	O
external_relocs	pointer
;	O
erel_end	pointer
=	O
erel	pointer
+	O
relsz	long
*	O
sec	pointer
->	O
reloc_count	int
;	O
irel	pointer
=	O
internal_relocs	pointer
;	O
for	O
(	O
;	O
erel	pointer
<	O
erel_end	pointer
;	O
erel	pointer
+=	O
relsz	long
,	O
irel	pointer
++	O
)	O
bfd_coff_swap_reloc_in	O
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
erel	pointer
,	O
(	O
void	O
*	O
)	O
irel	pointer
)	O
;	O
if	O
(	O
free_external	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
free_external	pointer
)	O
;	O
free_external	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
cache	pointer
&&	O
free_internal	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
==	O
NULL	O
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
coff_section_tdata	struct
)	O
;	O
sec	pointer
->	O
used_by_bfd	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
sec	pointer
->	O
used_by_bfd	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
contents	pointer
=	O
NULL	O
;	O
}	O
coff_section_data	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
->	O
relocs	pointer
=	O
free_internal	pointer
;	O
}	O
return	O
internal_relocs	pointer
;	O
error_return	O
:	O
if	O
(	O
free_external	pointer
!=	O
NULL	O
)	O
free	function
(	O
free_external	pointer
)	O
;	O
if	O
(	O
free_internal	pointer
!=	O
NULL	O
)	O
free	function
(	O
free_internal	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
coff_count_linenumbers	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
unsigned	O
int	O
limit	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
unsigned	O
int	O
i	pointer
;	O
int	O
total	int
=	O
0	int
;	O
asymbol	struct
*	O
*	O
p	pointer
;	O
asection	struct
*	O
s	pointer
;	O
if	O
(	O
limit	int
==	O
0	int
)	O
{	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
total	int
+=	O
s	pointer
->	O
lineno_count	int
;	O
return	O
total	int
;	O
}	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
BFD_ASSERT	O
(	O
s	pointer
->	O
lineno_count	int
==	O
0	int
)	O
;	O
for	O
(	O
p	pointer
=	O
abfd	pointer
->	O
outsymbols	pointer
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
limit	int
;	O
i	pointer
++	O
,	O
p	pointer
++	O
)	O
{	O
asymbol	struct
*	O
q_maybe	pointer
=	O
*	O
p	pointer
;	O
if	O
(	O
bfd_family_coff	function
(	O
bfd_asymbol_bfd	function
(	O
q_maybe	pointer
)	O
)	O
)	O
{	O
coff_symbol_type	struct
*	O
q	pointer
=	O
coffsymbol	O
(	O
q_maybe	pointer
)	O
;	O
if	O
(	O
q	pointer
->	O
lineno	pointer
!=	O
NULL	O
&&	O
q	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
)	O
{	O
alent	struct
*	O
l	long
=	O
q	pointer
->	O
lineno	pointer
;	O
do	O
{	O
asection	struct
*	O
sec	pointer
=	O
q	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
!	O
bfd_is_const_section	function
(	O
sec	pointer
)	O
)	O
sec	pointer
->	O
lineno_count	int
++	O
;	O
++	O
total	int
;	O
++	O
l	long
;	O
}	O
while	O
(	O
l	long
->	O
line_number	int
!=	O
0	int
)	O
;	O
}	O
}	O
}	O
return	O
total	int
;	O
}	O
static	O
void	O
fixup_symbol_value	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
coff_symbol_type	struct
*	O
coff_symbol_ptr	pointer
,	O
struct	O
internal_syment	struct
*	O
syment	struct
)	O
{	O
if	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
&&	O
bfd_is_com_section	function
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
)	O
)	O
{	O
syment	struct
->	O
n_scnum	int
=	O
N_UNDEF	O
;	O
syment	struct
->	O
n_value	long
=	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
value	long
;	O
}	O
else	O
if	O
(	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
!=	O
0	int
&&	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
flags	int
&	O
BSF_DEBUGGING_RELOC	O
)	O
==	O
0	int
)	O
{	O
syment	struct
->	O
n_value	long
=	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
value	long
;	O
}	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
)	O
)	O
{	O
syment	struct
->	O
n_scnum	int
=	O
N_UNDEF	O
;	O
syment	struct
->	O
n_value	long
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
)	O
{	O
syment	struct
->	O
n_scnum	int
=	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
target_index	int
;	O
syment	struct
->	O
n_value	long
=	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
value	long
+	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
!	O
obj_pe	O
(	O
abfd	pointer
)	O
)	O
{	O
syment	struct
->	O
n_value	long
+=	O
(	O
syment	struct
->	O
n_sclass	char
==	O
C_STATLAB	int
)	O
?	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
lma	long
:	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
}	O
}	O
else	O
{	O
BFD_ASSERT	O
(	O
0	int
)	O
;	O
syment	struct
->	O
n_scnum	int
=	O
N_ABS	O
;	O
syment	struct
->	O
n_value	long
=	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
value	long
;	O
}	O
}	O
}	O
bfd_boolean	int
coff_renumber_symbols	function
(	O
bfd	struct
*	O
bfd_ptr	pointer
,	O
int	O
*	O
first_undef	pointer
)	O
{	O
unsigned	O
int	O
symbol_count	int
=	O
bfd_get_symcount	function
(	O
bfd_ptr	pointer
)	O
;	O
asymbol	struct
*	O
*	O
symbol_ptr_ptr	pointer
=	O
bfd_ptr	pointer
->	O
outsymbols	pointer
;	O
unsigned	O
int	O
native_index	int
=	O
0	int
;	O
struct	O
internal_syment	struct
*	O
last_file	struct
=	O
NULL	O
;	O
unsigned	O
int	O
symbol_index	int
;	O
{	O
asymbol	struct
*	O
*	O
newsyms	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_size_type	long
amt	long
;	O
amt	long
=	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
*	O
(	O
(	O
bfd_size_type	long
)	O
symbol_count	int
+	O
1	int
)	O
;	O
newsyms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_alloc	function
(	O
bfd_ptr	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
!	O
newsyms	pointer
)	O
return	O
FALSE	int
;	O
bfd_ptr	pointer
->	O
outsymbols	pointer
=	O
newsyms	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symbol_count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
BSF_NOT_AT_END	O
)	O
!=	O
0	int
||	O
(	O
!	O
bfd_is_und_section	function
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
section	pointer
)	O
&&	O
!	O
bfd_is_com_section	function
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
section	pointer
)	O
&&	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
BSF_FUNCTION	O
)	O
!=	O
0	int
||	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
)	O
==	O
0	int
)	O
)	O
)	O
)	O
*	O
newsyms	pointer
++	O
=	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symbol_count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
BSF_NOT_AT_END	O
)	O
==	O
0	int
&&	O
!	O
bfd_is_und_section	function
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
section	pointer
)	O
&&	O
(	O
bfd_is_com_section	function
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
section	pointer
)	O
||	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
BSF_FUNCTION	O
)	O
==	O
0	int
&&	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
)	O
!=	O
0	int
)	O
)	O
)	O
)	O
*	O
newsyms	pointer
++	O
=	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
;	O
*	O
first_undef	pointer
=	O
newsyms	pointer
-	O
bfd_ptr	pointer
->	O
outsymbols	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symbol_count	int
;	O
i	pointer
++	O
)	O
if	O
(	O
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
flags	int
&	O
BSF_NOT_AT_END	O
)	O
==	O
0	int
&&	O
bfd_is_und_section	function
(	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
->	O
section	pointer
)	O
)	O
*	O
newsyms	pointer
++	O
=	O
symbol_ptr_ptr	pointer
[	O
i	pointer
]	O
;	O
*	O
newsyms	pointer
=	O
(	O
asymbol	struct
*	O
)	O
NULL	O
;	O
symbol_ptr_ptr	pointer
=	O
bfd_ptr	pointer
->	O
outsymbols	pointer
;	O
}	O
for	O
(	O
symbol_index	int
=	O
0	int
;	O
symbol_index	int
<	O
symbol_count	int
;	O
symbol_index	int
++	O
)	O
{	O
coff_symbol_type	struct
*	O
coff_symbol_ptr	pointer
;	O
coff_symbol_ptr	pointer
=	O
coff_symbol_from	O
(	O
symbol_ptr_ptr	pointer
[	O
symbol_index	int
]	O
)	O
;	O
symbol_ptr_ptr	pointer
[	O
symbol_index	int
]	O
->	O
udata	union
.	O
i	pointer
=	O
symbol_index	int
;	O
if	O
(	O
coff_symbol_ptr	pointer
&&	O
coff_symbol_ptr	pointer
->	O
native	pointer
)	O
{	O
combined_entry_type	struct
*	O
s	pointer
=	O
coff_symbol_ptr	pointer
->	O
native	pointer
;	O
int	O
i	pointer
;	O
BFD_ASSERT	O
(	O
s	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
)	O
{	O
if	O
(	O
last_file	struct
!=	O
NULL	O
)	O
last_file	struct
->	O
n_value	long
=	O
native_index	int
;	O
last_file	struct
=	O
&	O
(	O
s	pointer
->	O
u	union
.	O
syment	struct
)	O
;	O
}	O
else	O
fixup_symbol_value	function
(	O
bfd_ptr	pointer
,	O
coff_symbol_ptr	pointer
,	O
&	O
(	O
s	pointer
->	O
u	union
.	O
syment	struct
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
+	O
1	int
;	O
i	pointer
++	O
)	O
s	pointer
[	O
i	pointer
]	O
.	O
offset	long
=	O
native_index	int
++	O
;	O
}	O
else	O
native_index	int
++	O
;	O
}	O
obj_conv_table_size	O
(	O
bfd_ptr	pointer
)	O
=	O
native_index	int
;	O
return	O
TRUE	int
;	O
}	O
void	O
coff_mangle_symbols	function
(	O
bfd	struct
*	O
bfd_ptr	pointer
)	O
{	O
unsigned	O
int	O
symbol_count	int
=	O
bfd_get_symcount	function
(	O
bfd_ptr	pointer
)	O
;	O
asymbol	struct
*	O
*	O
symbol_ptr_ptr	pointer
=	O
bfd_ptr	pointer
->	O
outsymbols	pointer
;	O
unsigned	O
int	O
symbol_index	int
;	O
for	O
(	O
symbol_index	int
=	O
0	int
;	O
symbol_index	int
<	O
symbol_count	int
;	O
symbol_index	int
++	O
)	O
{	O
coff_symbol_type	struct
*	O
coff_symbol_ptr	pointer
;	O
coff_symbol_ptr	pointer
=	O
coff_symbol_from	O
(	O
symbol_ptr_ptr	pointer
[	O
symbol_index	int
]	O
)	O
;	O
if	O
(	O
coff_symbol_ptr	pointer
&&	O
coff_symbol_ptr	pointer
->	O
native	pointer
)	O
{	O
int	O
i	pointer
;	O
combined_entry_type	struct
*	O
s	pointer
=	O
coff_symbol_ptr	pointer
->	O
native	pointer
;	O
BFD_ASSERT	O
(	O
s	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
s	pointer
->	O
fix_value	int
)	O
{	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
(	O
bfd_hostptr_t	long
)	O
(	O
(	O
combined_entry_type	struct
*	O
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
)	O
)	O
->	O
offset	long
;	O
s	pointer
->	O
fix_value	int
=	O
0	int
;	O
}	O
if	O
(	O
s	pointer
->	O
fix_line	int
)	O
{	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
line_filepos	long
+	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
*	O
bfd_coff_linesz	O
(	O
bfd_ptr	pointer
)	O
)	O
;	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
coff_section_from_bfd_index	function
(	O
bfd_ptr	pointer
,	O
N_DEBUG	O
)	O
;	O
BFD_ASSERT	O
(	O
coff_symbol_ptr	pointer
->	O
symbol	pointer
.	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
i	pointer
++	O
)	O
{	O
combined_entry_type	struct
*	O
a	pointer
=	O
s	pointer
+	O
i	pointer
+	O
1	int
;	O
BFD_ASSERT	O
(	O
!	O
a	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
a	pointer
->	O
fix_tag	int
)	O
{	O
a	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
=	O
a	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
p	pointer
->	O
offset	long
;	O
a	pointer
->	O
fix_tag	int
=	O
0	int
;	O
}	O
if	O
(	O
a	pointer
->	O
fix_end	int
)	O
{	O
a	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
=	O
a	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
p	pointer
->	O
offset	long
;	O
a	pointer
->	O
fix_end	int
=	O
0	int
;	O
}	O
if	O
(	O
a	pointer
->	O
fix_scnlen	int
)	O
{	O
a	pointer
->	O
u	union
.	O
auxent	union
.	O
x_csect	struct
.	O
x_scnlen	long
.	O
l	long
=	O
a	pointer
->	O
u	union
.	O
auxent	union
.	O
x_csect	struct
.	O
x_scnlen	long
.	O
p	pointer
->	O
offset	long
;	O
a	pointer
->	O
fix_scnlen	int
=	O
0	int
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
coff_fix_symbol_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
combined_entry_type	struct
*	O
native	pointer
,	O
bfd_size_type	long
*	O
string_size_p	pointer
,	O
asection	struct
*	O
*	O
debug_string_section_p	pointer
,	O
bfd_size_type	long
*	O
debug_string_size_p	pointer
)	O
{	O
unsigned	O
int	O
name_length	int
;	O
union	O
internal_auxent	union
*	O
auxent	union
;	O
char	O
*	O
name	pointer
=	O
(	O
char	O
*	O
)	O
(	O
symbol	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
symbol	pointer
->	O
name	pointer
=	O
"strange"	pointer
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
symbol	pointer
->	O
name	pointer
;	O
}	O
name_length	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
BFD_ASSERT	O
(	O
native	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
&&	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
>	O
0	int
)	O
{	O
unsigned	O
int	O
filnmlen	int
;	O
if	O
(	O
bfd_coff_force_symnames_in_strings	O
(	O
abfd	pointer
)	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
*	O
string_size_p	pointer
+	O
STRING_SIZE_SIZE	int
)	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
=	O
0	int
;	O
*	O
string_size_p	pointer
+=	O
6	int
;	O
}	O
else	O
strncpy	function
(	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_name	array
,	O
".file"	pointer
,	O
SYMNMLEN	int
)	O
;	O
BFD_ASSERT	O
(	O
!	O
(	O
native	pointer
+	O
1	int
)	O
->	O
is_sym	int
)	O
;	O
auxent	union
=	O
&	O
(	O
native	pointer
+	O
1	int
)	O
->	O
u	union
.	O
auxent	union
;	O
filnmlen	int
=	O
bfd_coff_filnmlen	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_coff_long_filenames	O
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
name_length	int
<=	O
filnmlen	int
)	O
strncpy	function
(	O
auxent	union
->	O
x_file	union
.	O
x_fname	array
,	O
name	pointer
,	O
filnmlen	int
)	O
;	O
else	O
{	O
auxent	union
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
=	O
*	O
string_size_p	pointer
+	O
STRING_SIZE_SIZE	int
;	O
auxent	union
->	O
x_file	union
.	O
x_n	struct
.	O
x_zeroes	long
=	O
0	int
;	O
*	O
string_size_p	pointer
+=	O
name_length	int
+	O
1	int
;	O
}	O
}	O
else	O
{	O
strncpy	function
(	O
auxent	union
->	O
x_file	union
.	O
x_fname	array
,	O
name	pointer
,	O
filnmlen	int
)	O
;	O
if	O
(	O
name_length	int
>	O
filnmlen	int
)	O
name	pointer
[	O
filnmlen	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
name_length	int
<=	O
SYMNMLEN	int
&&	O
!	O
bfd_coff_force_symnames_in_strings	O
(	O
abfd	pointer
)	O
)	O
strncpy	function
(	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_name	array
,	O
symbol	pointer
->	O
name	pointer
,	O
SYMNMLEN	int
)	O
;	O
else	O
if	O
(	O
!	O
bfd_coff_symname_in_debug	O
(	O
abfd	pointer
,	O
&	O
native	pointer
->	O
u	union
.	O
syment	struct
)	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
*	O
string_size_p	pointer
+	O
STRING_SIZE_SIZE	int
)	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
=	O
0	int
;	O
*	O
string_size_p	pointer
+=	O
name_length	int
+	O
1	int
;	O
}	O
else	O
{	O
file_ptr	long
filepos	long
;	O
bfd_byte	char
buf	pointer
[	O
4	int
]	O
;	O
int	O
prefix_len	int
=	O
bfd_coff_debug_string_prefix_length	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
*	O
debug_string_section_p	pointer
==	O
(	O
asection	struct
*	O
)	O
NULL	O
)	O
*	O
debug_string_section_p	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".debug"	pointer
)	O
;	O
filepos	long
=	O
bfd_tell	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
prefix_len	int
==	O
4	int
)	O
bfd_put_32	O
(	O
abfd	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
name_length	int
+	O
1	int
)	O
,	O
buf	pointer
)	O
;	O
else	O
bfd_put_16	O
(	O
abfd	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
name_length	int
+	O
1	int
)	O
,	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
*	O
debug_string_section_p	pointer
,	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
(	O
file_ptr	long
)	O
*	O
debug_string_size_p	pointer
,	O
(	O
bfd_size_type	long
)	O
prefix_len	int
)	O
||	O
!	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
*	O
debug_string_section_p	pointer
,	O
(	O
void	O
*	O
)	O
symbol	pointer
->	O
name	pointer
,	O
(	O
file_ptr	long
)	O
(	O
*	O
debug_string_size_p	pointer
+	O
prefix_len	int
)	O
,	O
(	O
bfd_size_type	long
)	O
name_length	int
+	O
1	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
abort	function
(	O
)	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
*	O
debug_string_size_p	pointer
+	O
prefix_len	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
=	O
0	int
;	O
*	O
debug_string_size_p	pointer
+=	O
name_length	int
+	O
1	int
+	O
prefix_len	int
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
coff_write_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
combined_entry_type	struct
*	O
native	pointer
,	O
bfd_vma	long
*	O
written	pointer
,	O
bfd_size_type	long
*	O
string_size_p	pointer
,	O
asection	struct
*	O
*	O
debug_string_section_p	pointer
,	O
bfd_size_type	long
*	O
debug_string_size_p	pointer
)	O
{	O
unsigned	O
int	O
numaux	char
=	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
int	O
type	enum
=	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
;	O
int	O
n_sclass	char
=	O
(	O
int	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
;	O
asection	struct
*	O
output_section	pointer
=	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
?	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
:	O
symbol	pointer
->	O
section	pointer
;	O
void	O
*	O
buf	pointer
;	O
bfd_size_type	long
symesz	long
;	O
BFD_ASSERT	O
(	O
native	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
)	O
symbol	pointer
->	O
flags	int
|=	O
BSF_DEBUGGING	O
;	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
&&	O
bfd_is_abs_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_DEBUG	O
;	O
else	O
if	O
(	O
bfd_is_abs_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_ABS	O
;	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
else	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
output_section	pointer
->	O
target_index	int
;	O
coff_fix_symbol_name	function
(	O
abfd	pointer
,	O
symbol	pointer
,	O
native	pointer
,	O
string_size_p	pointer
,	O
debug_string_section_p	pointer
,	O
debug_string_size_p	pointer
)	O
;	O
symesz	long
=	O
bfd_coff_symesz	O
(	O
abfd	pointer
)	O
;	O
buf	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
symesz	long
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
FALSE	int
;	O
bfd_coff_swap_sym_out	O
(	O
abfd	pointer
,	O
&	O
native	pointer
->	O
u	union
.	O
syment	struct
,	O
buf	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
buf	pointer
,	O
symesz	long
,	O
abfd	pointer
)	O
!=	O
symesz	long
)	O
return	O
FALSE	int
;	O
bfd_release	function
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
>	O
0	int
)	O
{	O
bfd_size_type	long
auxesz	long
;	O
unsigned	O
int	O
j	int
;	O
auxesz	long
=	O
bfd_coff_auxesz	O
(	O
abfd	pointer
)	O
;	O
buf	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
auxesz	long
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
j	int
++	O
)	O
{	O
BFD_ASSERT	O
(	O
!	O
(	O
native	pointer
+	O
j	int
+	O
1	int
)	O
->	O
is_sym	int
)	O
;	O
bfd_coff_swap_aux_out	O
(	O
abfd	pointer
,	O
&	O
(	O
(	O
native	pointer
+	O
j	int
+	O
1	int
)	O
->	O
u	union
.	O
auxent	union
)	O
,	O
type	enum
,	O
n_sclass	char
,	O
(	O
int	O
)	O
j	int
,	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
,	O
buf	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
buf	pointer
,	O
auxesz	long
,	O
abfd	pointer
)	O
!=	O
auxesz	long
)	O
return	O
FALSE	int
;	O
}	O
bfd_release	function
(	O
abfd	pointer
,	O
buf	pointer
)	O
;	O
}	O
set_index	O
(	O
symbol	pointer
,	O
*	O
written	pointer
)	O
;	O
*	O
written	pointer
+=	O
numaux	char
+	O
1	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
coff_write_alien_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
struct	O
internal_syment	struct
*	O
isym	pointer
,	O
union	O
internal_auxent	union
*	O
iaux	pointer
,	O
bfd_vma	long
*	O
written	pointer
,	O
bfd_size_type	long
*	O
string_size_p	pointer
,	O
asection	struct
*	O
*	O
debug_string_section_p	pointer
,	O
bfd_size_type	long
*	O
debug_string_size_p	pointer
)	O
{	O
combined_entry_type	struct
*	O
native	pointer
;	O
combined_entry_type	struct
dummy	array
[	O
2	int
]	O
;	O
asection	struct
*	O
output_section	pointer
=	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
?	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
:	O
symbol	pointer
->	O
section	pointer
;	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
=	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
link_info	pointer
;	O
bfd_boolean	int
ret	pointer
;	O
if	O
(	O
(	O
!	O
link_info	pointer
||	O
link_info	pointer
->	O
strip_discarded	int
)	O
&&	O
!	O
bfd_is_abs_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
&&	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
)	O
{	O
symbol	pointer
->	O
name	pointer
=	O
""	pointer
;	O
if	O
(	O
isym	pointer
!=	O
NULL	O
)	O
memset	function
(	O
isym	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
isym	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
native	pointer
=	O
dummy	array
;	O
native	pointer
->	O
is_sym	int
=	O
TRUE	int
;	O
native	pointer
[	O
1	int
]	O
.	O
is_sym	int
=	O
FALSE	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
=	O
T_NULL	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_flags	short
=	O
0	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
=	O
0	int
;	O
if	O
(	O
bfd_is_und_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
symbol	pointer
->	O
value	long
;	O
}	O
else	O
if	O
(	O
bfd_is_com_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
symbol	pointer
->	O
value	long
;	O
}	O
else	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_FILE	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_DEBUG	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
=	O
1	int
;	O
}	O
else	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
{	O
symbol	pointer
->	O
name	pointer
=	O
""	pointer
;	O
if	O
(	O
isym	pointer
!=	O
NULL	O
)	O
memset	function
(	O
isym	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
isym	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
output_section	pointer
->	O
target_index	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
(	O
symbol	pointer
->	O
value	long
+	O
symbol	pointer
->	O
section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
!	O
obj_pe	O
(	O
abfd	pointer
)	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
+=	O
output_section	pointer
->	O
vma	long
;	O
{	O
coff_symbol_type	struct
*	O
c	struct
=	O
coff_symbol_from	O
(	O
symbol	pointer
)	O
;	O
if	O
(	O
c	struct
!=	O
(	O
coff_symbol_type	struct
*	O
)	O
NULL	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_flags	short
=	O
bfd_asymbol_bfd	function
(	O
&	O
c	struct
->	O
symbol	pointer
)	O
->	O
flags	int
;	O
}	O
}	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
=	O
0	int
;	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_FILE	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
C_FILE	int
;	O
else	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
C_STAT	int
;	O
else	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
obj_pe	O
(	O
abfd	pointer
)	O
?	O
C_NT_WEAK	int
:	O
C_WEAKEXT	int
;	O
else	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
C_EXT	int
;	O
ret	pointer
=	O
coff_write_symbol	function
(	O
abfd	pointer
,	O
symbol	pointer
,	O
native	pointer
,	O
written	pointer
,	O
string_size_p	pointer
,	O
debug_string_section_p	pointer
,	O
debug_string_size_p	pointer
)	O
;	O
if	O
(	O
isym	pointer
!=	O
NULL	O
)	O
*	O
isym	pointer
=	O
native	pointer
->	O
u	union
.	O
syment	struct
;	O
if	O
(	O
iaux	pointer
!=	O
NULL	O
&&	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
)	O
*	O
iaux	pointer
=	O
native	pointer
[	O
1	int
]	O
.	O
u	union
.	O
auxent	union
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
coff_write_native_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
coff_symbol_type	struct
*	O
symbol	pointer
,	O
bfd_vma	long
*	O
written	pointer
,	O
bfd_size_type	long
*	O
string_size_p	pointer
,	O
asection	struct
*	O
*	O
debug_string_section_p	pointer
,	O
bfd_size_type	long
*	O
debug_string_size_p	pointer
)	O
{	O
combined_entry_type	struct
*	O
native	pointer
=	O
symbol	pointer
->	O
native	pointer
;	O
alent	struct
*	O
lineno	pointer
=	O
symbol	pointer
->	O
lineno	pointer
;	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
=	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
link_info	pointer
;	O
if	O
(	O
(	O
!	O
link_info	pointer
||	O
link_info	pointer
->	O
strip_discarded	int
)	O
&&	O
!	O
bfd_is_abs_section	function
(	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
)	O
&&	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
)	O
{	O
symbol	pointer
->	O
symbol	pointer
.	O
name	pointer
=	O
""	pointer
;	O
return	O
TRUE	int
;	O
}	O
BFD_ASSERT	O
(	O
native	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
lineno	pointer
&&	O
!	O
symbol	pointer
->	O
done_lineno	int
&&	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
count	int
=	O
0	int
;	O
lineno	pointer
[	O
count	int
]	O
.	O
u	union
.	O
offset	long
=	O
*	O
written	pointer
;	O
if	O
(	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
)	O
{	O
union	O
internal_auxent	union
*	O
a	pointer
=	O
&	O
(	O
(	O
native	pointer
+	O
1	int
)	O
->	O
u	union
.	O
auxent	union
)	O
;	O
a	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_lnnoptr	long
=	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
moving_line_filepos	long
;	O
}	O
count	int
++	O
;	O
while	O
(	O
lineno	pointer
[	O
count	int
]	O
.	O
line_number	int
!=	O
0	int
)	O
{	O
lineno	pointer
[	O
count	int
]	O
.	O
u	union
.	O
offset	long
+=	O
(	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
count	int
++	O
;	O
}	O
symbol	pointer
->	O
done_lineno	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
bfd_is_const_section	function
(	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
)	O
)	O
symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
->	O
output_section	pointer
->	O
moving_line_filepos	long
+=	O
count	int
*	O
bfd_coff_linesz	O
(	O
abfd	pointer
)	O
;	O
}	O
return	O
coff_write_symbol	function
(	O
abfd	pointer
,	O
&	O
(	O
symbol	pointer
->	O
symbol	pointer
)	O
,	O
native	pointer
,	O
written	pointer
,	O
string_size_p	pointer
,	O
debug_string_section_p	pointer
,	O
debug_string_size_p	pointer
)	O
;	O
}	O
static	O
void	O
null_error_handler	function
(	O
const	O
char	O
*	O
fmt	pointer
ATTRIBUTE_UNUSED	O
,	O
va_list	array
ap	array
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
bfd_boolean	int
coff_write_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
string_size	long
;	O
asection	struct
*	O
debug_string_section	pointer
;	O
bfd_size_type	long
debug_string_size	long
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
limit	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
bfd_vma	long
written	pointer
=	O
0	int
;	O
asymbol	struct
*	O
*	O
p	pointer
;	O
string_size	long
=	O
0	int
;	O
debug_string_section	pointer
=	O
NULL	O
;	O
debug_string_size	long
=	O
0	int
;	O
if	O
(	O
bfd_coff_long_section_names	O
(	O
abfd	pointer
)	O
)	O
{	O
asection	struct
*	O
o	pointer
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
size_t	long
len	long
;	O
len	long
=	O
strlen	function
(	O
o	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
len	long
>	O
SCNNMLEN	O
)	O
string_size	long
+=	O
len	long
+	O
1	int
;	O
}	O
}	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
written	pointer
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
abfd	pointer
->	O
outsymbols	pointer
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
limit	int
;	O
i	pointer
++	O
,	O
p	pointer
++	O
)	O
{	O
asymbol	struct
*	O
symbol	pointer
=	O
*	O
p	pointer
;	O
coff_symbol_type	struct
*	O
c_symbol	pointer
=	O
coff_symbol_from	O
(	O
symbol	pointer
)	O
;	O
if	O
(	O
c_symbol	pointer
==	O
(	O
coff_symbol_type	struct
*	O
)	O
NULL	O
||	O
c_symbol	pointer
->	O
native	pointer
==	O
(	O
combined_entry_type	struct
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
coff_write_alien_symbol	function
(	O
abfd	pointer
,	O
symbol	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
written	pointer
,	O
&	O
string_size	long
,	O
&	O
debug_string_section	pointer
,	O
&	O
debug_string_size	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
coff_backend_info	O
(	O
abfd	pointer
)	O
->	O
_bfd_coff_classify_symbol	pointer
!=	O
NULL	O
)	O
{	O
bfd_error_handler_type	pointer
current_error_handler	pointer
;	O
enum	O
coff_symbol_classification	enum
sym_class	enum
;	O
unsigned	O
char	O
*	O
n_sclass	char
;	O
current_error_handler	pointer
=	O
bfd_set_error_handler	function
(	O
null_error_handler	function
)	O
;	O
BFD_ASSERT	O
(	O
c_symbol	pointer
->	O
native	pointer
->	O
is_sym	int
)	O
;	O
sym_class	enum
=	O
bfd_coff_classify_symbol	O
(	O
abfd	pointer
,	O
&	O
c_symbol	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
)	O
;	O
(	O
void	O
)	O
bfd_set_error_handler	function
(	O
current_error_handler	pointer
)	O
;	O
n_sclass	char
=	O
&	O
c_symbol	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
;	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
*	O
n_sclass	char
=	O
obj_pe	O
(	O
abfd	pointer
)	O
?	O
C_NT_WEAK	int
:	O
C_WEAKEXT	int
;	O
else	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
&&	O
sym_class	enum
!=	O
COFF_SYMBOL_LOCAL	int
)	O
*	O
n_sclass	char
=	O
C_STAT	int
;	O
else	O
if	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_GLOBAL	O
&&	O
(	O
sym_class	enum
!=	O
COFF_SYMBOL_GLOBAL	int
||	O
*	O
n_sclass	char
==	O
C_WEAKEXT	int
)	O
)	O
c_symbol	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
C_EXT	int
;	O
}	O
if	O
(	O
!	O
coff_write_native_symbol	function
(	O
abfd	pointer
,	O
c_symbol	pointer
,	O
&	O
written	pointer
,	O
&	O
string_size	long
,	O
&	O
debug_string_section	pointer
,	O
&	O
debug_string_size	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
=	O
written	pointer
;	O
if	O
(	O
string_size	long
!=	O
0	int
)	O
{	O
unsigned	O
int	O
size	long
=	O
string_size	long
+	O
STRING_SIZE_SIZE	int
;	O
bfd_byte	char
buffer	pointer
[	O
STRING_SIZE_SIZE	int
]	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
size	long
,	O
buffer	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
(	O
void	O
*	O
)	O
buffer	pointer
,	O
(	O
bfd_size_type	long
)	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
abfd	pointer
)	O
!=	O
sizeof	O
(	O
buffer	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_coff_long_section_names	O
(	O
abfd	pointer
)	O
)	O
{	O
asection	struct
*	O
o	pointer
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
size_t	long
len	long
;	O
len	long
=	O
strlen	function
(	O
o	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
len	long
>	O
SCNNMLEN	O
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
o	pointer
->	O
name	pointer
,	O
(	O
bfd_size_type	long
)	O
(	O
len	long
+	O
1	int
)	O
,	O
abfd	pointer
)	O
!=	O
len	long
+	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
for	O
(	O
p	pointer
=	O
abfd	pointer
->	O
outsymbols	pointer
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
limit	int
;	O
i	pointer
++	O
,	O
p	pointer
++	O
)	O
{	O
asymbol	struct
*	O
q	pointer
=	O
*	O
p	pointer
;	O
size_t	long
name_length	int
=	O
strlen	function
(	O
q	pointer
->	O
name	pointer
)	O
;	O
coff_symbol_type	struct
*	O
c_symbol	pointer
=	O
coff_symbol_from	O
(	O
q	pointer
)	O
;	O
size_t	long
maxlen	long
;	O
if	O
(	O
c_symbol	pointer
==	O
NULL	O
||	O
c_symbol	pointer
->	O
native	pointer
==	O
NULL	O
)	O
maxlen	long
=	O
bfd_coff_force_symnames_in_strings	O
(	O
abfd	pointer
)	O
?	O
0	int
:	O
SYMNMLEN	int
;	O
else	O
if	O
(	O
!	O
c_symbol	pointer
->	O
native	pointer
->	O
is_sym	int
)	O
maxlen	long
=	O
bfd_coff_force_symnames_in_strings	O
(	O
abfd	pointer
)	O
?	O
0	int
:	O
SYMNMLEN	int
;	O
else	O
if	O
(	O
bfd_coff_symname_in_debug	O
(	O
abfd	pointer
,	O
&	O
c_symbol	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
)	O
)	O
maxlen	long
=	O
name_length	int
;	O
else	O
if	O
(	O
c_symbol	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
&&	O
c_symbol	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
>	O
0	int
)	O
{	O
if	O
(	O
bfd_coff_force_symnames_in_strings	O
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
".file"	pointer
,	O
(	O
bfd_size_type	long
)	O
6	int
,	O
abfd	pointer
)	O
!=	O
6	int
)	O
return	O
FALSE	int
;	O
}	O
maxlen	long
=	O
bfd_coff_filnmlen	O
(	O
abfd	pointer
)	O
;	O
}	O
else	O
maxlen	long
=	O
bfd_coff_force_symnames_in_strings	O
(	O
abfd	pointer
)	O
?	O
0	int
:	O
SYMNMLEN	int
;	O
if	O
(	O
name_length	int
>	O
maxlen	long
)	O
{	O
if	O
(	O
bfd_bwrite	function
(	O
(	O
void	O
*	O
)	O
(	O
q	pointer
->	O
name	pointer
)	O
,	O
(	O
bfd_size_type	long
)	O
name_length	int
+	O
1	int
,	O
abfd	pointer
)	O
!=	O
name_length	int
+	O
1	int
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
size	long
=	O
STRING_SIZE_SIZE	int
;	O
bfd_byte	char
buffer	pointer
[	O
STRING_SIZE_SIZE	int
]	O
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
size	long
,	O
buffer	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
(	O
void	O
*	O
)	O
buffer	pointer
,	O
(	O
bfd_size_type	long
)	O
STRING_SIZE_SIZE	int
,	O
abfd	pointer
)	O
!=	O
STRING_SIZE_SIZE	int
)	O
return	O
FALSE	int
;	O
}	O
BFD_ASSERT	O
(	O
debug_string_size	long
==	O
0	int
||	O
(	O
debug_string_section	pointer
!=	O
(	O
asection	struct
*	O
)	O
NULL	O
&&	O
(	O
BFD_ALIGN	O
(	O
debug_string_size	long
,	O
1	int
<<	O
debug_string_section	pointer
->	O
alignment_power	int
)	O
==	O
debug_string_section	pointer
->	O
size	long
)	O
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
coff_write_linenumbers	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_size_type	long
linesz	long
;	O
void	O
*	O
buff	pointer
;	O
linesz	long
=	O
bfd_coff_linesz	O
(	O
abfd	pointer
)	O
;	O
buff	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
linesz	long
)	O
;	O
if	O
(	O
!	O
buff	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
(	O
asection	struct
*	O
)	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
lineno_count	int
)	O
{	O
asymbol	struct
*	O
*	O
q	pointer
=	O
abfd	pointer
->	O
outsymbols	pointer
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
s	pointer
->	O
line_filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
while	O
(	O
*	O
q	pointer
)	O
{	O
asymbol	struct
*	O
p	pointer
=	O
*	O
q	pointer
;	O
if	O
(	O
p	pointer
->	O
section	pointer
->	O
output_section	pointer
==	O
s	pointer
)	O
{	O
alent	struct
*	O
l	long
=	O
BFD_SEND	O
(	O
bfd_asymbol_bfd	function
(	O
p	pointer
)	O
,	O
_get_lineno	pointer
,	O
(	O
bfd_asymbol_bfd	function
(	O
p	pointer
)	O
,	O
p	pointer
)	O
)	O
;	O
if	O
(	O
l	long
)	O
{	O
struct	O
internal_lineno	struct
out	struct
;	O
memset	function
(	O
(	O
void	O
*	O
)	O
&	O
out	struct
,	O
0	int
,	O
sizeof	O
(	O
out	struct
)	O
)	O
;	O
out	struct
.	O
l_lnno	long
=	O
0	int
;	O
out	struct
.	O
l_addr	union
.	O
l_symndx	long
=	O
l	long
->	O
u	union
.	O
offset	long
;	O
bfd_coff_swap_lineno_out	O
(	O
abfd	pointer
,	O
&	O
out	struct
,	O
buff	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
buff	pointer
,	O
(	O
bfd_size_type	long
)	O
linesz	long
,	O
abfd	pointer
)	O
!=	O
linesz	long
)	O
return	O
FALSE	int
;	O
l	long
++	O
;	O
while	O
(	O
l	long
->	O
line_number	int
)	O
{	O
out	struct
.	O
l_lnno	long
=	O
l	long
->	O
line_number	int
;	O
out	struct
.	O
l_addr	union
.	O
l_symndx	long
=	O
l	long
->	O
u	union
.	O
offset	long
;	O
bfd_coff_swap_lineno_out	O
(	O
abfd	pointer
,	O
&	O
out	struct
,	O
buff	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
buff	pointer
,	O
(	O
bfd_size_type	long
)	O
linesz	long
,	O
abfd	pointer
)	O
!=	O
linesz	long
)	O
return	O
FALSE	int
;	O
l	long
++	O
;	O
}	O
}	O
}	O
q	pointer
++	O
;	O
}	O
}	O
}	O
bfd_release	function
(	O
abfd	pointer
,	O
buff	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
alent	struct
*	O
coff_get_lineno	function
(	O
bfd	struct
*	O
ignore_abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
symbol	pointer
)	O
{	O
return	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
lineno	pointer
;	O
}	O
static	O
void	O
coff_pointerize_aux	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
combined_entry_type	struct
*	O
table_base	pointer
,	O
combined_entry_type	struct
*	O
symbol	pointer
,	O
unsigned	O
int	O
indaux	int
,	O
combined_entry_type	struct
*	O
auxent	union
,	O
combined_entry_type	struct
*	O
table_end	pointer
)	O
{	O
unsigned	O
int	O
type	enum
=	O
symbol	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
;	O
unsigned	O
int	O
n_sclass	char
=	O
symbol	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
;	O
BFD_ASSERT	O
(	O
symbol	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
coff_backend_info	O
(	O
abfd	pointer
)	O
->	O
_bfd_coff_pointerize_aux_hook	pointer
)	O
{	O
if	O
(	O
(	O
*	O
coff_backend_info	O
(	O
abfd	pointer
)	O
->	O
_bfd_coff_pointerize_aux_hook	pointer
)	O
(	O
abfd	pointer
,	O
table_base	pointer
,	O
symbol	pointer
,	O
indaux	int
,	O
auxent	union
)	O
)	O
return	O
;	O
}	O
if	O
(	O
n_sclass	char
==	O
C_STAT	int
&&	O
type	enum
==	O
T_NULL	int
)	O
return	O
;	O
if	O
(	O
n_sclass	char
==	O
C_FILE	int
)	O
return	O
;	O
BFD_ASSERT	O
(	O
!	O
auxent	union
->	O
is_sym	int
)	O
;	O
if	O
(	O
(	O
ISFCN	O
(	O
type	enum
)	O
||	O
ISTAG	O
(	O
n_sclass	char
)	O
||	O
n_sclass	char
==	O
C_BLOCK	int
||	O
n_sclass	char
==	O
C_FCN	int
)	O
&&	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
>	O
0	int
&&	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
<	O
(	O
long	O
)	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
&&	O
table_base	pointer
+	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
<	O
table_end	pointer
)	O
{	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
p	pointer
=	O
table_base	pointer
+	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
;	O
auxent	union
->	O
fix_end	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
<	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
&&	O
table_base	pointer
+	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
<	O
table_end	pointer
)	O
{	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
p	pointer
=	O
table_base	pointer
+	O
auxent	union
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
;	O
auxent	union
->	O
fix_tag	int
=	O
1	int
;	O
}	O
}	O
static	O
char	O
*	O
build_debug_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
*	O
sect_return	pointer
)	O
{	O
char	O
*	O
debug_section	pointer
;	O
file_ptr	long
position	long
;	O
bfd_size_type	long
sec_size	long
;	O
asection	struct
*	O
sect	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".debug"	pointer
)	O
;	O
if	O
(	O
!	O
sect	pointer
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_debug_section	int
)	O
;	O
return	O
NULL	O
;	O
}	O
sec_size	long
=	O
sect	pointer
->	O
size	long
;	O
debug_section	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sec_size	long
)	O
;	O
if	O
(	O
debug_section	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
position	long
=	O
bfd_tell	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
sect	pointer
->	O
filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
debug_section	pointer
,	O
sec_size	long
,	O
abfd	pointer
)	O
!=	O
sec_size	long
||	O
bfd_seek	function
(	O
abfd	pointer
,	O
position	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
*	O
sect_return	pointer
=	O
sect	pointer
;	O
return	O
debug_section	pointer
;	O
}	O
static	O
char	O
*	O
copy_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
name	pointer
,	O
size_t	long
maxlen	long
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
newname	pointer
;	O
for	O
(	O
len	long
=	O
0	int
;	O
len	long
<	O
maxlen	long
;	O
++	O
len	long
)	O
if	O
(	O
name	pointer
[	O
len	long
]	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
(	O
newname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
len	long
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
strncpy	function
(	O
newname	pointer
,	O
name	pointer
,	O
len	long
)	O
;	O
newname	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
newname	pointer
;	O
}	O
bfd_boolean	int
_bfd_coff_get_external_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
symesz	long
;	O
bfd_size_type	long
size	long
;	O
void	O
*	O
syms	pointer
;	O
if	O
(	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
symesz	long
=	O
bfd_coff_symesz	O
(	O
abfd	pointer
)	O
;	O
size	long
=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
*	O
symesz	long
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
size	long
<	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
||	O
(	O
bfd_get_file_size	function
(	O
abfd	pointer
)	O
>	O
0	int
&&	O
size	long
>	O
bfd_get_file_size	function
(	O
abfd	pointer
)	O
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: corrupt symbol count: %#"	pointer
PRIx64	O
""	pointer
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
syms	pointer
=	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
syms	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: not enough memory to allocate space "	pointer
"for %#"	pointer
PRIx64	O
" symbols of size %#"	pointer
PRIx64	O
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
,	O
(	O
uint64_t	long
)	O
symesz	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
syms	pointer
,	O
size	long
,	O
abfd	pointer
)	O
!=	O
size	long
)	O
{	O
if	O
(	O
syms	pointer
!=	O
NULL	O
)	O
free	function
(	O
syms	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
=	O
syms	pointer
;	O
return	O
TRUE	int
;	O
}	O
const	O
char	O
*	O
_bfd_coff_read_string_table	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
char	O
extstrsize	array
[	O
STRING_SIZE_SIZE	int
]	O
;	O
bfd_size_type	long
strsize	long
;	O
char	O
*	O
strings	pointer
;	O
file_ptr	long
pos	long
;	O
if	O
(	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
return	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_symbols	int
)	O
;	O
return	O
NULL	O
;	O
}	O
pos	long
=	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
;	O
pos	long
+=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
*	O
bfd_coff_symesz	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
bfd_bread	function
(	O
extstrsize	array
,	O
(	O
bfd_size_type	long
)	O
sizeof	O
extstrsize	array
,	O
abfd	pointer
)	O
!=	O
sizeof	O
extstrsize	array
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_file_truncated	int
)	O
return	O
NULL	O
;	O
strsize	long
=	O
STRING_SIZE_SIZE	int
;	O
}	O
else	O
{	O
strsize	long
=	O
H_GET_32	O
(	O
abfd	pointer
,	O
extstrsize	array
)	O
;	O
}	O
if	O
(	O
strsize	long
<	O
STRING_SIZE_SIZE	int
||	O
strsize	long
>	O
bfd_get_file_size	function
(	O
abfd	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: bad string table size %"	pointer
PRIu64	O
)	O
,	O
abfd	pointer
,	O
(	O
uint64_t	long
)	O
strsize	long
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
NULL	O
;	O
}	O
strings	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
strsize	long
+	O
1	int
)	O
;	O
if	O
(	O
strings	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memset	function
(	O
strings	pointer
,	O
0	int
,	O
STRING_SIZE_SIZE	int
)	O
;	O
if	O
(	O
bfd_bread	function
(	O
strings	pointer
+	O
STRING_SIZE_SIZE	int
,	O
strsize	long
-	O
STRING_SIZE_SIZE	int
,	O
abfd	pointer
)	O
!=	O
strsize	long
-	O
STRING_SIZE_SIZE	int
)	O
{	O
free	function
(	O
strings	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
=	O
strings	pointer
;	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
=	O
strsize	long
;	O
strings	pointer
[	O
strsize	long
]	O
=	O
0	int
;	O
return	O
strings	pointer
;	O
}	O
bfd_boolean	int
_bfd_coff_free_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
!	O
bfd_family_coff	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
&&	O
!	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
)	O
{	O
free	function
(	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
)	O
;	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
=	O
NULL	O
;	O
}	O
if	O
(	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
&&	O
!	O
obj_coff_keep_strings	O
(	O
abfd	pointer
)	O
)	O
{	O
free	function
(	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
)	O
;	O
obj_coff_strings	O
(	O
abfd	pointer
)	O
=	O
NULL	O
;	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
combined_entry_type	struct
*	O
coff_get_normalized_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
combined_entry_type	struct
*	O
internal	pointer
;	O
combined_entry_type	struct
*	O
internal_ptr	pointer
;	O
combined_entry_type	struct
*	O
symbol_ptr	pointer
;	O
combined_entry_type	struct
*	O
internal_end	pointer
;	O
size_t	long
symesz	long
;	O
char	O
*	O
raw_src	pointer
;	O
char	O
*	O
raw_end	pointer
;	O
const	O
char	O
*	O
string_table	pointer
=	O
NULL	O
;	O
asection	struct
*	O
debug_sec	pointer
=	O
NULL	O
;	O
char	O
*	O
debug_sec_data	pointer
=	O
NULL	O
;	O
bfd_size_type	long
size	long
;	O
if	O
(	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
return	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_coff_get_external_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
NULL	O
;	O
size	long
=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
size	long
>	O
(	O
bfd_size_type	long
)	O
-	O
1	int
/	O
sizeof	O
(	O
combined_entry_type	struct
)	O
)	O
return	O
NULL	O
;	O
size	long
*=	O
sizeof	O
(	O
combined_entry_type	struct
)	O
;	O
internal	pointer
=	O
(	O
combined_entry_type	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
size	long
)	O
;	O
if	O
(	O
internal	pointer
==	O
NULL	O
&&	O
size	long
!=	O
0	int
)	O
return	O
NULL	O
;	O
internal_end	pointer
=	O
internal	pointer
+	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
;	O
raw_src	pointer
=	O
(	O
char	O
*	O
)	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
;	O
symesz	long
=	O
bfd_coff_symesz	O
(	O
abfd	pointer
)	O
;	O
raw_end	pointer
=	O
(	O
char	O
*	O
)	O
raw_src	pointer
+	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
*	O
symesz	long
;	O
for	O
(	O
internal_ptr	pointer
=	O
internal	pointer
;	O
raw_src	pointer
<	O
raw_end	pointer
;	O
raw_src	pointer
+=	O
symesz	long
,	O
internal_ptr	pointer
++	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
bfd_coff_swap_sym_in	O
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
raw_src	pointer
,	O
(	O
void	O
*	O
)	O
&	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
)	O
;	O
symbol_ptr	pointer
=	O
internal_ptr	pointer
;	O
internal_ptr	pointer
->	O
is_sym	int
=	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symbol_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
i	pointer
++	O
)	O
{	O
internal_ptr	pointer
++	O
;	O
raw_src	pointer
+=	O
symesz	long
;	O
if	O
(	O
raw_src	pointer
>=	O
raw_end	pointer
||	O
internal_ptr	pointer
>=	O
internal_end	pointer
)	O
{	O
bfd_release	function
(	O
abfd	pointer
,	O
internal	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
bfd_coff_swap_aux_in	O
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
raw_src	pointer
,	O
symbol_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
,	O
symbol_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
,	O
(	O
int	O
)	O
i	pointer
,	O
symbol_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
,	O
&	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
auxent	union
)	O
)	O
;	O
internal_ptr	pointer
->	O
is_sym	int
=	O
FALSE	int
;	O
coff_pointerize_aux	function
(	O
abfd	pointer
,	O
internal	pointer
,	O
symbol_ptr	pointer
,	O
i	pointer
,	O
internal_ptr	pointer
,	O
internal_end	pointer
)	O
;	O
}	O
}	O
obj_coff_keep_strings	O
(	O
abfd	pointer
)	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
_bfd_coff_free_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
NULL	O
;	O
for	O
(	O
internal_ptr	pointer
=	O
internal	pointer
;	O
internal_ptr	pointer
<	O
internal_end	pointer
;	O
internal_ptr	pointer
++	O
)	O
{	O
BFD_ASSERT	O
(	O
internal_ptr	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
&&	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
>	O
0	int
)	O
{	O
combined_entry_type	struct
*	O
aux	pointer
=	O
internal_ptr	pointer
+	O
1	int
;	O
BFD_ASSERT	O
(	O
!	O
aux	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
aux	pointer
->	O
u	union
.	O
auxent	union
.	O
x_file	union
.	O
x_n	struct
.	O
x_zeroes	long
==	O
0	int
)	O
{	O
if	O
(	O
string_table	pointer
==	O
NULL	O
)	O
{	O
string_table	pointer
=	O
_bfd_coff_read_string_table	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
string_table	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
bfd_size_type	long
)	O
(	O
aux	pointer
->	O
u	union
.	O
auxent	union
.	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
)	O
>=	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
)	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
else	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
(	O
string_table	pointer
+	O
(	O
aux	pointer
->	O
u	union
.	O
auxent	union
.	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
>	O
1	int
&&	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
pe	struct
)	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
copy_name	function
(	O
abfd	pointer
,	O
aux	pointer
->	O
u	union
.	O
auxent	union
.	O
x_file	union
.	O
x_fname	array
,	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
*	O
symesz	long
)	O
;	O
else	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
(	O
bfd_hostptr_t	long
)	O
copy_name	function
(	O
abfd	pointer
,	O
aux	pointer
->	O
u	union
.	O
auxent	union
.	O
x_file	union
.	O
x_fname	array
,	O
(	O
size_t	long
)	O
bfd_coff_filnmlen	O
(	O
abfd	pointer
)	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
!=	O
0	int
)	O
{	O
size_t	long
i	pointer
;	O
char	O
*	O
newstring	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
8	int
;	O
++	O
i	pointer
)	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_name	array
[	O
i	pointer
]	O
==	O
'\0'	O
)	O
break	O
;	O
newstring	pointer
=	O
(	O
char	O
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
(	O
i	pointer
+	O
1	int
)	O
)	O
;	O
if	O
(	O
newstring	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
strncpy	function
(	O
newstring	pointer
,	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_name	array
,	O
i	pointer
)	O
;	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
newstring	pointer
;	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
==	O
0	int
)	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
""	pointer
;	O
else	O
if	O
(	O
!	O
bfd_coff_symname_in_debug	O
(	O
abfd	pointer
,	O
&	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
)	O
)	O
{	O
if	O
(	O
string_table	pointer
==	O
NULL	O
)	O
{	O
string_table	pointer
=	O
_bfd_coff_read_string_table	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
string_table	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
>=	O
obj_coff_strings_len	O
(	O
abfd	pointer
)	O
||	O
string_table	pointer
+	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
<	O
string_table	pointer
)	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
else	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
(	O
bfd_hostptr_t	long
)	O
(	O
string_table	pointer
+	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug_sec_data	pointer
==	O
NULL	O
)	O
debug_sec_data	pointer
=	O
build_debug_section	function
(	O
abfd	pointer
,	O
&	O
debug_sec	pointer
)	O
;	O
if	O
(	O
debug_sec_data	pointer
!=	O
NULL	O
)	O
{	O
BFD_ASSERT	O
(	O
debug_sec	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
>	O
debug_sec	pointer
->	O
size	long
||	O
debug_sec_data	pointer
+	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
<	O
debug_sec_data	pointer
)	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
else	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
(	O
debug_sec_data	pointer
+	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
)	O
;	O
}	O
else	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
(	O
bfd_hostptr_t	long
)	O
""	pointer
;	O
}	O
}	O
internal_ptr	pointer
+=	O
internal_ptr	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
}	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
=	O
internal	pointer
;	O
BFD_ASSERT	O
(	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
==	O
(	O
unsigned	O
int	O
)	O
(	O
internal_ptr	pointer
-	O
internal	pointer
)	O
)	O
;	O
return	O
internal	pointer
;	O
}	O
long	O
coff_get_reloc_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
asect	pointer
)	O
{	O
if	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
!=	O
bfd_object	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
(	O
asect	pointer
->	O
reloc_count	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
arelent	struct
*	O
)	O
;	O
}	O
asymbol	struct
*	O
coff_make_empty_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
coff_symbol_type	struct
)	O
;	O
coff_symbol_type	struct
*	O
new_symbol	pointer
=	O
(	O
coff_symbol_type	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
new_symbol	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
0	int
;	O
new_symbol	pointer
->	O
native	pointer
=	O
NULL	O
;	O
new_symbol	pointer
->	O
lineno	pointer
=	O
NULL	O
;	O
new_symbol	pointer
->	O
done_lineno	int
=	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
the_bfd	pointer
=	O
abfd	pointer
;	O
return	O
&	O
new_symbol	pointer
->	O
symbol	pointer
;	O
}	O
asymbol	struct
*	O
coff_bfd_make_debug_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
ptr	pointer
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
long	O
sz	long
ATTRIBUTE_UNUSED	O
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
coff_symbol_type	struct
)	O
;	O
coff_symbol_type	struct
*	O
new_symbol	pointer
=	O
(	O
coff_symbol_type	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
new_symbol	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
amt	long
=	O
sizeof	O
(	O
combined_entry_type	struct
)	O
*	O
10	int
;	O
new_symbol	pointer
->	O
native	pointer
=	O
(	O
combined_entry_type	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
!	O
new_symbol	pointer
->	O
native	pointer
)	O
return	O
NULL	O
;	O
new_symbol	pointer
->	O
native	pointer
->	O
is_sym	int
=	O
TRUE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
flags	int
=	O
BSF_DEBUGGING	O
;	O
new_symbol	pointer
->	O
lineno	pointer
=	O
NULL	O
;	O
new_symbol	pointer
->	O
done_lineno	int
=	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
the_bfd	pointer
=	O
abfd	pointer
;	O
return	O
&	O
new_symbol	pointer
->	O
symbol	pointer
;	O
}	O
void	O
coff_get_symbol_info	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
symbol_info	struct
*	O
ret	pointer
)	O
{	O
bfd_symbol_info	function
(	O
symbol	pointer
,	O
ret	pointer
)	O
;	O
if	O
(	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
!=	O
NULL	O
&&	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
->	O
fix_value	int
&&	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
->	O
is_sym	int
)	O
ret	pointer
->	O
value	long
=	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
-	O
(	O
bfd_hostptr_t	long
)	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
;	O
}	O
void	O
coff_print_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
filep	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
bfd_print_symbol_type	enum
how	enum
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
filep	pointer
;	O
switch	O
(	O
how	enum
)	O
{	O
case	O
bfd_print_symbol_name	int
:	O
fprintf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
bfd_print_symbol_more	int
:	O
fprintf	function
(	O
file	pointer
,	O
"coff %s %s"	pointer
,	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
?	O
"n"	pointer
:	O
"g"	pointer
,	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
lineno	pointer
?	O
"l"	pointer
:	O
" "	pointer
)	O
;	O
break	O
;	O
case	O
bfd_print_symbol_all	int
:	O
if	O
(	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
)	O
{	O
bfd_vma	long
val	array
;	O
unsigned	O
int	O
aux	pointer
;	O
combined_entry_type	struct
*	O
combined	pointer
=	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
;	O
combined_entry_type	struct
*	O
root	struct
=	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
;	O
struct	O
lineno_cache_entry	struct
*	O
l	long
=	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
lineno	pointer
;	O
fprintf	function
(	O
file	pointer
,	O
"[%3ld]"	pointer
,	O
(	O
long	O
)	O
(	O
combined	pointer
-	O
root	struct
)	O
)	O
;	O
if	O
(	O
combined	pointer
<	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
||	O
combined	pointer
>=	O
obj_raw_syments	O
(	O
abfd	pointer
)	O
+	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"<corrupt info> %s"	pointer
)	O
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
}	O
BFD_ASSERT	O
(	O
combined	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
!	O
combined	pointer
->	O
fix_value	int
)	O
val	array
=	O
(	O
bfd_vma	long
)	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
;	O
else	O
val	array
=	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
-	O
(	O
bfd_hostptr_t	long
)	O
root	struct
;	O
fprintf	function
(	O
file	pointer
,	O
"(sec %2d)(fl 0x%02x)(ty %3x)(scl %3d) (nx %d) 0x"	pointer
,	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
,	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_flags	short
,	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
,	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
,	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
val	array
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %s"	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
aux	pointer
=	O
0	int
;	O
aux	pointer
<	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
aux	pointer
++	O
)	O
{	O
combined_entry_type	struct
*	O
auxp	pointer
=	O
combined	pointer
+	O
aux	pointer
+	O
1	int
;	O
long	O
tagndx	long
;	O
BFD_ASSERT	O
(	O
!	O
auxp	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
auxp	pointer
->	O
fix_tag	int
)	O
tagndx	long
=	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
p	pointer
-	O
root	struct
;	O
else	O
tagndx	long
=	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
bfd_coff_print_aux	O
(	O
abfd	pointer
,	O
file	pointer
,	O
root	struct
,	O
combined	pointer
,	O
auxp	pointer
,	O
aux	pointer
)	O
)	O
continue	O
;	O
switch	O
(	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
)	O
{	O
case	O
C_FILE	int
:	O
fprintf	function
(	O
file	pointer
,	O
"File "	pointer
)	O
;	O
break	O
;	O
case	O
C_STAT	int
:	O
if	O
(	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
==	O
T_NULL	int
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"AUX scnlen 0x%lx nreloc %d nlnno %d"	pointer
,	O
(	O
unsigned	O
long	O
)	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_scnlen	long
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_nreloc	short
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_nlinno	short
)	O
;	O
if	O
(	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_checksum	long
!=	O
0	int
||	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_associated	short
!=	O
0	int
||	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_comdat	char
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
" checksum 0x%lx assoc %d comdat %d"	pointer
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_checksum	long
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_associated	short
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_scn	struct
.	O
x_comdat	char
)	O
;	O
break	O
;	O
}	O
case	O
C_EXT	int
:	O
case	O
C_AIX_WEAKEXT	int
:	O
if	O
(	O
ISFCN	O
(	O
combined	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
)	O
)	O
{	O
long	O
next	pointer
,	O
llnos	long
;	O
if	O
(	O
auxp	pointer
->	O
fix_end	int
)	O
next	pointer
=	O
(	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
p	pointer
-	O
root	struct
)	O
;	O
else	O
next	pointer
=	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
;	O
llnos	long
=	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_lnnoptr	long
;	O
fprintf	function
(	O
file	pointer
,	O
"AUX tagndx %ld ttlsiz 0x%lx lnnos %ld next %ld"	pointer
,	O
tagndx	long
,	O
(	O
unsigned	O
long	O
)	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_misc	union
.	O
x_fsize	long
,	O
llnos	long
,	O
next	pointer
)	O
;	O
break	O
;	O
}	O
default	O
:	O
fprintf	function
(	O
file	pointer
,	O
"AUX lnno %d size 0x%x tagndx %ld"	pointer
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_lnno	short
,	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_size	short
,	O
tagndx	long
)	O
;	O
if	O
(	O
auxp	pointer
->	O
fix_end	int
)	O
fprintf	function
(	O
file	pointer
,	O
" endndx %ld"	pointer
,	O
(	O
(	O
long	O
)	O
(	O
auxp	pointer
->	O
u	union
.	O
auxent	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
p	pointer
-	O
root	struct
)	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
l	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"\n%s :"	pointer
,	O
l	long
->	O
u	union
.	O
sym	pointer
->	O
name	pointer
)	O
;	O
l	long
++	O
;	O
while	O
(	O
l	long
->	O
line_number	int
)	O
{	O
if	O
(	O
l	long
->	O
line_number	int
>	O
0	int
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"\n%4d : "	pointer
,	O
l	long
->	O
line_number	int
)	O
;	O
bfd_fprintf_vma	function
(	O
abfd	pointer
,	O
file	pointer
,	O
l	long
->	O
u	union
.	O
offset	long
+	O
symbol	pointer
->	O
section	pointer
->	O
vma	long
)	O
;	O
}	O
l	long
++	O
;	O
}	O
}	O
}	O
else	O
{	O
bfd_print_symbol_vandf	function
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
file	pointer
,	O
symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %-5s %s %s %s"	pointer
,	O
symbol	pointer
->	O
section	pointer
->	O
name	pointer
,	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
native	pointer
?	O
"n"	pointer
:	O
"g"	pointer
,	O
coffsymbol	O
(	O
symbol	pointer
)	O
->	O
lineno	pointer
?	O
"l"	pointer
:	O
" "	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
}	O
bfd_boolean	int
_bfd_coff_is_local_label_name	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'L'	O
;	O
}	O
bfd_boolean	int
coff_find_nearest_line_with_names	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
symbols	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
offset	long
,	O
const	O
char	O
*	O
*	O
filename_ptr	pointer
,	O
const	O
char	O
*	O
*	O
functionname_ptr	pointer
,	O
unsigned	O
int	O
*	O
line_ptr	pointer
,	O
const	O
struct	O
dwarf_debug_section	struct
*	O
debug_sections	pointer
)	O
{	O
bfd_boolean	int
found	int
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
line_base	int
;	O
coff_data_type	struct
*	O
cof	pointer
=	O
coff_data	O
(	O
abfd	pointer
)	O
;	O
combined_entry_type	struct
*	O
p	pointer
;	O
combined_entry_type	struct
*	O
pend	pointer
;	O
alent	struct
*	O
l	long
;	O
struct	O
coff_section_tdata	struct
*	O
sec_data	pointer
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
!	O
_bfd_stab_section_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
section	pointer
,	O
offset	long
,	O
&	O
found	int
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
&	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
line_info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
found	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
_bfd_dwarf2_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
NULL	O
,	O
section	pointer
,	O
offset	long
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
NULL	O
,	O
debug_sections	pointer
,	O
&	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
)	O
return	O
TRUE	int
;	O
sec_data	pointer
=	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
;	O
if	O
(	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
!=	O
NULL	O
)	O
{	O
bfd_signed_vma	long
bias	long
=	O
0	int
;	O
if	O
(	O
sec_data	pointer
==	O
NULL	O
&&	O
section	pointer
->	O
owner	pointer
==	O
abfd	pointer
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
coff_section_tdata	struct
)	O
;	O
section	pointer
->	O
used_by_bfd	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
sec_data	pointer
=	O
(	O
struct	O
coff_section_tdata	struct
*	O
)	O
section	pointer
->	O
used_by_bfd	pointer
;	O
}	O
if	O
(	O
sec_data	pointer
!=	O
NULL	O
&&	O
sec_data	pointer
->	O
saved_bias	int
)	O
bias	long
=	O
sec_data	pointer
->	O
saved_bias	int
;	O
else	O
if	O
(	O
symbols	pointer
)	O
{	O
bias	long
=	O
_bfd_dwarf2_find_symbol_bias	function
(	O
symbols	pointer
,	O
&	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
;	O
if	O
(	O
sec_data	pointer
)	O
{	O
sec_data	pointer
->	O
saved_bias	int
=	O
TRUE	int
;	O
sec_data	pointer
->	O
bias	long
=	O
bias	long
;	O
}	O
}	O
if	O
(	O
bias	long
&&	O
_bfd_dwarf2_find_nearest_line	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
NULL	O
,	O
section	pointer
,	O
offset	long
+	O
bias	long
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
NULL	O
,	O
debug_sections	pointer
,	O
&	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
)	O
return	O
TRUE	int
;	O
}	O
*	O
filename_ptr	pointer
=	O
0	int
;	O
*	O
functionname_ptr	pointer
=	O
0	int
;	O
*	O
line_ptr	pointer
=	O
0	int
;	O
if	O
(	O
!	O
bfd_family_coff	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
cof	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
cof	pointer
->	O
raw_syments	pointer
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
FALSE	int
;	O
pend	pointer
=	O
p	pointer
+	O
cof	pointer
->	O
raw_syment_count	long
;	O
while	O
(	O
p	pointer
<	O
pend	pointer
)	O
{	O
BFD_ASSERT	O
(	O
p	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
)	O
break	O
;	O
p	pointer
+=	O
1	int
+	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
}	O
if	O
(	O
p	pointer
<	O
pend	pointer
)	O
{	O
bfd_vma	long
sec_vma	long
;	O
bfd_vma	long
maxdiff	long
;	O
sec_vma	long
=	O
bfd_section_vma	function
(	O
section	pointer
)	O
;	O
*	O
filename_ptr	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
;	O
maxdiff	long
=	O
(	O
bfd_vma	long
)	O
0	int
-	O
(	O
bfd_vma	long
)	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
bfd_vma	long
file_addr	long
;	O
combined_entry_type	struct
*	O
p2	pointer
;	O
for	O
(	O
p2	pointer
=	O
p	pointer
+	O
1	int
+	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
p2	pointer
<	O
pend	pointer
;	O
p2	pointer
+=	O
1	int
+	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
)	O
{	O
BFD_ASSERT	O
(	O
p2	pointer
->	O
is_sym	int
)	O
;	O
if	O
(	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
>	O
0	int
&&	O
(	O
section	pointer
==	O
coff_section_from_bfd_index	function
(	O
abfd	pointer
,	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
)	O
)	O
)	O
break	O
;	O
if	O
(	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
==	O
C_FILE	int
)	O
{	O
p2	pointer
=	O
pend	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
p2	pointer
>=	O
pend	pointer
)	O
break	O
;	O
file_addr	long
=	O
(	O
bfd_vma	long
)	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
;	O
if	O
(	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
>	O
0	int
)	O
file_addr	long
+=	O
coff_section_from_bfd_index	function
(	O
abfd	pointer
,	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
)	O
->	O
vma	long
;	O
if	O
(	O
p2	pointer
<	O
pend	pointer
&&	O
offset	long
+	O
sec_vma	long
>=	O
file_addr	long
&&	O
offset	long
+	O
sec_vma	long
-	O
file_addr	long
<=	O
maxdiff	long
)	O
{	O
*	O
filename_ptr	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
;	O
maxdiff	long
=	O
offset	long
+	O
sec_vma	long
-	O
p2	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
;	O
}	O
if	O
(	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
>=	O
cof	pointer
->	O
raw_syment_count	long
)	O
break	O
;	O
if	O
(	O
p	pointer
>=	O
cof	pointer
->	O
raw_syments	pointer
+	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
)	O
break	O
;	O
p	pointer
=	O
cof	pointer
->	O
raw_syments	pointer
+	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
;	O
if	O
(	O
!	O
p	pointer
->	O
is_sym	int
||	O
p	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
!=	O
C_FILE	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
section	pointer
->	O
lineno_count	int
==	O
0	int
)	O
{	O
*	O
functionname_ptr	pointer
=	O
NULL	O
;	O
*	O
line_ptr	pointer
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
sec_data	pointer
!=	O
NULL	O
&&	O
sec_data	pointer
->	O
i	pointer
>	O
0	int
&&	O
offset	long
>=	O
sec_data	pointer
->	O
offset	long
)	O
{	O
i	pointer
=	O
sec_data	pointer
->	O
i	pointer
;	O
*	O
functionname_ptr	pointer
=	O
sec_data	pointer
->	O
function	pointer
;	O
line_base	int
=	O
sec_data	pointer
->	O
line_base	int
;	O
}	O
else	O
{	O
i	pointer
=	O
0	int
;	O
line_base	int
=	O
0	int
;	O
}	O
if	O
(	O
section	pointer
->	O
lineno	pointer
!=	O
NULL	O
)	O
{	O
bfd_vma	long
last_value	long
=	O
0	int
;	O
l	long
=	O
&	O
section	pointer
->	O
lineno	pointer
[	O
i	pointer
]	O
;	O
for	O
(	O
;	O
i	pointer
<	O
section	pointer
->	O
lineno_count	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
l	long
->	O
line_number	int
==	O
0	int
)	O
{	O
coff_symbol_type	struct
*	O
coff	struct
=	O
(	O
coff_symbol_type	struct
*	O
)	O
(	O
l	long
->	O
u	union
.	O
sym	pointer
)	O
;	O
if	O
(	O
coff	struct
->	O
symbol	pointer
.	O
value	long
>	O
offset	long
)	O
break	O
;	O
*	O
functionname_ptr	pointer
=	O
coff	struct
->	O
symbol	pointer
.	O
name	pointer
;	O
last_value	long
=	O
coff	struct
->	O
symbol	pointer
.	O
value	long
;	O
if	O
(	O
coff	struct
->	O
native	pointer
)	O
{	O
combined_entry_type	struct
*	O
s	pointer
=	O
coff	struct
->	O
native	pointer
;	O
BFD_ASSERT	O
(	O
s	pointer
->	O
is_sym	int
)	O
;	O
s	pointer
=	O
s	pointer
+	O
1	int
+	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
if	O
(	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
==	O
N_DEBUG	O
)	O
s	pointer
=	O
s	pointer
+	O
1	int
+	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
;	O
if	O
(	O
s	pointer
->	O
u	union
.	O
syment	struct
.	O
n_numaux	char
)	O
{	O
union	O
internal_auxent	union
*	O
a	pointer
=	O
&	O
(	O
(	O
s	pointer
+	O
1	int
)	O
->	O
u	union
.	O
auxent	union
)	O
;	O
line_base	int
=	O
a	pointer
->	O
x_sym	struct
.	O
x_misc	union
.	O
x_lnsz	struct
.	O
x_lnno	short
;	O
*	O
line_ptr	pointer
=	O
line_base	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
l	long
->	O
u	union
.	O
offset	long
>	O
offset	long
)	O
break	O
;	O
*	O
line_ptr	pointer
=	O
l	long
->	O
line_number	int
+	O
line_base	int
-	O
1	int
;	O
}	O
l	long
++	O
;	O
}	O
if	O
(	O
i	pointer
>=	O
section	pointer
->	O
lineno_count	int
&&	O
last_value	long
!=	O
0	int
&&	O
offset	long
-	O
last_value	long
>	O
0x100	int
)	O
{	O
*	O
functionname_ptr	pointer
=	O
NULL	O
;	O
*	O
line_ptr	pointer
=	O
0	int
;	O
}	O
}	O
if	O
(	O
sec_data	pointer
==	O
NULL	O
&&	O
section	pointer
->	O
owner	pointer
==	O
abfd	pointer
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
coff_section_tdata	struct
)	O
;	O
section	pointer
->	O
used_by_bfd	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
sec_data	pointer
=	O
(	O
struct	O
coff_section_tdata	struct
*	O
)	O
section	pointer
->	O
used_by_bfd	pointer
;	O
}	O
if	O
(	O
sec_data	pointer
!=	O
NULL	O
)	O
{	O
sec_data	pointer
->	O
offset	long
=	O
offset	long
;	O
sec_data	pointer
->	O
i	pointer
=	O
i	pointer
-	O
1	int
;	O
sec_data	pointer
->	O
function	pointer
=	O
*	O
functionname_ptr	pointer
;	O
sec_data	pointer
->	O
line_base	int
=	O
line_base	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
coff_find_nearest_line	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
symbols	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
offset	long
,	O
const	O
char	O
*	O
*	O
filename_ptr	pointer
,	O
const	O
char	O
*	O
*	O
functionname_ptr	pointer
,	O
unsigned	O
int	O
*	O
line_ptr	pointer
,	O
unsigned	O
int	O
*	O
discriminator_ptr	pointer
)	O
{	O
if	O
(	O
discriminator_ptr	pointer
)	O
*	O
discriminator_ptr	pointer
=	O
0	int
;	O
return	O
coff_find_nearest_line_with_names	function
(	O
abfd	pointer
,	O
symbols	pointer
,	O
section	pointer
,	O
offset	long
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
dwarf_debug_sections	array
)	O
;	O
}	O
bfd_boolean	int
coff_find_inliner_info	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
*	O
filename_ptr	pointer
,	O
const	O
char	O
*	O
*	O
functionname_ptr	pointer
,	O
unsigned	O
int	O
*	O
line_ptr	pointer
)	O
{	O
bfd_boolean	int
found	int
;	O
found	int
=	O
_bfd_dwarf2_find_inliner_info	function
(	O
abfd	pointer
,	O
filename_ptr	pointer
,	O
functionname_ptr	pointer
,	O
line_ptr	pointer
,	O
&	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
dwarf2_find_line_info	pointer
)	O
;	O
return	O
(	O
found	int
)	O
;	O
}	O
int	O
coff_sizeof_headers	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
size_t	long
size	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
size	long
=	O
bfd_coff_filhsz	O
(	O
abfd	pointer
)	O
+	O
bfd_coff_aoutsz	O
(	O
abfd	pointer
)	O
;	O
else	O
size	long
=	O
bfd_coff_filhsz	O
(	O
abfd	pointer
)	O
;	O
size	long
+=	O
abfd	pointer
->	O
section_count	int
*	O
bfd_coff_scnhsz	O
(	O
abfd	pointer
)	O
;	O
return	O
size	long
;	O
}	O
bfd_boolean	int
bfd_coff_set_symbol_class	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
unsigned	O
int	O
symbol_class	char
)	O
{	O
coff_symbol_type	struct
*	O
csym	pointer
;	O
csym	pointer
=	O
coff_symbol_from	O
(	O
symbol	pointer
)	O
;	O
if	O
(	O
csym	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
csym	pointer
->	O
native	pointer
==	O
NULL	O
)	O
{	O
combined_entry_type	struct
*	O
native	pointer
;	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
*	O
native	pointer
)	O
;	O
native	pointer
=	O
(	O
combined_entry_type	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
native	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
native	pointer
->	O
is_sym	int
=	O
TRUE	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_type	short
=	O
T_NULL	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
symbol_class	char
;	O
if	O
(	O
bfd_is_und_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
symbol	pointer
->	O
value	long
;	O
}	O
else	O
if	O
(	O
bfd_is_com_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
symbol	pointer
->	O
value	long
;	O
}	O
else	O
{	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_scnum	int
=	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
->	O
target_index	int
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
=	O
(	O
symbol	pointer
->	O
value	long
+	O
symbol	pointer
->	O
section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
!	O
obj_pe	O
(	O
abfd	pointer
)	O
)	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_value	long
+=	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_flags	short
=	O
bfd_asymbol_bfd	function
(	O
&	O
csym	pointer
->	O
symbol	pointer
)	O
->	O
flags	int
;	O
}	O
csym	pointer
->	O
native	pointer
=	O
native	pointer
;	O
}	O
else	O
csym	pointer
->	O
native	pointer
->	O
u	union
.	O
syment	struct
.	O
n_sclass	char
=	O
symbol_class	char
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_coff_section_already_linked	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
flagword	int
flags	int
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
key	long
;	O
struct	O
bfd_section_already_linked	function
*	O
l	long
;	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
already_linked_list	pointer
;	O
struct	O
coff_comdat_info	struct
*	O
s_comdat	pointer
;	O
if	O
(	O
sec	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
)	O
return	O
FALSE	int
;	O
flags	int
=	O
sec	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_LINK_ONCE	int
)	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
s_comdat	pointer
=	O
bfd_coff_get_comdat_section	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
s_comdat	pointer
!=	O
NULL	O
)	O
key	long
=	O
s_comdat	pointer
->	O
name	pointer
;	O
else	O
{	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
".gnu.linkonce."	pointer
)	O
&&	O
(	O
key	long
=	O
strchr	function
(	O
name	pointer
+	O
sizeof	O
(	O
".gnu.linkonce."	pointer
)	O
-	O
1	int
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
key	long
++	O
;	O
else	O
key	long
=	O
name	pointer
;	O
}	O
already_linked_list	pointer
=	O
bfd_section_already_linked_table_lookup	function
(	O
key	long
)	O
;	O
for	O
(	O
l	long
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
l	long
!=	O
NULL	O
;	O
l	long
=	O
l	long
->	O
next	pointer
)	O
{	O
struct	O
coff_comdat_info	struct
*	O
l_comdat	pointer
;	O
l_comdat	pointer
=	O
bfd_coff_get_comdat_section	O
(	O
l	long
->	O
sec	pointer
->	O
owner	pointer
,	O
l	long
->	O
sec	pointer
)	O
;	O
if	O
(	O
(	O
(	O
s_comdat	pointer
!=	O
NULL	O
)	O
==	O
(	O
l_comdat	pointer
!=	O
NULL	O
)	O
&&	O
strcmp	function
(	O
name	pointer
,	O
l	long
->	O
sec	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
||	O
(	O
l	long
->	O
sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
{	O
return	O
_bfd_handle_already_linked	function
(	O
sec	pointer
,	O
l	long
,	O
info	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
bfd_section_already_linked_table_insert	function
(	O
already_linked_list	pointer
,	O
sec	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: already_linked_table: %E\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
init_reloc_cookie	function
(	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_coff_slurp_symbol_table	O
(	O
abfd	pointer
)	O
;	O
cookie	pointer
->	O
abfd	pointer
=	O
abfd	pointer
;	O
cookie	pointer
->	O
sym_hashes	pointer
=	O
obj_coff_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
cookie	pointer
->	O
symbols	pointer
=	O
obj_symbols	O
(	O
abfd	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
fini_reloc_cookie	function
(	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
static	O
bfd_boolean	int
init_reloc_cookie_rels	function
(	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
reloc_count	int
==	O
0	int
)	O
{	O
cookie	pointer
->	O
rels	pointer
=	O
NULL	O
;	O
cookie	pointer
->	O
relend	pointer
=	O
NULL	O
;	O
cookie	pointer
->	O
rel	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
cookie	pointer
->	O
rels	pointer
=	O
_bfd_coff_read_internal_relocs	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
FALSE	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
cookie	pointer
->	O
rels	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
cookie	pointer
->	O
rel	pointer
=	O
cookie	pointer
->	O
rels	pointer
;	O
cookie	pointer
->	O
relend	pointer
=	O
(	O
cookie	pointer
->	O
rels	pointer
+	O
sec	pointer
->	O
reloc_count	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
fini_reloc_cookie_rels	function
(	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
cookie	pointer
->	O
rels	pointer
&&	O
coff_section_data	O
(	O
NULL	O
,	O
sec	pointer
)	O
&&	O
coff_section_data	O
(	O
NULL	O
,	O
sec	pointer
)	O
->	O
relocs	pointer
!=	O
cookie	pointer
->	O
rels	pointer
)	O
free	function
(	O
cookie	pointer
->	O
rels	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
init_reloc_cookie_for_section	function
(	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
!	O
init_reloc_cookie	function
(	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
init_reloc_cookie_rels	function
(	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
{	O
fini_reloc_cookie	function
(	O
cookie	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
fini_reloc_cookie_for_section	function
(	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
fini_reloc_cookie_rels	function
(	O
cookie	pointer
,	O
sec	pointer
)	O
;	O
fini_reloc_cookie	function
(	O
cookie	pointer
,	O
sec	pointer
->	O
owner	pointer
)	O
;	O
}	O
static	O
asection	struct
*	O
_bfd_coff_gc_mark_hook	function
(	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
internal_reloc	struct
*	O
rel	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
,	O
struct	O
internal_syment	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
return	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
case	O
bfd_link_hash_common	int
:	O
return	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
;	O
case	O
bfd_link_hash_undefweak	int
:	O
if	O
(	O
h	pointer
->	O
symbol_class	char
==	O
C_NT_WEAK	int
&&	O
h	pointer
->	O
numaux	char
==	O
1	int
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h2	pointer
=	O
h	pointer
->	O
auxbfd	pointer
->	O
tdata	union
.	O
coff_obj_data	pointer
->	O
sym_hashes	pointer
[	O
h	pointer
->	O
aux	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
]	O
;	O
if	O
(	O
h2	pointer
&&	O
h2	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefined	int
)	O
return	O
h2	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
}	O
break	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
return	O
coff_section_from_bfd_index	function
(	O
sec	pointer
->	O
owner	pointer
,	O
sym	pointer
->	O
n_scnum	int
)	O
;	O
}	O
static	O
asection	struct
*	O
_bfd_coff_gc_mark_rsec	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
coff_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
,	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
cookie	pointer
->	O
sym_hashes	pointer
[	O
cookie	pointer
->	O
rel	pointer
->	O
r_symndx	long
]	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
return	O
(	O
*	O
gc_mark_hook	pointer
)	O
(	O
sec	pointer
,	O
info	pointer
,	O
cookie	pointer
->	O
rel	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
*	O
gc_mark_hook	pointer
)	O
(	O
sec	pointer
,	O
info	pointer
,	O
cookie	pointer
->	O
rel	pointer
,	O
NULL	O
,	O
&	O
(	O
cookie	pointer
->	O
symbols	pointer
+	O
obj_convert	O
(	O
sec	pointer
->	O
owner	pointer
)	O
[	O
cookie	pointer
->	O
rel	pointer
->	O
r_symndx	long
]	O
)	O
->	O
native	pointer
->	O
u	union
.	O
syment	struct
)	O
;	O
}	O
static	O
bfd_boolean	int
_bfd_coff_gc_mark	function
(	O
struct	O
bfd_link_info	struct
*	O
,	O
asection	struct
*	O
,	O
coff_gc_mark_hook_fn	pointer
)	O
;	O
static	O
bfd_boolean	int
_bfd_coff_gc_mark_reloc	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
coff_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
,	O
struct	O
coff_reloc_cookie	struct
*	O
cookie	pointer
)	O
{	O
asection	struct
*	O
rsec	pointer
;	O
rsec	pointer
=	O
_bfd_coff_gc_mark_rsec	function
(	O
info	pointer
,	O
sec	pointer
,	O
gc_mark_hook	pointer
,	O
cookie	pointer
)	O
;	O
if	O
(	O
rsec	pointer
&&	O
!	O
rsec	pointer
->	O
gc_mark	int
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
rsec	pointer
->	O
owner	pointer
)	O
!=	O
bfd_target_coff_flavour	int
)	O
rsec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
_bfd_coff_gc_mark	function
(	O
info	pointer
,	O
rsec	pointer
,	O
gc_mark_hook	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
_bfd_coff_gc_mark	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
coff_gc_mark_hook_fn	pointer
gc_mark_hook	pointer
)	O
{	O
bfd_boolean	int
ret	pointer
=	O
TRUE	int
;	O
sec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
&&	O
sec	pointer
->	O
reloc_count	int
>	O
0	int
)	O
{	O
struct	O
coff_reloc_cookie	struct
cookie	pointer
;	O
if	O
(	O
!	O
init_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
info	pointer
,	O
sec	pointer
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
{	O
for	O
(	O
;	O
cookie	pointer
.	O
rel	pointer
<	O
cookie	pointer
.	O
relend	pointer
;	O
cookie	pointer
.	O
rel	pointer
++	O
)	O
{	O
if	O
(	O
!	O
_bfd_coff_gc_mark_reloc	function
(	O
info	pointer
,	O
sec	pointer
,	O
gc_mark_hook	pointer
,	O
&	O
cookie	pointer
)	O
)	O
{	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
fini_reloc_cookie_for_section	function
(	O
&	O
cookie	pointer
,	O
sec	pointer
)	O
;	O
}	O
}	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
_bfd_coff_gc_mark_extra_sections	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
coff_gc_mark_hook_fn	pointer
mark_hook	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
bfd	struct
*	O
ibfd	pointer
;	O
for	O
(	O
ibfd	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
ibfd	pointer
!=	O
NULL	O
;	O
ibfd	pointer
=	O
ibfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
isec	pointer
;	O
bfd_boolean	int
some_kept	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_coff_flavour	int
)	O
continue	O
;	O
some_kept	int
=	O
FALSE	int
;	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
)	O
isec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
else	O
if	O
(	O
isec	pointer
->	O
gc_mark	int
)	O
some_kept	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
some_kept	int
)	O
continue	O
;	O
for	O
(	O
isec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
isec	pointer
!=	O
NULL	O
;	O
isec	pointer
=	O
isec	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
isec	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
||	O
(	O
isec	pointer
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
)	O
==	O
0	int
)	O
isec	pointer
->	O
gc_mark	int
=	O
1	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
coff_gc_sweep_symbol	function
(	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
!	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
gc_mark	int
&&	O
!	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
)	O
{	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
h	pointer
->	O
symbol_class	char
=	O
C_HIDDEN	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
typedef	O
bfd_boolean	int
(	O
*	O
gc_sweep_hook_fn	pointer
)	O
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
asection	struct
*	O
,	O
const	O
struct	O
internal_reloc	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
coff_gc_sweep	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
sub	pointer
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
o	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
!=	O
bfd_target_coff_flavour	int
)	O
continue	O
;	O
for	O
(	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
(	O
SEC_DEBUGGING	int
|	O
SEC_LINKER_CREATED	int
)	O
)	O
!=	O
0	int
||	O
(	O
o	pointer
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
)	O
==	O
0	int
)	O
o	pointer
->	O
gc_mark	int
=	O
1	int
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".idata"	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".pdata"	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".xdata"	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".rsrc"	pointer
)	O
)	O
o	pointer
->	O
gc_mark	int
=	O
1	int
;	O
if	O
(	O
o	pointer
->	O
gc_mark	int
)	O
continue	O
;	O
if	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
continue	O
;	O
o	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
;	O
if	O
(	O
info	pointer
->	O
print_gc_sections	int
&&	O
o	pointer
->	O
size	long
!=	O
0	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"removing unused section '%pA' in file '%pB'"	pointer
)	O
,	O
o	pointer
,	O
sub	pointer
)	O
;	O
}	O
}	O
coff_link_hash_traverse	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
coff_gc_sweep_symbol	function
,	O
NULL	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
_bfd_coff_gc_keep	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
bfd_sym_chain	struct
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
info	pointer
->	O
gc_sym_list	pointer
;	O
sym	pointer
!=	O
NULL	O
;	O
sym	pointer
=	O
sym	pointer
->	O
next	pointer
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
sym	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
!	O
bfd_is_abs_section	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
}	O
}	O
bfd_boolean	int
bfd_coff_gc_sections	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
sub	pointer
;	O
_bfd_coff_gc_keep	function
(	O
info	pointer
)	O
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
asection	struct
*	O
o	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
sub	pointer
)	O
!=	O
bfd_target_coff_flavour	int
)	O
continue	O
;	O
for	O
(	O
o	pointer
=	O
sub	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
(	O
SEC_EXCLUDE	int
|	O
SEC_KEEP	int
)	O
)	O
==	O
SEC_KEEP	int
||	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".vectors"	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".ctors"	pointer
)	O
||	O
CONST_STRNEQ	O
(	O
o	pointer
->	O
name	pointer
,	O
".dtors"	pointer
)	O
)	O
&&	O
!	O
o	pointer
->	O
gc_mark	int
)	O
{	O
if	O
(	O
!	O
_bfd_coff_gc_mark	function
(	O
info	pointer
,	O
o	pointer
,	O
_bfd_coff_gc_mark_hook	function
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
_bfd_coff_gc_mark_extra_sections	function
(	O
info	pointer
,	O
_bfd_coff_gc_mark_hook	function
)	O
;	O
return	O
coff_gc_sweep	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
const	O
char	O
*	O
bfd_coff_group_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
coff_comdat_info	struct
*	O
ci	pointer
=	O
bfd_coff_get_comdat_section	O
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
ci	pointer
!=	O
NULL	O
)	O
return	O
ci	pointer
->	O
name	pointer
;	O
return	O
NULL	O
;	O
}	O
bfd_boolean	int
_bfd_coff_close_and_cleanup	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
format	enum
==	O
bfd_object	int
&&	O
bfd_family_coff	function
(	O
abfd	pointer
)	O
&&	O
coff_data	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
)	O
{	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
=	O
FALSE	int
;	O
obj_coff_keep_strings	O
(	O
abfd	pointer
)	O
=	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_coff_free_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
_bfd_generic_close_and_cleanup	O
(	O
abfd	pointer
)	O
;	O
}	O