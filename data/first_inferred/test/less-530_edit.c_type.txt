public	O
int	O
fd0	int
=	O
0	int
;	O
extern	O
int	O
new_file	int
;	O
extern	O
int	O
errmsgs	int
;	O
extern	O
int	O
cbufs	int
;	O
extern	O
char	O
*	O
every_first_cmd	pointer
;	O
extern	O
int	O
any_display	int
;	O
extern	O
int	O
force_open	int
;	O
extern	O
int	O
is_tty	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
IFILE	O
curr_ifile	pointer
;	O
extern	O
IFILE	O
old_ifile	pointer
;	O
extern	O
struct	O
scrpos	struct
initial_scrpos	struct
;	O
extern	O
void	O
*	O
ml_examine	pointer
;	O
extern	O
char	O
openquote	char
;	O
extern	O
char	O
closequote	char
;	O
extern	O
int	O
logfile	int
;	O
extern	O
int	O
force_logfile	int
;	O
extern	O
char	O
*	O
namelogfile	pointer
;	O
public	O
dev_t	long
curr_dev	long
;	O
public	O
ino_t	long
curr_ino	long
;	O
public	O
void	O
init_textlist	function
(	O
tlist	pointer
,	O
str	pointer
)	O
struct	O
textlist	struct
*	O
tlist	pointer
;	O
char	O
*	O
str	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
meta_quoted	int
=	O
0	int
;	O
int	O
delim_quoted	int
=	O
0	int
;	O
char	O
*	O
esc	pointer
=	O
get_meta_escape	function
(	O
)	O
;	O
int	O
esclen	int
=	O
(	O
int	O
)	O
strlen	function
(	O
esc	pointer
)	O
;	O
tlist	pointer
->	O
string	pointer
=	O
skipsp	function
(	O
str	pointer
)	O
;	O
tlist	pointer
->	O
endstring	pointer
=	O
tlist	pointer
->	O
string	pointer
+	O
strlen	function
(	O
tlist	pointer
->	O
string	pointer
)	O
;	O
for	O
(	O
s	pointer
=	O
str	pointer
;	O
s	pointer
<	O
tlist	pointer
->	O
endstring	pointer
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
meta_quoted	int
)	O
{	O
meta_quoted	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
esclen	int
>	O
0	int
&&	O
s	pointer
+	O
esclen	int
<	O
tlist	pointer
->	O
endstring	pointer
&&	O
strncmp	function
(	O
s	pointer
,	O
esc	pointer
,	O
esclen	int
)	O
==	O
0	int
)	O
{	O
meta_quoted	int
=	O
1	int
;	O
s	pointer
+=	O
esclen	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
delim_quoted	int
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
closequote	char
)	O
delim_quoted	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
s	pointer
==	O
openquote	char
)	O
delim_quoted	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
*	O
s	pointer
=	O
'\0'	O
;	O
}	O
}	O
}	O
public	O
char	O
*	O
forw_textlist	function
(	O
tlist	pointer
,	O
prev	pointer
)	O
struct	O
textlist	struct
*	O
tlist	pointer
;	O
char	O
*	O
prev	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
prev	pointer
==	O
NULL	O
)	O
s	pointer
=	O
tlist	pointer
->	O
string	pointer
;	O
else	O
s	pointer
=	O
prev	pointer
+	O
strlen	function
(	O
prev	pointer
)	O
;	O
if	O
(	O
s	pointer
>=	O
tlist	pointer
->	O
endstring	pointer
)	O
return	O
(	O
NULL	O
)	O
;	O
while	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
s	pointer
++	O
;	O
if	O
(	O
s	pointer
>=	O
tlist	pointer
->	O
endstring	pointer
)	O
return	O
(	O
NULL	O
)	O
;	O
return	O
(	O
s	pointer
)	O
;	O
}	O
public	O
char	O
*	O
back_textlist	function
(	O
tlist	pointer
,	O
prev	pointer
)	O
struct	O
textlist	struct
*	O
tlist	pointer
;	O
char	O
*	O
prev	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
prev	pointer
==	O
NULL	O
)	O
s	pointer
=	O
tlist	pointer
->	O
endstring	pointer
;	O
else	O
if	O
(	O
prev	pointer
<=	O
tlist	pointer
->	O
string	pointer
)	O
return	O
(	O
NULL	O
)	O
;	O
else	O
s	pointer
=	O
prev	pointer
-	O
1	int
;	O
while	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
s	pointer
--	O
;	O
if	O
(	O
s	pointer
<=	O
tlist	pointer
->	O
string	pointer
)	O
return	O
(	O
NULL	O
)	O
;	O
while	O
(	O
s	pointer
[	O
-	O
1	int
]	O
!=	O
'\0'	O
&&	O
s	pointer
>	O
tlist	pointer
->	O
string	pointer
)	O
s	pointer
--	O
;	O
return	O
(	O
s	pointer
)	O
;	O
}	O
static	O
void	O
close_pipe	function
(	O
FILE	struct
*	O
pipefd	pointer
)	O
{	O
if	O
(	O
pipefd	pointer
==	O
NULL	O
)	O
return	O
;	O
pclose	function
(	O
pipefd	pointer
)	O
;	O
}	O
static	O
void	O
close_file	function
(	O
)	O
{	O
struct	O
scrpos	struct
scrpos	struct
;	O
int	O
chflags	int
;	O
FILE	struct
*	O
altpipe	pointer
;	O
char	O
*	O
altfilename	pointer
;	O
if	O
(	O
curr_ifile	pointer
==	O
NULL_IFILE	O
)	O
return	O
;	O
get_scrpos	function
(	O
&	O
scrpos	struct
,	O
TOP	O
)	O
;	O
if	O
(	O
scrpos	struct
.	O
pos	long
!=	O
NULL_POSITION	O
)	O
{	O
store_pos	function
(	O
curr_ifile	pointer
,	O
&	O
scrpos	struct
)	O
;	O
lastmark	function
(	O
)	O
;	O
}	O
chflags	int
=	O
ch_getflags	function
(	O
)	O
;	O
ch_close	function
(	O
)	O
;	O
altfilename	pointer
=	O
get_altfilename	function
(	O
curr_ifile	pointer
)	O
;	O
if	O
(	O
altfilename	pointer
!=	O
NULL	O
)	O
{	O
altpipe	pointer
=	O
get_altpipe	function
(	O
curr_ifile	pointer
)	O
;	O
if	O
(	O
altpipe	pointer
!=	O
NULL	O
&&	O
!	O
(	O
chflags	int
&	O
CH_KEEPOPEN	int
)	O
)	O
{	O
close_pipe	function
(	O
altpipe	pointer
)	O
;	O
set_altpipe	function
(	O
curr_ifile	pointer
,	O
NULL	O
)	O
;	O
}	O
close_altfile	function
(	O
altfilename	pointer
,	O
get_filename	function
(	O
curr_ifile	pointer
)	O
)	O
;	O
set_altfilename	function
(	O
curr_ifile	pointer
,	O
NULL	O
)	O
;	O
}	O
curr_ifile	pointer
=	O
NULL_IFILE	O
;	O
curr_ino	long
=	O
curr_dev	long
=	O
0	int
;	O
}	O
public	O
int	O
edit	function
(	O
filename	pointer
)	O
char	O
*	O
filename	pointer
;	O
{	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
return	O
(	O
edit_ifile	function
(	O
NULL_IFILE	O
)	O
)	O
;	O
return	O
(	O
edit_ifile	function
(	O
get_ifile	function
(	O
filename	pointer
,	O
curr_ifile	pointer
)	O
)	O
)	O
;	O
}	O
public	O
int	O
edit_ifile	function
(	O
ifile	pointer
)	O
IFILE	O
ifile	pointer
;	O
{	O
int	O
f	int
;	O
int	O
answer	int
;	O
int	O
no_display	int
;	O
int	O
chflags	int
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
open_filename	pointer
;	O
char	O
*	O
alt_filename	pointer
;	O
void	O
*	O
altpipe	pointer
;	O
IFILE	O
was_curr_ifile	pointer
;	O
PARG	union
parg	union
;	O
if	O
(	O
ifile	pointer
==	O
curr_ifile	pointer
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
end_logfile	function
(	O
)	O
;	O
was_curr_ifile	pointer
=	O
save_curr_ifile	function
(	O
)	O
;	O
if	O
(	O
curr_ifile	pointer
!=	O
NULL_IFILE	O
)	O
{	O
chflags	int
=	O
ch_getflags	function
(	O
)	O
;	O
close_file	function
(	O
)	O
;	O
if	O
(	O
(	O
chflags	int
&	O
CH_HELPFILE	int
)	O
&&	O
held_ifile	function
(	O
was_curr_ifile	pointer
)	O
<=	O
1	int
)	O
{	O
del_ifile	function
(	O
was_curr_ifile	pointer
)	O
;	O
was_curr_ifile	pointer
=	O
old_ifile	pointer
;	O
}	O
}	O
if	O
(	O
ifile	pointer
==	O
NULL_IFILE	O
)	O
{	O
unsave_ifile	function
(	O
was_curr_ifile	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
filename	pointer
=	O
save	function
(	O
get_filename	function
(	O
ifile	pointer
)	O
)	O
;	O
altpipe	pointer
=	O
get_altpipe	function
(	O
ifile	pointer
)	O
;	O
if	O
(	O
altpipe	pointer
!=	O
NULL	O
)	O
{	O
chflags	int
=	O
0	int
;	O
f	int
=	O
-	O
1	int
;	O
alt_filename	pointer
=	O
get_altfilename	function
(	O
ifile	pointer
)	O
;	O
open_filename	pointer
=	O
(	O
alt_filename	pointer
!=	O
NULL	O
)	O
?	O
alt_filename	pointer
:	O
filename	pointer
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
FAKE_HELPFILE	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
filename	pointer
,	O
FAKE_EMPTYFILE	pointer
)	O
==	O
0	int
)	O
alt_filename	pointer
=	O
NULL	O
;	O
else	O
alt_filename	pointer
=	O
open_altfile	function
(	O
filename	pointer
,	O
&	O
f	int
,	O
&	O
altpipe	pointer
)	O
;	O
open_filename	pointer
=	O
(	O
alt_filename	pointer
!=	O
NULL	O
)	O
?	O
alt_filename	pointer
:	O
filename	pointer
;	O
chflags	int
=	O
0	int
;	O
if	O
(	O
altpipe	pointer
!=	O
NULL	O
)	O
{	O
chflags	int
|=	O
CH_POPENED	int
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
chflags	int
|=	O
CH_KEEPOPEN	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
f	int
=	O
fd0	int
;	O
chflags	int
|=	O
CH_KEEPOPEN	int
;	O
SET_BINARY	O
(	O
f	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
open_filename	pointer
,	O
FAKE_EMPTYFILE	pointer
)	O
==	O
0	int
)	O
{	O
f	int
=	O
-	O
1	int
;	O
chflags	int
|=	O
CH_NODATA	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
open_filename	pointer
,	O
FAKE_HELPFILE	pointer
)	O
==	O
0	int
)	O
{	O
f	int
=	O
-	O
1	int
;	O
chflags	int
|=	O
CH_HELPFILE	int
;	O
}	O
else	O
if	O
(	O
(	O
parg	union
.	O
p_string	pointer
=	O
bad_file	function
(	O
open_filename	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
error	function
(	O
"%s"	pointer
,	O
&	O
parg	union
)	O
;	O
free	function
(	O
parg	union
.	O
p_string	pointer
)	O
;	O
err1	O
:	O
if	O
(	O
alt_filename	pointer
!=	O
NULL	O
)	O
{	O
close_pipe	function
(	O
altpipe	pointer
)	O
;	O
close_altfile	function
(	O
alt_filename	pointer
,	O
filename	pointer
)	O
;	O
free	function
(	O
alt_filename	pointer
)	O
;	O
}	O
del_ifile	function
(	O
ifile	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
was_curr_ifile	pointer
==	O
ifile	pointer
)	O
{	O
quit	function
(	O
QUIT_ERROR	int
)	O
;	O
}	O
reedit_ifile	function
(	O
was_curr_ifile	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
f	int
=	O
open	function
(	O
open_filename	pointer
,	O
OPEN_READ	O
)	O
)	O
<	O
0	int
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
errno_message	function
(	O
filename	pointer
)	O
;	O
error	function
(	O
"%s"	pointer
,	O
&	O
parg	union
)	O
;	O
free	function
(	O
parg	union
.	O
p_string	pointer
)	O
;	O
goto	O
err1	O
;	O
}	O
else	O
{	O
chflags	int
|=	O
CH_CANSEEK	int
;	O
if	O
(	O
!	O
force_open	int
&&	O
!	O
opened	function
(	O
ifile	pointer
)	O
&&	O
bin_file	function
(	O
f	int
)	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
filename	pointer
;	O
answer	int
=	O
query	function
(	O
"\"%s\" may be a binary file.  See it anyway? "	pointer
,	O
&	O
parg	union
)	O
;	O
if	O
(	O
answer	int
!=	O
'y'	O
&&	O
answer	int
!=	O
'Y'	O
)	O
{	O
close	function
(	O
f	int
)	O
;	O
goto	O
err1	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
was_curr_ifile	pointer
!=	O
NULL_IFILE	O
)	O
{	O
old_ifile	pointer
=	O
was_curr_ifile	pointer
;	O
unsave_ifile	function
(	O
was_curr_ifile	pointer
)	O
;	O
}	O
curr_ifile	pointer
=	O
ifile	pointer
;	O
set_altfilename	function
(	O
curr_ifile	pointer
,	O
alt_filename	pointer
)	O
;	O
set_altpipe	function
(	O
curr_ifile	pointer
,	O
altpipe	pointer
)	O
;	O
set_open	function
(	O
curr_ifile	pointer
)	O
;	O
get_pos	function
(	O
curr_ifile	pointer
,	O
&	O
initial_scrpos	struct
)	O
;	O
new_file	int
=	O
TRUE	int
;	O
ch_init	function
(	O
f	int
,	O
chflags	int
)	O
;	O
if	O
(	O
!	O
(	O
chflags	int
&	O
CH_HELPFILE	int
)	O
)	O
{	O
if	O
(	O
namelogfile	pointer
!=	O
NULL	O
&&	O
is_tty	int
)	O
use_logfile	function
(	O
namelogfile	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
open_filename	pointer
,	O
"-"	pointer
)	O
!=	O
0	int
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
int	O
r	int
=	O
stat	struct
(	O
open_filename	pointer
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
r	int
==	O
0	int
)	O
{	O
curr_ino	long
=	O
statbuf	struct
.	O
st_ino	long
;	O
curr_dev	long
=	O
statbuf	struct
.	O
st_dev	long
;	O
}	O
}	O
if	O
(	O
every_first_cmd	pointer
!=	O
NULL	O
)	O
{	O
ungetcc	function
(	O
CHAR_END_COMMAND	int
)	O
;	O
ungetsc	function
(	O
every_first_cmd	pointer
)	O
;	O
}	O
}	O
no_display	int
=	O
!	O
any_display	int
;	O
flush	function
(	O
)	O
;	O
any_display	int
=	O
TRUE	int
;	O
if	O
(	O
is_tty	int
)	O
{	O
pos_clear	function
(	O
)	O
;	O
clr_linenum	function
(	O
)	O
;	O
clr_hilite	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
FAKE_HELPFILE	pointer
)	O
&&	O
strcmp	function
(	O
filename	pointer
,	O
FAKE_EMPTYFILE	pointer
)	O
)	O
cmd_addhist	function
(	O
ml_examine	pointer
,	O
filename	pointer
,	O
1	int
)	O
;	O
if	O
(	O
no_display	int
&&	O
errmsgs	int
>	O
0	int
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
filename	pointer
;	O
error	function
(	O
"%s"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
int	O
edit_list	function
(	O
filelist	pointer
)	O
char	O
*	O
filelist	pointer
;	O
{	O
IFILE	O
save_ifile	pointer
;	O
char	O
*	O
good_filename	pointer
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
gfilelist	pointer
;	O
char	O
*	O
gfilename	pointer
;	O
char	O
*	O
qfilename	pointer
;	O
struct	O
textlist	struct
tl_files	struct
;	O
struct	O
textlist	struct
tl_gfiles	struct
;	O
save_ifile	pointer
=	O
save_curr_ifile	function
(	O
)	O
;	O
good_filename	pointer
=	O
NULL	O
;	O
init_textlist	function
(	O
&	O
tl_files	struct
,	O
filelist	pointer
)	O
;	O
filename	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
filename	pointer
=	O
forw_textlist	function
(	O
&	O
tl_files	struct
,	O
filename	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
gfilelist	pointer
=	O
lglob	function
(	O
filename	pointer
)	O
;	O
init_textlist	function
(	O
&	O
tl_gfiles	struct
,	O
gfilelist	pointer
)	O
;	O
gfilename	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
gfilename	pointer
=	O
forw_textlist	function
(	O
&	O
tl_gfiles	struct
,	O
gfilename	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
qfilename	pointer
=	O
shell_unquote	function
(	O
gfilename	pointer
)	O
;	O
if	O
(	O
edit	function
(	O
qfilename	pointer
)	O
==	O
0	int
&&	O
good_filename	pointer
==	O
NULL	O
)	O
good_filename	pointer
=	O
get_filename	function
(	O
curr_ifile	pointer
)	O
;	O
free	function
(	O
qfilename	pointer
)	O
;	O
}	O
free	function
(	O
gfilelist	pointer
)	O
;	O
}	O
if	O
(	O
good_filename	pointer
==	O
NULL	O
)	O
{	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
get_ifile	function
(	O
good_filename	pointer
,	O
curr_ifile	pointer
)	O
==	O
curr_ifile	pointer
)	O
{	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
reedit_ifile	function
(	O
save_ifile	pointer
)	O
;	O
return	O
(	O
edit	function
(	O
good_filename	pointer
)	O
)	O
;	O
}	O
public	O
int	O
edit_first	function
(	O
)	O
{	O
curr_ifile	pointer
=	O
NULL_IFILE	O
;	O
return	O
(	O
edit_next	function
(	O
1	int
)	O
)	O
;	O
}	O
public	O
int	O
edit_last	function
(	O
)	O
{	O
curr_ifile	pointer
=	O
NULL_IFILE	O
;	O
return	O
(	O
edit_prev	function
(	O
1	int
)	O
)	O
;	O
}	O
static	O
int	O
edit_istep	function
(	O
h	pointer
,	O
n	int
,	O
dir	int
)	O
IFILE	O
h	pointer
;	O
int	O
n	int
;	O
int	O
dir	int
;	O
{	O
IFILE	O
next	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
next	pointer
=	O
(	O
dir	int
>	O
0	int
)	O
?	O
next_ifile	function
(	O
h	pointer
)	O
:	O
prev_ifile	function
(	O
h	pointer
)	O
;	O
if	O
(	O
--	O
n	int
<	O
0	int
)	O
{	O
if	O
(	O
edit_ifile	function
(	O
h	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
next	pointer
==	O
NULL_IFILE	O
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
h	pointer
=	O
next	pointer
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
edit_inext	function
(	O
h	pointer
,	O
n	int
)	O
IFILE	O
h	pointer
;	O
int	O
n	int
;	O
{	O
return	O
(	O
edit_istep	function
(	O
h	pointer
,	O
n	int
,	O
+	O
1	int
)	O
)	O
;	O
}	O
public	O
int	O
edit_next	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
return	O
edit_istep	function
(	O
curr_ifile	pointer
,	O
n	int
,	O
+	O
1	int
)	O
;	O
}	O
static	O
int	O
edit_iprev	function
(	O
h	pointer
,	O
n	int
)	O
IFILE	O
h	pointer
;	O
int	O
n	int
;	O
{	O
return	O
(	O
edit_istep	function
(	O
h	pointer
,	O
n	int
,	O
-	O
1	int
)	O
)	O
;	O
}	O
public	O
int	O
edit_prev	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
return	O
edit_istep	function
(	O
curr_ifile	pointer
,	O
n	int
,	O
-	O
1	int
)	O
;	O
}	O
public	O
int	O
edit_index	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
IFILE	O
h	pointer
;	O
h	pointer
=	O
NULL_IFILE	O
;	O
do	O
{	O
if	O
(	O
(	O
h	pointer
=	O
next_ifile	function
(	O
h	pointer
)	O
)	O
==	O
NULL_IFILE	O
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
while	O
(	O
get_index	function
(	O
h	pointer
)	O
!=	O
n	int
)	O
;	O
return	O
(	O
edit_ifile	function
(	O
h	pointer
)	O
)	O
;	O
}	O
public	O
IFILE	O
save_curr_ifile	function
(	O
)	O
{	O
if	O
(	O
curr_ifile	pointer
!=	O
NULL_IFILE	O
)	O
hold_ifile	function
(	O
curr_ifile	pointer
,	O
1	int
)	O
;	O
return	O
(	O
curr_ifile	pointer
)	O
;	O
}	O
public	O
void	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
IFILE	O
save_ifile	pointer
;	O
{	O
if	O
(	O
save_ifile	pointer
!=	O
NULL_IFILE	O
)	O
hold_ifile	function
(	O
save_ifile	pointer
,	O
-	O
1	int
)	O
;	O
}	O
public	O
void	O
reedit_ifile	function
(	O
save_ifile	pointer
)	O
IFILE	O
save_ifile	pointer
;	O
{	O
IFILE	O
next	pointer
;	O
IFILE	O
prev	pointer
;	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
next	pointer
=	O
next_ifile	function
(	O
save_ifile	pointer
)	O
;	O
prev	pointer
=	O
prev_ifile	function
(	O
save_ifile	pointer
)	O
;	O
if	O
(	O
edit_ifile	function
(	O
save_ifile	pointer
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
next	pointer
!=	O
NULL_IFILE	O
&&	O
edit_inext	function
(	O
next	pointer
,	O
0	int
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
prev	pointer
!=	O
NULL_IFILE	O
&&	O
edit_iprev	function
(	O
prev	pointer
,	O
0	int
)	O
==	O
0	int
)	O
return	O
;	O
quit	function
(	O
QUIT_ERROR	int
)	O
;	O
}	O
public	O
void	O
reopen_curr_ifile	function
(	O
)	O
{	O
IFILE	O
save_ifile	pointer
=	O
save_curr_ifile	function
(	O
)	O
;	O
close_file	function
(	O
)	O
;	O
reedit_ifile	function
(	O
save_ifile	pointer
)	O
;	O
}	O
public	O
int	O
edit_stdin	function
(	O
)	O
{	O
if	O
(	O
isatty	function
(	O
fd0	int
)	O
)	O
{	O
error	function
(	O
"Missing filename (\"less --help\" for help)"	pointer
,	O
NULL_PARG	O
)	O
;	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
}	O
return	O
(	O
edit	function
(	O
"-"	pointer
)	O
)	O
;	O
}	O
public	O
void	O
cat_file	function
(	O
)	O
{	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
ch_forw_get	function
(	O
)	O
)	O
!=	O
EOI	O
)	O
putchr	function
(	O
c	int
)	O
;	O
flush	function
(	O
)	O
;	O
}	O
public	O
void	O
use_logfile	function
(	O
filename	pointer
)	O
char	O
*	O
filename	pointer
;	O
{	O
int	O
exists	int
;	O
int	O
answer	int
;	O
PARG	union
parg	union
;	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_CANSEEK	int
)	O
return	O
;	O
exists	int
=	O
open	function
(	O
filename	pointer
,	O
OPEN_READ	O
)	O
;	O
if	O
(	O
exists	int
>=	O
0	int
)	O
close	function
(	O
exists	int
)	O
;	O
exists	int
=	O
(	O
exists	int
>=	O
0	int
)	O
;	O
if	O
(	O
!	O
exists	int
||	O
force_logfile	int
)	O
{	O
answer	int
=	O
'O'	O
;	O
}	O
else	O
{	O
parg	union
.	O
p_string	pointer
=	O
filename	pointer
;	O
answer	int
=	O
query	function
(	O
"Warning: \"%s\" exists; Overwrite, Append or Don't log? "	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
loop	O
:	O
switch	O
(	O
answer	int
)	O
{	O
case	O
'O'	O
:	O
case	O
'o'	O
:	O
logfile	int
=	O
creat	function
(	O
filename	pointer
,	O
0644	int
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
case	O
'a'	O
:	O
logfile	int
=	O
open	function
(	O
filename	pointer
,	O
OPEN_APPEND	O
)	O
;	O
if	O
(	O
lseek	function
(	O
logfile	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_END	int
)	O
==	O
BAD_LSEEK	O
)	O
{	O
close	function
(	O
logfile	int
)	O
;	O
logfile	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'd'	O
:	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
;	O
case	O
'q'	O
:	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
default	O
:	O
answer	int
=	O
query	function
(	O
"Overwrite, Append, or Don't log? (Type \"O\", \"A\", \"D\" or \"q\") "	pointer
,	O
NULL_PARG	O
)	O
;	O
goto	O
loop	O
;	O
}	O
if	O
(	O
logfile	int
<	O
0	int
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
filename	pointer
;	O
error	function
(	O
"Cannot write to \"%s\""	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
;	O
}	O
SET_BINARY	O
(	O
logfile	int
)	O
;	O
}	O