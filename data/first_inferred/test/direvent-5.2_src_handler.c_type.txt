struct	O
handler	struct
*	O
handler_alloc	function
(	O
event_mask	O
ev_mask	*
)	O
{	O
struct	O
handler	struct
*	O
hp	*
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
hp	*
)	O
)	O
;	O
hp	*
->	O
refcnt	int
=	O
0	int
;	O
hp	*
->	O
ev_mask	*
=	O
ev_mask	*
;	O
return	O
hp	*
;	O
}	O
void	O
watchpoint_run_handlers	function
(	O
struct	O
watchpoint	struct
*	O
wp	*
,	O
int	O
evflags	int
,	O
const	O
char	O
*	O
dirname	*
,	O
const	O
char	O
*	O
filename	*
)	O
{	O
handler_iterator_t	*
itr	*
;	O
struct	O
handler	*
*	O
hp	*
;	O
event_mask	struct
m	*
;	O
for_each_handler	function
(	O
wp	*
,	O
itr	*
,	O
hp	*
)	O
{	O
if	O
(	O
handler_matches_event	function
(	O
hp	*
,	O
sys	*
,	O
evflags	*
,	O
filename	*
)	O
)	O
hp	*
->	O
run	*
(	O
wp	*
,	O
event_mask_init	function
(	O
&	O
m	*
,	O
evflags	*
,	O
&	O
hp	*
->	O
ev_mask	*
)	O
,	O
dirname	*
,	O
filename	*
,	O
hp	*
->	O
data	*
)	O
;	O
}	O
}	O
static	O
void	O
handler_ref	function
(	O
struct	O
handler	*
*	O
hp	*
)	O
{	O
++	O
hp	*
->	O
refcnt	int
;	O
}	O
void	O
handler_free	function
(	O
struct	O
handler	struct
*	O
hp	*
)	O
{	O
filpatlist_destroy	function
(	O
&	O
hp	*
->	O
fnames	array
)	O
;	O
if	O
(	O
hp	*
->	O
free	function
)	O
hp	*
->	O
free	function
(	O
hp	*
->	O
data	*
)	O
;	O
}	O
static	O
void	O
handler_unref	function
(	O
struct	O
handler	struct
*	O
hp	*
)	O
{	O
if	O
(	O
hp	*
&&	O
--	O
hp	*
->	O
refcnt	int
)	O
{	O
handler_free	function
(	O
hp	*
)	O
;	O
free	function
(	O
hp	*
)	O
;	O
}	O
}	O
static	O
void	O
handler_listent_free	function
(	O
void	O
*	O
p	*
)	O
{	O
struct	O
handler	struct
*	O
hp	*
=	O
p	*
;	O
handler_unref	function
(	O
hp	*
)	O
;	O
}	O
struct	O
handler_list	struct
{	O
size_t	long
refcnt	int
;	O
grecs_list_ptr_t	*
list	*
;	O
struct	O
handler_iterator	struct
*	O
itr_chain	*
;	O
}	O
;	O
struct	O
handler_iterator	struct
{	O
struct	O
handler_iterator	struct
*	O
prev	*
,	O
*	O
next	*
;	O
handler_list_t	struct
hlist	*
;	O
struct	O
grecs_list_entry	struct
*	O
ent	*
;	O
int	O
advanced	int
;	O
}	O
;	O
static	O
struct	O
handler_iterator	struct
*	O
itr_avail	*
;	O
struct	O
handler	struct
*	O
handler_itr_first	function
(	O
struct	O
watchpoint	struct
*	O
wpt	*
,	O
handler_iterator_t	struct
*	O
ret_itr	*
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	*
;	O
if	O
(	O
!	O
wpt	*
->	O
handler_list	*
)	O
return	O
NULL	O
;	O
if	O
(	O
itr_avail	*
)	O
{	O
itr	*
=	O
itr_avail	*
;	O
itr_avail	*
=	O
itr	*
->	O
next	*
;	O
if	O
(	O
itr_avail	*
)	O
itr_avail	*
->	O
prev	*
=	O
NULL	O
;	O
}	O
else	O
itr	*
=	O
emalloc	function
(	O
sizeof	O
*	O
itr	*
)	O
;	O
itr	*
->	O
prev	*
=	O
NULL	O
;	O
itr	*
->	O
next	*
=	O
wpt	*
->	O
handler_list	*
->	O
itr_chain	*
;	O
itr	*
->	O
hlist	*
=	O
wpt	*
->	O
handler_list	*
;	O
if	O
(	O
wpt	*
->	O
handler_list	*
->	O
itr_chain	*
)	O
wpt	*
->	O
handler_list	*
->	O
itr_chain	*
->	O
prev	*
=	O
itr	*
;	O
wpt	*
->	O
handler_list	*
->	O
itr_chain	*
=	O
itr	*
;	O
itr	*
->	O
ent	*
=	O
wpt	*
->	O
handler_list	*
->	O
list	*
->	O
head	*
;	O
itr	*
->	O
advanced	int
=	O
0	int
;	O
*	O
ret_itr	*
=	O
itr	*
;	O
return	O
handler_itr_current	function
(	O
itr	*
)	O
;	O
}	O
struct	O
handler	*
*	O
handler_itr_next	function
(	O
handler_iterator_t	struct
*	O
pitr	*
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	*
;	O
if	O
(	O
!	O
pitr	*
||	O
(	O
itr	*
=	O
*	O
pitr	*
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
itr	*
->	O
advanced	*
)	O
itr	*
->	O
advanced	int
=	O
0	int
;	O
else	O
itr	*
->	O
ent	*
=	O
itr	*
->	O
ent	*
->	O
next	*
;	O
if	O
(	O
!	O
itr	*
->	O
ent	*
)	O
{	O
struct	O
handler_iterator	struct
*	O
p	*
;	O
if	O
(	O
(	O
p	*
=	O
itr	*
->	O
prev	*
)	O
!=	O
NULL	O
)	O
p	*
->	O
next	*
=	O
itr	*
->	O
next	*
;	O
else	O
itr	*
->	O
hlist	*
->	O
itr_chain	*
=	O
itr	*
->	O
next	*
;	O
if	O
(	O
(	O
p	*
=	O
itr	*
->	O
next	*
)	O
!=	O
NULL	O
)	O
p	*
->	O
prev	*
=	O
itr	*
->	O
prev	*
;	O
if	O
(	O
itr_avail	*
)	O
itr_avail	*
->	O
prev	*
=	O
itr	*
;	O
itr	*
->	O
prev	*
=	O
NULL	O
;	O
itr	*
->	O
next	*
=	O
itr_avail	*
;	O
itr	*
->	O
hlist	*
=	O
NULL	O
;	O
itr_avail	*
=	O
itr	*
;	O
*	O
pitr	*
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
return	O
handler_itr_current	function
(	O
itr	*
)	O
;	O
}	O
struct	O
handler	*
*	O
handler_itr_current	function
(	O
handler_iterator_t	*
itr	*
)	O
{	O
if	O
(	O
!	O
itr	*
)	O
return	O
NULL	O
;	O
return	O
itr	*
->	O
ent	*
?	O
itr	*
->	O
ent	*
->	O
data	*
:	O
NULL	O
;	O
}	O
handler_list_t	O
handler_list_create	function
(	O
void	O
)	O
{	O
handler_list_t	*
hlist	*
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
hlist	*
)	O
)	O
;	O
hlist	*
->	O
list	*
=	O
grecs_list_create	function
(	O
)	O
;	O
hlist	*
->	O
list	*
->	O
free_entry	*
=	O
handler_listent_free	*
;	O
hlist	*
->	O
refcnt	int
=	O
1	int
;	O
hlist	*
->	O
itr_chain	*
=	O
NULL	O
;	O
return	O
hlist	int
;	O
}	O
size_t	long
handler_list_size	function
(	O
handler_list_t	*
hlist	*
)	O
{	O
return	O
grecs_list_size	function
(	O
hlist	*
->	O
list	*
)	O
;	O
}	O
handler_list_t	*
handler_list_copy	function
(	O
handler_list_t	*
orig	*
)	O
{	O
if	O
(	O
!	O
orig	*
)	O
return	O
handler_list_create	function
(	O
)	O
;	O
++	O
orig	*
->	O
refcnt	int
;	O
return	O
orig	*
;	O
}	O
void	O
handler_list_unref	function
(	O
handler_list_t	*
hlist	*
)	O
{	O
if	O
(	O
hlist	*
)	O
{	O
if	O
(	O
--	O
hlist	*
->	O
refcnt	int
==	O
0	int
)	O
{	O
grecs_list_free	function
(	O
hlist	*
->	O
list	*
)	O
;	O
free	function
(	O
hlist	*
)	O
;	O
}	O
}	O
}	O
void	O
handler_list_append	function
(	O
handler_list_t	*
hlist	*
,	O
struct	O
handler	*
*	O
hp	*
)	O
{	O
handler_ref	function
(	O
hp	*
)	O
;	O
grecs_list_append	function
(	O
hlist	*
->	O
list	*
,	O
hp	*
)	O
;	O
}	O
size_t	long
handler_list_remove	function
(	O
handler_list_t	*
hlist	*
,	O
struct	O
handler	*
*	O
hp	*
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	*
;	O
for	O
(	O
ep	*
=	O
hlist	*
->	O
list	*
->	O
head	*
;	O
ep	*
;	O
ep	*
=	O
ep	*
->	O
next	*
)	O
if	O
(	O
ep	*
->	O
data	*
==	O
hp	*
)	O
break	O
;	O
if	O
(	O
!	O
ep	*
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
hlist	*
->	O
itr_chain	*
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	*
;	O
for	O
(	O
itr	*
=	O
hlist	*
->	O
itr_chain	*
;	O
itr	*
;	O
itr	*
=	O
itr	*
->	O
next	*
)	O
if	O
(	O
itr	*
->	O
ent	*
==	O
ep	*
)	O
{	O
itr	*
->	O
ent	*
=	O
ep	*
->	O
next	*
;	O
itr	*
->	O
advanced	int
=	O
1	int
;	O
}	O
}	O
grecs_list_remove_entry	function
(	O
hlist	*
->	O
list	*
,	O
ep	*
)	O
;	O
return	O
grecs_list_size	function
(	O
hlist	*
->	O
list	*
)	O
;	O
}	O