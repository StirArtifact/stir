void	O
error	function
(	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
message	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: Error: "	pointer
)	O
,	O
program_name	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
void	O
warn	function
(	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
message	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: Warning: "	pointer
)	O
,	O
program_name	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
void	O
(	O
*	O
byte_put	pointer
)	O
(	O
unsigned	O
char	O
*	O
,	O
elf_vma	long
,	O
int	O
)	O
;	O
void	O
byte_put_little_endian	function
(	O
unsigned	O
char	O
*	O
field	pointer
,	O
elf_vma	long
value	long
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
8	int
:	O
field	pointer
[	O
7	int
]	O
=	O
(	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
24	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
field	pointer
[	O
6	int
]	O
=	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
24	int
)	O
&	O
0xff	int
;	O
field	pointer
[	O
5	int
]	O
=	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
16	int
)	O
&	O
0xff	int
;	O
field	pointer
[	O
4	int
]	O
=	O
(	O
(	O
value	long
>>	O
24	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
case	O
4	int
:	O
field	pointer
[	O
3	int
]	O
=	O
(	O
value	long
>>	O
24	int
)	O
&	O
0xff	int
;	O
case	O
3	int
:	O
field	pointer
[	O
2	int
]	O
=	O
(	O
value	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
case	O
2	int
:	O
field	pointer
[	O
1	int
]	O
=	O
(	O
value	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
case	O
1	int
:	O
field	pointer
[	O
0	int
]	O
=	O
value	long
&	O
0xff	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unhandled data length: %d\n"	pointer
)	O
,	O
size	long
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
void	O
byte_put_big_endian	function
(	O
unsigned	O
char	O
*	O
field	pointer
,	O
elf_vma	long
value	long
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
8	int
:	O
field	pointer
[	O
7	int
]	O
=	O
value	long
&	O
0xff	int
;	O
field	pointer
[	O
6	int
]	O
=	O
(	O
value	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
field	pointer
[	O
5	int
]	O
=	O
(	O
value	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
field	pointer
[	O
4	int
]	O
=	O
(	O
value	long
>>	O
24	int
)	O
&	O
0xff	int
;	O
value	long
>>=	O
16	int
;	O
value	long
>>=	O
16	int
;	O
case	O
4	int
:	O
field	pointer
[	O
3	int
]	O
=	O
value	long
&	O
0xff	int
;	O
value	long
>>=	O
8	int
;	O
case	O
3	int
:	O
field	pointer
[	O
2	int
]	O
=	O
value	long
&	O
0xff	int
;	O
value	long
>>=	O
8	int
;	O
case	O
2	int
:	O
field	pointer
[	O
1	int
]	O
=	O
value	long
&	O
0xff	int
;	O
value	long
>>=	O
8	int
;	O
case	O
1	int
:	O
field	pointer
[	O
0	int
]	O
=	O
value	long
&	O
0xff	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unhandled data length: %d\n"	pointer
)	O
,	O
size	long
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
elf_vma	long
(	O
*	O
byte_get	pointer
)	O
(	O
const	O
unsigned	O
char	O
*	O
,	O
int	O
)	O
;	O
elf_vma	long
byte_get_little_endian	function
(	O
const	O
unsigned	O
char	O
*	O
field	pointer
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
1	int
:	O
return	O
*	O
field	pointer
;	O
case	O
2	int
:	O
return	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
;	O
case	O
3	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
;	O
case	O
4	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
5	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
6	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
5	int
]	O
)	O
)	O
<<	O
40	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
7	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
5	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
6	int
]	O
)	O
)	O
<<	O
48	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
8	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
5	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
6	int
]	O
)	O
)	O
<<	O
48	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
7	int
]	O
)	O
)	O
<<	O
56	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unhandled data length: %d\n"	pointer
)	O
,	O
size	long
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
elf_vma	long
byte_get_big_endian	function
(	O
const	O
unsigned	O
char	O
*	O
field	pointer
,	O
int	O
size	long
)	O
{	O
switch	O
(	O
size	long
)	O
{	O
case	O
1	int
:	O
return	O
*	O
field	pointer
;	O
case	O
2	int
:	O
return	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
int	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
8	int
)	O
;	O
case	O
3	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
16	int
)	O
;	O
case	O
4	int
:	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
case	O
5	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
32	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
{	O
field	pointer
+=	O
1	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
case	O
6	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
5	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
40	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
{	O
field	pointer
+=	O
2	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
case	O
7	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
6	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
5	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
48	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
{	O
field	pointer
+=	O
3	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
case	O
8	int
:	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
8	int
)	O
return	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
7	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
6	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
5	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
4	int
]	O
)	O
)	O
<<	O
24	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
40	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
48	int
)	O
|	O
(	O
(	O
(	O
elf_vma	long
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
56	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
elf_vma	long
)	O
==	O
4	int
)	O
{	O
field	pointer
+=	O
4	int
;	O
return	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
2	int
]	O
)	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
1	int
]	O
)	O
)	O
<<	O
16	int
)	O
|	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
field	pointer
[	O
0	int
]	O
)	O
)	O
<<	O
24	int
)	O
;	O
}	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unhandled data length: %d\n"	pointer
)	O
,	O
size	long
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
elf_vma	long
byte_get_signed	function
(	O
const	O
unsigned	O
char	O
*	O
field	pointer
,	O
int	O
size	long
)	O
{	O
elf_vma	long
x	long
=	O
byte_get	pointer
(	O
field	pointer
,	O
size	long
)	O
;	O
switch	O
(	O
size	long
)	O
{	O
case	O
1	int
:	O
return	O
(	O
x	long
^	O
0x80	int
)	O
-	O
0x80	int
;	O
case	O
2	int
:	O
return	O
(	O
x	long
^	O
0x8000	int
)	O
-	O
0x8000	int
;	O
case	O
3	int
:	O
return	O
(	O
x	long
^	O
0x800000	int
)	O
-	O
0x800000	int
;	O
case	O
4	int
:	O
return	O
(	O
x	long
^	O
0x80000000	int
)	O
-	O
0x80000000	int
;	O
case	O
5	int
:	O
case	O
6	int
:	O
case	O
7	int
:	O
case	O
8	int
:	O
return	O
x	long
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
void	O
byte_get_64	function
(	O
const	O
unsigned	O
char	O
*	O
field	pointer
,	O
elf_vma	long
*	O
high	pointer
,	O
elf_vma	long
*	O
low	pointer
)	O
{	O
if	O
(	O
byte_get	pointer
==	O
byte_get_big_endian	function
)	O
{	O
*	O
high	pointer
=	O
byte_get_big_endian	function
(	O
field	pointer
,	O
4	int
)	O
;	O
*	O
low	pointer
=	O
byte_get_big_endian	function
(	O
field	pointer
+	O
4	int
,	O
4	int
)	O
;	O
}	O
else	O
{	O
*	O
high	pointer
=	O
byte_get_little_endian	function
(	O
field	pointer
+	O
4	int
,	O
4	int
)	O
;	O
*	O
low	pointer
=	O
byte_get_little_endian	function
(	O
field	pointer
,	O
4	int
)	O
;	O
}	O
return	O
;	O
}	O
char	O
*	O
adjust_relative_path	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
unsigned	O
long	O
name_len	long
)	O
{	O
char	O
*	O
member_file_name	pointer
;	O
const	O
char	O
*	O
base_name	pointer
=	O
lbasename	function
(	O
file_name	pointer
)	O
;	O
size_t	long
amt	long
;	O
if	O
(	O
IS_ABSOLUTE_PATH	O
(	O
name	pointer
)	O
||	O
base_name	pointer
==	O
file_name	pointer
)	O
{	O
amt	long
=	O
name_len	long
+	O
1	int
;	O
if	O
(	O
amt	long
==	O
0	int
)	O
return	O
NULL	O
;	O
member_file_name	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
member_file_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	function
(	O
member_file_name	pointer
,	O
name	pointer
,	O
name_len	long
)	O
;	O
member_file_name	pointer
[	O
name_len	long
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
size_t	long
prefix_len	long
=	O
base_name	pointer
-	O
file_name	pointer
;	O
amt	long
=	O
prefix_len	long
+	O
name_len	long
+	O
1	int
;	O
if	O
(	O
amt	long
<	O
prefix_len	long
||	O
amt	long
<	O
name_len	long
)	O
{	O
error	function
(	O
_	O
(	O
"Abnormal length of thin archive member name: %lx\n"	pointer
)	O
,	O
name_len	long
)	O
;	O
return	O
NULL	O
;	O
}	O
member_file_name	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
member_file_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	function
(	O
member_file_name	pointer
,	O
file_name	pointer
,	O
prefix_len	long
)	O
;	O
memcpy	function
(	O
member_file_name	pointer
+	O
prefix_len	long
,	O
name	pointer
,	O
name_len	long
)	O
;	O
member_file_name	pointer
[	O
prefix_len	long
+	O
name_len	long
]	O
=	O
'\0'	O
;	O
}	O
return	O
member_file_name	pointer
;	O
}	O
static	O
bfd_boolean	int
process_archive_index_and_symbols	function
(	O
struct	O
archive_info	struct
*	O
arch	enum
,	O
unsigned	O
int	O
sizeof_ar_index	int
,	O
bfd_boolean	int
read_symbols	int
)	O
{	O
size_t	long
got	long
;	O
unsigned	O
long	O
size	long
;	O
char	O
fmag_save	char
;	O
fmag_save	char
=	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
;	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
0	int
;	O
size	long
=	O
strtoul	function
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_size	array
,	O
NULL	O
,	O
10	int
)	O
;	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
fmag_save	char
;	O
if	O
(	O
(	O
signed	O
long	O
)	O
size	long
<	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: invalid archive header size: %ld\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
,	O
size	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
size	long
=	O
size	long
+	O
(	O
size	long
&	O
1	int
)	O
;	O
arch	enum
->	O
next_arhdr_offset	long
+=	O
sizeof	O
arch	enum
->	O
arhdr	struct
+	O
size	long
;	O
if	O
(	O
!	O
read_symbols	int
)	O
{	O
if	O
(	O
fseek	function
(	O
arch	enum
->	O
file	pointer
,	O
size	long
,	O
SEEK_CUR	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to skip archive symbol table\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
long	O
i	pointer
;	O
unsigned	O
char	O
integer_buffer	array
[	O
sizeof	O
arch	enum
->	O
index_num	long
]	O
;	O
unsigned	O
char	O
*	O
index_buffer	pointer
;	O
assert	O
(	O
sizeof_ar_index	int
<=	O
sizeof	O
integer_buffer	array
)	O
;	O
if	O
(	O
size	long
<	O
sizeof_ar_index	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: the archive index is empty\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
got	long
=	O
fread	function
(	O
integer_buffer	array
,	O
1	int
,	O
sizeof_ar_index	int
,	O
arch	enum
->	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
sizeof_ar_index	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to read archive index\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
arch	enum
->	O
index_num	long
=	O
byte_get_big_endian	function
(	O
integer_buffer	array
,	O
sizeof_ar_index	int
)	O
;	O
size	long
-=	O
sizeof_ar_index	int
;	O
if	O
(	O
size	long
<	O
arch	enum
->	O
index_num	long
*	O
sizeof_ar_index	int
||	O
size	long
<	O
arch	enum
->	O
index_num	long
)	O
{	O
error	function
(	O
_	O
(	O
"%s: the archive index is supposed to have 0x%lx entries of %d bytes, but the size is only 0x%lx\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
,	O
(	O
long	O
)	O
arch	enum
->	O
index_num	long
,	O
sizeof_ar_index	int
,	O
size	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
index_buffer	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	function
(	O
arch	enum
->	O
index_num	long
*	O
sizeof_ar_index	int
)	O
;	O
if	O
(	O
index_buffer	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory whilst trying to read archive symbol index\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
got	long
=	O
fread	function
(	O
index_buffer	pointer
,	O
sizeof_ar_index	int
,	O
arch	enum
->	O
index_num	long
,	O
arch	enum
->	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
arch	enum
->	O
index_num	long
)	O
{	O
free	function
(	O
index_buffer	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"%s: failed to read archive index\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
size	long
-=	O
arch	enum
->	O
index_num	long
*	O
sizeof_ar_index	int
;	O
arch	enum
->	O
index_array	pointer
=	O
(	O
elf_vma	long
*	O
)	O
malloc	function
(	O
arch	enum
->	O
index_num	long
*	O
sizeof	O
(	O
*	O
arch	enum
->	O
index_array	pointer
)	O
)	O
;	O
if	O
(	O
arch	enum
->	O
index_array	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
index_buffer	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"Out of memory whilst trying to convert the archive symbol index\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
arch	enum
->	O
index_num	long
;	O
i	pointer
++	O
)	O
arch	enum
->	O
index_array	pointer
[	O
i	pointer
]	O
=	O
byte_get_big_endian	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
index_buffer	pointer
+	O
(	O
i	pointer
*	O
sizeof_ar_index	int
)	O
)	O
,	O
sizeof_ar_index	int
)	O
;	O
free	function
(	O
index_buffer	pointer
)	O
;	O
if	O
(	O
size	long
<	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: the archive has an index but no symbols\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
arch	enum
->	O
sym_table	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
arch	enum
->	O
sym_table	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory whilst trying to read archive index symbol table\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
arch	enum
->	O
sym_size	long
=	O
size	long
;	O
got	long
=	O
fread	function
(	O
arch	enum
->	O
sym_table	pointer
,	O
1	int
,	O
size	long
,	O
arch	enum
->	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
size	long
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to read archive index symbol table\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
got	long
=	O
fread	function
(	O
&	O
arch	enum
->	O
arhdr	struct
,	O
1	int
,	O
sizeof	O
arch	enum
->	O
arhdr	struct
,	O
arch	enum
->	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
sizeof	O
arch	enum
->	O
arhdr	struct
&&	O
got	long
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to read archive header following archive index\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
int	O
setup_archive	function
(	O
struct	O
archive_info	struct
*	O
arch	enum
,	O
const	O
char	O
*	O
file_name	pointer
,	O
FILE	struct
*	O
file	pointer
,	O
bfd_boolean	int
is_thin_archive	int
,	O
bfd_boolean	int
read_symbols	int
)	O
{	O
size_t	long
got	long
;	O
arch	enum
->	O
file_name	pointer
=	O
strdup	function
(	O
file_name	pointer
)	O
;	O
arch	enum
->	O
file	pointer
=	O
file	pointer
;	O
arch	enum
->	O
index_num	long
=	O
0	int
;	O
arch	enum
->	O
index_array	pointer
=	O
NULL	O
;	O
arch	enum
->	O
sym_table	pointer
=	O
NULL	O
;	O
arch	enum
->	O
sym_size	long
=	O
0	int
;	O
arch	enum
->	O
longnames	pointer
=	O
NULL	O
;	O
arch	enum
->	O
longnames_size	long
=	O
0	int
;	O
arch	enum
->	O
nested_member_origin	long
=	O
0	int
;	O
arch	enum
->	O
is_thin_archive	int
=	O
is_thin_archive	int
;	O
arch	enum
->	O
uses_64bit_indices	int
=	O
FALSE	int
;	O
arch	enum
->	O
next_arhdr_offset	long
=	O
SARMAG	int
;	O
if	O
(	O
fseek	function
(	O
file	pointer
,	O
SARMAG	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek to first archive header\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
got	long
=	O
fread	function
(	O
&	O
arch	enum
->	O
arhdr	struct
,	O
1	int
,	O
sizeof	O
arch	enum
->	O
arhdr	struct
,	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
sizeof	O
arch	enum
->	O
arhdr	struct
)	O
{	O
if	O
(	O
got	long
==	O
0	int
)	O
return	O
0	int
;	O
error	function
(	O
_	O
(	O
"%s: failed to read archive header\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
const_strneq	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
,	O
"/               "	pointer
)	O
)	O
{	O
if	O
(	O
!	O
process_archive_index_and_symbols	function
(	O
arch	enum
,	O
4	int
,	O
read_symbols	int
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
const_strneq	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
,	O
"/SYM64/         "	pointer
)	O
)	O
{	O
arch	enum
->	O
uses_64bit_indices	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
process_archive_index_and_symbols	function
(	O
arch	enum
,	O
8	int
,	O
read_symbols	int
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
read_symbols	int
)	O
printf	function
(	O
_	O
(	O
"%s has no archive index\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
if	O
(	O
const_strneq	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
,	O
"//              "	pointer
)	O
)	O
{	O
char	O
fmag_save	char
=	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
;	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
0	int
;	O
arch	enum
->	O
longnames_size	long
=	O
strtoul	function
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_size	array
,	O
NULL	O
,	O
10	int
)	O
;	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
fmag_save	char
;	O
if	O
(	O
arch	enum
->	O
longnames_size	long
<	O
8	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: long name table is too small, (size = %ld)\n"	pointer
)	O
,	O
file_name	pointer
,	O
arch	enum
->	O
longnames_size	long
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
signed	O
long	O
)	O
arch	enum
->	O
longnames_size	long
<	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: long name table is too big, (size = 0x%lx)\n"	pointer
)	O
,	O
file_name	pointer
,	O
arch	enum
->	O
longnames_size	long
)	O
;	O
return	O
1	int
;	O
}	O
arch	enum
->	O
next_arhdr_offset	long
+=	O
sizeof	O
arch	enum
->	O
arhdr	struct
+	O
arch	enum
->	O
longnames_size	long
;	O
arch	enum
->	O
longnames	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
arch	enum
->	O
longnames_size	long
+	O
1	int
)	O
;	O
if	O
(	O
arch	enum
->	O
longnames	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading long symbol names in archive\n"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fread	function
(	O
arch	enum
->	O
longnames	pointer
,	O
arch	enum
->	O
longnames_size	long
,	O
1	int
,	O
file	pointer
)	O
!=	O
1	int
)	O
{	O
free	function
(	O
arch	enum
->	O
longnames	pointer
)	O
;	O
arch	enum
->	O
longnames	pointer
=	O
NULL	O
;	O
error	function
(	O
_	O
(	O
"%s: failed to read long symbol name string table\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
arch	enum
->	O
longnames_size	long
&	O
1	int
)	O
!=	O
0	int
)	O
getc	function
(	O
file	pointer
)	O
;	O
arch	enum
->	O
longnames	pointer
[	O
arch	enum
->	O
longnames_size	long
]	O
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
setup_nested_archive	function
(	O
struct	O
archive_info	struct
*	O
nested_arch	pointer
,	O
const	O
char	O
*	O
member_file_name	pointer
)	O
{	O
FILE	struct
*	O
member_file	pointer
;	O
if	O
(	O
nested_arch	pointer
->	O
file_name	pointer
!=	O
NULL	O
&&	O
streq	O
(	O
nested_arch	pointer
->	O
file_name	pointer
,	O
member_file_name	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
nested_arch	pointer
->	O
file	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
nested_arch	pointer
->	O
file	pointer
)	O
;	O
release_archive	function
(	O
nested_arch	pointer
)	O
;	O
member_file	pointer
=	O
fopen	function
(	O
member_file_name	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
member_file	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
return	O
setup_archive	function
(	O
nested_arch	pointer
,	O
member_file_name	pointer
,	O
member_file	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
}	O
void	O
release_archive	function
(	O
struct	O
archive_info	struct
*	O
arch	enum
)	O
{	O
if	O
(	O
arch	enum
->	O
file_name	pointer
!=	O
NULL	O
)	O
free	function
(	O
arch	enum
->	O
file_name	pointer
)	O
;	O
if	O
(	O
arch	enum
->	O
index_array	pointer
!=	O
NULL	O
)	O
free	function
(	O
arch	enum
->	O
index_array	pointer
)	O
;	O
if	O
(	O
arch	enum
->	O
sym_table	pointer
!=	O
NULL	O
)	O
free	function
(	O
arch	enum
->	O
sym_table	pointer
)	O
;	O
if	O
(	O
arch	enum
->	O
longnames	pointer
!=	O
NULL	O
)	O
free	function
(	O
arch	enum
->	O
longnames	pointer
)	O
;	O
}	O
char	O
*	O
get_archive_member_name	function
(	O
struct	O
archive_info	struct
*	O
arch	enum
,	O
struct	O
archive_info	struct
*	O
nested_arch	pointer
)	O
{	O
unsigned	O
long	O
j	long
,	O
k	long
;	O
if	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
char	O
*	O
endp	pointer
;	O
char	O
*	O
member_file_name	pointer
;	O
char	O
*	O
member_name	pointer
;	O
char	O
fmag_save	char
;	O
if	O
(	O
arch	enum
->	O
longnames	pointer
==	O
NULL	O
||	O
arch	enum
->	O
longnames_size	long
==	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"Archive member uses long names, but no longname table found\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
arch	enum
->	O
nested_member_origin	long
=	O
0	int
;	O
fmag_save	char
=	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
;	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
0	int
;	O
k	long
=	O
j	long
=	O
strtoul	function
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
+	O
1	int
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
arch	enum
->	O
is_thin_archive	int
&&	O
endp	pointer
!=	O
NULL	O
&&	O
*	O
endp	pointer
==	O
':'	O
)	O
arch	enum
->	O
nested_member_origin	long
=	O
strtoul	function
(	O
endp	pointer
+	O
1	int
,	O
NULL	O
,	O
10	int
)	O
;	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
[	O
0	int
]	O
=	O
fmag_save	char
;	O
if	O
(	O
j	long
>	O
arch	enum
->	O
longnames_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Found long name index (%ld) beyond end of long name table\n"	pointer
)	O
,	O
j	long
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
(	O
j	long
<	O
arch	enum
->	O
longnames_size	long
)	O
&&	O
(	O
arch	enum
->	O
longnames	pointer
[	O
j	long
]	O
!=	O
'\n'	O
)	O
&&	O
(	O
arch	enum
->	O
longnames	pointer
[	O
j	long
]	O
!=	O
'\0'	O
)	O
)	O
j	long
++	O
;	O
if	O
(	O
j	long
>	O
0	int
&&	O
arch	enum
->	O
longnames	pointer
[	O
j	long
-	O
1	int
]	O
==	O
'/'	O
)	O
j	long
--	O
;	O
if	O
(	O
j	long
>	O
arch	enum
->	O
longnames_size	long
)	O
j	long
=	O
arch	enum
->	O
longnames_size	long
;	O
arch	enum
->	O
longnames	pointer
[	O
j	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
arch	enum
->	O
is_thin_archive	int
||	O
arch	enum
->	O
nested_member_origin	long
==	O
0	int
)	O
return	O
arch	enum
->	O
longnames	pointer
+	O
k	long
;	O
if	O
(	O
k	long
>=	O
j	long
)	O
{	O
error	function
(	O
_	O
(	O
"Invalid Thin archive member name\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
member_file_name	pointer
=	O
adjust_relative_path	function
(	O
arch	enum
->	O
file_name	pointer
,	O
arch	enum
->	O
longnames	pointer
+	O
k	long
,	O
j	long
-	O
k	long
)	O
;	O
if	O
(	O
member_file_name	pointer
!=	O
NULL	O
&&	O
setup_nested_archive	function
(	O
nested_arch	pointer
,	O
member_file_name	pointer
)	O
==	O
0	int
)	O
{	O
member_name	pointer
=	O
get_archive_member_name_at	function
(	O
nested_arch	pointer
,	O
arch	enum
->	O
nested_member_origin	long
,	O
NULL	O
)	O
;	O
if	O
(	O
member_name	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
member_file_name	pointer
)	O
;	O
return	O
member_name	pointer
;	O
}	O
}	O
free	function
(	O
member_file_name	pointer
)	O
;	O
return	O
arch	enum
->	O
longnames	pointer
+	O
k	long
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
sizeof	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
)	O
;	O
j	long
++	O
)	O
if	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
[	O
j	long
]	O
==	O
'/'	O
)	O
{	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
[	O
j	long
]	O
=	O
'\0'	O
;	O
return	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
;	O
}	O
{	O
char	O
*	O
name	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
)	O
+	O
1	int
)	O
;	O
memcpy	function
(	O
name	pointer
,	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
,	O
sizeof	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
)	O
)	O
;	O
name	pointer
[	O
sizeof	O
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_name	array
)	O
]	O
=	O
'\0'	O
;	O
return	O
name	pointer
;	O
}	O
}	O
char	O
*	O
get_archive_member_name_at	function
(	O
struct	O
archive_info	struct
*	O
arch	enum
,	O
unsigned	O
long	O
offset	long
,	O
struct	O
archive_info	struct
*	O
nested_arch	pointer
)	O
{	O
size_t	long
got	long
;	O
if	O
(	O
fseek	function
(	O
arch	enum
->	O
file	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek to next file name\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
got	long
=	O
fread	function
(	O
&	O
arch	enum
->	O
arhdr	struct
,	O
1	int
,	O
sizeof	O
arch	enum
->	O
arhdr	struct
,	O
arch	enum
->	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
sizeof	O
arch	enum
->	O
arhdr	struct
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to read archive header\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
memcmp	function
(	O
arch	enum
->	O
arhdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: did not find a valid archive header\n"	pointer
)	O
,	O
arch	enum
->	O
file_name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
get_archive_member_name	function
(	O
arch	enum
,	O
nested_arch	pointer
)	O
;	O
}	O
char	O
*	O
make_qualified_name	function
(	O
struct	O
archive_info	struct
*	O
arch	enum
,	O
struct	O
archive_info	struct
*	O
nested_arch	pointer
,	O
const	O
char	O
*	O
member_name	pointer
)	O
{	O
const	O
char	O
*	O
error_name	pointer
=	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
size_t	long
len	long
;	O
char	O
*	O
name	pointer
;	O
len	long
=	O
strlen	function
(	O
arch	enum
->	O
file_name	pointer
)	O
+	O
strlen	function
(	O
member_name	pointer
)	O
+	O
3	int
;	O
if	O
(	O
arch	enum
->	O
is_thin_archive	int
&&	O
arch	enum
->	O
nested_member_origin	long
!=	O
0	int
)	O
{	O
if	O
(	O
nested_arch	pointer
->	O
file_name	pointer
)	O
len	long
+=	O
strlen	function
(	O
nested_arch	pointer
->	O
file_name	pointer
)	O
+	O
2	int
;	O
else	O
len	long
+=	O
strlen	function
(	O
error_name	pointer
)	O
+	O
2	int
;	O
}	O
name	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
arch	enum
->	O
is_thin_archive	int
&&	O
arch	enum
->	O
nested_member_origin	long
!=	O
0	int
)	O
{	O
if	O
(	O
nested_arch	pointer
->	O
file_name	pointer
)	O
snprintf	function
(	O
name	pointer
,	O
len	long
,	O
"%s[%s(%s)]"	pointer
,	O
arch	enum
->	O
file_name	pointer
,	O
nested_arch	pointer
->	O
file_name	pointer
,	O
member_name	pointer
)	O
;	O
else	O
snprintf	function
(	O
name	pointer
,	O
len	long
,	O
"%s[%s(%s)]"	pointer
,	O
arch	enum
->	O
file_name	pointer
,	O
error_name	pointer
,	O
member_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
arch	enum
->	O
is_thin_archive	int
)	O
snprintf	function
(	O
name	pointer
,	O
len	long
,	O
"%s[%s]"	pointer
,	O
arch	enum
->	O
file_name	pointer
,	O
member_name	pointer
)	O
;	O
else	O
snprintf	function
(	O
name	pointer
,	O
len	long
,	O
"%s(%s)"	pointer
,	O
arch	enum
->	O
file_name	pointer
,	O
member_name	pointer
)	O
;	O
return	O
name	pointer
;	O
}	O