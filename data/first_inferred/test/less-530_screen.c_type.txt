static	O
char	O
*	O
sc_pad	pointer
,	O
*	O
sc_home	pointer
,	O
*	O
sc_addline	pointer
,	O
*	O
sc_lower_left	pointer
,	O
*	O
sc_return	pointer
,	O
*	O
sc_move	pointer
,	O
*	O
sc_clear	pointer
,	O
*	O
sc_eol_clear	pointer
,	O
*	O
sc_eos_clear	pointer
,	O
*	O
sc_s_in	pointer
,	O
*	O
sc_s_out	pointer
,	O
*	O
sc_u_in	pointer
,	O
*	O
sc_u_out	pointer
,	O
*	O
sc_b_in	pointer
,	O
*	O
sc_b_out	pointer
,	O
*	O
sc_bl_in	pointer
,	O
*	O
sc_bl_out	pointer
,	O
*	O
sc_visual_bell	pointer
,	O
*	O
sc_backspace	pointer
,	O
*	O
sc_s_keypad	pointer
,	O
*	O
sc_e_keypad	pointer
,	O
*	O
sc_init	pointer
,	O
*	O
sc_deinit	pointer
;	O
static	O
int	O
init_done	int
=	O
0	int
;	O
public	O
int	O
auto_wrap	int
;	O
public	O
int	O
ignaw	int
;	O
public	O
int	O
erase_char	int
;	O
public	O
int	O
erase2_char	int
;	O
public	O
int	O
kill_char	int
;	O
public	O
int	O
werase_char	int
;	O
public	O
int	O
sc_width	int
,	O
sc_height	int
;	O
public	O
int	O
bo_s_width	int
,	O
bo_e_width	int
;	O
public	O
int	O
ul_s_width	int
,	O
ul_e_width	int
;	O
public	O
int	O
so_s_width	int
,	O
so_e_width	int
;	O
public	O
int	O
bl_s_width	int
,	O
bl_e_width	int
;	O
public	O
int	O
above_mem	int
,	O
below_mem	int
;	O
public	O
int	O
can_goto_line	int
;	O
public	O
int	O
clear_bg	int
;	O
public	O
int	O
missing_cap	int
=	O
0	int
;	O
public	O
char	O
*	O
kent	pointer
=	O
NULL	O
;	O
static	O
int	O
attrmode	int
=	O
AT_NORMAL	O
;	O
extern	O
int	O
binattr	int
;	O
extern	O
int	O
line_count	int
;	O
static	O
char	O
*	O
cheaper	function
(	O
)	O
;	O
static	O
void	O
tmodes	function
(	O
)	O
;	O
extern	O
int	O
quiet	int
;	O
extern	O
int	O
no_back_scroll	int
;	O
extern	O
int	O
swindow	int
;	O
extern	O
int	O
no_init	int
;	O
extern	O
int	O
no_keypad	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
wscroll	int
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
tty	int
;	O
extern	O
int	O
top_scroll	int
;	O
extern	O
int	O
quit_if_one_screen	int
;	O
extern	O
int	O
oldbot	int
;	O
extern	O
int	O
hilite_search	int
;	O
extern	O
char	O
*	O
tgetstr	function
(	O
)	O
;	O
extern	O
char	O
*	O
tgoto	function
(	O
)	O
;	O
public	O
void	O
raw_mode	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
static	O
int	O
curr_on	int
=	O
0	int
;	O
if	O
(	O
on	int
==	O
curr_on	int
)	O
return	O
;	O
erase2_char	int
=	O
'\b'	O
;	O
{	O
struct	O
termios	struct
s	pointer
;	O
static	O
struct	O
termios	struct
save_term	struct
;	O
static	O
int	O
saved_term	int
=	O
0	int
;	O
if	O
(	O
on	int
)	O
{	O
tcgetattr	function
(	O
tty	int
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
!	O
saved_term	int
)	O
{	O
save_term	struct
=	O
s	pointer
;	O
saved_term	int
=	O
1	int
;	O
}	O
switch	O
(	O
cfgetospeed	function
(	O
&	O
s	pointer
)	O
)	O
{	O
case	O
B0	int
:	O
ospeed	short
=	O
0	int
;	O
break	O
;	O
case	O
B50	int
:	O
ospeed	short
=	O
1	int
;	O
break	O
;	O
case	O
B75	int
:	O
ospeed	short
=	O
2	int
;	O
break	O
;	O
case	O
B110	int
:	O
ospeed	short
=	O
3	int
;	O
break	O
;	O
case	O
B134	int
:	O
ospeed	short
=	O
4	int
;	O
break	O
;	O
case	O
B150	int
:	O
ospeed	short
=	O
5	int
;	O
break	O
;	O
case	O
B200	int
:	O
ospeed	short
=	O
6	int
;	O
break	O
;	O
case	O
B300	int
:	O
ospeed	short
=	O
7	int
;	O
break	O
;	O
case	O
B600	int
:	O
ospeed	short
=	O
8	int
;	O
break	O
;	O
case	O
B1200	int
:	O
ospeed	short
=	O
9	int
;	O
break	O
;	O
case	O
B1800	int
:	O
ospeed	short
=	O
10	int
;	O
break	O
;	O
case	O
B2400	int
:	O
ospeed	short
=	O
11	int
;	O
break	O
;	O
case	O
B4800	int
:	O
ospeed	short
=	O
12	int
;	O
break	O
;	O
case	O
B9600	int
:	O
ospeed	short
=	O
13	int
;	O
break	O
;	O
case	O
EXTA	O
:	O
ospeed	short
=	O
14	int
;	O
break	O
;	O
case	O
EXTB	O
:	O
ospeed	short
=	O
15	int
;	O
break	O
;	O
case	O
B57600	int
:	O
ospeed	short
=	O
16	int
;	O
break	O
;	O
case	O
B115200	int
:	O
ospeed	short
=	O
17	int
;	O
break	O
;	O
default	O
:	O
;	O
}	O
erase_char	int
=	O
s	pointer
.	O
c_cc	array
[	O
VERASE	int
]	O
;	O
kill_char	int
=	O
s	pointer
.	O
c_cc	array
[	O
VKILL	int
]	O
;	O
werase_char	int
=	O
s	pointer
.	O
c_cc	array
[	O
VWERASE	int
]	O
;	O
s	pointer
.	O
c_lflag	short
&=	O
~	O
(	O
0	int
|	O
ICANON	int
|	O
ECHO	int
|	O
ECHOE	int
|	O
ECHOK	int
|	O
ECHONL	int
)	O
;	O
s	pointer
.	O
c_oflag	short
|=	O
(	O
0	int
|	O
TAB3	int
|	O
OPOST	int
|	O
ONLCR	int
)	O
;	O
s	pointer
.	O
c_oflag	short
&=	O
~	O
(	O
0	int
|	O
OCRNL	int
|	O
ONOCR	int
|	O
ONLRET	int
)	O
;	O
s	pointer
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
s	pointer
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
s	pointer
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
s	pointer
=	O
save_term	struct
;	O
}	O
fsync	function
(	O
tty	int
)	O
;	O
tcsetattr	function
(	O
tty	int
,	O
TCSADRAIN	int
,	O
&	O
s	pointer
)	O
;	O
}	O
curr_on	int
=	O
on	int
;	O
}	O
static	O
int	O
hardcopy	int
;	O
static	O
char	O
*	O
ltget_env	function
(	O
capname	pointer
)	O
char	O
*	O
capname	pointer
;	O
{	O
char	O
name	pointer
[	O
16	int
]	O
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
lgetenv	function
(	O
"LESS_TERMCAP_DEBUG"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
struct	O
env	struct
{	O
struct	O
env	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
value	pointer
;	O
}	O
;	O
static	O
struct	O
env	struct
*	O
envs	pointer
=	O
NULL	O
;	O
struct	O
env	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
envs	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
name	pointer
,	O
capname	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
->	O
value	pointer
;	O
p	pointer
=	O
(	O
struct	O
env	struct
*	O
)	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
env	struct
)	O
)	O
;	O
p	pointer
->	O
name	pointer
=	O
save	function
(	O
capname	pointer
)	O
;	O
p	pointer
->	O
value	pointer
=	O
(	O
char	O
*	O
)	O
ecalloc	function
(	O
strlen	function
(	O
capname	pointer
)	O
+	O
3	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
sprintf	function
(	O
p	pointer
->	O
value	pointer
,	O
"<%s>"	pointer
,	O
capname	pointer
)	O
;	O
p	pointer
->	O
next	pointer
=	O
envs	pointer
;	O
envs	pointer
=	O
p	pointer
;	O
return	O
p	pointer
->	O
value	pointer
;	O
}	O
strcpy	function
(	O
name	pointer
,	O
"LESS_TERMCAP_"	pointer
)	O
;	O
strcat	function
(	O
name	pointer
,	O
capname	pointer
)	O
;	O
return	O
(	O
lgetenv	function
(	O
name	pointer
)	O
)	O
;	O
}	O
static	O
int	O
ltgetflag	function
(	O
capname	pointer
)	O
char	O
*	O
capname	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
ltget_env	function
(	O
capname	pointer
)	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
*	O
s	pointer
!=	O
'0'	O
)	O
;	O
if	O
(	O
hardcopy	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
tgetflag	function
(	O
capname	pointer
)	O
)	O
;	O
}	O
static	O
int	O
ltgetnum	function
(	O
capname	pointer
)	O
char	O
*	O
capname	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
ltget_env	function
(	O
capname	pointer
)	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
atoi	function
(	O
s	pointer
)	O
)	O
;	O
if	O
(	O
hardcopy	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
return	O
(	O
tgetnum	function
(	O
capname	pointer
)	O
)	O
;	O
}	O
static	O
char	O
*	O
ltgetstr	function
(	O
capname	pointer
,	O
pp	pointer
)	O
char	O
*	O
capname	pointer
;	O
char	O
*	O
*	O
pp	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
ltget_env	function
(	O
capname	pointer
)	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
s	pointer
)	O
;	O
if	O
(	O
hardcopy	int
)	O
return	O
(	O
NULL	O
)	O
;	O
return	O
(	O
tgetstr	function
(	O
capname	pointer
,	O
pp	pointer
)	O
)	O
;	O
}	O
public	O
void	O
scrsize	function
(	O
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
sys_height	int
;	O
int	O
sys_width	int
;	O
int	O
n	int
;	O
sys_width	int
=	O
sys_height	int
=	O
0	int
;	O
{	O
struct	O
winsize	struct
w	struct
;	O
if	O
(	O
ioctl	function
(	O
2	int
,	O
TIOCGWINSZ	int
,	O
&	O
w	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
w	struct
.	O
ws_row	short
>	O
0	int
)	O
sys_height	int
=	O
w	struct
.	O
ws_row	short
;	O
if	O
(	O
w	struct
.	O
ws_col	short
>	O
0	int
)	O
sys_width	int
=	O
w	struct
.	O
ws_col	short
;	O
}	O
}	O
if	O
(	O
sys_height	int
>	O
0	int
)	O
sc_height	int
=	O
sys_height	int
;	O
else	O
if	O
(	O
(	O
s	pointer
=	O
lgetenv	function
(	O
"LINES"	pointer
)	O
)	O
!=	O
NULL	O
)	O
sc_height	int
=	O
atoi	function
(	O
s	pointer
)	O
;	O
else	O
if	O
(	O
(	O
n	int
=	O
ltgetnum	function
(	O
"li"	pointer
)	O
)	O
>	O
0	int
)	O
sc_height	int
=	O
n	int
;	O
if	O
(	O
sc_height	int
<=	O
0	int
)	O
sc_height	int
=	O
DEF_SC_HEIGHT	int
;	O
if	O
(	O
sys_width	int
>	O
0	int
)	O
sc_width	int
=	O
sys_width	int
;	O
else	O
if	O
(	O
(	O
s	pointer
=	O
lgetenv	function
(	O
"COLUMNS"	pointer
)	O
)	O
!=	O
NULL	O
)	O
sc_width	int
=	O
atoi	function
(	O
s	pointer
)	O
;	O
else	O
if	O
(	O
(	O
n	int
=	O
ltgetnum	function
(	O
"co"	pointer
)	O
)	O
>	O
0	int
)	O
sc_width	int
=	O
n	int
;	O
if	O
(	O
sc_width	int
<=	O
0	int
)	O
sc_width	int
=	O
DEF_SC_WIDTH	int
;	O
}	O
public	O
char	O
*	O
special_key_str	function
(	O
key	int
)	O
int	O
key	int
;	O
{	O
static	O
char	O
tbuf	array
[	O
40	int
]	O
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
sp	pointer
=	O
tbuf	array
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
SK_RIGHT_ARROW	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kr"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_LEFT_ARROW	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kl"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_UP_ARROW	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"ku"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_DOWN_ARROW	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kd"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_PAGE_UP	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kP"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_PAGE_DOWN	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kN"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_HOME	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kh"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_END	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"@7"	pointer
,	O
&	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
SK_DELETE	int
:	O
s	pointer
=	O
ltgetstr	function
(	O
"kD"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
{	O
tbuf	array
[	O
0	int
]	O
=	O
'\177'	O
;	O
tbuf	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
s	pointer
=	O
tbuf	array
;	O
}	O
break	O
;	O
case	O
SK_CONTROL_K	int
:	O
tbuf	array
[	O
0	int
]	O
=	O
CONTROL	O
(	O
'K'	O
)	O
;	O
tbuf	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
s	pointer
=	O
tbuf	array
;	O
break	O
;	O
default	O
:	O
return	O
(	O
NULL	O
)	O
;	O
}	O
return	O
(	O
s	pointer
)	O
;	O
}	O
public	O
void	O
get_term	function
(	O
)	O
{	O
char	O
*	O
sp	pointer
;	O
char	O
*	O
t1	pointer
,	O
*	O
t2	pointer
;	O
char	O
*	O
term	pointer
;	O
char	O
termbuf	array
[	O
TERMBUF_SIZE	int
]	O
;	O
static	O
char	O
sbuf	array
[	O
TERMSBUF_SIZE	int
]	O
;	O
if	O
(	O
(	O
term	pointer
=	O
lgetenv	function
(	O
"TERM"	pointer
)	O
)	O
==	O
NULL	O
)	O
term	pointer
=	O
DEFAULT_TERM	pointer
;	O
hardcopy	int
=	O
0	int
;	O
if	O
(	O
tgetent	function
(	O
termbuf	array
,	O
term	pointer
)	O
!=	O
TGETENT_OK	int
)	O
hardcopy	int
=	O
1	int
;	O
if	O
(	O
ltgetflag	function
(	O
"hc"	pointer
)	O
)	O
hardcopy	int
=	O
1	int
;	O
scrsize	function
(	O
)	O
;	O
pos_init	function
(	O
)	O
;	O
auto_wrap	int
=	O
ltgetflag	function
(	O
"am"	pointer
)	O
;	O
ignaw	int
=	O
ltgetflag	function
(	O
"xn"	pointer
)	O
;	O
above_mem	int
=	O
ltgetflag	function
(	O
"da"	pointer
)	O
;	O
below_mem	int
=	O
ltgetflag	function
(	O
"db"	pointer
)	O
;	O
clear_bg	int
=	O
ltgetflag	function
(	O
"ut"	pointer
)	O
;	O
if	O
(	O
(	O
so_s_width	int
=	O
ltgetnum	function
(	O
"sg"	pointer
)	O
)	O
<	O
0	int
)	O
so_s_width	int
=	O
0	int
;	O
so_e_width	int
=	O
so_s_width	int
;	O
bo_s_width	int
=	O
bo_e_width	int
=	O
so_s_width	int
;	O
ul_s_width	int
=	O
ul_e_width	int
=	O
so_s_width	int
;	O
bl_s_width	int
=	O
bl_e_width	int
=	O
so_s_width	int
;	O
if	O
(	O
so_s_width	int
>	O
0	int
||	O
so_e_width	int
>	O
0	int
)	O
hilite_search	int
=	O
0	int
;	O
sp	pointer
=	O
sbuf	array
;	O
sc_pad	pointer
=	O
ltgetstr	function
(	O
"pc"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_pad	pointer
!=	O
NULL	O
)	O
PC	char
=	O
*	O
sc_pad	pointer
;	O
sc_s_keypad	pointer
=	O
ltgetstr	function
(	O
"ks"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_s_keypad	pointer
==	O
NULL	O
)	O
sc_s_keypad	pointer
=	O
""	pointer
;	O
sc_e_keypad	pointer
=	O
ltgetstr	function
(	O
"ke"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_e_keypad	pointer
==	O
NULL	O
)	O
sc_e_keypad	pointer
=	O
""	pointer
;	O
kent	pointer
=	O
ltgetstr	function
(	O
"@8"	pointer
,	O
&	O
sp	pointer
)	O
;	O
sc_init	pointer
=	O
ltgetstr	function
(	O
"ti"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_init	pointer
==	O
NULL	O
)	O
sc_init	pointer
=	O
""	pointer
;	O
sc_deinit	pointer
=	O
ltgetstr	function
(	O
"te"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_deinit	pointer
==	O
NULL	O
)	O
sc_deinit	pointer
=	O
""	pointer
;	O
sc_eol_clear	pointer
=	O
ltgetstr	function
(	O
"ce"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_eol_clear	pointer
==	O
NULL	O
||	O
*	O
sc_eol_clear	pointer
==	O
'\0'	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
sc_eol_clear	pointer
=	O
""	pointer
;	O
}	O
sc_eos_clear	pointer
=	O
ltgetstr	function
(	O
"cd"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
below_mem	int
&&	O
(	O
sc_eos_clear	pointer
==	O
NULL	O
||	O
*	O
sc_eos_clear	pointer
==	O
'\0'	O
)	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
sc_eos_clear	pointer
=	O
""	pointer
;	O
}	O
sc_clear	pointer
=	O
ltgetstr	function
(	O
"cl"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_clear	pointer
==	O
NULL	O
||	O
*	O
sc_clear	pointer
==	O
'\0'	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
sc_clear	pointer
=	O
"\n\n"	pointer
;	O
}	O
sc_move	pointer
=	O
ltgetstr	function
(	O
"cm"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_move	pointer
==	O
NULL	O
||	O
*	O
sc_move	pointer
==	O
'\0'	O
)	O
{	O
sc_move	pointer
=	O
""	pointer
;	O
can_goto_line	int
=	O
0	int
;	O
}	O
else	O
can_goto_line	int
=	O
1	int
;	O
tmodes	function
(	O
"so"	pointer
,	O
"se"	pointer
,	O
&	O
sc_s_in	pointer
,	O
&	O
sc_s_out	pointer
,	O
""	pointer
,	O
""	pointer
,	O
&	O
sp	pointer
)	O
;	O
tmodes	function
(	O
"us"	pointer
,	O
"ue"	pointer
,	O
&	O
sc_u_in	pointer
,	O
&	O
sc_u_out	pointer
,	O
sc_s_in	pointer
,	O
sc_s_out	pointer
,	O
&	O
sp	pointer
)	O
;	O
tmodes	function
(	O
"md"	pointer
,	O
"me"	pointer
,	O
&	O
sc_b_in	pointer
,	O
&	O
sc_b_out	pointer
,	O
sc_s_in	pointer
,	O
sc_s_out	pointer
,	O
&	O
sp	pointer
)	O
;	O
tmodes	function
(	O
"mb"	pointer
,	O
"me"	pointer
,	O
&	O
sc_bl_in	pointer
,	O
&	O
sc_bl_out	pointer
,	O
sc_s_in	pointer
,	O
sc_s_out	pointer
,	O
&	O
sp	pointer
)	O
;	O
sc_visual_bell	pointer
=	O
ltgetstr	function
(	O
"vb"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_visual_bell	pointer
==	O
NULL	O
)	O
sc_visual_bell	pointer
=	O
""	pointer
;	O
if	O
(	O
ltgetflag	function
(	O
"bs"	pointer
)	O
)	O
sc_backspace	pointer
=	O
"\b"	pointer
;	O
else	O
{	O
sc_backspace	pointer
=	O
ltgetstr	function
(	O
"bc"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_backspace	pointer
==	O
NULL	O
||	O
*	O
sc_backspace	pointer
==	O
'\0'	O
)	O
sc_backspace	pointer
=	O
"\b"	pointer
;	O
}	O
t1	pointer
=	O
ltgetstr	function
(	O
"ho"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
t1	pointer
==	O
NULL	O
)	O
t1	pointer
=	O
""	pointer
;	O
if	O
(	O
*	O
sc_move	pointer
==	O
'\0'	O
)	O
t2	pointer
=	O
""	pointer
;	O
else	O
{	O
strcpy	function
(	O
sp	pointer
,	O
tgoto	function
(	O
sc_move	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
t2	pointer
=	O
sp	pointer
;	O
sp	pointer
+=	O
strlen	function
(	O
sp	pointer
)	O
+	O
1	int
;	O
}	O
sc_home	pointer
=	O
cheaper	function
(	O
t1	pointer
,	O
t2	pointer
,	O
"|\b^"	pointer
)	O
;	O
t1	pointer
=	O
ltgetstr	function
(	O
"ll"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
t1	pointer
==	O
NULL	O
)	O
t1	pointer
=	O
""	pointer
;	O
if	O
(	O
*	O
sc_move	pointer
==	O
'\0'	O
)	O
t2	pointer
=	O
""	pointer
;	O
else	O
{	O
strcpy	function
(	O
sp	pointer
,	O
tgoto	function
(	O
sc_move	pointer
,	O
0	int
,	O
sc_height	int
-	O
1	int
)	O
)	O
;	O
t2	pointer
=	O
sp	pointer
;	O
sp	pointer
+=	O
strlen	function
(	O
sp	pointer
)	O
+	O
1	int
;	O
}	O
sc_lower_left	pointer
=	O
cheaper	function
(	O
t1	pointer
,	O
t2	pointer
,	O
"\r"	pointer
)	O
;	O
sc_return	pointer
=	O
ltgetstr	function
(	O
"cr"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
sc_return	pointer
==	O
NULL	O
)	O
sc_return	pointer
=	O
"\r"	pointer
;	O
t1	pointer
=	O
ltgetstr	function
(	O
"al"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
t1	pointer
==	O
NULL	O
)	O
t1	pointer
=	O
""	pointer
;	O
t2	pointer
=	O
ltgetstr	function
(	O
"sr"	pointer
,	O
&	O
sp	pointer
)	O
;	O
if	O
(	O
t2	pointer
==	O
NULL	O
)	O
t2	pointer
=	O
""	pointer
;	O
if	O
(	O
above_mem	int
)	O
sc_addline	pointer
=	O
t1	pointer
;	O
else	O
sc_addline	pointer
=	O
cheaper	function
(	O
t1	pointer
,	O
t2	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
*	O
sc_addline	pointer
==	O
'\0'	O
)	O
{	O
no_back_scroll	int
=	O
1	int
;	O
}	O
}	O
static	O
int	O
costcount	int
;	O
static	O
int	O
inc_costcount	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
costcount	int
++	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
static	O
int	O
cost	function
(	O
t	pointer
)	O
char	O
*	O
t	pointer
;	O
{	O
costcount	int
=	O
0	int
;	O
tputs	function
(	O
t	pointer
,	O
sc_height	int
,	O
inc_costcount	function
)	O
;	O
return	O
(	O
costcount	int
)	O
;	O
}	O
static	O
char	O
*	O
cheaper	function
(	O
t1	pointer
,	O
t2	pointer
,	O
def	pointer
)	O
char	O
*	O
t1	pointer
,	O
*	O
t2	pointer
;	O
char	O
*	O
def	pointer
;	O
{	O
if	O
(	O
*	O
t1	pointer
==	O
'\0'	O
&&	O
*	O
t2	pointer
==	O
'\0'	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
return	O
(	O
def	pointer
)	O
;	O
}	O
if	O
(	O
*	O
t1	pointer
==	O
'\0'	O
)	O
return	O
(	O
t2	pointer
)	O
;	O
if	O
(	O
*	O
t2	pointer
==	O
'\0'	O
)	O
return	O
(	O
t1	pointer
)	O
;	O
if	O
(	O
cost	function
(	O
t1	pointer
)	O
<	O
cost	function
(	O
t2	pointer
)	O
)	O
return	O
(	O
t1	pointer
)	O
;	O
return	O
(	O
t2	pointer
)	O
;	O
}	O
static	O
void	O
tmodes	function
(	O
incap	pointer
,	O
outcap	pointer
,	O
instr	pointer
,	O
outstr	pointer
,	O
def_instr	pointer
,	O
def_outstr	pointer
,	O
spp	pointer
)	O
char	O
*	O
incap	pointer
;	O
char	O
*	O
outcap	pointer
;	O
char	O
*	O
*	O
instr	pointer
;	O
char	O
*	O
*	O
outstr	pointer
;	O
char	O
*	O
def_instr	pointer
;	O
char	O
*	O
def_outstr	pointer
;	O
char	O
*	O
*	O
spp	pointer
;	O
{	O
*	O
instr	pointer
=	O
ltgetstr	function
(	O
incap	pointer
,	O
spp	pointer
)	O
;	O
if	O
(	O
*	O
instr	pointer
==	O
NULL	O
)	O
{	O
*	O
instr	pointer
=	O
def_instr	pointer
;	O
*	O
outstr	pointer
=	O
def_outstr	pointer
;	O
return	O
;	O
}	O
*	O
outstr	pointer
=	O
ltgetstr	function
(	O
outcap	pointer
,	O
spp	pointer
)	O
;	O
if	O
(	O
*	O
outstr	pointer
==	O
NULL	O
)	O
*	O
outstr	pointer
=	O
ltgetstr	function
(	O
"me"	pointer
,	O
spp	pointer
)	O
;	O
if	O
(	O
*	O
outstr	pointer
==	O
NULL	O
)	O
*	O
outstr	pointer
=	O
""	pointer
;	O
}	O
public	O
void	O
init	function
(	O
)	O
{	O
if	O
(	O
quit_if_one_screen	int
&&	O
line_count	int
>=	O
sc_height	int
)	O
quit_if_one_screen	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
no_init	int
&&	O
!	O
quit_if_one_screen	int
)	O
tputs	function
(	O
sc_init	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
if	O
(	O
!	O
no_keypad	int
)	O
tputs	function
(	O
sc_s_keypad	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
if	O
(	O
top_scroll	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
sc_height	int
;	O
i	int
++	O
)	O
putchr	function
(	O
'\n'	O
)	O
;	O
}	O
else	O
line_left	function
(	O
)	O
;	O
init_done	int
=	O
1	int
;	O
}	O
public	O
void	O
deinit	function
(	O
)	O
{	O
if	O
(	O
!	O
init_done	int
)	O
return	O
;	O
if	O
(	O
!	O
no_keypad	int
)	O
tputs	function
(	O
sc_e_keypad	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
if	O
(	O
!	O
no_init	int
&&	O
!	O
quit_if_one_screen	int
)	O
tputs	function
(	O
sc_deinit	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
init_done	int
=	O
0	int
;	O
}	O
public	O
void	O
home	function
(	O
)	O
{	O
tputs	function
(	O
sc_home	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
add_line	function
(	O
)	O
{	O
tputs	function
(	O
sc_addline	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
lower_left	function
(	O
)	O
{	O
if	O
(	O
!	O
init_done	int
)	O
return	O
;	O
tputs	function
(	O
sc_lower_left	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
line_left	function
(	O
)	O
{	O
tputs	function
(	O
sc_return	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
check_winch	function
(	O
)	O
{	O
}	O
public	O
void	O
goto_line	function
(	O
sindex	int
)	O
int	O
sindex	int
;	O
{	O
tputs	function
(	O
tgoto	function
(	O
sc_move	pointer
,	O
0	int
,	O
sindex	int
)	O
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
vbell	function
(	O
)	O
{	O
if	O
(	O
*	O
sc_visual_bell	pointer
==	O
'\0'	O
)	O
return	O
;	O
tputs	function
(	O
sc_visual_bell	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
}	O
static	O
void	O
beep	function
(	O
)	O
{	O
putchr	function
(	O
CONTROL	O
(	O
'G'	O
)	O
)	O
;	O
}	O
public	O
void	O
bell	function
(	O
)	O
{	O
if	O
(	O
quiet	int
==	O
VERY_QUIET	int
)	O
vbell	function
(	O
)	O
;	O
else	O
beep	function
(	O
)	O
;	O
}	O
public	O
void	O
clear	function
(	O
)	O
{	O
tputs	function
(	O
sc_clear	pointer
,	O
sc_height	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
clear_eol	function
(	O
)	O
{	O
tputs	function
(	O
sc_eol_clear	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O
static	O
void	O
clear_eol_bot	function
(	O
)	O
{	O
if	O
(	O
below_mem	int
)	O
tputs	function
(	O
sc_eos_clear	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
else	O
tputs	function
(	O
sc_eol_clear	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O
public	O
void	O
clear_bot	function
(	O
)	O
{	O
if	O
(	O
oldbot	int
)	O
lower_left	function
(	O
)	O
;	O
else	O
line_left	function
(	O
)	O
;	O
if	O
(	O
attrmode	int
==	O
AT_NORMAL	O
)	O
clear_eol_bot	function
(	O
)	O
;	O
else	O
{	O
int	O
saved_attrmode	int
=	O
attrmode	int
;	O
at_exit	function
(	O
)	O
;	O
clear_eol_bot	function
(	O
)	O
;	O
at_enter	function
(	O
saved_attrmode	int
)	O
;	O
}	O
}	O
public	O
void	O
at_enter	function
(	O
attr	int
)	O
int	O
attr	int
;	O
{	O
attr	int
=	O
apply_at_specials	function
(	O
attr	int
)	O
;	O
if	O
(	O
attr	int
&	O
AT_UNDERLINE	O
)	O
tputs	function
(	O
sc_u_in	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
if	O
(	O
attr	int
&	O
AT_BOLD	O
)	O
tputs	function
(	O
sc_b_in	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
if	O
(	O
attr	int
&	O
AT_BLINK	O
)	O
tputs	function
(	O
sc_bl_in	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
if	O
(	O
attr	int
&	O
AT_STANDOUT	O
)	O
tputs	function
(	O
sc_s_in	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
attrmode	int
=	O
attr	int
;	O
}	O
public	O
void	O
at_exit	function
(	O
)	O
{	O
if	O
(	O
attrmode	int
&	O
AT_STANDOUT	O
)	O
tputs	function
(	O
sc_s_out	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
if	O
(	O
attrmode	int
&	O
AT_BLINK	O
)	O
tputs	function
(	O
sc_bl_out	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
if	O
(	O
attrmode	int
&	O
AT_BOLD	O
)	O
tputs	function
(	O
sc_b_out	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
if	O
(	O
attrmode	int
&	O
AT_UNDERLINE	O
)	O
tputs	function
(	O
sc_u_out	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
attrmode	int
=	O
AT_NORMAL	O
;	O
}	O
public	O
void	O
at_switch	function
(	O
attr	int
)	O
int	O
attr	int
;	O
{	O
int	O
new_attrmode	int
=	O
apply_at_specials	function
(	O
attr	int
)	O
;	O
int	O
ignore_modes	int
=	O
AT_ANSI	O
;	O
if	O
(	O
(	O
new_attrmode	int
&	O
~	O
ignore_modes	int
)	O
!=	O
(	O
attrmode	int
&	O
~	O
ignore_modes	int
)	O
)	O
{	O
at_exit	function
(	O
)	O
;	O
at_enter	function
(	O
attr	int
)	O
;	O
}	O
}	O
public	O
int	O
is_at_equiv	function
(	O
attr1	int
,	O
attr2	int
)	O
int	O
attr1	int
;	O
int	O
attr2	int
;	O
{	O
attr1	int
=	O
apply_at_specials	function
(	O
attr1	int
)	O
;	O
attr2	int
=	O
apply_at_specials	function
(	O
attr2	int
)	O
;	O
return	O
(	O
attr1	int
==	O
attr2	int
)	O
;	O
}	O
public	O
int	O
apply_at_specials	function
(	O
attr	int
)	O
int	O
attr	int
;	O
{	O
if	O
(	O
attr	int
&	O
AT_BINARY	O
)	O
attr	int
|=	O
binattr	int
;	O
if	O
(	O
attr	int
&	O
AT_HILITE	O
)	O
attr	int
|=	O
AT_STANDOUT	O
;	O
attr	int
&=	O
~	O
(	O
AT_BINARY	O
|	O
AT_HILITE	O
)	O
;	O
return	O
attr	int
;	O
}	O
public	O
void	O
putbs	function
(	O
)	O
{	O
tputs	function
(	O
sc_backspace	pointer
,	O
1	int
,	O
putchr	function
)	O
;	O
}	O