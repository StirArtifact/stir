static	O
const	O
char	O
*	O
const	O
pex_regs	array
[	O
16	int
]	O
=	O
{	O
"rax"	pointer
,	O
"rcx"	pointer
,	O
"rdx"	pointer
,	O
"rbx"	pointer
,	O
"rsp"	pointer
,	O
"rbp"	pointer
,	O
"rsi"	pointer
,	O
"rdi"	pointer
,	O
"r8"	pointer
,	O
"r9"	pointer
,	O
"r10"	pointer
,	O
"r11"	pointer
,	O
"r12"	pointer
,	O
"r13"	pointer
,	O
"r14"	pointer
,	O
"r15"	pointer
}	O
;	O
static	O
void	O
pex64_get_runtime_function	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
pex64_runtime_function	struct
*	O
rf	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
struct	O
external_pex64_runtime_function	struct
*	O
ex_rf	pointer
=	O
(	O
const	O
struct	O
external_pex64_runtime_function	struct
*	O
)	O
data	pointer
;	O
rf	pointer
->	O
rva_BeginAddress	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_rf	pointer
->	O
rva_BeginAddress	long
)	O
;	O
rf	pointer
->	O
rva_EndAddress	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_rf	pointer
->	O
rva_EndAddress	long
)	O
;	O
rf	pointer
->	O
rva_UnwindData	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_rf	pointer
->	O
rva_UnwindData	long
)	O
;	O
}	O
static	O
bfd_boolean	int
pex64_get_unwind_info	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
pex64_unwind_info	struct
*	O
ui	pointer
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
data_end	pointer
)	O
{	O
struct	O
external_pex64_unwind_info	struct
*	O
ex_ui	pointer
=	O
(	O
struct	O
external_pex64_unwind_info	struct
*	O
)	O
data	pointer
;	O
bfd_byte	char
*	O
ex_dta	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
data	pointer
;	O
bfd_byte	char
*	O
ex_dta_end	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
data_end	pointer
;	O
memset	function
(	O
ui	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
pex64_unwind_info	struct
)	O
)	O
;	O
if	O
(	O
ex_dta	pointer
>=	O
ex_dta_end	pointer
||	O
ex_dta	pointer
+	O
4	int
>=	O
ex_dta_end	pointer
)	O
return	O
FALSE	int
;	O
ui	pointer
->	O
Version	array
=	O
PEX64_UWI_VERSION	O
(	O
ex_ui	pointer
->	O
Version_Flags	char
)	O
;	O
ui	pointer
->	O
Flags	array
=	O
PEX64_UWI_FLAGS	O
(	O
ex_ui	pointer
->	O
Version_Flags	char
)	O
;	O
ui	pointer
->	O
SizeOfPrologue	long
=	O
(	O
bfd_vma	long
)	O
ex_ui	pointer
->	O
SizeOfPrologue	long
;	O
ui	pointer
->	O
CountOfCodes	long
=	O
(	O
bfd_vma	long
)	O
ex_ui	pointer
->	O
CountOfCodes	long
;	O
ui	pointer
->	O
FrameRegister	int
=	O
PEX64_UWI_FRAMEREG	O
(	O
ex_ui	pointer
->	O
FrameRegisterOffset	char
)	O
;	O
ui	pointer
->	O
FrameOffset	long
=	O
PEX64_UWI_FRAMEOFF	O
(	O
ex_ui	pointer
->	O
FrameRegisterOffset	char
)	O
;	O
ui	pointer
->	O
sizeofUnwindCodes	long
=	O
PEX64_UWI_SIZEOF_UWCODE_ARRAY	O
(	O
ui	pointer
->	O
CountOfCodes	long
)	O
;	O
ui	pointer
->	O
SizeOfBlock	long
=	O
ui	pointer
->	O
sizeofUnwindCodes	long
+	O
4	int
;	O
ui	pointer
->	O
rawUnwindCodes	pointer
=	O
ex_dta	pointer
+	O
4	int
;	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
=	O
ex_dta_end	pointer
;	O
ex_dta	pointer
+=	O
ui	pointer
->	O
SizeOfBlock	long
;	O
if	O
(	O
ex_dta	pointer
>=	O
ex_dta_end	pointer
)	O
return	O
FALSE	int
;	O
switch	O
(	O
ui	pointer
->	O
Flags	array
)	O
{	O
case	O
UNW_FLAG_CHAININFO	int
:	O
if	O
(	O
ex_dta	pointer
+	O
12	int
>=	O
ex_dta_end	pointer
)	O
return	O
FALSE	int
;	O
ui	pointer
->	O
rva_BeginAddress	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_dta	pointer
+	O
0	int
)	O
;	O
ui	pointer
->	O
rva_EndAddress	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_dta	pointer
+	O
4	int
)	O
;	O
ui	pointer
->	O
rva_UnwindData	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_dta	pointer
+	O
8	int
)	O
;	O
ui	pointer
->	O
SizeOfBlock	long
+=	O
12	int
;	O
return	O
TRUE	int
;	O
case	O
UNW_FLAG_EHANDLER	int
:	O
case	O
UNW_FLAG_UHANDLER	int
:	O
case	O
UNW_FLAG_FHANDLER	int
:	O
if	O
(	O
ex_dta	pointer
+	O
4	int
>=	O
ex_dta_end	pointer
)	O
return	O
FALSE	int
;	O
ui	pointer
->	O
rva_ExceptionHandler	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
ex_dta	pointer
)	O
;	O
ui	pointer
->	O
SizeOfBlock	long
+=	O
4	int
;	O
return	O
TRUE	int
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
}	O
static	O
void	O
pex64_xdata_print_uwd_codes	function
(	O
FILE	struct
*	O
file	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
pex64_unwind_info	struct
*	O
ui	pointer
,	O
struct	O
pex64_runtime_function	struct
*	O
rf	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
tmp	int
;	O
int	O
save_allowed	int
;	O
if	O
(	O
ui	pointer
->	O
CountOfCodes	long
==	O
0	int
||	O
ui	pointer
->	O
rawUnwindCodes	pointer
==	O
NULL	O
)	O
return	O
;	O
save_allowed	int
=	O
TRUE	int
;	O
i	pointer
=	O
0	int
;	O
if	O
(	O
ui	pointer
->	O
rawUnwindCodes	pointer
+	O
1	int
>=	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ui	pointer
->	O
Version	array
==	O
2	int
&&	O
PEX64_UNWCODE_CODE	O
(	O
ui	pointer
->	O
rawUnwindCodes	pointer
[	O
1	int
]	O
)	O
==	O
UWOP_EPILOG	int
)	O
{	O
unsigned	O
int	O
func_size	int
=	O
rf	pointer
->	O
rva_EndAddress	long
-	O
rf	pointer
->	O
rva_BeginAddress	long
;	O
if	O
(	O
ui	pointer
->	O
rawUnwindCodes	pointer
+	O
1	int
+	O
(	O
ui	pointer
->	O
CountOfCodes	long
*	O
2	int
)	O
>=	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"\tv2 epilog (length: %02x) at pc+:"	pointer
,	O
ui	pointer
->	O
rawUnwindCodes	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
PEX64_UNWCODE_INFO	O
(	O
ui	pointer
->	O
rawUnwindCodes	pointer
[	O
1	int
]	O
)	O
)	O
fprintf	function
(	O
file	pointer
,	O
" 0x%x"	pointer
,	O
func_size	int
-	O
ui	pointer
->	O
rawUnwindCodes	pointer
[	O
0	int
]	O
)	O
;	O
i	pointer
++	O
;	O
for	O
(	O
;	O
i	pointer
<	O
ui	pointer
->	O
CountOfCodes	long
;	O
i	pointer
++	O
)	O
{	O
const	O
bfd_byte	char
*	O
dta	array
=	O
ui	pointer
->	O
rawUnwindCodes	pointer
+	O
2	int
*	O
i	pointer
;	O
unsigned	O
int	O
off	int
;	O
if	O
(	O
PEX64_UNWCODE_CODE	O
(	O
dta	array
[	O
1	int
]	O
)	O
!=	O
UWOP_EPILOG	int
)	O
break	O
;	O
off	int
=	O
dta	array
[	O
0	int
]	O
|	O
(	O
PEX64_UNWCODE_INFO	O
(	O
dta	array
[	O
1	int
]	O
)	O
<<	O
8	int
)	O
;	O
if	O
(	O
off	int
==	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
" [pad]"	pointer
)	O
;	O
else	O
fprintf	function
(	O
file	pointer
,	O
" 0x%x"	pointer
,	O
func_size	int
-	O
off	int
)	O
;	O
}	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
if	O
(	O
ui	pointer
->	O
rawUnwindCodes	pointer
+	O
2	int
+	O
(	O
ui	pointer
->	O
CountOfCodes	long
*	O
2	int
)	O
>=	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
i	pointer
<	O
ui	pointer
->	O
CountOfCodes	long
;	O
i	pointer
++	O
)	O
{	O
const	O
bfd_byte	char
*	O
dta	array
=	O
ui	pointer
->	O
rawUnwindCodes	pointer
+	O
2	int
*	O
i	pointer
;	O
unsigned	O
int	O
info	pointer
=	O
PEX64_UNWCODE_INFO	O
(	O
dta	array
[	O
1	int
]	O
)	O
;	O
int	O
unexpected	int
=	O
FALSE	int
;	O
fprintf	function
(	O
file	pointer
,	O
"\t  pc+0x%02x: "	pointer
,	O
(	O
unsigned	O
int	O
)	O
dta	array
[	O
0	int
]	O
)	O
;	O
switch	O
(	O
PEX64_UNWCODE_CODE	O
(	O
dta	array
[	O
1	int
]	O
)	O
)	O
{	O
case	O
UWOP_PUSH_NONVOL	int
:	O
fprintf	function
(	O
file	pointer
,	O
"push %s"	pointer
,	O
pex_regs	array
[	O
info	pointer
]	O
)	O
;	O
break	O
;	O
case	O
UWOP_ALLOC_LARGE	int
:	O
if	O
(	O
info	pointer
==	O
0	int
)	O
{	O
if	O
(	O
dta	array
+	O
4	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
*	O
8	int
;	O
i	pointer
++	O
;	O
}	O
else	O
{	O
if	O
(	O
dta	array
+	O
6	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
;	O
i	pointer
+=	O
2	int
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"alloc large area: rsp = rsp - 0x%x"	pointer
,	O
tmp	int
)	O
;	O
break	O
;	O
case	O
UWOP_ALLOC_SMALL	int
:	O
fprintf	function
(	O
file	pointer
,	O
"alloc small area: rsp = rsp - 0x%x"	pointer
,	O
(	O
info	pointer
+	O
1	int
)	O
*	O
8	int
)	O
;	O
break	O
;	O
case	O
UWOP_SET_FPREG	int
:	O
fprintf	function
(	O
file	pointer
,	O
"FPReg: %s = rsp + 0x%x (info = 0x%x)"	pointer
,	O
pex_regs	array
[	O
ui	pointer
->	O
FrameRegister	int
]	O
,	O
(	O
unsigned	O
int	O
)	O
ui	pointer
->	O
FrameOffset	long
*	O
16	int
,	O
info	pointer
)	O
;	O
unexpected	int
=	O
ui	pointer
->	O
FrameRegister	int
==	O
0	int
;	O
save_allowed	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
UWOP_SAVE_NONVOL	int
:	O
if	O
(	O
dta	array
+	O
4	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
*	O
8	int
;	O
i	pointer
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"save %s at rsp + 0x%x"	pointer
,	O
pex_regs	array
[	O
info	pointer
]	O
,	O
tmp	int
)	O
;	O
unexpected	int
=	O
!	O
save_allowed	int
;	O
break	O
;	O
case	O
UWOP_SAVE_NONVOL_FAR	int
:	O
if	O
(	O
dta	array
+	O
6	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
;	O
i	pointer
+=	O
2	int
;	O
fprintf	function
(	O
file	pointer
,	O
"save %s at rsp + 0x%x"	pointer
,	O
pex_regs	array
[	O
info	pointer
]	O
,	O
tmp	int
)	O
;	O
unexpected	int
=	O
!	O
save_allowed	int
;	O
break	O
;	O
case	O
UWOP_SAVE_XMM	int
:	O
if	O
(	O
ui	pointer
->	O
Version	array
==	O
1	int
)	O
{	O
if	O
(	O
dta	array
+	O
4	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
*	O
8	int
;	O
i	pointer
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"save mm%u at rsp + 0x%x"	pointer
,	O
info	pointer
,	O
tmp	int
)	O
;	O
unexpected	int
=	O
!	O
save_allowed	int
;	O
}	O
else	O
if	O
(	O
ui	pointer
->	O
Version	array
==	O
2	int
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"epilog %02x %01x"	pointer
,	O
dta	array
[	O
0	int
]	O
,	O
info	pointer
)	O
;	O
unexpected	int
=	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
UWOP_SAVE_XMM_FAR	int
:	O
if	O
(	O
dta	array
+	O
6	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
*	O
8	int
;	O
i	pointer
+=	O
2	int
;	O
fprintf	function
(	O
file	pointer
,	O
"save mm%u at rsp + 0x%x"	pointer
,	O
info	pointer
,	O
tmp	int
)	O
;	O
unexpected	int
=	O
!	O
save_allowed	int
;	O
break	O
;	O
case	O
UWOP_SAVE_XMM128	int
:	O
if	O
(	O
dta	array
+	O
4	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
*	O
16	int
;	O
i	pointer
++	O
;	O
fprintf	function
(	O
file	pointer
,	O
"save xmm%u at rsp + 0x%x"	pointer
,	O
info	pointer
,	O
tmp	int
)	O
;	O
unexpected	int
=	O
!	O
save_allowed	int
;	O
break	O
;	O
case	O
UWOP_SAVE_XMM128_FAR	int
:	O
if	O
(	O
dta	array
+	O
6	int
>	O
ui	pointer
->	O
rawUnwindCodesEnd	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: corrupt unwind data\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tmp	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
dta	array
+	O
2	int
)	O
*	O
16	int
;	O
i	pointer
+=	O
2	int
;	O
fprintf	function
(	O
file	pointer
,	O
"save xmm%u at rsp + 0x%x"	pointer
,	O
info	pointer
,	O
tmp	int
)	O
;	O
unexpected	int
=	O
!	O
save_allowed	int
;	O
break	O
;	O
case	O
UWOP_PUSH_MACHFRAME	int
:	O
fprintf	function
(	O
file	pointer
,	O
"interrupt entry (SS, old RSP, EFLAGS, CS, RIP"	pointer
)	O
;	O
if	O
(	O
info	pointer
==	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
")"	pointer
)	O
;	O
else	O
if	O
(	O
info	pointer
==	O
1	int
)	O
fprintf	function
(	O
file	pointer
,	O
",ErrorCode)"	pointer
)	O
;	O
else	O
fprintf	function
(	O
file	pointer
,	O
", unknown(%u))"	pointer
,	O
info	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Unknown: %x"	pointer
)	O
,	O
PEX64_UNWCODE_CODE	O
(	O
dta	array
[	O
1	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
unexpected	int
)	O
fprintf	function
(	O
file	pointer
,	O
" [Unexpected!]"	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
}	O
static	O
asection	struct
*	O
pex64_get_section_by_rva	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
addr	pointer
,	O
const	O
char	O
*	O
sec_name	pointer
)	O
{	O
asection	struct
*	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
sec_name	pointer
)	O
;	O
bfd_vma	long
vsize	long
;	O
bfd_size_type	long
datasize	long
=	O
0	int
;	O
if	O
(	O
section	pointer
==	O
NULL	O
||	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
==	O
NULL	O
||	O
pei_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
vsize	long
=	O
section	pointer
->	O
vma	long
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
datasize	long
=	O
section	pointer
->	O
size	long
;	O
if	O
(	O
!	O
datasize	long
||	O
vsize	long
>	O
addr	pointer
||	O
(	O
vsize	long
+	O
datasize	long
)	O
<	O
addr	pointer
)	O
return	O
NULL	O
;	O
return	O
section	pointer
;	O
}	O
static	O
void	O
pex64_dump_xdata	function
(	O
FILE	struct
*	O
file	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
xdata_section	pointer
,	O
bfd_byte	char
*	O
xdata	pointer
,	O
bfd_vma	long
*	O
endx	pointer
,	O
struct	O
pex64_runtime_function	struct
*	O
rf	pointer
)	O
{	O
bfd_vma	long
vaddr	long
;	O
bfd_vma	long
end_addr	long
;	O
bfd_vma	long
addr	pointer
=	O
rf	pointer
->	O
rva_UnwindData	long
;	O
bfd_size_type	long
sec_size	long
=	O
xdata_section	pointer
->	O
rawsize	long
>	O
0	int
?	O
xdata_section	pointer
->	O
rawsize	long
:	O
xdata_section	pointer
->	O
size	long
;	O
struct	O
pex64_unwind_info	struct
ui	pointer
;	O
vaddr	long
=	O
xdata_section	pointer
->	O
vma	long
-	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
addr	pointer
-=	O
vaddr	long
;	O
if	O
(	O
addr	pointer
>=	O
sec_size	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: xdata section corrupt\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
endx	pointer
)	O
{	O
end_addr	long
=	O
endx	pointer
[	O
0	int
]	O
-	O
vaddr	long
;	O
if	O
(	O
end_addr	long
>	O
sec_size	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: xdata section corrupt\n"	pointer
)	O
)	O
;	O
end_addr	long
=	O
sec_size	long
;	O
}	O
}	O
else	O
end_addr	long
=	O
sec_size	long
;	O
if	O
(	O
!	O
pex64_get_unwind_info	function
(	O
abfd	pointer
,	O
&	O
ui	pointer
,	O
xdata	pointer
+	O
addr	pointer
,	O
xdata	pointer
+	O
end_addr	long
)	O
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"warning: xdata section corrupt\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ui	pointer
.	O
Version	array
!=	O
1	int
&&	O
ui	pointer
.	O
Version	array
!=	O
2	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
fprintf	function
(	O
file	pointer
,	O
"\tVersion %u (unknown).\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
ui	pointer
.	O
Version	array
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
addr	pointer
<	O
end_addr	long
;	O
addr	pointer
+=	O
1	int
,	O
i	pointer
++	O
)	O
{	O
if	O
(	O
(	O
i	pointer
&	O
15	int
)	O
==	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
"\t  %03x:"	pointer
,	O
i	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %02x"	pointer
,	O
xdata	pointer
[	O
addr	pointer
]	O
)	O
;	O
if	O
(	O
(	O
i	pointer
&	O
15	int
)	O
==	O
15	int
)	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
i	pointer
&	O
15	int
)	O
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"\tVersion: %d, Flags: "	pointer
,	O
ui	pointer
.	O
Version	array
)	O
;	O
switch	O
(	O
ui	pointer
.	O
Flags	array
)	O
{	O
case	O
UNW_FLAG_NHANDLER	int
:	O
fprintf	function
(	O
file	pointer
,	O
"none"	pointer
)	O
;	O
break	O
;	O
case	O
UNW_FLAG_EHANDLER	int
:	O
fprintf	function
(	O
file	pointer
,	O
"UNW_FLAG_EHANDLER"	pointer
)	O
;	O
break	O
;	O
case	O
UNW_FLAG_UHANDLER	int
:	O
fprintf	function
(	O
file	pointer
,	O
"UNW_FLAG_UHANDLER"	pointer
)	O
;	O
break	O
;	O
case	O
UNW_FLAG_FHANDLER	int
:	O
fprintf	function
(	O
file	pointer
,	O
"UNW_FLAG_EHANDLER | UNW_FLAG_UHANDLER"	pointer
)	O
;	O
break	O
;	O
case	O
UNW_FLAG_CHAININFO	int
:	O
fprintf	function
(	O
file	pointer
,	O
"UNW_FLAG_CHAININFO"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
file	pointer
,	O
"unknown flags value 0x%x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
ui	pointer
.	O
Flags	array
)	O
;	O
break	O
;	O
}	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\tNbr codes: %u, "	pointer
,	O
(	O
unsigned	O
int	O
)	O
ui	pointer
.	O
CountOfCodes	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"Prologue size: 0x%02x, Frame offset: 0x%x, "	pointer
,	O
(	O
unsigned	O
int	O
)	O
ui	pointer
.	O
SizeOfPrologue	long
,	O
(	O
unsigned	O
int	O
)	O
ui	pointer
.	O
FrameOffset	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"Frame reg: %s\n"	pointer
,	O
ui	pointer
.	O
FrameRegister	int
==	O
0	int
?	O
"none"	pointer
:	O
pex_regs	array
[	O
(	O
unsigned	O
int	O
)	O
ui	pointer
.	O
FrameRegister	int
]	O
)	O
;	O
if	O
(	O
ui	pointer
.	O
CountOfCodes	long
*	O
2	int
+	O
ui	pointer
.	O
rawUnwindCodes	pointer
>	O
xdata	pointer
+	O
xdata_section	pointer
->	O
size	long
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Too many unwind codes (%ld)\n"	pointer
)	O
,	O
(	O
long	O
)	O
ui	pointer
.	O
CountOfCodes	long
)	O
;	O
else	O
pex64_xdata_print_uwd_codes	function
(	O
file	pointer
,	O
abfd	pointer
,	O
&	O
ui	pointer
,	O
rf	pointer
)	O
;	O
switch	O
(	O
ui	pointer
.	O
Flags	array
)	O
{	O
case	O
UNW_FLAG_EHANDLER	int
:	O
case	O
UNW_FLAG_UHANDLER	int
:	O
case	O
UNW_FLAG_FHANDLER	int
:	O
fprintf	function
(	O
file	pointer
,	O
"\tHandler: "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
(	O
ui	pointer
.	O
rva_ExceptionHandler	long
+	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
".\n"	pointer
)	O
;	O
break	O
;	O
case	O
UNW_FLAG_CHAININFO	int
:	O
fprintf	function
(	O
file	pointer
,	O
"\tChain: start: "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
ui	pointer
.	O
rva_BeginAddress	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
", end: "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
ui	pointer
.	O
rva_EndAddress	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n\t unwind data: "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
ui	pointer
.	O
rva_UnwindData	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
".\n"	pointer
)	O
;	O
break	O
;	O
}	O
addr	pointer
+=	O
ui	pointer
.	O
SizeOfBlock	long
;	O
if	O
(	O
addr	pointer
<	O
end_addr	long
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
fprintf	function
(	O
file	pointer
,	O
"\tUser data:\n"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
addr	pointer
<	O
end_addr	long
;	O
addr	pointer
+=	O
1	int
,	O
i	pointer
++	O
)	O
{	O
if	O
(	O
(	O
i	pointer
&	O
15	int
)	O
==	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
"\t  %03x:"	pointer
,	O
i	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %02x"	pointer
,	O
xdata	pointer
[	O
addr	pointer
]	O
)	O
;	O
if	O
(	O
(	O
i	pointer
&	O
15	int
)	O
==	O
15	int
)	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
i	pointer
&	O
15	int
)	O
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
static	O
int	O
sort_xdata_arr	function
(	O
const	O
void	O
*	O
l	long
,	O
const	O
void	O
*	O
r	pointer
)	O
{	O
const	O
bfd_vma	long
*	O
lp	pointer
=	O
(	O
const	O
bfd_vma	long
*	O
)	O
l	long
;	O
const	O
bfd_vma	long
*	O
rp	pointer
=	O
(	O
const	O
bfd_vma	long
*	O
)	O
r	pointer
;	O
if	O
(	O
*	O
lp	pointer
==	O
*	O
rp	pointer
)	O
return	O
0	int
;	O
return	O
(	O
*	O
lp	pointer
<	O
*	O
rp	pointer
?	O
-	O
1	int
:	O
1	int
)	O
;	O
}	O
static	O
bfd_boolean	int
pex64_bfd_print_pdata_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
,	O
asection	struct
*	O
pdata_section	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
vfile	pointer
;	O
bfd_byte	char
*	O
pdata	pointer
=	O
NULL	O
;	O
bfd_byte	char
*	O
xdata	pointer
=	O
NULL	O
;	O
asection	struct
*	O
xdata_section	pointer
=	O
NULL	O
;	O
bfd_vma	long
xdata_base	long
;	O
bfd_size_type	long
i	pointer
;	O
bfd_size_type	long
datasize	long
;	O
bfd_size_type	long
stop	long
;	O
bfd_vma	long
prev_beginaddress	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
bfd_vma	long
prev_unwinddata_rva	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
bfd_vma	long
imagebase	long
;	O
int	O
onaline	int
=	O
PDATA_ROW_SIZE	O
;	O
int	O
seen_error	int
=	O
0	int
;	O
bfd_vma	long
*	O
xdata_arr	pointer
=	O
NULL	O
;	O
int	O
xdata_arr_cnt	int
;	O
bfd_boolean	int
virt_size_is_zero	int
=	O
FALSE	int
;	O
if	O
(	O
pdata_section	pointer
==	O
NULL	O
||	O
coff_section_data	O
(	O
abfd	pointer
,	O
pdata_section	pointer
)	O
==	O
NULL	O
||	O
pei_section_data	O
(	O
abfd	pointer
,	O
pdata_section	pointer
)	O
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
stop	long
=	O
pei_section_data	O
(	O
abfd	pointer
,	O
pdata_section	pointer
)	O
->	O
virt_size	long
;	O
if	O
(	O
(	O
stop	long
%	O
onaline	int
)	O
!=	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Warning: %s section size (%ld) is not a multiple of %d\n"	pointer
)	O
,	O
pdata_section	pointer
->	O
name	pointer
,	O
(	O
long	O
)	O
stop	long
,	O
onaline	int
)	O
;	O
datasize	long
=	O
pdata_section	pointer
->	O
size	long
;	O
if	O
(	O
datasize	long
==	O
0	int
)	O
{	O
if	O
(	O
stop	long
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Warning: %s section size is zero\n"	pointer
)	O
,	O
pdata_section	pointer
->	O
name	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
stop	long
==	O
0	int
&&	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"pe-x86-64"	pointer
)	O
==	O
0	int
)	O
{	O
stop	long
=	O
datasize	long
;	O
virt_size_is_zero	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
datasize	long
<	O
stop	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"Warning: %s section size (%ld) is smaller than virtual size (%ld)\n"	pointer
)	O
,	O
pdata_section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
datasize	long
,	O
(	O
unsigned	O
long	O
)	O
stop	long
)	O
;	O
stop	long
=	O
datasize	long
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nThe Function Table (interpreted %s section contents)\n"	pointer
)	O
,	O
pdata_section	pointer
->	O
name	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"vma:\t\t\tBeginAddress\t EndAddress\t  UnwindData\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
pdata_section	pointer
,	O
&	O
pdata	pointer
)	O
)	O
goto	O
done	O
;	O
xdata_arr	pointer
=	O
(	O
bfd_vma	long
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
bfd_vma	long
)	O
*	O
(	O
(	O
stop	long
/	O
onaline	int
)	O
+	O
1	int
)	O
)	O
;	O
xdata_arr_cnt	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"pei-x86-64"	pointer
)	O
==	O
0	int
)	O
imagebase	long
=	O
pe_data	O
(	O
abfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
else	O
imagebase	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
stop	long
;	O
i	pointer
+=	O
onaline	int
)	O
{	O
struct	O
pex64_runtime_function	struct
rf	pointer
;	O
if	O
(	O
i	pointer
+	O
PDATA_ROW_SIZE	O
>	O
stop	long
)	O
break	O
;	O
pex64_get_runtime_function	function
(	O
abfd	pointer
,	O
&	O
rf	pointer
,	O
&	O
pdata	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
rf	pointer
.	O
rva_BeginAddress	long
==	O
0	int
&&	O
rf	pointer
.	O
rva_EndAddress	long
==	O
0	int
&&	O
rf	pointer
.	O
rva_UnwindData	long
==	O
0	int
)	O
break	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
i	pointer
+	O
pdata_section	pointer
->	O
vma	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
":\t"	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
imagebase	long
+	O
rf	pointer
.	O
rva_BeginAddress	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
imagebase	long
+	O
rf	pointer
.	O
rva_EndAddress	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
imagebase	long
+	O
rf	pointer
.	O
rva_UnwindData	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
i	pointer
!=	O
0	int
&&	O
rf	pointer
.	O
rva_BeginAddress	long
<=	O
prev_beginaddress	long
)	O
{	O
seen_error	int
=	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
"  has %s begin address as predecessor\n"	pointer
,	O
(	O
rf	pointer
.	O
rva_BeginAddress	long
<	O
prev_beginaddress	long
?	O
"smaller"	pointer
:	O
"same"	pointer
)	O
)	O
;	O
}	O
prev_beginaddress	long
=	O
rf	pointer
.	O
rva_BeginAddress	long
;	O
if	O
(	O
(	O
prev_beginaddress	long
&	O
0x80000000	int
)	O
!=	O
0	int
)	O
{	O
seen_error	int
=	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
"  has negative begin address\n"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
rf	pointer
.	O
rva_EndAddress	long
&	O
0x80000000	int
)	O
!=	O
0	int
)	O
{	O
seen_error	int
=	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
"  has negative end address\n"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
rf	pointer
.	O
rva_UnwindData	long
&	O
0x80000000	int
)	O
!=	O
0	int
)	O
{	O
seen_error	int
=	O
1	int
;	O
fprintf	function
(	O
file	pointer
,	O
"  has negative unwind address\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
rf	pointer
.	O
rva_UnwindData	long
&&	O
!	O
PEX64_IS_RUNTIME_FUNCTION_CHAINED	O
(	O
&	O
rf	pointer
)	O
)	O
||	O
virt_size_is_zero	int
)	O
xdata_arr	pointer
[	O
xdata_arr_cnt	int
++	O
]	O
=	O
rf	pointer
.	O
rva_UnwindData	long
;	O
}	O
if	O
(	O
seen_error	int
)	O
goto	O
done	O
;	O
xdata_arr	pointer
[	O
xdata_arr_cnt	int
++	O
]	O
=	O
~	O
(	O
(	O
bfd_vma	long
)	O
0	int
)	O
;	O
if	O
(	O
xdata_arr_cnt	int
>	O
1	int
)	O
qsort	function
(	O
xdata_arr	pointer
,	O
(	O
size_t	long
)	O
xdata_arr_cnt	int
,	O
sizeof	O
(	O
bfd_vma	long
)	O
,	O
sort_xdata_arr	function
)	O
;	O
xdata_base	long
=	O
xdata_arr	pointer
[	O
0	int
]	O
;	O
if	O
(	O
strcmp	function
(	O
pdata_section	pointer
->	O
name	pointer
,	O
".pdata"	pointer
)	O
!=	O
0	int
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
pdata_section	pointer
->	O
name	pointer
)	O
;	O
char	O
*	O
xdata_name	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
xdata_name	pointer
=	O
memcpy	function
(	O
xdata_name	pointer
,	O
pdata_section	pointer
->	O
name	pointer
,	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
len	long
>	O
1	int
)	O
xdata_name	pointer
[	O
1	int
]	O
=	O
'x'	O
;	O
xdata_section	pointer
=	O
pex64_get_section_by_rva	function
(	O
abfd	pointer
,	O
xdata_base	long
,	O
xdata_name	pointer
)	O
;	O
free	function
(	O
xdata_name	pointer
)	O
;	O
}	O
if	O
(	O
!	O
xdata_section	pointer
)	O
xdata_section	pointer
=	O
pex64_get_section_by_rva	function
(	O
abfd	pointer
,	O
xdata_base	long
,	O
".xdata"	pointer
)	O
;	O
if	O
(	O
!	O
xdata_section	pointer
&&	O
xdata_base	long
)	O
xdata_section	pointer
=	O
pex64_get_section_by_rva	function
(	O
abfd	pointer
,	O
xdata_base	long
,	O
".rdata"	pointer
)	O
;	O
if	O
(	O
!	O
xdata_section	pointer
&&	O
xdata_base	long
)	O
xdata_section	pointer
=	O
pex64_get_section_by_rva	function
(	O
abfd	pointer
,	O
xdata_base	long
,	O
".data"	pointer
)	O
;	O
if	O
(	O
!	O
xdata_section	pointer
&&	O
xdata_base	long
)	O
xdata_section	pointer
=	O
pex64_get_section_by_rva	function
(	O
abfd	pointer
,	O
xdata_base	long
,	O
".pdata"	pointer
)	O
;	O
if	O
(	O
!	O
xdata_section	pointer
&&	O
xdata_base	long
)	O
xdata_section	pointer
=	O
pex64_get_section_by_rva	function
(	O
abfd	pointer
,	O
xdata_base	long
,	O
".text"	pointer
)	O
;	O
if	O
(	O
!	O
xdata_section	pointer
||	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
xdata_section	pointer
,	O
&	O
xdata	pointer
)	O
)	O
goto	O
done	O
;	O
prev_unwinddata_rva	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
stop	long
;	O
i	pointer
+=	O
onaline	int
)	O
{	O
struct	O
pex64_runtime_function	struct
rf	pointer
;	O
if	O
(	O
i	pointer
+	O
PDATA_ROW_SIZE	O
>	O
stop	long
)	O
break	O
;	O
pex64_get_runtime_function	function
(	O
abfd	pointer
,	O
&	O
rf	pointer
,	O
&	O
pdata	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
rf	pointer
.	O
rva_BeginAddress	long
==	O
0	int
&&	O
rf	pointer
.	O
rva_EndAddress	long
==	O
0	int
&&	O
rf	pointer
.	O
rva_UnwindData	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	pointer
==	O
0	int
)	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"\nDump of %s\n"	pointer
)	O
,	O
xdata_section	pointer
->	O
name	pointer
)	O
;	O
fputc	function
(	O
' '	O
,	O
file	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
rf	pointer
.	O
rva_UnwindData	long
+	O
imagebase	long
)	O
;	O
if	O
(	O
prev_unwinddata_rva	long
==	O
rf	pointer
.	O
rva_UnwindData	long
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
" also used for function at "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
rf	pointer
.	O
rva_BeginAddress	long
+	O
imagebase	long
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
prev_unwinddata_rva	long
=	O
rf	pointer
.	O
rva_UnwindData	long
;	O
fprintf	function
(	O
file	pointer
,	O
" (rva: %08x): "	pointer
,	O
(	O
unsigned	O
int	O
)	O
rf	pointer
.	O
rva_UnwindData	long
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
rf	pointer
.	O
rva_BeginAddress	long
+	O
imagebase	long
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" - "	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
rf	pointer
.	O
rva_EndAddress	long
+	O
imagebase	long
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
if	O
(	O
rf	pointer
.	O
rva_UnwindData	long
!=	O
0	int
||	O
virt_size_is_zero	int
)	O
{	O
if	O
(	O
PEX64_IS_RUNTIME_FUNCTION_CHAINED	O
(	O
&	O
rf	pointer
)	O
)	O
{	O
bfd_vma	long
altent	long
=	O
PEX64_GET_UNWINDDATA_UNIFIED_RVA	O
(	O
&	O
rf	pointer
)	O
;	O
bfd_vma	long
pdata_vma	long
=	O
bfd_section_vma	function
(	O
pdata_section	pointer
)	O
;	O
struct	O
pex64_runtime_function	struct
arf	struct
;	O
fprintf	function
(	O
file	pointer
,	O
"\t shares information with "	pointer
)	O
;	O
altent	long
+=	O
imagebase	long
;	O
if	O
(	O
altent	long
>=	O
pdata_vma	long
&&	O
altent	long
-	O
pdata_vma	long
+	O
PDATA_ROW_SIZE	O
<=	O
stop	long
)	O
{	O
pex64_get_runtime_function	function
(	O
abfd	pointer
,	O
&	O
arf	struct
,	O
&	O
pdata	pointer
[	O
altent	long
-	O
pdata_vma	long
]	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"pdata element at 0x"	pointer
)	O
;	O
fprintf_vma	O
(	O
file	pointer
,	O
arf	struct
.	O
rva_UnwindData	long
)	O
;	O
}	O
else	O
fprintf	function
(	O
file	pointer
,	O
"unknown pdata element"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
".\n"	pointer
)	O
;	O
}	O
else	O
{	O
bfd_vma	long
*	O
p	pointer
;	O
p	pointer
=	O
(	O
bfd_vma	long
*	O
)	O
bsearch	function
(	O
&	O
rf	pointer
.	O
rva_UnwindData	long
,	O
xdata_arr	pointer
,	O
(	O
size_t	long
)	O
xdata_arr_cnt	int
,	O
sizeof	O
(	O
bfd_vma	long
)	O
,	O
sort_xdata_arr	function
)	O
;	O
while	O
(	O
p	pointer
[	O
0	int
]	O
<=	O
rf	pointer
.	O
rva_UnwindData	long
)	O
++	O
p	pointer
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
~	O
(	O
(	O
bfd_vma	long
)	O
0	int
)	O
)	O
p	pointer
=	O
NULL	O
;	O
pex64_dump_xdata	function
(	O
file	pointer
,	O
abfd	pointer
,	O
xdata_section	pointer
,	O
xdata	pointer
,	O
p	pointer
,	O
&	O
rf	pointer
)	O
;	O
}	O
}	O
}	O
done	O
:	O
free	function
(	O
pdata	pointer
)	O
;	O
free	function
(	O
xdata_arr	pointer
)	O
;	O
free	function
(	O
xdata	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pdata_count	int
;	O
bfd_boolean	int
pex64_bfd_print_pdata	function
(	O
bfd	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
pex64_print_all_pdata_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
pdata	pointer
,	O
void	O
*	O
obj	pointer
)	O
{	O
if	O
(	O
CONST_STRNEQ	O
(	O
pdata	pointer
->	O
name	pointer
,	O
".pdata"	pointer
)	O
)	O
{	O
if	O
(	O
pex64_bfd_print_pdata_section	function
(	O
abfd	pointer
,	O
obj	pointer
,	O
pdata	pointer
)	O
)	O
pdata_count	int
++	O
;	O
}	O
}	O
bfd_boolean	int
pex64_bfd_print_pdata	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
vfile	pointer
)	O
{	O
asection	struct
*	O
pdata_section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".pdata"	pointer
)	O
;	O
if	O
(	O
pdata_section	pointer
)	O
return	O
pex64_bfd_print_pdata_section	function
(	O
abfd	pointer
,	O
vfile	pointer
,	O
pdata_section	pointer
)	O
;	O
pdata_count	int
=	O
0	int
;	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
pex64_print_all_pdata_sections	function
,	O
vfile	pointer
)	O
;	O
return	O
(	O
pdata_count	int
>	O
0	int
)	O
;	O
}	O