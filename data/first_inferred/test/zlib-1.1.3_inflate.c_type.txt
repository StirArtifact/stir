struct	O
inflate_blocks_state	struct
{	O
int	O
dummy	int
;	O
}	O
;	O
typedef	O
enum	O
{	O
METHOD	int
,	O
FLAG	int
,	O
DICT4	int
,	O
DICT3	int
,	O
DICT2	int
,	O
DICT1	int
,	O
DICT0	int
,	O
BLOCKS	int
,	O
CHECK4	int
,	O
CHECK3	int
,	O
CHECK2	int
,	O
CHECK1	int
,	O
DONE	int
,	O
BAD	int
}	O
inflate_mode	enum
;	O
struct	O
internal_state	struct
{	O
inflate_mode	enum
mode	pointer
;	O
union	O
{	O
uInt	int
method	int
;	O
struct	O
{	O
uLong	long
was	long
;	O
uLong	long
need	long
;	O
}	O
check	long
;	O
uInt	int
marker	int
;	O
}	O
sub	union
;	O
int	O
nowrap	int
;	O
uInt	int
wbits	int
;	O
inflate_blocks_statef	struct
*	O
blocks	pointer
;	O
}	O
;	O
int	O
ZEXPORT	O
inflateReset	function
(	O
z	pointer
)	O
z_streamp	pointer
z	pointer
;	O
{	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
z	pointer
->	O
total_in	long
=	O
z	pointer
->	O
total_out	long
=	O
0	int
;	O
z	pointer
->	O
msg	pointer
=	O
Z_NULL	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
z	pointer
->	O
state	pointer
->	O
nowrap	int
?	O
BLOCKS	int
:	O
METHOD	int
;	O
inflate_blocks_reset	function
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
,	O
z	pointer
,	O
Z_NULL	int
)	O
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: reset\n"	pointer
)	O
)	O
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateEnd	function
(	O
z	pointer
)	O
z_streamp	pointer
z	pointer
;	O
{	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
zfree	pointer
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
if	O
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
!=	O
Z_NULL	int
)	O
inflate_blocks_free	function
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
,	O
z	pointer
)	O
;	O
ZFREE	O
(	O
z	pointer
,	O
z	pointer
->	O
state	pointer
)	O
;	O
z	pointer
->	O
state	pointer
=	O
Z_NULL	int
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: end\n"	pointer
)	O
)	O
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateInit2_	function
(	O
z	pointer
,	O
w	int
,	O
version	pointer
,	O
stream_size	int
)	O
z_streamp	pointer
z	pointer
;	O
int	O
w	int
;	O
const	O
char	O
*	O
version	pointer
;	O
int	O
stream_size	int
;	O
{	O
if	O
(	O
version	pointer
==	O
Z_NULL	int
||	O
version	pointer
[	O
0	int
]	O
!=	O
ZLIB_VERSION	pointer
[	O
0	int
]	O
||	O
stream_size	int
!=	O
sizeof	O
(	O
z_stream	struct
)	O
)	O
return	O
Z_VERSION_ERROR	O
;	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
z	pointer
->	O
msg	pointer
=	O
Z_NULL	int
;	O
if	O
(	O
z	pointer
->	O
zalloc	pointer
==	O
Z_NULL	int
)	O
{	O
z	pointer
->	O
zalloc	pointer
=	O
zcalloc	function
;	O
z	pointer
->	O
opaque	pointer
=	O
(	O
voidpf	pointer
)	O
0	int
;	O
}	O
if	O
(	O
z	pointer
->	O
zfree	pointer
==	O
Z_NULL	int
)	O
z	pointer
->	O
zfree	pointer
=	O
zcfree	function
;	O
if	O
(	O
(	O
z	pointer
->	O
state	pointer
=	O
(	O
struct	O
internal_state	struct
FAR	O
*	O
)	O
ZALLOC	O
(	O
z	pointer
,	O
1	int
,	O
sizeof	O
(	O
struct	O
internal_state	struct
)	O
)	O
)	O
==	O
Z_NULL	int
)	O
return	O
Z_MEM_ERROR	O
;	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
=	O
Z_NULL	int
;	O
z	pointer
->	O
state	pointer
->	O
nowrap	int
=	O
0	int
;	O
if	O
(	O
w	int
<	O
0	int
)	O
{	O
w	int
=	O
-	O
w	int
;	O
z	pointer
->	O
state	pointer
->	O
nowrap	int
=	O
1	int
;	O
}	O
if	O
(	O
w	int
<	O
8	int
||	O
w	int
>	O
15	int
)	O
{	O
inflateEnd	function
(	O
z	pointer
)	O
;	O
return	O
Z_STREAM_ERROR	O
;	O
}	O
z	pointer
->	O
state	pointer
->	O
wbits	int
=	O
(	O
uInt	int
)	O
w	int
;	O
if	O
(	O
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
=	O
inflate_blocks_new	function
(	O
z	pointer
,	O
z	pointer
->	O
state	pointer
->	O
nowrap	int
?	O
Z_NULL	int
:	O
adler32	function
,	O
(	O
uInt	int
)	O
1	int
<<	O
w	int
)	O
)	O
==	O
Z_NULL	int
)	O
{	O
inflateEnd	function
(	O
z	pointer
)	O
;	O
return	O
Z_MEM_ERROR	O
;	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: allocated\n"	pointer
)	O
)	O
;	O
inflateReset	function
(	O
z	pointer
)	O
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateInit_	function
(	O
z	pointer
,	O
version	pointer
,	O
stream_size	int
)	O
z_streamp	pointer
z	pointer
;	O
const	O
char	O
*	O
version	pointer
;	O
int	O
stream_size	int
;	O
{	O
return	O
inflateInit2_	function
(	O
z	pointer
,	O
DEF_WBITS	O
,	O
version	pointer
,	O
stream_size	int
)	O
;	O
}	O
int	O
ZEXPORT	O
inflate	function
(	O
z	pointer
,	O
f	int
)	O
z_streamp	pointer
z	pointer
;	O
int	O
f	int
;	O
{	O
int	O
r	int
;	O
uInt	int
b	int
;	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
next_in	pointer
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
f	int
=	O
f	int
==	O
Z_FINISH	int
?	O
Z_BUF_ERROR	O
:	O
Z_OK	int
;	O
r	int
=	O
Z_BUF_ERROR	O
;	O
while	O
(	O
1	int
)	O
switch	O
(	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
)	O
{	O
case	O
METHOD	int
:	O
NEEDBYTE	O
if	O
(	O
(	O
(	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
method	int
=	O
NEXTBYTE	O
)	O
&	O
0xf	int
)	O
!=	O
Z_DEFLATED	int
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
"unknown compression method"	pointer
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
method	int
>>	O
4	int
)	O
+	O
8	int
>	O
z	pointer
->	O
state	pointer
->	O
wbits	int
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
"invalid window size"	pointer
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
FLAG	int
;	O
case	O
FLAG	int
:	O
NEEDBYTE	O
b	int
=	O
NEXTBYTE	O
;	O
if	O
(	O
(	O
(	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
method	int
<<	O
8	int
)	O
+	O
b	int
)	O
%	O
31	int
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
"incorrect header check"	pointer
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: zlib header ok\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
b	int
&	O
PRESET_DICT	int
)	O
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BLOCKS	int
;	O
break	O
;	O
}	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DICT4	int
;	O
case	O
DICT4	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
24	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DICT3	int
;	O
case	O
DICT3	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
16	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DICT2	int
;	O
case	O
DICT2	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
8	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DICT1	int
;	O
case	O
DICT1	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
;	O
z	pointer
->	O
adler	long
=	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DICT0	int
;	O
return	O
Z_NEED_DICT	int
;	O
case	O
DICT0	int
:	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
"need dictionary"	pointer
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
0	int
;	O
return	O
Z_STREAM_ERROR	O
;	O
case	O
BLOCKS	int
:	O
r	int
=	O
inflate_blocks	function
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
,	O
z	pointer
,	O
r	int
)	O
;	O
if	O
(	O
r	int
==	O
Z_DATA_ERROR	O
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
r	int
==	O
Z_OK	int
)	O
r	int
=	O
f	int
;	O
if	O
(	O
r	int
!=	O
Z_STREAM_END	int
)	O
return	O
r	int
;	O
r	int
=	O
f	int
;	O
inflate_blocks_reset	function
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
,	O
z	pointer
,	O
&	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
was	long
)	O
;	O
if	O
(	O
z	pointer
->	O
state	pointer
->	O
nowrap	int
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DONE	int
;	O
break	O
;	O
}	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
CHECK4	int
;	O
case	O
CHECK4	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
24	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
CHECK3	int
;	O
case	O
CHECK3	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
16	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
CHECK2	int
;	O
case	O
CHECK2	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
8	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
CHECK1	int
;	O
case	O
CHECK1	int
:	O
NEEDBYTE	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
;	O
if	O
(	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
was	long
!=	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
check	long
.	O
need	long
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
"incorrect data check"	pointer
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: zlib check ok\n"	pointer
)	O
)	O
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
DONE	int
;	O
case	O
DONE	int
:	O
return	O
Z_STREAM_END	int
;	O
case	O
BAD	int
:	O
return	O
Z_DATA_ERROR	O
;	O
default	O
:	O
return	O
Z_STREAM_ERROR	O
;	O
}	O
}	O
int	O
ZEXPORT	O
inflateSetDictionary	function
(	O
z	pointer
,	O
dictionary	pointer
,	O
dictLength	int
)	O
z_streamp	pointer
z	pointer
;	O
const	O
Bytef	char
*	O
dictionary	pointer
;	O
uInt	int
dictLength	int
;	O
{	O
uInt	int
length	int
=	O
dictLength	int
;	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
!=	O
DICT0	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
if	O
(	O
adler32	function
(	O
1L	int
,	O
dictionary	pointer
,	O
dictLength	int
)	O
!=	O
z	pointer
->	O
adler	long
)	O
return	O
Z_DATA_ERROR	O
;	O
z	pointer
->	O
adler	long
=	O
1L	int
;	O
if	O
(	O
length	int
>=	O
(	O
(	O
uInt	int
)	O
1	int
<<	O
z	pointer
->	O
state	pointer
->	O
wbits	int
)	O
)	O
{	O
length	int
=	O
(	O
1	int
<<	O
z	pointer
->	O
state	pointer
->	O
wbits	int
)	O
-	O
1	int
;	O
dictionary	pointer
+=	O
dictLength	int
-	O
length	int
;	O
}	O
inflate_set_dictionary	function
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
,	O
dictionary	pointer
,	O
length	int
)	O
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BLOCKS	int
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateSync	function
(	O
z	pointer
)	O
z_streamp	pointer
z	pointer
;	O
{	O
uInt	int
n	int
;	O
Bytef	char
*	O
p	pointer
;	O
uInt	int
m	int
;	O
uLong	long
r	int
,	O
w	int
;	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
if	O
(	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
!=	O
BAD	int
)	O
{	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BAD	int
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
n	int
=	O
z	pointer
->	O
avail_in	int
)	O
==	O
0	int
)	O
return	O
Z_BUF_ERROR	O
;	O
p	pointer
=	O
z	pointer
->	O
next_in	pointer
;	O
m	int
=	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
;	O
while	O
(	O
n	int
&&	O
m	int
<	O
4	int
)	O
{	O
static	O
const	O
Byte	char
mark	array
[	O
4	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0xff	int
}	O
;	O
if	O
(	O
*	O
p	pointer
==	O
mark	array
[	O
m	int
]	O
)	O
m	int
++	O
;	O
else	O
if	O
(	O
*	O
p	pointer
)	O
m	int
=	O
0	int
;	O
else	O
m	int
=	O
4	int
-	O
m	int
;	O
p	pointer
++	O
,	O
n	int
--	O
;	O
}	O
z	pointer
->	O
total_in	long
+=	O
p	pointer
-	O
z	pointer
->	O
next_in	pointer
;	O
z	pointer
->	O
next_in	pointer
=	O
p	pointer
;	O
z	pointer
->	O
avail_in	int
=	O
n	int
;	O
z	pointer
->	O
state	pointer
->	O
sub	union
.	O
marker	int
=	O
m	int
;	O
if	O
(	O
m	int
!=	O
4	int
)	O
return	O
Z_DATA_ERROR	O
;	O
r	int
=	O
z	pointer
->	O
total_in	long
;	O
w	int
=	O
z	pointer
->	O
total_out	long
;	O
inflateReset	function
(	O
z	pointer
)	O
;	O
z	pointer
->	O
total_in	long
=	O
r	int
;	O
z	pointer
->	O
total_out	long
=	O
w	int
;	O
z	pointer
->	O
state	pointer
->	O
mode	pointer
=	O
BLOCKS	int
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateSyncPoint	function
(	O
z	pointer
)	O
z_streamp	pointer
z	pointer
;	O
{	O
if	O
(	O
z	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
==	O
Z_NULL	int
||	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
return	O
inflate_blocks_sync_point	function
(	O
z	pointer
->	O
state	pointer
->	O
blocks	pointer
)	O
;	O
}	O