static	O
int	O
GetFPolyYBounds	function
(	O
const	O
SppPoint	struct
*	O
pts	array
,	O
int	O
n	int
,	O
double	O
yFtrans	double
,	O
int	O
*	O
by	*
,	O
int	O
*	O
ty	*
)	O
;	O
void	O
miFillSppPoly	O
(	O
miPaintedSet	struct
*	O
paintedSet	*
,	O
miPixel	int
pixel	int
,	O
int	O
count	int
,	O
const	O
SppPoint	struct
*	O
ptsIn	*
,	O
int	O
xTrans	int
,	O
int	O
yTrans	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
{	O
double	O
xl	double
=	O
0.0	int
,	O
xr	double
=	O
0.0	int
,	O
ml	double
=	O
0.0	int
,	O
mr	double
=	O
0.0	int
,	O
dy	int
,	O
i	int
;	O
int	O
y	int
,	O
j	int
,	O
imin	int
,	O
ymin	int
,	O
ymax	int
;	O
int	O
left	int
,	O
right	int
,	O
nextleft	int
,	O
nextright	int
;	O
int	O
*	O
Marked	*
;	O
unsigned	O
int	O
*	O
width	int
,	O
*	O
FirstWidth	*
;	O
miPoint	struct
*	O
ptsOut	*
,	O
*	O
FirstPoint	*
;	O
imin	int
=	O
GetFPolyYBounds	function
(	O
ptsIn	*
,	O
count	int
,	O
yFtrans	double
,	O
&	O
ymin	int
,	O
&	O
ymax	int
)	O
;	O
y	int
=	O
ymax	double
-	O
ymin	int
+	O
1	int
;	O
if	O
(	O
(	O
count	int
<	O
3	int
)	O
||	O
(	O
y	int
<=	O
0	int
)	O
)	O
return	O
;	O
ptsOut	*
=	O
FirstPoint	*
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
y	double
)	O
;	O
width	array
=	O
FirstWidth	*
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
y	double
)	O
;	O
Marked	*
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
int	O
)	O
*	O
count	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
count	int
;	O
j	int
++	O
)	O
Marked	*
[	O
j	int
]	O
=	O
0	int
;	O
nextleft	int
=	O
nextright	int
=	O
imin	int
;	O
Marked	*
[	O
imin	int
]	O
=	O
-	O
1	int
;	O
y	int
=	O
ICEIL	O
(	O
ptsIn	*
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
;	O
do	O
{	O
if	O
(	O
(	O
y	int
>	O
(	O
ptsIn	*
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
||	O
ISEQUAL	O
(	O
y	int
,	O
ptsIn	*
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
)	O
&&	O
Marked	*
[	O
nextleft	int
]	O
!=	O
1	int
)	O
{	O
Marked	*
[	O
nextleft	int
]	O
++	O
;	O
left	int
=	O
nextleft	int
++	O
;	O
if	O
(	O
nextleft	int
>=	O
count	int
)	O
nextleft	int
=	O
0	int
;	O
dy	int
=	O
ptsIn	*
[	O
nextleft	int
]	O
.	O
y	int
-	O
ptsIn	*
[	O
left	int
]	O
.	O
y	int
;	O
if	O
(	O
dy	double
!=	O
0.0	int
)	O
{	O
ml	int
=	O
(	O
ptsIn	*
[	O
nextleft	int
]	O
.	O
x	int
-	O
ptsIn	*
[	O
left	int
]	O
.	O
x	int
)	O
/	O
dy	int
;	O
dy	int
=	O
y	int
-	O
(	O
ptsIn	*
[	O
left	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
;	O
xl	int
=	O
(	O
ptsIn	*
[	O
left	int
]	O
.	O
x	int
+	O
xFtrans	int
)	O
+	O
ml	int
*	O
DMAX	O
(	O
dy	int
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
y	int
>	O
ptsIn	*
[	O
nextright	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
||	O
(	O
ISEQUAL	O
(	O
y	int
,	O
ptsIn	*
[	O
nextright	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
&&	O
Marked	*
[	O
nextright	int
]	O
!=	O
1	int
)	O
)	O
{	O
Marked	*
[	O
nextright	int
]	O
++	O
;	O
right	int
=	O
nextright	int
--	O
;	O
if	O
(	O
nextright	int
<	O
0	int
)	O
nextright	int
=	O
count	int
-	O
1	int
;	O
dy	int
=	O
ptsIn	*
[	O
nextright	int
]	O
.	O
y	int
-	O
ptsIn	*
[	O
right	int
]	O
.	O
y	int
;	O
if	O
(	O
dy	double
!=	O
0.0	int
)	O
{	O
mr	int
=	O
(	O
ptsIn	*
[	O
nextright	int
]	O
.	O
x	int
-	O
ptsIn	*
[	O
right	int
]	O
.	O
x	int
)	O
/	O
dy	int
;	O
dy	int
=	O
y	int
-	O
(	O
ptsIn	*
[	O
right	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
;	O
xr	int
=	O
(	O
ptsIn	*
[	O
right	int
]	O
.	O
x	int
+	O
xFtrans	int
)	O
+	O
mr	double
*	O
DMAX	O
(	O
dy	int
,	O
0	int
)	O
;	O
}	O
}	O
i	int
=	O
(	O
DMIN	O
(	O
ptsIn	*
[	O
nextleft	int
]	O
.	O
y	int
,	O
ptsIn	*
[	O
nextright	int
]	O
.	O
y	int
)	O
+	O
yFtrans	double
)	O
-	O
y	int
;	O
if	O
(	O
i	int
<	O
EPSILON	int
)	O
{	O
if	O
(	O
Marked	*
[	O
nextleft	int
]	O
&&	O
Marked	*
[	O
nextright	int
]	O
)	O
{	O
break	O
;	O
}	O
continue	O
;	O
}	O
else	O
{	O
j	int
=	O
(	O
int	O
)	O
i	int
;	O
if	O
(	O
!	O
j	int
)	O
j	int
++	O
;	O
}	O
while	O
(	O
j	int
>	O
0	int
)	O
{	O
int	O
cxl	int
,	O
cxr	int
;	O
ptsOut	*
->	O
y	int
=	O
(	O
y	int
)	O
+	O
yTrans	int
;	O
cxl	int
=	O
ICEIL	O
(	O
xl	int
)	O
;	O
cxr	int
=	O
ICEIL	O
(	O
xr	int
)	O
;	O
if	O
(	O
xl	int
<	O
xr	int
)	O
{	O
*	O
(	O
width	int
++	O
)	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
cxr	int
-	O
cxl	int
)	O
;	O
(	O
ptsOut	*
++	O
)	O
->	O
x	int
=	O
cxl	int
+	O
xTrans	int
;	O
}	O
else	O
{	O
*	O
(	O
width	int
++	O
)	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
cxl	int
-	O
cxr	int
)	O
;	O
(	O
ptsOut	*
++	O
)	O
->	O
x	int
=	O
cxr	int
+	O
xTrans	int
;	O
}	O
y	int
++	O
;	O
xl	int
+=	O
ml	int
;	O
xr	double
+=	O
mr	int
;	O
j	int
--	O
;	O
}	O
}	O
while	O
(	O
y	int
<=	O
ymax	int
)	O
;	O
free	function
(	O
Marked	*
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	*
,	O
pixel	int
,	O
ptsOut	*
-	O
FirstPoint	*
,	O
FirstPoint	*
,	O
FirstWidth	*
)	O
}	O
static	O
int	O
GetFPolyYBounds	function
(	O
const	O
SppPoint	struct
*	O
pts	array
,	O
int	O
n	int
,	O
double	O
yFtrans	double
,	O
int	O
*	O
by	*
,	O
int	O
*	O
ty	*
)	O
{	O
const	O
SppPoint	struct
*	O
ptsStart	*
=	O
pts	array
;	O
const	O
SppPoint	struct
*	O
ptMin	*
;	O
double	O
ymin	int
,	O
ymax	int
;	O
ptMin	*
=	O
pts	array
;	O
ymin	int
=	O
ymax	int
=	O
(	O
pts	array
++	O
)	O
->	O
y	int
;	O
while	O
(	O
--	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
pts	array
->	O
y	int
<	O
ymin	int
)	O
{	O
ptMin	*
=	O
pts	array
;	O
ymin	int
=	O
pts	array
->	O
y	int
;	O
}	O
if	O
(	O
pts	array
->	O
y	int
>	O
ymax	int
)	O
ymax	int
=	O
pts	array
->	O
y	int
;	O
pts	array
++	O
;	O
}	O
*	O
by	*
=	O
ICEIL	O
(	O
ymin	int
+	O
yFtrans	double
)	O
;	O
*	O
ty	*
=	O
ICEIL	O
(	O
ymax	int
+	O
yFtrans	double
-	O
1	int
)	O
;	O
return	O
(	O
ptMin	*
-	O
ptsStart	*
)	O
;	O
}	O