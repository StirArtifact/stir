extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
int	O
real_uid	int
,	O
real_gid	int
,	O
eff_uid	int
,	O
eff_gid	int
;	O
extern	O
struct	O
term	struct
term	struct
[	O
]	O
;	O
extern	O
struct	O
NewWindow	struct
nwin_undef	struct
,	O
nwin_default	struct
,	O
nwin_options	struct
;	O
extern	O
int	O
force_vt	int
;	O
extern	O
int	O
hardstatusemu	int
;	O
extern	O
char	O
*	O
kmapdef	array
[	O
]	O
;	O
extern	O
struct	O
action	struct
umtab	array
[	O
]	O
;	O
extern	O
struct	O
action	struct
mmtab	array
[	O
]	O
;	O
extern	O
struct	O
action	struct
dmtab	array
[	O
]	O
;	O
extern	O
struct	O
action	struct
ktab	array
[	O
]	O
;	O
extern	O
struct	O
kmap_ext	struct
*	O
kmap_exts	pointer
;	O
extern	O
int	O
kmap_extn	int
;	O
extern	O
int	O
DefaultEsc	int
;	O
static	O
void	O
AddCap	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
MakeString	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
findcap	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
copyarg	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
e_tgetent	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
e_tgetstr	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
int	O
e_tgetflag	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
e_tgetnum	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
findseq_ge	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
unsigned	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
void	O
setseqoff	function
__P	O
(	O
(	O
unsigned	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
addmapseq	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
remmapseq	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
char	O
Termcap	array
[	O
TERMCAP_BUFSIZE	int
+	O
8	int
]	O
;	O
static	O
int	O
Termcaplen	int
;	O
static	O
int	O
tcLineLen	int
;	O
char	O
Term	array
[	O
MAXSTR	int
+	O
5	int
]	O
;	O
char	O
screenterm	array
[	O
MAXTERMLEN	int
+	O
1	int
]	O
;	O
char	O
*	O
extra_incap	pointer
,	O
*	O
extra_outcap	pointer
;	O
static	O
const	O
char	O
TermcapConst	array
[	O
]	O
=	O
"DO=\\E[%dB:LE=\\E[%dD:RI=\\E[%dC:UP=\\E[%dA:bs:bt=\\E[Z:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:cm=\\E[%i%d;%dH:ct=\\E[3g:do=^J:nd=\\E[C:pt:rc=\\E8:rs=\\Ec:sc=\\E7:st=\\EH:up=\\EM:le=^H:bl=^G:cr=^M:it#8:ho=\\E[H:nw=\\EE:ta=^I:is=\\E)0:"	pointer
;	O
char	O
*	O
gettermcapstring	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
int	O
i	int
;	O
if	O
(	O
display	struct
==	O
0	int
||	O
s	pointer
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
T_N	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
term	struct
[	O
i	int
]	O
.	O
type	int
!=	O
T_STR	int
)	O
continue	O
;	O
if	O
(	O
strcmp	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
,	O
s	pointer
)	O
==	O
0	int
)	O
return	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
;	O
}	O
return	O
0	int
;	O
}	O
int	O
InitTermcap	function
(	O
wi	int
,	O
he	int
)	O
int	O
wi	int
;	O
int	O
he	int
;	O
{	O
register	O
char	O
*	O
s	pointer
;	O
int	O
i	int
;	O
char	O
tbuf	array
[	O
TERMCAP_BUFSIZE	int
]	O
,	O
*	O
tp	pointer
;	O
int	O
t	int
,	O
xue	int
,	O
xse	int
,	O
xme	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
bzero	function
(	O
tbuf	array
,	O
sizeof	O
(	O
tbuf	array
)	O
)	O
;	O
debug1	O
(	O
"InitTermcap: looking for tgetent('%s')\n"	pointer
,	O
D_termname	O
)	O
;	O
if	O
(	O
*	O
D_termname	O
==	O
0	int
||	O
e_tgetent	function
(	O
tbuf	array
,	O
D_termname	O
)	O
!=	O
1	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Cannot find terminfo entry for '%s'."	pointer
,	O
D_termname	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
debug1	O
(	O
"got it:\n%s\n"	pointer
,	O
tbuf	array
)	O
;	O
if	O
(	O
(	O
D_tentry	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
TERMCAP_BUFSIZE	int
+	O
(	O
extra_incap	pointer
?	O
strlen	function
(	O
extra_incap	pointer
)	O
+	O
1	int
:	O
0	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
tp	pointer
=	O
D_tentry	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
T_N	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
term	struct
[	O
i	int
]	O
.	O
type	int
)	O
{	O
case	O
T_FLG	int
:	O
D_tcs	O
[	O
i	int
]	O
.	O
flg	int
=	O
e_tgetflag	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
)	O
;	O
break	O
;	O
case	O
T_NUM	int
:	O
D_tcs	O
[	O
i	int
]	O
.	O
num	int
=	O
e_tgetnum	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
)	O
;	O
break	O
;	O
case	O
T_STR	int
:	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
=	O
e_tgetstr	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
,	O
&	O
tp	pointer
)	O
;	O
if	O
(	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
&&	O
*	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
==	O
0	int
)	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
=	O
0	int
;	O
break	O
;	O
default	O
:	O
Panic	function
(	O
0	int
,	O
"Illegal tc type in entry #%d"	pointer
,	O
i	int
)	O
;	O
}	O
}	O
if	O
(	O
D_HC	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"You can't run screen on a hardcopy terminal."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
D_OS	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"You can't run screen on a terminal that overstrikes."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
D_CL	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"Clear screen capability required."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
D_CM	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"Addressable cursor capability required."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
s	pointer
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
)	O
&&	O
(	O
i	int
=	O
atoi	function
(	O
s	pointer
)	O
)	O
>	O
0	int
)	O
D_CO	O
=	O
i	int
;	O
if	O
(	O
(	O
s	pointer
=	O
getenv	function
(	O
"LINES"	pointer
)	O
)	O
&&	O
(	O
i	int
=	O
atoi	function
(	O
s	pointer
)	O
)	O
>	O
0	int
)	O
D_LI	O
=	O
i	int
;	O
if	O
(	O
wi	int
)	O
D_CO	O
=	O
wi	int
;	O
if	O
(	O
he	int
)	O
D_LI	O
=	O
he	int
;	O
if	O
(	O
D_CO	O
<=	O
0	int
)	O
D_CO	O
=	O
80	int
;	O
if	O
(	O
D_LI	O
<=	O
0	int
)	O
D_LI	O
=	O
24	int
;	O
if	O
(	O
D_CTF	O
)	O
{	O
if	O
(	O
!	O
D_CAF	O
&&	O
D_ME	O
&&	O
(	O
InStr	function
(	O
D_ME	O
,	O
"\033[m"	pointer
)	O
||	O
InStr	function
(	O
D_ME	O
,	O
"\033[0m"	pointer
)	O
)	O
)	O
{	O
D_CAF	O
=	O
"\033[3%p1%dm"	pointer
;	O
D_CAB	O
=	O
"\033[4%p1%dm"	pointer
;	O
}	O
if	O
(	O
D_OP	O
&&	O
InStr	function
(	O
D_OP	O
,	O
"\033[39;49m"	pointer
)	O
)	O
D_CAX	O
=	O
1	int
;	O
if	O
(	O
D_OP	O
&&	O
(	O
InStr	function
(	O
D_OP	O
,	O
"\033[m"	pointer
)	O
||	O
InStr	function
(	O
D_OP	O
,	O
"\033[0m"	pointer
)	O
)	O
)	O
D_OP	O
=	O
0	int
;	O
if	O
(	O
(	O
D_EA	O
&&	O
InStr	function
(	O
D_EA	O
,	O
"\033(B"	pointer
)	O
)	O
||	O
(	O
D_AS	O
&&	O
InStr	function
(	O
D_AS	O
,	O
"\033(0"	pointer
)	O
)	O
)	O
D_CG0	O
=	O
1	int
;	O
if	O
(	O
InStr	function
(	O
D_termname	O
,	O
"xterm"	pointer
)	O
||	O
InStr	function
(	O
D_termname	O
,	O
"rxvt"	pointer
)	O
||	O
(	O
D_CKM	O
&&	O
(	O
InStr	function
(	O
D_CKM	O
,	O
"\033[M"	pointer
)	O
||	O
InStr	function
(	O
D_CKM	O
,	O
"\033[<"	pointer
)	O
)	O
)	O
)	O
{	O
D_CXT	O
=	O
1	int
;	O
kmapdef	array
[	O
0	int
]	O
=	O
D_CKM	O
?	O
SaveStr	function
(	O
D_CKM	O
)	O
:	O
NULL	O
;	O
}	O
if	O
(	O
D_CXT	O
)	O
D_BE	O
=	O
1	int
;	O
}	O
if	O
(	O
nwin_options	struct
.	O
flowflag	int
==	O
nwin_undef	struct
.	O
flowflag	int
)	O
nwin_default	struct
.	O
flowflag	int
=	O
D_CNF	O
?	O
FLOW_NOW	O
*	O
0	int
:	O
D_NX	O
?	O
FLOW_NOW	O
*	O
1	int
:	O
FLOW_AUTOFLAG	O
;	O
D_CLP	O
|=	O
(	O
!	O
D_AM	O
||	O
D_XV	O
||	O
D_XN	O
)	O
;	O
if	O
(	O
!	O
D_BL	O
)	O
D_BL	O
=	O
"\007"	pointer
;	O
if	O
(	O
!	O
D_BC	O
)	O
{	O
if	O
(	O
D_BS	O
)	O
D_BC	O
=	O
"\b"	pointer
;	O
else	O
D_BC	O
=	O
D_LE	O
;	O
}	O
if	O
(	O
!	O
D_CR	O
)	O
D_CR	O
=	O
"\r"	pointer
;	O
if	O
(	O
!	O
D_NL	O
)	O
D_NL	O
=	O
"\n"	pointer
;	O
if	O
(	O
D_UG	O
>	O
0	int
)	O
D_US	O
=	O
D_UE	O
=	O
0	int
;	O
if	O
(	O
D_SG	O
>	O
0	int
)	O
D_SO	O
=	O
D_SE	O
=	O
0	int
;	O
if	O
(	O
D_UG	O
>	O
0	int
&&	O
D_SG	O
>	O
0	int
)	O
D_MH	O
=	O
D_MD	O
=	O
D_MR	O
=	O
D_MB	O
=	O
D_ME	O
=	O
0	int
;	O
xue	int
=	O
ATYP_U	O
;	O
xse	int
=	O
ATYP_S	O
;	O
xme	int
=	O
ATYP_M	O
;	O
if	O
(	O
D_SO	O
&&	O
D_SE	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Warning: 'so' but no 'se' capability."	pointer
)	O
;	O
if	O
(	O
D_ME	O
)	O
xse	int
=	O
xme	int
;	O
else	O
D_SO	O
=	O
0	int
;	O
}	O
if	O
(	O
D_US	O
&&	O
D_UE	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Warning: 'us' but no 'ue' capability."	pointer
)	O
;	O
if	O
(	O
D_ME	O
)	O
xue	int
=	O
xme	int
;	O
else	O
D_US	O
=	O
0	int
;	O
}	O
if	O
(	O
(	O
D_MH	O
||	O
D_MD	O
||	O
D_MR	O
||	O
D_MB	O
)	O
&&	O
D_ME	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Warning: 'm?' but no 'me' capability."	pointer
)	O
;	O
D_MH	O
=	O
D_MD	O
=	O
D_MR	O
=	O
D_MB	O
=	O
0	int
;	O
}	O
if	O
(	O
D_UE	O
&&	O
D_SE	O
&&	O
strcmp	function
(	O
D_SE	O
,	O
D_UE	O
)	O
==	O
0	int
)	O
xse	int
=	O
xue	int
;	O
if	O
(	O
D_SE	O
&&	O
D_ME	O
&&	O
strcmp	function
(	O
D_ME	O
,	O
D_SE	O
)	O
==	O
0	int
)	O
xse	int
=	O
xme	int
;	O
if	O
(	O
D_UE	O
&&	O
D_ME	O
&&	O
strcmp	function
(	O
D_ME	O
,	O
D_UE	O
)	O
==	O
0	int
)	O
xue	int
=	O
xme	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NATTR	int
;	O
i	int
++	O
)	O
{	O
D_attrtab	O
[	O
i	int
]	O
=	O
D_tcs	O
[	O
T_ATTR	int
+	O
i	int
]	O
.	O
str	pointer
;	O
D_attrtyp	O
[	O
i	int
]	O
=	O
i	int
==	O
ATTR_SO	int
?	O
xse	int
:	O
(	O
i	int
==	O
ATTR_US	int
?	O
xue	int
:	O
xme	int
)	O
;	O
}	O
s	pointer
=	O
0	int
;	O
t	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NATTR	int
;	O
i	int
++	O
)	O
if	O
(	O
(	O
s	pointer
=	O
D_attrtab	O
[	O
i	int
]	O
)	O
)	O
{	O
t	int
=	O
D_attrtyp	O
[	O
i	int
]	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NATTR	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
D_attrtab	O
[	O
i	int
]	O
==	O
0	int
)	O
{	O
D_attrtab	O
[	O
i	int
]	O
=	O
s	pointer
;	O
D_attrtyp	O
[	O
i	int
]	O
=	O
t	int
;	O
}	O
else	O
{	O
s	pointer
=	O
D_attrtab	O
[	O
i	int
]	O
;	O
t	int
=	O
D_attrtyp	O
[	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
D_CAF	O
||	O
D_CAB	O
||	O
D_CSF	O
||	O
D_CSB	O
)	O
D_hascolor	O
=	O
1	int
;	O
if	O
(	O
D_UT	O
)	O
D_BE	O
=	O
1	int
;	O
if	O
(	O
!	O
D_DO	O
)	O
D_DO	O
=	O
D_NL	O
;	O
if	O
(	O
!	O
D_SF	O
)	O
D_SF	O
=	O
D_NL	O
;	O
if	O
(	O
D_IN	O
)	O
D_IC	O
=	O
D_IM	O
=	O
0	int
;	O
if	O
(	O
D_EI	O
==	O
0	int
)	O
D_IM	O
=	O
0	int
;	O
if	O
(	O
D_IC	O
&&	O
D_IM	O
&&	O
strcmp	function
(	O
D_IC	O
,	O
D_IM	O
)	O
==	O
0	int
)	O
D_IC	O
=	O
0	int
;	O
if	O
(	O
D_KE	O
==	O
0	int
)	O
D_KS	O
=	O
0	int
;	O
if	O
(	O
D_CVN	O
==	O
0	int
)	O
D_CVR	O
=	O
0	int
;	O
if	O
(	O
D_VE	O
==	O
0	int
)	O
D_VI	O
=	O
D_VS	O
=	O
0	int
;	O
if	O
(	O
D_CCE	O
==	O
0	int
)	O
D_CCS	O
=	O
0	int
;	O
if	O
(	O
D_CG0	O
)	O
{	O
if	O
(	O
D_CS0	O
==	O
0	int
)	O
D_CS0	O
=	O
"\033(%p1%c"	pointer
;	O
if	O
(	O
D_CE0	O
==	O
0	int
)	O
D_CE0	O
=	O
"\033(B"	pointer
;	O
D_AC	O
=	O
0	int
;	O
D_EA	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
D_AC	O
||	O
(	O
D_AS	O
&&	O
D_AE	O
)	O
)	O
{	O
D_CS0	O
=	O
(	O
D_AS	O
&&	O
D_AE	O
)	O
?	O
D_AS	O
:	O
""	pointer
;	O
D_CE0	O
=	O
(	O
D_AS	O
&&	O
D_AE	O
)	O
?	O
D_AE	O
:	O
""	pointer
;	O
D_CC0	O
=	O
D_AC	O
;	O
}	O
else	O
{	O
D_CS0	O
=	O
D_CE0	O
=	O
""	pointer
;	O
D_CC0	O
=	O
0	int
;	O
D_AC	O
=	O
""	pointer
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
D_c0_tab	O
[	O
i	int
]	O
=	O
i	int
;	O
if	O
(	O
D_AC	O
)	O
{	O
s	pointer
=	O
"l+m+k+j+u+t+v+w+q-x|n+o~s_p\"r#`+a:f'g#~o.v-^+<,>h#I#0#y<z>"	pointer
;	O
for	O
(	O
i	int
=	O
(	O
strlen	function
(	O
s	pointer
)	O
-	O
2	int
)	O
&	O
~	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
-=	O
2	int
)	O
D_c0_tab	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
s	pointer
[	O
i	int
]	O
]	O
=	O
s	pointer
[	O
i	int
+	O
1	int
]	O
;	O
}	O
if	O
(	O
D_CC0	O
)	O
for	O
(	O
i	int
=	O
(	O
strlen	function
(	O
D_CC0	O
)	O
-	O
2	int
)	O
&	O
~	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
-=	O
2	int
)	O
D_c0_tab	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_CC0	O
[	O
i	int
]	O
]	O
=	O
D_CC0	O
[	O
i	int
+	O
1	int
]	O
;	O
debug1	O
(	O
"ISO2022 = %d\n"	pointer
,	O
D_CG0	O
)	O
;	O
if	O
(	O
D_PF	O
==	O
0	int
)	O
D_PO	O
=	O
0	int
;	O
debug2	O
(	O
"terminal size is %d, %d (says TERMCAP)\n"	pointer
,	O
D_CO	O
,	O
D_LI	O
)	O
;	O
if	O
(	O
D_CXC	O
)	O
if	O
(	O
CreateTransTable	function
(	O
D_CXC	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
D_CZ1	O
==	O
0	int
)	O
D_CZ0	O
=	O
0	int
;	O
CheckScreenSize	function
(	O
0	int
)	O
;	O
if	O
(	O
D_TS	O
==	O
0	int
||	O
D_FS	O
==	O
0	int
||	O
D_DS	O
==	O
0	int
)	O
D_HS	O
=	O
0	int
;	O
if	O
(	O
D_HS	O
)	O
{	O
debug	O
(	O
"oy! we have a hardware status line, says termcap\n"	pointer
)	O
;	O
if	O
(	O
D_WS	O
<	O
0	int
)	O
D_WS	O
=	O
0	int
;	O
}	O
D_has_hstatus	O
=	O
hardstatusemu	int
&	O
~	O
HSTATUS_ALWAYS	O
;	O
if	O
(	O
D_HS	O
&&	O
!	O
(	O
hardstatusemu	int
&	O
HSTATUS_ALWAYS	O
)	O
)	O
D_has_hstatus	O
=	O
HSTATUS_HS	int
;	O
if	O
(	O
D_CKJ	O
)	O
{	O
int	O
enc	int
=	O
FindEncoding	function
(	O
D_CKJ	O
)	O
;	O
if	O
(	O
enc	int
!=	O
-	O
1	int
)	O
D_encoding	O
=	O
enc	int
;	O
}	O
if	O
(	O
!	O
D_tcs	O
[	O
T_NAVIGATE	int
]	O
.	O
str	pointer
&&	O
D_tcs	O
[	O
T_NAVIGATE	int
+	O
1	int
]	O
.	O
str	pointer
)	O
D_tcs	O
[	O
T_NAVIGATE	int
]	O
.	O
str	pointer
=	O
D_tcs	O
[	O
T_NAVIGATE	int
+	O
1	int
]	O
.	O
str	pointer
;	O
if	O
(	O
!	O
D_tcs	O
[	O
T_NAVIGATE	int
+	O
2	int
]	O
.	O
str	pointer
&&	O
D_tcs	O
[	O
T_NAVIGATE	int
+	O
3	int
]	O
.	O
str	pointer
)	O
D_tcs	O
[	O
T_NAVIGATE	int
+	O
2	int
]	O
.	O
str	pointer
=	O
D_tcs	O
[	O
T_NAVIGATE	int
+	O
3	int
]	O
.	O
str	pointer
;	O
D_UPcost	O
=	O
CalcCost	function
(	O
D_UP	O
)	O
;	O
D_DOcost	O
=	O
CalcCost	function
(	O
D_DO	O
)	O
;	O
D_NLcost	O
=	O
CalcCost	function
(	O
D_NL	O
)	O
;	O
D_LEcost	O
=	O
CalcCost	function
(	O
D_BC	O
)	O
;	O
D_NDcost	O
=	O
CalcCost	function
(	O
D_ND	O
)	O
;	O
D_CRcost	O
=	O
CalcCost	function
(	O
D_CR	O
)	O
;	O
D_IMcost	O
=	O
CalcCost	function
(	O
D_IM	O
)	O
;	O
D_EIcost	O
=	O
CalcCost	function
(	O
D_EI	O
)	O
;	O
if	O
(	O
D_CAN	O
)	O
{	O
debug	O
(	O
"termcap has AN, setting autonuke\n"	pointer
)	O
;	O
D_auto_nuke	O
=	O
1	int
;	O
}	O
if	O
(	O
D_COL	O
>	O
0	int
)	O
{	O
debug1	O
(	O
"termcap has OL (%d), setting limit\n"	pointer
,	O
D_COL	O
)	O
;	O
D_obufmax	O
=	O
D_COL	O
;	O
D_obuflenmax	O
=	O
D_obuflen	O
-	O
D_obufmax	O
;	O
}	O
if	O
(	O
D_tcs	O
[	O
T_CAPS	int
]	O
.	O
str	pointer
&&	O
D_tcs	O
[	O
T_CAPS	int
+	O
10	int
]	O
.	O
str	pointer
&&	O
!	O
strcmp	function
(	O
D_tcs	O
[	O
T_CAPS	int
]	O
.	O
str	pointer
,	O
D_tcs	O
[	O
T_CAPS	int
+	O
10	int
]	O
.	O
str	pointer
)	O
)	O
D_tcs	O
[	O
T_CAPS	int
]	O
.	O
str	pointer
=	O
0	int
;	O
if	O
(	O
D_tcs	O
[	O
T_NAVIGATE_DELETE	int
]	O
.	O
str	pointer
&&	O
!	O
strcmp	function
(	O
D_tcs	O
[	O
T_NAVIGATE_DELETE	int
]	O
.	O
str	pointer
,	O
"\0177"	pointer
)	O
)	O
D_tcs	O
[	O
T_NAVIGATE_DELETE	int
]	O
.	O
str	pointer
=	O
0	int
;	O
if	O
(	O
D_tcs	O
[	O
T_CURSOR	int
+	O
3	int
]	O
.	O
str	pointer
&&	O
!	O
strcmp	function
(	O
D_tcs	O
[	O
T_CURSOR	int
+	O
3	int
]	O
.	O
str	pointer
,	O
"\008"	pointer
)	O
)	O
D_tcs	O
[	O
T_CURSOR	int
+	O
3	int
]	O
.	O
str	pointer
=	O
0	int
;	O
D_nseqs	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
T_OCAPS	int
-	O
T_CAPS	int
;	O
i	int
++	O
)	O
remap	function
(	O
i	int
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
kmap_extn	int
;	O
i	int
++	O
)	O
remap	function
(	O
i	int
+	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
,	O
1	int
)	O
;	O
D_seqp	O
=	O
D_kmaps	O
+	O
3	int
;	O
D_seql	O
=	O
0	int
;	O
D_seqh	O
=	O
0	int
;	O
D_tcinited	O
=	O
1	int
;	O
MakeTermcap	function
(	O
0	int
)	O
;	O
e_tgetent	function
(	O
tbuf	array
,	O
D_termname	O
)	O
;	O
CheckEscape	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
remap	function
(	O
n	int
,	O
map	int
)	O
int	O
n	int
;	O
int	O
map	int
;	O
{	O
char	O
*	O
s	pointer
=	O
0	int
;	O
int	O
fl	int
=	O
0	int
,	O
domap	int
=	O
0	int
;	O
struct	O
action	struct
*	O
a1	pointer
,	O
*	O
a2	pointer
,	O
*	O
tab	pointer
;	O
int	O
l	int
=	O
0	int
;	O
struct	O
kmap_ext	struct
*	O
kme	pointer
=	O
0	int
;	O
a1	pointer
=	O
0	int
;	O
if	O
(	O
n	int
>=	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
{	O
kme	pointer
=	O
kmap_exts	pointer
+	O
(	O
n	int
-	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
)	O
;	O
s	pointer
=	O
kme	pointer
->	O
str	pointer
;	O
l	int
=	O
kme	pointer
->	O
fl	int
&	O
~	O
KMAP_NOTIMEOUT	int
;	O
fl	int
=	O
kme	pointer
->	O
fl	int
&	O
KMAP_NOTIMEOUT	int
;	O
a1	pointer
=	O
&	O
kme	pointer
->	O
um	struct
;	O
}	O
tab	pointer
=	O
umtab	array
;	O
for	O
(	O
;	O
;	O
)	O
{	O
a2	pointer
=	O
0	int
;	O
if	O
(	O
n	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
{	O
a1	pointer
=	O
&	O
tab	pointer
[	O
n	int
]	O
;	O
if	O
(	O
n	int
>=	O
KMAP_KEYS	O
)	O
n	int
-=	O
T_OCAPS	int
-	O
T_CURSOR	int
;	O
s	pointer
=	O
D_tcs	O
[	O
n	int
+	O
T_CAPS	int
]	O
.	O
str	pointer
;	O
l	int
=	O
s	pointer
?	O
strlen	function
(	O
s	pointer
)	O
:	O
0	int
;	O
if	O
(	O
n	int
>=	O
T_CURSOR	int
-	O
T_CAPS	int
)	O
a2	pointer
=	O
&	O
tab	pointer
[	O
n	int
+	O
(	O
T_OCAPS	int
-	O
T_CURSOR	int
)	O
]	O
;	O
}	O
if	O
(	O
s	pointer
==	O
0	int
||	O
l	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
a1	pointer
&&	O
a1	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
a1	pointer
=	O
0	int
;	O
if	O
(	O
a2	pointer
&&	O
a2	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
a2	pointer
=	O
0	int
;	O
if	O
(	O
a1	pointer
&&	O
a1	pointer
->	O
nr	int
==	O
RC_STUFF	int
&&	O
a1	pointer
->	O
args	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
a1	pointer
->	O
args	pointer
[	O
0	int
]	O
,	O
s	pointer
)	O
==	O
0	int
)	O
a1	pointer
=	O
0	int
;	O
if	O
(	O
a2	pointer
&&	O
a2	pointer
->	O
nr	int
==	O
RC_STUFF	int
&&	O
a2	pointer
->	O
args	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
a2	pointer
->	O
args	pointer
[	O
0	int
]	O
,	O
s	pointer
)	O
==	O
0	int
)	O
a2	pointer
=	O
0	int
;	O
domap	int
|=	O
(	O
a1	pointer
||	O
a2	pointer
)	O
;	O
if	O
(	O
tab	pointer
==	O
umtab	array
)	O
{	O
tab	pointer
=	O
dmtab	array
;	O
a1	pointer
=	O
kme	pointer
?	O
&	O
kme	pointer
->	O
dm	struct
:	O
0	int
;	O
}	O
else	O
if	O
(	O
tab	pointer
==	O
dmtab	array
)	O
{	O
tab	pointer
=	O
mmtab	array
;	O
a1	pointer
=	O
kme	pointer
?	O
&	O
kme	pointer
->	O
mm	struct
:	O
0	int
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
n	int
<	O
KMAP_KEYS	O
)	O
domap	int
=	O
1	int
;	O
if	O
(	O
map	int
==	O
0	int
&&	O
domap	int
)	O
return	O
0	int
;	O
if	O
(	O
map	int
&&	O
!	O
domap	int
)	O
return	O
0	int
;	O
debug3	O
(	O
"%smapping %s %#x\n"	pointer
,	O
map	int
?	O
""	pointer
:	O
"un"	pointer
,	O
s	pointer
,	O
n	int
)	O
;	O
if	O
(	O
map	int
)	O
return	O
addmapseq	function
(	O
s	pointer
,	O
l	int
,	O
n	int
|	O
fl	int
)	O
;	O
else	O
return	O
remmapseq	function
(	O
s	pointer
,	O
l	int
)	O
;	O
}	O
void	O
CheckEscape	function
(	O
)	O
{	O
struct	O
display	struct
*	O
odisplay	pointer
;	O
int	O
i	int
,	O
nr	int
;	O
if	O
(	O
DefaultEsc	int
>=	O
0	int
)	O
return	O
;	O
odisplay	pointer
=	O
display	struct
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
D_nseqs	O
;	O
i	int
+=	O
D_kmaps	O
[	O
i	int
+	O
2	int
]	O
*	O
2	int
+	O
4	int
)	O
{	O
nr	int
=	O
(	O
D_kmaps	O
[	O
i	int
]	O
<<	O
8	int
|	O
D_kmaps	O
[	O
i	int
+	O
1	int
]	O
)	O
&	O
~	O
KMAP_NOTIMEOUT	int
;	O
if	O
(	O
nr	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
{	O
if	O
(	O
umtab	array
[	O
nr	int
]	O
.	O
nr	int
==	O
RC_COMMAND	int
)	O
break	O
;	O
if	O
(	O
umtab	array
[	O
nr	int
]	O
.	O
nr	int
==	O
RC_ILLEGAL	O
&&	O
dmtab	array
[	O
nr	int
]	O
.	O
nr	int
==	O
RC_COMMAND	int
)	O
break	O
;	O
}	O
else	O
{	O
struct	O
kmap_ext	struct
*	O
kme	pointer
=	O
kmap_exts	pointer
+	O
nr	int
-	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
;	O
if	O
(	O
kme	pointer
->	O
um	struct
.	O
nr	int
==	O
RC_COMMAND	int
)	O
break	O
;	O
if	O
(	O
kme	pointer
->	O
um	struct
.	O
nr	int
==	O
RC_ILLEGAL	O
&&	O
kme	pointer
->	O
dm	struct
.	O
nr	int
==	O
RC_COMMAND	int
)	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
display	struct
==	O
0	int
)	O
{	O
display	struct
=	O
odisplay	pointer
;	O
return	O
;	O
}	O
SetEscape	function
(	O
(	O
struct	O
acluser	struct
*	O
)	O
0	int
,	O
Ctrl	O
(	O
'a'	O
)	O
,	O
'a'	O
)	O
;	O
if	O
(	O
odisplay	pointer
->	O
d_user	pointer
->	O
u_Esc	int
==	O
-	O
1	int
)	O
odisplay	pointer
->	O
d_user	pointer
->	O
u_Esc	int
=	O
DefaultEsc	int
;	O
if	O
(	O
odisplay	pointer
->	O
d_user	pointer
->	O
u_MetaEsc	int
==	O
-	O
1	int
)	O
odisplay	pointer
->	O
d_user	pointer
->	O
u_MetaEsc	int
=	O
DefaultMetaEsc	int
;	O
display	struct
=	O
0	int
;	O
Msg	function
(	O
0	int
,	O
"Warning: escape char set back to ^A"	pointer
)	O
;	O
display	struct
=	O
odisplay	pointer
;	O
}	O
static	O
int	O
findseq_ge	function
(	O
seq	pointer
,	O
k	int
,	O
sp	pointer
)	O
char	O
*	O
seq	pointer
;	O
int	O
k	int
;	O
unsigned	O
char	O
*	O
*	O
sp	pointer
;	O
{	O
unsigned	O
char	O
*	O
p	pointer
;	O
int	O
j	int
,	O
l	int
;	O
p	pointer
=	O
D_kmaps	O
;	O
while	O
(	O
p	pointer
-	O
D_kmaps	O
<	O
D_nseqs	O
)	O
{	O
l	int
=	O
p	pointer
[	O
2	int
]	O
;	O
p	pointer
+=	O
3	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
k	int
||	O
j	int
==	O
l	int
)	O
j	int
=	O
l	int
-	O
k	int
;	O
else	O
if	O
(	O
p	pointer
[	O
j	int
]	O
!=	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
seq	pointer
)	O
[	O
j	int
]	O
)	O
j	int
=	O
p	pointer
[	O
j	int
]	O
-	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
seq	pointer
)	O
[	O
j	int
]	O
;	O
else	O
continue	O
;	O
break	O
;	O
}	O
if	O
(	O
j	int
>=	O
0	int
)	O
{	O
*	O
sp	pointer
=	O
p	pointer
-	O
3	int
;	O
return	O
j	int
;	O
}	O
p	pointer
+=	O
2	int
*	O
l	int
+	O
1	int
;	O
}	O
*	O
sp	pointer
=	O
p	pointer
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
setseqoff	function
(	O
p	pointer
,	O
i	int
,	O
o	int
)	O
unsigned	O
char	O
*	O
p	pointer
;	O
int	O
i	int
;	O
int	O
o	int
;	O
{	O
unsigned	O
char	O
*	O
q	pointer
;	O
int	O
l	int
,	O
k	int
;	O
k	int
=	O
p	pointer
[	O
2	int
]	O
;	O
if	O
(	O
o	int
<	O
256	int
)	O
{	O
p	pointer
[	O
k	int
+	O
4	int
+	O
i	int
]	O
=	O
o	int
;	O
return	O
;	O
}	O
for	O
(	O
q	pointer
=	O
p	pointer
+	O
k	int
*	O
2	int
+	O
4	int
;	O
;	O
q	pointer
+=	O
l	int
*	O
2	int
+	O
4	int
)	O
{	O
l	int
=	O
q	pointer
[	O
2	int
]	O
;	O
if	O
(	O
(	O
q	pointer
+	O
l	int
*	O
2	int
-	O
p	pointer
)	O
/	O
2	int
>=	O
256	int
)	O
{	O
p	pointer
[	O
k	int
+	O
4	int
+	O
i	int
]	O
=	O
(	O
q	pointer
-	O
p	pointer
-	O
4	int
)	O
/	O
2	int
;	O
return	O
;	O
}	O
}	O
}	O
static	O
int	O
addmapseq	function
(	O
seq	pointer
,	O
k	int
,	O
nr	int
)	O
char	O
*	O
seq	pointer
;	O
int	O
k	int
;	O
int	O
nr	int
;	O
{	O
int	O
i	int
,	O
j	int
,	O
l	int
,	O
mo	int
,	O
m	union
;	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
k	int
>=	O
254	int
)	O
return	O
-	O
1	int
;	O
j	int
=	O
findseq_ge	function
(	O
seq	pointer
,	O
k	int
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
{	O
p	pointer
[	O
0	int
]	O
=	O
nr	int
>>	O
8	int
;	O
p	pointer
[	O
1	int
]	O
=	O
nr	int
;	O
return	O
0	int
;	O
}	O
i	int
=	O
p	pointer
-	O
D_kmaps	O
;	O
if	O
(	O
D_nseqs	O
+	O
2	int
*	O
k	int
+	O
4	int
>=	O
D_aseqs	O
)	O
{	O
D_kmaps	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
xrealloc	function
(	O
(	O
char	O
*	O
)	O
D_kmaps	O
,	O
D_aseqs	O
+	O
256	int
)	O
;	O
D_aseqs	O
+=	O
256	int
;	O
p	pointer
=	O
D_kmaps	O
+	O
i	int
;	O
}	O
D_seqp	O
=	O
D_kmaps	O
+	O
3	int
;	O
D_seql	O
=	O
0	int
;	O
D_seqh	O
=	O
0	int
;	O
evdeq	function
(	O
&	O
D_mapev	O
)	O
;	O
if	O
(	O
j	int
>	O
0	int
)	O
bcopy	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
(	O
char	O
*	O
)	O
p	pointer
+	O
2	int
*	O
k	int
+	O
4	int
,	O
D_nseqs	O
-	O
i	int
)	O
;	O
p	pointer
[	O
0	int
]	O
=	O
nr	int
>>	O
8	int
;	O
p	pointer
[	O
1	int
]	O
=	O
nr	int
;	O
p	pointer
[	O
2	int
]	O
=	O
k	int
;	O
bcopy	function
(	O
seq	pointer
,	O
(	O
char	O
*	O
)	O
p	pointer
+	O
3	int
,	O
k	int
)	O
;	O
bzero	function
(	O
p	pointer
+	O
k	int
+	O
3	int
,	O
k	int
+	O
1	int
)	O
;	O
D_nseqs	O
+=	O
2	int
*	O
k	int
+	O
4	int
;	O
if	O
(	O
j	int
>	O
0	int
)	O
{	O
q	pointer
=	O
p	pointer
+	O
2	int
*	O
k	int
+	O
4	int
;	O
l	int
=	O
q	pointer
[	O
2	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
p	pointer
[	O
3	int
+	O
i	int
]	O
!=	O
q	pointer
[	O
3	int
+	O
i	int
]	O
)	O
{	O
p	pointer
[	O
k	int
+	O
4	int
+	O
i	int
]	O
=	O
k	int
;	O
break	O
;	O
}	O
setseqoff	function
(	O
p	pointer
,	O
i	int
,	O
q	pointer
[	O
l	int
+	O
4	int
+	O
i	int
]	O
?	O
q	pointer
[	O
l	int
+	O
4	int
+	O
i	int
]	O
+	O
k	int
+	O
2	int
:	O
0	int
)	O
;	O
}	O
}	O
for	O
(	O
q	pointer
=	O
D_kmaps	O
;	O
q	pointer
<	O
p	pointer
;	O
q	pointer
+=	O
2	int
*	O
l	int
+	O
4	int
)	O
{	O
l	int
=	O
q	pointer
[	O
2	int
]	O
;	O
for	O
(	O
m	union
=	O
j	int
=	O
0	int
;	O
j	int
<	O
l	int
;	O
j	int
++	O
)	O
{	O
mo	int
=	O
m	union
;	O
if	O
(	O
!	O
m	union
&&	O
q	pointer
[	O
3	int
+	O
j	int
]	O
!=	O
seq	pointer
[	O
j	int
]	O
)	O
m	union
=	O
1	int
;	O
if	O
(	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
mo	int
&&	O
m	union
)	O
setseqoff	function
(	O
q	pointer
,	O
j	int
,	O
(	O
p	pointer
-	O
q	pointer
-	O
4	int
)	O
/	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
q	pointer
+	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
*	O
2	int
+	O
4	int
>	O
p	pointer
||	O
(	O
q	pointer
+	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
*	O
2	int
+	O
4	int
==	O
p	pointer
&&	O
!	O
m	union
)	O
)	O
setseqoff	function
(	O
q	pointer
,	O
j	int
,	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
+	O
k	int
+	O
2	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
remmapseq	function
(	O
seq	pointer
,	O
k	int
)	O
char	O
*	O
seq	pointer
;	O
int	O
k	int
;	O
{	O
int	O
j	int
,	O
l	int
;	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
k	int
>=	O
254	int
||	O
(	O
j	int
=	O
findseq_ge	function
(	O
seq	pointer
,	O
k	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
q	pointer
=	O
D_kmaps	O
;	O
q	pointer
<	O
p	pointer
;	O
q	pointer
+=	O
2	int
*	O
l	int
+	O
4	int
)	O
{	O
l	int
=	O
q	pointer
[	O
2	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
l	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
q	pointer
+	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
*	O
2	int
+	O
4	int
==	O
p	pointer
)	O
setseqoff	function
(	O
q	pointer
,	O
j	int
,	O
p	pointer
[	O
k	int
+	O
4	int
+	O
j	int
]	O
?	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
+	O
p	pointer
[	O
k	int
+	O
4	int
+	O
j	int
]	O
-	O
k	int
:	O
0	int
)	O
;	O
else	O
if	O
(	O
q	pointer
+	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
*	O
2	int
+	O
4	int
>	O
p	pointer
)	O
q	pointer
[	O
l	int
+	O
4	int
+	O
j	int
]	O
-=	O
k	int
+	O
2	int
;	O
}	O
}	O
if	O
(	O
D_kmaps	O
+	O
D_nseqs	O
>	O
p	pointer
+	O
2	int
*	O
k	int
+	O
4	int
)	O
bcopy	function
(	O
(	O
char	O
*	O
)	O
p	pointer
+	O
2	int
*	O
k	int
+	O
4	int
,	O
(	O
char	O
*	O
)	O
p	pointer
,	O
(	O
D_kmaps	O
+	O
D_nseqs	O
)	O
-	O
(	O
p	pointer
+	O
2	int
*	O
k	int
+	O
4	int
)	O
)	O
;	O
D_nseqs	O
-=	O
2	int
*	O
k	int
+	O
4	int
;	O
D_seqp	O
=	O
D_kmaps	O
+	O
3	int
;	O
D_seql	O
=	O
0	int
;	O
D_seqh	O
=	O
0	int
;	O
evdeq	function
(	O
&	O
D_mapev	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
AddCap	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
register	O
int	O
n	int
;	O
n	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
Termcaplen	int
+	O
n	int
<	O
TERMCAP_BUFSIZE	int
-	O
1	int
)	O
{	O
strcpy	function
(	O
Termcap	array
+	O
Termcaplen	int
,	O
s	pointer
)	O
;	O
Termcaplen	int
+=	O
n	int
;	O
tcLineLen	int
+=	O
n	int
;	O
}	O
}	O
char	O
*	O
MakeTermcap	function
(	O
aflag	int
)	O
int	O
aflag	int
;	O
{	O
char	O
buf	pointer
[	O
TERMCAP_BUFSIZE	int
]	O
;	O
register	O
char	O
*	O
p	pointer
,	O
*	O
cp	pointer
,	O
*	O
s	pointer
,	O
ch	char
,	O
*	O
tname	pointer
;	O
int	O
i	int
,	O
wi	int
,	O
he	int
;	O
if	O
(	O
display	struct
)	O
{	O
wi	int
=	O
D_width	O
;	O
he	int
=	O
D_height	O
;	O
tname	pointer
=	O
D_termname	O
;	O
}	O
else	O
{	O
wi	int
=	O
80	int
;	O
he	int
=	O
24	int
;	O
tname	pointer
=	O
"vt100"	pointer
;	O
}	O
debug1	O
(	O
"MakeTermcap(%d)\n"	pointer
,	O
aflag	int
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
getenv	function
(	O
"SCREENCAP"	pointer
)	O
)	O
&&	O
strlen	function
(	O
s	pointer
)	O
<	O
TERMCAP_BUFSIZE	int
)	O
{	O
sprintf	function
(	O
Termcap	array
,	O
"TERMCAP=%s"	pointer
,	O
s	pointer
)	O
;	O
strcpy	function
(	O
Term	array
,	O
"TERM=screen"	pointer
)	O
;	O
debug	O
(	O
"getenvSCREENCAP o.k.\n"	pointer
)	O
;	O
return	O
Termcap	array
;	O
}	O
Termcaplen	int
=	O
0	int
;	O
debug1	O
(	O
"MakeTermcap screenterm='%s'\n"	pointer
,	O
screenterm	array
)	O
;	O
debug1	O
(	O
"MakeTermcap termname='%s'\n"	pointer
,	O
tname	pointer
)	O
;	O
if	O
(	O
*	O
screenterm	array
==	O
'\0'	O
||	O
strlen	function
(	O
screenterm	array
)	O
>	O
MAXSTR	int
-	O
3	int
)	O
{	O
debug	O
(	O
"MakeTermcap sets screenterm=screen\n"	pointer
)	O
;	O
strncpy	function
(	O
screenterm	array
,	O
"screen"	pointer
,	O
MAXTERMLEN	int
)	O
;	O
screenterm	array
[	O
MAXTERMLEN	int
]	O
=	O
'\0'	O
;	O
}	O
do	O
{	O
strcpy	function
(	O
Term	array
,	O
"TERM="	pointer
)	O
;	O
p	pointer
=	O
Term	array
+	O
5	int
;	O
if	O
(	O
!	O
aflag	int
&&	O
strlen	function
(	O
screenterm	array
)	O
+	O
strlen	function
(	O
tname	pointer
)	O
<	O
MAXSTR	int
-	O
1	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"%s.%s"	pointer
,	O
screenterm	array
,	O
tname	pointer
)	O
;	O
if	O
(	O
e_tgetent	function
(	O
buf	pointer
,	O
p	pointer
)	O
==	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
nwin_default	struct
.	O
bce	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"%s-bce"	pointer
,	O
screenterm	array
)	O
;	O
if	O
(	O
e_tgetent	function
(	O
buf	pointer
,	O
p	pointer
)	O
==	O
1	int
)	O
break	O
;	O
}	O
strcpy	function
(	O
p	pointer
,	O
screenterm	array
)	O
;	O
if	O
(	O
e_tgetent	function
(	O
buf	pointer
,	O
p	pointer
)	O
==	O
1	int
)	O
break	O
;	O
strcpy	function
(	O
p	pointer
,	O
"vt100"	pointer
)	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
tcLineLen	int
=	O
100	int
;	O
if	O
(	O
strlen	function
(	O
Term	array
)	O
>	O
TERMCAP_BUFSIZE	int
-	O
40	int
)	O
strcpy	function
(	O
Term	array
,	O
"too_long"	pointer
)	O
;	O
sprintf	function
(	O
Termcap	array
,	O
"TERMCAP=SC|%s|VT 100/ANSI X3.64 virtual terminal:"	pointer
,	O
Term	array
+	O
5	int
)	O
;	O
Termcaplen	int
=	O
strlen	function
(	O
Termcap	array
)	O
;	O
debug1	O
(	O
"MakeTermcap decided '%s'\n"	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
extra_outcap	pointer
&&	O
*	O
extra_outcap	pointer
)	O
{	O
for	O
(	O
cp	pointer
=	O
extra_outcap	pointer
;	O
(	O
p	pointer
=	O
index	function
(	O
cp	pointer
,	O
':'	O
)	O
)	O
;	O
cp	pointer
=	O
p	pointer
)	O
{	O
ch	char
=	O
*	O
++	O
p	pointer
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
AddCap	function
(	O
cp	pointer
)	O
;	O
*	O
p	pointer
=	O
ch	char
;	O
}	O
tcLineLen	int
=	O
100	int
;	O
}	O
debug1	O
(	O
"MakeTermcap after outcap '%s'\n"	pointer
,	O
(	O
char	O
*	O
)	O
TermcapConst	array
)	O
;	O
if	O
(	O
Termcaplen	int
+	O
strlen	function
(	O
TermcapConst	array
)	O
<	O
TERMCAP_BUFSIZE	int
)	O
{	O
strcpy	function
(	O
Termcap	array
+	O
Termcaplen	int
,	O
(	O
char	O
*	O
)	O
TermcapConst	array
)	O
;	O
Termcaplen	int
+=	O
strlen	function
(	O
TermcapConst	array
)	O
;	O
}	O
sprintf	function
(	O
buf	pointer
,	O
"li#%d:co#%d:"	pointer
,	O
he	int
,	O
wi	int
)	O
;	O
AddCap	function
(	O
buf	pointer
)	O
;	O
AddCap	function
(	O
"am:"	pointer
)	O
;	O
if	O
(	O
aflag	int
||	O
(	O
force_vt	int
&&	O
!	O
D_COP	O
)	O
||	O
D_CLP	O
||	O
!	O
D_AM	O
)	O
{	O
AddCap	function
(	O
"xn:"	pointer
)	O
;	O
AddCap	function
(	O
"xv:"	pointer
)	O
;	O
AddCap	function
(	O
"LP:"	pointer
)	O
;	O
}	O
if	O
(	O
aflag	int
||	O
(	O
D_CS	O
&&	O
D_SR	O
)	O
||	O
D_AL	O
||	O
D_CAL	O
)	O
{	O
AddCap	function
(	O
"sr=\\EM:"	pointer
)	O
;	O
AddCap	function
(	O
"al=\\E[L:"	pointer
)	O
;	O
AddCap	function
(	O
"AL=\\E[%dL:"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
D_SR	O
)	O
AddCap	function
(	O
"sr=\\EM:"	pointer
)	O
;	O
if	O
(	O
aflag	int
||	O
D_CS	O
)	O
AddCap	function
(	O
"cs=\\E[%i%d;%dr:"	pointer
)	O
;	O
if	O
(	O
aflag	int
||	O
D_CS	O
||	O
D_DL	O
||	O
D_CDL	O
)	O
{	O
AddCap	function
(	O
"dl=\\E[M:"	pointer
)	O
;	O
AddCap	function
(	O
"DL=\\E[%dM:"	pointer
)	O
;	O
}	O
if	O
(	O
aflag	int
||	O
D_DC	O
||	O
D_CDC	O
)	O
{	O
AddCap	function
(	O
"dc=\\E[P:"	pointer
)	O
;	O
AddCap	function
(	O
"DC=\\E[%dP:"	pointer
)	O
;	O
}	O
if	O
(	O
aflag	int
||	O
D_CIC	O
||	O
D_IC	O
||	O
D_IM	O
)	O
{	O
AddCap	function
(	O
"im=\\E[4h:"	pointer
)	O
;	O
AddCap	function
(	O
"ei=\\E[4l:"	pointer
)	O
;	O
AddCap	function
(	O
"mi:"	pointer
)	O
;	O
AddCap	function
(	O
"IC=\\E[%d@:"	pointer
)	O
;	O
}	O
AddCap	function
(	O
"ks=\\E[?1h\\E=:"	pointer
)	O
;	O
AddCap	function
(	O
"ke=\\E[?1l\\E>:"	pointer
)	O
;	O
AddCap	function
(	O
"vi=\\E[?25l:"	pointer
)	O
;	O
AddCap	function
(	O
"ve=\\E[34h\\E[?25h:"	pointer
)	O
;	O
AddCap	function
(	O
"vs=\\E[34l:"	pointer
)	O
;	O
AddCap	function
(	O
"ti=\\E[?1049h:"	pointer
)	O
;	O
AddCap	function
(	O
"te=\\E[?1049l:"	pointer
)	O
;	O
if	O
(	O
display	struct
)	O
{	O
if	O
(	O
D_US	O
)	O
{	O
AddCap	function
(	O
"us=\\E[4m:"	pointer
)	O
;	O
AddCap	function
(	O
"ue=\\E[24m:"	pointer
)	O
;	O
}	O
if	O
(	O
D_SO	O
)	O
{	O
AddCap	function
(	O
"so=\\E[3m:"	pointer
)	O
;	O
AddCap	function
(	O
"se=\\E[23m:"	pointer
)	O
;	O
}	O
if	O
(	O
D_MB	O
)	O
AddCap	function
(	O
"mb=\\E[5m:"	pointer
)	O
;	O
if	O
(	O
D_MD	O
)	O
AddCap	function
(	O
"md=\\E[1m:"	pointer
)	O
;	O
if	O
(	O
D_MH	O
)	O
AddCap	function
(	O
"mh=\\E[2m:"	pointer
)	O
;	O
if	O
(	O
D_MR	O
)	O
AddCap	function
(	O
"mr=\\E[7m:"	pointer
)	O
;	O
if	O
(	O
D_MB	O
||	O
D_MD	O
||	O
D_MH	O
||	O
D_MR	O
)	O
AddCap	function
(	O
"me=\\E[m:ms:"	pointer
)	O
;	O
if	O
(	O
D_hascolor	O
)	O
AddCap	function
(	O
"Co#8:pa#64:AF=\\E[3%dm:AB=\\E[4%dm:op=\\E[39;49m:AX:"	pointer
)	O
;	O
if	O
(	O
D_VB	O
)	O
AddCap	function
(	O
"vb=\\Eg:"	pointer
)	O
;	O
if	O
(	O
D_CG0	O
)	O
AddCap	function
(	O
"G0:"	pointer
)	O
;	O
if	O
(	O
D_CC0	O
||	O
(	O
D_CS0	O
&&	O
*	O
D_CS0	O
)	O
)	O
{	O
AddCap	function
(	O
"as=\\E(0:"	pointer
)	O
;	O
AddCap	function
(	O
"ae=\\E(B:"	pointer
)	O
;	O
AddCap	function
(	O
"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:"	pointer
)	O
;	O
}	O
if	O
(	O
D_PO	O
)	O
{	O
AddCap	function
(	O
"po=\\E[5i:"	pointer
)	O
;	O
AddCap	function
(	O
"pf=\\E[4i:"	pointer
)	O
;	O
}	O
if	O
(	O
D_CZ0	O
)	O
{	O
AddCap	function
(	O
"Z0=\\E[?3h:"	pointer
)	O
;	O
AddCap	function
(	O
"Z1=\\E[?3l:"	pointer
)	O
;	O
}	O
if	O
(	O
D_CWS	O
)	O
AddCap	function
(	O
"WS=\\E[8;%d;%dt:"	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
T_CAPS	int
;	O
i	int
<	O
T_ECAPS	int
;	O
i	int
++	O
)	O
{	O
struct	O
action	struct
*	O
act	pointer
;	O
if	O
(	O
i	int
<	O
T_OCAPS	int
)	O
{	O
if	O
(	O
i	int
>=	O
T_KEYPAD	int
)	O
continue	O
;	O
if	O
(	O
i	int
>=	O
T_FEXTRA	int
&&	O
i	int
<	O
T_BACKTAB	int
)	O
continue	O
;	O
if	O
(	O
i	int
>	O
T_BACKTAB	int
&&	O
i	int
<	O
T_NAVIGATE	int
)	O
continue	O
;	O
if	O
(	O
i	int
>=	O
T_CURSOR	int
&&	O
i	int
<	O
T_OCAPS	int
)	O
{	O
act	pointer
=	O
&	O
umtab	array
[	O
i	int
-	O
(	O
T_CURSOR	int
-	O
T_OCAPS	int
+	O
T_CAPS	int
)	O
]	O
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
act	pointer
=	O
&	O
dmtab	array
[	O
i	int
-	O
(	O
T_CURSOR	int
-	O
T_OCAPS	int
+	O
T_CAPS	int
)	O
]	O
;	O
}	O
else	O
{	O
act	pointer
=	O
&	O
umtab	array
[	O
i	int
-	O
T_CAPS	int
]	O
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
act	pointer
=	O
&	O
dmtab	array
[	O
i	int
-	O
T_CAPS	int
]	O
;	O
}	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
&&	O
(	O
i	int
==	O
T_NAVIGATE	int
+	O
1	int
||	O
i	int
==	O
T_NAVIGATE	int
+	O
3	int
)	O
)	O
{	O
act	pointer
=	O
&	O
umtab	array
[	O
i	int
-	O
T_CAPS	int
-	O
1	int
]	O
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
act	pointer
=	O
&	O
dmtab	array
[	O
i	int
-	O
T_CAPS	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
act	pointer
->	O
nr	int
!=	O
RC_ILLEGAL	O
)	O
{	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_STUFF	int
)	O
{	O
MakeString	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
act	pointer
->	O
args	pointer
[	O
0	int
]	O
)	O
;	O
AddCap	function
(	O
buf	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
}	O
if	O
(	O
display	struct
==	O
0	int
)	O
continue	O
;	O
switch	O
(	O
term	struct
[	O
i	int
]	O
.	O
type	int
)	O
{	O
case	O
T_STR	int
:	O
if	O
(	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
==	O
0	int
)	O
break	O
;	O
MakeString	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
)	O
;	O
AddCap	function
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
T_FLG	int
:	O
if	O
(	O
D_tcs	O
[	O
i	int
]	O
.	O
flg	int
==	O
0	int
)	O
break	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s:"	pointer
,	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
)	O
;	O
AddCap	function
(	O
buf	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
debug	O
(	O
"MakeTermcap: end\n"	pointer
)	O
;	O
return	O
Termcap	array
;	O
}	O
void	O
DumpTermcap	function
(	O
aflag	int
,	O
f	pointer
)	O
int	O
aflag	int
;	O
FILE	struct
*	O
f	pointer
;	O
{	O
register	O
const	O
char	O
*	O
p	pointer
,	O
*	O
pe	pointer
;	O
int	O
n	int
,	O
col	int
=	O
0	int
;	O
if	O
(	O
(	O
p	pointer
=	O
index	function
(	O
MakeTermcap	function
(	O
aflag	int
)	O
,	O
'='	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
p	pointer
++	O
;	O
debug1	O
(	O
"DumpTermcap: '%s'\n"	pointer
,	O
p	pointer
)	O
;	O
while	O
(	O
(	O
pe	pointer
=	O
index	function
(	O
p	pointer
,	O
':'	O
)	O
)	O
)	O
{	O
n	int
=	O
pe	pointer
-	O
p	pointer
+	O
1	int
;	O
if	O
(	O
(	O
col	int
>	O
8	int
)	O
&&	O
(	O
(	O
col	int
+	O
n	int
)	O
>	O
TERMCAP_MAX_WIDTH	int
)	O
)	O
{	O
fwrite	function
(	O
"\\\n\t:"	pointer
,	O
1	int
,	O
4	int
,	O
f	pointer
)	O
;	O
col	int
=	O
8	int
;	O
}	O
fwrite	function
(	O
p	pointer
,	O
1	int
,	O
n	int
,	O
f	pointer
)	O
;	O
col	int
+=	O
n	int
;	O
p	pointer
=	O
++	O
pe	pointer
;	O
}	O
if	O
(	O
*	O
p	pointer
)	O
fwrite	function
(	O
p	pointer
,	O
1	int
,	O
strlen	function
(	O
p	pointer
)	O
,	O
f	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
f	pointer
)	O
;	O
}	O
static	O
void	O
MakeString	function
(	O
cap	pointer
,	O
buf	pointer
,	O
buflen	int
,	O
s	pointer
)	O
char	O
*	O
cap	pointer
,	O
*	O
buf	pointer
;	O
int	O
buflen	int
;	O
char	O
*	O
s	pointer
;	O
{	O
register	O
char	O
*	O
p	pointer
,	O
*	O
pmax	pointer
;	O
register	O
unsigned	O
int	O
c	int
;	O
p	pointer
=	O
buf	pointer
;	O
pmax	pointer
=	O
p	pointer
+	O
buflen	int
-	O
(	O
3	int
+	O
4	int
+	O
2	int
)	O
;	O
*	O
p	pointer
++	O
=	O
*	O
cap	pointer
++	O
;	O
*	O
p	pointer
++	O
=	O
*	O
cap	pointer
;	O
*	O
p	pointer
++	O
=	O
'='	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
s	pointer
++	O
)	O
&&	O
(	O
p	pointer
<	O
pmax	pointer
)	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\033'	O
:	O
*	O
p	pointer
++	O
=	O
'\\'	O
;	O
*	O
p	pointer
++	O
=	O
'E'	O
;	O
break	O
;	O
case	O
':'	O
:	O
strcpy	function
(	O
p	pointer
,	O
"\\072"	pointer
)	O
;	O
p	pointer
+=	O
4	int
;	O
break	O
;	O
case	O
'^'	O
:	O
case	O
'\\'	O
:	O
*	O
p	pointer
++	O
=	O
'\\'	O
;	O
*	O
p	pointer
++	O
=	O
c	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
c	int
>=	O
200	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"\\%03o"	pointer
,	O
c	int
&	O
0377	int
)	O
;	O
p	pointer
+=	O
4	int
;	O
}	O
else	O
if	O
(	O
c	int
<	O
' '	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'^'	O
;	O
*	O
p	pointer
++	O
=	O
c	int
+	O
'@'	O
;	O
}	O
else	O
*	O
p	pointer
++	O
=	O
c	int
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
':'	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
int	O
CreateTransTable	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
int	O
curchar	int
;	O
char	O
*	O
templ	pointer
,	O
*	O
arg	pointer
;	O
int	O
templlen	int
;	O
int	O
templnsub	int
;	O
char	O
*	O
p	pointer
,	O
*	O
sx	pointer
;	O
char	O
*	O
*	O
ctable	pointer
;	O
int	O
l	int
,	O
c	int
;	O
if	O
(	O
(	O
D_xtable	O
=	O
(	O
char	O
*	O
*	O
*	O
)	O
calloc	function
(	O
256	int
,	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
)	O
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
QUOTES	O
(	O
s	pointer
)	O
)	O
s	pointer
++	O
;	O
curchar	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
++	O
;	O
if	O
(	O
curchar	int
==	O
'B'	O
)	O
curchar	int
=	O
0	int
;	O
templ	pointer
=	O
s	pointer
;	O
templlen	int
=	O
0	int
;	O
templnsub	int
=	O
0	int
;	O
if	O
(	O
D_xtable	O
[	O
curchar	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
D_xtable	O
[	O
curchar	int
]	O
=	O
(	O
char	O
*	O
*	O
)	O
calloc	function
(	O
257	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
FreeTransTable	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
ctable	pointer
=	O
D_xtable	O
[	O
curchar	int
]	O
;	O
for	O
(	O
;	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
','	O
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
QUOTES	O
(	O
s	pointer
)	O
)	O
s	pointer
++	O
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'%'	O
)	O
{	O
templnsub	int
++	O
;	O
continue	O
;	O
}	O
templlen	int
++	O
;	O
}	O
if	O
(	O
*	O
s	pointer
++	O
==	O
0	int
)	O
break	O
;	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
','	O
)	O
{	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
++	O
;	O
if	O
(	O
QUOTES	O
(	O
(	O
s	pointer
-	O
1	int
)	O
)	O
)	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
++	O
;	O
else	O
if	O
(	O
c	int
==	O
'%'	O
)	O
c	int
=	O
256	int
;	O
if	O
(	O
ctable	pointer
[	O
c	int
]	O
)	O
free	function
(	O
ctable	pointer
[	O
c	int
]	O
)	O
;	O
arg	pointer
=	O
s	pointer
;	O
l	int
=	O
copyarg	function
(	O
&	O
s	pointer
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
c	int
!=	O
256	int
)	O
l	int
=	O
l	int
*	O
templnsub	int
+	O
templlen	int
;	O
if	O
(	O
(	O
ctable	pointer
[	O
c	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
l	int
+	O
1	int
)	O
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
FreeTransTable	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
sx	pointer
=	O
ctable	pointer
[	O
c	int
]	O
;	O
for	O
(	O
p	pointer
=	O
(	O
(	O
c	int
==	O
256	int
)	O
?	O
"%"	pointer
:	O
templ	pointer
)	O
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
','	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
QUOTES	O
(	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'%'	O
)	O
{	O
s	pointer
=	O
arg	pointer
;	O
sx	pointer
+=	O
copyarg	function
(	O
&	O
s	pointer
,	O
sx	pointer
)	O
;	O
continue	O
;	O
}	O
*	O
sx	pointer
++	O
=	O
*	O
p	pointer
;	O
}	O
*	O
sx	pointer
=	O
0	int
;	O
ASSERT	O
(	O
ctable	pointer
[	O
c	int
]	O
+	O
l	int
*	O
templnsub	int
+	O
templlen	int
==	O
sx	pointer
)	O
;	O
debug3	O
(	O
"XC: %c %c->%s\n"	pointer
,	O
curchar	int
,	O
c	int
,	O
ctable	pointer
[	O
c	int
]	O
)	O
;	O
}	O
if	O
(	O
*	O
s	pointer
==	O
','	O
)	O
s	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
FreeTransTable	function
(	O
)	O
{	O
char	O
*	O
*	O
*	O
p	pointer
,	O
*	O
*	O
q	pointer
;	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
(	O
p	pointer
=	O
D_xtable	O
)	O
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
,	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
continue	O
;	O
q	pointer
=	O
*	O
p	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
257	int
;	O
j	int
++	O
,	O
q	pointer
++	O
)	O
if	O
(	O
*	O
q	pointer
)	O
free	function
(	O
*	O
q	pointer
)	O
;	O
free	function
(	O
*	O
p	pointer
)	O
;	O
}	O
free	function
(	O
D_xtable	O
)	O
;	O
D_xtable	O
=	O
NULL	O
;	O
}	O
static	O
int	O
copyarg	function
(	O
pp	pointer
,	O
s	pointer
)	O
char	O
*	O
*	O
pp	pointer
,	O
*	O
s	pointer
;	O
{	O
int	O
l	int
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
l	int
=	O
0	int
,	O
p	pointer
=	O
*	O
pp	pointer
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
','	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
QUOTES	O
(	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
if	O
(	O
s	pointer
)	O
*	O
s	pointer
++	O
=	O
*	O
p	pointer
;	O
l	int
++	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
p	pointer
++	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
return	O
l	int
;	O
}	O
static	O
int	O
e_tgetent	function
(	O
bp	pointer
,	O
name	pointer
)	O
char	O
*	O
bp	pointer
,	O
*	O
name	pointer
;	O
{	O
int	O
r	int
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
r	int
=	O
tgetent	function
(	O
bp	pointer
,	O
name	pointer
)	O
;	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
return	O
r	int
;	O
}	O
static	O
char	O
*	O
findcap	function
(	O
cap	pointer
,	O
tepp	pointer
,	O
n	int
)	O
char	O
*	O
cap	pointer
;	O
char	O
*	O
*	O
tepp	pointer
;	O
int	O
n	int
;	O
{	O
char	O
*	O
tep	pointer
;	O
char	O
c	int
,	O
*	O
p	pointer
,	O
*	O
cp	pointer
;	O
int	O
mode	struct
;	O
int	O
num	int
=	O
0	int
,	O
capl	int
;	O
if	O
(	O
!	O
extra_incap	pointer
)	O
return	O
0	int
;	O
tep	pointer
=	O
*	O
tepp	pointer
;	O
capl	int
=	O
strlen	function
(	O
cap	pointer
)	O
;	O
cp	pointer
=	O
0	int
;	O
mode	struct
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
extra_incap	pointer
;	O
*	O
p	pointer
;	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
cap	pointer
,	O
capl	int
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
capl	int
;	O
c	int
=	O
*	O
p	pointer
;	O
if	O
(	O
c	int
&&	O
c	int
!=	O
':'	O
&&	O
c	int
!=	O
'@'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
c	int
==	O
0	int
||	O
c	int
==	O
'@'	O
||	O
c	int
==	O
'='	O
||	O
c	int
==	O
':'	O
||	O
c	int
==	O
'#'	O
)	O
cp	pointer
=	O
tep	pointer
;	O
}	O
while	O
(	O
(	O
c	int
=	O
*	O
p	pointer
)	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
mode	struct
==	O
0	int
)	O
{	O
if	O
(	O
c	int
==	O
':'	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'^'	O
)	O
mode	struct
=	O
1	int
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
mode	struct
=	O
2	int
;	O
}	O
else	O
if	O
(	O
mode	struct
==	O
1	int
)	O
{	O
mode	struct
=	O
0	int
;	O
c	int
=	O
c	int
&	O
0x1f	int
;	O
}	O
else	O
if	O
(	O
mode	struct
==	O
2	int
)	O
{	O
mode	struct
=	O
0	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
mode	struct
=	O
3	int
;	O
num	int
=	O
0	int
;	O
break	O
;	O
case	O
'E'	O
:	O
c	int
=	O
27	int
;	O
break	O
;	O
case	O
'n'	O
:	O
c	int
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	int
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	int
=	O
'\t'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
c	int
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	int
=	O
'\f'	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
mode	struct
>	O
2	int
)	O
{	O
num	int
=	O
num	int
*	O
8	int
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
if	O
(	O
mode	struct
++	O
==	O
5	int
||	O
(	O
*	O
p	pointer
<	O
'0'	O
||	O
*	O
p	pointer
>	O
'9'	O
)	O
)	O
{	O
c	int
=	O
num	int
;	O
mode	struct
=	O
0	int
;	O
}	O
}	O
if	O
(	O
mode	struct
)	O
continue	O
;	O
if	O
(	O
cp	pointer
&&	O
n	int
!=	O
1	int
)	O
{	O
*	O
cp	pointer
++	O
=	O
c	int
;	O
n	int
--	O
;	O
}	O
}	O
if	O
(	O
cp	pointer
)	O
{	O
*	O
cp	pointer
++	O
=	O
0	int
;	O
*	O
tepp	pointer
=	O
cp	pointer
;	O
debug2	O
(	O
"'%s' found in extra_incap -> %s\n"	pointer
,	O
cap	pointer
,	O
tep	pointer
)	O
;	O
return	O
tep	pointer
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
e_tgetstr	function
(	O
cap	pointer
,	O
tepp	pointer
)	O
char	O
*	O
cap	pointer
;	O
char	O
*	O
*	O
tepp	pointer
;	O
{	O
char	O
*	O
tep	pointer
;	O
if	O
(	O
(	O
tep	pointer
=	O
findcap	function
(	O
cap	pointer
,	O
tepp	pointer
,	O
0	int
)	O
)	O
)	O
return	O
(	O
*	O
tep	pointer
==	O
'@'	O
)	O
?	O
0	int
:	O
tep	pointer
;	O
return	O
tgetstr	function
(	O
cap	pointer
,	O
tepp	pointer
)	O
;	O
}	O
static	O
int	O
e_tgetflag	function
(	O
cap	pointer
)	O
char	O
*	O
cap	pointer
;	O
{	O
char	O
buf	pointer
[	O
2	int
]	O
,	O
*	O
bufp	pointer
;	O
char	O
*	O
tep	pointer
;	O
bufp	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
tep	pointer
=	O
findcap	function
(	O
cap	pointer
,	O
&	O
bufp	pointer
,	O
2	int
)	O
)	O
)	O
return	O
(	O
*	O
tep	pointer
==	O
'@'	O
)	O
?	O
0	int
:	O
1	int
;	O
return	O
tgetflag	function
(	O
cap	pointer
)	O
>	O
0	int
;	O
}	O
static	O
int	O
e_tgetnum	function
(	O
cap	pointer
)	O
char	O
*	O
cap	pointer
;	O
{	O
char	O
buf	pointer
[	O
20	int
]	O
,	O
*	O
bufp	pointer
;	O
char	O
*	O
tep	pointer
,	O
c	int
;	O
int	O
res	int
,	O
base	int
=	O
10	int
;	O
bufp	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
tep	pointer
=	O
findcap	function
(	O
cap	pointer
,	O
&	O
bufp	pointer
,	O
20	int
)	O
)	O
)	O
{	O
c	int
=	O
*	O
tep	pointer
;	O
if	O
(	O
c	int
==	O
'@'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
c	int
==	O
'0'	O
)	O
base	int
=	O
8	int
;	O
res	int
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
tep	pointer
++	O
)	O
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
res	int
=	O
res	int
*	O
base	int
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
return	O
res	int
;	O
}	O
return	O
tgetnum	function
(	O
cap	pointer
)	O
;	O
}	O