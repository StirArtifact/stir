static	O
void	O
gen_schur_decomp	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
inline	O
int	O
gen_qzstep	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
inline	O
void	O
gen_qzstep_d	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
void	O
gen_tri_split_top	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
inline	O
void	O
gen_tri_chase_zero	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
size_t	long
q	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
inline	O
void	O
gen_tri_zero_H	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
inline	O
size_t	long
gen_search_small_elements	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
int	O
*	O
flag	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
int	O
gen_schur_standardize1	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
double	O
*	O
alphar	pointer
,	O
double	O
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
int	O
gen_schur_standardize2	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_complex	struct
*	O
alpha1	pointer
,	O
gsl_complex	struct
*	O
alpha2	pointer
,	O
double	O
*	O
beta1	pointer
,	O
double	O
*	O
beta2	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
int	O
gen_compute_eigenvals	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_complex	struct
*	O
alpha1	pointer
,	O
gsl_complex	struct
*	O
alpha2	pointer
,	O
double	O
*	O
beta1	pointer
,	O
double	O
*	O
beta2	pointer
)	O
;	O
static	O
void	O
gen_store_eigval1	function
(	O
const	O
gsl_matrix	struct
*	O
H	pointer
,	O
const	O
double	O
a	pointer
,	O
const	O
double	O
b	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
void	O
gen_store_eigval2	function
(	O
const	O
gsl_matrix	struct
*	O
H	pointer
,	O
const	O
gsl_complex	struct
*	O
alpha1	pointer
,	O
const	O
double	O
beta1	pointer
,	O
const	O
gsl_complex	struct
*	O
alpha2	pointer
,	O
const	O
double	O
beta2	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
inline	O
size_t	long
gen_get_submatrix	function
(	O
const	O
gsl_matrix	struct
*	O
A	pointer
,	O
const	O
gsl_matrix	struct
*	O
B	pointer
)	O
;	O
inline	O
static	O
double	O
normF	function
(	O
gsl_matrix	struct
*	O
A	pointer
)	O
;	O
gsl_eigen_gen_workspace	struct
*	O
gsl_eigen_gen_alloc	function
(	O
const	O
size_t	long
n	long
)	O
{	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"matrix dimension must be positive integer"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
w	pointer
=	O
(	O
gsl_eigen_gen_workspace	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
gsl_eigen_gen_workspace	struct
)	O
)	O
;	O
if	O
(	O
w	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	pointer
->	O
size	long
=	O
n	long
;	O
w	pointer
->	O
max_iterations	long
=	O
30	int
*	O
n	long
;	O
w	pointer
->	O
n_evals	long
=	O
0	int
;	O
w	pointer
->	O
n_iter	long
=	O
0	int
;	O
w	pointer
->	O
needtop	int
=	O
0	int
;	O
w	pointer
->	O
atol	function
=	O
0.0	int
;	O
w	pointer
->	O
btol	double
=	O
0.0	int
;	O
w	pointer
->	O
ascale	double
=	O
0.0	int
;	O
w	pointer
->	O
bscale	double
=	O
0.0	int
;	O
w	pointer
->	O
eshift	double
=	O
0.0	int
;	O
w	pointer
->	O
H	pointer
=	O
NULL	O
;	O
w	pointer
->	O
R	pointer
=	O
NULL	O
;	O
w	pointer
->	O
compute_s	int
=	O
0	int
;	O
w	pointer
->	O
compute_t	int
=	O
0	int
;	O
w	pointer
->	O
Q	pointer
=	O
NULL	O
;	O
w	pointer
->	O
Z	pointer
=	O
NULL	O
;	O
w	pointer
->	O
work	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
if	O
(	O
w	pointer
->	O
work	pointer
==	O
0	int
)	O
{	O
gsl_eigen_gen_free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for additional workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
(	O
w	pointer
)	O
;	O
}	O
void	O
gsl_eigen_gen_free	function
(	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
w	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
}	O
void	O
gsl_eigen_gen_params	function
(	O
const	O
int	O
compute_s	int
,	O
const	O
int	O
compute_t	int
,	O
const	O
int	O
balance	int
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
w	pointer
->	O
compute_s	int
=	O
compute_s	int
;	O
w	pointer
->	O
compute_t	int
=	O
compute_t	int
;	O
}	O
int	O
gsl_eigen_gen	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
A	pointer
->	O
size1	long
;	O
if	O
(	O
N	int
!=	O
A	pointer
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square to compute eigenvalues"	pointer
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
N	int
!=	O
B	pointer
->	O
size1	long
)	O
||	O
(	O
N	int
!=	O
B	pointer
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"B matrix dimensions must match A"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
alpha	long double
->	O
size	long
!=	O
N	int
||	O
beta	long double
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"eigenvalue vector must match matrix size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
w	pointer
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix size does not match workspace"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
double	O
anorm	double
,	O
bnorm	double
;	O
gsl_linalg_hesstri_decomp	function
(	O
A	pointer
,	O
B	pointer
,	O
w	pointer
->	O
Q	pointer
,	O
w	pointer
->	O
Z	pointer
,	O
w	pointer
->	O
work	pointer
)	O
;	O
w	pointer
->	O
H	pointer
=	O
A	pointer
;	O
w	pointer
->	O
R	pointer
=	O
B	pointer
;	O
w	pointer
->	O
n_evals	long
=	O
0	int
;	O
w	pointer
->	O
n_iter	long
=	O
0	int
;	O
w	pointer
->	O
eshift	double
=	O
0.0	int
;	O
w	pointer
->	O
needtop	int
=	O
w	pointer
->	O
Q	pointer
!=	O
0	int
||	O
w	pointer
->	O
Z	pointer
!=	O
0	int
||	O
w	pointer
->	O
compute_t	int
||	O
w	pointer
->	O
compute_s	int
;	O
anorm	double
=	O
normF	function
(	O
A	pointer
)	O
;	O
bnorm	double
=	O
normF	function
(	O
B	pointer
)	O
;	O
w	pointer
->	O
atol	function
=	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_DBL_EPSILON	int
*	O
anorm	double
)	O
;	O
w	pointer
->	O
btol	double
=	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_DBL_EPSILON	int
*	O
bnorm	double
)	O
;	O
w	pointer
->	O
ascale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
anorm	double
)	O
;	O
w	pointer
->	O
bscale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
bnorm	double
)	O
;	O
gen_schur_decomp	function
(	O
A	pointer
,	O
B	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
n_evals	long
!=	O
N	int
)	O
return	O
GSL_EMAXITER	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_eigen_gen_QZ	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_matrix	struct
*	O
Q	pointer
,	O
gsl_matrix	struct
*	O
Z	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
Q	pointer
&&	O
(	O
A	pointer
->	O
size1	long
!=	O
Q	pointer
->	O
size1	long
||	O
A	pointer
->	O
size1	long
!=	O
Q	pointer
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Q matrix has wrong dimensions"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
Z	pointer
&&	O
(	O
A	pointer
->	O
size1	long
!=	O
Z	pointer
->	O
size1	long
||	O
A	pointer
->	O
size1	long
!=	O
Z	pointer
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Z matrix has wrong dimensions"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
s	pointer
;	O
w	pointer
->	O
Q	pointer
=	O
Q	pointer
;	O
w	pointer
->	O
Z	pointer
=	O
Z	pointer
;	O
s	pointer
=	O
gsl_eigen_gen	function
(	O
A	pointer
,	O
B	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
w	pointer
->	O
Q	pointer
=	O
NULL	O
;	O
w	pointer
->	O
Z	pointer
=	O
NULL	O
;	O
return	O
s	pointer
;	O
}	O
}	O
static	O
void	O
gen_schur_decomp	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
size_t	long
N	int
;	O
gsl_matrix_view	struct
h	pointer
,	O
r	pointer
;	O
gsl_matrix_view	struct
vh	struct
,	O
vr	struct
;	O
size_t	long
q	pointer
;	O
gsl_complex	struct
z1	struct
,	O
z2	struct
;	O
double	O
a	pointer
,	O
b	pointer
;	O
int	O
s	pointer
;	O
int	O
flag	pointer
;	O
N	int
=	O
H	pointer
->	O
size1	long
;	O
h	pointer
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
r	pointer
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
while	O
(	O
(	O
N	int
>	O
1	int
)	O
&&	O
(	O
w	pointer
->	O
n_iter	long
)	O
++	O
<	O
w	pointer
->	O
max_iterations	long
)	O
{	O
q	pointer
=	O
gen_search_small_elements	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
&	O
flag	pointer
,	O
w	pointer
)	O
;	O
if	O
(	O
flag	pointer
==	O
0	int
)	O
{	O
s	pointer
=	O
gen_qzstep	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
w	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
GSL_CONTINUE	int
)	O
{	O
s	pointer
=	O
gen_schur_standardize2	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
&	O
z1	struct
,	O
&	O
z2	struct
,	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
w	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
continue	O
;	O
}	O
gen_store_eigval2	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
z1	struct
,	O
a	pointer
,	O
&	O
z2	struct
,	O
b	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
N	int
=	O
0	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
flag	pointer
==	O
2	int
)	O
{	O
if	O
(	O
q	pointer
==	O
0	int
)	O
{	O
gen_tri_split_top	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
w	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
q	pointer
!=	O
N	int
-	O
1	int
)	O
gen_tri_chase_zero	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
w	pointer
)	O
;	O
gen_tri_zero_H	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
w	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
q	pointer
==	O
(	O
N	int
-	O
1	int
)	O
)	O
{	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
q	pointer
,	O
1	int
,	O
1	int
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
q	pointer
,	O
1	int
,	O
1	int
)	O
;	O
gen_schur_standardize1	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
w	pointer
)	O
;	O
gen_store_eigval1	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
a	pointer
,	O
b	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
--	O
N	int
;	O
h	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
r	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
if	O
(	O
q	pointer
==	O
(	O
N	int
-	O
2	int
)	O
)	O
{	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
q	pointer
,	O
2	int
,	O
2	int
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
q	pointer
,	O
2	int
,	O
2	int
)	O
;	O
s	pointer
=	O
gen_schur_standardize2	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
&	O
z1	struct
,	O
&	O
z2	struct
,	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
w	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
gen_schur_decomp	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
}	O
else	O
{	O
gen_store_eigval2	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
z1	struct
,	O
a	pointer
,	O
&	O
z2	struct
,	O
b	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
}	O
N	int
-=	O
2	int
;	O
h	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
r	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
if	O
(	O
q	pointer
==	O
1	int
)	O
{	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
gen_schur_standardize1	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
w	pointer
)	O
;	O
gen_store_eigval1	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
a	pointer
,	O
b	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
--	O
N	int
;	O
h	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
1	int
,	O
1	int
,	O
N	int
,	O
N	int
)	O
;	O
r	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
1	int
,	O
1	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
if	O
(	O
q	pointer
==	O
2	int
)	O
{	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
2	int
,	O
2	int
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
2	int
,	O
2	int
)	O
;	O
s	pointer
=	O
gen_schur_standardize2	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
&	O
z1	struct
,	O
&	O
z2	struct
,	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
w	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
gen_schur_decomp	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
}	O
else	O
{	O
gen_store_eigval2	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
z1	struct
,	O
a	pointer
,	O
&	O
z2	struct
,	O
b	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
}	O
N	int
-=	O
2	int
;	O
h	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
2	int
,	O
2	int
,	O
N	int
,	O
N	int
)	O
;	O
r	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
2	int
,	O
2	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
{	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
q	pointer
,	O
N	int
-	O
q	pointer
,	O
N	int
-	O
q	pointer
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
q	pointer
,	O
q	pointer
,	O
N	int
-	O
q	pointer
,	O
N	int
-	O
q	pointer
)	O
;	O
gen_schur_decomp	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
q	pointer
,	O
q	pointer
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
&	O
r	pointer
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
q	pointer
,	O
q	pointer
)	O
;	O
gen_schur_decomp	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
N	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
gen_schur_standardize1	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
&	O
r	pointer
.	O
matrix	struct
,	O
&	O
a	pointer
,	O
&	O
b	pointer
,	O
w	pointer
)	O
;	O
gen_store_eigval1	function
(	O
&	O
h	pointer
.	O
matrix	struct
,	O
a	pointer
,	O
b	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
)	O
;	O
}	O
}	O
static	O
inline	O
int	O
gen_qzstep	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
H	pointer
->	O
size1	long
;	O
gsl_matrix_view	struct
vh	struct
,	O
vr	struct
;	O
double	O
wr1	pointer
,	O
wr2	pointer
,	O
wi	pointer
;	O
double	O
scale1	pointer
,	O
scale2	pointer
,	O
scale	double
;	O
double	O
cs	double
,	O
sn	double
;	O
double	O
temp	double
,	O
temp2	double
;	O
size_t	long
j	long
;	O
gsl_vector_view	struct
xv	struct
,	O
yv	struct
;	O
size_t	long
top	long
=	O
0	int
;	O
size_t	long
rows	long
;	O
if	O
(	O
w	pointer
->	O
n_iter	long
%	O
10	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
GSL_DBL_MIN	int
*	O
w	pointer
->	O
max_iterations	long
)	O
*	O
fabs	function
(	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
)	O
<	O
fabs	function
(	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
)	O
{	O
w	pointer
->	O
eshift	double
+=	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
/	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
;	O
}	O
else	O
w	pointer
->	O
eshift	double
+=	O
1.0	int
/	O
(	O
GSL_DBL_MIN	int
*	O
w	pointer
->	O
max_iterations	long
)	O
;	O
if	O
(	O
(	O
w	pointer
->	O
eshift	double
<	O
GSL_DBL_EPSILON	int
)	O
&&	O
(	O
GSL_DBL_MIN	int
*	O
w	pointer
->	O
max_iterations	long
)	O
*	O
fabs	function
(	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
)	O
<	O
fabs	function
(	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
)	O
{	O
w	pointer
->	O
eshift	double
=	O
GEN_ESHIFT_COEFF	O
*	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
;	O
}	O
scale1	pointer
=	O
1.0	int
;	O
wr1	pointer
=	O
w	pointer
->	O
eshift	double
;	O
}	O
else	O
{	O
vh	struct
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
vr	struct
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_schur_gen_eigvals	function
(	O
&	O
vh	struct
.	O
matrix	struct
,	O
&	O
vr	struct
.	O
matrix	struct
,	O
&	O
wr1	pointer
,	O
&	O
wr2	pointer
,	O
&	O
wi	pointer
,	O
&	O
scale1	pointer
,	O
&	O
scale2	pointer
)	O
;	O
if	O
(	O
wi	pointer
!=	O
0.0	int
)	O
{	O
if	O
(	O
N	int
==	O
2	int
)	O
{	O
return	O
(	O
GSL_CONTINUE	int
)	O
;	O
}	O
else	O
{	O
gen_qzstep_d	function
(	O
H	pointer
,	O
R	pointer
,	O
w	pointer
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
temp	double
=	O
GSL_MIN	O
(	O
w	pointer
->	O
ascale	double
,	O
1.0	int
)	O
*	O
(	O
0.5	int
/	O
GSL_DBL_MIN	int
)	O
;	O
if	O
(	O
scale1	pointer
>	O
temp	double
)	O
scale	double
=	O
temp	double
/	O
scale1	pointer
;	O
else	O
scale	double
=	O
1.0	int
;	O
temp	double
=	O
GSL_MIN	O
(	O
w	pointer
->	O
bscale	double
,	O
1.0	int
)	O
*	O
(	O
0.5	int
/	O
GSL_DBL_MIN	int
)	O
;	O
if	O
(	O
fabs	function
(	O
wr1	pointer
)	O
>	O
temp	double
)	O
scale	double
=	O
GSL_MIN	O
(	O
scale	double
,	O
temp	double
/	O
fabs	function
(	O
wr1	pointer
)	O
)	O
;	O
scale1	pointer
*=	O
scale	double
;	O
wr1	pointer
*=	O
scale	double
;	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
{	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
}	O
temp	double
=	O
scale1	pointer
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
0	int
,	O
0	int
)	O
-	O
wr1	pointer
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
0	int
,	O
0	int
)	O
;	O
temp2	double
=	O
scale1	pointer
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
1	int
,	O
0	int
)	O
;	O
gsl_linalg_givens	function
(	O
temp	double
,	O
temp2	double
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
-	O
1	int
;	O
++	O
j	long
)	O
{	O
if	O
(	O
j	long
>	O
0	int
)	O
{	O
temp	double
=	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
,	O
j	long
-	O
1	int
)	O
;	O
temp2	double
=	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
)	O
;	O
gsl_linalg_givens	function
(	O
temp	double
,	O
temp2	double
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
temp	double
=	O
cs	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
,	O
j	long
-	O
1	int
)	O
+	O
sn	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
)	O
;	O
gsl_matrix_set	function
(	O
H	pointer
,	O
j	long
,	O
j	long
-	O
1	int
,	O
temp	double
)	O
;	O
gsl_matrix_set	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
,	O
0.0	int
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
H	pointer
,	O
j	long
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
R	pointer
,	O
j	long
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
Q	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
temp	double
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
temp2	double
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
)	O
;	O
gsl_linalg_givens	function
(	O
temp	double
,	O
temp2	double
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
rows	long
=	O
GSL_MIN	O
(	O
j	long
+	O
3	int
,	O
N	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
H	pointer
,	O
j	long
,	O
0	int
,	O
rows	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
0	int
,	O
rows	long
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
rows	long
=	O
GSL_MIN	O
(	O
j	long
+	O
2	int
,	O
N	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
R	pointer
,	O
j	long
,	O
0	int
,	O
rows	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
0	int
,	O
rows	long
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
inline	O
void	O
gen_qzstep_d	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
H	pointer
->	O
size1	long
;	O
size_t	long
j	long
;	O
double	O
dat	array
[	O
3	int
]	O
;	O
double	O
tau	pointer
;	O
gsl_vector_view	struct
v2	struct
,	O
v3	struct
;	O
gsl_matrix_view	struct
m	pointer
;	O
double	O
tmp	double
;	O
size_t	long
q	pointer
,	O
r	pointer
;	O
size_t	long
top	long
=	O
0	int
;	O
double	O
scale	double
;	O
double	O
AB11	double
,	O
AB22	double
,	O
ABNN	double
,	O
ABMM	double
,	O
AMNBNN	double
,	O
ANMBMM	double
,	O
A21B11	double
,	O
A12B22	double
,	O
A32B22	double
,	O
B12B22	double
,	O
BMNBNN	double
;	O
v2	struct
=	O
gsl_vector_view_array	function
(	O
dat	array
,	O
2	int
)	O
;	O
v3	struct
=	O
gsl_vector_view_array	function
(	O
dat	array
,	O
3	int
)	O
;	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
{	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
}	O
ABMM	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
;	O
ABNN	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
)	O
;	O
AB11	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
0	int
,	O
0	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
AB22	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
1	int
,	O
1	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
1	int
,	O
1	int
)	O
)	O
;	O
AMNBNN	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
)	O
;	O
ANMBMM	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
;	O
BMNBNN	double
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
/	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
A21B11	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
1	int
,	O
0	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
A12B22	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
0	int
,	O
1	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
1	int
,	O
1	int
)	O
)	O
;	O
A32B22	double
=	O
(	O
w	pointer
->	O
ascale	double
*	O
gsl_matrix_get	function
(	O
H	pointer
,	O
2	int
,	O
1	int
)	O
)	O
/	O
(	O
w	pointer
->	O
bscale	double
*	O
gsl_matrix_get	function
(	O
R	pointer
,	O
1	int
,	O
1	int
)	O
)	O
;	O
B12B22	double
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
0	int
,	O
1	int
)	O
/	O
gsl_matrix_get	function
(	O
R	pointer
,	O
1	int
,	O
1	int
)	O
;	O
dat	array
[	O
0	int
]	O
=	O
(	O
ABMM	double
-	O
AB11	double
)	O
*	O
(	O
ABNN	double
-	O
AB11	double
)	O
-	O
(	O
AMNBNN	double
*	O
ANMBMM	double
)	O
+	O
(	O
ANMBMM	double
*	O
BMNBNN	double
*	O
AB11	double
)	O
+	O
(	O
A12B22	double
-	O
(	O
AB11	double
*	O
B12B22	double
)	O
)	O
*	O
A21B11	double
;	O
dat	array
[	O
1	int
]	O
=	O
(	O
(	O
AB22	double
-	O
AB11	double
)	O
-	O
(	O
A21B11	double
*	O
B12B22	double
)	O
-	O
(	O
ABMM	double
-	O
AB11	double
)	O
-	O
(	O
ABNN	double
-	O
AB11	double
)	O
+	O
(	O
ANMBMM	double
*	O
BMNBNN	double
)	O
)	O
*	O
A21B11	double
;	O
dat	array
[	O
2	int
]	O
=	O
A32B22	double
*	O
A21B11	double
;	O
scale	double
=	O
fabs	function
(	O
dat	array
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
1	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
1	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
2	int
]	O
/=	O
scale	double
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
-	O
2	int
;	O
++	O
j	long
)	O
{	O
r	pointer
=	O
GSL_MIN	O
(	O
j	long
+	O
4	int
,	O
N	int
)	O
;	O
tau	pointer
=	O
gsl_linalg_householder_transform	function
(	O
&	O
v3	struct
.	O
vector	struct
)	O
;	O
if	O
(	O
tau	pointer
!=	O
0.0	int
)	O
{	O
q	pointer
=	O
(	O
size_t	long
)	O
GSL_MAX	O
(	O
0	int
,	O
(	O
int	O
)	O
j	long
-	O
1	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
q	pointer
,	O
3	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
q	pointer
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
j	long
,	O
q	pointer
,	O
3	int
,	O
N	int
-	O
q	pointer
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
,	O
3	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
j	long
,	O
j	long
,	O
3	int
,	O
N	int
-	O
j	long
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Q	pointer
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
Q	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
}	O
dat	array
[	O
0	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
2	int
,	O
j	long
+	O
2	int
)	O
;	O
dat	array
[	O
1	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
2	int
,	O
j	long
)	O
;	O
dat	array
[	O
2	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
2	int
,	O
j	long
+	O
1	int
)	O
;	O
scale	double
=	O
fabs	function
(	O
dat	array
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
1	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
1	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
2	int
]	O
/=	O
scale	double
;	O
}	O
tau	pointer
=	O
gsl_linalg_householder_transform	function
(	O
&	O
v3	struct
.	O
vector	struct
)	O
;	O
if	O
(	O
tau	pointer
!=	O
0.0	int
)	O
{	O
tmp	double
=	O
gsl_vector_get	function
(	O
&	O
v3	struct
.	O
vector	struct
,	O
1	int
)	O
;	O
gsl_vector_set	function
(	O
&	O
v3	struct
.	O
vector	struct
,	O
1	int
,	O
gsl_vector_get	function
(	O
&	O
v3	struct
.	O
vector	struct
,	O
2	int
)	O
/	O
tmp	double
)	O
;	O
gsl_vector_set	function
(	O
&	O
v3	struct
.	O
vector	struct
,	O
2	int
,	O
1.0	int
/	O
tmp	double
)	O
;	O
tau	pointer
*=	O
tmp	double
*	O
tmp	double
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
r	pointer
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
0	int
,	O
j	long
,	O
r	pointer
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
R	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
+	O
3	int
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
0	int
,	O
j	long
,	O
j	long
+	O
3	int
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
Z	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v3	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
}	O
dat	array
[	O
0	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
dat	array
[	O
1	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
)	O
;	O
scale	double
=	O
fabs	function
(	O
dat	array
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
1	int
]	O
/=	O
scale	double
;	O
}	O
tau	pointer
=	O
gsl_linalg_householder_transform	function
(	O
&	O
v2	struct
.	O
vector	struct
)	O
;	O
if	O
(	O
tau	pointer
!=	O
0.0	int
)	O
{	O
tmp	double
=	O
gsl_vector_get	function
(	O
&	O
v2	struct
.	O
vector	struct
,	O
1	int
)	O
;	O
gsl_vector_set	function
(	O
&	O
v2	struct
.	O
vector	struct
,	O
1	int
,	O
1.0	int
/	O
tmp	double
)	O
;	O
tau	pointer
*=	O
tmp	double
*	O
tmp	double
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
r	pointer
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
0	int
,	O
j	long
,	O
r	pointer
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
R	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
+	O
3	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
0	int
,	O
j	long
,	O
j	long
+	O
3	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
Z	pointer
,	O
0	int
,	O
top	long
+	O
j	long
,	O
w	pointer
->	O
size	long
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
}	O
dat	array
[	O
0	int
]	O
=	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
)	O
;	O
dat	array
[	O
1	int
]	O
=	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
2	int
,	O
j	long
)	O
;	O
if	O
(	O
j	long
<	O
N	int
-	O
3	int
)	O
dat	array
[	O
2	int
]	O
=	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
3	int
,	O
j	long
)	O
;	O
scale	double
=	O
fabs	function
(	O
dat	array
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
1	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
1	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
2	int
]	O
/=	O
scale	double
;	O
}	O
}	O
scale	double
=	O
fabs	function
(	O
dat	array
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
1	int
]	O
/=	O
scale	double
;	O
}	O
tau	pointer
=	O
gsl_linalg_householder_transform	function
(	O
&	O
v2	struct
.	O
vector	struct
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
-	O
3	int
,	O
2	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
N	int
+	O
3	int
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
3	int
,	O
2	int
,	O
3	int
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
2	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
N	int
+	O
2	int
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_hm	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Q	pointer
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
Q	pointer
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
w	pointer
->	O
size	long
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
dat	array
[	O
0	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
dat	array
[	O
1	int
]	O
=	O
gsl_matrix_get	function
(	O
R	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
;	O
scale	double
=	O
fabs	function
(	O
dat	array
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
dat	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array
[	O
1	int
]	O
/=	O
scale	double
;	O
}	O
tau	pointer
=	O
gsl_linalg_householder_transform	function
(	O
&	O
v2	struct
.	O
vector	struct
)	O
;	O
tmp	double
=	O
gsl_vector_get	function
(	O
&	O
v2	struct
.	O
vector	struct
,	O
1	int
)	O
;	O
gsl_vector_set	function
(	O
&	O
v2	struct
.	O
vector	struct
,	O
1	int
,	O
1.0	int
/	O
tmp	double
)	O
;	O
tau	pointer
*=	O
tmp	double
*	O
tmp	double
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
H	pointer
,	O
0	int
,	O
N	int
-	O
2	int
,	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
R	pointer
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
else	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
R	pointer
,	O
0	int
,	O
N	int
-	O
2	int
,	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
w	pointer
->	O
Z	pointer
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
w	pointer
->	O
size	long
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	function
(	O
tau	pointer
,	O
&	O
v2	struct
.	O
vector	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
}	O
}	O
static	O
void	O
gen_tri_split_top	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
H	pointer
->	O
size1	long
;	O
size_t	long
j	long
,	O
top	long
=	O
0	int
;	O
double	O
cs	double
,	O
sn	double
;	O
gsl_vector_view	struct
xv	struct
,	O
yv	struct
;	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
j	long
=	O
0	int
;	O
gsl_linalg_givens	function
(	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
,	O
j	long
)	O
,	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
,	O
top	long
,	O
w	pointer
->	O
size	long
-	O
top	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
,	O
w	pointer
->	O
size	long
-	O
top	long
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_row	function
(	O
H	pointer
,	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_row	function
(	O
H	pointer
,	O
j	long
+	O
1	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
,	O
0.0	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
1	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
1	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
R	pointer
,	O
j	long
,	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
Q	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
gen_tri_chase_zero	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
size_t	long
q	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
H	pointer
->	O
size1	long
;	O
size_t	long
j	long
,	O
top	long
=	O
0	int
;	O
double	O
cs	double
,	O
sn	double
;	O
gsl_vector_view	struct
xv	struct
,	O
yv	struct
;	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
for	O
(	O
j	long
=	O
q	pointer
;	O
j	long
<	O
N	int
-	O
1	int
;	O
++	O
j	long
)	O
{	O
gsl_linalg_givens	function
(	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
,	O
j	long
+	O
1	int
)	O
,	O
gsl_matrix_get	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
+	O
1	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
+	O
1	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
R	pointer
,	O
j	long
,	O
j	long
+	O
1	int
,	O
N	int
-	O
j	long
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
,	O
N	int
-	O
j	long
-	O
1	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	function
(	O
R	pointer
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
,	O
0.0	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
-	O
1	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
+	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
-	O
1	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
j	long
+	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
H	pointer
,	O
j	long
,	O
j	long
-	O
1	int
,	O
N	int
-	O
j	long
+	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
,	O
N	int
-	O
j	long
+	O
1	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
Q	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
gsl_linalg_givens	function
(	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
)	O
,	O
gsl_matrix_get	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
j	long
+	O
2	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
j	long
-	O
1	int
,	O
0	int
,	O
top	long
+	O
j	long
+	O
2	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
H	pointer
,	O
j	long
,	O
0	int
,	O
j	long
+	O
2	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
H	pointer
,	O
j	long
-	O
1	int
,	O
0	int
,	O
j	long
+	O
2	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	function
(	O
H	pointer
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
,	O
0.0	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
j	long
-	O
1	int
,	O
0	int
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
R	pointer
,	O
j	long
,	O
0	int
,	O
j	long
+	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
R	pointer
,	O
j	long
-	O
1	int
,	O
0	int
,	O
j	long
+	O
1	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
j	long
-	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
}	O
static	O
inline	O
void	O
gen_tri_zero_H	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
H	pointer
->	O
size1	long
;	O
size_t	long
top	long
=	O
0	int
;	O
double	O
cs	double
,	O
sn	double
;	O
gsl_vector_view	struct
xv	struct
,	O
yv	struct
;	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
gsl_linalg_givens	function
(	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
,	O
gsl_matrix_get	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
N	int
-	O
1	int
,	O
0	int
,	O
top	long
+	O
N	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
N	int
-	O
2	int
,	O
0	int
,	O
top	long
+	O
N	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
H	pointer
,	O
N	int
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
H	pointer
,	O
N	int
-	O
2	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	function
(	O
H	pointer
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
,	O
0.0	int
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
N	int
-	O
1	int
,	O
0	int
,	O
top	long
+	O
N	int
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
N	int
-	O
2	int
,	O
0	int
,	O
top	long
+	O
N	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
R	pointer
,	O
N	int
-	O
1	int
,	O
0	int
,	O
N	int
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
R	pointer
,	O
N	int
-	O
2	int
,	O
0	int
,	O
N	int
-	O
1	int
)	O
;	O
}	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
N	int
-	O
1	int
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
N	int
-	O
2	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
static	O
inline	O
size_t	long
gen_search_small_elements	function
(	O
gsl_matrix	struct
*	O
H	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
,	O
int	O
*	O
flag	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
H	pointer
->	O
size1	long
;	O
int	O
k	long
;	O
size_t	long
i	long
;	O
int	O
pass1	int
=	O
0	int
;	O
int	O
pass2	int
=	O
0	int
;	O
for	O
(	O
k	long
=	O
(	O
int	O
)	O
N	int
-	O
1	int
;	O
k	long
>=	O
0	int
;	O
--	O
k	long
)	O
{	O
i	long
=	O
(	O
size_t	long
)	O
k	long
;	O
if	O
(	O
i	long
!=	O
0	int
&&	O
fabs	function
(	O
gsl_matrix_get	function
(	O
H	pointer
,	O
i	long
,	O
i	long
-	O
1	int
)	O
)	O
<=	O
w	pointer
->	O
atol	function
)	O
{	O
gsl_matrix_set	function
(	O
H	pointer
,	O
i	long
,	O
i	long
-	O
1	int
,	O
0.0	int
)	O
;	O
pass1	int
=	O
1	int
;	O
}	O
if	O
(	O
fabs	function
(	O
gsl_matrix_get	function
(	O
R	pointer
,	O
i	long
,	O
i	long
)	O
)	O
<	O
w	pointer
->	O
btol	double
)	O
{	O
gsl_matrix_set	function
(	O
R	pointer
,	O
i	long
,	O
i	long
,	O
0.0	int
)	O
;	O
pass2	int
=	O
1	int
;	O
}	O
if	O
(	O
pass1	int
&&	O
!	O
pass2	int
)	O
{	O
*	O
flag	pointer
=	O
1	int
;	O
return	O
(	O
i	long
)	O
;	O
}	O
else	O
if	O
(	O
!	O
pass1	int
&&	O
pass2	int
)	O
{	O
*	O
flag	pointer
=	O
2	int
;	O
return	O
(	O
i	long
)	O
;	O
}	O
else	O
if	O
(	O
pass1	int
&&	O
pass2	int
)	O
{	O
*	O
flag	pointer
=	O
3	int
;	O
return	O
(	O
i	long
)	O
;	O
}	O
}	O
*	O
flag	pointer
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
gen_schur_standardize1	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
double	O
*	O
alphar	pointer
,	O
double	O
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
size_t	long
i	long
;	O
size_t	long
top	long
=	O
0	int
;	O
if	O
(	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
0	int
)	O
<	O
0.0	int
)	O
{	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
A	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
top	long
;	O
++	O
i	long
)	O
gsl_matrix_set	function
(	O
w	pointer
->	O
R	pointer
,	O
i	long
,	O
top	long
,	O
-	O
gsl_matrix_get	function
(	O
w	pointer
->	O
R	pointer
,	O
i	long
,	O
top	long
)	O
)	O
;	O
}	O
else	O
gsl_matrix_set	function
(	O
B	pointer
,	O
0	int
,	O
0	int
,	O
-	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
top	long
;	O
++	O
i	long
)	O
gsl_matrix_set	function
(	O
w	pointer
->	O
H	pointer
,	O
i	long
,	O
top	long
,	O
-	O
gsl_matrix_get	function
(	O
w	pointer
->	O
H	pointer
,	O
i	long
,	O
top	long
)	O
)	O
;	O
}	O
else	O
gsl_matrix_set	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
-	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
w	pointer
->	O
size	long
;	O
++	O
i	long
)	O
gsl_matrix_set	function
(	O
w	pointer
->	O
Z	pointer
,	O
i	long
,	O
top	long
,	O
-	O
gsl_matrix_get	function
(	O
w	pointer
->	O
Z	pointer
,	O
i	long
,	O
top	long
)	O
)	O
;	O
}	O
}	O
*	O
alphar	pointer
=	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
;	O
*	O
beta	long double
=	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
gen_schur_standardize2	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_complex	struct
*	O
alpha1	pointer
,	O
gsl_complex	struct
*	O
alpha2	pointer
,	O
double	O
*	O
beta1	pointer
,	O
double	O
*	O
beta2	pointer
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
double	O
datB	array
[	O
4	int
]	O
,	O
datV	array
[	O
4	int
]	O
,	O
datS	array
[	O
2	int
]	O
,	O
work	pointer
[	O
2	int
]	O
;	O
gsl_matrix_view	struct
uv	struct
=	O
gsl_matrix_view_array	function
(	O
datB	array
,	O
2	int
,	O
2	int
)	O
;	O
gsl_matrix_view	struct
vv	struct
=	O
gsl_matrix_view_array	function
(	O
datV	array
,	O
2	int
,	O
2	int
)	O
;	O
gsl_vector_view	struct
sv	struct
=	O
gsl_vector_view_array	function
(	O
datS	array
,	O
2	int
)	O
;	O
gsl_vector_view	struct
wv	struct
=	O
gsl_vector_view_array	function
(	O
work	pointer
,	O
2	int
)	O
;	O
double	O
B11	double
,	O
B22	double
;	O
size_t	long
top	long
=	O
0	int
;	O
double	O
det	double
;	O
double	O
cr	double
,	O
sr	double
,	O
cl	double
,	O
sl	double
;	O
gsl_vector_view	struct
xv	struct
,	O
yv	struct
;	O
int	O
s	pointer
;	O
if	O
(	O
w	pointer
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
A	pointer
)	O
;	O
gsl_matrix_memcpy	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
B	pointer
)	O
;	O
gsl_linalg_SV_decomp	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
&	O
vv	struct
.	O
matrix	struct
,	O
&	O
sv	struct
.	O
vector	struct
,	O
&	O
wv	struct
.	O
vector	struct
)	O
;	O
det	double
=	O
gsl_matrix_get	function
(	O
&	O
vv	struct
.	O
matrix	struct
,	O
0	int
,	O
0	int
)	O
*	O
gsl_matrix_get	function
(	O
&	O
vv	struct
.	O
matrix	struct
,	O
1	int
,	O
1	int
)	O
-	O
gsl_matrix_get	function
(	O
&	O
vv	struct
.	O
matrix	struct
,	O
0	int
,	O
1	int
)	O
*	O
gsl_matrix_get	function
(	O
&	O
vv	struct
.	O
matrix	struct
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
det	double
<	O
0.0	int
)	O
{	O
datS	array
[	O
1	int
]	O
=	O
-	O
datS	array
[	O
1	int
]	O
;	O
}	O
cr	double
=	O
gsl_matrix_get	function
(	O
&	O
vv	struct
.	O
matrix	struct
,	O
0	int
,	O
0	int
)	O
;	O
sr	double
=	O
gsl_matrix_get	function
(	O
&	O
vv	struct
.	O
matrix	struct
,	O
1	int
,	O
0	int
)	O
;	O
det	double
=	O
gsl_matrix_get	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
0	int
,	O
0	int
)	O
*	O
gsl_matrix_get	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
1	int
,	O
1	int
)	O
-	O
gsl_matrix_get	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
0	int
,	O
1	int
)	O
*	O
gsl_matrix_get	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
det	double
<	O
0.0	int
)	O
datS	array
[	O
1	int
]	O
=	O
-	O
datS	array
[	O
1	int
]	O
;	O
cl	double
=	O
gsl_matrix_get	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
0	int
,	O
0	int
)	O
;	O
sl	double
=	O
gsl_matrix_get	function
(	O
&	O
uv	struct
.	O
matrix	struct
,	O
1	int
,	O
0	int
)	O
;	O
B11	double
=	O
gsl_vector_get	function
(	O
&	O
sv	struct
.	O
vector	struct
,	O
0	int
)	O
;	O
B22	double
=	O
gsl_vector_get	function
(	O
&	O
sv	struct
.	O
vector	struct
,	O
1	int
)	O
;	O
if	O
(	O
B11	double
<	O
0.0	int
)	O
{	O
B11	double
=	O
-	O
B11	double
;	O
B22	double
=	O
-	O
B22	double
;	O
cr	double
=	O
-	O
cr	double
;	O
sr	double
=	O
-	O
sr	double
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
,	O
top	long
,	O
w	pointer
->	O
size	long
-	O
top	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
1	int
,	O
top	long
,	O
w	pointer
->	O
size	long
-	O
top	long
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cl	double
,	O
sl	double
)	O
;	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
,	O
0	int
,	O
top	long
+	O
2	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
H	pointer
,	O
top	long
+	O
1	int
,	O
0	int
,	O
top	long
+	O
2	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
else	O
{	O
xv	struct
=	O
gsl_matrix_row	function
(	O
A	pointer
,	O
0	int
)	O
;	O
yv	struct
=	O
gsl_matrix_row	function
(	O
A	pointer
,	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cl	double
,	O
sl	double
)	O
;	O
xv	struct
=	O
gsl_matrix_column	function
(	O
A	pointer
,	O
0	int
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
A	pointer
,	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
if	O
(	O
top	long
!=	O
(	O
w	pointer
->	O
size	long
-	O
2	int
)	O
)	O
{	O
xv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
,	O
top	long
+	O
2	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
2	int
)	O
;	O
yv	struct
=	O
gsl_matrix_subrow	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
1	int
,	O
top	long
+	O
2	int
,	O
w	pointer
->	O
size	long
-	O
top	long
-	O
2	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cl	double
,	O
sl	double
)	O
;	O
}	O
if	O
(	O
top	long
!=	O
0	int
)	O
{	O
xv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
,	O
0	int
,	O
top	long
)	O
;	O
yv	struct
=	O
gsl_matrix_subcolumn	function
(	O
w	pointer
->	O
R	pointer
,	O
top	long
+	O
1	int
,	O
0	int
,	O
top	long
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
}	O
if	O
(	O
w	pointer
->	O
Q	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Q	pointer
,	O
top	long
+	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cl	double
,	O
sl	double
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
)	O
;	O
yv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
1	int
)	O
;	O
gsl_blas_drot	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
yv	struct
.	O
vector	struct
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
gsl_matrix_set	function
(	O
B	pointer
,	O
0	int
,	O
0	int
,	O
B11	double
)	O
;	O
gsl_matrix_set	function
(	O
B	pointer
,	O
0	int
,	O
1	int
,	O
0.0	int
)	O
;	O
gsl_matrix_set	function
(	O
B	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
)	O
;	O
gsl_matrix_set	function
(	O
B	pointer
,	O
1	int
,	O
1	int
,	O
B22	double
)	O
;	O
if	O
(	O
B22	double
<	O
0.0	int
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
w	pointer
->	O
compute_s	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
top	long
+	O
2	int
;	O
++	O
i	long
)	O
gsl_matrix_set	function
(	O
w	pointer
->	O
H	pointer
,	O
i	long
,	O
top	long
+	O
1	int
,	O
-	O
gsl_matrix_get	function
(	O
w	pointer
->	O
H	pointer
,	O
i	long
,	O
top	long
+	O
1	int
)	O
)	O
;	O
}	O
else	O
{	O
gsl_matrix_set	function
(	O
A	pointer
,	O
0	int
,	O
1	int
,	O
-	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
1	int
)	O
)	O
;	O
gsl_matrix_set	function
(	O
A	pointer
,	O
1	int
,	O
1	int
,	O
-	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
compute_t	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
top	long
+	O
2	int
;	O
++	O
i	long
)	O
gsl_matrix_set	function
(	O
w	pointer
->	O
R	pointer
,	O
i	long
,	O
top	long
+	O
1	int
,	O
-	O
gsl_matrix_get	function
(	O
w	pointer
->	O
R	pointer
,	O
i	long
,	O
top	long
+	O
1	int
)	O
)	O
;	O
}	O
else	O
{	O
gsl_matrix_set	function
(	O
B	pointer
,	O
0	int
,	O
1	int
,	O
-	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
1	int
)	O
)	O
;	O
gsl_matrix_set	function
(	O
B	pointer
,	O
1	int
,	O
1	int
,	O
-	O
gsl_matrix_get	function
(	O
B	pointer
,	O
1	int
,	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
xv	struct
=	O
gsl_matrix_column	function
(	O
w	pointer
->	O
Z	pointer
,	O
top	long
+	O
1	int
)	O
;	O
gsl_vector_scale	function
(	O
&	O
xv	struct
.	O
vector	struct
,	O
-	O
1.0	int
)	O
;	O
}	O
}	O
s	pointer
=	O
gen_compute_eigenvals	function
(	O
A	pointer
,	O
B	pointer
,	O
alpha1	pointer
,	O
alpha2	pointer
,	O
beta1	pointer
,	O
beta2	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
static	O
int	O
gen_compute_eigenvals	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_complex	struct
*	O
alpha1	pointer
,	O
gsl_complex	struct
*	O
alpha2	pointer
,	O
double	O
*	O
beta1	pointer
,	O
double	O
*	O
beta2	pointer
)	O
{	O
double	O
wr1	pointer
,	O
wr2	pointer
,	O
wi	pointer
,	O
scale1	pointer
,	O
scale2	pointer
;	O
double	O
s1inv	double
;	O
double	O
A11	double
,	O
A12	double
,	O
A21	double
,	O
A22	double
;	O
double	O
B11	double
,	O
B22	double
;	O
double	O
c11r	double
,	O
c11i	double
,	O
c12	double
,	O
c21	double
,	O
c22r	double
,	O
c22i	double
;	O
double	O
cz	double
,	O
cq	double
;	O
double	O
szr	double
,	O
szi	double
,	O
sqr	double
,	O
sqi	double
;	O
double	O
a1r	double
,	O
a1i	double
,	O
a2r	double
,	O
a2i	double
,	O
b1r	double
,	O
b1i	double
,	O
b1a	double
,	O
b2r	double
,	O
b2i	double
,	O
b2a	double
;	O
double	O
alphar	pointer
,	O
alphai	double
;	O
double	O
t1	double
,	O
an	double
,	O
bn	double
,	O
tempr	double
,	O
tempi	double
,	O
wabs	double
;	O
gsl_schur_gen_eigvals	function
(	O
A	pointer
,	O
B	pointer
,	O
&	O
wr1	pointer
,	O
&	O
wr2	pointer
,	O
&	O
wi	pointer
,	O
&	O
scale1	pointer
,	O
&	O
scale2	pointer
)	O
;	O
if	O
(	O
wi	pointer
==	O
0.0	int
)	O
return	O
GSL_CONTINUE	int
;	O
s1inv	double
=	O
1.0	int
/	O
scale1	pointer
;	O
A11	double
=	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
;	O
A12	double
=	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
1	int
)	O
;	O
A21	double
=	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
0	int
)	O
;	O
A22	double
=	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
1	int
)	O
;	O
B11	double
=	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
0	int
)	O
;	O
B22	double
=	O
gsl_matrix_get	function
(	O
B	pointer
,	O
1	int
,	O
1	int
)	O
;	O
c11r	double
=	O
scale1	pointer
*	O
A11	double
-	O
wr1	pointer
*	O
B11	double
;	O
c11i	double
=	O
-	O
wi	pointer
*	O
B11	double
;	O
c12	double
=	O
scale1	pointer
*	O
A12	double
;	O
c21	double
=	O
scale1	pointer
*	O
A21	double
;	O
c22r	double
=	O
scale1	pointer
*	O
A22	double
-	O
wr1	pointer
*	O
B22	double
;	O
c22i	double
=	O
-	O
wi	pointer
*	O
B22	double
;	O
if	O
(	O
fabs	function
(	O
c11r	double
)	O
+	O
fabs	function
(	O
c11i	double
)	O
+	O
fabs	function
(	O
c12	double
)	O
>	O
fabs	function
(	O
c21	double
)	O
+	O
fabs	function
(	O
c22r	double
)	O
+	O
fabs	function
(	O
c22i	double
)	O
)	O
{	O
t1	double
=	O
gsl_hypot3	function
(	O
c12	double
,	O
c11r	double
,	O
c11i	double
)	O
;	O
if	O
(	O
t1	double
!=	O
0.0	int
)	O
{	O
cz	double
=	O
c12	double
/	O
t1	double
;	O
szr	double
=	O
-	O
c11r	double
/	O
t1	double
;	O
szi	double
=	O
-	O
c11i	double
/	O
t1	double
;	O
}	O
else	O
{	O
cz	double
=	O
0.0	int
;	O
szr	double
=	O
1.0	int
;	O
szi	double
=	O
0.0	int
;	O
}	O
}	O
else	O
{	O
cz	double
=	O
hypot	function
(	O
c22r	double
,	O
c22i	double
)	O
;	O
if	O
(	O
cz	double
<=	O
GSL_DBL_MIN	int
)	O
{	O
cz	double
=	O
0.0	int
;	O
szr	double
=	O
1.0	int
;	O
szi	double
=	O
0.0	int
;	O
}	O
else	O
{	O
tempr	double
=	O
c22r	double
/	O
cz	double
;	O
tempi	double
=	O
c22i	double
/	O
cz	double
;	O
t1	double
=	O
hypot	function
(	O
cz	double
,	O
c21	double
)	O
;	O
cz	double
/=	O
t1	double
;	O
szr	double
=	O
-	O
c21	double
*	O
tempr	double
/	O
t1	double
;	O
szi	double
=	O
c21	double
*	O
tempi	double
/	O
t1	double
;	O
}	O
}	O
an	double
=	O
fabs	function
(	O
A11	double
)	O
+	O
fabs	function
(	O
A12	double
)	O
+	O
fabs	function
(	O
A21	double
)	O
+	O
fabs	function
(	O
A22	double
)	O
;	O
bn	double
=	O
fabs	function
(	O
B11	double
)	O
+	O
fabs	function
(	O
B22	double
)	O
;	O
wabs	double
=	O
fabs	function
(	O
wr1	pointer
)	O
+	O
fabs	function
(	O
wi	pointer
)	O
;	O
if	O
(	O
scale1	pointer
*	O
an	double
>	O
wabs	double
*	O
bn	double
)	O
{	O
cq	double
=	O
cz	double
*	O
B11	double
;	O
if	O
(	O
cq	double
<=	O
GSL_DBL_MIN	int
)	O
{	O
cq	double
=	O
0.0	int
;	O
sqr	double
=	O
1.0	int
;	O
sqi	double
=	O
0.0	int
;	O
}	O
else	O
{	O
sqr	double
=	O
szr	double
*	O
B22	double
;	O
sqi	double
=	O
-	O
szi	double
*	O
B22	double
;	O
}	O
}	O
else	O
{	O
a1r	double
=	O
cz	double
*	O
A11	double
+	O
szr	double
*	O
A12	double
;	O
a1i	double
=	O
szi	double
*	O
A12	double
;	O
a2r	double
=	O
cz	double
*	O
A21	double
+	O
szr	double
*	O
A22	double
;	O
a2i	double
=	O
szi	double
*	O
A22	double
;	O
cq	double
=	O
hypot	function
(	O
a1r	double
,	O
a1i	double
)	O
;	O
if	O
(	O
cq	double
<=	O
GSL_DBL_MIN	int
)	O
{	O
cq	double
=	O
0.0	int
;	O
sqr	double
=	O
1.0	int
;	O
sqi	double
=	O
0.0	int
;	O
}	O
else	O
{	O
tempr	double
=	O
a1r	double
/	O
cq	double
;	O
tempi	double
=	O
a1i	double
/	O
cq	double
;	O
sqr	double
=	O
tempr	double
*	O
a2r	double
+	O
tempi	double
*	O
a2i	double
;	O
sqi	double
=	O
tempi	double
*	O
a2r	double
-	O
tempr	double
*	O
a2i	double
;	O
}	O
}	O
t1	double
=	O
gsl_hypot3	function
(	O
cq	double
,	O
sqr	double
,	O
sqi	double
)	O
;	O
cq	double
/=	O
t1	double
;	O
sqr	double
/=	O
t1	double
;	O
sqi	double
/=	O
t1	double
;	O
tempr	double
=	O
sqr	double
*	O
szr	double
-	O
sqi	double
*	O
szi	double
;	O
tempi	double
=	O
sqr	double
*	O
szi	double
+	O
sqi	double
*	O
szr	double
;	O
b1r	double
=	O
cq	double
*	O
cz	double
*	O
B11	double
+	O
tempr	double
*	O
B22	double
;	O
b1i	double
=	O
tempi	double
*	O
B22	double
;	O
b1a	double
=	O
hypot	function
(	O
b1r	double
,	O
b1i	double
)	O
;	O
b2r	double
=	O
cq	double
*	O
cz	double
*	O
B22	double
+	O
tempr	double
*	O
B11	double
;	O
b2i	double
=	O
-	O
tempi	double
*	O
B11	double
;	O
b2a	double
=	O
hypot	function
(	O
b2r	double
,	O
b2i	double
)	O
;	O
*	O
beta1	pointer
=	O
b1a	double
;	O
*	O
beta2	pointer
=	O
b2a	double
;	O
alphar	pointer
=	O
(	O
wr1	pointer
*	O
b1a	double
)	O
*	O
s1inv	double
;	O
alphai	double
=	O
(	O
wi	pointer
*	O
b1a	double
)	O
*	O
s1inv	double
;	O
GSL_SET_COMPLEX	O
(	O
alpha1	pointer
,	O
alphar	pointer
,	O
alphai	double
)	O
;	O
alphar	pointer
=	O
(	O
wr1	pointer
*	O
b2a	double
)	O
*	O
s1inv	double
;	O
alphai	double
=	O
-	O
(	O
wi	pointer
*	O
b2a	double
)	O
*	O
s1inv	double
;	O
GSL_SET_COMPLEX	O
(	O
alpha2	pointer
,	O
alphar	pointer
,	O
alphai	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
gen_store_eigval1	function
(	O
const	O
gsl_matrix	struct
*	O
H	pointer
,	O
const	O
double	O
a	pointer
,	O
const	O
double	O
b	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
size_t	long
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
gsl_complex	struct
z	struct
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	struct
,	O
a	pointer
,	O
0.0	int
)	O
;	O
gsl_vector_complex_set	function
(	O
alpha	long double
,	O
top	long
,	O
z	struct
)	O
;	O
gsl_vector_set	function
(	O
beta	long double
,	O
top	long
,	O
b	pointer
)	O
;	O
w	pointer
->	O
n_evals	long
+=	O
1	int
;	O
w	pointer
->	O
n_iter	long
=	O
0	int
;	O
w	pointer
->	O
eshift	double
=	O
0.0	int
;	O
}	O
static	O
void	O
gen_store_eigval2	function
(	O
const	O
gsl_matrix	struct
*	O
H	pointer
,	O
const	O
gsl_complex	struct
*	O
alpha1	pointer
,	O
const	O
double	O
beta1	pointer
,	O
const	O
gsl_complex	struct
*	O
alpha2	pointer
,	O
const	O
double	O
beta2	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct
*	O
w	pointer
)	O
{	O
size_t	long
top	long
=	O
gen_get_submatrix	function
(	O
w	pointer
->	O
H	pointer
,	O
H	pointer
)	O
;	O
gsl_vector_complex_set	function
(	O
alpha	long double
,	O
top	long
,	O
*	O
alpha1	pointer
)	O
;	O
gsl_vector_set	function
(	O
beta	long double
,	O
top	long
,	O
beta1	pointer
)	O
;	O
gsl_vector_complex_set	function
(	O
alpha	long double
,	O
top	long
+	O
1	int
,	O
*	O
alpha2	pointer
)	O
;	O
gsl_vector_set	function
(	O
beta	long double
,	O
top	long
+	O
1	int
,	O
beta2	pointer
)	O
;	O
w	pointer
->	O
n_evals	long
+=	O
2	int
;	O
w	pointer
->	O
n_iter	long
=	O
0	int
;	O
w	pointer
->	O
eshift	double
=	O
0.0	int
;	O
}	O
static	O
inline	O
size_t	long
gen_get_submatrix	function
(	O
const	O
gsl_matrix	struct
*	O
A	pointer
,	O
const	O
gsl_matrix	struct
*	O
B	pointer
)	O
{	O
size_t	long
diff	long
;	O
double	O
ratio	double
;	O
size_t	long
top	long
;	O
diff	long
=	O
(	O
size_t	long
)	O
(	O
B	pointer
->	O
data	pointer
-	O
A	pointer
->	O
data	pointer
)	O
;	O
ratio	double
=	O
(	O
double	O
)	O
diff	long
/	O
(	O
(	O
double	O
)	O
(	O
A	pointer
->	O
tda	long
+	O
1	int
)	O
)	O
;	O
top	long
=	O
(	O
size_t	long
)	O
floor	function
(	O
ratio	double
)	O
;	O
return	O
top	long
;	O
}	O
inline	O
static	O
double	O
normF	function
(	O
gsl_matrix	struct
*	O
A	pointer
)	O
{	O
size_t	long
i	long
,	O
j	long
,	O
M	int
=	O
A	pointer
->	O
size1	long
,	O
N	int
=	O
A	pointer
->	O
size2	long
;	O
double	O
sum	double
=	O
0.0	int
,	O
scale	double
=	O
0.0	int
,	O
ssq	double
=	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
M	int
;	O
i	long
++	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
j	long
++	O
)	O
{	O
double	O
Aij	double
=	O
gsl_matrix_get	function
(	O
A	pointer
,	O
i	long
,	O
j	long
)	O
;	O
if	O
(	O
Aij	double
!=	O
0.0	int
)	O
{	O
double	O
ax	double
=	O
fabs	function
(	O
Aij	double
)	O
;	O
if	O
(	O
scale	double
<	O
ax	double
)	O
{	O
ssq	double
=	O
1.0	int
+	O
ssq	double
*	O
(	O
scale	double
/	O
ax	double
)	O
*	O
(	O
scale	double
/	O
ax	double
)	O
;	O
scale	double
=	O
ax	double
;	O
}	O
else	O
{	O
ssq	double
+=	O
(	O
ax	double
/	O
scale	double
)	O
*	O
(	O
ax	double
/	O
scale	double
)	O
;	O
}	O
}	O
}	O
}	O
sum	double
=	O
scale	double
*	O
sqrt	function
(	O
ssq	double
)	O
;	O
return	O
sum	double
;	O
}	O