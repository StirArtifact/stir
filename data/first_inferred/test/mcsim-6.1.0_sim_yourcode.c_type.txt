void	O
DoStep_by_Step	function
(	O
)	O
{	O
}	O
void	O
TransformPred	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PMCPREDOUT	pointer
pMCPredOut	pointer
)	O
{	O
OutspecToLinearArray	function
(	O
panal	pointer
,	O
pMCPredOut	pointer
)	O
;	O
}	O
void	O
OutspecToLinearArray	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PMCPREDOUT	pointer
pMCPredOut	pointer
)	O
{	O
POUTSPEC	pointer
pos	pointer
;	O
long	O
i	long
,	O
j	long
,	O
k	long
;	O
pMCPredOut	pointer
->	O
nbrdy	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
,	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
;	O
k	long
++	O
)	O
pMCPredOut	pointer
->	O
nbrdy	long
++	O
;	O
if	O
(	O
!	O
(	O
pMCPredOut	pointer
->	O
pred	pointer
)	O
)	O
if	O
(	O
!	O
(	O
pMCPredOut	pointer
->	O
pred	pointer
=	O
InitdVector	function
(	O
pMCPredOut	pointer
->	O
nbrdy	long
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"OutspecToLinearArray"	pointer
,	O
NULL	O
)	O
;	O
pMCPredOut	pointer
->	O
nbrdy	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
,	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
;	O
k	long
++	O
)	O
pMCPredOut	pointer
->	O
pred	pointer
[	O
pMCPredOut	pointer
->	O
nbrdy	long
++	O
]	O
=	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
j	long
]	O
[	O
k	long
]	O
;	O
}	O
double	O
Definite_Integral	function
(	O
double	O
(	O
*	O
Function	pointer
)	O
(	O
double	O
)	O
,	O
double	O
dFrom	double
,	O
double	O
dTo	double
)	O
{	O
double	O
dTotal_Area	double
,	O
dDelta_Area	double
;	O
double	O
pdArea	array
[	O
MAX_STEPS	int
+	O
2	int
]	O
,	O
pdTemp	array
[	O
MAX_STEPS	int
+	O
2	int
]	O
;	O
int	O
i	long
;	O
if	O
(	O
dFrom	double
>=	O
dTo	double
)	O
{	O
if	O
(	O
dFrom	double
==	O
dTo	double
)	O
return	O
(	O
0	int
)	O
;	O
else	O
{	O
printf	function
(	O
"\nError: inverted integration bounds in Definite_Integral - "	pointer
"Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
pdTemp	array
[	O
0	int
]	O
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
MAX_STEPS	int
;	O
i	long
++	O
)	O
{	O
pdArea	array
[	O
i	long
]	O
=	O
Trapezes	function
(	O
Function	pointer
,	O
dFrom	double
,	O
dTo	double
,	O
i	long
+	O
1	int
)	O
;	O
if	O
(	O
i	long
>=	O
MIN_STEP	int
)	O
{	O
Interpolate_Poly	function
(	O
&	O
pdTemp	array
[	O
i	long
-	O
MIN_STEP	int
]	O
,	O
&	O
pdArea	array
[	O
i	long
-	O
MIN_STEP	int
]	O
,	O
MIN_STEP	int
+	O
1	int
,	O
0.0	int
,	O
&	O
dTotal_Area	double
,	O
&	O
dDelta_Area	double
)	O
;	O
if	O
(	O
dTotal_Area	double
==	O
0	int
)	O
{	O
if	O
(	O
fabs	function
(	O
dDelta_Area	double
)	O
<	O
PRECISION	int
)	O
return	O
dTotal_Area	double
;	O
}	O
else	O
{	O
if	O
(	O
fabs	function
(	O
dDelta_Area	double
)	O
<	O
PRECISION	int
*	O
fabs	function
(	O
dTotal_Area	double
)	O
)	O
return	O
dTotal_Area	double
;	O
}	O
}	O
pdArea	array
[	O
i	long
+	O
1	int
]	O
=	O
pdArea	array
[	O
i	long
]	O
;	O
pdTemp	array
[	O
i	long
+	O
1	int
]	O
=	O
0.25	int
*	O
pdTemp	array
[	O
i	long
]	O
;	O
}	O
printf	function
(	O
"\nError: Too many steps in routine Definite_Integral "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
Interpolate_Poly	function
(	O
double	O
rgdX	array
[	O
]	O
,	O
double	O
rgdY	array
[	O
]	O
,	O
int	O
n	int
,	O
double	O
x	pointer
,	O
double	O
*	O
pdY	pointer
,	O
double	O
*	O
pdDY	pointer
)	O
{	O
int	O
i	long
,	O
j	long
,	O
nIndex	int
=	O
1	int
;	O
double	O
dDenom	double
,	O
dDiff	double
,	O
dTemp1	double
,	O
dTemp2	double
;	O
static	O
PDOUBLE	pointer
pdTerm1	pointer
=	O
NULL	O
,	O
pdTerm2	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
pdTerm1	pointer
)	O
if	O
(	O
!	O
(	O
pdTerm1	pointer
=	O
InitdVector	function
(	O
n	int
+	O
1	int
)	O
)	O
||	O
!	O
(	O
pdTerm2	pointer
=	O
InitdVector	function
(	O
n	int
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"Interpolate_Poly"	pointer
,	O
NULL	O
)	O
;	O
dDiff	double
=	O
fabs	function
(	O
x	pointer
-	O
rgdX	array
[	O
0	int
]	O
)	O
;	O
pdTerm1	pointer
[	O
0	int
]	O
=	O
rgdY	array
[	O
0	int
]	O
;	O
pdTerm2	pointer
[	O
0	int
]	O
=	O
rgdY	array
[	O
0	int
]	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
(	O
dTemp1	double
=	O
fabs	function
(	O
x	pointer
-	O
rgdX	array
[	O
i	long
]	O
)	O
)	O
<	O
dDiff	double
)	O
{	O
nIndex	int
=	O
i	long
;	O
dDiff	double
=	O
dTemp1	double
;	O
}	O
pdTerm1	pointer
[	O
i	long
]	O
=	O
rgdY	array
[	O
i	long
]	O
;	O
pdTerm2	pointer
[	O
i	long
]	O
=	O
rgdY	array
[	O
i	long
]	O
;	O
}	O
*	O
pdY	pointer
=	O
rgdY	array
[	O
nIndex	int
--	O
]	O
;	O
for	O
(	O
j	long
=	O
1	int
;	O
j	long
<	O
n	int
;	O
j	long
++	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
-	O
j	long
;	O
i	long
++	O
)	O
{	O
dTemp1	double
=	O
rgdX	array
[	O
i	long
]	O
-	O
x	pointer
;	O
dTemp2	double
=	O
rgdX	array
[	O
i	long
+	O
j	long
]	O
-	O
x	pointer
;	O
if	O
(	O
(	O
dDenom	double
=	O
dTemp1	double
-	O
dTemp2	double
)	O
==	O
0	int
)	O
{	O
printf	function
(	O
"\nError: null denominator in Interpolate_Poly - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
dDenom	double
=	O
(	O
pdTerm1	pointer
[	O
i	long
+	O
1	int
]	O
-	O
pdTerm2	pointer
[	O
i	long
]	O
)	O
/	O
dDenom	double
;	O
pdTerm2	pointer
[	O
i	long
]	O
=	O
dTemp2	double
*	O
dDenom	double
;	O
pdTerm1	pointer
[	O
i	long
]	O
=	O
dTemp1	double
*	O
dDenom	double
;	O
}	O
*	O
pdDY	pointer
=	O
(	O
2	int
*	O
(	O
nIndex	int
+	O
1	int
)	O
<	O
(	O
n	int
-	O
j	long
)	O
?	O
pdTerm1	pointer
[	O
nIndex	int
+	O
1	int
]	O
:	O
pdTerm2	pointer
[	O
nIndex	int
--	O
]	O
)	O
;	O
*	O
pdY	pointer
=	O
*	O
pdY	pointer
+	O
*	O
pdDY	pointer
;	O
}	O
}	O
double	O
Trapezes	function
(	O
double	O
(	O
*	O
Function	pointer
)	O
(	O
double	O
x	pointer
)	O
,	O
double	O
dFrom	double
,	O
double	O
dTo	double
,	O
int	O
nSteps	int
)	O
{	O
double	O
x	pointer
,	O
dSum	double
,	O
dDelta	double
;	O
static	O
double	O
dStoredArea	double
;	O
int	O
i	long
,	O
j	long
;	O
if	O
(	O
nSteps	int
==	O
1	int
)	O
{	O
return	O
(	O
dStoredArea	double
=	O
0.5	int
*	O
(	O
dTo	double
-	O
dFrom	double
)	O
*	O
(	O
(	O
*	O
Function	pointer
)	O
(	O
dFrom	double
)	O
+	O
(	O
*	O
Function	pointer
)	O
(	O
dTo	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
i	long
=	O
1	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nSteps	int
-	O
2	int
;	O
j	long
++	O
)	O
i	long
=	O
i	long
<<	O
1	int
;	O
dDelta	double
=	O
(	O
dTo	double
-	O
dFrom	double
)	O
/	O
(	O
double	O
)	O
i	long
;	O
x	pointer
=	O
dFrom	double
+	O
0.5	int
*	O
dDelta	double
;	O
dSum	double
=	O
0	int
;	O
while	O
(	O
x	pointer
<	O
dTo	double
)	O
{	O
dSum	double
=	O
dSum	double
+	O
(	O
*	O
Function	pointer
)	O
(	O
x	pointer
)	O
;	O
x	pointer
=	O
x	pointer
+	O
dDelta	double
;	O
}	O
return	O
(	O
dStoredArea	double
=	O
0.5	int
*	O
(	O
dStoredArea	double
+	O
dDelta	double
*	O
dSum	double
)	O
)	O
;	O
}	O
}	O
