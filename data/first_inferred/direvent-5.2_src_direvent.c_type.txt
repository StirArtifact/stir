const	O
char	O
*	O
program_name	pointer
;	O
const	O
char	O
*	O
conffile	pointer
=	O
DEFAULT_CONFFILE	O
;	O
int	O
foreground	int
;	O
char	O
*	O
self_test_prog	pointer
;	O
char	O
*	O
tag	pointer
;	O
int	O
facility	int
=	O
-	O
1	int
;	O
int	O
syslog_include_prio	int
;	O
int	O
debug_level	int
;	O
char	O
*	O
pidfile	pointer
=	O
NULL	O
;	O
char	O
*	O
user	pointer
=	O
NULL	O
;	O
int	O
log_to_stderr	int
=	O
LOG_DEBUG	int
;	O
const	O
char	O
*	O
severity	function
(	O
int	O
prio	int
)	O
{	O
switch	O
(	O
prio	int
)	O
{	O
case	O
LOG_EMERG	int
:	O
return	O
"EMERG"	pointer
;	O
case	O
LOG_ALERT	int
:	O
return	O
"ALERT"	pointer
;	O
case	O
LOG_CRIT	int
:	O
return	O
"CRIT"	pointer
;	O
case	O
LOG_ERR	int
:	O
return	O
"ERROR"	pointer
;	O
case	O
LOG_WARNING	int
:	O
return	O
"WARNING"	pointer
;	O
case	O
LOG_NOTICE	int
:	O
return	O
"NOTICE"	pointer
;	O
case	O
LOG_INFO	int
:	O
return	O
"INFO"	pointer
;	O
case	O
LOG_DEBUG	int
:	O
return	O
"DEBUG"	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
vdiag	function
(	O
int	O
prio	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
va_list	array
tmp	array
;	O
if	O
(	O
log_to_stderr	int
>=	O
prio	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
s	pointer
=	O
severity	function
(	O
prio	int
)	O
;	O
if	O
(	O
s	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"[%s] "	pointer
,	O
s	pointer
)	O
;	O
va_copy	O
(	O
tmp	array
,	O
ap	array
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
tmp	array
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
va_end	O
(	O
tmp	array
)	O
;	O
}	O
if	O
(	O
facility	int
>	O
0	int
)	O
{	O
if	O
(	O
syslog_include_prio	int
&&	O
(	O
s	pointer
=	O
severity	function
(	O
prio	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
static	O
char	O
*	O
fmtbuf	pointer
;	O
static	O
size_t	long
fmtsize	long
;	O
size_t	long
len	long
=	O
strlen	function
(	O
fmt	pointer
)	O
+	O
strlen	function
(	O
s	pointer
)	O
+	O
4	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
len	long
>	O
fmtsize	long
)	O
{	O
fmtbuf	pointer
=	O
erealloc	function
(	O
fmtbuf	pointer
,	O
len	long
)	O
;	O
fmtsize	long
=	O
len	long
;	O
}	O
p	pointer
=	O
fmtbuf	pointer
;	O
*	O
p	pointer
++	O
=	O
'['	O
;	O
while	O
(	O
*	O
s	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
*	O
p	pointer
++	O
=	O
']'	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
while	O
(	O
*	O
p	pointer
++	O
=	O
*	O
fmt	pointer
++	O
)	O
;	O
vsyslog	function
(	O
prio	int
,	O
fmtbuf	pointer
,	O
ap	array
)	O
;	O
}	O
else	O
vsyslog	function
(	O
prio	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
}	O
void	O
diag	function
(	O
int	O
prio	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdiag	function
(	O
prio	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
debugprt	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdiag	function
(	O
LOG_DEBUG	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
*	O
emalloc	function
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
*	O
ecalloc	function
(	O
size_t	long
nmemb	long
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	pointer
=	O
calloc	function
(	O
nmemb	long
,	O
size	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"not enough memory"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
*	O
erealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
char	O
*	O
estrdup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
char	O
*	O
p	pointer
=	O
emalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
str	pointer
,	O
len	long
)	O
;	O
p	pointer
[	O
len	long
]	O
=	O
0	int
;	O
return	O
p	pointer
;	O
}	O
char	O
*	O
mkfilename	function
(	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
tmp	array
;	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
size_t	long
fillen	long
=	O
strlen	function
(	O
file	pointer
)	O
;	O
size_t	long
len	long
;	O
if	O
(	O
!	O
file	pointer
||	O
file	pointer
[	O
0	int
]	O
==	O
0	int
)	O
return	O
strdup	function
(	O
dir	pointer
)	O
;	O
while	O
(	O
dirlen	long
>	O
0	int
&&	O
dir	pointer
[	O
dirlen	long
-	O
1	int
]	O
==	O
'/'	O
)	O
dirlen	long
--	O
;	O
len	long
=	O
dirlen	long
+	O
(	O
dir	pointer
[	O
0	int
]	O
?	O
1	int
:	O
0	int
)	O
+	O
fillen	long
;	O
tmp	array
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
tmp	array
)	O
{	O
memcpy	function
(	O
tmp	array
,	O
dir	pointer
,	O
dirlen	long
)	O
;	O
if	O
(	O
dir	pointer
[	O
0	int
]	O
)	O
tmp	array
[	O
dirlen	long
++	O
]	O
=	O
'/'	O
;	O
memcpy	function
(	O
tmp	array
+	O
dirlen	long
,	O
file	pointer
,	O
fillen	long
)	O
;	O
tmp	array
[	O
len	long
]	O
=	O
0	int
;	O
}	O
return	O
tmp	array
;	O
}	O
int	O
trans_strtotok	function
(	O
struct	O
transtab	struct
*	O
tab	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
int	O
*	O
ret	pointer
)	O
{	O
for	O
(	O
;	O
tab	pointer
->	O
name	pointer
;	O
tab	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
tab	pointer
->	O
name	pointer
,	O
str	pointer
)	O
==	O
0	int
)	O
{	O
*	O
ret	pointer
=	O
tab	pointer
->	O
tok	int
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
trans_toktostr	function
(	O
struct	O
transtab	struct
*	O
tab	pointer
,	O
int	O
tok	int
)	O
{	O
for	O
(	O
;	O
tab	pointer
->	O
name	pointer
;	O
tab	pointer
++	O
)	O
if	O
(	O
tab	pointer
->	O
tok	int
==	O
tok	int
)	O
return	O
tab	pointer
->	O
name	pointer
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
trans_toknext	function
(	O
struct	O
transtab	struct
*	O
tab	pointer
,	O
int	O
tok	int
,	O
int	O
*	O
next	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
*	O
next	pointer
;	O
tab	pointer
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
tab	pointer
[	O
i	int
]	O
.	O
tok	int
&	O
tok	int
)	O
{	O
*	O
next	pointer
=	O
i	int
+	O
1	int
;	O
return	O
tab	pointer
[	O
i	int
]	O
.	O
name	pointer
;	O
}	O
*	O
next	pointer
=	O
i	int
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
trans_tokfirst	function
(	O
struct	O
transtab	struct
*	O
tab	pointer
,	O
int	O
tok	int
,	O
int	O
*	O
next	pointer
)	O
{	O
*	O
next	pointer
=	O
0	int
;	O
return	O
trans_toknext	function
(	O
tab	pointer
,	O
tok	int
,	O
next	pointer
)	O
;	O
}	O
static	O
void	O
set_program_name	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
arg	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
program_name	pointer
=	O
p	pointer
+	O
1	int
;	O
else	O
program_name	pointer
=	O
arg	pointer
;	O
}	O
void	O
signal_setup	function
(	O
void	O
(	O
*	O
sf	pointer
)	O
(	O
int	O
)	O
)	O
{	O
static	O
int	O
sigv	pointer
[	O
]	O
=	O
{	O
SIGTERM	int
,	O
SIGQUIT	int
,	O
SIGINT	int
,	O
SIGHUP	int
,	O
SIGALRM	int
,	O
SIGUSR1	int
,	O
SIGUSR1	int
,	O
SIGCHLD	int
}	O
;	O
sigv_set_all	function
(	O
sf	pointer
,	O
NITEMS	O
(	O
sigv	pointer
)	O
,	O
sigv	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
storepid	function
(	O
const	O
char	O
*	O
pidfile	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
pidfile	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot open pidfile %s for writing: %s"	pointer
)	O
,	O
pidfile	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
getpid	function
(	O
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
}	O
static	O
int	O
membergid	function
(	O
gid_t	int
gid	int
,	O
size_t	long
gc	long
,	O
gid_t	int
*	O
gv	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gc	long
;	O
i	int
++	O
)	O
if	O
(	O
gv	pointer
[	O
i	int
]	O
==	O
gid	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_user_groups	function
(	O
uid_t	int
uid	int
,	O
size_t	long
*	O
pgidc	pointer
,	O
gid_t	int
*	O
*	O
pgidv	pointer
)	O
{	O
size_t	long
gidc	long
=	O
0	int
,	O
n	long
=	O
0	int
;	O
gid_t	int
*	O
gidv	pointer
=	O
NULL	O
;	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
struct	O
group	struct
*	O
gr	pointer
;	O
pw	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pw	pointer
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
0	int
,	O
_	O
(	O
"no user with UID %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
n	long
=	O
32	int
;	O
gidv	pointer
=	O
ecalloc	function
(	O
n	long
,	O
sizeof	O
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
gidv	pointer
[	O
0	int
]	O
=	O
pw	pointer
->	O
pw_gid	int
;	O
gidc	long
=	O
1	int
;	O
setgrent	function
(	O
)	O
;	O
while	O
(	O
gr	pointer
=	O
getgrent	function
(	O
)	O
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
gr	pointer
->	O
gr_mem	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
*	O
p	pointer
,	O
pw	pointer
->	O
pw_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
gidc	long
)	O
{	O
n	long
+=	O
32	int
;	O
gidv	pointer
=	O
erealloc	function
(	O
gidv	pointer
,	O
n	long
*	O
sizeof	O
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
membergid	function
(	O
gr	pointer
->	O
gr_gid	int
,	O
gidc	long
,	O
gidv	pointer
)	O
)	O
gidv	pointer
[	O
gidc	long
++	O
]	O
=	O
gr	pointer
->	O
gr_gid	int
;	O
}	O
}	O
endgrent	function
(	O
)	O
;	O
*	O
pgidc	pointer
=	O
gidc	long
;	O
*	O
pgidv	pointer
=	O
gidv	pointer
;	O
}	O
void	O
setuser	function
(	O
const	O
char	O
*	O
user	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
size_t	long
gidc	long
;	O
gid_t	int
*	O
gidv	pointer
;	O
pw	pointer
=	O
getpwnam	function
(	O
user	pointer
)	O
;	O
if	O
(	O
!	O
pw	pointer
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"getpwnam(%s): %s"	pointer
,	O
user	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
pw	pointer
->	O
pw_uid	int
==	O
0	int
)	O
return	O
;	O
get_user_groups	function
(	O
pw	pointer
->	O
pw_uid	int
,	O
&	O
gidc	long
,	O
&	O
gidv	pointer
)	O
;	O
if	O
(	O
setgroups	function
(	O
gidc	long
,	O
gidv	pointer
)	O
<	O
0	int
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"setgroups: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
free	function
(	O
gidv	pointer
)	O
;	O
if	O
(	O
setgid	function
(	O
pw	pointer
->	O
pw_gid	int
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"setgid(%lu): %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
pw	pointer
->	O
pw_gid	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
setuid	function
(	O
pw	pointer
->	O
pw_uid	int
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"setuid(%lu): %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
pw	pointer
->	O
pw_uid	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
}	O
void	O
ev_log	function
(	O
int	O
flags	int
,	O
struct	O
watchpoint	struct
*	O
dp	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
debug_level	int
>	O
0	int
)	O
{	O
for	O
(	O
p	pointer
=	O
trans_tokfirst	function
(	O
sysev_transtab	array
,	O
flags	int
,	O
&	O
i	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
trans_toknext	function
(	O
sysev_transtab	array
,	O
flags	int
,	O
&	O
i	int
)	O
)	O
debug	O
(	O
1	int
,	O
(	O
"%s: %s"	pointer
,	O
dp	pointer
->	O
dirname	pointer
,	O
p	pointer
)	O
)	O
;	O
}	O
}	O
void	O
genev_init	function
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
genev_xlat	array
[	O
i	int
]	O
.	O
gen_mask	int
;	O
i	int
++	O
)	O
defevt	function
(	O
trans_toktostr	function
(	O
genev_transtab	array
,	O
genev_xlat	array
[	O
i	int
]	O
.	O
gen_mask	int
)	O
,	O
&	O
genev_xlat	array
[	O
i	int
]	O
,	O
0	int
)	O
;	O
}	O
int	O
signo	int
=	O
0	int
;	O
int	O
stop	int
=	O
0	int
;	O
pid_t	int
self_test_pid	int
;	O
int	O
exit_code	int
=	O
0	int
;	O
void	O
sigmain	function
(	O
int	O
sig	int
)	O
{	O
signo	int
=	O
sig	int
;	O
switch	O
(	O
signo	int
)	O
{	O
case	O
SIGCHLD	int
:	O
case	O
SIGALRM	int
:	O
break	O
;	O
default	O
:	O
stop	int
=	O
1	int
;	O
}	O
}	O
void	O
self_test	function
(	O
)	O
{	O
pid_t	int
pid	int
;	O
char	O
*	O
args	array
[	O
4	int
]	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"cannot run `%s': fork failed: %s"	pointer
)	O
,	O
self_test_prog	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
pid	int
!=	O
0	int
)	O
{	O
self_test_pid	int
=	O
pid	int
;	O
return	O
;	O
}	O
args	array
[	O
0	int
]	O
=	O
"/bin/sh"	pointer
;	O
args	array
[	O
1	int
]	O
=	O
"-c"	pointer
;	O
args	array
[	O
2	int
]	O
=	O
self_test_prog	pointer
;	O
args	array
[	O
3	int
]	O
=	O
NULL	O
;	O
execv	function
(	O
args	array
[	O
0	int
]	O
,	O
args	array
)	O
;	O
diag	function
(	O
LOG_ERR	int
,	O
"execv: %s: %s"	pointer
,	O
self_test_prog	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
static	O
int	O
opt_debug_level	int
=	O
0	int
;	O
static	O
int	O
opt_foreground	int
=	O
0	int
;	O
static	O
char	O
*	O
opt_pidfile	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
opt_user	pointer
=	O
NULL	O
;	O
static	O
int	O
opt_facility	int
=	O
-	O
1	int
;	O
static	O
int	O
lint_only	int
=	O
0	int
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
tag	pointer
=	O
estrdup	function
(	O
program_name	pointer
)	O
;	O
genev_init	function
(	O
)	O
;	O
config_init	function
(	O
)	O
;	O
parse_options	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
i	int
)	O
;	O
argc	int
-=	O
i	int
;	O
argv	pointer
+=	O
i	int
;	O
switch	O
(	O
argc	int
)	O
{	O
default	O
:	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
1	int
:	O
conffile	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
}	O
config_parse	function
(	O
conffile	pointer
)	O
;	O
if	O
(	O
lint_only	int
)	O
return	O
0	int
;	O
if	O
(	O
opt_debug_level	int
)	O
debug_level	int
+=	O
opt_debug_level	int
;	O
if	O
(	O
opt_foreground	int
)	O
foreground	int
=	O
opt_foreground	int
;	O
if	O
(	O
opt_pidfile	pointer
)	O
pidfile	pointer
=	O
opt_pidfile	pointer
;	O
if	O
(	O
opt_facility	int
!=	O
-	O
1	int
)	O
facility	int
=	O
opt_facility	int
;	O
if	O
(	O
!	O
foreground	int
&&	O
facility	int
<=	O
0	int
)	O
facility	int
=	O
LOG_DAEMON	O
;	O
if	O
(	O
opt_user	pointer
)	O
user	pointer
=	O
opt_user	pointer
;	O
if	O
(	O
facility	int
>	O
0	int
)	O
{	O
openlog	function
(	O
tag	pointer
,	O
LOG_PID	int
,	O
facility	int
)	O
;	O
grecs_log_to_stderr	int
=	O
0	int
;	O
}	O
if	O
(	O
foreground	int
)	O
setup_watchers	function
(	O
)	O
;	O
else	O
{	O
if	O
(	O
detach	function
(	O
setup_watchers	function
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"daemon: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
log_to_stderr	int
=	O
-	O
1	int
;	O
}	O
diag	function
(	O
LOG_INFO	int
,	O
_	O
(	O
"%s %s started"	pointer
)	O
,	O
program_name	pointer
,	O
VERSION	pointer
)	O
;	O
if	O
(	O
pidfile	pointer
)	O
storepid	function
(	O
pidfile	pointer
)	O
;	O
if	O
(	O
user	pointer
&&	O
getuid	function
(	O
)	O
==	O
0	int
)	O
setuser	function
(	O
user	pointer
)	O
;	O
signal_setup	function
(	O
sigmain	function
)	O
;	O
if	O
(	O
self_test_prog	pointer
)	O
self_test	function
(	O
)	O
;	O
while	O
(	O
!	O
stop	int
&&	O
sysev_select	function
(	O
)	O
==	O
0	int
)	O
{	O
process_timeouts	function
(	O
)	O
;	O
process_cleanup	function
(	O
0	int
)	O
;	O
watchpoint_gc	function
(	O
)	O
;	O
}	O
shutdown_watchers	function
(	O
)	O
;	O
diag	function
(	O
LOG_INFO	int
,	O
_	O
(	O
"%s %s stopped"	pointer
)	O
,	O
program_name	pointer
,	O
VERSION	pointer
)	O
;	O
if	O
(	O
pidfile	pointer
)	O
unlink	function
(	O
pidfile	pointer
)	O
;	O
return	O
exit_code	int
;	O
}	O
