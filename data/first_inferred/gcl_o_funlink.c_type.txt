static	O
int	O
clean_link_array	function
(	O
object	function
*	O
,	O
object	function
*	O
)	O
;	O
object	function
sScdefn	int
;	O
typedef	O
object	function
(	O
*	O
object_func	pointer
)	O
(	O
)	O
;	O
static	O
int	O
vpush_extend	function
(	O
void	O
*	O
,	O
object	function
)	O
;	O
object	function
sLAlink_arrayA	function
;	O
int	O
Rset	int
=	O
0	int
;	O
DEFVAR	function
(	O
"*LINK-LIST*"	pointer
,	O
sSAlink_listA	O
,	O
SI	O
,	O
0	int
,	O
""	pointer
)	O
;	O
static	O
inline	O
void	O
append_link_list	function
(	O
object	function
sym	function
,	O
int	O
n	int
)	O
{	O
object	function
x	function
;	O
int	O
i	int
;	O
if	O
(	O
!	O
Rset	int
||	O
!	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
)	O
return	O
;	O
for	O
(	O
x	function
=	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
;	O
x	function
!=	O
Cnil	O
&&	O
x	function
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
!=	O
sym	function
;	O
x	function
=	O
x	function
->	O
c	O
.	O
c_cdr	O
)	O
;	O
if	O
(	O
x	function
==	O
Cnil	O
)	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
=	O
MMcons	function
(	O
(	O
x	function
=	O
list	function
(	O
7	int
,	O
sym	function
,	O
make_fixnum	function
(	O
0	int
)	O
,	O
make_fixnum	function
(	O
0	int
)	O
,	O
make_fixnum	function
(	O
0	int
)	O
,	O
make_fixnum	function
(	O
0	int
)	O
,	O
make_fixnum	function
(	O
0	int
)	O
,	O
make_fixnum	function
(	O
0	int
)	O
)	O
)	O
,	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
)	O
;	O
else	O
x	function
=	O
x	function
->	O
c	O
.	O
c_car	O
;	O
x	function
=	O
x	function
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
listp	function
(	O
sym	function
->	O
s	O
.	O
s_gfdef	O
)	O
)	O
x	function
->	O
c	O
.	O
c_car	O
=	O
one_plus	function
(	O
x	function
->	O
c	O
.	O
c_car	O
)	O
;	O
for	O
(	O
x	function
=	O
x	function
->	O
c	O
.	O
c_cdr	O
,	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
,	O
x	function
=	O
x	function
->	O
c	O
.	O
c_cdr	O
)	O
;	O
x	function
->	O
c	O
.	O
c_car	O
=	O
one_plus	function
(	O
x	function
->	O
c	O
.	O
c_car	O
)	O
;	O
}	O
void	O
call_or_link	function
(	O
object	function
sym	function
,	O
void	O
*	O
*	O
link	pointer
)	O
{	O
object	function
fun	function
;	O
fun	function
=	O
sym	function
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	function
==	O
OBJNULL	O
)	O
{	O
FEinvalid_function	function
(	O
sym	function
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_cclosure	O
&&	O
(	O
fun	function
->	O
cc	O
.	O
cc_turbo	O
)	O
)	O
{	O
if	O
(	O
Rset	int
==	O
0	int
)	O
MMccall	function
(	O
fun	function
)	O
;	O
else	O
fun	function
->	O
cf	O
.	O
cf_self	O
(	O
fun	function
)	O
;	O
return	O
;	O
}	O
if	O
(	O
Rset	int
==	O
0	int
)	O
funcall	function
(	O
fun	function
)	O
;	O
else	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_cfun	O
)	O
{	O
(	O
void	O
)	O
vpush_extend	function
(	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	function
(	O
*	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	pointer
=	O
(	O
void	O
*	O
)	O
(	O
fun	function
->	O
cf	O
.	O
cf_self	O
)	O
;	O
(	O
*	O
(	O
void	O
(	O
*	O
)	O
(	O
)	O
)	O
(	O
fun	function
->	O
cf	O
.	O
cf_self	O
)	O
)	O
(	O
)	O
;	O
}	O
else	O
{	O
append_link_list	function
(	O
sym	function
,	O
0	int
)	O
;	O
funcall	function
(	O
fun	function
)	O
;	O
}	O
}	O
void	O
call_or_link_closure	function
(	O
object	function
sym	function
,	O
void	O
*	O
*	O
link	pointer
,	O
void	O
*	O
*	O
ptr	pointer
)	O
{	O
object	function
fun	function
;	O
fun	function
=	O
sym	function
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	function
==	O
OBJNULL	O
)	O
{	O
FEinvalid_function	function
(	O
sym	function
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_cclosure	O
&&	O
(	O
fun	function
->	O
cc	O
.	O
cc_turbo	O
)	O
)	O
{	O
if	O
(	O
Rset	int
)	O
{	O
(	O
void	O
)	O
vpush_extend	function
(	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	function
(	O
*	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
ptr	pointer
=	O
(	O
void	O
*	O
)	O
fun	function
;	O
*	O
link	pointer
=	O
(	O
void	O
*	O
)	O
(	O
fun	function
->	O
cf	O
.	O
cf_self	O
)	O
;	O
MMccall	function
(	O
fun	function
)	O
;	O
}	O
else	O
{	O
append_link_list	function
(	O
sym	function
,	O
1	int
)	O
;	O
MMccall	function
(	O
fun	function
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
Rset	int
==	O
0	int
)	O
funcall	function
(	O
fun	function
)	O
;	O
else	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_cfun	O
)	O
{	O
(	O
void	O
)	O
vpush_extend	function
(	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	function
(	O
*	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	pointer
=	O
(	O
void	O
*	O
)	O
fun	function
->	O
cf	O
.	O
cf_self	O
;	O
(	O
*	O
(	O
void	O
(	O
*	O
)	O
(	O
)	O
)	O
fun	function
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
}	O
else	O
{	O
append_link_list	function
(	O
sym	function
,	O
2	int
)	O
;	O
funcall	function
(	O
fun	function
)	O
;	O
}	O
}	O
static	O
int	O
vpush_extend	function
(	O
void	O
*	O
item	pointer
,	O
object	function
ar	function
)	O
{	O
register	O
int	O
ind	int
=	O
ar	function
->	O
ust	O
.	O
ust_fillp	O
;	O
AGAIN	O
:	O
if	O
(	O
ind	int
<	O
ar	function
->	O
ust	O
.	O
ust_dim	O
)	O
{	O
SET_ITEM	O
(	O
ar	function
,	O
ind	int
,	O
item	pointer
)	O
;	O
ind	int
+=	O
sizeof	O
(	O
void	O
*	O
)	O
;	O
return	O
(	O
ar	function
->	O
v	O
.	O
v_fillp	O
=	O
ind	int
)	O
;	O
}	O
else	O
{	O
int	O
newdim	int
=	O
ROUND_UP_PTR	function
(	O
(	O
2	int
+	O
(	O
int	O
)	O
(	O
1.3	int
*	O
ind	int
)	O
)	O
)	O
;	O
unsigned	O
char	O
*	O
newself	pointer
;	O
newself	pointer
=	O
(	O
void	O
*	O
)	O
alloc_relblock	function
(	O
newdim	int
)	O
;	O
bcopy	function
(	O
ar	function
->	O
ust	O
.	O
ust_self	O
,	O
newself	pointer
,	O
ind	int
)	O
;	O
ar	function
->	O
ust	O
.	O
ust_dim	O
=	O
newdim	int
;	O
ar	function
->	O
ust	O
.	O
ust_self	O
=	O
newself	pointer
;	O
goto	O
AGAIN	O
;	O
}	O
}	O
static	O
int	O
number_unlinked	int
=	O
0	int
;	O
static	O
void	O
delete_link	function
(	O
void	O
*	O
address	pointer
,	O
object	function
link_ar	function
)	O
{	O
object	function
*	O
ar	function
,	O
*	O
ar_end	pointer
,	O
*	O
p	pointer
;	O
p	pointer
=	O
0	int
;	O
ar	function
=	O
link_ar	function
->	O
v	O
.	O
v_self	O
;	O
ar_end	pointer
=	O
(	O
object	function
*	O
)	O
&	O
(	O
link_ar	function
->	O
ust	O
.	O
ust_self	O
[	O
link_ar	function
->	O
v	O
.	O
v_fillp	O
]	O
)	O
;	O
while	O
(	O
ar	function
<	O
ar_end	pointer
)	O
{	O
if	O
(	O
*	O
ar	function
&&	O
*	O
(	O
(	O
void	O
*	O
*	O
)	O
*	O
ar	function
)	O
==	O
address	pointer
)	O
{	O
p	pointer
=	O
(	O
object	function
*	O
)	O
*	O
ar	function
;	O
*	O
ar	function
=	O
0	int
;	O
*	O
p	pointer
=	O
*	O
(	O
ar	function
+	O
1	int
)	O
;	O
number_unlinked	int
++	O
;	O
}	O
ar	function
=	O
ar	function
+	O
2	int
;	O
}	O
if	O
(	O
number_unlinked	int
>	O
40	int
)	O
link_ar	function
->	O
v	O
.	O
v_fillp	O
=	O
clean_link_array	function
(	O
link_ar	function
->	O
v	O
.	O
v_self	O
,	O
ar_end	pointer
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"USE-FAST-LINKS"	pointer
,	O
object	function
,	O
fSuse_fast_links	O
,	O
SI	O
,	O
1	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	function
flag	function
,	O
...	O
)	O
,	O
"Usage: (use-fast-links {nil,t} &optional fun) turns on or off the fast linking depending on FLAG, so that things will either go faster, or turns it off so that stack information is kept.  If SYMBOL is supplied and FLAG is nil, then this function is deleted from the fast links"	pointer
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	function
sym	function
;	O
va_list	O
ap	O
;	O
object	function
*	O
p	pointer
,	O
*	O
ar	function
,	O
*	O
ar_end	pointer
;	O
object	function
link_ar	function
;	O
object	function
fun	function
=	O
Cnil	O
;	O
{	O
va_start	O
(	O
ap	O
,	O
flag	function
)	O
;	O
if	O
(	O
n	int
>=	O
2	int
)	O
sym	function
=	O
va_arg	function
(	O
ap	O
,	O
object	function
)	O
;	O
else	O
goto	O
LDEFAULT2	O
;	O
goto	O
LEND_VARARG	O
;	O
LDEFAULT2	O
:	O
sym	function
=	O
Cnil	O
;	O
LEND_VARARG	O
:	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
if	O
(	O
sLAlink_arrayA	function
==	O
0	int
)	O
RETURN1	function
(	O
Cnil	O
)	O
;	O
link_ar	function
=	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
;	O
if	O
(	O
link_ar	function
==	O
Cnil	O
&&	O
flag	function
==	O
Cnil	O
)	O
RETURN1	function
(	O
Cnil	O
)	O
;	O
check_type_array	function
(	O
&	O
link_ar	function
)	O
;	O
if	O
(	O
type_of	function
(	O
link_ar	function
)	O
!=	O
t_string	O
)	O
{	O
FEerror	function
(	O
"*LINK-ARRAY* must be a string"	pointer
,	O
0	int
)	O
;	O
}	O
ar	function
=	O
link_ar	function
->	O
v	O
.	O
v_self	O
;	O
ar_end	pointer
=	O
(	O
object	function
*	O
)	O
&	O
(	O
link_ar	function
->	O
ust	O
.	O
ust_self	O
[	O
link_ar	function
->	O
v	O
.	O
v_fillp	O
]	O
)	O
;	O
switch	O
(	O
n	int
)	O
{	O
case	O
1	int
:	O
if	O
(	O
flag	function
==	O
Cnil	O
)	O
{	O
Rset	int
=	O
0	int
;	O
while	O
(	O
ar	function
<	O
ar_end	pointer
)	O
{	O
p	pointer
=	O
(	O
object	function
*	O
)	O
*	O
ar	function
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
(	O
ar	function
++	O
,	O
*	O
ar	function
)	O
;	O
else	O
ar	function
++	O
;	O
ar	function
++	O
;	O
}	O
link_ar	function
->	O
v	O
.	O
v_fillp	O
=	O
0	int
;	O
}	O
else	O
{	O
Rset	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
type_of	function
(	O
sym	function
)	O
==	O
t_symbol	O
)	O
)	O
fun	function
=	O
sym	function
->	O
s	O
.	O
s_gfdef	O
;	O
else	O
if	O
(	O
type_of	function
(	O
sym	function
)	O
==	O
t_cclosure	O
)	O
fun	function
=	O
sym	function
;	O
else	O
{	O
FEerror	function
(	O
"Second arg: ~a must be symbol or closure"	pointer
,	O
0	int
,	O
sym	function
)	O
;	O
}	O
if	O
(	O
Rset	int
)	O
{	O
if	O
(	O
!	O
fun	function
)	O
RETURN1	function
(	O
Cnil	O
)	O
;	O
switch	O
(	O
type_of	function
(	O
fun	function
)	O
)	O
{	O
case	O
t_cfun	O
:	O
case	O
t_sfun	O
:	O
case	O
t_vfun	O
:	O
case	O
t_gfun	O
:	O
case	O
t_cclosure	O
:	O
case	O
t_closure	O
:	O
case	O
t_afun	O
:	O
delete_link	function
(	O
fun	function
->	O
cf	O
.	O
cf_self	O
,	O
link_ar	function
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"Usage: (use-fast-links {nil,t} &optional fun)"	pointer
,	O
0	int
)	O
;	O
}	O
RETURN1	function
(	O
Cnil	O
)	O
;	O
}	O
object	function
fSuse_fast_links_2	function
(	O
object	function
flag	function
,	O
object	function
res	function
)	O
{	O
VFUN_NARGS	O
=	O
2	int
;	O
return	O
FFN	function
(	O
fSuse_fast_links	O
)	O
(	O
flag	function
,	O
res	function
)	O
;	O
}	O
object	function
clear_compiler_properties	function
(	O
object	function
sym	function
,	O
object	function
code	function
)	O
{	O
object	function
tem	function
;	O
extern	O
object	function
sSclear_compiler_properties	function
;	O
if	O
(	O
sSclear_compiler_properties	function
&&	O
sSclear_compiler_properties	function
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
)	O
if	O
(	O
(	O
sSAinhibit_macro_specialA	O
&&	O
sSAinhibit_macro_specialA	O
->	O
s	O
.	O
s_dbind	O
!=	O
Cnil	O
)	O
||	O
sym	function
->	O
s	O
.	O
s_sfdef	O
==	O
NOT_SPECIAL	O
)	O
(	O
void	O
)	O
ifuncall2	function
(	O
sSclear_compiler_properties	function
,	O
sym	function
,	O
code	function
)	O
;	O
tem	function
=	O
getf	function
(	O
sym	function
->	O
s	O
.	O
s_plist	O
,	O
sStraced	O
,	O
Cnil	O
)	O
;	O
VFUN_NARGS	O
=	O
2	int
;	O
FFN	function
(	O
fSuse_fast_links	O
)	O
(	O
Cnil	O
,	O
sym	function
)	O
;	O
return	O
tem	function
!=	O
Cnil	O
?	O
tem	function
:	O
sym	function
;	O
}	O
static	O
int	O
clean_link_array	function
(	O
object	function
*	O
ar	function
,	O
object	function
*	O
ar_end	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
object	function
*	O
orig	pointer
;	O
orig	pointer
=	O
ar	function
;	O
number_unlinked	int
=	O
0	int
;	O
while	O
(	O
ar	function
<	O
ar_end	pointer
)	O
{	O
if	O
(	O
*	O
ar	function
)	O
{	O
orig	pointer
[	O
i	int
++	O
]	O
=	O
*	O
ar	function
++	O
;	O
orig	pointer
[	O
i	int
++	O
]	O
=	O
*	O
ar	function
++	O
;	O
}	O
else	O
ar	function
=	O
ar	function
+	O
2	int
;	O
}	O
return	O
(	O
i	int
*	O
sizeof	O
(	O
object	function
*	O
)	O
)	O
;	O
}	O
static	O
object	function
call_proc	function
(	O
object	function
sym	function
,	O
void	O
*	O
*	O
link	pointer
,	O
int	O
argd	int
,	O
va_list	O
ll	int
)	O
{	O
object	function
fun	function
;	O
int	O
nargs	int
;	O
check_type_sym	function
(	O
&	O
sym	function
)	O
;	O
fun	function
=	O
sym	function
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	function
&&	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_sfun	O
||	O
type_of	function
(	O
fun	function
)	O
==	O
t_gfun	O
||	O
type_of	function
(	O
fun	function
)	O
==	O
t_afun	O
||	O
type_of	function
(	O
fun	function
)	O
==	O
t_vfun	O
)	O
&&	O
Rset	int
)	O
{	O
object	function
(	O
*	O
fn	pointer
)	O
(	O
)	O
=	O
fun	function
->	O
sfn	O
.	O
sfn_self	O
;	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_vfun	O
)	O
{	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
fun	function
->	O
vfn	O
.	O
vfn_minargs	O
||	O
nargs	int
>	O
fun	function
->	O
vfn	O
.	O
vfn_maxargs	O
||	O
(	O
argd	int
&	O
(	O
SFUN_ARG_TYPE_MASK	O
|	O
SFUN_RETURN_MASK	O
)	O
)	O
)	O
goto	O
WRONG_ARGS	O
;	O
if	O
(	O
(	O
VFUN_NARG_BIT	O
&	O
argd	int
)	O
==	O
0	int
)	O
{	O
VFUN_NARGS	O
=	O
nargs	int
;	O
goto	O
AFTER_LINK	O
;	O
}	O
}	O
else	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_afun	O
)	O
{	O
ufixnum	O
at	O
=	O
F_TYPES	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
>>	O
F_TYPE_WIDTH	O
;	O
ufixnum	O
ma	O
=	O
F_MIN_ARGS	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
xa	O
=	O
F_MAX_ARGS	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
rt	O
=	O
F_RESULT_TYPE	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
ma	O
||	O
nargs	int
>	O
xa	O
||	O
(	O
(	O
argd	int
>>	O
8	int
)	O
&	O
0x3	int
)	O
!=	O
rt	O
||	O
(	O
argd	int
>>	O
12	int
)	O
!=	O
at	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
else	O
{	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
if	O
(	O
(	O
argd	int
&	O
(	O
~	O
VFUN_NARG_BIT	O
)	O
)	O
!=	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
(	O
void	O
)	O
vpush_extend	function
(	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	function
(	O
*	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	pointer
=	O
(	O
void	O
*	O
)	O
fn	pointer
;	O
AFTER_LINK	O
:	O
{	O
object	function
*	O
new	pointer
;	O
COERCE_VA_LIST	function
(	O
new	pointer
,	O
ll	int
,	O
nargs	int
)	O
;	O
return	O
(	O
c_apply_n_fun	function
(	O
fun	function
,	O
nargs	int
,	O
new	pointer
)	O
)	O
;	O
}	O
}	O
else	O
WRONG_ARGS	O
:	O
{	O
object	function
fun	function
;	O
register	O
object	function
*	O
base	pointer
;	O
enum	O
ftype	O
result_type	enum
;	O
int	O
i	int
;	O
append_link_list	function
(	O
sym	function
,	O
3	int
)	O
;	O
fun	function
=	O
type_of	function
(	O
sym	function
)	O
==	O
t_symbol	O
?	O
symbol_function	function
(	O
sym	function
)	O
:	O
sym	function
;	O
vs_base	O
=	O
base	pointer
=	O
vs_top	O
;	O
if	O
(	O
fun	function
==	O
OBJNULL	O
)	O
FEinvalid_function	function
(	O
sym	function
)	O
;	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
result_type	enum
=	O
SFUN_RETURN_TYPE	function
(	O
argd	int
)	O
;	O
SFUN_START_ARG_TYPES	function
(	O
argd	int
)	O
;	O
if	O
(	O
argd	int
==	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
vs_push	function
(	O
va_arg	function
(	O
ll	int
,	O
object	function
)	O
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
vs_push	function
(	O
(	O
(	O
SFUN_NEXT_TYPE	function
(	O
argd	int
)	O
)	O
==	O
f_object	O
?	O
va_arg	function
(	O
ll	int
,	O
object	function
)	O
:	O
make_fixnum	function
(	O
va_arg	function
(	O
ll	int
,	O
fixnum	O
)	O
)	O
)	O
)	O
;	O
vs_check	O
;	O
funcall	function
(	O
fun	function
)	O
;	O
vs_top	O
=	O
base	pointer
;	O
return	O
(	O
(	O
result_type	enum
==	O
f_object	O
?	O
vs_base	O
[	O
0	int
]	O
:	O
(	O
object	function
)	O
fix	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
)	O
;	O
}	O
}	O
object	function
call_proc_new	function
(	O
object	function
sym	function
,	O
void	O
*	O
*	O
link	pointer
,	O
int	O
argd	int
,	O
object	function
first	function
,	O
va_list	O
ll	int
)	O
{	O
object	function
fun	function
;	O
int	O
nargs	int
;	O
check_type_sym	function
(	O
&	O
sym	function
)	O
;	O
fun	function
=	O
sym	function
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	function
&&	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_sfun	O
||	O
type_of	function
(	O
fun	function
)	O
==	O
t_gfun	O
||	O
type_of	function
(	O
fun	function
)	O
==	O
t_afun	O
||	O
type_of	function
(	O
fun	function
)	O
==	O
t_vfun	O
)	O
&&	O
Rset	int
)	O
{	O
object	function
(	O
*	O
fn	pointer
)	O
(	O
)	O
=	O
fun	function
->	O
sfn	O
.	O
sfn_self	O
;	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_vfun	O
)	O
{	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
fun	function
->	O
vfn	O
.	O
vfn_minargs	O
||	O
nargs	int
>	O
fun	function
->	O
vfn	O
.	O
vfn_maxargs	O
||	O
(	O
argd	int
&	O
(	O
SFUN_ARG_TYPE_MASK	O
|	O
SFUN_RETURN_MASK	O
)	O
)	O
)	O
goto	O
WRONG_ARGS	O
;	O
if	O
(	O
(	O
VFUN_NARG_BIT	O
&	O
argd	int
)	O
==	O
0	int
)	O
{	O
VFUN_NARGS	O
=	O
nargs	int
;	O
goto	O
AFTER_LINK	O
;	O
}	O
}	O
else	O
if	O
(	O
type_of	function
(	O
fun	function
)	O
==	O
t_afun	O
)	O
{	O
ufixnum	O
at	O
=	O
F_TYPES	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
>>	O
F_TYPE_WIDTH	O
;	O
ufixnum	O
ma	O
=	O
F_MIN_ARGS	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
xa	O
=	O
F_MAX_ARGS	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
rt	O
=	O
F_RESULT_TYPE	O
(	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
ma	O
||	O
nargs	int
>	O
xa	O
||	O
(	O
(	O
argd	int
>>	O
8	int
)	O
&	O
0x3	int
)	O
!=	O
rt	O
||	O
(	O
argd	int
>>	O
12	int
)	O
!=	O
at	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
else	O
{	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
if	O
(	O
(	O
argd	int
&	O
(	O
~	O
VFUN_NARG_BIT	O
)	O
)	O
!=	O
fun	function
->	O
sfn	O
.	O
sfn_argd	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
(	O
void	O
)	O
vpush_extend	function
(	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	function
(	O
*	O
link	pointer
,	O
sLAlink_arrayA	function
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	pointer
=	O
(	O
void	O
*	O
)	O
fn	pointer
;	O
AFTER_LINK	O
:	O
{	O
object	function
*	O
new	pointer
;	O
COERCE_VA_LIST_NEW	function
(	O
new	pointer
,	O
first	function
,	O
ll	int
,	O
nargs	int
)	O
;	O
return	O
(	O
c_apply_n_fun	function
(	O
fun	function
,	O
nargs	int
,	O
new	pointer
)	O
)	O
;	O
}	O
}	O
else	O
WRONG_ARGS	O
:	O
{	O
object	function
fun	function
;	O
register	O
object	function
*	O
base	pointer
;	O
enum	O
ftype	O
result_type	enum
;	O
int	O
i	int
;	O
append_link_list	function
(	O
sym	function
,	O
4	int
)	O
;	O
fun	function
=	O
type_of	function
(	O
sym	function
)	O
==	O
t_symbol	O
?	O
symbol_function	function
(	O
sym	function
)	O
:	O
sym	function
;	O
vs_base	O
=	O
base	pointer
=	O
vs_top	O
;	O
if	O
(	O
fun	function
==	O
OBJNULL	O
)	O
FEinvalid_function	function
(	O
sym	function
)	O
;	O
nargs	int
=	O
SFUN_NARGS	function
(	O
argd	int
)	O
;	O
result_type	enum
=	O
SFUN_RETURN_TYPE	function
(	O
argd	int
)	O
;	O
SFUN_START_ARG_TYPES	function
(	O
argd	int
)	O
;	O
if	O
(	O
argd	int
==	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
vs_push	function
(	O
i	int
?	O
va_arg	function
(	O
ll	int
,	O
object	function
)	O
:	O
first	function
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
{	O
object	function
_xx	function
;	O
if	O
(	O
SFUN_NEXT_TYPE	function
(	O
argd	int
)	O
==	O
f_object	O
)	O
_xx	function
=	O
i	int
?	O
va_arg	function
(	O
ll	int
,	O
object	function
)	O
:	O
first	function
;	O
else	O
{	O
long	O
_yy	long
;	O
_yy	long
=	O
i	int
?	O
va_arg	function
(	O
ll	int
,	O
fixnum	O
)	O
:	O
(	O
fixnum	O
)	O
first	function
;	O
_xx	function
=	O
make_fixnum	function
(	O
_yy	long
)	O
;	O
}	O
vs_push	function
(	O
_xx	function
)	O
;	O
}	O
vs_check	O
;	O
funcall	function
(	O
fun	function
)	O
;	O
vs_top	O
=	O
base	pointer
;	O
return	O
(	O
(	O
result_type	enum
==	O
f_object	O
?	O
vs_base	O
[	O
0	int
]	O
:	O
(	O
object	function
)	O
fix	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
)	O
;	O
}	O
}	O
object	function
call_vproc_new	function
(	O
object	function
sym	function
,	O
void	O
*	O
link	pointer
,	O
object	function
first	function
,	O
va_list	O
ll	int
)	O
{	O
return	O
call_proc_new	function
(	O
sym	function
,	O
link	pointer
,	O
VFUN_NARGS	O
|	O
VFUN_NARG_BIT	O
,	O
first	function
,	O
ll	int
)	O
;	O
}	O
static	O
object	function
mcall_proc0	function
(	O
object	function
sym	function
,	O
void	O
*	O
link	pointer
,	O
int	O
argd	int
,	O
...	O
)	O
{	O
object	function
res	function
;	O
va_list	O
ap	O
;	O
va_start	O
(	O
ap	O
,	O
argd	int
)	O
;	O
res	function
=	O
call_proc	function
(	O
sym	function
,	O
link	pointer
,	O
argd	int
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
return	O
res	function
;	O
}	O
object	function
call_proc0	function
(	O
object	function
sym	function
,	O
void	O
*	O
link	pointer
)	O
{	O
return	O
mcall_proc0	function
(	O
sym	function
,	O
link	pointer
,	O
0	int
)	O
;	O
}	O
object	function
ifuncall	function
(	O
object	function
sym	function
,	O
int	O
n	int
,	O
...	O
)	O
{	O
va_list	O
ap	O
;	O
int	O
i	int
;	O
object	function
*	O
old_vs_base	pointer
;	O
object	function
*	O
old_vs_top	pointer
;	O
object	function
x	function
;	O
old_vs_base	pointer
=	O
vs_base	O
;	O
old_vs_top	pointer
=	O
vs_top	O
;	O
vs_base	O
=	O
old_vs_top	pointer
;	O
vs_top	O
=	O
old_vs_top	pointer
+	O
n	int
;	O
vs_check	O
;	O
va_start	O
(	O
ap	O
,	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
old_vs_top	pointer
[	O
i	int
]	O
=	O
va_arg	function
(	O
ap	O
,	O
object	function
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
if	O
(	O
type_of	function
(	O
sym	function
->	O
s	O
.	O
s_gfdef	O
)	O
==	O
t_cfun	O
)	O
(	O
*	O
(	O
sym	function
->	O
s	O
.	O
s_gfdef	O
)	O
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
else	O
super_funcall	function
(	O
sym	function
)	O
;	O
x	function
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
old_vs_top	pointer
;	O
vs_base	O
=	O
old_vs_base	pointer
;	O
return	O
(	O
x	function
)	O
;	O
}	O
int	O
clear_stack	function
(	O
object	function
*	O
beg	pointer
,	O
object	function
*	O
limit	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
++	O
beg	pointer
<	O
limit	pointer
)	O
{	O
if	O
(	O
*	O
beg	pointer
==	O
0	int
)	O
i	int
++	O
;	O
if	O
(	O
i	int
>	O
FRESH	int
)	O
return	O
0	int
;	O
;	O
*	O
beg	pointer
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
object	function
FFN	function
(	O
set_mv	int
)	O
(	O
int	O
i	int
,	O
object	function
val	function
)	O
{	O
if	O
(	O
i	int
>=	O
(	O
sizeof	O
(	O
MVloc	O
)	O
/	O
sizeof	O
(	O
object	function
)	O
)	O
)	O
FEerror	function
(	O
"Bad mv index"	pointer
,	O
0	int
)	O
;	O
return	O
(	O
MVloc	O
[	O
i	int
]	O
=	O
val	function
)	O
;	O
}	O
static	O
object	function
FFN	function
(	O
mv_ref	int
)	O
(	O
unsigned	O
int	O
i	int
)	O
{	O
object	function
x	function
;	O
if	O
(	O
i	int
>=	O
(	O
sizeof	O
(	O
MVloc	O
)	O
/	O
sizeof	O
(	O
object	function
)	O
)	O
)	O
FEerror	function
(	O
"Bad mv index"	pointer
,	O
0	int
)	O
;	O
x	function
=	O
MVloc	O
[	O
i	int
]	O
;	O
return	O
x	function
;	O
}	O
DEF_ORDINARY	function
(	O
"CDEFN"	pointer
,	O
sScdefn	int
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*LINK-ARRAY*"	pointer
,	O
sLAlink_arrayA	function
,	O
LISP	O
,	O
Cnil	O
,	O
""	pointer
)	O
;	O
void	O
gcl_init_links	function
(	O
void	O
)	O
{	O
make_si_sfun	function
(	O
"SET-MV"	pointer
,	O
set_mv	int
,	O
ARGTYPE2	function
(	O
f_fixnum	O
,	O
f_object	O
)	O
|	O
RESTYPE	function
(	O
f_object	O
)	O
)	O
;	O
make_si_sfun	function
(	O
"MV-REF"	pointer
,	O
mv_ref	int
,	O
ARGTYPE1	function
(	O
f_fixnum	O
)	O
|	O
RESTYPE	function
(	O
f_object	O
)	O
)	O
;	O
gcl_init_xdrfuns	function
(	O
)	O
;	O
}	O
