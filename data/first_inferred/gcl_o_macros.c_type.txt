object	O
sLwarn	int
;	O
object	O
sSAinhibit_macro_specialA	int
;	O
static	O
void	O
FFN	function
(	O
siLdefine_macro	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
2	int
)	O
;	O
if	O
(	O
type_of	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	function
(	O
"~S, a special form, cannot be redefined."	pointer
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
clear_compiler_properties	function
(	O
vs_base	O
[	O
0	int
]	O
,	O
MMcaddr	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
vs_push	function
(	O
make_simple_string	function
(	O
"~S is being redefined."	pointer
)	O
)	O
;	O
ifuncall2	function
(	O
sLwarn	int
,	O
vs_head	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_popp	O
;	O
}	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_gfdef	O
=	O
MMcaddr	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_mflag	O
=	O
TRUE	O
;	O
if	O
(	O
MMcar	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
!=	O
Cnil	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_plist	O
=	O
putf	function
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_plist	O
,	O
MMcar	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
,	O
sSfunction_documentation	O
)	O
;	O
}	O
if	O
(	O
MMcadr	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
!=	O
Cnil	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_plist	O
=	O
putf	function
(	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_plist	O
,	O
MMcadr	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
,	O
sSpretty_print_format	O
)	O
;	O
}	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
static	O
void	O
FFN	function
(	O
Fdefmacro	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
object	O
name	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
name	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
name	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
name	O
)	O
;	O
vs_push	function
(	O
ifuncall3	function
(	O
sSdefmacroA	O
,	O
name	O
,	O
MMcadr	function
(	O
form	int
)	O
,	O
MMcddr	function
(	O
form	int
)	O
)	O
)	O
;	O
if	O
(	O
MMcar	function
(	O
top	O
[	O
0	int
]	O
)	O
!=	O
Cnil	O
)	O
name	O
->	O
s	O
.	O
s_plist	O
=	O
putf	function
(	O
name	O
->	O
s	O
.	O
s_plist	O
,	O
MMcar	function
(	O
top	O
[	O
0	int
]	O
)	O
,	O
sSfunction_documentation	O
)	O
;	O
if	O
(	O
MMcadr	function
(	O
top	O
[	O
0	int
]	O
)	O
!=	O
Cnil	O
)	O
name	O
->	O
s	O
.	O
s_plist	O
=	O
putf	function
(	O
name	O
->	O
s	O
.	O
s_plist	O
,	O
MMcadr	function
(	O
top	O
[	O
0	int
]	O
)	O
,	O
sSpretty_print_format	O
)	O
;	O
if	O
(	O
name	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
name	O
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
name	O
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	function
(	O
"~S, a special form, cannot be redefined."	pointer
,	O
1	int
,	O
name	O
)	O
;	O
}	O
clear_compiler_properties	function
(	O
name	O
,	O
MMcaddr	function
(	O
top	O
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
name	O
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
name	O
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
vs_push	function
(	O
make_simple_string	function
(	O
"~S is being redefined."	pointer
)	O
)	O
;	O
ifuncall2	function
(	O
sLwarn	int
,	O
vs_head	O
,	O
name	O
)	O
;	O
vs_popp	O
;	O
}	O
name	O
->	O
s	O
.	O
s_gfdef	O
=	O
MMcaddr	function
(	O
top	O
[	O
0	int
]	O
)	O
;	O
name	O
->	O
s	O
.	O
s_mflag	O
=	O
TRUE	O
;	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
name	O
)	O
;	O
}	O
object	O
Imacro_expand1	function
(	O
object	O
exp_fun	int
,	O
object	O
form	int
)	O
{	O
return	O
Ifuncall_n	function
(	O
sLAmacroexpand_hookA	O
->	O
s	O
.	O
s_dbind	O
,	O
3	int
,	O
exp_fun	int
,	O
form	int
,	O
MACRO_EXPAND_ENV	O
)	O
;	O
}	O
static	O
object	O
macro_def	function
(	O
object	O
form	int
)	O
{	O
object	O
head	O
,	O
fd	O
;	O
if	O
(	O
type_of	function
(	O
form	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
Cnil	O
)	O
;	O
head	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
head	O
)	O
!=	O
t_symbol	O
)	O
return	O
(	O
Cnil	O
)	O
;	O
fd	O
=	O
lex_fd_sch	function
(	O
head	O
)	O
;	O
if	O
(	O
MMnull	function
(	O
fd	O
)	O
)	O
if	O
(	O
head	O
->	O
s	O
.	O
s_mflag	O
)	O
return	O
(	O
head	O
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
else	O
return	O
(	O
Cnil	O
)	O
;	O
else	O
if	O
(	O
MMcadr	function
(	O
fd	O
)	O
==	O
sLmacro	O
)	O
return	O
(	O
MMcaddr	function
(	O
fd	O
)	O
)	O
;	O
else	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
DEFUNOM_NEW	function
(	O
"MACROEXPAND"	pointer
,	O
object	O
,	O
fLmacroexpand	O
,	O
LISP	O
,	O
1	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lmacroexpand	O
,	O
(	O
object	O
form	int
,	O
...	O
)	O
,	O
""	pointer
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	O
envir	O
;	O
object	O
exp_fun	int
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
object	O
buf	O
[	O
3	int
]	O
;	O
va_list	O
ap	O
;	O
{	O
va_start	O
(	O
ap	O
,	O
form	int
)	O
;	O
if	O
(	O
n	int
>=	O
2	int
)	O
envir	O
=	O
va_arg	function
(	O
ap	O
,	O
object	O
)	O
;	O
else	O
goto	O
LDEFAULT2	O
;	O
goto	O
LEND_VARARG	O
;	O
LDEFAULT2	O
:	O
envir	O
=	O
Cnil	O
;	O
LEND_VARARG	O
:	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
lex_env	O
=	O
buf	O
;	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
buf	O
[	O
0	int
]	O
=	O
sLnil	O
;	O
buf	O
[	O
1	int
]	O
=	O
sLnil	O
;	O
buf	O
[	O
2	int
]	O
=	O
sLnil	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
2	int
)	O
{	O
buf	O
[	O
0	int
]	O
=	O
car	function
(	O
envir	O
)	O
;	O
envir	O
=	O
Mcdr	function
(	O
envir	O
)	O
;	O
buf	O
[	O
1	int
]	O
=	O
car	function
(	O
envir	O
)	O
;	O
envir	O
=	O
Mcdr	function
(	O
envir	O
)	O
;	O
buf	O
[	O
2	int
]	O
=	O
car	function
(	O
envir	O
)	O
;	O
}	O
else	O
check_arg_range	function
(	O
1	int
,	O
2	int
)	O
;	O
exp_fun	int
=	O
macro_def	function
(	O
form	int
)	O
;	O
if	O
(	O
MMnull	function
(	O
exp_fun	int
)	O
)	O
{	O
lex_env	O
=	O
lex	O
;	O
RETURN	function
(	O
2	int
,	O
object	O
,	O
form	int
,	O
(	O
RV	function
(	O
sLnil	O
)	O
)	O
)	O
;	O
}	O
else	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
form	int
=	O
Imacro_expand1	function
(	O
exp_fun	int
,	O
form	int
)	O
;	O
vs_top	O
=	O
top	O
;	O
exp_fun	int
=	O
macro_def	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
MMnull	function
(	O
exp_fun	int
)	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
RETURN	function
(	O
2	int
,	O
object	O
,	O
form	int
,	O
(	O
RV	function
(	O
sLt	O
)	O
)	O
)	O
;	O
}	O
}	O
LFD	function
(	O
Lmacroexpand_1	int
)	O
(	O
void	O
)	O
{	O
object	O
exp_fun	int
;	O
object	O
*	O
base	O
=	O
vs_base	O
;	O
object	O
*	O
lex	O
=	O
lex_env	O
;	O
lex_env	O
=	O
vs_top	O
;	O
if	O
(	O
vs_top	O
-	O
vs_base	O
<	O
1	int
)	O
too_few_arguments	function
(	O
)	O
;	O
else	O
if	O
(	O
vs_top	O
-	O
vs_base	O
==	O
1	int
)	O
{	O
vs_push	function
(	O
Cnil	O
)	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
if	O
(	O
vs_top	O
-	O
vs_base	O
==	O
2	int
)	O
{	O
vs_push	function
(	O
car	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
)	O
;	O
vs_push	function
(	O
car	function
(	O
cdr	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
)	O
)	O
;	O
vs_push	function
(	O
car	function
(	O
cdr	function
(	O
cdr	function
(	O
vs_base	O
[	O
1	int
]	O
)	O
)	O
)	O
)	O
;	O
}	O
else	O
too_many_arguments	function
(	O
)	O
;	O
exp_fun	int
=	O
macro_def	function
(	O
base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
MMnull	function
(	O
exp_fun	int
)	O
)	O
{	O
lex_env	O
=	O
lex	O
;	O
vs_base	O
=	O
base	O
;	O
vs_top	O
=	O
base	O
+	O
1	int
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
base	O
[	O
0	int
]	O
=	O
Imacro_expand1	function
(	O
exp_fun	int
,	O
base	O
[	O
0	int
]	O
)	O
;	O
lex_env	O
=	O
lex	O
;	O
vs_base	O
=	O
base	O
;	O
vs_top	O
=	O
base	O
+	O
1	int
;	O
vs_push	function
(	O
Ct	O
)	O
;	O
}	O
}	O
object	O
macro_expand	function
(	O
object	O
form	int
)	O
{	O
object	O
exp_fun	int
,	O
head	O
,	O
fd	O
;	O
object	O
*	O
base	O
=	O
vs_base	O
;	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
type_of	function
(	O
form	int
)	O
!=	O
t_cons	O
)	O
return	O
(	O
form	int
)	O
;	O
head	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
head	O
)	O
!=	O
t_symbol	O
)	O
return	O
(	O
form	int
)	O
;	O
if	O
(	O
head	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
return	O
(	O
form	int
)	O
;	O
fd	O
=	O
lex_fd_sch	function
(	O
head	O
)	O
;	O
if	O
(	O
MMnull	function
(	O
fd	O
)	O
)	O
if	O
(	O
head	O
->	O
s	O
.	O
s_mflag	O
)	O
exp_fun	int
=	O
head	O
->	O
s	O
.	O
s_gfdef	O
;	O
else	O
return	O
(	O
form	int
)	O
;	O
else	O
if	O
(	O
MMcadr	function
(	O
fd	O
)	O
==	O
sLmacro	O
)	O
exp_fun	int
=	O
MMcaddr	function
(	O
fd	O
)	O
;	O
else	O
return	O
(	O
form	int
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
vs_push	function
(	O
exp_fun	int
)	O
;	O
LOOP	O
:	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
exp_fun	int
)	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
VS_PUSH_ENV	O
;	O
super_funcall	function
(	O
symbol_value	function
(	O
sLAmacroexpand_hookA	O
)	O
)	O
;	O
if	O
(	O
vs_base	O
==	O
vs_top	O
)	O
vs_push	function
(	O
Cnil	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	function
(	O
form	int
)	O
!=	O
t_cons	O
)	O
goto	O
END	O
;	O
head	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
head	O
)	O
!=	O
t_symbol	O
)	O
goto	O
END	O
;	O
if	O
(	O
head	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
goto	O
END	O
;	O
fd	O
=	O
lex_fd_sch	function
(	O
head	O
)	O
;	O
if	O
(	O
MMnull	function
(	O
fd	O
)	O
)	O
if	O
(	O
head	O
->	O
s	O
.	O
s_mflag	O
)	O
exp_fun	int
=	O
head	O
->	O
s	O
.	O
s_gfdef	O
;	O
else	O
goto	O
END	O
;	O
else	O
if	O
(	O
MMcadr	function
(	O
fd	O
)	O
==	O
sLmacro	O
)	O
exp_fun	int
=	O
MMcaddr	function
(	O
fd	O
)	O
;	O
else	O
goto	O
END	O
;	O
top	O
[	O
1	int
]	O
=	O
exp_fun	int
;	O
vs_top	O
=	O
top	O
+	O
2	int
;	O
goto	O
LOOP	O
;	O
END	O
:	O
vs_base	O
=	O
base	O
;	O
vs_top	O
=	O
top	O
;	O
return	O
(	O
form	int
)	O
;	O
}	O
DEF_ORDINARY	function
(	O
"FUNCALL"	pointer
,	O
sLfuncall	O
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*MACROEXPAND-HOOK*"	pointer
,	O
sLAmacroexpand_hookA	O
,	O
LISP	O
,	O
sLfuncall	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"DEFMACRO*"	pointer
,	O
sSdefmacroA	O
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*INHIBIT-MACRO-SPECIAL*"	pointer
,	O
sSAinhibit_macro_specialA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	pointer
)	O
;	O
void	O
gcl_init_macros	function
(	O
void	O
)	O
{	O
make_si_function	function
(	O
"DEFINE-MACRO"	pointer
,	O
siLdefine_macro	int
)	O
;	O
make_function	function
(	O
"MACROEXPAND-1"	pointer
,	O
Lmacroexpand_1	int
)	O
;	O
make_special_form	function
(	O
"DEFMACRO"	pointer
,	O
Fdefmacro	int
)	O
;	O
}	O
