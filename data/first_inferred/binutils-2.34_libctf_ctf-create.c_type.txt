static	O
int	O
ctf_grow_ptrtab	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
size_t	long
new_ptrtab_len	long
=	O
fp	pointer
->	O
ctf_ptrtab_len	long
;	O
if	O
(	O
fp	pointer
->	O
ctf_ptrtab	pointer
==	O
NULL	O
)	O
new_ptrtab_len	long
=	O
1024	int
;	O
else	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_typemax	long
+	O
2	int
)	O
>	O
fp	pointer
->	O
ctf_ptrtab_len	long
)	O
new_ptrtab_len	long
=	O
fp	pointer
->	O
ctf_ptrtab_len	long
*	O
1.25	int
;	O
if	O
(	O
new_ptrtab_len	long
!=	O
fp	pointer
->	O
ctf_ptrtab_len	long
)	O
{	O
uint32_t	int
*	O
new_ptrtab	pointer
;	O
if	O
(	O
(	O
new_ptrtab	pointer
=	O
realloc	function
(	O
fp	pointer
->	O
ctf_ptrtab	pointer
,	O
new_ptrtab_len	long
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_ptrtab	pointer
=	O
new_ptrtab	pointer
;	O
memset	function
(	O
fp	pointer
->	O
ctf_ptrtab	pointer
+	O
fp	pointer
->	O
ctf_ptrtab_len	long
,	O
0	int
,	O
(	O
new_ptrtab_len	long
-	O
fp	pointer
->	O
ctf_ptrtab_len	long
)	O
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_ptrtab_len	long
=	O
new_ptrtab_len	long
;	O
}	O
return	O
0	int
;	O
}	O
ctf_file_t	struct
*	O
ctf_create	function
(	O
int	O
*	O
errp	pointer
)	O
{	O
static	O
const	O
ctf_header_t	struct
hdr	struct
=	O
{	O
.	O
cth_preamble	struct
=	O
{	O
CTF_MAGIC	int
,	O
CTF_VERSION	O
,	O
0	int
}	O
}	O
;	O
ctf_dynhash_t	struct
*	O
dthash	pointer
;	O
ctf_dynhash_t	struct
*	O
dvhash	pointer
;	O
ctf_dynhash_t	struct
*	O
structs	pointer
=	O
NULL	O
,	O
*	O
unions	pointer
=	O
NULL	O
,	O
*	O
enums	pointer
=	O
NULL	O
,	O
*	O
names	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
cts	struct
;	O
ctf_file_t	struct
*	O
fp	pointer
;	O
libctf_init_debug	function
(	O
)	O
;	O
dthash	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_integer	function
,	O
ctf_hash_eq_integer	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dthash	pointer
==	O
NULL	O
)	O
{	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
EAGAIN	int
)	O
;	O
goto	O
err	long
;	O
}	O
dvhash	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dvhash	pointer
==	O
NULL	O
)	O
{	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
EAGAIN	int
)	O
;	O
goto	O
err_dt	O
;	O
}	O
structs	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
unions	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
enums	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
names	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
structs	pointer
||	O
!	O
unions	pointer
||	O
!	O
enums	pointer
||	O
!	O
names	pointer
)	O
{	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
EAGAIN	int
)	O
;	O
goto	O
err_dv	O
;	O
}	O
cts	struct
.	O
cts_name	pointer
=	O
_CTF_SECTION	array
;	O
cts	struct
.	O
cts_data	pointer
=	O
&	O
hdr	struct
;	O
cts	struct
.	O
cts_size	long
=	O
sizeof	O
(	O
hdr	struct
)	O
;	O
cts	struct
.	O
cts_entsize	long
=	O
1	int
;	O
if	O
(	O
(	O
fp	pointer
=	O
ctf_bufopen_internal	function
(	O
&	O
cts	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
1	int
,	O
errp	pointer
)	O
)	O
==	O
NULL	O
)	O
goto	O
err_dv	O
;	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_writable	pointer
=	O
structs	pointer
;	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_writable	pointer
=	O
unions	pointer
;	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_writable	pointer
=	O
enums	pointer
;	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_writable	pointer
=	O
names	pointer
;	O
fp	pointer
->	O
ctf_dthash	pointer
=	O
dthash	pointer
;	O
fp	pointer
->	O
ctf_dvhash	pointer
=	O
dvhash	pointer
;	O
fp	pointer
->	O
ctf_dtoldid	long
=	O
0	int
;	O
fp	pointer
->	O
ctf_snapshots	long
=	O
1	int
;	O
fp	pointer
->	O
ctf_snapshot_lu	long
=	O
0	int
;	O
ctf_set_ctl_hashes	function
(	O
fp	pointer
)	O
;	O
ctf_setmodel	function
(	O
fp	pointer
,	O
CTF_MODEL_NATIVE	O
)	O
;	O
if	O
(	O
ctf_grow_ptrtab	function
(	O
fp	pointer
)	O
<	O
0	int
)	O
{	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ctf_errno	function
(	O
fp	pointer
)	O
)	O
;	O
ctf_file_close	function
(	O
fp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
fp	pointer
;	O
err_dv	O
:	O
ctf_dynhash_destroy	function
(	O
structs	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
unions	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
enums	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
names	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
dvhash	pointer
)	O
;	O
err_dt	O
:	O
ctf_dynhash_destroy	function
(	O
dthash	pointer
)	O
;	O
err	long
:	O
return	O
NULL	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
ctf_copy_smembers	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dtdef_t	struct
*	O
dtd	pointer
,	O
unsigned	O
char	O
*	O
t	pointer
)	O
{	O
ctf_dmdef_t	struct
*	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
ctf_member_t	struct
ctm	struct
;	O
for	O
(	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
)	O
{	O
ctf_member_t	struct
*	O
copied	pointer
;	O
ctm	struct
.	O
ctm_name	int
=	O
0	int
;	O
ctm	struct
.	O
ctm_type	short
=	O
(	O
uint32_t	int
)	O
dmd	pointer
->	O
dmd_type	long
;	O
ctm	struct
.	O
ctm_offset	short
=	O
(	O
uint32_t	int
)	O
dmd	pointer
->	O
dmd_offset	long
;	O
memcpy	function
(	O
t	pointer
,	O
&	O
ctm	struct
,	O
sizeof	O
(	O
ctm	struct
)	O
)	O
;	O
copied	pointer
=	O
(	O
ctf_member_t	struct
*	O
)	O
t	pointer
;	O
if	O
(	O
dmd	pointer
->	O
dmd_name	pointer
)	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
dmd	pointer
->	O
dmd_name	pointer
,	O
&	O
copied	pointer
->	O
ctm_name	int
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
ctm	struct
)	O
;	O
}	O
return	O
t	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
ctf_copy_lmembers	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dtdef_t	struct
*	O
dtd	pointer
,	O
unsigned	O
char	O
*	O
t	pointer
)	O
{	O
ctf_dmdef_t	struct
*	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
ctf_lmember_t	struct
ctlm	struct
;	O
for	O
(	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
)	O
{	O
ctf_lmember_t	struct
*	O
copied	pointer
;	O
ctlm	struct
.	O
ctlm_name	int
=	O
0	int
;	O
ctlm	struct
.	O
ctlm_type	short
=	O
(	O
uint32_t	int
)	O
dmd	pointer
->	O
dmd_type	long
;	O
ctlm	struct
.	O
ctlm_offsethi	int
=	O
CTF_OFFSET_TO_LMEMHI	O
(	O
dmd	pointer
->	O
dmd_offset	long
)	O
;	O
ctlm	struct
.	O
ctlm_offsetlo	int
=	O
CTF_OFFSET_TO_LMEMLO	O
(	O
dmd	pointer
->	O
dmd_offset	long
)	O
;	O
memcpy	function
(	O
t	pointer
,	O
&	O
ctlm	struct
,	O
sizeof	O
(	O
ctlm	struct
)	O
)	O
;	O
copied	pointer
=	O
(	O
ctf_lmember_t	struct
*	O
)	O
t	pointer
;	O
if	O
(	O
dmd	pointer
->	O
dmd_name	pointer
)	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
dmd	pointer
->	O
dmd_name	pointer
,	O
&	O
copied	pointer
->	O
ctlm_name	int
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
ctlm	struct
)	O
;	O
}	O
return	O
t	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
ctf_copy_emembers	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dtdef_t	struct
*	O
dtd	pointer
,	O
unsigned	O
char	O
*	O
t	pointer
)	O
{	O
ctf_dmdef_t	struct
*	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
ctf_enum_t	struct
cte	struct
;	O
for	O
(	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
)	O
{	O
ctf_enum_t	struct
*	O
copied	pointer
;	O
cte	struct
.	O
cte_value	int
=	O
dmd	pointer
->	O
dmd_value	int
;	O
memcpy	function
(	O
t	pointer
,	O
&	O
cte	struct
,	O
sizeof	O
(	O
cte	struct
)	O
)	O
;	O
copied	pointer
=	O
(	O
ctf_enum_t	struct
*	O
)	O
t	pointer
;	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
dmd	pointer
->	O
dmd_name	pointer
,	O
&	O
copied	pointer
->	O
cte_name	int
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
cte	struct
)	O
;	O
}	O
return	O
t	pointer
;	O
}	O
typedef	O
struct	O
ctf_sort_var_arg_cb	struct
{	O
ctf_file_t	struct
*	O
fp	pointer
;	O
ctf_strs_t	struct
*	O
strtab	pointer
;	O
}	O
ctf_sort_var_arg_cb_t	struct
;	O
static	O
int	O
ctf_sort_var	function
(	O
const	O
void	O
*	O
one_	pointer
,	O
const	O
void	O
*	O
two_	pointer
,	O
void	O
*	O
arg_	pointer
)	O
{	O
const	O
ctf_varent_t	struct
*	O
one	pointer
=	O
one_	pointer
;	O
const	O
ctf_varent_t	struct
*	O
two	pointer
=	O
two_	pointer
;	O
ctf_sort_var_arg_cb_t	struct
*	O
arg	pointer
=	O
arg_	pointer
;	O
return	O
(	O
strcmp	function
(	O
ctf_strraw_explicit	function
(	O
arg	pointer
->	O
fp	pointer
,	O
one	pointer
->	O
ctv_name	int
,	O
arg	pointer
->	O
strtab	pointer
)	O
,	O
ctf_strraw_explicit	function
(	O
arg	pointer
->	O
fp	pointer
,	O
two	pointer
->	O
ctv_name	int
,	O
arg	pointer
->	O
strtab	pointer
)	O
)	O
)	O
;	O
}	O
int	O
ctf_update	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_dtoldid	long
=	O
fp	pointer
->	O
ctf_typemax	long
;	O
return	O
0	int
;	O
}	O
int	O
ctf_serialize	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
ctf_file_t	struct
ofp	struct
,	O
*	O
nfp	pointer
;	O
ctf_header_t	struct
hdr	struct
,	O
*	O
hdrp	pointer
;	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_dvdef_t	struct
*	O
dvd	pointer
;	O
ctf_varent_t	struct
*	O
dvarents	pointer
;	O
ctf_strs_writable_t	struct
strtab	pointer
;	O
unsigned	O
char	O
*	O
t	pointer
;	O
unsigned	O
long	O
i	pointer
;	O
size_t	long
buf_size	long
,	O
type_size	long
,	O
nvars	long
;	O
unsigned	O
char	O
*	O
buf	pointer
,	O
*	O
newbuf	pointer
;	O
int	O
err	long
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_DIRTY	int
)	O
)	O
return	O
0	int
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
cth_magic	O
=	O
CTF_MAGIC	int
;	O
hdr	struct
.	O
cth_version	O
=	O
CTF_VERSION	O
;	O
for	O
(	O
type_size	long
=	O
0	int
,	O
dtd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
)	O
;	O
dtd	pointer
!=	O
NULL	O
;	O
dtd	pointer
=	O
ctf_list_next	O
(	O
dtd	pointer
)	O
)	O
{	O
uint32_t	int
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
uint32_t	int
vlen	int
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
!=	O
CTF_LSIZE_SENT	int
)	O
type_size	long
+=	O
sizeof	O
(	O
ctf_stype_t	O
)	O
;	O
else	O
type_size	long
+=	O
sizeof	O
(	O
ctf_type_t	struct
)	O
;	O
switch	O
(	O
kind	int
)	O
{	O
case	O
CTF_K_INTEGER	int
:	O
case	O
CTF_K_FLOAT	int
:	O
type_size	long
+=	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
break	O
;	O
case	O
CTF_K_ARRAY	int
:	O
type_size	long
+=	O
sizeof	O
(	O
ctf_array_t	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_SLICE	int
:	O
type_size	long
+=	O
sizeof	O
(	O
ctf_slice_t	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
type_size	long
+=	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
vlen	int
+	O
(	O
vlen	int
&	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
<	O
CTF_LSTRUCT_THRESH	int
)	O
type_size	long
+=	O
sizeof	O
(	O
ctf_member_t	struct
)	O
*	O
vlen	int
;	O
else	O
type_size	long
+=	O
sizeof	O
(	O
ctf_lmember_t	struct
)	O
*	O
vlen	int
;	O
break	O
;	O
case	O
CTF_K_ENUM	int
:	O
type_size	long
+=	O
sizeof	O
(	O
ctf_enum_t	struct
)	O
*	O
vlen	int
;	O
break	O
;	O
}	O
}	O
for	O
(	O
nvars	long
=	O
0	int
,	O
dvd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
)	O
;	O
dvd	pointer
!=	O
NULL	O
;	O
dvd	pointer
=	O
ctf_list_next	O
(	O
dvd	pointer
)	O
,	O
nvars	long
++	O
)	O
;	O
hdr	struct
.	O
cth_typeoff	int
=	O
hdr	struct
.	O
cth_varoff	int
+	O
(	O
nvars	long
*	O
sizeof	O
(	O
ctf_varent_t	struct
)	O
)	O
;	O
hdr	struct
.	O
cth_stroff	int
=	O
hdr	struct
.	O
cth_typeoff	int
+	O
type_size	long
;	O
hdr	struct
.	O
cth_strlen	int
=	O
0	int
;	O
buf_size	long
=	O
sizeof	O
(	O
ctf_header_t	struct
)	O
+	O
hdr	struct
.	O
cth_stroff	int
+	O
hdr	struct
.	O
cth_strlen	int
;	O
if	O
(	O
(	O
buf	pointer
=	O
malloc	function
(	O
buf_size	long
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
memcpy	function
(	O
buf	pointer
,	O
&	O
hdr	struct
,	O
sizeof	O
(	O
ctf_header_t	struct
)	O
)	O
;	O
t	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
+	O
sizeof	O
(	O
ctf_header_t	struct
)	O
+	O
hdr	struct
.	O
cth_varoff	int
;	O
hdrp	pointer
=	O
(	O
ctf_header_t	struct
*	O
)	O
buf	pointer
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_CHILD	int
)	O
&&	O
(	O
fp	pointer
->	O
ctf_parname	pointer
!=	O
NULL	O
)	O
)	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
fp	pointer
->	O
ctf_parname	pointer
,	O
&	O
hdrp	pointer
->	O
cth_parname	int
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_cuname	function
!=	O
NULL	O
)	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
fp	pointer
->	O
ctf_cuname	function
,	O
&	O
hdrp	pointer
->	O
cth_cuname	int
)	O
;	O
dvarents	pointer
=	O
(	O
ctf_varent_t	struct
*	O
)	O
t	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
dvd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
)	O
;	O
dvd	pointer
!=	O
NULL	O
;	O
dvd	pointer
=	O
ctf_list_next	O
(	O
dvd	pointer
)	O
,	O
i	pointer
++	O
)	O
{	O
ctf_varent_t	struct
*	O
var	pointer
=	O
&	O
dvarents	pointer
[	O
i	pointer
]	O
;	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
dvd	pointer
->	O
dvd_name	pointer
,	O
&	O
var	pointer
->	O
ctv_name	int
)	O
;	O
var	pointer
->	O
ctv_type	int
=	O
dvd	pointer
->	O
dvd_type	long
;	O
}	O
assert	O
(	O
i	pointer
==	O
nvars	long
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
ctf_varent_t	struct
)	O
*	O
nvars	long
;	O
assert	O
(	O
t	pointer
==	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
+	O
sizeof	O
(	O
ctf_header_t	struct
)	O
+	O
hdr	struct
.	O
cth_typeoff	int
)	O
;	O
for	O
(	O
dtd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
)	O
;	O
dtd	pointer
!=	O
NULL	O
;	O
dtd	pointer
=	O
ctf_list_next	O
(	O
dtd	pointer
)	O
)	O
{	O
uint32_t	int
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
uint32_t	int
vlen	int
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
ctf_array_t	struct
cta	struct
;	O
uint32_t	int
encoding	int
;	O
size_t	long
len	int
;	O
ctf_stype_t	O
*	O
copied	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
!=	O
CTF_LSIZE_SENT	int
)	O
len	int
=	O
sizeof	O
(	O
ctf_stype_t	O
)	O
;	O
else	O
len	int
=	O
sizeof	O
(	O
ctf_type_t	struct
)	O
;	O
memcpy	function
(	O
t	pointer
,	O
&	O
dtd	pointer
->	O
dtd_data	struct
,	O
len	int
)	O
;	O
copied	pointer
=	O
(	O
ctf_stype_t	O
*	O
)	O
t	pointer
;	O
if	O
(	O
copied	pointer
->	O
ctt_name	int
&&	O
(	O
name	pointer
=	O
ctf_strraw	function
(	O
fp	pointer
,	O
copied	pointer
->	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
name	pointer
,	O
&	O
copied	pointer
->	O
ctt_name	int
)	O
;	O
t	pointer
+=	O
len	int
;	O
switch	O
(	O
kind	int
)	O
{	O
case	O
CTF_K_INTEGER	int
:	O
case	O
CTF_K_FLOAT	int
:	O
if	O
(	O
kind	int
==	O
CTF_K_INTEGER	int
)	O
{	O
encoding	int
=	O
CTF_INT_DATA	O
(	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
.	O
cte_format	int
,	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
.	O
cte_offset	int
,	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
.	O
cte_bits	int
)	O
;	O
}	O
else	O
{	O
encoding	int
=	O
CTF_FP_DATA	O
(	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
.	O
cte_format	int
,	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
.	O
cte_offset	int
,	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
.	O
cte_bits	int
)	O
;	O
}	O
memcpy	function
(	O
t	pointer
,	O
&	O
encoding	int
,	O
sizeof	O
(	O
encoding	int
)	O
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
encoding	int
)	O
;	O
break	O
;	O
case	O
CTF_K_SLICE	int
:	O
memcpy	function
(	O
t	pointer
,	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_slice	struct
,	O
sizeof	O
(	O
struct	O
ctf_slice	struct
)	O
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
struct	O
ctf_slice	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_ARRAY	int
:	O
cta	struct
.	O
cta_contents	short
=	O
(	O
uint32_t	int
)	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_arr	struct
.	O
ctr_contents	long
;	O
cta	struct
.	O
cta_index	short
=	O
(	O
uint32_t	int
)	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_arr	struct
.	O
ctr_index	long
;	O
cta	struct
.	O
cta_nelems	int
=	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_arr	struct
.	O
ctr_nelems	int
;	O
memcpy	function
(	O
t	pointer
,	O
&	O
cta	struct
,	O
sizeof	O
(	O
cta	struct
)	O
)	O
;	O
t	pointer
+=	O
sizeof	O
(	O
cta	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
{	O
uint32_t	int
*	O
argv	pointer
=	O
(	O
uint32_t	int
*	O
)	O
(	O
uintptr_t	long
)	O
t	pointer
;	O
uint32_t	int
argc	int
;	O
for	O
(	O
argc	int
=	O
0	int
;	O
argc	int
<	O
vlen	int
;	O
argc	int
++	O
)	O
*	O
argv	pointer
++	O
=	O
(	O
uint32_t	int
)	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_argv	pointer
[	O
argc	int
]	O
;	O
if	O
(	O
vlen	int
&	O
1	int
)	O
*	O
argv	pointer
++	O
=	O
0	int
;	O
t	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
argv	pointer
;	O
break	O
;	O
}	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
<	O
CTF_LSTRUCT_THRESH	int
)	O
t	pointer
=	O
ctf_copy_smembers	function
(	O
fp	pointer
,	O
dtd	pointer
,	O
t	pointer
)	O
;	O
else	O
t	pointer
=	O
ctf_copy_lmembers	function
(	O
fp	pointer
,	O
dtd	pointer
,	O
t	pointer
)	O
;	O
break	O
;	O
case	O
CTF_K_ENUM	int
:	O
t	pointer
=	O
ctf_copy_emembers	function
(	O
fp	pointer
,	O
dtd	pointer
,	O
t	pointer
)	O
;	O
break	O
;	O
}	O
}	O
assert	O
(	O
t	pointer
==	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
+	O
sizeof	O
(	O
ctf_header_t	struct
)	O
+	O
hdr	struct
.	O
cth_stroff	int
)	O
;	O
strtab	pointer
=	O
ctf_str_write_strtab	function
(	O
fp	pointer
)	O
;	O
ctf_str_purge_refs	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
strtab	pointer
.	O
cts_strs	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
ctf_sort_var_arg_cb_t	struct
sort_var_arg	struct
=	O
{	O
fp	pointer
,	O
(	O
ctf_strs_t	struct
*	O
)	O
&	O
strtab	pointer
}	O
;	O
ctf_qsort_r	function
(	O
dvarents	pointer
,	O
nvars	long
,	O
sizeof	O
(	O
ctf_varent_t	struct
)	O
,	O
ctf_sort_var	function
,	O
&	O
sort_var_arg	struct
)	O
;	O
if	O
(	O
(	O
newbuf	pointer
=	O
ctf_realloc	function
(	O
fp	pointer
,	O
buf	pointer
,	O
buf_size	long
+	O
strtab	pointer
.	O
cts_len	long
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
free	function
(	O
strtab	pointer
.	O
cts_strs	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
buf	pointer
=	O
newbuf	pointer
;	O
memcpy	function
(	O
buf	pointer
+	O
buf_size	long
,	O
strtab	pointer
.	O
cts_strs	pointer
,	O
strtab	pointer
.	O
cts_len	long
)	O
;	O
hdrp	pointer
=	O
(	O
ctf_header_t	struct
*	O
)	O
buf	pointer
;	O
hdrp	pointer
->	O
cth_strlen	int
=	O
strtab	pointer
.	O
cts_len	long
;	O
buf_size	long
+=	O
hdrp	pointer
->	O
cth_strlen	int
;	O
free	function
(	O
strtab	pointer
.	O
cts_strs	pointer
)	O
;	O
if	O
(	O
(	O
nfp	pointer
=	O
ctf_simple_open_internal	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
buf_size	long
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
fp	pointer
->	O
ctf_syn_ext_strtab	pointer
,	O
1	int
,	O
&	O
err	long
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
err	long
)	O
)	O
;	O
}	O
(	O
void	O
)	O
ctf_setmodel	function
(	O
nfp	pointer
,	O
ctf_getmodel	function
(	O
fp	pointer
)	O
)	O
;	O
(	O
void	O
)	O
ctf_import	function
(	O
nfp	pointer
,	O
fp	pointer
->	O
ctf_parent	pointer
)	O
;	O
nfp	pointer
->	O
ctf_refcnt	int
=	O
fp	pointer
->	O
ctf_refcnt	int
;	O
nfp	pointer
->	O
ctf_flags	int
|=	O
fp	pointer
->	O
ctf_flags	int
&	O
~	O
LCTF_DIRTY	int
;	O
if	O
(	O
nfp	pointer
->	O
ctf_dynbase	pointer
==	O
NULL	O
)	O
nfp	pointer
->	O
ctf_dynbase	pointer
=	O
buf	pointer
;	O
nfp	pointer
->	O
ctf_dthash	pointer
=	O
fp	pointer
->	O
ctf_dthash	pointer
;	O
nfp	pointer
->	O
ctf_dtdefs	struct
=	O
fp	pointer
->	O
ctf_dtdefs	struct
;	O
nfp	pointer
->	O
ctf_dvhash	pointer
=	O
fp	pointer
->	O
ctf_dvhash	pointer
;	O
nfp	pointer
->	O
ctf_dvdefs	struct
=	O
fp	pointer
->	O
ctf_dvdefs	struct
;	O
nfp	pointer
->	O
ctf_dtoldid	long
=	O
fp	pointer
->	O
ctf_dtoldid	long
;	O
nfp	pointer
->	O
ctf_add_processing	pointer
=	O
fp	pointer
->	O
ctf_add_processing	pointer
;	O
nfp	pointer
->	O
ctf_snapshots	long
=	O
fp	pointer
->	O
ctf_snapshots	long
+	O
1	int
;	O
nfp	pointer
->	O
ctf_specific	pointer
=	O
fp	pointer
->	O
ctf_specific	pointer
;	O
nfp	pointer
->	O
ctf_ptrtab	pointer
=	O
fp	pointer
->	O
ctf_ptrtab	pointer
;	O
nfp	pointer
->	O
ctf_ptrtab_len	long
=	O
fp	pointer
->	O
ctf_ptrtab_len	long
;	O
nfp	pointer
->	O
ctf_link_inputs	pointer
=	O
fp	pointer
->	O
ctf_link_inputs	pointer
;	O
nfp	pointer
->	O
ctf_link_outputs	pointer
=	O
fp	pointer
->	O
ctf_link_outputs	pointer
;	O
nfp	pointer
->	O
ctf_str_prov_offset	int
=	O
fp	pointer
->	O
ctf_str_prov_offset	int
;	O
nfp	pointer
->	O
ctf_syn_ext_strtab	pointer
=	O
fp	pointer
->	O
ctf_syn_ext_strtab	pointer
;	O
nfp	pointer
->	O
ctf_link_cu_mapping	pointer
=	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
;	O
nfp	pointer
->	O
ctf_link_type_mapping	pointer
=	O
fp	pointer
->	O
ctf_link_type_mapping	pointer
;	O
nfp	pointer
->	O
ctf_link_memb_name_changer	pointer
=	O
fp	pointer
->	O
ctf_link_memb_name_changer	pointer
;	O
nfp	pointer
->	O
ctf_link_memb_name_changer_arg	pointer
=	O
fp	pointer
->	O
ctf_link_memb_name_changer_arg	pointer
;	O
nfp	pointer
->	O
ctf_snapshot_lu	long
=	O
fp	pointer
->	O
ctf_snapshots	long
;	O
memcpy	function
(	O
&	O
nfp	pointer
->	O
ctf_lookups	array
,	O
fp	pointer
->	O
ctf_lookups	array
,	O
sizeof	O
(	O
fp	pointer
->	O
ctf_lookups	array
)	O
)	O
;	O
nfp	pointer
->	O
ctf_structs	struct
=	O
fp	pointer
->	O
ctf_structs	struct
;	O
nfp	pointer
->	O
ctf_unions	struct
=	O
fp	pointer
->	O
ctf_unions	struct
;	O
nfp	pointer
->	O
ctf_enums	struct
=	O
fp	pointer
->	O
ctf_enums	struct
;	O
nfp	pointer
->	O
ctf_names	struct
=	O
fp	pointer
->	O
ctf_names	struct
;	O
fp	pointer
->	O
ctf_dthash	pointer
=	O
NULL	O
;	O
ctf_str_free_atoms	function
(	O
nfp	pointer
)	O
;	O
nfp	pointer
->	O
ctf_str_atoms	pointer
=	O
fp	pointer
->	O
ctf_str_atoms	pointer
;	O
nfp	pointer
->	O
ctf_prov_strtab	pointer
=	O
fp	pointer
->	O
ctf_prov_strtab	pointer
;	O
fp	pointer
->	O
ctf_str_atoms	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_prov_strtab	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
,	O
0	int
,	O
sizeof	O
(	O
ctf_list_t	struct
)	O
)	O
;	O
fp	pointer
->	O
ctf_add_processing	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_ptrtab	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_link_inputs	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_link_outputs	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_syn_ext_strtab	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_link_type_mapping	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_dvhash	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
,	O
0	int
,	O
sizeof	O
(	O
ctf_list_t	struct
)	O
)	O
;	O
memset	function
(	O
fp	pointer
->	O
ctf_lookups	array
,	O
0	int
,	O
sizeof	O
(	O
fp	pointer
->	O
ctf_lookups	array
)	O
)	O
;	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_writable	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_writable	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_writable	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_writable	pointer
=	O
NULL	O
;	O
memcpy	function
(	O
&	O
ofp	struct
,	O
fp	pointer
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
memcpy	function
(	O
fp	pointer
,	O
nfp	pointer
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
memcpy	function
(	O
nfp	pointer
,	O
&	O
ofp	struct
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
nfp	pointer
->	O
ctf_refcnt	int
=	O
1	int
;	O
ctf_file_close	function
(	O
nfp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ctf_names_t	struct
*	O
ctf_name_table	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
int	O
kind	int
)	O
{	O
switch	O
(	O
kind	int
)	O
{	O
case	O
CTF_K_STRUCT	int
:	O
return	O
&	O
fp	pointer
->	O
ctf_structs	struct
;	O
case	O
CTF_K_UNION	int
:	O
return	O
&	O
fp	pointer
->	O
ctf_unions	struct
;	O
case	O
CTF_K_ENUM	int
:	O
return	O
&	O
fp	pointer
->	O
ctf_enums	struct
;	O
default	O
:	O
return	O
&	O
fp	pointer
->	O
ctf_names	struct
;	O
}	O
}	O
int	O
ctf_dtd_insert	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dtdef_t	struct
*	O
dtd	pointer
,	O
int	O
kind	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
ctf_dynhash_insert	function
(	O
fp	pointer
->	O
ctf_dthash	pointer
,	O
(	O
void	O
*	O
)	O
dtd	pointer
->	O
dtd_type	long
,	O
dtd	pointer
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
&&	O
(	O
name	pointer
=	O
ctf_strraw	function
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
ctf_dynhash_insert	function
(	O
ctf_name_table	function
(	O
fp	pointer
,	O
kind	int
)	O
->	O
ctn_writable	pointer
,	O
(	O
char	O
*	O
)	O
name	pointer
,	O
(	O
void	O
*	O
)	O
dtd	pointer
->	O
dtd_type	long
)	O
<	O
0	int
)	O
{	O
ctf_dynhash_remove	function
(	O
fp	pointer
->	O
ctf_dthash	pointer
,	O
(	O
void	O
*	O
)	O
dtd	pointer
->	O
dtd_type	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
ctf_list_append	function
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
,	O
dtd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ctf_dtd_delete	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dtdef_t	struct
*	O
dtd	pointer
)	O
{	O
ctf_dmdef_t	struct
*	O
dmd	pointer
,	O
*	O
nmd	pointer
;	O
int	O
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
const	O
char	O
*	O
name	pointer
;	O
ctf_dynhash_remove	function
(	O
fp	pointer
->	O
ctf_dthash	pointer
,	O
(	O
void	O
*	O
)	O
dtd	pointer
->	O
dtd_type	long
)	O
;	O
switch	O
(	O
kind	int
)	O
{	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
case	O
CTF_K_ENUM	int
:	O
for	O
(	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
nmd	pointer
)	O
{	O
if	O
(	O
dmd	pointer
->	O
dmd_name	pointer
!=	O
NULL	O
)	O
free	function
(	O
dmd	pointer
->	O
dmd_name	pointer
)	O
;	O
nmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
;	O
free	function
(	O
dmd	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
free	function
(	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_argv	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
&&	O
(	O
name	pointer
=	O
ctf_strraw	function
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
ctf_dynhash_remove	function
(	O
ctf_name_table	function
(	O
fp	pointer
,	O
kind	int
)	O
->	O
ctn_writable	pointer
,	O
name	pointer
)	O
;	O
ctf_str_remove_ref	function
(	O
fp	pointer
,	O
name	pointer
,	O
&	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
;	O
}	O
ctf_list_delete	function
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
,	O
dtd	pointer
)	O
;	O
free	function
(	O
dtd	pointer
)	O
;	O
}	O
ctf_dtdef_t	struct
*	O
ctf_dtd_lookup	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
type	long
)	O
{	O
return	O
(	O
ctf_dtdef_t	struct
*	O
)	O
ctf_dynhash_lookup	function
(	O
fp	pointer
->	O
ctf_dthash	pointer
,	O
(	O
void	O
*	O
)	O
type	long
)	O
;	O
}	O
ctf_dtdef_t	struct
*	O
ctf_dynamic_type	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
id	int
)	O
{	O
ctf_id_t	long
idx	long
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_CHILD	int
)	O
&&	O
LCTF_TYPE_ISPARENT	O
(	O
fp	pointer
,	O
id	int
)	O
)	O
fp	pointer
=	O
fp	pointer
->	O
ctf_parent	pointer
;	O
idx	long
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
id	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
idx	long
<=	O
fp	pointer
->	O
ctf_typemax	long
)	O
return	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
id	int
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
ctf_dvd_insert	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dvdef_t	struct
*	O
dvd	pointer
)	O
{	O
if	O
(	O
ctf_dynhash_insert	function
(	O
fp	pointer
->	O
ctf_dvhash	pointer
,	O
dvd	pointer
->	O
dvd_name	pointer
,	O
dvd	pointer
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
ctf_list_append	function
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
,	O
dvd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ctf_dvd_delete	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dvdef_t	struct
*	O
dvd	pointer
)	O
{	O
ctf_dynhash_remove	function
(	O
fp	pointer
->	O
ctf_dvhash	pointer
,	O
dvd	pointer
->	O
dvd_name	pointer
)	O
;	O
free	function
(	O
dvd	pointer
->	O
dvd_name	pointer
)	O
;	O
ctf_list_delete	function
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
,	O
dvd	pointer
)	O
;	O
free	function
(	O
dvd	pointer
)	O
;	O
}	O
ctf_dvdef_t	struct
*	O
ctf_dvd_lookup	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
ctf_dvdef_t	struct
*	O
)	O
ctf_dynhash_lookup	function
(	O
fp	pointer
->	O
ctf_dvhash	pointer
,	O
name	pointer
)	O
;	O
}	O
int	O
ctf_discard	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
ctf_snapshot_id_t	struct
last_update	struct
=	O
{	O
fp	pointer
->	O
ctf_dtoldid	long
,	O
fp	pointer
->	O
ctf_snapshot_lu	long
+	O
1	int
}	O
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_DIRTY	int
)	O
)	O
return	O
0	int
;	O
return	O
(	O
ctf_rollback	function
(	O
fp	pointer
,	O
last_update	struct
)	O
)	O
;	O
}	O
ctf_snapshot_id_t	struct
ctf_snapshot	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
ctf_snapshot_id_t	struct
snapid	struct
;	O
snapid	struct
.	O
dtd_id	long
=	O
fp	pointer
->	O
ctf_typemax	long
;	O
snapid	struct
.	O
snapshot_id	long
=	O
fp	pointer
->	O
ctf_snapshots	long
++	O
;	O
return	O
snapid	struct
;	O
}	O
int	O
ctf_rollback	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_snapshot_id_t	struct
id	int
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
,	O
*	O
ntd	pointer
;	O
ctf_dvdef_t	struct
*	O
dvd	pointer
,	O
*	O
nvd	pointer
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_snapshot_lu	long
>=	O
id	int
.	O
snapshot_id	long
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_OVERROLLBACK	int
)	O
)	O
;	O
for	O
(	O
dtd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
)	O
;	O
dtd	pointer
!=	O
NULL	O
;	O
dtd	pointer
=	O
ntd	pointer
)	O
{	O
int	O
kind	int
;	O
const	O
char	O
*	O
name	pointer
;	O
ntd	pointer
=	O
ctf_list_next	O
(	O
dtd	pointer
)	O
;	O
if	O
(	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_type	long
)	O
<=	O
id	int
.	O
dtd_id	long
)	O
continue	O
;	O
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
&&	O
(	O
name	pointer
=	O
ctf_strraw	function
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
ctf_dynhash_remove	function
(	O
ctf_name_table	function
(	O
fp	pointer
,	O
kind	int
)	O
->	O
ctn_writable	pointer
,	O
name	pointer
)	O
;	O
ctf_str_remove_ref	function
(	O
fp	pointer
,	O
name	pointer
,	O
&	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
;	O
}	O
ctf_dynhash_remove	function
(	O
fp	pointer
->	O
ctf_dthash	pointer
,	O
(	O
void	O
*	O
)	O
dtd	pointer
->	O
dtd_type	long
)	O
;	O
ctf_dtd_delete	function
(	O
fp	pointer
,	O
dtd	pointer
)	O
;	O
}	O
for	O
(	O
dvd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
)	O
;	O
dvd	pointer
!=	O
NULL	O
;	O
dvd	pointer
=	O
nvd	pointer
)	O
{	O
nvd	pointer
=	O
ctf_list_next	O
(	O
dvd	pointer
)	O
;	O
if	O
(	O
dvd	pointer
->	O
dvd_snapshots	long
<=	O
id	int
.	O
snapshot_id	long
)	O
continue	O
;	O
ctf_dvd_delete	function
(	O
fp	pointer
,	O
dvd	pointer
)	O
;	O
}	O
fp	pointer
->	O
ctf_typemax	long
=	O
id	int
.	O
dtd_id	long
;	O
fp	pointer
->	O
ctf_snapshots	long
=	O
id	int
.	O
snapshot_id	long
;	O
if	O
(	O
fp	pointer
->	O
ctf_snapshots	long
==	O
fp	pointer
->	O
ctf_snapshot_lu	long
)	O
fp	pointer
->	O
ctf_flags	int
&=	O
~	O
LCTF_DIRTY	int
;	O
return	O
0	int
;	O
}	O
static	O
ctf_id_t	long
ctf_add_generic	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
kind	int
,	O
ctf_dtdef_t	struct
*	O
*	O
rp	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
if	O
(	O
flag	int
!=	O
CTF_ADD_NONROOT	int
&&	O
flag	int
!=	O
CTF_ADD_ROOT	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
fp	pointer
->	O
ctf_typemax	long
,	O
1	int
)	O
>=	O
CTF_MAX_TYPE	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_FULL	int
)	O
)	O
;	O
if	O
(	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
fp	pointer
->	O
ctf_typemax	long
,	O
1	int
)	O
==	O
(	O
CTF_MAX_PTYPE	int
-	O
1	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_FULL	int
)	O
)	O
;	O
if	O
(	O
ctf_grow_ptrtab	function
(	O
fp	pointer
)	O
<	O
0	int
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
dtd	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_dtdef_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
type	long
=	O
++	O
fp	pointer
->	O
ctf_typemax	long
;	O
type	long
=	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
type	long
,	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_CHILD	int
)	O
)	O
;	O
memset	function
(	O
dtd	pointer
,	O
0	int
,	O
sizeof	O
(	O
ctf_dtdef_t	struct
)	O
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
=	O
ctf_str_add_ref	function
(	O
fp	pointer
,	O
name	pointer
,	O
&	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
;	O
dtd	pointer
->	O
dtd_type	long
=	O
type	long
;	O
if	O
(	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
==	O
0	int
&&	O
name	pointer
!=	O
NULL	O
&&	O
name	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
free	function
(	O
dtd	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
if	O
(	O
ctf_dtd_insert	function
(	O
fp	pointer
,	O
dtd	pointer
,	O
kind	int
)	O
<	O
0	int
)	O
{	O
free	function
(	O
dtd	pointer
)	O
;	O
return	O
CTF_ERR	O
;	O
}	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
*	O
rp	pointer
=	O
dtd	pointer
;	O
return	O
type	long
;	O
}	O
static	O
size_t	long
clp2	function
(	O
size_t	long
x	long
)	O
{	O
x	long
--	O
;	O
x	long
|=	O
(	O
x	long
>>	O
1	int
)	O
;	O
x	long
|=	O
(	O
x	long
>>	O
2	int
)	O
;	O
x	long
|=	O
(	O
x	long
>>	O
4	int
)	O
;	O
x	long
|=	O
(	O
x	long
>>	O
8	int
)	O
;	O
x	long
|=	O
(	O
x	long
>>	O
16	int
)	O
;	O
return	O
(	O
x	long
+	O
1	int
)	O
;	O
}	O
static	O
ctf_id_t	long
ctf_add_encoded	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
ctf_encoding_t	struct
*	O
ep	pointer
,	O
uint32_t	int
kind	int
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
if	O
(	O
ep	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
kind	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
clp2	function
(	O
P2ROUNDUP	O
(	O
ep	pointer
->	O
cte_bits	int
,	O
CHAR_BIT	O
)	O
/	O
CHAR_BIT	O
)	O
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_enc	struct
=	O
*	O
ep	pointer
;	O
return	O
type	long
;	O
}	O
static	O
ctf_id_t	long
ctf_add_reftype	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	pointer
,	O
uint32_t	int
kind	int
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
ctf_file_t	struct
*	O
tmp	pointer
=	O
fp	pointer
;	O
int	O
child	int
=	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_CHILD	int
;	O
if	O
(	O
ref	pointer
==	O
CTF_ERR	O
||	O
ref	pointer
>	O
CTF_MAX_TYPE	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
ref	pointer
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
NULL	O
,	O
kind	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_type	short
=	O
(	O
uint32_t	int
)	O
ref	pointer
;	O
if	O
(	O
kind	int
!=	O
CTF_K_POINTER	int
)	O
return	O
type	long
;	O
uint32_t	int
type_idx	int
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
type	long
)	O
;	O
uint32_t	int
ref_idx	int
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
ref	pointer
)	O
;	O
if	O
(	O
LCTF_TYPE_ISCHILD	O
(	O
fp	pointer
,	O
ref	pointer
)	O
==	O
child	int
&&	O
ref_idx	int
<	O
fp	pointer
->	O
ctf_typemax	long
)	O
{	O
fp	pointer
->	O
ctf_ptrtab	pointer
[	O
ref_idx	int
]	O
=	O
type_idx	int
;	O
ctf_id_t	long
refref_idx	long
=	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_type	short
)	O
;	O
if	O
(	O
tmp	pointer
==	O
fp	pointer
&&	O
(	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
==	O
CTF_K_TYPEDEF	int
)	O
&&	O
strcmp	function
(	O
ctf_strptr	function
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_name	int
)	O
,	O
""	pointer
)	O
==	O
0	int
&&	O
refref_idx	long
<	O
fp	pointer
->	O
ctf_typemax	long
)	O
fp	pointer
->	O
ctf_ptrtab	pointer
[	O
refref_idx	long
]	O
=	O
type_idx	int
;	O
}	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_slice	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	pointer
,	O
const	O
ctf_encoding_t	struct
*	O
ep	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
int	O
kind	int
;	O
const	O
ctf_type_t	struct
*	O
tp	pointer
;	O
ctf_file_t	struct
*	O
tmp	pointer
=	O
fp	pointer
;	O
if	O
(	O
ep	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
(	O
ep	pointer
->	O
cte_bits	int
>	O
255	int
)	O
||	O
(	O
ep	pointer
->	O
cte_offset	int
>	O
255	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_SLICEOVERFLOW	int
)	O
)	O
;	O
if	O
(	O
ref	pointer
==	O
CTF_ERR	O
||	O
ref	pointer
>	O
CTF_MAX_TYPE	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
(	O
tp	pointer
=	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
ref	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
kind	int
=	O
ctf_type_kind_unsliced	function
(	O
tmp	pointer
,	O
ref	pointer
)	O
;	O
if	O
(	O
(	O
kind	int
!=	O
CTF_K_INTEGER	int
)	O
&&	O
(	O
kind	int
!=	O
CTF_K_FLOAT	int
)	O
&&	O
(	O
kind	int
!=	O
CTF_K_ENUM	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTINTFP	int
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
NULL	O
,	O
CTF_K_SLICE	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_SLICE	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
clp2	function
(	O
P2ROUNDUP	O
(	O
ep	pointer
->	O
cte_bits	int
,	O
CHAR_BIT	O
)	O
/	O
CHAR_BIT	O
)	O
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_slice	struct
.	O
cts_type	int
=	O
ref	pointer
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_slice	struct
.	O
cts_bits	short
=	O
ep	pointer
->	O
cte_bits	int
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_slice	struct
.	O
cts_offset	short
=	O
ep	pointer
->	O
cte_offset	int
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_integer	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
ctf_encoding_t	struct
*	O
ep	pointer
)	O
{	O
return	O
(	O
ctf_add_encoded	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
ep	pointer
,	O
CTF_K_INTEGER	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_float	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
ctf_encoding_t	struct
*	O
ep	pointer
)	O
{	O
return	O
(	O
ctf_add_encoded	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
ep	pointer
,	O
CTF_K_FLOAT	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_pointer	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	pointer
)	O
{	O
return	O
(	O
ctf_add_reftype	function
(	O
fp	pointer
,	O
flag	int
,	O
ref	pointer
,	O
CTF_K_POINTER	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_array	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
ctf_arinfo_t	struct
*	O
arp	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
ctf_file_t	struct
*	O
tmp	pointer
=	O
fp	pointer
;	O
if	O
(	O
arp	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
arp	pointer
->	O
ctr_contents	long
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
tmp	pointer
=	O
fp	pointer
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
arp	pointer
->	O
ctr_index	long
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
NULL	O
,	O
CTF_K_ARRAY	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_ARRAY	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
0	int
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_arr	struct
=	O
*	O
arp	pointer
;	O
return	O
type	long
;	O
}	O
int	O
ctf_set_array	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
type	long
,	O
const	O
ctf_arinfo_t	struct
*	O
arp	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
type	long
)	O
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
dtd	pointer
==	O
NULL	O
||	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
!=	O
CTF_K_ARRAY	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_BADID	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_arr	struct
=	O
*	O
arp	pointer
;	O
return	O
0	int
;	O
}	O
ctf_id_t	long
ctf_add_function	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
ctf_funcinfo_t	struct
*	O
ctc	pointer
,	O
const	O
ctf_id_t	long
*	O
argv	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
uint32_t	int
vlen	int
;	O
ctf_id_t	long
*	O
vdat	pointer
=	O
NULL	O
;	O
ctf_file_t	struct
*	O
tmp	pointer
=	O
fp	pointer
;	O
size_t	long
i	pointer
;	O
if	O
(	O
ctc	pointer
==	O
NULL	O
||	O
(	O
ctc	pointer
->	O
ctc_flags	int
&	O
~	O
CTF_FUNC_VARARG	int
)	O
!=	O
0	int
||	O
(	O
ctc	pointer
->	O
ctc_argc	int
!=	O
0	int
&&	O
argv	pointer
==	O
NULL	O
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
vlen	int
=	O
ctc	pointer
->	O
ctc_argc	int
;	O
if	O
(	O
ctc	pointer
->	O
ctc_flags	int
&	O
CTF_FUNC_VARARG	int
)	O
vlen	int
++	O
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
ctc	pointer
->	O
ctc_return	long
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ctc	pointer
->	O
ctc_argc	int
;	O
i	pointer
++	O
)	O
{	O
tmp	pointer
=	O
fp	pointer
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
argv	pointer
[	O
i	pointer
]	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
}	O
if	O
(	O
vlen	int
>	O
CTF_MAX_VLEN	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EOVERFLOW	int
)	O
)	O
;	O
if	O
(	O
vlen	int
!=	O
0	int
&&	O
(	O
vdat	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_id_t	long
)	O
*	O
vlen	int
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
NULL	O
,	O
CTF_K_FUNCTION	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
{	O
free	function
(	O
vdat	pointer
)	O
;	O
return	O
CTF_ERR	O
;	O
}	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_FUNCTION	int
,	O
flag	int
,	O
vlen	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_type	short
=	O
(	O
uint32_t	int
)	O
ctc	pointer
->	O
ctc_return	long
;	O
memcpy	function
(	O
vdat	pointer
,	O
argv	pointer
,	O
sizeof	O
(	O
ctf_id_t	long
)	O
*	O
ctc	pointer
->	O
ctc_argc	int
)	O
;	O
if	O
(	O
ctc	pointer
->	O
ctc_flags	int
&	O
CTF_FUNC_VARARG	int
)	O
vdat	pointer
[	O
vlen	int
-	O
1	int
]	O
=	O
0	int
;	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_argv	pointer
=	O
vdat	pointer
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_struct_sized	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
size	long
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	function
(	O
fp	pointer
,	O
CTF_K_STRUCT	int
,	O
name	pointer
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
&&	O
ctf_type_kind	function
(	O
fp	pointer
,	O
type	long
)	O
==	O
CTF_K_FORWARD	int
)	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
type	long
)	O
;	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
CTF_K_STRUCT	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_STRUCT	int
,	O
flag	int
,	O
0	int
)	O
;	O
if	O
(	O
size	long
>	O
CTF_MAX_SIZE	int
)	O
{	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	int
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
else	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
size	long
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_struct	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
ctf_add_struct_sized	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
0	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_union_sized	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
size	long
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	function
(	O
fp	pointer
,	O
CTF_K_UNION	int
,	O
name	pointer
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
&&	O
ctf_type_kind	function
(	O
fp	pointer
,	O
type	long
)	O
==	O
CTF_K_FORWARD	int
)	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
type	long
)	O
;	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
CTF_K_UNION	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_UNION	int
,	O
flag	int
,	O
0	int
)	O
;	O
if	O
(	O
size	long
>	O
CTF_MAX_SIZE	int
)	O
{	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	int
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
else	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
size	long
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_union	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
ctf_add_union_sized	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
0	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_enum	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	function
(	O
fp	pointer
,	O
CTF_K_ENUM	int
,	O
name	pointer
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
&&	O
ctf_type_kind	function
(	O
fp	pointer
,	O
type	long
)	O
==	O
CTF_K_FORWARD	int
)	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
type	long
)	O
;	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
CTF_K_ENUM	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_ENUM	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
fp	pointer
->	O
ctf_dmodel	struct
->	O
ctd_int	long
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_enum_encoded	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
ctf_encoding_t	struct
*	O
ep	pointer
)	O
{	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	function
(	O
fp	pointer
,	O
CTF_K_ENUM	int
,	O
name	pointer
)	O
;	O
if	O
(	O
type	long
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ctf_type_kind	function
(	O
fp	pointer
,	O
type	long
)	O
!=	O
CTF_K_FORWARD	int
)	O
&&	O
(	O
ctf_type_kind_unsliced	function
(	O
fp	pointer
,	O
type	long
)	O
!=	O
CTF_K_ENUM	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTINTFP	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
type	long
=	O
ctf_add_enum	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
return	O
ctf_add_slice	function
(	O
fp	pointer
,	O
flag	int
,	O
type	long
,	O
ep	pointer
)	O
;	O
}	O
ctf_id_t	long
ctf_add_forward	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
uint32_t	int
kind	int
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
=	O
0	int
;	O
if	O
(	O
kind	int
!=	O
CTF_K_STRUCT	int
&&	O
kind	int
!=	O
CTF_K_UNION	int
&&	O
kind	int
!=	O
CTF_K_ENUM	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTSUE	int
)	O
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
type	long
=	O
ctf_lookup_by_rawname	function
(	O
fp	pointer
,	O
kind	int
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
CTF_K_FORWARD	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_FORWARD	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_type	short
=	O
kind	int
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_typedef	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
ref	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
ctf_id_t	long
type	long
;	O
ctf_file_t	struct
*	O
tmp	pointer
=	O
fp	pointer
;	O
if	O
(	O
ref	pointer
==	O
CTF_ERR	O
||	O
ref	pointer
>	O
CTF_MAX_TYPE	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
ref	pointer
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_generic	function
(	O
fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
CTF_K_TYPEDEF	int
,	O
&	O
dtd	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
CTF_K_TYPEDEF	int
,	O
flag	int
,	O
0	int
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_type	short
=	O
(	O
uint32_t	int
)	O
ref	pointer
;	O
return	O
type	long
;	O
}	O
ctf_id_t	long
ctf_add_volatile	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	pointer
)	O
{	O
return	O
(	O
ctf_add_reftype	function
(	O
fp	pointer
,	O
flag	int
,	O
ref	pointer
,	O
CTF_K_VOLATILE	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_const	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	pointer
)	O
{	O
return	O
(	O
ctf_add_reftype	function
(	O
fp	pointer
,	O
flag	int
,	O
ref	pointer
,	O
CTF_K_CONST	int
)	O
)	O
;	O
}	O
ctf_id_t	long
ctf_add_restrict	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
uint32_t	int
flag	int
,	O
ctf_id_t	long
ref	pointer
)	O
{	O
return	O
(	O
ctf_add_reftype	function
(	O
fp	pointer
,	O
flag	int
,	O
ref	pointer
,	O
CTF_K_RESTRICT	int
)	O
)	O
;	O
}	O
int	O
ctf_add_enumerator	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
enid	long
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
value	int
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
enid	long
)	O
;	O
ctf_dmdef_t	struct
*	O
dmd	pointer
;	O
uint32_t	int
kind	int
,	O
vlen	int
,	O
root	int
;	O
char	O
*	O
s	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
dtd	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_BADID	int
)	O
)	O
;	O
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
root	int
=	O
LCTF_INFO_ISROOT	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
vlen	int
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
if	O
(	O
kind	int
!=	O
CTF_K_ENUM	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTENUM	int
)	O
)	O
;	O
if	O
(	O
vlen	int
==	O
CTF_MAX_VLEN	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DTFULL	int
)	O
)	O
;	O
for	O
(	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
dmd	pointer
->	O
dmd_name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DUPLICATE	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
dmd	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_dmdef_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
dmd	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
dmd	pointer
->	O
dmd_name	pointer
=	O
s	pointer
;	O
dmd	pointer
->	O
dmd_type	long
=	O
CTF_ERR	O
;	O
dmd	pointer
->	O
dmd_offset	long
=	O
0	int
;	O
dmd	pointer
->	O
dmd_value	int
=	O
value	int
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	int
,	O
root	int
,	O
vlen	int
+	O
1	int
)	O
;	O
ctf_list_append	function
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
,	O
dmd	pointer
)	O
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
return	O
0	int
;	O
}	O
int	O
ctf_add_member_offset	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
souid	long
,	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
,	O
unsigned	O
long	O
bit_offset	long
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
souid	long
)	O
;	O
ctf_dmdef_t	struct
*	O
dmd	pointer
;	O
ssize_t	long
msize	long
,	O
malign	long
,	O
ssize	long
;	O
uint32_t	int
kind	int
,	O
vlen	int
,	O
root	int
;	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
dtd	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_BADID	int
)	O
)	O
;	O
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
root	int
=	O
LCTF_INFO_ISROOT	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
vlen	int
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
if	O
(	O
kind	int
!=	O
CTF_K_STRUCT	int
&&	O
kind	int
!=	O
CTF_K_UNION	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTSOU	int
)	O
)	O
;	O
if	O
(	O
vlen	int
==	O
CTF_MAX_VLEN	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DTFULL	int
)	O
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
)	O
{	O
if	O
(	O
dmd	pointer
->	O
dmd_name	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
dmd	pointer
->	O
dmd_name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DUPLICATE	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
msize	long
=	O
ctf_type_size	function
(	O
fp	pointer
,	O
type	long
)	O
)	O
<	O
0	int
||	O
(	O
malign	long
=	O
ctf_type_align	function
(	O
fp	pointer
,	O
type	long
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
dmd	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_dmdef_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
dmd	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
dmd	pointer
->	O
dmd_name	pointer
=	O
s	pointer
;	O
dmd	pointer
->	O
dmd_type	long
=	O
type	long
;	O
dmd	pointer
->	O
dmd_value	int
=	O
-	O
1	int
;	O
if	O
(	O
kind	int
==	O
CTF_K_STRUCT	int
&&	O
vlen	int
!=	O
0	int
)	O
{	O
if	O
(	O
bit_offset	long
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
{	O
ctf_dmdef_t	struct
*	O
lmd	pointer
=	O
ctf_list_prev	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
ctf_id_t	long
ltype	long
=	O
ctf_type_resolve	function
(	O
fp	pointer
,	O
lmd	pointer
->	O
dmd_type	long
)	O
;	O
size_t	long
off	long
=	O
lmd	pointer
->	O
dmd_offset	long
;	O
ctf_encoding_t	struct
linfo	struct
;	O
ssize_t	long
lsize	long
;	O
if	O
(	O
ctf_type_encoding	function
(	O
fp	pointer
,	O
ltype	long
,	O
&	O
linfo	struct
)	O
==	O
0	int
)	O
off	long
+=	O
linfo	struct
.	O
cte_bits	int
;	O
else	O
if	O
(	O
(	O
lsize	long
=	O
ctf_type_size	function
(	O
fp	pointer
,	O
ltype	long
)	O
)	O
>	O
0	int
)	O
off	long
+=	O
lsize	long
*	O
CHAR_BIT	O
;	O
off	long
=	O
roundup	O
(	O
off	long
,	O
CHAR_BIT	O
)	O
/	O
CHAR_BIT	O
;	O
off	long
=	O
roundup	O
(	O
off	long
,	O
MAX	O
(	O
malign	long
,	O
1	int
)	O
)	O
;	O
dmd	pointer
->	O
dmd_offset	long
=	O
off	long
*	O
CHAR_BIT	O
;	O
ssize	long
=	O
off	long
+	O
msize	long
;	O
}	O
else	O
{	O
dmd	pointer
->	O
dmd_offset	long
=	O
bit_offset	long
;	O
ssize	long
=	O
ctf_get_ctt_size	function
(	O
fp	pointer
,	O
&	O
dtd	pointer
->	O
dtd_data	struct
,	O
NULL	O
,	O
NULL	O
)	O
;	O
ssize	long
=	O
MAX	O
(	O
ssize	long
,	O
(	O
(	O
signed	O
)	O
bit_offset	long
/	O
CHAR_BIT	O
)	O
+	O
msize	long
)	O
;	O
}	O
}	O
else	O
{	O
dmd	pointer
->	O
dmd_offset	long
=	O
0	int
;	O
ssize	long
=	O
ctf_get_ctt_size	function
(	O
fp	pointer
,	O
&	O
dtd	pointer
->	O
dtd_data	struct
,	O
NULL	O
,	O
NULL	O
)	O
;	O
ssize	long
=	O
MAX	O
(	O
ssize	long
,	O
msize	long
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
ssize	long
>	O
CTF_MAX_SIZE	int
)	O
{	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	int
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
ssize	long
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
ssize	long
)	O
;	O
}	O
else	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
ssize	long
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	int
,	O
root	int
,	O
vlen	int
+	O
1	int
)	O
;	O
ctf_list_append	function
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
,	O
dmd	pointer
)	O
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
return	O
0	int
;	O
}	O
int	O
ctf_add_member_encoded	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
souid	long
,	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
,	O
unsigned	O
long	O
bit_offset	long
,	O
const	O
ctf_encoding_t	struct
encoding	int
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
=	O
ctf_dtd_lookup	function
(	O
fp	pointer
,	O
type	long
)	O
;	O
int	O
kind	int
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
)	O
;	O
int	O
otype	int
=	O
type	long
;	O
if	O
(	O
(	O
kind	int
!=	O
CTF_K_INTEGER	int
)	O
&&	O
(	O
kind	int
!=	O
CTF_K_FLOAT	int
)	O
&&	O
(	O
kind	int
!=	O
CTF_K_ENUM	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTINTFP	int
)	O
)	O
;	O
if	O
(	O
(	O
type	long
=	O
ctf_add_slice	function
(	O
fp	pointer
,	O
CTF_ADD_NONROOT	int
,	O
otype	int
,	O
&	O
encoding	int
)	O
)	O
==	O
CTF_ERR	O
)	O
return	O
-	O
1	int
;	O
return	O
ctf_add_member_offset	function
(	O
fp	pointer
,	O
souid	long
,	O
name	pointer
,	O
type	long
,	O
bit_offset	long
)	O
;	O
}	O
int	O
ctf_add_member	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
souid	long
,	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
)	O
{	O
return	O
ctf_add_member_offset	function
(	O
fp	pointer
,	O
souid	long
,	O
name	pointer
,	O
type	long
,	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
;	O
}	O
int	O
ctf_add_variable	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
ref	pointer
)	O
{	O
ctf_dvdef_t	struct
*	O
dvd	pointer
;	O
ctf_file_t	struct
*	O
tmp	pointer
=	O
fp	pointer
;	O
if	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
ctf_dvd_lookup	function
(	O
fp	pointer
,	O
name	pointer
)	O
!=	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DUPLICATE	int
)	O
)	O
;	O
if	O
(	O
ctf_lookup_by_id	function
(	O
&	O
tmp	pointer
,	O
ref	pointer
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
ctf_type_resolve	function
(	O
fp	pointer
,	O
ref	pointer
)	O
==	O
CTF_ERR	O
)	O
&&	O
(	O
ctf_errno	function
(	O
fp	pointer
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
dvd	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_dvdef_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
(	O
dvd	pointer
->	O
dvd_name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
dvd	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
dvd	pointer
->	O
dvd_type	long
=	O
ref	pointer
;	O
dvd	pointer
->	O
dvd_snapshots	long
=	O
fp	pointer
->	O
ctf_snapshots	long
;	O
if	O
(	O
ctf_dvd_insert	function
(	O
fp	pointer
,	O
dvd	pointer
)	O
<	O
0	int
)	O
{	O
free	function
(	O
dvd	pointer
->	O
dvd_name	pointer
)	O
;	O
free	function
(	O
dvd	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
enumcmp	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
value	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
ctf_bundle_t	struct
*	O
ctb	pointer
=	O
arg	pointer
;	O
int	O
bvalue	int
;	O
if	O
(	O
ctf_enum_value	function
(	O
ctb	pointer
->	O
ctb_file	pointer
,	O
ctb	pointer
->	O
ctb_type	long
,	O
name	pointer
,	O
&	O
bvalue	int
)	O
<	O
0	int
)	O
{	O
ctf_dprintf	function
(	O
"Conflict due to member %s iteration error: %s.\n"	pointer
,	O
name	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctb	pointer
->	O
ctb_file	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
value	int
!=	O
bvalue	int
)	O
{	O
ctf_dprintf	function
(	O
"Conflict due to value change: %i versus %i\n"	pointer
,	O
value	int
,	O
bvalue	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
enumadd	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
value	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
ctf_bundle_t	struct
*	O
ctb	pointer
=	O
arg	pointer
;	O
return	O
(	O
ctf_add_enumerator	function
(	O
ctb	pointer
->	O
ctb_file	pointer
,	O
ctb	pointer
->	O
ctb_type	long
,	O
name	pointer
,	O
value	int
)	O
<	O
0	int
)	O
;	O
}	O
static	O
int	O
membcmp	function
(	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
_libctf_unused_	O
,	O
unsigned	O
long	O
offset	long
,	O
void	O
*	O
arg	pointer
)	O
{	O
ctf_bundle_t	struct
*	O
ctb	pointer
=	O
arg	pointer
;	O
ctf_membinfo_t	struct
ctm	struct
;	O
if	O
(	O
ctf_member_info	function
(	O
ctb	pointer
->	O
ctb_file	pointer
,	O
ctb	pointer
->	O
ctb_type	long
,	O
name	pointer
,	O
&	O
ctm	struct
)	O
<	O
0	int
)	O
{	O
ctf_dprintf	function
(	O
"Conflict due to member %s iteration error: %s.\n"	pointer
,	O
name	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctb	pointer
->	O
ctb_file	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ctm	struct
.	O
ctm_offset	short
!=	O
offset	long
)	O
{	O
ctf_dprintf	function
(	O
"Conflict due to member %s offset change: "	pointer
"%lx versus %lx\n"	pointer
,	O
name	pointer
,	O
ctm	struct
.	O
ctm_offset	short
,	O
offset	long
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
membadd	function
(	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
,	O
unsigned	O
long	O
offset	long
,	O
void	O
*	O
arg	pointer
)	O
{	O
ctf_bundle_t	struct
*	O
ctb	pointer
=	O
arg	pointer
;	O
ctf_dmdef_t	struct
*	O
dmd	pointer
;	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
dmd	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_dmdef_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
ctb	pointer
->	O
ctb_file	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
dmd	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
ctb	pointer
->	O
ctb_file	pointer
,	O
EAGAIN	int
)	O
)	O
;	O
}	O
dmd	pointer
->	O
dmd_name	pointer
=	O
s	pointer
;	O
dmd	pointer
->	O
dmd_type	long
=	O
type	long
;	O
dmd	pointer
->	O
dmd_offset	long
=	O
offset	long
;	O
dmd	pointer
->	O
dmd_value	int
=	O
-	O
1	int
;	O
ctf_list_append	function
(	O
&	O
ctb	pointer
->	O
ctb_dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
,	O
dmd	pointer
)	O
;	O
ctb	pointer
->	O
ctb_file	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
return	O
0	int
;	O
}	O
static	O
ctf_id_t	long
ctf_add_type_internal	function
(	O
ctf_file_t	struct
*	O
dst_fp	pointer
,	O
ctf_file_t	struct
*	O
src_fp	pointer
,	O
ctf_id_t	long
src_type	long
,	O
ctf_file_t	struct
*	O
proc_tracking_fp	pointer
)	O
{	O
ctf_id_t	long
dst_type	long
=	O
CTF_ERR	O
;	O
uint32_t	int
dst_kind	int
=	O
CTF_K_UNKNOWN	int
;	O
ctf_file_t	struct
*	O
tmp_fp	pointer
=	O
dst_fp	pointer
;	O
ctf_id_t	long
tmp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
uint32_t	int
kind	int
,	O
forward_kind	int
,	O
flag	int
,	O
vlen	int
;	O
const	O
ctf_type_t	struct
*	O
src_tp	pointer
,	O
*	O
dst_tp	pointer
;	O
ctf_bundle_t	struct
src	pointer
,	O
dst	pointer
;	O
ctf_encoding_t	struct
src_en	struct
,	O
dst_en	struct
;	O
ctf_arinfo_t	struct
src_ar	struct
,	O
dst_ar	struct
;	O
ctf_funcinfo_t	struct
ctc	pointer
;	O
ctf_id_t	long
orig_src_type	long
=	O
src_type	long
;	O
if	O
(	O
!	O
(	O
dst_fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_RDONLY	int
)	O
)	O
;	O
if	O
(	O
(	O
src_tp	pointer
=	O
ctf_lookup_by_id	function
(	O
&	O
src_fp	pointer
,	O
src_type	long
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ctf_errno	function
(	O
src_fp	pointer
)	O
)	O
)	O
;	O
if	O
(	O
(	O
ctf_type_resolve	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
==	O
CTF_ERR	O
)	O
&&	O
(	O
ctf_errno	function
(	O
src_fp	pointer
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_NONREPRESENTABLE	int
)	O
)	O
;	O
name	pointer
=	O
ctf_strptr	function
(	O
src_fp	pointer
,	O
src_tp	pointer
->	O
ctt_name	int
)	O
;	O
kind	int
=	O
LCTF_INFO_KIND	O
(	O
src_fp	pointer
,	O
src_tp	pointer
->	O
ctt_info	short
)	O
;	O
flag	int
=	O
LCTF_INFO_ISROOT	O
(	O
src_fp	pointer
,	O
src_tp	pointer
->	O
ctt_info	short
)	O
;	O
vlen	int
=	O
LCTF_INFO_VLEN	O
(	O
src_fp	pointer
,	O
src_tp	pointer
->	O
ctt_info	short
)	O
;	O
tmp	pointer
=	O
ctf_type_mapping	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
&	O
tmp_fp	pointer
)	O
;	O
if	O
(	O
tmp	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
ctf_dynhash_lookup	function
(	O
proc_tracking_fp	pointer
->	O
ctf_add_processing	pointer
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
src_type	long
)	O
)	O
return	O
tmp	pointer
;	O
if	O
(	O
(	O
ctf_type_kind_unsliced	function
(	O
tmp_fp	pointer
,	O
tmp	pointer
)	O
==	O
(	O
int	O
)	O
kind	int
)	O
&&	O
(	O
kind	int
==	O
CTF_K_STRUCT	int
||	O
kind	int
==	O
CTF_K_UNION	int
||	O
kind	int
==	O
CTF_K_ENUM	int
)	O
)	O
{	O
if	O
(	O
(	O
dst_tp	pointer
=	O
ctf_lookup_by_id	function
(	O
&	O
tmp_fp	pointer
,	O
dst_type	long
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
vlen	int
==	O
LCTF_INFO_VLEN	O
(	O
tmp_fp	pointer
,	O
dst_tp	pointer
->	O
ctt_info	short
)	O
)	O
return	O
tmp	pointer
;	O
}	O
}	O
forward_kind	int
=	O
kind	int
;	O
if	O
(	O
kind	int
==	O
CTF_K_FORWARD	int
)	O
forward_kind	int
=	O
src_tp	pointer
->	O
ctt_type	short
;	O
if	O
(	O
(	O
flag	int
&	O
CTF_ADD_ROOT	int
)	O
&&	O
name	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
(	O
tmp	pointer
=	O
ctf_lookup_by_rawname	function
(	O
dst_fp	pointer
,	O
forward_kind	int
,	O
name	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
dst_type	long
=	O
tmp	pointer
;	O
dst_kind	int
=	O
ctf_type_kind_unsliced	function
(	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
}	O
if	O
(	O
dst_type	long
!=	O
CTF_ERR	O
&&	O
dst_kind	int
!=	O
kind	int
)	O
{	O
if	O
(	O
kind	int
==	O
CTF_K_FORWARD	int
&&	O
(	O
dst_kind	int
==	O
CTF_K_ENUM	int
||	O
dst_kind	int
==	O
CTF_K_STRUCT	int
||	O
dst_kind	int
==	O
CTF_K_UNION	int
)	O
)	O
{	O
ctf_add_type_mapping	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
return	O
dst_type	long
;	O
}	O
if	O
(	O
dst_kind	int
!=	O
CTF_K_FORWARD	int
||	O
(	O
kind	int
!=	O
CTF_K_ENUM	int
&&	O
kind	int
!=	O
CTF_K_STRUCT	int
&&	O
kind	int
!=	O
CTF_K_UNION	int
)	O
)	O
{	O
ctf_dprintf	function
(	O
"Conflict for type %s: kinds differ, new: %i; "	pointer
"old (ID %lx): %i\n"	pointer
,	O
name	pointer
,	O
kind	int
,	O
dst_type	long
,	O
dst_kind	int
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
kind	int
==	O
CTF_K_INTEGER	int
||	O
kind	int
==	O
CTF_K_FLOAT	int
||	O
kind	int
==	O
CTF_K_SLICE	int
)	O
{	O
if	O
(	O
ctf_type_encoding	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
&	O
src_en	struct
)	O
!=	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ctf_errno	function
(	O
src_fp	pointer
)	O
)	O
)	O
;	O
if	O
(	O
dst_type	long
!=	O
CTF_ERR	O
)	O
{	O
ctf_file_t	struct
*	O
fp	pointer
=	O
dst_fp	pointer
;	O
if	O
(	O
(	O
dst_tp	pointer
=	O
ctf_lookup_by_id	function
(	O
&	O
fp	pointer
,	O
dst_type	long
)	O
)	O
==	O
NULL	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
ctf_type_encoding	function
(	O
dst_fp	pointer
,	O
dst_type	long
,	O
&	O
dst_en	struct
)	O
!=	O
0	int
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
LCTF_INFO_ISROOT	O
(	O
fp	pointer
,	O
dst_tp	pointer
->	O
ctt_info	short
)	O
&	O
CTF_ADD_ROOT	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
&	O
src_en	struct
,	O
&	O
dst_en	struct
,	O
sizeof	O
(	O
ctf_encoding_t	struct
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
kind	int
!=	O
CTF_K_SLICE	int
)	O
{	O
ctf_add_type_mapping	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
return	O
dst_type	long
;	O
}	O
}	O
else	O
{	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
memcmp	function
(	O
&	O
src_en	struct
,	O
&	O
dst_en	struct
,	O
sizeof	O
(	O
ctf_encoding_t	struct
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
kind	int
!=	O
CTF_K_SLICE	int
)	O
{	O
ctf_add_type_mapping	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
return	O
dst_type	long
;	O
}	O
}	O
}	O
}	O
}	O
src	pointer
.	O
ctb_file	pointer
=	O
src_fp	pointer
;	O
src	pointer
.	O
ctb_type	long
=	O
src_type	long
;	O
src	pointer
.	O
ctb_dtd	pointer
=	O
NULL	O
;	O
dst	pointer
.	O
ctb_file	pointer
=	O
dst_fp	pointer
;	O
dst	pointer
.	O
ctb_type	long
=	O
dst_type	long
;	O
dst	pointer
.	O
ctb_dtd	pointer
=	O
NULL	O
;	O
if	O
(	O
ctf_dynhash_insert	function
(	O
proc_tracking_fp	pointer
->	O
ctf_add_processing	pointer
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
src_type	long
,	O
(	O
void	O
*	O
)	O
1	int
)	O
<	O
0	int
)	O
return	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ENOMEM	int
)	O
;	O
switch	O
(	O
kind	int
)	O
{	O
case	O
CTF_K_INTEGER	int
:	O
dst_type	long
=	O
ctf_add_integer	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
&	O
src_en	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_FLOAT	int
:	O
dst_type	long
=	O
ctf_add_float	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
&	O
src_en	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_SLICE	int
:	O
src_type	long
=	O
ctf_type_reference	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
;	O
src_type	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_type	long
,	O
proc_tracking_fp	pointer
)	O
;	O
if	O
(	O
src_type	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst_type	long
=	O
ctf_add_slice	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
src_type	long
,	O
&	O
src_en	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_POINTER	int
:	O
case	O
CTF_K_VOLATILE	int
:	O
case	O
CTF_K_CONST	int
:	O
case	O
CTF_K_RESTRICT	int
:	O
src_type	long
=	O
ctf_type_reference	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
;	O
src_type	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_type	long
,	O
proc_tracking_fp	pointer
)	O
;	O
if	O
(	O
src_type	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst_type	long
=	O
ctf_add_reftype	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
src_type	long
,	O
kind	int
)	O
;	O
break	O
;	O
case	O
CTF_K_ARRAY	int
:	O
if	O
(	O
ctf_array_info	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
&	O
src_ar	struct
)	O
!=	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ctf_errno	function
(	O
src_fp	pointer
)	O
)	O
)	O
;	O
src_ar	struct
.	O
ctr_contents	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_ar	struct
.	O
ctr_contents	long
,	O
proc_tracking_fp	pointer
)	O
;	O
src_ar	struct
.	O
ctr_index	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_ar	struct
.	O
ctr_index	long
,	O
proc_tracking_fp	pointer
)	O
;	O
src_ar	struct
.	O
ctr_nelems	int
=	O
src_ar	struct
.	O
ctr_nelems	int
;	O
if	O
(	O
src_ar	struct
.	O
ctr_contents	long
==	O
CTF_ERR	O
||	O
src_ar	struct
.	O
ctr_index	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
dst_type	long
!=	O
CTF_ERR	O
)	O
{	O
if	O
(	O
ctf_array_info	function
(	O
dst_fp	pointer
,	O
dst_type	long
,	O
&	O
dst_ar	struct
)	O
!=	O
0	int
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
memcmp	function
(	O
&	O
src_ar	struct
,	O
&	O
dst_ar	struct
,	O
sizeof	O
(	O
ctf_arinfo_t	struct
)	O
)	O
)	O
{	O
ctf_dprintf	function
(	O
"Conflict for type %s against ID %lx: "	pointer
"array info differs, old %lx/%lx/%x; "	pointer
"new: %lx/%lx/%x\n"	pointer
,	O
name	pointer
,	O
dst_type	long
,	O
src_ar	struct
.	O
ctr_contents	long
,	O
src_ar	struct
.	O
ctr_index	long
,	O
src_ar	struct
.	O
ctr_nelems	int
,	O
dst_ar	struct
.	O
ctr_contents	long
,	O
dst_ar	struct
.	O
ctr_index	long
,	O
dst_ar	struct
.	O
ctr_nelems	int
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
else	O
dst_type	long
=	O
ctf_add_array	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
&	O
src_ar	struct
)	O
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
ctc	pointer
.	O
ctc_return	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_tp	pointer
->	O
ctt_type	short
,	O
proc_tracking_fp	pointer
)	O
;	O
ctc	pointer
.	O
ctc_argc	int
=	O
0	int
;	O
ctc	pointer
.	O
ctc_flags	int
=	O
0	int
;	O
if	O
(	O
ctc	pointer
.	O
ctc_return	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst_type	long
=	O
ctf_add_function	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
&	O
ctc	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
{	O
ctf_dmdef_t	struct
*	O
dmd	pointer
;	O
int	O
errs	int
=	O
0	int
;	O
size_t	long
size	long
;	O
ssize_t	long
ssize	long
;	O
ctf_dtdef_t	struct
*	O
dtd	pointer
;	O
if	O
(	O
dst_type	long
!=	O
CTF_ERR	O
&&	O
kind	int
!=	O
CTF_K_FORWARD	int
&&	O
dst_kind	int
!=	O
CTF_K_FORWARD	int
)	O
{	O
if	O
(	O
ctf_type_size	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
!=	O
ctf_type_size	function
(	O
dst_fp	pointer
,	O
dst_type	long
)	O
)	O
{	O
ctf_dprintf	function
(	O
"Conflict for type %s against ID %lx: "	pointer
"union size differs, old %li, new %li\n"	pointer
,	O
name	pointer
,	O
dst_type	long
,	O
(	O
long	O
)	O
ctf_type_size	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
,	O
(	O
long	O
)	O
ctf_type_size	function
(	O
dst_fp	pointer
,	O
dst_type	long
)	O
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
if	O
(	O
ctf_member_iter	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
membcmp	function
,	O
&	O
dst	pointer
)	O
)	O
{	O
ctf_dprintf	function
(	O
"Conflict for type %s against ID %lx: "	pointer
"members differ, see above\n"	pointer
,	O
name	pointer
,	O
dst_type	long
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
break	O
;	O
}	O
dst_type	long
=	O
ctf_add_generic	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
kind	int
,	O
&	O
dtd	pointer
)	O
;	O
if	O
(	O
dst_type	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
dst	pointer
.	O
ctb_type	long
=	O
dst_type	long
;	O
dst	pointer
.	O
ctb_dtd	pointer
=	O
dtd	pointer
;	O
ctf_add_type_mapping	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
if	O
(	O
ctf_member_iter	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
membadd	function
,	O
&	O
dst	pointer
)	O
!=	O
0	int
)	O
errs	int
++	O
;	O
if	O
(	O
(	O
ssize	long
=	O
ctf_type_size	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
)	O
<	O
0	int
)	O
return	O
CTF_ERR	O
;	O
size	long
=	O
(	O
size_t	long
)	O
ssize	long
;	O
if	O
(	O
size	long
>	O
CTF_MAX_SIZE	int
)	O
{	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
CTF_LSIZE_SENT	int
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
else	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_size	short
=	O
(	O
uint32_t	int
)	O
size	long
;	O
dtd	pointer
->	O
dtd_data	struct
.	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	int
,	O
flag	int
,	O
vlen	int
)	O
;	O
for	O
(	O
dmd	pointer
=	O
ctf_list_next	O
(	O
&	O
dtd	pointer
->	O
dtd_u	union
.	O
dtu_members	struct
)	O
;	O
dmd	pointer
!=	O
NULL	O
;	O
dmd	pointer
=	O
ctf_list_next	O
(	O
dmd	pointer
)	O
)	O
{	O
ctf_file_t	struct
*	O
dst	pointer
=	O
dst_fp	pointer
;	O
ctf_id_t	long
memb_type	long
;	O
memb_type	long
=	O
ctf_type_mapping	function
(	O
src_fp	pointer
,	O
dmd	pointer
->	O
dmd_type	long
,	O
&	O
dst	pointer
)	O
;	O
if	O
(	O
memb_type	long
==	O
0	int
)	O
{	O
if	O
(	O
(	O
dmd	pointer
->	O
dmd_type	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
dmd	pointer
->	O
dmd_type	long
,	O
proc_tracking_fp	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
{	O
if	O
(	O
ctf_errno	function
(	O
dst_fp	pointer
)	O
!=	O
ECTF_NONREPRESENTABLE	int
)	O
errs	int
++	O
;	O
}	O
}	O
else	O
dmd	pointer
->	O
dmd_type	long
=	O
memb_type	long
;	O
}	O
if	O
(	O
errs	int
)	O
return	O
CTF_ERR	O
;	O
break	O
;	O
}	O
case	O
CTF_K_ENUM	int
:	O
if	O
(	O
dst_type	long
!=	O
CTF_ERR	O
&&	O
kind	int
!=	O
CTF_K_FORWARD	int
&&	O
dst_kind	int
!=	O
CTF_K_FORWARD	int
)	O
{	O
if	O
(	O
ctf_enum_iter	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
enumcmp	function
,	O
&	O
dst	pointer
)	O
||	O
ctf_enum_iter	function
(	O
dst_fp	pointer
,	O
dst_type	long
,	O
enumcmp	function
,	O
&	O
src	pointer
)	O
)	O
{	O
ctf_dprintf	function
(	O
"Conflict for enum %s against ID %lx: "	pointer
"members differ, see above\n"	pointer
,	O
name	pointer
,	O
dst_type	long
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CONFLICT	int
)	O
)	O
;	O
}	O
}	O
else	O
{	O
dst_type	long
=	O
ctf_add_enum	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
dst	pointer
.	O
ctb_type	long
=	O
dst_type	long
)	O
==	O
CTF_ERR	O
||	O
ctf_enum_iter	function
(	O
src_fp	pointer
,	O
src_type	long
,	O
enumadd	function
,	O
&	O
dst	pointer
)	O
)	O
return	O
CTF_ERR	O
;	O
}	O
break	O
;	O
case	O
CTF_K_FORWARD	int
:	O
if	O
(	O
dst_type	long
==	O
CTF_ERR	O
)	O
dst_type	long
=	O
ctf_add_forward	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
forward_kind	int
)	O
;	O
break	O
;	O
case	O
CTF_K_TYPEDEF	int
:	O
src_type	long
=	O
ctf_type_reference	function
(	O
src_fp	pointer
,	O
src_type	long
)	O
;	O
src_type	long
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_type	long
,	O
proc_tracking_fp	pointer
)	O
;	O
if	O
(	O
src_type	long
==	O
CTF_ERR	O
)	O
return	O
CTF_ERR	O
;	O
if	O
(	O
dst_type	long
==	O
CTF_ERR	O
)	O
dst_type	long
=	O
ctf_add_typedef	function
(	O
dst_fp	pointer
,	O
flag	int
,	O
name	pointer
,	O
src_type	long
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
}	O
if	O
(	O
dst_type	long
!=	O
CTF_ERR	O
)	O
ctf_add_type_mapping	function
(	O
src_fp	pointer
,	O
orig_src_type	long
,	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
return	O
dst_type	long
;	O
}	O
ctf_id_t	long
ctf_add_type	function
(	O
ctf_file_t	struct
*	O
dst_fp	pointer
,	O
ctf_file_t	struct
*	O
src_fp	pointer
,	O
ctf_id_t	long
src_type	long
)	O
{	O
ctf_id_t	long
id	int
;	O
if	O
(	O
!	O
src_fp	pointer
->	O
ctf_add_processing	pointer
)	O
src_fp	pointer
->	O
ctf_add_processing	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_integer	function
,	O
ctf_hash_eq_integer	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
src_fp	pointer
->	O
ctf_add_processing	pointer
)	O
return	O
(	O
ctf_set_errno	function
(	O
dst_fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
id	int
=	O
ctf_add_type_internal	function
(	O
dst_fp	pointer
,	O
src_fp	pointer
,	O
src_type	long
,	O
src_fp	pointer
)	O
;	O
ctf_dynhash_empty	function
(	O
src_fp	pointer
->	O
ctf_add_processing	pointer
)	O
;	O
return	O
id	int
;	O
}	O
int	O
ctf_gzwrite	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
gzFile	pointer
fd	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
buf	pointer
;	O
ssize_t	long
resid	long
;	O
ssize_t	long
len	int
;	O
resid	long
=	O
sizeof	O
(	O
ctf_header_t	struct
)	O
;	O
buf	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_header	struct
;	O
while	O
(	O
resid	long
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
gzwrite	function
(	O
fd	int
,	O
buf	pointer
,	O
resid	long
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
resid	long
-=	O
len	int
;	O
buf	pointer
+=	O
len	int
;	O
}	O
resid	long
=	O
fp	pointer
->	O
ctf_size	long
;	O
buf	pointer
=	O
fp	pointer
->	O
ctf_buf	pointer
;	O
while	O
(	O
resid	long
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
gzwrite	function
(	O
fd	int
,	O
buf	pointer
,	O
resid	long
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
resid	long
-=	O
len	int
;	O
buf	pointer
+=	O
len	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
ctf_compress_write	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
int	O
fd	int
)	O
{	O
unsigned	O
char	O
*	O
buf	pointer
;	O
unsigned	O
char	O
*	O
bp	pointer
;	O
ctf_header_t	struct
h	pointer
;	O
ctf_header_t	struct
*	O
hp	pointer
=	O
&	O
h	pointer
;	O
ssize_t	long
header_len	long
=	O
sizeof	O
(	O
ctf_header_t	struct
)	O
;	O
ssize_t	long
compress_len	long
;	O
ssize_t	long
len	int
;	O
int	O
rc	int
;	O
int	O
err	long
=	O
0	int
;	O
if	O
(	O
ctf_serialize	function
(	O
fp	pointer
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
memcpy	function
(	O
hp	pointer
,	O
fp	pointer
->	O
ctf_header	struct
,	O
header_len	long
)	O
;	O
hp	pointer
->	O
cth_flags	O
|=	O
CTF_F_COMPRESS	int
;	O
compress_len	long
=	O
compressBound	function
(	O
fp	pointer
->	O
ctf_size	long
)	O
;	O
if	O
(	O
(	O
buf	pointer
=	O
malloc	function
(	O
compress_len	long
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_ZALLOC	int
)	O
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
compress	function
(	O
buf	pointer
,	O
(	O
uLongf	long
*	O
)	O
&	O
compress_len	long
,	O
fp	pointer
->	O
ctf_buf	pointer
,	O
fp	pointer
->	O
ctf_size	long
)	O
)	O
!=	O
Z_OK	int
)	O
{	O
ctf_dprintf	function
(	O
"zlib deflate err: %s\n"	pointer
,	O
zError	function
(	O
rc	int
)	O
)	O
;	O
err	long
=	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_COMPRESS	int
)	O
;	O
goto	O
ret	pointer
;	O
}	O
while	O
(	O
header_len	long
>	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	pointer
(	O
fd	int
,	O
hp	pointer
,	O
header_len	long
)	O
)	O
<	O
0	int
)	O
{	O
err	long
=	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
;	O
goto	O
ret	pointer
;	O
}	O
header_len	long
-=	O
len	int
;	O
hp	pointer
+=	O
len	int
;	O
}	O
bp	pointer
=	O
buf	pointer
;	O
while	O
(	O
compress_len	long
>	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	pointer
(	O
fd	int
,	O
bp	pointer
,	O
compress_len	long
)	O
)	O
<	O
0	int
)	O
{	O
err	long
=	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
;	O
goto	O
ret	pointer
;	O
}	O
compress_len	long
-=	O
len	int
;	O
bp	pointer
+=	O
len	int
;	O
}	O
ret	pointer
:	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
err	long
;	O
}	O
unsigned	O
char	O
*	O
ctf_write_mem	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
size_t	long
*	O
size	long
,	O
size_t	long
threshold	long
)	O
{	O
unsigned	O
char	O
*	O
buf	pointer
;	O
unsigned	O
char	O
*	O
bp	pointer
;	O
ctf_header_t	struct
*	O
hp	pointer
;	O
ssize_t	long
header_len	long
=	O
sizeof	O
(	O
ctf_header_t	struct
)	O
;	O
ssize_t	long
compress_len	long
;	O
int	O
rc	int
;	O
if	O
(	O
ctf_serialize	function
(	O
fp	pointer
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
compress_len	long
=	O
compressBound	function
(	O
fp	pointer
->	O
ctf_size	long
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_size	long
<	O
threshold	long
)	O
compress_len	long
=	O
fp	pointer
->	O
ctf_size	long
;	O
if	O
(	O
(	O
buf	pointer
=	O
malloc	function
(	O
compress_len	long
+	O
sizeof	O
(	O
struct	O
ctf_header	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
NULL	O
;	O
}	O
hp	pointer
=	O
(	O
ctf_header_t	struct
*	O
)	O
buf	pointer
;	O
memcpy	function
(	O
hp	pointer
,	O
fp	pointer
->	O
ctf_header	struct
,	O
header_len	long
)	O
;	O
bp	pointer
=	O
buf	pointer
+	O
sizeof	O
(	O
struct	O
ctf_header	struct
)	O
;	O
*	O
size	long
=	O
sizeof	O
(	O
struct	O
ctf_header	struct
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_size	long
<	O
threshold	long
)	O
{	O
hp	pointer
->	O
cth_flags	O
&=	O
~	O
CTF_F_COMPRESS	int
;	O
memcpy	function
(	O
bp	pointer
,	O
fp	pointer
->	O
ctf_buf	pointer
,	O
fp	pointer
->	O
ctf_size	long
)	O
;	O
*	O
size	long
+=	O
fp	pointer
->	O
ctf_size	long
;	O
}	O
else	O
{	O
hp	pointer
->	O
cth_flags	O
|=	O
CTF_F_COMPRESS	int
;	O
if	O
(	O
(	O
rc	int
=	O
compress	function
(	O
bp	pointer
,	O
(	O
uLongf	long
*	O
)	O
&	O
compress_len	long
,	O
fp	pointer
->	O
ctf_buf	pointer
,	O
fp	pointer
->	O
ctf_size	long
)	O
)	O
!=	O
Z_OK	int
)	O
{	O
ctf_dprintf	function
(	O
"zlib deflate err: %s\n"	pointer
,	O
zError	function
(	O
rc	int
)	O
)	O
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_COMPRESS	int
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
*	O
size	long
+=	O
compress_len	long
;	O
}	O
return	O
buf	pointer
;	O
}	O
int	O
ctf_write	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
int	O
fd	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
buf	pointer
;	O
ssize_t	long
resid	long
;	O
ssize_t	long
len	int
;	O
if	O
(	O
ctf_serialize	function
(	O
fp	pointer
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
resid	long
=	O
sizeof	O
(	O
ctf_header_t	struct
)	O
;	O
buf	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_header	struct
;	O
while	O
(	O
resid	long
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	pointer
(	O
fd	int
,	O
buf	pointer
,	O
resid	long
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
resid	long
-=	O
len	int
;	O
buf	pointer
+=	O
len	int
;	O
}	O
resid	long
=	O
fp	pointer
->	O
ctf_size	long
;	O
buf	pointer
=	O
fp	pointer
->	O
ctf_buf	pointer
;	O
while	O
(	O
resid	long
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
len	int
=	O
write	pointer
(	O
fd	int
,	O
buf	pointer
,	O
resid	long
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
resid	long
-=	O
len	int
;	O
buf	pointer
+=	O
len	int
;	O
}	O
return	O
0	int
;	O
}	O
