int	O
gsl_schur_gen_eigvals	function
(	O
const	O
gsl_matrix	struct
*	O
A	pointer
,	O
const	O
gsl_matrix	struct
*	O
B	pointer
,	O
double	O
*	O
wr1	pointer
,	O
double	O
*	O
wr2	pointer
,	O
double	O
*	O
wi	pointer
,	O
double	O
*	O
scale1	pointer
,	O
double	O
*	O
scale2	pointer
)	O
{	O
const	O
double	O
safemin	double
=	O
GSL_DBL_MIN	int
*	O
1.0e2	int
;	O
const	O
double	O
safemax	double
=	O
1.0	int
/	O
safemin	double
;	O
const	O
double	O
rtmin	double
=	O
sqrt	function
(	O
safemin	double
)	O
;	O
const	O
double	O
rtmax	double
=	O
1.0	int
/	O
rtmin	double
;	O
double	O
anorm	double
,	O
bnorm	double
;	O
double	O
ascale	double
,	O
bscale	double
,	O
bsize	double
;	O
double	O
s1	double
,	O
s2	double
;	O
double	O
A11	double
,	O
A12	double
,	O
A21	double
,	O
A22	double
;	O
double	O
B11	double
,	O
B12	double
,	O
B22	double
;	O
double	O
binv11	double
,	O
binv22	double
;	O
double	O
bmin	double
;	O
double	O
as11	double
,	O
as12	double
,	O
as22	double
,	O
abi22	double
;	O
double	O
pp	double
,	O
qq	double
,	O
shift	double
,	O
ss	double
,	O
discr	double
,	O
r	double
;	O
anorm	double
=	O
GSL_MAX	O
(	O
GSL_MAX	O
(	O
fabs	function
(	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
)	O
+	O
fabs	function
(	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
0	int
)	O
)	O
,	O
fabs	function
(	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
1	int
)	O
)	O
+	O
fabs	function
(	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
1	int
)	O
)	O
)	O
,	O
safemin	double
)	O
;	O
ascale	double
=	O
1.0	int
/	O
anorm	double
;	O
A11	double
=	O
ascale	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
;	O
A12	double
=	O
ascale	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
1	int
)	O
;	O
A21	double
=	O
ascale	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
0	int
)	O
;	O
A22	double
=	O
ascale	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
1	int
)	O
;	O
B11	double
=	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
0	int
)	O
;	O
B12	double
=	O
gsl_matrix_get	function
(	O
B	pointer
,	O
0	int
,	O
1	int
)	O
;	O
B22	double
=	O
gsl_matrix_get	function
(	O
B	pointer
,	O
1	int
,	O
1	int
)	O
;	O
bmin	double
=	O
rtmin	double
*	O
GSL_MAX	O
(	O
fabs	function
(	O
B11	double
)	O
,	O
GSL_MAX	O
(	O
fabs	function
(	O
B12	double
)	O
,	O
GSL_MAX	O
(	O
fabs	function
(	O
B22	double
)	O
,	O
rtmin	double
)	O
)	O
)	O
;	O
if	O
(	O
fabs	function
(	O
B11	double
)	O
<	O
bmin	double
)	O
B11	double
=	O
GSL_SIGN	O
(	O
B11	double
)	O
*	O
bmin	double
;	O
if	O
(	O
fabs	function
(	O
B22	double
)	O
<	O
bmin	double
)	O
B22	double
=	O
GSL_SIGN	O
(	O
B22	double
)	O
*	O
bmin	double
;	O
bnorm	double
=	O
GSL_MAX	O
(	O
fabs	function
(	O
B11	double
)	O
,	O
GSL_MAX	O
(	O
fabs	function
(	O
B12	double
)	O
+	O
fabs	function
(	O
B22	double
)	O
,	O
safemin	double
)	O
)	O
;	O
bsize	double
=	O
GSL_MAX	O
(	O
fabs	function
(	O
B11	double
)	O
,	O
fabs	function
(	O
B22	double
)	O
)	O
;	O
bscale	double
=	O
1.0	int
/	O
bsize	double
;	O
B11	double
*=	O
bscale	double
;	O
B12	double
*=	O
bscale	double
;	O
B22	double
*=	O
bscale	double
;	O
binv11	double
=	O
1.0	int
/	O
B11	double
;	O
binv22	double
=	O
1.0	int
/	O
B22	double
;	O
s1	double
=	O
A11	double
*	O
binv11	double
;	O
s2	double
=	O
A22	double
*	O
binv22	double
;	O
if	O
(	O
fabs	function
(	O
s1	double
)	O
<=	O
fabs	function
(	O
s2	double
)	O
)	O
{	O
as12	double
=	O
A12	double
-	O
s1	double
*	O
B12	double
;	O
as22	double
=	O
A22	double
-	O
s1	double
*	O
B22	double
;	O
ss	double
=	O
A21	double
*	O
(	O
binv11	double
*	O
binv22	double
)	O
;	O
abi22	double
=	O
as22	double
*	O
binv22	double
-	O
ss	double
*	O
B12	double
;	O
pp	double
=	O
0.5	int
*	O
abi22	double
;	O
shift	double
=	O
s1	double
;	O
}	O
else	O
{	O
as12	double
=	O
A12	double
-	O
s2	double
*	O
B12	double
;	O
as11	double
=	O
A11	double
-	O
s2	double
*	O
B11	double
;	O
ss	double
=	O
A21	double
*	O
(	O
binv11	double
*	O
binv22	double
)	O
;	O
abi22	double
=	O
-	O
ss	double
*	O
B12	double
;	O
pp	double
=	O
0.5	int
*	O
(	O
as11	double
*	O
binv11	double
+	O
abi22	double
)	O
;	O
shift	double
=	O
s2	double
;	O
}	O
qq	double
=	O
ss	double
*	O
as12	double
;	O
if	O
(	O
fabs	function
(	O
pp	double
*	O
rtmin	double
)	O
>=	O
1.0	int
)	O
{	O
discr	double
=	O
(	O
rtmin	double
*	O
pp	double
)	O
*	O
(	O
rtmin	double
*	O
pp	double
)	O
+	O
qq	double
*	O
safemin	double
;	O
r	double
=	O
sqrt	function
(	O
fabs	function
(	O
discr	double
)	O
)	O
*	O
rtmax	double
;	O
}	O
else	O
if	O
(	O
pp	double
*	O
pp	double
+	O
fabs	function
(	O
qq	double
)	O
<=	O
safemin	double
)	O
{	O
discr	double
=	O
(	O
rtmax	double
*	O
pp	double
)	O
*	O
(	O
rtmax	double
*	O
pp	double
)	O
+	O
qq	double
*	O
safemax	double
;	O
r	double
=	O
sqrt	function
(	O
fabs	function
(	O
discr	double
)	O
)	O
*	O
rtmin	double
;	O
}	O
else	O
{	O
discr	double
=	O
pp	double
*	O
pp	double
+	O
qq	double
;	O
r	double
=	O
sqrt	function
(	O
fabs	function
(	O
discr	double
)	O
)	O
;	O
}	O
if	O
(	O
discr	double
>=	O
0.0	int
||	O
r	double
==	O
0.0	int
)	O
{	O
double	O
sum	double
=	O
pp	double
+	O
GSL_SIGN	O
(	O
pp	double
)	O
*	O
r	double
;	O
double	O
diff	double
=	O
pp	double
-	O
GSL_SIGN	O
(	O
pp	double
)	O
*	O
r	double
;	O
double	O
wbig	double
=	O
shift	double
+	O
sum	double
;	O
double	O
wsmall	double
=	O
shift	double
+	O
diff	double
;	O
if	O
(	O
0.5	int
*	O
fabs	function
(	O
wbig	double
)	O
>	O
GSL_MAX	O
(	O
fabs	function
(	O
wsmall	double
)	O
,	O
safemin	double
)	O
)	O
{	O
double	O
wdet	double
=	O
(	O
A11	double
*	O
A22	double
-	O
A12	double
*	O
A21	double
)	O
*	O
(	O
binv11	double
*	O
binv22	double
)	O
;	O
wsmall	double
=	O
wdet	double
/	O
wbig	double
;	O
}	O
if	O
(	O
pp	double
>	O
abi22	double
)	O
{	O
*	O
wr1	pointer
=	O
GSL_MIN	O
(	O
wbig	double
,	O
wsmall	double
)	O
;	O
*	O
wr2	pointer
=	O
GSL_MAX	O
(	O
wbig	double
,	O
wsmall	double
)	O
;	O
}	O
else	O
{	O
*	O
wr1	pointer
=	O
GSL_MAX	O
(	O
wbig	double
,	O
wsmall	double
)	O
;	O
*	O
wr2	pointer
=	O
GSL_MIN	O
(	O
wbig	double
,	O
wsmall	double
)	O
;	O
}	O
*	O
wi	pointer
=	O
0.0	int
;	O
}	O
else	O
{	O
*	O
wr1	pointer
=	O
shift	double
+	O
pp	double
;	O
*	O
wr2	pointer
=	O
*	O
wr1	pointer
;	O
*	O
wi	pointer
=	O
r	double
;	O
}	O
{	O
const	O
double	O
fuzzy1	double
=	O
1.0	int
+	O
1.0e-5	int
;	O
double	O
c1	double
,	O
c2	double
,	O
c3	double
,	O
c4	double
,	O
c5	double
;	O
double	O
wabs	double
,	O
wsize	double
,	O
wscale	double
;	O
c1	double
=	O
bsize	double
*	O
(	O
safemin	double
*	O
GSL_MAX	O
(	O
1.0	int
,	O
ascale	double
)	O
)	O
;	O
c2	double
=	O
safemin	double
*	O
GSL_MAX	O
(	O
1.0	int
,	O
bnorm	double
)	O
;	O
c3	double
=	O
bsize	double
*	O
safemin	double
;	O
if	O
(	O
ascale	double
<=	O
1.0	int
&&	O
bsize	double
<=	O
1.0	int
)	O
c4	double
=	O
GSL_MIN	O
(	O
1.0	int
,	O
(	O
ascale	double
/	O
safemin	double
)	O
*	O
bsize	double
)	O
;	O
else	O
c4	double
=	O
1.0	int
;	O
if	O
(	O
ascale	double
<=	O
1.0	int
||	O
bsize	double
<=	O
1.0	int
)	O
c5	double
=	O
GSL_MIN	O
(	O
1.0	int
,	O
ascale	double
*	O
bsize	double
)	O
;	O
else	O
c5	double
=	O
1.0	int
;	O
wabs	double
=	O
fabs	function
(	O
*	O
wr1	pointer
)	O
+	O
fabs	function
(	O
*	O
wi	pointer
)	O
;	O
wsize	double
=	O
GSL_MAX	O
(	O
safemin	double
,	O
GSL_MAX	O
(	O
c1	double
,	O
GSL_MAX	O
(	O
fuzzy1	double
*	O
(	O
wabs	double
*	O
c2	double
+	O
c3	double
)	O
,	O
GSL_MIN	O
(	O
c4	double
,	O
0.5	int
*	O
GSL_MAX	O
(	O
wabs	double
,	O
c5	double
)	O
)	O
)	O
)	O
)	O
;	O
if	O
(	O
wsize	double
!=	O
1.0	int
)	O
{	O
wscale	double
=	O
1.0	int
/	O
wsize	double
;	O
if	O
(	O
wsize	double
>	O
1.0	int
)	O
{	O
*	O
scale1	pointer
=	O
(	O
GSL_MAX	O
(	O
ascale	double
,	O
bsize	double
)	O
*	O
wscale	double
)	O
*	O
GSL_MIN	O
(	O
ascale	double
,	O
bsize	double
)	O
;	O
}	O
else	O
{	O
*	O
scale1	pointer
=	O
(	O
GSL_MIN	O
(	O
ascale	double
,	O
bsize	double
)	O
*	O
wscale	double
)	O
*	O
GSL_MAX	O
(	O
ascale	double
,	O
bsize	double
)	O
;	O
}	O
*	O
wr1	pointer
*=	O
wscale	double
;	O
if	O
(	O
*	O
wi	pointer
!=	O
0.0	int
)	O
{	O
*	O
wi	pointer
*=	O
wscale	double
;	O
*	O
wr2	pointer
=	O
*	O
wr1	pointer
;	O
*	O
scale2	pointer
=	O
*	O
scale1	pointer
;	O
}	O
}	O
else	O
{	O
*	O
scale1	pointer
=	O
ascale	double
*	O
bsize	double
;	O
*	O
scale2	pointer
=	O
*	O
scale1	pointer
;	O
}	O
if	O
(	O
*	O
wi	pointer
==	O
0.0	int
)	O
{	O
wsize	double
=	O
GSL_MAX	O
(	O
safemin	double
,	O
GSL_MAX	O
(	O
c1	double
,	O
GSL_MAX	O
(	O
fuzzy1	double
*	O
(	O
fabs	function
(	O
*	O
wr2	pointer
)	O
*	O
c2	double
+	O
c3	double
)	O
,	O
GSL_MIN	O
(	O
c4	double
,	O
0.5	int
*	O
GSL_MAX	O
(	O
fabs	function
(	O
*	O
wr2	pointer
)	O
,	O
c5	double
)	O
)	O
)	O
)	O
)	O
;	O
if	O
(	O
wsize	double
!=	O
1.0	int
)	O
{	O
wscale	double
=	O
1.0	int
/	O
wsize	double
;	O
if	O
(	O
wsize	double
>	O
1.0	int
)	O
{	O
*	O
scale2	pointer
=	O
(	O
GSL_MAX	O
(	O
ascale	double
,	O
bsize	double
)	O
*	O
wscale	double
)	O
*	O
GSL_MIN	O
(	O
ascale	double
,	O
bsize	double
)	O
;	O
}	O
else	O
{	O
*	O
scale2	pointer
=	O
(	O
GSL_MIN	O
(	O
ascale	double
,	O
bsize	double
)	O
*	O
wscale	double
)	O
*	O
GSL_MAX	O
(	O
ascale	double
,	O
bsize	double
)	O
;	O
}	O
*	O
wr2	pointer
*=	O
wscale	double
;	O
}	O
else	O
{	O
*	O
scale2	pointer
=	O
ascale	double
*	O
bsize	double
;	O
}	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_schur_solve_equation	function
(	O
double	O
ca	double
,	O
const	O
gsl_matrix	struct
*	O
A	pointer
,	O
double	O
z	struct
,	O
double	O
d1	pointer
,	O
double	O
d2	pointer
,	O
const	O
gsl_vector	struct
*	O
b	pointer
,	O
gsl_vector	struct
*	O
x	long double
,	O
double	O
*	O
s	pointer
,	O
double	O
*	O
xnorm	pointer
,	O
double	O
smin	double
)	O
{	O
size_t	long
N	int
=	O
A	pointer
->	O
size1	long
;	O
double	O
bnorm	double
;	O
double	O
scale	double
=	O
1.0	int
;	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
double	O
c	pointer
,	O
cnorm	double
;	O
c	pointer
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
-	O
z	struct
*	O
d1	pointer
;	O
cnorm	double
=	O
fabs	function
(	O
c	pointer
)	O
;	O
if	O
(	O
cnorm	double
<	O
smin	double
)	O
{	O
c	pointer
=	O
smin	double
;	O
cnorm	double
=	O
smin	double
;	O
}	O
bnorm	double
=	O
fabs	function
(	O
gsl_vector_get	function
(	O
b	pointer
,	O
0	int
)	O
)	O
;	O
if	O
(	O
cnorm	double
<	O
1.0	int
&&	O
bnorm	double
>	O
1.0	int
)	O
{	O
if	O
(	O
bnorm	double
>	O
GSL_SCHUR_BIGNUM	O
*	O
cnorm	double
)	O
scale	double
=	O
1.0	int
/	O
bnorm	double
;	O
}	O
gsl_vector_set	function
(	O
x	long double
,	O
0	int
,	O
gsl_vector_get	function
(	O
b	pointer
,	O
0	int
)	O
*	O
scale	double
/	O
c	pointer
)	O
;	O
*	O
xnorm	pointer
=	O
fabs	function
(	O
gsl_vector_get	function
(	O
x	long double
,	O
0	int
)	O
)	O
;	O
}	O
else	O
{	O
double	O
cr	array
[	O
2	int
]	O
[	O
2	int
]	O
;	O
double	O
*	O
crv	pointer
;	O
double	O
cmax	double
;	O
size_t	long
icmax	long
,	O
j	long
;	O
double	O
bval1	double
,	O
bval2	double
;	O
double	O
ur11	double
,	O
ur12	double
,	O
ur22	double
,	O
ur11r	double
;	O
double	O
cr21	double
,	O
cr22	double
;	O
double	O
lr21	double
;	O
double	O
b1	pointer
,	O
b2	float
,	O
bbnd	double
;	O
double	O
x1	double
,	O
x2	double
;	O
double	O
temp	double
;	O
size_t	long
ipivot	array
[	O
4	int
]	O
[	O
4	int
]	O
=	O
{	O
{	O
0	int
,	O
1	int
,	O
2	int
,	O
3	int
}	O
,	O
{	O
1	int
,	O
0	int
,	O
3	int
,	O
2	int
}	O
,	O
{	O
2	int
,	O
3	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
3	int
,	O
2	int
,	O
1	int
,	O
0	int
}	O
}	O
;	O
int	O
rswap	array
[	O
4	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
}	O
;	O
int	O
zswap	array
[	O
4	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
}	O
;	O
crv	pointer
=	O
(	O
double	O
*	O
)	O
cr	array
;	O
cr	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
-	O
z	struct
*	O
d1	pointer
;	O
cr	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
1	int
)	O
-	O
z	struct
*	O
d2	pointer
;	O
cr	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
0	int
)	O
;	O
cr	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
1	int
)	O
;	O
cmax	double
=	O
0.0	int
;	O
icmax	long
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
4	int
;	O
++	O
j	long
)	O
{	O
if	O
(	O
fabs	function
(	O
crv	pointer
[	O
j	long
]	O
)	O
>	O
cmax	double
)	O
{	O
cmax	double
=	O
fabs	function
(	O
crv	pointer
[	O
j	long
]	O
)	O
;	O
icmax	long
=	O
j	long
;	O
}	O
}	O
bval1	double
=	O
gsl_vector_get	function
(	O
b	pointer
,	O
0	int
)	O
;	O
bval2	double
=	O
gsl_vector_get	function
(	O
b	pointer
,	O
1	int
)	O
;	O
if	O
(	O
cmax	double
<	O
smin	double
)	O
{	O
bnorm	double
=	O
GSL_MAX	O
(	O
fabs	function
(	O
bval1	double
)	O
,	O
fabs	function
(	O
bval2	double
)	O
)	O
;	O
if	O
(	O
smin	double
<	O
1.0	int
&&	O
bnorm	double
>	O
1.0	int
)	O
{	O
if	O
(	O
bnorm	double
>	O
GSL_SCHUR_BIGNUM	O
*	O
smin	double
)	O
scale	double
=	O
1.0	int
/	O
bnorm	double
;	O
}	O
temp	double
=	O
scale	double
/	O
smin	double
;	O
gsl_vector_set	function
(	O
x	long double
,	O
0	int
,	O
temp	double
*	O
bval1	double
)	O
;	O
gsl_vector_set	function
(	O
x	long double
,	O
1	int
,	O
temp	double
*	O
bval2	double
)	O
;	O
*	O
xnorm	pointer
=	O
temp	double
*	O
bnorm	double
;	O
*	O
s	pointer
=	O
scale	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
ur11	double
=	O
crv	pointer
[	O
icmax	long
]	O
;	O
cr21	double
=	O
crv	pointer
[	O
ipivot	array
[	O
1	int
]	O
[	O
icmax	long
]	O
]	O
;	O
ur12	double
=	O
crv	pointer
[	O
ipivot	array
[	O
2	int
]	O
[	O
icmax	long
]	O
]	O
;	O
cr22	double
=	O
crv	pointer
[	O
ipivot	array
[	O
3	int
]	O
[	O
icmax	long
]	O
]	O
;	O
ur11r	double
=	O
1.0	int
/	O
ur11	double
;	O
lr21	double
=	O
ur11r	double
*	O
cr21	double
;	O
ur22	double
=	O
cr22	double
-	O
ur12	double
*	O
lr21	double
;	O
if	O
(	O
fabs	function
(	O
ur22	double
)	O
<	O
smin	double
)	O
ur22	double
=	O
smin	double
;	O
if	O
(	O
rswap	array
[	O
icmax	long
]	O
)	O
{	O
b1	pointer
=	O
bval2	double
;	O
b2	float
=	O
bval1	double
;	O
}	O
else	O
{	O
b1	pointer
=	O
bval1	double
;	O
b2	float
=	O
bval2	double
;	O
}	O
b2	float
-=	O
lr21	double
*	O
b1	pointer
;	O
bbnd	double
=	O
GSL_MAX	O
(	O
fabs	function
(	O
b1	pointer
*	O
(	O
ur22	double
*	O
ur11r	double
)	O
)	O
,	O
fabs	function
(	O
b2	float
)	O
)	O
;	O
if	O
(	O
bbnd	double
>	O
1.0	int
&&	O
fabs	function
(	O
ur22	double
)	O
<	O
1.0	int
)	O
{	O
if	O
(	O
bbnd	double
>=	O
GSL_SCHUR_BIGNUM	O
*	O
fabs	function
(	O
ur22	double
)	O
)	O
scale	double
=	O
1.0	int
/	O
bbnd	double
;	O
}	O
x2	double
=	O
(	O
b2	float
*	O
scale	double
)	O
/	O
ur22	double
;	O
x1	double
=	O
(	O
scale	double
*	O
b1	pointer
)	O
*	O
ur11r	double
-	O
x2	double
*	O
(	O
ur11r	double
*	O
ur12	double
)	O
;	O
if	O
(	O
zswap	array
[	O
icmax	long
]	O
)	O
{	O
gsl_vector_set	function
(	O
x	long double
,	O
0	int
,	O
x2	double
)	O
;	O
gsl_vector_set	function
(	O
x	long double
,	O
1	int
,	O
x1	double
)	O
;	O
}	O
else	O
{	O
gsl_vector_set	function
(	O
x	long double
,	O
0	int
,	O
x1	double
)	O
;	O
gsl_vector_set	function
(	O
x	long double
,	O
1	int
,	O
x2	double
)	O
;	O
}	O
*	O
xnorm	pointer
=	O
GSL_MAX	O
(	O
fabs	function
(	O
x1	double
)	O
,	O
fabs	function
(	O
x2	double
)	O
)	O
;	O
if	O
(	O
*	O
xnorm	pointer
>	O
1.0	int
&&	O
cmax	double
>	O
1.0	int
)	O
{	O
if	O
(	O
*	O
xnorm	pointer
>	O
GSL_SCHUR_BIGNUM	O
/	O
cmax	double
)	O
{	O
temp	double
=	O
cmax	double
/	O
GSL_SCHUR_BIGNUM	O
;	O
gsl_blas_dscal	function
(	O
temp	double
,	O
x	long double
)	O
;	O
*	O
xnorm	pointer
*=	O
temp	double
;	O
scale	double
*=	O
temp	double
;	O
}	O
}	O
}	O
*	O
s	pointer
=	O
scale	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_schur_solve_equation_z	function
(	O
double	O
ca	double
,	O
const	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_complex	struct
*	O
z	struct
,	O
double	O
d1	pointer
,	O
double	O
d2	pointer
,	O
const	O
gsl_vector_complex	struct
*	O
b	pointer
,	O
gsl_vector_complex	struct
*	O
x	long double
,	O
double	O
*	O
s	pointer
,	O
double	O
*	O
xnorm	pointer
,	O
double	O
smin	double
)	O
{	O
size_t	long
N	int
=	O
A	pointer
->	O
size1	long
;	O
double	O
scale	double
=	O
1.0	int
;	O
double	O
bnorm	double
;	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
double	O
cr	array
,	O
ci	double
,	O
cnorm	double
;	O
gsl_complex	struct
bval	struct
,	O
c	pointer
,	O
xval	struct
,	O
tmp	struct
;	O
cr	array
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
-	O
GSL_REAL	O
(	O
*	O
z	struct
)	O
*	O
d1	pointer
;	O
ci	double
=	O
-	O
GSL_IMAG	O
(	O
*	O
z	struct
)	O
*	O
d1	pointer
;	O
cnorm	double
=	O
fabs	function
(	O
cr	array
)	O
+	O
fabs	function
(	O
ci	double
)	O
;	O
if	O
(	O
cnorm	double
<	O
smin	double
)	O
{	O
cr	array
=	O
smin	double
;	O
ci	double
=	O
0.0	int
;	O
cnorm	double
=	O
smin	double
;	O
}	O
bval	struct
=	O
gsl_vector_complex_get	function
(	O
b	pointer
,	O
0	int
)	O
;	O
bnorm	double
=	O
fabs	function
(	O
GSL_REAL	O
(	O
bval	struct
)	O
)	O
+	O
fabs	function
(	O
GSL_IMAG	O
(	O
bval	struct
)	O
)	O
;	O
if	O
(	O
cnorm	double
<	O
1.0	int
&&	O
bnorm	double
>	O
1.0	int
)	O
{	O
if	O
(	O
bnorm	double
>	O
GSL_SCHUR_BIGNUM	O
*	O
cnorm	double
)	O
scale	double
=	O
1.0	int
/	O
bnorm	double
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
tmp	struct
,	O
scale	double
*	O
GSL_REAL	O
(	O
bval	struct
)	O
,	O
scale	double
*	O
GSL_IMAG	O
(	O
bval	struct
)	O
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
c	pointer
,	O
cr	array
,	O
ci	double
)	O
;	O
xval	struct
=	O
gsl_complex_div	function
(	O
tmp	struct
,	O
c	pointer
)	O
;	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
0	int
,	O
xval	struct
)	O
;	O
*	O
xnorm	pointer
=	O
fabs	function
(	O
GSL_REAL	O
(	O
xval	struct
)	O
)	O
+	O
fabs	function
(	O
GSL_IMAG	O
(	O
xval	struct
)	O
)	O
;	O
}	O
else	O
{	O
double	O
cr	array
[	O
2	int
]	O
[	O
2	int
]	O
,	O
ci	double
[	O
2	int
]	O
[	O
2	int
]	O
;	O
double	O
*	O
civ	pointer
,	O
*	O
crv	pointer
;	O
double	O
cmax	double
;	O
gsl_complex	struct
bval1	double
,	O
bval2	double
;	O
gsl_complex	struct
xval1	struct
,	O
xval2	struct
;	O
double	O
xr1	double
,	O
xi1	double
;	O
size_t	long
icmax	long
;	O
size_t	long
j	long
;	O
double	O
temp	double
;	O
double	O
ur11	double
,	O
ur12	double
,	O
ur22	double
,	O
ui11	double
,	O
ui12	double
,	O
ui22	double
,	O
ur11r	double
,	O
ui11r	double
;	O
double	O
ur12s	double
,	O
ui12s	double
;	O
double	O
u22abs	double
;	O
double	O
lr21	double
,	O
li21	double
;	O
double	O
cr21	double
,	O
cr22	double
,	O
ci21	double
,	O
ci22	double
;	O
double	O
br1	double
,	O
bi1	double
,	O
br2	double
,	O
bi2	double
,	O
bbnd	double
;	O
gsl_complex	struct
b1	pointer
,	O
b2	float
;	O
size_t	long
ipivot	array
[	O
4	int
]	O
[	O
4	int
]	O
=	O
{	O
{	O
0	int
,	O
1	int
,	O
2	int
,	O
3	int
}	O
,	O
{	O
1	int
,	O
0	int
,	O
3	int
,	O
2	int
}	O
,	O
{	O
2	int
,	O
3	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
3	int
,	O
2	int
,	O
1	int
,	O
0	int
}	O
}	O
;	O
int	O
rswap	array
[	O
4	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
}	O
;	O
int	O
zswap	array
[	O
4	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
}	O
;	O
civ	pointer
=	O
(	O
double	O
*	O
)	O
ci	double
;	O
crv	pointer
=	O
(	O
double	O
*	O
)	O
cr	array
;	O
cr	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
-	O
GSL_REAL	O
(	O
*	O
z	struct
)	O
*	O
d1	pointer
;	O
cr	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
1	int
)	O
-	O
GSL_REAL	O
(	O
*	O
z	struct
)	O
*	O
d2	pointer
;	O
cr	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
1	int
,	O
0	int
)	O
;	O
cr	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
ca	double
*	O
gsl_matrix_get	function
(	O
A	pointer
,	O
0	int
,	O
1	int
)	O
;	O
ci	double
[	O
0	int
]	O
[	O
0	int
]	O
=	O
-	O
GSL_IMAG	O
(	O
*	O
z	struct
)	O
*	O
d1	pointer
;	O
ci	double
[	O
0	int
]	O
[	O
1	int
]	O
=	O
0.0	int
;	O
ci	double
[	O
1	int
]	O
[	O
0	int
]	O
=	O
0.0	int
;	O
ci	double
[	O
1	int
]	O
[	O
1	int
]	O
=	O
-	O
GSL_IMAG	O
(	O
*	O
z	struct
)	O
*	O
d2	pointer
;	O
cmax	double
=	O
0.0	int
;	O
icmax	long
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
4	int
;	O
++	O
j	long
)	O
{	O
if	O
(	O
fabs	function
(	O
crv	pointer
[	O
j	long
]	O
)	O
+	O
fabs	function
(	O
civ	pointer
[	O
j	long
]	O
)	O
>	O
cmax	double
)	O
{	O
cmax	double
=	O
fabs	function
(	O
crv	pointer
[	O
j	long
]	O
)	O
+	O
fabs	function
(	O
civ	pointer
[	O
j	long
]	O
)	O
;	O
icmax	long
=	O
j	long
;	O
}	O
}	O
bval1	double
=	O
gsl_vector_complex_get	function
(	O
b	pointer
,	O
0	int
)	O
;	O
bval2	double
=	O
gsl_vector_complex_get	function
(	O
b	pointer
,	O
1	int
)	O
;	O
if	O
(	O
cmax	double
<	O
smin	double
)	O
{	O
bnorm	double
=	O
GSL_MAX	O
(	O
fabs	function
(	O
GSL_REAL	O
(	O
bval1	double
)	O
)	O
+	O
fabs	function
(	O
GSL_IMAG	O
(	O
bval1	double
)	O
)	O
,	O
fabs	function
(	O
GSL_REAL	O
(	O
bval2	double
)	O
)	O
+	O
fabs	function
(	O
GSL_IMAG	O
(	O
bval2	double
)	O
)	O
)	O
;	O
if	O
(	O
smin	double
<	O
1.0	int
&&	O
bnorm	double
>	O
1.0	int
)	O
{	O
if	O
(	O
bnorm	double
>	O
GSL_SCHUR_BIGNUM	O
*	O
smin	double
)	O
scale	double
=	O
1.0	int
/	O
bnorm	double
;	O
}	O
temp	double
=	O
scale	double
/	O
smin	double
;	O
xval1	struct
=	O
gsl_complex_mul_real	function
(	O
bval1	double
,	O
temp	double
)	O
;	O
xval2	struct
=	O
gsl_complex_mul_real	function
(	O
bval2	double
,	O
temp	double
)	O
;	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
0	int
,	O
xval1	struct
)	O
;	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
1	int
,	O
xval2	struct
)	O
;	O
*	O
xnorm	pointer
=	O
temp	double
*	O
bnorm	double
;	O
*	O
s	pointer
=	O
scale	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
ur11	double
=	O
crv	pointer
[	O
icmax	long
]	O
;	O
ui11	double
=	O
civ	pointer
[	O
icmax	long
]	O
;	O
cr21	double
=	O
crv	pointer
[	O
ipivot	array
[	O
1	int
]	O
[	O
icmax	long
]	O
]	O
;	O
ci21	double
=	O
civ	pointer
[	O
ipivot	array
[	O
1	int
]	O
[	O
icmax	long
]	O
]	O
;	O
ur12	double
=	O
crv	pointer
[	O
ipivot	array
[	O
2	int
]	O
[	O
icmax	long
]	O
]	O
;	O
ui12	double
=	O
civ	pointer
[	O
ipivot	array
[	O
2	int
]	O
[	O
icmax	long
]	O
]	O
;	O
cr22	double
=	O
crv	pointer
[	O
ipivot	array
[	O
3	int
]	O
[	O
icmax	long
]	O
]	O
;	O
ci22	double
=	O
civ	pointer
[	O
ipivot	array
[	O
3	int
]	O
[	O
icmax	long
]	O
]	O
;	O
if	O
(	O
icmax	long
==	O
0	int
||	O
icmax	long
==	O
3	int
)	O
{	O
if	O
(	O
fabs	function
(	O
ur11	double
)	O
>	O
fabs	function
(	O
ui11	double
)	O
)	O
{	O
temp	double
=	O
ui11	double
/	O
ur11	double
;	O
ur11r	double
=	O
1.0	int
/	O
(	O
ur11	double
*	O
(	O
1.0	int
+	O
temp	double
*	O
temp	double
)	O
)	O
;	O
ui11r	double
=	O
-	O
temp	double
*	O
ur11r	double
;	O
}	O
else	O
{	O
temp	double
=	O
ur11	double
/	O
ui11	double
;	O
ui11r	double
=	O
-	O
1.0	int
/	O
(	O
ui11	double
*	O
(	O
1.0	int
+	O
temp	double
*	O
temp	double
)	O
)	O
;	O
ur11r	double
=	O
-	O
temp	double
*	O
ui11r	double
;	O
}	O
lr21	double
=	O
cr21	double
*	O
ur11r	double
;	O
li21	double
=	O
cr21	double
*	O
ui11r	double
;	O
ur12s	double
=	O
ur12	double
*	O
ur11r	double
;	O
ui12s	double
=	O
ur12	double
*	O
ui11r	double
;	O
ur22	double
=	O
cr22	double
-	O
ur12	double
*	O
lr21	double
;	O
ui22	double
=	O
ci22	double
-	O
ur12	double
*	O
li21	double
;	O
}	O
else	O
{	O
ur11r	double
=	O
1.0	int
/	O
ur11	double
;	O
ui11r	double
=	O
0.0	int
;	O
lr21	double
=	O
cr21	double
*	O
ur11r	double
;	O
li21	double
=	O
ci21	double
*	O
ur11r	double
;	O
ur12s	double
=	O
ur12	double
*	O
ur11r	double
;	O
ui12s	double
=	O
ui12	double
*	O
ur11r	double
;	O
ur22	double
=	O
cr22	double
-	O
ur12	double
*	O
lr21	double
+	O
ui12	double
*	O
li21	double
;	O
ui22	double
=	O
-	O
ur12	double
*	O
li21	double
-	O
ui12	double
*	O
lr21	double
;	O
}	O
u22abs	double
=	O
fabs	function
(	O
ur22	double
)	O
+	O
fabs	function
(	O
ui22	double
)	O
;	O
if	O
(	O
u22abs	double
<	O
smin	double
)	O
{	O
ur22	double
=	O
smin	double
;	O
ui22	double
=	O
0.0	int
;	O
}	O
if	O
(	O
rswap	array
[	O
icmax	long
]	O
)	O
{	O
br2	double
=	O
GSL_REAL	O
(	O
bval1	double
)	O
;	O
bi2	double
=	O
GSL_IMAG	O
(	O
bval1	double
)	O
;	O
br1	double
=	O
GSL_REAL	O
(	O
bval2	double
)	O
;	O
bi1	double
=	O
GSL_IMAG	O
(	O
bval2	double
)	O
;	O
}	O
else	O
{	O
br1	double
=	O
GSL_REAL	O
(	O
bval1	double
)	O
;	O
bi1	double
=	O
GSL_IMAG	O
(	O
bval1	double
)	O
;	O
br2	double
=	O
GSL_REAL	O
(	O
bval2	double
)	O
;	O
bi2	double
=	O
GSL_IMAG	O
(	O
bval2	double
)	O
;	O
}	O
br2	double
+=	O
li21	double
*	O
bi1	double
-	O
lr21	double
*	O
br1	double
;	O
bi2	double
-=	O
li21	double
*	O
br1	double
+	O
lr21	double
*	O
bi1	double
;	O
bbnd	double
=	O
GSL_MAX	O
(	O
(	O
fabs	function
(	O
br1	double
)	O
+	O
fabs	function
(	O
bi1	double
)	O
)	O
*	O
(	O
u22abs	double
*	O
(	O
fabs	function
(	O
ur11r	double
)	O
+	O
fabs	function
(	O
ui11r	double
)	O
)	O
)	O
,	O
fabs	function
(	O
br2	double
)	O
+	O
fabs	function
(	O
bi2	double
)	O
)	O
;	O
if	O
(	O
bbnd	double
>	O
1.0	int
&&	O
u22abs	double
<	O
1.0	int
)	O
{	O
if	O
(	O
bbnd	double
>=	O
GSL_SCHUR_BIGNUM	O
*	O
u22abs	double
)	O
{	O
scale	double
=	O
1.0	int
/	O
bbnd	double
;	O
br1	double
*=	O
scale	double
;	O
bi1	double
*=	O
scale	double
;	O
br2	double
*=	O
scale	double
;	O
bi2	double
*=	O
scale	double
;	O
}	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
b1	pointer
,	O
br2	double
,	O
bi2	double
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
b2	float
,	O
ur22	double
,	O
ui22	double
)	O
;	O
xval2	struct
=	O
gsl_complex_div	function
(	O
b1	pointer
,	O
b2	float
)	O
;	O
xr1	double
=	O
ur11r	double
*	O
br1	double
-	O
ui11r	double
*	O
bi1	double
-	O
ur12s	double
*	O
GSL_REAL	O
(	O
xval2	struct
)	O
+	O
ui12s	double
*	O
GSL_IMAG	O
(	O
xval2	struct
)	O
;	O
xi1	double
=	O
ui11r	double
*	O
br1	double
+	O
ur11r	double
*	O
bi1	double
-	O
ui12s	double
*	O
GSL_REAL	O
(	O
xval2	struct
)	O
-	O
ur12s	double
*	O
GSL_IMAG	O
(	O
xval2	struct
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
xval1	struct
,	O
xr1	double
,	O
xi1	double
)	O
;	O
if	O
(	O
zswap	array
[	O
icmax	long
]	O
)	O
{	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
0	int
,	O
xval2	struct
)	O
;	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
1	int
,	O
xval1	struct
)	O
;	O
}	O
else	O
{	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
0	int
,	O
xval1	struct
)	O
;	O
gsl_vector_complex_set	function
(	O
x	long double
,	O
1	int
,	O
xval2	struct
)	O
;	O
}	O
*	O
xnorm	pointer
=	O
GSL_MAX	O
(	O
fabs	function
(	O
GSL_REAL	O
(	O
xval1	struct
)	O
)	O
+	O
fabs	function
(	O
GSL_IMAG	O
(	O
xval1	struct
)	O
)	O
,	O
fabs	function
(	O
GSL_REAL	O
(	O
xval2	struct
)	O
)	O
+	O
fabs	function
(	O
GSL_IMAG	O
(	O
xval2	struct
)	O
)	O
)	O
;	O
if	O
(	O
*	O
xnorm	pointer
>	O
1.0	int
&&	O
cmax	double
>	O
1.0	int
)	O
{	O
if	O
(	O
*	O
xnorm	pointer
>	O
GSL_SCHUR_BIGNUM	O
/	O
cmax	double
)	O
{	O
temp	double
=	O
cmax	double
/	O
GSL_SCHUR_BIGNUM	O
;	O
gsl_blas_zdscal	function
(	O
temp	double
,	O
x	long double
)	O
;	O
*	O
xnorm	pointer
*=	O
temp	double
;	O
scale	double
*=	O
temp	double
;	O
}	O
}	O
}	O
*	O
s	pointer
=	O
scale	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
