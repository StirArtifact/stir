struct	O
local_owl_data	struct
{	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
boundary	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
cumulative_goal	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
neighbors	int
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
escape_values	array
[	O
BOARDMAX	O
]	O
;	O
int	O
color	int
;	O
struct	O
eye_data	struct
my_eye	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
half_eye_data	struct
half_eye	array
[	O
BOARDMAX	O
]	O
;	O
int	O
lunch	int
[	O
MAX_LUNCHES	int
]	O
;	O
int	O
lunch_attack_code	array
[	O
MAX_LUNCHES	int
]	O
;	O
int	O
lunch_attack_point	array
[	O
MAX_LUNCHES	int
]	O
;	O
int	O
lunch_defend_code	array
[	O
MAX_LUNCHES	int
]	O
;	O
int	O
lunch_defense_point	array
[	O
MAX_LUNCHES	int
]	O
;	O
signed	O
char	O
inessential	int
[	O
BOARDMAX	O
]	O
;	O
int	O
lunches_are_current	int
;	O
signed	O
char	O
safe_move_cache	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
local_owl_data	struct
*	O
restore_from	pointer
;	O
}	O
;	O
static	O
int	O
result_certain	int
;	O
static	O
int	O
local_owl_node_counter	int
;	O
static	O
int	O
global_owl_node_counter	int
=	O
0	int
;	O
static	O
struct	O
local_owl_data	struct
*	O
current_owl_data	pointer
;	O
static	O
struct	O
local_owl_data	struct
*	O
other_owl_data	pointer
;	O
static	O
int	O
goal_worms_computed	int
=	O
0	int
;	O
static	O
int	O
owl_goal_worm	array
[	O
MAX_GOAL_WORMS	int
]	O
;	O
enum	O
same_dragon_value	enum
{	O
SAME_DRAGON_NOT_CONNECTED	int
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
SAME_DRAGON_CONNECTED	int
,	O
SAME_DRAGON_ALL_CONNECTED	int
}	O
;	O
struct	O
matched_pattern_data	struct
;	O
struct	O
owl_move_data	struct
{	O
int	O
pos	int
;	O
int	O
value	pointer
;	O
const	O
char	O
*	O
name	short
;	O
enum	O
same_dragon_value	enum
same_dragon	function
;	O
int	O
lunch	int
;	O
int	O
escape	int
;	O
int	O
defense_pos	int
;	O
int	O
cuts	array
[	O
MAX_CUTS	int
]	O
;	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
;	O
}	O
;	O
struct	O
matched_pattern_data	struct
{	O
int	O
move	pointer
;	O
int	O
value	pointer
;	O
int	O
ll	int
;	O
int	O
anchor	int
;	O
int	O
bdist	int
;	O
struct	O
pattern	pointer
*	O
pattern	pointer
;	O
int	O
next_pattern_index	int
;	O
}	O
;	O
struct	O
matched_patterns_list_data	struct
{	O
int	O
initialized	int
;	O
int	O
counter	int
;	O
int	O
used	int
;	O
int	O
list_size	int
;	O
struct	O
matched_pattern_data	struct
*	O
pattern_list	pointer
;	O
int	O
first_pattern_index	array
[	O
BOARDMAX	O
]	O
;	O
int	O
heap_num_patterns	int
;	O
struct	O
matched_pattern_data	struct
*	O
*	O
pattern_heap	pointer
;	O
}	O
;	O
void	O
dump_pattern_list	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
int	O
do_owl_attack	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
wormid	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
escape	int
)	O
;	O
static	O
int	O
do_owl_defend	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
wormid	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
escape	int
)	O
;	O
static	O
void	O
owl_shapes	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
,	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
color	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
struct	O
pattern_db	struct
*	O
type	char
)	O
;	O
static	O
void	O
collect_owl_shapes_callbacks	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern_db	struct
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
;	O
static	O
void	O
pattern_list_prepare	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
pattern_list_build_heap	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
pattern_list_pop_heap_once	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
pattern_list_sink_heap_top_element	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
int	O
get_next_move_from_list	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
,	O
int	O
color	int
,	O
struct	O
owl_move_data	struct
*	O
moves	array
,	O
int	O
cutoff	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
init_pattern_list	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
close_pattern_list	function
(	O
int	O
color	int
,	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
owl_shapes_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern_db	struct
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
;	O
static	O
void	O
owl_add_move	function
(	O
struct	O
owl_move_data	struct
*	O
moves	array
,	O
int	O
move	pointer
,	O
int	O
value	pointer
,	O
const	O
char	O
*	O
reason	pointer
,	O
enum	O
same_dragon_value	enum
same_dragon	function
,	O
int	O
lunch	int
,	O
int	O
escape	int
,	O
int	O
defense_pos	int
,	O
int	O
max_moves	int
,	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
)	O
;	O
static	O
void	O
owl_determine_life	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
struct	O
local_owl_data	struct
*	O
second_owl	pointer
,	O
int	O
does_attack	function
,	O
struct	O
owl_move_data	struct
*	O
moves	array
,	O
struct	O
eyevalue	struct
*	O
probable_eyes	pointer
,	O
int	O
*	O
eyemin	pointer
,	O
int	O
*	O
eyemax	pointer
)	O
;	O
static	O
void	O
owl_find_relevant_eyespaces	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
mw	array
[	O
BOARDMAX	O
]	O
,	O
int	O
mz	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
owl_estimate_life	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
struct	O
local_owl_data	struct
*	O
second_owl	pointer
,	O
struct	O
owl_move_data	struct
vital_moves	array
[	O
MAX_MOVES	int
]	O
,	O
const	O
char	O
*	O
*	O
live_reason	pointer
,	O
int	O
does_attack	function
,	O
struct	O
eyevalue	struct
*	O
probable_eyes	pointer
,	O
int	O
*	O
eyemin	pointer
,	O
int	O
*	O
eyemax	pointer
)	O
;	O
static	O
int	O
modify_stupid_eye_vital_point	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
*	O
vital_point	pointer
,	O
int	O
is_attack_point	int
)	O
;	O
static	O
int	O
modify_eyefilling_move	function
(	O
int	O
*	O
move	pointer
,	O
int	O
color	int
)	O
;	O
static	O
int	O
estimate_lunch_half_eye_bonus	function
(	O
int	O
lunch	int
,	O
struct	O
half_eye_data	struct
half_eye	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
owl_mark_dragon	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
new_dragons	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
owl_mark_worm	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
owl_mark_boundary	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
owl_update_goal	function
(	O
int	O
pos	int
,	O
enum	O
same_dragon_value	enum
same_dragon	function
,	O
int	O
lunch	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
semeai_call	int
,	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
)	O
;	O
static	O
void	O
owl_test_cuts	function
(	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
,	O
int	O
cuts	array
[	O
MAX_CUTS	int
]	O
)	O
;	O
static	O
void	O
componentdump	function
(	O
const	O
signed	O
char	O
component	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
owl_update_boundary_marks	function
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
owl_find_lunches	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
int	O
improve_lunch_attack	function
(	O
int	O
lunch	int
,	O
int	O
attack_point	pointer
)	O
;	O
static	O
int	O
improve_lunch_defense	function
(	O
int	O
lunch	int
,	O
int	O
defense_point	pointer
)	O
;	O
static	O
void	O
owl_make_domains	function
(	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
)	O
;	O
static	O
int	O
owl_safe_move	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
;	O
static	O
void	O
sniff_lunch	function
(	O
int	O
lunch	int
,	O
int	O
*	O
min	pointer
,	O
int	O
*	O
probable	pointer
,	O
int	O
*	O
max	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
eat_lunch_escape_bonus	function
(	O
int	O
lunch	int
,	O
int	O
*	O
min	pointer
,	O
int	O
*	O
probable	pointer
,	O
int	O
*	O
max	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
int	O
select_new_goal_origin	function
(	O
int	O
origin	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
compute_owl_escape_values	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
int	O
owl_escape_route	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
void	O
do_owl_analyze_semeai	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
*	O
resulta	pointer
,	O
int	O
*	O
resultb	pointer
,	O
int	O
*	O
move	pointer
,	O
int	O
pass	int
,	O
int	O
owl_phase	int
)	O
;	O
static	O
int	O
semeai_trymove_and_recurse	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
owl_phase	int
,	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
ko_allowed	int
,	O
int	O
move_value	pointer
,	O
const	O
char	O
*	O
move_name	pointer
,	O
enum	O
same_dragon_value	enum
same_dragon	function
,	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
,	O
int	O
lunch	int
,	O
int	O
*	O
semeai_move	pointer
,	O
int	O
*	O
this_resulta	pointer
,	O
int	O
*	O
this_resultb	pointer
)	O
;	O
static	O
void	O
semeai_add_sgf_comment	function
(	O
int	O
value	pointer
,	O
int	O
owl_phase	int
)	O
;	O
static	O
int	O
semeai_trust_tactical_attack	function
(	O
int	O
str	int
)	O
;	O
static	O
int	O
semeai_propose_eyespace_filling_move	function
(	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
)	O
;	O
static	O
void	O
semeai_review_owl_moves	function
(	O
struct	O
owl_move_data	struct
owl_moves	array
[	O
MAX_MOVES	int
]	O
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
color	int
,	O
int	O
*	O
safe_outside_liberty_found	pointer
,	O
int	O
*	O
safe_common_liberty_found	pointer
,	O
int	O
*	O
riskless_move_found	pointer
,	O
signed	O
char	O
mw	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
owl_move_data	struct
semeai_moves	array
[	O
MAX_SEMEAI_MOVES	int
]	O
,	O
int	O
guess_same_dragon	int
,	O
int	O
value_bonus	int
,	O
int	O
*	O
critical_semeai_worms	pointer
)	O
;	O
static	O
int	O
semeai_move_value	function
(	O
int	O
move	pointer
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
raw_value	int
,	O
int	O
*	O
critical_semeai_worms	pointer
)	O
;	O
static	O
int	O
semeai_is_riskless_move	function
(	O
int	O
move	pointer
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
)	O
;	O
static	O
void	O
remove_eye_filling_moves	function
(	O
struct	O
local_owl_data	struct
*	O
our_owl	pointer
,	O
struct	O
owl_move_data	struct
*	O
moves	array
)	O
;	O
static	O
int	O
find_semeai_backfilling_move	function
(	O
int	O
worm	array
,	O
int	O
liberty	int
)	O
;	O
static	O
int	O
liberty_of_goal	function
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
int	O
second_liberty_of_goal	function
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
;	O
static	O
int	O
matches_found	int
;	O
static	O
signed	O
char	O
found_matches	array
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
reduced_init_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
,	O
int	O
at_bottom_of_stack	int
)	O
;	O
static	O
void	O
init_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
int	O
move	pointer
,	O
int	O
use_stack	int
,	O
int	O
new_dragons	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
struct	O
local_owl_data	struct
*	O
owl_stack	array
[	O
2	int
*	O
MAXSTACK	O
]	O
;	O
static	O
int	O
owl_stack_size	int
=	O
0	int
;	O
static	O
int	O
owl_stack_pointer	int
=	O
0	int
;	O
static	O
void	O
check_owl_stack_size	function
(	O
void	O
)	O
;	O
static	O
void	O
push_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
)	O
;	O
static	O
void	O
do_push_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
)	O
;	O
static	O
void	O
pop_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
)	O
;	O
static	O
int	O
list_goal_worms	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
goal_worm	array
[	O
MAX_GOAL_WORMS	int
]	O
)	O
;	O
static	O
int	O
dragon_goal_worms	array
[	O
MAX_DRAGONS	O
]	O
[	O
MAX_GOAL_WORMS	int
]	O
;	O
static	O
void	O
prepare_goal_list	function
(	O
int	O
str	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
list	pointer
[	O
MAX_GOAL_WORMS	int
]	O
,	O
int	O
*	O
flag	pointer
,	O
int	O
*	O
kworm	int
,	O
int	O
do_list	int
)	O
;	O
static	O
void	O
finish_goal_list	function
(	O
int	O
*	O
flag	pointer
,	O
int	O
*	O
wpos	pointer
,	O
int	O
list	pointer
[	O
MAX_GOAL_WORMS	int
]	O
,	O
int	O
index	function
)	O
;	O
static	O
int	O
s_worms	int
=	O
0	int
;	O
static	O
int	O
semeai_worms	array
[	O
MAX_SEMEAI_WORMS	int
]	O
;	O
static	O
int	O
important_semeai_worms	array
[	O
MAX_SEMEAI_WORMS	int
]	O
;	O
static	O
int	O
prefer_ko	int
;	O
static	O
int	O
include_semeai_worms_in_eyespace	int
=	O
0	int
;	O
static	O
void	O
clear_cut_list	function
(	O
int	O
cuts	array
[	O
MAX_CUTS	int
]	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_CUTS	int
;	O
i	int
++	O
)	O
cuts	array
[	O
i	int
]	O
=	O
NO_MOVE	O
;	O
}	O
void	O
owl_analyze_semeai	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
*	O
resulta	pointer
,	O
int	O
*	O
resultb	pointer
,	O
int	O
*	O
semeai_move	pointer
,	O
int	O
owl	int
,	O
int	O
*	O
semeai_result_certain	pointer
)	O
{	O
owl_analyze_semeai_after_move	function
(	O
PASS_MOVE	int
,	O
EMPTY	int
,	O
apos	int
,	O
bpos	int
,	O
resulta	pointer
,	O
resultb	pointer
,	O
semeai_move	pointer
,	O
owl	int
,	O
semeai_result_certain	pointer
,	O
0	int
)	O
;	O
}	O
void	O
owl_analyze_semeai_after_move	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
*	O
resulta	pointer
,	O
int	O
*	O
resultb	pointer
,	O
int	O
*	O
semeai_move	pointer
,	O
int	O
owl	int
,	O
int	O
*	O
semeai_result_certain	pointer
,	O
int	O
recompute_dragons	int
)	O
{	O
signed	O
char	O
ms	array
[	O
BOARDMAX	O
]	O
;	O
int	O
w1	int
,	O
w2	int
;	O
int	O
str	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
int	O
dummy_resulta	int
;	O
int	O
dummy_resultb	int
;	O
int	O
dummy_semeai_move	int
;	O
double	O
start	double
=	O
0.0	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
nodes_used	int
;	O
int	O
new_dragons	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
local_owl_data	struct
*	O
owla	pointer
;	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
;	O
Hash_data	struct
goal_hash	pointer
;	O
if	O
(	O
!	O
resulta	pointer
)	O
resulta	pointer
=	O
&	O
dummy_resulta	int
;	O
if	O
(	O
!	O
resultb	pointer
)	O
resultb	pointer
=	O
&	O
dummy_resultb	int
;	O
if	O
(	O
!	O
semeai_move	pointer
)	O
semeai_move	pointer
=	O
&	O
dummy_semeai_move	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
if	O
(	O
recompute_dragons	int
)	O
{	O
if	O
(	O
tryko	function
(	O
move	pointer
,	O
color	int
,	O
"Recompute dragons for semeai."	pointer
)	O
)	O
{	O
compute_new_dragons	function
(	O
new_dragons	array
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
else	O
recompute_dragons	int
=	O
0	int
;	O
}	O
s_worms	int
=	O
0	int
;	O
memset	function
(	O
ms	array
,	O
0	int
,	O
sizeof	O
(	O
ms	array
)	O
)	O
;	O
for	O
(	O
w1	int
=	O
first_worm_in_dragon	function
(	O
apos	int
)	O
;	O
w1	int
!=	O
NO_MOVE	O
;	O
w1	int
=	O
next_worm_in_dragon	function
(	O
w1	int
)	O
)	O
{	O
for	O
(	O
w2	int
=	O
first_worm_in_dragon	function
(	O
bpos	int
)	O
;	O
w2	int
!=	O
NO_MOVE	O
;	O
w2	int
=	O
next_worm_in_dragon	function
(	O
w2	int
)	O
)	O
{	O
if	O
(	O
adjacent_strings	function
(	O
w1	int
,	O
w2	int
)	O
||	O
have_common_lib	function
(	O
w1	int
,	O
w2	int
,	O
NULL	O
)	O
)	O
{	O
mark_string	function
(	O
w1	int
,	O
ms	array
,	O
1	int
)	O
;	O
mark_string	function
(	O
w2	int
,	O
ms	array
,	O
1	int
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
ms	array
[	O
str	int
]	O
&&	O
worm	array
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
{	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
int	O
adjacent_to_outside	int
=	O
0	int
;	O
adj	array
=	O
chainlinks	function
(	O
str	int
,	O
adjs	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
is_same_dragon	function
(	O
adjs	array
[	O
k	int
]	O
,	O
apos	int
)	O
&&	O
!	O
is_same_dragon	function
(	O
adjs	array
[	O
k	int
]	O
,	O
bpos	int
)	O
&&	O
dragon	int
[	O
adjs	array
[	O
k	int
]	O
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
adjacent_to_outside	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
adjacent_to_outside	int
||	O
countstones	function
(	O
str	int
)	O
>	O
6	int
)	O
&&	O
s_worms	int
<	O
MAX_SEMEAI_WORMS	int
)	O
{	O
important_semeai_worms	array
[	O
s_worms	int
]	O
=	O
1	int
;	O
semeai_worms	array
[	O
s_worms	int
++	O
]	O
=	O
str	int
;	O
DEBUG	O
(	O
DEBUG_SEMEAI	int
,	O
"important semeai worm: %1m\n"	pointer
,	O
str	int
)	O
;	O
}	O
else	O
if	O
(	O
owl_substantial	function
(	O
str	int
)	O
&&	O
s_worms	int
<	O
MAX_SEMEAI_WORMS	int
)	O
{	O
important_semeai_worms	array
[	O
s_worms	int
]	O
=	O
0	int
;	O
semeai_worms	array
[	O
s_worms	int
++	O
]	O
=	O
str	int
;	O
DEBUG	O
(	O
DEBUG_SEMEAI	int
,	O
"semeai worm: %1m\n"	pointer
,	O
str	int
)	O
;	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
ASSERT1	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
bpos	int
]	O
)	O
,	O
apos	int
)	O
;	O
count_variations	int
=	O
1	int
;	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
DEBUG	O
(	O
DEBUG_SEMEAI	int
,	O
"owl_analyze_semeai: %1m vs. %1m\n"	pointer
,	O
apos	int
,	O
bpos	int
)	O
;	O
else	O
DEBUG	O
(	O
DEBUG_SEMEAI	int
,	O
"owl_analyze_semeai_after_move %C %1m: %1m vs. %1m\n"	pointer
,	O
color	int
,	O
move	pointer
,	O
apos	int
,	O
bpos	int
)	O
;	O
if	O
(	O
owl	int
)	O
{	O
if	O
(	O
recompute_dragons	int
)	O
{	O
init_owl	function
(	O
&	O
owla	pointer
,	O
apos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
new_dragons	array
)	O
;	O
init_owl	function
(	O
&	O
owlb	pointer
,	O
bpos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
0	int
,	O
new_dragons	array
)	O
;	O
}	O
else	O
{	O
init_owl	function
(	O
&	O
owla	pointer
,	O
apos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
init_owl	function
(	O
&	O
owlb	pointer
,	O
bpos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
owl_make_domains	function
(	O
owla	pointer
,	O
owlb	pointer
)	O
;	O
}	O
else	O
{	O
reduced_init_owl	function
(	O
&	O
owla	pointer
,	O
1	int
)	O
;	O
reduced_init_owl	function
(	O
&	O
owlb	pointer
,	O
0	int
)	O
;	O
local_owl_node_counter	int
=	O
0	int
;	O
owl_mark_worm	function
(	O
apos	int
,	O
NO_MOVE	O
,	O
owla	pointer
)	O
;	O
owl_mark_worm	function
(	O
bpos	int
,	O
NO_MOVE	O
,	O
owlb	pointer
)	O
;	O
}	O
result_certain	int
=	O
1	int
;	O
{	O
Hash_data	struct
temp	struct
=	O
goal_to_hashvalue	function
(	O
owla	pointer
->	O
goal	pointer
)	O
;	O
goal_hash	pointer
=	O
goal_to_hashvalue	function
(	O
owlb	pointer
->	O
goal	pointer
)	O
;	O
hashdata_xor	O
(	O
goal_hash	pointer
,	O
temp	struct
)	O
;	O
}	O
if	O
(	O
owl	int
&&	O
search_persistent_semeai_cache	function
(	O
ANALYZE_SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
move	pointer
,	O
color	int
,	O
&	O
goal_hash	pointer
,	O
resulta	pointer
,	O
resultb	pointer
,	O
semeai_move	pointer
,	O
semeai_result_certain	pointer
)	O
)	O
{	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"analyze_semeai %1m vs. %1m, result %d %d %1m (cached)\n"	pointer
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
*	O
semeai_move	pointer
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"analyze_semeai_after_move %C %1m: %1m vs. %1m, result %d %d %1m (cached)\n"	pointer
,	O
color	int
,	O
move	pointer
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
*	O
semeai_move	pointer
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
dragon	int
[	O
apos	int
]	O
.	O
size	int
<=	O
5	int
&&	O
dragon	int
[	O
bpos	int
]	O
.	O
size	int
>	O
3	int
*	O
dragon	int
[	O
apos	int
]	O
.	O
size	int
)	O
prefer_ko	int
=	O
board	pointer
[	O
apos	int
]	O
;	O
else	O
if	O
(	O
dragon	int
[	O
bpos	int
]	O
.	O
size	int
<=	O
5	int
&&	O
dragon	int
[	O
apos	int
]	O
.	O
size	int
>	O
3	int
*	O
dragon	int
[	O
bpos	int
]	O
.	O
size	int
)	O
prefer_ko	int
=	O
board	pointer
[	O
bpos	int
]	O
;	O
else	O
prefer_ko	int
=	O
EMPTY	int
;	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
do_owl_analyze_semeai	function
(	O
apos	int
,	O
bpos	int
,	O
owla	pointer
,	O
owlb	pointer
,	O
resulta	pointer
,	O
resultb	pointer
,	O
semeai_move	pointer
,	O
0	int
,	O
owl	int
)	O
;	O
else	O
{	O
semeai_trymove_and_recurse	function
(	O
bpos	int
,	O
apos	int
,	O
owlb	pointer
,	O
owla	pointer
,	O
owl	int
,	O
move	pointer
,	O
color	int
,	O
1	int
,	O
0	int
,	O
"mandatory move"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NULL	O
,	O
NO_MOVE	O
,	O
semeai_move	pointer
,	O
resultb	pointer
,	O
resulta	pointer
)	O
;	O
*	O
resulta	pointer
=	O
REVERSE_RESULT	O
(	O
*	O
resulta	pointer
)	O
;	O
*	O
resultb	pointer
=	O
REVERSE_RESULT	O
(	O
*	O
resultb	pointer
)	O
;	O
}	O
nodes_used	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
if	O
(	O
move	pointer
==	O
PASS_MOVE	int
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"analyze_semeai %1m vs. %1m, result %d %d %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
*	O
semeai_move	pointer
,	O
local_owl_node_counter	int
,	O
nodes_used	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"analyze_semeai_after_move %C %1m: %1m vs. %1m, result %d %d %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
color	int
,	O
move	pointer
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
*	O
semeai_move	pointer
,	O
local_owl_node_counter	int
,	O
nodes_used	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
}	O
if	O
(	O
semeai_result_certain	pointer
)	O
*	O
semeai_result_certain	pointer
=	O
result_certain	int
;	O
if	O
(	O
owl	int
)	O
store_persistent_semeai_cache	function
(	O
ANALYZE_SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
move	pointer
,	O
color	int
,	O
&	O
goal_hash	pointer
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
*	O
semeai_move	pointer
,	O
result_certain	int
,	O
nodes_used	int
,	O
owla	pointer
->	O
goal	pointer
,	O
owlb	pointer
->	O
goal	pointer
)	O
;	O
}	O
static	O
void	O
do_owl_analyze_semeai	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
*	O
resulta	pointer
,	O
int	O
*	O
resultb	pointer
,	O
int	O
*	O
move	pointer
,	O
int	O
pass	int
,	O
int	O
owl_phase	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
apos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
struct	O
owl_move_data	struct
vital_defensive_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
vital_offensive_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
shape_defensive_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
shape_offensive_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
matched_patterns_list_data	struct
shape_offensive_patterns	struct
;	O
struct	O
matched_patterns_list_data	struct
shape_defensive_patterns	struct
;	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_SEMEAI_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
outside_liberty	struct
;	O
struct	O
owl_move_data	struct
common_liberty	struct
;	O
struct	O
owl_move_data	struct
backfill_outside_liberty	struct
;	O
struct	O
owl_move_data	struct
backfill_common_liberty	struct
;	O
int	O
safe_outside_liberty_found	pointer
=	O
0	int
;	O
int	O
safe_common_liberty_found	pointer
=	O
0	int
;	O
int	O
riskless_move_found	pointer
=	O
0	int
;	O
signed	O
char	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
int	O
k	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
move_value	pointer
;	O
int	O
best_resulta	int
=	O
0	int
;	O
int	O
best_resultb	int
=	O
0	int
;	O
int	O
best_move	int
=	O
0	int
;	O
const	O
char	O
*	O
best_move_name	pointer
=	O
NULL	O
;	O
int	O
this_resulta	pointer
=	O
-	O
1	int
;	O
int	O
this_resultb	pointer
=	O
-	O
1	int
;	O
int	O
xpos	int
;	O
int	O
value1	pointer
;	O
int	O
value2	pointer
;	O
int	O
this_variation_number	int
=	O
count_variations	int
-	O
1	int
;	O
int	O
you_look_alive	int
=	O
0	int
;	O
int	O
I_look_alive	int
=	O
0	int
;	O
int	O
dummy_move	int
;	O
int	O
tested_moves	int
;	O
int	O
critical_semeai_worms	pointer
[	O
MAX_SEMEAI_WORMS	int
]	O
;	O
int	O
sworm	int
;	O
int	O
we_might_be_inessential	int
;	O
struct	O
eyevalue	struct
probable_eyes_a	struct
;	O
struct	O
eyevalue	struct
probable_eyes_b	struct
;	O
struct	O
eyevalue	struct
dummy_eyes	struct
;	O
int	O
I_have_more_eyes	int
;	O
SETUP_TRACE_INFO2	O
(	O
"do_owl_analyze_semeai"	pointer
,	O
apos	int
,	O
bpos	int
)	O
;	O
if	O
(	O
!	O
move	pointer
)	O
move	pointer
=	O
&	O
dummy_move	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
owla	pointer
->	O
color	int
,	O
apos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
owlb	pointer
->	O
color	int
,	O
bpos	int
)	O
;	O
apos	int
=	O
find_origin	function
(	O
apos	int
)	O
;	O
bpos	int
=	O
find_origin	function
(	O
bpos	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
semeai_branch_depth	int
&&	O
owl_phase	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value1	pointer
,	O
&	O
value2	pointer
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT2	O
(	O
value1	pointer
,	O
value2	pointer
,	O
xpos	int
)	O
;	O
*	O
move	pointer
=	O
xpos	int
;	O
*	O
resulta	pointer
=	O
value1	pointer
;	O
*	O
resultb	pointer
=	O
value2	pointer
;	O
TRACE	O
(	O
"%oVariation %d: %1m %1m %s %s %1m (cached) "	pointer
,	O
this_variation_number	int
,	O
apos	int
,	O
bpos	int
,	O
result_to_string	function
(	O
*	O
resulta	pointer
)	O
,	O
result_to_string	function
(	O
*	O
resultb	pointer
)	O
,	O
*	O
move	pointer
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
xpos	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
"cached"	pointer
)	O
;	O
return	O
;	O
}	O
global_owl_node_counter	int
++	O
;	O
local_owl_node_counter	int
++	O
;	O
shape_offensive_patterns	struct
.	O
initialized	int
=	O
0	int
;	O
shape_defensive_patterns	struct
.	O
initialized	int
=	O
0	int
;	O
outside_liberty	struct
.	O
pos	int
=	O
NO_MOVE	O
;	O
common_liberty	struct
.	O
pos	int
=	O
NO_MOVE	O
;	O
backfill_outside_liberty	struct
.	O
pos	int
=	O
NO_MOVE	O
;	O
backfill_common_liberty	struct
.	O
pos	int
=	O
NO_MOVE	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_SEMEAI_MOVES	int
;	O
k	int
++	O
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
pos	int
=	O
0	int
;	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
=	O
-	O
1	int
;	O
moves	array
[	O
k	int
]	O
.	O
name	short
=	O
NULL	O
;	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_CONNECTED	int
;	O
moves	array
[	O
k	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
clear_cut_list	function
(	O
moves	array
[	O
k	int
]	O
.	O
cuts	array
)	O
;	O
}	O
ASSERT1	O
(	O
other	int
==	O
board	pointer
[	O
bpos	int
]	O
,	O
bpos	int
)	O
;	O
memset	function
(	O
mw	array
,	O
0	int
,	O
sizeof	O
(	O
mw	array
)	O
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
{	O
int	O
upos	int
;	O
for	O
(	O
sworm	int
=	O
0	int
;	O
sworm	int
<	O
s_worms	int
;	O
sworm	int
++	O
)	O
{	O
critical_semeai_worms	pointer
[	O
sworm	int
]	O
=	O
0	int
;	O
if	O
(	O
board	pointer
[	O
semeai_worms	array
[	O
sworm	int
]	O
]	O
==	O
other	int
)	O
{	O
int	O
acode	int
=	O
attack	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
,	O
&	O
upos	int
)	O
;	O
if	O
(	O
acode	int
==	O
WIN	int
&&	O
semeai_trust_tactical_attack	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
)	O
&&	O
important_semeai_worms	array
[	O
sworm	int
]	O
)	O
{	O
*	O
resulta	pointer
=	O
WIN	int
;	O
*	O
resultb	pointer
=	O
WIN	int
;	O
*	O
move	pointer
=	O
upos	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
SGFTRACE_SEMEAI	O
(	O
upos	int
,	O
WIN	int
,	O
WIN	int
,	O
"tactical win found"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
upos	int
,	O
WIN	int
,	O
WIN	int
)	O
;	O
}	O
else	O
if	O
(	O
acode	int
!=	O
0	int
&&	O
find_defense	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
,	O
NULL	O
)	O
)	O
{	O
critical_semeai_worms	pointer
[	O
sworm	int
]	O
=	O
1	int
;	O
owl_add_move	function
(	O
moves	array
,	O
upos	int
,	O
105	int
,	O
"attack semeai worm"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d (-1)\n"	pointer
,	O
upos	int
,	O
105	int
)	O
;	O
}	O
else	O
if	O
(	O
acode	int
==	O
WIN	int
&&	O
important_semeai_worms	array
[	O
sworm	int
]	O
)	O
{	O
owl_add_move	function
(	O
moves	array
,	O
upos	int
,	O
100	int
,	O
"attack semeai worm"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d (-1)\n"	pointer
,	O
upos	int
,	O
100	int
)	O
;	O
}	O
}	O
}	O
we_might_be_inessential	int
=	O
1	int
;	O
for	O
(	O
sworm	int
=	O
0	int
;	O
sworm	int
<	O
s_worms	int
;	O
sworm	int
++	O
)	O
if	O
(	O
board	pointer
[	O
semeai_worms	array
[	O
sworm	int
]	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
important_semeai_worms	array
[	O
sworm	int
]	O
)	O
we_might_be_inessential	int
=	O
0	int
;	O
if	O
(	O
attack	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
,	O
NULL	O
)	O
&&	O
find_defense	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
,	O
&	O
upos	int
)	O
)	O
{	O
critical_semeai_worms	pointer
[	O
sworm	int
]	O
=	O
1	int
;	O
owl_add_move	function
(	O
moves	array
,	O
upos	int
,	O
85	int
,	O
"defend semeai worm"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d (0)\n"	pointer
,	O
upos	int
,	O
85	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
owl_phase	int
)	O
{	O
set_eyevalue	function
(	O
&	O
probable_eyes_a	struct
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
set_eyevalue	function
(	O
&	O
probable_eyes_b	struct
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
I_have_more_eyes	int
=	O
0	int
;	O
}	O
else	O
{	O
int	O
eyemin_a	int
;	O
int	O
eyemin_b	int
;	O
int	O
eyemax_a	int
;	O
int	O
eyemax_b	int
;	O
const	O
char	O
*	O
live_reasona	pointer
;	O
const	O
char	O
*	O
live_reasonb	pointer
;	O
owl_find_lunches	function
(	O
owla	pointer
)	O
;	O
owl_find_lunches	function
(	O
owlb	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owla	pointer
->	O
lunch	int
[	O
k	int
]	O
!=	O
NO_MOVE	O
&&	O
owlb	pointer
->	O
goal	pointer
[	O
owla	pointer
->	O
lunch	int
[	O
k	int
]	O
]	O
)	O
{	O
owla	pointer
->	O
lunch	int
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owlb	pointer
->	O
lunch	int
[	O
k	int
]	O
!=	O
NO_MOVE	O
&&	O
owla	pointer
->	O
goal	pointer
[	O
owlb	pointer
->	O
lunch	int
[	O
k	int
]	O
]	O
)	O
{	O
owlb	pointer
->	O
lunch	int
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
if	O
(	O
owl_estimate_life	function
(	O
owla	pointer
,	O
owlb	pointer
,	O
vital_defensive_moves	array
,	O
&	O
live_reasona	pointer
,	O
0	int
,	O
&	O
probable_eyes_a	struct
,	O
&	O
eyemin_a	int
,	O
&	O
eyemax_a	int
)	O
)	O
I_look_alive	int
=	O
1	int
;	O
else	O
if	O
(	O
stackp	int
>	O
2	int
&&	O
owl_escape_route	function
(	O
owla	pointer
)	O
>=	O
5	int
)	O
{	O
live_reasona	pointer
=	O
"escaped"	pointer
;	O
I_look_alive	int
=	O
1	int
;	O
}	O
if	O
(	O
owl_estimate_life	function
(	O
owlb	pointer
,	O
owla	pointer
,	O
vital_offensive_moves	array
,	O
&	O
live_reasonb	pointer
,	O
1	int
,	O
&	O
probable_eyes_b	struct
,	O
&	O
eyemin_b	int
,	O
&	O
eyemax_b	int
)	O
)	O
you_look_alive	int
=	O
1	int
;	O
else	O
if	O
(	O
stackp	int
>	O
2	int
&&	O
owl_escape_route	function
(	O
owlb	pointer
)	O
>=	O
5	int
)	O
{	O
live_reasonb	pointer
=	O
"escaped"	pointer
;	O
you_look_alive	int
=	O
1	int
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	function
(	O
"probable_eyes_a: %s eyemin: %d eyemax: %d"	pointer
,	O
eyevalue_to_string	function
(	O
&	O
probable_eyes_a	struct
)	O
,	O
eyemin_a	int
,	O
eyemax_a	int
)	O
;	O
if	O
(	O
I_look_alive	int
)	O
gprintf	function
(	O
"%o I look alive (%s)"	pointer
,	O
live_reasona	pointer
)	O
;	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
gprintf	function
(	O
"probable_eyes_b: %s eyemin: %d eyemax: %d"	pointer
,	O
eyevalue_to_string	function
(	O
&	O
probable_eyes_b	struct
)	O
,	O
eyemin_b	int
,	O
eyemax_b	int
)	O
;	O
if	O
(	O
you_look_alive	int
)	O
gprintf	function
(	O
"%o you look alive(%s)"	pointer
,	O
live_reasonb	pointer
)	O
;	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
}	O
if	O
(	O
I_look_alive	int
&&	O
you_look_alive	int
)	O
{	O
*	O
resulta	pointer
=	O
WIN	int
;	O
*	O
resultb	pointer
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
TRACE	O
(	O
"Both live\n"	pointer
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
0	int
,	O
"Both live"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
WIN	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
I_look_alive	int
)	O
{	O
owl_shapes	function
(	O
&	O
shape_defensive_patterns	struct
,	O
shape_defensive_moves	array
,	O
color	int
,	O
owla	pointer
,	O
&	O
owl_defendpat_db	struct
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
-	O
1	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
get_next_move_from_list	function
(	O
&	O
shape_defensive_patterns	struct
,	O
color	int
,	O
shape_defensive_moves	array
,	O
1	int
,	O
owla	pointer
)	O
)	O
break	O
;	O
}	O
else	O
shape_defensive_moves	array
[	O
0	int
]	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
!	O
you_look_alive	int
)	O
{	O
owl_shapes	function
(	O
&	O
shape_offensive_patterns	struct
,	O
shape_offensive_moves	array
,	O
color	int
,	O
owlb	pointer
,	O
&	O
owl_attackpat_db	struct
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
-	O
1	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
get_next_move_from_list	function
(	O
&	O
shape_offensive_patterns	struct
,	O
color	int
,	O
shape_offensive_moves	array
,	O
1	int
,	O
owlb	pointer
)	O
)	O
break	O
;	O
}	O
else	O
shape_offensive_moves	array
[	O
0	int
]	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
eyemax_a	int
>	O
0	int
)	O
{	O
remove_eye_filling_moves	function
(	O
owla	pointer
,	O
vital_defensive_moves	array
)	O
;	O
remove_eye_filling_moves	function
(	O
owla	pointer
,	O
vital_offensive_moves	array
)	O
;	O
remove_eye_filling_moves	function
(	O
owla	pointer
,	O
shape_defensive_moves	array
)	O
;	O
remove_eye_filling_moves	function
(	O
owla	pointer
,	O
shape_offensive_moves	array
)	O
;	O
}	O
if	O
(	O
!	O
I_look_alive	int
)	O
{	O
semeai_review_owl_moves	function
(	O
vital_defensive_moves	array
,	O
owla	pointer
,	O
owlb	pointer
,	O
color	int
,	O
&	O
safe_outside_liberty_found	pointer
,	O
&	O
safe_common_liberty_found	pointer
,	O
&	O
riskless_move_found	pointer
,	O
mw	array
,	O
moves	array
,	O
0	int
,	O
30	int
,	O
critical_semeai_worms	pointer
)	O
;	O
semeai_review_owl_moves	function
(	O
shape_defensive_moves	array
,	O
owla	pointer
,	O
owlb	pointer
,	O
color	int
,	O
&	O
safe_outside_liberty_found	pointer
,	O
&	O
safe_common_liberty_found	pointer
,	O
&	O
riskless_move_found	pointer
,	O
mw	array
,	O
moves	array
,	O
0	int
,	O
0	int
,	O
critical_semeai_worms	pointer
)	O
;	O
}	O
if	O
(	O
!	O
you_look_alive	int
)	O
{	O
semeai_review_owl_moves	function
(	O
vital_offensive_moves	array
,	O
owla	pointer
,	O
owlb	pointer
,	O
color	int
,	O
&	O
safe_outside_liberty_found	pointer
,	O
&	O
safe_common_liberty_found	pointer
,	O
&	O
riskless_move_found	pointer
,	O
mw	array
,	O
moves	array
,	O
1	int
,	O
30	int
,	O
critical_semeai_worms	pointer
)	O
;	O
semeai_review_owl_moves	function
(	O
shape_offensive_moves	array
,	O
owla	pointer
,	O
owlb	pointer
,	O
color	int
,	O
&	O
safe_outside_liberty_found	pointer
,	O
&	O
safe_common_liberty_found	pointer
,	O
&	O
riskless_move_found	pointer
,	O
mw	array
,	O
moves	array
,	O
1	int
,	O
0	int
,	O
critical_semeai_worms	pointer
)	O
;	O
}	O
if	O
(	O
moves	array
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
||	O
we_might_be_inessential	int
)	O
{	O
include_semeai_worms_in_eyespace	int
=	O
1	int
;	O
if	O
(	O
!	O
owl_estimate_life	function
(	O
owlb	pointer
,	O
owla	pointer
,	O
vital_offensive_moves	array
,	O
&	O
live_reasonb	pointer
,	O
1	int
,	O
&	O
dummy_eyes	struct
,	O
&	O
eyemin_b	int
,	O
&	O
eyemax_b	int
)	O
)	O
semeai_review_owl_moves	function
(	O
vital_offensive_moves	array
,	O
owla	pointer
,	O
owlb	pointer
,	O
color	int
,	O
&	O
safe_outside_liberty_found	pointer
,	O
&	O
safe_common_liberty_found	pointer
,	O
&	O
riskless_move_found	pointer
,	O
mw	array
,	O
moves	array
,	O
1	int
,	O
30	int
,	O
critical_semeai_worms	pointer
)	O
;	O
include_semeai_worms_in_eyespace	int
=	O
0	int
;	O
}	O
if	O
(	O
eyemin_a	int
==	O
eyemax_a	int
)	O
I_have_more_eyes	int
=	O
(	O
eyemin_a	int
>	O
min_eyes	function
(	O
&	O
probable_eyes_b	struct
)	O
)	O
;	O
else	O
{	O
if	O
(	O
min_eyes	function
(	O
&	O
probable_eyes_a	struct
)	O
==	O
max_eyes	function
(	O
&	O
probable_eyes_a	struct
)	O
)	O
I_have_more_eyes	int
=	O
(	O
max_eyes	function
(	O
&	O
probable_eyes_a	struct
)	O
>	O
min_eyes	function
(	O
&	O
probable_eyes_b	struct
)	O
)	O
;	O
else	O
I_have_more_eyes	int
=	O
(	O
max_eyes	function
(	O
&	O
probable_eyes_a	struct
)	O
>	O
max_eyes	function
(	O
&	O
probable_eyes_b	struct
)	O
)	O
;	O
}	O
if	O
(	O
get_level	function
(	O
)	O
<	O
8	int
)	O
{	O
if	O
(	O
moves	array
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
if	O
(	O
owl_phase	int
==	O
1	int
)	O
owl_phase	int
=	O
2	int
;	O
else	O
if	O
(	O
owl_phase	int
==	O
2	int
)	O
owl_phase	int
=	O
0	int
;	O
}	O
else	O
owl_phase	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
1	int
&&	O
verbose	int
)	O
{	O
showboard	function
(	O
0	int
)	O
;	O
goaldump	function
(	O
owla	pointer
->	O
goal	pointer
)	O
;	O
goaldump	function
(	O
owlb	pointer
->	O
goal	pointer
)	O
;	O
}	O
if	O
(	O
!	O
you_look_alive	int
&&	O
!	O
safe_outside_liberty_found	pointer
&&	O
(	O
moves	array
[	O
0	int
]	O
.	O
value	pointer
<	O
110	int
||	O
I_have_more_eyes	int
)	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
!	O
mw	array
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
liberty_of_goal	function
(	O
pos	int
,	O
owlb	pointer
)	O
)	O
{	O
if	O
(	O
!	O
liberty_of_goal	function
(	O
pos	int
,	O
owla	pointer
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
pos	int
,	O
color	int
)	O
==	O
WIN	int
)	O
{	O
safe_outside_liberty_found	pointer
=	O
1	int
;	O
outside_liberty	struct
.	O
pos	int
=	O
pos	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
backfill_outside_liberty	struct
.	O
pos	int
==	O
NO_MOVE	O
)	O
backfill_outside_liberty	struct
.	O
pos	int
=	O
find_semeai_backfilling_move	function
(	O
bpos	int
,	O
pos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
safe_move	function
(	O
pos	int
,	O
color	int
)	O
==	O
WIN	int
)	O
{	O
safe_common_liberty_found	pointer
=	O
1	int
;	O
common_liberty	struct
.	O
pos	int
=	O
pos	int
;	O
}	O
else	O
if	O
(	O
backfill_common_liberty	struct
.	O
pos	int
==	O
NO_MOVE	O
)	O
backfill_common_liberty	struct
.	O
pos	int
=	O
find_semeai_backfilling_move	function
(	O
bpos	int
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
you_look_alive	int
)	O
{	O
if	O
(	O
safe_outside_liberty_found	pointer
&&	O
outside_liberty	struct
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	pointer
=	O
semeai_move_value	function
(	O
outside_liberty	struct
.	O
pos	int
,	O
owla	pointer
,	O
owlb	pointer
,	O
50	int
,	O
critical_semeai_worms	pointer
)	O
;	O
owl_add_move	function
(	O
moves	array
,	O
outside_liberty	struct
.	O
pos	int
,	O
move_value	pointer
,	O
"safe outside liberty"	pointer
,	O
SAME_DRAGON_NOT_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
riskless_move_found	pointer
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (5)\n"	pointer
,	O
outside_liberty	struct
.	O
pos	int
,	O
move_value	pointer
)	O
;	O
}	O
else	O
if	O
(	O
backfill_outside_liberty	struct
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	pointer
=	O
semeai_move_value	function
(	O
backfill_outside_liberty	struct
.	O
pos	int
,	O
owla	pointer
,	O
owlb	pointer
,	O
50	int
,	O
critical_semeai_worms	pointer
)	O
;	O
owl_add_move	function
(	O
moves	array
,	O
backfill_outside_liberty	struct
.	O
pos	int
,	O
move_value	pointer
,	O
"backfilling move"	pointer
,	O
SAME_DRAGON_NOT_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
riskless_move_found	pointer
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (6)\n"	pointer
,	O
backfill_outside_liberty	struct
.	O
pos	int
,	O
move_value	pointer
)	O
;	O
}	O
else	O
if	O
(	O
safe_common_liberty_found	pointer
&&	O
common_liberty	struct
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	pointer
=	O
semeai_move_value	function
(	O
common_liberty	struct
.	O
pos	int
,	O
owla	pointer
,	O
owlb	pointer
,	O
10	int
,	O
critical_semeai_worms	pointer
)	O
;	O
owl_add_move	function
(	O
moves	array
,	O
common_liberty	struct
.	O
pos	int
,	O
move_value	pointer
,	O
"safe common liberty"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
if	O
(	O
semeai_is_riskless_move	function
(	O
common_liberty	struct
.	O
pos	int
,	O
owla	pointer
)	O
)	O
riskless_move_found	pointer
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (7)\n"	pointer
,	O
common_liberty	struct
.	O
pos	int
,	O
move_value	pointer
)	O
;	O
}	O
else	O
if	O
(	O
backfill_common_liberty	struct
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	pointer
=	O
semeai_move_value	function
(	O
backfill_common_liberty	struct
.	O
pos	int
,	O
owla	pointer
,	O
owlb	pointer
,	O
10	int
,	O
critical_semeai_worms	pointer
)	O
;	O
owl_add_move	function
(	O
moves	array
,	O
backfill_common_liberty	struct
.	O
pos	int
,	O
move_value	pointer
,	O
"backfilling move"	pointer
,	O
SAME_DRAGON_NOT_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
if	O
(	O
semeai_is_riskless_move	function
(	O
backfill_common_liberty	struct
.	O
pos	int
,	O
owla	pointer
)	O
)	O
riskless_move_found	pointer
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (6)\n"	pointer
,	O
backfill_common_liberty	struct
.	O
pos	int
,	O
move_value	pointer
)	O
;	O
}	O
}	O
if	O
(	O
moves	array
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
if	O
(	O
min_eyes	function
(	O
&	O
probable_eyes_b	struct
)	O
==	O
1	int
)	O
{	O
int	O
move	pointer
=	O
semeai_propose_eyespace_filling_move	function
(	O
owla	pointer
,	O
owlb	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
{	O
owl_add_move	function
(	O
moves	array
,	O
move	pointer
,	O
70	int
,	O
"eyespace filling"	pointer
,	O
SAME_DRAGON_NOT_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
moves	array
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
TRACE	O
(	O
"No move found\n"	pointer
)	O
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
tested_moves	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_SEMEAI_MOVES	int
;	O
k	int
++	O
)	O
{	O
int	O
mpos	int
=	O
moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
if	O
(	O
mpos	int
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
tested_moves	int
>	O
2	int
||	O
(	O
stackp	int
>	O
semeai_branch_depth2	int
&&	O
tested_moves	int
>	O
1	int
)	O
||	O
(	O
stackp	int
>	O
semeai_branch_depth	int
&&	O
tested_moves	int
>	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
allpats	int
)	O
break	O
;	O
else	O
if	O
(	O
trymove	function
(	O
mpos	int
,	O
color	int
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
,	O
apos	int
)	O
)	O
{	O
semeai_add_sgf_comment	function
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
,	O
owl_phase	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
count_variations	int
>=	O
semeai_node_limit	int
||	O
stackp	int
>=	O
MAX_SEMEAI_DEPTH	int
)	O
continue	O
;	O
if	O
(	O
semeai_trymove_and_recurse	function
(	O
apos	int
,	O
bpos	int
,	O
owla	pointer
,	O
owlb	pointer
,	O
owl_phase	int
,	O
mpos	int
,	O
color	int
,	O
best_resulta	int
==	O
0	int
||	O
best_resultb	int
==	O
0	int
,	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
,	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
,	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
,	O
moves	array
[	O
k	int
]	O
.	O
lunch	int
,	O
NULL	O
,	O
&	O
this_resulta	pointer
,	O
&	O
this_resultb	pointer
)	O
)	O
{	O
tested_moves	int
++	O
;	O
if	O
(	O
this_resultb	pointer
==	O
WIN	int
&&	O
this_resulta	pointer
==	O
WIN	int
)	O
{	O
*	O
resulta	pointer
=	O
WIN	int
;	O
*	O
resultb	pointer
=	O
WIN	int
;	O
*	O
move	pointer
=	O
mpos	int
;	O
TRACE	O
(	O
"After %1m I (%C) am alive, you are dead\n"	pointer
,	O
mpos	int
,	O
color	int
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
mpos	int
,	O
WIN	int
,	O
WIN	int
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
)	O
;	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_defensive_patterns	struct
)	O
;	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_offensive_patterns	struct
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
mpos	int
,	O
WIN	int
,	O
WIN	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
prefer_ko	int
!=	O
color	int
&&	O
(	O
this_resulta	pointer
>	O
best_resulta	int
||	O
(	O
this_resulta	pointer
==	O
best_resulta	int
&&	O
this_resultb	pointer
>	O
best_resultb	int
)	O
)	O
)	O
||	O
(	O
prefer_ko	int
==	O
color	int
&&	O
(	O
this_resultb	pointer
>	O
best_resultb	int
||	O
(	O
this_resultb	pointer
==	O
best_resultb	int
&&	O
this_resulta	pointer
>	O
best_resulta	int
)	O
)	O
)	O
)	O
{	O
best_resulta	int
=	O
this_resulta	pointer
;	O
best_resultb	int
=	O
this_resultb	pointer
;	O
best_move	int
=	O
mpos	int
;	O
best_move_name	pointer
=	O
moves	array
[	O
k	int
]	O
.	O
name	short
;	O
}	O
}	O
}	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_defensive_patterns	struct
)	O
;	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_offensive_patterns	struct
)	O
;	O
if	O
(	O
best_resulta	int
==	O
0	int
&&	O
best_resultb	int
==	O
0	int
&&	O
you_look_alive	int
)	O
{	O
*	O
resulta	pointer
=	O
0	int
;	O
*	O
resultb	pointer
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
0	int
,	O
"You live, I die"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
best_resulta	int
==	O
0	int
&&	O
best_resultb	int
==	O
0	int
&&	O
!	O
riskless_move_found	pointer
)	O
{	O
const	O
char	O
*	O
live_reasona	pointer
;	O
int	O
eyemin_a	int
;	O
int	O
eyemax_a	int
;	O
for	O
(	O
sworm	int
=	O
0	int
;	O
sworm	int
<	O
s_worms	int
;	O
sworm	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
semeai_worms	array
[	O
sworm	int
]	O
]	O
==	O
other	int
)	O
{	O
if	O
(	O
important_semeai_worms	array
[	O
sworm	int
]	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
sworm	int
==	O
s_worms	int
)	O
{	O
include_semeai_worms_in_eyespace	int
=	O
1	int
;	O
if	O
(	O
!	O
owl_estimate_life	function
(	O
owla	pointer
,	O
owlb	pointer
,	O
vital_defensive_moves	array
,	O
&	O
live_reasona	pointer
,	O
0	int
,	O
&	O
dummy_eyes	struct
,	O
&	O
eyemin_a	int
,	O
&	O
eyemax_a	int
)	O
&&	O
eyemax_a	int
<	O
2	int
)	O
{	O
include_semeai_worms_in_eyespace	int
=	O
0	int
;	O
*	O
resulta	pointer
=	O
0	int
;	O
*	O
resultb	pointer
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
0	int
,	O
"You live, I die - 2"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
include_semeai_worms_in_eyespace	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
best_resulta	int
==	O
0	int
&&	O
best_resultb	int
==	O
0	int
&&	O
!	O
riskless_move_found	pointer
)	O
{	O
if	O
(	O
pass	int
)	O
{	O
if	O
(	O
max_eyes	function
(	O
&	O
probable_eyes_a	struct
)	O
<	O
min_eyes	function
(	O
&	O
probable_eyes_b	struct
)	O
)	O
{	O
*	O
resulta	pointer
=	O
0	int
;	O
*	O
resultb	pointer
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
TRACE	O
(	O
"You have more eyes.\n"	pointer
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
0	int
,	O
"You have more eyes"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
max_eyes	function
(	O
&	O
probable_eyes_b	struct
)	O
<	O
min_eyes	function
(	O
&	O
probable_eyes_a	struct
)	O
)	O
{	O
*	O
resulta	pointer
=	O
WIN	int
;	O
*	O
resultb	pointer
=	O
WIN	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
TRACE	O
(	O
"I have more eyes\n"	pointer
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
WIN	int
,	O
"I have more eyes"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
WIN	int
,	O
WIN	int
)	O
;	O
}	O
else	O
{	O
*	O
resulta	pointer
=	O
WIN	int
;	O
*	O
resultb	pointer
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
TRACE	O
(	O
"Seki\n"	pointer
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
0	int
,	O
"Seki"	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
WIN	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
do_owl_analyze_semeai	function
(	O
bpos	int
,	O
apos	int
,	O
owlb	pointer
,	O
owla	pointer
,	O
resultb	pointer
,	O
resulta	pointer
,	O
NULL	O
,	O
1	int
,	O
owl_phase	int
)	O
;	O
*	O
resulta	pointer
=	O
REVERSE_RESULT	O
(	O
*	O
resulta	pointer
)	O
;	O
*	O
resultb	pointer
=	O
REVERSE_RESULT	O
(	O
*	O
resultb	pointer
)	O
;	O
TRACE	O
(	O
"No move found\n"	pointer
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
,	O
"No move found"	pointer
)	O
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
PASS_MOVE	int
,	O
*	O
resulta	pointer
,	O
*	O
resultb	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
pass	int
&&	O
k	int
==	O
1	int
)	O
{	O
if	O
(	O
(	O
best_resulta	int
==	O
WIN	int
&&	O
best_resultb	int
==	O
0	int
&&	O
best_move	int
!=	O
NO_MOVE	O
&&	O
best_move	int
==	O
common_liberty	struct
.	O
pos	int
)	O
||	O
(	O
best_resulta	int
==	O
KO_B	int
&&	O
best_resultb	int
==	O
KO_B	int
&&	O
is_ko	function
(	O
best_move	int
,	O
owla	pointer
->	O
color	int
,	O
NULL	O
)	O
)	O
)	O
{	O
do_owl_analyze_semeai	function
(	O
bpos	int
,	O
apos	int
,	O
owlb	pointer
,	O
owla	pointer
,	O
&	O
this_resultb	pointer
,	O
&	O
this_resulta	pointer
,	O
NULL	O
,	O
1	int
,	O
owl_phase	int
)	O
;	O
if	O
(	O
REVERSE_RESULT	O
(	O
this_resulta	pointer
)	O
>=	O
best_resulta	int
&&	O
REVERSE_RESULT	O
(	O
this_resultb	pointer
)	O
>=	O
best_resultb	int
)	O
{	O
best_move	int
=	O
PASS_MOVE	int
;	O
best_resulta	int
=	O
REVERSE_RESULT	O
(	O
this_resulta	pointer
)	O
;	O
best_resultb	int
=	O
REVERSE_RESULT	O
(	O
this_resultb	pointer
)	O
;	O
best_move_name	pointer
=	O
"Pass"	pointer
;	O
}	O
}	O
}	O
*	O
resulta	pointer
=	O
best_resulta	int
;	O
*	O
resultb	pointer
=	O
best_resultb	int
;	O
if	O
(	O
best_resulta	int
==	O
0	int
)	O
best_move	int
=	O
PASS_MOVE	int
;	O
*	O
move	pointer
=	O
best_move	int
;	O
SGFTRACE_SEMEAI	O
(	O
best_move	int
,	O
best_resulta	int
,	O
best_resultb	int
,	O
best_move_name	pointer
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
best_move	int
,	O
best_resulta	int
,	O
best_resultb	int
)	O
;	O
}	O
static	O
int	O
semeai_trymove_and_recurse	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
owl_phase	int
,	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
ko_allowed	int
,	O
int	O
move_value	pointer
,	O
const	O
char	O
*	O
move_name	pointer
,	O
enum	O
same_dragon_value	enum
same_dragon	function
,	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
,	O
int	O
lunch	int
,	O
int	O
*	O
semeai_move	pointer
,	O
int	O
*	O
this_resulta	pointer
,	O
int	O
*	O
this_resultb	pointer
)	O
{	O
int	O
ko_move	int
=	O
0	int
;	O
gg_assert	O
(	O
this_resulta	pointer
!=	O
NULL	O
&&	O
this_resultb	pointer
!=	O
NULL	O
)	O
;	O
*	O
this_resulta	pointer
=	O
0	int
;	O
*	O
this_resultb	pointer
=	O
0	int
;	O
if	O
(	O
!	O
komaster_trymove	function
(	O
move	pointer
,	O
color	int
,	O
move_name	pointer
,	O
apos	int
,	O
&	O
ko_move	int
,	O
ko_allowed	int
)	O
)	O
{	O
int	O
kpos	int
;	O
if	O
(	O
is_ko	function
(	O
move	pointer
,	O
color	int
,	O
&	O
kpos	int
)	O
)	O
{	O
int	O
libs	pointer
[	O
MAX_LIBERTIES	int
]	O
;	O
int	O
n	int
;	O
int	O
nlib	int
;	O
int	O
sworm	int
;	O
int	O
worm_color	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
sworm	int
=	O
0	int
;	O
sworm	int
<	O
s_worms	int
;	O
sworm	int
++	O
)	O
{	O
worm_color	int
=	O
board	pointer
[	O
semeai_worms	array
[	O
sworm	int
]	O
]	O
;	O
if	O
(	O
worm_color	int
==	O
color	int
)	O
{	O
nlib	int
=	O
findlib	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
,	O
MAX_LIBERTIES	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
nlib	int
>	O
MAX_LIBERTIES	int
)	O
return	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nlib	int
;	O
n	int
++	O
)	O
if	O
(	O
is_ko	function
(	O
libs	pointer
[	O
n	int
]	O
,	O
other	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
DIAGONAL_NEIGHBORS	O
(	O
libs	pointer
[	O
n	int
]	O
,	O
kpos	int
)	O
)	O
return	O
0	int
;	O
*	O
this_resulta	pointer
=	O
WIN	int
;	O
*	O
this_resultb	pointer
=	O
WIN	int
;	O
}	O
}	O
else	O
if	O
(	O
worm_color	int
==	O
other	int
)	O
{	O
if	O
(	O
countlib	function
(	O
semeai_worms	array
[	O
sworm	int
]	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
*	O
this_resulta	pointer
==	O
WIN	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
semeai_add_sgf_comment	function
(	O
move_value	pointer
,	O
owl_phase	int
)	O
;	O
TRACE	O
(	O
"Trying %C %1m. Current stack: "	pointer
,	O
color	int
,	O
move	pointer
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
dump_stack	function
(	O
)	O
;	O
goaldump	function
(	O
owla	pointer
->	O
goal	pointer
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
goaldump	function
(	O
owlb	pointer
->	O
goal	pointer
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
TRACE	O
(	O
"%s, value %d, same_dragon %d\n"	pointer
,	O
move_name	pointer
,	O
move_value	pointer
,	O
same_dragon	function
)	O
;	O
push_owl	function
(	O
&	O
owla	pointer
)	O
;	O
push_owl	function
(	O
&	O
owlb	pointer
)	O
;	O
if	O
(	O
owla	pointer
->	O
color	int
==	O
color	int
)	O
{	O
owl_update_goal	function
(	O
move	pointer
,	O
same_dragon	function
,	O
lunch	int
,	O
owla	pointer
,	O
1	int
,	O
pattern_data	pointer
)	O
;	O
owl_update_boundary_marks	function
(	O
move	pointer
,	O
owlb	pointer
)	O
;	O
}	O
else	O
{	O
owl_update_goal	function
(	O
move	pointer
,	O
same_dragon	function
,	O
lunch	int
,	O
owlb	pointer
,	O
1	int
,	O
pattern_data	pointer
)	O
;	O
owl_update_boundary_marks	function
(	O
move	pointer
,	O
owla	pointer
)	O
;	O
}	O
mark_goal_in_sgf	function
(	O
owla	pointer
->	O
goal	pointer
)	O
;	O
mark_goal_in_sgf	function
(	O
owlb	pointer
->	O
goal	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
)	O
{	O
*	O
this_resulta	pointer
=	O
REVERSE_RESULT	O
(	O
do_owl_attack	function
(	O
apos	int
,	O
semeai_move	pointer
,	O
NULL	O
,	O
owla	pointer
,	O
0	int
)	O
)	O
;	O
*	O
this_resultb	pointer
=	O
*	O
this_resulta	pointer
;	O
}	O
else	O
{	O
do_owl_analyze_semeai	function
(	O
bpos	int
,	O
apos	int
,	O
owlb	pointer
,	O
owla	pointer
,	O
this_resultb	pointer
,	O
this_resulta	pointer
,	O
semeai_move	pointer
,	O
0	int
,	O
owl_phase	int
)	O
;	O
*	O
this_resulta	pointer
=	O
REVERSE_RESULT	O
(	O
*	O
this_resulta	pointer
)	O
;	O
*	O
this_resultb	pointer
=	O
REVERSE_RESULT	O
(	O
*	O
this_resultb	pointer
)	O
;	O
}	O
pop_owl	function
(	O
&	O
owlb	pointer
)	O
;	O
pop_owl	function
(	O
&	O
owla	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
ko_move	int
)	O
{	O
if	O
(	O
*	O
this_resulta	pointer
!=	O
0	int
)	O
*	O
this_resulta	pointer
=	O
KO_B	int
;	O
if	O
(	O
*	O
this_resultb	pointer
!=	O
0	int
)	O
*	O
this_resultb	pointer
=	O
KO_B	int
;	O
}	O
if	O
(	O
count_variations	int
>=	O
semeai_node_limit	int
)	O
{	O
TRACE	O
(	O
"Out of nodes, claiming win.\n"	pointer
)	O
;	O
result_certain	int
=	O
0	int
;	O
*	O
this_resulta	pointer
=	O
WIN	int
;	O
*	O
this_resultb	pointer
=	O
WIN	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
semeai_add_sgf_comment	function
(	O
int	O
value	pointer
,	O
int	O
owl_phase	int
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
if	O
(	O
!	O
sgf_dumptree	pointer
)	O
return	O
;	O
if	O
(	O
owl_phase	int
)	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"value %d, owl_phase"	pointer
,	O
value	pointer
)	O
;	O
else	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"value %d"	pointer
,	O
value	pointer
)	O
;	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
}	O
static	O
int	O
semeai_trust_tactical_attack	function
(	O
int	O
str	int
)	O
{	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
3	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
3	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
liberties	pointer
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
liberties	pointer
<	O
2	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
)	O
||	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
semeai_is_riskless_move	function
(	O
int	O
move	pointer
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
)	O
{	O
int	O
k	int
;	O
int	O
liberties	pointer
=	O
accuratelib	function
(	O
move	pointer
,	O
owla	pointer
->	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
liberty_of_goal	function
(	O
move	pointer
,	O
owla	pointer
)	O
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
owla	pointer
->	O
color	int
&&	O
owla	pointer
->	O
goal	pointer
[	O
pos	int
]	O
&&	O
countlib	function
(	O
pos	int
)	O
>	O
liberties	pointer
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
semeai_review_owl_moves	function
(	O
struct	O
owl_move_data	struct
owl_moves	array
[	O
MAX_MOVES	int
]	O
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
color	int
,	O
int	O
*	O
safe_outside_liberty_found	pointer
,	O
int	O
*	O
safe_common_liberty_found	pointer
,	O
int	O
*	O
riskless_move_found	pointer
,	O
signed	O
char	O
mw	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
owl_move_data	struct
semeai_moves	array
[	O
MAX_SEMEAI_MOVES	int
]	O
,	O
int	O
guess_same_dragon	int
,	O
int	O
value_bonus	int
,	O
int	O
*	O
critical_semeai_worms	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
move_value	pointer
;	O
enum	O
same_dragon_value	enum
same_dragon	function
;	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
=	O
NULL	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
-	O
1	int
;	O
k	int
++	O
)	O
{	O
move	pointer
=	O
owl_moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
if	O
(	O
move	pointer
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
owl_moves	array
[	O
k	int
]	O
.	O
value	pointer
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
liberty_of_goal	function
(	O
move	pointer
,	O
owlb	pointer
)	O
&&	O
safe_move	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
!	O
liberty_of_goal	function
(	O
move	pointer
,	O
owla	pointer
)	O
)	O
*	O
safe_outside_liberty_found	pointer
=	O
1	int
;	O
else	O
*	O
safe_common_liberty_found	pointer
=	O
1	int
;	O
}	O
if	O
(	O
is_legal	function
(	O
move	pointer
,	O
color	int
)	O
&&	O
!	O
is_ko	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
)	O
&&	O
semeai_is_riskless_move	function
(	O
move	pointer
,	O
owla	pointer
)	O
)	O
*	O
riskless_move_found	pointer
=	O
1	int
;	O
if	O
(	O
guess_same_dragon	int
)	O
{	O
if	O
(	O
liberty_of_goal	function
(	O
move	pointer
,	O
owla	pointer
)	O
||	O
second_liberty_of_goal	function
(	O
move	pointer
,	O
owla	pointer
)	O
)	O
same_dragon	function
=	O
SAME_DRAGON_MAYBE_CONNECTED	int
;	O
else	O
same_dragon	function
=	O
SAME_DRAGON_NOT_CONNECTED	int
;	O
}	O
else	O
{	O
same_dragon	function
=	O
owl_moves	array
[	O
k	int
]	O
.	O
same_dragon	function
;	O
pattern_data	pointer
=	O
owl_moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
;	O
}	O
mw	array
[	O
move	pointer
]	O
=	O
1	int
;	O
move_value	pointer
=	O
(	O
semeai_move_value	function
(	O
move	pointer
,	O
owla	pointer
,	O
owlb	pointer
,	O
owl_moves	array
[	O
k	int
]	O
.	O
value	pointer
,	O
critical_semeai_worms	pointer
)	O
+	O
value_bonus	int
)	O
;	O
owl_add_move	function
(	O
semeai_moves	array
,	O
move	pointer
,	O
move_value	pointer
,	O
owl_moves	array
[	O
k	int
]	O
.	O
name	short
,	O
same_dragon	function
,	O
NO_MOVE	O
,	O
owl_moves	array
[	O
k	int
]	O
.	O
escape	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	int
,	O
pattern_data	pointer
)	O
;	O
TRACE	O
(	O
"Added %1m %d\n"	pointer
,	O
move	pointer
,	O
move_value	pointer
)	O
;	O
}	O
}	O
static	O
int	O
semeai_propose_eyespace_filling_move	function
(	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
)	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
owlb	pointer
->	O
color	int
)	O
;	O
int	O
pos	int
;	O
int	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
int	O
mz	array
[	O
BOARDMAX	O
]	O
;	O
owl_find_relevant_eyespaces	function
(	O
owlb	pointer
,	O
mw	array
,	O
mz	array
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
owla	pointer
->	O
goal	pointer
[	O
pos	int
]	O
)	O
mw	array
[	O
owlb	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
origin	int
=	O
owlb	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
mw	array
[	O
origin	int
]	O
>	O
1	int
&&	O
min_eyes	function
(	O
&	O
owlb	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
value	pointer
)	O
==	O
1	int
)	O
{	O
int	O
good_move	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"eyespace_filling"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
struct	O
eyevalue	struct
new_value	struct
;	O
int	O
dummy_attack	int
;	O
int	O
dummy_defense	int
;	O
compute_eyes	function
(	O
origin	int
,	O
&	O
new_value	struct
,	O
&	O
dummy_attack	int
,	O
&	O
dummy_defense	int
,	O
owlb	pointer
->	O
my_eye	array
,	O
owlb	pointer
->	O
half_eye	array
,	O
0	int
)	O
;	O
if	O
(	O
max_eyes	function
(	O
&	O
new_value	struct
)	O
<=	O
1	int
)	O
good_move	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
good_move	int
)	O
return	O
pos	int
;	O
}	O
}	O
}	O
return	O
NO_MOVE	O
;	O
}	O
static	O
int	O
semeai_move_value	function
(	O
int	O
move	pointer
,	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
,	O
int	O
raw_value	int
,	O
int	O
*	O
critical_semeai_worms	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
net	int
=	O
0	int
;	O
int	O
color	int
=	O
owla	pointer
->	O
color	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
int	O
k	int
;	O
int	O
bonus	int
=	O
0	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
move	pointer
]	O
==	O
EMPTY	int
,	O
move	pointer
)	O
;	O
verbose	int
=	O
0	int
;	O
if	O
(	O
safe_move	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
pos	int
==	O
find_origin	function
(	O
pos	int
)	O
)	O
{	O
int	O
count_lib	int
=	O
-	O
1	int
;	O
if	O
(	O
owla	pointer
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
count_lib	int
=	O
countlib	function
(	O
pos	int
)	O
;	O
net	int
-=	O
75	int
*	O
count_lib	int
;	O
}	O
if	O
(	O
owlb	pointer
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
count_lib	int
<	O
0	int
)	O
count_lib	int
=	O
countlib	function
(	O
pos	int
)	O
;	O
net	int
+=	O
100	int
*	O
count_lib	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
pos	int
==	O
find_origin	function
(	O
pos	int
)	O
)	O
{	O
int	O
count_lib	int
=	O
-	O
1	int
;	O
if	O
(	O
owla	pointer
->	O
goal	pointer
[	O
pos	int
]	O
||	O
(	O
pos	int
==	O
move	pointer
&&	O
liberty_of_goal	function
(	O
move	pointer
,	O
owla	pointer
)	O
)	O
)	O
{	O
count_lib	int
=	O
countlib	function
(	O
pos	int
)	O
;	O
net	int
+=	O
75	int
*	O
count_lib	int
;	O
}	O
if	O
(	O
owlb	pointer
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
count_lib	int
<	O
0	int
)	O
count_lib	int
=	O
countlib	function
(	O
pos	int
)	O
;	O
net	int
-=	O
100	int
*	O
count_lib	int
;	O
}	O
}	O
}	O
increase_depth_values	function
(	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s_worms	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
critical_semeai_worms	pointer
[	O
k	int
]	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
semeai_worms	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
attack	function
(	O
semeai_worms	array
[	O
k	int
]	O
,	O
NULL	O
)	O
)	O
bonus	int
+=	O
50	int
;	O
else	O
if	O
(	O
board	pointer
[	O
semeai_worms	array
[	O
k	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
find_defense	function
(	O
semeai_worms	array
[	O
k	int
]	O
,	O
NULL	O
)	O
)	O
bonus	int
+=	O
50	int
;	O
}	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
if	O
(	O
net	int
<	O
0	int
)	O
net	int
=	O
0	int
;	O
net	int
/=	O
25	int
;	O
net	int
*=	O
3	int
;	O
return	O
raw_value	int
+	O
net	int
+	O
bonus	int
;	O
}	O
static	O
void	O
remove_eye_filling_moves	function
(	O
struct	O
local_owl_data	struct
*	O
our_owl	pointer
,	O
struct	O
owl_move_data	struct
*	O
moves	array
)	O
{	O
int	O
k	int
;	O
int	O
color	int
=	O
our_owl	pointer
->	O
color	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
break	O
;	O
else	O
{	O
struct	O
eye_data	struct
*	O
eye	array
=	O
&	O
our_owl	pointer
->	O
my_eye	array
[	O
moves	array
[	O
k	int
]	O
.	O
pos	int
]	O
;	O
if	O
(	O
eye	array
->	O
color	int
==	O
color	int
&&	O
eye	array
->	O
msize	int
==	O
0	int
&&	O
eye	array
->	O
neighbors	int
<=	O
1	int
&&	O
eye	array
->	O
esize	int
!=	O
1	int
&&	O
our_owl	pointer
->	O
half_eye	array
[	O
moves	array
[	O
k	int
]	O
.	O
pos	int
]	O
.	O
type	char
!=	O
HALF_EYE	int
&&	O
!	O
has_neighbor	function
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
=	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
liberty_of_goal	function
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
second_liberty_of_goal	function
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
liberty_of_goal	function
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
,	O
owl	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
find_semeai_backfilling_move	function
(	O
int	O
worm	array
,	O
int	O
liberty	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
worm	array
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
result	int
=	O
NO_MOVE	O
;	O
if	O
(	O
safe_move	function
(	O
liberty	int
,	O
other	int
)	O
==	O
WIN	int
)	O
return	O
liberty	int
;	O
if	O
(	O
is_self_atari	function
(	O
liberty	int
,	O
other	int
)	O
)	O
{	O
int	O
fill	int
;	O
if	O
(	O
approxlib	function
(	O
liberty	int
,	O
other	int
,	O
1	int
,	O
&	O
fill	int
)	O
>	O
0	int
&&	O
trymove	function
(	O
fill	int
,	O
other	int
,	O
"find_semeai_backfilling_move"	pointer
,	O
worm	array
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
liberty	int
,	O
other	int
)	O
)	O
result	int
=	O
fill	int
;	O
else	O
if	O
(	O
board	pointer
[	O
worm	array
]	O
!=	O
EMPTY	int
)	O
result	int
=	O
find_semeai_backfilling_move	function
(	O
worm	array
,	O
liberty	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
result	int
)	O
&&	O
safe_move	function
(	O
result	int
,	O
other	int
)	O
)	O
return	O
result	int
;	O
else	O
return	O
NO_MOVE	O
;	O
}	O
static	O
int	O
reading_limit_reached	function
(	O
const	O
char	O
*	O
*	O
live_reason	pointer
,	O
int	O
this_variation_number	int
)	O
{	O
if	O
(	O
stackp	int
>	O
owl_reading_depth	int
)	O
{	O
TRACE	O
(	O
"%oVariation %d: ALIVE (maximum reading depth reached)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
*	O
live_reason	pointer
=	O
"max reading depth reached"	pointer
;	O
return	O
1	int
;	O
}	O
if	O
(	O
local_owl_node_counter	int
>=	O
owl_node_limit	int
)	O
{	O
result_certain	int
=	O
0	int
;	O
TRACE	O
(	O
"%oVariation %d: ALIVE (owl node limit reached)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
*	O
live_reason	pointer
=	O
"owl node limit reached"	pointer
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
clear_owl_move_data	function
(	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_MOVES	int
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
=	O
-	O
1	int
;	O
moves	array
[	O
k	int
]	O
.	O
name	short
=	O
NULL	O
;	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_CONNECTED	int
;	O
moves	array
[	O
k	int
]	O
.	O
escape	int
=	O
0	int
;	O
moves	array
[	O
k	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
=	O
NULL	O
;	O
clear_cut_list	function
(	O
moves	array
[	O
k	int
]	O
.	O
cuts	array
)	O
;	O
}	O
}	O
static	O
void	O
set_single_owl_move	function
(	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
pos	int
,	O
const	O
char	O
*	O
name	short
)	O
{	O
moves	array
[	O
0	int
]	O
.	O
pos	int
=	O
pos	int
;	O
moves	array
[	O
0	int
]	O
.	O
value	pointer
=	O
25	int
;	O
moves	array
[	O
0	int
]	O
.	O
name	short
=	O
name	short
;	O
moves	array
[	O
0	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_MAYBE_CONNECTED	int
;	O
moves	array
[	O
0	int
]	O
.	O
escape	int
=	O
0	int
;	O
moves	array
[	O
0	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
moves	array
[	O
0	int
]	O
.	O
pattern_data	pointer
=	O
NULL	O
;	O
clear_cut_list	function
(	O
moves	array
[	O
0	int
]	O
.	O
cuts	array
)	O
;	O
moves	array
[	O
1	int
]	O
.	O
value	pointer
=	O
0	int
;	O
}	O
int	O
owl_attack	function
(	O
int	O
target	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
certain	pointer
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
result	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
double	O
start	double
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	pointer
=	O
NO_MOVE	O
;	O
int	O
wpos	pointer
=	O
NO_MOVE	O
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
result_certain	int
=	O
1	int
;	O
if	O
(	O
worm	array
[	O
target	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
{	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
NO_MOVE	O
;	O
if	O
(	O
certain	pointer
)	O
*	O
certain	pointer
=	O
1	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
attack_point	pointer
,	O
kworm	int
,	O
certain	pointer
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
TRACE	O
(	O
"owl_attack %1m\n"	pointer
,	O
target	int
)	O
;	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
owl_make_domains	function
(	O
owl	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	function
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	array
,	O
&	O
goal_worms_computed	int
,	O
kworm	int
,	O
1	int
)	O
;	O
result	int
=	O
do_owl_attack	function
(	O
target	int
,	O
&	O
move	pointer
,	O
&	O
wid	int
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	function
(	O
&	O
goal_worms_computed	int
,	O
&	O
wpos	pointer
,	O
owl_goal_worm	array
,	O
wid	int
)	O
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_attack %1m, result %d %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
target	int
,	O
result	int
,	O
move	pointer
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	pointer
,	O
wpos	pointer
,	O
result_certain	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
move	pointer
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	pointer
;	O
if	O
(	O
certain	pointer
)	O
*	O
certain	pointer
=	O
result_certain	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
do_owl_attack	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
wormid	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
escape	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
struct	O
owl_move_data	struct
vital_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
shape_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
*	O
moves	array
;	O
struct	O
matched_patterns_list_data	struct
shape_patterns	struct
;	O
signed	O
char	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
int	O
number_tried_moves	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
k	int
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
saveworm	int
=	O
MAX_GOAL_WORMS	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
eyemin	pointer
=	O
-	O
1	int
;	O
int	O
eyemax	pointer
=	O
-	O
1	int
;	O
struct	O
eyevalue	struct
probable_eyes	pointer
;	O
const	O
char	O
*	O
live_reason	pointer
;	O
int	O
move_cutoff	int
;	O
int	O
xpos	int
;	O
int	O
value1	pointer
;	O
int	O
value2	pointer
;	O
int	O
this_variation_number	int
=	O
count_variations	int
-	O
1	int
;	O
SETUP_TRACE_INFO	O
(	O
"owl_attack"	pointer
,	O
str	int
)	O
;	O
shape_patterns	struct
.	O
initialized	int
=	O
0	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
tt_get	function
(	O
&	O
ttable	struct
,	O
OWL_ATTACK	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value1	pointer
,	O
&	O
value2	pointer
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
value1	pointer
,	O
xpos	int
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
if	O
(	O
value1	pointer
==	O
GAIN	int
)	O
{	O
if	O
(	O
wormid	pointer
)	O
{	O
if	O
(	O
goal_worms_computed	int
)	O
*	O
wormid	pointer
=	O
value2	pointer
;	O
else	O
*	O
wormid	pointer
=	O
MAX_GOAL_WORMS	int
;	O
}	O
}	O
if	O
(	O
value1	pointer
==	O
WIN	int
)	O
TRACE	O
(	O
"%oVariation %d: DEAD (cached)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
else	O
TRACE	O
(	O
"%oVariation %d: ALIVE (cached)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
value1	pointer
,	O
"cached"	pointer
)	O
;	O
return	O
value1	pointer
;	O
}	O
if	O
(	O
reading_limit_reached	function
(	O
&	O
live_reason	pointer
,	O
this_variation_number	int
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
live_reason	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
memset	function
(	O
mw	array
,	O
0	int
,	O
sizeof	O
(	O
mw	array
)	O
)	O
;	O
global_owl_node_counter	int
++	O
;	O
local_owl_node_counter	int
++	O
;	O
current_owl_data	pointer
=	O
owl	int
;	O
memset	function
(	O
owl	int
->	O
safe_move_cache	array
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	array
)	O
)	O
;	O
if	O
(	O
owl_estimate_life	function
(	O
owl	int
,	O
NULL	O
,	O
vital_moves	array
,	O
&	O
live_reason	pointer
,	O
1	int
,	O
&	O
probable_eyes	pointer
,	O
&	O
eyemin	pointer
,	O
&	O
eyemax	pointer
)	O
)	O
{	O
int	O
acode	int
=	O
0	int
;	O
int	O
mpos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
experimental_owl_ext	int
&&	O
goal_worms_computed	int
)	O
{	O
int	O
size	int
=	O
0	int
;	O
saveworm	int
=	O
MAX_GOAL_WORMS	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_GOAL_WORMS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owl_goal_worm	array
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
board	pointer
[	O
owl_goal_worm	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
||	O
countlib	function
(	O
owl_goal_worm	array
[	O
k	int
]	O
)	O
>	O
1	int
)	O
continue	O
;	O
if	O
(	O
worm	array
[	O
owl_goal_worm	array
[	O
k	int
]	O
]	O
.	O
size	int
>	O
size	int
)	O
{	O
saveworm	int
=	O
k	int
;	O
size	int
=	O
worm	array
[	O
owl_goal_worm	array
[	O
k	int
]	O
]	O
.	O
size	int
;	O
}	O
}	O
if	O
(	O
saveworm	int
!=	O
MAX_GOAL_WORMS	int
&&	O
size	int
>=	O
3	int
)	O
{	O
acode	int
=	O
GAIN	int
;	O
findlib	function
(	O
worm	array
[	O
owl_goal_worm	array
[	O
saveworm	int
]	O
]	O
.	O
origin	int
,	O
1	int
,	O
&	O
mpos	int
)	O
;	O
}	O
}	O
SGFTRACE	O
(	O
0	int
,	O
acode	int
,	O
live_reason	pointer
)	O
;	O
TRACE	O
(	O
"%oVariation %d: ALIVE (%s)\n"	pointer
,	O
this_variation_number	int
,	O
live_reason	pointer
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
wormid	pointer
)	O
*	O
wormid	pointer
=	O
saveworm	int
;	O
READ_RETURN2	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
mpos	int
,	O
acode	int
,	O
saveworm	int
)	O
;	O
}	O
}	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
6	int
;	O
pass	int
++	O
)	O
{	O
moves	array
=	O
NULL	O
;	O
move_cutoff	int
=	O
1	int
;	O
current_owl_data	pointer
=	O
owl	int
;	O
switch	O
(	O
pass	int
)	O
{	O
case	O
1	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	int
>	O
0	int
)	O
continue	O
;	O
owl_shapes	function
(	O
&	O
shape_patterns	struct
,	O
shape_moves	array
,	O
other	int
,	O
owl	int
,	O
&	O
owl_attackpat_db	struct
)	O
;	O
moves	array
=	O
shape_moves	array
;	O
break	O
;	O
case	O
0	int
:	O
case	O
2	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	int
>	O
0	int
)	O
continue	O
;	O
moves	array
=	O
vital_moves	array
;	O
if	O
(	O
pass	int
==	O
0	int
||	O
stackp	int
>	O
owl_distrust_depth	int
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
move_cutoff	int
=	O
70	int
;	O
else	O
move_cutoff	int
=	O
45	int
;	O
}	O
if	O
(	O
eyemax	pointer
<	O
2	int
&&	O
stackp	int
>	O
2	int
)	O
move_cutoff	int
=	O
99	int
;	O
break	O
;	O
case	O
3	int
:	O
case	O
5	int
:	O
{	O
int	O
apos	int
;	O
int	O
result	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
result	int
=	O
attack	function
(	O
str	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
result	int
==	O
WIN	int
||	O
(	O
result	int
!=	O
0	int
&&	O
(	O
min_eyes	function
(	O
&	O
probable_eyes	pointer
)	O
>=	O
2	int
||	O
pass	int
==	O
5	int
)	O
)	O
)	O
{	O
set_single_owl_move	function
(	O
shape_moves	array
,	O
apos	int
,	O
"tactical attack"	pointer
)	O
;	O
moves	array
=	O
shape_moves	array
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
number_tried_moves	int
==	O
0	int
)	O
{	O
int	O
dpos	int
;	O
int	O
dcode	int
=	O
do_owl_defend	function
(	O
str	int
,	O
&	O
dpos	int
,	O
NULL	O
,	O
owl	int
,	O
escape	int
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
TRACE	O
(	O
"%oVariation %d: DEAD (no defense)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
"no defense"	pointer
)	O
;	O
close_pattern_list	function
(	O
other	int
,	O
&	O
shape_patterns	struct
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
WIN	int
)	O
;	O
}	O
else	O
if	O
(	O
dpos	int
!=	O
NO_MOVE	O
)	O
{	O
const	O
char	O
*	O
name	short
=	O
"defense move"	pointer
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
is_suicide	function
(	O
dpos	int
,	O
other	int
)	O
||	O
send_two_return_one	function
(	O
dpos	int
,	O
other	int
)	O
)	O
{	O
int	O
dpos2	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
other	int
&&	O
find_defense	function
(	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
,	O
&	O
dpos2	int
)	O
)	O
{	O
dpos	int
=	O
dpos2	int
;	O
name	short
=	O
"defense move (backfill)"	pointer
;	O
break	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
dpos	int
!=	O
NO_MOVE	O
)	O
{	O
set_single_owl_move	function
(	O
shape_moves	array
,	O
dpos	int
,	O
name	short
)	O
;	O
moves	array
=	O
shape_moves	array
;	O
}	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
moves	array
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
int	O
mpos	int
;	O
int	O
ko_move	int
=	O
-	O
1	int
;	O
int	O
origin	int
=	O
NO_MOVE	O
;	O
int	O
captured	int
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
int	O
dcode	int
;	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
k	int
>	O
0	int
)	O
break	O
;	O
current_owl_data	pointer
=	O
owl	int
;	O
if	O
(	O
pass	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
get_next_move_from_list	function
(	O
&	O
shape_patterns	struct
,	O
other	int
,	O
shape_moves	array
,	O
move_cutoff	int
,	O
owl	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
<	O
move_cutoff	int
)	O
break	O
;	O
mpos	int
=	O
moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
ASSERT_ON_BOARD1	O
(	O
mpos	int
)	O
;	O
if	O
(	O
mw	array
[	O
mpos	int
]	O
)	O
continue	O
;	O
captured	int
=	O
(	O
color	int
==	O
WHITE	int
?	O
white_captured	int
:	O
black_captured	int
)	O
;	O
if	O
(	O
!	O
komaster_trymove	function
(	O
mpos	int
,	O
other	int
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
,	O
str	int
,	O
&	O
ko_move	int
,	O
savecode	int
==	O
0	int
)	O
)	O
continue	O
;	O
captured	int
=	O
(	O
color	int
==	O
WHITE	int
?	O
white_captured	int
:	O
black_captured	int
)	O
-	O
captured	int
;	O
TRACE	O
(	O
"Trying %C %1m. Escape = %d. Current stack: "	pointer
,	O
other	int
,	O
mpos	int
,	O
escape	int
)	O
;	O
if	O
(	O
verbose	int
)	O
dump_stack	function
(	O
)	O
;	O
push_owl	function
(	O
&	O
owl	int
)	O
;	O
mw	array
[	O
mpos	int
]	O
=	O
1	int
;	O
number_tried_moves	int
++	O
;	O
owl_update_boundary_marks	function
(	O
mpos	int
,	O
owl	int
)	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
)	O
origin	int
=	O
str	int
;	O
else	O
origin	int
=	O
select_new_goal_origin	function
(	O
NO_MOVE	O
,	O
owl	int
)	O
;	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
cuts	array
[	O
0	int
]	O
!=	O
NO_MOVE	O
&&	O
origin	int
!=	O
NO_MOVE	O
)	O
{	O
owl_test_cuts	function
(	O
owl	int
->	O
goal	pointer
,	O
owl	int
->	O
color	int
,	O
moves	array
[	O
k	int
]	O
.	O
cuts	array
)	O
;	O
if	O
(	O
!	O
owl	int
->	O
goal	pointer
[	O
origin	int
]	O
)	O
origin	int
=	O
select_new_goal_origin	function
(	O
origin	int
,	O
owl	int
)	O
;	O
}	O
mark_goal_in_sgf	function
(	O
owl	int
->	O
goal	pointer
)	O
;	O
if	O
(	O
origin	int
==	O
NO_MOVE	O
)	O
dcode	int
=	O
0	int
;	O
else	O
dcode	int
=	O
do_owl_defend	function
(	O
origin	int
,	O
NULL	O
,	O
&	O
wid	int
,	O
owl	int
,	O
escape	int
)	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
pop_owl	function
(	O
&	O
owl	int
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
const	O
char	O
*	O
wintxt	pointer
;	O
char	O
winstr	array
[	O
192	int
]	O
;	O
if	O
(	O
origin	int
==	O
NO_MOVE	O
)	O
wintxt	pointer
=	O
"all original stones captured"	pointer
;	O
else	O
wintxt	pointer
=	O
"attack effective"	pointer
;	O
sprintf	function
(	O
winstr	array
,	O
"%s)\n  (%d variations"	pointer
,	O
wintxt	pointer
,	O
count_variations	int
-	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
mpos	int
,	O
WIN	int
,	O
winstr	array
)	O
;	O
}	O
close_pattern_list	function
(	O
other	int
,	O
&	O
shape_patterns	struct
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
mpos	int
,	O
WIN	int
)	O
;	O
}	O
else	O
if	O
(	O
experimental_owl_ext	int
&&	O
dcode	int
==	O
LOSS	int
)	O
{	O
if	O
(	O
saveworm	int
==	O
MAX_GOAL_WORMS	int
||	O
worm	array
[	O
owl_goal_worm	array
[	O
wid	int
]	O
]	O
.	O
size	int
>	O
worm	array
[	O
owl_goal_worm	array
[	O
saveworm	int
]	O
]	O
.	O
size	int
)	O
saveworm	int
=	O
wid	int
;	O
}	O
else	O
if	O
(	O
experimental_owl_ext	int
&&	O
goal_worms_computed	int
&&	O
captured	int
>=	O
3	int
)	O
{	O
int	O
w	int
=	O
MAX_GOAL_WORMS	int
;	O
int	O
size	int
=	O
0	int
;	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
MAX_GOAL_WORMS	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
owl_goal_worm	array
[	O
l	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
board	pointer
[	O
owl_goal_worm	array
[	O
l	int
]	O
]	O
==	O
EMPTY	int
)	O
if	O
(	O
size	int
==	O
0	int
||	O
worm	array
[	O
owl_goal_worm	array
[	O
l	int
]	O
]	O
.	O
size	int
>	O
size	int
)	O
{	O
w	int
=	O
l	int
;	O
size	int
=	O
worm	array
[	O
owl_goal_worm	array
[	O
l	int
]	O
]	O
.	O
size	int
;	O
}	O
}	O
if	O
(	O
w	int
!=	O
MAX_GOAL_WORMS	int
)	O
{	O
if	O
(	O
GAIN	int
>	O
savecode	int
)	O
{	O
dcode	int
=	O
LOSS	int
;	O
saveworm	int
=	O
w	int
;	O
}	O
else	O
if	O
(	O
GAIN	int
==	O
savecode	int
)	O
{	O
int	O
wpos	pointer
=	O
owl_goal_worm	array
[	O
saveworm	int
]	O
;	O
if	O
(	O
size	int
>	O
worm	array
[	O
wpos	pointer
]	O
.	O
size	int
)	O
saveworm	int
=	O
w	int
;	O
}	O
}	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
mpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
{	O
if	O
(	O
mpos	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
mpos	int
,	O
KO_B	int
,	O
"all original stones captured with ko"	pointer
)	O
;	O
}	O
else	O
{	O
SGFTRACE	O
(	O
mpos	int
,	O
KO_B	int
,	O
"attack effective - ko"	pointer
)	O
;	O
}	O
savemove	int
=	O
mpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
number_tried_moves	int
--	O
;	O
}	O
}	O
pop_owl	function
(	O
&	O
owl	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
close_pattern_list	function
(	O
other	int
,	O
&	O
shape_patterns	struct
)	O
;	O
if	O
(	O
savecode	int
)	O
{	O
if	O
(	O
savecode	int
==	O
GAIN	int
)	O
{	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"attack effective (gain) - E"	pointer
)	O
;	O
if	O
(	O
wormid	pointer
)	O
*	O
wormid	pointer
=	O
saveworm	int
;	O
READ_RETURN2	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
,	O
saveworm	int
)	O
;	O
}	O
else	O
{	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"attack effective (ko) - E"	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
)	O
;	O
}	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
winstr	array
[	O
128	int
]	O
;	O
sprintf	function
(	O
winstr	array
,	O
"attack failed)\n  (%d variations"	pointer
,	O
count_variations	int
-	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
winstr	array
)	O
;	O
}	O
READ_RETURN0	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
int	O
owl_threaten_attack	function
(	O
int	O
target	int
,	O
int	O
*	O
attack1	pointer
,	O
int	O
*	O
attack2	pointer
)	O
{	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
k	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
target	int
]	O
)	O
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
result	int
=	O
0	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
signed	O
char	O
saved_boundary	array
[	O
BOARDMAX	O
]	O
;	O
double	O
start	double
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	pointer
=	O
0	int
;	O
int	O
move2	pointer
=	O
0	int
;	O
struct	O
matched_patterns_list_data	struct
shape_patterns	struct
;	O
shape_patterns	struct
.	O
initialized	int
=	O
0	int
;	O
result_certain	int
=	O
1	int
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_THREATEN_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
attack1	pointer
,	O
attack2	pointer
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
TRACE	O
(	O
"owl_threaten_attack %1m\n"	pointer
,	O
target	int
)	O
;	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
memcpy	function
(	O
saved_boundary	array
,	O
owl	int
->	O
boundary	array
,	O
sizeof	O
(	O
saved_boundary	array
)	O
)	O
;	O
owl_make_domains	function
(	O
owl	int
,	O
NULL	O
)	O
;	O
owl_shapes	function
(	O
&	O
shape_patterns	struct
,	O
moves	array
,	O
other	int
,	O
owl	int
,	O
&	O
owl_attackpat_db	struct
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
current_owl_data	pointer
=	O
owl	int
;	O
if	O
(	O
!	O
get_next_move_from_list	function
(	O
&	O
shape_patterns	struct
,	O
other	int
,	O
moves	array
,	O
1	int
,	O
owl	int
)	O
)	O
break	O
;	O
else	O
{	O
int	O
mpos	int
=	O
moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
if	O
(	O
mpos	int
!=	O
NO_MOVE	O
&&	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
>	O
0	int
)	O
if	O
(	O
trymove	function
(	O
mpos	int
,	O
other	int
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
,	O
target	int
)	O
)	O
{	O
int	O
pos	int
;	O
int	O
origin	int
=	O
NO_MOVE	O
;	O
owl	int
->	O
lunches_are_current	int
=	O
0	int
;	O
owl_update_boundary_marks	function
(	O
mpos	int
,	O
owl	int
)	O
;	O
if	O
(	O
board	pointer
[	O
target	int
]	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
origin	int
=	O
find_origin	function
(	O
pos	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
origin	int
==	O
NO_MOVE	O
||	O
do_owl_attack	function
(	O
origin	int
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
result	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
do_owl_attack	function
(	O
target	int
,	O
&	O
move2	pointer
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
==	O
WIN	int
)	O
{	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
popgo	function
(	O
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
result	int
=	O
1	int
;	O
break	O
;	O
}	O
popgo	function
(	O
)	O
;	O
memcpy	function
(	O
owl	int
->	O
boundary	array
,	O
saved_boundary	array
,	O
sizeof	O
(	O
saved_boundary	array
)	O
)	O
;	O
}	O
}	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_threaten_attack %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n"	pointer
,	O
target	int
,	O
move	pointer
,	O
move2	pointer
,	O
result	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_THREATEN_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	pointer
,	O
move2	pointer
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
attack1	pointer
)	O
*	O
attack1	pointer
=	O
move	pointer
;	O
if	O
(	O
attack2	pointer
)	O
*	O
attack2	pointer
=	O
move2	pointer
;	O
close_pattern_list	function
(	O
other	int
,	O
&	O
shape_patterns	struct
)	O
;	O
return	O
result	int
;	O
}	O
int	O
owl_defend	function
(	O
int	O
target	int
,	O
int	O
*	O
defense_point	pointer
,	O
int	O
*	O
certain	pointer
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
result	int
;	O
static	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
double	O
start	double
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	pointer
=	O
NO_MOVE	O
;	O
int	O
wpos	pointer
=	O
NO_MOVE	O
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
result_certain	int
=	O
1	int
;	O
if	O
(	O
worm	array
[	O
target	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_DEFEND	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
defense_point	pointer
,	O
kworm	int
,	O
certain	pointer
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
TRACE	O
(	O
"owl_defend %1m\n"	pointer
,	O
target	int
)	O
;	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
owl_make_domains	function
(	O
owl	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	function
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	array
,	O
&	O
goal_worms_computed	int
,	O
kworm	int
,	O
1	int
)	O
;	O
result	int
=	O
do_owl_defend	function
(	O
target	int
,	O
&	O
move	pointer
,	O
&	O
wid	int
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	function
(	O
&	O
goal_worms_computed	int
,	O
&	O
wpos	pointer
,	O
owl_goal_worm	array
,	O
wid	int
)	O
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_defend %1m, result %d %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
target	int
,	O
result	int
,	O
move	pointer
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_DEFEND	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	pointer
,	O
wpos	pointer
,	O
result_certain	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
move	pointer
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	pointer
;	O
if	O
(	O
certain	pointer
)	O
*	O
certain	pointer
=	O
result_certain	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
do_owl_defend	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
wormid	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
escape	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
struct	O
owl_move_data	struct
shape_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
vital_moves	array
[	O
MAX_MOVES	int
]	O
;	O
struct	O
owl_move_data	struct
*	O
moves	array
;	O
struct	O
matched_patterns_list_data	struct
shape_patterns	struct
;	O
signed	O
char	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
int	O
number_tried_moves	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
k	int
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
saveworm	int
=	O
MAX_GOAL_WORMS	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
eyemin	pointer
=	O
-	O
1	int
;	O
int	O
eyemax	pointer
=	O
-	O
1	int
;	O
struct	O
eyevalue	struct
probable_eyes	pointer
;	O
int	O
escape_route	float
;	O
const	O
char	O
*	O
live_reason	pointer
;	O
int	O
move_cutoff	int
;	O
int	O
xpos	int
;	O
int	O
value1	pointer
;	O
int	O
value2	pointer
;	O
int	O
this_variation_number	int
=	O
count_variations	int
-	O
1	int
;	O
SETUP_TRACE_INFO	O
(	O
"owl_defend"	pointer
,	O
str	int
)	O
;	O
shape_patterns	struct
.	O
initialized	int
=	O
0	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
tt_get	function
(	O
&	O
ttable	struct
,	O
OWL_DEFEND	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value1	pointer
,	O
&	O
value2	pointer
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
value1	pointer
,	O
xpos	int
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
if	O
(	O
value1	pointer
==	O
LOSS	int
)	O
{	O
if	O
(	O
wormid	pointer
)	O
{	O
if	O
(	O
goal_worms_computed	int
)	O
*	O
wormid	pointer
=	O
value2	pointer
;	O
else	O
*	O
wormid	pointer
=	O
MAX_GOAL_WORMS	int
;	O
}	O
}	O
if	O
(	O
value1	pointer
==	O
WIN	int
||	O
value1	pointer
==	O
LOSS	int
)	O
TRACE	O
(	O
"%oVariation %d: ALIVE (cached)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
else	O
TRACE	O
(	O
"%oVariation %d: DEAD (cached)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
value1	pointer
,	O
"cached"	pointer
)	O
;	O
return	O
value1	pointer
;	O
}	O
escape_route	float
=	O
owl_escape_route	function
(	O
owl	int
)	O
;	O
if	O
(	O
stackp	int
>	O
2	int
&&	O
escape_route	float
>=	O
5	int
)	O
{	O
TRACE	O
(	O
"%oVariation %d: ALIVE (escaped)\n"	pointer
,	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
"escaped"	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
reading_limit_reached	function
(	O
&	O
live_reason	pointer
,	O
this_variation_number	int
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
live_reason	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
WIN	int
)	O
;	O
}	O
memset	function
(	O
mw	array
,	O
0	int
,	O
sizeof	O
(	O
mw	array
)	O
)	O
;	O
local_owl_node_counter	int
++	O
;	O
global_owl_node_counter	int
++	O
;	O
current_owl_data	pointer
=	O
owl	int
;	O
memset	function
(	O
owl	int
->	O
safe_move_cache	array
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	array
)	O
)	O
;	O
if	O
(	O
escape	int
<	O
MAX_ESCAPE	int
)	O
{	O
if	O
(	O
owl_estimate_life	function
(	O
owl	int
,	O
NULL	O
,	O
vital_moves	array
,	O
&	O
live_reason	pointer
,	O
0	int
,	O
&	O
probable_eyes	pointer
,	O
&	O
eyemin	pointer
,	O
&	O
eyemax	pointer
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
live_reason	pointer
)	O
;	O
TRACE	O
(	O
"%oVariation %d: ALIVE (%s)\n"	pointer
,	O
this_variation_number	int
,	O
live_reason	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
WIN	int
)	O
;	O
}	O
}	O
else	O
{	O
memcpy	function
(	O
owl	int
->	O
my_eye	array
,	O
owl	int
->	O
restore_from	pointer
->	O
my_eye	array
,	O
sizeof	O
(	O
owl	int
->	O
my_eye	array
)	O
)	O
;	O
memcpy	function
(	O
owl	int
->	O
half_eye	array
,	O
owl	int
->	O
restore_from	pointer
->	O
half_eye	array
,	O
sizeof	O
(	O
owl	int
->	O
half_eye	array
)	O
)	O
;	O
vital_moves	array
[	O
0	int
]	O
.	O
pos	int
=	O
0	int
;	O
vital_moves	array
[	O
0	int
]	O
.	O
value	pointer
=	O
-	O
1	int
;	O
set_eyevalue	function
(	O
&	O
probable_eyes	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
4	int
;	O
pass	int
++	O
)	O
{	O
moves	array
=	O
NULL	O
;	O
move_cutoff	int
=	O
1	int
;	O
current_owl_data	pointer
=	O
owl	int
;	O
switch	O
(	O
pass	int
)	O
{	O
case	O
1	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	int
>	O
0	int
)	O
continue	O
;	O
owl_shapes	function
(	O
&	O
shape_patterns	struct
,	O
shape_moves	array
,	O
color	int
,	O
owl	int
,	O
&	O
owl_defendpat_db	struct
)	O
;	O
moves	array
=	O
shape_moves	array
;	O
break	O
;	O
case	O
0	int
:	O
case	O
2	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	int
>	O
0	int
)	O
continue	O
;	O
moves	array
=	O
vital_moves	array
;	O
if	O
(	O
pass	int
==	O
0	int
||	O
stackp	int
>	O
owl_distrust_depth	int
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
move_cutoff	int
=	O
70	int
;	O
else	O
if	O
(	O
eyemin	pointer
+	O
min_eyes	function
(	O
&	O
probable_eyes	pointer
)	O
>	O
3	int
)	O
move_cutoff	int
=	O
25	int
;	O
else	O
if	O
(	O
eyemin	pointer
+	O
min_eyes	function
(	O
&	O
probable_eyes	pointer
)	O
>=	O
3	int
)	O
move_cutoff	int
=	O
35	int
;	O
else	O
move_cutoff	int
=	O
45	int
;	O
}	O
if	O
(	O
eyemax	pointer
<	O
2	int
&&	O
stackp	int
>	O
2	int
)	O
move_cutoff	int
=	O
99	int
;	O
break	O
;	O
case	O
3	int
:	O
{	O
int	O
goalcount	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
BOARDMIN	O
;	O
k	int
<	O
BOARDMAX	O
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
k	int
)	O
)	O
goalcount	int
+=	O
owl	int
->	O
goal	pointer
[	O
k	int
]	O
;	O
if	O
(	O
goalcount	int
<	O
5	int
)	O
{	O
int	O
dpos	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
attack_and_defend	function
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dpos	int
)	O
&&	O
(	O
approxlib	function
(	O
dpos	int
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
||	O
does_capture_something	function
(	O
dpos	int
,	O
color	int
)	O
)	O
)	O
{	O
TRACE	O
(	O
"Found tactical defense for %1m at %1m.\n"	pointer
,	O
str	int
,	O
dpos	int
)	O
;	O
set_single_owl_move	function
(	O
shape_moves	array
,	O
dpos	int
,	O
"tactical_defense"	pointer
)	O
;	O
moves	array
=	O
shape_moves	array
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
if	O
(	O
!	O
moves	array
)	O
continue	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
int	O
mpos	int
;	O
int	O
ko_move	int
=	O
-	O
1	int
;	O
int	O
new_escape	int
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
k	int
>	O
0	int
)	O
break	O
;	O
current_owl_data	pointer
=	O
owl	int
;	O
if	O
(	O
pass	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
get_next_move_from_list	function
(	O
&	O
shape_patterns	struct
,	O
color	int
,	O
shape_moves	array
,	O
move_cutoff	int
,	O
owl	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
<	O
move_cutoff	int
)	O
break	O
;	O
mpos	int
=	O
moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
modify_eyefilling_move	function
(	O
&	O
mpos	int
,	O
color	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
mpos	int
)	O
;	O
if	O
(	O
mw	array
[	O
mpos	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
komaster_trymove	function
(	O
mpos	int
,	O
color	int
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
,	O
str	int
,	O
&	O
ko_move	int
,	O
savecode	int
==	O
0	int
)	O
)	O
continue	O
;	O
new_escape	int
=	O
escape	int
;	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
escape	int
)	O
new_escape	int
++	O
;	O
TRACE	O
(	O
"Trying %C %1m. Escape = %d. Current stack: "	pointer
,	O
color	int
,	O
mpos	int
,	O
escape	int
)	O
;	O
if	O
(	O
verbose	int
)	O
dump_stack	function
(	O
)	O
;	O
push_owl	function
(	O
&	O
owl	int
)	O
;	O
mw	array
[	O
mpos	int
]	O
=	O
1	int
;	O
number_tried_moves	int
++	O
;	O
owl_update_goal	function
(	O
mpos	int
,	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
,	O
moves	array
[	O
k	int
]	O
.	O
lunch	int
,	O
owl	int
,	O
0	int
,	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
)	O
;	O
mark_goal_in_sgf	function
(	O
owl	int
->	O
goal	pointer
)	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
acode	int
=	O
do_owl_attack	function
(	O
str	int
,	O
NULL	O
,	O
&	O
wid	int
,	O
owl	int
,	O
new_escape	int
)	O
;	O
if	O
(	O
!	O
acode	int
)	O
{	O
pop_owl	function
(	O
&	O
owl	int
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
winstr	array
[	O
192	int
]	O
;	O
sprintf	function
(	O
winstr	array
,	O
"defense effective)\n  (%d variations"	pointer
,	O
count_variations	int
-	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
mpos	int
,	O
WIN	int
,	O
winstr	array
)	O
;	O
}	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_patterns	struct
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
mpos	int
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
acode	int
==	O
GAIN	int
)	O
saveworm	int
=	O
wid	int
;	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
mpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_owl_attack	function
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
new_escape	int
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
mpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
}	O
pop_owl	function
(	O
&	O
owl	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_patterns	struct
)	O
;	O
if	O
(	O
savecode	int
)	O
{	O
if	O
(	O
savecode	int
==	O
LOSS	int
)	O
{	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"defense effective (loss) - B"	pointer
)	O
;	O
if	O
(	O
wormid	pointer
)	O
*	O
wormid	pointer
=	O
saveworm	int
;	O
READ_RETURN2	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
,	O
saveworm	int
)	O
;	O
}	O
else	O
{	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"defense effective (ko) - B"	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
)	O
;	O
}	O
}	O
if	O
(	O
number_tried_moves	int
==	O
0	int
&&	O
min_eyes	function
(	O
&	O
probable_eyes	pointer
)	O
>=	O
2	int
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
"genus probably >= 2"	pointer
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
0	int
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
winstr	array
[	O
196	int
]	O
;	O
int	O
print_genus	int
=	O
eyemin	pointer
==	O
1	int
?	O
1	int
:	O
0	int
;	O
sprintf	function
(	O
winstr	array
,	O
"defense failed - genus %d)\n  (%d variations"	pointer
,	O
print_genus	int
,	O
count_variations	int
-	O
this_variation_number	int
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
winstr	array
)	O
;	O
}	O
READ_RETURN0	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
int	O
owl_threaten_defense	function
(	O
int	O
target	int
,	O
int	O
*	O
defend1	pointer
,	O
int	O
*	O
defend2	pointer
)	O
{	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
k	int
;	O
int	O
color	int
=	O
board	pointer
[	O
target	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
signed	O
char	O
saved_goal	array
[	O
BOARDMAX	O
]	O
;	O
double	O
start	double
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	pointer
=	O
0	int
;	O
int	O
move2	pointer
=	O
0	int
;	O
struct	O
matched_patterns_list_data	struct
shape_patterns	struct
;	O
shape_patterns	struct
.	O
initialized	int
=	O
0	int
;	O
result_certain	int
=	O
1	int
;	O
if	O
(	O
worm	array
[	O
target	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_THREATEN_DEFENSE	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
defend1	pointer
,	O
defend2	pointer
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
TRACE	O
(	O
"owl_threaten_defense %1m\n"	pointer
,	O
target	int
)	O
;	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
memcpy	function
(	O
saved_goal	array
,	O
owl	int
->	O
goal	pointer
,	O
sizeof	O
(	O
saved_goal	array
)	O
)	O
;	O
owl_make_domains	function
(	O
owl	int
,	O
NULL	O
)	O
;	O
owl_shapes	function
(	O
&	O
shape_patterns	struct
,	O
moves	array
,	O
color	int
,	O
owl	int
,	O
&	O
owl_defendpat_db	struct
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
current_owl_data	pointer
=	O
owl	int
;	O
if	O
(	O
!	O
get_next_move_from_list	function
(	O
&	O
shape_patterns	struct
,	O
color	int
,	O
moves	array
,	O
1	int
,	O
owl	int
)	O
)	O
break	O
;	O
else	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
!=	O
NO_MOVE	O
&&	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
>	O
0	int
)	O
if	O
(	O
trymove	function
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
,	O
color	int
,	O
moves	array
[	O
k	int
]	O
.	O
name	short
,	O
target	int
)	O
)	O
{	O
owl	int
->	O
lunches_are_current	int
=	O
0	int
;	O
owl_update_goal	function
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
,	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
,	O
moves	array
[	O
k	int
]	O
.	O
lunch	int
,	O
owl	int
,	O
0	int
,	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
)	O
;	O
if	O
(	O
do_owl_defend	function
(	O
target	int
,	O
&	O
move2	pointer
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
==	O
WIN	int
)	O
{	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
.	O
pos	int
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
move2	pointer
!=	O
NO_MOVE	O
&&	O
IS_STONE	O
(	O
board	pointer
[	O
move2	pointer
]	O
)	O
)	O
move2	pointer
=	O
NO_MOVE	O
;	O
result	int
=	O
WIN	int
;	O
break	O
;	O
}	O
else	O
popgo	function
(	O
)	O
;	O
memcpy	function
(	O
owl	int
->	O
goal	pointer
,	O
saved_goal	array
,	O
sizeof	O
(	O
saved_goal	array
)	O
)	O
;	O
}	O
}	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_threaten_defense %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n"	pointer
,	O
target	int
,	O
move	pointer
,	O
move2	pointer
,	O
result	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_THREATEN_DEFENSE	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	pointer
,	O
move2	pointer
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
defend1	pointer
)	O
*	O
defend1	pointer
=	O
move	pointer
;	O
if	O
(	O
defend2	pointer
)	O
*	O
defend2	pointer
=	O
move2	pointer
;	O
close_pattern_list	function
(	O
color	int
,	O
&	O
shape_patterns	struct
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
owl_estimate_life	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
struct	O
local_owl_data	struct
*	O
second_owl	pointer
,	O
struct	O
owl_move_data	struct
vital_moves	array
[	O
MAX_MOVES	int
]	O
,	O
const	O
char	O
*	O
*	O
live_reason	pointer
,	O
int	O
does_attack	function
,	O
struct	O
eyevalue	struct
*	O
probable_eyes	pointer
,	O
int	O
*	O
eyemin	pointer
,	O
int	O
*	O
eyemax	pointer
)	O
{	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
struct	O
owl_move_data	struct
dummy_moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
owl_determine_life	function
(	O
owl	int
,	O
second_owl	pointer
,	O
does_attack	function
,	O
vital_moves	array
,	O
probable_eyes	pointer
,	O
eyemin	pointer
,	O
eyemax	pointer
)	O
;	O
matches_found	int
=	O
0	int
;	O
memset	function
(	O
found_matches	array
,	O
0	int
,	O
sizeof	O
(	O
found_matches	array
)	O
)	O
;	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
)	O
{	O
memset	function
(	O
owl	int
->	O
safe_move_cache	array
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	array
)	O
)	O
;	O
if	O
(	O
!	O
does_attack	function
)	O
{	O
clear_owl_move_data	function
(	O
dummy_moves	array
)	O
;	O
matchpat	function
(	O
owl_shapes_callback	function
,	O
other	int
,	O
&	O
owl_vital_apat_db	struct
,	O
dummy_moves	array
,	O
owl	int
->	O
goal	pointer
)	O
;	O
}	O
else	O
if	O
(	O
max_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
2	int
)	O
matchpat	function
(	O
owl_shapes_callback	function
,	O
other	int
,	O
&	O
owl_vital_apat_db	struct
,	O
vital_moves	array
,	O
owl	int
->	O
goal	pointer
)	O
;	O
}	O
if	O
(	O
(	O
debug	int
&	O
DEBUG_EYES	int
)	O
&&	O
(	O
debug	int
&	O
DEBUG_OWL	int
)	O
)	O
gprintf	function
(	O
"owl: eyemin=%d matches_found=%d\n"	pointer
,	O
*	O
eyemin	pointer
,	O
matches_found	int
)	O
;	O
if	O
(	O
*	O
eyemin	pointer
>=	O
matches_found	int
)	O
*	O
eyemin	pointer
-=	O
matches_found	int
;	O
else	O
*	O
eyemin	pointer
=	O
0	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
*	O
eyemin	pointer
>=	O
2	int
||	O
(	O
*	O
eyemin	pointer
==	O
1	int
&&	O
min_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
4	int
)	O
||	O
(	O
stackp	int
>	O
owl_distrust_depth	int
&&	O
min_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
2	int
&&	O
!	O
matches_found	int
)	O
)	O
{	O
if	O
(	O
*	O
eyemin	pointer
>=	O
2	int
)	O
*	O
live_reason	pointer
=	O
"2 or more secure eyes"	pointer
;	O
else	O
if	O
(	O
*	O
eyemin	pointer
==	O
1	int
&&	O
min_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
4	int
)	O
*	O
live_reason	pointer
=	O
"1 secure eye, likely >= 4"	pointer
;	O
else	O
if	O
(	O
stackp	int
>	O
owl_distrust_depth	int
&&	O
min_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
2	int
&&	O
!	O
matches_found	int
)	O
*	O
live_reason	pointer
=	O
"getting deep, looks lively"	pointer
;	O
else	O
gg_assert	O
(	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
does_attack	function
&&	O
(	O
*	O
eyemin	pointer
+	O
matches_found	int
>=	O
2	int
||	O
(	O
*	O
eyemin	pointer
+	O
matches_found	int
==	O
1	int
&&	O
min_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
4	int
)	O
||	O
(	O
stackp	int
>	O
owl_distrust_depth	int
&&	O
min_eyes	function
(	O
probable_eyes	pointer
)	O
>=	O
2	int
)	O
)	O
)	O
{	O
owl_add_move	function
(	O
vital_moves	array
,	O
dummy_moves	array
[	O
0	int
]	O
.	O
defense_pos	int
,	O
dummy_moves	array
[	O
0	int
]	O
.	O
value	pointer
,	O
dummy_moves	array
[	O
0	int
]	O
.	O
name	short
,	O
SAME_DRAGON_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
owl_determine_life	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
struct	O
local_owl_data	struct
*	O
second_owl	pointer
,	O
int	O
does_attack	function
,	O
struct	O
owl_move_data	struct
*	O
moves	array
,	O
struct	O
eyevalue	struct
*	O
probable_eyes	pointer
,	O
int	O
*	O
eyemin	pointer
,	O
int	O
*	O
eyemax	pointer
)	O
{	O
int	O
color	int
=	O
owl	int
->	O
color	int
;	O
struct	O
eye_data	struct
*	O
eye	array
=	O
owl	int
->	O
my_eye	array
;	O
int	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
int	O
mz	array
[	O
BOARDMAX	O
]	O
;	O
int	O
vital_values	array
[	O
BOARDMAX	O
]	O
;	O
int	O
dummy_eyemin	int
=	O
0	int
;	O
int	O
dummy_eyemax	int
=	O
0	int
;	O
struct	O
eyevalue	struct
eyevalue	struct
;	O
struct	O
eyevalue	struct
eyevalue_list	array
[	O
BOARDMAX	O
/	O
2	int
]	O
;	O
int	O
eyes_attack_points	array
[	O
BOARDMAX	O
/	O
2	int
]	O
;	O
int	O
pessimistic_min	pointer
;	O
int	O
attack_point	pointer
;	O
int	O
defense_point	pointer
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
lunch	int
;	O
int	O
num_eyes	int
=	O
0	int
;	O
int	O
num_lunches	int
=	O
0	int
;	O
int	O
save_debug	int
=	O
debug	int
;	O
memset	function
(	O
vital_values	array
,	O
0	int
,	O
sizeof	O
(	O
vital_values	array
)	O
)	O
;	O
if	O
(	O
!	O
eyemin	pointer
)	O
eyemin	pointer
=	O
&	O
dummy_eyemin	int
;	O
if	O
(	O
!	O
eyemax	pointer
)	O
eyemax	pointer
=	O
&	O
dummy_eyemax	int
;	O
*	O
eyemin	pointer
=	O
0	int
;	O
*	O
eyemax	pointer
=	O
0	int
;	O
if	O
(	O
!	O
(	O
debug	int
&	O
DEBUG_OWL	int
)	O
)	O
debug	int
&=	O
~	O
DEBUG_EYES	int
;	O
clear_owl_move_data	function
(	O
moves	array
)	O
;	O
if	O
(	O
!	O
owl	int
->	O
lunches_are_current	int
)	O
owl_find_lunches	function
(	O
owl	int
)	O
;	O
if	O
(	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	int
;	O
k	int
++	O
)	O
if	O
(	O
owl	int
->	O
lunch	int
[	O
k	int
]	O
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"owl lunch %1m, attack %1m, defend %1m\n"	pointer
,	O
owl	int
->	O
lunch	int
[	O
k	int
]	O
,	O
owl	int
->	O
lunch_attack_point	array
[	O
k	int
]	O
,	O
owl	int
->	O
lunch_defense_point	array
[	O
k	int
]	O
)	O
;	O
}	O
owl_make_domains	function
(	O
owl	int
,	O
second_owl	pointer
)	O
;	O
owl_find_relevant_eyespaces	function
(	O
owl	int
,	O
mw	array
,	O
mz	array
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
owl	int
->	O
half_eye	array
[	O
pos	int
]	O
.	O
type	char
=	O
0	int
;	O
owl	int
->	O
half_eye	array
[	O
pos	int
]	O
.	O
value	pointer
=	O
10.0	int
;	O
}	O
}	O
find_half_and_false_eyes	function
(	O
color	int
,	O
eye	array
,	O
owl	int
->	O
half_eye	array
,	O
mw	array
)	O
;	O
partition_eyespaces	function
(	O
owl	int
->	O
my_eye	array
,	O
owl	int
->	O
color	int
)	O
;	O
owl_find_relevant_eyespaces	function
(	O
owl	int
,	O
mw	array
,	O
mz	array
)	O
;	O
set_eyevalue	function
(	O
probable_eyes	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
mw	array
[	O
pos	int
]	O
>	O
1	int
)	O
{	O
int	O
value	pointer
=	O
0	int
;	O
const	O
char	O
*	O
reason	pointer
=	O
""	pointer
;	O
compute_eyes_pessimistic	function
(	O
pos	int
,	O
&	O
eyevalue	struct
,	O
&	O
pessimistic_min	pointer
,	O
&	O
attack_point	pointer
,	O
&	O
defense_point	pointer
,	O
eye	array
,	O
owl	int
->	O
half_eye	array
)	O
;	O
if	O
(	O
mw	array
[	O
pos	int
]	O
<	O
mz	array
[	O
pos	int
]	O
||	O
(	O
mw	array
[	O
pos	int
]	O
<	O
3	int
*	O
mz	array
[	O
pos	int
]	O
&&	O
mz	array
[	O
pos	int
]	O
>	O
5	int
)	O
)	O
pessimistic_min	pointer
=	O
0	int
;	O
eyes_attack_points	array
[	O
num_eyes	int
]	O
=	O
NO_MOVE	O
;	O
eyevalue_list	array
[	O
num_eyes	int
]	O
=	O
eyevalue	struct
;	O
*	O
eyemin	pointer
+=	O
pessimistic_min	pointer
;	O
eye	array
[	O
pos	int
]	O
.	O
value	pointer
=	O
eyevalue	struct
;	O
if	O
(	O
eye_move_urgency	function
(	O
&	O
eyevalue	struct
)	O
)	O
{	O
value	pointer
=	O
50	int
;	O
if	O
(	O
max_eyes	function
(	O
&	O
eyevalue	struct
)	O
-	O
min_eyes	function
(	O
&	O
eyevalue	struct
)	O
==	O
2	int
)	O
value	pointer
=	O
70	int
;	O
else	O
if	O
(	O
max_eyes	function
(	O
&	O
eyevalue	struct
)	O
-	O
pessimistic_min	pointer
==	O
2	int
)	O
value	pointer
=	O
60	int
;	O
reason	pointer
=	O
"vital move"	pointer
;	O
}	O
else	O
if	O
(	O
max_eyes	function
(	O
&	O
eyevalue	struct
)	O
!=	O
pessimistic_min	pointer
)	O
{	O
if	O
(	O
max_eyes	function
(	O
&	O
eyevalue	struct
)	O
-	O
pessimistic_min	pointer
==	O
2	int
)	O
value	pointer
=	O
40	int
;	O
else	O
value	pointer
=	O
30	int
;	O
reason	pointer
=	O
"marginal eye space"	pointer
;	O
}	O
if	O
(	O
value	pointer
>	O
0	int
)	O
{	O
if	O
(	O
does_attack	function
&&	O
attack_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
vital_values	array
[	O
attack_point	pointer
]	O
>	O
0	int
)	O
{	O
value	pointer
+=	O
vital_values	array
[	O
attack_point	pointer
]	O
;	O
if	O
(	O
value	pointer
>	O
98	int
)	O
value	pointer
=	O
98	int
;	O
}	O
TRACE	O
(	O
"%s at %1m, score %d (eye at %1m, value %s, pessimistic_min %d)\n"	pointer
,	O
reason	pointer
,	O
attack_point	pointer
,	O
value	pointer
,	O
pos	int
,	O
eyevalue_to_string	function
(	O
&	O
eyevalue	struct
)	O
,	O
pessimistic_min	pointer
)	O
;	O
if	O
(	O
eye	array
[	O
attack_point	pointer
]	O
.	O
marginal	char
&&	O
modify_stupid_eye_vital_point	function
(	O
owl	int
,	O
&	O
attack_point	pointer
,	O
1	int
)	O
)	O
TRACE	O
(	O
"vital point looked stupid, moved it to %1m\n"	pointer
,	O
attack_point	pointer
)	O
;	O
if	O
(	O
attack_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
owl_add_move	function
(	O
moves	array
,	O
attack_point	pointer
,	O
value	pointer
,	O
reason	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
vital_values	array
[	O
attack_point	pointer
]	O
=	O
value	pointer
;	O
eyes_attack_points	array
[	O
num_eyes	int
]	O
=	O
attack_point	pointer
;	O
}	O
}	O
else	O
if	O
(	O
!	O
does_attack	function
&&	O
defense_point	pointer
!=	O
NO_MOVE	O
&&	O
board	pointer
[	O
defense_point	pointer
]	O
==	O
EMPTY	int
&&	O
(	O
!	O
liberty_of_goal	function
(	O
defense_point	pointer
,	O
owl	int
)	O
||	O
!	O
is_self_atari	function
(	O
defense_point	pointer
,	O
color	int
)	O
||	O
is_ko	function
(	O
defense_point	pointer
,	O
color	int
,	O
NULL	O
)	O
||	O
safe_move	function
(	O
defense_point	pointer
,	O
color	int
)	O
!=	O
0	int
)	O
)	O
{	O
if	O
(	O
vital_values	array
[	O
defense_point	pointer
]	O
>	O
0	int
)	O
{	O
value	pointer
+=	O
vital_values	array
[	O
defense_point	pointer
]	O
;	O
if	O
(	O
value	pointer
>	O
98	int
)	O
value	pointer
=	O
98	int
;	O
}	O
TRACE	O
(	O
"%s at %1m, score %d (eye at %1m, value %s, pessimistic_min %d)\n"	pointer
,	O
reason	pointer
,	O
defense_point	pointer
,	O
value	pointer
,	O
pos	int
,	O
eyevalue_to_string	function
(	O
&	O
eyevalue	struct
)	O
,	O
pessimistic_min	pointer
)	O
;	O
if	O
(	O
(	O
eye	array
[	O
defense_point	pointer
]	O
.	O
marginal	char
||	O
eye	array
[	O
defense_point	pointer
]	O
.	O
origin	int
!=	O
pos	int
)	O
&&	O
modify_stupid_eye_vital_point	function
(	O
owl	int
,	O
&	O
defense_point	pointer
,	O
0	int
)	O
)	O
TRACE	O
(	O
"vital point looked stupid, moved it to %1m\n"	pointer
,	O
defense_point	pointer
)	O
;	O
if	O
(	O
defense_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
owl_add_move	function
(	O
moves	array
,	O
defense_point	pointer
,	O
value	pointer
,	O
reason	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
vital_values	array
[	O
defense_point	pointer
]	O
=	O
value	pointer
;	O
}	O
}	O
}	O
num_eyes	int
++	O
;	O
}	O
}	O
{	O
for	O
(	O
lunch	int
=	O
0	int
;	O
(	O
lunch	int
<	O
MAX_LUNCHES	int
)	O
;	O
lunch	int
++	O
)	O
if	O
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
!=	O
NO_MOVE	O
&&	O
owl	int
->	O
lunch_defense_point	array
[	O
lunch	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
value	pointer
=	O
0	int
;	O
int	O
lunch_min	int
;	O
int	O
lunch_probable	int
;	O
int	O
lunch_max	int
;	O
struct	O
eyevalue	struct
e	pointer
;	O
sniff_lunch	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
&	O
lunch_min	int
,	O
&	O
lunch_probable	int
,	O
&	O
lunch_max	int
,	O
owl	int
)	O
;	O
set_eyevalue	function
(	O
&	O
e	pointer
,	O
0	int
,	O
0	int
,	O
lunch_probable	int
,	O
lunch_probable	int
)	O
;	O
*	O
eyemax	pointer
+=	O
lunch_max	int
;	O
if	O
(	O
lunch_probable	int
==	O
0	int
)	O
{	O
if	O
(	O
countstones	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
==	O
1	int
)	O
continue	O
;	O
value	pointer
=	O
20	int
;	O
}	O
else	O
if	O
(	O
lunch_probable	int
==	O
1	int
&&	O
lunch_max	int
==	O
1	int
)	O
value	pointer
=	O
60	int
+	O
countstones	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
;	O
else	O
if	O
(	O
lunch_probable	int
==	O
1	int
&&	O
lunch_max	int
==	O
2	int
)	O
value	pointer
=	O
70	int
+	O
countstones	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
;	O
else	O
value	pointer
=	O
75	int
+	O
countstones	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
;	O
if	O
(	O
owl	int
->	O
lunch_attack_code	array
[	O
lunch	int
]	O
!=	O
WIN	int
)	O
value	pointer
-=	O
10	int
;	O
if	O
(	O
does_attack	function
)	O
{	O
defense_point	pointer
=	O
improve_lunch_defense	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
owl	int
->	O
lunch_defense_point	array
[	O
lunch	int
]	O
)	O
;	O
if	O
(	O
vital_values	array
[	O
defense_point	pointer
]	O
)	O
{	O
int	O
ne	int
;	O
for	O
(	O
ne	int
=	O
0	int
;	O
ne	int
<	O
num_eyes	int
-	O
num_lunches	int
;	O
ne	int
++	O
)	O
if	O
(	O
eyes_attack_points	array
[	O
ne	int
]	O
==	O
defense_point	pointer
)	O
break	O
;	O
gg_assert	O
(	O
ne	int
<	O
num_eyes	int
-	O
num_lunches	int
)	O
;	O
add_eyevalues	function
(	O
&	O
eyevalue_list	array
[	O
ne	int
]	O
,	O
&	O
e	pointer
,	O
&	O
eyevalue_list	array
[	O
ne	int
]	O
)	O
;	O
eyevalue_list	array
[	O
ne	int
]	O
.	O
a	char
=	O
0	int
;	O
eyevalue_list	array
[	O
ne	int
]	O
.	O
b	char
=	O
0	int
;	O
}	O
else	O
{	O
num_lunches	int
++	O
;	O
eyevalue_list	array
[	O
num_eyes	int
++	O
]	O
=	O
e	pointer
;	O
}	O
TRACE	O
(	O
"save lunch at %1m with %1m, score %d, probable eye %d, max eye %d\n"	pointer
,	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
defense_point	pointer
,	O
value	pointer
,	O
lunch_probable	int
,	O
lunch_max	int
)	O
;	O
owl_add_move	function
(	O
moves	array
,	O
defense_point	pointer
,	O
value	pointer
,	O
"save lunch"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
attack_point	pointer
=	O
improve_lunch_attack	function
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
owl	int
->	O
lunch_attack_point	array
[	O
lunch	int
]	O
)	O
;	O
TRACE	O
(	O
"eat lunch at %1m with %1m, score %d, probable eye %d, max eye %d\n"	pointer
,	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
attack_point	pointer
,	O
value	pointer
,	O
lunch_probable	int
,	O
lunch_max	int
)	O
;	O
if	O
(	O
owl	int
->	O
lunch_attack_code	array
[	O
lunch	int
]	O
==	O
WIN	int
||	O
is_illegal_ko_capture	function
(	O
attack_point	pointer
,	O
owl	int
->	O
color	int
)	O
)	O
owl_add_move	function
(	O
moves	array
,	O
attack_point	pointer
,	O
value	pointer
,	O
"eat lunch"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
else	O
owl_add_move	function
(	O
moves	array
,	O
attack_point	pointer
,	O
value	pointer
,	O
"eat lunch"	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
num_lunches	int
++	O
;	O
eyevalue_list	array
[	O
num_eyes	int
++	O
]	O
=	O
e	pointer
;	O
}	O
}	O
}	O
{	O
int	O
ne	int
;	O
for	O
(	O
ne	int
=	O
0	int
;	O
ne	int
<	O
num_eyes	int
-	O
num_lunches	int
;	O
ne	int
++	O
)	O
add_eyevalues	function
(	O
probable_eyes	pointer
,	O
&	O
eyevalue_list	array
[	O
ne	int
]	O
,	O
probable_eyes	pointer
)	O
;	O
*	O
eyemax	pointer
+=	O
max_eyes	function
(	O
probable_eyes	pointer
)	O
;	O
if	O
(	O
num_eyes	int
-	O
num_lunches	int
>	O
1	int
&&	O
max_eye_threat	function
(	O
probable_eyes	pointer
)	O
>	O
1	int
)	O
*	O
eyemax	pointer
+=	O
1	int
;	O
for	O
(	O
;	O
ne	int
<	O
num_eyes	int
;	O
ne	int
++	O
)	O
add_eyevalues	function
(	O
probable_eyes	pointer
,	O
&	O
eyevalue_list	array
[	O
ne	int
]	O
,	O
probable_eyes	pointer
)	O
;	O
}	O
debug	int
=	O
save_debug	int
;	O
}	O
static	O
void	O
owl_find_relevant_eyespaces	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
mw	array
[	O
BOARDMAX	O
]	O
,	O
int	O
mz	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
eye_color	int
;	O
int	O
k	int
;	O
struct	O
eye_data	struct
*	O
eye	array
=	O
owl	int
->	O
my_eye	array
;	O
if	O
(	O
owl	int
->	O
color	int
==	O
WHITE	int
)	O
eye_color	int
=	O
WHITE	int
;	O
else	O
eye_color	int
=	O
BLACK	int
;	O
memset	function
(	O
mw	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
mw	array
[	O
0	int
]	O
)	O
)	O
;	O
memset	function
(	O
mz	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
mz	array
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
owl	int
->	O
color	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eye	array
[	O
pos2	int
]	O
.	O
color	int
==	O
eye_color	int
&&	O
!	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
)	O
{	O
if	O
(	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
)	O
mw	array
[	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
]	O
++	O
;	O
else	O
mz	array
[	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
]	O
++	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
int	O
modify_stupid_eye_vital_point	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
*	O
vital_point	pointer
,	O
int	O
is_attack_point	int
)	O
{	O
int	O
up	int
;	O
int	O
right	int
;	O
int	O
k	int
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
*	O
vital_point	pointer
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
*	O
vital_point	pointer
+	O
up	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
board	pointer
[	O
*	O
vital_point	pointer
+	O
right	int
]	O
!=	O
EMPTY	int
||	O
board	pointer
[	O
*	O
vital_point	pointer
-	O
right	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
*	O
vital_point	pointer
+	O
2	int
*	O
up	int
]	O
!=	O
EMPTY	int
||	O
board	pointer
[	O
*	O
vital_point	pointer
+	O
up	int
+	O
right	int
]	O
!=	O
EMPTY	int
||	O
board	pointer
[	O
*	O
vital_point	pointer
+	O
up	int
-	O
right	int
]	O
!=	O
EMPTY	int
)	O
{	O
*	O
vital_point	pointer
+=	O
up	int
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
is_attack_point	int
)	O
{	O
if	O
(	O
approxlib	function
(	O
*	O
vital_point	pointer
,	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
,	O
1	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
*	O
vital_point	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
&&	O
countlib	function
(	O
pos	int
)	O
==	O
1	int
)	O
{	O
findlib	function
(	O
pos	int
,	O
1	int
,	O
vital_point	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
is_attack_point	int
&&	O
does_capture_something	function
(	O
*	O
vital_point	pointer
,	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
)	O
&&	O
accuratelib	function
(	O
*	O
vital_point	pointer
,	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
,	O
2	int
,	O
libs	pointer
)	O
==	O
1	int
&&	O
!	O
attack	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
NULL	O
)	O
)	O
{	O
*	O
vital_point	pointer
=	O
NO_MOVE	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
modify_eyefilling_move	function
(	O
int	O
*	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
*	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
board	pointer
[	O
*	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
]	O
!=	O
color	int
)	O
return	O
0	int
;	O
for	O
(	O
r	int
=	O
4	int
;	O
r	int
<	O
8	int
;	O
r	int
++	O
)	O
if	O
(	O
board	pointer
[	O
*	O
move	pointer
+	O
delta	array
[	O
r	int
]	O
]	O
==	O
other	int
&&	O
countlib	function
(	O
*	O
move	pointer
+	O
delta	array
[	O
r	int
]	O
)	O
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
*	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
countlib	function
(	O
*	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
)	O
==	O
1	int
&&	O
!	O
adjacent_strings	function
(	O
*	O
move	pointer
+	O
delta	array
[	O
r	int
]	O
,	O
*	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
4	int
)	O
{	O
int	O
new_move	int
;	O
findlib	function
(	O
*	O
move	pointer
+	O
delta	array
[	O
r	int
]	O
,	O
1	int
,	O
&	O
new_move	int
)	O
;	O
TRACE	O
(	O
"Changing eyefilling move at %1m to capture at %1m.\n"	pointer
,	O
*	O
move	pointer
,	O
new_move	int
)	O
;	O
*	O
move	pointer
=	O
new_move	int
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
owl_shapes	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
pattern_list	pointer
,	O
struct	O
owl_move_data	struct
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
color	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
struct	O
pattern_db	struct
*	O
type	char
)	O
{	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
current_owl_data	pointer
=	O
owl	int
;	O
clear_owl_move_data	function
(	O
moves	array
)	O
;	O
memset	function
(	O
owl	int
->	O
safe_move_cache	array
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	array
)	O
)	O
;	O
init_pattern_list	function
(	O
pattern_list	pointer
)	O
;	O
matchpat	function
(	O
collect_owl_shapes_callbacks	function
,	O
color	int
,	O
type	char
,	O
pattern_list	pointer
,	O
owl	int
->	O
goal	pointer
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
static	O
int	O
check_pattern_hard	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
)	O
{	O
int	O
constraint_checked	int
=	O
0	int
;	O
int	O
safe_move_checked	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_s	int
)	O
)	O
if	O
(	O
current_owl_data	pointer
->	O
safe_move_cache	array
[	O
move	pointer
]	O
)	O
{	O
if	O
(	O
current_owl_data	pointer
->	O
safe_move_cache	array
[	O
move	pointer
]	O
==	O
1	int
)	O
return	O
0	int
;	O
else	O
safe_move_checked	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
&&	O
pattern	pointer
->	O
constraint_cost	float
<	O
0.45	int
)	O
{	O
if	O
(	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
move	pointer
,	O
color	int
,	O
0	int
)	O
)	O
return	O
0	int
;	O
constraint_checked	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_s	int
)	O
&&	O
!	O
safe_move_checked	int
)	O
{	O
if	O
(	O
!	O
owl_safe_move	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  move at %1m wasn't safe, discarded\n"	pointer
,	O
move	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
is_legal	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  move at %1m wasn't legal, discarded\n"	pointer
,	O
move	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_n	int
)	O
{	O
if	O
(	O
safe_move	function
(	O
move	pointer
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  opponent can't play safely at %1m, move discarded\n"	pointer
,	O
move	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
&&	O
!	O
constraint_checked	int
)	O
if	O
(	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
move	pointer
,	O
color	int
,	O
0	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
init_pattern_list	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
gg_assert	O
(	O
!	O
list	pointer
->	O
initialized	int
)	O
;	O
list	pointer
->	O
counter	int
=	O
0	int
;	O
list	pointer
->	O
used	int
=	O
0	int
;	O
list	pointer
->	O
pattern_list	pointer
=	O
malloc	function
(	O
200	int
*	O
sizeof	O
(	O
list	pointer
->	O
pattern_list	pointer
[	O
0	int
]	O
)	O
)	O
;	O
list	pointer
->	O
list_size	int
=	O
200	int
;	O
gg_assert	O
(	O
list	pointer
->	O
pattern_list	pointer
!=	O
NULL	O
)	O
;	O
list	pointer
->	O
pattern_heap	pointer
=	O
NULL	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"List at %x has new array at %x\n"	pointer
,	O
list	pointer
,	O
list	pointer
->	O
pattern_list	pointer
)	O
;	O
list	pointer
->	O
initialized	int
=	O
1	int
;	O
}	O
static	O
void	O
close_pattern_list	function
(	O
int	O
color	int
,	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
list	pointer
->	O
initialized	int
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"%d patterns matched, %d patterns checked\n"	pointer
,	O
list	pointer
->	O
counter	int
,	O
list	pointer
->	O
used	int
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Pattern list at %x freed for list at %x\n"	pointer
,	O
list	pointer
->	O
pattern_list	pointer
,	O
list	pointer
)	O
;	O
if	O
(	O
allpats	int
&&	O
verbose	int
)	O
{	O
int	O
i	int
;	O
int	O
found_one	int
=	O
0	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
!	O
current_owl_data	pointer
->	O
lunches_are_current	int
)	O
owl_find_lunches	function
(	O
current_owl_data	pointer
)	O
;	O
if	O
(	O
!	O
list	pointer
->	O
pattern_heap	pointer
)	O
pattern_list_build_heap	function
(	O
list	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	pointer
->	O
heap_num_patterns	int
;	O
i	int
++	O
)	O
if	O
(	O
check_pattern_hard	function
(	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
->	O
move	pointer
,	O
color	int
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
->	O
pattern	pointer
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
->	O
ll	int
)	O
)	O
{	O
if	O
(	O
!	O
found_one	int
)	O
{	O
TRACE	O
(	O
"Remaining valid (but unused) patterns at stack: "	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
found_one	int
=	O
1	int
;	O
}	O
TRACE	O
(	O
"Pattern %s found at %1m with value %d\n"	pointer
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
->	O
pattern	pointer
->	O
name	short
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
->	O
move	pointer
,	O
(	O
int	O
)	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
->	O
pattern	pointer
->	O
value	pointer
)	O
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
free	function
(	O
list	pointer
->	O
pattern_list	pointer
)	O
;	O
free	function
(	O
list	pointer
->	O
pattern_heap	pointer
)	O
;	O
}	O
list	pointer
->	O
counter	int
=	O
-	O
1	int
;	O
}	O
void	O
dump_pattern_list	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
int	O
i	int
;	O
struct	O
matched_pattern_data	struct
*	O
matched_pattern	pointer
;	O
if	O
(	O
!	O
list	pointer
->	O
initialized	int
)	O
return	O
;	O
gprintf	function
(	O
"%oList size %d. %d Patterns in list, %d have been used."	pointer
,	O
list	pointer
->	O
list_size	int
,	O
list	pointer
->	O
counter	int
,	O
list	pointer
->	O
used	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	pointer
->	O
counter	int
;	O
i	int
++	O
)	O
{	O
matched_pattern	pointer
=	O
&	O
list	pointer
->	O
pattern_list	pointer
[	O
i	int
]	O
;	O
gprintf	function
(	O
"%o\n  Pattern %s (orient. %d) at %1m, value %f."	pointer
,	O
matched_pattern	pointer
->	O
pattern	pointer
->	O
name	short
,	O
matched_pattern	pointer
->	O
ll	int
,	O
matched_pattern	pointer
->	O
move	pointer
,	O
matched_pattern	pointer
->	O
pattern	pointer
->	O
value	pointer
)	O
;	O
if	O
(	O
matched_pattern	pointer
->	O
next_pattern_index	int
!=	O
-	O
1	int
)	O
gprintf	function
(	O
"%o * "	pointer
)	O
;	O
}	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
gprintf	function
(	O
"%oCurrent heap ordering: \n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	pointer
->	O
heap_num_patterns	int
;	O
i	int
++	O
)	O
{	O
matched_pattern	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
;	O
gprintf	function
(	O
"%o %s (%1m), %f; "	pointer
,	O
matched_pattern	pointer
->	O
pattern	pointer
->	O
name	short
,	O
matched_pattern	pointer
->	O
move	pointer
,	O
matched_pattern	pointer
->	O
pattern	pointer
->	O
value	pointer
)	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
collect_owl_shapes_callbacks	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
matched_patterns_list_data	struct
*	O
matched_patterns	pointer
=	O
data	pointer
;	O
struct	O
matched_pattern_data	struct
*	O
next_pattern	pointer
;	O
UNUSED	O
(	O
color	int
)	O
;	O
if	O
(	O
matched_patterns	pointer
->	O
counter	int
>=	O
matched_patterns	pointer
->	O
list_size	int
)	O
{	O
matched_patterns	pointer
->	O
list_size	int
+=	O
100	int
;	O
matched_patterns	pointer
->	O
pattern_list	pointer
=	O
realloc	function
(	O
matched_patterns	pointer
->	O
pattern_list	pointer
,	O
matched_patterns	pointer
->	O
list_size	int
*	O
sizeof	O
(	O
matched_patterns	pointer
->	O
pattern_list	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
next_pattern	pointer
=	O
&	O
matched_patterns	pointer
->	O
pattern_list	pointer
[	O
matched_patterns	pointer
->	O
counter	int
]	O
;	O
next_pattern	pointer
->	O
move	pointer
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
next_pattern	pointer
->	O
value	pointer
=	O
pattern	pointer
->	O
value	pointer
;	O
next_pattern	pointer
->	O
ll	int
=	O
ll	int
;	O
next_pattern	pointer
->	O
anchor	int
=	O
anchor	int
;	O
next_pattern	pointer
->	O
pattern	pointer
=	O
pattern	pointer
;	O
next_pattern	pointer
->	O
next_pattern_index	int
=	O
-	O
1	int
;	O
matched_patterns	pointer
->	O
counter	int
++	O
;	O
}	O
static	O
int	O
valuate_combinable_pattern_chain	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
,	O
int	O
pos	int
)	O
{	O
int	O
pattern_index	int
=	O
list	pointer
->	O
first_pattern_index	array
[	O
pos	int
]	O
;	O
int	O
num_capture_threats	int
=	O
0	int
;	O
int	O
capture_threats	array
[	O
MAX_STORED_REASONS	int
]	O
;	O
int	O
num_eye_threats	int
=	O
0	int
;	O
int	O
eye_threats	array
[	O
MAX_STORED_REASONS	int
]	O
;	O
int	O
num_reverse_sente	int
=	O
0	int
;	O
int	O
reverse_sente_against	array
[	O
MAX_STORED_REASONS	int
]	O
;	O
int	O
num_move_reasons	int
;	O
float	O
full_value	float
=	O
0.0	int
;	O
ASSERT1	O
(	O
pattern_index	int
!=	O
-	O
1	int
,	O
pos	int
)	O
;	O
do	O
{	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
=	O
(	O
list	pointer
->	O
pattern_list	pointer
+	O
pattern_index	int
)	O
;	O
struct	O
pattern_attribute	struct
*	O
attribute	pointer
;	O
if	O
(	O
pattern_data	pointer
->	O
pattern	pointer
)	O
{	O
for	O
(	O
attribute	pointer
=	O
pattern_data	pointer
->	O
pattern	pointer
->	O
attributes	pointer
;	O
attribute	pointer
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	pointer
++	O
)	O
{	O
int	O
k	int
;	O
int	O
target	int
=	O
AFFINE_TRANSFORM	O
(	O
attribute	pointer
->	O
offset	short
,	O
pattern_data	pointer
->	O
ll	int
,	O
pattern_data	pointer
->	O
move	pointer
)	O
;	O
switch	O
(	O
attribute	pointer
->	O
type	char
)	O
{	O
case	O
THREATENS_TO_CAPTURE	int
:	O
if	O
(	O
num_capture_threats	int
<	O
MAX_STORED_REASONS	int
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
target	int
]	O
)	O
,	O
target	int
)	O
;	O
target	int
=	O
find_origin	function
(	O
target	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_capture_threats	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
capture_threats	array
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_capture_threats	int
)	O
{	O
capture_threats	array
[	O
num_capture_threats	int
++	O
]	O
=	O
target	int
;	O
full_value	float
+=	O
pattern_data	pointer
->	O
pattern	pointer
->	O
value	pointer
;	O
}	O
}	O
break	O
;	O
case	O
THREATENS_EYE	int
:	O
if	O
(	O
num_eye_threats	int
<	O
MAX_STORED_REASONS	int
)	O
{	O
target	int
=	O
current_owl_data	pointer
->	O
my_eye	array
[	O
target	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_eye_threats	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
eye_threats	array
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_eye_threats	int
)	O
{	O
eye_threats	array
[	O
num_eye_threats	int
++	O
]	O
=	O
target	int
;	O
full_value	float
+=	O
pattern_data	pointer
->	O
pattern	pointer
->	O
value	pointer
;	O
}	O
}	O
break	O
;	O
case	O
REVERSE_SENTE	int
:	O
if	O
(	O
num_reverse_sente	int
<	O
MAX_STORED_REASONS	int
)	O
{	O
ASSERT1	O
(	O
board	pointer
[	O
target	int
]	O
==	O
EMPTY	int
,	O
target	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_reverse_sente	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
reverse_sente_against	array
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_reverse_sente	int
)	O
{	O
reverse_sente_against	array
[	O
num_reverse_sente	int
++	O
]	O
=	O
target	int
;	O
full_value	float
+=	O
pattern_data	pointer
->	O
pattern	pointer
->	O
value	pointer
;	O
}	O
}	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
pattern_index	int
=	O
pattern_data	pointer
->	O
next_pattern_index	int
;	O
}	O
while	O
(	O
pattern_index	int
>=	O
0	int
)	O
;	O
num_move_reasons	int
=	O
num_capture_threats	int
+	O
num_eye_threats	int
+	O
num_reverse_sente	int
;	O
if	O
(	O
num_move_reasons	int
<=	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
num_move_reasons	int
==	O
2	int
)	O
return	O
gg_min	O
(	O
gg_normalize_float2int	function
(	O
full_value	float
,	O
1.0	int
)	O
,	O
75	int
)	O
;	O
if	O
(	O
num_move_reasons	int
==	O
3	int
)	O
return	O
gg_min	O
(	O
gg_normalize_float2int	function
(	O
full_value	float
*	O
0.85	int
,	O
1.0	int
)	O
,	O
90	int
)	O
;	O
return	O
gg_min	O
(	O
gg_normalize_float2int	function
(	O
full_value	float
*	O
0.75	int
,	O
1.0	int
)	O
,	O
99	int
)	O
;	O
}	O
static	O
int	O
bdist	int
(	O
int	O
move	pointer
)	O
{	O
int	O
idist	int
=	O
2	int
*	O
I	O
(	O
move	pointer
)	O
-	O
board_size	int
+	O
1	int
;	O
int	O
jdist	int
=	O
2	int
*	O
J	O
(	O
move	pointer
)	O
-	O
board_size	int
+	O
1	int
;	O
return	O
idist	int
*	O
idist	int
+	O
jdist	int
*	O
jdist	int
;	O
}	O
static	O
void	O
pattern_list_prepare	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
list	pointer
->	O
heap_num_patterns	int
=	O
0	int
;	O
if	O
(	O
list	pointer
->	O
counter	int
>	O
0	int
)	O
{	O
list	pointer
->	O
pattern_heap	pointer
=	O
malloc	function
(	O
list	pointer
->	O
counter	int
*	O
sizeof	O
(	O
*	O
(	O
list	pointer
->	O
pattern_heap	pointer
)	O
)	O
)	O
;	O
gg_assert	O
(	O
list	pointer
->	O
pattern_heap	pointer
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
list	pointer
->	O
pattern_heap	pointer
=	O
NULL	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
list	pointer
->	O
first_pattern_index	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
list	pointer
->	O
counter	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
list	pointer
->	O
pattern_list	pointer
[	O
k	int
]	O
.	O
move	pointer
;	O
list	pointer
->	O
pattern_list	pointer
[	O
k	int
]	O
.	O
bdist	int
=	O
bdist	int
(	O
move	pointer
)	O
;	O
if	O
(	O
!	O
(	O
list	pointer
->	O
pattern_list	pointer
[	O
k	int
]	O
.	O
pattern	pointer
->	O
class	int
&	O
CLASS_c	int
)	O
)	O
list	pointer
->	O
pattern_heap	pointer
[	O
list	pointer
->	O
heap_num_patterns	int
++	O
]	O
=	O
&	O
list	pointer
->	O
pattern_list	pointer
[	O
k	int
]	O
;	O
else	O
{	O
list	pointer
->	O
pattern_list	pointer
[	O
k	int
]	O
.	O
next_pattern_index	int
=	O
list	pointer
->	O
first_pattern_index	array
[	O
move	pointer
]	O
;	O
list	pointer
->	O
first_pattern_index	array
[	O
move	pointer
]	O
=	O
k	int
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
list	pointer
->	O
first_pattern_index	array
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
{	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
=	O
&	O
list	pointer
->	O
pattern_list	pointer
[	O
list	pointer
->	O
first_pattern_index	array
[	O
pos	int
]	O
]	O
;	O
pattern_data	pointer
->	O
value	pointer
=	O
valuate_combinable_pattern_chain	function
(	O
list	pointer
,	O
pos	int
)	O
;	O
list	pointer
->	O
pattern_heap	pointer
[	O
list	pointer
->	O
heap_num_patterns	int
++	O
]	O
=	O
pattern_data	pointer
;	O
}	O
}	O
if	O
(	O
list	pointer
->	O
heap_num_patterns	int
>	O
0	int
)	O
pattern_list_build_heap	function
(	O
list	pointer
)	O
;	O
}	O
static	O
void	O
pattern_list_build_heap	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
int	O
k	int
;	O
int	O
limit	int
=	O
list	pointer
->	O
heap_num_patterns	int
/	O
2	int
;	O
for	O
(	O
k	int
=	O
limit	int
;	O
--	O
k	int
>=	O
0	int
;	O
)	O
{	O
int	O
parent	pointer
;	O
int	O
child	pointer
;	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
k	int
]	O
;	O
for	O
(	O
parent	pointer
=	O
k	int
;	O
parent	pointer
<	O
limit	int
;	O
parent	pointer
=	O
child	pointer
)	O
{	O
child	pointer
=	O
2	int
*	O
parent	pointer
+	O
1	int
;	O
if	O
(	O
child	pointer
+	O
1	int
<	O
list	pointer
->	O
heap_num_patterns	int
&&	O
BETTER_PATTERN	O
(	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
+	O
1	int
]	O
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
)	O
)	O
child	pointer
++	O
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
pattern_data	pointer
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
)	O
)	O
break	O
;	O
list	pointer
->	O
pattern_heap	pointer
[	O
parent	pointer
]	O
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
;	O
}	O
list	pointer
->	O
pattern_heap	pointer
[	O
parent	pointer
]	O
=	O
pattern_data	pointer
;	O
}	O
}	O
static	O
void	O
pattern_list_pop_heap_once	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
int	O
parent	pointer
;	O
int	O
child	pointer
;	O
list	pointer
->	O
heap_num_patterns	int
--	O
;	O
for	O
(	O
parent	pointer
=	O
0	int
;	O
2	int
*	O
parent	pointer
+	O
1	int
<	O
list	pointer
->	O
heap_num_patterns	int
;	O
parent	pointer
=	O
child	pointer
)	O
{	O
child	pointer
=	O
2	int
*	O
parent	pointer
+	O
1	int
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
+	O
1	int
]	O
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
)	O
)	O
child	pointer
++	O
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
list	pointer
->	O
pattern_heap	pointer
[	O
list	pointer
->	O
heap_num_patterns	int
]	O
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
)	O
)	O
break	O
;	O
list	pointer
->	O
pattern_heap	pointer
[	O
parent	pointer
]	O
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
;	O
}	O
list	pointer
->	O
pattern_heap	pointer
[	O
parent	pointer
]	O
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
list	pointer
->	O
heap_num_patterns	int
]	O
;	O
}	O
static	O
void	O
pattern_list_sink_heap_top_element	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
)	O
{	O
int	O
parent	pointer
;	O
int	O
child	pointer
;	O
struct	O
matched_pattern_data	struct
*	O
heap_top_element	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
;	O
for	O
(	O
parent	pointer
=	O
0	int
;	O
2	int
*	O
parent	pointer
+	O
1	int
<	O
list	pointer
->	O
heap_num_patterns	int
;	O
parent	pointer
=	O
child	pointer
)	O
{	O
child	pointer
=	O
2	int
*	O
parent	pointer
+	O
1	int
;	O
if	O
(	O
child	pointer
+	O
1	int
<	O
list	pointer
->	O
heap_num_patterns	int
&&	O
BETTER_PATTERN	O
(	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
+	O
1	int
]	O
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
)	O
)	O
child	pointer
++	O
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
heap_top_element	pointer
,	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
)	O
)	O
break	O
;	O
list	pointer
->	O
pattern_heap	pointer
[	O
parent	pointer
]	O
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
child	pointer
]	O
;	O
}	O
list	pointer
->	O
pattern_heap	pointer
[	O
parent	pointer
]	O
=	O
heap_top_element	pointer
;	O
}	O
static	O
void	O
generate_cut_list	function
(	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
int	O
anchor	int
,	O
int	O
cuts	array
[	O
MAX_CUTS	int
]	O
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
int	O
num	int
=	O
0	int
;	O
signed	O
char	O
mark	char
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
mark	char
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
continue	O
;	O
pos	int
=	O
find_origin	function
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
mark	char
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
owl	int
->	O
color	int
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
cuts	array
[	O
num	int
++	O
]	O
=	O
pos	int
;	O
mark	char
[	O
pos	int
]	O
=	O
1	int
;	O
if	O
(	O
num	int
==	O
MAX_CUTS	int
)	O
return	O
;	O
}	O
}	O
if	O
(	O
num	int
==	O
1	int
)	O
cuts	array
[	O
0	int
]	O
=	O
NO_MOVE	O
;	O
else	O
if	O
(	O
(	O
debug	int
&	O
DEBUG_SPLIT_OWL	int
)	O
&&	O
num	int
>	O
1	int
)	O
gprintf	function
(	O
"Move provokes %d cuts, among them %1m and %1m.\n"	pointer
,	O
num	int
,	O
cuts	array
[	O
0	int
]	O
,	O
cuts	array
[	O
1	int
]	O
)	O
;	O
}	O
static	O
int	O
get_next_move_from_list	function
(	O
struct	O
matched_patterns_list_data	struct
*	O
list	pointer
,	O
int	O
color	int
,	O
struct	O
owl_move_data	struct
*	O
moves	array
,	O
int	O
cutoff	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
move_found	int
=	O
0	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
!	O
list	pointer
->	O
pattern_heap	pointer
)	O
pattern_list_prepare	function
(	O
list	pointer
)	O
;	O
while	O
(	O
list	pointer
->	O
heap_num_patterns	int
>	O
0	int
)	O
{	O
int	O
k	int
;	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
;	O
struct	O
pattern	pointer
*	O
pattern	pointer
;	O
int	O
move	pointer
;	O
int	O
value	pointer
;	O
int	O
ll	int
;	O
int	O
anchor	int
;	O
int	O
next_pattern_index	int
;	O
if	O
(	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
value	pointer
<	O
cutoff	int
)	O
break	O
;	O
pattern_data	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
;	O
pattern	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
pattern	pointer
;	O
move	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
move	pointer
;	O
value	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
value	pointer
;	O
ll	int
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
ll	int
;	O
anchor	int
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
anchor	int
;	O
next_pattern_index	int
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
next_pattern_index	int
;	O
list	pointer
->	O
used	int
++	O
;	O
ASSERT_ON_BOARD1	O
(	O
move	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
==	O
move	pointer
||	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
<=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
==	O
move	pointer
)	O
{	O
pattern_list_pop_heap_once	function
(	O
list	pointer
)	O
;	O
continue	O
;	O
}	O
gg_assert	O
(	O
k	int
<	O
MAX_MOVES	int
)	O
;	O
if	O
(	O
pattern	pointer
==	O
NULL	O
||	O
check_pattern_hard	function
(	O
move	pointer
,	O
color	int
,	O
pattern	pointer
,	O
ll	int
)	O
)	O
{	O
if	O
(	O
next_pattern_index	int
==	O
-	O
1	int
)	O
{	O
pattern_list_pop_heap_once	function
(	O
list	pointer
)	O
;	O
}	O
else	O
{	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
=	O
list	pointer
->	O
pattern_list	pointer
+	O
next_pattern_index	int
;	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
value	pointer
=	O
value	pointer
;	O
continue	O
;	O
}	O
moves	array
[	O
k	int
]	O
.	O
pos	int
=	O
move	pointer
;	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
=	O
value	pointer
;	O
clear_cut_list	function
(	O
moves	array
[	O
k	int
]	O
.	O
cuts	array
)	O
;	O
move_found	int
=	O
1	int
;	O
if	O
(	O
pattern	pointer
&&	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_c	int
)	O
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
name	short
=	O
pattern	pointer
->	O
name	short
;	O
TRACE	O
(	O
"Pattern %s found at %1m with value %d\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
move	pointer
,	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_C	int
)	O
{	O
DEBUG	O
(	O
DEBUG_SPLIT_OWL	int
,	O
"Generating cut list for move at %1m.\n"	pointer
,	O
move	pointer
)	O
;	O
generate_cut_list	function
(	O
pattern	pointer
,	O
ll	int
,	O
anchor	int
,	O
moves	array
[	O
k	int
]	O
.	O
cuts	array
,	O
owl	int
)	O
;	O
}	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_NOT_CONNECTED	int
;	O
else	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_a	int
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_ALL_CONNECTED	int
;	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
=	O
pattern_data	pointer
;	O
}	O
else	O
if	O
(	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_b	int
)	O
)	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_CONNECTED	int
;	O
else	O
{	O
int	O
i	int
;	O
enum	O
same_dragon_value	enum
same_dragon	function
=	O
SAME_DRAGON_MAYBE_CONNECTED	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	pointer
->	O
heap_num_patterns	int
;	O
i	int
++	O
)	O
{	O
pattern_data	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
i	int
]	O
;	O
if	O
(	O
pattern_data	pointer
->	O
pattern	pointer
&&	O
pattern_data	pointer
->	O
move	pointer
==	O
move	pointer
&&	O
(	O
(	O
pattern_data	pointer
->	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
||	O
!	O
(	O
pattern_data	pointer
->	O
pattern	pointer
->	O
class	int
&	O
CLASS_b	int
)	O
)	O
)	O
{	O
if	O
(	O
check_pattern_hard	function
(	O
move	pointer
,	O
color	int
,	O
pattern_data	pointer
->	O
pattern	pointer
,	O
pattern_data	pointer
->	O
ll	int
)	O
)	O
{	O
TRACE	O
(	O
"Additionally pattern %s found at %1m\n"	pointer
,	O
pattern_data	pointer
->	O
pattern	pointer
->	O
name	short
,	O
move	pointer
)	O
;	O
if	O
(	O
pattern_data	pointer
->	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
same_dragon	function
=	O
SAME_DRAGON_NOT_CONNECTED	int
;	O
else	O
if	O
(	O
pattern_data	pointer
->	O
pattern	pointer
->	O
class	int
&	O
CLASS_a	int
)	O
{	O
same_dragon	function
=	O
SAME_DRAGON_ALL_CONNECTED	int
;	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
=	O
pattern_data	pointer
;	O
}	O
else	O
same_dragon	function
=	O
SAME_DRAGON_CONNECTED	int
;	O
break	O
;	O
}	O
}	O
}	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
same_dragon	function
;	O
}	O
}	O
else	O
{	O
moves	array
[	O
k	int
]	O
.	O
name	short
=	O
"Pattern combination"	pointer
;	O
if	O
(	O
verbose	int
)	O
{	O
}	O
if	O
(	O
pattern	pointer
&&	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_NOT_CONNECTED	int
;	O
else	O
if	O
(	O
pattern	pointer
&&	O
pattern	pointer
->	O
class	int
&	O
CLASS_a	int
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_ALL_CONNECTED	int
;	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
=	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
;	O
}	O
else	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
SAME_DRAGON_CONNECTED	int
;	O
}	O
if	O
(	O
pattern	pointer
&&	O
pattern	pointer
->	O
class	int
&	O
CLASS_E	int
)	O
moves	array
[	O
k	int
]	O
.	O
escape	int
=	O
1	int
;	O
else	O
moves	array
[	O
k	int
]	O
.	O
escape	int
=	O
0	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_c	int
)	O
)	O
{	O
pattern_list_pop_heap_once	function
(	O
list	pointer
)	O
;	O
}	O
else	O
{	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
pattern	pointer
=	O
NULL	O
;	O
if	O
(	O
next_pattern_index	int
!=	O
-	O
1	int
)	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
=	O
list	pointer
->	O
pattern_list	pointer
+	O
next_pattern_index	int
;	O
list	pointer
->	O
pattern_heap	pointer
[	O
0	int
]	O
->	O
value	pointer
=	O
valuate_combinable_pattern_chain	function
(	O
list	pointer
,	O
move	pointer
)	O
;	O
pattern_list_sink_heap_top_element	function
(	O
list	pointer
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
move_found	int
;	O
}	O
static	O
void	O
owl_shapes_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
tval	int
;	O
int	O
move	pointer
;	O
struct	O
owl_move_data	struct
*	O
moves	array
=	O
data	pointer
;	O
enum	O
same_dragon_value	enum
same_dragon	function
=	O
SAME_DRAGON_MAYBE_CONNECTED	int
;	O
int	O
escape	int
=	O
0	int
;	O
int	O
defense_pos	int
;	O
move	pointer
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
!	O
allpats	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
==	O
move	pointer
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
>=	O
pattern	pointer
->	O
value	pointer
)	O
return	O
;	O
else	O
break	O
;	O
}	O
}	O
if	O
(	O
k	int
==	O
MAX_MOVES	int
&&	O
moves	array
[	O
MAX_MOVES	int
-	O
1	int
]	O
.	O
value	pointer
>=	O
pattern	pointer
->	O
value	pointer
)	O
return	O
;	O
}	O
if	O
(	O
!	O
check_pattern_hard	function
(	O
move	pointer
,	O
color	int
,	O
pattern	pointer
,	O
ll	int
)	O
)	O
return	O
;	O
if	O
(	O
pattern	pointer
->	O
helper	pointer
)	O
{	O
gg_assert	O
(	O
0	int
)	O
;	O
DEBUG	O
(	O
DEBUG_HELPER	int
,	O
"  asking helper to consider '%s'+%d at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
move	pointer
)	O
;	O
tval	int
=	O
pattern	pointer
->	O
helper	pointer
(	O
pattern	pointer
,	O
ll	int
,	O
move	pointer
,	O
color	int
)	O
;	O
if	O
(	O
tval	int
>	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_HELPER	int
,	O
"helper likes pattern '%s' value %d at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
tval	int
,	O
move	pointer
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_HELPER	int
,	O
"  helper does not like pattern '%s' at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
move	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
tval	int
=	O
(	O
int	O
)	O
pattern	pointer
->	O
value	pointer
;	O
}	O
TRACE	O
(	O
"Pattern %s found at %1m with value %d\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
move	pointer
,	O
tval	int
)	O
;	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
same_dragon	function
=	O
SAME_DRAGON_NOT_CONNECTED	int
;	O
else	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_b	int
)	O
same_dragon	function
=	O
SAME_DRAGON_MAYBE_CONNECTED	int
;	O
else	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_a	int
)	O
{	O
same_dragon	function
=	O
SAME_DRAGON_ALL_CONNECTED	int
;	O
gg_assert	O
(	O
0	int
)	O
;	O
}	O
else	O
same_dragon	function
=	O
SAME_DRAGON_CONNECTED	int
;	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_E	int
)	O
escape	int
=	O
1	int
;	O
else	O
escape	int
=	O
0	int
;	O
{	O
int	O
k	int
;	O
defense_pos	int
=	O
move	pointer
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
k	int
++	O
)	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_not	int
)	O
defense_pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
}	O
owl_add_move	function
(	O
moves	array
,	O
move	pointer
,	O
tval	int
,	O
pattern	pointer
->	O
name	short
,	O
same_dragon	function
,	O
NO_MOVE	O
,	O
escape	int
,	O
defense_pos	int
,	O
MAX_MOVES	int
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
owl_add_move	function
(	O
struct	O
owl_move_data	struct
*	O
moves	array
,	O
int	O
move	pointer
,	O
int	O
value	pointer
,	O
const	O
char	O
*	O
reason	pointer
,	O
enum	O
same_dragon_value	enum
same_dragon	function
,	O
int	O
lunch	int
,	O
int	O
escape	int
,	O
int	O
defense_pos	int
,	O
int	O
max_moves	int
,	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
)	O
{	O
int	O
k	int
;	O
if	O
(	O
!	O
found_matches	array
[	O
move	pointer
]	O
)	O
{	O
found_matches	array
[	O
move	pointer
]	O
=	O
1	int
;	O
matches_found	int
++	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
==	O
move	pointer
)	O
{	O
if	O
(	O
same_dragon	function
>	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
same_dragon	function
;	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
=	O
pattern_data	pointer
;	O
}	O
if	O
(	O
!	O
moves	array
[	O
k	int
]	O
.	O
escape	int
)	O
escape	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
k	int
<	O
max_moves	int
&&	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
>=	O
value	pointer
)	O
return	O
;	O
for	O
(	O
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
if	O
(	O
k	int
==	O
0	int
||	O
value	pointer
<=	O
moves	array
[	O
k	int
-	O
1	int
]	O
.	O
value	pointer
)	O
{	O
if	O
(	O
k	int
<	O
max_moves	int
)	O
{	O
moves	array
[	O
k	int
]	O
.	O
pos	int
=	O
move	pointer
;	O
moves	array
[	O
k	int
]	O
.	O
value	pointer
=	O
value	pointer
;	O
moves	array
[	O
k	int
]	O
.	O
name	short
=	O
reason	pointer
;	O
moves	array
[	O
k	int
]	O
.	O
same_dragon	function
=	O
same_dragon	function
;	O
moves	array
[	O
k	int
]	O
.	O
pattern_data	pointer
=	O
pattern_data	pointer
;	O
moves	array
[	O
k	int
]	O
.	O
lunch	int
=	O
lunch	int
;	O
moves	array
[	O
k	int
]	O
.	O
escape	int
=	O
escape	int
;	O
moves	array
[	O
k	int
]	O
.	O
defense_pos	int
=	O
defense_pos	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
k	int
<	O
max_moves	int
)	O
moves	array
[	O
k	int
]	O
=	O
moves	array
[	O
k	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
int	O
l	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max_moves	int
;	O
k	int
++	O
)	O
for	O
(	O
l	int
=	O
k	int
+	O
1	int
;	O
l	int
<	O
max_moves	int
;	O
l	int
++	O
)	O
gg_assert	O
(	O
moves	array
[	O
k	int
]	O
.	O
pos	int
==	O
0	int
||	O
moves	array
[	O
k	int
]	O
.	O
pos	int
!=	O
moves	array
[	O
l	int
]	O
.	O
pos	int
)	O
;	O
}	O
}	O
static	O
void	O
owl_mark_dragon	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
new_dragons	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
=	O
board	pointer
[	O
apos	int
]	O
;	O
ASSERT1	O
(	O
bpos	int
==	O
NO_MOVE	O
||	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
,	O
bpos	int
)	O
;	O
if	O
(	O
new_dragons	array
==	O
NULL	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
is_same_dragon	function
(	O
pos	int
,	O
apos	int
)	O
||	O
is_same_dragon	function
(	O
pos	int
,	O
bpos	int
)	O
)	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
(	O
new_dragons	array
[	O
pos	int
]	O
==	O
new_dragons	array
[	O
apos	int
]	O
||	O
new_dragons	array
[	O
pos	int
]	O
==	O
new_dragons	array
[	O
bpos	int
]	O
)	O
)	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
}	O
memcpy	function
(	O
owl	int
->	O
cumulative_goal	array
,	O
owl	int
->	O
goal	pointer
,	O
sizeof	O
(	O
owl	int
->	O
goal	pointer
)	O
)	O
;	O
owl	int
->	O
color	int
=	O
color	int
;	O
owl_mark_boundary	function
(	O
owl	int
)	O
;	O
}	O
static	O
void	O
owl_mark_worm	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
=	O
board	pointer
[	O
apos	int
]	O
;	O
ASSERT1	O
(	O
bpos	int
==	O
NO_MOVE	O
||	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
,	O
bpos	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
is_same_worm	function
(	O
pos	int
,	O
apos	int
)	O
||	O
is_same_worm	function
(	O
pos	int
,	O
bpos	int
)	O
)	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
owl	int
->	O
color	int
=	O
color	int
;	O
}	O
static	O
void	O
owl_mark_boundary	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
color	int
=	O
owl	int
->	O
color	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
memset	function
(	O
owl	int
->	O
boundary	array
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
boundary	array
)	O
)	O
;	O
memset	function
(	O
owl	int
->	O
neighbors	int
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
neighbors	int
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
pos	int
+	O
2	int
*	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos	int
+	O
2	int
*	O
delta	array
[	O
k	int
]	O
]	O
)	O
mark_string	function
(	O
pos	int
+	O
2	int
*	O
delta	array
[	O
k	int
]	O
,	O
owl	int
->	O
neighbors	int
,	O
1	int
)	O
;	O
}	O
for	O
(	O
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos2	int
]	O
&&	O
(	O
board	pointer
[	O
SOUTH	O
(	O
gg_min	O
(	O
pos	int
,	O
pos2	int
)	O
)	O
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
NORTH	O
(	O
gg_max	O
(	O
pos	int
,	O
pos2	int
)	O
)	O
]	O
==	O
EMPTY	int
)	O
)	O
mark_string	function
(	O
pos2	int
,	O
owl	int
->	O
neighbors	int
,	O
1	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
!	O
owl	int
->	O
boundary	array
[	O
pos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
(	O
owl	int
->	O
goal	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
||	O
owl	int
->	O
neighbors	int
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
)	O
{	O
mark_string	function
(	O
pos	int
,	O
owl	int
->	O
boundary	array
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
owl	int
->	O
boundary	array
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
goal	pointer
[	O
pos2	int
]	O
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos2	int
]	O
&&	O
(	O
(	O
dragon	int
[	O
pos2	int
]	O
.	O
crude_status	function
!=	O
DEAD	int
&&	O
countstones	function
(	O
pos2	int
)	O
>	O
2	int
)	O
||	O
dragon	int
[	O
pos2	int
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
)	O
{	O
mark_string	function
(	O
pos	int
,	O
owl	int
->	O
boundary	array
,	O
2	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
owl	int
->	O
boundary	array
[	O
pos	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
size	int
!=	O
dragon	int
[	O
pos	int
]	O
.	O
size	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
==	O
-	O
1	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
;	O
int	O
apos	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
goal	pointer
[	O
apos	int
]	O
)	O
{	O
owl	int
->	O
boundary	array
[	O
pos	int
]	O
=	O
2	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
owl_update_goal	function
(	O
int	O
pos	int
,	O
enum	O
same_dragon_value	enum
same_dragon	function
,	O
int	O
lunch	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
semeai_call	int
,	O
struct	O
matched_pattern_data	struct
*	O
pattern_data	pointer
)	O
{	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
;	O
int	O
k	int
;	O
int	O
do_add	int
=	O
1	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
same_dragon	function
==	O
SAME_DRAGON_NOT_CONNECTED	int
)	O
num_stones	int
=	O
findstones	function
(	O
pos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	pointer
)	O
;	O
else	O
if	O
(	O
semeai_call	int
)	O
find_superstring_conservative	function
(	O
pos	int
,	O
&	O
num_stones	int
,	O
stones	pointer
)	O
;	O
else	O
find_superstring	function
(	O
pos	int
,	O
&	O
num_stones	int
,	O
stones	pointer
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
same_dragon	function
<=	O
SAME_DRAGON_MAYBE_CONNECTED	int
)	O
{	O
do_add	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
if	O
(	O
owl	int
->	O
goal	pointer
[	O
stones	pointer
[	O
k	int
]	O
]	O
!=	O
0	int
)	O
{	O
do_add	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
do_add	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owl	int
->	O
goal	pointer
[	O
stones	pointer
[	O
k	int
]	O
]	O
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"Added %1m to goal.\n"	pointer
,	O
stones	pointer
[	O
k	int
]	O
)	O
;	O
owl	int
->	O
goal	pointer
[	O
stones	pointer
[	O
k	int
]	O
]	O
=	O
2	int
;	O
owl	int
->	O
cumulative_goal	array
[	O
stones	pointer
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
semeai_call	int
&&	O
lunch	int
!=	O
NO_MOVE	O
&&	O
board	pointer
[	O
lunch	int
]	O
!=	O
EMPTY	int
)	O
{	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
adj	array
=	O
chainlinks	function
(	O
lunch	int
,	O
adjs	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array
;	O
k	int
++	O
)	O
if	O
(	O
!	O
owl	int
->	O
goal	pointer
[	O
adjs	array
[	O
k	int
]	O
]	O
)	O
{	O
mark_string	function
(	O
adjs	array
[	O
k	int
]	O
,	O
owl	int
->	O
goal	pointer
,	O
2	int
)	O
;	O
mark_string	function
(	O
adjs	array
[	O
k	int
]	O
,	O
owl	int
->	O
cumulative_goal	array
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
same_dragon	function
==	O
SAME_DRAGON_ALL_CONNECTED	int
)	O
{	O
gg_assert	O
(	O
pattern_data	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern_data	pointer
->	O
pattern	pointer
->	O
patlen	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
;	O
if	O
(	O
pattern_data	pointer
->	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
!=	O
ATT_O	int
)	O
continue	O
;	O
pos2	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern_data	pointer
->	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
pattern_data	pointer
->	O
ll	int
,	O
pattern_data	pointer
->	O
anchor	int
)	O
;	O
if	O
(	O
!	O
owl	int
->	O
goal	pointer
[	O
pos2	int
]	O
)	O
owl_update_goal	function
(	O
pos2	int
,	O
SAME_DRAGON_CONNECTED	int
,	O
NO_MOVE	O
,	O
owl	int
,	O
semeai_call	int
,	O
pattern_data	pointer
)	O
;	O
}	O
}	O
if	O
(	O
1	int
&&	O
verbose	int
)	O
goaldump	function
(	O
owl	int
->	O
goal	pointer
)	O
;	O
}	O
static	O
int	O
connected_components	function
(	O
signed	O
char	O
graph	array
[	O
MAX_CUTS	int
]	O
[	O
MAX_CUTS	int
]	O
,	O
int	O
graph_size	int
,	O
signed	O
char	O
component	array
[	O
MAX_CUTS	int
]	O
)	O
{	O
int	O
num_components	int
=	O
0	int
;	O
int	O
k	int
,	O
j	int
;	O
if	O
(	O
graph_size	int
<=	O
0	int
)	O
return	O
0	int
;	O
memset	function
(	O
component	array
,	O
-	O
1	int
,	O
MAX_CUTS	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
found_one	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
graph_size	int
;	O
k	int
++	O
)	O
if	O
(	O
component	array
[	O
k	int
]	O
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
k	int
==	O
graph_size	int
)	O
break	O
;	O
component	array
[	O
k	int
]	O
=	O
num_components	int
;	O
do	O
{	O
found_one	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
k	int
+	O
1	int
;	O
j	int
<	O
graph_size	int
;	O
j	int
++	O
)	O
if	O
(	O
graph	array
[	O
k	int
]	O
[	O
j	int
]	O
&&	O
component	array
[	O
j	int
]	O
==	O
-	O
1	int
)	O
{	O
component	array
[	O
j	int
]	O
=	O
num_components	int
;	O
found_one	int
=	O
1	int
;	O
}	O
}	O
while	O
(	O
found_one	int
)	O
;	O
num_components	int
++	O
;	O
}	O
gg_assert	O
(	O
num_components	int
>	O
0	int
)	O
;	O
return	O
num_components	int
;	O
}	O
static	O
void	O
owl_test_cuts	function
(	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
,	O
int	O
cuts	array
[	O
MAX_CUTS	int
]	O
)	O
{	O
int	O
k	int
,	O
j	int
;	O
signed	O
char	O
connected	array
[	O
MAX_CUTS	int
]	O
[	O
MAX_CUTS	int
]	O
;	O
int	O
num_cuts	int
;	O
int	O
found_cut	int
=	O
0	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
memset	function
(	O
connected	array
,	O
1	int
,	O
MAX_CUTS	int
*	O
MAX_CUTS	int
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_SPLIT_OWL	int
)	O
{	O
gprintf	function
(	O
"Called for this goal: "	pointer
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
gprintf	function
(	O
"At this position:\n"	pointer
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_CUTS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
cuts	array
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
board	pointer
[	O
cuts	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
j	int
=	O
k	int
+	O
1	int
;	O
j	int
<	O
MAX_CUTS	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
cuts	array
[	O
j	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
cuts	array
[	O
j	int
-	O
1	int
]	O
=	O
cuts	array
[	O
j	int
]	O
;	O
}	O
cuts	array
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
k	int
--	O
;	O
}	O
}	O
num_cuts	int
=	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_cuts	int
;	O
k	int
++	O
)	O
{	O
ASSERT1	O
(	O
board	pointer
[	O
cuts	array
[	O
k	int
]	O
]	O
==	O
color	int
,	O
cuts	array
[	O
k	int
]	O
)	O
;	O
for	O
(	O
j	int
=	O
k	int
+	O
1	int
;	O
j	int
<	O
num_cuts	int
;	O
j	int
++	O
)	O
if	O
(	O
fast_disconnect	function
(	O
cuts	array
[	O
k	int
]	O
,	O
cuts	array
[	O
j	int
]	O
,	O
NULL	O
)	O
==	O
WIN	int
)	O
{	O
found_cut	int
=	O
1	int
;	O
connected	array
[	O
k	int
]	O
[	O
j	int
]	O
=	O
0	int
;	O
connected	array
[	O
j	int
]	O
[	O
k	int
]	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
found_cut	int
)	O
{	O
signed	O
char	O
component	array
[	O
MAX_CUTS	int
]	O
;	O
signed	O
char	O
component2	array
[	O
BOARDMAX	O
]	O
;	O
int	O
component_size	array
[	O
MAX_CUTS	int
]	O
;	O
int	O
num_components	int
;	O
int	O
biggest_component	int
=	O
-	O
1	int
;	O
struct	O
connection_data	struct
*	O
conn_data	pointer
;	O
int	O
c_id	int
;	O
int	O
pos	int
;	O
num_components	int
=	O
connected_components	function
(	O
connected	array
,	O
num_cuts	int
,	O
component	array
)	O
;	O
if	O
(	O
num_components	int
<=	O
1	int
)	O
{	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
;	O
}	O
memset	function
(	O
component2	array
,	O
-	O
1	int
,	O
BOARDMAX	O
)	O
;	O
memset	function
(	O
component_size	array
,	O
0	int
,	O
sizeof	O
(	O
int	O
)	O
*	O
num_components	int
)	O
;	O
conn_data	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
connection_data	struct
)	O
*	O
num_components	int
)	O
;	O
for	O
(	O
c_id	int
=	O
0	int
;	O
c_id	int
<	O
num_components	int
;	O
c_id	int
++	O
)	O
{	O
signed	O
char	O
this_goal	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
this_goal	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_cuts	int
;	O
k	int
++	O
)	O
if	O
(	O
component	array
[	O
k	int
]	O
==	O
c_id	int
)	O
{	O
mark_string	function
(	O
cuts	array
[	O
k	int
]	O
,	O
this_goal	array
,	O
1	int
)	O
;	O
mark_string	function
(	O
cuts	array
[	O
k	int
]	O
,	O
component2	array
,	O
(	O
signed	O
char	O
)	O
c_id	int
)	O
;	O
}	O
init_connection_data	function
(	O
color	int
,	O
this_goal	array
,	O
NO_MOVE	O
,	O
FP	O
(	O
3.01	int
)	O
,	O
conn_data	pointer
+	O
c_id	int
,	O
1	int
)	O
;	O
spread_connection_distances	function
(	O
color	int
,	O
conn_data	pointer
+	O
c_id	int
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
closest_dist	int
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
int	O
closest_component	int
=	O
-	O
1	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
||	O
!	O
goal	pointer
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
pos	int
!=	O
find_origin	function
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
c_id	int
=	O
0	int
;	O
c_id	int
<	O
num_components	int
;	O
c_id	int
++	O
)	O
{	O
if	O
(	O
conn_data	pointer
[	O
c_id	int
]	O
.	O
distances	array
[	O
pos	int
]	O
<	O
closest_dist	int
)	O
{	O
closest_dist	int
=	O
conn_data	pointer
[	O
c_id	int
]	O
.	O
distances	array
[	O
pos	int
]	O
;	O
closest_component	int
=	O
c_id	int
;	O
}	O
}	O
if	O
(	O
closest_component	int
!=	O
-	O
1	int
)	O
{	O
mark_string	function
(	O
pos	int
,	O
component2	array
,	O
(	O
signed	O
char	O
)	O
closest_component	int
)	O
;	O
component_size	array
[	O
closest_component	int
]	O
+=	O
countstones	function
(	O
pos	int
)	O
;	O
}	O
}	O
{	O
int	O
biggest_size	int
=	O
0	int
;	O
for	O
(	O
c_id	int
=	O
0	int
;	O
c_id	int
<	O
num_components	int
;	O
c_id	int
++	O
)	O
if	O
(	O
component_size	array
[	O
c_id	int
]	O
>	O
biggest_size	int
)	O
{	O
biggest_size	int
=	O
component_size	array
[	O
c_id	int
]	O
;	O
biggest_component	int
=	O
c_id	int
;	O
}	O
gg_assert	O
(	O
biggest_component	int
!=	O
-	O
1	int
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
component2	array
[	O
pos	int
]	O
!=	O
biggest_component	int
)	O
goal	pointer
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_SPLIT_OWL	int
)	O
{	O
gprintf	function
(	O
"Split dragon. Biggest component is %d (of %d).\n"	pointer
,	O
biggest_component	int
,	O
num_components	int
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
componentdump	function
(	O
component2	array
)	O
;	O
}	O
free	function
(	O
conn_data	pointer
)	O
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
static	O
void	O
owl_update_boundary_marks	function
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
signed	O
char	O
boundary_mark	char
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
owl	int
->	O
boundary	array
[	O
pos2	int
]	O
>	O
boundary_mark	char
)	O
boundary_mark	char
=	O
owl	int
->	O
boundary	array
[	O
pos2	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
owl	int
->	O
color	int
&&	O
dragon	int
[	O
pos2	int
]	O
.	O
color	int
==	O
owl	int
->	O
color	int
&&	O
dragon	int
[	O
pos2	int
]	O
.	O
status	enum
==	O
ALIVE	int
&&	O
!	O
owl	int
->	O
goal	pointer
[	O
pos2	int
]	O
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos2	int
]	O
)	O
boundary_mark	char
=	O
2	int
;	O
}	O
mark_string	function
(	O
pos	int
,	O
owl	int
->	O
boundary	array
,	O
boundary_mark	char
)	O
;	O
}	O
void	O
goaldump	function
(	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	pointer
[	O
pos	int
]	O
)	O
gprintf	function
(	O
"%o%1m (%d)  "	pointer
,	O
pos	int
,	O
(	O
int	O
)	O
goal	pointer
[	O
pos	int
]	O
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
void	O
componentdump	function
(	O
const	O
signed	O
char	O
component	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
component	array
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
gprintf	function
(	O
"%o%1m (%d)  "	pointer
,	O
pos	int
,	O
(	O
int	O
)	O
component	array
[	O
pos	int
]	O
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
test_owl_attack_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
kworm	int
,	O
int	O
acode	int
)	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
dr	int
]	O
)	O
;	O
if	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeais	int
==	O
0	int
||	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeai_defense_point	int
==	O
NO_MOVE	O
||	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeais	int
==	O
1	int
&&	O
semeai_move_reason_known	function
(	O
pos	int
,	O
dr	int
)	O
)	O
||	O
acode	int
==	O
GAIN	int
)	O
{	O
add_owl_attack_move	function
(	O
pos	int
,	O
dr	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m attacks %1m (%s) at move %d\n"	pointer
,	O
pos	int
,	O
dr	int
,	O
result_to_string	function
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
owl_attack_code	int
)	O
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
dr2	int
=	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeai_defense_target	int
;	O
int	O
semeai_result	int
,	O
certain	pointer
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
owl_analyze_semeai_after_move	function
(	O
pos	int
,	O
color	int
,	O
dr	int
,	O
dr2	int
,	O
&	O
semeai_result	int
,	O
NULL	O
,	O
NULL	O
,	O
1	int
,	O
&	O
certain	pointer
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
if	O
(	O
certain	pointer
>=	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeai_defense_certain	int
&&	O
(	O
semeai_result	int
>=	O
REVERSE_RESULT	O
(	O
acode	int
)	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m ineffective owl attack on %1m (can live in semeai with %1m)\n"	pointer
,	O
pos	int
,	O
dr	int
,	O
dr2	int
)	O
;	O
add_strategical_attack_move	function
(	O
pos	int
,	O
dr	int
)	O
;	O
}	O
else	O
{	O
add_owl_attack_move	function
(	O
pos	int
,	O
dr	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m attacks %1m (%s) at move %d\n"	pointer
,	O
pos	int
,	O
dr	int
,	O
result_to_string	function
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
owl_attack_code	int
)	O
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
owl_reasons	function
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
||	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
!=	O
pos	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
CRITICAL	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
==	O
LOSS	int
)	O
{	O
add_loss_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_kworm	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m defends %1m with loss at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
add_owl_defense_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m defends %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
int	O
move	pointer
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
effective_size	float
<	O
8	int
)	O
{	O
int	O
largest	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
bpos	int
=	O
NO_MOVE	O
;	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
safe	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
;	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
color	int
==	O
color	int
)	O
{	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum
==	O
ALIVE	int
)	O
{	O
safe	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
size	int
>	O
largest	int
)	O
{	O
bpos	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
largest	int
=	O
DRAGON	O
(	O
d	int
)	O
.	O
size	int
;	O
}	O
}	O
}	O
if	O
(	O
bpos	int
==	O
NO_MOVE	O
)	O
safe	int
=	O
1	int
;	O
if	O
(	O
!	O
safe	int
&&	O
owl_does_defend	function
(	O
move	pointer
,	O
bpos	int
,	O
&	O
kworm	int
)	O
!=	O
WIN	int
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m attacks %1m at move %d, but the attacker dies.\n"	pointer
,	O
move	pointer
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
=	O
INESSENTIAL	int
;	O
continue	O
;	O
}	O
}	O
test_owl_attack_move	function
(	O
move	pointer
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_kworm	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum
==	O
DEAD	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_threat_status	enum
==	O
CAN_THREATEN_DEFENSE	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_defense_threat_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
WIN	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m threatens to defend %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
!=	O
NO_MOVE	O
&&	O
is_legal	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
,	O
color	int
)	O
)	O
{	O
add_owl_defense_threat_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
,	O
pos	int
,	O
WIN	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m threatens to defend %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_threat_status	enum
==	O
CAN_THREATEN_DEFENSE	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_prevent_threat_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m prevents a threat against %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum
==	O
ALIVE	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_threat_status	enum
==	O
CAN_THREATEN_ATTACK	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_attack_threat_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
WIN	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m threatens %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
!=	O
NO_MOVE	O
&&	O
is_legal	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
,	O
color	int
)	O
)	O
{	O
add_owl_attack_threat_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
,	O
pos	int
,	O
WIN	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m threatens %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
==	O
GAIN	int
)	O
{	O
add_owl_attack_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_kworm	int
,	O
GAIN	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m attacks %1m with gain at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
==	O
LOSS	int
)	O
{	O
add_loss_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_kworm	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m defends %1m with loss at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
==	O
GAIN	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
==	O
WIN	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_defense_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m defends %1m against possible loss at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_certain	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_certain	int
&&	O
ON_BOARD	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
)	O
)	O
{	O
add_owl_uncertain_defense_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m defends the uncertain dragon at %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum
==	O
DEAD	int
&&	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_certain	int
&&	O
ON_BOARD	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
)	O
)	O
{	O
add_owl_uncertain_defense_move	function
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	int
,	O
"owl: %1m might defend the uncertain dragon at %1m at move %d\n"	pointer
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
int	O
owl_does_defend	function
(	O
int	O
move	pointer
,	O
int	O
target	int
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
target	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
origin	int
;	O
int	O
acode	int
;	O
int	O
wpos	pointer
=	O
NO_MOVE	O
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
double	O
start	double
=	O
0.0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
if	O
(	O
worm	array
[	O
target	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
return	O
0	int
;	O
origin	int
=	O
dragon	int
[	O
target	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"owl_does_defend %1m %1m(%1m)\n"	pointer
,	O
move	pointer
,	O
target	int
,	O
origin	int
)	O
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_DOES_DEFEND	int
,	O
move	pointer
,	O
target	int
,	O
0	int
,	O
&	O
result	int
,	O
kworm	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"owl_does_defend"	pointer
,	O
target	int
)	O
)	O
{	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_ATTACK	int
,	O
origin	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
NULL	O
,	O
kworm	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
REVERSE_RESULT	O
(	O
result	int
)	O
;	O
}	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
move	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	function
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	array
,	O
&	O
goal_worms_computed	int
,	O
kworm	int
,	O
0	int
)	O
;	O
acode	int
=	O
do_owl_attack	function
(	O
target	int
,	O
NULL	O
,	O
&	O
wid	int
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	function
(	O
&	O
goal_worms_computed	int
,	O
&	O
wpos	pointer
,	O
owl_goal_worm	array
,	O
wid	int
)	O
;	O
result	int
=	O
REVERSE_RESULT	O
(	O
acode	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
else	O
return	O
0	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_does_defend %1m %1m(%1m), result %d (%d, %d nodes, %f seconds)\n"	pointer
,	O
move	pointer
,	O
target	int
,	O
origin	int
,	O
result	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_DOES_DEFEND	int
,	O
move	pointer
,	O
target	int
,	O
0	int
,	O
result	int
,	O
wpos	pointer
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	pointer
;	O
return	O
result	int
;	O
}	O
int	O
owl_confirm_safety	function
(	O
int	O
move	pointer
,	O
int	O
target	int
,	O
int	O
*	O
defense_point	pointer
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
target	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
origin	int
;	O
int	O
defense	int
=	O
0	int
;	O
double	O
start	double
=	O
0.0	int
;	O
int	O
acode	int
;	O
int	O
wpos	pointer
=	O
NO_MOVE	O
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
if	O
(	O
worm	array
[	O
target	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
return	O
0	int
;	O
origin	int
=	O
dragon	int
[	O
target	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"owl_confirm_safety %1m %1m(%1m)\n"	pointer
,	O
move	pointer
,	O
target	int
,	O
origin	int
)	O
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_CONFIRM_SAFETY	int
,	O
move	pointer
,	O
target	int
,	O
0	int
,	O
&	O
result	int
,	O
defense_point	pointer
,	O
kworm	int
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"owl_confirm_safety"	pointer
,	O
target	int
)	O
)	O
{	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_ATTACK	int
,	O
origin	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
defense_point	pointer
,	O
kworm	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
return	O
WIN	int
;	O
else	O
if	O
(	O
result	int
==	O
GAIN	int
)	O
return	O
LOSS	int
;	O
else	O
return	O
0	int
;	O
}	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
move	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	function
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	array
,	O
&	O
goal_worms_computed	int
,	O
kworm	int
,	O
0	int
)	O
;	O
acode	int
=	O
do_owl_attack	function
(	O
target	int
,	O
&	O
defense	int
,	O
&	O
wid	int
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	function
(	O
&	O
goal_worms_computed	int
,	O
&	O
wpos	pointer
,	O
owl_goal_worm	array
,	O
wid	int
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
result	int
=	O
WIN	int
;	O
else	O
if	O
(	O
acode	int
==	O
GAIN	int
)	O
result	int
=	O
LOSS	int
;	O
popgo	function
(	O
)	O
;	O
}	O
else	O
return	O
0	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_confirm_safety %1m %1m(%1m), result %d %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
move	pointer
,	O
target	int
,	O
origin	int
,	O
result	int
,	O
defense	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_CONFIRM_SAFETY	int
,	O
move	pointer
,	O
target	int
,	O
0	int
,	O
result	int
,	O
defense	int
,	O
wpos	pointer
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
defense	int
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	pointer
;	O
return	O
result	int
;	O
}	O
int	O
owl_does_attack	function
(	O
int	O
move	pointer
,	O
int	O
target	int
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
target	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
origin	int
;	O
int	O
dcode	int
;	O
int	O
wpos	pointer
=	O
NO_MOVE	O
;	O
int	O
wid	int
=	O
MAX_GOAL_WORMS	int
;	O
double	O
start	double
=	O
0.0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
if	O
(	O
worm	array
[	O
target	int
]	O
.	O
unconditional_status	enum
==	O
ALIVE	int
)	O
return	O
0	int
;	O
origin	int
=	O
dragon	int
[	O
target	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"owl_does_attack %1m %1m(%1m)\n"	pointer
,	O
move	pointer
,	O
target	int
,	O
origin	int
)	O
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_DOES_ATTACK	int
,	O
move	pointer
,	O
target	int
,	O
0	int
,	O
&	O
result	int
,	O
kworm	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
init_owl	function
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
other	int
,	O
"owl_does_attack"	pointer
,	O
target	int
)	O
)	O
{	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_DEFEND	int
,	O
origin	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
NULL	O
,	O
kworm	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
REVERSE_RESULT	O
(	O
result	int
)	O
;	O
}	O
owl_update_boundary_marks	function
(	O
move	pointer
,	O
owl	int
)	O
;	O
if	O
(	O
board	pointer
[	O
target	int
]	O
==	O
EMPTY	int
)	O
dcode	int
=	O
0	int
;	O
else	O
{	O
prepare_goal_list	function
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	array
,	O
&	O
goal_worms_computed	int
,	O
kworm	int
,	O
0	int
)	O
;	O
dcode	int
=	O
do_owl_defend	function
(	O
target	int
,	O
NULL	O
,	O
&	O
wid	int
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	function
(	O
&	O
goal_worms_computed	int
,	O
&	O
wpos	pointer
,	O
owl_goal_worm	array
,	O
wid	int
)	O
;	O
}	O
result	int
=	O
REVERSE_RESULT	O
(	O
dcode	int
)	O
;	O
owl	int
->	O
lunches_are_current	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
else	O
return	O
0	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_does_attack %1m %1m(%1m), result %d (%d, %d nodes, %f seconds)\n"	pointer
,	O
move	pointer
,	O
target	int
,	O
origin	int
,	O
result	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_DOES_ATTACK	int
,	O
move	pointer
,	O
target	int
,	O
0	int
,	O
result	int
,	O
wpos	pointer
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
board	pointer
[	O
target	int
]	O
)	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	pointer
;	O
return	O
result	int
;	O
}	O
int	O
owl_connection_defends	function
(	O
int	O
move	pointer
,	O
int	O
target1	int
,	O
int	O
target2	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
target1	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
double	O
start	double
=	O
0.0	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
target2	int
]	O
==	O
color	int
,	O
target2	int
)	O
;	O
TRACE	O
(	O
"owl_connection_defends %1m %1m %1m\n"	pointer
,	O
move	pointer
,	O
target1	int
,	O
target2	int
)	O
;	O
if	O
(	O
worm	array
[	O
target1	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
worm	array
[	O
target2	int
]	O
.	O
unconditional_status	enum
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_CONNECTION_DEFENDS	int
,	O
move	pointer
,	O
target1	int
,	O
target2	int
,	O
&	O
result	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
init_owl	function
(	O
&	O
owl	int
,	O
target1	int
,	O
target2	int
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"owl_connection_defends"	pointer
,	O
target1	int
)	O
)	O
{	O
owl_update_goal	function
(	O
move	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
owl	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
do_owl_attack	function
(	O
move	pointer
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
)	O
result	int
=	O
WIN	int
;	O
owl	int
->	O
lunches_are_current	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_conn_defends %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n"	pointer
,	O
move	pointer
,	O
target1	int
,	O
target2	int
,	O
result	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_CONNECTION_DEFENDS	int
,	O
move	pointer
,	O
target1	int
,	O
target2	int
,	O
result	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
color	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
void	O
owl_find_lunches	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
lunches	int
=	O
0	int
;	O
int	O
prevlunch	int
;	O
int	O
lunch	int
;	O
int	O
acode	int
;	O
int	O
apos	int
;	O
int	O
dcode	int
;	O
int	O
dpos	int
;	O
int	O
color	int
=	O
owl	int
->	O
color	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
signed	O
char	O
already_checked	array
[	O
BOARDMAX	O
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
for	O
(	O
prevlunch	int
=	O
0	int
;	O
prevlunch	int
<	O
MAX_LUNCHES	int
;	O
prevlunch	int
++	O
)	O
owl	int
->	O
lunch	int
[	O
prevlunch	int
]	O
=	O
NO_MOVE	O
;	O
memset	function
(	O
owl	int
->	O
inessential	int
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
inessential	int
)	O
)	O
;	O
memset	function
(	O
already_checked	array
,	O
0	int
,	O
sizeof	O
(	O
already_checked	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
k	int
<	O
4	int
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
pos2	int
+=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
!=	O
other	int
)	O
continue	O
;	O
lunch	int
=	O
find_origin	function
(	O
pos2	int
)	O
;	O
if	O
(	O
already_checked	array
[	O
lunch	int
]	O
)	O
continue	O
;	O
already_checked	array
[	O
lunch	int
]	O
=	O
1	int
;	O
attack_and_defend	function
(	O
lunch	int
,	O
&	O
acode	int
,	O
&	O
apos	int
,	O
&	O
dcode	int
,	O
&	O
dpos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
owl	int
->	O
lunch	int
[	O
lunches	int
]	O
=	O
lunch	int
;	O
owl	int
->	O
lunch_attack_code	array
[	O
lunches	int
]	O
=	O
acode	int
;	O
owl	int
->	O
lunch_attack_point	array
[	O
lunches	int
]	O
=	O
apos	int
;	O
owl	int
->	O
lunch_defend_code	array
[	O
lunches	int
]	O
=	O
dcode	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
,	O
lunch	int
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
owl	int
->	O
lunch_defense_point	array
[	O
lunches	int
]	O
=	O
dpos	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
dpos	int
]	O
==	O
EMPTY	int
,	O
lunch	int
)	O
;	O
}	O
else	O
owl	int
->	O
lunch_defense_point	array
[	O
lunches	int
]	O
=	O
NO_MOVE	O
;	O
lunches	int
++	O
;	O
if	O
(	O
lunches	int
==	O
MAX_LUNCHES	int
)	O
{	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
owl	int
->	O
lunches_are_current	int
=	O
1	int
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
owl	int
->	O
inessential	int
[	O
lunch	int
]	O
)	O
{	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_stones	int
;	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
r	int
;	O
int	O
essential	int
=	O
0	int
;	O
int	O
superstring	array
[	O
BOARDMAX	O
]	O
;	O
adj	array
=	O
chainlinks	function
(	O
lunch	int
,	O
adjs	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
if	O
(	O
!	O
owl	int
->	O
goal	pointer
[	O
adjs	array
[	O
r	int
]	O
]	O
||	O
attack	function
(	O
adjs	array
[	O
r	int
]	O
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
essential	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
essential	int
)	O
continue	O
;	O
find_superstring_stones_and_liberties	function
(	O
lunch	int
,	O
&	O
num_stones	int
,	O
stones	pointer
,	O
&	O
liberties	pointer
,	O
libs	pointer
,	O
0	int
)	O
;	O
memset	function
(	O
superstring	array
,	O
0	int
,	O
sizeof	O
(	O
superstring	array
)	O
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_stones	int
;	O
r	int
++	O
)	O
superstring	array
[	O
stones	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
int	O
bpos	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
int	O
goal_found	int
=	O
0	int
;	O
int	O
s	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
4	int
;	O
s	int
++	O
)	O
{	O
int	O
cpos	int
=	O
bpos	int
+	O
delta	array
[	O
s	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
cpos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
attack	function
(	O
cpos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
essential	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
owl	int
->	O
goal	pointer
[	O
cpos	int
]	O
)	O
goal_found	int
=	O
1	int
;	O
else	O
{	O
essential	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
==	O
other	int
&&	O
!	O
superstring	array
[	O
cpos	int
]	O
)	O
{	O
essential	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
goal_found	int
)	O
{	O
int	O
off_board	int
=	O
0	int
;	O
int	O
diagonal_goal	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
4	int
;	O
s	int
<	O
8	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
bpos	int
+	O
delta	array
[	O
s	int
]	O
)	O
)	O
off_board	int
++	O
;	O
else	O
if	O
(	O
owl	int
->	O
goal	pointer
[	O
bpos	int
+	O
delta	array
[	O
s	int
]	O
]	O
)	O
diagonal_goal	int
++	O
;	O
}	O
if	O
(	O
diagonal_goal	int
+	O
(	O
off_board	int
>=	O
2	int
)	O
<	O
2	int
)	O
essential	int
=	O
1	int
;	O
else	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
4	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
bpos	int
+	O
delta	array
[	O
s	int
]	O
]	O
==	O
EMPTY	int
)	O
{	O
essential	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
essential	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
essential	int
)	O
{	O
TRACE	O
(	O
"Inessential string found at %1m.\n"	pointer
,	O
lunch	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_stones	int
;	O
r	int
++	O
)	O
owl	int
->	O
inessential	int
[	O
stones	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
owl	int
->	O
lunches_are_current	int
=	O
1	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
static	O
int	O
improve_lunch_attack	function
(	O
int	O
lunch	int
,	O
int	O
attack_point	pointer
)	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
lunch	int
]	O
)	O
;	O
int	O
defense_point	pointer
;	O
int	O
k	int
;	O
if	O
(	O
safe_move	function
(	O
attack_point	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
is_edge_vertex	function
(	O
lunch	int
)	O
&&	O
is_edge_vertex	function
(	O
attack_point	pointer
)	O
&&	O
neighbor_of_string	function
(	O
attack_point	pointer
,	O
lunch	int
)	O
)	O
{	O
int	O
stones	pointer
=	O
countstones	function
(	O
lunch	int
)	O
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
if	O
(	O
stones	pointer
==	O
1	int
||	O
(	O
stones	pointer
==	O
2	int
&&	O
findlib	function
(	O
lunch	int
,	O
2	int
,	O
libs	pointer
)	O
==	O
2	int
&&	O
is_edge_vertex	function
(	O
libs	pointer
[	O
0	int
]	O
)	O
&&	O
is_edge_vertex	function
(	O
libs	pointer
[	O
1	int
]	O
)	O
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
attack_point	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
attack_point	pointer
-	O
delta	array
[	O
k	int
]	O
)	O
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
does_attack	function
(	O
apos	int
,	O
lunch	int
)	O
&&	O
safe_move	function
(	O
apos	int
,	O
color	int
)	O
)	O
return	O
apos	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
return	O
attack_point	pointer
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
attack_point	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
&&	O
find_defense	function
(	O
pos	int
,	O
&	O
defense_point	pointer
)	O
&&	O
defense_point	pointer
!=	O
NO_MOVE	O
&&	O
does_attack	function
(	O
defense_point	pointer
,	O
lunch	int
)	O
)	O
{	O
TRACE	O
(	O
"Moved attack of lunch %1m from %1m to %1m.\n"	pointer
,	O
lunch	int
,	O
attack_point	pointer
,	O
defense_point	pointer
)	O
;	O
return	O
defense_point	pointer
;	O
}	O
}	O
return	O
attack_point	pointer
;	O
}	O
static	O
int	O
improve_lunch_defense	function
(	O
int	O
lunch	int
,	O
int	O
defense_point	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
lunch	int
]	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
defense_point	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
countlib	function
(	O
pos	int
)	O
==	O
2	int
)	O
{	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
pos2	int
;	O
findlib	function
(	O
pos	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
libs	pointer
[	O
0	int
]	O
==	O
defense_point	pointer
)	O
pos2	int
=	O
libs	pointer
[	O
1	int
]	O
;	O
else	O
pos2	int
=	O
libs	pointer
[	O
0	int
]	O
;	O
if	O
(	O
accuratelib	function
(	O
pos2	int
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
>	O
accuratelib	function
(	O
defense_point	pointer
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
&&	O
does_defend	function
(	O
pos2	int
,	O
lunch	int
)	O
)	O
{	O
TRACE	O
(	O
"Moved defense of lunch %1m from %1m to %1m.\n"	pointer
,	O
lunch	int
,	O
defense_point	pointer
,	O
pos2	int
)	O
;	O
return	O
pos2	int
;	O
}	O
}	O
}	O
return	O
defense_point	pointer
;	O
}	O
static	O
void	O
owl_make_domains	function
(	O
struct	O
local_owl_data	struct
*	O
owla	pointer
,	O
struct	O
local_owl_data	struct
*	O
owlb	pointer
)	O
{	O
struct	O
eye_data	struct
*	O
black_eye	array
=	O
NULL	O
;	O
struct	O
eye_data	struct
*	O
white_eye	array
=	O
NULL	O
;	O
current_owl_data	pointer
=	O
owla	pointer
;	O
other_owl_data	pointer
=	O
owlb	pointer
;	O
if	O
(	O
!	O
owla	pointer
->	O
lunches_are_current	int
)	O
owl_find_lunches	function
(	O
owla	pointer
)	O
;	O
if	O
(	O
owla	pointer
->	O
color	int
==	O
BLACK	int
)	O
black_eye	array
=	O
owla	pointer
->	O
my_eye	array
;	O
else	O
white_eye	array
=	O
owla	pointer
->	O
my_eye	array
;	O
if	O
(	O
owlb	pointer
)	O
{	O
gg_assert	O
(	O
owla	pointer
->	O
color	int
==	O
OTHER_COLOR	O
(	O
owlb	pointer
->	O
color	int
)	O
)	O
;	O
if	O
(	O
!	O
owlb	pointer
->	O
lunches_are_current	int
)	O
owl_find_lunches	function
(	O
owlb	pointer
)	O
;	O
if	O
(	O
owlb	pointer
->	O
color	int
==	O
BLACK	int
)	O
black_eye	array
=	O
owlb	pointer
->	O
my_eye	array
;	O
else	O
white_eye	array
=	O
owlb	pointer
->	O
my_eye	array
;	O
}	O
make_domains	function
(	O
black_eye	array
,	O
white_eye	array
,	O
1	int
)	O
;	O
}	O
int	O
owl_lively	function
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
int	O
lunch	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
origin	int
=	O
find_origin	function
(	O
pos	int
)	O
;	O
if	O
(	O
other_owl_data	pointer
)	O
{	O
if	O
(	O
include_semeai_worms_in_eyespace	int
&&	O
other_owl_data	pointer
->	O
goal	pointer
[	O
pos	int
]	O
)	O
return	O
0	int
;	O
if	O
(	O
other_owl_data	pointer
->	O
goal	pointer
[	O
pos	int
]	O
&&	O
!	O
semeai_trust_tactical_attack	function
(	O
pos	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
lunch	int
=	O
0	int
;	O
lunch	int
<	O
MAX_LUNCHES	int
;	O
lunch	int
++	O
)	O
if	O
(	O
other_owl_data	pointer
->	O
lunch	int
[	O
lunch	int
]	O
==	O
origin	int
&&	O
other_owl_data	pointer
->	O
lunch_defense_point	array
[	O
lunch	int
]	O
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
current_owl_data	pointer
->	O
inessential	int
[	O
origin	int
]	O
)	O
return	O
0	int
;	O
for	O
(	O
lunch	int
=	O
0	int
;	O
lunch	int
<	O
MAX_LUNCHES	int
;	O
lunch	int
++	O
)	O
if	O
(	O
current_owl_data	pointer
->	O
lunch	int
[	O
lunch	int
]	O
==	O
origin	int
&&	O
current_owl_data	pointer
->	O
lunch_defense_point	array
[	O
lunch	int
]	O
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
owl_safe_move	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
acode	int
,	O
safe	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"owl_safe_move"	pointer
,	O
0	int
)	O
)	O
{	O
acode	int
=	O
attack	function
(	O
move	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
WIN	int
)	O
safe	int
=	O
1	int
;	O
else	O
safe	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
current_owl_data	pointer
->	O
safe_move_cache	array
[	O
move	pointer
]	O
=	O
safe	int
+	O
1	int
;	O
return	O
safe	int
;	O
}	O
int	O
owl_substantial	function
(	O
int	O
str	int
)	O
{	O
int	O
k	int
;	O
int	O
libs	pointer
[	O
MAX_SUBSTANTIAL_LIBS	int
+	O
1	int
]	O
;	O
int	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
MAX_SUBSTANTIAL_LIBS	int
+	O
1	int
,	O
libs	pointer
)	O
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
result	int
;	O
double	O
start	double
=	O
0.0	int
;	O
struct	O
local_owl_data	struct
*	O
owl	int
;	O
int	O
num_moves	int
=	O
0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	int
)	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
reduced_init_owl	function
(	O
&	O
owl	int
,	O
1	int
)	O
;	O
owl	int
->	O
color	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
;	O
local_owl_node_counter	int
=	O
0	int
;	O
if	O
(	O
countstones	function
(	O
str	int
)	O
>	O
6	int
)	O
return	O
1	int
;	O
if	O
(	O
liberties	pointer
>	O
MAX_SUBSTANTIAL_LIBS	int
)	O
return	O
0	int
;	O
memset	function
(	O
owl	int
->	O
goal	pointer
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
goal	pointer
)	O
)	O
;	O
{	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array
;	O
adj	array
=	O
chainlinks	function
(	O
str	int
,	O
adjs	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array
;	O
k	int
++	O
)	O
{	O
if	O
(	O
dragon	int
[	O
adjs	array
[	O
k	int
]	O
]	O
.	O
status	enum
==	O
ALIVE	int
)	O
return	O
1	int
;	O
mark_dragon	function
(	O
adjs	array
[	O
k	int
]	O
,	O
owl	int
->	O
goal	pointer
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
search_persistent_owl_cache	function
(	O
OWL_SUBSTANTIAL	int
,	O
str	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
owl	int
->	O
color	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
)	O
increase_depth_values	function
(	O
)	O
;	O
owl	int
->	O
goal	pointer
[	O
libs	pointer
[	O
k	int
]	O
]	O
=	O
1	int
;	O
num_moves	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
k	int
<	O
liberties	pointer
-	O
1	int
&&	O
trymove	function
(	O
libs	pointer
[	O
k	int
+	O
1	int
]	O
,	O
owl	int
->	O
color	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
)	O
increase_depth_values	function
(	O
)	O
;	O
owl	int
->	O
goal	pointer
[	O
libs	pointer
[	O
k	int
+	O
1	int
]	O
]	O
=	O
1	int
;	O
libs	pointer
[	O
k	int
+	O
1	int
]	O
=	O
libs	pointer
[	O
k	int
]	O
;	O
num_moves	int
++	O
;	O
}	O
else	O
{	O
while	O
(	O
num_moves	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
)	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
}	O
memcpy	function
(	O
owl	int
->	O
cumulative_goal	array
,	O
owl	int
->	O
goal	pointer
,	O
BOARDMAX	O
)	O
;	O
compute_owl_escape_values	function
(	O
owl	int
)	O
;	O
owl_mark_boundary	function
(	O
owl	int
)	O
;	O
owl	int
->	O
lunches_are_current	int
=	O
0	int
;	O
if	O
(	O
do_owl_attack	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
)	O
result	int
=	O
0	int
;	O
else	O
result	int
=	O
1	int
;	O
while	O
(	O
num_moves	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
)	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"owl_substantial %1m, result %d (%d, %d nodes, %f seconds)\n"	pointer
,	O
str	int
,	O
result	int
,	O
local_owl_node_counter	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
store_persistent_owl_cache	function
(	O
OWL_SUBSTANTIAL	int
,	O
str	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	pointer
,	O
owl	int
->	O
color	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
one_two_point	function
(	O
int	O
pos	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
if	O
(	O
(	O
i	int
==	O
0	int
||	O
i	int
==	O
board_size	int
-	O
1	int
||	O
j	int
==	O
0	int
||	O
j	int
==	O
board_size	int
-	O
1	int
)	O
&&	O
(	O
i	int
==	O
1	int
||	O
i	int
==	O
board_size	int
-	O
2	int
||	O
j	int
==	O
1	int
||	O
j	int
==	O
board_size	int
-	O
2	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
sniff_lunch	function
(	O
int	O
lunch	int
,	O
int	O
*	O
min	pointer
,	O
int	O
*	O
probable	pointer
,	O
int	O
*	O
max	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
lunch	int
]	O
)	O
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
int	O
r	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
lunch	int
]	O
)	O
,	O
lunch	int
)	O
;	O
if	O
(	O
owl	int
->	O
boundary	array
[	O
lunch	int
]	O
==	O
2	int
)	O
{	O
*	O
min	pointer
=	O
2	int
;	O
*	O
probable	pointer
=	O
2	int
;	O
*	O
max	pointer
=	O
2	int
;	O
return	O
;	O
}	O
liberties	pointer
=	O
findlib	function
(	O
lunch	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
if	O
(	O
owl	int
->	O
escape_values	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
>	O
0	int
&&	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
r	int
]	O
,	O
other	int
)	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
owl	int
->	O
goal	pointer
[	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
8	int
)	O
{	O
*	O
min	pointer
=	O
2	int
;	O
*	O
probable	pointer
=	O
2	int
;	O
*	O
max	pointer
=	O
2	int
;	O
return	O
;	O
}	O
}	O
}	O
estimate_lunch_eye_value	function
(	O
lunch	int
,	O
min	pointer
,	O
probable	pointer
,	O
max	pointer
,	O
1	int
)	O
;	O
if	O
(	O
*	O
min	pointer
<	O
2	int
)	O
{	O
int	O
bonus	int
=	O
estimate_lunch_half_eye_bonus	function
(	O
lunch	int
,	O
owl	int
->	O
half_eye	array
)	O
;	O
*	O
min	pointer
+=	O
bonus	int
/	O
2	int
;	O
*	O
probable	pointer
+=	O
bonus	int
;	O
*	O
max	pointer
+=	O
(	O
bonus	int
+	O
1	int
)	O
/	O
2	int
;	O
}	O
if	O
(	O
*	O
probable	pointer
<	O
2	int
)	O
eat_lunch_escape_bonus	function
(	O
lunch	int
,	O
min	pointer
,	O
probable	pointer
,	O
max	pointer
,	O
owl	int
)	O
;	O
}	O
static	O
int	O
estimate_lunch_half_eye_bonus	function
(	O
int	O
lunch	int
,	O
struct	O
half_eye_data	struct
half_eye	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
stones	pointer
[	O
10	int
]	O
;	O
int	O
k	int
;	O
int	O
size	int
=	O
findstones	function
(	O
lunch	int
,	O
10	int
,	O
stones	pointer
)	O
;	O
int	O
half_eyes	int
=	O
0	int
;	O
ASSERT1	O
(	O
size	int
<	O
10	int
,	O
lunch	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
size	int
;	O
k	int
++	O
)	O
{	O
int	O
stone	int
=	O
stones	pointer
[	O
k	int
]	O
;	O
int	O
d	int
;	O
for	O
(	O
d	int
=	O
4	int
;	O
d	int
<	O
8	int
;	O
d	int
++	O
)	O
{	O
int	O
pos	int
=	O
stone	int
+	O
delta	array
[	O
d	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
is_halfeye	function
(	O
half_eye	array
,	O
pos	int
)	O
||	O
is_false_eye	function
(	O
half_eye	array
,	O
pos	int
)	O
)	O
)	O
half_eyes	int
++	O
;	O
}	O
}	O
return	O
half_eyes	int
;	O
}	O
void	O
estimate_lunch_eye_value	function
(	O
int	O
lunch	int
,	O
int	O
*	O
min	pointer
,	O
int	O
*	O
probable	pointer
,	O
int	O
*	O
max	pointer
,	O
int	O
appreciate_one_two_lunches	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
lunch	int
]	O
)	O
;	O
int	O
size	int
=	O
countstones	function
(	O
lunch	int
)	O
;	O
if	O
(	O
size	int
>	O
6	int
)	O
{	O
*	O
min	pointer
=	O
2	int
;	O
*	O
probable	pointer
=	O
2	int
;	O
*	O
max	pointer
=	O
2	int
;	O
}	O
else	O
if	O
(	O
size	int
>	O
4	int
)	O
{	O
*	O
min	pointer
=	O
1	int
;	O
*	O
probable	pointer
=	O
2	int
;	O
*	O
max	pointer
=	O
2	int
;	O
}	O
else	O
if	O
(	O
size	int
>	O
2	int
)	O
{	O
*	O
min	pointer
=	O
0	int
;	O
*	O
probable	pointer
=	O
1	int
;	O
*	O
max	pointer
=	O
2	int
;	O
}	O
else	O
if	O
(	O
size	int
==	O
2	int
)	O
{	O
int	O
stones	pointer
[	O
2	int
]	O
;	O
findstones	function
(	O
lunch	int
,	O
2	int
,	O
stones	pointer
)	O
;	O
if	O
(	O
(	O
obvious_false_eye	function
(	O
stones	pointer
[	O
0	int
]	O
,	O
other	int
)	O
||	O
obvious_false_eye	function
(	O
stones	pointer
[	O
1	int
]	O
,	O
other	int
)	O
)	O
&&	O
(	O
!	O
appreciate_one_two_lunches	int
||	O
!	O
(	O
one_two_point	function
(	O
stones	pointer
[	O
0	int
]	O
)	O
||	O
one_two_point	function
(	O
stones	pointer
[	O
1	int
]	O
)	O
)	O
)	O
)	O
{	O
*	O
min	pointer
=	O
0	int
;	O
*	O
probable	pointer
=	O
0	int
;	O
*	O
max	pointer
=	O
0	int
;	O
}	O
else	O
{	O
*	O
min	pointer
=	O
0	int
;	O
*	O
probable	pointer
=	O
1	int
;	O
*	O
max	pointer
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
size	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
obvious_false_eye	function
(	O
lunch	int
,	O
other	int
)	O
)	O
{	O
*	O
min	pointer
=	O
0	int
;	O
*	O
probable	pointer
=	O
1	int
;	O
*	O
max	pointer
=	O
1	int
;	O
}	O
else	O
{	O
*	O
min	pointer
=	O
0	int
;	O
*	O
probable	pointer
=	O
0	int
;	O
*	O
max	pointer
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
eat_lunch_escape_bonus	function
(	O
int	O
lunch	int
,	O
int	O
*	O
min	pointer
,	O
int	O
*	O
probable	pointer
,	O
int	O
*	O
max	pointer
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
adjacent	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors	int
;	O
int	O
adjoins	int
=	O
0	int
;	O
int	O
n	int
;	O
UNUSED	O
(	O
min	pointer
)	O
;	O
if	O
(	O
is_ko_point	function
(	O
lunch	int
)	O
)	O
return	O
;	O
neighbors	int
=	O
chainlinks	function
(	O
lunch	int
,	O
adjacent	array
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
neighbors	int
;	O
n	int
++	O
)	O
adjoins	int
|=	O
!	O
owl	int
->	O
goal	pointer
[	O
adjacent	array
[	O
n	int
]	O
]	O
;	O
if	O
(	O
adjoins	int
)	O
{	O
int	O
before	int
,	O
after	int
;	O
before	int
=	O
dragon_escape	function
(	O
owl	int
->	O
goal	pointer
,	O
owl	int
->	O
color	int
,	O
owl	int
->	O
escape_values	array
)	O
;	O
if	O
(	O
before	int
<	O
5	int
)	O
{	O
signed	O
char	O
new_goal	array
[	O
BOARDMAX	O
]	O
;	O
memcpy	function
(	O
new_goal	array
,	O
owl	int
->	O
goal	pointer
,	O
sizeof	O
(	O
new_goal	array
)	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
neighbors	int
;	O
n	int
++	O
)	O
if	O
(	O
!	O
owl	int
->	O
goal	pointer
[	O
adjacent	array
[	O
n	int
]	O
]	O
)	O
mark_string	function
(	O
adjacent	array
[	O
n	int
]	O
,	O
new_goal	array
,	O
2	int
)	O
;	O
after	int
=	O
dragon_escape	function
(	O
new_goal	array
,	O
owl	int
->	O
color	int
,	O
owl	int
->	O
escape_values	array
)	O
;	O
if	O
(	O
after	int
-	O
before	int
>=	O
3	int
)	O
{	O
if	O
(	O
after	int
>=	O
8	int
||	O
(	O
before	int
==	O
0	int
&&	O
after	int
>=	O
5	int
)	O
)	O
{	O
*	O
probable	pointer
=	O
2	int
;	O
*	O
max	pointer
=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
max	pointer
<	O
2	int
)	O
(	O
*	O
max	pointer
)	O
++	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
select_new_goal_origin	function
(	O
int	O
origin	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
owl	int
->	O
color	int
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
==	O
1	int
)	O
return	O
find_origin	function
(	O
pos	int
)	O
;	O
return	O
origin	int
;	O
}	O
int	O
owl_topological_eye	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
float	O
value	pointer
;	O
UNUSED	O
(	O
color	int
)	O
;	O
value	pointer
=	O
current_owl_data	pointer
->	O
half_eye	array
[	O
pos	int
]	O
.	O
value	pointer
;	O
if	O
(	O
value	pointer
>	O
2.0	int
&&	O
value	pointer
<	O
4.0	int
)	O
return	O
3	int
;	O
else	O
if	O
(	O
value	pointer
<=	O
2.0	int
)	O
return	O
(	O
int	O
)	O
(	O
value	pointer
+	O
0.99	int
)	O
;	O
else	O
return	O
(	O
int	O
)	O
value	pointer
;	O
}	O
int	O
vital_chain	function
(	O
int	O
pos	int
)	O
{	O
int	O
min	pointer
;	O
int	O
probable	pointer
;	O
int	O
max	pointer
;	O
sniff_lunch	function
(	O
pos	int
,	O
&	O
min	pointer
,	O
&	O
probable	pointer
,	O
&	O
max	pointer
,	O
current_owl_data	pointer
)	O
;	O
return	O
max	pointer
;	O
}	O
static	O
void	O
compute_owl_escape_values	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
int	O
pos	int
;	O
int	O
m	int
,	O
n	int
;	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
get_lively_stones	function
(	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
,	O
safe_stones	array
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
compute_escape_influence	function
(	O
owl	int
->	O
color	int
,	O
safe_stones	array
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
->	O
escape_values	array
)	O
;	O
DEBUG	O
(	O
DEBUG_ESCAPE	int
,	O
"Owl escape values:\n"	pointer
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
color	int
==	O
owl	int
->	O
color	int
&&	O
!	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
owl	int
->	O
escape_values	array
[	O
pos	int
]	O
=	O
6	int
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	function
==	O
UNKNOWN	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
moyo_size	int
>	O
5	int
)	O
owl	int
->	O
escape_values	array
[	O
pos	int
]	O
=	O
4	int
;	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
escape_route	float
>	O
5	int
)	O
{	O
if	O
(	O
mx	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
)	O
owl	int
->	O
escape_values	array
[	O
pos	int
]	O
=	O
owl	int
->	O
escape_values	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
;	O
else	O
{	O
int	O
pos2	int
;	O
signed	O
char	O
escape_values	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
dragon_stones	array
[	O
BOARDMAX	O
]	O
;	O
compute_escape_influence	function
(	O
owl	int
->	O
color	int
,	O
safe_stones	array
,	O
owl	int
->	O
goal	pointer
,	O
NULL	O
,	O
escape_values	array
)	O
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
dragon_stones	array
[	O
pos2	int
]	O
=	O
is_same_dragon	function
(	O
pos2	int
,	O
pos	int
)	O
;	O
}	O
if	O
(	O
dragon_escape	function
(	O
dragon_stones	array
,	O
owl	int
->	O
color	int
,	O
escape_values	array
)	O
>	O
5	int
)	O
owl	int
->	O
escape_values	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
4	int
;	O
mx	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
}	O
DEBUG	O
(	O
DEBUG_ESCAPE	int
,	O
"%o%d"	pointer
,	O
owl	int
->	O
escape_values	array
[	O
pos	int
]	O
)	O
;	O
}	O
DEBUG	O
(	O
DEBUG_ESCAPE	int
,	O
"%o\n"	pointer
)	O
;	O
}	O
}	O
int	O
owl_escape_value	function
(	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
current_owl_data	pointer
->	O
goal	pointer
[	O
pos	int
]	O
)	O
return	O
-	O
10	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
current_owl_data	pointer
->	O
goal	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
return	O
-	O
10	int
;	O
return	O
current_owl_data	pointer
->	O
escape_values	array
[	O
pos	int
]	O
;	O
}	O
int	O
owl_goal_dragon	function
(	O
int	O
pos	int
)	O
{	O
return	O
current_owl_data	pointer
->	O
goal	pointer
[	O
pos	int
]	O
!=	O
0	int
;	O
}	O
int	O
owl_eyespace	function
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
return	O
(	O
ON_BOARD	O
(	O
origin	int
)	O
&&	O
(	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
color	int
==	O
current_owl_data	pointer
->	O
color	int
)	O
&&	O
max_eyes	function
(	O
&	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
value	pointer
)	O
>	O
0	int
)	O
;	O
}	O
int	O
owl_big_eyespace	function
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
return	O
(	O
ON_BOARD	O
(	O
origin	int
)	O
&&	O
(	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
color	int
==	O
current_owl_data	pointer
->	O
color	int
)	O
&&	O
max_eyes	function
(	O
&	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
value	pointer
)	O
>=	O
2	int
)	O
;	O
}	O
int	O
owl_mineye	function
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
origin	int
)	O
||	O
(	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
color	int
!=	O
current_owl_data	pointer
->	O
color	int
)	O
)	O
return	O
0	int
;	O
return	O
min_eyes	function
(	O
&	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
value	pointer
)	O
;	O
}	O
int	O
owl_maxeye	function
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
origin	int
)	O
||	O
(	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
color	int
!=	O
current_owl_data	pointer
->	O
color	int
)	O
)	O
return	O
0	int
;	O
return	O
max_eyes	function
(	O
&	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
value	pointer
)	O
;	O
}	O
int	O
owl_proper_eye	function
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
return	O
(	O
(	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
current_owl_data	pointer
->	O
color	int
)	O
&&	O
!	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
marginal	char
)	O
;	O
}	O
int	O
owl_eye_size	function
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	pointer
->	O
my_eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
return	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
esize	int
-	O
current_owl_data	pointer
->	O
my_eye	array
[	O
origin	int
]	O
.	O
msize	int
;	O
}	O
int	O
owl_lunch	function
(	O
int	O
str	int
)	O
{	O
int	O
k	int
;	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
current_owl_data	pointer
->	O
lunches_are_current	int
,	O
str	int
)	O
;	O
origin	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
current_owl_data	pointer
->	O
lunch	int
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
current_owl_data	pointer
->	O
lunch	int
[	O
k	int
]	O
==	O
origin	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
owl_strong_dragon	function
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
,	O
pos	int
)	O
;	O
return	O
(	O
!	O
current_owl_data	pointer
->	O
goal	pointer
[	O
pos	int
]	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
color	int
==	O
board	pointer
[	O
pos	int
]	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
;	O
}	O
static	O
int	O
owl_escape_route	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
)	O
{	O
signed	O
char	O
modified_escape	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
memcpy	function
(	O
modified_escape	array
,	O
owl	int
->	O
escape_values	array
,	O
sizeof	O
(	O
modified_escape	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
owl	int
->	O
cumulative_goal	array
[	O
pos	int
]	O
)	O
modified_escape	array
[	O
pos	int
]	O
=	O
0	int
;	O
return	O
dragon_escape	function
(	O
owl	int
->	O
goal	pointer
,	O
owl	int
->	O
color	int
,	O
modified_escape	array
)	O
;	O
}	O
static	O
void	O
reduced_init_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
,	O
int	O
at_bottom_of_stack	int
)	O
{	O
if	O
(	O
at_bottom_of_stack	int
)	O
owl_stack_pointer	int
=	O
0	int
;	O
else	O
owl_stack_pointer	int
++	O
;	O
check_owl_stack_size	function
(	O
)	O
;	O
*	O
owl	int
=	O
owl_stack	array
[	O
owl_stack_pointer	int
]	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
*	O
owl	int
,	O
sizeof	O
(	O
struct	O
local_owl_data	struct
)	O
)	O
;	O
}	O
static	O
void	O
init_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
int	O
move	pointer
,	O
int	O
at_bottom_of_stack	int
,	O
int	O
new_dragons	array
[	O
BOARDMAX	O
]	O
)	O
{	O
reduced_init_owl	function
(	O
owl	int
,	O
at_bottom_of_stack	int
)	O
;	O
local_owl_node_counter	int
=	O
0	int
;	O
(	O
*	O
owl	int
)	O
->	O
lunches_are_current	int
=	O
0	int
;	O
owl_mark_dragon	function
(	O
target1	int
,	O
target2	int
,	O
*	O
owl	int
,	O
new_dragons	array
)	O
;	O
if	O
(	O
move	pointer
!=	O
NO_MOVE	O
)	O
owl_update_goal	function
(	O
move	pointer
,	O
SAME_DRAGON_MAYBE_CONNECTED	int
,	O
NO_MOVE	O
,	O
*	O
owl	int
,	O
0	int
,	O
NULL	O
)	O
;	O
compute_owl_escape_values	function
(	O
*	O
owl	int
)	O
;	O
}	O
static	O
void	O
check_owl_stack_size	function
(	O
void	O
)	O
{	O
while	O
(	O
owl_stack_size	int
<=	O
owl_stack_pointer	int
)	O
{	O
owl_stack	array
[	O
owl_stack_size	int
]	O
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
owl_stack	array
[	O
0	int
]	O
)	O
)	O
;	O
gg_assert	O
(	O
owl_stack	array
[	O
owl_stack_size	int
]	O
!=	O
NULL	O
)	O
;	O
owl_stack_size	int
++	O
;	O
}	O
}	O
static	O
void	O
do_push_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
)	O
{	O
struct	O
local_owl_data	struct
*	O
new_owl	pointer
=	O
owl_stack	array
[	O
owl_stack_pointer	int
]	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
new_owl	pointer
,	O
sizeof	O
(	O
struct	O
local_owl_data	struct
)	O
)	O
;	O
memcpy	function
(	O
new_owl	pointer
->	O
goal	pointer
,	O
(	O
*	O
owl	int
)	O
->	O
goal	pointer
,	O
sizeof	O
(	O
new_owl	pointer
->	O
goal	pointer
)	O
)	O
;	O
memcpy	function
(	O
new_owl	pointer
->	O
cumulative_goal	array
,	O
(	O
*	O
owl	int
)	O
->	O
cumulative_goal	array
,	O
sizeof	O
(	O
new_owl	pointer
->	O
cumulative_goal	array
)	O
)	O
;	O
memcpy	function
(	O
new_owl	pointer
->	O
boundary	array
,	O
(	O
*	O
owl	int
)	O
->	O
boundary	array
,	O
sizeof	O
(	O
new_owl	pointer
->	O
boundary	array
)	O
)	O
;	O
memcpy	function
(	O
new_owl	pointer
->	O
neighbors	int
,	O
(	O
*	O
owl	int
)	O
->	O
neighbors	int
,	O
sizeof	O
(	O
new_owl	pointer
->	O
neighbors	int
)	O
)	O
;	O
memcpy	function
(	O
new_owl	pointer
->	O
escape_values	array
,	O
(	O
*	O
owl	int
)	O
->	O
escape_values	array
,	O
sizeof	O
(	O
new_owl	pointer
->	O
escape_values	array
)	O
)	O
;	O
new_owl	pointer
->	O
color	int
=	O
(	O
*	O
owl	int
)	O
->	O
color	int
;	O
new_owl	pointer
->	O
lunches_are_current	int
=	O
0	int
;	O
new_owl	pointer
->	O
restore_from	pointer
=	O
*	O
owl	int
;	O
*	O
owl	int
=	O
new_owl	pointer
;	O
}	O
static	O
void	O
push_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
)	O
{	O
owl_stack_pointer	int
++	O
;	O
check_owl_stack_size	function
(	O
)	O
;	O
do_push_owl	function
(	O
owl	int
)	O
;	O
}	O
static	O
void	O
pop_owl	function
(	O
struct	O
local_owl_data	struct
*	O
*	O
owl	int
)	O
{	O
*	O
owl	int
=	O
(	O
*	O
owl	int
)	O
->	O
restore_from	pointer
;	O
owl_stack_pointer	int
--	O
;	O
}	O
static	O
int	O
list_goal_worms	function
(	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
goal_worm	array
[	O
MAX_GOAL_WORMS	int
]	O
)	O
{	O
int	O
pos	int
,	O
k	int
;	O
int	O
w	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_GOAL_WORMS	int
;	O
k	int
++	O
)	O
goal_worm	array
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
&&	O
w	int
<	O
MAX_GOAL_WORMS	int
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
board	pointer
[	O
pos	int
]	O
&&	O
owl	int
->	O
goal	pointer
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
int	O
origin	int
=	O
find_origin	function
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
w	int
;	O
k	int
++	O
)	O
if	O
(	O
goal_worm	array
[	O
k	int
]	O
==	O
origin	int
)	O
break	O
;	O
if	O
(	O
k	int
==	O
w	int
)	O
goal_worm	array
[	O
w	int
++	O
]	O
=	O
pos	int
;	O
}	O
}	O
if	O
(	O
1	int
&&	O
(	O
w	int
>	O
0	int
)	O
&&	O
(	O
w	int
<	O
MAX_GOAL_WORMS	int
)	O
)	O
{	O
pos	int
=	O
goal_worm	array
[	O
0	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
&&	O
w	int
<	O
MAX_GOAL_WORMS	int
;	O
k	int
++	O
)	O
{	O
int	O
ii	int
;	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
;	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
color	int
!=	O
owl	int
->	O
color	int
)	O
continue	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
&&	O
w	int
<	O
MAX_GOAL_WORMS	int
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
board	pointer
[	O
ii	int
]	O
&&	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
==	O
ii	int
&&	O
worm	array
[	O
ii	int
]	O
.	O
size	int
>=	O
3	int
&&	O
dragon	int
[	O
ii	int
]	O
.	O
id	int
==	O
d	int
)	O
goal_worm	array
[	O
w	int
++	O
]	O
=	O
ii	int
;	O
}	O
}	O
return	O
w	int
;	O
}	O
static	O
void	O
prepare_goal_list	function
(	O
int	O
str	int
,	O
struct	O
local_owl_data	struct
*	O
owl	int
,	O
int	O
list	pointer
[	O
MAX_GOAL_WORMS	int
]	O
,	O
int	O
*	O
flag	pointer
,	O
int	O
*	O
kworm	int
,	O
int	O
do_list	int
)	O
{	O
gg_assert	O
(	O
flag	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
kworm	int
)	O
{	O
if	O
(	O
do_list	int
)	O
list_goal_worms	function
(	O
owl	int
,	O
list	pointer
)	O
;	O
memcpy	function
(	O
dragon_goal_worms	array
[	O
dragon	int
[	O
str	int
]	O
.	O
id	int
]	O
,	O
list	pointer
,	O
sizeof	O
(	O
dragon_goal_worms	array
[	O
dragon	int
[	O
str	int
]	O
.	O
id	int
]	O
)	O
)	O
;	O
*	O
flag	pointer
=	O
1	int
;	O
}	O
else	O
*	O
flag	pointer
=	O
0	int
;	O
}	O
static	O
void	O
finish_goal_list	function
(	O
int	O
*	O
flag	pointer
,	O
int	O
*	O
wpos	pointer
,	O
int	O
list	pointer
[	O
MAX_GOAL_WORMS	int
]	O
,	O
int	O
index	function
)	O
{	O
gg_assert	O
(	O
flag	pointer
!=	O
NULL	O
)	O
;	O
gg_assert	O
(	O
wpos	pointer
!=	O
NULL	O
)	O
;	O
*	O
flag	pointer
=	O
0	int
;	O
if	O
(	O
index	function
==	O
MAX_GOAL_WORMS	int
)	O
*	O
wpos	pointer
=	O
NO_MOVE	O
;	O
else	O
*	O
wpos	pointer
=	O
list	pointer
[	O
index	function
]	O
;	O
}	O
void	O
reset_owl_node_counter	function
(	O
)	O
{	O
global_owl_node_counter	int
=	O
0	int
;	O
}	O
int	O
get_owl_node_counter	function
(	O
)	O
{	O
return	O
global_owl_node_counter	int
;	O
}	O
