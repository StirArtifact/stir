static	O
int	O
CheckPid	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
ExecCreate	function
__P	O
(	O
(	O
struct	O
msg	struct
*	O
)	O
)	O
;	O
static	O
void	O
DoCommandMsg	function
__P	O
(	O
(	O
struct	O
msg	struct
*	O
)	O
)	O
;	O
static	O
void	O
FinishAttach	function
__P	O
(	O
(	O
struct	O
msg	struct
*	O
)	O
)	O
;	O
static	O
void	O
FinishDetach	function
__P	O
(	O
(	O
struct	O
msg	struct
*	O
)	O
)	O
;	O
static	O
void	O
AskPassword	function
__P	O
(	O
(	O
struct	O
msg	struct
*	O
)	O
)	O
;	O
extern	O
char	O
*	O
RcFileName	pointer
,	O
*	O
extra_incap	pointer
,	O
*	O
extra_outcap	pointer
;	O
extern	O
int	O
ServerSocket	int
,	O
real_uid	int
,	O
real_gid	int
,	O
eff_uid	int
,	O
eff_gid	int
;	O
extern	O
int	O
dflag	int
,	O
iflag	int
,	O
rflag	int
,	O
lsflag	int
,	O
quietflag	int
,	O
wipeflag	int
,	O
xflag	int
;	O
extern	O
int	O
queryflag	int
;	O
extern	O
char	O
*	O
attach_tty	pointer
,	O
*	O
LoginName	pointer
,	O
HostName	array
[	O
]	O
;	O
extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
,	O
*	O
*	O
wtab	pointer
,	O
*	O
console_window	pointer
,	O
*	O
windows	pointer
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
layout	struct
*	O
layout_attach	pointer
,	O
*	O
layout_last	pointer
,	O
layout_last_marker	struct
;	O
extern	O
struct	O
NewWindow	struct
nwin_undef	struct
;	O
extern	O
char	O
*	O
multi	pointer
;	O
extern	O
int	O
maxwin	int
;	O
extern	O
char	O
*	O
getenv	function
(	O
)	O
;	O
extern	O
char	O
SockPath	array
[	O
]	O
;	O
extern	O
struct	O
event	struct
serv_read	struct
;	O
extern	O
char	O
*	O
rc_name	pointer
;	O
extern	O
struct	O
comm	struct
comms	array
[	O
]	O
;	O
int	O
FindSocket	function
(	O
fdp	pointer
,	O
nfoundp	pointer
,	O
notherp	pointer
,	O
match	pointer
,	O
is_sock	pointer
)	O
int	O
*	O
fdp	pointer
;	O
int	O
*	O
nfoundp	pointer
,	O
*	O
notherp	pointer
;	O
char	O
*	O
match	pointer
;	O
bool	bool
*	O
is_sock	pointer
;	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
struct	O
stat	struct
st	struct
;	O
int	O
mode	struct
;	O
int	O
sdirlen	int
;	O
int	O
matchlen	int
=	O
0	int
;	O
char	O
*	O
name	pointer
,	O
*	O
n	pointer
;	O
int	O
firsts	int
=	O
-	O
1	int
,	O
sockfd	int
;	O
char	O
*	O
firstn	pointer
=	O
NULL	O
;	O
int	O
nfound	int
=	O
0	int
,	O
ngood	int
=	O
0	int
,	O
ndead	int
=	O
0	int
,	O
nwipe	int
=	O
0	int
,	O
npriv	int
=	O
0	int
;	O
int	O
nperfect	int
=	O
0	int
;	O
struct	O
sent	struct
{	O
struct	O
sent	struct
*	O
next	pointer
;	O
int	O
mode	struct
;	O
char	O
*	O
name	pointer
;	O
}	O
*	O
slist	pointer
,	O
*	O
*	O
slisttail	pointer
,	O
*	O
sent	struct
,	O
*	O
nsent	pointer
;	O
if	O
(	O
match	pointer
)	O
{	O
matchlen	int
=	O
strlen	function
(	O
match	pointer
)	O
;	O
if	O
(	O
matchlen	int
>	O
NAME_MAX	int
)	O
matchlen	int
=	O
NAME_MAX	int
;	O
}	O
sdirlen	int
=	O
strlen	function
(	O
SockPath	array
)	O
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
if	O
(	O
(	O
dirp	pointer
=	O
opendir	function
(	O
SockPath	array
)	O
)	O
==	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"Cannot opendir %s"	pointer
,	O
SockPath	array
)	O
;	O
slist	pointer
=	O
0	int
;	O
slisttail	pointer
=	O
&	O
slist	pointer
;	O
while	O
(	O
(	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
)	O
{	O
int	O
cmatch	int
=	O
0	int
;	O
name	pointer
=	O
dp	pointer
->	O
d_name	array
;	O
debug1	O
(	O
"- %s\n"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
*	O
name	pointer
==	O
0	int
||	O
*	O
name	pointer
==	O
'.'	O
||	O
strlen	function
(	O
name	pointer
)	O
>	O
2	int
*	O
MAXSTR	int
)	O
continue	O
;	O
if	O
(	O
matchlen	int
)	O
{	O
n	pointer
=	O
name	pointer
;	O
if	O
(	O
(	O
*	O
match	pointer
<=	O
'0'	O
||	O
*	O
match	pointer
>	O
'9'	O
)	O
&&	O
(	O
*	O
n	pointer
>	O
'0'	O
&&	O
*	O
n	pointer
<=	O
'9'	O
)	O
)	O
{	O
while	O
(	O
*	O
n	pointer
>=	O
'0'	O
&&	O
*	O
n	pointer
<=	O
'9'	O
)	O
n	pointer
++	O
;	O
if	O
(	O
*	O
n	pointer
==	O
'.'	O
)	O
n	pointer
++	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
match	pointer
,	O
"tty"	pointer
,	O
3	int
)	O
&&	O
strncmp	function
(	O
n	pointer
,	O
"tty"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
n	pointer
+=	O
3	int
;	O
if	O
(	O
strncmp	function
(	O
match	pointer
,	O
n	pointer
,	O
matchlen	int
)	O
)	O
{	O
if	O
(	O
n	pointer
==	O
name	pointer
&&	O
*	O
match	pointer
>	O
'0'	O
&&	O
*	O
match	pointer
<=	O
'9'	O
)	O
{	O
while	O
(	O
*	O
n	pointer
>=	O
'0'	O
&&	O
*	O
n	pointer
<=	O
'9'	O
)	O
n	pointer
++	O
;	O
if	O
(	O
*	O
n	pointer
==	O
'.'	O
)	O
n	pointer
++	O
;	O
if	O
(	O
strncmp	function
(	O
match	pointer
,	O
n	pointer
,	O
matchlen	int
)	O
)	O
continue	O
;	O
}	O
else	O
continue	O
;	O
}	O
else	O
cmatch	int
=	O
(	O
*	O
(	O
n	pointer
+	O
matchlen	int
)	O
==	O
0	int
)	O
;	O
debug1	O
(	O
"  -> matched %s\n"	pointer
,	O
match	pointer
)	O
;	O
}	O
sprintf	function
(	O
SockPath	array
+	O
sdirlen	int
,	O
"/%s"	pointer
,	O
name	pointer
)	O
;	O
debug1	O
(	O
"stat %s\n"	pointer
,	O
SockPath	array
)	O
;	O
errno	O
=	O
0	int
;	O
debug2	O
(	O
"uid = %d, gid = %d\n"	pointer
,	O
getuid	function
(	O
)	O
,	O
getgid	function
(	O
)	O
)	O
;	O
debug2	O
(	O
"euid = %d, egid = %d\n"	pointer
,	O
geteuid	function
(	O
)	O
,	O
getegid	function
(	O
)	O
)	O
;	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
st	struct
)	O
)	O
{	O
debug1	O
(	O
"errno = %d\n"	pointer
,	O
errno	O
)	O
;	O
continue	O
;	O
}	O
*	O
is_sock	pointer
=	O
S_ISSOCK	O
(	O
st	struct
.	O
st_mode	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
is_sock	pointer
)	O
&&	O
!	O
S_ISFIFO	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
continue	O
;	O
debug2	O
(	O
"st.st_uid = %d, real_uid = %d\n"	pointer
,	O
st	struct
.	O
st_uid	int
,	O
real_uid	int
)	O
;	O
if	O
(	O
(	O
int	O
)	O
st	struct
.	O
st_uid	int
!=	O
real_uid	int
)	O
continue	O
;	O
mode	struct
=	O
(	O
int	O
)	O
st	struct
.	O
st_mode	int
&	O
0777	int
;	O
debug1	O
(	O
"  has mode 0%03o\n"	pointer
,	O
mode	struct
)	O
;	O
if	O
(	O
multi	pointer
&&	O
(	O
(	O
mode	struct
&	O
0677	int
)	O
!=	O
0601	int
)	O
)	O
{	O
debug	O
(	O
"  is not a MULTI-USER session"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
multi	pointer
,	O
LoginName	pointer
)	O
)	O
{	O
debug	O
(	O
" and we are in a foreign directory.\n"	pointer
)	O
;	O
mode	struct
=	O
-	O
4	int
;	O
}	O
else	O
{	O
debug	O
(	O
", but it is our own session.\n"	pointer
)	O
;	O
}	O
}	O
debug	O
(	O
"  store it.\n"	pointer
)	O
;	O
if	O
(	O
(	O
sent	struct
=	O
(	O
struct	O
sent	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
sent	struct
)	O
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
sent	struct
->	O
next	pointer
=	O
0	int
;	O
sent	struct
->	O
name	pointer
=	O
SaveStr	function
(	O
name	pointer
)	O
;	O
sent	struct
->	O
mode	struct
=	O
mode	struct
;	O
*	O
slisttail	pointer
=	O
sent	struct
;	O
slisttail	pointer
=	O
&	O
sent	struct
->	O
next	pointer
;	O
nfound	int
++	O
;	O
sockfd	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
*	O
is_sock	pointer
)	O
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
if	O
(	O
sockfd	int
==	O
-	O
1	int
)	O
{	O
debug2	O
(	O
"  MakeClientSocket failed, unreachable? %d %d\n"	pointer
,	O
matchlen	int
,	O
wipeflag	int
)	O
;	O
sent	struct
->	O
mode	struct
=	O
-	O
3	int
;	O
ndead	int
++	O
;	O
sent	struct
->	O
mode	struct
=	O
-	O
1	int
;	O
if	O
(	O
wipeflag	int
)	O
{	O
if	O
(	O
unlink	function
(	O
SockPath	array
)	O
==	O
0	int
)	O
{	O
sent	struct
->	O
mode	struct
=	O
-	O
2	int
;	O
nwipe	int
++	O
;	O
}	O
}	O
continue	O
;	O
}	O
mode	struct
&=	O
0776	int
;	O
debug2	O
(	O
"  connecting: mode=%03o, rflag=%d, "	pointer
,	O
mode	struct
,	O
rflag	int
)	O
;	O
debug2	O
(	O
"xflag=%d, dflag=%d ?\n"	pointer
,	O
xflag	int
,	O
dflag	int
)	O
;	O
if	O
(	O
(	O
mode	struct
!=	O
0700	int
&&	O
mode	struct
!=	O
0600	int
)	O
||	O
(	O
dflag	int
&&	O
!	O
rflag	int
&&	O
!	O
xflag	int
&&	O
mode	struct
==	O
0600	int
)	O
||	O
(	O
!	O
dflag	int
&&	O
rflag	int
&&	O
mode	struct
==	O
0700	int
&&	O
!	O
xflag	int
)	O
||	O
(	O
!	O
dflag	int
&&	O
!	O
rflag	int
&&	O
!	O
xflag	int
)	O
)	O
{	O
close	function
(	O
sockfd	int
)	O
;	O
debug	O
(	O
"  no!\n"	pointer
)	O
;	O
npriv	int
++	O
;	O
continue	O
;	O
}	O
ngood	int
++	O
;	O
if	O
(	O
cmatch	int
)	O
nperfect	int
++	O
;	O
if	O
(	O
fdp	pointer
&&	O
(	O
firsts	int
==	O
-	O
1	int
||	O
(	O
cmatch	int
&&	O
nperfect	int
==	O
1	int
)	O
)	O
)	O
{	O
if	O
(	O
firsts	int
!=	O
-	O
1	int
)	O
close	function
(	O
firsts	int
)	O
;	O
firsts	int
=	O
sockfd	int
;	O
firstn	pointer
=	O
sent	struct
->	O
name	pointer
;	O
debug	O
(	O
"  taken.\n"	pointer
)	O
;	O
}	O
else	O
{	O
debug	O
(	O
"  discarded.\n"	pointer
)	O
;	O
close	function
(	O
sockfd	int
)	O
;	O
}	O
}	O
(	O
void	O
)	O
closedir	function
(	O
dirp	pointer
)	O
;	O
if	O
(	O
!	O
lsflag	int
&&	O
nperfect	int
==	O
1	int
)	O
ngood	int
=	O
nperfect	int
;	O
if	O
(	O
nfound	int
&&	O
(	O
lsflag	int
||	O
ngood	int
!=	O
1	int
)	O
&&	O
!	O
quietflag	int
)	O
{	O
switch	O
(	O
ngood	int
)	O
{	O
case	O
0	int
:	O
Msg	function
(	O
0	int
,	O
nfound	int
>	O
1	int
?	O
"There are screens on:"	pointer
:	O
"There is a screen on:"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
Msg	function
(	O
0	int
,	O
nfound	int
>	O
1	int
?	O
"There are several screens on:"	pointer
:	O
"There is a suitable screen on:"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
Msg	function
(	O
0	int
,	O
"There are several suitable screens on:"	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
sent	struct
=	O
slist	pointer
;	O
sent	struct
;	O
sent	struct
=	O
sent	struct
->	O
next	pointer
)	O
{	O
switch	O
(	O
sent	struct
->	O
mode	struct
)	O
{	O
case	O
0700	int
:	O
printf	function
(	O
"\t%s\t(Attached)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
0600	int
:	O
printf	function
(	O
"\t%s\t(Detached)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
0701	int
:	O
printf	function
(	O
"\t%s\t(Multi, attached)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
0601	int
:	O
printf	function
(	O
"\t%s\t(Multi, detached)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
-	O
1	int
:	O
printf	function
(	O
"\t%s\t(Dead ?%c?)\n"	pointer
,	O
sent	struct
->	O
name	pointer
,	O
'?'	O
)	O
;	O
break	O
;	O
case	O
-	O
2	int
:	O
printf	function
(	O
"\t%s\t(Removed)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
-	O
3	int
:	O
printf	function
(	O
"\t%s\t(Remote or dead)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
-	O
4	int
:	O
printf	function
(	O
"\t%s\t(Private)\n"	pointer
,	O
sent	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
ndead	int
&&	O
!	O
quietflag	int
)	O
{	O
char	O
*	O
m	union
=	O
"Remove dead screens with 'screen -wipe'."	pointer
;	O
if	O
(	O
wipeflag	int
)	O
Msg	function
(	O
0	int
,	O
"%d socket%s wiped out."	pointer
,	O
nwipe	int
,	O
nwipe	int
>	O
1	int
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
else	O
Msg	function
(	O
0	int
,	O
m	union
,	O
ndead	int
>	O
1	int
?	O
"s"	pointer
:	O
""	pointer
,	O
ndead	int
>	O
1	int
?	O
""	pointer
:	O
"es"	pointer
)	O
;	O
}	O
if	O
(	O
firsts	int
!=	O
-	O
1	int
)	O
{	O
sprintf	function
(	O
SockPath	array
+	O
sdirlen	int
,	O
"/%s"	pointer
,	O
firstn	pointer
)	O
;	O
*	O
fdp	pointer
=	O
firsts	int
;	O
}	O
else	O
SockPath	array
[	O
sdirlen	int
]	O
=	O
0	int
;	O
for	O
(	O
sent	struct
=	O
slist	pointer
;	O
sent	struct
;	O
sent	struct
=	O
nsent	pointer
)	O
{	O
nsent	pointer
=	O
sent	struct
->	O
next	pointer
;	O
free	function
(	O
sent	struct
->	O
name	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
sent	struct
)	O
;	O
}	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
if	O
(	O
notherp	pointer
)	O
*	O
notherp	pointer
=	O
npriv	int
;	O
if	O
(	O
nfoundp	pointer
)	O
*	O
nfoundp	pointer
=	O
nfound	int
-	O
nwipe	int
;	O
return	O
ngood	int
;	O
}	O
static	O
int	O
MakeServerFifo	function
(	O
)	O
{	O
register	O
int	O
s	int
;	O
struct	O
stat	struct
st	struct
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
s	int
=	O
open	function
(	O
SockPath	array
,	O
O_WRONLY	int
|	O
O_NONBLOCK	int
)	O
;	O
if	O
(	O
s	int
>=	O
0	int
)	O
{	O
debug	O
(	O
"huii, my fifo already exists??\n"	pointer
)	O
;	O
if	O
(	O
quietflag	int
)	O
{	O
Kill	function
(	O
D_userpid	O
,	O
SIG_BYE	O
)	O
;	O
eexit	function
(	O
11	int
)	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"There is already a screen running on %s."	pointer
,	O
Filename	function
(	O
SockPath	array
)	O
)	O
;	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"stat"	pointer
)	O
;	O
if	O
(	O
(	O
int	O
)	O
st	struct
.	O
st_uid	int
!=	O
real_uid	int
)	O
Panic	function
(	O
0	int
,	O
"Unfortunately you are not its owner."	pointer
)	O
;	O
if	O
(	O
(	O
st	struct
.	O
st_mode	int
&	O
0700	int
)	O
==	O
0600	int
)	O
Panic	function
(	O
0	int
,	O
"To resume it, use \"screen -r\""	pointer
)	O
;	O
else	O
Panic	function
(	O
0	int
,	O
"It is not detached."	pointer
)	O
;	O
}	O
(	O
void	O
)	O
unlink	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
mkfifo	function
(	O
SockPath	array
,	O
SOCKMODE	O
)	O
<	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"mkfifo %s failed"	pointer
,	O
SockPath	array
)	O
;	O
s	int
=	O
open	function
(	O
SockPath	array
,	O
O_RDONLY	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
;	O
if	O
(	O
s	int
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"open fifo %s"	pointer
,	O
SockPath	array
)	O
;	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
return	O
s	int
;	O
}	O
static	O
int	O
MakeClientFifo	function
(	O
err	long
)	O
int	O
err	long
;	O
{	O
register	O
int	O
s	int
=	O
0	int
;	O
s	int
=	O
secopen	function
(	O
SockPath	array
,	O
O_WRONLY	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
;	O
if	O
(	O
s	int
>=	O
0	int
)	O
{	O
(	O
void	O
)	O
fcntl	function
(	O
s	int
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
return	O
s	int
;	O
}	O
if	O
(	O
err	long
)	O
Msg	function
(	O
errno	O
,	O
"%s"	pointer
,	O
SockPath	array
)	O
;	O
debug2	O
(	O
"MakeClientSocket() open %s failed (%d)\n"	pointer
,	O
SockPath	array
,	O
errno	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
MakeServerUnixSocket	function
(	O
)	O
{	O
register	O
int	O
s	int
;	O
struct	O
sockaddr_un	struct
a	struct
;	O
struct	O
stat	struct
st	struct
;	O
s	int
=	O
socket	function
(	O
AF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
s	int
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"socket"	pointer
)	O
;	O
a	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	function
(	O
a	struct
.	O
sun_path	array
,	O
SockPath	array
,	O
sizeof	O
(	O
a	struct
.	O
sun_path	array
)	O
)	O
;	O
a	struct
.	O
sun_path	array
[	O
sizeof	O
(	O
a	struct
.	O
sun_path	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
if	O
(	O
connect	function
(	O
s	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
a	struct
,	O
strlen	function
(	O
SockPath	array
)	O
+	O
2	int
)	O
!=	O
-	O
1	int
)	O
{	O
debug	O
(	O
"oooooh! socket already is alive!\n"	pointer
)	O
;	O
if	O
(	O
quietflag	int
)	O
{	O
Kill	function
(	O
D_userpid	O
,	O
SIG_BYE	O
)	O
;	O
eexit	function
(	O
11	int
)	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"There is already a screen running on %s."	pointer
,	O
Filename	function
(	O
SockPath	array
)	O
)	O
;	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"stat"	pointer
)	O
;	O
if	O
(	O
st	struct
.	O
st_uid	int
!=	O
real_uid	int
)	O
Panic	function
(	O
0	int
,	O
"Unfortunately you are not its owner."	pointer
)	O
;	O
if	O
(	O
(	O
st	struct
.	O
st_mode	int
&	O
0700	int
)	O
==	O
0600	int
)	O
Panic	function
(	O
0	int
,	O
"To resume it, use \"screen -r\""	pointer
)	O
;	O
else	O
Panic	function
(	O
0	int
,	O
"It is not detached."	pointer
)	O
;	O
}	O
(	O
void	O
)	O
unlink	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
bind	function
(	O
s	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
a	struct
,	O
strlen	function
(	O
SockPath	array
)	O
+	O
2	int
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"bind (%s)"	pointer
,	O
SockPath	array
)	O
;	O
chmod	function
(	O
SockPath	array
,	O
SOCKMODE	O
)	O
;	O
if	O
(	O
listen	function
(	O
s	int
,	O
5	int
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"listen"	pointer
)	O
;	O
fcntl	function
(	O
s	int
,	O
F_SETOWN	O
,	O
getpid	function
(	O
)	O
)	O
;	O
debug1	O
(	O
"Serversocket owned by %d\n"	pointer
,	O
fcntl	function
(	O
s	int
,	O
F_GETOWN	O
,	O
0	int
)	O
)	O
;	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
return	O
s	int
;	O
}	O
static	O
int	O
MakeClientUnixSocket	function
(	O
err	long
)	O
int	O
err	long
;	O
{	O
register	O
int	O
s	int
;	O
struct	O
sockaddr_un	struct
a	struct
;	O
s	int
=	O
socket	function
(	O
AF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
s	int
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"socket"	pointer
)	O
;	O
a	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	function
(	O
a	struct
.	O
sun_path	array
,	O
SockPath	array
,	O
sizeof	O
(	O
a	struct
.	O
sun_path	array
)	O
)	O
;	O
a	struct
.	O
sun_path	array
[	O
sizeof	O
(	O
a	struct
.	O
sun_path	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
if	O
(	O
connect	function
(	O
s	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
a	struct
,	O
strlen	function
(	O
SockPath	array
)	O
+	O
2	int
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
err	long
)	O
Msg	function
(	O
errno	O
,	O
"%s: connect"	pointer
,	O
SockPath	array
)	O
;	O
debug	O
(	O
"MakeClientSocket: connect failed.\n"	pointer
)	O
;	O
close	function
(	O
s	int
)	O
;	O
s	int
=	O
-	O
1	int
;	O
}	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
return	O
s	int
;	O
}	O
int	O
MakeServerSocket	function
(	O
socket	function
)	O
bool	bool
socket	function
;	O
{	O
if	O
(	O
socket	function
)	O
return	O
MakeServerUnixSocket	function
(	O
)	O
;	O
return	O
MakeServerFifo	function
(	O
)	O
;	O
}	O
int	O
MakeClientSocket	function
(	O
err	long
,	O
socket	function
)	O
int	O
err	long
;	O
bool	bool
socket	function
;	O
{	O
if	O
(	O
socket	function
)	O
return	O
MakeClientUnixSocket	function
(	O
err	long
)	O
;	O
return	O
MakeClientFifo	function
(	O
err	long
)	O
;	O
}	O
void	O
SendCreateMsg	function
(	O
sty	pointer
,	O
nwin	pointer
)	O
char	O
*	O
sty	pointer
;	O
struct	O
NewWindow	struct
*	O
nwin	pointer
;	O
{	O
int	O
s	int
;	O
struct	O
msg	struct
m	union
;	O
register	O
char	O
*	O
p	pointer
;	O
register	O
int	O
len	int
,	O
n	pointer
;	O
char	O
*	O
*	O
av	pointer
;	O
bool	bool
is_socket	bool
;	O
if	O
(	O
strlen	function
(	O
sty	pointer
)	O
>	O
NAME_MAX	int
)	O
sty	pointer
[	O
NAME_MAX	int
]	O
=	O
0	int
;	O
if	O
(	O
strlen	function
(	O
sty	pointer
)	O
>	O
2	int
*	O
MAXSTR	int
-	O
1	int
)	O
sty	pointer
[	O
2	int
*	O
MAXSTR	int
-	O
1	int
]	O
=	O
0	int
;	O
sprintf	function
(	O
SockPath	array
+	O
strlen	function
(	O
SockPath	array
)	O
,	O
"/%s"	pointer
,	O
sty	pointer
)	O
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
(	O
s	int
=	O
MakeClientSocket	function
(	O
1	int
,	O
is_socket	bool
)	O
)	O
==	O
-	O
1	int
)	O
exit	function
(	O
1	int
)	O
;	O
debug1	O
(	O
"SendCreateMsg() to '%s'\n"	pointer
,	O
SockPath	array
)	O
;	O
bzero	function
(	O
(	O
char	O
*	O
)	O
&	O
m	union
,	O
sizeof	O
(	O
m	union
)	O
)	O
;	O
m	union
.	O
type	enum
=	O
MSG_CREATE	int
;	O
strncpy	function
(	O
m	union
.	O
m_tty	array
,	O
attach_tty	pointer
,	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m_tty	array
[	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
p	pointer
=	O
m	union
.	O
m	union
.	O
create	struct
.	O
line	array
;	O
n	pointer
=	O
0	int
;	O
if	O
(	O
nwin	pointer
->	O
args	pointer
!=	O
nwin_undef	struct
.	O
args	pointer
)	O
for	O
(	O
av	pointer
=	O
nwin	pointer
->	O
args	pointer
;	O
*	O
av	pointer
&&	O
n	pointer
<	O
MAXARGS	int
-	O
1	int
;	O
++	O
av	pointer
,	O
++	O
n	pointer
)	O
{	O
len	int
=	O
strlen	function
(	O
*	O
av	pointer
)	O
+	O
1	int
;	O
if	O
(	O
p	pointer
+	O
len	int
>=	O
m	union
.	O
m	union
.	O
create	struct
.	O
line	array
+	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
create	struct
.	O
line	array
)	O
-	O
1	int
)	O
break	O
;	O
strcpy	function
(	O
p	pointer
,	O
*	O
av	pointer
)	O
;	O
p	pointer
+=	O
len	int
;	O
}	O
if	O
(	O
nwin	pointer
->	O
aka	pointer
!=	O
nwin_undef	struct
.	O
aka	pointer
&&	O
p	pointer
+	O
strlen	function
(	O
nwin	pointer
->	O
aka	pointer
)	O
+	O
1	int
<	O
m	union
.	O
m	union
.	O
create	struct
.	O
line	array
+	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
create	struct
.	O
line	array
)	O
)	O
strcpy	function
(	O
p	pointer
,	O
nwin	pointer
->	O
aka	pointer
)	O
;	O
else	O
*	O
p	pointer
=	O
'\0'	O
;	O
m	union
.	O
m	union
.	O
create	struct
.	O
nargs	int
=	O
n	pointer
;	O
m	union
.	O
m	union
.	O
create	struct
.	O
aflag	int
=	O
nwin	pointer
->	O
aflag	int
;	O
m	union
.	O
m	union
.	O
create	struct
.	O
flowflag	int
=	O
nwin	pointer
->	O
flowflag	int
;	O
m	union
.	O
m	union
.	O
create	struct
.	O
lflag	int
=	O
nwin	pointer
->	O
lflag	int
;	O
m	union
.	O
m	union
.	O
create	struct
.	O
hheight	int
=	O
nwin	pointer
->	O
histheight	int
;	O
if	O
(	O
getcwd	function
(	O
m	union
.	O
m	union
.	O
create	struct
.	O
dir	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
create	struct
.	O
dir	pointer
)	O
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"getcwd"	pointer
)	O
;	O
goto	O
end	pointer
;	O
}	O
if	O
(	O
nwin	pointer
->	O
term	struct
!=	O
nwin_undef	struct
.	O
term	struct
)	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
create	struct
.	O
screenterm	array
,	O
nwin	pointer
->	O
term	struct
,	O
MAXTERMLEN	int
)	O
;	O
m	union
.	O
m	union
.	O
create	struct
.	O
screenterm	array
[	O
MAXTERMLEN	int
]	O
=	O
'\0'	O
;	O
m	union
.	O
protocol_revision	int
=	O
MSG_REVISION	O
;	O
debug1	O
(	O
"SendCreateMsg writing '%s'\n"	pointer
,	O
m	union
.	O
m	union
.	O
create	struct
.	O
line	array
)	O
;	O
if	O
(	O
write	function
(	O
s	int
,	O
(	O
char	O
*	O
)	O
&	O
m	union
,	O
sizeof	O
m	union
)	O
!=	O
sizeof	O
m	union
)	O
Msg	function
(	O
errno	O
,	O
"write"	pointer
)	O
;	O
end	pointer
:	O
close	function
(	O
s	int
)	O
;	O
}	O
int	O
SendErrorMsg	function
(	O
tty	pointer
,	O
buf	pointer
)	O
char	O
*	O
tty	pointer
,	O
*	O
buf	pointer
;	O
{	O
int	O
s	int
;	O
struct	O
msg	struct
m	union
;	O
bool	bool
is_socket	bool
;	O
debug2	O
(	O
"SendErrorMsg: %s %s\n"	pointer
,	O
tty	pointer
,	O
buf	pointer
)	O
;	O
strncpy	function
(	O
m	union
.	O
m	union
.	O
message	array
,	O
buf	pointer
,	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
message	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m	union
.	O
message	array
[	O
sizeof	O
(	O
m	union
.	O
m	union
.	O
message	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
s	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
is_socket	bool
)	O
;	O
if	O
(	O
s	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
m	union
.	O
type	enum
=	O
MSG_ERROR	int
;	O
strncpy	function
(	O
m	union
.	O
m_tty	array
,	O
tty	pointer
,	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
)	O
;	O
m	union
.	O
m_tty	array
[	O
sizeof	O
(	O
m	union
.	O
m_tty	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
m	union
.	O
protocol_revision	int
=	O
MSG_REVISION	O
;	O
debug1	O
(	O
"SendErrorMsg(): writing to '%s'\n"	pointer
,	O
SockPath	array
)	O
;	O
(	O
void	O
)	O
write	function
(	O
s	int
,	O
(	O
char	O
*	O
)	O
&	O
m	union
,	O
sizeof	O
m	union
)	O
;	O
close	function
(	O
s	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
ExecCreate	function
(	O
mp	pointer
)	O
struct	O
msg	struct
*	O
mp	pointer
;	O
{	O
struct	O
NewWindow	struct
nwin	pointer
;	O
char	O
*	O
args	pointer
[	O
MAXARGS	int
]	O
;	O
register	O
int	O
n	pointer
;	O
register	O
char	O
*	O
*	O
pp	pointer
=	O
args	pointer
,	O
*	O
p	pointer
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
line	array
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
nwin	pointer
=	O
nwin_undef	struct
;	O
n	pointer
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
nargs	int
;	O
if	O
(	O
n	pointer
>	O
MAXARGS	int
-	O
1	int
)	O
n	pointer
=	O
MAXARGS	int
-	O
1	int
;	O
if	O
(	O
n	pointer
)	O
{	O
int	O
l	int
,	O
num	int
;	O
l	int
=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
IsNumColon	function
(	O
p	pointer
,	O
10	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
{	O
if	O
(	O
*	O
buf	pointer
)	O
nwin	pointer
.	O
aka	pointer
=	O
buf	pointer
;	O
num	int
=	O
atoi	function
(	O
p	pointer
)	O
;	O
if	O
(	O
num	int
<	O
0	int
||	O
num	int
>	O
maxwin	int
-	O
1	int
)	O
num	int
=	O
0	int
;	O
nwin	pointer
.	O
StartAt	int
=	O
num	int
;	O
p	pointer
+=	O
l	int
+	O
1	int
;	O
n	pointer
--	O
;	O
}	O
}	O
for	O
(	O
;	O
n	pointer
>	O
0	int
;	O
n	pointer
--	O
)	O
{	O
*	O
pp	pointer
++	O
=	O
p	pointer
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
;	O
}	O
*	O
pp	pointer
=	O
0	int
;	O
if	O
(	O
*	O
p	pointer
)	O
nwin	pointer
.	O
aka	pointer
=	O
p	pointer
;	O
if	O
(	O
*	O
args	pointer
)	O
nwin	pointer
.	O
args	pointer
=	O
args	pointer
;	O
nwin	pointer
.	O
aflag	int
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
aflag	int
;	O
nwin	pointer
.	O
flowflag	int
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
flowflag	int
;	O
if	O
(	O
*	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
dir	pointer
)	O
nwin	pointer
.	O
dir	pointer
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
dir	pointer
;	O
nwin	pointer
.	O
lflag	int
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
lflag	int
;	O
nwin	pointer
.	O
histheight	int
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
hheight	int
;	O
if	O
(	O
*	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
screenterm	array
)	O
nwin	pointer
.	O
term	struct
=	O
mp	pointer
->	O
m	union
.	O
create	struct
.	O
screenterm	array
;	O
MakeWindow	function
(	O
&	O
nwin	pointer
)	O
;	O
}	O
static	O
int	O
CheckPid	function
(	O
pid	int
)	O
int	O
pid	int
;	O
{	O
debug1	O
(	O
"Checking pid %d\n"	pointer
,	O
pid	int
)	O
;	O
if	O
(	O
pid	int
<	O
2	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
eff_uid	int
==	O
real_uid	int
)	O
return	O
kill	function
(	O
pid	int
,	O
0	int
)	O
;	O
if	O
(	O
UserContext	function
(	O
)	O
>	O
0	int
)	O
UserReturn	function
(	O
kill	function
(	O
pid	int
,	O
0	int
)	O
)	O
;	O
return	O
UserStatus	function
(	O
)	O
;	O
}	O
static	O
int	O
CreateTempDisplay	function
(	O
m	union
,	O
recvfd	int
,	O
wi	pointer
)	O
struct	O
msg	struct
*	O
m	union
;	O
int	O
recvfd	int
;	O
struct	O
win	struct
*	O
wi	pointer
;	O
{	O
int	O
pid	int
;	O
int	O
attach	struct
;	O
char	O
*	O
user	pointer
;	O
int	O
i	int
;	O
struct	O
mode	struct
Mode	struct
;	O
struct	O
display	struct
*	O
olddisplays	pointer
=	O
displays	pointer
;	O
switch	O
(	O
m	union
->	O
type	enum
)	O
{	O
case	O
MSG_CONT	int
:	O
case	O
MSG_ATTACH	int
:	O
pid	int
=	O
m	union
->	O
m	union
.	O
attach	struct
.	O
apid	int
;	O
user	pointer
=	O
m	union
->	O
m	union
.	O
attach	struct
.	O
auser	array
;	O
attach	struct
=	O
1	int
;	O
break	O
;	O
case	O
MSG_DETACH	int
:	O
case	O
MSG_POW_DETACH	int
:	O
pid	int
=	O
m	union
->	O
m	union
.	O
detach	struct
.	O
dpid	int
;	O
user	pointer
=	O
m	union
->	O
m	union
.	O
detach	struct
.	O
duser	array
;	O
attach	struct
=	O
0	int
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
CheckPid	function
(	O
pid	int
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"Attach attempt with bad pid(%d)!"	pointer
,	O
pid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
recvfd	int
!=	O
-	O
1	int
)	O
{	O
int	O
ret	int
;	O
char	O
ttyname_in_ns	array
[	O
MAXPATHLEN	O
]	O
;	O
char	O
*	O
myttyname	pointer
;	O
i	int
=	O
recvfd	int
;	O
recvfd	int
=	O
-	O
1	int
;	O
memset	function
(	O
&	O
ttyname_in_ns	array
,	O
0	int
,	O
sizeof	O
(	O
ttyname_in_ns	array
)	O
)	O
;	O
errno	O
=	O
0	int
;	O
myttyname	pointer
=	O
GetPtsPathOrSymlink	function
(	O
i	int
)	O
;	O
if	O
(	O
myttyname	pointer
&&	O
errno	O
==	O
ENODEV	int
)	O
{	O
ret	int
=	O
readlink	function
(	O
myttyname	pointer
,	O
ttyname_in_ns	array
,	O
sizeof	O
(	O
ttyname_in_ns	array
)	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
(	O
size_t	long
)	O
ret	int
>=	O
sizeof	O
(	O
ttyname_in_ns	array
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Could not perform necessary sanity checks on pts device."	pointer
)	O
;	O
close	function
(	O
i	int
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
ttyname_in_ns	array
,	O
m	union
->	O
m_tty	array
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Attach: passed fd does not match tty: %s - %s!"	pointer
,	O
ttyname_in_ns	array
,	O
m	union
->	O
m_tty	array
[	O
0	int
]	O
!=	O
'\0'	O
?	O
m	union
->	O
m_tty	array
:	O
"(null)"	pointer
)	O
;	O
close	function
(	O
i	int
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
m	union
->	O
m_tty	array
,	O
myttyname	pointer
,	O
sizeof	O
(	O
m	union
->	O
m_tty	array
)	O
-	O
1	int
)	O
;	O
m	union
->	O
m_tty	array
[	O
sizeof	O
(	O
m	union
->	O
m_tty	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
myttyname	pointer
==	O
0	int
||	O
strcmp	function
(	O
myttyname	pointer
,	O
m	union
->	O
m_tty	array
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Attach: passed fd does not match tty: %s - %s!"	pointer
,	O
m	union
->	O
m_tty	array
,	O
myttyname	pointer
?	O
myttyname	pointer
:	O
"NULL"	pointer
)	O
;	O
close	function
(	O
i	int
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
i	int
=	O
secopen	function
(	O
m	union
->	O
m_tty	array
,	O
O_RDWR	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Attach: Could not open %s!"	pointer
,	O
m	union
->	O
m_tty	array
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
attach	struct
)	O
Kill	function
(	O
pid	int
,	O
SIGCONT	int
)	O
;	O
if	O
(	O
attach	struct
)	O
{	O
if	O
(	O
display	struct
||	O
wi	pointer
)	O
{	O
write	function
(	O
i	int
,	O
"Attaching from inside of screen?\n"	pointer
,	O
33	int
)	O
;	O
close	function
(	O
i	int
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
Msg	function
(	O
0	int
,	O
"Attach msg ignored: coming from inside."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
user	pointer
,	O
LoginName	pointer
)	O
)	O
if	O
(	O
*	O
FindUserPtr	function
(	O
user	pointer
)	O
==	O
0	int
)	O
{	O
write	function
(	O
i	int
,	O
"Access to session denied.\n"	pointer
,	O
26	int
)	O
;	O
close	function
(	O
i	int
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
Msg	function
(	O
0	int
,	O
"Attach: access denied for user %s."	pointer
,	O
user	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
debug2	O
(	O
"RecMsg: apid %d is o.k. and we just opened '%s'\n"	pointer
,	O
pid	int
,	O
m	union
->	O
m_tty	array
)	O
;	O
}	O
GetTTY	function
(	O
i	int
,	O
&	O
Mode	struct
)	O
;	O
if	O
(	O
MakeDisplay	function
(	O
user	pointer
,	O
m	union
->	O
m_tty	array
,	O
attach	struct
?	O
m	union
->	O
m	union
.	O
attach	struct
.	O
envterm	array
:	O
""	pointer
,	O
i	int
,	O
pid	int
,	O
&	O
Mode	struct
)	O
==	O
0	int
)	O
{	O
write	function
(	O
i	int
,	O
"Could not make display.\n"	pointer
,	O
24	int
)	O
;	O
close	function
(	O
i	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"Attach: could not make display for user %s"	pointer
,	O
user	pointer
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
attach	struct
)	O
{	O
D_encoding	O
=	O
m	union
->	O
m	union
.	O
attach	struct
.	O
encoding	int
==	O
1	int
?	O
UTF8	int
:	O
m	union
->	O
m	union
.	O
attach	struct
.	O
encoding	int
?	O
m	union
->	O
m	union
.	O
attach	struct
.	O
encoding	int
-	O
1	int
:	O
0	int
;	O
if	O
(	O
D_encoding	O
<	O
0	int
||	O
!	O
EncodingName	function
(	O
D_encoding	O
)	O
)	O
D_encoding	O
=	O
0	int
;	O
}	O
if	O
(	O
iflag	int
&&	O
olddisplays	pointer
)	O
{	O
iflag	int
=	O
0	int
;	O
olddisplays	pointer
->	O
d_NewMode	struct
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
VDISABLE	O
;	O
olddisplays	pointer
->	O
d_NewMode	struct
.	O
tio	struct
.	O
c_lflag	int
&=	O
~	O
ISIG	int
;	O
SetTTY	function
(	O
olddisplays	pointer
->	O
d_userfd	int
,	O
&	O
olddisplays	pointer
->	O
d_NewMode	struct
)	O
;	O
}	O
SetMode	function
(	O
&	O
D_OldMode	O
,	O
&	O
D_NewMode	O
,	O
D_flow	O
,	O
iflag	int
)	O
;	O
SetTTY	function
(	O
D_userfd	O
,	O
&	O
D_NewMode	O
)	O
;	O
if	O
(	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
FNBLOCK	O
)	O
)	O
Msg	function
(	O
errno	O
,	O
"Warning: NBLOCK fcntl failed"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ReceiveMsg	function
(	O
)	O
{	O
int	O
left	pointer
,	O
len	int
;	O
static	O
struct	O
msg	struct
m	union
;	O
char	O
*	O
p	pointer
;	O
int	O
ns	int
=	O
ServerSocket	int
;	O
struct	O
win	struct
*	O
wi	pointer
;	O
int	O
recvfd	int
=	O
-	O
1	int
;	O
struct	O
acluser	struct
*	O
user	pointer
;	O
bool	bool
is_socket	bool
;	O
struct	O
sockaddr_un	struct
a	struct
;	O
struct	O
msghdr	struct
msg	struct
;	O
struct	O
iovec	struct
iov	struct
;	O
char	O
control	array
[	O
1024	int
]	O
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
!	O
is_socket	bool
)	O
{	O
debug	O
(	O
"Ha, there was someone knocking on my fifo??\n"	pointer
)	O
;	O
if	O
(	O
fcntl	function
(	O
ServerSocket	int
,	O
F_SETFL	int
,	O
0	int
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"BLOCK fcntl"	pointer
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
&	O
m	union
;	O
left	pointer
=	O
sizeof	O
(	O
m	union
)	O
;	O
}	O
else	O
{	O
len	int
=	O
sizeof	O
(	O
a	struct
)	O
;	O
debug	O
(	O
"Ha, there was someone knocking on my socket??\n"	pointer
)	O
;	O
if	O
(	O
(	O
ns	int
=	O
accept	function
(	O
ns	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
a	struct
,	O
(	O
void	O
*	O
)	O
&	O
len	int
)	O
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"accept"	pointer
)	O
;	O
return	O
;	O
}	O
p	pointer
=	O
(	O
char	O
*	O
)	O
&	O
m	union
;	O
left	pointer
=	O
sizeof	O
(	O
m	union
)	O
;	O
bzero	function
(	O
&	O
msg	struct
,	O
sizeof	O
(	O
msg	struct
)	O
)	O
;	O
iov	struct
.	O
iov_base	pointer
=	O
&	O
m	union
;	O
iov	struct
.	O
iov_len	long
=	O
left	pointer
;	O
msg	struct
.	O
msg_iov	pointer
=	O
&	O
iov	struct
;	O
msg	struct
.	O
msg_iovlen	long
=	O
1	int
;	O
msg	struct
.	O
msg_controllen	long
=	O
sizeof	O
(	O
control	array
)	O
;	O
msg	struct
.	O
msg_control	pointer
=	O
&	O
control	array
;	O
while	O
(	O
left	pointer
>	O
0	int
)	O
{	O
len	int
=	O
recvmsg	function
(	O
ns	int
,	O
&	O
msg	struct
,	O
0	int
)	O
;	O
if	O
(	O
len	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
close	function
(	O
ns	int
)	O
;	O
Msg	function
(	O
errno	O
,	O
"read"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
msg	struct
.	O
msg_controllen	long
)	O
{	O
struct	O
cmsghdr	struct
*	O
cmsg	pointer
;	O
for	O
(	O
cmsg	pointer
=	O
CMSG_FIRSTHDR	O
(	O
&	O
msg	struct
)	O
;	O
cmsg	pointer
;	O
cmsg	pointer
=	O
CMSG_NXTHDR	O
(	O
&	O
msg	struct
,	O
cmsg	pointer
)	O
)	O
{	O
int	O
cl	int
;	O
char	O
*	O
cp	pointer
;	O
if	O
(	O
cmsg	pointer
->	O
cmsg_level	int
!=	O
SOL_SOCKET	int
||	O
cmsg	pointer
->	O
cmsg_type	int
!=	O
SCM_RIGHTS	int
)	O
continue	O
;	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
CMSG_DATA	O
(	O
cmsg	pointer
)	O
;	O
cl	int
=	O
cmsg	pointer
->	O
cmsg_len	long
;	O
while	O
(	O
cl	int
>=	O
CMSG_LEN	O
(	O
sizeof	O
(	O
int	O
)	O
)	O
)	O
{	O
int	O
passedfd	int
;	O
bcopy	function
(	O
cp	pointer
,	O
&	O
passedfd	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
if	O
(	O
recvfd	int
>=	O
0	int
&&	O
passedfd	int
!=	O
recvfd	int
)	O
close	function
(	O
recvfd	int
)	O
;	O
recvfd	int
=	O
passedfd	int
;	O
cl	int
-=	O
CMSG_LEN	O
(	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
}	O
}	O
p	pointer
+=	O
len	int
;	O
left	pointer
-=	O
len	int
;	O
break	O
;	O
}	O
}	O
while	O
(	O
left	pointer
>	O
0	int
)	O
{	O
len	int
=	O
read	function
(	O
ns	int
,	O
p	pointer
,	O
left	pointer
)	O
;	O
if	O
(	O
len	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
len	int
<=	O
0	int
)	O
break	O
;	O
p	pointer
+=	O
len	int
;	O
left	pointer
-=	O
len	int
;	O
}	O
if	O
(	O
!	O
is_socket	bool
)	O
{	O
close	function
(	O
ServerSocket	int
)	O
;	O
if	O
(	O
(	O
ServerSocket	int
=	O
secopen	function
(	O
SockPath	array
,	O
O_RDONLY	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"reopen fifo %s"	pointer
,	O
SockPath	array
)	O
;	O
evdeq	function
(	O
&	O
serv_read	struct
)	O
;	O
serv_read	struct
.	O
fd	int
=	O
ServerSocket	int
;	O
evenq	function
(	O
&	O
serv_read	struct
)	O
;	O
}	O
else	O
{	O
close	function
(	O
ns	int
)	O
;	O
}	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"read"	pointer
)	O
;	O
if	O
(	O
recvfd	int
!=	O
-	O
1	int
)	O
close	function
(	O
recvfd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
left	pointer
>	O
0	int
)	O
{	O
if	O
(	O
left	pointer
!=	O
sizeof	O
(	O
m	union
)	O
)	O
Msg	function
(	O
0	int
,	O
"Message %d of %d bytes too small"	pointer
,	O
left	pointer
,	O
(	O
int	O
)	O
sizeof	O
(	O
m	union
)	O
)	O
;	O
else	O
debug	O
(	O
"No data on socket.\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
m	union
.	O
protocol_revision	int
!=	O
MSG_REVISION	O
)	O
{	O
if	O
(	O
recvfd	int
!=	O
-	O
1	int
)	O
close	function
(	O
recvfd	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"Invalid message (magic 0x%08x)."	pointer
,	O
m	union
.	O
protocol_revision	int
)	O
;	O
return	O
;	O
}	O
debug2	O
(	O
"*** RecMsg: type %d tty %s\n"	pointer
,	O
m	union
.	O
type	enum
,	O
m	union
.	O
m_tty	array
)	O
;	O
if	O
(	O
m	union
.	O
type	enum
!=	O
MSG_ATTACH	int
&&	O
recvfd	int
!=	O
-	O
1	int
)	O
{	O
close	function
(	O
recvfd	int
)	O
;	O
recvfd	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
if	O
(	O
TTYCMP	O
(	O
D_usertty	O
,	O
m	union
.	O
m_tty	array
)	O
==	O
0	int
)	O
break	O
;	O
debug2	O
(	O
"display: %s display %sfound\n"	pointer
,	O
m	union
.	O
m_tty	array
,	O
display	struct
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
wi	pointer
=	O
0	int
;	O
if	O
(	O
!	O
display	struct
)	O
{	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
TTYCMP	O
(	O
m	union
.	O
m_tty	array
,	O
wi	pointer
->	O
w_tty	array
)	O
)	O
{	O
display	struct
=	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
?	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
:	O
0	int
;	O
debug2	O
(	O
"but window %s %sfound.\n"	pointer
,	O
m	union
.	O
m_tty	array
,	O
display	struct
?	O
""	pointer
:	O
"(backfacing)"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
display	struct
&&	O
D_status	O
)	O
RemoveStatus	function
(	O
)	O
;	O
if	O
(	O
display	struct
&&	O
!	O
D_tcinited	O
&&	O
m	union
.	O
type	enum
!=	O
MSG_HANGUP	int
)	O
{	O
if	O
(	O
recvfd	int
!=	O
-	O
1	int
)	O
close	function
(	O
recvfd	int
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
m	union
.	O
type	enum
)	O
{	O
case	O
MSG_WINCH	int
:	O
if	O
(	O
display	struct
)	O
CheckScreenSize	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
MSG_CREATE	int
:	O
ExecCreate	function
(	O
&	O
m	union
)	O
;	O
break	O
;	O
case	O
MSG_CONT	int
:	O
if	O
(	O
display	struct
&&	O
D_userpid	O
!=	O
0	int
&&	O
kill	function
(	O
D_userpid	O
,	O
0	int
)	O
==	O
0	int
)	O
break	O
;	O
debug2	O
(	O
"RecMsg: apid=%d,was %d\n"	pointer
,	O
m	union
.	O
m	union
.	O
attach	struct
.	O
apid	int
,	O
display	struct
?	O
D_userpid	O
:	O
0	int
)	O
;	O
case	O
MSG_ATTACH	int
:	O
if	O
(	O
CreateTempDisplay	function
(	O
&	O
m	union
,	O
recvfd	int
,	O
wi	pointer
)	O
)	O
break	O
;	O
if	O
(	O
D_user	O
->	O
u_password	pointer
&&	O
*	O
D_user	O
->	O
u_password	pointer
)	O
AskPassword	function
(	O
&	O
m	union
)	O
;	O
else	O
FinishAttach	function
(	O
&	O
m	union
)	O
;	O
break	O
;	O
case	O
MSG_ERROR	int
:	O
{	O
int	O
blocked	int
=	O
D_blocked	O
;	O
if	O
(	O
D_blocked	O
==	O
4	int
)	O
D_blocked	O
=	O
0	int
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
m	union
.	O
m	union
.	O
message	array
)	O
;	O
D_blocked	O
=	O
blocked	int
;	O
}	O
break	O
;	O
case	O
MSG_HANGUP	int
:	O
if	O
(	O
!	O
wi	pointer
)	O
Hangup	function
(	O
)	O
;	O
break	O
;	O
case	O
MSG_DETACH	int
:	O
case	O
MSG_POW_DETACH	int
:	O
user	pointer
=	O
*	O
FindUserPtr	function
(	O
m	union
.	O
m	union
.	O
detach	struct
.	O
duser	array
)	O
;	O
if	O
(	O
user	pointer
&&	O
user	pointer
->	O
u_password	pointer
&&	O
*	O
user	pointer
->	O
u_password	pointer
)	O
{	O
if	O
(	O
CreateTempDisplay	function
(	O
&	O
m	union
,	O
recvfd	int
,	O
0	int
)	O
)	O
break	O
;	O
AskPassword	function
(	O
&	O
m	union
)	O
;	O
}	O
else	O
FinishDetach	function
(	O
&	O
m	union
)	O
;	O
break	O
;	O
case	O
MSG_QUERY	int
:	O
{	O
char	O
*	O
oldSockPath	pointer
=	O
SaveStr	function
(	O
SockPath	array
)	O
;	O
strcpy	function
(	O
SockPath	array
,	O
m	union
.	O
m	union
.	O
command	struct
.	O
writeback	array
)	O
;	O
bool	bool
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
int	O
s	int
=	O
MakeClientSocket	function
(	O
0	int
,	O
is_socket	bool
)	O
;	O
strcpy	function
(	O
SockPath	array
,	O
oldSockPath	pointer
)	O
;	O
Free	O
(	O
oldSockPath	pointer
)	O
;	O
if	O
(	O
s	int
>=	O
0	int
)	O
{	O
queryflag	int
=	O
s	int
;	O
DoCommandMsg	function
(	O
&	O
m	union
)	O
;	O
close	function
(	O
s	int
)	O
;	O
}	O
else	O
queryflag	int
=	O
-	O
1	int
;	O
Kill	function
(	O
m	union
.	O
m	union
.	O
command	struct
.	O
apid	int
,	O
(	O
queryflag	int
>=	O
0	int
)	O
?	O
SIGCONT	int
:	O
SIG_BYE	O
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
MSG_COMMAND	int
:	O
DoCommandMsg	function
(	O
&	O
m	union
)	O
;	O
break	O
;	O
default	O
:	O
Msg	function
(	O
0	int
,	O
"Invalid message (type %d)."	pointer
,	O
m	union
.	O
type	enum
)	O
;	O
}	O
}	O
void	O
ReceiveRaw	function
(	O
s	int
)	O
int	O
s	int
;	O
{	O
char	O
rd	array
[	O
256	int
]	O
;	O
int	O
len	int
=	O
0	int
;	O
struct	O
sockaddr_un	struct
a	struct
;	O
bool	bool
is_socket	bool
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
!	O
is_socket	bool
)	O
{	O
if	O
(	O
fcntl	function
(	O
s	int
,	O
F_SETFL	int
,	O
0	int
)	O
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"BLOCK fcntl"	pointer
)	O
;	O
}	O
else	O
{	O
len	int
=	O
sizeof	O
(	O
a	struct
)	O
;	O
s	int
=	O
accept	function
(	O
s	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
a	struct
,	O
(	O
void	O
*	O
)	O
&	O
len	int
)	O
;	O
if	O
(	O
s	int
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"accept"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
(	O
len	int
=	O
read	function
(	O
s	int
,	O
rd	array
,	O
255	int
)	O
)	O
>	O
0	int
)	O
{	O
rd	array
[	O
len	int
]	O
=	O
0	int
;	O
printf	function
(	O
"%s"	pointer
,	O
rd	array
)	O
;	O
}	O
close	function
(	O
s	int
)	O
;	O
}	O
int	O
chsock	function
(	O
)	O
{	O
int	O
r	int
,	O
euid	int
=	O
geteuid	function
(	O
)	O
;	O
if	O
(	O
euid	int
!=	O
real_uid	int
)	O
{	O
if	O
(	O
UserContext	function
(	O
)	O
<=	O
0	int
)	O
return	O
UserStatus	function
(	O
)	O
;	O
}	O
r	int
=	O
chmod	function
(	O
SockPath	array
,	O
SOCKMODE	O
)	O
;	O
(	O
void	O
)	O
utimes	function
(	O
SockPath	array
,	O
NULL	O
)	O
;	O
if	O
(	O
euid	int
!=	O
real_uid	int
)	O
UserReturn	function
(	O
r	int
)	O
;	O
return	O
r	int
;	O
}	O
int	O
RecoverSocket	function
(	O
)	O
{	O
bool	bool
is_socket	bool
;	O
close	function
(	O
ServerSocket	int
)	O
;	O
if	O
(	O
(	O
int	O
)	O
geteuid	function
(	O
)	O
!=	O
real_uid	int
)	O
{	O
if	O
(	O
UserContext	function
(	O
)	O
>	O
0	int
)	O
UserReturn	function
(	O
unlink	function
(	O
SockPath	array
)	O
)	O
;	O
(	O
void	O
)	O
UserStatus	function
(	O
)	O
;	O
}	O
else	O
(	O
void	O
)	O
unlink	function
(	O
SockPath	array
)	O
;	O
is_socket	bool
=	O
IsSocket	function
(	O
SockPath	array
)	O
;	O
if	O
(	O
(	O
ServerSocket	int
=	O
MakeServerSocket	function
(	O
is_socket	bool
)	O
)	O
<	O
0	int
)	O
return	O
0	int
;	O
evdeq	function
(	O
&	O
serv_read	struct
)	O
;	O
serv_read	struct
.	O
fd	int
=	O
ServerSocket	int
;	O
evenq	function
(	O
&	O
serv_read	struct
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
FinishAttach	function
(	O
m	union
)	O
struct	O
msg	struct
*	O
m	union
;	O
{	O
char	O
*	O
p	pointer
;	O
int	O
pid	int
;	O
int	O
noshowwin	int
;	O
struct	O
win	struct
*	O
wi	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
pid	int
=	O
D_userpid	O
;	O
if	O
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
detachfirst	int
==	O
MSG_DETACH	int
||	O
m	union
->	O
m	union
.	O
attach	struct
.	O
detachfirst	int
==	O
MSG_POW_DETACH	int
)	O
FinishDetach	function
(	O
m	union
)	O
;	O
if	O
(	O
extra_outcap	pointer
)	O
free	function
(	O
extra_outcap	pointer
)	O
;	O
if	O
(	O
extra_incap	pointer
)	O
free	function
(	O
extra_incap	pointer
)	O
;	O
extra_incap	pointer
=	O
extra_outcap	pointer
=	O
0	int
;	O
debug2	O
(	O
"Message says size (%dx%d)\n"	pointer
,	O
m	union
->	O
m	union
.	O
attach	struct
.	O
columns	int
,	O
m	union
->	O
m	union
.	O
attach	struct
.	O
lines	int
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
getenv	function
(	O
"SYSSCREENRC"	pointer
)	O
)	O
)	O
StartRc	function
(	O
p	pointer
,	O
1	int
)	O
;	O
else	O
StartRc	function
(	O
ETCSCREENRC	O
,	O
1	int
)	O
;	O
StartRc	function
(	O
RcFileName	pointer
,	O
1	int
)	O
;	O
if	O
(	O
InitTermcap	function
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
columns	int
,	O
m	union
->	O
m	union
.	O
attach	struct
.	O
lines	int
)	O
)	O
{	O
FreeDisplay	function
(	O
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
;	O
}	O
MakeDefaultCanvas	function
(	O
)	O
;	O
InitTerm	function
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
adaptflag	int
)	O
;	O
if	O
(	O
displays	pointer
->	O
d_next	pointer
==	O
0	int
)	O
(	O
void	O
)	O
chsock	function
(	O
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
SigHup	function
)	O
;	O
if	O
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
esc	int
!=	O
-	O
1	int
&&	O
m	union
->	O
m	union
.	O
attach	struct
.	O
meta_esc	int
!=	O
-	O
1	int
)	O
{	O
D_user	O
->	O
u_Esc	int
=	O
m	union
->	O
m	union
.	O
attach	struct
.	O
esc	int
;	O
D_user	O
->	O
u_MetaEsc	int
=	O
m	union
->	O
m	union
.	O
attach	struct
.	O
meta_esc	int
;	O
}	O
RemoveLoginSlot	function
(	O
)	O
;	O
if	O
(	O
displays	pointer
->	O
d_next	pointer
==	O
0	int
)	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
wi	pointer
->	O
w_ptyfd	int
>=	O
0	int
&&	O
wi	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
)	O
SetUtmp	function
(	O
wi	pointer
)	O
;	O
D_fore	O
=	O
NULL	O
;	O
if	O
(	O
layout_attach	pointer
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
=	O
layout_attach	pointer
;	O
if	O
(	O
lay	pointer
==	O
&	O
layout_last_marker	struct
)	O
lay	pointer
=	O
layout_last	pointer
;	O
if	O
(	O
lay	pointer
)	O
{	O
LoadLayout	function
(	O
lay	pointer
,	O
&	O
D_canvas	O
)	O
;	O
SetCanvasWindow	function
(	O
D_forecv	O
,	O
0	int
)	O
;	O
}	O
}	O
debug1	O
(	O
"D_user->u_detachwin = %d\n"	pointer
,	O
D_user	O
->	O
u_detachwin	int
)	O
;	O
if	O
(	O
D_user	O
->	O
u_detachwin	int
>=	O
0	int
)	O
fore	pointer
=	O
wtab	pointer
[	O
D_user	O
->	O
u_detachwin	int
]	O
;	O
else	O
fore	pointer
=	O
0	int
;	O
if	O
(	O
D_user	O
->	O
u_detachotherwin	int
>=	O
0	int
)	O
D_other	O
=	O
wtab	pointer
[	O
D_user	O
->	O
u_detachotherwin	int
]	O
;	O
noshowwin	int
=	O
0	int
;	O
if	O
(	O
*	O
m	union
->	O
m	union
.	O
attach	struct
.	O
preselect	array
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
preselect	array
,	O
"="	pointer
)	O
)	O
fore	pointer
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
preselect	array
,	O
"-"	pointer
)	O
)	O
{	O
fore	pointer
=	O
0	int
;	O
noshowwin	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
preselect	array
,	O
"+"	pointer
)	O
)	O
{	O
struct	O
action	struct
newscreen	struct
;	O
char	O
*	O
na	pointer
=	O
0	int
;	O
newscreen	struct
.	O
nr	int
=	O
RC_SCREEN	int
;	O
newscreen	struct
.	O
args	pointer
=	O
&	O
na	pointer
;	O
newscreen	struct
.	O
quiet	int
=	O
0	int
;	O
DoAction	function
(	O
&	O
newscreen	struct
,	O
-	O
1	int
)	O
;	O
}	O
else	O
fore	pointer
=	O
FindNiceWindow	function
(	O
fore	pointer
,	O
m	union
->	O
m	union
.	O
attach	struct
.	O
preselect	array
)	O
;	O
}	O
else	O
fore	pointer
=	O
FindNiceWindow	function
(	O
fore	pointer
,	O
0	int
)	O
;	O
if	O
(	O
fore	pointer
)	O
SetForeWindow	function
(	O
fore	pointer
)	O
;	O
else	O
if	O
(	O
!	O
noshowwin	int
)	O
{	O
if	O
(	O
!	O
AclCheckPermCmd	function
(	O
D_user	O
,	O
ACL_EXEC	int
,	O
&	O
comms	array
[	O
RC_WINDOWLIST	int
]	O
)	O
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
display_windows	function
(	O
1	int
,	O
WLIST_NUM	int
,	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
noshowwin	int
=	O
1	int
;	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
}	O
Activate	function
(	O
0	int
)	O
;	O
ResetIdle	function
(	O
)	O
;	O
if	O
(	O
!	O
D_fore	O
&&	O
!	O
noshowwin	int
)	O
ShowWindows	function
(	O
-	O
1	int
)	O
;	O
if	O
(	O
displays	pointer
->	O
d_next	pointer
==	O
0	int
&&	O
console_window	pointer
)	O
{	O
if	O
(	O
TtyGrabConsole	function
(	O
console_window	pointer
->	O
w_ptyfd	int
,	O
1	int
,	O
"reattach"	pointer
)	O
==	O
0	int
)	O
Msg	function
(	O
0	int
,	O
"console %s is on window %d"	pointer
,	O
HostName	array
,	O
console_window	pointer
->	O
w_number	int
)	O
;	O
}	O
debug	O
(	O
"activated...\n"	pointer
)	O
;	O
}	O
static	O
void	O
FinishDetach	function
(	O
m	union
)	O
struct	O
msg	struct
*	O
m	union
;	O
{	O
struct	O
display	struct
*	O
next	pointer
,	O
*	O
*	O
d	int
,	O
*	O
det	pointer
;	O
int	O
pid	int
;	O
if	O
(	O
m	union
->	O
type	enum
==	O
MSG_ATTACH	int
)	O
pid	int
=	O
D_userpid	O
;	O
else	O
pid	int
=	O
m	union
->	O
m	union
.	O
detach	struct
.	O
dpid	int
;	O
for	O
(	O
d	int
=	O
&	O
displays	pointer
;	O
(	O
det	pointer
=	O
*	O
d	int
)	O
;	O
d	int
=	O
&	O
det	pointer
->	O
d_next	pointer
)	O
{	O
if	O
(	O
det	pointer
->	O
d_userpid	int
==	O
pid	int
)	O
break	O
;	O
}	O
if	O
(	O
det	pointer
)	O
{	O
*	O
d	int
=	O
det	pointer
->	O
d_next	pointer
;	O
det	pointer
->	O
d_next	pointer
=	O
0	int
;	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
next	pointer
)	O
{	O
next	pointer
=	O
display	struct
->	O
d_next	pointer
;	O
if	O
(	O
m	union
->	O
type	enum
==	O
MSG_POW_DETACH	int
)	O
Detach	function
(	O
D_REMOTE_POWER	int
)	O
;	O
else	O
if	O
(	O
m	union
->	O
type	enum
==	O
MSG_DETACH	int
)	O
Detach	function
(	O
D_REMOTE	int
)	O
;	O
else	O
if	O
(	O
m	union
->	O
type	enum
==	O
MSG_ATTACH	int
)	O
{	O
if	O
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
detachfirst	int
==	O
MSG_POW_DETACH	int
)	O
Detach	function
(	O
D_REMOTE_POWER	int
)	O
;	O
else	O
if	O
(	O
m	union
->	O
m	union
.	O
attach	struct
.	O
detachfirst	int
==	O
MSG_DETACH	int
)	O
Detach	function
(	O
D_REMOTE	int
)	O
;	O
}	O
}	O
display	struct
=	O
displays	pointer
=	O
det	pointer
;	O
if	O
(	O
m	union
->	O
type	enum
!=	O
MSG_ATTACH	int
)	O
{	O
if	O
(	O
display	struct
)	O
FreeDisplay	function
(	O
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIGCONT	int
)	O
;	O
}	O
}	O
static	O
void	O
PasswordProcessInput	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
struct	O
pwdata	struct
{	O
int	O
l	int
;	O
char	O
buf	pointer
[	O
MAXLOGINLEN	int
+	O
1	int
]	O
;	O
struct	O
msg	struct
m	union
;	O
}	O
;	O
static	O
void	O
AskPassword	function
(	O
m	union
)	O
struct	O
msg	struct
*	O
m	union
;	O
{	O
struct	O
pwdata	struct
*	O
pwdata	struct
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
pwdata	struct
=	O
(	O
struct	O
pwdata	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
pwdata	struct
)	O
)	O
;	O
if	O
(	O
!	O
pwdata	struct
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
pwdata	struct
->	O
l	int
=	O
0	int
;	O
pwdata	struct
->	O
m	union
=	O
*	O
m	union
;	O
D_processinputdata	O
=	O
(	O
char	O
*	O
)	O
pwdata	struct
;	O
D_processinput	O
=	O
PasswordProcessInput	function
;	O
AddStr	function
(	O
"Screen password: "	pointer
)	O
;	O
}	O
static	O
void	O
PasswordProcessInput	function
(	O
ibuf	pointer
,	O
ilen	int
)	O
char	O
*	O
ibuf	pointer
;	O
int	O
ilen	int
;	O
{	O
struct	O
pwdata	struct
*	O
pwdata	struct
;	O
int	O
c	int
,	O
l	int
;	O
char	O
*	O
up	pointer
;	O
int	O
pid	int
=	O
D_userpid	O
;	O
pwdata	struct
=	O
(	O
struct	O
pwdata	struct
*	O
)	O
D_processinputdata	O
;	O
l	int
=	O
pwdata	struct
->	O
l	int
;	O
while	O
(	O
ilen	int
--	O
>	O
0	int
)	O
{	O
c	int
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
ibuf	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
||	O
c	int
==	O
'\n'	O
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
up	pointer
=	O
D_user	O
->	O
u_password	pointer
;	O
pwdata	struct
->	O
buf	pointer
[	O
l	int
]	O
=	O
0	int
;	O
buf	pointer
=	O
crypt	function
(	O
pwdata	struct
->	O
buf	pointer
,	O
up	pointer
)	O
;	O
if	O
(	O
!	O
buf	pointer
||	O
strncmp	function
(	O
buf	pointer
,	O
up	pointer
,	O
strlen	function
(	O
up	pointer
)	O
)	O
)	O
{	O
bzero	function
(	O
pwdata	struct
->	O
buf	pointer
,	O
sizeof	O
(	O
pwdata	struct
->	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
AddStr	function
(	O
"\r\ncrypt() failed.\r\n"	pointer
)	O
;	O
else	O
AddStr	function
(	O
"\r\nPassword incorrect.\r\n"	pointer
)	O
;	O
D_processinputdata	O
=	O
0	int
;	O
FreeDisplay	function
(	O
)	O
;	O
Msg	function
(	O
0	int
,	O
"Illegal reattach attempt from terminal %s."	pointer
,	O
pwdata	struct
->	O
m	union
.	O
m_tty	array
)	O
;	O
free	function
(	O
pwdata	struct
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
;	O
}	O
bzero	function
(	O
pwdata	struct
->	O
buf	pointer
,	O
sizeof	O
(	O
pwdata	struct
->	O
buf	pointer
)	O
)	O
;	O
AddStr	function
(	O
"\r\n"	pointer
)	O
;	O
D_processinputdata	O
=	O
0	int
;	O
D_processinput	O
=	O
ProcessInput	function
;	O
if	O
(	O
pwdata	struct
->	O
m	union
.	O
type	enum
==	O
MSG_DETACH	int
||	O
pwdata	struct
->	O
m	union
.	O
type	enum
==	O
MSG_POW_DETACH	int
)	O
FinishDetach	function
(	O
&	O
pwdata	struct
->	O
m	union
)	O
;	O
else	O
FinishAttach	function
(	O
&	O
pwdata	struct
->	O
m	union
)	O
;	O
free	function
(	O
pwdata	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
==	O
Ctrl	O
(	O
'c'	O
)	O
)	O
{	O
AddStr	function
(	O
"\r\n"	pointer
)	O
;	O
FreeDisplay	function
(	O
)	O
;	O
Kill	function
(	O
pid	int
,	O
SIG_BYE	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
==	O
'\b'	O
||	O
c	int
==	O
0177	int
)	O
{	O
if	O
(	O
l	int
>	O
0	int
)	O
l	int
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
Ctrl	O
(	O
'u'	O
)	O
)	O
{	O
l	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
l	int
<	O
(	O
int	O
)	O
sizeof	O
(	O
pwdata	struct
->	O
buf	pointer
)	O
-	O
1	int
)	O
pwdata	struct
->	O
buf	pointer
[	O
l	int
++	O
]	O
=	O
c	int
;	O
}	O
pwdata	struct
->	O
l	int
=	O
l	int
;	O
}	O
static	O
char	O
*	O
strncpy_escape_quote	function
(	O
dst	pointer
,	O
src	pointer
,	O
end	pointer
)	O
char	O
*	O
dst	pointer
;	O
const	O
char	O
*	O
src	pointer
,	O
*	O
end	pointer
;	O
{	O
while	O
(	O
*	O
src	pointer
&&	O
dst	pointer
<	O
end	pointer
)	O
{	O
if	O
(	O
*	O
src	pointer
==	O
'"'	O
)	O
{	O
if	O
(	O
dst	pointer
+	O
2	int
<	O
end	pointer
)	O
*	O
dst	pointer
++	O
=	O
'\\'	O
;	O
else	O
return	O
NULL	O
;	O
}	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
}	O
if	O
(	O
dst	pointer
>=	O
end	pointer
)	O
return	O
NULL	O
;	O
*	O
dst	pointer
=	O
'\0'	O
;	O
return	O
dst	pointer
;	O
}	O
static	O
void	O
DoCommandMsg	function
(	O
mp	pointer
)	O
struct	O
msg	struct
*	O
mp	pointer
;	O
{	O
char	O
*	O
args	pointer
[	O
MAXARGS	int
]	O
;	O
int	O
argl	pointer
[	O
MAXARGS	int
]	O
;	O
char	O
fullcmd	array
[	O
MAXSTR	int
]	O
;	O
register	O
char	O
*	O
fc	pointer
;	O
int	O
n	pointer
;	O
register	O
char	O
*	O
p	pointer
=	O
mp	pointer
->	O
m	union
.	O
command	struct
.	O
cmd	array
;	O
struct	O
acluser	struct
*	O
user	pointer
;	O
extern	O
struct	O
acluser	struct
*	O
EffectiveAclUser	pointer
;	O
n	pointer
=	O
mp	pointer
->	O
m	union
.	O
command	struct
.	O
nargs	int
;	O
if	O
(	O
n	pointer
>	O
MAXARGS	int
-	O
1	int
)	O
n	pointer
=	O
MAXARGS	int
-	O
1	int
;	O
for	O
(	O
fc	pointer
=	O
fullcmd	array
;	O
n	pointer
>	O
0	int
;	O
n	pointer
--	O
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
p	pointer
)	O
;	O
*	O
fc	pointer
++	O
=	O
'"'	O
;	O
if	O
(	O
!	O
(	O
fc	pointer
=	O
strncpy_escape_quote	function
(	O
fc	pointer
,	O
p	pointer
,	O
fullcmd	array
+	O
sizeof	O
(	O
fullcmd	array
)	O
-	O
2	int
)	O
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"Remote command too long."	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
p	pointer
+=	O
len	int
+	O
1	int
;	O
*	O
fc	pointer
++	O
=	O
'"'	O
;	O
*	O
fc	pointer
++	O
=	O
' '	O
;	O
}	O
if	O
(	O
fc	pointer
!=	O
fullcmd	array
)	O
*	O
--	O
fc	pointer
=	O
0	int
;	O
if	O
(	O
Parse	function
(	O
fullcmd	array
,	O
sizeof	O
fullcmd	array
,	O
args	pointer
,	O
argl	pointer
)	O
<=	O
0	int
)	O
{	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
user	pointer
=	O
*	O
FindUserPtr	function
(	O
mp	pointer
->	O
m	union
.	O
attach	struct
.	O
auser	array
)	O
;	O
if	O
(	O
user	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Unknown user %s tried to send a command!"	pointer
,	O
mp	pointer
->	O
m	union
.	O
attach	struct
.	O
auser	array
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
user	pointer
->	O
u_password	pointer
&&	O
*	O
user	pointer
->	O
u_password	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"User %s has a password, cannot use remote commands (using -Q or -X option)."	pointer
,	O
mp	pointer
->	O
m	union
.	O
attach	struct
.	O
auser	array
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
!	O
display	struct
)	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
if	O
(	O
D_user	O
==	O
user	pointer
)	O
break	O
;	O
for	O
(	O
fore	pointer
=	O
windows	pointer
;	O
fore	pointer
;	O
fore	pointer
=	O
fore	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
TTYCMP	O
(	O
mp	pointer
->	O
m_tty	array
,	O
fore	pointer
->	O
w_tty	array
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
display	struct
=	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
?	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
:	O
0	int
;	O
if	O
(	O
!	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
||	O
!	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
)	O
fore	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
display	struct
)	O
display	struct
=	O
displays	pointer
;	O
if	O
(	O
*	O
mp	pointer
->	O
m	union
.	O
command	struct
.	O
preselect	array
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
mp	pointer
->	O
m	union
.	O
command	struct
.	O
preselect	array
,	O
"-"	pointer
)	O
)	O
{	O
i	int
=	O
WindowByNoN	function
(	O
mp	pointer
->	O
m	union
.	O
command	struct
.	O
preselect	array
)	O
;	O
if	O
(	O
i	int
<	O
0	int
||	O
!	O
wtab	pointer
[	O
i	int
]	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"Could not find pre-select window."	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
}	O
fore	pointer
=	O
i	int
>=	O
0	int
?	O
wtab	pointer
[	O
i	int
]	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
fore	pointer
)	O
{	O
if	O
(	O
display	struct
&&	O
D_user	O
==	O
user	pointer
)	O
fore	pointer
=	O
Layer2Window	O
(	O
display	struct
->	O
d_forecv	pointer
->	O
c_layer	pointer
)	O
;	O
if	O
(	O
!	O
fore	pointer
)	O
{	O
fore	pointer
=	O
user	pointer
->	O
u_detachwin	int
>=	O
0	int
?	O
wtab	pointer
[	O
user	pointer
->	O
u_detachwin	int
]	O
:	O
0	int
;	O
fore	pointer
=	O
FindNiceWindow	function
(	O
fore	pointer
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
fore	pointer
)	O
fore	pointer
=	O
windows	pointer
;	O
EffectiveAclUser	pointer
=	O
user	pointer
;	O
if	O
(	O
*	O
args	pointer
)	O
{	O
char	O
*	O
oldrcname	pointer
=	O
rc_name	pointer
;	O
rc_name	pointer
=	O
"-X"	pointer
;	O
debug3	O
(	O
"Running command on display %x window %x (%d)\n"	pointer
,	O
display	struct
,	O
fore	pointer
,	O
fore	pointer
?	O
fore	pointer
->	O
w_number	int
:	O
-	O
1	int
)	O
;	O
flayer	pointer
=	O
fore	pointer
?	O
&	O
fore	pointer
->	O
w_layer	struct
:	O
0	int
;	O
if	O
(	O
fore	pointer
&&	O
fore	pointer
->	O
w_savelayer	pointer
&&	O
(	O
fore	pointer
->	O
w_blocked	int
||	O
fore	pointer
->	O
w_savelayer	pointer
->	O
l_cvlist	pointer
==	O
0	int
)	O
)	O
flayer	pointer
=	O
fore	pointer
->	O
w_savelayer	pointer
;	O
DoCommand	function
(	O
args	pointer
,	O
argl	pointer
)	O
;	O
rc_name	pointer
=	O
oldrcname	pointer
;	O
}	O
EffectiveAclUser	pointer
=	O
0	int
;	O
}	O
int	O
SendAttachMsg	function
(	O
s	int
,	O
m	union
,	O
fd	int
)	O
int	O
s	int
;	O
struct	O
msg	struct
*	O
m	union
;	O
int	O
fd	int
;	O
{	O
int	O
r	int
;	O
struct	O
msghdr	struct
msg	struct
;	O
struct	O
iovec	struct
iov	struct
;	O
char	O
buf	pointer
[	O
CMSG_SPACE	O
(	O
sizeof	O
(	O
int	O
)	O
)	O
]	O
;	O
struct	O
cmsghdr	struct
*	O
cmsg	pointer
;	O
iov	struct
.	O
iov_base	pointer
=	O
(	O
char	O
*	O
)	O
m	union
;	O
iov	struct
.	O
iov_len	long
=	O
sizeof	O
(	O
*	O
m	union
)	O
;	O
bzero	function
(	O
&	O
msg	struct
,	O
sizeof	O
(	O
msg	struct
)	O
)	O
;	O
msg	struct
.	O
msg_name	pointer
=	O
0	int
;	O
msg	struct
.	O
msg_namelen	int
=	O
0	int
;	O
msg	struct
.	O
msg_iov	pointer
=	O
&	O
iov	struct
;	O
msg	struct
.	O
msg_iovlen	long
=	O
1	int
;	O
msg	struct
.	O
msg_control	pointer
=	O
buf	pointer
;	O
msg	struct
.	O
msg_controllen	long
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
cmsg	pointer
=	O
CMSG_FIRSTHDR	O
(	O
&	O
msg	struct
)	O
;	O
cmsg	pointer
->	O
cmsg_level	int
=	O
SOL_SOCKET	int
;	O
cmsg	pointer
->	O
cmsg_type	int
=	O
SCM_RIGHTS	int
;	O
cmsg	pointer
->	O
cmsg_len	long
=	O
CMSG_LEN	O
(	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
bcopy	function
(	O
&	O
fd	int
,	O
CMSG_DATA	O
(	O
cmsg	pointer
)	O
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
msg	struct
.	O
msg_controllen	long
=	O
cmsg	pointer
->	O
cmsg_len	long
;	O
while	O
(	O
1	int
)	O
{	O
r	int
=	O
sendmsg	function
(	O
s	int
,	O
&	O
msg	struct
,	O
0	int
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
}	O
bool	bool
IsSocket	function
(	O
path	pointer
)	O
const	O
char	O
*	O
path	pointer
;	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
return	O
false	int
;	O
return	O
S_ISSOCK	O
(	O
st	struct
.	O
st_mode	int
)	O
;	O
}	O
