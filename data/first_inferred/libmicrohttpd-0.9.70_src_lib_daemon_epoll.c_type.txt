enum	O
MHD_StatusCode	enum
MHD_daemon_epoll_	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
bool	bool
may_block	bool
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
struct	O
MHD_Connection	struct
*	O
prev	pointer
;	O
struct	O
epoll_event	struct
events	int
[	O
MAX_EVENTS	int
]	O
;	O
struct	O
epoll_event	struct
event	struct
;	O
int	O
timeout_ms	int
;	O
MHD_UNSIGNED_LONG_LONG	O
timeout_ll	long long
;	O
int	O
num_events	int
;	O
unsigned	O
int	O
i	int
;	O
MHD_socket	int
ls	int
;	O
if	O
(	O
-	O
1	int
==	O
daemon	function
->	O
epoll_fd	int
)	O
return	O
MHD_SC_EPOLL_FD_INVALID	int
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_SC_DAEMON_ALREADY_SHUTDOWN	int
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ls	int
=	O
daemon	function
->	O
listen_socket	int
)	O
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
daemon	function
->	O
connections	int
<	O
daemon	function
->	O
global_connection_limit	int
)	O
&&	O
(	O
!	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
&&	O
(	O
!	O
daemon	function
->	O
at_limit	bool
)	O
)	O
{	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
daemon	function
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
ls	int
,	O
&	O
event	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_EPOLL_CTL_ADD_FAILED	int
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
return	O
MHD_SC_EPOLL_CTL_ADD_FAILED	int
;	O
}	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
ls	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
"Failed to remove listen FD from epoll set\n"	pointer
)	O
;	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
false	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
&&	O
(	O
(	O
daemon	function
->	O
connections	int
==	O
daemon	function
->	O
global_connection_limit	int
)	O
||	O
(	O
daemon	function
->	O
at_limit	bool
)	O
||	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
ls	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to remove listen FD from epoll set\n"	pointer
)	O
)	O
;	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
false	int
;	O
}	O
if	O
(	O
(	O
!	O
daemon	function
->	O
disallow_suspend_resume	bool
)	O
&&	O
(	O
MHD_resume_suspended_connections_	function
(	O
daemon	function
)	O
)	O
)	O
may_block	bool
=	O
false	int
;	O
if	O
(	O
may_block	bool
)	O
{	O
if	O
(	O
MHD_SC_OK	int
==	O
MHD_daemon_get_timeout	function
(	O
daemon	function
,	O
&	O
timeout_ll	long long
)	O
)	O
{	O
if	O
(	O
timeout_ll	long long
>=	O
(	O
MHD_UNSIGNED_LONG_LONG	O
)	O
INT_MAX	O
)	O
timeout_ms	int
=	O
INT_MAX	O
;	O
else	O
timeout_ms	int
=	O
(	O
int	O
)	O
timeout_ll	long long
;	O
}	O
else	O
timeout_ms	int
=	O
-	O
1	int
;	O
}	O
else	O
timeout_ms	int
=	O
0	int
;	O
daemon	function
->	O
data_already_pending	bool
=	O
false	int
;	O
num_events	int
=	O
MAX_EVENTS	int
;	O
while	O
(	O
MAX_EVENTS	int
==	O
num_events	int
)	O
{	O
num_events	int
=	O
epoll_wait	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
events	int
,	O
MAX_EVENTS	int
,	O
timeout_ms	int
)	O
;	O
if	O
(	O
-	O
1	int
==	O
num_events	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_SC_OK	int
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_UNEXPECTED_EPOLL_WAIT_ERROR	int
,	O
_	O
(	O
"Call to epoll_wait failed: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
return	O
MHD_SC_UNEXPECTED_EPOLL_WAIT_ERROR	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
unsigned	O
int	O
)	O
num_events	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
NULL	O
==	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
)	O
continue	O
;	O
if	O
(	O
daemon	function
->	O
epoll_itc_marker	pointer
==	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
)	O
{	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
daemon	function
==	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
)	O
{	O
if	O
(	O
0	int
==	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
(	O
EPOLLERR	int
|	O
EPOLLHUP	int
)	O
)	O
)	O
{	O
unsigned	O
int	O
series_length	int
=	O
0	int
;	O
while	O
(	O
(	O
MHD_SC_OK	int
==	O
MHD_accept_connection_	function
(	O
daemon	function
)	O
)	O
&&	O
(	O
series_length	int
<	O
10	int
)	O
&&	O
(	O
daemon	function
->	O
connections	int
<	O
daemon	function
->	O
global_connection_limit	int
)	O
&&	O
(	O
!	O
daemon	function
->	O
at_limit	bool
)	O
)	O
series_length	int
++	O
;	O
}	O
continue	O
;	O
}	O
pos	long
=	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
;	O
if	O
(	O
0	int
!=	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
(	O
EPOLLPRI	int
|	O
EPOLLERR	int
|	O
EPOLLHUP	int
)	O
)	O
)	O
{	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_ERROR	int
;	O
if	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
{	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
0	int
!=	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
EPOLLIN	int
)	O
)	O
{	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_READ_READY	int
;	O
if	O
(	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
pos	long
->	O
request	pointer
.	O
event_loop_info	enum
)	O
||	O
(	O
pos	long
->	O
request	pointer
.	O
read_buffer_size	long
>	O
pos	long
->	O
request	pointer
.	O
read_buffer_offset	long
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
)	O
{	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
if	O
(	O
0	int
!=	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
EPOLLOUT	int
)	O
)	O
{	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
pos	long
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
)	O
{	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
}	O
}	O
}	O
prev	pointer
=	O
daemon	function
->	O
eready_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prevE	pointer
;	O
MHD_connection_call_handlers_	function
(	O
pos	long
,	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_READ_READY	int
)	O
,	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_WRITE_READY	int
)	O
,	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_ERROR	int
)	O
)	O
;	O
if	O
(	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
(	O
MHD_EPOLL_STATE_SUSPENDED	int
|	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
pos	long
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_READ_READY	int
)	O
)	O
)	O
||	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
pos	long
->	O
request	pointer
.	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_WRITE_READY	int
)	O
)	O
)	O
||	O
(	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
==	O
pos	long
->	O
request	pointer
.	O
event_loop_info	enum
)	O
)	O
{	O
EDLL_remove	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
}	O
prev	pointer
=	O
daemon	function
->	O
manual_timeout_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prevX	pointer
;	O
MHD_request_handle_idle_	function
(	O
&	O
pos	long
->	O
request	pointer
)	O
;	O
}	O
prev	pointer
=	O
daemon	function
->	O
normal_timeout_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prevX	pointer
;	O
MHD_request_handle_idle_	function
(	O
&	O
pos	long
->	O
request	pointer
)	O
;	O
if	O
(	O
MHD_REQUEST_CLOSED	int
!=	O
pos	long
->	O
request	pointer
.	O
state	pointer
)	O
break	O
;	O
}	O
return	O
MHD_SC_OK	int
;	O
}	O
