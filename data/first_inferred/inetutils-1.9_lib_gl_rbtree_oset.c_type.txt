typedef	O
enum	O
color	enum
{	O
BLACK	int
,	O
RED	int
}	O
color_t	enum
;	O
struct	O
gl_oset_node_impl	struct
{	O
struct	O
gl_oset_node_impl	struct
*	O
left	pointer
;	O
struct	O
gl_oset_node_impl	struct
*	O
right	pointer
;	O
struct	O
gl_oset_node_impl	struct
*	O
parent	pointer
;	O
color_t	enum
color	enum
;	O
const	O
void	O
*	O
value	pointer
;	O
}	O
;	O
typedef	O
struct	O
gl_oset_node_impl	struct
*	O
gl_oset_node_t	pointer
;	O
struct	O
gl_oset_impl	struct
{	O
struct	O
gl_oset_impl_base	struct
base	struct
;	O
struct	O
gl_oset_node_impl	struct
*	O
root	pointer
;	O
size_t	long
count	long
;	O
}	O
;	O
static	O
inline	O
gl_oset_node_t	pointer
rotate_left	function
(	O
gl_oset_node_t	pointer
b_node	pointer
,	O
gl_oset_node_t	pointer
d_node	pointer
)	O
{	O
gl_oset_node_t	pointer
c_node	pointer
=	O
d_node	pointer
->	O
left	pointer
;	O
b_node	pointer
->	O
right	pointer
=	O
c_node	pointer
;	O
d_node	pointer
->	O
left	pointer
=	O
b_node	pointer
;	O
d_node	pointer
->	O
parent	pointer
=	O
b_node	pointer
->	O
parent	pointer
;	O
b_node	pointer
->	O
parent	pointer
=	O
d_node	pointer
;	O
if	O
(	O
c_node	pointer
!=	O
NULL	O
)	O
c_node	pointer
->	O
parent	pointer
=	O
b_node	pointer
;	O
return	O
d_node	pointer
;	O
}	O
static	O
inline	O
gl_oset_node_t	pointer
rotate_right	function
(	O
gl_oset_node_t	pointer
b_node	pointer
,	O
gl_oset_node_t	pointer
d_node	pointer
)	O
{	O
gl_oset_node_t	pointer
c_node	pointer
=	O
b_node	pointer
->	O
right	pointer
;	O
d_node	pointer
->	O
left	pointer
=	O
c_node	pointer
;	O
b_node	pointer
->	O
right	pointer
=	O
d_node	pointer
;	O
b_node	pointer
->	O
parent	pointer
=	O
d_node	pointer
->	O
parent	pointer
;	O
d_node	pointer
->	O
parent	pointer
=	O
b_node	pointer
;	O
if	O
(	O
c_node	pointer
!=	O
NULL	O
)	O
c_node	pointer
->	O
parent	pointer
=	O
d_node	pointer
;	O
return	O
b_node	pointer
;	O
}	O
static	O
void	O
rebalance_after_add	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
,	O
gl_oset_node_t	pointer
parent	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
gl_oset_node_t	pointer
grandparent	pointer
;	O
gl_oset_node_t	pointer
uncle	pointer
;	O
if	O
(	O
parent	pointer
->	O
color	enum
==	O
BLACK	int
)	O
{	O
node	pointer
->	O
color	enum
=	O
RED	int
;	O
return	O
;	O
}	O
grandparent	pointer
=	O
parent	pointer
->	O
parent	pointer
;	O
if	O
(	O
grandparent	pointer
->	O
left	pointer
==	O
parent	pointer
)	O
uncle	pointer
=	O
grandparent	pointer
->	O
right	pointer
;	O
else	O
if	O
(	O
grandparent	pointer
->	O
right	pointer
==	O
parent	pointer
)	O
uncle	pointer
=	O
grandparent	pointer
->	O
left	pointer
;	O
else	O
abort	function
(	O
)	O
;	O
if	O
(	O
uncle	pointer
!=	O
NULL	O
&&	O
uncle	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
node	pointer
->	O
color	enum
=	O
RED	int
;	O
parent	pointer
->	O
color	enum
=	O
uncle	pointer
->	O
color	enum
=	O
BLACK	int
;	O
node	pointer
=	O
grandparent	pointer
;	O
}	O
else	O
{	O
gl_oset_node_t	pointer
*	O
grandparentp	pointer
;	O
if	O
(	O
grandparent	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
grandparentp	pointer
=	O
&	O
set	pointer
->	O
root	pointer
;	O
else	O
if	O
(	O
grandparent	pointer
->	O
parent	pointer
->	O
left	pointer
==	O
grandparent	pointer
)	O
grandparentp	pointer
=	O
&	O
grandparent	pointer
->	O
parent	pointer
->	O
left	pointer
;	O
else	O
if	O
(	O
grandparent	pointer
->	O
parent	pointer
->	O
right	pointer
==	O
grandparent	pointer
)	O
grandparentp	pointer
=	O
&	O
grandparent	pointer
->	O
parent	pointer
->	O
right	pointer
;	O
else	O
abort	function
(	O
)	O
;	O
if	O
(	O
grandparent	pointer
->	O
left	pointer
==	O
parent	pointer
)	O
{	O
if	O
(	O
parent	pointer
->	O
right	pointer
==	O
node	pointer
)	O
{	O
grandparent	pointer
->	O
left	pointer
=	O
rotate_left	function
(	O
parent	pointer
,	O
node	pointer
)	O
;	O
node	pointer
=	O
parent	pointer
;	O
parent	pointer
=	O
grandparent	pointer
->	O
left	pointer
;	O
}	O
*	O
grandparentp	pointer
=	O
rotate_right	function
(	O
parent	pointer
,	O
grandparent	pointer
)	O
;	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
node	pointer
->	O
color	enum
=	O
grandparent	pointer
->	O
color	enum
=	O
RED	int
;	O
}	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
{	O
grandparent	pointer
->	O
right	pointer
=	O
rotate_right	function
(	O
node	pointer
,	O
parent	pointer
)	O
;	O
node	pointer
=	O
parent	pointer
;	O
parent	pointer
=	O
grandparent	pointer
->	O
right	pointer
;	O
}	O
*	O
grandparentp	pointer
=	O
rotate_left	function
(	O
grandparent	pointer
,	O
parent	pointer
)	O
;	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
node	pointer
->	O
color	enum
=	O
grandparent	pointer
->	O
color	enum
=	O
RED	int
;	O
}	O
return	O
;	O
}	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
{	O
node	pointer
->	O
color	enum
=	O
BLACK	int
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
rebalance_after_remove	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
child	pointer
,	O
gl_oset_node_t	pointer
parent	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
gl_oset_node_t	pointer
*	O
parentp	pointer
;	O
if	O
(	O
parent	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
parentp	pointer
=	O
&	O
set	pointer
->	O
root	pointer
;	O
else	O
if	O
(	O
parent	pointer
->	O
parent	pointer
->	O
left	pointer
==	O
parent	pointer
)	O
parentp	pointer
=	O
&	O
parent	pointer
->	O
parent	pointer
->	O
left	pointer
;	O
else	O
if	O
(	O
parent	pointer
->	O
parent	pointer
->	O
right	pointer
==	O
parent	pointer
)	O
parentp	pointer
=	O
&	O
parent	pointer
->	O
parent	pointer
->	O
right	pointer
;	O
else	O
abort	function
(	O
)	O
;	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
child	pointer
)	O
{	O
gl_oset_node_t	pointer
sibling	pointer
=	O
parent	pointer
->	O
right	pointer
;	O
if	O
(	O
sibling	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
*	O
parentp	pointer
=	O
rotate_left	function
(	O
parent	pointer
,	O
sibling	pointer
)	O
;	O
parent	pointer
->	O
color	enum
=	O
RED	int
;	O
sibling	pointer
->	O
color	enum
=	O
BLACK	int
;	O
parentp	pointer
=	O
&	O
sibling	pointer
->	O
left	pointer
;	O
sibling	pointer
=	O
parent	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
sibling	pointer
->	O
right	pointer
!=	O
NULL	O
&&	O
sibling	pointer
->	O
right	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
*	O
parentp	pointer
=	O
rotate_left	function
(	O
parent	pointer
,	O
sibling	pointer
)	O
;	O
sibling	pointer
->	O
color	enum
=	O
parent	pointer
->	O
color	enum
;	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
sibling	pointer
->	O
right	pointer
->	O
color	enum
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
sibling	pointer
->	O
left	pointer
!=	O
NULL	O
&&	O
sibling	pointer
->	O
left	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
parent	pointer
->	O
right	pointer
=	O
rotate_right	function
(	O
sibling	pointer
->	O
left	pointer
,	O
sibling	pointer
)	O
;	O
sibling	pointer
->	O
color	enum
=	O
RED	int
;	O
sibling	pointer
=	O
parent	pointer
->	O
right	pointer
;	O
sibling	pointer
->	O
color	enum
=	O
BLACK	int
;	O
*	O
parentp	pointer
=	O
rotate_left	function
(	O
parent	pointer
,	O
sibling	pointer
)	O
;	O
sibling	pointer
->	O
color	enum
=	O
parent	pointer
->	O
color	enum
;	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
sibling	pointer
->	O
right	pointer
->	O
color	enum
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
color	enum
==	O
BLACK	int
)	O
{	O
sibling	pointer
->	O
color	enum
=	O
RED	int
;	O
child	pointer
=	O
parent	pointer
;	O
}	O
else	O
{	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
sibling	pointer
->	O
color	enum
=	O
RED	int
;	O
return	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
parent	pointer
->	O
right	pointer
==	O
child	pointer
)	O
{	O
gl_oset_node_t	pointer
sibling	pointer
=	O
parent	pointer
->	O
left	pointer
;	O
if	O
(	O
sibling	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
*	O
parentp	pointer
=	O
rotate_right	function
(	O
sibling	pointer
,	O
parent	pointer
)	O
;	O
parent	pointer
->	O
color	enum
=	O
RED	int
;	O
sibling	pointer
->	O
color	enum
=	O
BLACK	int
;	O
parentp	pointer
=	O
&	O
sibling	pointer
->	O
right	pointer
;	O
sibling	pointer
=	O
parent	pointer
->	O
left	pointer
;	O
}	O
if	O
(	O
sibling	pointer
->	O
left	pointer
!=	O
NULL	O
&&	O
sibling	pointer
->	O
left	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
*	O
parentp	pointer
=	O
rotate_right	function
(	O
sibling	pointer
,	O
parent	pointer
)	O
;	O
sibling	pointer
->	O
color	enum
=	O
parent	pointer
->	O
color	enum
;	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
sibling	pointer
->	O
left	pointer
->	O
color	enum
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
sibling	pointer
->	O
right	pointer
!=	O
NULL	O
&&	O
sibling	pointer
->	O
right	pointer
->	O
color	enum
==	O
RED	int
)	O
{	O
parent	pointer
->	O
left	pointer
=	O
rotate_left	function
(	O
sibling	pointer
,	O
sibling	pointer
->	O
right	pointer
)	O
;	O
sibling	pointer
->	O
color	enum
=	O
RED	int
;	O
sibling	pointer
=	O
parent	pointer
->	O
left	pointer
;	O
sibling	pointer
->	O
color	enum
=	O
BLACK	int
;	O
*	O
parentp	pointer
=	O
rotate_right	function
(	O
sibling	pointer
,	O
parent	pointer
)	O
;	O
sibling	pointer
->	O
color	enum
=	O
parent	pointer
->	O
color	enum
;	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
sibling	pointer
->	O
left	pointer
->	O
color	enum
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
color	enum
==	O
BLACK	int
)	O
{	O
sibling	pointer
->	O
color	enum
=	O
RED	int
;	O
child	pointer
=	O
parent	pointer
;	O
}	O
else	O
{	O
parent	pointer
->	O
color	enum
=	O
BLACK	int
;	O
sibling	pointer
->	O
color	enum
=	O
RED	int
;	O
return	O
;	O
}	O
}	O
}	O
else	O
abort	function
(	O
)	O
;	O
parent	pointer
=	O
child	pointer
->	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
return	O
;	O
}	O
}	O
static	O
gl_oset_node_t	pointer
gl_tree_nx_add_first	function
(	O
gl_oset_t	pointer
set	pointer
,	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
gl_oset_node_t	pointer
new_node	pointer
=	O
(	O
struct	O
gl_oset_node_impl	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct
)	O
)	O
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	pointer
->	O
left	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
right	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
value	pointer
=	O
elt	pointer
;	O
if	O
(	O
set	pointer
->	O
root	pointer
==	O
NULL	O
)	O
{	O
new_node	pointer
->	O
color	enum
=	O
BLACK	int
;	O
set	pointer
->	O
root	pointer
=	O
new_node	pointer
;	O
new_node	pointer
->	O
parent	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
gl_oset_node_t	pointer
node	pointer
;	O
for	O
(	O
node	pointer
=	O
set	pointer
->	O
root	pointer
;	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
;	O
)	O
node	pointer
=	O
node	pointer
->	O
left	pointer
;	O
node	pointer
->	O
left	pointer
=	O
new_node	pointer
;	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
rebalance_after_add	function
(	O
set	pointer
,	O
new_node	pointer
,	O
node	pointer
)	O
;	O
}	O
set	pointer
->	O
count	long
++	O
;	O
return	O
new_node	pointer
;	O
}	O
static	O
gl_oset_node_t	pointer
gl_tree_nx_add_before	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
,	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
gl_oset_node_t	pointer
new_node	pointer
=	O
(	O
struct	O
gl_oset_node_impl	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct
)	O
)	O
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	pointer
->	O
left	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
right	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
value	pointer
=	O
elt	pointer
;	O
if	O
(	O
node	pointer
->	O
left	pointer
==	O
NULL	O
)	O
node	pointer
->	O
left	pointer
=	O
new_node	pointer
;	O
else	O
{	O
for	O
(	O
node	pointer
=	O
node	pointer
->	O
left	pointer
;	O
node	pointer
->	O
right	pointer
!=	O
NULL	O
;	O
)	O
node	pointer
=	O
node	pointer
->	O
right	pointer
;	O
node	pointer
->	O
right	pointer
=	O
new_node	pointer
;	O
}	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
rebalance_after_add	function
(	O
set	pointer
,	O
new_node	pointer
,	O
node	pointer
)	O
;	O
set	pointer
->	O
count	long
++	O
;	O
return	O
new_node	pointer
;	O
}	O
static	O
gl_oset_node_t	pointer
gl_tree_nx_add_after	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
,	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
gl_oset_node_t	pointer
new_node	pointer
=	O
(	O
struct	O
gl_oset_node_impl	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct
)	O
)	O
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	pointer
->	O
left	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
right	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
value	pointer
=	O
elt	pointer
;	O
if	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
)	O
node	pointer
->	O
right	pointer
=	O
new_node	pointer
;	O
else	O
{	O
for	O
(	O
node	pointer
=	O
node	pointer
->	O
right	pointer
;	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
;	O
)	O
node	pointer
=	O
node	pointer
->	O
left	pointer
;	O
node	pointer
->	O
left	pointer
=	O
new_node	pointer
;	O
}	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
rebalance_after_add	function
(	O
set	pointer
,	O
new_node	pointer
,	O
node	pointer
)	O
;	O
set	pointer
->	O
count	long
++	O
;	O
return	O
new_node	pointer
;	O
}	O
static	O
bool	bool
gl_tree_remove_node	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
)	O
{	O
gl_oset_node_t	pointer
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
if	O
(	O
node	pointer
->	O
left	pointer
==	O
NULL	O
)	O
{	O
gl_oset_node_t	pointer
child	pointer
=	O
node	pointer
->	O
right	pointer
;	O
if	O
(	O
child	pointer
!=	O
NULL	O
)	O
{	O
child	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
child	pointer
->	O
color	enum
=	O
BLACK	int
;	O
}	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
set	pointer
->	O
root	pointer
=	O
child	pointer
;	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
parent	pointer
->	O
left	pointer
=	O
child	pointer
;	O
else	O
parent	pointer
->	O
right	pointer
=	O
child	pointer
;	O
if	O
(	O
child	pointer
==	O
NULL	O
&&	O
node	pointer
->	O
color	enum
==	O
BLACK	int
)	O
rebalance_after_remove	function
(	O
set	pointer
,	O
child	pointer
,	O
parent	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
)	O
{	O
gl_oset_node_t	pointer
child	pointer
=	O
node	pointer
->	O
left	pointer
;	O
child	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
child	pointer
->	O
color	enum
=	O
BLACK	int
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
set	pointer
->	O
root	pointer
=	O
child	pointer
;	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
parent	pointer
->	O
left	pointer
=	O
child	pointer
;	O
else	O
parent	pointer
->	O
right	pointer
=	O
child	pointer
;	O
}	O
}	O
else	O
{	O
gl_oset_node_t	pointer
subst	pointer
;	O
gl_oset_node_t	pointer
subst_parent	pointer
;	O
gl_oset_node_t	pointer
child	pointer
;	O
color_t	enum
removed_color	enum
;	O
for	O
(	O
subst	pointer
=	O
node	pointer
->	O
left	pointer
;	O
subst	pointer
->	O
right	pointer
!=	O
NULL	O
;	O
)	O
subst	pointer
=	O
subst	pointer
->	O
right	pointer
;	O
subst_parent	pointer
=	O
subst	pointer
->	O
parent	pointer
;	O
child	pointer
=	O
subst	pointer
->	O
left	pointer
;	O
removed_color	enum
=	O
subst	pointer
->	O
color	enum
;	O
if	O
(	O
subst_parent	pointer
!=	O
node	pointer
)	O
{	O
if	O
(	O
child	pointer
!=	O
NULL	O
)	O
child	pointer
->	O
parent	pointer
=	O
subst_parent	pointer
;	O
subst_parent	pointer
->	O
right	pointer
=	O
child	pointer
;	O
}	O
if	O
(	O
subst_parent	pointer
!=	O
node	pointer
)	O
{	O
subst	pointer
->	O
left	pointer
=	O
node	pointer
->	O
left	pointer
;	O
subst	pointer
->	O
left	pointer
->	O
parent	pointer
=	O
subst	pointer
;	O
}	O
subst	pointer
->	O
right	pointer
=	O
node	pointer
->	O
right	pointer
;	O
subst	pointer
->	O
right	pointer
->	O
parent	pointer
=	O
subst	pointer
;	O
subst	pointer
->	O
color	enum
=	O
node	pointer
->	O
color	enum
;	O
subst	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
set	pointer
->	O
root	pointer
=	O
subst	pointer
;	O
else	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
parent	pointer
->	O
left	pointer
=	O
subst	pointer
;	O
else	O
parent	pointer
->	O
right	pointer
=	O
subst	pointer
;	O
if	O
(	O
removed_color	enum
==	O
BLACK	int
)	O
{	O
if	O
(	O
child	pointer
!=	O
NULL	O
&&	O
child	pointer
->	O
color	enum
==	O
RED	int
)	O
child	pointer
->	O
color	enum
=	O
BLACK	int
;	O
else	O
rebalance_after_remove	function
(	O
set	pointer
,	O
child	pointer
,	O
subst_parent	pointer
!=	O
node	pointer
?	O
subst_parent	pointer
:	O
subst	pointer
)	O
;	O
}	O
}	O
set	pointer
->	O
count	long
--	O
;	O
if	O
(	O
set	pointer
->	O
base	struct
.	O
dispose_fn	pointer
!=	O
NULL	O
)	O
set	pointer
->	O
base	struct
.	O
dispose_fn	pointer
(	O
node	pointer
->	O
value	pointer
)	O
;	O
free	function
(	O
node	pointer
)	O
;	O
return	O
true	int
;	O
}	O
static	O
unsigned	O
int	O
check_invariants	function
(	O
gl_oset_node_t	pointer
node	pointer
,	O
gl_oset_node_t	pointer
parent	pointer
,	O
size_t	long
*	O
counterp	pointer
)	O
{	O
unsigned	O
int	O
left_blackheight	int
=	O
(	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
?	O
check_invariants	function
(	O
node	pointer
->	O
left	pointer
,	O
node	pointer
,	O
counterp	pointer
)	O
:	O
0	int
)	O
;	O
unsigned	O
int	O
right_blackheight	int
=	O
(	O
node	pointer
->	O
right	pointer
!=	O
NULL	O
?	O
check_invariants	function
(	O
node	pointer
->	O
right	pointer
,	O
node	pointer
,	O
counterp	pointer
)	O
:	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
parent	pointer
==	O
parent	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
color	enum
==	O
BLACK	int
||	O
node	pointer
->	O
color	enum
==	O
RED	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
&&	O
!	O
(	O
node	pointer
->	O
color	enum
==	O
BLACK	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
left_blackheight	int
==	O
right_blackheight	int
)	O
)	O
abort	function
(	O
)	O
;	O
(	O
*	O
counterp	pointer
)	O
++	O
;	O
return	O
left_blackheight	int
+	O
(	O
node	pointer
->	O
color	enum
==	O
BLACK	int
?	O
1	int
:	O
0	int
)	O
;	O
}	O
void	O
gl_rbtree_oset_check_invariants	function
(	O
gl_oset_t	pointer
set	pointer
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
if	O
(	O
set	pointer
->	O
root	pointer
!=	O
NULL	O
)	O
check_invariants	function
(	O
set	pointer
->	O
root	pointer
,	O
NULL	O
,	O
&	O
counter	long
)	O
;	O
if	O
(	O
!	O
(	O
set	pointer
->	O
count	long
==	O
counter	long
)	O
)	O
abort	function
(	O
)	O
;	O
}	O
const	O
struct	O
gl_oset_implementation	struct
gl_rbtree_oset_implementation	struct
=	O
{	O
gl_tree_nx_create_empty	function
,	O
gl_tree_size	function
,	O
gl_tree_search	function
,	O
gl_tree_search_atleast	function
,	O
gl_tree_nx_add	function
,	O
gl_tree_remove	function
,	O
gl_tree_oset_free	function
,	O
gl_tree_iterator	function
,	O
gl_tree_iterator_next	function
,	O
gl_tree_iterator_free	function
}	O
;	O
