static	O
void	O
osip_util_replace_all_lws	function
(	O
char	O
*	O
sip_message	pointer
)	O
;	O
static	O
int	O
osip_message_set__header	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
hname	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
;	O
static	O
int	O
msg_headers_parse	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
start_of_header	pointer
,	O
const	O
char	O
*	O
*	O
body	pointer
)	O
;	O
static	O
int	O
msg_osip_body_parse	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
start_of_buf	pointer
,	O
const	O
char	O
*	O
*	O
next_body	pointer
,	O
size_t	long
length	long
)	O
;	O
static	O
int	O
__osip_message_startline_parsereq	function
(	O
osip_message_t	struct
*	O
dest	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
const	O
char	O
*	O
*	O
headers	pointer
)	O
{	O
const	O
char	O
*	O
p1	pointer
;	O
const	O
char	O
*	O
p2	pointer
;	O
char	O
*	O
requesturi	pointer
;	O
int	O
i	int
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
dest	pointer
->	O
status_code	int
=	O
0	int
;	O
dest	pointer
->	O
reason_phrase	pointer
=	O
NULL	O
;	O
*	O
headers	pointer
=	O
buf	pointer
;	O
p2	pointer
=	O
strchr	function
(	O
buf	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
p2	pointer
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
*	O
(	O
p2	pointer
+	O
1	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
p2	pointer
+	O
2	int
)	O
==	O
'\0'	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
p2	pointer
-	O
buf	pointer
==	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No space allowed here\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
dest	pointer
->	O
sip_method	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
p2	pointer
-	O
buf	pointer
+	O
1	int
)	O
;	O
if	O
(	O
dest	pointer
->	O
sip_method	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_strncpy	function
(	O
dest	pointer
->	O
sip_method	pointer
,	O
buf	pointer
,	O
p2	pointer
-	O
buf	pointer
)	O
;	O
p1	pointer
=	O
strchr	function
(	O
p2	pointer
+	O
2	int
,	O
' '	O
)	O
;	O
if	O
(	O
p1	pointer
==	O
NULL	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Uncompliant request-uri\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
p1	pointer
-	O
p2	pointer
<	O
2	int
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
requesturi	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
p1	pointer
-	O
p2	pointer
)	O
;	O
if	O
(	O
requesturi	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_clrncpy	function
(	O
requesturi	pointer
,	O
p2	pointer
+	O
1	int
,	O
(	O
p1	pointer
-	O
p2	pointer
-	O
1	int
)	O
)	O
;	O
i	int
=	O
osip_uri_init	function
(	O
&	O
(	O
dest	pointer
->	O
req_uri	pointer
)	O
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
requesturi	pointer
)	O
;	O
requesturi	pointer
=	O
NULL	O
;	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
i	int
=	O
osip_uri_parse	function
(	O
dest	pointer
->	O
req_uri	pointer
,	O
requesturi	pointer
)	O
;	O
osip_free	O
(	O
requesturi	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
{	O
const	O
char	O
*	O
hp	pointer
=	O
p1	pointer
;	O
hp	pointer
++	O
;	O
if	O
(	O
*	O
hp	pointer
==	O
'\0'	O
||	O
*	O
(	O
hp	pointer
+	O
1	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	pointer
+	O
2	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	pointer
+	O
3	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	pointer
+	O
4	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	pointer
+	O
5	int
)	O
==	O
'\0'	O
||	O
*	O
(	O
hp	pointer
+	O
6	int
)	O
==	O
'\0'	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Uncomplete request line\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
(	O
(	O
hp	pointer
[	O
0	int
]	O
!=	O
'S'	O
)	O
&&	O
(	O
hp	pointer
[	O
0	int
]	O
!=	O
's'	O
)	O
)	O
||	O
(	O
(	O
hp	pointer
[	O
1	int
]	O
!=	O
'I'	O
)	O
&&	O
(	O
hp	pointer
[	O
1	int
]	O
!=	O
'i'	O
)	O
)	O
||	O
(	O
(	O
hp	pointer
[	O
2	int
]	O
!=	O
'P'	O
)	O
&&	O
(	O
hp	pointer
[	O
2	int
]	O
!=	O
'p'	O
)	O
)	O
||	O
(	O
hp	pointer
[	O
3	int
]	O
!=	O
'/'	O
)	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No crlf found/No SIP/2.0 found\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
hp	pointer
=	O
hp	pointer
+	O
4	int
;	O
while	O
(	O
(	O
*	O
hp	pointer
!=	O
'\r'	O
)	O
&&	O
(	O
*	O
hp	pointer
!=	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
*	O
hp	pointer
)	O
{	O
if	O
(	O
(	O
*	O
hp	pointer
>=	O
'0'	O
)	O
&&	O
(	O
*	O
hp	pointer
<=	O
'9'	O
)	O
)	O
hp	pointer
++	O
;	O
else	O
if	O
(	O
*	O
hp	pointer
==	O
'.'	O
)	O
hp	pointer
++	O
;	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"incorrect sip version string\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No crlf found\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
if	O
(	O
hp	pointer
-	O
p1	pointer
<	O
2	int
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
dest	pointer
->	O
sip_version	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
hp	pointer
-	O
p1	pointer
)	O
;	O
if	O
(	O
dest	pointer
->	O
sip_version	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_method	pointer
)	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
osip_uri_free	function
(	O
dest	pointer
->	O
req_uri	pointer
)	O
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_strncpy	function
(	O
dest	pointer
->	O
sip_version	pointer
,	O
p1	pointer
+	O
1	int
,	O
(	O
hp	pointer
-	O
p1	pointer
-	O
1	int
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
osip_strcasecmp	function
(	O
dest	pointer
->	O
sip_version	pointer
,	O
"SIP/2.0"	pointer
)	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_WARNING	O
,	O
NULL	O
,	O
"Wrong version number\n"	pointer
)	O
)	O
;	O
}	O
hp	pointer
++	O
;	O
if	O
(	O
(	O
*	O
hp	pointer
)	O
&&	O
(	O
'\r'	O
==	O
hp	pointer
[	O
-	O
1	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
hp	pointer
[	O
0	int
]	O
)	O
)	O
hp	pointer
++	O
;	O
(	O
*	O
headers	pointer
)	O
=	O
hp	pointer
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
static	O
int	O
__osip_message_startline_parseresp	function
(	O
osip_message_t	struct
*	O
dest	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
const	O
char	O
*	O
*	O
headers	pointer
)	O
{	O
const	O
char	O
*	O
statuscode	int
;	O
const	O
char	O
*	O
reasonphrase	pointer
;	O
dest	pointer
->	O
req_uri	pointer
=	O
NULL	O
;	O
dest	pointer
->	O
sip_method	pointer
=	O
NULL	O
;	O
*	O
headers	pointer
=	O
buf	pointer
;	O
statuscode	int
=	O
strchr	function
(	O
buf	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
statuscode	int
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
statuscode	int
-	O
(	O
*	O
headers	pointer
)	O
<	O
7	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
dest	pointer
->	O
sip_version	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
statuscode	int
-	O
(	O
*	O
headers	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
dest	pointer
->	O
sip_version	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_strncpy	function
(	O
dest	pointer
->	O
sip_version	pointer
,	O
*	O
headers	pointer
,	O
statuscode	int
-	O
(	O
*	O
headers	pointer
)	O
)	O
;	O
reasonphrase	pointer
=	O
strchr	function
(	O
statuscode	int
+	O
1	int
,	O
' '	O
)	O
;	O
if	O
(	O
reasonphrase	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_version	pointer
)	O
;	O
dest	pointer
->	O
sip_version	pointer
=	O
NULL	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
sscanf	function
(	O
statuscode	int
+	O
1	int
,	O
"%d"	pointer
,	O
&	O
dest	pointer
->	O
status_code	int
)	O
!=	O
1	int
)	O
{	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
dest	pointer
->	O
status_code	int
==	O
0	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
{	O
const	O
char	O
*	O
hp	pointer
=	O
reasonphrase	pointer
;	O
while	O
(	O
(	O
*	O
hp	pointer
!=	O
'\r'	O
)	O
&&	O
(	O
*	O
hp	pointer
!=	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
*	O
hp	pointer
)	O
hp	pointer
++	O
;	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"No crlf found\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
dest	pointer
->	O
reason_phrase	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
hp	pointer
-	O
reasonphrase	pointer
)	O
;	O
if	O
(	O
dest	pointer
->	O
reason_phrase	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
dest	pointer
->	O
sip_version	pointer
)	O
;	O
dest	pointer
->	O
sip_version	pointer
=	O
NULL	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_strncpy	function
(	O
dest	pointer
->	O
reason_phrase	pointer
,	O
reasonphrase	pointer
+	O
1	int
,	O
hp	pointer
-	O
reasonphrase	pointer
-	O
1	int
)	O
;	O
hp	pointer
++	O
;	O
if	O
(	O
(	O
*	O
hp	pointer
)	O
&&	O
(	O
'\r'	O
==	O
hp	pointer
[	O
-	O
1	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
hp	pointer
[	O
0	int
]	O
)	O
)	O
hp	pointer
++	O
;	O
(	O
*	O
headers	pointer
)	O
=	O
hp	pointer
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
static	O
int	O
__osip_message_startline_parse	function
(	O
osip_message_t	struct
*	O
dest	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
const	O
char	O
*	O
*	O
headers	pointer
)	O
{	O
if	O
(	O
0	int
==	O
strncmp	function
(	O
(	O
const	O
char	O
*	O
)	O
buf	pointer
,	O
(	O
const	O
char	O
*	O
)	O
"SIP/"	pointer
,	O
4	int
)	O
)	O
return	O
__osip_message_startline_parseresp	function
(	O
dest	pointer
,	O
buf	pointer
,	O
headers	pointer
)	O
;	O
else	O
return	O
__osip_message_startline_parsereq	function
(	O
dest	pointer
,	O
buf	pointer
,	O
headers	pointer
)	O
;	O
}	O
int	O
__osip_find_next_occurence	function
(	O
const	O
char	O
*	O
str	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
const	O
char	O
*	O
*	O
index_of_str	pointer
,	O
const	O
char	O
*	O
end_of_buf	pointer
)	O
{	O
size_t	long
slen	long
;	O
*	O
index_of_str	pointer
=	O
NULL	O
;	O
if	O
(	O
str	pointer
==	O
NULL	O
||	O
buf	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
slen	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
while	O
(	O
slen	long
<	O
(	O
size_t	long
)	O
(	O
end_of_buf	pointer
-	O
buf	pointer
)	O
)	O
{	O
if	O
(	O
!	O
memcmp	function
(	O
str	pointer
,	O
buf	pointer
,	O
slen	long
)	O
)	O
{	O
*	O
index_of_str	pointer
=	O
buf	pointer
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
++	O
buf	pointer
;	O
}	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
static	O
void	O
osip_util_replace_all_lws	function
(	O
char	O
*	O
sip_message	pointer
)	O
{	O
char	O
*	O
tmp	pointer
;	O
if	O
(	O
sip_message	pointer
==	O
NULL	O
)	O
return	O
;	O
tmp	pointer
=	O
sip_message	pointer
;	O
for	O
(	O
;	O
tmp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
;	O
tmp	pointer
++	O
)	O
{	O
if	O
(	O
(	O
'\0'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
||	O
(	O
'\0'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
||	O
(	O
'\0'	O
==	O
tmp	pointer
[	O
2	int
]	O
)	O
||	O
(	O
'\0'	O
==	O
tmp	pointer
[	O
3	int
]	O
)	O
)	O
return	O
;	O
if	O
(	O
(	O
(	O
'\r'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
&&	O
(	O
'\r'	O
==	O
tmp	pointer
[	O
2	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	pointer
[	O
3	int
]	O
)	O
)	O
||	O
(	O
(	O
'\r'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'\r'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
)	O
||	O
(	O
(	O
'\n'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
)	O
)	O
return	O
;	O
if	O
(	O
(	O
(	O
'\r'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
tmp	pointer
[	O
2	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	pointer
[	O
2	int
]	O
)	O
)	O
)	O
||	O
(	O
(	O
'\r'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
)	O
)	O
||	O
(	O
(	O
'\n'	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
(	O
' '	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
tmp	pointer
[	O
1	int
]	O
)	O
)	O
)	O
)	O
{	O
tmp	pointer
[	O
0	int
]	O
=	O
' '	O
;	O
tmp	pointer
[	O
1	int
]	O
=	O
' '	O
;	O
tmp	pointer
=	O
tmp	pointer
+	O
2	int
;	O
for	O
(	O
;	O
(	O
'\t'	O
==	O
tmp	pointer
[	O
0	int
]	O
||	O
' '	O
==	O
tmp	pointer
[	O
0	int
]	O
)	O
;	O
)	O
{	O
tmp	pointer
[	O
0	int
]	O
=	O
' '	O
;	O
tmp	pointer
++	O
;	O
}	O
if	O
(	O
tmp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
;	O
}	O
}	O
}	O
int	O
__osip_find_next_crlf	function
(	O
const	O
char	O
*	O
start_of_header	pointer
,	O
const	O
char	O
*	O
*	O
end_of_header	pointer
)	O
{	O
const	O
char	O
*	O
soh	pointer
=	O
start_of_header	pointer
;	O
*	O
end_of_header	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
'\r'	O
!=	O
*	O
soh	pointer
)	O
&&	O
(	O
'\n'	O
!=	O
*	O
soh	pointer
)	O
)	O
{	O
if	O
(	O
*	O
soh	pointer
)	O
soh	pointer
++	O
;	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Final CRLF is missing\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
}	O
if	O
(	O
(	O
'\r'	O
==	O
soh	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
'\n'	O
==	O
soh	pointer
[	O
1	int
]	O
)	O
)	O
soh	pointer
=	O
soh	pointer
+	O
1	int
;	O
if	O
(	O
(	O
' '	O
==	O
soh	pointer
[	O
1	int
]	O
)	O
||	O
(	O
'\t'	O
==	O
soh	pointer
[	O
1	int
]	O
)	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_BUG	O
,	O
NULL	O
,	O
"Message that contains LWS must be processed with osip_util_replace_all_lws(char *tmp) before being parsed.\n"	pointer
)	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
*	O
end_of_header	pointer
=	O
soh	pointer
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
__osip_find_next_crlfcrlf	function
(	O
const	O
char	O
*	O
start_of_part	pointer
,	O
const	O
char	O
*	O
*	O
end_of_part	pointer
)	O
{	O
const	O
char	O
*	O
start_of_line	pointer
;	O
const	O
char	O
*	O
end_of_line	pointer
;	O
int	O
i	int
;	O
start_of_line	pointer
=	O
start_of_part	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
i	int
=	O
__osip_find_next_crlf	function
(	O
start_of_line	pointer
,	O
&	O
end_of_line	pointer
)	O
;	O
if	O
(	O
i	int
==	O
-	O
2	int
)	O
{	O
}	O
else	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Final CRLF is missing\n"	pointer
)	O
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
'\0'	O
==	O
end_of_line	pointer
[	O
0	int
]	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Final CRLF is missing\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
else	O
if	O
(	O
'\r'	O
==	O
end_of_line	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
end_of_line	pointer
[	O
1	int
]	O
)	O
end_of_line	pointer
++	O
;	O
*	O
end_of_part	pointer
=	O
end_of_line	pointer
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
'\n'	O
==	O
end_of_line	pointer
[	O
0	int
]	O
)	O
{	O
*	O
end_of_part	pointer
=	O
end_of_line	pointer
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
start_of_line	pointer
=	O
end_of_line	pointer
;	O
}	O
}	O
static	O
int	O
osip_message_set__header	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
hname	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
{	O
int	O
my_index	int
;	O
if	O
(	O
hname	pointer
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
my_index	int
=	O
__osip_message_is_known_header	function
(	O
hname	pointer
)	O
;	O
if	O
(	O
my_index	int
>=	O
0	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
__osip_message_call_method	function
(	O
my_index	int
,	O
sip	pointer
,	O
hvalue	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
ret	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
if	O
(	O
osip_message_set_header	function
(	O
sip	pointer
,	O
hname	pointer
,	O
hvalue	pointer
)	O
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_WARNING	O
,	O
NULL	O
,	O
"Could not set unknown header\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_message_set_multiple_header	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
char	O
*	O
hname	pointer
,	O
char	O
*	O
hvalue	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
ptr	pointer
,	O
*	O
p	pointer
;	O
char	O
*	O
comma	pointer
;	O
char	O
*	O
beg	pointer
;	O
char	O
*	O
end	pointer
;	O
int	O
inquotes	int
,	O
inuri	int
;	O
osip_tolower	function
(	O
hname	pointer
)	O
;	O
if	O
(	O
hvalue	pointer
==	O
NULL	O
)	O
{	O
i	int
=	O
osip_message_set__header	function
(	O
sip	pointer
,	O
hname	pointer
,	O
hvalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
ptr	pointer
=	O
hvalue	pointer
;	O
comma	pointer
=	O
strchr	function
(	O
ptr	pointer
,	O
','	O
)	O
;	O
if	O
(	O
comma	pointer
==	O
NULL	O
||	O
__osip_message_is_header_comma_separated	function
(	O
hname	pointer
)	O
!=	O
OSIP_SUCCESS	int
)	O
{	O
i	int
=	O
osip_message_set__header	function
(	O
sip	pointer
,	O
hname	pointer
,	O
hvalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
beg	pointer
=	O
hvalue	pointer
;	O
inquotes	int
=	O
0	int
;	O
inuri	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
ptr	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
ptr	pointer
)	O
{	O
case	O
'"'	O
:	O
for	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
ptr	pointer
-	O
1	int
;	O
p	pointer
>=	O
beg	pointer
&&	O
*	O
p	pointer
==	O
'\\'	O
;	O
p	pointer
--	O
,	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
%	O
2	int
==	O
0	int
)	O
inquotes	int
=	O
!	O
inquotes	int
;	O
break	O
;	O
case	O
'<'	O
:	O
if	O
(	O
!	O
inquotes	int
)	O
{	O
if	O
(	O
!	O
inuri	int
)	O
{	O
if	O
(	O
(	O
osip_strncasecmp	function
(	O
ptr	pointer
+	O
1	int
,	O
"sip:"	pointer
,	O
4	int
)	O
==	O
0	int
||	O
osip_strncasecmp	function
(	O
ptr	pointer
+	O
1	int
,	O
"sips:"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
osip_strncasecmp	function
(	O
ptr	pointer
+	O
1	int
,	O
"http:"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
osip_strncasecmp	function
(	O
ptr	pointer
+	O
1	int
,	O
"https:"	pointer
,	O
6	int
)	O
==	O
0	int
||	O
osip_strncasecmp	function
(	O
ptr	pointer
+	O
1	int
,	O
"tel:"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
&&	O
strchr	function
(	O
ptr	pointer
,	O
'>'	O
)	O
)	O
inuri	int
=	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
!	O
inquotes	int
)	O
{	O
if	O
(	O
inuri	int
)	O
inuri	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\0'	O
:	O
inquotes	int
=	O
0	int
;	O
inuri	int
=	O
0	int
;	O
case	O
','	O
:	O
if	O
(	O
!	O
inquotes	int
&&	O
!	O
inuri	int
)	O
{	O
char	O
*	O
avalue	pointer
;	O
if	O
(	O
beg	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
end	pointer
=	O
ptr	pointer
;	O
if	O
(	O
end	pointer
-	O
beg	pointer
+	O
1	int
<	O
2	int
)	O
{	O
beg	pointer
=	O
end	pointer
+	O
1	int
;	O
break	O
;	O
}	O
avalue	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
end	pointer
-	O
beg	pointer
+	O
1	int
)	O
;	O
if	O
(	O
avalue	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_clrncpy	function
(	O
avalue	pointer
,	O
beg	pointer
,	O
end	pointer
-	O
beg	pointer
)	O
;	O
i	int
=	O
osip_message_set__header	function
(	O
sip	pointer
,	O
hname	pointer
,	O
avalue	pointer
)	O
;	O
osip_free	O
(	O
avalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
beg	pointer
=	O
end	pointer
+	O
1	int
;	O
}	O
if	O
(	O
*	O
ptr	pointer
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
msg_headers_parse	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
start_of_header	pointer
,	O
const	O
char	O
*	O
*	O
body	pointer
)	O
{	O
const	O
char	O
*	O
colon_index	pointer
;	O
char	O
*	O
hname	pointer
;	O
char	O
*	O
hvalue	pointer
;	O
const	O
char	O
*	O
end_of_header	pointer
;	O
int	O
i	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
start_of_header	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO1	O
,	O
NULL	O
,	O
"SIP message does not end with CRLFCRLF\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
i	int
=	O
__osip_find_next_crlf	function
(	O
start_of_header	pointer
,	O
&	O
end_of_header	pointer
)	O
;	O
if	O
(	O
i	int
==	O
-	O
2	int
)	O
{	O
}	O
else	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"End of header Not found\n"	pointer
)	O
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
(	O
start_of_header	pointer
[	O
0	int
]	O
==	O
'\r'	O
)	O
||	O
(	O
start_of_header	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
*	O
body	pointer
=	O
start_of_header	pointer
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
colon_index	pointer
=	O
strchr	function
(	O
start_of_header	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
colon_index	pointer
==	O
NULL	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"End of header Not found\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
if	O
(	O
colon_index	pointer
-	O
start_of_header	pointer
+	O
1	int
<	O
2	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
end_of_header	pointer
<=	O
colon_index	pointer
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Malformed message\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
hname	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
colon_index	pointer
-	O
start_of_header	pointer
+	O
1	int
)	O
;	O
if	O
(	O
hname	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_clrncpy	function
(	O
hname	pointer
,	O
start_of_header	pointer
,	O
colon_index	pointer
-	O
start_of_header	pointer
)	O
;	O
{	O
const	O
char	O
*	O
end	pointer
;	O
if	O
(	O
(	O
end_of_header	pointer
[	O
-	O
2	int
]	O
==	O
'\r'	O
)	O
||	O
(	O
end_of_header	pointer
[	O
-	O
2	int
]	O
==	O
'\n'	O
)	O
)	O
end	pointer
=	O
end_of_header	pointer
-	O
2	int
;	O
else	O
end	pointer
=	O
end_of_header	pointer
-	O
1	int
;	O
if	O
(	O
(	O
end	pointer
)	O
-	O
colon_index	pointer
<	O
2	int
)	O
hvalue	pointer
=	O
NULL	O
;	O
else	O
{	O
hvalue	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
(	O
end	pointer
)	O
-	O
colon_index	pointer
+	O
1	int
)	O
;	O
if	O
(	O
hvalue	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
hname	pointer
)	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
osip_clrncpy	function
(	O
hvalue	pointer
,	O
colon_index	pointer
+	O
1	int
,	O
(	O
end	pointer
)	O
-	O
colon_index	pointer
-	O
1	int
)	O
;	O
}	O
}	O
i	int
=	O
osip_message_set_multiple_header	function
(	O
sip	pointer
,	O
hname	pointer
,	O
hvalue	pointer
)	O
;	O
osip_free	O
(	O
hname	pointer
)	O
;	O
if	O
(	O
hvalue	pointer
!=	O
NULL	O
)	O
osip_free	O
(	O
hvalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"End of header Not found\n"	pointer
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
start_of_header	pointer
=	O
end_of_header	pointer
;	O
}	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
static	O
int	O
msg_osip_body_parse	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
start_of_buf	pointer
,	O
const	O
char	O
*	O
*	O
next_body	pointer
,	O
size_t	long
length	long
)	O
{	O
const	O
char	O
*	O
start_of_body	pointer
;	O
const	O
char	O
*	O
end_of_body	pointer
;	O
const	O
char	O
*	O
end_of_buf	pointer
;	O
char	O
*	O
tmp	pointer
;	O
int	O
i	int
;	O
char	O
*	O
sep_boundary	pointer
;	O
size_t	long
len_sep_boundary	long
;	O
osip_generic_param_t	struct
*	O
ct_param	pointer
;	O
if	O
(	O
sip	pointer
->	O
content_type	pointer
==	O
NULL	O
||	O
sip	pointer
->	O
content_type	pointer
->	O
type	pointer
==	O
NULL	O
||	O
sip	pointer
->	O
content_type	pointer
->	O
subtype	pointer
==	O
NULL	O
)	O
return	O
OSIP_SUCCESS	int
;	O
if	O
(	O
0	int
!=	O
osip_strcasecmp	function
(	O
sip	pointer
->	O
content_type	pointer
->	O
type	pointer
,	O
"multipart"	pointer
)	O
)	O
{	O
size_t	long
osip_body_len	long
;	O
if	O
(	O
start_of_buf	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
'\r'	O
==	O
start_of_buf	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
start_of_buf	pointer
[	O
1	int
]	O
)	O
start_of_body	pointer
=	O
start_of_buf	pointer
+	O
2	int
;	O
else	O
start_of_body	pointer
=	O
start_of_buf	pointer
+	O
1	int
;	O
}	O
else	O
if	O
(	O
'\n'	O
==	O
start_of_buf	pointer
[	O
0	int
]	O
)	O
start_of_body	pointer
=	O
start_of_buf	pointer
+	O
1	int
;	O
else	O
return	O
OSIP_SYNTAXERROR	O
;	O
length	long
=	O
length	long
-	O
(	O
start_of_body	pointer
-	O
start_of_buf	pointer
)	O
;	O
if	O
(	O
length	long
<=	O
0	int
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
!=	O
NULL	O
)	O
osip_body_len	long
=	O
osip_atoi	function
(	O
sip	pointer
->	O
content_length	pointer
->	O
value	pointer
)	O
;	O
else	O
{	O
char	O
tmp	pointer
[	O
16	int
]	O
;	O
osip_body_len	long
=	O
length	long
;	O
sprintf	function
(	O
tmp	pointer
,	O
"%i"	pointer
,	O
(	O
int	O
)	O
osip_body_len	long
)	O
;	O
i	int
=	O
osip_message_set_content_length	function
(	O
sip	pointer
,	O
tmp	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
}	O
if	O
(	O
length	long
<	O
osip_body_len	long
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Message was not receieved enterely. length=%i osip_body_len=%i\n"	pointer
,	O
(	O
int	O
)	O
length	long
,	O
(	O
int	O
)	O
osip_body_len	long
)	O
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
end_of_body	pointer
=	O
start_of_body	pointer
+	O
osip_body_len	long
;	O
tmp	pointer
=	O
osip_malloc	O
(	O
end_of_body	pointer
-	O
start_of_body	pointer
+	O
2	int
)	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
start_of_body	pointer
,	O
end_of_body	pointer
-	O
start_of_body	pointer
)	O
;	O
tmp	pointer
[	O
end_of_body	pointer
-	O
start_of_body	pointer
]	O
=	O
'\0'	O
;	O
i	int
=	O
osip_message_set_body	function
(	O
sip	pointer
,	O
tmp	pointer
,	O
end_of_body	pointer
-	O
start_of_body	pointer
)	O
;	O
osip_free	O
(	O
tmp	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
i	int
=	O
osip_generic_param_get_byname	O
(	O
&	O
sip	pointer
->	O
content_type	pointer
->	O
gen_params	struct
,	O
"boundary"	pointer
,	O
&	O
ct_param	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
if	O
(	O
ct_param	pointer
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
if	O
(	O
ct_param	pointer
->	O
gvalue	pointer
==	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
{	O
const	O
char	O
*	O
boundary_prefix	pointer
=	O
"\n--"	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
ct_param	pointer
->	O
gvalue	pointer
)	O
;	O
sep_boundary	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
len	long
+	O
4	int
)	O
;	O
if	O
(	O
sep_boundary	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
strcpy	function
(	O
sep_boundary	pointer
,	O
boundary_prefix	pointer
)	O
;	O
if	O
(	O
ct_param	pointer
->	O
gvalue	pointer
[	O
0	int
]	O
==	O
'"'	O
&&	O
ct_param	pointer
->	O
gvalue	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'"'	O
)	O
strncat	function
(	O
sep_boundary	pointer
,	O
ct_param	pointer
->	O
gvalue	pointer
+	O
1	int
,	O
len	long
-	O
2	int
)	O
;	O
else	O
strncat	function
(	O
sep_boundary	pointer
,	O
ct_param	pointer
->	O
gvalue	pointer
,	O
len	long
)	O
;	O
}	O
len_sep_boundary	long
=	O
strlen	function
(	O
sep_boundary	pointer
)	O
;	O
*	O
next_body	pointer
=	O
NULL	O
;	O
start_of_body	pointer
=	O
start_of_buf	pointer
;	O
end_of_buf	pointer
=	O
start_of_buf	pointer
+	O
length	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
body_len	long
=	O
0	int
;	O
i	int
=	O
__osip_find_next_occurence	function
(	O
sep_boundary	pointer
,	O
start_of_body	pointer
,	O
&	O
start_of_body	pointer
,	O
end_of_buf	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
sep_boundary	pointer
)	O
;	O
return	O
i	int
;	O
}	O
i	int
=	O
__osip_find_next_occurence	function
(	O
sep_boundary	pointer
,	O
start_of_body	pointer
+	O
len_sep_boundary	long
,	O
&	O
end_of_body	pointer
,	O
end_of_buf	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
sep_boundary	pointer
)	O
;	O
return	O
i	int
;	O
}	O
start_of_body	pointer
=	O
start_of_body	pointer
+	O
len_sep_boundary	long
+	O
1	int
;	O
if	O
(	O
'\n'	O
==	O
start_of_body	pointer
[	O
0	int
]	O
||	O
'\r'	O
==	O
start_of_body	pointer
[	O
0	int
]	O
)	O
start_of_body	pointer
++	O
;	O
if	O
(	O
end_of_body	pointer
<=	O
start_of_body	pointer
)	O
{	O
osip_free	O
(	O
sep_boundary	pointer
)	O
;	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
body_len	long
=	O
end_of_body	pointer
-	O
start_of_body	pointer
;	O
if	O
(	O
*	O
(	O
end_of_body	pointer
-	O
1	int
)	O
==	O
'\r'	O
)	O
body_len	long
--	O
;	O
tmp	pointer
=	O
osip_malloc	O
(	O
body_len	long
+	O
2	int
)	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
sep_boundary	pointer
)	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
memcpy	function
(	O
tmp	pointer
,	O
start_of_body	pointer
,	O
body_len	long
)	O
;	O
tmp	pointer
[	O
body_len	long
]	O
=	O
'\0'	O
;	O
i	int
=	O
osip_message_set_body_mime	function
(	O
sip	pointer
,	O
tmp	pointer
,	O
body_len	long
)	O
;	O
osip_free	O
(	O
tmp	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_free	O
(	O
sep_boundary	pointer
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
strncmp	function
(	O
end_of_body	pointer
+	O
len_sep_boundary	long
,	O
"--"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
*	O
next_body	pointer
=	O
end_of_body	pointer
;	O
osip_free	O
(	O
sep_boundary	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
start_of_body	pointer
=	O
end_of_body	pointer
;	O
}	O
return	O
OSIP_SYNTAXERROR	O
;	O
}	O
static	O
int	O
_osip_message_parse	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
length	long
,	O
int	O
sipfrag	int
)	O
{	O
int	O
i	int
;	O
const	O
char	O
*	O
next_header_index	pointer
;	O
char	O
*	O
tmp	pointer
;	O
char	O
*	O
beg	pointer
;	O
tmp	pointer
=	O
osip_malloc	O
(	O
length	long
+	O
2	int
)	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Could not allocate memory.\n"	pointer
)	O
)	O
;	O
return	O
OSIP_NOMEM	O
;	O
}	O
beg	pointer
=	O
tmp	pointer
;	O
memcpy	function
(	O
tmp	pointer
,	O
buf	pointer
,	O
length	long
)	O
;	O
tmp	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
tmp	pointer
+=	O
strspn	function
(	O
tmp	pointer
,	O
"\r\n"	pointer
)	O
;	O
osip_util_replace_all_lws	function
(	O
tmp	pointer
)	O
;	O
i	int
=	O
__osip_message_startline_parse	function
(	O
sip	pointer
,	O
tmp	pointer
,	O
&	O
next_header_index	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
&&	O
!	O
sipfrag	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"Could not parse start line of message.\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
beg	pointer
)	O
;	O
return	O
i	int
;	O
}	O
tmp	pointer
=	O
(	O
char	O
*	O
)	O
next_header_index	pointer
;	O
i	int
=	O
msg_headers_parse	function
(	O
sip	pointer
,	O
tmp	pointer
,	O
&	O
next_header_index	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"error in msg_headers_parse()\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
beg	pointer
)	O
;	O
return	O
i	int
;	O
}	O
tmp	pointer
=	O
(	O
char	O
*	O
)	O
next_header_index	pointer
;	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
!=	O
NULL	O
&&	O
sip	pointer
->	O
content_length	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
osip_content_length_free	function
(	O
sip	pointer
->	O
content_length	pointer
)	O
;	O
sip	pointer
->	O
content_length	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
!=	O
NULL	O
&&	O
sip	pointer
->	O
content_length	pointer
->	O
value	pointer
!=	O
NULL	O
&&	O
atoi	function
(	O
sip	pointer
->	O
content_length	pointer
->	O
value	pointer
)	O
>	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
==	O
NULL	O
&&	O
'\r'	O
==	O
next_header_index	pointer
[	O
0	int
]	O
&&	O
'\n'	O
==	O
next_header_index	pointer
[	O
1	int
]	O
&&	O
length	long
-	O
(	O
tmp	pointer
-	O
beg	pointer
)	O
-	O
(	O
2	int
)	O
>	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
==	O
NULL	O
&&	O
'\n'	O
==	O
next_header_index	pointer
[	O
0	int
]	O
&&	O
length	long
-	O
(	O
tmp	pointer
-	O
beg	pointer
)	O
-	O
(	O
1	int
)	O
>	O
0	int
)	O
{	O
}	O
else	O
{	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
==	O
NULL	O
)	O
osip_message_set_content_length	function
(	O
sip	pointer
,	O
"0"	pointer
)	O
;	O
osip_free	O
(	O
beg	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
i	int
=	O
msg_osip_body_parse	function
(	O
sip	pointer
,	O
tmp	pointer
,	O
&	O
next_header_index	pointer
,	O
length	long
-	O
(	O
tmp	pointer
-	O
beg	pointer
)	O
)	O
;	O
osip_free	O
(	O
beg	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"error in msg_osip_body_parse()\n"	pointer
)	O
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
sip	pointer
->	O
content_length	pointer
==	O
NULL	O
)	O
osip_message_set_content_length	function
(	O
sip	pointer
,	O
"0"	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_message_parse	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
length	long
)	O
{	O
return	O
_osip_message_parse	function
(	O
sip	pointer
,	O
buf	pointer
,	O
length	long
,	O
0	int
)	O
;	O
}	O
int	O
osip_message_parse_sipfrag	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
length	long
)	O
{	O
return	O
_osip_message_parse	function
(	O
sip	pointer
,	O
buf	pointer
,	O
length	long
,	O
1	int
)	O
;	O
}	O
int	O
osip_message_fix_last_via_header	function
(	O
osip_message_t	struct
*	O
request	pointer
,	O
const	O
char	O
*	O
ip_addr	pointer
,	O
int	O
port	pointer
)	O
{	O
osip_generic_param_t	struct
*	O
rport	pointer
;	O
osip_via_t	struct
*	O
via	pointer
;	O
if	O
(	O
request	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
if	O
(	O
MSG_IS_RESPONSE	O
(	O
request	pointer
)	O
)	O
return	O
OSIP_SUCCESS	int
;	O
via	pointer
=	O
osip_list_get	function
(	O
&	O
request	pointer
->	O
vias	struct
,	O
0	int
)	O
;	O
if	O
(	O
via	pointer
==	O
NULL	O
||	O
via	pointer
->	O
host	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
osip_via_param_get_byname	O
(	O
via	pointer
,	O
"rport"	pointer
,	O
&	O
rport	pointer
)	O
;	O
if	O
(	O
rport	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
rport	pointer
->	O
gvalue	pointer
==	O
NULL	O
)	O
{	O
rport	pointer
->	O
gvalue	pointer
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
9	int
)	O
;	O
if	O
(	O
rport	pointer
->	O
gvalue	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
snprintf	function
(	O
rport	pointer
->	O
gvalue	pointer
,	O
8	int
,	O
"%i"	pointer
,	O
port	pointer
)	O
;	O
}	O
}	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
via	pointer
->	O
host	pointer
,	O
ip_addr	pointer
)	O
)	O
return	O
OSIP_SUCCESS	int
;	O
osip_via_set_received	O
(	O
via	pointer
,	O
osip_strdup	function
(	O
ip_addr	pointer
)	O
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
const	O
char	O
*	O
osip_message_get_reason	function
(	O
int	O
replycode	int
)	O
{	O
struct	O
code_to_reason	struct
{	O
int	O
code	int
;	O
const	O
char	O
*	O
reason	pointer
;	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct
reasons1xx	array
[	O
]	O
=	O
{	O
{	O
100	int
,	O
"Trying"	pointer
}	O
,	O
{	O
180	int
,	O
"Ringing"	pointer
}	O
,	O
{	O
181	int
,	O
"Call Is Being Forwarded"	pointer
}	O
,	O
{	O
182	int
,	O
"Queued"	pointer
}	O
,	O
{	O
183	int
,	O
"Session Progress"	pointer
}	O
,	O
{	O
199	int
,	O
"Early Dialog Terminated"	pointer
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct
reasons2xx	array
[	O
]	O
=	O
{	O
{	O
200	int
,	O
"OK"	pointer
}	O
,	O
{	O
202	int
,	O
"Accepted"	pointer
}	O
,	O
{	O
204	int
,	O
"No Notification"	pointer
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct
reasons3xx	array
[	O
]	O
=	O
{	O
{	O
300	int
,	O
"Multiple Choices"	pointer
}	O
,	O
{	O
301	int
,	O
"Moved Permanently"	pointer
}	O
,	O
{	O
302	int
,	O
"Moved Temporarily"	pointer
}	O
,	O
{	O
305	int
,	O
"Use Proxy"	pointer
}	O
,	O
{	O
380	int
,	O
"Alternative Service"	pointer
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct
reasons4xx	array
[	O
]	O
=	O
{	O
{	O
400	int
,	O
"Bad Request"	pointer
}	O
,	O
{	O
401	int
,	O
"Unauthorized"	pointer
}	O
,	O
{	O
402	int
,	O
"Payment Required"	pointer
}	O
,	O
{	O
403	int
,	O
"Forbidden"	pointer
}	O
,	O
{	O
404	int
,	O
"Not Found"	pointer
}	O
,	O
{	O
405	int
,	O
"Method Not Allowed"	pointer
}	O
,	O
{	O
406	int
,	O
"Not Acceptable"	pointer
}	O
,	O
{	O
407	int
,	O
"Proxy Authentication Required"	pointer
}	O
,	O
{	O
408	int
,	O
"Request Timeout"	pointer
}	O
,	O
{	O
409	int
,	O
"Conflict"	pointer
}	O
,	O
{	O
410	int
,	O
"Gone"	pointer
}	O
,	O
{	O
411	int
,	O
"Length Required"	pointer
}	O
,	O
{	O
412	int
,	O
"Conditional Request Failed"	pointer
}	O
,	O
{	O
413	int
,	O
"Request Entity Too Large"	pointer
}	O
,	O
{	O
414	int
,	O
"Request-URI Too Long"	pointer
}	O
,	O
{	O
415	int
,	O
"Unsupported Media Type"	pointer
}	O
,	O
{	O
416	int
,	O
"Unsupported URI Scheme"	pointer
}	O
,	O
{	O
417	int
,	O
"Unknown Resource-Priority"	pointer
}	O
,	O
{	O
420	int
,	O
"Bad Extension"	pointer
}	O
,	O
{	O
421	int
,	O
"Extension Required"	pointer
}	O
,	O
{	O
422	int
,	O
"Session Interval Too Small"	pointer
}	O
,	O
{	O
423	int
,	O
"Interval Too Brief"	pointer
}	O
,	O
{	O
424	int
,	O
"Bad Location Information"	pointer
}	O
,	O
{	O
428	int
,	O
"Use Identity Header"	pointer
}	O
,	O
{	O
429	int
,	O
"Provide Referrer Identity"	pointer
}	O
,	O
{	O
430	int
,	O
"Flow Failed"	pointer
}	O
,	O
{	O
433	int
,	O
"Anonymity Disallowed"	pointer
}	O
,	O
{	O
436	int
,	O
"Bad Identity Info"	pointer
}	O
,	O
{	O
437	int
,	O
"Unsupported Credential"	pointer
}	O
,	O
{	O
438	int
,	O
"Invalid Identity Header"	pointer
}	O
,	O
{	O
439	int
,	O
"First Hop Lacks Outbound Support"	pointer
}	O
,	O
{	O
440	int
,	O
"Max-Breadth Exceeded"	pointer
}	O
,	O
{	O
469	int
,	O
"Bad Info Package"	pointer
}	O
,	O
{	O
470	int
,	O
"Consent Needed"	pointer
}	O
,	O
{	O
480	int
,	O
"Temporarily Unavailable"	pointer
}	O
,	O
{	O
481	int
,	O
"Call/Transaction Does Not Exist"	pointer
}	O
,	O
{	O
482	int
,	O
"Loop Detected"	pointer
}	O
,	O
{	O
483	int
,	O
"Too Many Hops"	pointer
}	O
,	O
{	O
484	int
,	O
"Address Incomplete"	pointer
}	O
,	O
{	O
485	int
,	O
"Ambiguous"	pointer
}	O
,	O
{	O
486	int
,	O
"Busy Here"	pointer
}	O
,	O
{	O
487	int
,	O
"Request Terminated"	pointer
}	O
,	O
{	O
488	int
,	O
"Not Acceptable Here"	pointer
}	O
,	O
{	O
489	int
,	O
"Bad Event"	pointer
}	O
,	O
{	O
491	int
,	O
"Request Pending"	pointer
}	O
,	O
{	O
493	int
,	O
"Undecipherable"	pointer
}	O
,	O
{	O
494	int
,	O
"Security Agreement Required"	pointer
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct
reasons5xx	array
[	O
]	O
=	O
{	O
{	O
500	int
,	O
"Server Internal Error"	pointer
}	O
,	O
{	O
501	int
,	O
"Not Implemented"	pointer
}	O
,	O
{	O
502	int
,	O
"Bad Gateway"	pointer
}	O
,	O
{	O
503	int
,	O
"Service Unavailable"	pointer
}	O
,	O
{	O
504	int
,	O
"Server Time-out"	pointer
}	O
,	O
{	O
505	int
,	O
"Version Not Supported"	pointer
}	O
,	O
{	O
513	int
,	O
"Message Too Large"	pointer
}	O
,	O
{	O
580	int
,	O
"Precondition Failure"	pointer
}	O
,	O
}	O
;	O
static	O
const	O
struct	O
code_to_reason	struct
reasons6xx	array
[	O
]	O
=	O
{	O
{	O
600	int
,	O
"Busy Everywhere"	pointer
}	O
,	O
{	O
603	int
,	O
"Decline"	pointer
}	O
,	O
{	O
604	int
,	O
"Does Not Exist Anywhere"	pointer
}	O
,	O
{	O
606	int
,	O
"Not Acceptable"	pointer
}	O
,	O
{	O
607	int
,	O
"Unwanted"	pointer
}	O
,	O
{	O
687	int
,	O
"Dialog Terminated"	pointer
}	O
}	O
;	O
const	O
struct	O
code_to_reason	struct
*	O
reasons	pointer
;	O
int	O
len	long
,	O
i	int
;	O
switch	O
(	O
replycode	int
/	O
100	int
)	O
{	O
case	O
1	int
:	O
reasons	pointer
=	O
reasons1xx	array
;	O
len	long
=	O
sizeof	O
(	O
reasons1xx	array
)	O
/	O
sizeof	O
(	O
*	O
reasons	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
reasons	pointer
=	O
reasons2xx	array
;	O
len	long
=	O
sizeof	O
(	O
reasons2xx	array
)	O
/	O
sizeof	O
(	O
*	O
reasons	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
reasons	pointer
=	O
reasons3xx	array
;	O
len	long
=	O
sizeof	O
(	O
reasons3xx	array
)	O
/	O
sizeof	O
(	O
*	O
reasons	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
reasons	pointer
=	O
reasons4xx	array
;	O
len	long
=	O
sizeof	O
(	O
reasons4xx	array
)	O
/	O
sizeof	O
(	O
*	O
reasons	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
reasons	pointer
=	O
reasons5xx	array
;	O
len	long
=	O
sizeof	O
(	O
reasons5xx	array
)	O
/	O
sizeof	O
(	O
*	O
reasons	pointer
)	O
;	O
break	O
;	O
case	O
6	int
:	O
reasons	pointer
=	O
reasons6xx	array
;	O
len	long
=	O
sizeof	O
(	O
reasons6xx	array
)	O
/	O
sizeof	O
(	O
*	O
reasons	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
if	O
(	O
reasons	pointer
[	O
i	int
]	O
.	O
code	int
==	O
replycode	int
)	O
return	O
reasons	pointer
[	O
i	int
]	O
.	O
reason	pointer
;	O
return	O
NULL	O
;	O
}	O
