desktop_reader_ty	struct
*	O
desktop_reader_alloc	function
(	O
desktop_reader_class_ty	struct
*	O
method_table	pointer
)	O
{	O
desktop_reader_ty	struct
*	O
reader	pointer
;	O
reader	pointer
=	O
(	O
desktop_reader_ty	struct
*	O
)	O
xmalloc	function
(	O
method_table	pointer
->	O
size	long
)	O
;	O
reader	pointer
->	O
methods	pointer
=	O
method_table	pointer
;	O
if	O
(	O
method_table	pointer
->	O
constructor	pointer
)	O
method_table	pointer
->	O
constructor	pointer
(	O
reader	pointer
)	O
;	O
return	O
reader	pointer
;	O
}	O
void	O
desktop_reader_free	function
(	O
desktop_reader_ty	struct
*	O
reader	pointer
)	O
{	O
if	O
(	O
reader	pointer
->	O
methods	pointer
->	O
destructor	pointer
)	O
reader	pointer
->	O
methods	pointer
->	O
destructor	pointer
(	O
reader	pointer
)	O
;	O
free	function
(	O
reader	pointer
)	O
;	O
}	O
void	O
desktop_reader_handle_group	function
(	O
desktop_reader_ty	struct
*	O
reader	pointer
,	O
const	O
char	O
*	O
group	pointer
)	O
{	O
if	O
(	O
reader	pointer
->	O
methods	pointer
->	O
handle_group	pointer
)	O
reader	pointer
->	O
methods	pointer
->	O
handle_group	pointer
(	O
reader	pointer
,	O
group	pointer
)	O
;	O
}	O
void	O
desktop_reader_handle_pair	function
(	O
desktop_reader_ty	struct
*	O
reader	pointer
,	O
lex_pos_ty	struct
*	O
key_pos	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
locale	pointer
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
if	O
(	O
reader	pointer
->	O
methods	pointer
->	O
handle_pair	pointer
)	O
reader	pointer
->	O
methods	pointer
->	O
handle_pair	pointer
(	O
reader	pointer
,	O
key_pos	pointer
,	O
key	pointer
,	O
locale	pointer
,	O
value	pointer
)	O
;	O
}	O
void	O
desktop_reader_handle_comment	function
(	O
desktop_reader_ty	struct
*	O
reader	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
reader	pointer
->	O
methods	pointer
->	O
handle_comment	pointer
)	O
reader	pointer
->	O
methods	pointer
->	O
handle_comment	pointer
(	O
reader	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
desktop_reader_handle_blank	function
(	O
desktop_reader_ty	struct
*	O
reader	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
reader	pointer
->	O
methods	pointer
->	O
handle_blank	pointer
)	O
reader	pointer
->	O
methods	pointer
->	O
handle_blank	pointer
(	O
reader	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
real_file_name	pointer
;	O
extern	O
lex_pos_ty	struct
gram_pos	struct
;	O
static	O
FILE	struct
*	O
fp	pointer
;	O
static	O
int	O
phase1_getc	function
(	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
getc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
{	O
const	O
char	O
*	O
errno_description	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
xasprintf	function
(	O
"%s: %s"	pointer
,	O
xasprintf	function
(	O
_	O
(	O
"error while reading \"%s\""	pointer
)	O
,	O
real_file_name	pointer
)	O
,	O
errno_description	pointer
)	O
)	O
;	O
}	O
return	O
EOF	O
;	O
}	O
return	O
c	int
;	O
}	O
static	O
inline	O
void	O
phase1_ungetc	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
fp	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
phase2_pushback	array
[	O
2	int
]	O
;	O
static	O
int	O
phase2_pushback_length	int
;	O
static	O
int	O
phase2_getc	function
(	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
phase2_pushback_length	int
)	O
c	int
=	O
phase2_pushback	array
[	O
--	O
phase2_pushback_length	int
]	O
;	O
else	O
{	O
c	int
=	O
phase1_getc	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
int	O
c2	int
=	O
phase1_getc	function
(	O
)	O
;	O
if	O
(	O
c2	int
==	O
'\n'	O
)	O
c	int
=	O
c2	int
;	O
else	O
phase1_ungetc	function
(	O
c2	int
)	O
;	O
}	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
gram_pos	struct
.	O
line_number	long
++	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
phase2_ungetc	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
--	O
gram_pos	struct
.	O
line_number	long
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
phase2_pushback	array
[	O
phase2_pushback_length	int
++	O
]	O
=	O
c	int
;	O
}	O
enum	O
token_type_ty	enum
{	O
token_type_eof	int
,	O
token_type_group	int
,	O
token_type_pair	int
,	O
token_type_comment	int
,	O
token_type_blank	int
,	O
token_type_other	int
}	O
;	O
typedef	O
enum	O
token_type_ty	enum
token_type_ty	enum
;	O
typedef	O
struct	O
token_ty	struct
token_ty	struct
;	O
struct	O
token_ty	struct
{	O
token_type_ty	enum
type	enum
;	O
char	O
*	O
string	pointer
;	O
const	O
char	O
*	O
value	pointer
;	O
const	O
char	O
*	O
locale	pointer
;	O
}	O
;	O
static	O
inline	O
void	O
free_token	function
(	O
token_ty	struct
*	O
tp	pointer
)	O
{	O
if	O
(	O
tp	pointer
->	O
type	enum
==	O
token_type_group	int
||	O
tp	pointer
->	O
type	enum
==	O
token_type_pair	int
||	O
tp	pointer
->	O
type	enum
==	O
token_type_comment	int
||	O
tp	pointer
->	O
type	enum
==	O
token_type_blank	int
)	O
free	function
(	O
tp	pointer
->	O
string	pointer
)	O
;	O
}	O
static	O
void	O
desktop_lex	function
(	O
token_ty	struct
*	O
tp	pointer
)	O
{	O
static	O
char	O
*	O
buffer	pointer
;	O
static	O
size_t	long
bufmax	long
;	O
size_t	long
bufpos	long
;	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
EOF	O
:	O
tp	pointer
->	O
type	enum
=	O
token_type_eof	int
;	O
return	O
;	O
case	O
'['	O
:	O
{	O
bool	bool
non_blank	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
if	O
(	O
!	O
(	O
c_isascii	function
(	O
c	int
)	O
&&	O
c	int
!=	O
'['	O
)	O
&&	O
!	O
c_iscntrl	function
(	O
c	int
)	O
)	O
break	O
;	O
APPEND	O
(	O
c	int
)	O
;	O
continue	O
;	O
case	O
'\n'	O
:	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	pointer
,	O
gram_pos	struct
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"unterminated group name"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
case	O
']'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
!	O
c_isspace	function
(	O
c	int
)	O
)	O
non_blank	bool
=	O
true	int
;	O
}	O
if	O
(	O
non_blank	bool
)	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	pointer
,	O
gram_pos	struct
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"invalid non-blank character"	pointer
)	O
)	O
;	O
APPEND	O
(	O
0	int
)	O
;	O
tp	pointer
->	O
type	enum
=	O
token_type_group	int
;	O
tp	pointer
->	O
string	pointer
=	O
xstrdup	function
(	O
buffer	pointer
)	O
;	O
return	O
;	O
}	O
case	O
'#'	O
:	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
APPEND	O
(	O
c	int
)	O
;	O
continue	O
;	O
case	O
EOF	O
:	O
case	O
'\n'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
tp	pointer
->	O
type	enum
=	O
token_type_comment	int
;	O
tp	pointer
->	O
string	pointer
=	O
xstrdup	function
(	O
buffer	pointer
)	O
;	O
return	O
;	O
}	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'-'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
size_t	long
locale_start	long
;	O
bool	bool
found_locale	bool
=	O
false	int
;	O
size_t	long
value_start	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
APPEND	O
(	O
c	int
)	O
;	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'-'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
continue	O
;	O
case	O
'['	O
:	O
APPEND	O
(	O
0	int
)	O
;	O
found_locale	bool
=	O
true	int
;	O
locale_start	long
=	O
bufpos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c2	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c2	int
)	O
{	O
default	O
:	O
APPEND	O
(	O
c2	int
)	O
;	O
continue	O
;	O
case	O
EOF	O
:	O
case	O
']'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
phase2_ungetc	function
(	O
c	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
if	O
(	O
c	int
==	O
' '	O
)	O
continue	O
;	O
phase2_ungetc	function
(	O
c	int
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
case	O
'\n'	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
'='	O
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	pointer
,	O
gram_pos	struct
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
xasprintf	function
(	O
_	O
(	O
"missing '=' after \"%s\""	pointer
)	O
,	O
buffer	pointer
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
||	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
tp	pointer
->	O
type	enum
=	O
token_type_other	int
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
if	O
(	O
c	int
==	O
' '	O
)	O
continue	O
;	O
phase2_ungetc	function
(	O
c	int
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
value_start	long
=	O
bufpos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
||	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
APPEND	O
(	O
c	int
)	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
tp	pointer
->	O
type	enum
=	O
token_type_pair	int
;	O
tp	pointer
->	O
string	pointer
=	O
xmemdup	function
(	O
buffer	pointer
,	O
bufpos	long
)	O
;	O
tp	pointer
->	O
locale	pointer
=	O
found_locale	bool
?	O
&	O
buffer	pointer
[	O
locale_start	long
]	O
:	O
NULL	O
;	O
tp	pointer
->	O
value	pointer
=	O
&	O
buffer	pointer
[	O
value_start	long
]	O
;	O
return	O
;	O
}	O
default	O
:	O
{	O
bool	bool
non_blank	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
!	O
c_isspace	function
(	O
c	int
)	O
)	O
non_blank	bool
=	O
true	int
;	O
else	O
APPEND	O
(	O
c	int
)	O
;	O
c	int
=	O
phase2_getc	function
(	O
)	O
;	O
}	O
if	O
(	O
non_blank	bool
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
NULL	O
,	O
real_file_name	pointer
,	O
gram_pos	struct
.	O
line_number	long
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"invalid non-blank line"	pointer
)	O
)	O
;	O
tp	pointer
->	O
type	enum
=	O
token_type_other	int
;	O
return	O
;	O
}	O
APPEND	O
(	O
0	int
)	O
;	O
tp	pointer
->	O
type	enum
=	O
token_type_blank	int
;	O
tp	pointer
->	O
string	pointer
=	O
xstrdup	function
(	O
buffer	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
void	O
desktop_parse	function
(	O
desktop_reader_ty	struct
*	O
reader	pointer
,	O
FILE	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
real_filename	pointer
,	O
const	O
char	O
*	O
logical_filename	pointer
)	O
{	O
fp	pointer
=	O
file	pointer
;	O
real_file_name	pointer
=	O
real_filename	pointer
;	O
gram_pos	struct
.	O
file_name	pointer
=	O
xstrdup	function
(	O
logical_filename	pointer
)	O
;	O
gram_pos	struct
.	O
line_number	long
=	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token_ty	struct
token	struct
;	O
desktop_lex	function
(	O
&	O
token	struct
)	O
;	O
switch	O
(	O
token	struct
.	O
type	enum
)	O
{	O
case	O
token_type_eof	int
:	O
goto	O
out	O
;	O
case	O
token_type_group	int
:	O
desktop_reader_handle_group	function
(	O
reader	pointer
,	O
token	struct
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
token_type_comment	int
:	O
desktop_reader_handle_comment	function
(	O
reader	pointer
,	O
token	struct
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
token_type_pair	int
:	O
desktop_reader_handle_pair	function
(	O
reader	pointer
,	O
&	O
gram_pos	struct
,	O
token	struct
.	O
string	pointer
,	O
token	struct
.	O
locale	pointer
,	O
token	struct
.	O
value	pointer
)	O
;	O
break	O
;	O
case	O
token_type_blank	int
:	O
desktop_reader_handle_blank	function
(	O
reader	pointer
,	O
token	struct
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
token_type_other	int
:	O
break	O
;	O
}	O
free_token	function
(	O
&	O
token	struct
)	O
;	O
}	O
out	O
:	O
fp	pointer
=	O
NULL	O
;	O
real_file_name	pointer
=	O
NULL	O
;	O
gram_pos	struct
.	O
line_number	long
=	O
0	int
;	O
}	O
char	O
*	O
desktop_escape_string	function
(	O
const	O
char	O
*	O
s	pointer
,	O
bool	bool
is_list	bool
)	O
{	O
char	O
*	O
buffer	pointer
,	O
*	O
p	pointer
;	O
p	pointer
=	O
buffer	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
s	pointer
)	O
*	O
2	int
+	O
1	int
,	O
char	O
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
{	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\s"	pointer
)	O
;	O
s	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'\t'	O
)	O
{	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\t"	pointer
)	O
;	O
s	pointer
++	O
;	O
}	O
for	O
(	O
;	O
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
break	O
;	O
}	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'\n'	O
:	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\n"	pointer
)	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\r"	pointer
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
is_list	bool
&&	O
*	O
(	O
s	pointer
+	O
1	int
)	O
==	O
';'	O
)	O
{	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\;"	pointer
)	O
;	O
s	pointer
++	O
;	O
}	O
else	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\\\"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
break	O
;	O
}	O
}	O
return	O
buffer	pointer
;	O
}	O
char	O
*	O
desktop_unescape_string	function
(	O
const	O
char	O
*	O
s	pointer
,	O
bool	bool
is_list	bool
)	O
{	O
char	O
*	O
buffer	pointer
,	O
*	O
p	pointer
;	O
p	pointer
=	O
buffer	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
,	O
char	O
)	O
;	O
for	O
(	O
;	O
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
s	pointer
==	O
'\\'	O
)	O
{	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
break	O
;	O
}	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
's'	O
:	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	pointer
++	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	pointer
++	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
';'	O
:	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
"\\;"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
break	O
;	O
}	O
}	O
else	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
}	O
return	O
buffer	pointer
;	O
}	O
void	O
desktop_add_keyword	function
(	O
hash_table	struct
*	O
keywords	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bool	bool
is_list	bool
)	O
{	O
hash_insert_entry	function
(	O
keywords	pointer
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
,	O
(	O
void	O
*	O
)	O
is_list	bool
)	O
;	O
}	O
void	O
desktop_add_default_keywords	function
(	O
hash_table	struct
*	O
keywords	pointer
)	O
{	O
desktop_add_keyword	function
(	O
keywords	pointer
,	O
"Name"	pointer
,	O
false	int
)	O
;	O
desktop_add_keyword	function
(	O
keywords	pointer
,	O
"GenericName"	pointer
,	O
false	int
)	O
;	O
desktop_add_keyword	function
(	O
keywords	pointer
,	O
"Comment"	pointer
,	O
false	int
)	O
;	O
desktop_add_keyword	function
(	O
keywords	pointer
,	O
"Icon"	pointer
,	O
false	int
)	O
;	O
desktop_add_keyword	function
(	O
keywords	pointer
,	O
"Keywords"	pointer
,	O
true	int
)	O
;	O
}	O
