static	O
int	O
textstart	int
=	O
1	int
;	O
static	O
char	O
inputtext	array
[	O
XTEXTMAX	int
]	O
[	O
YTEXTMAX	int
]	O
;	O
static	O
int	O
line	int
;	O
static	O
int	O
nlines	int
;	O
static	O
int	O
mlines	int
;	O
void	O
(	O
*	O
inputhandler	pointer
)	O
(	O
void	O
)	O
;	O
int	O
prog_argc	int
;	O
char	O
*	O
*	O
prog_argv	pointer
;	O
extern	O
struct	O
ui_driver	struct
*	O
drivers	array
[	O
]	O
;	O
extern	O
int	O
ndrivers	int
;	O
static	O
int	O
width	int
,	O
height	int
;	O
static	O
int	O
maxiter	int
;	O
static	O
xio_pathdata	array
configfile	array
;	O
static	O
int	O
autopilot	int
;	O
static	O
void	O
ui_help	function
(	O
int	O
)	O
;	O
static	O
int	O
ui_mouse	function
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
;	O
static	O
int	O
keybuffer	array
[	O
SIZE	int
]	O
;	O
static	O
int	O
introtext	int
=	O
1	int
;	O
static	O
int	O
begin	int
=	O
0	int
,	O
end	int
=	O
0	int
;	O
static	O
int	O
resized	int
;	O
static	O
int	O
callresize	int
=	O
0	int
;	O
char	O
*	O
interruptkeys	pointer
=	O
"z123456789rmfqe"	pointer
;	O
static	O
int	O
defformula	array
[	O
10	int
]	O
;	O
static	O
int	O
defautopilot	int
=	O
0	int
;	O
static	O
int	O
defiters	int
=	O
-	O
1	int
;	O
static	O
int	O
defperiodicity	int
=	O
-	O
1	int
;	O
static	O
tl_timer	struct
*	O
maintimer	pointer
;	O
static	O
tl_timer	struct
*	O
loopt	pointer
;	O
static	O
int	O
defincoloring	int
=	O
-	O
1	int
;	O
static	O
int	O
maxframerate	int
=	O
0	int
;	O
static	O
int	O
letterspersec	int
=	O
15	int
;	O
static	O
int	O
defoutcoloring	int
=	O
-	O
1	int
;	O
static	O
int	O
defplane	int
=	O
-	O
1	int
;	O
static	O
float	O
defspeed	float
=	O
-	O
1	int
;	O
static	O
char	O
*	O
defdriver	pointer
=	O
NULL	O
;	O
static	O
int	O
todriver	int
=	O
0	int
;	O
static	O
int	O
defguessing	int
=	O
-	O
1	int
;	O
static	O
int	O
deflist	int
;	O
static	O
char	O
*	O
deflanguage	pointer
=	O
NULL	O
;	O
static	O
int	O
printconfig	int
;	O
static	O
int	O
printspeed	int
;	O
static	O
int	O
fastmode	int
=	O
-	O
1	int
;	O
static	O
int	O
delaytime	int
=	O
0	int
;	O
static	O
int	O
defthreads	int
=	O
0	int
;	O
static	O
char	O
*	O
loadfile	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
playfile	pointer
=	O
NULL	O
;	O
static	O
float	O
defscreenwidth	float
=	O
0.0	int
,	O
defscreenheight	float
=	O
0.0	int
,	O
defpixelwidth	float
=	O
0.0	int
,	O
defpixelheight	float
=	O
0.0	int
;	O
struct	O
params	struct
global_params	array
[	O
]	O
=	O
{	O
{	O
"-language"	pointer
,	O
P_STRING	int
,	O
&	O
deflanguage	pointer
,	O
"Select language catalog for tutorials"	pointer
}	O
,	O
{	O
"-load"	pointer
,	O
P_STRING	int
,	O
&	O
loadfile	pointer
,	O
"Load possition"	pointer
}	O
,	O
{	O
"-play"	pointer
,	O
P_STRING	int
,	O
&	O
playfile	pointer
,	O
"Play animation"	pointer
}	O
,	O
{	O
"-delay"	pointer
,	O
P_NUMBER	int
,	O
&	O
delaytime	int
,	O
"Delay screen updates (milliseconds)."	pointer
}	O
,	O
{	O
"-maxframerate"	pointer
,	O
P_NUMBER	int
,	O
&	O
maxframerate	int
,	O
"Maximal framerate (0 for unlimited - default)"	pointer
}	O
,	O
{	O
"-letterspersec"	pointer
,	O
P_NUMBER	int
,	O
&	O
letterspersec	int
,	O
"Subtitles speed in tutorials (20 by default)"	pointer
}	O
,	O
{	O
""	pointer
,	O
P_HELP	int
,	O
NULL	O
,	O
"Screen size options: \n\n  Knowedge of exact screen size makes random dot stereogram look better. \n  Also is used for choosing correct view area."	pointer
}	O
,	O
{	O
"-screenwidth"	pointer
,	O
P_FLOAT	int
,	O
&	O
defscreenwidth	float
,	O
"exact size of screen in centimeters"	pointer
}	O
,	O
{	O
"-screenheight"	pointer
,	O
P_FLOAT	int
,	O
&	O
defscreenheight	float
,	O
"exact size of screen in centimeters"	pointer
}	O
,	O
{	O
""	pointer
,	O
P_HELP	int
,	O
NULL	O
,	O
"  Use this option in case you use some kind of virtual screen\n  or something similiar that confuses previous options"	pointer
}	O
,	O
{	O
"-pixelwidth"	pointer
,	O
P_FLOAT	int
,	O
&	O
defpixelwidth	float
,	O
"exact size of one pixel in centimeters"	pointer
}	O
,	O
{	O
"-pixelheight"	pointer
,	O
P_FLOAT	int
,	O
&	O
defpixelheight	float
,	O
"exact size of one pixel in centimeters"	pointer
}	O
,	O
{	O
""	pointer
,	O
P_HELP	int
,	O
NULL	O
,	O
"Fractal formulas:"	pointer
}	O
,	O
{	O
"-mandel"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
,	O
"Start with Mandelbrot set fractal(default)"	pointer
}	O
,	O
{	O
"-mandel3"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
1	int
,	O
"Start with Mandelbrot set power 3 fractal"	pointer
}	O
,	O
{	O
"-mandel4"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
2	int
,	O
"Start with Mandelbrot set power 4 fractal"	pointer
}	O
,	O
{	O
"-mandel5"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
3	int
,	O
"Start with Mandelbrot set power 5 fractal"	pointer
}	O
,	O
{	O
"-mandel6"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
4	int
,	O
"Start with Mandelbrot set power 6 fractal"	pointer
}	O
,	O
{	O
"-octo"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
5	int
,	O
"Start with Octal fractal"	pointer
}	O
,	O
{	O
"-newton"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
6	int
,	O
"Start with Newton fractal"	pointer
}	O
,	O
{	O
"-barnsley"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
7	int
,	O
"Start with Barnsley fractal"	pointer
}	O
,	O
{	O
"-phoenix"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
8	int
,	O
"Start with Phoenix fractal"	pointer
}	O
,	O
{	O
"-magnet"	pointer
,	O
P_SWITCH	int
,	O
defformula	array
+	O
9	int
,	O
"Start with Magnet fractal"	pointer
}	O
,	O
{	O
""	pointer
,	O
P_HELP	int
,	O
NULL	O
,	O
"Fractal oprions:"	pointer
}	O
,	O
{	O
"-iter"	pointer
,	O
P_NUMBER	int
,	O
&	O
defiters	int
,	O
"Default number of iterations"	pointer
}	O
,	O
{	O
"-incoloring"	pointer
,	O
P_NUMBER	int
,	O
&	O
defincoloring	int
,	O
"Set incoloring mode"	pointer
}	O
,	O
{	O
"-outcoloring"	pointer
,	O
P_NUMBER	int
,	O
&	O
defoutcoloring	int
,	O
"Default outcoloringcoloring scheme"	pointer
}	O
,	O
{	O
"-plane"	pointer
,	O
P_NUMBER	int
,	O
&	O
defplane	int
,	O
"Default plane"	pointer
}	O
,	O
{	O
"-noperiodicity"	pointer
,	O
P_SWITCH	int
,	O
&	O
defperiodicity	int
,	O
"Disable periodicity checking"	pointer
}	O
,	O
{	O
"-guessing"	pointer
,	O
P_NUMBER	int
,	O
&	O
defguessing	int
,	O
"Default solid guessing range"	pointer
}	O
,	O
{	O
"-dynres"	pointer
,	O
P_NUMBER	int
,	O
&	O
fastmode	int
,	O
"Default dynamic resolution mode"	pointer
}	O
,	O
{	O
""	pointer
,	O
P_HELP	int
,	O
NULL	O
,	O
"Parameters for ugly interface:"	pointer
}	O
,	O
{	O
"-autopilot"	pointer
,	O
P_SWITCH	int
,	O
&	O
defautopilot	int
,	O
"Enable autopilot"	pointer
}	O
,	O
{	O
"-speed"	pointer
,	O
P_FLOAT	int
,	O
&	O
defspeed	float
,	O
"Zooming speed (default is 1)"	pointer
}	O
,	O
{	O
"-driver"	pointer
,	O
P_STRING	int
,	O
&	O
defdriver	pointer
,	O
"Select driver"	pointer
}	O
,	O
{	O
"-list"	pointer
,	O
P_SWITCH	int
,	O
&	O
deflist	int
,	O
"List available drivers. Than exit"	pointer
}	O
,	O
{	O
"-config"	pointer
,	O
P_SWITCH	int
,	O
&	O
printconfig	int
,	O
"Print configuration. Than exit"	pointer
}	O
,	O
{	O
"-speedtest"	pointer
,	O
P_SWITCH	int
,	O
&	O
printspeed	int
,	O
"Test speed of caluclation loop. Than exit"	pointer
}	O
,	O
{	O
"-threads"	pointer
,	O
P_NUMBER	int
,	O
&	O
defthreads	int
,	O
"Multiple CPUs supported - please recompile XaoS with threads enabled"	pointer
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
fractal_context	struct
*	O
fcontext	pointer
;	O
static	O
struct	O
palette	struct
*	O
palette	struct
;	O
static	O
struct	O
image	struct
*	O
image	struct
;	O
static	O
uih_context	struct
*	O
uih	pointer
;	O
static	O
struct	O
ui_driver	struct
*	O
driver	pointer
;	O
static	O
int	O
ministatus	int
=	O
0	int
;	O
static	O
char	O
statustext	array
[	O
256	int
]	O
;	O
static	O
int	O
menumax	int
;	O
static	O
void	O
(	O
*	O
menucallback	pointer
)	O
(	O
int	O
)	O
;	O
static	O
int	O
numbertype	int
=	O
FORMULA	int
;	O
static	O
int	O
helppage	int
;	O
static	O
void	O
mousetype	pointer
(	O
int	O
m	int
)	O
{	O
static	O
int	O
mouse	int
;	O
if	O
(	O
mouse	int
!=	O
m	int
)	O
{	O
mouse	int
=	O
m	int
;	O
if	O
(	O
driver	pointer
->	O
mousetype	pointer
!=	O
NULL	O
)	O
driver	pointer
->	O
mousetype	pointer
(	O
m	int
)	O
;	O
}	O
}	O
static	O
void	O
ui_display	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
uih	pointer
->	O
clearscreen	int
)	O
driver	pointer
->	O
display	int
(	O
)	O
;	O
if	O
(	O
numbertype	int
!=	O
FORMULA	int
)	O
uih_cycling_continue	function
(	O
uih	pointer
)	O
;	O
numbertype	int
=	O
FORMULA	int
;	O
if	O
(	O
ministatus	int
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
statustext	array
)	O
;	O
if	O
(	O
!	O
(	O
driver	pointer
->	O
flags	int
&	O
NOFLUSHDISPLAY	int
)	O
)	O
ui_flush	O
(	O
)	O
;	O
}	O
static	O
float	O
get_windowwidth	function
(	O
int	O
width	int
)	O
{	O
if	O
(	O
defscreenwidth	float
>	O
0.0	int
&&	O
driver	pointer
->	O
flags	int
&	O
RESOLUTION	int
)	O
return	O
(	O
defscreenwidth	float
*	O
width	int
/	O
driver	pointer
->	O
maxwidth	int
)	O
;	O
if	O
(	O
defscreenwidth	float
>	O
0.0	int
)	O
return	O
(	O
defscreenwidth	float
)	O
;	O
if	O
(	O
defpixelwidth	float
>	O
0.0	int
)	O
return	O
(	O
defpixelwidth	float
*	O
width	int
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
PIXELSIZE	int
)	O
return	O
(	O
driver	pointer
->	O
width	int
*	O
width	int
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
SCREENSIZE	int
)	O
return	O
(	O
driver	pointer
->	O
width	int
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
RESOLUTION	int
)	O
return	O
(	O
29.0	int
/	O
driver	pointer
->	O
maxwidth	int
*	O
width	int
)	O
;	O
return	O
(	O
29.0	int
)	O
;	O
}	O
static	O
float	O
get_windowheight	function
(	O
int	O
height	int
)	O
{	O
if	O
(	O
defscreenheight	float
>	O
0.0	int
&&	O
driver	pointer
->	O
flags	int
&	O
RESOLUTION	int
)	O
return	O
(	O
defscreenheight	float
*	O
height	int
/	O
driver	pointer
->	O
maxheight	int
)	O
;	O
if	O
(	O
defscreenheight	float
>	O
0.0	int
)	O
return	O
(	O
defscreenheight	float
)	O
;	O
if	O
(	O
defpixelheight	float
>	O
0.0	int
)	O
return	O
(	O
defpixelheight	float
*	O
height	int
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
PIXELSIZE	int
)	O
return	O
(	O
driver	pointer
->	O
height	int
*	O
height	int
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
SCREENSIZE	int
)	O
return	O
(	O
driver	pointer
->	O
height	int
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
RESOLUTION	int
)	O
return	O
(	O
21.0	int
/	O
driver	pointer
->	O
maxheight	int
*	O
height	int
)	O
;	O
return	O
(	O
21.5	int
)	O
;	O
}	O
extern	O
int	O
dynsize	int
;	O
static	O
void	O
ui_outofmem	function
(	O
void	O
)	O
{	O
printf	function
(	O
"\n\nXaoS is out of memory.\n"	pointer
)	O
;	O
}	O
static	O
int	O
ui_passfunc	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
,	O
int	O
display	int
,	O
char	O
*	O
text	pointer
,	O
float	O
percent	float
)	O
{	O
char	O
str	array
[	O
80	int
]	O
;	O
int	O
x	pointer
,	O
y	pointer
,	O
b	int
,	O
k	double
;	O
if	O
(	O
!	O
uih	pointer
->	O
play	int
)	O
{	O
if	O
(	O
display	int
)	O
ui_display	function
(	O
)	O
;	O
sprintf	function
(	O
str	array
,	O
"%s %3.2f%%        "	pointer
,	O
text	pointer
,	O
percent	float
)	O
;	O
}	O
driver	pointer
->	O
processevents	pointer
(	O
0	int
,	O
&	O
x	pointer
,	O
&	O
y	pointer
,	O
&	O
b	int
,	O
&	O
k	double
)	O
;	O
CHECKPROCESSEVENTS	O
(	O
b	int
,	O
k	double
)	O
;	O
if	O
(	O
k	double
&	O
3	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
!	O
c	pointer
->	O
interruptiblemode	int
&&	O
!	O
uih	pointer
->	O
play	int
)	O
{	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
height	int
-	O
textheight1	O
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
driver	pointer
->	O
flags	int
&	O
NOFLUSHDISPLAY	int
)	O
)	O
ui_flush	O
(	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
ui_updatestatus	function
(	O
void	O
)	O
{	O
double	O
times	array
=	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
v	struct
.	O
rr	double
)	O
/	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
)	O
;	O
double	O
speed	double
;	O
if	O
(	O
!	O
uih	pointer
->	O
clearscreen	int
)	O
driver	pointer
->	O
display	int
(	O
)	O
;	O
if	O
(	O
numbertype	int
!=	O
FORMULA	int
)	O
uih_cycling_continue	function
(	O
uih	pointer
)	O
;	O
numbertype	int
=	O
FORMULA	int
;	O
speed	double
=	O
uih_displayed	function
(	O
uih	pointer
)	O
;	O
sprintf	function
(	O
statustext	array
,	O
"%s %.2f times %2.2f frames/sec %c %i %i %i %i            "	pointer
,	O
times	array
<	O
1	int
?	O
"unzoomed"	pointer
:	O
"zoomed"	pointer
,	O
times	array
<	O
1	int
?	O
1.0	int
/	O
times	array
:	O
times	array
,	O
speed	double
,	O
autopilot	int
?	O
'A'	O
:	O
' '	O
,	O
uih	pointer
->	O
fcontext	pointer
->	O
coloringmode	int
+	O
1	int
,	O
uih	pointer
->	O
fcontext	pointer
->	O
incoloringmode	int
+	O
1	int
,	O
uih	pointer
->	O
fcontext	pointer
->	O
plane	int
+	O
1	int
,	O
uih	pointer
->	O
fcontext	pointer
->	O
maxiter	int
)	O
;	O
if	O
(	O
ministatus	int
)	O
{	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
statustext	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
driver	pointer
->	O
flags	int
&	O
NOFLUSHDISPLAY	int
)	O
)	O
ui_flush	O
(	O
)	O
;	O
STAT	O
(	O
printf	function
(	O
"framerate:%f\n"	pointer
,	O
speed	double
)	O
)	O
;	O
}	O
void	O
ui_menu	function
(	O
char	O
*	O
*	O
text	pointer
,	O
char	O
*	O
label	pointer
,	O
int	O
n	int
,	O
void	O
(	O
*	O
callback	pointer
)	O
(	O
int	O
)	O
)	O
{	O
int	O
i	pointer
;	O
char	O
s	struct
[	O
50	int
]	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
PALETTE_REDISPLAYS	int
)	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
numbertype	int
=	O
MENU	int
;	O
menumax	int
=	O
n	int
;	O
menucallback	pointer
=	O
callback	pointer
;	O
sprintf	function
(	O
s	struct
,	O
"%-40s"	pointer
,	O
label	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
s	struct
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
i	pointer
<	O
10	int
)	O
sprintf	function
(	O
s	struct
,	O
" %i - %-35s"	pointer
,	O
i	pointer
==	O
9	int
?	O
0	int
:	O
i	pointer
+	O
1	int
,	O
text	pointer
[	O
i	pointer
]	O
)	O
;	O
else	O
sprintf	function
(	O
s	struct
,	O
" %c - %-35s"	pointer
,	O
'A'	O
+	O
i	pointer
-	O
10	int
,	O
text	pointer
[	O
i	pointer
]	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
i	pointer
+	O
1	int
)	O
*	O
textheight1	O
,	O
s	struct
)	O
;	O
}	O
ui_flush	O
(	O
)	O
;	O
}	O
static	O
void	O
ui_menupress	function
(	O
int	O
number	int
)	O
{	O
if	O
(	O
number	int
>=	O
menumax	int
)	O
return	O
;	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
numbertype	int
=	O
FORMULA	int
;	O
menucallback	pointer
(	O
number	int
)	O
;	O
}	O
static	O
void	O
ui_fastmode	function
(	O
int	O
mode	int
)	O
{	O
uih	pointer
->	O
fastmode	int
=	O
mode	int
+	O
1	int
;	O
}	O
static	O
void	O
ui_fastmode_menu	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
fastmodes	array
[	O
]	O
=	O
{	O
"dynamic resolution disabled"	pointer
,	O
"use only during animation"	pointer
,	O
"use also for new images"	pointer
,	O
}	O
;	O
ui_menu	function
(	O
fastmodes	array
,	O
"Please select drawing mode"	pointer
,	O
3	int
,	O
ui_fastmode	function
)	O
;	O
}	O
static	O
void	O
ui_guessing	function
(	O
int	O
mode	int
)	O
{	O
uih_setguessing	function
(	O
uih	pointer
,	O
mode	int
+	O
1	int
)	O
;	O
}	O
static	O
int	O
tutorialn	int
;	O
static	O
void	O
ui_playtutorial	function
(	O
int	O
n	int
)	O
{	O
char	O
*	O
name	pointer
;	O
xio_pathdata	array
tmp	array
;	O
xio_file	pointer
f	pointer
=	O
XIO_FAILED	O
;	O
static	O
char	O
*	O
names	array
[	O
]	O
[	O
10	int
]	O
=	O
{	O
{	O
"cesky"	pointer
,	O
"deutsch"	pointer
,	O
"english"	pointer
,	O
"francais"	pointer
,	O
}	O
,	O
{	O
"fractal.xaf"	pointer
,	O
"intro.xaf"	pointer
,	O
"power.xaf"	pointer
,	O
"newton.xaf"	pointer
,	O
"barnsley.xaf"	pointer
,	O
"phoenix.xaf"	pointer
,	O
"octo.xaf"	pointer
,	O
"magnet.xaf"	pointer
,	O
}	O
,	O
{	O
"features.xaf"	pointer
,	O
"outcolor.xaf"	pointer
,	O
"incolor.xaf"	pointer
,	O
"truecol.xaf"	pointer
,	O
"filter.xaf"	pointer
,	O
"plane.xaf"	pointer
,	O
"anim.xaf"	pointer
,	O
"pert.xaf"	pointer
,	O
"palette.xaf"	pointer
,	O
"other.xaf"	pointer
,	O
}	O
,	O
{	O
"new30.xaf"	pointer
,	O
}	O
}	O
;	O
name	pointer
=	O
names	array
[	O
tutorialn	int
]	O
[	O
n	int
]	O
;	O
if	O
(	O
!	O
tutorialn	int
)	O
{	O
uih_loadcatalog	function
(	O
uih	pointer
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
f	pointer
=	O
xio_gettutorial	function
(	O
name	pointer
,	O
tmp	array
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
uih	pointer
->	O
errstring	pointer
=	O
"Tutorial files not found. Reinstall XaoS"	pointer
;	O
return	O
;	O
}	O
driver	pointer
->	O
clrscr	pointer
(	O
)	O
;	O
mousetype	pointer
(	O
WAITMOUSE	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Preparing first frame. Please wait"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
uih_replayenable	function
(	O
uih	pointer
,	O
f	pointer
,	O
tmp	array
)	O
;	O
}	O
static	O
void	O
ui_loadexample	function
(	O
void	O
)	O
{	O
xio_pathdata	array
name	pointer
;	O
xio_file	pointer
f	pointer
=	O
xio_getrandomexample	function
(	O
name	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
uih	pointer
->	O
errstring	pointer
=	O
"Could not open examples"	pointer
;	O
return	O
;	O
}	O
uih_load	function
(	O
uih	pointer
,	O
f	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
int	O
ui_loadfile	function
(	O
xio_path	pointer
name	pointer
)	O
{	O
xio_file	pointer
f	pointer
;	O
f	pointer
=	O
xio_ropen	O
(	O
name	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
return	O
0	int
;	O
}	O
uih_load	function
(	O
uih	pointer
,	O
f	pointer
,	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
ui_load2	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
ui_loadfile	function
(	O
inputtext	array
[	O
0	int
]	O
)	O
)	O
{	O
char	O
s	struct
[	O
256	int
]	O
;	O
sprintf	function
(	O
s	struct
,	O
"%s.xpf"	pointer
,	O
inputtext	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
ui_loadfile	function
(	O
s	struct
)	O
)	O
{	O
sprintf	function
(	O
s	struct
,	O
"fract%s.xpf"	pointer
,	O
inputtext	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
ui_loadfile	function
(	O
s	struct
)	O
)	O
{	O
uih	pointer
->	O
errstring	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
ui_play2	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
uih_replayenable	function
(	O
uih	pointer
,	O
xio_ropen	O
(	O
inputtext	array
[	O
0	int
]	O
)	O
,	O
inputtext	array
[	O
0	int
]	O
)	O
)	O
{	O
char	O
s	struct
[	O
256	int
]	O
;	O
uih	pointer
->	O
errstring	pointer
=	O
NULL	O
;	O
sprintf	function
(	O
s	struct
,	O
"%s.xaf"	pointer
,	O
inputtext	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
uih_replayenable	function
(	O
uih	pointer
,	O
xio_ropen	O
(	O
s	struct
)	O
,	O
s	struct
)	O
)	O
{	O
sprintf	function
(	O
s	struct
,	O
"anim%s.xaf"	pointer
,	O
inputtext	array
[	O
0	int
]	O
)	O
;	O
uih	pointer
->	O
errstring	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
uih_replayenable	function
(	O
uih	pointer
,	O
xio_ropen	O
(	O
s	struct
)	O
,	O
s	struct
)	O
)	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
ui_input	function
(	O
int	O
ml	int
,	O
int	O
shift	int
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
void	O
)	O
)	O
{	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
inputhandler	pointer
=	O
handler	pointer
;	O
numbertype	int
=	O
INPUT	int
;	O
mlines	int
=	O
ml	int
;	O
nlines	int
=	O
1	int
;	O
inputtext	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
line	int
=	O
0	int
;	O
textstart	int
=	O
shift	int
;	O
}	O
static	O
void	O
ui_load	function
(	O
void	O
)	O
{	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Enter filename (or number)"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
ui_input	function
(	O
0	int
,	O
1	int
,	O
ui_load2	function
)	O
;	O
}	O
static	O
void	O
ui_play	function
(	O
void	O
)	O
{	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Enter filename (or number)"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
ui_input	function
(	O
0	int
,	O
1	int
,	O
ui_play2	function
)	O
;	O
}	O
static	O
void	O
ui_tutorial	function
(	O
int	O
n	int
)	O
{	O
int	O
num	int
;	O
static	O
char	O
*	O
tutorials	array
[	O
]	O
[	O
11	int
]	O
=	O
{	O
{	O
"Cesky"	pointer
,	O
"Deutsch"	pointer
,	O
"English"	pointer
,	O
"Francais"	pointer
,	O
NULL	O
}	O
,	O
{	O
"Whole story"	pointer
,	O
"Introduction and the Mandelbrot set"	pointer
,	O
"Higher power Mandelbrots"	pointer
,	O
"Newton's method"	pointer
,	O
"Barnsley's formula"	pointer
,	O
"Phoenix"	pointer
,	O
"Octo"	pointer
,	O
"Magnet"	pointer
,	O
NULL	O
}	O
,	O
{	O
"All features"	pointer
,	O
"Outcoloring modes"	pointer
,	O
"Incoloring modes"	pointer
,	O
"True-color coloring modes"	pointer
,	O
"Filters"	pointer
,	O
"Planes"	pointer
,	O
"Animations and possition files"	pointer
,	O
"Perturbation"	pointer
,	O
"Random palettes"	pointer
,	O
"Other noteworthly features"	pointer
}	O
,	O
{	O
"Whats new in 3.0?"	pointer
}	O
,	O
}	O
;	O
tutorialn	int
=	O
n	int
;	O
ui_display	function
(	O
)	O
;	O
for	O
(	O
num	int
=	O
0	int
;	O
tutorials	array
[	O
n	int
]	O
[	O
num	int
]	O
!=	O
NULL	O
;	O
num	int
++	O
)	O
;	O
ui_menu	function
(	O
tutorials	array
[	O
n	int
]	O
,	O
"Please select chapter"	pointer
,	O
num	int
,	O
ui_playtutorial	function
)	O
;	O
}	O
static	O
void	O
ui_tutorial_menu	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
tutorials	array
[	O
]	O
=	O
{	O
"Select language for tutorials"	pointer
,	O
"An introduction to fractals"	pointer
,	O
"XaoS features overview"	pointer
,	O
"Whats new?"	pointer
,	O
}	O
;	O
ui_display	function
(	O
)	O
;	O
ui_menu	function
(	O
tutorials	array
,	O
"Please select tutorial"	pointer
,	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
tutorials	array
)	O
/	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
,	O
ui_tutorial	function
)	O
;	O
}	O
static	O
void	O
ui_guessing_menu	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
guessmodes	array
[	O
]	O
=	O
{	O
"solid guessing disabled"	pointer
,	O
"guess maximally 2x2 rectangles"	pointer
,	O
"guess maximally 3x3 rectangles"	pointer
,	O
"guess maximally 4x4 rectangles"	pointer
,	O
"guess maximally 5x5 rectangles"	pointer
,	O
"guess maximally 6x6 rectangles"	pointer
,	O
"guess maximally 7x7 rectangles"	pointer
,	O
"guess maximally 8x8 rectangles"	pointer
,	O
}	O
;	O
ui_menu	function
(	O
guessmodes	array
,	O
"Please select solid guessing mode"	pointer
,	O
8	int
,	O
ui_guessing	function
)	O
;	O
}	O
static	O
void	O
ui_outcoloringmode	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
coloringmode	int
==	O
10	int
)	O
{	O
if	O
(	O
mode	int
==	O
TCOLOR	int
)	O
uih_setoutcoloringmode	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
else	O
uih_setouttcolor	function
(	O
uih	pointer
,	O
mode	int
)	O
;	O
}	O
else	O
uih_setoutcoloringmode	function
(	O
uih	pointer
,	O
mode	int
)	O
;	O
}	O
static	O
void	O
ui_outcoloringmode_menu	function
(	O
void	O
)	O
{	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
coloringmode	int
!=	O
10	int
)	O
ui_menu	function
(	O
outcolorname	array
,	O
"Please select outcoloring mode"	pointer
,	O
OUTCOLORING	int
,	O
ui_outcoloringmode	function
)	O
;	O
else	O
ui_menu	function
(	O
tcolorname	array
,	O
"Please select truecolor outcoloring mode"	pointer
,	O
TCOLOR	int
+	O
1	int
,	O
ui_outcoloringmode	function
)	O
;	O
}	O
static	O
void	O
ui_incoloringmode	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
incoloringmode	int
==	O
10	int
)	O
{	O
if	O
(	O
mode	int
==	O
TCOLOR	int
)	O
uih_setincoloringmode	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
else	O
uih_setintcolor	function
(	O
uih	pointer
,	O
mode	int
)	O
;	O
}	O
else	O
uih_setincoloringmode	function
(	O
uih	pointer
,	O
mode	int
)	O
;	O
}	O
static	O
void	O
ui_incoloringmode_menu	function
(	O
void	O
)	O
{	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
incoloringmode	int
!=	O
10	int
)	O
ui_menu	function
(	O
incolorname	array
,	O
"Please select incoloring mode"	pointer
,	O
INCOLORING	int
,	O
ui_incoloringmode	function
)	O
;	O
else	O
ui_menu	function
(	O
tcolorname	array
,	O
"Please select truecolor incoloring mode"	pointer
,	O
TCOLOR	int
+	O
1	int
,	O
ui_incoloringmode	function
)	O
;	O
}	O
static	O
void	O
ui_periodicity	function
(	O
void	O
)	O
{	O
ui_updatestatus	function
(	O
)	O
;	O
uih_setperiodicity	function
(	O
uih	pointer
,	O
fcontext	pointer
->	O
periodicity	int
^	O
1	int
)	O
;	O
if	O
(	O
fcontext	pointer
->	O
periodicity	int
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Periodicity checking enabled. "	pointer
)	O
;	O
else	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Periodicity checking disabled."	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
xio_path	pointer
ui_getfile	function
(	O
char	O
*	O
basename	pointer
,	O
char	O
*	O
extension	pointer
)	O
{	O
return	O
(	O
xio_getfilename	function
(	O
basename	pointer
,	O
extension	pointer
)	O
)	O
;	O
}	O
static	O
void	O
ui_savepngfile	function
(	O
void	O
)	O
{	O
char	O
str	array
[	O
256	int
]	O
;	O
xio_path	pointer
name	pointer
=	O
ui_getfile	function
(	O
"fract"	pointer
,	O
".png"	pointer
)	O
;	O
char	O
*	O
s	struct
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Writing png image..  "	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
s	struct
=	O
uih_save	function
(	O
uih	pointer
,	O
name	pointer
)	O
;	O
ui_updatestatus	function
(	O
)	O
;	O
if	O
(	O
s	struct
!=	O
NULL	O
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
s	struct
)	O
;	O
else	O
{	O
sprintf	function
(	O
str	array
,	O
"File %s saved"	pointer
,	O
name	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
}	O
static	O
void	O
ui_savepos	function
(	O
int	O
mode	int
)	O
{	O
char	O
str	array
[	O
256	int
]	O
;	O
xio_path	pointer
name	pointer
;	O
xio_file	pointer
f	pointer
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Writing possition..  "	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
if	O
(	O
mode	int
==	O
0	int
)	O
name	pointer
=	O
ui_getfile	function
(	O
"fract"	pointer
,	O
".xpf"	pointer
)	O
;	O
else	O
name	pointer
=	O
configfile	array
;	O
f	pointer
=	O
xio_wopen	O
(	O
name	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
XIO_FAILED	O
)	O
{	O
ui_updatestatus	function
(	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Can not open file"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
return	O
;	O
}	O
uih_save_possition	function
(	O
uih	pointer
,	O
f	pointer
,	O
mode	int
?	O
UIH_SAVEALL	int
:	O
UIH_SAVEPOS	int
)	O
;	O
ui_updatestatus	function
(	O
)	O
;	O
if	O
(	O
uih	pointer
->	O
errstring	pointer
!=	O
NULL	O
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
uih	pointer
->	O
errstring	pointer
)	O
,	O
uih	pointer
->	O
errstring	pointer
=	O
NULL	O
;	O
else	O
{	O
sprintf	function
(	O
str	array
,	O
"File %s saved"	pointer
,	O
name	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
}	O
ui_flush	O
(	O
)	O
;	O
numbertype	int
=	O
FORMULA	int
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
}	O
static	O
void	O
ui_saveanimation	function
(	O
void	O
)	O
{	O
char	O
str	array
[	O
256	int
]	O
;	O
xio_path	pointer
name	pointer
;	O
xio_file	pointer
f	pointer
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Openning animation file..  "	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
name	pointer
=	O
ui_getfile	function
(	O
"anim"	pointer
,	O
".xaf"	pointer
)	O
;	O
f	pointer
=	O
xio_wopen	O
(	O
name	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
XIO_FAILED	O
)	O
{	O
ui_updatestatus	function
(	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Can not open file"	pointer
)	O
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
ui_flush	O
(	O
)	O
;	O
return	O
;	O
}	O
uih_save_enable	function
(	O
uih	pointer
,	O
f	pointer
,	O
UIH_SAVEANIMATION	int
)	O
;	O
ui_updatestatus	function
(	O
)	O
;	O
if	O
(	O
uih	pointer
->	O
errstring	pointer
!=	O
NULL	O
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
uih	pointer
->	O
errstring	pointer
)	O
,	O
uih	pointer
->	O
errstring	pointer
=	O
NULL	O
;	O
else	O
{	O
sprintf	function
(	O
str	array
,	O
"Recording into %s enabled"	pointer
,	O
name	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
}	O
ui_flush	O
(	O
)	O
;	O
numbertype	int
=	O
FORMULA	int
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
}	O
static	O
void	O
ui_waitforcomplette	function
(	O
void	O
)	O
{	O
while	O
(	O
uih_needrecalculate	O
(	O
uih	pointer
)	O
)	O
{	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
display	int
)	O
ui_updatestatus	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
ui_text	function
(	O
void	O
)	O
{	O
char	O
text	pointer
[	O
XTEXTMAX	int
*	O
YTEXTMAX	int
]	O
;	O
int	O
i	pointer
;	O
ui_waitforcomplette	function
(	O
)	O
;	O
text	pointer
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nlines	int
;	O
i	pointer
++	O
)	O
{	O
strcat	function
(	O
text	pointer
,	O
inputtext	array
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
i	pointer
!=	O
nlines	int
-	O
1	int
)	O
strcat	function
(	O
text	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
uih_text	function
(	O
uih	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
void	O
ui_save	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
{	O
switch	O
(	O
mode	int
)	O
{	O
case	O
0	int
:	O
ui_savepngfile	function
(	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
ui_savepos	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
ui_savepos	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
!	O
uih	pointer
->	O
save	int
)	O
switch	O
(	O
mode	int
)	O
{	O
case	O
0	int
:	O
ui_savepngfile	function
(	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
ui_savepos	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
ui_saveanimation	function
(	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
ui_load	function
(	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
ui_play	function
(	O
)	O
;	O
break	O
;	O
case	O
5	int
:	O
ui_loadexample	function
(	O
)	O
;	O
break	O
;	O
case	O
6	int
:	O
ui_savepos	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
else	O
switch	O
(	O
mode	int
)	O
{	O
case	O
0	int
:	O
ui_savepngfile	function
(	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
uih_save_disable	function
(	O
uih	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Recording disabled"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
uih_clearscreen	function
(	O
uih	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
ui_updatestatus	function
(	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Enter text, <cr><.><cr> to save"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
ui_input	function
(	O
1	int
,	O
1	int
,	O
ui_text	function
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
ui_save_menu	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
guessmodes	array
[	O
]	O
=	O
{	O
"Save image into PNG file"	pointer
,	O
"Save possition"	pointer
,	O
"Record animation"	pointer
,	O
"Load file"	pointer
,	O
"Play animation"	pointer
,	O
"Load random example"	pointer
,	O
"Use current settings as default"	pointer
,	O
}	O
;	O
static	O
char	O
*	O
guessmodes2	array
[	O
]	O
=	O
{	O
"Save image into PNG file"	pointer
,	O
"Finish animation recording"	pointer
,	O
"Clear screen"	pointer
,	O
"Display text"	pointer
,	O
}	O
;	O
static	O
char	O
*	O
guessmodes3	array
[	O
]	O
=	O
{	O
"Save image into PNG file"	pointer
,	O
"Save possition"	pointer
,	O
"Use current settings as default"	pointer
,	O
}	O
;	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
ui_menu	function
(	O
guessmodes3	array
,	O
"Please select format"	pointer
,	O
3	int
,	O
ui_save	function
)	O
;	O
else	O
if	O
(	O
!	O
uih	pointer
->	O
save	int
)	O
ui_menu	function
(	O
guessmodes	array
,	O
"Please select format"	pointer
,	O
7	int
,	O
ui_save	function
)	O
;	O
else	O
ui_menu	function
(	O
guessmodes2	array
,	O
"Please select format"	pointer
,	O
4	int
,	O
ui_save	function
)	O
;	O
}	O
void	O
ui_tbreak	function
(	O
void	O
)	O
{	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
}	O
static	O
void	O
ui_plane	function
(	O
int	O
mode	int
)	O
{	O
uih_setplane	function
(	O
uih	pointer
,	O
mode	int
)	O
;	O
}	O
static	O
void	O
ui_driver_menu	function
(	O
void	O
)	O
{	O
int	O
i	pointer
;	O
char	O
s	struct
[	O
80	int
]	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
PALETTE_REDISPLAYS	int
)	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
ndrivers	int
!=	O
1	int
)	O
{	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Please select driver:                        "	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
textheight1	O
,	O
"Warning..Xaos Can crash during this operation"	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
2	int
*	O
textheight1	O
,	O
"Palette will be set to default               "	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
3	int
*	O
textheight1	O
,	O
" 1 - abort action                            "	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ndrivers	int
;	O
i	pointer
++	O
)	O
{	O
sprintf	function
(	O
s	struct
,	O
" %i - %-40s"	pointer
,	O
i	pointer
+	O
2	int
,	O
drivers	array
[	O
i	pointer
]	O
->	O
name	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
i	pointer
+	O
4	int
)	O
*	O
textheight1	O
,	O
s	struct
)	O
;	O
}	O
numbertype	int
=	O
DRIVER	int
;	O
}	O
else	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Only one driver available-function disabled"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
static	O
void	O
ui_filter_menu	function
(	O
void	O
)	O
{	O
int	O
i	pointer
;	O
char	O
s	struct
[	O
80	int
]	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
PALETTE_REDISPLAYS	int
)	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
uih_nfilters	int
;	O
i	pointer
++	O
)	O
{	O
sprintf	function
(	O
s	struct
,	O
"%i %-23s - %s"	pointer
,	O
i	pointer
+	O
1	int
,	O
uih_filters	array
[	O
i	pointer
]	O
->	O
name	pointer
,	O
uih	pointer
->	O
filter	struct
[	O
i	pointer
]	O
!=	O
NULL	O
?	O
"enabled"	pointer
:	O
"disabled"	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
i	pointer
*	O
textheight1	O
,	O
s	struct
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
numbertype	int
=	O
FILTER	int
;	O
}	O
static	O
void	O
ui_plane_menu	function
(	O
void	O
)	O
{	O
ui_menu	function
(	O
planename	array
,	O
"Please select display plane:"	pointer
,	O
PLANES	int
,	O
ui_plane	function
)	O
;	O
}	O
static	O
void	O
ui_mandelbrot	function
(	O
int	O
mousex	int
,	O
int	O
mousey	int
)	O
{	O
uih_setmandelbrot	function
(	O
uih	pointer
,	O
fcontext	pointer
->	O
mandelbrot	int
^	O
1	int
,	O
mousex	int
,	O
mousey	int
)	O
;	O
}	O
static	O
void	O
ui_autopilot	function
(	O
void	O
)	O
{	O
autopilot	int
^=	O
1	int
;	O
if	O
(	O
autopilot	int
)	O
uih_autopilot_on	function
(	O
uih	pointer
)	O
;	O
else	O
uih_autopilot_off	function
(	O
uih	pointer
)	O
;	O
}	O
static	O
void	O
ui_help	function
(	O
int	O
number	int
)	O
{	O
int	O
nlines	int
=	O
height	int
/	O
textheight1	O
-	O
7	int
;	O
int	O
i	pointer
,	O
page	int
;	O
int	O
npages	int
=	O
(	O
UGLYTEXTSIZE	O
+	O
driver	pointer
->	O
helpsize	int
+	O
nlines	int
-	O
1	int
)	O
/	O
(	O
nlines	int
?	O
nlines	int
:	O
1	int
)	O
;	O
char	O
str	array
[	O
80	int
]	O
;	O
if	O
(	O
nlines	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
number	int
)	O
helppage	int
--	O
;	O
if	O
(	O
number	int
==	O
1	int
)	O
helppage	int
++	O
;	O
if	O
(	O
helppage	int
<	O
0	int
)	O
helppage	int
=	O
0	int
;	O
if	O
(	O
helppage	int
>=	O
npages	int
)	O
helppage	int
=	O
npages	int
-	O
1	int
;	O
page	int
=	O
helppage	int
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
PALETTE_REDISPLAYS	int
)	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
sprintf	function
(	O
str	array
,	O
"------> Ugly help <-----> %2i/%2i <------"	pointer
,	O
page	int
+	O
1	int
,	O
npages	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
textheight1	O
,	O
"                                       "	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nlines	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
page	int
*	O
nlines	int
+	O
i	pointer
<	O
(	O
int	O
)	O
UGLYTEXTSIZE	O
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
i	pointer
+	O
2	int
)	O
*	O
textheight1	O
,	O
helptext	array
[	O
page	int
*	O
nlines	int
+	O
i	pointer
]	O
)	O
;	O
else	O
{	O
if	O
(	O
page	int
*	O
nlines	int
+	O
i	pointer
<	O
(	O
int	O
)	O
UGLYTEXTSIZE	O
+	O
driver	pointer
->	O
helpsize	int
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
i	pointer
+	O
2	int
)	O
*	O
textheight1	O
,	O
driver	pointer
->	O
help	pointer
[	O
page	int
*	O
nlines	int
+	O
i	pointer
-	O
UGLYTEXTSIZE	O
]	O
)	O
;	O
else	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
i	pointer
+	O
2	int
)	O
*	O
textheight1	O
,	O
"~                                      "	pointer
)	O
;	O
}	O
}	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
nlines	int
+	O
2	int
)	O
*	O
textheight1	O
,	O
"                                       "	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
nlines	int
+	O
3	int
)	O
*	O
textheight1	O
,	O
"Hyperuglytext browser (tm) version 1.0 "	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
nlines	int
+	O
4	int
)	O
*	O
textheight1	O
,	O
"Press '1' for previous and '2' for next"	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
nlines	int
+	O
5	int
)	O
*	O
textheight1	O
,	O
"             space for exit            "	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
numbertype	int
=	O
HELP	int
;	O
}	O
void	O
ui_status	function
(	O
void	O
)	O
{	O
char	O
str	array
[	O
6000	int
]	O
;	O
sprintf	function
(	O
str	array
,	O
"Fractal name:%s"	pointer
,	O
fcontext	pointer
->	O
currentformula	pointer
->	O
name	pointer
[	O
!	O
fcontext	pointer
->	O
mandelbrot	int
]	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"Fractal type:%s"	pointer
,	O
fcontext	pointer
->	O
mandelbrot	int
?	O
"Mandelbrot"	pointer
:	O
"Julia"	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
2	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"View:[%1.12f,%1.12f]"	pointer
,	O
(	O
double	O
)	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
,	O
(	O
double	O
)	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
3	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"size:[%1.12f,%1.12f]"	pointer
,	O
(	O
double	O
)	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
,	O
(	O
double	O
)	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
4	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"Rotation:%4.2f   Screen size:%4i:%-4i"	pointer
,	O
(	O
double	O
)	O
fcontext	pointer
->	O
angle	double
,	O
width	int
,	O
height	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
5	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"Iterations:%4i"	pointer
,	O
fcontext	pointer
->	O
maxiter	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
6	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"Autopilot:%-4s    Plane:%s"	pointer
,	O
uih	pointer
->	O
autopilot	int
?	O
"On"	pointer
:	O
"Off"	pointer
,	O
planename	array
[	O
fcontext	pointer
->	O
plane	int
]	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
7	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"zoomspeed:%f   Palette size:%i"	pointer
,	O
(	O
float	O
)	O
uih	pointer
->	O
maxstep	double
*	O
1000	int
,	O
uih	pointer
->	O
image	struct
->	O
palette	struct
->	O
size	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
8	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
sprintf	function
(	O
str	array
,	O
"incoloring:%s outcoloring:%s"	pointer
,	O
incolorname	array
[	O
fcontext	pointer
->	O
incoloringmode	int
]	O
,	O
outcolorname	array
[	O
fcontext	pointer
->	O
coloringmode	int
]	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
9	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
if	O
(	O
fcontext	pointer
->	O
mandelbrot	int
)	O
strcpy	function
(	O
str	array
,	O
"Parameter:none"	pointer
)	O
;	O
else	O
sprintf	function
(	O
str	array
,	O
"Parameter:[%f,%f]"	pointer
,	O
(	O
float	O
)	O
fcontext	pointer
->	O
pre	double
,	O
(	O
float	O
)	O
fcontext	pointer
->	O
pim	double
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
10	int
*	O
textheight1	O
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
void	O
ui_message	function
(	O
void	O
)	O
{	O
char	O
s	struct
[	O
80	int
]	O
;	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
return	O
;	O
mousetype	pointer
(	O
WAITMOUSE	int
)	O
;	O
maxiter	int
=	O
fcontext	pointer
->	O
maxiter	int
;	O
sprintf	function
(	O
s	struct
,	O
"Please wait while calculating %s"	pointer
,	O
fcontext	pointer
->	O
currentformula	pointer
->	O
name	pointer
[	O
!	O
fcontext	pointer
->	O
mandelbrot	int
]	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
s	struct
)	O
;	O
ui_status	function
(	O
)	O
;	O
}	O
void	O
ui_message2	function
(	O
struct	O
uih_context	struct
*	O
u	pointer
)	O
{	O
ui_message	function
(	O
)	O
;	O
}	O
static	O
int	O
ui_mouse	function
(	O
int	O
mousex	int
,	O
int	O
mousey	int
,	O
int	O
mousebuttons	int
,	O
int	O
iterchange	int
)	O
{	O
int	O
inmovement	int
=	O
0	int
;	O
static	O
int	O
dirty	int
=	O
0	int
;	O
static	O
int	O
iterstep	int
=	O
1	int
;	O
static	O
int	O
lastiter	int
;	O
char	O
str	array
[	O
80	int
]	O
;	O
tl_update_time	function
(	O
)	O
;	O
CHECKPROCESSEVENTS	O
(	O
mousebuttons	int
,	O
iterchange	int
)	O
;	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
{	O
if	O
(	O
iterchange	int
==	O
2	int
&&	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
2	int
*	O
FRAMETIME	O
)	O
{	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
uih	pointer
->	O
letterspersec	int
++	O
;	O
sprintf	function
(	O
str	array
,	O
"Letters per second:%i "	pointer
,	O
uih	pointer
->	O
letterspersec	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
iterchange	int
==	O
1	int
&&	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
2	int
*	O
FRAMETIME	O
)	O
{	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
uih	pointer
->	O
letterspersec	int
--	O
;	O
sprintf	function
(	O
str	array
,	O
"Letters per second:%i "	pointer
,	O
uih	pointer
->	O
letterspersec	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
uih_update	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
,	O
mousebuttons	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
numbertype	int
==	O
HELP	int
)	O
{	O
if	O
(	O
(	O
iterchange	int
&	O
5	int
)	O
&&	O
!	O
lastiter	int
)	O
{	O
ui_help	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
iterchange	int
&	O
10	int
)	O
&&	O
!	O
lastiter	int
)	O
{	O
ui_help	function
(	O
1	int
)	O
;	O
}	O
lastiter	int
=	O
iterchange	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
uih	pointer
->	O
cycling	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
rotatemode	int
==	O
ROTATE_CONTINUOUS	int
)	O
{	O
if	O
(	O
iterchange	int
==	O
2	int
)	O
{	O
uih	pointer
->	O
rotationspeed	double
+=	O
ROTATESPEEDUP	int
*	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
/	O
1000000.0	int
;	O
sprintf	function
(	O
str	array
,	O
"Rotation speed:%2.2f degrees per second "	pointer
,	O
(	O
float	O
)	O
uih	pointer
->	O
rotationspeed	double
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
if	O
(	O
iterchange	int
==	O
1	int
)	O
{	O
uih	pointer
->	O
rotationspeed	double
-=	O
ROTATESPEEDUP	int
*	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
/	O
1000000.0	int
;	O
sprintf	function
(	O
str	array
,	O
"Rotation speed:%2.2f degrees per second "	pointer
,	O
(	O
float	O
)	O
uih	pointer
->	O
rotationspeed	double
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
iterchange	int
==	O
2	int
&&	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
FRAMETIME	O
)	O
{	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
maxiter	int
+=	O
iterstep	int
;	O
if	O
(	O
!	O
(	O
fcontext	pointer
->	O
maxiter	int
%	O
10	int
)	O
)	O
iterstep	int
=	O
10	int
;	O
dirty	int
=	O
1	int
;	O
sprintf	function
(	O
str	array
,	O
"Iterations:%i "	pointer
,	O
maxiter	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
iterchange	int
==	O
1	int
&&	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
FRAMETIME	O
)	O
{	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
maxiter	int
-=	O
iterstep	int
;	O
if	O
(	O
!	O
(	O
fcontext	pointer
->	O
maxiter	int
%	O
10	int
)	O
)	O
iterstep	int
=	O
10	int
;	O
dirty	int
=	O
1	int
;	O
if	O
(	O
maxiter	int
<	O
1	int
)	O
{	O
maxiter	int
=	O
1	int
;	O
}	O
sprintf	function
(	O
str	array
,	O
"Iterations:%i "	pointer
,	O
maxiter	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
iterchange	int
||	O
iterchange	int
==	O
3	int
)	O
iterstep	int
=	O
1	int
;	O
if	O
(	O
iterchange	int
&	O
3	int
)	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
dirty	int
)	O
uih_setmaxiter	function
(	O
uih	pointer
,	O
maxiter	int
)	O
,	O
dirty	int
=	O
0	int
;	O
if	O
(	O
numbertype	int
==	O
FORMULA	int
)	O
uih_update	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
,	O
mousebuttons	int
)	O
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
{	O
if	O
(	O
iterchange	int
&	O
1	int
&&	O
(	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
FRAMETIME	O
||	O
mousebuttons	int
)	O
)	O
{	O
uih	pointer
->	O
cyclingspeed	int
--	O
;	O
if	O
(	O
!	O
uih	pointer
->	O
cyclingspeed	int
)	O
uih	pointer
->	O
cyclingspeed	int
=	O
-	O
1	int
;	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
sprintf	function
(	O
str	array
,	O
"cyclingspeed:%i "	pointer
,	O
uih	pointer
->	O
cyclingspeed	int
)	O
;	O
uih_setcycling	function
(	O
uih	pointer
,	O
uih	pointer
->	O
cyclingspeed	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
if	O
(	O
iterchange	int
&	O
2	int
&&	O
(	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
FRAMETIME	O
||	O
mousebuttons	int
)	O
)	O
{	O
uih	pointer
->	O
cyclingspeed	int
++	O
;	O
if	O
(	O
!	O
uih	pointer
->	O
cyclingspeed	int
)	O
uih	pointer
->	O
cyclingspeed	int
=	O
1	int
;	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
sprintf	function
(	O
str	array
,	O
"cyclingspeed:%i "	pointer
,	O
uih	pointer
->	O
cyclingspeed	int
)	O
;	O
uih_setcycling	function
(	O
uih	pointer
,	O
uih	pointer
->	O
cyclingspeed	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
}	O
if	O
(	O
iterchange	int
&	O
4	int
&&	O
(	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
FRAMETIME	O
||	O
mousebuttons	int
)	O
)	O
{	O
double	O
mul1	double
=	O
(	O
double	O
)	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
/	O
FRAMETIME	O
;	O
double	O
su	double
=	O
1	int
+	O
(	O
SPEEDUP	int
-	O
1	int
)	O
*	O
mul1	double
;	O
if	O
(	O
su	double
>	O
2	int
*	O
SPEEDUP	int
)	O
su	double
=	O
SPEEDUP	int
;	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
uih	pointer
->	O
speedup	double
*=	O
su	double
,	O
uih	pointer
->	O
maxstep	double
*=	O
su	double
;	O
sprintf	function
(	O
str	array
,	O
"speed:%2.2f "	pointer
,	O
(	O
double	O
)	O
uih	pointer
->	O
speedup	double
*	O
(	O
1.0	int
/	O
STEP	O
)	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
if	O
(	O
iterchange	int
&	O
8	int
&&	O
(	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
>	O
FRAMETIME	O
||	O
mousebuttons	int
)	O
)	O
{	O
double	O
mul1	double
=	O
(	O
double	O
)	O
tl_lookup_timer	function
(	O
maintimer	pointer
)	O
/	O
FRAMETIME	O
;	O
double	O
su	double
=	O
1	int
+	O
(	O
SPEEDUP	int
-	O
1	int
)	O
*	O
mul1	double
;	O
if	O
(	O
su	double
>	O
2	int
*	O
SPEEDUP	int
)	O
su	double
=	O
SPEEDUP	int
;	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
uih	pointer
->	O
speedup	double
/=	O
su	double
,	O
uih	pointer
->	O
maxstep	double
/=	O
su	double
;	O
sprintf	function
(	O
str	array
,	O
"speed:%2.2f "	pointer
,	O
(	O
double	O
)	O
uih	pointer
->	O
speedup	double
*	O
(	O
1	int
/	O
STEP	O
)	O
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
if	O
(	O
iterchange	int
&	O
15	int
)	O
inmovement	int
=	O
1	int
;	O
lastiter	int
=	O
iterchange	int
;	O
return	O
(	O
inmovement	int
||	O
(	O
autopilot	int
&&	O
numbertype	int
==	O
FORMULA	int
)	O
||	O
inmovement	int
)	O
;	O
}	O
void	O
ui_call_resize	function
(	O
void	O
)	O
{	O
callresize	int
=	O
1	int
;	O
}	O
static	O
int	O
ui_alloccolor	function
(	O
struct	O
palette	struct
*	O
pal	pointer
,	O
int	O
init	int
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
int	O
i	pointer
;	O
i	pointer
=	O
driver	pointer
->	O
set_color	pointer
(	O
r	int
,	O
g	int
,	O
b	int
,	O
init	int
)	O
;	O
if	O
(	O
i	pointer
==	O
-	O
1	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
init	int
)	O
pal	pointer
->	O
size	int
=	O
0	int
;	O
pal	pointer
->	O
pixels	pointer
[	O
pal	pointer
->	O
size	int
]	O
=	O
i	pointer
;	O
pal	pointer
->	O
rgb	pointer
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
r	int
;	O
pal	pointer
->	O
rgb	pointer
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
g	int
;	O
pal	pointer
->	O
rgb	pointer
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
b	int
;	O
pal	pointer
->	O
size	int
++	O
;	O
return	O
(	O
i	pointer
)	O
;	O
}	O
static	O
void	O
ui_setpalette	function
(	O
struct	O
palette	struct
*	O
pal	pointer
,	O
int	O
start	int
,	O
int	O
end	int
,	O
rgb_t	array
*	O
rgb1	pointer
)	O
{	O
driver	pointer
->	O
set_range	pointer
(	O
(	O
ui_palette	pointer
)	O
rgb1	pointer
,	O
start	int
,	O
end	int
)	O
;	O
}	O
static	O
void	O
ui_flip	function
(	O
struct	O
image	struct
*	O
image	struct
)	O
{	O
flipgeneric	function
(	O
image	struct
)	O
;	O
driver	pointer
->	O
flip_buffers	pointer
(	O
)	O
;	O
}	O
void	O
ui_resize	function
(	O
void	O
)	O
{	O
int	O
w	int
,	O
h	function
,	O
scanline	int
;	O
char	O
*	O
b1	pointer
,	O
*	O
b2	pointer
;	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
{	O
resized	int
=	O
1	int
;	O
uih_interrupt	function
(	O
uih	pointer
)	O
;	O
return	O
;	O
}	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
uih_savepalette	function
(	O
uih	pointer
)	O
;	O
driver	pointer
->	O
getsize	pointer
(	O
&	O
w	int
,	O
&	O
h	function
)	O
;	O
assert	O
(	O
w	int
>	O
0	int
&&	O
w	int
<	O
65000	int
&&	O
h	function
>	O
0	int
&&	O
h	function
<	O
65000	int
)	O
;	O
if	O
(	O
w	int
!=	O
width	int
||	O
h	function
!=	O
height	int
||	O
(	O
driver	pointer
->	O
flags	int
&	O
UPDATE_AFTER_RESIZE	int
)	O
)	O
{	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
width	int
=	O
w	int
;	O
height	int
=	O
h	function
;	O
if	O
(	O
!	O
(	O
scanline	int
=	O
driver	pointer
->	O
alloc_buffers	pointer
(	O
&	O
b1	pointer
,	O
&	O
b2	pointer
)	O
)	O
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not allocate buffers\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
destroy_image	function
(	O
image	struct
)	O
;	O
destroypalette	function
(	O
palette	struct
)	O
;	O
palette	struct
=	O
createpalette	function
(	O
driver	pointer
->	O
palettestart	int
,	O
driver	pointer
->	O
paletteend	int
,	O
driver	pointer
->	O
imagetype	int
,	O
(	O
driver	pointer
->	O
flags	int
&	O
RANDOM_PALETTE_SIZE	int
)	O
?	O
UNKNOWNENTRIES	int
:	O
0	int
,	O
driver	pointer
->	O
maxentries	int
,	O
driver	pointer
->	O
set_color	pointer
!=	O
NULL	O
?	O
ui_alloccolor	function
:	O
NULL	O
,	O
driver	pointer
->	O
set_range	pointer
!=	O
NULL	O
?	O
ui_setpalette	function
:	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
palette	struct
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not create palette\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
image	struct
=	O
create_image_cont	function
(	O
width	int
,	O
height	int
,	O
scanline	int
,	O
2	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
b1	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
b2	pointer
,	O
palette	struct
,	O
ui_flip	function
,	O
0	int
,	O
get_windowwidth	function
(	O
width	int
)	O
/	O
width	int
,	O
get_windowheight	function
(	O
height	int
)	O
/	O
height	int
)	O
;	O
if	O
(	O
!	O
image	struct
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not create image\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
uih_updateimage	function
(	O
uih	pointer
,	O
image	struct
)	O
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not allocate tables\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
tl_process_group	function
(	O
syncgroup	pointer
,	O
NULL	O
)	O
;	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
uih_restorepalette	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
;	O
uih_cycling_continue	function
(	O
uih	pointer
)	O
;	O
}	O
static	O
void	O
ui_driver	struct
(	O
int	O
d	pointer
)	O
{	O
int	O
scanline	int
;	O
char	O
*	O
b1	pointer
,	O
*	O
b2	pointer
;	O
struct	O
ui_driver	struct
*	O
driver1	pointer
;	O
if	O
(	O
d	pointer
<	O
0	int
)	O
d	pointer
=	O
0	int
;	O
if	O
(	O
d	pointer
>=	O
ndrivers	int
)	O
d	pointer
=	O
ndrivers	int
-	O
1	int
;	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
driver1	pointer
=	O
driver	pointer
;	O
uih_cycling_off	function
(	O
uih	pointer
)	O
;	O
uih_savepalette	function
(	O
uih	pointer
)	O
;	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
driver	pointer
=	O
drivers	array
[	O
d	pointer
]	O
;	O
if	O
(	O
!	O
driver	pointer
->	O
init	int
(	O
)	O
)	O
{	O
driver	pointer
=	O
driver1	pointer
;	O
printf	function
(	O
"Can not initialize new driver\n"	pointer
)	O
;	O
if	O
(	O
!	O
driver1	pointer
->	O
init	int
(	O
)	O
)	O
{	O
printf	function
(	O
"Can not return back to previous driver\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
else	O
driver	pointer
=	O
driver1	pointer
;	O
}	O
driver	pointer
->	O
getsize	pointer
(	O
&	O
width	int
,	O
&	O
height	int
)	O
;	O
if	O
(	O
!	O
(	O
scanline	int
=	O
driver	pointer
->	O
alloc_buffers	pointer
(	O
&	O
b1	pointer
,	O
&	O
b2	pointer
)	O
)	O
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not allocate buffers\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
destroy_image	function
(	O
image	struct
)	O
;	O
destroypalette	function
(	O
palette	struct
)	O
;	O
palette	struct
=	O
createpalette	function
(	O
driver	pointer
->	O
palettestart	int
,	O
driver	pointer
->	O
paletteend	int
,	O
driver	pointer
->	O
imagetype	int
,	O
(	O
driver	pointer
->	O
flags	int
&	O
RANDOM_PALETTE_SIZE	int
)	O
?	O
UNKNOWNENTRIES	int
:	O
0	int
,	O
driver	pointer
->	O
maxentries	int
,	O
driver	pointer
->	O
set_color	pointer
!=	O
NULL	O
?	O
ui_alloccolor	function
:	O
NULL	O
,	O
driver	pointer
->	O
set_range	pointer
!=	O
NULL	O
?	O
ui_setpalette	function
:	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
image	struct
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not create palette\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
image	struct
=	O
create_image_cont	function
(	O
width	int
,	O
height	int
,	O
scanline	int
,	O
2	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
b1	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
b2	pointer
,	O
palette	struct
,	O
ui_flip	function
,	O
0	int
,	O
get_windowwidth	function
(	O
width	int
)	O
/	O
width	int
,	O
get_windowheight	function
(	O
height	int
)	O
/	O
height	int
)	O
;	O
if	O
(	O
!	O
image	struct
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not create image\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
uih_updateimage	function
(	O
uih	pointer
,	O
image	struct
)	O
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not allocate tables\n"	pointer
)	O
;	O
ui_outofmem	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
tl_process_group	function
(	O
syncgroup	pointer
,	O
NULL	O
)	O
;	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
uih_restorepalette	function
(	O
uih	pointer
)	O
;	O
uih_do_fractal	function
(	O
uih	pointer
)	O
;	O
ui_updatestatus	function
(	O
)	O
;	O
}	O
static	O
void	O
processbuffer	function
(	O
void	O
)	O
{	O
int	O
k	double
;	O
for	O
(	O
;	O
begin	int
!=	O
end	int
%	O
SIZE	int
;	O
)	O
{	O
if	O
(	O
resized	int
)	O
resized	int
=	O
0	int
,	O
ui_resize	function
(	O
)	O
;	O
k	double
=	O
keybuffer	array
[	O
begin	int
]	O
;	O
begin	int
=	O
(	O
begin	int
+	O
1	int
)	O
%	O
SIZE	int
;	O
ui_key	function
(	O
k	double
)	O
;	O
}	O
}	O
static	O
void	O
displaytext	int
(	O
void	O
)	O
{	O
int	O
i	pointer
;	O
char	O
str	array
[	O
XTEXTMAX	int
+	O
2	int
]	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nlines	int
+	O
2	int
;	O
i	pointer
++	O
)	O
{	O
memset	function
(	O
str	array
,	O
' '	O
,	O
XTEXTMAX	int
+	O
1	int
)	O
;	O
str	array
[	O
XTEXTMAX	int
]	O
=	O
0	int
;	O
if	O
(	O
line	int
==	O
i	pointer
)	O
sprintf	function
(	O
str	array
,	O
"%s_"	pointer
,	O
inputtext	array
[	O
i	pointer
]	O
)	O
;	O
else	O
sprintf	function
(	O
str	array
,	O
"%s"	pointer
,	O
inputtext	array
[	O
i	pointer
]	O
)	O
;	O
str	array
[	O
strlen	function
(	O
str	array
)	O
]	O
=	O
' '	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
(	O
i	pointer
+	O
textstart	int
)	O
*	O
textheight1	O
,	O
str	array
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
}	O
void	O
ui_quit	function
(	O
int	O
quit	int
)	O
{	O
if	O
(	O
!	O
quit	int
)	O
{	O
uih_cycling_off	function
(	O
uih	pointer
)	O
;	O
uih_freecontext	function
(	O
uih	pointer
)	O
;	O
tl_free_timer	function
(	O
maintimer	pointer
)	O
;	O
tl_free_timer	function
(	O
loopt	pointer
)	O
;	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
destroy_image	function
(	O
image	struct
)	O
;	O
destroypalette	function
(	O
palette	struct
)	O
;	O
uih_freecatalog	function
(	O
uih	pointer
)	O
;	O
xth_uninit	O
(	O
)	O
;	O
printf	function
(	O
"Thank you for using XaoS\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
ui_various	function
(	O
int	O
m	int
)	O
{	O
ui_updatestatus	function
(	O
)	O
;	O
switch	O
(	O
m	int
)	O
{	O
case	O
0	int
:	O
ui_periodicity	function
(	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
ui_guessing_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
ui_fastmode_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
ui_driver_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
driver	pointer
->	O
driveropt	pointer
(	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
ui_various_menu	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
menu	array
[	O
]	O
=	O
{	O
"Periodicity check"	pointer
,	O
"Guessing options"	pointer
,	O
"Dynamic resolution options"	pointer
,	O
"Change driver"	pointer
,	O
"Driver depended functions"	pointer
,	O
}	O
;	O
ui_menu	function
(	O
menu	array
,	O
"Please select format"	pointer
,	O
sizeof	O
(	O
menu	array
)	O
/	O
sizeof	O
(	O
char	O
*	O
)	O
-	O
(	O
driver	pointer
->	O
driveropt	pointer
==	O
NULL	O
)	O
,	O
ui_various	function
)	O
;	O
}	O
int	O
ui_key	function
(	O
int	O
key	int
)	O
{	O
int	O
sym	int
;	O
int	O
lasttype	int
=	O
numbertype	int
;	O
if	O
(	O
numbertype	int
==	O
INPUT	int
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
13	int
:	O
case	O
'\n'	O
:	O
if	O
(	O
mlines	int
)	O
{	O
if	O
(	O
inputtext	array
[	O
line	int
]	O
[	O
0	int
]	O
==	O
'.'	O
&&	O
inputtext	array
[	O
line	int
]	O
[	O
1	int
]	O
==	O
0	int
)	O
{	O
numbertype	int
=	O
FORMULA	int
;	O
inputhandler	pointer
(	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
line	int
++	O
;	O
if	O
(	O
line	int
>=	O
YTEXTMAX	int
)	O
line	int
=	O
YTEXTMAX	int
-	O
1	int
;	O
else	O
if	O
(	O
line	int
>	O
nlines	int
)	O
nlines	int
++	O
;	O
inputtext	array
[	O
line	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
{	O
numbertype	int
=	O
FORMULA	int
;	O
inputhandler	pointer
(	O
)	O
;	O
return	O
0	int
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
int	O
len	int
=	O
strlen	function
(	O
inputtext	array
[	O
line	int
]	O
)	O
;	O
if	O
(	O
len	int
)	O
inputtext	array
[	O
line	int
]	O
[	O
len	int
-	O
1	int
]	O
=	O
0	int
;	O
else	O
if	O
(	O
nlines	int
&&	O
line	int
)	O
{	O
inputtext	array
[	O
line	int
]	O
[	O
0	int
]	O
=	O
0	int
,	O
line	int
--	O
;	O
nlines	int
--	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
{	O
int	O
len	int
=	O
strlen	function
(	O
inputtext	array
[	O
line	int
]	O
)	O
;	O
if	O
(	O
isprint	function
(	O
key	int
)	O
&&	O
len	int
<	O
XTEXTMAX	int
-	O
2	int
)	O
inputtext	array
[	O
line	int
]	O
[	O
len	int
]	O
=	O
key	int
,	O
inputtext	array
[	O
line	int
]	O
[	O
len	int
+	O
1	int
]	O
=	O
0	int
;	O
}	O
break	O
;	O
}	O
displaytext	int
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
{	O
int	O
number	int
;	O
switch	O
(	O
sym	int
=	O
tolower	function
(	O
key	int
)	O
)	O
{	O
case	O
'q'	O
:	O
uih_replaydisable	function
(	O
uih	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
{	O
add_buffer	O
(	O
key	int
)	O
;	O
}	O
else	O
ui_save_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
ui_updatestatus	function
(	O
)	O
;	O
else	O
{	O
uih_skipframe	function
(	O
uih	pointer
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Skipping, please wait..."	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'z'	O
:	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
uih_interrupt	function
(	O
uih	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
ministatus	int
^=	O
1	int
;	O
ui_display	function
(	O
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
{	O
add_buffer	O
(	O
key	int
)	O
;	O
}	O
else	O
callresize	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
sym	int
>=	O
'0'	O
&&	O
sym	int
<=	O
'9'	O
)	O
{	O
number	int
=	O
sym	int
-	O
'1'	O
;	O
if	O
(	O
number	int
<	O
0	int
)	O
number	int
=	O
9	int
;	O
if	O
(	O
numbertype	int
==	O
MENU	int
)	O
{	O
ui_menupress	function
(	O
number	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
{	O
int	O
i	pointer
;	O
if	O
(	O
tolower	function
(	O
key	int
)	O
==	O
' '	O
)	O
ui_updatestatus	function
(	O
)	O
;	O
else	O
if	O
(	O
tolower	function
(	O
key	int
)	O
==	O
'z'	O
)	O
uih_interrupt	function
(	O
uih	pointer
)	O
;	O
else	O
{	O
add_buffer	O
(	O
key	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
(	O
int	O
)	O
strlen	function
(	O
interruptkeys	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
tolower	function
(	O
key	int
)	O
==	O
interruptkeys	pointer
[	O
i	pointer
]	O
)	O
uih_interrupt	function
(	O
uih	pointer
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
if	O
(	O
numbertype	int
==	O
MENU	int
&&	O
tolower	function
(	O
key	int
)	O
>=	O
'a'	O
&&	O
tolower	function
(	O
key	int
)	O
-	O
'a'	O
<	O
menumax	int
-	O
10	int
)	O
{	O
ui_menupress	function
(	O
tolower	function
(	O
key	int
)	O
-	O
'a'	O
+	O
10	int
)	O
;	O
}	O
else	O
switch	O
(	O
sym	int
=	O
tolower	function
(	O
key	int
)	O
)	O
{	O
case	O
'o'	O
:	O
if	O
(	O
uih	pointer
->	O
fastrotate	int
&&	O
uih	pointer
->	O
rotatemode	int
==	O
ROTATE_MOUSE	int
)	O
uih_fastrotate	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
!	O
uih	pointer
->	O
fastrotate	int
)	O
uih_fastrotate	function
(	O
uih	pointer
,	O
!	O
uih	pointer
->	O
fastrotate	int
)	O
,	O
uih_rotatemode	function
(	O
uih	pointer
,	O
ROTATE_CONTINUOUS	int
)	O
;	O
else	O
uih_rotatemode	function
(	O
uih	pointer
,	O
ROTATE_MOUSE	int
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
uih	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
uih_cycling_on	function
(	O
uih	pointer
)	O
)	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Inicialization of color cycling failed. Try to enable palette emulation filter"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'j'	O
:	O
if	O
(	O
uih	pointer
->	O
juliamode	int
)	O
uih_disablejulia	function
(	O
uih	pointer
)	O
;	O
else	O
{	O
uih_enablejulia	function
(	O
uih	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'v'	O
:	O
ui_various_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
callresize	int
=	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
{	O
int	O
mousex	int
,	O
mousey	int
,	O
b	int
;	O
driver	pointer
->	O
getmouse	pointer
(	O
&	O
mousex	int
,	O
&	O
mousey	int
,	O
&	O
b	int
)	O
;	O
ui_mandelbrot	function
(	O
mousex	int
,	O
mousey	int
)	O
;	O
}	O
break	O
;	O
case	O
'b'	O
:	O
{	O
int	O
mousex	int
,	O
mousey	int
,	O
b	int
;	O
driver	pointer
->	O
getmouse	pointer
(	O
&	O
mousex	int
,	O
&	O
mousey	int
,	O
&	O
b	int
)	O
;	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
bre	double
||	O
uih	pointer
->	O
fcontext	pointer
->	O
bim	double
)	O
uih_setperbutation	function
(	O
uih	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
else	O
uih_perbutation	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
)	O
;	O
}	O
break	O
;	O
case	O
'i'	O
:	O
ui_plane_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
ui_incoloringmode_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
ui_outcoloringmode_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
if	O
(	O
numbertype	int
==	O
HELP	int
)	O
ui_tutorial_menu	function
(	O
)	O
;	O
else	O
ui_help	function
(	O
5	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
ui_save_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
case	O
'/'	O
:	O
ui_status	function
(	O
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
uih_mkpalette	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
UPDATE_AFTER_PALETTE	int
)	O
{	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
uih_mkdefaultpalette	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
driver	pointer
->	O
flags	int
&	O
UPDATE_AFTER_PALETTE	int
)	O
{	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
'l'	O
:	O
ministatus	int
^=	O
1	int
;	O
ui_display	function
(	O
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
ui_filter_menu	function
(	O
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
ui_autopilot	function
(	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
if	O
(	O
numbertype	int
==	O
MENU	int
&&	O
menucallback	pointer
==	O
ui_quit	function
)	O
ui_quit	function
(	O
0	int
)	O
;	O
if	O
(	O
numbertype	int
==	O
FORMULA	int
)	O
{	O
static	O
char	O
*	O
quittext	array
[	O
]	O
=	O
{	O
"Yes I want quit"	pointer
,	O
"Not yet"	pointer
}	O
;	O
ui_menu	function
(	O
quittext	array
,	O
"Quit ceremony:"	pointer
,	O
2	int
,	O
ui_quit	function
)	O
;	O
break	O
;	O
}	O
case	O
' '	O
:	O
uih_display	function
(	O
uih	pointer
)	O
;	O
ui_updatestatus	function
(	O
)	O
;	O
ui_flush	O
(	O
)	O
;	O
break	O
;	O
default	O
:	O
{	O
int	O
number	int
;	O
if	O
(	O
sym	int
>=	O
'0'	O
&&	O
sym	int
<=	O
'9'	O
)	O
{	O
number	int
=	O
sym	int
-	O
'1'	O
;	O
if	O
(	O
number	int
<	O
0	int
)	O
number	int
=	O
9	int
;	O
switch	O
(	O
numbertype	int
)	O
{	O
case	O
FORMULA	int
:	O
set_formula	function
(	O
fcontext	pointer
,	O
number	int
)	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
break	O
;	O
case	O
HELP	int
:	O
ui_help	function
(	O
number	int
)	O
;	O
break	O
;	O
case	O
MENU	int
:	O
ui_menupress	function
(	O
number	int
)	O
;	O
break	O
;	O
case	O
DRIVER	int
:	O
if	O
(	O
number	int
)	O
todriver	int
=	O
number	int
;	O
else	O
ui_display	function
(	O
)	O
;	O
return	O
2	int
;	O
break	O
;	O
case	O
FILTER	int
:	O
if	O
(	O
number	int
<	O
uih_nfilters	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
filter	struct
[	O
number	int
]	O
!=	O
NULL	O
)	O
uih_disablefilter	function
(	O
uih	pointer
,	O
number	int
)	O
;	O
else	O
uih_enablefilter	function
(	O
uih	pointer
,	O
number	int
)	O
;	O
}	O
numbertype	int
=	O
FORMULA	int
;	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
numbertype	int
!=	O
FORMULA	int
&&	O
lasttype	int
==	O
FORMULA	int
)	O
uih_stopzooming	function
(	O
uih	pointer
)	O
;	O
processbuffer	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
displayui	function
(	O
void	O
)	O
{	O
int	O
i	pointer
,	O
l	int
=	O
strlen	function
(	O
uih	pointer
->	O
text	pointer
)	O
;	O
int	O
nlines	int
=	O
0	int
;	O
int	O
pos	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
l	int
;	O
i	pointer
++	O
)	O
if	O
(	O
uih	pointer
->	O
text	pointer
[	O
i	pointer
]	O
==	O
'\n'	O
)	O
uih	pointer
->	O
text	pointer
[	O
i	pointer
]	O
=	O
0	int
,	O
nlines	int
++	O
;	O
nlines	int
++	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nlines	int
;	O
i	pointer
++	O
)	O
{	O
int	O
x	pointer
=	O
0	int
,	O
y	pointer
=	O
0	int
,	O
l	int
;	O
l	int
=	O
strlen	function
(	O
uih	pointer
->	O
text	pointer
+	O
pos	int
)	O
;	O
switch	O
(	O
uih	pointer
->	O
xtextpos	int
)	O
{	O
case	O
0	int
:	O
x	pointer
=	O
0	int
;	O
break	O
;	O
case	O
1	int
:	O
x	pointer
=	O
(	O
uih	pointer
->	O
image	struct
->	O
width	int
-	O
textwidth1	O
*	O
l	int
)	O
/	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
x	pointer
=	O
uih	pointer
->	O
image	struct
->	O
width	int
-	O
textwidth1	O
*	O
l	int
;	O
break	O
;	O
}	O
switch	O
(	O
uih	pointer
->	O
ytextpos	int
)	O
{	O
case	O
0	int
:	O
y	pointer
=	O
i	pointer
*	O
textheight1	O
;	O
break	O
;	O
case	O
1	int
:	O
y	pointer
=	O
(	O
uih	pointer
->	O
image	struct
->	O
height	int
-	O
textheight1	O
*	O
nlines	int
)	O
/	O
2	int
+	O
i	pointer
*	O
textheight1	O
;	O
break	O
;	O
case	O
2	int
:	O
y	pointer
=	O
uih	pointer
->	O
image	struct
->	O
height	int
-	O
textheight1	O
*	O
(	O
nlines	int
-	O
i	pointer
)	O
;	O
break	O
;	O
}	O
driver	pointer
->	O
print	pointer
(	O
x	pointer
,	O
y	pointer
,	O
uih	pointer
->	O
text	pointer
+	O
pos	int
)	O
;	O
pos	int
+=	O
l	int
+	O
1	int
;	O
}	O
ui_flush	O
(	O
)	O
;	O
}	O
static	O
void	O
main_loop	function
(	O
void	O
)	O
{	O
int	O
inmovement	int
=	O
1	int
;	O
int	O
x	pointer
,	O
y	pointer
,	O
b	int
,	O
k	double
;	O
int	O
time	int
;	O
loopt	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
mousetype	pointer
(	O
uih	pointer
->	O
play	int
?	O
REPLAYMOUSE	int
:	O
NORMALMOUSE	int
)	O
;	O
if	O
(	O
numbertype	int
==	O
FORMULA	int
)	O
{	O
if	O
(	O
uih_needrecalculate	O
(	O
uih	pointer
)	O
)	O
uih_do_fractal	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
display	int
)	O
ui_updatestatus	function
(	O
)	O
;	O
if	O
(	O
uih	pointer
->	O
errstring	pointer
!=	O
NULL	O
)	O
{	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
uih	pointer
->	O
errstring	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
uih	pointer
->	O
errstring	pointer
=	O
NULL	O
,	O
sleep	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
uih	pointer
->	O
clearscreen	int
)	O
driver	pointer
->	O
clrscr	pointer
(	O
)	O
,	O
uih_cleared	O
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
displaytext	int
)	O
displayui	function
(	O
)	O
,	O
uih_textdisplayed	O
(	O
uih	pointer
)	O
;	O
}	O
else	O
{	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
}	O
if	O
(	O
introtext	int
)	O
{	O
introtext	int
=	O
0	int
;	O
driver	pointer
->	O
print	pointer
(	O
width	int
/	O
2	int
-	O
textwidth1	O
*	O
29	int
/	O
2	int
,	O
height	int
-	O
textheight1	O
,	O
"Press 'H' twice for tutorials"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
if	O
(	O
(	O
time	int
=	O
tl_process_group	function
(	O
syncgroup	pointer
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
inmovement	int
&&	O
!	O
uih	pointer
->	O
inanimation	int
)	O
{	O
if	O
(	O
time	int
>	O
1000000	int
/	O
50	int
)	O
time	int
=	O
1000000	int
/	O
50	int
;	O
if	O
(	O
time	int
>	O
delaytime	int
)	O
{	O
tl_sleep	function
(	O
time	int
-	O
delaytime	int
)	O
;	O
}	O
}	O
inmovement	int
=	O
1	int
;	O
}	O
if	O
(	O
delaytime	int
||	O
maxframerate	int
)	O
{	O
tl_update_time	function
(	O
)	O
;	O
time	int
=	O
tl_lookup_timer	function
(	O
loopt	pointer
)	O
;	O
tl_reset_timer	function
(	O
loopt	pointer
)	O
;	O
time	int
=	O
1000000	int
/	O
maxframerate	int
-	O
time	int
;	O
if	O
(	O
time	int
<	O
delaytime	int
)	O
time	int
=	O
delaytime	int
;	O
if	O
(	O
time	int
)	O
tl_sleep	function
(	O
time	int
)	O
;	O
}	O
processbuffer	function
(	O
)	O
;	O
driver	pointer
->	O
processevents	pointer
(	O
(	O
!	O
inmovement	int
&&	O
!	O
uih	pointer
->	O
inanimation	int
)	O
,	O
&	O
x	pointer
,	O
&	O
y	pointer
,	O
&	O
b	int
,	O
&	O
k	double
)	O
;	O
inmovement	int
=	O
ui_mouse	function
(	O
x	pointer
,	O
y	pointer
,	O
b	int
,	O
k	double
)	O
;	O
if	O
(	O
todriver	int
)	O
ui_driver	struct
(	O
todriver	int
-	O
1	int
)	O
,	O
todriver	int
=	O
0	int
;	O
if	O
(	O
callresize	int
)	O
ui_resize	function
(	O
)	O
,	O
callresize	int
=	O
0	int
;	O
}	O
}	O
int	O
MAIN_FUNCTION	O
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
scanline	int
;	O
int	O
i	pointer
,	O
formula	struct
=	O
-	O
1	int
;	O
char	O
*	O
buffer1	pointer
,	O
*	O
buffer2	pointer
;	O
prog_argc	int
=	O
argc	int
;	O
prog_argv	pointer
=	O
argv	pointer
;	O
params_parser	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
signal	function
(	O
SIGFPE	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
printconfig	int
)	O
{	O
printf	function
(	O
"XaoS configuration\n"	pointer
"Version:   %s\n"	pointer
"Type size: %i\n"	pointer
"Maxiter:   %i\n"	pointer
"MaxStep:   %f\n"	pointer
"integer size: %i\n"	pointer
"configfile: %s\n"	pointer
"using alloca\n"	pointer
"using ncurses\n"	pointer
"using gettimeofday\n"	pointer
"using ftime\n"	pointer
"assertions disabled\n"	pointer
,	O
XaoS_VERSION	pointer
,	O
(	O
int	O
)	O
sizeof	O
(	O
FPOINT_TYPE	double
)	O
,	O
(	O
int	O
)	O
DEFAULT_MAX_ITER	int
,	O
MAXSTEP	O
,	O
(	O
int	O
)	O
sizeof	O
(	O
int	O
)	O
,	O
CONFIGFILE	pointer
)	O
;	O
}	O
if	O
(	O
deflist	int
||	O
printconfig	int
)	O
{	O
printf	function
(	O
"Available drivers:\n"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ndrivers	int
;	O
i	pointer
++	O
)	O
{	O
printf	function
(	O
"   %s\n"	pointer
,	O
drivers	array
[	O
i	pointer
]	O
->	O
name	pointer
)	O
;	O
}	O
exit	function
(	O
0	int
)	O
;	O
}	O
xth_init	O
(	O
defthreads	int
)	O
;	O
if	O
(	O
defdriver	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ndrivers	int
;	O
i	pointer
++	O
)	O
{	O
int	O
y	pointer
;	O
for	O
(	O
y	pointer
=	O
0	int
;	O
tolower	function
(	O
drivers	array
[	O
i	pointer
]	O
->	O
name	pointer
[	O
y	pointer
]	O
)	O
==	O
tolower	function
(	O
defdriver	pointer
[	O
y	pointer
]	O
)	O
&&	O
drivers	array
[	O
i	pointer
]	O
->	O
name	pointer
[	O
y	pointer
]	O
!=	O
0	int
;	O
y	pointer
++	O
)	O
;	O
if	O
(	O
drivers	array
[	O
i	pointer
]	O
->	O
name	pointer
[	O
y	pointer
]	O
==	O
0	int
)	O
{	O
driver	pointer
=	O
drivers	array
[	O
i	pointer
]	O
;	O
if	O
(	O
driver	pointer
->	O
init	int
(	O
)	O
)	O
break	O
;	O
else	O
{	O
printf	function
(	O
"Can not initialize %s driver\n"	pointer
,	O
defdriver	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
i	pointer
==	O
ndrivers	int
)	O
{	O
printf	function
(	O
"Unknown driver %s\n"	pointer
,	O
defdriver	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ndrivers	int
;	O
i	pointer
++	O
)	O
{	O
driver	pointer
=	O
drivers	array
[	O
i	pointer
]	O
;	O
if	O
(	O
driver	pointer
->	O
init	int
(	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
==	O
ndrivers	int
)	O
{	O
printf	function
(	O
"Can not initialize driver\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
}	O
driver	pointer
->	O
getsize	pointer
(	O
&	O
width	int
,	O
&	O
height	int
)	O
;	O
if	O
(	O
!	O
(	O
scanline	int
=	O
driver	pointer
->	O
alloc_buffers	pointer
(	O
&	O
buffer1	pointer
,	O
&	O
buffer2	pointer
)	O
)	O
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
printf	function
(	O
"Can not alocate buffers\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
mousetype	pointer
(	O
WAITMOUSE	int
)	O
;	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Initializing. Please wait"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nformulas	int
;	O
i	pointer
++	O
)	O
if	O
(	O
defformula	array
[	O
i	pointer
]	O
)	O
formula	struct
=	O
i	pointer
;	O
palette	struct
=	O
createpalette	function
(	O
driver	pointer
->	O
palettestart	int
,	O
driver	pointer
->	O
paletteend	int
,	O
driver	pointer
->	O
imagetype	int
,	O
(	O
driver	pointer
->	O
flags	int
&	O
RANDOM_PALETTE_SIZE	int
)	O
?	O
UNKNOWNENTRIES	int
:	O
0	int
,	O
driver	pointer
->	O
maxentries	int
,	O
driver	pointer
->	O
set_color	pointer
!=	O
NULL	O
?	O
ui_alloccolor	function
:	O
NULL	O
,	O
driver	pointer
->	O
set_range	pointer
!=	O
NULL	O
?	O
ui_setpalette	function
:	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
image	struct
=	O
create_image_cont	function
(	O
width	int
,	O
height	int
,	O
scanline	int
,	O
2	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
buffer1	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
buffer2	pointer
,	O
palette	struct
,	O
ui_flip	function
,	O
0	int
,	O
get_windowwidth	function
(	O
width	int
)	O
/	O
width	int
,	O
get_windowheight	function
(	O
height	int
)	O
/	O
height	int
)	O
;	O
uih	pointer
=	O
uih_mkcontext	function
(	O
driver	pointer
->	O
flags	int
,	O
image	struct
,	O
ui_passfunc	function
,	O
ui_message2	function
)	O
;	O
uih_loadcatalog	function
(	O
uih	pointer
,	O
"english"	pointer
)	O
;	O
if	O
(	O
deflanguage	pointer
!=	O
NULL	O
)	O
uih_loadcatalog	function
(	O
uih	pointer
,	O
deflanguage	pointer
)	O
;	O
if	O
(	O
getenv	function
(	O
"HOME"	pointer
)	O
!=	O
NULL	O
)	O
{	O
char	O
home	array
[	O
256	int
]	O
,	O
*	O
env	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
int	O
maxsize	double
=	O
255	int
-	O
strlen	function
(	O
CONFIGFILE	pointer
)	O
-	O
1	int
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
maxsize	double
&&	O
env	pointer
[	O
i	pointer
]	O
;	O
i	pointer
++	O
)	O
home	array
[	O
i	pointer
]	O
=	O
env	pointer
[	O
i	pointer
]	O
;	O
env	pointer
[	O
i	pointer
]	O
=	O
0	int
;	O
xio_addfname	O
(	O
configfile	array
,	O
home	array
,	O
CONFIGFILE	pointer
)	O
;	O
}	O
else	O
xio_addfname	O
(	O
configfile	array
,	O
XIO_EMPTYPATH	pointer
,	O
CONFIGFILE	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
{	O
xio_file	pointer
f	pointer
=	O
xio_ropen	O
(	O
configfile	array
)	O
;	O
if	O
(	O
f	pointer
!=	O
XIO_FAILED	O
)	O
{	O
uih_load	function
(	O
uih	pointer
,	O
f	pointer
,	O
configfile	array
)	O
;	O
if	O
(	O
uih	pointer
->	O
errstring	pointer
)	O
{	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Configuration file %s load failed:%s\n"	pointer
,	O
configfile	array
,	O
uih	pointer
->	O
errstring	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Hint:try to remove it :)\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
fcontext	pointer
=	O
uih	pointer
->	O
fcontext	pointer
;	O
if	O
(	O
formula	struct
!=	O
-	O
1	int
)	O
set_formula	function
(	O
fcontext	pointer
,	O
formula	struct
)	O
;	O
srand	function
(	O
time	int
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
defiters	int
>	O
0	int
)	O
fcontext	pointer
->	O
maxiter	int
=	O
defiters	int
;	O
if	O
(	O
defperiodicity	int
>=	O
0	int
)	O
fcontext	pointer
->	O
periodicity	int
=	O
defperiodicity	int
^	O
1	int
;	O
if	O
(	O
fastmode	int
>=	O
0	int
)	O
uih	pointer
->	O
fastmode	int
=	O
fastmode	int
;	O
if	O
(	O
defguessing	int
>=	O
0	int
)	O
fcontext	pointer
->	O
range	int
=	O
defguessing	int
;	O
if	O
(	O
defincoloring	int
>=	O
0	int
)	O
fcontext	pointer
->	O
incoloringmode	int
=	O
defincoloring	int
;	O
if	O
(	O
defoutcoloring	int
>=	O
0	int
)	O
fcontext	pointer
->	O
coloringmode	int
=	O
abs	function
(	O
defoutcoloring	int
-	O
1	int
)	O
%	O
OUTCOLORING	int
;	O
if	O
(	O
defplane	int
>=	O
0	int
)	O
fcontext	pointer
->	O
plane	int
=	O
abs	function
(	O
defplane	int
-	O
1	int
)	O
%	O
PLANES	int
;	O
uih_letterspersec	function
(	O
uih	pointer
,	O
letterspersec	int
)	O
;	O
fcontext	pointer
->	O
version	int
++	O
;	O
maintimer	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
if	O
(	O
defautopilot	int
)	O
ui_autopilot	function
(	O
)	O
;	O
if	O
(	O
defspeed	float
>=	O
0	int
)	O
{	O
if	O
(	O
defspeed	float
>=	O
100	int
)	O
defspeed	float
=	O
1.0	int
;	O
uih	pointer
->	O
speedup	double
=	O
uih	pointer
->	O
speedup	double
*	O
defspeed	float
;	O
uih	pointer
->	O
maxstep	double
=	O
uih	pointer
->	O
maxstep	double
*	O
defspeed	float
;	O
}	O
tl_update_time	function
(	O
)	O
;	O
tl_process_group	function
(	O
syncgroup	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
printspeed	int
)	O
{	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
speed_test	function
(	O
uih	pointer
->	O
fcontext	pointer
,	O
image	struct
)	O
;	O
return	O
0	int
;	O
}	O
tl_reset_timer	function
(	O
maintimer	pointer
)	O
;	O
if	O
(	O
loadfile	pointer
!=	O
NULL	O
)	O
{	O
xio_file	pointer
f	pointer
=	O
xio_ropen	O
(	O
loadfile	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
XIO_FAILED	O
)	O
{	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
perror	function
(	O
loadfile	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
uih_load	function
(	O
uih	pointer
,	O
f	pointer
,	O
loadfile	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
errstring	pointer
)	O
{	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Load failed:%s\n"	pointer
,	O
uih	pointer
->	O
errstring	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
playfile	pointer
!=	O
NULL	O
)	O
{	O
xio_file	pointer
f	pointer
=	O
xio_ropen	O
(	O
playfile	pointer
)	O
;	O
introtext	int
=	O
0	int
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
perror	function
(	O
playfile	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
uih_replayenable	function
(	O
uih	pointer
,	O
f	pointer
,	O
playfile	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
errstring	pointer
)	O
{	O
driver	pointer
->	O
free_buffers	pointer
(	O
NULL	O
,	O
NULL	O
)	O
;	O
driver	pointer
->	O
uninit	pointer
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Play failed:%s\n"	pointer
,	O
uih	pointer
->	O
errstring	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
driver	pointer
->	O
print	pointer
(	O
0	int
,	O
0	int
,	O
"Preparing first frame. Please wait"	pointer
)	O
;	O
ui_flush	O
(	O
)	O
;	O
}	O
main_loop	function
(	O
)	O
;	O
ui_quit	function
(	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
fractal_context	struct
*	O
ui_getcontext	function
(	O
void	O
)	O
{	O
return	O
(	O
fcontext	pointer
)	O
;	O
}	O
