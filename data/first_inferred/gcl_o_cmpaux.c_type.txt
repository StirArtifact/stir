DEFUNO_NEW	function
(	O
"SPECIALP"	pointer
,	O
object	O
,	O
fSspecialp	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
siLspecialp	O
,	O
(	O
object	O
sym	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
sym	O
)	O
==	O
t_symbol	O
&&	O
(	O
enum	O
stype	O
)	O
sym	O
->	O
s	pointer
.	O
s_stype	O
==	O
stp_special	O
)	O
sym	O
=	O
Ct	O
;	O
else	O
sym	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
sym	O
)	O
;	O
}	O
DEF_ORDINARY	function
(	O
"DEBUG"	pointer
,	O
sSdebug	O
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEFUN_NEW	function
(	O
"DEFVAR1"	pointer
,	O
object	O
,	O
fSdefvar1	O
,	O
SI	O
,	O
2	int
,	O
3	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
sym	O
,	O
object	O
val	O
,	O
...	O
)	O
,	O
""	pointer
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	O
doc	O
;	O
va_list	O
ap	O
;	O
{	O
va_start	O
(	O
ap	O
,	O
val	O
)	O
;	O
if	O
(	O
n	int
>=	O
3	int
)	O
doc	O
=	O
va_arg	function
(	O
ap	O
,	O
object	O
)	O
;	O
else	O
goto	O
LDEFAULT3	O
;	O
goto	O
LEND_VARARG	O
;	O
LDEFAULT3	O
:	O
doc	O
=	O
Cnil	O
;	O
LEND_VARARG	O
:	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
CHECK_ARG_RANGE	function
(	O
2	int
,	O
3	int
)	O
;	O
if	O
(	O
sym	O
->	O
s	pointer
.	O
s_dbind	O
==	O
0	int
&&	O
n	int
>	O
1	int
)	O
sym	O
->	O
s	pointer
.	O
s_dbind	O
=	O
val	O
;	O
sym	O
->	O
s	pointer
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_special	O
;	O
if	O
(	O
n	int
>	O
2	int
)	O
putprop	function
(	O
sym	O
,	O
doc	O
,	O
sSvariable_documentation	O
)	O
;	O
RETURN1	function
(	O
sym	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"DEBUG"	pointer
,	O
object	O
,	O
fSdebug	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
sym	O
,	O
object	O
val	O
)	O
,	O
""	pointer
)	O
{	O
putprop	function
(	O
sym	O
,	O
val	O
,	O
sSdebug	O
)	O
;	O
RETURN1	function
(	O
sym	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"SETVV"	pointer
,	O
object	O
,	O
fSsetvv	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
index	function
,	O
object	O
val	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
sSPmemory	O
->	O
s	pointer
.	O
s_dbind	O
)	O
==	O
t_cfdata	O
)	O
sSPmemory	O
->	O
s	pointer
.	O
s_dbind	O
->	O
cfd	O
.	O
cfd_self	O
[	O
fix	function
(	O
index	function
)	O
]	O
=	O
val	O
;	O
else	O
FEerror	function
(	O
"setvv called outside %init"	pointer
,	O
0	int
)	O
;	O
RETURN1	function
(	O
index	function
)	O
;	O
}	O
DEF_ORDINARY	function
(	O
"%MEMORY"	pointer
,	O
sSPmemory	O
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"%INIT"	pointer
,	O
sSPinit	O
,	O
SI	O
,	O
""	pointer
)	O
;	O
void	O
gcl_init_cmpaux	function
(	O
void	O
)	O
{	O
}	O
char	O
object_to_char	function
(	O
object	O
x	int
)	O
{	O
int	O
c	int
=	O
0	int
;	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
c	int
=	O
fix	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
{	O
object	O
*	O
to	O
=	O
vs_top	O
;	O
vs_push	function
(	O
x	int
)	O
;	O
vs_push	function
(	O
small_fixnum	function
(	O
0xff	int
)	O
)	O
;	O
Llogand	function
(	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
to	O
;	O
c	int
=	O
(	O
char	O
)	O
fix	function
(	O
x	int
)	O
;	O
break	O
;	O
}	O
case	O
t_character	O
:	O
c	int
=	O
char_code	function
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"~S cannot be coerce to a C char."	pointer
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
c	int
)	O
;	O
}	O
int	O
object_to_int	function
(	O
object	O
x	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
i	int
=	O
char_code	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
i	int
=	O
fix	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
i	int
=	O
number_to_double	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_ratio	O
:	O
i	int
=	O
number_to_double	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
i	int
=	O
sf	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
i	int
=	O
lf	function
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"~S cannot be coerce to a C int."	pointer
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
i	int
)	O
;	O
}	O
fixnum	O
object_to_fixnum	function
(	O
object	O
x	int
)	O
{	O
fixnum	O
i	int
=	O
0	int
;	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
i	int
=	O
char_code	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
i	int
=	O
fix	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
i	int
=	O
number_to_double	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_ratio	O
:	O
i	int
=	O
number_to_double	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
i	int
=	O
sf	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
i	int
=	O
lf	function
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"~S cannot be coerce to a C int."	pointer
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
i	int
)	O
;	O
}	O
float	O
object_to_float	function
(	O
object	O
x	int
)	O
{	O
float	O
f	float
=	O
0.0	int
;	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
f	float
=	O
char_code	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
f	float
=	O
fix	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
f	float
=	O
number_to_double	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
f	float
=	O
sf	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
f	float
=	O
lf	function
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"~S cannot be coerce to a C float."	pointer
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
f	float
)	O
;	O
}	O
double	O
object_to_double	function
(	O
object	O
x	int
)	O
{	O
double	O
d	double
=	O
0.0	int
;	O
switch	O
(	O
type_of	function
(	O
x	int
)	O
)	O
{	O
case	O
t_character	O
:	O
d	double
=	O
char_code	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_fixnum	O
:	O
d	double
=	O
fix	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
d	double
=	O
number_to_double	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
d	double
=	O
sf	function
(	O
x	int
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
d	double
=	O
lf	function
(	O
x	int
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"~S cannot be coerce to a C double."	pointer
,	O
1	int
,	O
x	int
)	O
;	O
}	O
return	O
(	O
d	double
)	O
;	O
}	O
char	O
*	O
object_to_string	function
(	O
object	O
x	int
)	O
{	O
unsigned	O
int	O
leng	int
;	O
char	O
*	O
res	pointer
;	O
if	O
(	O
type_of	function
(	O
x	int
)	O
!=	O
t_string	O
)	O
FEwrong_type_argument	function
(	O
sLstring	O
,	O
x	int
)	O
;	O
leng	int
=	O
x	int
->	O
st	O
.	O
st_fillp	O
;	O
if	O
(	O
leng	int
>	O
0	int
&&	O
leng	int
<	O
x	int
->	O
st	O
.	O
st_dim	O
&&	O
x	int
->	O
st	O
.	O
st_self	O
[	O
leng	int
]	O
==	O
0	int
)	O
return	O
x	int
->	O
st	O
.	O
st_self	O
;	O
if	O
(	O
x	int
->	O
st	O
.	O
st_dim	O
==	O
leng	int
&&	O
leng	int
%	O
sizeof	O
(	O
object	O
)	O
&&	O
MAYBE_DATA_P	function
(	O
x	int
->	O
st	O
.	O
st_self	O
)	O
)	O
{	O
x	int
->	O
st	O
.	O
st_self	O
[	O
leng	int
]	O
=	O
0	int
;	O
return	O
x	int
->	O
st	O
.	O
st_self	O
;	O
}	O
res	pointer
=	O
malloc	function
(	O
leng	int
+	O
1	int
)	O
;	O
bcopy	function
(	O
x	int
->	O
st	O
.	O
st_self	O
,	O
res	pointer
,	O
leng	int
)	O
;	O
res	pointer
[	O
leng	int
]	O
=	O
0	int
;	O
return	O
res	pointer
;	O
}	O
void	O
call_init	function
(	O
int	O
init_address	int
,	O
object	O
memory	int
,	O
object	O
fasl_vec	int
,	O
FUNC	O
fptr	pointer
)	O
{	O
object	O
form	O
;	O
FUNC	O
at	O
;	O
check_type	function
(	O
fasl_vec	int
,	O
t_vector	O
)	O
;	O
form	O
=	O
(	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
[	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
-	O
1	int
]	O
)	O
;	O
if	O
(	O
fptr	pointer
)	O
at	O
=	O
fptr	pointer
;	O
else	O
at	O
=	O
(	O
FUNC	O
)	O
(	O
memory	int
->	O
cfd	O
.	O
cfd_start	O
+	O
init_address	int
)	O
;	O
if	O
(	O
type_of	function
(	O
form	O
)	O
==	O
t_cons	O
&&	O
form	O
->	O
c	int
.	O
c_car	O
==	O
sSPinit	O
)	O
{	O
bds_bind	function
(	O
sSPinit	O
,	O
fasl_vec	int
)	O
;	O
bds_bind	function
(	O
sSPmemory	O
,	O
memory	int
)	O
;	O
(	O
*	O
at	O
)	O
(	O
)	O
;	O
bds_unwind1	O
;	O
bds_unwind1	O
;	O
}	O
else	O
{	O
memory	int
->	O
cfd	O
.	O
cfd_self	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
;	O
memory	int
->	O
cfd	O
.	O
cfd_fillp	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
;	O
(	O
*	O
at	O
)	O
(	O
memory	int
->	O
cfd	O
.	O
cfd_start	O
,	O
memory	int
->	O
cfd	O
.	O
cfd_size	O
,	O
memory	int
)	O
;	O
}	O
}	O
void	O
do_init	function
(	O
object	O
*	O
statVV	pointer
)	O
{	O
object	O
fasl_vec	int
=	O
sSPinit	O
->	O
s	pointer
.	O
s_dbind	O
;	O
object	O
data	O
=	O
sSPmemory	O
->	O
s	pointer
.	O
s_dbind	O
;	O
{	O
object	O
*	O
p	O
,	O
*	O
q	pointer
,	O
y	O
;	O
int	O
n	int
=	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
-	O
1	int
;	O
int	O
i	int
;	O
object	O
form	O
;	O
check_type	function
(	O
fasl_vec	int
,	O
t_vector	O
)	O
;	O
form	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
[	O
n	int
]	O
;	O
dcheck_type	O
(	O
form	O
,	O
t_cons	O
)	O
;	O
fasl_vec	int
->	O
v	O
.	O
v_elttype	O
=	O
aet_fix	O
;	O
fasl_vec	int
->	O
v	O
.	O
v_dim	O
*=	O
(	O
sizeof	O
(	O
object	O
)	O
/	O
sizeof	O
(	O
fixnum	O
)	O
)	O
;	O
fasl_vec	int
->	O
v	O
.	O
v_fillp	O
*=	O
(	O
sizeof	O
(	O
object	O
)	O
/	O
sizeof	O
(	O
fixnum	O
)	O
)	O
;	O
p	O
=	O
fasl_vec	int
->	O
v	O
.	O
v_self	O
;	O
q	pointer
=	O
statVV	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
n	int
;	O
i	int
++	O
)	O
{	O
y	O
=	O
*	O
p	O
;	O
*	O
p	O
++	O
=	O
*	O
q	pointer
;	O
*	O
q	pointer
++	O
=	O
y	O
;	O
}	O
data	O
->	O
cfd	O
.	O
cfd_self	O
=	O
statVV	pointer
;	O
data	O
->	O
cfd	O
.	O
cfd_fillp	O
=	O
n	int
+	O
1	int
;	O
statVV	pointer
[	O
n	int
]	O
=	O
data	O
;	O
form	O
=	O
form	O
->	O
c	int
.	O
c_cdr	O
;	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
form	O
->	O
v	O
.	O
v_fillp	O
;	O
i	int
++	O
)	O
{	O
eval	function
(	O
form	O
->	O
v	O
.	O
v_self	O
[	O
i	int
]	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
}	O
}	O
}	O
void	O
gcl_init_or_load1	function
(	O
void	O
(	O
*	O
fn	pointer
)	O
(	O
void	O
)	O
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
if	O
(	O
file	pointer
[	O
strlen	function
(	O
file	pointer
)	O
-	O
1	int
]	O
==	O
'o'	O
)	O
{	O
object	O
memory	int
;	O
object	O
fasl_data	O
;	O
file	pointer
=	O
FIX_PATH_STRING	function
(	O
file	pointer
)	O
;	O
memory	int
=	O
alloc_object	function
(	O
t_cfdata	O
)	O
;	O
memory	int
->	O
cfd	O
.	O
cfd_self	O
=	O
0	int
;	O
memory	int
->	O
cfd	O
.	O
cfd_fillp	O
=	O
0	int
;	O
memory	int
->	O
cfd	O
.	O
cfd_size	O
=	O
0	int
;	O
memory	int
->	O
cfd	O
.	O
cfd_start	O
=	O
(	O
char	O
*	O
)	O
fn	pointer
;	O
printf	O
(	O
"Initializing %s\n"	pointer
,	O
file	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
fasl_data	O
=	O
read_fasl_data	function
(	O
file	pointer
)	O
;	O
call_init	function
(	O
0	int
,	O
memory	int
,	O
fasl_data	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
printf	O
(	O
"loading %s\n"	pointer
,	O
file	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
load	function
(	O
file	pointer
)	O
;	O
}	O
}	O
DEFUN_NEW	function
(	O
"INIT-CMP-ANON"	pointer
,	O
object	O
,	O
fSinit_cmp_anon	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
"Initialize previously compiled and linked anonymous function from the .text section of the running executable.  This function is inherently dangerous, and is meant as a work-around to facilitate the production of an ansi GCL image on systems which must currently link using dlopen.  On such systems, it is imposible to compile and load anonymous functions as part of the initialization sequence of the lisp image, as is done in pcl, and preserve that function across a save-system call.  The approach here is to provide a flag to GCL's compile function which will direct the algorithm to forgo recompilation and loading in favor of initialization via this function."	pointer
)	O
{	O
int	O
i	int
;	O
i	int
=	O
gcl_init_cmp_anon	function
(	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
FEerror	function
(	O
"No such anonymous function"	pointer
,	O
0	int
)	O
;	O
return	O
i	int
?	O
Cnil	O
:	O
Ct	O
;	O
}	O
object	O
find_init_name1	function
(	O
char	O
*	O
s	pointer
,	O
unsigned	O
len	int
)	O
{	O
struct	O
stat	struct
ss	struct
;	O
char	O
*	O
tmp	pointer
,	O
*	O
q	pointer
;	O
FILE	O
*	O
f	float
;	O
if	O
(	O
len	int
)	O
{	O
tmp	pointer
=	O
alloca	function
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
s	pointer
,	O
len	int
)	O
;	O
tmp	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
tmp	pointer
=	O
s	pointer
;	O
if	O
(	O
stat	struct
(	O
tmp	pointer
,	O
&	O
ss	struct
)	O
)	O
FEerror	function
(	O
"File ~a does not exist"	pointer
,	O
1	int
,	O
make_simple_string	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
f	float
=	O
fopen	function
(	O
tmp	pointer
,	O
"rb"	pointer
)	O
)	O
)	O
FEerror	function
(	O
"Cannot open ~a for binary reading"	pointer
,	O
1	int
,	O
make_simple_string	function
(	O
tmp	pointer
)	O
)	O
;	O
tmp	pointer
=	O
alloca	function
(	O
ss	struct
.	O
st_size	long
+	O
1	int
)	O
;	O
if	O
(	O
fread	function
(	O
tmp	pointer
,	O
1	int
,	O
ss	struct
.	O
st_size	long
,	O
f	float
)	O
!=	O
ss	struct
.	O
st_size	long
)	O
FEerror	function
(	O
"Error reading binary file"	pointer
,	O
0	int
)	O
;	O
fclose	function
(	O
f	float
)	O
;	O
for	O
(	O
s	pointer
=	O
tmp	pointer
+	O
1	int
;	O
s	pointer
<	O
tmp	pointer
+	O
ss	struct
.	O
st_size	long
&&	O
(	O
strncmp	function
(	O
s	pointer
,	O
"init_"	pointer
,	O
5	int
)	O
||	O
(	O
s	pointer
>	O
tmp	pointer
&&	O
(	O
s	pointer
[	O
-	O
1	int
]	O
==	O
'_'	O
?	O
(	O
s	pointer
>	O
tmp	pointer
+	O
1	int
&&	O
s	pointer
[	O
-	O
2	int
]	O
)	O
:	O
s	pointer
[	O
-	O
1	int
]	O
)	O
)	O
)	O
;	O
q	pointer
=	O
strstr	function
(	O
s	pointer
+	O
1	int
,	O
"init_"	pointer
)	O
,	O
s	pointer
=	O
q	pointer
?	O
q	pointer
:	O
s	pointer
+	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
strncmp	function
(	O
s	pointer
,	O
"init_"	pointer
,	O
5	int
)	O
)	O
FEerror	function
(	O
"Init name not found"	pointer
,	O
0	int
)	O
;	O
return	O
make_simple_string	function
(	O
s	pointer
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"FIND-INIT-NAME"	pointer
,	O
object	O
,	O
fSfind_init_name	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
namestring	O
)	O
,	O
""	pointer
)	O
{	O
check_type_string	function
(	O
&	O
namestring	O
)	O
;	O
return	O
find_init_name1	function
(	O
namestring	O
->	O
st	O
.	O
st_self	O
,	O
namestring	O
->	O
st	O
.	O
st_dim	O
)	O
;	O
}	O
