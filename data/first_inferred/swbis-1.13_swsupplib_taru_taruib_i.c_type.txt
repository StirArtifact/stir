static	O
char	O
*	O
md5sum_adjunct_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/adjunct_md5sum"	pointer
,	O
"*/catalog/*/adjunct_md5sum"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
md5sum_full_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/md5sum"	pointer
,	O
"*/catalog/*/md5sum"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
sha1sum_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/sha1sum"	pointer
,	O
"*/catalog/*/sha1sum"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
sha512sum_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/sha512sum"	pointer
,	O
"*/catalog/*/sha512sum"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
signature_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/"	pointer
SWBN_SIGNATURE	pointer
,	O
"*/catalog/*/"	pointer
SWBN_SIGNATURE	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
size_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/size"	pointer
,	O
"*/catalog/*/size"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
signature_header_pattern	array
[	O
3	int
]	O
=	O
{	O
"catalog/*/"	pointer
SWBN_SIG_HEADER	pointer
,	O
"*/catalog/*/"	pointer
SWBN_SIG_HEADER	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
static	O
char	O
*	O
*	O
determine_pattern_array	function
(	O
int	O
*	O
detpat	pointer
,	O
char	O
*	O
name	array
)	O
{	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/md5sum"	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_MD5	int
;	O
return	O
md5sum_full_pattern	array
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/adjunct_md5sum"	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_ADJUNCT_MD5	int
;	O
return	O
md5sum_adjunct_pattern	array
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/sha1sum"	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_SHA1	int
;	O
return	O
sha1sum_pattern	array
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/sha512sum"	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_SHA512	int
;	O
return	O
sha512sum_pattern	array
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/size"	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_SIZE	int
;	O
return	O
size_pattern	array
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/"	pointer
SWBN_SIGNATURE	pointer
)	O
&&	O
strlen	function
(	O
strstr	function
(	O
name	array
,	O
"/"	pointer
SWBN_SIGNATURE	pointer
)	O
)	O
==	O
strlen	function
(	O
"/"	pointer
SWBN_SIGNATURE	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_SIG	int
;	O
return	O
signature_pattern	array
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
name	array
,	O
"/"	pointer
SWBN_SIG_HEADER	pointer
)	O
&&	O
strlen	function
(	O
strstr	function
(	O
name	array
,	O
"/"	pointer
SWBN_SIG_HEADER	pointer
)	O
)	O
==	O
strlen	function
(	O
"/"	pointer
SWBN_SIG_HEADER	pointer
)	O
)	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_SIG_HDR	int
;	O
return	O
signature_header_pattern	array
;	O
}	O
else	O
{	O
*	O
detpat	pointer
=	O
TARUIB_N_OTHER	O
;	O
return	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
}	O
}	O
static	O
int	O
check_useArray	function
(	O
int	O
*	O
useArray	pointer
,	O
int	O
digest_type	int
,	O
int	O
dfd	int
)	O
{	O
int	O
ret	int
=	O
-	O
1	int
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
useArray	pointer
)	O
{	O
if	O
(	O
digest_type	int
>	O
TARUIB_N_MAX_INDEX	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
useArray	pointer
[	O
digest_type	int
]	O
&&	O
digest_type	int
!=	O
TARUIB_N_SIG	int
)	O
{	O
ret	int
=	O
-	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: catalog file error : type = %d\n"	pointer
,	O
digest_type	int
)	O
;	O
}	O
else	O
{	O
useArray	pointer
[	O
digest_type	int
]	O
++	O
;	O
ret	int
=	O
dfd	int
;	O
}	O
}	O
else	O
{	O
ret	int
=	O
dfd	int
;	O
}	O
return	O
ret	int
;	O
}	O
static	O
int	O
verbose_decode	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
*	O
useArray	pointer
,	O
int	O
*	O
detpat	pointer
,	O
char	O
*	O
prepath	pointer
,	O
char	O
*	O
name	array
,	O
int	O
nullfd	int
,	O
int	O
digest_type	int
,	O
int	O
verbose	int
,	O
int	O
md5digestfd	int
,	O
int	O
sha1digestfd	int
,	O
int	O
sizefd	int
,	O
int	O
sigfd	int
,	O
int	O
sha512digestfd	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
int	O
ret	int
;	O
int	O
passfd	int
=	O
nullfd	int
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
*	O
pattern_array	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
intmax_t	long
filesize	long
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
verbose	int
==	O
0	int
)	O
return	O
nullfd	int
;	O
if	O
(	O
prepath	pointer
&&	O
strlen	function
(	O
prepath	pointer
)	O
)	O
{	O
s	pointer
=	O
strstr	function
(	O
name	array
,	O
prepath	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
s	pointer
==	O
name	array
)	O
{	O
name	array
+=	O
(	O
strlen	function
(	O
prepath	pointer
)	O
)	O
;	O
if	O
(	O
*	O
name	array
==	O
'/'	O
)	O
name	array
++	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
pattern_array	pointer
=	O
determine_pattern_array	function
(	O
detpat	pointer
,	O
name	array
)	O
;	O
digest_type	int
=	O
*	O
detpat	pointer
;	O
if	O
(	O
pattern_array	pointer
==	O
NULL	O
)	O
return	O
nullfd	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
while	O
(	O
pattern_array	pointer
[	O
i	int
]	O
)	O
{	O
if	O
(	O
!	O
name	array
||	O
!	O
strlen	function
(	O
name	array
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error in taruib::verbose_decode\n"	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
nullfd	int
;	O
}	O
E_DEBUG3	O
(	O
"fnmatch [%s] [%s]"	pointer
,	O
pattern_array	pointer
[	O
i	int
]	O
,	O
name	array
)	O
;	O
ret	int
=	O
fnmatch	function
(	O
pattern_array	pointer
[	O
i	int
]	O
,	O
name	array
,	O
1	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
filesize	long
=	O
xformat_get_filesize	function
(	O
package	pointer
)	O
;	O
if	O
(	O
digest_type	int
==	O
TARUIB_N_MD5	int
&&	O
md5digestfd	int
>=	O
0	int
)	O
{	O
passfd	int
=	O
check_useArray	function
(	O
useArray	pointer
,	O
digest_type	int
,	O
md5digestfd	int
)	O
;	O
}	O
else	O
if	O
(	O
digest_type	int
==	O
TARUIB_N_SIG	int
&&	O
sigfd	int
>=	O
0	int
)	O
{	O
passfd	int
=	O
check_useArray	function
(	O
useArray	pointer
,	O
digest_type	int
,	O
sigfd	int
)	O
;	O
}	O
else	O
if	O
(	O
digest_type	int
==	O
TARUIB_N_SHA1	int
&&	O
sha1digestfd	int
>=	O
0	int
)	O
{	O
passfd	int
=	O
check_useArray	function
(	O
useArray	pointer
,	O
digest_type	int
,	O
sha1digestfd	int
)	O
;	O
}	O
else	O
if	O
(	O
digest_type	int
==	O
TARUIB_N_SHA512	int
&&	O
sha512digestfd	int
>=	O
0	int
)	O
{	O
passfd	int
=	O
check_useArray	function
(	O
useArray	pointer
,	O
digest_type	int
,	O
sha512digestfd	int
)	O
;	O
}	O
else	O
if	O
(	O
digest_type	int
==	O
TARUIB_N_SIZE	int
&&	O
sizefd	int
>=	O
0	int
)	O
{	O
passfd	int
=	O
check_useArray	function
(	O
useArray	pointer
,	O
digest_type	int
,	O
sizefd	int
)	O
;	O
}	O
else	O
if	O
(	O
digest_type	int
==	O
TARUIB_N_SIG_HDR	int
)	O
{	O
passfd	int
=	O
nullfd	int
;	O
}	O
else	O
{	O
if	O
(	O
detpat	pointer
)	O
{	O
passfd	int
=	O
nullfd	int
;	O
}	O
else	O
{	O
passfd	int
=	O
STDERR_FILENO	int
;	O
}	O
}	O
break	O
;	O
}	O
i	int
++	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
passfd	int
;	O
}	O
static	O
int	O
check_signature_name	function
(	O
char	O
*	O
sigfilename	pointer
,	O
char	O
*	O
prevname	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
s	pointer
=	O
strstr	function
(	O
sigfilename	pointer
,	O
"/"	pointer
SWBN_SIGNATURE	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
||	O
*	O
(	O
s	pointer
+	O
strlen	function
(	O
"/"	pointer
SWBN_SIGNATURE	pointer
)	O
)	O
!=	O
'\0'	O
)	O
{	O
return	O
1	int
;	O
}	O
s	pointer
++	O
;	O
*	O
s	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
p	pointer
=	O
strstr	function
(	O
prevname	pointer
,	O
sigfilename	pointer
)	O
)	O
==	O
NULL	O
||	O
p	pointer
!=	O
prevname	pointer
)	O
{	O
ret	int
=	O
1	int
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
*	O
s	pointer
=	O
's'	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
do_sig_safety_checks	function
(	O
int	O
memfd	int
,	O
int	O
sigsize	int
,	O
int	O
whichsig	int
)	O
{	O
char	O
*	O
data	pointer
;	O
int	O
data_len	int
;	O
int	O
cnt	int
=	O
0	int
;	O
char	O
*	O
s	pointer
;	O
int	O
foundnull	int
=	O
0	int
;	O
int	O
foundchar	int
=	O
0	int
;	O
int	O
which_offset	int
=	O
0	int
;	O
int	O
nsig	int
;	O
int	O
start_sig	int
;	O
int	O
end_sig	int
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
uxfio_get_dynamic_buffer	function
(	O
memfd	int
,	O
&	O
data	pointer
,	O
NULL	O
,	O
&	O
data_len	int
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"data_len=[%d]"	pointer
,	O
data_len	int
)	O
;	O
if	O
(	O
whichsig	int
==	O
0	int
)	O
{	O
if	O
(	O
data_len	int
<	O
sigsize	int
)	O
{	O
return	O
-	O
3	int
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
whichsig	int
>	O
0	int
)	O
{	O
if	O
(	O
data_len	int
<	O
(	O
whichsig	int
*	O
sigsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid signature number specified\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
-	O
4	int
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
data_len	int
%	O
sigsize	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
5	int
;	O
}	O
nsig	int
=	O
data_len	int
/	O
sigsize	int
;	O
E_DEBUG2	O
(	O
"number of sigs are [%d]"	pointer
,	O
nsig	int
)	O
;	O
if	O
(	O
nsig	int
<	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
6	int
;	O
}	O
if	O
(	O
whichsig	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"whichsig = 0"	pointer
)	O
;	O
which_offset	int
=	O
(	O
nsig	int
-	O
1	int
)	O
*	O
sigsize	int
;	O
start_sig	int
=	O
end_sig	int
=	O
nsig	int
;	O
}	O
else	O
if	O
(	O
whichsig	int
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"whichsig > 0"	pointer
)	O
;	O
which_offset	int
=	O
(	O
whichsig	int
-	O
1	int
)	O
*	O
sigsize	int
;	O
start_sig	int
=	O
end_sig	int
=	O
whichsig	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"whichsig < 0"	pointer
)	O
;	O
start_sig	int
=	O
1	int
;	O
end_sig	int
=	O
nsig	int
;	O
}	O
while	O
(	O
start_sig	int
++	O
<=	O
end_sig	int
)	O
{	O
s	pointer
=	O
data	pointer
+	O
(	O
(	O
start_sig	int
-	O
2	int
)	O
*	O
sigsize	int
)	O
;	O
E_DEBUG2	O
(	O
"((start_sig-2) * sigsize) = %d"	pointer
,	O
(	O
(	O
start_sig	int
-	O
2	int
)	O
*	O
sigsize	int
)	O
)	O
;	O
while	O
(	O
cnt	int
<	O
sigsize	int
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
(	O
*	O
s	pointer
)	O
)	O
{	O
case	O
'\0'	O
:	O
if	O
(	O
!	O
foundchar	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Corrupt char in sigfile\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
3	int
;	O
}	O
foundnull	int
++	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
foundnull	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Corrupt char in sigfile\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
!	O
isprint	function
(	O
(	O
int	O
)	O
(	O
*	O
s	pointer
)	O
)	O
&&	O
*	O
s	pointer
!=	O
'\x0a'	O
&&	O
*	O
s	pointer
!=	O
'\x0d'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Corrupt char in sigfile\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
foundchar	int
++	O
;	O
break	O
;	O
}	O
s	pointer
++	O
;	O
cnt	int
++	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
do_header_safety_checks	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
char	O
*	O
name	array
,	O
char	O
*	O
prevname	pointer
,	O
char	O
*	O
signature_header	pointer
)	O
{	O
int	O
type	pointer
;	O
mode_t	int
mode	array
;	O
char	O
*	O
linkname	array
;	O
intmax_t	long
sigsize	int
;	O
unsigned	O
long	O
trusted_sigsize	long
;	O
char	O
*	O
header_bytes	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
check_signature_name	function
(	O
name	array
,	O
prevname	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: *** The file name [%s]\n"	pointer
"         *** indicate strong possibility of tampering.\n"	pointer
"         *** Use of this package is a security risk.\n"	pointer
,	O
name	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
header_bytes	pointer
=	O
taru_get_recorded_header	function
(	O
package	pointer
->	O
taruM	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
type	pointer
=	O
xformat_get_tar_typeflag	function
(	O
package	pointer
)	O
;	O
mode	array
=	O
xformat_get_perms	function
(	O
package	pointer
)	O
;	O
linkname	array
=	O
xformat_get_linkname	function
(	O
package	pointer
,	O
NULL	O
)	O
;	O
sigsize	int
=	O
xformat_get_filesize	function
(	O
package	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
mode	array
)	O
==	O
0	int
&&	O
(	O
(	O
mode	array
&	O
S_ISUID	O
)	O
||	O
(	O
mode	array
&	O
S_ISGID	O
)	O
||	O
(	O
mode	array
&	O
S_ISVTX	O
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: *** The file mode permissions on %s\n"	pointer
"         *** indicate strong possibility of tampering.\n"	pointer
"         *** Use of this package is a security risk.\n"	pointer
,	O
name	array
)	O
;	O
return	O
-	O
2	int
;	O
}	O
if	O
(	O
type	pointer
!=	O
REGTYPE	char
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: *** The file type flag on %s\n"	pointer
"         *** indicate strong possibility of tampering.\n"	pointer
"         *** Use of this package is a security risk.\n"	pointer
,	O
name	array
)	O
;	O
return	O
-	O
2	int
;	O
}	O
if	O
(	O
linkname	array
&&	O
strlen	function
(	O
linkname	array
)	O
)	O
{	O
return	O
-	O
3	int
;	O
}	O
if	O
(	O
signature_header	pointer
)	O
{	O
taru_otoul	function
(	O
signature_header	pointer
+	O
THB_BO_size	int
,	O
&	O
trusted_sigsize	long
)	O
;	O
if	O
(	O
header_bytes	pointer
&&	O
(	O
int	O
)	O
trusted_sigsize	long
==	O
sigsize	int
)	O
{	O
ret	int
=	O
memcmp	function
(	O
signature_header	pointer
,	O
header_bytes	pointer
,	O
TARRECORDSIZE	int
)	O
;	O
if	O
(	O
ret	int
)	O
ret	int
=	O
-	O
5	int
;	O
}	O
else	O
{	O
ret	int
=	O
-	O
6	int
;	O
}	O
}	O
else	O
{	O
}	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
return	O
-	O
ret	int
;	O
return	O
sigsize	int
;	O
}	O
static	O
int	O
read_catalog_section	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
ifd	int
)	O
{	O
XFORMAT	struct
*	O
package	pointer
=	O
(	O
XFORMAT	struct
*	O
)	O
vp	pointer
;	O
int	O
nullfd	int
;	O
int	O
copyret	int
;	O
int	O
ret	int
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
path_ret	int
;	O
int	O
is_catalog	int
;	O
STROB	struct
*	O
namebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
char	O
*	O
name	array
;	O
SWPATH	struct
*	O
swpath	pointer
=	O
swpath_open	function
(	O
""	pointer
)	O
;	O
int	O
header_bytes	pointer
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
nullfd	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
swpath	pointer
)	O
return	O
-	O
21	int
;	O
if	O
(	O
nullfd	int
<	O
0	int
)	O
return	O
-	O
22	int
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
return	O
-	O
32	int
;	O
taruib_set_fd	function
(	O
nullfd	int
)	O
;	O
taruib_set_overflow_release	function
(	O
0	int
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
package	pointer
)	O
)	O
>	O
0	int
)	O
{	O
header_bytes	pointer
=	O
ret	int
;	O
retval	int
+=	O
ret	int
;	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
package	pointer
)	O
)	O
{	O
taruib_clear_buffer	function
(	O
)	O
;	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
return	O
0	int
;	O
}	O
xformat_get_name	function
(	O
package	pointer
,	O
namebuf	pointer
)	O
;	O
name	array
=	O
strob_str	function
(	O
namebuf	pointer
)	O
;	O
path_ret	int
=	O
swpath_parse_path	function
(	O
swpath	pointer
,	O
name	array
)	O
;	O
if	O
(	O
path_ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"read_catalog_section:"	pointer
" error parsing path [%s].\n"	pointer
,	O
name	array
)	O
;	O
return	O
-	O
2	int
;	O
}	O
is_catalog	int
=	O
swpath_get_is_catalog	function
(	O
swpath	pointer
)	O
;	O
if	O
(	O
is_catalog	int
!=	O
SWPATH_CTYPE_STORE	int
)	O
{	O
taruib_set_overflow_release	function
(	O
0	int
)	O
;	O
taruib_set_fd	function
(	O
0	int
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
nullfd	int
,	O
ifd	int
)	O
;	O
if	O
(	O
copyret	int
<	O
0	int
)	O
{	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
return	O
copyret	int
;	O
}	O
taruib_set_fd	function
(	O
nullfd	int
)	O
;	O
taruib_clear_buffer	function
(	O
)	O
;	O
}	O
else	O
{	O
taruib_clear_buffer	function
(	O
)	O
;	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
taruib_clear_buffer	function
(	O
)	O
;	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
taruib_write_signedfile_if_i	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
sigfile	pointer
,	O
int	O
md5digestfd	int
,	O
int	O
sha1digestfd	int
,	O
int	O
sizefd	int
,	O
int	O
sigfd	int
,	O
int	O
sha512digestfd	int
,	O
int	O
*	O
p_has_storage_section	pointer
)	O
{	O
XFORMAT	struct
*	O
package	pointer
=	O
(	O
XFORMAT	struct
*	O
)	O
vp	pointer
;	O
int	O
i	int
;	O
int	O
nullfd	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
int	O
memfd	int
=	O
-	O
1	int
;	O
int	O
ifd	int
=	O
xformat_get_ifd	function
(	O
package	pointer
)	O
;	O
int	O
passfd	int
;	O
int	O
copyret	int
;	O
int	O
ret	int
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
is_catalog	int
;	O
char	O
*	O
name	array
;	O
char	O
*	O
prepath	pointer
;	O
int	O
debug	int
=	O
0	int
;	O
int	O
header_bytes	pointer
;	O
int	O
pattern_code	int
=	O
0	int
;	O
int	O
verbose	int
=	O
1	int
;	O
int	O
path_ret	int
;	O
int	O
detected_pattern_code	int
;	O
STROB	struct
*	O
namebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
STROB	struct
*	O
oldnamebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
SWPATH	struct
*	O
swpath	pointer
=	O
swpath_open	function
(	O
""	pointer
)	O
;	O
int	O
useArray	pointer
[	O
TARUIB_N_MAX_INDEX	int
+	O
1	int
]	O
;	O
int	O
sigsize	int
=	O
0	int
;	O
int	O
sighdr_len	int
=	O
0	int
;	O
int	O
got_md5	int
=	O
0	int
;	O
int	O
got_sha1	int
=	O
0	int
;	O
int	O
got_sha512	int
=	O
0	int
;	O
int	O
got_size	int
=	O
0	int
;	O
int	O
got_sig	int
=	O
0	int
;	O
char	O
*	O
sighdr_addr	pointer
=	O
NULL	O
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
*	O
p_has_storage_section	pointer
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
TARUIB_N_MAX_INDEX	int
;	O
i	int
++	O
)	O
useArray	pointer
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
swpath	pointer
)	O
return	O
-	O
21	int
;	O
if	O
(	O
nullfd	int
<	O
0	int
)	O
return	O
-	O
22	int
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
return	O
-	O
32	int
;	O
taruib_set_fd	function
(	O
nullfd	int
)	O
;	O
taruib_set_overflow_release	function
(	O
0	int
)	O
;	O
taru_set_header_recording	function
(	O
package	pointer
->	O
taruM	pointer
,	O
1	int
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
package	pointer
)	O
)	O
>	O
0	int
)	O
{	O
header_bytes	pointer
=	O
ret	int
;	O
retval	int
+=	O
ret	int
;	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
package	pointer
)	O
)	O
{	O
taruib_set_fd	function
(	O
ofd	int
)	O
;	O
taruib_clear_buffer	function
(	O
)	O
;	O
retval	int
=	O
ret	int
;	O
taruib_set_fd	function
(	O
0	int
)	O
;	O
*	O
p_has_storage_section	pointer
=	O
0	int
;	O
break	O
;	O
}	O
strob_strcpy	function
(	O
oldnamebuf	pointer
,	O
strob_str	function
(	O
namebuf	pointer
)	O
)	O
;	O
xformat_get_name	function
(	O
package	pointer
,	O
namebuf	pointer
)	O
;	O
name	array
=	O
strob_str	function
(	O
namebuf	pointer
)	O
;	O
path_ret	int
=	O
swpath_parse_path	function
(	O
swpath	pointer
,	O
name	array
)	O
;	O
if	O
(	O
path_ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" error parsing path [%s].\n"	pointer
,	O
name	array
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
is_catalog	int
=	O
swpath_get_is_catalog	function
(	O
swpath	pointer
)	O
;	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %d\n"	pointer
,	O
name	array
,	O
is_catalog	int
)	O
;	O
prepath	pointer
=	O
swpath_get_prepath	function
(	O
swpath	pointer
)	O
;	O
if	O
(	O
is_catalog	int
==	O
SWPATH_CTYPE_CAT	int
)	O
{	O
taruib_set_overflow_release	function
(	O
0	int
)	O
;	O
taruib_set_fd	function
(	O
0	int
)	O
;	O
passfd	int
=	O
verbose_decode	function
(	O
package	pointer
,	O
useArray	pointer
,	O
&	O
detected_pattern_code	int
,	O
prepath	pointer
,	O
name	array
,	O
nullfd	int
,	O
pattern_code	int
,	O
verbose	int
,	O
md5digestfd	int
,	O
sha1digestfd	int
,	O
sizefd	int
,	O
sigfd	int
,	O
sha512digestfd	int
)	O
;	O
pattern_code	int
=	O
detected_pattern_code	int
;	O
if	O
(	O
passfd	int
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"name=[%s] passfd < 0 error"	pointer
,	O
name	array
)	O
;	O
copyret	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_OTHER	O
)	O
{	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_SIG_HDR	int
)	O
{	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
if	O
(	O
got_sig	int
)	O
{	O
return	O
-	O
3	int
;	O
}	O
memfd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
memfd	int
,	O
ifd	int
)	O
;	O
sighdr_addr	pointer
=	O
uxfio_get_fd_mem	function
(	O
memfd	int
,	O
&	O
sighdr_len	int
)	O
;	O
if	O
(	O
sighdr_addr	pointer
==	O
NULL	O
||	O
(	O
sighdr_len	int
!=	O
512	int
)	O
)	O
{	O
return	O
-	O
4	int
;	O
}	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_SIG	int
)	O
{	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
if	O
(	O
(	O
sigsize	int
=	O
do_header_safety_checks	function
(	O
package	pointer
,	O
strob_str	function
(	O
namebuf	pointer
)	O
,	O
strob_str	function
(	O
oldnamebuf	pointer
)	O
,	O
sighdr_addr	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\nWarning: *** The signature header checks failed (status=%d)\n"	pointer
"         *** This indicates possibility of tampering or corruption.\n"	pointer
"         *** Use of this package is a security risk.\n"	pointer
,	O
sigsize	int
)	O
;	O
return	O
-	O
5	int
;	O
}	O
got_sig	int
++	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
if	O
(	O
(	O
sigsize	int
!=	O
512	int
&&	O
sigsize	int
!=	O
1024	int
)	O
||	O
sigsize	int
!=	O
copyret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\nWarning: *** The signature file size and data length does not match. (%d %d)\n"	pointer
"         *** This indicates possibility of tampering or corruption.\n"	pointer
"         *** Use of this package is a security risk.\n"	pointer
,	O
sigsize	int
,	O
copyret	int
)	O
;	O
return	O
-	O
7	int
;	O
}	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_MD5	int
)	O
{	O
got_md5	int
++	O
;	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_SHA1	int
)	O
{	O
got_sha1	int
++	O
;	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_SHA512	int
)	O
{	O
got_sha512	int
++	O
;	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
}	O
else	O
if	O
(	O
pattern_code	int
==	O
TARUIB_N_SIZE	int
)	O
{	O
got_size	int
++	O
;	O
E_DEBUG3	O
(	O
"name=[%s] pattern code = %d"	pointer
,	O
name	array
,	O
pattern_code	int
)	O
;	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
}	O
else	O
if	O
(	O
passfd	int
==	O
nullfd	int
)	O
{	O
copyret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
passfd	int
,	O
ifd	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error loc = 5a\n"	pointer
)	O
;	O
copyret	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
copyret	int
<	O
0	int
)	O
{	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
strob_close	function
(	O
oldnamebuf	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
return	O
-	O
8	int
;	O
}	O
E_DEBUG3	O
(	O
"copyret = %d for %s"	pointer
,	O
copyret	int
,	O
name	array
)	O
;	O
taruib_set_fd	function
(	O
nullfd	int
)	O
;	O
taruib_clear_buffer	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
is_catalog	int
==	O
SWPATH_CTYPE_DIR	O
)	O
{	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"in leading dirs\n"	pointer
)	O
;	O
taruib_set_fd	function
(	O
ofd	int
)	O
;	O
taruib_clear_buffer	function
(	O
)	O
;	O
}	O
else	O
{	O
taruib_set_fd	function
(	O
ofd	int
)	O
;	O
taruib_clear_buffer	function
(	O
)	O
;	O
retval	int
=	O
ret	int
;	O
taruib_set_fd	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
taruib_set_overflow_release	function
(	O
1	int
)	O
;	O
}	O
taru_set_header_recording	function
(	O
package	pointer
->	O
taruM	pointer
,	O
0	int
)	O
;	O
strob_close	function
(	O
oldnamebuf	pointer
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
if	O
(	O
got_sha1	int
&&	O
!	O
got_md5	int
)	O
{	O
return	O
-	O
9	int
;	O
}	O
if	O
(	O
!	O
got_sig	int
&&	O
!	O
got_md5	int
&&	O
!	O
got_sha1	int
)	O
{	O
return	O
-	O
TARUIB_TEXIT_NOT_SIGNED	int
;	O
}	O
if	O
(	O
!	O
got_sig	int
||	O
!	O
got_md5	int
)	O
{	O
return	O
-	O
10	int
;	O
}	O
if	O
(	O
sigsize	int
==	O
0	int
)	O
{	O
return	O
-	O
11	int
;	O
}	O
if	O
(	O
got_sig	int
&&	O
got_md5	int
)	O
{	O
return	O
sigsize	int
;	O
}	O
return	O
-	O
12	int
;	O
}	O
static	O
void	O
truncate_sigfile	function
(	O
char	O
*	O
sigfile	pointer
)	O
{	O
int	O
sigfd	int
=	O
open	function
(	O
sigfile	pointer
,	O
O_RDWR	int
|	O
O_TRUNC	int
|	O
O_CREAT	int
,	O
0600	int
)	O
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
sigfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"open failed ( %s ) : %s\n"	pointer
,	O
sigfile	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
close	pointer
(	O
sigfd	int
)	O
;	O
return	O
;	O
}	O
static	O
int	O
write_selected_sig_i	function
(	O
int	O
sigfd	int
,	O
int	O
memfd	int
,	O
int	O
whichsig	int
,	O
int	O
sigsize	int
)	O
{	O
int	O
offset	int
;	O
int	O
ret	int
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
sigbuf	pointer
;	O
char	O
*	O
nsig	int
;	O
if	O
(	O
whichsig	int
==	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
whichsig	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
offset	int
=	O
sigsize	int
*	O
(	O
whichsig	int
-	O
1	int
)	O
;	O
}	O
if	O
(	O
uxfio_lseek	function
(	O
memfd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_END	int
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
uxfio_write	function
(	O
memfd	int
,	O
"\0"	pointer
,	O
1	int
)	O
;	O
sigbuf	pointer
=	O
uxfio_get_fd_mem	function
(	O
memfd	int
,	O
NULL	O
)	O
;	O
nsig	int
=	O
sigbuf	pointer
+	O
offset	int
;	O
if	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
nsig	int
,	O
"\n\n\n\n\n\n\n\n\n\n"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
(	O
s	pointer
+	O
4	int
)	O
=	O
'\0'	O
;	O
ret	int
=	O
uxfio_write	function
(	O
sigfd	int
,	O
nsig	int
,	O
strlen	function
(	O
nsig	int
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strlen	function
(	O
nsig	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
ret	int
=	O
uxfio_write	function
(	O
sigfd	int
,	O
nsig	int
,	O
sigsize	int
)	O
;	O
if	O
(	O
ret	int
!=	O
sigsize	int
)	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
write_selected_sig	function
(	O
int	O
sigfd	int
,	O
int	O
memfd	int
,	O
int	O
whichsig	int
,	O
int	O
sigsize	int
)	O
{	O
int	O
len	int
;	O
int	O
start_sig	int
,	O
end_sig	int
;	O
int	O
ret	int
;	O
len	int
=	O
uxfio_lseek	function
(	O
memfd	int
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
end_sig	int
=	O
len	int
/	O
sigsize	int
;	O
if	O
(	O
whichsig	int
==	O
0	int
)	O
{	O
start_sig	int
=	O
end_sig	int
;	O
}	O
else	O
if	O
(	O
whichsig	int
<	O
0	int
)	O
{	O
start_sig	int
=	O
1	int
;	O
}	O
else	O
{	O
start_sig	int
=	O
whichsig	int
;	O
end_sig	int
=	O
whichsig	int
;	O
}	O
while	O
(	O
start_sig	int
++	O
<=	O
end_sig	int
)	O
{	O
ret	int
=	O
write_selected_sig_i	function
(	O
sigfd	int
,	O
memfd	int
,	O
start_sig	int
-	O
1	int
,	O
sigsize	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
report_dig_error	function
(	O
STROB	struct
*	O
buf	pointer
,	O
int	O
msgfd	int
,	O
int	O
efd	int
,	O
char	O
*	O
digname	pointer
,	O
int	O
dlen	int
,	O
int	O
verbose	int
)	O
{	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
swlib_writef	function
(	O
msgfd	int
,	O
buf	pointer
,	O
"%s FAIL (Bad)\n"	pointer
,	O
digname	pointer
)	O
;	O
if	O
(	O
dlen	int
>	O
0	int
)	O
{	O
swlib_writef	function
(	O
efd	int
,	O
buf	pointer
,	O
"%s: package integrity error: archive %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
digname	pointer
)	O
;	O
}	O
if	O
(	O
dlen	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Warning: %s digest not present\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
digname	pointer
)	O
;	O
}	O
}	O
int	O
taruib_write_signedfile_if	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
sigfile	pointer
,	O
int	O
verbose	int
,	O
int	O
whichsig	int
,	O
int	O
logger_fd	int
)	O
{	O
pid_t	int
pid	int
[	O
3	int
]	O
;	O
int	O
status	int
[	O
3	int
]	O
;	O
int	O
md5dig	array
[	O
2	int
]	O
;	O
int	O
sha1dig	array
[	O
2	int
]	O
;	O
int	O
sha512dig	array
[	O
2	int
]	O
;	O
int	O
filesizefd	array
[	O
2	int
]	O
;	O
int	O
digfile	array
[	O
2	int
]	O
;	O
int	O
sigpipefd	array
[	O
2	int
]	O
;	O
int	O
msgfd	int
;	O
char	O
md5digbuf	array
[	O
1024	int
]	O
;	O
char	O
sha1digbuf	array
[	O
1024	int
]	O
;	O
char	O
sha512digbuf	array
[	O
1024	int
]	O
;	O
char	O
sizebuf	array
[	O
1024	int
]	O
;	O
char	O
calc_md5digbuf	array
[	O
64	int
]	O
;	O
char	O
calc_sha1digbuf	array
[	O
64	int
]	O
;	O
char	O
calc_sha512digbuf	array
[	O
129	int
]	O
;	O
char	O
calc_size	array
[	O
64	int
]	O
;	O
XFORMAT	struct
*	O
package	pointer
=	O
(	O
XFORMAT	struct
*	O
)	O
vp	pointer
;	O
int	O
sigsize	int
;	O
int	O
ifd	int
=	O
xformat_get_ifd	function
(	O
package	pointer
)	O
;	O
int	O
efd	int
;	O
int	O
sigfd	int
;	O
int	O
ret	int
;	O
int	O
pri_ret	int
;	O
int	O
memfd	int
;	O
int	O
ifret	int
;	O
int	O
has_storage_section	int
;	O
unsigned	O
long	O
actual_read_size	long
;	O
unsigned	O
long	O
claimed_size	long
;	O
STROB	struct
*	O
tmp	pointer
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
E_DEBUG2	O
(	O
"ENTERING whichsig=[%d]"	pointer
,	O
whichsig	int
)	O
;	O
msgfd	int
=	O
logger_fd	int
;	O
efd	int
=	O
STDERR_FILENO	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
memset	function
(	O
sizebuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
sizebuf	array
)	O
)	O
;	O
memset	function
(	O
sha1digbuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
sha1digbuf	array
)	O
)	O
;	O
memset	function
(	O
sha512digbuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
sha512digbuf	array
)	O
)	O
;	O
memset	function
(	O
md5digbuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
md5digbuf	array
)	O
)	O
;	O
memset	function
(	O
calc_sha1digbuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
calc_sha1digbuf	array
)	O
)	O
;	O
memset	function
(	O
calc_sha512digbuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
calc_sha512digbuf	array
)	O
)	O
;	O
memset	function
(	O
calc_md5digbuf	array
,	O
'\0'	O
,	O
sizeof	O
(	O
calc_md5digbuf	array
)	O
)	O
;	O
memset	function
(	O
calc_size	array
,	O
'\0'	O
,	O
sizeof	O
(	O
calc_size	array
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"uxfio_lseek error fd=%d loc=1 ret=%d\n"	pointer
,	O
ifd	int
,	O
ret	int
)	O
;	O
return	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_fcntl	function
(	O
ifd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
read_catalog_section	function
(	O
vp	pointer
,	O
ifd	int
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error from read_catalog_section, ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
return	O
2	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
0	int
,	O
UXFIO_SEEK_VSET	int
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"uxfio_lseek error loc=2 ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
return	O
3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pipe	function
(	O
digfile	array
)	O
;	O
pipe	function
(	O
sha1dig	array
)	O
;	O
pipe	function
(	O
sha512dig	array
)	O
;	O
pipe	function
(	O
filesizefd	array
)	O
;	O
pipe	function
(	O
md5dig	array
)	O
;	O
pipe	function
(	O
sigpipefd	array
)	O
;	O
pid	int
[	O
0	int
]	O
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
[	O
0	int
]	O
<	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
pid	int
[	O
0	int
]	O
==	O
0	int
)	O
{	O
int	O
cret	int
;	O
close	pointer
(	O
filesizefd	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sha1dig	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sha512dig	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
md5dig	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
digfile	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sigpipefd	array
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
"entering taruib_write_signedfile_if_i in child"	pointer
)	O
;	O
cret	int
=	O
taruib_write_signedfile_if_i	function
(	O
vp	pointer
,	O
digfile	array
[	O
1	int
]	O
,	O
sigfile	pointer
,	O
md5dig	array
[	O
1	int
]	O
,	O
sha1dig	array
[	O
1	int
]	O
,	O
filesizefd	array
[	O
1	int
]	O
,	O
sigpipefd	array
[	O
1	int
]	O
,	O
sha512dig	array
[	O
1	int
]	O
,	O
&	O
has_storage_section	int
)	O
;	O
E_DEBUG2	O
(	O
"taruib_write_signedfile_if_i cret=%d"	pointer
,	O
cret	int
)	O
;	O
if	O
(	O
cret	int
<=	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"exiting with value cret=%d"	pointer
,	O
cret	int
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
if	O
(	O
cret	int
==	O
0	int
)	O
_exit	function
(	O
TARUIB_TEXIT_ERROR_CONDITION_0	int
)	O
;	O
else	O
_exit	function
(	O
TARUIB_TEXIT_ERROR_CONDITION_1	int
)	O
;	O
}	O
sigsize	int
=	O
cret	int
;	O
uxfio_fcntl	function
(	O
ifd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_OFF	int
)	O
;	O
if	O
(	O
has_storage_section	int
)	O
{	O
if	O
(	O
xformat_file_has_data	function
(	O
package	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"xformat_file_has_data is true"	pointer
)	O
;	O
E_DEBUG	O
(	O
"into xformat_copy_pass2"	pointer
)	O
;	O
if	O
(	O
xformat_copy_pass2	function
(	O
package	pointer
,	O
digfile	array
[	O
1	int
]	O
,	O
ifd	int
,	O
-	O
1	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" error from xformat_copy_pass2\n"	pointer
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
_exit	function
(	O
TARUIB_TEXIT_ERROR_CONDITION_2	int
)	O
;	O
}	O
E_DEBUG	O
(	O
"out of xformat_copy_pass2"	pointer
)	O
;	O
}	O
}	O
close	pointer
(	O
sigpipefd	array
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
"entering taruib_write_pass_files"	pointer
)	O
;	O
cret	int
=	O
taruib_write_pass_files	function
(	O
vp	pointer
,	O
digfile	array
[	O
1	int
]	O
,	O
-	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"taruib_write_pass_files exited cret=%d"	pointer
,	O
cret	int
)	O
;	O
if	O
(	O
cret	int
<	O
0	int
)	O
_exit	function
(	O
TARUIB_TEXIT_ERROR_CONDITION_3	int
)	O
;	O
E_DEBUG2	O
(	O
"sigsize=%d"	pointer
,	O
sigsize	int
)	O
;	O
if	O
(	O
sigsize	int
==	O
512	int
)	O
_exit	function
(	O
TARUIB_TEXIT_512	int
)	O
;	O
if	O
(	O
sigsize	int
==	O
1024	int
)	O
_exit	function
(	O
TARUIB_TEXIT_1024	int
)	O
;	O
_exit	function
(	O
TARUIB_TEXIT_ERROR_CONDITION_4	int
)	O
;	O
}	O
close	pointer
(	O
filesizefd	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
sha1dig	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
sha512dig	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
md5dig	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
digfile	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
sigpipefd	array
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
calc_sha1digbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
calc_sha512digbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
calc_md5digbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
swlib_digests	function
(	O
digfile	array
[	O
0	int
]	O
,	O
calc_md5digbuf	array
,	O
calc_sha1digbuf	array
,	O
calc_size	array
,	O
calc_sha512digbuf	array
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if: error reading archive data\n"	pointer
)	O
;	O
return	O
15	int
;	O
}	O
md5digbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
sha1digbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
sha512digbuf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
safeio	function
(	O
read	pointer
,	O
md5dig	array
[	O
0	int
]	O
,	O
md5digbuf	array
,	O
513	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii digest loc=1\n"	pointer
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
4	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
(	O
ret	int
>	O
0	int
&&	O
ret	int
<	O
MD5_ASCII_LEN	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii digest loc=2, ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
5	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
safeio	function
(	O
read	pointer
,	O
sha1dig	array
[	O
0	int
]	O
,	O
sha1digbuf	array
,	O
513	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii sha1 digest loc=1\n"	pointer
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
6	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
safeio	function
(	O
read	pointer
,	O
sha512dig	array
[	O
0	int
]	O
,	O
sha512digbuf	array
,	O
513	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii sha512 digest loc=1\n"	pointer
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
10	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
(	O
ret	int
>	O
0	int
&&	O
ret	int
<	O
SHA1_ASCII_LEN	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii sha1 digest loc=2,"	pointer
" ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
7	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
safeio	function
(	O
read	pointer
,	O
filesizefd	array
[	O
0	int
]	O
,	O
sizebuf	array
,	O
513	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii size loc=1\n"	pointer
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
16	int
;	O
}	O
swlib_squash_all_trailing_vnewline	function
(	O
sizebuf	array
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
(	O
ret	int
>	O
0	int
&&	O
ret	int
<	O
30	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading ascii size loc=2,"	pointer
" ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
17	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
memfd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
ret	int
=	O
swlib_pipe_pump	function
(	O
memfd	int
,	O
sigpipefd	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if:"	pointer
" internal error reading sigpipdfd,  ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
return	O
18	int
;	O
}	O
E_DEBUG2	O
(	O
"ret from sigpipefd is [%d]"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
memfd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taruib_write_signedfile_if: internal error : uxfio_lseek\n"	pointer
)	O
;	O
truncate_sigfile	function
(	O
sigfile	pointer
)	O
;	O
return	O
8	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
close	pointer
(	O
sigpipefd	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
digfile	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
md5dig	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
filesizefd	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sha1dig	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sha512dig	array
[	O
0	int
]	O
)	O
;	O
swlib_wait_on_all_pids	function
(	O
pid	int
,	O
1	int
,	O
status	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
[	O
0	int
]	O
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %d exited abnormally : status = %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
pid	int
[	O
0	int
]	O
,	O
status	int
[	O
0	int
]	O
)	O
;	O
return	O
9	int
;	O
}	O
ifret	int
=	O
WEXITSTATUS	O
(	O
status	int
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ifret	int
==	O
TARUIB_TEXIT_NOT_SIGNED	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Package not signed.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
12	int
;	O
}	O
E_DEBUG2	O
(	O
"ifret=%d"	pointer
,	O
ifret	int
)	O
;	O
if	O
(	O
ifret	int
!=	O
TARUIB_TEXIT_512	int
&&	O
ifret	int
!=	O
TARUIB_TEXIT_1024	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: pid[%d] exited with ifret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
pid	int
[	O
0	int
]	O
,	O
ifret	int
)	O
;	O
return	O
13	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ifret	int
==	O
TARUIB_TEXIT_512	int
)	O
sigsize	int
=	O
512	int
;	O
else	O
sigsize	int
=	O
1024	int
;	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"%s: Archive digest: "	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
pri_ret	int
=	O
1	int
;	O
calc_md5digbuf	array
[	O
MD5_ASCII_LEN	int
]	O
=	O
'\0'	O
;	O
md5digbuf	array
[	O
MD5_ASCII_LEN	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strlen	function
(	O
md5digbuf	array
)	O
==	O
MD5_ASCII_LEN	int
&&	O
strncmp	function
(	O
calc_md5digbuf	array
,	O
md5digbuf	array
,	O
MD5_ASCII_LEN	int
)	O
==	O
0	int
)	O
{	O
pri_ret	int
=	O
0	int
;	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"md5 OK (Good)\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
pri_ret	int
=	O
2	int
;	O
if	O
(	O
verbose	int
>=	O
1	int
)	O
{	O
report_dig_error	function
(	O
tmp	pointer
,	O
msgfd	int
,	O
efd	int
,	O
"md5"	pointer
,	O
strlen	function
(	O
md5digbuf	array
)	O
,	O
verbose	int
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"%s: Archive digest: "	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
calc_sha1digbuf	array
[	O
SHA1_ASCII_LEN	int
]	O
=	O
'\0'	O
;	O
sha1digbuf	array
[	O
SHA1_ASCII_LEN	int
]	O
=	O
'\0'	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
sha1digbuf	array
)	O
==	O
SHA1_ASCII_LEN	int
&&	O
strncmp	function
(	O
calc_sha1digbuf	array
,	O
sha1digbuf	array
,	O
SHA1_ASCII_LEN	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"sha1 OK (Good)\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
report_dig_error	function
(	O
tmp	pointer
,	O
msgfd	int
,	O
efd	int
,	O
"sha1"	pointer
,	O
strlen	function
(	O
md5digbuf	array
)	O
,	O
verbose	int
)	O
;	O
if	O
(	O
strlen	function
(	O
sha1digbuf	array
)	O
)	O
{	O
pri_ret	int
=	O
1	int
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"%s: Archive size: "	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
sizebuf	array
)	O
)	O
{	O
int	O
size_failed	int
;	O
char	O
*	O
e	pointer
;	O
size_failed	int
=	O
1	int
;	O
E_DEBUG2	O
(	O
"calc_size is [%s]"	pointer
,	O
calc_size	array
)	O
;	O
actual_read_size	long
=	O
strtoul	function
(	O
calc_size	array
,	O
&	O
e	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
e	pointer
-	O
calc_size	array
)	O
==	O
0	int
||	O
actual_read_size	long
==	O
0	int
)	O
{	O
pri_ret	int
=	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"file size is [%s]"	pointer
,	O
sizebuf	array
)	O
;	O
claimed_size	long
=	O
strtoul	function
(	O
sizebuf	array
,	O
&	O
e	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
e	pointer
-	O
calc_size	array
)	O
==	O
0	int
||	O
claimed_size	long
==	O
0	int
)	O
{	O
pri_ret	int
=	O
1	int
;	O
}	O
if	O
(	O
claimed_size	long
!=	O
actual_read_size	long
)	O
{	O
pri_ret	int
=	O
1	int
;	O
size_failed	int
=	O
1	int
;	O
}	O
else	O
{	O
size_failed	int
=	O
0	int
;	O
}	O
if	O
(	O
size_failed	int
)	O
{	O
if	O
(	O
verbose	int
>=	O
1	int
)	O
{	O
report_dig_error	function
(	O
tmp	pointer
,	O
msgfd	int
,	O
efd	int
,	O
"size"	pointer
,	O
-	O
1	int
,	O
verbose	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"OK (Good)\n"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
verbose	int
>=	O
2	int
)	O
{	O
swlib_writef	function
(	O
efd	int
,	O
tmp	pointer
,	O
"Warning, the package does not contain an archive size attribute.\n"	pointer
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
sha512digbuf	array
[	O
SHA512_ASCII_LEN	int
]	O
=	O
'\0'	O
;	O
calc_sha512digbuf	array
[	O
SHA512_ASCII_LEN	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"%s: Archive digest: "	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
sha512digbuf	array
)	O
==	O
SHA512_ASCII_LEN	int
&&	O
strncmp	function
(	O
calc_sha512digbuf	array
,	O
sha512digbuf	array
,	O
SHA512_ASCII_LEN	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
verbose	int
>=	O
DIG_VERBOSE_LEVEL	O
)	O
{	O
swlib_writef	function
(	O
msgfd	int
,	O
tmp	pointer
,	O
"sha512 OK (Good)\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
strlen	function
(	O
sha512digbuf	array
)	O
)	O
{	O
pri_ret	int
=	O
1	int
;	O
}	O
report_dig_error	function
(	O
tmp	pointer
,	O
msgfd	int
,	O
efd	int
,	O
"sha512"	pointer
,	O
strlen	function
(	O
sha512digbuf	array
)	O
,	O
verbose	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
sigfd	int
=	O
open	function
(	O
sigfile	pointer
,	O
O_RDWR	int
|	O
O_TRUNC	int
|	O
O_CREAT	int
,	O
0600	int
)	O
;	O
if	O
(	O
sigfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"open failed ( %s ) : %s\n"	pointer
,	O
sigfile	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
14	int
;	O
}	O
E_DEBUG2	O
(	O
"whichsig=%d"	pointer
,	O
whichsig	int
)	O
;	O
if	O
(	O
pri_ret	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
do_sig_safety_checks	function
(	O
memfd	int
,	O
sigsize	int
,	O
whichsig	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error reading signature block\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
pri_ret	int
=	O
10	int
;	O
}	O
else	O
{	O
write_selected_sig	function
(	O
sigfd	int
,	O
memfd	int
,	O
whichsig	int
,	O
sigsize	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
close	pointer
(	O
sigfd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_close	function
(	O
memfd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
verbose	int
>=	O
4	int
)	O
{	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: size: %s from archive.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
sizebuf	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: size: %s calculated.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
calc_size	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: md5: %s from archive.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
md5digbuf	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: md5: %s calculated.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
calc_md5digbuf	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: sha1: %s from archive.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
sha1digbuf	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: sha1: %s calculated.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
calc_sha1digbuf	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: sha512: %s from archive.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
sha512digbuf	array
)	O
;	O
swlib_writef	function
(	O
logger_fd	int
,	O
tmp	pointer
,	O
"%s: sha512: %s calculated.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
calc_sha512digbuf	array
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
0	int
,	O
UXFIO_SEEK_VSET	int
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"uxfio_lseek error loc=3 ret=%d\n"	pointer
,	O
ret	int
)	O
;	O
return	O
10	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_fcntl	function
(	O
ifd	int
,	O
UXFIO_F_ARM_AUTO_DISABLE	O
,	O
1	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
taruib_write_catalog_stream	function
(	O
vp	pointer
,	O
ofd	int
,	O
1	int
,	O
0	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<=	O
0	int
)	O
{	O
pri_ret	int
=	O
9	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
verbose	int
>	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: md5: %s from archive.\n"	pointer
,	O
md5digbuf	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: md5: %s calculated.\n"	pointer
,	O
calc_md5digbuf	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: sha1: %s from archive.\n"	pointer
,	O
sha1digbuf	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: sha1: %s calculated.\n"	pointer
,	O
calc_sha1digbuf	array
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
close	pointer
(	O
sigfd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_close	function
(	O
memfd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
pri_ret	int
)	O
;	O
return	O
pri_ret	int
;	O
}	O
