int	O
nperopens	int
;	O
struct	O
async_req	struct
{	O
mach_port_t	int
notify	int
;	O
struct	O
async_req	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
async_req	struct
*	O
async_requests	pointer
;	O
static	O
int	O
num_icky_async_peropens	int
=	O
0	int
;	O
mach_port_t	int
async_icky_id	int
;	O
mach_port_t	int
async_id	int
;	O
struct	O
port_info	O
*	O
cttyid	pointer
;	O
int	O
foreground_id	int
;	O
struct	O
winsize	O
window_size	struct
;	O
static	O
int	O
sigs_in_progress	int
;	O
static	O
pthread_cond_t	union
input_sig_wait	union
=	O
PTHREAD_COND_INITIALIZER	O
;	O
static	O
int	O
input_sig_wakeup	int
;	O
static	O
error_t	int
carrier_error	int
;	O
struct	O
protid_hook	struct
{	O
int	O
refcnt	int
;	O
pid_t	int
pid	int
,	O
pgrp	int
,	O
sid	int
;	O
}	O
;	O
void	O
init_users	function
(	O
)	O
{	O
error_t	int
err	int
;	O
err	int
=	O
ports_create_port	function
(	O
cttyid_class	pointer
,	O
term_bucket	pointer
,	O
sizeof	O
(	O
struct	O
port_info	O
)	O
,	O
&	O
cttyid	pointer
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
1	int
,	O
err	int
,	O
"Allocating cttyid"	pointer
)	O
;	O
mach_port_allocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
async_icky_id	int
)	O
;	O
mach_port_insert_right	function
(	O
mach_task_self	function
(	O
)	O
,	O
async_icky_id	int
,	O
async_icky_id	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
mach_port_allocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
async_id	int
)	O
;	O
mach_port_insert_right	function
(	O
mach_task_self	function
(	O
)	O
,	O
async_id	int
,	O
async_id	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
}	O
static	O
error_t	int
check_access_hook	function
(	O
struct	O
trivfs_control	O
*	O
cntl	pointer
,	O
struct	O
iouser	O
*	O
user	pointer
,	O
mach_port_t	int
realnode	int
,	O
int	O
*	O
allowed	pointer
)	O
{	O
struct	O
stat	O
st	struct
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
st	struct
.	O
st_mode	O
=	O
term_mode	int
;	O
*	O
allowed	pointer
=	O
0	int
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
st	struct
,	O
S_IREAD	O
,	O
user	pointer
)	O
==	O
0	int
)	O
*	O
allowed	pointer
|=	O
O_READ	O
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
st	struct
,	O
S_IWRITE	O
,	O
user	pointer
)	O
==	O
0	int
)	O
*	O
allowed	pointer
|=	O
O_WRITE	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_check_access_hook	pointer
)	O
(	O
struct	O
trivfs_control	O
*	O
,	O
struct	O
iouser	O
*	O
,	O
mach_port_t	int
,	O
int	O
*	O
)	O
=	O
check_access_hook	function
;	O
static	O
error_t	int
open_hook	function
(	O
struct	O
trivfs_control	O
*	O
cntl	pointer
,	O
struct	O
iouser	O
*	O
user	pointer
,	O
int	O
flags	int
)	O
{	O
static	O
int	O
open_count	int
=	O
0	int
;	O
int	O
cancel	int
=	O
0	int
;	O
error_t	int
err	int
;	O
if	O
(	O
cntl	pointer
==	O
ptyctl	pointer
)	O
return	O
pty_open_hook	function
(	O
cntl	pointer
,	O
user	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
TTY_OPEN	int
)	O
)	O
{	O
memset	O
(	O
&	O
termstate	struct
,	O
0	int
,	O
sizeof	O
termstate	struct
)	O
;	O
termstate	struct
.	O
c_iflag	O
|=	O
BRKINT	O
|	O
ICRNL	O
|	O
IMAXBEL	O
|	O
IXON	O
|	O
IXANY	O
;	O
termstate	struct
.	O
c_oflag	O
|=	O
OPOST	O
|	O
ONLCR	O
|	O
OXTABS	O
;	O
termstate	struct
.	O
c_lflag	O
|=	O
(	O
ECHO	O
|	O
ICANON	O
|	O
ISIG	O
|	O
IEXTEN	O
|	O
ECHOE	O
|	O
ECHOKE	O
|	O
ECHOCTL	O
)	O
;	O
termstate	struct
.	O
c_cflag	O
|=	O
CREAD	O
|	O
CS8	O
|	O
HUPCL	O
;	O
memcpy	O
(	O
termstate	struct
.	O
c_cc	O
,	O
ttydefchars	O
,	O
NCCS	O
)	O
;	O
memset	O
(	O
&	O
window_size	struct
,	O
0	int
,	O
sizeof	O
window_size	struct
)	O
;	O
termflags	long
|=	O
NO_OWNER	int
;	O
}	O
else	O
{	O
assert	O
(	O
open_count	int
>	O
0	int
)	O
;	O
if	O
(	O
termflags	long
&	O
EXCL_USE	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBUSY	int
;	O
}	O
}	O
open_count	int
++	O
;	O
if	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
{	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
assert_dtr	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
}	O
while	O
(	O
(	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
&&	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
&&	O
!	O
(	O
flags	int
&	O
O_NONBLOCK	int
)	O
&&	O
!	O
cancel	int
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	function
(	O
&	O
carrier_alert	union
,	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
cancel	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EINTR	int
;	O
}	O
err	int
=	O
carrier_error	int
;	O
carrier_error	int
=	O
0	int
;	O
if	O
(	O
!	O
err	int
)	O
{	O
struct	O
termios	O
state	pointer
=	O
termstate	struct
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
set_bits	pointer
)	O
(	O
&	O
state	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
termstate	struct
=	O
state	pointer
;	O
termflags	long
|=	O
TTY_OPEN	int
;	O
}	O
if	O
(	O
bottom	pointer
->	O
gwinsz	pointer
)	O
(	O
*	O
bottom	pointer
->	O
gwinsz	pointer
)	O
(	O
&	O
window_size	struct
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_check_open_hook	pointer
)	O
(	O
struct	O
trivfs_control	O
*	O
,	O
struct	O
iouser	O
*	O
,	O
int	O
)	O
=	O
open_hook	function
;	O
static	O
error_t	int
pi_create_hook	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
return	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
cred	pointer
->	O
hook	pointer
)	O
(	O
(	O
struct	O
protid_hook	struct
*	O
)	O
cred	pointer
->	O
hook	pointer
)	O
->	O
refcnt	int
++	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_protid_create_hook	pointer
)	O
(	O
struct	O
trivfs_protid	O
*	O
)	O
=	O
pi_create_hook	function
;	O
static	O
void	O
pi_destroy_hook	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
return	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
cred	pointer
->	O
hook	pointer
)	O
{	O
assert	O
(	O
(	O
(	O
struct	O
protid_hook	struct
*	O
)	O
cred	pointer
->	O
hook	pointer
)	O
->	O
refcnt	int
>	O
0	int
)	O
;	O
if	O
(	O
--	O
(	O
(	O
struct	O
protid_hook	struct
*	O
)	O
cred	pointer
->	O
hook	pointer
)	O
->	O
refcnt	int
==	O
0	int
)	O
free	function
(	O
cred	pointer
->	O
hook	pointer
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
}	O
void	O
(	O
*	O
trivfs_protid_destroy_hook	pointer
)	O
(	O
struct	O
trivfs_protid	O
*	O
)	O
=	O
pi_destroy_hook	function
;	O
static	O
error_t	int
po_create_hook	function
(	O
struct	O
trivfs_peropen	O
*	O
po	pointer
)	O
{	O
if	O
(	O
po	pointer
->	O
cntl	pointer
==	O
ptyctl	pointer
)	O
return	O
pty_po_create_hook	function
(	O
po	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
nperopens	int
++	O
;	O
if	O
(	O
po	pointer
->	O
openmodes	O
&	O
O_ASYNC	int
)	O
{	O
termflags	long
|=	O
ICKY_ASYNC	int
;	O
num_icky_async_peropens	int
++	O
;	O
call_asyncs	function
(	O
O_READ	O
|	O
O_WRITE	O
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
(	O
*	O
trivfs_peropen_create_hook	pointer
)	O
(	O
struct	O
trivfs_peropen	O
*	O
)	O
=	O
po_create_hook	function
;	O
static	O
void	O
po_destroy_hook	function
(	O
struct	O
trivfs_peropen	O
*	O
po	pointer
)	O
{	O
if	O
(	O
po	pointer
->	O
cntl	pointer
==	O
ptyctl	pointer
)	O
{	O
pty_po_destroy_hook	function
(	O
po	pointer
)	O
;	O
return	O
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
(	O
po	pointer
->	O
openmodes	O
&	O
O_ASYNC	int
)	O
&&	O
--	O
num_icky_async_peropens	int
==	O
0	int
)	O
termflags	long
&=	O
~	O
ICKY_ASYNC	int
;	O
nperopens	int
--	O
;	O
if	O
(	O
!	O
nperopens	int
&&	O
(	O
termflags	long
&	O
TTY_OPEN	int
)	O
)	O
{	O
clear_queue	function
(	O
inputq	pointer
)	O
;	O
clear_queue	function
(	O
rawq	pointer
)	O
;	O
(	O
*	O
bottom	pointer
->	O
notice_input_flushed	pointer
)	O
(	O
)	O
;	O
drain_output	function
(	O
)	O
;	O
if	O
(	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
HUPCL	O
)	O
||	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
)	O
(	O
*	O
bottom	pointer
->	O
desert_dtr	pointer
)	O
(	O
)	O
;	O
termflags	long
&=	O
~	O
TTY_OPEN	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
}	O
void	O
(	O
*	O
trivfs_peropen_destroy_hook	pointer
)	O
(	O
struct	O
trivfs_peropen	O
*	O
)	O
=	O
po_destroy_hook	function
;	O
static	O
inline	O
int	O
fg_p	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
struct	O
protid_hook	struct
*	O
hook	pointer
=	O
cred	pointer
->	O
hook	pointer
;	O
if	O
(	O
!	O
hook	pointer
||	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
hook	pointer
->	O
pid	int
==	O
foreground_id	int
||	O
hook	pointer
->	O
pgrp	int
==	O
-	O
foreground_id	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
trivfs_modify_stat	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
struct	O
stat	O
*	O
st	struct
)	O
{	O
st	struct
->	O
st_blksize	O
=	O
512	int
;	O
st	struct
->	O
st_fstype	O
=	O
FSTYPE_TERM	O
;	O
st	struct
->	O
st_fsid	O
=	O
getpid	function
(	O
)	O
;	O
st	struct
->	O
st_ino	O
=	O
0	int
;	O
st	struct
->	O
st_rdev	O
=	O
rdev	long
;	O
st	struct
->	O
st_mode	O
=	O
term_mode	int
;	O
st	struct
->	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
->	O
st_gid	O
=	O
term_group	int
;	O
}	O
kern_return_t	O
S_term_getctty	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
*	O
id	pointer
,	O
mach_msg_type_name_t	O
*	O
idtype	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
*	O
id	pointer
=	O
ports_get_right	function
(	O
cttyid	pointer
)	O
;	O
*	O
idtype	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_termctty_open_terminal	function
(	O
struct	O
port_info	O
*	O
pi	pointer
,	O
int	O
flags	int
,	O
mach_port_t	int
*	O
result	pointer
,	O
mach_msg_type_name_t	O
*	O
resulttype	pointer
)	O
{	O
error_t	int
err	int
;	O
mach_port_t	int
new_realnode	O
;	O
struct	O
iouser	O
*	O
user	pointer
;	O
struct	O
trivfs_protid	O
*	O
newcred	pointer
;	O
if	O
(	O
!	O
pi	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
assert	O
(	O
pi	pointer
==	O
cttyid	pointer
)	O
;	O
err	int
=	O
io_restrict_auth	function
(	O
termctl	pointer
->	O
underlying	O
,	O
&	O
new_realnode	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
err	int
=	O
iohelp_create_empty_iouser	function
(	O
&	O
user	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
trivfs_open	function
(	O
termctl	pointer
,	O
user	pointer
,	O
flags	int
,	O
new_realnode	O
,	O
&	O
newcred	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
*	O
result	pointer
=	O
ports_get_right	function
(	O
newcred	pointer
)	O
;	O
*	O
resulttype	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	function
(	O
newcred	pointer
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_term_open_ctty	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
pid_t	int
pid	int
,	O
pid_t	int
pgrp	int
,	O
mach_port_t	int
*	O
newpt	pointer
,	O
mach_msg_type_name_t	O
*	O
newpttype	pointer
)	O
{	O
error_t	int
err	int
;	O
struct	O
trivfs_protid	O
*	O
newcred	pointer
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
pid	int
<=	O
0	int
||	O
pgrp	int
<=	O
0	int
)	O
{	O
return	O
EINVAL	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
err	int
=	O
EBADF	int
;	O
}	O
else	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
err	int
=	O
trivfs_protid_dup	function
(	O
cred	pointer
,	O
&	O
newcred	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
struct	O
protid_hook	struct
*	O
hook	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
protid_hook	struct
)	O
)	O
;	O
hook	pointer
->	O
pid	int
=	O
pid	int
;	O
hook	pointer
->	O
pgrp	int
=	O
pgrp	int
;	O
hook	pointer
->	O
sid	int
=	O
getsid	function
(	O
pid	int
)	O
;	O
hook	pointer
->	O
refcnt	int
=	O
1	int
;	O
if	O
(	O
newcred	pointer
->	O
hook	pointer
)	O
pi_destroy_hook	function
(	O
newcred	pointer
)	O
;	O
newcred	pointer
->	O
hook	pointer
=	O
hook	pointer
;	O
*	O
newpt	pointer
=	O
ports_get_right	function
(	O
newcred	pointer
)	O
;	O
*	O
newpttype	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	function
(	O
newcred	pointer
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_file_chown	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
struct	O
stat	O
st	struct
;	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
if	O
(	O
!	O
cred	pointer
->	O
isroot	O
)	O
{	O
err	int
=	O
fshelp_isowner	function
(	O
&	O
st	struct
,	O
cred	pointer
->	O
user	pointer
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
if	O
(	O
(	O
uid	int
!=	O
(	O
uid_t	int
)	O
-	O
1	int
&&	O
!	O
idvec_contains	function
(	O
cred	pointer
->	O
user	pointer
->	O
uids	O
,	O
uid	int
)	O
)	O
||	O
(	O
gid	int
!=	O
(	O
gid_t	int
)	O
-	O
1	int
&&	O
!	O
idvec_contains	function
(	O
cred	pointer
->	O
user	pointer
->	O
gids	O
,	O
gid	int
)	O
)	O
)	O
{	O
err	int
=	O
EPERM	int
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
uid	int
!=	O
(	O
uid_t	int
)	O
-	O
1	int
)	O
term_owner	int
=	O
uid	int
;	O
if	O
(	O
gid	int
!=	O
(	O
gid_t	int
)	O
-	O
1	int
)	O
term_group	int
=	O
gid	int
;	O
err	int
=	O
0	int
;	O
out	O
:	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_file_chmod	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mode_t	int
mode	int
)	O
{	O
error_t	int
err	int
;	O
struct	O
stat	O
st	struct
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
cred	pointer
->	O
isroot	O
)	O
{	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
err	int
=	O
fshelp_isowner	function
(	O
&	O
st	struct
,	O
cred	pointer
->	O
user	pointer
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
mode	int
&=	O
~	O
S_ISVTX	O
;	O
if	O
(	O
!	O
idvec_contains	function
(	O
cred	pointer
->	O
user	pointer
->	O
uids	O
,	O
term_owner	int
)	O
)	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
if	O
(	O
!	O
idvec_contains	function
(	O
cred	pointer
->	O
user	pointer
->	O
gids	O
,	O
term_group	int
)	O
)	O
mode	int
&=	O
~	O
S_ISUID	O
;	O
}	O
term_mode	int
=	O
(	O
(	O
mode	int
&	O
~	O
S_IFMT	O
&	O
~	O
S_ITRANS	O
&	O
~	O
S_ISPARE	O
)	O
|	O
S_IFCHR	O
|	O
S_IROOT	O
)	O
;	O
err	int
=	O
0	int
;	O
out	O
:	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_io_write	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
char	O
*	O
data	pointer
,	O
size_t	long
datalen	long
,	O
loff_t	long
offset	long
,	O
size_t	long
*	O
amt	pointer
)	O
{	O
int	O
i	int
;	O
int	O
cancel	int
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
return	O
pty_io_write	function
(	O
cred	pointer
,	O
data	pointer
,	O
datalen	long
,	O
amt	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
if	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
TOSTOP	O
)	O
&&	O
!	O
fg_p	function
(	O
cred	pointer
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBACKGROUND	O
;	O
}	O
if	O
(	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
&&	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EIO	int
;	O
}	O
cancel	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
datalen	long
;	O
i	int
++	O
)	O
{	O
while	O
(	O
!	O
qavail	function
(	O
outputq	pointer
)	O
&&	O
!	O
cancel	int
)	O
{	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
start_output	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
cancel	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
!	O
qavail	function
(	O
outputq	pointer
)	O
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	function
(	O
outputq	pointer
->	O
wait	pointer
,	O
&	O
global_lock	union
)	O
;	O
}	O
}	O
if	O
(	O
cancel	int
)	O
break	O
;	O
write_character	function
(	O
data	pointer
[	O
i	int
]	O
)	O
;	O
}	O
*	O
amt	pointer
=	O
i	int
;	O
if	O
(	O
!	O
err	int
&&	O
datalen	long
)	O
(	O
*	O
bottom	pointer
->	O
start_output	pointer
)	O
(	O
)	O
;	O
trivfs_set_mtime	function
(	O
termctl	pointer
)	O
;	O
call_asyncs	function
(	O
O_WRITE	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
(	O
(	O
cancel	int
&&	O
datalen	long
&&	O
!	O
*	O
amt	pointer
)	O
?	O
(	O
err	int
?	O
:	O
EINTR	int
)	O
:	O
0	int
)	O
;	O
}	O
error_t	int
trivfs_S_io_read	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
char	O
*	O
*	O
data	pointer
,	O
size_t	long
*	O
datalen	long
,	O
loff_t	long
offset	long
,	O
size_t	long
amount	long
)	O
{	O
int	O
cancel	int
;	O
int	O
i	int
,	O
max	int
;	O
char	O
*	O
cp	pointer
;	O
int	O
avail	int
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
return	O
pty_io_read	function
(	O
cred	pointer
,	O
data	pointer
,	O
datalen	long
,	O
amount	long
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
if	O
(	O
!	O
fg_p	function
(	O
cred	pointer
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBACKGROUND	O
;	O
}	O
while	O
(	O
!	O
qsize	function
(	O
inputq	pointer
)	O
)	O
{	O
if	O
(	O
(	O
(	O
termflags	long
&	O
NO_CARRIER	int
)	O
&&	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
||	O
!	O
amount	long
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
*	O
datalen	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_NONBLOCK	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EWOULDBLOCK	O
;	O
}	O
if	O
(	O
pthread_hurd_cond_wait_np	function
(	O
inputq	pointer
->	O
wait	pointer
,	O
&	O
global_lock	union
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EINTR	int
;	O
}	O
if	O
(	O
sigs_in_progress	int
)	O
{	O
input_sig_wakeup	int
++	O
;	O
if	O
(	O
pthread_hurd_cond_wait_np	function
(	O
&	O
input_sig_wait	union
,	O
&	O
global_lock	union
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EINTR	int
;	O
}	O
}	O
}	O
avail	int
=	O
qsize	function
(	O
inputq	pointer
)	O
;	O
if	O
(	O
remote_input_mode	int
)	O
avail	int
--	O
;	O
max	int
=	O
(	O
amount	long
<	O
avail	int
)	O
?	O
amount	long
:	O
avail	int
;	O
if	O
(	O
max	int
>	O
*	O
datalen	long
)	O
*	O
data	pointer
=	O
mmap	function
(	O
0	int
,	O
max	int
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
cancel	int
=	O
0	int
;	O
cp	pointer
=	O
*	O
data	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max	int
;	O
i	int
++	O
)	O
{	O
char	O
c	short
=	O
dequeue	function
(	O
inputq	pointer
)	O
;	O
if	O
(	O
remote_input_mode	int
)	O
*	O
cp	pointer
++	O
=	O
c	short
;	O
else	O
{	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
||	O
!	O
CCEQ	function
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOF	O
]	O
,	O
c	short
)	O
)	O
*	O
cp	pointer
++	O
=	O
c	short
;	O
if	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
&&	O
(	O
c	short
==	O
'\n'	O
||	O
CCEQ	function
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOF	O
]	O
,	O
c	short
)	O
||	O
CCEQ	function
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOL	O
]	O
,	O
c	short
)	O
||	O
CCEQ	function
(	O
termstate	struct
.	O
c_cc	O
[	O
VEOL2	O
]	O
,	O
c	short
)	O
)	O
)	O
break	O
;	O
if	O
(	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ISIG	O
)	O
&&	O
CCEQ	function
(	O
termstate	struct
.	O
c_cc	O
[	O
VDSUSP	O
]	O
,	O
c	short
)	O
)	O
{	O
send_signal	function
(	O
SIGTSTP	O
)	O
;	O
cancel	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
remote_input_mode	int
&&	O
qsize	function
(	O
inputq	pointer
)	O
==	O
1	int
)	O
dequeue	function
(	O
inputq	pointer
)	O
;	O
*	O
datalen	long
=	O
cp	pointer
-	O
*	O
data	pointer
;	O
if	O
(	O
*	O
datalen	long
||	O
!	O
cancel	int
)	O
trivfs_set_atime	function
(	O
termctl	pointer
)	O
;	O
call_asyncs	function
(	O
O_READ	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
!	O
*	O
datalen	long
&&	O
cancel	int
?	O
EINTR	int
:	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_pathconf	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
name	int
,	O
int	O
*	O
val	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
switch	O
(	O
name	int
)	O
{	O
case	O
_PC_LINK_MAX	O
:	O
case	O
_PC_NAME_MAX	O
:	O
case	O
_PC_PATH_MAX	O
:	O
case	O
_PC_PIPE_BUF	O
:	O
case	O
_PC_NO_TRUNC	O
:	O
default	O
:	O
return	O
io_pathconf	function
(	O
cred	pointer
->	O
realnode	int
,	O
name	int
,	O
val	pointer
)	O
;	O
case	O
_PC_MAX_CANON	O
:	O
*	O
val	pointer
=	O
rawq	pointer
->	O
hiwat	int
;	O
return	O
0	int
;	O
case	O
_PC_MAX_INPUT	O
:	O
*	O
val	pointer
=	O
inputq	pointer
->	O
hiwat	int
;	O
return	O
0	int
;	O
case	O
_PC_CHOWN_RESTRICTED	O
:	O
*	O
val	pointer
=	O
1	int
;	O
return	O
0	int
;	O
case	O
_PC_VDISABLE	O
:	O
*	O
val	pointer
=	O
_POSIX_VDISABLE	O
;	O
return	O
0	int
;	O
}	O
}	O
error_t	int
trivfs_S_io_readable	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
size_t	long
*	O
amt	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
return	O
pty_io_readable	function
(	O
amt	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
*	O
amt	pointer
=	O
qsize	function
(	O
inputq	pointer
)	O
;	O
if	O
(	O
remote_input_mode	int
&&	O
*	O
amt	pointer
)	O
--	O
*	O
amt	pointer
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_revoke	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
)	O
{	O
struct	O
stat	O
st	struct
;	O
error_t	int
iterator_function	O
(	O
void	O
*	O
port	pointer
)	O
{	O
struct	O
trivfs_protid	O
*	O
user	pointer
=	O
port	pointer
;	O
if	O
(	O
user	pointer
!=	O
cred	pointer
)	O
ports_destroy_right	O
(	O
user	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
cred	pointer
->	O
isroot	O
)	O
{	O
error_t	int
err	int
;	O
st	struct
.	O
st_uid	O
=	O
term_owner	int
;	O
st	struct
.	O
st_gid	O
=	O
term_group	int
;	O
err	int
=	O
fshelp_isowner	function
(	O
&	O
st	struct
,	O
cred	pointer
->	O
user	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
ports_inhibit_bucket_rpcs	function
(	O
term_bucket	pointer
)	O
;	O
ports_class_iterate	function
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
,	O
iterator_function	O
)	O
;	O
ports_resume_bucket_rpcs	function
(	O
term_bucket	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmodg	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
*	O
state	pointer
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmstate	pointer
)	O
(	O
state	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmods	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
state	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmctl	pointer
)	O
(	O
MDMCTL_SET	int
,	O
state	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocexcl	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
termflags	long
|=	O
EXCL_USE	int
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocnxcl	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
termflags	long
&=	O
~	O
EXCL_USE	int
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocflush	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
flags	int
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
if	O
(	O
flags	int
==	O
0	int
)	O
flags	int
=	O
O_READ	O
|	O
O_WRITE	O
;	O
if	O
(	O
flags	int
&	O
O_READ	O
)	O
{	O
(	O
*	O
bottom	pointer
->	O
notice_input_flushed	pointer
)	O
(	O
)	O
;	O
clear_queue	function
(	O
inputq	pointer
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
(	O
flags	int
&	O
O_WRITE	O
)	O
)	O
err	int
=	O
drop_output	function
(	O
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocgeta	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	pointer
,	O
speed_t	O
*	O
speeds	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
modes	int
[	O
0	int
]	O
=	O
termstate	struct
.	O
c_iflag	O
;	O
modes	int
[	O
1	int
]	O
=	O
termstate	struct
.	O
c_oflag	O
;	O
modes	int
[	O
2	int
]	O
=	O
termstate	struct
.	O
c_cflag	O
;	O
modes	int
[	O
3	int
]	O
=	O
termstate	struct
.	O
c_lflag	O
;	O
memcpy	O
(	O
ccs	pointer
,	O
termstate	struct
.	O
c_cc	O
,	O
NCCS	O
)	O
;	O
speeds	pointer
[	O
0	int
]	O
=	O
termstate	struct
.	O
__ispeed	O
;	O
speeds	pointer
[	O
1	int
]	O
=	O
termstate	struct
.	O
__ospeed	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
set_state	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	pointer
,	O
speed_t	O
*	O
speeds	pointer
,	O
int	O
draino	int
,	O
int	O
flushi	int
)	O
{	O
error_t	int
err	int
;	O
struct	O
termios	O
state	pointer
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
if	O
(	O
!	O
fg_p	function
(	O
cred	pointer
)	O
)	O
err	int
=	O
EBACKGROUND	O
;	O
else	O
{	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
{	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
abandon_physical_output	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
leave	O
;	O
clear_queue	function
(	O
outputq	pointer
)	O
;	O
}	O
if	O
(	O
draino	int
)	O
{	O
err	int
=	O
drain_output	function
(	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
leave	O
;	O
}	O
if	O
(	O
flushi	int
)	O
{	O
(	O
*	O
bottom	pointer
->	O
notice_input_flushed	pointer
)	O
(	O
)	O
;	O
clear_queue	function
(	O
inputq	pointer
)	O
;	O
}	O
state	pointer
=	O
termstate	struct
;	O
state	pointer
.	O
c_iflag	O
=	O
modes	int
[	O
0	int
]	O
;	O
state	pointer
.	O
c_oflag	O
=	O
modes	int
[	O
1	int
]	O
;	O
state	pointer
.	O
c_cflag	O
=	O
modes	int
[	O
2	int
]	O
;	O
state	pointer
.	O
c_lflag	O
=	O
modes	int
[	O
3	int
]	O
;	O
memcpy	O
(	O
state	pointer
.	O
c_cc	O
,	O
ccs	pointer
,	O
NCCS	O
)	O
;	O
state	pointer
.	O
__ispeed	O
=	O
speeds	pointer
[	O
0	int
]	O
;	O
state	pointer
.	O
__ospeed	O
=	O
speeds	pointer
[	O
1	int
]	O
;	O
if	O
(	O
external_processing	int
)	O
state	pointer
.	O
c_lflag	O
|=	O
EXTPROC	O
;	O
else	O
state	pointer
.	O
c_lflag	O
&=	O
~	O
EXTPROC	O
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
set_bits	pointer
)	O
(	O
&	O
state	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
int	O
oldlflag	int
=	O
termstate	struct
.	O
c_lflag	O
;	O
termstate	struct
=	O
state	pointer
;	O
if	O
(	O
oldlflag	int
&	O
ICANON	O
)	O
{	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
)	O
copy_rawq	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
termstate	struct
.	O
c_lflag	O
&	O
ICANON	O
)	O
rescan_inputq	function
(	O
)	O
;	O
}	O
}	O
err	int
=	O
0	int
;	O
}	O
leave	O
:	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocseta	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	pointer
,	O
speed_t	O
*	O
speeds	pointer
)	O
{	O
return	O
set_state	function
(	O
cred	pointer
,	O
modes	int
,	O
ccs	pointer
,	O
speeds	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
kern_return_t	O
S_tioctl_tiocsetaw	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	pointer
,	O
speed_t	O
*	O
speeds	pointer
)	O
{	O
return	O
set_state	function
(	O
cred	pointer
,	O
modes	int
,	O
ccs	pointer
,	O
speeds	pointer
,	O
1	int
,	O
0	int
)	O
;	O
}	O
kern_return_t	O
S_tioctl_tiocsetaf	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
tcflag_t	O
*	O
modes	int
,	O
cc_t	O
*	O
ccs	pointer
,	O
speed_t	O
*	O
speeds	pointer
)	O
{	O
return	O
set_state	function
(	O
cred	pointer
,	O
modes	int
,	O
ccs	pointer
,	O
speeds	pointer
,	O
1	int
,	O
1	int
)	O
;	O
}	O
kern_return_t	O
S_tioctl_tiocgetd	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
*	O
disc	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
*	O
disc	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsetd	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
disc	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
disc	pointer
!=	O
0	int
)	O
err	int
=	O
ENXIO	int
;	O
else	O
err	int
=	O
0	int
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocdrain	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_WRITE	O
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
err	int
=	O
drain_output	function
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocswinsz	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
struct	O
winsize	O
size	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
0	int
;	O
if	O
(	O
!	O
err	int
&&	O
(	O
size	pointer
.	O
ws_row	O
!=	O
window_size	struct
.	O
ws_row	O
||	O
size	pointer
.	O
ws_col	O
!=	O
window_size	struct
.	O
ws_col	O
||	O
size	pointer
.	O
ws_xpixel	O
!=	O
window_size	struct
.	O
ws_xpixel	O
||	O
size	pointer
.	O
ws_ypixel	O
!=	O
window_size	struct
.	O
ws_ypixel	O
)	O
)	O
{	O
window_size	struct
=	O
size	pointer
;	O
send_signal	function
(	O
SIGWINCH	O
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocgwinsz	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
struct	O
winsize	O
*	O
size	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
*	O
size	pointer
=	O
window_size	struct
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmget	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
*	O
bits	int
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmstate	pointer
)	O
(	O
bits	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmset	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmctl	pointer
)	O
(	O
MDMCTL_SET	int
,	O
bits	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmbic	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmctl	pointer
)	O
(	O
MDMCTL_BIC	int
,	O
bits	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocmbis	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmctl	pointer
)	O
(	O
MDMCTL_BIS	int
,	O
bits	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocstart	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
int	O
old_termflags	int
=	O
termflags	long
;	O
termflags	long
&=	O
~	O
USER_OUTPUT_SUSP	int
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
start_output	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
termflags	long
=	O
old_termflags	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocstop	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
int	O
old_termflags	int
=	O
termflags	long
;	O
termflags	long
|=	O
USER_OUTPUT_SUSP	int
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
suspend_physical_output	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
termflags	long
=	O
old_termflags	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsti	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
char	O
c	short
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_READ	O
)	O
)	O
err	int
=	O
EPERM	int
;	O
else	O
{	O
input_character	function
(	O
c	short
)	O
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocoutq	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
*	O
queue_size	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
*	O
queue_size	pointer
=	O
qsize	function
(	O
outputq	pointer
)	O
+	O
(	O
*	O
bottom	pointer
->	O
pending_output_size	pointer
)	O
(	O
)	O
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocspgrp	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
pgrp	int
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
{	O
termflags	long
&=	O
~	O
NO_OWNER	int
;	O
foreground_id	int
=	O
-	O
pgrp	int
;	O
err	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocgpgrp	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
*	O
pgrp	int
)	O
{	O
error_t	int
ret	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
ret	int
=	O
ENOTTY	int
;	O
else	O
{	O
*	O
pgrp	int
=	O
-	O
foreground_id	int
;	O
ret	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
ret	int
;	O
}	O
kern_return_t	O
S_tioctl_tioccdtr	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmctl	pointer
)	O
(	O
MDMCTL_BIC	int
,	O
TIOCM_DTR	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsdtr	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
mdmctl	pointer
)	O
(	O
MDMCTL_BIS	int
,	O
TIOCM_DTR	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tioccbrk	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
clear_break	pointer
)	O
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_tioctl_tiocsbrk	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
)	O
{	O
error_t	int
err	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
err	int
=	O
EBADF	int
;	O
else	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
set_break	pointer
)	O
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
trivfs_S_file_set_size	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
off_t	long
size	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
else	O
if	O
(	O
size	pointer
<	O
0	int
)	O
return	O
EINVAL	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_seek	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
off_t	long
off	long
,	O
int	O
whence	int
,	O
off_t	long
*	O
newp	pointer
)	O
{	O
return	O
ESPIPE	int
;	O
}	O
error_t	int
trivfs_S_io_get_openmodes	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
int	O
*	O
bits	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
*	O
bits	int
=	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_set_all_openmodes	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
int	O
bits	int
)	O
{	O
int	O
obits	int
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
obits	int
=	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
;	O
if	O
(	O
(	O
obits	int
&	O
O_ASYNC	int
)	O
&&	O
--	O
num_icky_async_peropens	int
==	O
0	int
)	O
termflags	long
&=	O
~	O
ICKY_ASYNC	int
;	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&=	O
~	O
HONORED_STATE_MODES	O
;	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
|=	O
(	O
bits	int
&	O
HONORED_STATE_MODES	O
)	O
;	O
if	O
(	O
(	O
bits	int
&	O
O_ASYNC	int
)	O
&&	O
!	O
(	O
obits	int
&	O
O_ASYNC	int
)	O
)	O
{	O
termflags	long
|=	O
ICKY_ASYNC	int
;	O
num_icky_async_peropens	int
++	O
;	O
call_asyncs	function
(	O
O_READ	O
|	O
O_WRITE	O
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_set_some_openmodes	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
bits	int
)	O
{	O
int	O
obits	int
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
obits	int
=	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
;	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
|=	O
(	O
bits	int
&	O
HONORED_STATE_MODES	O
)	O
;	O
if	O
(	O
(	O
bits	int
&	O
O_ASYNC	int
)	O
&&	O
!	O
(	O
obits	int
&	O
O_ASYNC	int
)	O
)	O
{	O
termflags	long
|=	O
ICKY_ASYNC	int
;	O
num_icky_async_peropens	int
++	O
;	O
call_asyncs	function
(	O
O_READ	O
|	O
O_WRITE	O
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_clear_some_openmodes	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
bits	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_ASYNC	int
)	O
&&	O
--	O
num_icky_async_peropens	int
==	O
0	int
)	O
termflags	long
&=	O
~	O
ICKY_ASYNC	int
;	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&=	O
~	O
(	O
bits	int
&	O
HONORED_STATE_MODES	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_mod_owner	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
pid_t	int
owner	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
termflags	long
&=	O
~	O
NO_OWNER	int
;	O
foreground_id	int
=	O
owner	int
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_get_owner	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
erply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
pid_t	int
*	O
owner	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
ENOTTY	int
;	O
}	O
*	O
owner	int
=	O
foreground_id	int
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_get_icky_async_id	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mach_port_t	int
*	O
id	pointer
,	O
mach_msg_type_name_t	O
*	O
idtype	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
*	O
id	pointer
=	O
async_icky_id	int
;	O
*	O
idtype	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
error_t	int
trivfs_S_io_async	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mach_port_t	int
notify	int
,	O
mach_port_t	int
*	O
id	pointer
,	O
mach_msg_type_name_t	O
*	O
idtype	pointer
)	O
{	O
struct	O
async_req	struct
*	O
ar	pointer
;	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
!	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
(	O
O_READ	O
|	O
O_WRITE	O
)	O
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
EBADF	int
;	O
}	O
ar	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
async_req	struct
)	O
)	O
;	O
ar	pointer
->	O
notify	int
=	O
notify	int
;	O
ar	pointer
->	O
next	pointer
=	O
async_requests	pointer
;	O
async_requests	pointer
=	O
ar	pointer
;	O
*	O
id	pointer
=	O
async_id	int
;	O
*	O
idtype	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
io_select_common	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
struct	O
timespec	struct
*	O
tsp	pointer
,	O
int	O
*	O
type	enum
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
pty_class	pointer
)	O
return	O
pty_io_select	function
(	O
cred	pointer
,	O
reply	int
,	O
tsp	pointer
,	O
type	enum
)	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_READ	O
)	O
==	O
0	int
)	O
*	O
type	enum
&=	O
~	O
SELECT_READ	O
;	O
if	O
(	O
(	O
cred	pointer
->	O
po	pointer
->	O
openmodes	O
&	O
O_WRITE	O
)	O
==	O
0	int
)	O
*	O
type	enum
&=	O
~	O
SELECT_WRITE	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
available	int
=	O
0	int
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
(	O
*	O
type	enum
&	O
SELECT_READ	O
)	O
&&	O
qsize	function
(	O
inputq	pointer
)	O
)	O
available	int
|=	O
SELECT_READ	O
;	O
if	O
(	O
(	O
*	O
type	enum
&	O
SELECT_WRITE	O
)	O
&&	O
qavail	function
(	O
outputq	pointer
)	O
)	O
available	int
|=	O
SELECT_WRITE	O
;	O
if	O
(	O
available	int
==	O
0	int
)	O
{	O
ports_interrupt_self_on_port_death	function
(	O
cred	pointer
,	O
reply	int
)	O
;	O
err	int
=	O
pthread_hurd_cond_timedwait_np	function
(	O
&	O
select_alert	union
,	O
&	O
global_lock	union
,	O
tsp	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
continue	O
;	O
}	O
*	O
type	enum
=	O
available	int
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
if	O
(	O
err	int
==	O
ETIMEDOUT	int
)	O
err	int
=	O
0	int
;	O
return	O
err	int
;	O
}	O
}	O
error_t	int
trivfs_S_io_select	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
*	O
type	enum
)	O
{	O
return	O
io_select_common	function
(	O
cred	pointer
,	O
reply	int
,	O
reply_type	int
,	O
NULL	O
,	O
type	enum
)	O
;	O
}	O
error_t	int
trivfs_S_io_select_timeout	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
struct	O
timespec	struct
ts	struct
,	O
int	O
*	O
type	enum
)	O
{	O
return	O
io_select_common	function
(	O
cred	pointer
,	O
reply	int
,	O
reply_type	int
,	O
&	O
ts	struct
,	O
type	enum
)	O
;	O
}	O
kern_return_t	O
trivfs_S_io_map	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
mach_port_t	int
reply	int
,	O
mach_msg_type_name_t	O
replyPoly	int
,	O
mach_port_t	int
*	O
rdobj	pointer
,	O
mach_msg_type_name_t	O
*	O
rdtype	pointer
,	O
mach_port_t	int
*	O
wrobj	pointer
,	O
mach_msg_type_name_t	O
*	O
wrtype	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
static	O
void	O
report_sig_start	function
(	O
)	O
{	O
sigs_in_progress	int
++	O
;	O
}	O
static	O
void	O
report_sig_end	function
(	O
)	O
{	O
sigs_in_progress	int
--	O
;	O
if	O
(	O
(	O
sigs_in_progress	int
==	O
0	int
)	O
&&	O
input_sig_wakeup	int
)	O
{	O
input_sig_wakeup	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
input_sig_wait	union
)	O
;	O
}	O
}	O
void	O
call_asyncs	function
(	O
int	O
dir	int
)	O
{	O
struct	O
async_req	struct
*	O
ar	pointer
,	O
*	O
nxt	pointer
,	O
*	O
*	O
prevp	pointer
;	O
mach_port_t	int
err	int
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
ICKY_ASYNC	int
)	O
&&	O
!	O
async_requests	pointer
)	O
return	O
;	O
if	O
(	O
(	O
!	O
(	O
dir	int
&	O
O_READ	O
)	O
||	O
qsize	function
(	O
inputq	pointer
)	O
==	O
0	int
)	O
&&	O
(	O
!	O
(	O
dir	int
&	O
O_WRITE	O
)	O
&&	O
qavail	function
(	O
outputq	pointer
)	O
==	O
0	int
)	O
)	O
return	O
;	O
if	O
(	O
(	O
termflags	long
&	O
ICKY_ASYNC	int
)	O
&&	O
!	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
)	O
{	O
report_sig_start	function
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
hurd_sig_post	function
(	O
foreground_id	int
,	O
SIGIO	O
,	O
async_icky_id	int
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
report_sig_end	function
(	O
)	O
;	O
}	O
for	O
(	O
ar	pointer
=	O
async_requests	pointer
,	O
prevp	pointer
=	O
&	O
async_requests	pointer
;	O
ar	pointer
;	O
ar	pointer
=	O
nxt	pointer
)	O
{	O
nxt	pointer
=	O
ar	pointer
->	O
next	pointer
;	O
err	int
=	O
nowait_msg_sig_post	function
(	O
ar	pointer
->	O
notify	int
,	O
SIGIO	O
,	O
0	int
,	O
async_id	int
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
*	O
prevp	pointer
=	O
ar	pointer
->	O
next	pointer
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
ar	pointer
->	O
notify	int
)	O
;	O
free	function
(	O
ar	pointer
)	O
;	O
}	O
else	O
prevp	pointer
=	O
&	O
ar	pointer
->	O
next	pointer
;	O
}	O
}	O
void	O
send_signal	function
(	O
int	O
signo	int
)	O
{	O
mach_port_t	int
right	O
;	O
if	O
(	O
!	O
(	O
termflags	long
&	O
NO_OWNER	int
)	O
)	O
{	O
right	O
=	O
ports_get_send_right	function
(	O
cttyid	pointer
)	O
;	O
report_sig_start	function
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
hurd_sig_post	function
(	O
foreground_id	int
,	O
signo	int
,	O
right	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
report_sig_end	function
(	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
right	O
)	O
;	O
}	O
}	O
void	O
report_carrier_off	function
(	O
)	O
{	O
clear_queue	function
(	O
inputq	pointer
)	O
;	O
(	O
*	O
bottom	pointer
->	O
notice_input_flushed	pointer
)	O
(	O
)	O
;	O
drop_output	function
(	O
)	O
;	O
termflags	long
|=	O
NO_CARRIER	int
;	O
if	O
(	O
!	O
(	O
termstate	struct
.	O
c_cflag	O
&	O
CLOCAL	O
)	O
)	O
send_signal	function
(	O
SIGHUP	O
)	O
;	O
}	O
void	O
report_carrier_on	function
(	O
)	O
{	O
termflags	long
&=	O
~	O
NO_CARRIER	int
;	O
pthread_cond_broadcast	function
(	O
&	O
carrier_alert	union
)	O
;	O
}	O
void	O
report_carrier_error	function
(	O
error_t	int
err	int
)	O
{	O
carrier_error	int
=	O
err	int
;	O
pthread_cond_broadcast	function
(	O
&	O
carrier_alert	union
)	O
;	O
}	O
kern_return_t	O
S_term_get_nodename	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
char	O
*	O
name	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
!	O
cred	pointer
->	O
po	pointer
->	O
cntl	pointer
->	O
hook	pointer
)	O
{	O
return	O
ENOENT	int
;	O
}	O
strcpy	O
(	O
name	int
,	O
(	O
char	O
*	O
)	O
cred	pointer
->	O
po	pointer
->	O
cntl	pointer
->	O
hook	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_term_set_nodename	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
char	O
*	O
name	int
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
strcmp	O
(	O
name	int
,	O
(	O
char	O
*	O
)	O
cred	pointer
->	O
po	pointer
->	O
cntl	pointer
->	O
hook	pointer
)	O
!=	O
0	int
)	O
err	int
=	O
EINVAL	int
;	O
return	O
err	int
;	O
}	O
kern_return_t	O
S_term_set_filenode	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
file_t	O
filenode	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
return	O
EINVAL	int
;	O
}	O
kern_return_t	O
S_term_get_peername	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
char	O
*	O
name	int
)	O
{	O
struct	O
trivfs_control	O
*	O
peer	pointer
;	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
if	O
(	O
!	O
cred	pointer
||	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
&&	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
pty_class	pointer
)	O
)	O
{	O
if	O
(	O
cred	pointer
)	O
ports_port_deref	function
(	O
cred	pointer
)	O
;	O
return	O
EOPNOTSUPP	int
;	O
}	O
peer	pointer
=	O
(	O
cred	pointer
->	O
pi	pointer
.	O
class	O
==	O
tty_class	pointer
)	O
?	O
ptyctl	pointer
:	O
termctl	pointer
;	O
if	O
(	O
bottom	pointer
!=	O
&	O
ptyio_bottom	struct
||	O
!	O
peer	pointer
->	O
hook	pointer
)	O
{	O
ports_port_deref	function
(	O
cred	pointer
)	O
;	O
return	O
ENOENT	int
;	O
}	O
strcpy	O
(	O
name	int
,	O
(	O
char	O
*	O
)	O
peer	pointer
->	O
hook	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_term_get_bottom_type	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
int	O
*	O
ttype	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
*	O
ttype	pointer
=	O
bottom	pointer
->	O
type	enum
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_term_on_machdev	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
device_t	O
machdev	int
)	O
{	O
if	O
(	O
!	O
cred	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
bucket	O
!=	O
term_bucket	pointer
||	O
cred	pointer
->	O
pi	pointer
.	O
class	O
!=	O
tty_class	pointer
)	O
return	O
EOPNOTSUPP	int
;	O
return	O
EINVAL	int
;	O
}	O
kern_return_t	O
S_term_on_hurddev	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
struct	O
trivfs_protid	O
*	O
hurddev	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
kern_return_t	O
S_term_on_pty	function
(	O
struct	O
trivfs_protid	O
*	O
cred	pointer
,	O
struct	O
trivfs_protid	O
*	O
*	O
master	pointer
)	O
{	O
return	O
EOPNOTSUPP	int
;	O
}	O
error_t	int
trivfs_goaway	function
(	O
struct	O
trivfs_control	O
*	O
cntl	pointer
,	O
int	O
flags	int
)	O
{	O
return	O
EBUSY	int
;	O
}	O
