static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_region.c,v 1.5 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
static	O
int	O
__mpool_init	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_MPOOL	struct
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
int	O
CDB___memp_open	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOL	struct
*	O
mp	pointer
;	O
REGINFO	struct
reginfo	pointer
;	O
roff_t	int
reg_size	int
,	O
*	O
regids	int
;	O
u_int32_t	int
i	int
;	O
int	O
htab_buckets	int
,	O
ret	int
;	O
reg_size	int
=	O
dbenv	pointer
->	O
mp_gbytes	int
/	O
dbenv	pointer
->	O
mp_ncache	int
;	O
reg_size	int
+=	O
(	O
dbenv	pointer
->	O
mp_gbytes	int
%	O
dbenv	pointer
->	O
mp_ncache	int
)	O
/	O
dbenv	pointer
->	O
mp_ncache	int
;	O
reg_size	int
+=	O
dbenv	pointer
->	O
mp_bytes	int
/	O
dbenv	pointer
->	O
mp_ncache	int
;	O
htab_buckets	int
=	O
CDB___db_tablesize	function
(	O
(	O
reg_size	int
/	O
(	O
1	int
*	O
1024	int
)	O
)	O
/	O
10	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
*	O
dbmp	pointer
)	O
,	O
&	O
dbmp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LIST_INIT	O
(	O
&	O
dbmp	pointer
->	O
dbregq	struct
)	O
;	O
TAILQ_INIT	O
(	O
&	O
dbmp	pointer
->	O
dbmfq	struct
)	O
;	O
dbmp	pointer
->	O
dbenv	pointer
=	O
dbenv	pointer
;	O
reginfo	pointer
.	O
id	int
=	O
REG_ID_MPOOL	int
;	O
reginfo	pointer
.	O
mode	enum
=	O
dbenv	pointer
->	O
db_mode	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_CREATE	int
)	O
)	O
F_SET	O
(	O
&	O
reginfo	pointer
,	O
REGION_CREATE_OK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_r_attach	function
(	O
dbenv	pointer
,	O
&	O
reginfo	pointer
,	O
reg_size	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
{	O
dbmp	pointer
->	O
nreg	int
=	O
dbenv	pointer
->	O
mp_ncache	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
nreg	int
,	O
sizeof	O
(	O
REGINFO	struct
)	O
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
=	O
REG_ID_INVALID	int
;	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
=	O
reginfo	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__mpool_init	function
(	O
dbenv	pointer
,	O
dbmp	pointer
,	O
0	int
,	O
htab_buckets	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
mp	pointer
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
rp	pointer
->	O
primary	int
)	O
;	O
regids	int
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mp	pointer
->	O
regids	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
{	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
=	O
REG_ID_INVALID	int
;	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
mode	enum
=	O
dbenv	pointer
->	O
db_mode	int
;	O
F_SET	O
(	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
,	O
REGION_CREATE_OK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_r_attach	function
(	O
dbenv	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
,	O
reg_size	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__mpool_init	function
(	O
dbenv	pointer
,	O
dbmp	pointer
,	O
i	int
,	O
htab_buckets	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
)	O
;	O
regids	int
[	O
i	int
]	O
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
;	O
}	O
}	O
else	O
{	O
mp	pointer
=	O
R_ADDR	O
(	O
&	O
reginfo	pointer
,	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
)	O
;	O
dbmp	pointer
->	O
nreg	int
=	O
mp	pointer
->	O
nreg	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
nreg	int
,	O
sizeof	O
(	O
REGINFO	struct
)	O
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
=	O
REG_ID_INVALID	int
;	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
=	O
reginfo	pointer
;	O
regids	int
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mp	pointer
->	O
regids	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
{	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
=	O
regids	int
[	O
i	int
]	O
;	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
mode	enum
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_r_attach	function
(	O
dbenv	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
primary	int
=	O
R_ADDR	O
(	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
,	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
rp	pointer
->	O
primary	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_mutex_alloc	function
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
&	O
dbmp	pointer
->	O
mutexp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
mutexp	pointer
,	O
0	int
,	O
MUTEX_THREAD	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
dbenv	pointer
->	O
mp_handle	pointer
=	O
dbmp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
if	O
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
!=	O
REG_ID_INVALID	int
)	O
F_SET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
rp	pointer
,	O
REG_DEAD	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
if	O
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
id	int
!=	O
REG_ID_INVALID	int
)	O
(	O
void	O
)	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
dbmp	pointer
->	O
nreg	int
*	O
sizeof	O
(	O
*	O
dbmp	pointer
->	O
reginfo	pointer
)	O
)	O
;	O
}	O
CDB___os_free	function
(	O
dbmp	pointer
,	O
sizeof	O
(	O
*	O
dbmp	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__mpool_init	function
(	O
dbenv	pointer
,	O
dbmp	pointer
,	O
reginfo_off	int
,	O
htab_buckets	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
int	O
reginfo_off	int
,	O
htab_buckets	int
;	O
{	O
DB_HASHTAB	struct
*	O
htab	int
;	O
MPOOL	struct
*	O
mp	pointer
;	O
REGINFO	struct
*	O
reginfo	pointer
;	O
int	O
ret	int
;	O
void	O
*	O
p	pointer
;	O
mp	pointer
=	O
NULL	O
;	O
reginfo	pointer
=	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
reginfo_off	int
]	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
reginfo	pointer
->	O
addr	pointer
,	O
sizeof	O
(	O
MPOOL	struct
)	O
,	O
MUTEX_ALIGN	int
,	O
&	O
reginfo	pointer
->	O
primary	int
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
reginfo	pointer
->	O
rp	pointer
->	O
primary	int
=	O
R_OFFSET	O
(	O
reginfo	pointer
,	O
reginfo	pointer
->	O
primary	int
)	O
;	O
mp	pointer
=	O
reginfo	pointer
->	O
primary	int
;	O
memset	function
(	O
mp	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
mp	pointer
)	O
)	O
;	O
if	O
(	O
reginfo_off	int
==	O
0	int
)	O
{	O
SH_TAILQ_INIT	O
(	O
&	O
mp	pointer
->	O
mpfq	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
&	O
mp	pointer
->	O
sync_mutex	struct
,	O
R_OFFSET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
&	O
mp	pointer
->	O
sync_mutex	struct
)	O
+	O
DB_FCNTL_OFF_MPOOL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ZERO_LSN	O
(	O
mp	pointer
->	O
lsn	struct
)	O
;	O
mp	pointer
->	O
lsn_cnt	int
=	O
0	int
;	O
mp	pointer
->	O
nreg	int
=	O
dbmp	pointer
->	O
nreg	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
dbmp	pointer
->	O
nreg	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
0	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
mp	pointer
->	O
regids	int
=	O
R_OFFSET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
p	pointer
)	O
;	O
}	O
SH_TAILQ_INIT	O
(	O
&	O
mp	pointer
->	O
bhq	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
reginfo	pointer
->	O
addr	pointer
,	O
htab_buckets	int
*	O
sizeof	O
(	O
DB_HASHTAB	struct
)	O
,	O
0	int
,	O
&	O
htab	int
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
CDB___db_hashinit	function
(	O
htab	int
,	O
htab_buckets	int
)	O
;	O
mp	pointer
->	O
htab	int
=	O
R_OFFSET	O
(	O
reginfo	pointer
,	O
htab	int
)	O
;	O
mp	pointer
->	O
htab_buckets	int
=	O
htab_buckets	int
;	O
return	O
(	O
0	int
)	O
;	O
mem_err	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory for mpool region"	pointer
)	O
;	O
err	pointer
:	O
if	O
(	O
reginfo	pointer
->	O
primary	int
!=	O
NULL	O
)	O
CDB___db_shalloc_free	function
(	O
reginfo	pointer
->	O
addr	pointer
,	O
reginfo	pointer
->	O
primary	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___memp_close	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
DB_MPREG	struct
*	O
mpreg	pointer
;	O
u_int32_t	int
i	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
ret	int
=	O
0	int
;	O
dbmp	pointer
=	O
dbenv	pointer
->	O
mp_handle	pointer
;	O
while	O
(	O
(	O
mpreg	pointer
=	O
LIST_FIRST	O
(	O
&	O
dbmp	pointer
->	O
dbregq	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
LIST_REMOVE	O
(	O
mpreg	pointer
,	O
q	struct
)	O
;	O
CDB___os_free	function
(	O
mpreg	pointer
,	O
sizeof	O
(	O
DB_MPREG	struct
)	O
)	O
;	O
}	O
while	O
(	O
(	O
dbmfp	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbmp	pointer
->	O
dbmfq	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fclose	function
(	O
dbmfp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
dbmp	pointer
->	O
mutexp	pointer
!=	O
NULL	O
)	O
CDB___db_mutex_free	function
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbmp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
CDB___os_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
dbmp	pointer
->	O
nreg	int
*	O
sizeof	O
(	O
*	O
dbmp	pointer
->	O
reginfo	pointer
)	O
)	O
;	O
CDB___os_free	function
(	O
dbmp	pointer
,	O
sizeof	O
(	O
*	O
dbmp	pointer
)	O
)	O
;	O
dbenv	pointer
->	O
mp_handle	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
