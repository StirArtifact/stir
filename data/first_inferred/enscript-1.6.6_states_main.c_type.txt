char	O
*	O
program	pointer
;	O
StringHashPtr	pointer
ns_prims	pointer
=	O
NULL	O
;	O
StringHashPtr	pointer
ns_vars	pointer
=	O
NULL	O
;	O
StringHashPtr	pointer
ns_subs	pointer
=	O
NULL	O
;	O
StringHashPtr	pointer
ns_states	pointer
=	O
NULL	O
;	O
List	struct
*	O
global_stmts	pointer
=	O
NULL	O
;	O
List	struct
*	O
start_stmts	pointer
=	O
NULL	O
;	O
List	struct
*	O
startrules	pointer
=	O
NULL	O
;	O
List	struct
*	O
namerules	pointer
=	O
NULL	O
;	O
Node	struct
*	O
nvoid	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
ifp	pointer
=	O
NULL	O
;	O
char	O
*	O
inbuf	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
data_in_buffer	int
;	O
unsigned	O
int	O
bufpos	int
;	O
int	O
eof_seen	int
;	O
char	O
*	O
current_fname	pointer
;	O
unsigned	O
int	O
current_linenum	int
;	O
struct	O
re_registers	struct
*	O
current_match	pointer
=	O
NULL	O
;	O
char	O
*	O
current_match_buf	pointer
=	O
NULL	O
;	O
VariableDef	struct
*	O
vardefs	pointer
=	O
NULL	O
;	O
VariableDef	struct
*	O
vardefs_tail	pointer
=	O
NULL	O
;	O
char	O
*	O
defs_file	pointer
=	O
"states.st"	pointer
;	O
unsigned	O
int	O
linenum	int
=	O
1	int
;	O
char	O
*	O
yyin_name	pointer
;	O
FILE	struct
*	O
ofp	pointer
=	O
NULL	O
;	O
char	O
*	O
path	pointer
=	O
NULL	O
;	O
char	O
*	O
start_state_arg	pointer
=	O
NULL	O
;	O
char	O
*	O
start_state	pointer
;	O
unsigned	O
int	O
verbose	int
=	O
0	int
;	O
WarningLevel	enum
warning_level	enum
=	O
WARN_LIGHT	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"define"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"file"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"output"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"path"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"state"	pointer
,	O
required_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"warning"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
char	O
version	array
[	O
256	int
]	O
;	O
static	O
void	O
usage	function
___P	O
(	O
(	O
void	O
)	O
)	O
;	O
int	O
main	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
argv	pointer
[	O
]	O
;	O
{	O
int	O
c	int
;	O
VariableDef	struct
*	O
vardef	pointer
;	O
ofp	pointer
=	O
stdout	pointer
;	O
program	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
program	pointer
==	O
NULL	O
)	O
program	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
else	O
program	pointer
++	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
program	pointer
;	O
sprintf	function
(	O
version	array
,	O
_	O
(	O
"states for %s"	pointer
)	O
,	O
PACKAGE_STRING	pointer
)	O
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
ns_prims	pointer
=	O
strhash_init	function
(	O
)	O
;	O
ns_vars	pointer
=	O
strhash_init	function
(	O
)	O
;	O
ns_subs	pointer
=	O
strhash_init	function
(	O
)	O
;	O
ns_states	pointer
=	O
strhash_init	function
(	O
)	O
;	O
global_stmts	pointer
=	O
list	function
(	O
)	O
;	O
start_stmts	pointer
=	O
list	function
(	O
)	O
;	O
startrules	pointer
=	O
list	function
(	O
)	O
;	O
namerules	pointer
=	O
list	function
(	O
)	O
;	O
nvoid	pointer
=	O
node_alloc	function
(	O
nVOID	int
)	O
;	O
inbuf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
INBUFSIZE	O
)	O
;	O
init_primitives	function
(	O
)	O
;	O
re_set_syntax	function
(	O
RE_SYNTAX_GNU_AWK	O
|	O
RE_INTERVALS	O
)	O
;	O
enter_system_variable	function
(	O
"program"	pointer
,	O
program	pointer
)	O
;	O
enter_system_variable	function
(	O
"version"	pointer
,	O
version	array
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"D:f:ho:p:s:vVW:"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'D'	O
:	O
vardef	pointer
=	O
(	O
VariableDef	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
vardef	pointer
)	O
)	O
;	O
vardef	pointer
->	O
sym	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
optarg	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
vardef	pointer
->	O
sym	pointer
,	O
optarg	pointer
)	O
;	O
vardef	pointer
->	O
val	array
=	O
strchr	function
(	O
vardef	pointer
->	O
sym	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
vardef	pointer
->	O
val	array
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: malformed variable definition \"%s\"\n"	pointer
)	O
,	O
program	pointer
,	O
vardef	pointer
->	O
sym	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
*	O
vardef	pointer
->	O
val	array
=	O
'\0'	O
;	O
vardef	pointer
->	O
val	array
++	O
;	O
if	O
(	O
vardefs	pointer
)	O
vardefs_tail	pointer
->	O
next	pointer
=	O
vardef	pointer
;	O
else	O
vardefs	pointer
=	O
vardef	pointer
;	O
vardefs_tail	pointer
=	O
vardef	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
defs_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
ofp	pointer
=	O
fopen	function
(	O
optarg	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
ofp	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: couldn't create output file \"%s\": %s\n"	pointer
)	O
,	O
program	pointer
,	O
optarg	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'p'	O
:	O
path	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
's'	O
:	O
start_state_arg	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'V'	O
:	O
printf	function
(	O
"%s\n"	pointer
,	O
version	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"light"	pointer
)	O
==	O
0	int
)	O
warning_level	enum
=	O
WARN_LIGHT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"all"	pointer
)	O
==	O
0	int
)	O
warning_level	enum
=	O
WARN_ALL	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unknown warning level `%s'\n"	pointer
)	O
,	O
program	pointer
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'?'	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Hey! main() didn't handle option \"%c\" (%d)"	pointer
,	O
c	int
,	O
c	int
)	O
;	O
if	O
(	O
optarg	pointer
)	O
printf	function
(	O
" with arg %s"	pointer
,	O
optarg	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
{	O
Node	struct
*	O
v	pointer
,	O
*	O
n	long
;	O
int	O
i	int
;	O
v	pointer
=	O
node_alloc	function
(	O
nARRAY	int
)	O
;	O
v	pointer
->	O
u	union
.	O
array	pointer
.	O
allocated	long
=	O
argc	int
-	O
optind	int
+	O
1	int
;	O
v	pointer
->	O
u	union
.	O
array	pointer
.	O
len	int
=	O
argc	int
-	O
optind	int
;	O
v	pointer
->	O
u	union
.	O
array	pointer
.	O
array	pointer
=	O
(	O
Node	struct
*	O
*	O
)	O
xcalloc	function
(	O
v	pointer
->	O
u	union
.	O
array	pointer
.	O
allocated	long
,	O
sizeof	O
(	O
Node	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
optind	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
data	pointer
;	O
n	long
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
data	pointer
=	O
STDIN_NAME	pointer
;	O
else	O
data	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
strlen	function
(	O
data	pointer
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
xstrdup	function
(	O
data	pointer
)	O
;	O
v	pointer
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
i	int
-	O
optind	int
]	O
=	O
n	long
;	O
}	O
if	O
(	O
!	O
strhash_put	function
(	O
ns_vars	pointer
,	O
"argv"	pointer
,	O
4	int
,	O
v	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
n	long
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: out of memory\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
node_free	function
(	O
n	long
)	O
;	O
}	O
if	O
(	O
path	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
cp	pointer
;	O
cp	pointer
=	O
strrchr	function
(	O
defs_file	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
path	pointer
=	O
xmalloc	function
(	O
cp	pointer
-	O
defs_file	pointer
+	O
3	int
)	O
;	O
sprintf	function
(	O
path	pointer
,	O
".%c%.*s"	pointer
,	O
PATH_SEPARATOR	char
,	O
cp	pointer
-	O
defs_file	pointer
,	O
defs_file	pointer
)	O
;	O
}	O
else	O
path	pointer
=	O
"."	pointer
;	O
}	O
load_states_file	function
(	O
defs_file	pointer
)	O
;	O
for	O
(	O
vardef	pointer
=	O
vardefs	pointer
;	O
vardef	pointer
;	O
vardef	pointer
=	O
vardef	pointer
->	O
next	pointer
)	O
{	O
Node	struct
*	O
val	array
;	O
Node	struct
*	O
old_val	pointer
;	O
val	array
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
val	array
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
strlen	function
(	O
vardef	pointer
->	O
val	array
)	O
;	O
val	array
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
xstrdup	function
(	O
vardef	pointer
->	O
val	array
)	O
;	O
if	O
(	O
!	O
strhash_put	function
(	O
ns_vars	pointer
,	O
vardef	pointer
->	O
sym	pointer
,	O
strlen	function
(	O
vardef	pointer
->	O
sym	pointer
)	O
,	O
val	array
,	O
(	O
void	O
*	O
*	O
)	O
&	O
old_val	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: out of memory\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
node_free	function
(	O
old_val	pointer
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
{	O
ifp	pointer
=	O
stdin	pointer
;	O
process_file	function
(	O
STDIN_NAME	pointer
)	O
;	O
}	O
else	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
ifp	pointer
=	O
stdin	pointer
;	O
process_file	function
(	O
STDIN_NAME	pointer
)	O
;	O
}	O
else	O
{	O
ifp	pointer
=	O
fopen	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
ifp	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: couldn't open input file `%s': %s\n"	pointer
)	O
,	O
program	pointer
,	O
argv	pointer
[	O
optind	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
process_file	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
fclose	function
(	O
ifp	pointer
)	O
;	O
}	O
}	O
if	O
(	O
ofp	pointer
!=	O
stdout	pointer
)	O
fclose	function
(	O
ofp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
usage	function
(	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [FILE]...\nMandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  -D, --define=VAR=VAL       define variable VAR to have value VAL\n  -f, --file=NAME            read state definitions from file NAME\n  -h, --help                 print this help and exit\n  -o, --output=NAME          save output to file NAME\n  -p, --path=PATH            set the load path to PATH\n  -s, --state=NAME           start from state NAME\n  -v, --verbose              increase the program verbosity\n  -V, --version              print version number\n  -W, --warning=LEVEL        set the warning level to LEVEL\n"	pointer
)	O
)	O
;	O
}	O
