const	O
char	O
*	O
argp_program_version	pointer
=	O
"radiusd ("	pointer
PACKAGE	pointer
") "	pointer
VERSION	pointer
;	O
static	O
char	O
doc	pointer
[	O
]	O
=	O
N_	O
(	O
"GNU radius daemon"	pointer
)	O
;	O
static	O
struct	O
argp_option	struct
options	int
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"radiusd specific switches:"	pointer
)	O
,	O
GRP	int
}	O
,	O
{	O
"foreground"	pointer
,	O
'f'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Stay in foreground"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"mode"	pointer
,	O
'm'	O
,	O
"{t|c|b}"	pointer
,	O
0	int
,	O
N_	O
(	O
"Select operation mode: test, checkconf, builddbm."	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"single-process"	pointer
,	O
's'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Run in single process mode"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"pid-file-dir"	pointer
,	O
'P'	O
,	O
N_	O
(	O
"DIR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Store pidfile in DIR"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"show-defaults"	pointer
,	O
SHOW_DEFAULTS_OPTION	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Show compilation defaults"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"quiet"	pointer
,	O
'q'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Quiet mode (valid only with --mode)"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Daemon configuration options. Please use raddb/config instead."	pointer
)	O
,	O
GRP	int
}	O
,	O
{	O
"log-auth-detail"	pointer
,	O
'A'	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"Do detailed authentication logging"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"acct-directory"	pointer
,	O
'a'	O
,	O
N_	O
(	O
"DIR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set accounting directory"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"logging-directory"	pointer
,	O
'l'	O
,	O
N_	O
(	O
"DIR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set logging directory name"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"do-not-resolve"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Do not resolve IP addresses"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"ip-address"	pointer
,	O
'i'	O
,	O
N_	O
(	O
"IPADDR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Listen on IPADDR"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"port"	pointer
,	O
'p'	O
,	O
"NUMBER"	pointer
,	O
0	int
,	O
N_	O
(	O
"Set authentication port number"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"log-stripped-names"	pointer
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Strip prefixes/suffixes off user names before logging"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"debug"	pointer
,	O
'x'	O
,	O
N_	O
(	O
"DEBUGSPEC"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set debugging level"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"log-auth"	pointer
,	O
'y'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Log authentications"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"log-auth-pass"	pointer
,	O
'z'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Log users' passwords"	pointer
)	O
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
debug_flag	int
;	O
int	O
log_mode	int
;	O
int	O
console_logging_priority	int
=	O
-	O
1	int
;	O
char	O
*	O
auth_log_hook	pointer
;	O
static	O
int	O
foreground	int
;	O
int	O
spawn_flag	int
;	O
int	O
use_dbm	int
=	O
0	int
;	O
int	O
auth_detail	int
=	O
0	int
;	O
char	O
*	O
auth_detail_template	pointer
;	O
int	O
acct_detail	int
=	O
1	int
;	O
char	O
*	O
acct_detail_template	pointer
;	O
int	O
acct_system	int
=	O
1	int
;	O
int	O
auth_trace_rules	int
=	O
0	int
;	O
int	O
acct_trace_rules	int
=	O
0	int
;	O
int	O
strip_names	int
;	O
int	O
suspend_flag	int
;	O
int	O
auth_reject_malformed_names	int
=	O
0	int
;	O
RADIUS_USER	struct
radiusd_user	struct
;	O
RADIUS_USER	struct
exec_user	struct
;	O
int	O
daemon_command	int
=	O
CMD_NONE	int
;	O
static	O
INPUT	struct
*	O
radius_input	pointer
;	O
int	O
auth_comp_flag	int
;	O
int	O
acct_comp_flag	int
;	O
int	O
checkrad_assume_logged	int
=	O
1	int
;	O
size_t	long
max_requests	int
=	O
MAX_REQUESTS	int
;	O
size_t	long
max_children	long
=	O
MAX_CHILDREN	int
;	O
unsigned	O
process_timeout	int
=	O
PROCESS_TIMEOUT	int
;	O
unsigned	O
radiusd_write_timeout	int
=	O
RADIUSD_WRITE_TIMEOUT	int
;	O
unsigned	O
radiusd_read_timeout	int
=	O
RADIUSD_READ_TIMEOUT	int
;	O
grad_uint32_t	int
warning_seconds	int
;	O
int	O
use_guile	int
;	O
char	O
*	O
message_text	array
[	O
MSG_COUNT	int
]	O
;	O
grad_uint32_t	int
myip	int
=	O
INADDR_ANY	O
;	O
grad_uint32_t	int
ref_ip	int
=	O
INADDR_ANY	O
;	O
int	O
auth_port	int
;	O
int	O
acct_port	int
;	O
pid_t	int
radiusd_pid	int
;	O
int	O
radius_mode	int
=	O
MODE_DAEMON	int
;	O
int	O
xargc	int
;	O
char	O
*	O
*	O
xargv	pointer
;	O
char	O
*	O
x_debug_spec	pointer
;	O
static	O
RETSIGTYPE	void
sig_handler	function
(	O
int	O
sig	int
)	O
;	O
void	O
radiusd_main_loop	function
(	O
)	O
;	O
static	O
size_t	long
radius_count_channels	function
(	O
)	O
;	O
void	O
radiusd_run_preconfig_hooks	function
(	O
void	O
*	O
data	pointer
)	O
;	O
struct	O
cfg_stmt	struct
config_syntax	array
[	O
]	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'A'	O
:	O
auth_detail	int
++	O
;	O
break	O
;	O
case	O
'a'	O
:	O
grad_acct_dir	pointer
=	O
grad_estrdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
foreground	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
grad_log_dir	pointer
=	O
grad_estrdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
switch	O
(	O
arg	pointer
[	O
0	int
]	O
)	O
{	O
case	O
't'	O
:	O
radius_mode	int
=	O
MODE_TEST	int
;	O
break	O
;	O
case	O
'b'	O
:	O
argp_error	function
(	O
state	pointer
,	O
_	O
(	O
"radiusd compiled without DBM support"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
radius_mode	int
=	O
MODE_CHECKCONF	int
;	O
break	O
;	O
default	O
:	O
argp_error	function
(	O
state	pointer
,	O
_	O
(	O
"unknown mode: %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'n'	O
:	O
grad_resolve_hostnames	int
=	O
0	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
(	O
myip	int
=	O
grad_ip_gethostaddr	function
(	O
arg	pointer
)	O
)	O
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid IP address: %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
grad_pid_dir	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'p'	O
:	O
auth_port	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
acct_port	int
=	O
auth_port	int
+	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
console_logging_priority	int
=	O
GRAD_LOG_ERR	int
;	O
break	O
;	O
case	O
'S'	O
:	O
strip_names	int
++	O
;	O
break	O
;	O
case	O
's'	O
:	O
spawn_flag	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
x_debug_spec	pointer
=	O
arg	pointer
;	O
grad_set_debug_levels	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
log_mode	int
|=	O
RLOG_AUTH	int
;	O
break	O
;	O
case	O
'z'	O
:	O
log_mode	int
|=	O
RLOG_AUTH_PASS	int
;	O
break	O
;	O
case	O
SHOW_DEFAULTS_OPTION	int
:	O
show_compilation_defaults	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	int
,	O
parse_opt	function
,	O
NULL	O
,	O
doc	pointer
,	O
grad_common_argp_child	array
,	O
NULL	O
,	O
NULL	O
}	O
;	O
void	O
set_config_defaults	function
(	O
)	O
{	O
username_valid_chars	pointer
=	O
grad_estrdup	function
(	O
".-_!@#$%^&\\/"	pointer
)	O
;	O
message_text	array
[	O
MSG_ACCOUNT_CLOSED	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"Sorry, your account is currently closed\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_PASSWORD_EXPIRED	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"Password has expired\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_PASSWORD_EXPIRE_WARNING	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"Password will expire in %R{Password-Expire-Days} Days\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_ACCESS_DENIED	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"\nAccess denied\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_REALM_QUOTA	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"\nRealm quota exceeded - access denied\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_MULTIPLE_LOGIN	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"\nYou are already logged in %R{Simultaneous-Use} times - access denied\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_SECOND_LOGIN	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"\nYou are already logged in - access denied\n"	pointer
)	O
)	O
;	O
message_text	array
[	O
MSG_TIMESPAN_VIOLATION	int
]	O
=	O
grad_estrdup	function
(	O
_	O
(	O
"You are calling outside your allowed timespan\n"	pointer
)	O
)	O
;	O
}	O
static	O
int	O
get_port_number	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
proto	int
,	O
int	O
defval	pointer
)	O
{	O
struct	O
servent	struct
*	O
svp	pointer
;	O
svp	pointer
=	O
getservbyname	function
(	O
name	pointer
,	O
proto	int
)	O
;	O
return	O
svp	pointer
?	O
ntohs	function
(	O
svp	pointer
->	O
s_port	int
)	O
:	O
defval	pointer
;	O
}	O
unsigned	O
max_ttl	function
(	O
time_t	long
*	O
t	long
)	O
{	O
unsigned	O
i	int
,	O
delta	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
R_MAX	int
;	O
i	int
++	O
)	O
if	O
(	O
delta	int
<	O
request_class	struct
[	O
i	int
]	O
.	O
ttl	int
)	O
delta	int
=	O
request_class	struct
[	O
i	int
]	O
.	O
ttl	int
;	O
if	O
(	O
t	long
)	O
{	O
time	struct
(	O
t	long
)	O
;	O
*	O
t	long
+=	O
delta	int
;	O
}	O
return	O
delta	int
;	O
}	O
static	O
void	O
terminate_subprocesses	function
(	O
)	O
{	O
int	O
kill_sent	int
=	O
0	int
;	O
time_t	long
t	long
;	O
radiusd_flush_queue	function
(	O
)	O
;	O
request_init_queue	function
(	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Terminating the subprocesses"	pointer
)	O
)	O
;	O
rpp_kill	function
(	O
-	O
1	int
,	O
SIGTERM	int
)	O
;	O
max_ttl	function
(	O
&	O
t	long
)	O
;	O
while	O
(	O
rpp_count	function
(	O
)	O
)	O
{	O
sleep	function
(	O
1	int
)	O
;	O
radiusd_cleanup	function
(	O
)	O
;	O
if	O
(	O
time	struct
(	O
NULL	O
)	O
>=	O
t	long
)	O
{	O
if	O
(	O
kill_sent	int
)	O
{	O
int	O
n	long
=	O
rpp_count	function
(	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
ngettext	function
(	O
"%d process left!"	pointer
,	O
"%d processes left!"	pointer
,	O
n	long
)	O
,	O
n	long
)	O
;	O
break	O
;	O
}	O
max_ttl	function
(	O
&	O
t	long
)	O
;	O
rpp_kill	function
(	O
-	O
1	int
,	O
SIGKILL	int
)	O
;	O
kill_sent	int
=	O
1	int
;	O
}	O
}	O
}	O
static	O
void	O
radiusd_preconfig_hook	function
(	O
void	O
*	O
a	pointer
ARG_UNUSED	O
,	O
void	O
*	O
b	pointer
ARG_UNUSED	O
)	O
{	O
terminate_subprocesses	function
(	O
)	O
;	O
input_close_channels	function
(	O
radius_input	pointer
)	O
;	O
}	O
static	O
void	O
radiusd_postconfig_hook	function
(	O
void	O
*	O
a	pointer
ARG_UNUSED	O
,	O
void	O
*	O
b	pointer
ARG_UNUSED	O
)	O
{	O
if	O
(	O
radius_mode	int
==	O
MODE_DAEMON	int
&&	O
radius_count_channels	function
(	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
foreground	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ALERT	int
,	O
_	O
(	O
"Radiusd is not listening on any port."	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
grad_log	function
(	O
GRAD_LOG_ALERT	int
,	O
_	O
(	O
"Radiusd is not listening on any port. Trying to continue anyway..."	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
daemon_postconfig_hook	function
(	O
void	O
*	O
a	pointer
ARG_UNUSED	O
,	O
void	O
*	O
b	pointer
ARG_UNUSED	O
)	O
{	O
system_acct_init	function
(	O
)	O
;	O
}	O
void	O
radiusd_setup	function
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
grad_max_fd	function
(	O
)	O
;	O
i	int
>=	O
3	int
;	O
i	int
--	O
)	O
close	pointer
(	O
i	int
)	O
;	O
if	O
(	O
auth_port	int
==	O
0	int
)	O
auth_port	int
=	O
get_port_number	function
(	O
"radius"	pointer
,	O
"udp"	pointer
,	O
DEF_AUTH_PORT	int
)	O
;	O
if	O
(	O
acct_port	int
==	O
0	int
)	O
acct_port	int
=	O
get_port_number	function
(	O
"radacct"	pointer
,	O
"udp"	pointer
,	O
auth_port	int
+	O
1	int
)	O
;	O
srand	function
(	O
time	struct
(	O
NULL	O
)	O
)	O
;	O
radiusd_set_preconfig_hook	function
(	O
radiusd_preconfig_hook	function
,	O
NULL	O
,	O
0	int
)	O
;	O
radiusd_set_postconfig_hook	function
(	O
radiusd_postconfig_hook	function
,	O
NULL	O
,	O
0	int
)	O
;	O
rewrite_init	function
(	O
)	O
;	O
dynload_init	function
(	O
)	O
;	O
snmp_init	function
(	O
0	int
,	O
0	int
,	O
(	O
snmp_alloc_t	pointer
)	O
grad_emalloc	function
,	O
(	O
snmp_free_t	pointer
)	O
grad_free	function
)	O
;	O
mlc_init	function
(	O
)	O
;	O
sql_init	O
(	O
)	O
;	O
}	O
void	O
common_init	function
(	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Starting"	pointer
)	O
)	O
;	O
radiusd_pid	int
=	O
getpid	function
(	O
)	O
;	O
radius_input	pointer
=	O
input_create	function
(	O
)	O
;	O
input_register_method	function
(	O
radius_input	pointer
,	O
"rpp"	pointer
,	O
0	int
,	O
rpp_input_handler	function
,	O
rpp_input_close	function
,	O
NULL	O
)	O
;	O
input_register_method	function
(	O
radius_input	pointer
,	O
"udp"	pointer
,	O
1	int
,	O
udp_input_handler	function
,	O
udp_input_close	function
,	O
udp_input_cmp	function
)	O
;	O
setvbuf	function
(	O
stdout	pointer
,	O
NULL	O
,	O
_IOLBF	int
,	O
0	int
)	O
;	O
radiusd_signal_init	function
(	O
sig_handler	function
)	O
;	O
forward_init	function
(	O
)	O
;	O
acct_init	function
(	O
)	O
;	O
radiusd_reconfigure	function
(	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Ready"	pointer
)	O
)	O
;	O
}	O
void	O
radiusd_daemon	function
(	O
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
i	int
;	O
pid_t	int
pid	int
;	O
switch	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"fork"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
exit	function
(	O
0	int
)	O
;	O
}	O
setsid	function
(	O
)	O
;	O
grad_set_signal	function
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
switch	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
-	O
1	int
:	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"fork"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
default	O
:	O
exit	function
(	O
0	int
)	O
;	O
}	O
p	pointer
=	O
grad_mkfilename	function
(	O
grad_log_dir	pointer
,	O
"radius.stderr"	pointer
)	O
;	O
i	int
=	O
open	function
(	O
p	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
,	O
0644	int
)	O
;	O
if	O
(	O
i	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
i	int
!=	O
2	int
)	O
dup2	function
(	O
i	int
,	O
2	int
)	O
;	O
if	O
(	O
i	int
!=	O
1	int
)	O
dup2	function
(	O
i	int
,	O
1	int
)	O
;	O
if	O
(	O
i	int
!=	O
1	int
&&	O
i	int
!=	O
2	int
)	O
close	pointer
(	O
i	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
grad_free	function
(	O
p	pointer
)	O
;	O
}	O
int	O
radiusd_master	function
(	O
)	O
{	O
return	O
radiusd_pid	int
==	O
getpid	function
(	O
)	O
;	O
}	O
void	O
radiusd_main	function
(	O
)	O
{	O
switch	O
(	O
radius_mode	int
)	O
{	O
case	O
MODE_CHECKCONF	int
:	O
common_init	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
MODE_TEST	int
:	O
common_init	function
(	O
)	O
;	O
tsh	function
(	O
)	O
;	O
case	O
MODE_DAEMON	int
:	O
if	O
(	O
myip	int
!=	O
INADDR_ANY	O
)	O
ref_ip	int
=	O
myip	int
;	O
else	O
ref_ip	int
=	O
grad_first_ip	function
(	O
)	O
;	O
if	O
(	O
ref_ip	int
==	O
INADDR_ANY	O
)	O
grad_log	function
(	O
GRAD_LOG_ALERT	int
,	O
_	O
(	O
"can't find out my own IP address"	pointer
)	O
)	O
;	O
chdir	function
(	O
"/"	pointer
)	O
;	O
umask	function
(	O
022	int
)	O
;	O
if	O
(	O
!	O
foreground	int
)	O
radiusd_daemon	function
(	O
)	O
;	O
radiusd_set_postconfig_hook	function
(	O
daemon_postconfig_hook	function
,	O
NULL	O
,	O
0	int
)	O
;	O
common_init	function
(	O
)	O
;	O
}	O
radiusd_pidfile_write	function
(	O
RADIUSD_PID_FILE	pointer
)	O
;	O
if	O
(	O
radiusd_user	struct
.	O
username	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
log_change_owner	function
(	O
&	O
radiusd_user	struct
)	O
;	O
p	pointer
=	O
grad_mkfilename	function
(	O
grad_log_dir	pointer
,	O
"radius.stderr"	pointer
)	O
;	O
chown	function
(	O
p	pointer
,	O
radiusd_user	struct
.	O
uid	int
,	O
radiusd_user	struct
.	O
gid	int
)	O
;	O
grad_free	function
(	O
p	pointer
)	O
;	O
radius_switch_to_user	function
(	O
&	O
radiusd_user	struct
)	O
;	O
}	O
radiusd_main_loop	function
(	O
)	O
;	O
}	O
void	O
radiusd_start	function
(	O
)	O
{	O
radiusd_main	function
(	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
debug_flag	int
==	O
0	int
)	O
{	O
foreground	int
=	O
0	int
;	O
spawn_flag	int
=	O
1	int
;	O
}	O
grad_app_setup	function
(	O
)	O
;	O
grad_set_logger	function
(	O
radiusd_logger	function
)	O
;	O
xargc	int
=	O
argc	int
;	O
xargv	pointer
=	O
argv	pointer
;	O
set_config_defaults	function
(	O
)	O
;	O
argp_program_version_hook	pointer
=	O
version	function
;	O
if	O
(	O
grad_argp_parse	function
(	O
&	O
argp	struct
,	O
&	O
argc	int
,	O
&	O
argv	pointer
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
log_set_default	function
(	O
"default.log"	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
radius_mode	int
!=	O
MODE_DAEMON	int
)	O
log_set_to_console	function
(	O
-	O
1	int
,	O
console_logging_priority	int
)	O
;	O
radiusd_setup	function
(	O
)	O
;	O
radiusd_start	function
(	O
)	O
;	O
}	O
static	O
int	O
snmp_request_to_command	function
(	O
)	O
{	O
return	O
CMD_NONE	int
;	O
}	O
void	O
radiusd_suspend	function
(	O
)	O
{	O
if	O
(	O
suspend_flag	int
==	O
0	int
)	O
{	O
terminate_subprocesses	function
(	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"RADIUSD SUSPENDED"	pointer
)	O
)	O
;	O
suspend_flag	int
=	O
1	int
;	O
}	O
}	O
void	O
radiusd_continue	function
(	O
)	O
{	O
if	O
(	O
suspend_flag	int
)	O
{	O
terminate_subprocesses	function
(	O
)	O
;	O
suspend_flag	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
check_reload	function
(	O
)	O
{	O
if	O
(	O
daemon_command	int
==	O
CMD_NONE	int
)	O
daemon_command	int
=	O
snmp_request_to_command	function
(	O
)	O
;	O
switch	O
(	O
daemon_command	int
)	O
{	O
case	O
CMD_CLEANUP	int
:	O
radiusd_cleanup	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_RELOAD	int
:	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Reloading configuration now"	pointer
)	O
)	O
;	O
radiusd_reconfigure	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_RESTART	int
:	O
radiusd_restart	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_MEMINFO	int
:	O
break	O
;	O
case	O
CMD_DUMPDB	int
:	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Dumping users db to `%s'"	pointer
)	O
,	O
RADIUS_DUMPDB_NAME	pointer
)	O
;	O
dump_users_db	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_SUSPEND	int
:	O
radiusd_suspend	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_CONTINUE	int
:	O
radiusd_continue	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_SHUTDOWN	int
:	O
radiusd_exit	function
(	O
)	O
;	O
break	O
;	O
}	O
daemon_command	int
=	O
CMD_NONE	int
;	O
}	O
void	O
radiusd_register_input_fd	function
(	O
char	O
*	O
name	pointer
,	O
int	O
fd	int
,	O
void	O
*	O
data	pointer
)	O
{	O
input_register_channel	function
(	O
radius_input	pointer
,	O
name	pointer
,	O
fd	int
,	O
data	pointer
)	O
;	O
}	O
void	O
radiusd_close_channel	function
(	O
int	O
fd	int
)	O
{	O
input_close_channel_fd	function
(	O
radius_input	pointer
,	O
fd	int
)	O
;	O
}	O
void	O
radiusd_collect_children	function
(	O
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
pid	int
=	O
waitpid	function
(	O
(	O
pid_t	int
)	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
<=	O
0	int
)	O
break	O
;	O
rpp_status_changed	function
(	O
pid	int
,	O
status	int
)	O
;	O
}	O
}	O
void	O
radiusd_cleanup	function
(	O
)	O
{	O
rpp_collect_exited	function
(	O
)	O
;	O
}	O
void	O
radiusd_restart	function
(	O
)	O
{	O
pid_t	int
pid	int
;	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"restart initiated"	pointer
)	O
)	O
;	O
if	O
(	O
xargv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't restart: not started as absolute pathname"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
radiusd_run_preconfig_hooks	function
(	O
NULL	O
)	O
;	O
if	O
(	O
foreground	int
)	O
pid	int
=	O
0	int
;	O
else	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"radiusd_restart: cannot fork"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
radiusd_signal_init	function
(	O
SIG_DFL	O
)	O
;	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
sleep	function
(	O
10	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
sleep	function
(	O
10	int
)	O
;	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"restarting radius"	pointer
)	O
)	O
;	O
execvp	function
(	O
xargv	pointer
[	O
0	int
]	O
,	O
xargv	pointer
)	O
;	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"RADIUS NOT RESTARTED: exec failed"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
int	O
radiusd_rpp_wait	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
time_t	long
*	O
tp	pointer
=	O
arg	pointer
;	O
struct	O
timeval	struct
tv	pointer
;	O
if	O
(	O
time	struct
(	O
NULL	O
)	O
>	O
*	O
tp	pointer
)	O
return	O
1	int
;	O
tv	pointer
.	O
tv_sec	long
=	O
2	int
;	O
tv	pointer
.	O
tv_usec	long
=	O
0	int
;	O
input_select_channel	function
(	O
radius_input	pointer
,	O
"rpp"	pointer
,	O
&	O
tv	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radiusd_flush_queue	function
(	O
)	O
{	O
time_t	long
t	long
;	O
max_ttl	function
(	O
&	O
t	long
)	O
;	O
rpp_flush	function
(	O
radiusd_rpp_wait	function
,	O
&	O
t	long
)	O
;	O
}	O
void	O
radiusd_exit	function
(	O
)	O
{	O
stat_done	O
(	O
)	O
;	O
radiusd_pidfile_remove	function
(	O
RADIUSD_PID_FILE	pointer
)	O
;	O
radiusd_flush_queue	function
(	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"Normal shutdown."	pointer
)	O
)	O
;	O
rpp_kill	function
(	O
-	O
1	int
,	O
SIGTERM	int
)	O
;	O
radiusd_exit0	function
(	O
)	O
;	O
}	O
void	O
radiusd_exit0	function
(	O
)	O
{	O
radiusd_sql_shutdown	O
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
radiusd_main_loop	function
(	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Ready to process requests."	pointer
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
log_open	function
(	O
GRAD_LOG_MAIN	O
)	O
;	O
check_reload	function
(	O
)	O
;	O
input_select	function
(	O
radius_input	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
struct	O
hook_rec	struct
{	O
void	O
(	O
*	O
function	pointer
)	O
(	O
void	O
*	O
func_data	pointer
,	O
void	O
*	O
call_data	pointer
)	O
;	O
void	O
*	O
data	pointer
;	O
int	O
once	int
;	O
}	O
;	O
static	O
grad_list_t	struct
*	O
preconfig	pointer
;	O
static	O
grad_list_t	struct
*	O
postconfig	pointer
;	O
void	O
radiusd_set_preconfig_hook	function
(	O
void	O
(	O
*	O
f	pointer
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
p	pointer
,	O
int	O
once	int
)	O
{	O
struct	O
hook_rec	struct
*	O
hp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
hp	pointer
)	O
)	O
;	O
hp	pointer
->	O
function	pointer
=	O
f	pointer
;	O
hp	pointer
->	O
data	pointer
=	O
p	pointer
;	O
hp	pointer
->	O
once	int
=	O
once	int
;	O
if	O
(	O
!	O
preconfig	pointer
)	O
preconfig	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_prepend	function
(	O
preconfig	pointer
,	O
hp	pointer
)	O
;	O
}	O
void	O
radiusd_set_postconfig_hook	function
(	O
void	O
(	O
*	O
f	pointer
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
p	pointer
,	O
int	O
once	int
)	O
{	O
struct	O
hook_rec	struct
*	O
hp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
hp	pointer
)	O
)	O
;	O
hp	pointer
->	O
function	pointer
=	O
f	pointer
;	O
hp	pointer
->	O
data	pointer
=	O
p	pointer
;	O
hp	pointer
->	O
once	int
=	O
once	int
;	O
if	O
(	O
!	O
postconfig	pointer
)	O
postconfig	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_prepend	function
(	O
postconfig	pointer
,	O
hp	pointer
)	O
;	O
}	O
struct	O
hook_runtime_closure	struct
{	O
grad_list_t	struct
*	O
list	pointer
;	O
void	O
*	O
call_data	pointer
;	O
}	O
;	O
static	O
int	O
_hook_call	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
hook_rec	struct
*	O
hp	pointer
=	O
item	pointer
;	O
struct	O
hook_runtime_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
hp	pointer
->	O
function	pointer
(	O
hp	pointer
->	O
data	pointer
,	O
clos	pointer
->	O
call_data	pointer
)	O
;	O
if	O
(	O
hp	pointer
->	O
once	int
)	O
{	O
grad_list_remove	function
(	O
clos	pointer
->	O
list	pointer
,	O
hp	pointer
,	O
NULL	O
)	O
;	O
grad_free	function
(	O
hp	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
radiusd_run_preconfig_hooks	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
hook_runtime_closure	struct
clos	pointer
;	O
clos	pointer
.	O
list	pointer
=	O
preconfig	pointer
;	O
clos	pointer
.	O
call_data	pointer
=	O
data	pointer
;	O
grad_list_iterate	function
(	O
clos	pointer
.	O
list	pointer
,	O
_hook_call	function
,	O
&	O
clos	pointer
)	O
;	O
}	O
void	O
radiusd_run_postconfig_hooks	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
hook_runtime_closure	struct
clos	pointer
;	O
clos	pointer
.	O
list	pointer
=	O
postconfig	pointer
;	O
clos	pointer
.	O
call_data	pointer
=	O
data	pointer
;	O
grad_list_iterate	function
(	O
clos	pointer
.	O
list	pointer
,	O
_hook_call	function
,	O
&	O
clos	pointer
)	O
;	O
}	O
void	O
radiusd_reconfigure	function
(	O
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
char	O
*	O
filename	pointer
;	O
radiusd_run_preconfig_hooks	function
(	O
NULL	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"Loading configuration files."	pointer
)	O
)	O
;	O
filename	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_CONFIG	pointer
)	O
;	O
cfg_read	function
(	O
filename	pointer
,	O
config_syntax	array
,	O
NULL	O
)	O
;	O
grad_free	function
(	O
filename	pointer
)	O
;	O
rc	int
=	O
reload_config_file	function
(	O
reload_all	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"Errors reading config file - EXITING"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
grad_path_init	function
(	O
)	O
;	O
radiusd_run_postconfig_hooks	function
(	O
NULL	O
)	O
;	O
}	O
static	O
RETSIGTYPE	void
sig_handler	function
(	O
int	O
sig	int
)	O
{	O
switch	O
(	O
sig	int
)	O
{	O
case	O
SIGHUP	int
:	O
daemon_command	int
=	O
CMD_RELOAD	int
;	O
break	O
;	O
case	O
SIGUSR1	int
:	O
daemon_command	int
=	O
CMD_MEMINFO	int
;	O
break	O
;	O
case	O
SIGUSR2	int
:	O
daemon_command	int
=	O
CMD_DUMPDB	int
;	O
break	O
;	O
case	O
SIGCHLD	int
:	O
radiusd_collect_children	function
(	O
)	O
;	O
daemon_command	int
=	O
CMD_CLEANUP	int
;	O
break	O
;	O
case	O
SIGTERM	int
:	O
case	O
SIGQUIT	int
:	O
daemon_command	int
=	O
CMD_SHUTDOWN	int
;	O
break	O
;	O
case	O
SIGPIPE	int
:	O
daemon_command	int
=	O
CMD_CLEANUP	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
grad_reset_signal	function
(	O
sig	int
,	O
sig_handler	function
)	O
;	O
}	O
void	O
radiusd_signal_init	function
(	O
RETSIGTYPE	void
(	O
*	O
hp	pointer
)	O
(	O
int	O
sig	int
)	O
)	O
{	O
static	O
int	O
signum	array
[	O
]	O
=	O
{	O
SIGHUP	int
,	O
SIGUSR1	int
,	O
SIGUSR2	int
,	O
SIGCHLD	int
,	O
SIGTERM	int
,	O
SIGQUIT	int
,	O
SIGPIPE	int
}	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
signum	array
)	O
/	O
sizeof	O
(	O
signum	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
grad_set_signal	function
(	O
signum	array
[	O
i	int
]	O
,	O
hp	pointer
)	O
;	O
}	O
void	O
radiusd_pidfile_write	function
(	O
char	O
*	O
name	pointer
)	O
{	O
pid_t	int
pid	int
=	O
getpid	function
(	O
)	O
;	O
char	O
*	O
p	pointer
=	O
grad_mkfilename	function
(	O
grad_pid_dir	pointer
,	O
name	pointer
)	O
;	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
p	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
fp	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%lu\n"	pointer
,	O
(	O
u_long	long
)	O
pid	int
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
grad_free	function
(	O
p	pointer
)	O
;	O
}	O
pid_t	int
radiusd_pidfile_read	function
(	O
char	O
*	O
name	pointer
)	O
{	O
unsigned	O
long	O
val	array
;	O
char	O
*	O
p	pointer
=	O
grad_mkfilename	function
(	O
grad_pid_dir	pointer
,	O
name	pointer
)	O
;	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
p	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fscanf	function
(	O
fp	pointer
,	O
"%lu"	pointer
,	O
&	O
val	array
)	O
!=	O
1	int
)	O
val	array
=	O
-	O
1	int
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
grad_free	function
(	O
p	pointer
)	O
;	O
return	O
(	O
pid_t	int
)	O
val	array
;	O
}	O
void	O
radiusd_pidfile_remove	function
(	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
grad_mkfilename	function
(	O
grad_pid_dir	pointer
,	O
name	pointer
)	O
;	O
unlink	function
(	O
p	pointer
)	O
;	O
grad_free	function
(	O
p	pointer
)	O
;	O
}	O
static	O
u_char	char
recv_buffer	array
[	O
RAD_BUFFER_SIZE	int
]	O
;	O
struct	O
udp_data	struct
{	O
int	O
type	enum
;	O
struct	O
sockaddr_in	struct
addr	int
;	O
}	O
;	O
int	O
udp_input_handler	function
(	O
int	O
fd	int
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
sockaddr	struct
sa	struct
;	O
socklen_t	int
salen	int
=	O
sizeof	O
(	O
sa	struct
)	O
;	O
int	O
size	int
;	O
struct	O
udp_data	struct
*	O
sd	int
=	O
data	pointer
;	O
size	int
=	O
recvfrom	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
recv_buffer	array
,	O
sizeof	O
(	O
recv_buffer	array
)	O
,	O
0	int
,	O
&	O
sa	struct
,	O
&	O
salen	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
request_fail	function
(	O
sd	int
->	O
type	enum
,	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
&	O
sa	struct
)	O
;	O
else	O
{	O
REQUEST	struct
*	O
req	pointer
=	O
request_create	function
(	O
sd	int
->	O
type	enum
,	O
fd	int
,	O
&	O
sd	int
->	O
addr	int
,	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
&	O
sa	struct
,	O
recv_buffer	array
,	O
size	int
)	O
;	O
if	O
(	O
request_handle	function
(	O
req	pointer
,	O
spawn_flag	int
?	O
rpp_forward_request	function
:	O
request_respond	function
)	O
)	O
request_free	function
(	O
req	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
udp_input_close	function
(	O
int	O
fd	int
,	O
void	O
*	O
data	pointer
)	O
{	O
close	pointer
(	O
fd	int
)	O
;	O
grad_free	function
(	O
data	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
udp_input_cmp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
udp_data	struct
*	O
sda	pointer
=	O
a	pointer
;	O
const	O
struct	O
udp_data	struct
*	O
sdb	pointer
=	O
b	pointer
;	O
if	O
(	O
sda	pointer
->	O
addr	int
.	O
sin_port	short
!=	O
sdb	pointer
->	O
addr	int
.	O
sin_port	short
)	O
return	O
1	int
;	O
if	O
(	O
sda	pointer
->	O
addr	int
.	O
sin_addr	struct
.	O
s_addr	int
==	O
INADDR_ANY	O
||	O
sdb	pointer
->	O
addr	int
.	O
sin_addr	struct
.	O
s_addr	int
==	O
INADDR_ANY	O
)	O
return	O
0	int
;	O
return	O
sda	pointer
->	O
addr	int
.	O
sin_addr	struct
.	O
s_addr	int
!=	O
sdb	pointer
->	O
addr	int
.	O
sin_addr	struct
.	O
s_addr	int
;	O
}	O
int	O
udp_open	function
(	O
int	O
type	enum
,	O
grad_uint32_t	int
ipaddr	int
,	O
int	O
port	array
,	O
int	O
nonblock	int
)	O
{	O
int	O
fd	int
;	O
struct	O
sockaddr_in	struct
s	pointer
;	O
struct	O
udp_data	struct
*	O
p	pointer
;	O
s	pointer
.	O
sin_family	short
=	O
AF_INET	O
;	O
s	pointer
.	O
sin_addr	struct
.	O
s_addr	int
=	O
htonl	function
(	O
ipaddr	int
)	O
;	O
s	pointer
.	O
sin_port	short
=	O
htons	function
(	O
port	array
)	O
;	O
if	O
(	O
p	pointer
=	O
input_find_channel	function
(	O
radius_input	pointer
,	O
"udp"	pointer
,	O
&	O
s	pointer
)	O
)	O
{	O
char	O
buffer	pointer
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"socket %s:%d is already assigned for %s"	pointer
)	O
,	O
grad_ip_iptostr	function
(	O
ipaddr	int
,	O
buffer	pointer
)	O
,	O
port	array
,	O
request_class	struct
[	O
p	pointer
->	O
type	enum
]	O
.	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
fd	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
nonblock	int
)	O
grad_set_nonblocking	function
(	O
fd	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"%s socket"	pointer
,	O
request_class	struct
[	O
type	enum
]	O
.	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
bind	function
(	O
fd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
s	pointer
,	O
sizeof	O
(	O
s	pointer
)	O
)	O
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
"%s bind"	pointer
,	O
request_class	struct
[	O
type	enum
]	O
.	O
name	pointer
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
1	int
;	O
}	O
p	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
->	O
type	enum
=	O
type	enum
;	O
p	pointer
->	O
addr	int
=	O
s	pointer
;	O
input_register_channel	function
(	O
radius_input	pointer
,	O
"udp"	pointer
,	O
fd	int
,	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_counter	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
udp_data	struct
*	O
p	pointer
=	O
item	pointer
;	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
R_AUTH	int
||	O
p	pointer
->	O
type	enum
==	O
R_ACCT	int
)	O
++	O
*	O
(	O
size_t	long
*	O
)	O
data	pointer
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
radius_count_channels	function
(	O
)	O
{	O
size_t	long
count	int
=	O
0	int
;	O
input_iterate_channels	function
(	O
radius_input	pointer
,	O
"udp"	pointer
,	O
channel_counter	function
,	O
&	O
count	int
)	O
;	O
return	O
count	int
;	O
}	O
static	O
int	O
_opened_auth_sockets	int
;	O
static	O
int	O
_opened_acct_sockets	int
;	O
static	O
int	O
rad_cfg_listen_auth	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
int	O
i	int
,	O
errcnt	long
=	O
0	int
;	O
if	O
(	O
argc	int
==	O
2	int
&&	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
==	O
CFG_BOOLEAN	int
)	O
{	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
bool	int
==	O
0	int
)	O
auth_port	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
CFG_NETWORK	int
)	O
{	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
network	struct
.	O
netmask	int
!=	O
0xffffffffL	int
)	O
cfg_type_error	function
(	O
CFG_HOST	int
)	O
;	O
}	O
else	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
CFG_HOST	int
)	O
{	O
cfg_type_error	function
(	O
CFG_HOST	int
)	O
;	O
errcnt	long
++	O
;	O
}	O
if	O
(	O
errcnt	long
==	O
0	int
&&	O
radius_mode	int
==	O
MODE_DAEMON	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
grad_uint32_t	int
ip	pointer
;	O
int	O
port	array
;	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
CFG_NETWORK	int
)	O
{	O
ip	pointer
=	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
network	struct
.	O
ipaddr	int
;	O
port	array
=	O
auth_port	int
;	O
}	O
else	O
{	O
ip	pointer
=	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
host	int
.	O
ipaddr	int
;	O
port	array
=	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
host	int
.	O
port	array
;	O
}	O
if	O
(	O
udp_open	function
(	O
R_AUTH	int
,	O
ip	pointer
,	O
port	array
,	O
0	int
)	O
)	O
errcnt	long
++	O
;	O
}	O
}	O
if	O
(	O
errcnt	long
==	O
0	int
)	O
_opened_auth_sockets	int
++	O
;	O
return	O
0	int
;	O
}	O
int	O
auth_stmt_begin	function
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
_opened_auth_sockets	int
=	O
0	int
;	O
else	O
if	O
(	O
radius_mode	int
==	O
MODE_DAEMON	int
&&	O
!	O
_opened_auth_sockets	int
&&	O
auth_port	int
)	O
udp_open	function
(	O
R_AUTH	int
,	O
INADDR_ANY	O
,	O
auth_port	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rad_cfg_listen_acct	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
int	O
i	int
,	O
errcnt	long
=	O
0	int
;	O
if	O
(	O
argc	int
==	O
2	int
&&	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
==	O
CFG_BOOLEAN	int
)	O
{	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
bool	int
==	O
0	int
)	O
acct_port	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
CFG_NETWORK	int
)	O
{	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
network	struct
.	O
netmask	int
!=	O
0xffffffffL	int
)	O
cfg_type_error	function
(	O
CFG_HOST	int
)	O
;	O
}	O
else	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
CFG_HOST	int
)	O
{	O
cfg_type_error	function
(	O
CFG_HOST	int
)	O
;	O
errcnt	long
++	O
;	O
}	O
if	O
(	O
errcnt	long
==	O
0	int
&&	O
radius_mode	int
==	O
MODE_DAEMON	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
grad_uint32_t	int
ip	pointer
;	O
int	O
port	array
;	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
CFG_NETWORK	int
)	O
{	O
ip	pointer
=	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
network	struct
.	O
ipaddr	int
;	O
port	array
=	O
acct_port	int
;	O
}	O
else	O
{	O
ip	pointer
=	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
host	int
.	O
ipaddr	int
;	O
port	array
=	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
host	int
.	O
port	array
;	O
}	O
if	O
(	O
udp_open	function
(	O
R_ACCT	int
,	O
ip	pointer
,	O
port	array
,	O
0	int
)	O
)	O
errcnt	long
++	O
;	O
}	O
}	O
_opened_acct_sockets	int
++	O
;	O
return	O
0	int
;	O
}	O
int	O
acct_stmt_begin	function
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
_opened_acct_sockets	int
=	O
0	int
;	O
else	O
if	O
(	O
radius_mode	int
==	O
MODE_DAEMON	int
&&	O
!	O
_opened_acct_sockets	int
&&	O
acct_port	int
)	O
udp_open	function
(	O
R_ACCT	int
,	O
INADDR_ANY	O
,	O
acct_port	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rad_cfg_user	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
RADIUS_USER	struct
*	O
usr	pointer
=	O
handler_data	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
||	O
argv	pointer
[	O
1	int
]	O
.	O
type	enum
!=	O
CFG_STRING	int
)	O
return	O
1	int
;	O
return	O
radius_get_user_ids	function
(	O
(	O
RADIUS_USER	struct
*	O
)	O
handler_data	pointer
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
)	O
;	O
}	O
int	O
option_stmt_end	function
(	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
exec_user	struct
.	O
username	pointer
&&	O
radiusd_user	struct
.	O
uid	int
!=	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_WARN	int
,	O
_	O
(	O
"Ignoring exec-program-user"	pointer
)	O
)	O
;	O
grad_free	function
(	O
exec_user	struct
.	O
username	pointer
)	O
;	O
exec_user	struct
.	O
username	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
exec_user	struct
.	O
username	pointer
==	O
NULL	O
)	O
radius_get_user_ids	function
(	O
&	O
exec_user	struct
,	O
"daemon"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
cfg_stmt	struct
option_stmt	array
[	O
]	O
=	O
{	O
{	O
"source-ip"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_ipaddr	function
,	O
&	O
myip	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-requests"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_size_t	function
,	O
&	O
max_requests	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-threads"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_size_t	function
,	O
&	O
max_children	long
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-processes"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_size_t	function
,	O
&	O
max_children	long
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"process-idle-timeout"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_unsigned	function
,	O
&	O
process_timeout	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"master-read-timeout"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_unsigned	function
,	O
&	O
radiusd_read_timeout	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"master-write-timeout"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_unsigned	function
,	O
&	O
radiusd_write_timeout	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"exec-program-user"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_user	function
,	O
&	O
exec_user	struct
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"radiusd-user"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_user	function
,	O
&	O
radiusd_user	struct
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"log-dir"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
grad_log_dir	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"acct-dir"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
grad_acct_dir	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"resolve"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
grad_resolve_hostnames	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"username-chars"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
username_valid_chars	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"usr2delay"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct
message_stmt	array
[	O
]	O
=	O
{	O
{	O
"account-closed"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_ACCOUNT_CLOSED	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"password-expired"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_PASSWORD_EXPIRED	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"access-denied"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_ACCESS_DENIED	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"realm-quota"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_REALM_QUOTA	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"multiple-login"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_MULTIPLE_LOGIN	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"second-login"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_SECOND_LOGIN	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"timespan-violation"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_TIMESPAN_VIOLATION	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"password-expire-warning"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
message_text	array
[	O
MSG_PASSWORD_EXPIRE_WARNING	int
]	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct
auth_stmt	array
[	O
]	O
=	O
{	O
{	O
"port"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_port	function
,	O
&	O
auth_port	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"listen"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_listen_auth	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"forward"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_forward_auth	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-requests"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
request_class	struct
[	O
R_AUTH	int
]	O
.	O
max_requests	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"time-to-live"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
request_class	struct
[	O
R_AUTH	int
]	O
.	O
ttl	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"request-cleanup-delay"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
request_class	struct
[	O
R_AUTH	int
]	O
.	O
cleanup_delay	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
auth_detail	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail-file-name"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
auth_detail_template	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"strip-names"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
strip_names	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"checkrad-assume-logged"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
checkrad_assume_logged	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"reject-malformed-names"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
auth_reject_malformed_names	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"password-expire-warning"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_uint32_t	function
,	O
&	O
warning_seconds	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"compare-attribute-flag"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
auth_comp_flag	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"trace-rules"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
auth_trace_rules	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"spawn"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct
acct_stmt	array
[	O
]	O
=	O
{	O
{	O
"port"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_port	function
,	O
&	O
acct_port	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"listen"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_listen_acct	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"forward"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rad_cfg_forward_acct	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"max-requests"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
request_class	struct
[	O
R_ACCT	int
]	O
.	O
max_requests	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"time-to-live"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
request_class	struct
[	O
R_ACCT	int
]	O
.	O
ttl	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"request-cleanup-delay"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
request_class	struct
[	O
R_ACCT	int
]	O
.	O
cleanup_delay	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
acct_detail	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"detail-file-name"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
acct_detail_template	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"system"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
acct_system	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"compare-attribute-flag"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_integer	function
,	O
&	O
acct_comp_flag	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"trace-rules"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
acct_trace_rules	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"spawn"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct
proxy_stmt	array
[	O
]	O
=	O
{	O
{	O
"max-requests"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"request-cleanup-delay"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_obsolete	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct
config_syntax	array
[	O
]	O
=	O
{	O
{	O
"option"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
option_stmt	array
,	O
option_stmt_end	function
}	O
,	O
{	O
"message"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
message_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"logging"	pointer
,	O
CS_BLOCK	int
,	O
logging_stmt_begin	function
,	O
logging_stmt_handler	function
,	O
NULL	O
,	O
logging_stmt	array
,	O
logging_stmt_end	function
}	O
,	O
{	O
"auth"	pointer
,	O
CS_BLOCK	int
,	O
auth_stmt_begin	function
,	O
NULL	O
,	O
NULL	O
,	O
auth_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"acct"	pointer
,	O
CS_BLOCK	int
,	O
acct_stmt_begin	function
,	O
NULL	O
,	O
NULL	O
,	O
acct_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"mlc"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
mlc_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"proxy"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
proxy_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"rewrite"	pointer
,	O
CS_BLOCK	int
,	O
rewrite_stmt_term	function
,	O
NULL	O
,	O
NULL	O
,	O
rewrite_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"filters"	pointer
,	O
CS_BLOCK	int
,	O
filters_stmt_term	function
,	O
NULL	O
,	O
NULL	O
,	O
filters_stmt	array
,	O
NULL	O
}	O
,	O
{	O
"loadable-modules"	pointer
,	O
CS_BLOCK	int
,	O
dynload_stmt_term	function
,	O
NULL	O
,	O
NULL	O
,	O
dynload_stmt	array
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
,	O
}	O
;	O
