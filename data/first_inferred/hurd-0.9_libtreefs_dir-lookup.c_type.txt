error_t	function
_treefs_s_dir_lookup	function
(	O
struct	O
treefs_handle	struct
*	O
h	pointer
,	O
char	O
*	O
path	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
enum	O
retry_type	O
*	O
retry	pointer
,	O
char	O
*	O
retry_name	pointer
,	O
file_t	O
*	O
result	pointer
,	O
mach_msg_type_name_t	O
*	O
result_type	pointer
)	O
{	O
struct	O
treefs_node	struct
*	O
dir	pointer
;	O
struct	O
treefs_node	struct
*	O
node	pointer
;	O
unsigned	O
symlink_expansions	int
=	O
0	int
;	O
error_t	function
err	O
=	O
0	int
;	O
char	O
*	O
path_buf	pointer
=	O
0	int
;	O
int	O
path_buf_len	int
=	O
0	int
;	O
int	O
lastcomp	int
=	O
0	int
;	O
int	O
mustbedir	int
=	O
0	int
;	O
flags	int
&=	O
O_HURD	O
;	O
mode	int
&=	O
~	O
S_IFMT	O
;	O
while	O
(	O
path	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
path	pointer
++	O
;	O
*	O
result_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
retry	pointer
=	O
FS_RETRY_NORMAL	O
;	O
retry_name	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
path	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
dir	pointer
=	O
0	int
;	O
node	pointer
=	O
h	pointer
->	O
po	pointer
->	O
node	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
node	pointer
->	O
lock	int
)	O
;	O
treefs_node_ref	function
(	O
node	pointer
)	O
;	O
goto	O
gotit	O
;	O
}	O
dir	pointer
=	O
h	pointer
->	O
po	pointer
->	O
node	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	int
)	O
;	O
node	pointer
=	O
0	int
;	O
treefs_node_ref	function
(	O
dir	pointer
)	O
;	O
do	O
{	O
char	O
*	O
nextname	pointer
;	O
assert	function
(	O
!	O
lastcomp	int
)	O
;	O
nextname	pointer
=	O
index	function
(	O
path	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
nextname	pointer
)	O
{	O
*	O
nextname	pointer
++	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
nextname	pointer
==	O
'/'	O
)	O
nextname	pointer
++	O
;	O
if	O
(	O
*	O
nextname	pointer
==	O
'\0'	O
)	O
{	O
nextname	pointer
=	O
0	int
;	O
lastcomp	int
=	O
1	int
;	O
mustbedir	int
=	O
1	int
;	O
}	O
else	O
lastcomp	int
=	O
0	int
;	O
}	O
else	O
lastcomp	int
=	O
1	int
;	O
node	pointer
=	O
0	int
;	O
if	O
(	O
!	O
lastcomp	int
)	O
err	O
=	O
treefs_dir_lookup	function
(	O
dir	pointer
,	O
path	pointer
,	O
h	pointer
->	O
auth	pointer
,	O
0	int
,	O
0	int
,	O
&	O
node	pointer
)	O
;	O
else	O
err	O
=	O
treefs_dir_lookup	function
(	O
dir	pointer
,	O
path	pointer
,	O
h	pointer
->	O
auth	pointer
,	O
flags	int
,	O
mode	int
|	O
S_IFREG	O
,	O
&	O
node	pointer
)	O
;	O
if	O
(	O
err	O
==	O
EAGAIN	O
)	O
{	O
if	O
(	O
h	pointer
->	O
po	pointer
->	O
parent_port	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
*	O
retry	pointer
=	O
FS_RETRY_REAUTH	O
;	O
*	O
result	pointer
=	O
h	pointer
->	O
po	pointer
->	O
parent_port	int
;	O
*	O
result_type	pointer
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
if	O
(	O
!	O
lastcomp	int
)	O
strcpy	function
(	O
retry_name	pointer
,	O
nextname	pointer
)	O
;	O
err	O
=	O
0	int
;	O
goto	O
out	O
;	O
}	O
else	O
{	O
err	O
=	O
0	int
;	O
node	pointer
=	O
dir	pointer
;	O
treefs_node_ref	function
(	O
node	pointer
)	O
;	O
}	O
}	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
if	O
(	O
(	O
!	O
lastcomp	int
||	O
!	O
(	O
flags	int
&	O
O_NOTRANS	O
)	O
)	O
&&	O
node	pointer
!=	O
dir	pointer
)	O
{	O
file_t	O
dir_port	pointer
=	O
MACH_PORT_NULL	O
,	O
child_fsys	O
;	O
pthread_mutex_unlock	function
(	O
&	O
node	pointer
->	O
lock	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	int
)	O
;	O
do	O
{	O
err	O
=	O
treefs_node_get_active_trans	function
(	O
node	pointer
,	O
dir	pointer
,	O
h	pointer
->	O
po	pointer
->	O
parent_port	int
,	O
&	O
dir_port	pointer
,	O
&	O
child_fsys	O
)	O
;	O
if	O
(	O
err	O
==	O
0	int
&&	O
child_fsys	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
err	O
=	O
fsys_getroot	function
(	O
child_fsys	O
,	O
dir_port	pointer
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
h	pointer
->	O
auth	pointer
->	O
uids	pointer
,	O
h	pointer
->	O
auth	pointer
->	O
nuids	int
,	O
h	pointer
->	O
auth	pointer
->	O
gids	pointer
,	O
h	pointer
->	O
auth	pointer
->	O
ngids	int
,	O
lastcomp	int
?	O
flags	int
:	O
0	int
,	O
retry	pointer
,	O
retry_name	pointer
,	O
result	pointer
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
||	O
err	O
==	O
EMIG_SERVER_DIED	O
)	O
treefs_node_drop_active_trans	function
(	O
node	pointer
,	O
child_fsys	O
)	O
;	O
}	O
}	O
while	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
||	O
err	O
==	O
EMIG_SERVER_DIED	O
)	O
;	O
if	O
(	O
err	O
||	O
child_fsys	O
)	O
{	O
if	O
(	O
!	O
err	O
&&	O
!	O
lastcomp	int
)	O
{	O
strcat	function
(	O
retry_name	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
retry_name	pointer
,	O
nextname	pointer
)	O
;	O
}	O
*	O
result_type	pointer
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
treefs_node_unref	function
(	O
dir	pointer
)	O
;	O
treefs_node_unref	function
(	O
node	pointer
)	O
;	O
if	O
(	O
dir_port	pointer
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
dir_port	pointer
)	O
;	O
return	O
err	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
".."	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
pthread_mutex_trylock	function
(	O
&	O
dir	pointer
->	O
lock	int
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
node	pointer
->	O
lock	int
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	int
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
node	pointer
->	O
lock	int
)	O
;	O
}	O
}	O
else	O
pthread_mutex_lock	function
(	O
&	O
dir	pointer
->	O
lock	int
)	O
;	O
}	O
if	O
(	O
treefs_node_type	function
(	O
node	pointer
)	O
==	O
S_IFLNK	O
&&	O
!	O
(	O
lastcomp	int
&&	O
(	O
flags	int
&	O
(	O
O_NOLINK	O
|	O
O_NOTRANS	O
)	O
)	O
)	O
)	O
{	O
unsigned	O
nextname_len	int
=	O
nextname	pointer
?	O
strlen	function
(	O
nextname	pointer
)	O
+	O
1	int
:	O
0	int
;	O
unsigned	O
sym_len	int
=	O
path_buf_len	int
-	O
nextname_len	int
-	O
1	int
;	O
if	O
(	O
symlink_expansions	int
++	O
>	O
node	pointer
->	O
fsys	pointer
->	O
max_symlinks	int
)	O
{	O
err	O
=	O
ELOOP	O
;	O
goto	O
out	O
;	O
}	O
err	O
=	O
treefs_node_get_symlink	function
(	O
node	pointer
,	O
path_buf	pointer
,	O
&	O
sym_len	int
)	O
;	O
if	O
(	O
err	O
==	O
E2BIG	O
)	O
{	O
path_buf_len	int
=	O
sym_len	int
+	O
nextname_len	int
+	O
1	int
+	O
1	int
;	O
path_buf	pointer
=	O
alloca	O
(	O
path_buf_len	int
)	O
;	O
err	O
=	O
treefs_node_get_symlink	function
(	O
node	pointer
,	O
path_buf	pointer
,	O
&	O
sym_len	int
)	O
;	O
}	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
if	O
(	O
nextname	pointer
)	O
{	O
path_buf	pointer
[	O
sym_len	int
]	O
=	O
'/'	O
;	O
bcopy	function
(	O
nextname	pointer
,	O
path_buf	pointer
+	O
sym_len	int
+	O
1	int
,	O
nextname_len	int
-	O
1	int
)	O
;	O
}	O
if	O
(	O
mustbedir	int
)	O
{	O
path_buf	pointer
[	O
nextnamelen	O
+	O
sym_len	int
]	O
=	O
'/'	O
;	O
path_buf	pointer
[	O
nextnamelen	O
+	O
sym_len	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
path_buf	pointer
[	O
nextname_len	int
+	O
sym_len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
path_buf	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
*	O
retry	pointer
=	O
FS_RETRY_MAGICAL	O
;	O
*	O
result	pointer
=	O
MACH_PORT_NULL	O
;	O
strcpy	function
(	O
retry_name	pointer
,	O
path_buf	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
path	pointer
=	O
path_buf	pointer
;	O
mustbedir	int
=	O
0	int
;	O
if	O
(	O
lastcomp	int
)	O
{	O
lastcomp	int
=	O
0	int
;	O
flags	int
&=	O
~	O
O_CREAT	int
;	O
}	O
treefs_node_release	function
(	O
node	pointer
)	O
;	O
node	pointer
=	O
0	int
;	O
}	O
else	O
{	O
path	pointer
=	O
nextname	pointer
;	O
if	O
(	O
node	pointer
==	O
dir	pointer
)	O
treefs_node_unref	function
(	O
dir	pointer
)	O
;	O
else	O
treefs_node_release	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
!	O
lastcomp	int
)	O
{	O
dir	pointer
=	O
node	pointer
;	O
node	pointer
=	O
0	int
;	O
}	O
else	O
dir	pointer
=	O
0	int
;	O
}	O
}	O
while	O
(	O
path	pointer
&&	O
*	O
path	pointer
)	O
;	O
gotit	O
:	O
if	O
(	O
mustbedir	int
&&	O
!	O
treefs_node_isdir	function
(	O
node	pointer
)	O
)	O
err	O
=	O
ENOTDIR	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
err	O
=	O
treefs_node_create_right	function
(	O
node	pointer
,	O
flags	int
,	O
h	pointer
->	O
po	pointer
->	O
parent_port	int
,	O
h	pointer
->	O
auth	pointer
,	O
result	pointer
)	O
;	O
out	O
:	O
if	O
(	O
node	pointer
)	O
{	O
if	O
(	O
dir	pointer
==	O
node	pointer
)	O
treefs_node_unref	function
(	O
node	pointer
)	O
;	O
else	O
treefs_node_release	function
(	O
node	pointer
)	O
;	O
}	O
if	O
(	O
dir	pointer
)	O
treefs_node_release	function
(	O
dir	pointer
)	O
;	O
return	O
err	O
;	O
}	O
