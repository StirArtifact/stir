void	O
usage	function
(	O
void	O
)	O
;	O
static	O
int	O
peer	int
;	O
static	O
int	O
rexmtval	int
=	O
TIMEOUT	int
;	O
static	O
int	O
maxtimeout	int
=	O
5	int
*	O
TIMEOUT	int
;	O
static	O
char	O
buf	array
[	O
PKTSIZE	O
]	O
;	O
static	O
char	O
ackbuf	array
[	O
PKTSIZE	O
]	O
;	O
static	O
struct	O
sockaddr_storage	struct
from	struct
;	O
static	O
socklen_t	int
fromlen	int
;	O
void	O
tftp	function
(	O
struct	O
tftphdr	struct
*	O
,	O
int	O
)	O
;	O
static	O
struct	O
dirlist	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
len	int
;	O
}	O
dirs	array
[	O
MAXDIRS	int
+	O
1	int
]	O
;	O
static	O
int	O
suppress_naks	int
;	O
static	O
int	O
logging	int
;	O
static	O
const	O
char	O
*	O
errtomsg	function
(	O
int	O
)	O
;	O
static	O
void	O
nak	function
(	O
int	O
)	O
;	O
static	O
const	O
char	O
*	O
verifyhost	function
(	O
struct	O
sockaddr_storage	struct
*	O
,	O
socklen_t	int
)	O
;	O
static	O
struct	O
argp_option	struct
options	pointer
[	O
]	O
=	O
{	O
{	O
"logging"	pointer
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"enable logging"	pointer
}	O
,	O
{	O
"nonexistent"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"supress negative acknowledgement of requests for "	pointer
"nonexistent relative filenames"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'l'	O
:	O
logging	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
suppress_naks	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	pointer
,	O
parse_opt	function
,	O
"directory..."	pointer
,	O
"Trivial File Transfer Protocol server"	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
index	function
;	O
register	O
struct	O
tftphdr	struct
*	O
tp	pointer
;	O
int	O
on	int
,	O
n	int
;	O
struct	O
sockaddr_storage	struct
sin	struct
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"tftpd"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
&	O
index	function
,	O
NULL	O
)	O
;	O
openlog	function
(	O
"tftpd"	pointer
,	O
LOG_PID	int
,	O
LOG_FTP	O
)	O
;	O
if	O
(	O
index	function
<	O
argc	int
)	O
{	O
struct	O
dirlist	struct
*	O
dirp	pointer
;	O
for	O
(	O
dirp	pointer
=	O
dirs	array
;	O
index	function
<	O
argc	int
&&	O
dirp	pointer
<	O
&	O
dirs	array
[	O
MAXDIRS	int
]	O
;	O
index	function
++	O
)	O
{	O
if	O
(	O
argv	pointer
[	O
index	function
]	O
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
dirp	pointer
->	O
name	pointer
=	O
argv	pointer
[	O
index	function
]	O
;	O
dirp	pointer
->	O
len	int
=	O
strlen	function
(	O
dirp	pointer
->	O
name	pointer
)	O
;	O
dirp	pointer
++	O
;	O
}	O
}	O
}	O
on	int
=	O
1	int
;	O
if	O
(	O
ioctl	function
(	O
0	int
,	O
FIONBIO	int
,	O
&	O
on	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"ioctl(FIONBIO): %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fromlen	int
=	O
sizeof	O
(	O
from	struct
)	O
;	O
n	int
=	O
recvfrom	function
(	O
0	int
,	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
&	O
fromlen	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"recvfrom: %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
int	O
pid	int
;	O
int	O
i	int
;	O
socklen_t	int
j	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
20	int
;	O
i	int
++	O
)	O
{	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
sleep	function
(	O
i	int
)	O
;	O
j	int
=	O
sizeof	O
from	struct
;	O
i	int
=	O
recvfrom	function
(	O
0	int
,	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
&	O
j	int
)	O
;	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
n	int
=	O
i	int
;	O
fromlen	int
=	O
j	int
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"fork: %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
!=	O
0	int
)	O
{	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
alarm	function
(	O
0	int
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
peer	int
=	O
socket	function
(	O
from	struct
.	O
ss_family	short
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
peer	int
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"socket: %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
memset	function
(	O
&	O
sin	struct
,	O
0	int
,	O
sizeof	O
(	O
sin	struct
)	O
)	O
;	O
sin	struct
.	O
ss_family	short
=	O
from	struct
.	O
ss_family	short
;	O
if	O
(	O
bind	function
(	O
peer	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sin	struct
,	O
fromlen	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"bind: %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
tp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
buf	array
;	O
tp	pointer
->	O
th_opcode	short
=	O
ntohs	function
(	O
tp	pointer
->	O
th_opcode	short
)	O
;	O
if	O
(	O
tp	pointer
->	O
th_opcode	short
==	O
RRQ	int
||	O
tp	pointer
->	O
th_opcode	short
==	O
WRQ	int
)	O
tftp	function
(	O
tp	pointer
,	O
n	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
struct	O
formats	struct
;	O
int	O
validate_access	function
(	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
void	O
send_file	function
(	O
struct	O
formats	struct
*	O
)	O
;	O
void	O
recvfile	function
(	O
struct	O
formats	struct
*	O
)	O
;	O
struct	O
formats	struct
{	O
char	O
*	O
f_mode	pointer
;	O
int	O
(	O
*	O
f_validate	pointer
)	O
(	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
void	O
(	O
*	O
f_send	pointer
)	O
(	O
struct	O
formats	struct
*	O
)	O
;	O
void	O
(	O
*	O
f_recv	pointer
)	O
(	O
struct	O
formats	struct
*	O
)	O
;	O
int	O
f_convert	int
;	O
}	O
formats	struct
[	O
]	O
=	O
{	O
{	O
"netascii"	pointer
,	O
validate_access	function
,	O
send_file	function
,	O
recvfile	function
,	O
1	int
}	O
,	O
{	O
"octet"	pointer
,	O
validate_access	function
,	O
send_file	function
,	O
recvfile	function
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
void	O
tftp	function
(	O
struct	O
tftphdr	struct
*	O
tp	pointer
,	O
int	O
size	int
)	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
int	O
first	int
=	O
1	int
,	O
ecode	int
;	O
register	O
struct	O
formats	struct
*	O
pf	pointer
;	O
char	O
*	O
filename	pointer
,	O
*	O
mode	pointer
;	O
filename	pointer
=	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
&	O
(	O
tp	pointer
->	O
th_stuff	O
)	O
;	O
again	O
:	O
while	O
(	O
cp	pointer
<	O
buf	array
+	O
size	int
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'\0'	O
)	O
break	O
;	O
cp	pointer
++	O
;	O
}	O
if	O
(	O
*	O
cp	pointer
!=	O
'\0'	O
)	O
{	O
nak	function
(	O
EBADOP	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
first	int
)	O
{	O
mode	pointer
=	O
++	O
cp	pointer
;	O
first	int
=	O
0	int
;	O
goto	O
again	O
;	O
}	O
for	O
(	O
cp	pointer
=	O
mode	pointer
;	O
*	O
cp	pointer
;	O
cp	pointer
++	O
)	O
if	O
(	O
isupper	function
(	O
*	O
cp	pointer
)	O
)	O
*	O
cp	pointer
=	O
tolower	function
(	O
*	O
cp	pointer
)	O
;	O
for	O
(	O
pf	pointer
=	O
formats	struct
;	O
pf	pointer
->	O
f_mode	pointer
;	O
pf	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
pf	pointer
->	O
f_mode	pointer
,	O
mode	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
pf	pointer
->	O
f_mode	pointer
==	O
0	int
)	O
{	O
nak	function
(	O
EBADOP	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
ecode	int
=	O
(	O
*	O
pf	pointer
->	O
f_validate	pointer
)	O
(	O
&	O
filename	pointer
,	O
tp	pointer
->	O
th_opcode	short
)	O
;	O
if	O
(	O
logging	int
)	O
{	O
char	O
*	O
family	pointer
;	O
switch	O
(	O
from	struct
.	O
ss_family	short
)	O
{	O
case	O
AF_INET	O
:	O
family	pointer
=	O
"IPv4"	pointer
;	O
break	O
;	O
case	O
AF_INET6	O
:	O
family	pointer
=	O
"IPv6"	pointer
;	O
break	O
;	O
default	O
:	O
family	pointer
=	O
"?"	pointer
;	O
}	O
syslog	function
(	O
LOG_INFO	int
,	O
"%s (%s): %s request for %s: %s"	pointer
,	O
verifyhost	function
(	O
&	O
from	struct
,	O
fromlen	int
)	O
,	O
family	pointer
,	O
tp	pointer
->	O
th_opcode	short
==	O
WRQ	int
?	O
"write"	pointer
:	O
"read"	pointer
,	O
filename	pointer
,	O
errtomsg	function
(	O
ecode	int
)	O
)	O
;	O
}	O
if	O
(	O
ecode	int
)	O
{	O
if	O
(	O
suppress_naks	int
&&	O
*	O
filename	pointer
!=	O
'/'	O
&&	O
ecode	int
==	O
ENOTFOUND	int
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
nak	function
(	O
ecode	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
tp	pointer
->	O
th_opcode	short
==	O
WRQ	int
)	O
(	O
*	O
pf	pointer
->	O
f_recv	pointer
)	O
(	O
pf	pointer
)	O
;	O
else	O
(	O
*	O
pf	pointer
->	O
f_send	pointer
)	O
(	O
pf	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
FILE	struct
*	O
file	pointer
;	O
int	O
validate_access	function
(	O
char	O
*	O
*	O
filep	pointer
,	O
int	O
mode	pointer
)	O
{	O
struct	O
stat	struct
stbuf	struct
;	O
int	O
fd	int
;	O
struct	O
dirlist	struct
*	O
dirp	pointer
;	O
static	O
char	O
*	O
pathname	pointer
=	O
0	int
;	O
char	O
*	O
filename	pointer
=	O
*	O
filep	pointer
;	O
if	O
(	O
strstr	function
(	O
filename	pointer
,	O
"/../"	pointer
)	O
)	O
return	O
(	O
EACCESS	int
)	O
;	O
if	O
(	O
*	O
filename	pointer
==	O
'/'	O
)	O
{	O
for	O
(	O
dirp	pointer
=	O
dirs	array
;	O
dirp	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
dirp	pointer
++	O
)	O
{	O
if	O
(	O
dirp	pointer
->	O
len	int
==	O
1	int
||	O
(	O
!	O
strncmp	function
(	O
filename	pointer
,	O
dirp	pointer
->	O
name	pointer
,	O
dirp	pointer
->	O
len	int
)	O
&&	O
filename	pointer
[	O
dirp	pointer
->	O
len	int
]	O
==	O
'/'	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
dirp	pointer
->	O
name	pointer
==	O
NULL	O
&&	O
dirp	pointer
!=	O
dirs	array
)	O
return	O
(	O
EACCESS	int
)	O
;	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
stbuf	struct
)	O
<	O
0	int
)	O
return	O
(	O
errno	O
==	O
ENOENT	int
?	O
ENOTFOUND	int
:	O
EACCESS	int
)	O
;	O
if	O
(	O
(	O
stbuf	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
!=	O
S_IFREG	O
)	O
return	O
(	O
ENOTFOUND	int
)	O
;	O
if	O
(	O
mode	pointer
==	O
RRQ	int
)	O
{	O
if	O
(	O
(	O
stbuf	struct
.	O
st_mode	int
&	O
S_IROTH	O
)	O
==	O
0	int
)	O
return	O
(	O
EACCESS	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
stbuf	struct
.	O
st_mode	int
&	O
S_IWOTH	O
)	O
==	O
0	int
)	O
return	O
(	O
EACCESS	int
)	O
;	O
}	O
}	O
else	O
{	O
int	O
err	long
;	O
if	O
(	O
mode	pointer
!=	O
RRQ	int
||	O
!	O
strncmp	function
(	O
filename	pointer
,	O
"../"	pointer
,	O
3	int
)	O
)	O
return	O
(	O
EACCESS	int
)	O
;	O
err	long
=	O
ENOTFOUND	int
;	O
for	O
(	O
dirp	pointer
=	O
dirs	array
;	O
dirp	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
dirp	pointer
++	O
)	O
{	O
free	function
(	O
pathname	pointer
)	O
;	O
pathname	pointer
=	O
malloc	function
(	O
strlen	function
(	O
dirp	pointer
->	O
name	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
filename	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
pathname	pointer
)	O
return	O
ENOMEM	int
;	O
sprintf	function
(	O
pathname	pointer
,	O
"%s/%s"	pointer
,	O
dirp	pointer
->	O
name	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
pathname	pointer
,	O
&	O
stbuf	struct
)	O
==	O
0	int
&&	O
(	O
stbuf	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFREG	O
)	O
{	O
if	O
(	O
(	O
stbuf	struct
.	O
st_mode	int
&	O
S_IROTH	O
)	O
!=	O
0	int
)	O
{	O
break	O
;	O
}	O
err	long
=	O
EACCESS	int
;	O
}	O
}	O
if	O
(	O
dirp	pointer
->	O
name	pointer
==	O
NULL	O
)	O
return	O
(	O
err	long
)	O
;	O
*	O
filep	pointer
=	O
filename	pointer
=	O
pathname	pointer
;	O
}	O
fd	int
=	O
open	function
(	O
filename	pointer
,	O
mode	pointer
==	O
RRQ	int
?	O
O_RDONLY	int
:	O
(	O
O_WRONLY	int
|	O
O_TRUNC	int
)	O
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
(	O
errno	O
+	O
100	int
)	O
;	O
file	pointer
=	O
fdopen	function
(	O
fd	int
,	O
(	O
mode	pointer
==	O
RRQ	int
)	O
?	O
"r"	pointer
:	O
"w"	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
return	O
errno	O
+	O
100	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
timeout	int
;	O
jmp_buf	array
timeoutbuf	array
;	O
void	O
timer	function
(	O
int	O
sig	int
)	O
{	O
timeout	int
+=	O
rexmtval	int
;	O
if	O
(	O
timeout	int
>=	O
maxtimeout	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
siglongjmp	function
(	O
timeoutbuf	array
,	O
1	int
)	O
;	O
}	O
void	O
send_file	function
(	O
struct	O
formats	struct
*	O
pf	pointer
)	O
{	O
struct	O
tftphdr	struct
*	O
dp	pointer
,	O
*	O
r_init	function
(	O
void	O
)	O
;	O
register	O
struct	O
tftphdr	struct
*	O
ap	pointer
;	O
register	O
int	O
size	int
,	O
n	int
;	O
volatile	O
int	O
block	int
;	O
signal	function
(	O
SIGALRM	int
,	O
timer	function
)	O
;	O
dp	pointer
=	O
r_init	function
(	O
)	O
;	O
ap	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
ackbuf	array
;	O
block	int
=	O
1	int
;	O
do	O
{	O
size	int
=	O
readit	function
(	O
file	pointer
,	O
&	O
dp	pointer
,	O
pf	pointer
->	O
f_convert	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
nak	function
(	O
errno	O
+	O
100	int
)	O
;	O
goto	O
abort	function
;	O
}	O
dp	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
DATA	int
)	O
;	O
dp	pointer
->	O
th_block	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
timeout	int
=	O
0	int
;	O
sigsetjmp	O
(	O
timeoutbuf	array
,	O
SIGALRM	int
)	O
;	O
send_data	O
:	O
if	O
(	O
sendto	function
(	O
peer	int
,	O
(	O
const	O
char	O
*	O
)	O
dp	pointer
,	O
size	int
+	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
fromlen	int
)	O
!=	O
size	int
+	O
4	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"tftpd: write: %m\n"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
read_ahead	function
(	O
file	pointer
,	O
pf	pointer
->	O
f_convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	function
(	O
rexmtval	int
)	O
;	O
n	int
=	O
recv	function
(	O
peer	int
,	O
ackbuf	array
,	O
sizeof	O
(	O
ackbuf	array
)	O
,	O
0	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"tftpd: read: %m\n"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
ap	pointer
->	O
th_opcode	short
=	O
ntohs	function
(	O
(	O
unsigned	O
short	O
)	O
ap	pointer
->	O
th_opcode	short
)	O
;	O
ap	pointer
->	O
th_block	O
=	O
ntohs	function
(	O
(	O
unsigned	O
short	O
)	O
ap	pointer
->	O
th_block	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
th_opcode	short
==	O
ERROR	int
)	O
goto	O
abort	function
;	O
if	O
(	O
ap	pointer
->	O
th_opcode	short
==	O
ACK	int
)	O
{	O
if	O
(	O
(	O
unsigned	O
short	O
)	O
ap	pointer
->	O
th_block	O
==	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
break	O
;	O
synchnet	function
(	O
peer	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
short	O
)	O
ap	pointer
->	O
th_block	O
==	O
(	O
unsigned	O
short	O
)	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_data	O
;	O
}	O
}	O
block	int
++	O
;	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
)	O
;	O
abort	function
:	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
void	O
justquit	function
(	O
int	O
sig	int
)	O
{	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
recvfile	function
(	O
struct	O
formats	struct
*	O
pf	pointer
)	O
{	O
struct	O
tftphdr	struct
*	O
dp	pointer
,	O
*	O
w_init	function
(	O
void	O
)	O
;	O
register	O
struct	O
tftphdr	struct
*	O
ap	pointer
;	O
register	O
int	O
n	int
,	O
size	int
;	O
volatile	O
int	O
block	int
;	O
signal	function
(	O
SIGALRM	int
,	O
timer	function
)	O
;	O
dp	pointer
=	O
w_init	function
(	O
)	O
;	O
ap	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
ackbuf	array
;	O
block	int
=	O
0	int
;	O
do	O
{	O
timeout	int
=	O
0	int
;	O
ap	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	pointer
->	O
th_block	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
block	int
++	O
;	O
sigsetjmp	O
(	O
timeoutbuf	array
,	O
SIGALRM	int
)	O
;	O
send_ack	O
:	O
if	O
(	O
sendto	function
(	O
peer	int
,	O
ackbuf	array
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
fromlen	int
)	O
!=	O
4	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"tftpd: write: %m\n"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
write_behind	function
(	O
file	pointer
,	O
pf	pointer
->	O
f_convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	function
(	O
rexmtval	int
)	O
;	O
n	int
=	O
recv	function
(	O
peer	int
,	O
(	O
char	O
*	O
)	O
dp	pointer
,	O
PKTSIZE	O
,	O
0	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"tftpd: read: %m\n"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
dp	pointer
->	O
th_opcode	short
=	O
ntohs	function
(	O
(	O
unsigned	O
short	O
)	O
dp	pointer
->	O
th_opcode	short
)	O
;	O
dp	pointer
->	O
th_block	O
=	O
ntohs	function
(	O
(	O
unsigned	O
short	O
)	O
dp	pointer
->	O
th_block	O
)	O
;	O
if	O
(	O
dp	pointer
->	O
th_opcode	short
==	O
ERROR	int
)	O
goto	O
abort	function
;	O
if	O
(	O
dp	pointer
->	O
th_opcode	short
==	O
DATA	int
)	O
{	O
if	O
(	O
dp	pointer
->	O
th_block	O
==	O
block	int
)	O
{	O
break	O
;	O
}	O
synchnet	function
(	O
peer	int
)	O
;	O
if	O
(	O
dp	pointer
->	O
th_block	O
==	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_ack	O
;	O
}	O
}	O
size	int
=	O
writeit	function
(	O
file	pointer
,	O
&	O
dp	pointer
,	O
n	int
-	O
4	int
,	O
pf	pointer
->	O
f_convert	int
)	O
;	O
if	O
(	O
size	int
!=	O
(	O
n	int
-	O
4	int
)	O
)	O
{	O
if	O
(	O
size	int
<	O
0	int
)	O
nak	function
(	O
errno	O
+	O
100	int
)	O
;	O
else	O
nak	function
(	O
ENOSPACE	int
)	O
;	O
goto	O
abort	function
;	O
}	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
)	O
;	O
write_behind	function
(	O
file	pointer
,	O
pf	pointer
->	O
f_convert	int
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
ap	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	pointer
->	O
th_block	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
(	O
block	int
)	O
)	O
;	O
sendto	function
(	O
peer	int
,	O
ackbuf	array
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
fromlen	int
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
justquit	function
)	O
;	O
alarm	function
(	O
rexmtval	int
)	O
;	O
n	int
=	O
recv	function
(	O
peer	int
,	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
0	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
n	int
>=	O
4	int
&&	O
dp	pointer
->	O
th_opcode	short
==	O
DATA	int
&&	O
block	int
==	O
dp	pointer
->	O
th_block	O
)	O
{	O
sendto	function
(	O
peer	int
,	O
ackbuf	array
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
fromlen	int
)	O
;	O
}	O
abort	function
:	O
return	O
;	O
}	O
struct	O
errmsg	struct
{	O
int	O
e_code	int
;	O
const	O
char	O
*	O
e_msg	pointer
;	O
}	O
errmsgs	array
[	O
]	O
=	O
{	O
{	O
EUNDEF	int
,	O
"Undefined error code"	pointer
}	O
,	O
{	O
ENOTFOUND	int
,	O
"File not found"	pointer
}	O
,	O
{	O
EACCESS	int
,	O
"Access violation"	pointer
}	O
,	O
{	O
ENOSPACE	int
,	O
"Disk full or allocation exceeded"	pointer
}	O
,	O
{	O
EBADOP	int
,	O
"Illegal TFTP operation"	pointer
}	O
,	O
{	O
EBADID	int
,	O
"Unknown transfer ID"	pointer
}	O
,	O
{	O
EEXISTS	int
,	O
"File already exists"	pointer
}	O
,	O
{	O
ENOUSER	int
,	O
"No such user"	pointer
}	O
,	O
{	O
-	O
1	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
*	O
errtomsg	function
(	O
int	O
error	int
)	O
{	O
static	O
char	O
buf	array
[	O
20	int
]	O
;	O
register	O
struct	O
errmsg	struct
*	O
pe	pointer
;	O
if	O
(	O
error	int
==	O
0	int
)	O
return	O
"success"	pointer
;	O
for	O
(	O
pe	pointer
=	O
errmsgs	array
;	O
pe	pointer
->	O
e_code	int
>=	O
0	int
;	O
pe	pointer
++	O
)	O
if	O
(	O
pe	pointer
->	O
e_code	int
==	O
error	int
)	O
return	O
pe	pointer
->	O
e_msg	pointer
;	O
sprintf	function
(	O
buf	array
,	O
"error %d"	pointer
,	O
error	int
)	O
;	O
return	O
buf	array
;	O
}	O
static	O
void	O
nak	function
(	O
int	O
error	int
)	O
{	O
register	O
struct	O
tftphdr	struct
*	O
tp	pointer
;	O
int	O
length	int
;	O
register	O
struct	O
errmsg	struct
*	O
pe	pointer
;	O
tp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
buf	array
;	O
tp	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
ERROR	int
)	O
;	O
tp	pointer
->	O
th_code	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
error	int
)	O
;	O
for	O
(	O
pe	pointer
=	O
errmsgs	array
;	O
pe	pointer
->	O
e_code	int
>=	O
0	int
;	O
pe	pointer
++	O
)	O
if	O
(	O
pe	pointer
->	O
e_code	int
==	O
error	int
)	O
break	O
;	O
if	O
(	O
pe	pointer
->	O
e_code	int
<	O
0	int
)	O
{	O
pe	pointer
->	O
e_msg	pointer
=	O
strerror	function
(	O
error	int
-	O
100	int
)	O
;	O
tp	pointer
->	O
th_code	O
=	O
EUNDEF	int
;	O
}	O
strcpy	function
(	O
tp	pointer
->	O
th_msg	O
,	O
pe	pointer
->	O
e_msg	pointer
)	O
;	O
length	int
=	O
strlen	function
(	O
pe	pointer
->	O
e_msg	pointer
)	O
;	O
tp	pointer
->	O
th_msg	O
[	O
length	int
]	O
=	O
'\0'	O
;	O
length	int
+=	O
5	int
;	O
if	O
(	O
sendto	function
(	O
peer	int
,	O
buf	array
,	O
length	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
fromlen	int
)	O
!=	O
length	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"nak: %m\n"	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
verifyhost	function
(	O
struct	O
sockaddr_storage	struct
*	O
fromp	pointer
,	O
socklen_t	int
frlen	int
)	O
{	O
int	O
rc	int
;	O
static	O
char	O
host	pointer
[	O
NI_MAXHOST	int
]	O
;	O
rc	int
=	O
getnameinfo	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
fromp	pointer
,	O
frlen	int
,	O
host	pointer
,	O
sizeof	O
(	O
host	pointer
)	O
,	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
return	O
host	pointer
;	O
else	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"getnameinfo: %s\n"	pointer
,	O
gai_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
"0.0.0.0"	pointer
;	O
}	O
}	O
static	O
const	O
char	O
usage_str	array
[	O
]	O
=	O
"Usage: tftpd [OPTIONS...]\n"	pointer
"\n"	pointer
"Options are:\n"	pointer
"   -l                      Enable logging\n"	pointer
"   -n                      Supress negative acknowledgement of\n"	pointer
"                           requests for nonexistent relative filenames\n"	pointer
"       --help              Display usage instructions\n"	pointer
"       --version           Display program version\n"	pointer
;	O
void	O
usage	function
(	O
void	O
)	O
{	O
printf	function
(	O
"%s\n"	pointer
"Send bug reports to <%s>\n"	pointer
,	O
usage_str	array
,	O
PACKAGE_BUGREPORT	pointer
)	O
;	O
}	O
