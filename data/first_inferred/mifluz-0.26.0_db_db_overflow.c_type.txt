static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_overflow.c,v 1.5 2000/06/28 16:47:01 loic Exp $"	pointer
;	O
int	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
dbt	struct
,	O
tlen	int
,	O
pgno	int
,	O
bpp	pointer
,	O
bpsz	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
*	O
dbt	struct
;	O
u_int32_t	int
tlen	int
;	O
db_pgno_t	int
pgno	int
;	O
void	O
*	O
*	O
bpp	pointer
;	O
u_int32_t	int
*	O
bpsz	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_indx_t	short
bytes	long
;	O
u_int32_t	int
curoff	int
,	O
needed	int
,	O
start	int
;	O
u_int8_t	char
*	O
p	pointer
,	O
*	O
src	pointer
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
start	int
=	O
dbt	struct
->	O
doff	int
;	O
needed	int
=	O
dbt	struct
->	O
dlen	int
;	O
}	O
else	O
{	O
start	int
=	O
0	int
;	O
needed	int
=	O
tlen	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_USERMEM	int
)	O
)	O
{	O
if	O
(	O
needed	int
>	O
dbt	struct
->	O
ulen	int
)	O
{	O
dbt	struct
->	O
size	int
=	O
needed	int
;	O
return	O
(	O
ENOMEM	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_MALLOC	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
needed	int
,	O
dbp	pointer
->	O
db_malloc	pointer
,	O
&	O
dbt	struct
->	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_REALLOC	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbenv	pointer
,	O
needed	int
,	O
dbp	pointer
->	O
db_realloc	pointer
,	O
&	O
dbt	struct
->	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
bpsz	pointer
==	O
0	int
||	O
*	O
bpsz	pointer
<	O
needed	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbenv	pointer
,	O
needed	int
,	O
NULL	O
,	O
bpp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
bpsz	pointer
=	O
needed	int
;	O
dbt	struct
->	O
data	pointer
=	O
*	O
bpp	pointer
;	O
}	O
else	O
dbt	struct
->	O
data	pointer
=	O
*	O
bpp	pointer
;	O
dbt	struct
->	O
size	int
=	O
needed	int
;	O
for	O
(	O
curoff	int
=	O
0	int
,	O
p	pointer
=	O
dbt	struct
->	O
data	pointer
;	O
pgno	int
!=	O
PGNO_INVALID	int
&&	O
needed	int
>	O
0	int
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___db_pgerr	function
(	O
dbp	pointer
,	O
pgno	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
curoff	int
+	O
OV_LEN	O
(	O
h	pointer
)	O
>=	O
start	int
)	O
{	O
src	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
P_OVERHEAD	O
;	O
bytes	long
=	O
OV_LEN	O
(	O
h	pointer
)	O
;	O
if	O
(	O
start	int
>	O
curoff	int
)	O
{	O
src	pointer
+=	O
start	int
-	O
curoff	int
;	O
bytes	long
-=	O
start	int
-	O
curoff	int
;	O
}	O
if	O
(	O
bytes	long
>	O
needed	int
)	O
bytes	long
=	O
needed	int
;	O
memcpy	function
(	O
p	pointer
,	O
src	pointer
,	O
bytes	long
)	O
;	O
p	pointer
+=	O
bytes	long
;	O
needed	int
-=	O
bytes	long
;	O
}	O
curoff	int
+=	O
OV_LEN	O
(	O
h	pointer
)	O
;	O
pgno	int
=	O
h	pointer
->	O
next_pgno	int
;	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_poff	function
(	O
dbc	pointer
,	O
dbt	struct
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
DBT	struct
*	O
dbt	struct
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
pagep	pointer
,	O
*	O
lastp	pointer
;	O
DB_LSN	struct
new_lsn	struct
,	O
null_lsn	struct
;	O
DBT	struct
tmp_dbt	struct
;	O
db_indx_t	short
pagespace	short
;	O
u_int32_t	int
sz	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
pagespace	short
=	O
P_MAXSPACE	O
(	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
lastp	pointer
=	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
dbt	struct
->	O
data	pointer
,	O
sz	int
=	O
dbt	struct
->	O
size	int
;	O
sz	int
>	O
0	int
;	O
p	pointer
+=	O
pagespace	short
,	O
sz	int
-=	O
pagespace	short
)	O
{	O
if	O
(	O
sz	int
<	O
pagespace	short
)	O
pagespace	short
=	O
sz	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
(	O
P_OVERFLOW	int
|	O
dbp	pointer
->	O
tags	char
)	O
,	O
&	O
pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
tmp_dbt	struct
.	O
data	pointer
=	O
p	pointer
;	O
tmp_dbt	struct
.	O
size	int
=	O
pagespace	short
;	O
ZERO_LSN	O
(	O
null_lsn	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_big_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
DB_ADD_BIG	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
lastp	pointer
?	O
PGNO	O
(	O
lastp	pointer
)	O
:	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
&	O
tmp_dbt	struct
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
lastp	pointer
==	O
NULL	O
?	O
&	O
null_lsn	struct
:	O
&	O
LSN	O
(	O
lastp	pointer
)	O
,	O
&	O
null_lsn	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
lastp	pointer
)	O
LSN	O
(	O
lastp	pointer
)	O
=	O
new_lsn	struct
;	O
LSN	O
(	O
pagep	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
P_INIT	O
(	O
pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
P_OVERFLOW	int
,	O
dbp	pointer
->	O
tags	char
)	O
;	O
OV_LEN	O
(	O
pagep	pointer
)	O
=	O
pagespace	short
;	O
OV_REF	O
(	O
pagep	pointer
)	O
=	O
1	int
;	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
pagep	pointer
+	O
P_OVERHEAD	O
,	O
p	pointer
,	O
pagespace	short
)	O
;	O
if	O
(	O
lastp	pointer
==	O
NULL	O
)	O
*	O
pgnop	pointer
=	O
PGNO	O
(	O
pagep	pointer
)	O
;	O
else	O
{	O
lastp	pointer
->	O
next_pgno	int
=	O
PGNO	O
(	O
pagep	pointer
)	O
;	O
pagep	pointer
->	O
prev_pgno	int
=	O
PGNO	O
(	O
lastp	pointer
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
lastp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
}	O
lastp	pointer
=	O
pagep	pointer
;	O
}	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
lastp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_ovref	function
(	O
dbc	pointer
,	O
pgno	int
,	O
adjust	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int32_t	int
adjust	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___db_pgerr	function
(	O
dbp	pointer
,	O
pgno	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ovref_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
h	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
h	pointer
->	O
pgno	int
,	O
adjust	int
,	O
&	O
LSN	O
(	O
h	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
OV_REF	O
(	O
h	pointer
)	O
+=	O
adjust	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_doff	function
(	O
dbc	pointer
,	O
pgno	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
pgno	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
DB_LSN	struct
null_lsn	struct
;	O
DBT	struct
tmp_dbt	struct
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
do	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
pagep	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___db_pgerr	function
(	O
dbp	pointer
,	O
pgno	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
TYPE	O
(	O
pagep	pointer
)	O
==	O
P_OVERFLOW	int
&&	O
OV_REF	O
(	O
pagep	pointer
)	O
>	O
1	int
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pagep	pointer
,	O
0	int
)	O
;	O
return	O
(	O
CDB___db_ovref	function
(	O
dbc	pointer
,	O
pgno	int
,	O
-	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
tmp_dbt	struct
.	O
data	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
pagep	pointer
+	O
P_OVERHEAD	O
;	O
tmp_dbt	struct
.	O
size	int
=	O
OV_LEN	O
(	O
pagep	pointer
)	O
;	O
ZERO_LSN	O
(	O
null_lsn	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_big_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
0	int
,	O
DB_REM_BIG	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
PREV_PGNO	O
(	O
pagep	pointer
)	O
,	O
NEXT_PGNO	O
(	O
pagep	pointer
)	O
,	O
&	O
tmp_dbt	struct
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
&	O
null_lsn	struct
,	O
&	O
null_lsn	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
pgno	int
=	O
pagep	pointer
->	O
next_pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
while	O
(	O
pgno	int
!=	O
PGNO_INVALID	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_moff	function
(	O
dbp	pointer
,	O
dbt	struct
,	O
pgno	int
,	O
tlen	int
,	O
cmpfunc	pointer
,	O
cmpp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
DBT	struct
*	O
dbt	struct
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
tlen	int
;	O
int	O
(	O
*	O
cmpfunc	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
int	O
*	O
cmpp	pointer
;	O
{	O
PAGE	struct
*	O
pagep	pointer
;	O
DBT	struct
local_dbt	struct
;	O
void	O
*	O
buf	pointer
;	O
u_int32_t	int
bufsize	int
,	O
cmp_bytes	int
,	O
key_left	int
;	O
u_int8_t	char
*	O
p1	pointer
,	O
*	O
p2	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
cmpfunc	pointer
!=	O
NULL	O
)	O
{	O
memset	function
(	O
&	O
local_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
local_dbt	struct
)	O
)	O
;	O
buf	pointer
=	O
NULL	O
;	O
bufsize	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
&	O
local_dbt	struct
,	O
tlen	int
,	O
pgno	int
,	O
&	O
buf	pointer
,	O
&	O
bufsize	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
cmpp	pointer
=	O
cmpfunc	pointer
(	O
dbt	struct
,	O
&	O
local_dbt	struct
)	O
;	O
CDB___os_free	function
(	O
buf	pointer
,	O
bufsize	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
for	O
(	O
*	O
cmpp	pointer
=	O
0	int
,	O
p1	pointer
=	O
dbt	struct
->	O
data	pointer
,	O
key_left	int
=	O
dbt	struct
->	O
size	int
;	O
key_left	int
>	O
0	int
&&	O
pgno	int
!=	O
PGNO_INVALID	int
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
cmp_bytes	int
=	O
OV_LEN	O
(	O
pagep	pointer
)	O
<	O
key_left	int
?	O
OV_LEN	O
(	O
pagep	pointer
)	O
:	O
key_left	int
;	O
tlen	int
-=	O
cmp_bytes	int
;	O
key_left	int
-=	O
cmp_bytes	int
;	O
for	O
(	O
p2	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
pagep	pointer
+	O
P_OVERHEAD	O
;	O
cmp_bytes	int
--	O
>	O
0	int
;	O
++	O
p1	pointer
,	O
++	O
p2	pointer
)	O
if	O
(	O
*	O
p1	pointer
!=	O
*	O
p2	pointer
)	O
{	O
*	O
cmpp	pointer
=	O
(	O
long	O
)	O
*	O
p1	pointer
-	O
(	O
long	O
)	O
*	O
p2	pointer
;	O
break	O
;	O
}	O
pgno	int
=	O
NEXT_PGNO	O
(	O
pagep	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pagep	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
*	O
cmpp	pointer
!=	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
key_left	int
>	O
0	int
)	O
*	O
cmpp	pointer
=	O
1	int
;	O
else	O
if	O
(	O
tlen	int
>	O
0	int
)	O
*	O
cmpp	pointer
=	O
-	O
1	int
;	O
else	O
*	O
cmpp	pointer
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_vrfy_overflow	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
isbad	int
,	O
ret	int
,	O
t_ret	int
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_datapage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
pip	pointer
->	O
refcount	int
=	O
OV_REF	O
(	O
h	pointer
)	O
;	O
if	O
(	O
pip	pointer
->	O
refcount	int
<	O
1	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overflow page %lu has zero reference count"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
pip	pointer
->	O
olen	int
=	O
HOFFSET	O
(	O
h	pointer
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_vrfy_ovfl_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
tlen	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
tlen	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
pgset	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_pgno_t	int
next	int
,	O
prev	int
;	O
int	O
isbad	int
,	O
p	pointer
,	O
ret	int
,	O
t_ret	int
;	O
u_int32_t	int
refcount	int
;	O
pgset	pointer
=	O
vdp	pointer
->	O
pgset	pointer
;	O
DB_ASSERT	O
(	O
pgset	pointer
!=	O
NULL	O
)	O
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
pgno	int
)	O
)	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
refcount	int
=	O
pip	pointer
->	O
refcount	int
;	O
if	O
(	O
pip	pointer
->	O
type	enum
!=	O
P_OVERFLOW	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overflow page %lu of invalid type"	pointer
,	O
pgno	int
,	O
pip	pointer
->	O
type	enum
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
prev	int
=	O
pip	pointer
->	O
prev_pgno	int
;	O
if	O
(	O
prev	int
!=	O
PGNO_INVALID	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"First overflow page %lu has a prev_pgno"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
ST_OVFL_LEAF	int
)	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_OVFL_LEAFSEEN	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_dec	function
(	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_OVFL_LEAFSEEN	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
u_int32_t	int
)	O
p	pointer
>	O
refcount	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu encountered twice in overflow traversal"	pointer
,	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
tlen	int
-=	O
pip	pointer
->	O
olen	int
;	O
next	int
=	O
pip	pointer
->	O
next_pgno	int
;	O
if	O
(	O
next	int
==	O
PGNO_INVALID	int
)	O
break	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
next	int
)	O
)	O
{	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overflow page %lu has bad next_pgno"	pointer
,	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
next	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
pip	pointer
->	O
prev_pgno	int
!=	O
pgno	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overflow page %lu has bogus prev_pgno value"	pointer
,	O
next	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
pgno	int
=	O
next	int
;	O
}	O
if	O
(	O
tlen	int
>	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overflow item incomplete on page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_safe_goff	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
dbt	struct
,	O
buf	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
DBT	struct
*	O
dbt	struct
;	O
void	O
*	O
*	O
buf	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
PAGE	struct
*	O
h	pointer
;	O
int	O
ret	int
,	O
err_ret	int
;	O
u_int32_t	int
bytesgot	int
,	O
bytes	long
;	O
u_int8_t	char
*	O
src	pointer
,	O
*	O
dest	pointer
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
err_ret	int
=	O
0	int
;	O
bytesgot	int
=	O
bytes	long
=	O
0	int
;	O
while	O
(	O
(	O
pgno	int
!=	O
PGNO_INVALID	int
)	O
&&	O
(	O
IS_VALID_PGNO	O
(	O
pgno	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_salvage_markdone	function
(	O
vdp	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
&&	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_OVERFLOW	int
)	O
{	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
}	O
src	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
P_OVERHEAD	O
;	O
bytes	long
=	O
OV_LEN	O
(	O
h	pointer
)	O
;	O
if	O
(	O
bytes	long
+	O
P_OVERHEAD	O
>	O
dbp	pointer
->	O
pgsize	int
)	O
bytes	long
=	O
dbp	pointer
->	O
pgsize	int
-	O
P_OVERHEAD	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
bytesgot	int
+	O
bytes	long
,	O
0	int
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
dest	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
*	O
buf	pointer
+	O
bytesgot	int
;	O
bytesgot	int
+=	O
bytes	long
;	O
memcpy	function
(	O
dest	pointer
,	O
src	pointer
,	O
bytes	long
)	O
;	O
pgno	int
=	O
NEXT_PGNO	O
(	O
h	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
dbt	struct
->	O
size	int
=	O
bytesgot	int
;	O
dbt	struct
->	O
data	pointer
=	O
*	O
buf	pointer
;	O
}	O
return	O
(	O
(	O
err_ret	int
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
?	O
err_ret	int
:	O
ret	int
)	O
;	O
}	O
