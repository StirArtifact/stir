static	O
void	O
expand_macro	function
(	O
symbol	struct
*	O
)	O
;	O
static	O
void	O
expand_token	function
(	O
struct	O
obstack	struct
*	O
,	O
token_type	enum
,	O
token_data	struct
*	O
,	O
int	O
)	O
;	O
int	O
expansion_level	int
=	O
0	int
;	O
static	O
int	O
macro_call_id	int
=	O
0	int
;	O
static	O
struct	O
obstack	struct
argc_stack	struct
;	O
static	O
struct	O
obstack	struct
argv_stack	struct
;	O
void	O
expand_input	function
(	O
void	O
)	O
{	O
token_type	enum
t	enum
;	O
token_data	struct
td	struct
;	O
int	O
line	int
;	O
obstack_init	O
(	O
&	O
argc_stack	struct
)	O
;	O
obstack_init	O
(	O
&	O
argv_stack	struct
)	O
;	O
while	O
(	O
(	O
t	enum
=	O
next_token	function
(	O
&	O
td	struct
,	O
&	O
line	int
)	O
)	O
!=	O
TOKEN_EOF	int
)	O
expand_token	function
(	O
(	O
struct	O
obstack	struct
*	O
)	O
NULL	O
,	O
t	enum
,	O
&	O
td	struct
,	O
line	int
)	O
;	O
obstack_free	function
(	O
&	O
argc_stack	struct
,	O
NULL	O
)	O
;	O
obstack_free	function
(	O
&	O
argv_stack	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
expand_token	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
token_type	enum
t	enum
,	O
token_data	struct
*	O
td	struct
,	O
int	O
line	int
)	O
{	O
symbol	struct
*	O
sym	pointer
;	O
switch	O
(	O
t	enum
)	O
{	O
case	O
TOKEN_EOF	int
:	O
case	O
TOKEN_MACDEF	int
:	O
break	O
;	O
case	O
TOKEN_OPEN	int
:	O
case	O
TOKEN_COMMA	int
:	O
case	O
TOKEN_CLOSE	int
:	O
case	O
TOKEN_SIMPLE	int
:	O
case	O
TOKEN_STRING	int
:	O
shipout_text	function
(	O
obs	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
td	struct
)	O
,	O
strlen	function
(	O
TOKEN_DATA_TEXT	O
(	O
td	struct
)	O
)	O
,	O
line	int
)	O
;	O
break	O
;	O
case	O
TOKEN_WORD	int
:	O
sym	pointer
=	O
lookup_symbol	function
(	O
TOKEN_DATA_TEXT	O
(	O
td	struct
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
||	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
==	O
TOKEN_VOID	int
||	O
(	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
==	O
TOKEN_FUNC	int
&&	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	pointer
)	O
&&	O
peek_token	function
(	O
)	O
!=	O
TOKEN_OPEN	int
)	O
)	O
{	O
shipout_text	function
(	O
obs	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
td	struct
)	O
,	O
strlen	function
(	O
TOKEN_DATA_TEXT	O
(	O
td	struct
)	O
)	O
,	O
line	int
)	O
;	O
}	O
else	O
expand_macro	function
(	O
sym	pointer
)	O
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token type in expand_token ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
bool	bool
expand_argument	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
token_data	struct
*	O
argp	pointer
)	O
{	O
token_type	enum
t	enum
;	O
token_data	struct
td	struct
;	O
char	O
*	O
text	pointer
;	O
int	O
paren_level	int
;	O
const	O
char	O
*	O
file	pointer
=	O
current_file	pointer
;	O
int	O
line	int
=	O
current_line	int
;	O
TOKEN_DATA_TYPE	O
(	O
argp	pointer
)	O
=	O
TOKEN_VOID	int
;	O
do	O
{	O
t	enum
=	O
next_token	function
(	O
&	O
td	struct
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
t	enum
==	O
TOKEN_SIMPLE	int
&&	O
isspace	function
(	O
to_uchar	O
(	O
*	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct
)	O
)	O
)	O
)	O
;	O
paren_level	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
t	enum
)	O
{	O
case	O
TOKEN_COMMA	int
:	O
case	O
TOKEN_CLOSE	int
:	O
if	O
(	O
paren_level	int
==	O
0	int
)	O
{	O
obstack_1grow	O
(	O
obs	pointer
,	O
'\0'	O
)	O
;	O
text	pointer
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	pointer
)	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argp	pointer
)	O
==	O
TOKEN_VOID	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argp	pointer
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
argp	pointer
)	O
=	O
text	pointer
;	O
}	O
return	O
t	enum
==	O
TOKEN_COMMA	int
;	O
}	O
case	O
TOKEN_OPEN	int
:	O
case	O
TOKEN_SIMPLE	int
:	O
text	pointer
=	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct
)	O
;	O
if	O
(	O
*	O
text	pointer
==	O
'('	O
)	O
paren_level	int
++	O
;	O
else	O
if	O
(	O
*	O
text	pointer
==	O
')'	O
)	O
paren_level	int
--	O
;	O
expand_token	function
(	O
obs	pointer
,	O
t	enum
,	O
&	O
td	struct
,	O
line	int
)	O
;	O
break	O
;	O
case	O
TOKEN_EOF	int
:	O
M4ERROR_AT_LINE	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
file	pointer
,	O
line	int
,	O
"ERROR: end of file in argument list"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_WORD	int
:	O
case	O
TOKEN_STRING	int
:	O
expand_token	function
(	O
obs	pointer
,	O
t	enum
,	O
&	O
td	struct
,	O
line	int
)	O
;	O
break	O
;	O
case	O
TOKEN_MACDEF	int
:	O
if	O
(	O
obstack_object_size	O
(	O
obs	pointer
)	O
==	O
0	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argp	pointer
)	O
=	O
TOKEN_FUNC	int
;	O
TOKEN_DATA_FUNC	O
(	O
argp	pointer
)	O
=	O
TOKEN_DATA_FUNC	O
(	O
&	O
td	struct
)	O
;	O
}	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token type in expand_argument ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
t	enum
=	O
next_token	function
(	O
&	O
td	struct
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
collect_arguments	function
(	O
symbol	struct
*	O
sym	pointer
,	O
struct	O
obstack	struct
*	O
argptr	pointer
,	O
struct	O
obstack	struct
*	O
arguments	pointer
)	O
{	O
token_data	struct
td	struct
;	O
token_data	struct
*	O
tdp	pointer
;	O
bool	bool
more_args	bool
;	O
bool	bool
groks_macro_args	bool
=	O
SYMBOL_MACRO_ARGS	O
(	O
sym	pointer
)	O
;	O
TOKEN_DATA_TYPE	O
(	O
&	O
td	struct
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct
)	O
=	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
;	O
tdp	pointer
=	O
(	O
token_data	struct
*	O
)	O
obstack_copy	O
(	O
arguments	pointer
,	O
&	O
td	struct
,	O
sizeof	O
td	struct
)	O
;	O
obstack_ptr_grow	O
(	O
argptr	pointer
,	O
tdp	pointer
)	O
;	O
if	O
(	O
peek_token	function
(	O
)	O
==	O
TOKEN_OPEN	int
)	O
{	O
next_token	function
(	O
&	O
td	struct
,	O
NULL	O
)	O
;	O
do	O
{	O
more_args	bool
=	O
expand_argument	function
(	O
arguments	pointer
,	O
&	O
td	struct
)	O
;	O
if	O
(	O
!	O
groks_macro_args	bool
&&	O
TOKEN_DATA_TYPE	O
(	O
&	O
td	struct
)	O
==	O
TOKEN_FUNC	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
&	O
td	struct
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
&	O
td	struct
)	O
=	O
(	O
char	O
*	O
)	O
""	pointer
;	O
}	O
tdp	pointer
=	O
(	O
token_data	struct
*	O
)	O
obstack_copy	O
(	O
arguments	pointer
,	O
&	O
td	struct
,	O
sizeof	O
td	struct
)	O
;	O
obstack_ptr_grow	O
(	O
argptr	pointer
,	O
tdp	pointer
)	O
;	O
}	O
while	O
(	O
more_args	bool
)	O
;	O
}	O
}	O
void	O
call_macro	function
(	O
symbol	struct
*	O
sym	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
,	O
struct	O
obstack	struct
*	O
expansion	pointer
)	O
{	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
)	O
{	O
case	O
TOKEN_FUNC	int
:	O
(	O
*	O
SYMBOL_FUNC	O
(	O
sym	pointer
)	O
)	O
(	O
expansion	pointer
,	O
argc	int
,	O
argv	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_TEXT	int
:	O
expand_user_macro	function
(	O
expansion	pointer
,	O
sym	pointer
,	O
argc	int
,	O
argv	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad symbol type in call_macro ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
expand_macro	function
(	O
symbol	struct
*	O
sym	pointer
)	O
{	O
struct	O
obstack	struct
arguments	pointer
;	O
unsigned	O
argv_base	int
;	O
bool	bool
use_argc_stack	bool
=	O
true	int
;	O
token_data	struct
*	O
*	O
argv	pointer
;	O
int	O
argc	int
;	O
struct	O
obstack	struct
*	O
expansion	pointer
;	O
const	O
char	O
*	O
expanded	pointer
;	O
bool	bool
traced	bool
;	O
int	O
my_call_id	int
;	O
const	O
char	O
*	O
loc_open_file	pointer
=	O
current_file	pointer
;	O
int	O
loc_open_line	int
=	O
current_line	int
;	O
const	O
char	O
*	O
loc_close_file	pointer
;	O
int	O
loc_close_line	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
++	O
;	O
expansion_level	int
++	O
;	O
if	O
(	O
nesting_limit	int
>	O
0	int
&&	O
expansion_level	int
>	O
nesting_limit	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"recursion limit of %d exceeded, use -L<N> to change it"	pointer
,	O
nesting_limit	int
)	O
)	O
;	O
macro_call_id	int
++	O
;	O
my_call_id	int
=	O
macro_call_id	int
;	O
traced	bool
=	O
(	O
debug_level	int
&	O
DEBUG_TRACE_ALL	int
)	O
||	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
;	O
argv_base	int
=	O
obstack_object_size	O
(	O
&	O
argv_stack	struct
)	O
;	O
if	O
(	O
obstack_object_size	O
(	O
&	O
argc_stack	struct
)	O
>	O
0	int
)	O
{	O
obstack_init	O
(	O
&	O
arguments	pointer
)	O
;	O
use_argc_stack	bool
=	O
false	int
;	O
}	O
if	O
(	O
traced	bool
&&	O
(	O
debug_level	int
&	O
DEBUG_TRACE_CALL	int
)	O
)	O
trace_prepre	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
my_call_id	int
)	O
;	O
collect_arguments	function
(	O
sym	pointer
,	O
&	O
argv_stack	struct
,	O
use_argc_stack	bool
?	O
&	O
argc_stack	struct
:	O
&	O
arguments	pointer
)	O
;	O
argc	int
=	O
(	O
(	O
obstack_object_size	O
(	O
&	O
argv_stack	struct
)	O
-	O
argv_base	int
)	O
/	O
sizeof	O
(	O
token_data	struct
*	O
)	O
)	O
;	O
argv	pointer
=	O
(	O
token_data	struct
*	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
obstack_base	O
(	O
&	O
argv_stack	struct
)	O
+	O
argv_base	int
)	O
;	O
loc_close_file	pointer
=	O
current_file	pointer
;	O
loc_close_line	int
=	O
current_line	int
;	O
current_file	pointer
=	O
loc_open_file	pointer
;	O
current_line	int
=	O
loc_open_line	int
;	O
if	O
(	O
traced	bool
)	O
trace_pre	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
my_call_id	int
,	O
argc	int
,	O
argv	pointer
)	O
;	O
expansion	pointer
=	O
push_string_init	function
(	O
)	O
;	O
call_macro	function
(	O
sym	pointer
,	O
argc	int
,	O
argv	pointer
,	O
expansion	pointer
)	O
;	O
expanded	pointer
=	O
push_string_finish	function
(	O
)	O
;	O
if	O
(	O
traced	bool
)	O
trace_post	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
my_call_id	int
,	O
argc	int
,	O
expanded	pointer
)	O
;	O
current_file	pointer
=	O
loc_close_file	pointer
;	O
current_line	int
=	O
loc_close_line	int
;	O
--	O
expansion_level	int
;	O
--	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
;	O
if	O
(	O
SYMBOL_DELETED	O
(	O
sym	pointer
)	O
)	O
free_symbol	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
use_argc_stack	bool
)	O
obstack_free	function
(	O
&	O
argc_stack	struct
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
else	O
obstack_free	function
(	O
&	O
arguments	pointer
,	O
NULL	O
)	O
;	O
obstack_blank	O
(	O
&	O
argv_stack	struct
,	O
-	O
argc	int
*	O
sizeof	O
(	O
token_data	struct
*	O
)	O
)	O
;	O
}	O
