extern	O
struct	O
extendedOptions	struct
*	O
optionsArray	pointer
;	O
extern	O
char	O
*	O
CHARTRUE	pointer
;	O
static	O
int	O
swextopt_statusG	int
=	O
0	int
;	O
static	O
char	O
*	O
utilnames	array
[	O
]	O
=	O
{	O
"swask"	pointer
,	O
"swcopy"	pointer
,	O
"swinstall"	pointer
,	O
"swconfig"	pointer
,	O
"swlist"	pointer
,	O
"swmodify"	pointer
,	O
"swpackage"	pointer
,	O
"swremove"	pointer
,	O
"swverify"	pointer
,	O
""	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
i_is_value_false	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
(	O
strcasecmp	function
(	O
s	pointer
,	O
"f"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
s	pointer
,	O
"false"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
s	pointer
,	O
"no"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
s	pointer
,	O
"n"	pointer
)	O
==	O
0	int
||	O
0	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
i_is_value_true	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
strcasecmp	function
(	O
s	pointer
,	O
"t"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
s	pointer
,	O
"true"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
s	pointer
,	O
"yes"	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
s	pointer
,	O
"y"	pointer
)	O
==	O
0	int
||	O
0	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
find_pow	function
(	O
int	O
flag	pointer
)	O
{	O
int	O
i	int
=	O
1	int
;	O
if	O
(	O
flag	pointer
<=	O
1	int
)	O
return	O
0	int
;	O
while	O
(	O
flag	pointer
/	O
2	int
>	O
1	int
)	O
{	O
flag	pointer
=	O
flag	pointer
>>	O
1	int
;	O
i	int
++	O
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
i_getEnumFromName	function
(	O
char	O
*	O
optionname	pointer
,	O
struct	O
extendedOptions	struct
*	O
peop	pointer
)	O
{	O
struct	O
extendedOptions	struct
*	O
eop	pointer
;	O
eop	pointer
=	O
peop	pointer
;	O
while	O
(	O
eop	pointer
->	O
optionNameM	pointer
&&	O
strcmp	function
(	O
eop	pointer
->	O
optionNameM	pointer
,	O
optionname	pointer
)	O
)	O
{	O
eop	pointer
++	O
;	O
}	O
if	O
(	O
eop	pointer
->	O
optionNameM	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
(	O
(	O
(	O
char	O
*	O
)	O
eop	pointer
)	O
-	O
(	O
char	O
*	O
)	O
peop	pointer
)	O
/	O
sizeof	O
(	O
struct	O
extendedOptions	struct
)	O
;	O
}	O
static	O
int	O
check_applicability	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
)	O
{	O
int	O
bit	int
;	O
int	O
index	function
;	O
char	O
*	O
cu	pointer
;	O
int	O
ret	int
;	O
char	O
*	O
*	O
names	pointer
=	O
utilnames	array
;	O
int	O
ap_mask	int
;	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
ap_mask	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
app_flags	int
;	O
cu	pointer
=	O
swlib_utilname_get	function
(	O
)	O
;	O
while	O
(	O
*	O
names	pointer
&&	O
strcmp	function
(	O
cu	pointer
,	O
*	O
names	pointer
)	O
)	O
{	O
names	pointer
++	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
names	pointer
)	O
)	O
return	O
1	int
;	O
index	function
=	O
(	O
int	O
)	O
(	O
names	pointer
-	O
utilnames	array
)	O
;	O
bit	int
=	O
1	int
<<	O
index	function
;	O
ret	int
=	O
!	O
(	O
ap_mask	int
&	O
bit	int
)	O
;	O
if	O
(	O
ret	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: option not valid: %s\n"	pointer
,	O
cu	pointer
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
optionNameM	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
combine1	function
(	O
STROB	struct
*	O
result	pointer
,	O
char	O
*	O
directory	pointer
,	O
char	O
*	O
soc_spec	pointer
)	O
{	O
char	O
*	O
x	pointer
;	O
char	O
*	O
t	pointer
;	O
E_DEBUG3	O
(	O
"directory=%s soc_spec=%s"	pointer
,	O
directory	pointer
,	O
soc_spec	pointer
)	O
;	O
if	O
(	O
*	O
directory	pointer
==	O
'@'	O
)	O
directory	pointer
++	O
;	O
if	O
(	O
*	O
soc_spec	pointer
==	O
'@'	O
)	O
directory	pointer
++	O
;	O
strob_strcpy	function
(	O
result	pointer
,	O
"@"	pointer
)	O
;	O
strob_strcat	function
(	O
result	pointer
,	O
soc_spec	pointer
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	pointer
,	O
strob_str	function
(	O
result	pointer
)	O
)	O
;	O
x	pointer
=	O
directory	pointer
;	O
if	O
(	O
*	O
directory	pointer
==	O
':'	O
)	O
x	pointer
++	O
;	O
if	O
(	O
*	O
directory	pointer
==	O
'@'	O
)	O
x	pointer
++	O
;	O
if	O
(	O
soc_spec	pointer
[	O
strlen	function
(	O
soc_spec	pointer
)	O
-	O
1	int
]	O
!=	O
':'	O
&&	O
directory	pointer
[	O
0	int
]	O
!=	O
':'	O
&&	O
1	int
)	O
{	O
strob_strcat	function
(	O
result	pointer
,	O
":"	pointer
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	pointer
,	O
strob_str	function
(	O
result	pointer
)	O
)	O
;	O
}	O
if	O
(	O
*	O
directory	pointer
==	O
':'	O
)	O
directory	pointer
++	O
;	O
if	O
(	O
(	O
t	pointer
=	O
strrchr	function
(	O
strob_str	function
(	O
result	pointer
)	O
,	O
':'	O
)	O
)	O
&&	O
*	O
(	O
t	pointer
+	O
1	int
)	O
==	O
'\0'	O
)	O
{	O
strob_strcat	function
(	O
result	pointer
,	O
directory	pointer
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	pointer
,	O
strob_str	function
(	O
result	pointer
)	O
)	O
;	O
}	O
else	O
{	O
swlib_unix_dircat	function
(	O
result	pointer
,	O
directory	pointer
)	O
;	O
E_DEBUG2	O
(	O
"result=%s"	pointer
,	O
strob_str	function
(	O
result	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
close_stdio	function
(	O
void	O
)	O
{	O
close	pointer
(	O
STDOUT_FILENO	int
)	O
;	O
close	pointer
(	O
STDERR_FILENO	int
)	O
;	O
}	O
static	O
void	O
i_set_opta	function
(	O
int	O
optsetflag	int
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
,	O
char	O
*	O
value	int
)	O
{	O
if	O
(	O
value	int
&&	O
strpbrk	function
(	O
value	int
,	O
SWBIS_TAINTED_CHARS	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: shell meta-characters detected for %s option\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
optionNameM	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
opta	pointer
[	O
nopt	enum
]	O
.	O
option_setM	char
=	O
(	O
char	O
)	O
optsetflag	int
;	O
if	O
(	O
value	int
)	O
{	O
opta	pointer
[	O
nopt	enum
]	O
.	O
valueM	int
=	O
strdup	function
(	O
value	int
)	O
;	O
}	O
else	O
{	O
opta	pointer
[	O
nopt	enum
]	O
.	O
valueM	int
=	O
value	int
;	O
}	O
}	O
void	O
debug_writeBooleanExtendedOptions	function
(	O
int	O
ofd	int
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
)	O
{	O
struct	O
extendedOptions	struct
*	O
eop	pointer
=	O
opta	pointer
;	O
int	O
op	int
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
while	O
(	O
eop	pointer
->	O
optionNameM	pointer
)	O
{	O
if	O
(	O
eop	pointer
->	O
is_boolM	char
)	O
swlib_writef	function
(	O
ofd	int
,	O
tmp	pointer
,	O
"%s=%d\n"	pointer
,	O
eop	pointer
->	O
optionNameM	pointer
,	O
swextopt_is_value_true	function
(	O
get_opta	function
(	O
opta	pointer
,	O
op	int
)	O
)	O
)	O
;	O
op	int
++	O
;	O
eop	pointer
++	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
void	O
swextopt_write_session_options	function
(	O
STROB	struct
*	O
buf	pointer
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
int	O
SWC_FLAG	int
)	O
{	O
char	O
*	O
value	int
;	O
struct	O
extendedOptions	struct
*	O
eop	pointer
=	O
opta	pointer
;	O
int	O
op	int
=	O
0	int
;	O
int	O
bv	int
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
while	O
(	O
eop	pointer
->	O
optionNameM	pointer
)	O
{	O
if	O
(	O
(	O
SWC_FLAG	int
==	O
0	int
)	O
||	O
(	O
SWC_FLAG	int
&	O
(	O
eop	pointer
->	O
app_flags	int
)	O
)	O
)	O
{	O
if	O
(	O
eop	pointer
->	O
is_boolM	char
)	O
{	O
bv	int
=	O
swextopt_is_value_true	function
(	O
get_opta	function
(	O
opta	pointer
,	O
op	int
)	O
)	O
;	O
switch	O
(	O
bv	int
)	O
{	O
case	O
1	int
:	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"%s=\"true\"\n"	pointer
,	O
eop	pointer
->	O
optionNameM	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"%s=\"false\"\n"	pointer
,	O
eop	pointer
->	O
optionNameM	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
value	int
=	O
get_opta	function
(	O
opta	pointer
,	O
op	int
)	O
;	O
if	O
(	O
value	int
)	O
{	O
if	O
(	O
strpbrk	function
(	O
value	int
,	O
SWBIS_TAINTED_CHARS	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: shell meta-characters detected for %s option\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
eop	pointer
->	O
optionNameM	pointer
)	O
;	O
value	int
=	O
""	pointer
;	O
}	O
}	O
else	O
{	O
value	int
=	O
""	pointer
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"%s=\"%s\"\n"	pointer
,	O
eop	pointer
->	O
optionNameM	pointer
,	O
value	int
)	O
;	O
}	O
}	O
op	int
++	O
;	O
eop	pointer
++	O
;	O
}	O
}	O
int	O
swextopt_is_value_false	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
i_is_value_false	function
(	O
s	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
i_is_value_true	function
(	O
s	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: extended option boolean value '%s' is improperly formatted, assuming false\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
s	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
swextopt_is_value_true	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
i_is_value_true	function
(	O
s	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
i_is_value_false	function
(	O
s	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: extended option boolean value '%s' is improperly formatted, assuming false\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
s	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swextopt_is_option_false	function
(	O
enum	O
eOpts	enum
nopt	enum
,	O
struct	O
extendedOptions	struct
*	O
options	pointer
)	O
{	O
char	O
*	O
val	int
;	O
val	int
=	O
get_opta	function
(	O
options	pointer
,	O
nopt	enum
)	O
;	O
return	O
swextopt_is_value_false	function
(	O
val	int
)	O
;	O
}	O
int	O
swextopt_is_option_true	function
(	O
enum	O
eOpts	enum
nopt	enum
,	O
struct	O
extendedOptions	struct
*	O
options	pointer
)	O
{	O
char	O
*	O
val	int
;	O
val	int
=	O
get_opta	function
(	O
options	pointer
,	O
nopt	enum
)	O
;	O
return	O
swextopt_is_value_true	function
(	O
val	int
)	O
;	O
}	O
int	O
swextopt_is_option_set	function
(	O
enum	O
eOpts	enum
nopt	enum
,	O
struct	O
extendedOptions	struct
*	O
options	pointer
)	O
{	O
return	O
(	O
int	O
)	O
(	O
options	pointer
[	O
nopt	enum
]	O
.	O
option_setM	char
)	O
;	O
}	O
int	O
parseDefaultsFile	function
(	O
char	O
*	O
utility_name	pointer
,	O
char	O
*	O
defaults_filename	pointer
,	O
struct	O
extendedOptions	struct
*	O
options	pointer
,	O
int	O
doPreserveOptions	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
int	O
is_option_set	int
;	O
int	O
is_util_set	int
;	O
char	O
*	O
value	int
;	O
char	O
*	O
option	struct
;	O
char	O
*	O
optionutil	pointer
;	O
char	O
nullb	char
=	O
'\0'	O
;	O
int	O
fd	int
;	O
int	O
uxfio_fd	int
;	O
char	O
*	O
buf	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
line	pointer
;	O
char	O
*	O
oldvalue	pointer
;	O
int	O
is_util_option	int
;	O
int	O
is_global_option	int
;	O
int	O
is_set	int
;	O
uxfio_fd	int
=	O
uxfio_open	function
(	O
""	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
uxfio_fd	int
<	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
uxfio_fcntl	function
(	O
uxfio_fd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
uxfio_fcntl	function
(	O
uxfio_fd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
defaults_filename	pointer
,	O
SWBIS_STDIO_FNAME	pointer
)	O
!=	O
0	int
)	O
fd	int
=	O
open	function
(	O
defaults_filename	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
else	O
fd	int
=	O
STDIN_FILENO	int
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %s\n"	pointer
,	O
defaults_filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
uxfio_close	function
(	O
uxfio_fd	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
sw_yyparse	function
(	O
fd	int
,	O
uxfio_fd	int
,	O
"OPTION"	pointer
,	O
0	int
,	O
SWPARSE_FORM_MKUP_LEN	O
)	O
)	O
{	O
uxfio_close	function
(	O
uxfio_fd	int
)	O
;	O
if	O
(	O
fd	int
!=	O
STDIN_FILENO	int
)	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
3	int
;	O
}	O
if	O
(	O
fd	int
!=	O
STDIN_FILENO	int
)	O
close	pointer
(	O
fd	int
)	O
;	O
uxfio_write	function
(	O
uxfio_fd	int
,	O
(	O
void	O
*	O
)	O
(	O
&	O
nullb	char
)	O
,	O
1	int
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
uxfio_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
)	O
{	O
uxfio_close	function
(	O
uxfio_fd	int
)	O
;	O
return	O
4	int
;	O
}	O
if	O
(	O
uxfio_get_dynamic_buffer	function
(	O
uxfio_fd	int
,	O
&	O
buf	pointer
,	O
NULL	O
,	O
NULL	O
)	O
<	O
0	int
)	O
return	O
5	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
buf	pointer
,	O
"\r\n"	pointer
)	O
;	O
while	O
(	O
line	pointer
)	O
{	O
value	int
=	O
NULL	O
;	O
option	struct
=	O
NULL	O
;	O
optionutil	pointer
=	O
NULL	O
;	O
is_util_option	int
=	O
0	int
;	O
is_global_option	int
=	O
0	int
;	O
option	struct
=	O
swheaderline_get_keyword	function
(	O
line	pointer
)	O
;	O
value	int
=	O
swheaderline_get_value	function
(	O
line	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
strstr	function
(	O
option	struct
,	O
utility_name	pointer
)	O
==	O
option	struct
)	O
&&	O
option	struct
[	O
strlen	function
(	O
utility_name	pointer
)	O
]	O
==	O
'.'	O
)	O
{	O
is_util_option	int
=	O
1	int
;	O
option	struct
+=	O
(	O
strlen	function
(	O
utility_name	pointer
)	O
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
option	struct
,	O
'.'	O
)	O
==	O
NULL	O
)	O
{	O
is_global_option	int
=	O
1	int
;	O
}	O
if	O
(	O
is_util_option	int
||	O
is_global_option	int
)	O
{	O
if	O
(	O
(	O
oldvalue	pointer
=	O
getExtendedOption	function
(	O
option	struct
,	O
options	pointer
,	O
&	O
is_set	int
,	O
&	O
is_option_set	int
,	O
&	O
is_util_set	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
is_util_set	int
==	O
0	int
&&	O
is_global_option	int
&&	O
is_option_set	int
==	O
0	int
)	O
||	O
(	O
(	O
is_util_option	int
||	O
is_set	int
==	O
0	int
)	O
&&	O
is_option_set	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
is_set	int
&&	O
oldvalue	pointer
)	O
free	function
(	O
oldvalue	pointer
)	O
;	O
if	O
(	O
value	int
)	O
value	int
=	O
strdup	function
(	O
value	int
)	O
;	O
setExtendedOption	function
(	O
option	struct
,	O
value	int
,	O
options	pointer
,	O
doPreserveOptions	int
,	O
is_util_option	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: option %s not recognized\n"	pointer
,	O
utility_name	pointer
,	O
option	struct
)	O
;	O
ret	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
line	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"\n"	pointer
)	O
;	O
}	O
uxfio_close	function
(	O
uxfio_fd	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
initExtendedOption	function
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
char	O
*	O
getLongOptionNameFromValue	function
(	O
struct	O
option	struct
*	O
arr	pointer
,	O
int	O
val	int
)	O
{	O
struct	O
option	struct
*	O
p	pointer
=	O
arr	pointer
;	O
while	O
(	O
p	pointer
->	O
val	int
&&	O
p	pointer
->	O
name	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
val	int
==	O
val	int
)	O
return	O
(	O
char	O
*	O
)	O
(	O
p	pointer
->	O
name	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
int	O
getEnumFromName	function
(	O
char	O
*	O
fp_optionname	pointer
,	O
struct	O
extendedOptions	struct
*	O
peop	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
optionname	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
fp_optionname	pointer
)	O
;	O
optionname	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
swlib_tr	function
(	O
optionname	pointer
,	O
(	O
int	O
)	O
'_'	O
,	O
(	O
int	O
)	O
'-'	O
)	O
;	O
ret	int
=	O
i_getEnumFromName	function
(	O
optionname	pointer
,	O
peop	pointer
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
)	O
{	O
return	O
ret	int
;	O
}	O
swlib_tr	function
(	O
optionname	pointer
,	O
(	O
int	O
)	O
'-'	O
,	O
(	O
int	O
)	O
'_'	O
)	O
;	O
ret	int
=	O
i_getEnumFromName	function
(	O
optionname	pointer
,	O
peop	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
setExtendedOption	function
(	O
char	O
*	O
optionname	pointer
,	O
char	O
*	O
value	int
,	O
struct	O
extendedOptions	struct
*	O
peop	pointer
,	O
int	O
optSet	int
,	O
int	O
is_util_option	int
)	O
{	O
struct	O
extendedOptions	struct
*	O
eop	pointer
;	O
if	O
(	O
peop	pointer
)	O
{	O
eop	pointer
=	O
peop	pointer
;	O
}	O
else	O
{	O
eop	pointer
=	O
optionsArray	pointer
;	O
}	O
while	O
(	O
eop	pointer
->	O
optionNameM	pointer
&&	O
strcmp	function
(	O
eop	pointer
->	O
optionNameM	pointer
,	O
optionname	pointer
)	O
)	O
{	O
eop	pointer
++	O
;	O
}	O
if	O
(	O
eop	pointer
->	O
optionNameM	pointer
)	O
{	O
if	O
(	O
eop	pointer
->	O
util_setM	char
&&	O
is_util_option	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
optSet	int
&&	O
eop	pointer
->	O
option_setM	char
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
is_util_option	int
)	O
eop	pointer
->	O
util_setM	char
=	O
(	O
char	O
)	O
1	int
;	O
eop	pointer
->	O
valueM	int
=	O
value	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
swextopt_writeExtendedOptions	function
(	O
int	O
ofd	int
,	O
struct	O
extendedOptions	struct
*	O
eop	pointer
,	O
int	O
SWC_FLAG	int
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
swextopt_writeExtendedOptions_strob	function
(	O
tmp	pointer
,	O
eop	pointer
,	O
SWC_FLAG	int
,	O
0	int
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
ofd	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
return	O
-	O
1	int
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swextopt_writeExtendedOptions_strob	function
(	O
STROB	struct
*	O
tmp	pointer
,	O
struct	O
extendedOptions	struct
*	O
eop	pointer
,	O
int	O
SWC_FLAG	int
,	O
int	O
do_shell_protect	int
)	O
{	O
char	O
*	O
s	pointer
;	O
while	O
(	O
eop	pointer
->	O
optionNameM	pointer
)	O
{	O
if	O
(	O
(	O
SWC_FLAG	int
==	O
0	int
)	O
||	O
(	O
SWC_FLAG	int
&	O
(	O
eop	pointer
->	O
app_flags	int
)	O
)	O
)	O
{	O
s	pointer
=	O
getExtendedOption	function
(	O
eop	pointer
->	O
optionNameM	pointer
,	O
eop	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
s	pointer
=	O
""	pointer
;	O
if	O
(	O
do_shell_protect	int
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s=%s\n"	pointer
,	O
eop	pointer
->	O
optionNameM	pointer
,	O
s	pointer
)	O
;	O
}	O
else	O
{	O
swlib_is_sh_tainted_string_fatal	function
(	O
s	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s=\"%s\"\n"	pointer
,	O
eop	pointer
->	O
optionNameM	pointer
,	O
s	pointer
)	O
;	O
}	O
}	O
eop	pointer
++	O
;	O
}	O
}	O
char	O
*	O
getExtendedOption	function
(	O
char	O
*	O
optionname	pointer
,	O
struct	O
extendedOptions	struct
*	O
peop	pointer
,	O
int	O
*	O
pis_set	pointer
,	O
int	O
*	O
isOptSet	pointer
,	O
int	O
*	O
isUtilSet	pointer
)	O
{	O
struct	O
extendedOptions	struct
*	O
eop	pointer
;	O
if	O
(	O
peop	pointer
)	O
{	O
eop	pointer
=	O
peop	pointer
;	O
}	O
else	O
{	O
eop	pointer
=	O
optionsArray	pointer
;	O
}	O
while	O
(	O
eop	pointer
->	O
optionNameM	pointer
&&	O
strcmp	function
(	O
eop	pointer
->	O
optionNameM	pointer
,	O
optionname	pointer
)	O
)	O
eop	pointer
++	O
;	O
if	O
(	O
eop	pointer
->	O
optionNameM	pointer
)	O
{	O
if	O
(	O
eop	pointer
->	O
valueM	int
)	O
{	O
if	O
(	O
isOptSet	pointer
)	O
*	O
isOptSet	pointer
=	O
(	O
int	O
)	O
(	O
eop	pointer
->	O
option_setM	char
)	O
;	O
if	O
(	O
isUtilSet	pointer
)	O
*	O
isUtilSet	pointer
=	O
(	O
int	O
)	O
(	O
eop	pointer
->	O
util_setM	char
)	O
;	O
if	O
(	O
pis_set	pointer
)	O
*	O
pis_set	pointer
=	O
1	int
;	O
return	O
eop	pointer
->	O
valueM	int
;	O
}	O
else	O
{	O
if	O
(	O
isOptSet	pointer
)	O
*	O
isOptSet	pointer
=	O
(	O
int	O
)	O
(	O
eop	pointer
->	O
option_setM	char
)	O
;	O
if	O
(	O
isUtilSet	pointer
)	O
*	O
isUtilSet	pointer
=	O
(	O
int	O
)	O
(	O
eop	pointer
->	O
util_setM	char
)	O
;	O
if	O
(	O
pis_set	pointer
)	O
*	O
pis_set	pointer
=	O
0	int
;	O
return	O
eop	pointer
->	O
defaultValueM	pointer
;	O
}	O
}	O
if	O
(	O
isOptSet	pointer
)	O
*	O
isOptSet	pointer
=	O
0	int
;	O
if	O
(	O
isUtilSet	pointer
)	O
*	O
isUtilSet	pointer
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
void	O
set_opta_boolean	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
,	O
char	O
*	O
value	int
)	O
{	O
if	O
(	O
opta	pointer
[	O
nopt	enum
]	O
.	O
is_boolM	char
)	O
{	O
if	O
(	O
value	int
!=	O
NULL	O
&&	O
strcasecmp	function
(	O
value	int
,	O
"t"	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
"f"	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
SW_E_TRUE	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
SW_E_FALSE	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
"no"	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
"yes"	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
"n"	pointer
)	O
&&	O
strcasecmp	function
(	O
value	int
,	O
"y"	pointer
)	O
&&	O
strcmp	function
(	O
value	int
,	O
"0"	pointer
)	O
&&	O
strcmp	function
(	O
value	int
,	O
"1"	pointer
)	O
)	O
{	O
swextopt_statusG	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
value	int
)	O
{	O
if	O
(	O
*	O
value	int
==	O
'0'	O
)	O
value	int
=	O
SW_E_FALSE	pointer
;	O
if	O
(	O
*	O
value	int
==	O
'1'	O
)	O
value	int
=	O
SW_E_TRUE	pointer
;	O
}	O
i_set_opta	function
(	O
1	int
,	O
opta	pointer
,	O
nopt	enum
,	O
value	int
)	O
;	O
}	O
void	O
set_opta	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
,	O
char	O
*	O
value	int
)	O
{	O
if	O
(	O
opta	pointer
[	O
nopt	enum
]	O
.	O
is_boolM	char
)	O
set_opta_boolean	function
(	O
opta	pointer
,	O
nopt	enum
,	O
value	int
)	O
;	O
else	O
i_set_opta	function
(	O
1	int
,	O
opta	pointer
,	O
nopt	enum
,	O
value	int
)	O
;	O
}	O
void	O
set_opta_initial	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
,	O
char	O
*	O
value	int
)	O
{	O
i_set_opta	function
(	O
0	int
,	O
opta	pointer
,	O
nopt	enum
,	O
value	int
)	O
;	O
}	O
char	O
*	O
swbisoption_get_opta	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
)	O
{	O
char	O
*	O
value	int
;	O
value	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
valueM	int
;	O
if	O
(	O
value	int
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"internal warning: swbis option %d [%s] is null\n"	pointer
,	O
(	O
int	O
)	O
nopt	enum
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
optionNameM	pointer
)	O
;	O
}	O
if	O
(	O
!	O
value	int
)	O
value	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
defaultValueM	pointer
;	O
return	O
value	int
;	O
}	O
char	O
*	O
get_opta_isc	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
)	O
{	O
char	O
*	O
value	int
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
host	pointer
;	O
char	O
*	O
file	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
nopt	enum
!=	O
SW_E_installed_software_catalog	int
)	O
{	O
return	O
get_opta	function
(	O
opta	pointer
,	O
nopt	enum
)	O
;	O
}	O
value	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
valueM	int
;	O
if	O
(	O
value	int
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: sw option %d [%s] is null, using default [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
nopt	enum
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
optionNameM	pointer
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
defaultValueM	pointer
)	O
;	O
}	O
if	O
(	O
!	O
value	int
)	O
value	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
defaultValueM	pointer
;	O
s	pointer
=	O
strstr	function
(	O
value	int
,	O
FILE_URL	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"processing ordinary path"	pointer
)	O
;	O
swlib_squash_all_leading_slash	function
(	O
value	int
)	O
;	O
swlib_squash_all_dot_slash	function
(	O
value	int
)	O
;	O
swlib_squash_leading_dot_slash	function
(	O
value	int
)	O
;	O
return	O
value	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"processing file URL"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
value	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning malformed file URL: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
value	int
)	O
;	O
return	O
value	int
;	O
}	O
s	pointer
+=	O
strlen	function
(	O
FILE_URL	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'/'	O
)	O
{	O
host	pointer
=	O
NULL	O
;	O
file	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
host	pointer
=	O
s	pointer
;	O
file	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: malformed file URL, assuming host part is file part\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
file	pointer
=	O
host	pointer
;	O
}	O
else	O
{	O
if	O
(	O
strstr	function
(	O
host	pointer
,	O
"localhost/"	pointer
)	O
!=	O
host	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: remote catalog URL not supported: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
value	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: Possibly you intend URL: file:///absolute/path\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: exiting with error\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
return	O
file	pointer
;	O
}	O
char	O
*	O
get_opta	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
)	O
{	O
char	O
*	O
value	int
;	O
value	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
valueM	int
;	O
if	O
(	O
value	int
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: sw option %d [%s] is null, using default [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
nopt	enum
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
optionNameM	pointer
,	O
opta	pointer
[	O
nopt	enum
]	O
.	O
defaultValueM	pointer
)	O
;	O
}	O
if	O
(	O
!	O
value	int
)	O
value	int
=	O
opta	pointer
[	O
nopt	enum
]	O
.	O
defaultValueM	pointer
;	O
return	O
value	int
;	O
}	O
int	O
parse_options_file	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
util_name	pointer
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
access	function
(	O
filename	pointer
,	O
R_OK	int
)	O
==	O
0	int
||	O
strcmp	function
(	O
filename	pointer
,	O
SWBIS_STDIO_FNAME	pointer
)	O
==	O
0	int
)	O
{	O
ret	int
=	O
parseDefaultsFile	function
(	O
util_name	pointer
,	O
filename	pointer
,	O
opta	pointer
,	O
1	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
char	O
*	O
initialize_options_files_list	function
(	O
char	O
*	O
usethis	pointer
)	O
{	O
char	O
*	O
ret	int
;	O
if	O
(	O
usethis	pointer
)	O
{	O
ret	int
=	O
strdup	function
(	O
usethis	pointer
)	O
;	O
}	O
else	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
SYSTEM_DEFAULTS_FILE	O
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
" "	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
SYSTEM_SWBISDEFAULTS_FILE	O
)	O
;	O
if	O
(	O
getenv	function
(	O
"HOME"	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
tmp	pointer
,	O
" "	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
getenv	function
(	O
"HOME"	pointer
)	O
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
"/.swbis/swdefaults"	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
" "	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
getenv	function
(	O
"HOME"	pointer
)	O
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
"/.swbis/swbisdefaults"	pointer
)	O
;	O
}	O
ret	int
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swextopt_parse_options_files	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
char	O
*	O
option_files	pointer
,	O
char	O
*	O
util_name	pointer
,	O
int	O
reqd	int
,	O
int	O
show_only	int
)	O
{	O
int	O
do_check_access	int
=	O
0	int
;	O
char	O
*	O
file	pointer
;	O
int	O
skip	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
STROB	struct
*	O
ktmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
if	O
(	O
option_files	pointer
&&	O
strlen	function
(	O
option_files	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
option_files	pointer
)	O
return	O
0	int
;	O
if	O
(	O
show_only	int
)	O
{	O
do_check_access	int
=	O
1	int
;	O
}	O
do_check_access	int
=	O
1	int
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
option_files	pointer
)	O
;	O
file	pointer
=	O
strob_strtok	function
(	O
ktmp	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
" ,\n\r"	pointer
)	O
;	O
while	O
(	O
file	pointer
)	O
{	O
if	O
(	O
do_check_access	int
&&	O
strcmp	function
(	O
file	pointer
,	O
SWBIS_STDIO_FNAME	pointer
)	O
)	O
{	O
if	O
(	O
access	function
(	O
file	pointer
,	O
R_OK	int
)	O
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
if	O
(	O
reqd	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %s\n"	pointer
,	O
file	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
show_only	int
==	O
0	int
)	O
{	O
close_stdio	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
skip	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
skip	int
=	O
0	int
;	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
if	O
(	O
show_only	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"%s\n"	pointer
,	O
file	pointer
)	O
;	O
skip	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
show_only	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
skip	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
skip	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
ret	int
=	O
parse_options_file	function
(	O
opta	pointer
,	O
file	pointer
,	O
util_name	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"error processing option file : %s\n"	pointer
,	O
file	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
skip	int
=	O
0	int
;	O
file	pointer
=	O
strob_strtok	function
(	O
ktmp	pointer
,	O
NULL	O
,	O
" "	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
ktmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
has_file_part	function
(	O
char	O
*	O
soc	pointer
)	O
{	O
if	O
(	O
!	O
soc	pointer
||	O
strlen	function
(	O
soc	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
strchr	function
(	O
soc	pointer
,	O
':'	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
soc	pointer
+	O
(	O
strlen	function
(	O
soc	pointer
)	O
-	O
1	int
)	O
)	O
==	O
':'	O
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
is_host	function
(	O
char	O
*	O
soc	pointer
)	O
{	O
if	O
(	O
!	O
soc	pointer
||	O
!	O
strlen	function
(	O
soc	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
soc	pointer
==	O
'@'	O
)	O
soc	pointer
++	O
;	O
if	O
(	O
(	O
strcmp	function
(	O
soc	pointer
,	O
"."	pointer
)	O
&&	O
strcmp	function
(	O
soc	pointer
,	O
"./"	pointer
)	O
)	O
&&	O
(	O
(	O
strchr	function
(	O
soc	pointer
,	O
':'	O
)	O
&&	O
*	O
soc	pointer
!=	O
':'	O
)	O
||	O
(	O
strchr	function
(	O
soc	pointer
,	O
':'	O
)	O
==	O
NULL	O
&&	O
*	O
soc	pointer
!=	O
'/'	O
)	O
||	O
soc	pointer
[	O
strlen	function
(	O
soc	pointer
)	O
-	O
1	int
]	O
==	O
':'	O
||	O
0	int
)	O
)	O
{	O
E_DEBUG2	O
(	O
"is host: %s"	pointer
,	O
soc	pointer
)	O
;	O
return	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"is not host: %s"	pointer
,	O
soc	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
is_fq	function
(	O
char	O
*	O
soc_spec	pointer
)	O
{	O
char	O
*	O
trailing_colon	pointer
;	O
if	O
(	O
*	O
soc_spec	pointer
==	O
'/'	O
)	O
return	O
1	int
;	O
trailing_colon	pointer
=	O
strrchr	function
(	O
soc_spec	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
trailing_colon	pointer
&&	O
*	O
(	O
trailing_colon	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
return	O
1	int
;	O
if	O
(	O
trailing_colon	pointer
&&	O
*	O
(	O
trailing_colon	pointer
+	O
1	int
)	O
==	O
'.'	O
&&	O
*	O
(	O
trailing_colon	pointer
+	O
2	int
)	O
==	O
'\0'	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
swextopt_combine_directory	function
(	O
STROB	struct
*	O
result	pointer
,	O
char	O
*	O
soc_spec	pointer
,	O
char	O
*	O
directory	pointer
)	O
{	O
int	O
retval	int
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
E_DEBUG3	O
(	O
"soc_spec=%s directory=%s"	pointer
,	O
soc_spec	pointer
,	O
directory	pointer
)	O
;	O
if	O
(	O
soc_spec	pointer
)	O
{	O
strob_strcpy	function
(	O
result	pointer
,	O
soc_spec	pointer
)	O
;	O
}	O
if	O
(	O
soc_spec	pointer
==	O
NULL	O
||	O
directory	pointer
==	O
NULL	O
||	O
strlen	function
(	O
directory	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
directory	pointer
,	O
"-"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
directory	pointer
,	O
":"	pointer
)	O
==	O
0	int
||	O
(	O
*	O
soc_spec	pointer
==	O
'.'	O
&&	O
*	O
directory	pointer
==	O
'.'	O
)	O
||	O
(	O
*	O
soc_spec	pointer
==	O
'-'	O
)	O
||	O
is_fq	function
(	O
soc_spec	pointer
)	O
||	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"returning doing nothing"	pointer
)	O
;	O
E_DEBUG	O
(	O
"LEAVING retval=0"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
E_DEBUG3	O
(	O
"soc_spec=%s directory=%s"	pointer
,	O
soc_spec	pointer
,	O
directory	pointer
)	O
;	O
retval	int
=	O
0	int
;	O
if	O
(	O
(	O
is_host	function
(	O
directory	pointer
)	O
&&	O
is_host	function
(	O
soc_spec	pointer
)	O
)	O
||	O
(	O
is_host	function
(	O
directory	pointer
)	O
==	O
0	int
&&	O
is_host	function
(	O
soc_spec	pointer
)	O
==	O
0	int
)	O
||	O
0	int
)	O
{	O
;	O
E_DEBUG3	O
(	O
"directory: is_host(%s)=%d"	pointer
,	O
directory	pointer
,	O
is_host	function
(	O
directory	pointer
)	O
)	O
;	O
E_DEBUG3	O
(	O
"soc_spec:  is_host(%s)=%d"	pointer
,	O
soc_spec	pointer
,	O
is_host	function
(	O
soc_spec	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
"AMBIG retval=-1"	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
strlen	function
(	O
soc_spec	pointer
)	O
>	O
1	int
&&	O
*	O
soc_spec	pointer
==	O
':'	O
)	O
||	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
if	O
(	O
strchr	function
(	O
directory	pointer
,	O
':'	O
)	O
)	O
{	O
strob_strcpy	function
(	O
result	pointer
,	O
directory	pointer
)	O
;	O
if	O
(	O
directory	pointer
[	O
strlen	function
(	O
directory	pointer
)	O
-	O
1	int
]	O
!=	O
'/'	O
)	O
{	O
strob_strcat	function
(	O
result	pointer
,	O
"/"	pointer
)	O
;	O
}	O
strob_strcat	function
(	O
result	pointer
,	O
soc_spec	pointer
+	O
1	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
strob_strcpy	function
(	O
result	pointer
,	O
directory	pointer
)	O
;	O
strob_strcat	function
(	O
result	pointer
,	O
soc_spec	pointer
)	O
;	O
}	O
if	O
(	O
strchr	function
(	O
soc_spec	pointer
,	O
'/'	O
)	O
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
E_DEBUG	O
(	O
"LEAVING retval=-1"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strlen	function
(	O
soc_spec	pointer
)	O
>=	O
1	int
&&	O
*	O
soc_spec	pointer
==	O
'/'	O
&&	O
strchr	function
(	O
directory	pointer
,	O
':'	O
)	O
==	O
NULL	O
&&	O
*	O
directory	pointer
!=	O
'/'	O
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
strob_strcpy	function
(	O
result	pointer
,	O
"@"	pointer
)	O
;	O
strob_strcpy	function
(	O
result	pointer
,	O
directory	pointer
)	O
;	O
strob_strcat	function
(	O
result	pointer
,	O
":"	pointer
)	O
;	O
strob_strcat	function
(	O
result	pointer
,	O
soc_spec	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
soc_spec	pointer
!=	O
':'	O
&&	O
*	O
soc_spec	pointer
!=	O
'/'	O
&&	O
strchr	function
(	O
soc_spec	pointer
,	O
':'	O
)	O
==	O
NULL	O
&&	O
*	O
directory	pointer
==	O
'/'	O
&&	O
strchr	function
(	O
directory	pointer
,	O
':'	O
)	O
==	O
NULL	O
&&	O
strlen	function
(	O
directory	pointer
)	O
>	O
0	int
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
strob_strcpy	function
(	O
result	pointer
,	O
soc_spec	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
soc_spec	pointer
)	O
>	O
0	int
)	O
strob_strcat	function
(	O
result	pointer
,	O
":"	pointer
)	O
;	O
strob_strcat	function
(	O
result	pointer
,	O
directory	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
is_host	function
(	O
directory	pointer
)	O
&&	O
is_host	function
(	O
soc_spec	pointer
)	O
&&	O
has_file_part	function
(	O
soc_spec	pointer
)	O
==	O
0	int
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
combine1	function
(	O
result	pointer
,	O
directory	pointer
,	O
soc_spec	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_host	function
(	O
directory	pointer
)	O
&&	O
!	O
is_host	function
(	O
soc_spec	pointer
)	O
&&	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"case"	pointer
)	O
;	O
combine1	function
(	O
result	pointer
,	O
soc_spec	pointer
,	O
directory	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_host	function
(	O
soc_spec	pointer
)	O
&&	O
has_file_part	function
(	O
soc_spec	pointer
)	O
&&	O
1	int
)	O
{	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"null case"	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"result=%s"	pointer
,	O
strob_str	function
(	O
result	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"returning with value %d"	pointer
,	O
retval	int
)	O
;	O
E_DEBUG2	O
(	O
"LEAVING retval=%d"	pointer
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swextopt_get_status	function
(	O
void	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
swextopt_statusG	int
;	O
}	O
