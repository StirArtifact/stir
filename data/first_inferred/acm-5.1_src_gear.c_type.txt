extern	O
void	O
euler	function
(	O
craft	struct
*	O
)	O
;	O
double	O
groundContactTime	function
(	O
craft	struct
*	O
c	pointer
,	O
VPoint	struct
*	O
contactSg	pointer
)	O
{	O
register	O
craftType	struct
*	O
p	pointer
=	O
c	pointer
->	O
cinfo	pointer
;	O
register	O
double	O
tm	double
,	O
tn	double
;	O
VPoint	struct
v	struct
,	O
s0	struct
,	O
s0n	struct
,	O
Sg	struct
,	O
gear	struct
;	O
double	O
local_z	double
=	O
0.0	int
;	O
tm	double
=	O
tn	double
=	O
2.0	int
;	O
Sg	struct
.	O
x	float
=	O
Sg	struct
.	O
y	short
=	O
0.0	int
;	O
local_z	double
=	O
localAltitude	function
(	O
&	O
c	pointer
->	O
prevSg	struct
,	O
&	O
c	pointer
->	O
prevw	struct
)	O
;	O
Sg	struct
.	O
z	short
=	O
-	O
METERStoFEET	O
(	O
c	pointer
->	O
w	pointer
.	O
z	short
-	O
local_z	double
)	O
;	O
c	pointer
->	O
localTerrain_feet	double
=	O
METERStoFEET	O
(	O
local_z	double
)	O
;	O
v	struct
.	O
x	float
=	O
c	pointer
->	O
Cg	struct
.	O
x	float
;	O
v	struct
.	O
y	short
=	O
c	pointer
->	O
Cg	struct
.	O
y	short
;	O
v	struct
.	O
z	short
=	O
-	O
METERStoFEET	O
(	O
c	pointer
->	O
w	pointer
.	O
z	short
-	O
c	pointer
->	O
prevw	struct
.	O
z	short
)	O
;	O
if	O
(	O
v	struct
.	O
z	short
<=	O
0.0	int
)	O
{	O
return	O
-	O
1.0	int
;	O
}	O
gear	struct
=	O
p	pointer
->	O
rm	struct
;	O
gear	struct
.	O
z	short
+=	O
p	pointer
->	O
Gm	double
+	O
p	pointer
->	O
cmMax	double
;	O
VTransform	function
(	O
&	O
gear	struct
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
&	O
s0	struct
)	O
;	O
s0	struct
.	O
z	short
+=	O
-	O
METERStoFEET	O
(	O
c	pointer
->	O
prevw	struct
.	O
z	short
-	O
local_z	double
)	O
;	O
if	O
(	O
s0	struct
.	O
z	short
>	O
(	O
0.0	int
+	O
EPSILON	int
)	O
)	O
{	O
*	O
contactSg	pointer
=	O
c	pointer
->	O
prevSg	struct
;	O
c	pointer
->	O
flags	short
|=	O
FL_GND_CONTACT	O
;	O
return	O
0.0	int
;	O
}	O
if	O
(	O
(	O
s0	struct
.	O
z	short
+	O
v	struct
.	O
z	short
)	O
>	O
0.0	int
)	O
{	O
tm	double
=	O
-	O
s0	struct
.	O
z	short
/	O
v	struct
.	O
z	short
;	O
if	O
(	O
c	pointer
->	O
curGear	array
[	O
1	int
]	O
!=	O
geardown	O
||	O
c	pointer
->	O
curGear	array
[	O
2	int
]	O
!=	O
geardown	O
)	O
{	O
killPlayerEx	function
(	O
c	pointer
,	O
"Your main landing gear wasn't down and locked\n"	pointer
,	O
"Either you forgot to extend the gear, or it was damaged in combat."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
gear	struct
=	O
p	pointer
->	O
rn	struct
;	O
gear	struct
.	O
z	short
+=	O
p	pointer
->	O
Gn	double
+	O
p	pointer
->	O
cnMax	double
;	O
VTransform	function
(	O
&	O
gear	struct
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
&	O
s0n	struct
)	O
;	O
s0n	struct
.	O
z	short
-=	O
METERStoFEET	O
(	O
c	pointer
->	O
prevw	struct
.	O
z	short
-	O
local_z	double
)	O
;	O
if	O
(	O
s0n	struct
.	O
z	short
>	O
(	O
0.0	int
+	O
EPSILON	int
)	O
)	O
{	O
*	O
contactSg	pointer
=	O
c	pointer
->	O
prevSg	struct
;	O
c	pointer
->	O
flags	short
|=	O
FL_GND_CONTACT	O
;	O
return	O
0.0	int
;	O
}	O
if	O
(	O
(	O
s0n	struct
.	O
z	short
+	O
v	struct
.	O
z	short
)	O
>	O
0.0	int
)	O
{	O
tn	double
=	O
-	O
s0n	struct
.	O
z	short
/	O
v	struct
.	O
z	short
;	O
if	O
(	O
c	pointer
->	O
curGear	array
[	O
0	int
]	O
!=	O
geardown	O
)	O
{	O
killPlayerEx	function
(	O
c	pointer
,	O
"Your nose gear wasn't down and locked"	pointer
,	O
"Either you forgot to extend the gear, or it was damaged in combat."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
tm	double
!=	O
2.0	int
||	O
tn	double
!=	O
2.0	int
)	O
{	O
c	pointer
->	O
flags	short
|=	O
FL_GND_CONTACT	O
;	O
if	O
(	O
tn	double
<	O
tm	double
)	O
{	O
tm	double
=	O
tn	double
;	O
}	O
if	O
(	O
tm	double
<	O
0.0	int
)	O
{	O
return	O
-	O
1.0	int
;	O
}	O
return	O
tm	double
*	O
deltaT	double
;	O
}	O
else	O
return	O
-	O
1.0	int
;	O
}	O
static	O
VPoint	struct
zeroPt	struct
=	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
int	O
groundDynamics	function
(	O
craft	struct
*	O
c	pointer
,	O
double	O
startT	double
,	O
double	O
CL	double
,	O
double	O
CD	double
,	O
double	O
CM	double
,	O
double	O
w	pointer
,	O
double	O
qS	double
)	O
{	O
register	O
double	O
sinTheta	double
,	O
cosTheta	double
;	O
register	O
craftType	struct
*	O
p	pointer
;	O
double	O
theta	double
,	O
theta_dot	double
,	O
dT	double
,	O
cm	double
,	O
cn	int
,	O
cm_dot	double
,	O
cn_dot	double
,	O
m	float
;	O
double	O
t	double
,	O
next_t	double
,	O
muStatic	double
;	O
double	O
muKinetic	double
,	O
Mu	double
,	O
nMu	double
;	O
double	O
lift	double
,	O
drag	double
,	O
pitch_moment	double
,	O
angle	double
;	O
double	O
v	struct
,	O
sinAlphaP	double
,	O
cosAlphaP	double
;	O
VPoint	struct
F	struct
,	O
M	struct
,	O
mt	pointer
,	O
Sg	struct
,	O
Cg	struct
,	O
Fm	struct
,	O
Fn	struct
,	O
FnMu	struct
,	O
FmMu	struct
,	O
r	pointer
,	O
tmpPt	struct
,	O
Ftot	struct
;	O
VMatrix	struct
turn	struct
,	O
mtx	struct
;	O
double	O
theta_damp	double
;	O
int	O
done	int
=	O
0	int
,	O
niter	int
=	O
0	int
;	O
double	O
smag	double
;	O
double	O
local_z	double
=	O
0.0	int
;	O
t	double
=	O
0.0	int
;	O
Fm	struct
.	O
x	float
=	O
Fm	struct
.	O
y	short
=	O
Fm	struct
.	O
z	short
=	O
0.0	int
;	O
Fn	struct
.	O
x	float
=	O
Fn	struct
.	O
y	short
=	O
Fn	struct
.	O
z	short
=	O
0.0	int
;	O
Ftot	struct
.	O
x	float
=	O
Ftot	struct
.	O
y	short
=	O
Ftot	struct
.	O
z	short
=	O
0.0	int
;	O
m	float
=	O
w	pointer
/	O
earth_g	int
;	O
dT	double
=	O
0.002	int
;	O
p	pointer
=	O
c	pointer
->	O
cinfo	pointer
;	O
theta_damp	double
=	O
0.25	int
*	O
p	pointer
->	O
wingS	double
*	O
c	pointer
->	O
rho	double
*	O
p	pointer
->	O
c	pointer
*	O
p	pointer
->	O
c	pointer
*	O
p	pointer
->	O
Cmq	double
;	O
v	struct
=	O
mag	O
(	O
c	pointer
->	O
Cg	struct
)	O
;	O
Cg	struct
.	O
z	short
=	O
c	pointer
->	O
Cg	struct
.	O
z	short
;	O
Cg	struct
.	O
y	short
=	O
0.0	int
;	O
Cg	struct
.	O
x	float
=	O
sqrt	function
(	O
v	struct
*	O
v	struct
-	O
Cg	struct
.	O
z	short
*	O
Cg	struct
.	O
z	short
)	O
;	O
Sg	struct
.	O
x	float
=	O
Sg	struct
.	O
y	short
=	O
0.0	int
;	O
local_z	double
=	O
localAltitude	function
(	O
&	O
c	pointer
->	O
Sg	struct
,	O
&	O
c	pointer
->	O
w	pointer
)	O
;	O
Sg	struct
.	O
z	short
=	O
-	O
METERStoFEET	O
(	O
c	pointer
->	O
w	pointer
.	O
z	short
-	O
local_z	double
)	O
;	O
c	pointer
->	O
localTerrain_feet	double
=	O
METERStoFEET	O
(	O
local_z	double
)	O
;	O
theta	double
=	O
-	O
c	pointer
->	O
curPitch	double
;	O
theta_dot	double
=	O
-	O
c	pointer
->	O
q	double
;	O
lift	double
=	O
CL	double
*	O
qS	double
;	O
drag	double
=	O
CD	double
*	O
qS	double
;	O
pitch_moment	double
=	O
CM	double
*	O
(	O
c	pointer
->	O
alpha	double
+	O
elevatorSetting	function
(	O
c	pointer
,	O
qS	double
,	O
w	pointer
)	O
*	O
p	pointer
->	O
effElevator	double
)	O
*	O
p	pointer
->	O
c	pointer
*	O
qS	double
;	O
if	O
(	O
c	pointer
->	O
flags	short
&	O
FL_BRAKES	O
)	O
{	O
muStatic	double
=	O
p	pointer
->	O
muBStatic	double
;	O
muKinetic	double
=	O
p	pointer
->	O
muBKinetic	double
;	O
}	O
else	O
{	O
muStatic	double
=	O
p	pointer
->	O
muStatic	double
;	O
muKinetic	double
=	O
p	pointer
->	O
muKinetic	double
;	O
}	O
sinAlphaP	double
=	O
sin	function
(	O
c	pointer
->	O
alpha	double
+	O
theta	double
)	O
;	O
cosAlphaP	double
=	O
cos	function
(	O
c	pointer
->	O
alpha	double
+	O
theta	double
)	O
;	O
for	O
(	O
t	double
=	O
startT	double
;	O
!	O
done	int
;	O
t	double
=	O
next_t	double
)	O
{	O
next_t	double
=	O
t	double
+	O
dT	double
;	O
if	O
(	O
next_t	double
>=	O
deltaT	double
)	O
{	O
done	int
=	O
1	int
;	O
dT	double
=	O
deltaT	double
-	O
t	double
;	O
}	O
sinTheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
cosTheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
cm	double
=	O
-	O
(	O
Sg	struct
.	O
z	short
+	O
p	pointer
->	O
rm	struct
.	O
x	float
*	O
sinTheta	double
)	O
/	O
cosTheta	double
-	O
p	pointer
->	O
Gm	double
-	O
p	pointer
->	O
rm	struct
.	O
z	short
;	O
cn	int
=	O
-	O
(	O
Sg	struct
.	O
z	short
+	O
p	pointer
->	O
rn	struct
.	O
x	float
*	O
sinTheta	double
)	O
/	O
cosTheta	double
-	O
p	pointer
->	O
Gn	double
-	O
p	pointer
->	O
rn	struct
.	O
z	short
;	O
cm_dot	double
=	O
-	O
(	O
p	pointer
->	O
rm	struct
.	O
x	float
*	O
theta_dot	double
+	O
Cg	struct
.	O
z	short
/	O
cosTheta	double
+	O
(	O
(	O
Sg	struct
.	O
z	short
+	O
p	pointer
->	O
rm	struct
.	O
x	float
*	O
sinTheta	double
)	O
*	O
sinTheta	double
*	O
theta_dot	double
)	O
/	O
(	O
cosTheta	double
*	O
cosTheta	double
)	O
)	O
;	O
cn_dot	double
=	O
-	O
(	O
p	pointer
->	O
rn	struct
.	O
x	float
*	O
theta_dot	double
+	O
Cg	struct
.	O
z	short
/	O
cosTheta	double
+	O
(	O
(	O
Sg	struct
.	O
z	short
+	O
p	pointer
->	O
rn	struct
.	O
x	float
*	O
sinTheta	double
)	O
*	O
sinTheta	double
*	O
theta_dot	double
)	O
/	O
(	O
cosTheta	double
*	O
cosTheta	double
)	O
)	O
;	O
if	O
(	O
cm	double
<	O
0.0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
cn	int
<	O
0.0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
cm	double
<	O
p	pointer
->	O
cmMax	double
)	O
{	O
Fm	struct
.	O
z	short
=	O
-	O
(	O
p	pointer
->	O
Km	double
*	O
(	O
p	pointer
->	O
cmMax	double
-	O
cm	double
)	O
)	O
;	O
if	O
(	O
cm_dot	double
<	O
0.0	int
)	O
Fm	struct
.	O
z	short
+=	O
p	pointer
->	O
Dm	double
*	O
cm_dot	double
;	O
}	O
else	O
Fm	struct
.	O
z	short
=	O
0.0	int
;	O
if	O
(	O
cn	int
<	O
p	pointer
->	O
cnMax	double
)	O
{	O
Fn	struct
.	O
z	short
=	O
-	O
(	O
p	pointer
->	O
Kn	double
*	O
(	O
p	pointer
->	O
cnMax	double
-	O
cn	int
)	O
)	O
;	O
if	O
(	O
cn_dot	double
<	O
0.0	int
)	O
Fn	struct
.	O
z	short
+=	O
p	pointer
->	O
Dn	double
*	O
cn_dot	double
;	O
if	O
(	O
cn	int
<	O
0.1	int
)	O
Fn	struct
.	O
z	short
+=	O
-	O
100	int
*	O
(	O
p	pointer
->	O
Kn	double
*	O
(	O
0.1	int
-	O
cn	int
)	O
)	O
;	O
}	O
else	O
Fn	struct
.	O
z	short
=	O
0.0	int
;	O
VCrossProd	function
(	O
&	O
Fm	struct
,	O
&	O
p	pointer
->	O
rm	struct
,	O
&	O
M	struct
)	O
;	O
VCrossProd	function
(	O
&	O
Fn	struct
,	O
&	O
p	pointer
->	O
rn	struct
,	O
&	O
mt	pointer
)	O
;	O
M	struct
.	O
x	float
+=	O
mt	pointer
.	O
x	float
;	O
M	struct
.	O
y	short
+=	O
mt	pointer
.	O
y	short
;	O
M	struct
.	O
z	short
+=	O
mt	pointer
.	O
z	short
;	O
if	O
(	O
fabs	function
(	O
Cg	struct
.	O
x	float
)	O
<	O
0.5	int
)	O
{	O
nMu	double
=	O
p	pointer
->	O
muStatic	double
;	O
Mu	double
=	O
muStatic	double
;	O
}	O
else	O
{	O
nMu	double
=	O
p	pointer
->	O
muKinetic	double
;	O
Mu	double
=	O
muKinetic	double
;	O
}	O
if	O
(	O
Cg	struct
.	O
x	float
<	O
0.0	int
)	O
Mu	double
=	O
-	O
Mu	double
;	O
else	O
if	O
(	O
Cg	struct
.	O
x	float
==	O
0.0	int
)	O
Mu	double
=	O
0.0	int
;	O
if	O
(	O
cm	double
<	O
p	pointer
->	O
cmMax	double
)	O
{	O
FmMu	struct
.	O
x	float
=	O
Fm	struct
.	O
z	short
*	O
cosTheta	double
*	O
cosTheta	double
*	O
Mu	double
;	O
FmMu	struct
.	O
y	short
=	O
0.0	int
;	O
FmMu	struct
.	O
z	short
=	O
Fm	struct
.	O
z	short
*	O
cosTheta	double
*	O
sinTheta	double
*	O
Mu	double
;	O
VCrossProd	function
(	O
&	O
FmMu	struct
,	O
&	O
p	pointer
->	O
rm	struct
,	O
&	O
mt	pointer
)	O
;	O
M	struct
.	O
x	float
+=	O
mt	pointer
.	O
x	float
;	O
M	struct
.	O
y	short
+=	O
mt	pointer
.	O
y	short
;	O
M	struct
.	O
z	short
+=	O
mt	pointer
.	O
z	short
;	O
}	O
if	O
(	O
cn	int
<	O
p	pointer
->	O
cnMax	double
)	O
{	O
FnMu	struct
.	O
x	float
=	O
Fn	struct
.	O
z	short
*	O
cosTheta	double
*	O
cosTheta	double
*	O
nMu	double
;	O
FnMu	struct
.	O
y	short
=	O
0.0	int
;	O
FnMu	struct
.	O
z	short
=	O
Fn	struct
.	O
z	short
*	O
cosTheta	double
*	O
sinTheta	double
*	O
nMu	double
;	O
VCrossProd	function
(	O
&	O
FnMu	struct
,	O
&	O
p	pointer
->	O
rn	struct
,	O
&	O
mt	pointer
)	O
;	O
M	struct
.	O
x	float
+=	O
mt	pointer
.	O
x	float
;	O
M	struct
.	O
y	short
+=	O
mt	pointer
.	O
y	short
;	O
M	struct
.	O
z	short
+=	O
mt	pointer
.	O
z	short
;	O
}	O
M	struct
.	O
y	short
-=	O
pitch_moment	double
-	O
theta_damp	double
*	O
v	struct
*	O
theta_dot	double
;	O
F	struct
.	O
x	float
=	O
-	O
(	O
Fm	struct
.	O
z	short
+	O
Fn	struct
.	O
z	short
)	O
*	O
sinTheta	double
;	O
F	struct
.	O
x	float
+=	O
(	O
Fm	struct
.	O
z	short
+	O
Fn	struct
.	O
z	short
)	O
*	O
cosTheta	double
*	O
Mu	double
;	O
F	struct
.	O
x	float
+=	O
cosTheta	double
*	O
c	pointer
->	O
curThrust	double
;	O
F	struct
.	O
x	float
-=	O
sinAlphaP	double
*	O
lift	double
;	O
F	struct
.	O
x	float
-=	O
cosAlphaP	double
*	O
drag	double
;	O
F	struct
.	O
y	short
=	O
0.0	int
;	O
F	struct
.	O
z	short
=	O
w	pointer
+	O
(	O
Fm	struct
.	O
z	short
+	O
Fn	struct
.	O
z	short
)	O
*	O
cosTheta	double
;	O
F	struct
.	O
z	short
+=	O
sinTheta	double
*	O
c	pointer
->	O
curThrust	double
;	O
F	struct
.	O
z	short
-=	O
cosAlphaP	double
*	O
lift	double
;	O
F	struct
.	O
z	short
-=	O
sinAlphaP	double
*	O
drag	double
;	O
Ftot	struct
.	O
x	float
+=	O
F	struct
.	O
x	float
;	O
Ftot	struct
.	O
y	short
+=	O
F	struct
.	O
y	short
;	O
Ftot	struct
.	O
z	short
+=	O
F	struct
.	O
z	short
;	O
niter	int
++	O
;	O
Sg	struct
.	O
x	float
+=	O
Cg	struct
.	O
x	float
*	O
dT	double
+	O
0.5	int
*	O
F	struct
.	O
x	float
/	O
m	float
*	O
dT	double
*	O
dT	double
;	O
Sg	struct
.	O
y	short
+=	O
Cg	struct
.	O
y	short
*	O
dT	double
+	O
0.5	int
*	O
F	struct
.	O
y	short
/	O
m	float
*	O
dT	double
*	O
dT	double
;	O
Sg	struct
.	O
z	short
+=	O
Cg	struct
.	O
z	short
*	O
dT	double
+	O
0.5	int
*	O
F	struct
.	O
z	short
/	O
m	float
*	O
dT	double
*	O
dT	double
;	O
Cg	struct
.	O
x	float
+=	O
F	struct
.	O
x	float
/	O
m	float
*	O
dT	double
;	O
Cg	struct
.	O
y	short
+=	O
F	struct
.	O
y	short
/	O
m	float
*	O
dT	double
;	O
Cg	struct
.	O
z	short
+=	O
F	struct
.	O
z	short
/	O
m	float
*	O
dT	double
;	O
theta	double
+=	O
theta_dot	double
*	O
dT	double
+	O
0.5	int
*	O
M	struct
.	O
y	short
/	O
p	pointer
->	O
I	int
.	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
*	O
dT	double
*	O
dT	double
;	O
theta_dot	double
+=	O
M	struct
.	O
y	short
/	O
p	pointer
->	O
I	int
.	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
*	O
dT	double
;	O
if	O
(	O
theta	double
<	O
DEGtoRAD	O
(	O
-	O
20.0	int
)	O
)	O
{	O
theta	double
=	O
DEGtoRAD	O
(	O
-	O
20.0	int
)	O
;	O
theta_dot	double
=	O
0.0	int
;	O
}	O
}	O
Sg	struct
.	O
x	float
=	O
FEETtoMETERS	O
(	O
Sg	struct
.	O
x	float
)	O
;	O
Sg	struct
.	O
y	short
=	O
FEETtoMETERS	O
(	O
Sg	struct
.	O
y	short
)	O
;	O
Sg	struct
.	O
z	short
=	O
FEETtoMETERS	O
(	O
Sg	struct
.	O
z	short
)	O
;	O
c	pointer
->	O
curNWDef	double
=	O
-	O
c	pointer
->	O
Sa	double
*	O
c	pointer
->	O
cinfo	pointer
->	O
maxNWDef	double
*	O
0.3	int
;	O
if	O
(	O
c	pointer
->	O
curNWDef	double
!=	O
0.0	int
&&	O
v	struct
<	O
p	pointer
->	O
maxNWS	double
&&	O
cn	int
<	O
p	pointer
->	O
cnMax	double
)	O
{	O
tmpPt	struct
.	O
x	float
=	O
c	pointer
->	O
cinfo	pointer
->	O
gearD2	double
;	O
tmpPt	struct
.	O
y	short
=	O
c	pointer
->	O
cinfo	pointer
->	O
gearD1	double
/	O
tan	function
(	O
c	pointer
->	O
curNWDef	double
)	O
;	O
tmpPt	struct
.	O
z	short
=	O
0.0	int
;	O
angle	double
=	O
Sg	struct
.	O
x	float
/	O
tmpPt	struct
.	O
y	short
;	O
VTransform	function
(	O
&	O
tmpPt	struct
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
&	O
r	pointer
)	O
;	O
VIdentMatrix	function
(	O
&	O
turn	struct
)	O
;	O
turn	struct
.	O
m	float
[	O
0	int
]	O
[	O
3	int
]	O
=	O
-	O
r	pointer
.	O
x	float
;	O
turn	struct
.	O
m	float
[	O
1	int
]	O
[	O
3	int
]	O
=	O
-	O
r	pointer
.	O
y	short
;	O
turn	struct
.	O
m	float
[	O
2	int
]	O
[	O
3	int
]	O
=	O
-	O
METERStoFEET	O
(	O
c	pointer
->	O
w	pointer
.	O
z	short
)	O
;	O
VRotate	function
(	O
&	O
turn	struct
,	O
ZRotation	int
,	O
angle	double
)	O
;	O
turn	struct
.	O
m	float
[	O
0	int
]	O
[	O
3	int
]	O
=	O
turn	struct
.	O
m	float
[	O
0	int
]	O
[	O
3	int
]	O
+	O
r	pointer
.	O
x	float
;	O
turn	struct
.	O
m	float
[	O
1	int
]	O
[	O
3	int
]	O
=	O
turn	struct
.	O
m	float
[	O
1	int
]	O
[	O
3	int
]	O
+	O
r	pointer
.	O
y	short
;	O
turn	struct
.	O
m	float
[	O
2	int
]	O
[	O
3	int
]	O
=	O
turn	struct
.	O
m	float
[	O
2	int
]	O
[	O
3	int
]	O
+	O
METERStoFEET	O
(	O
c	pointer
->	O
w	pointer
.	O
z	short
)	O
;	O
VTransform	function
(	O
&	O
zeroPt	struct
,	O
&	O
turn	struct
,	O
&	O
tmpPt	struct
)	O
;	O
smag	double
=	O
sqrt	function
(	O
tmpPt	struct
.	O
x	float
*	O
tmpPt	struct
.	O
x	float
+	O
tmpPt	struct
.	O
y	short
*	O
tmpPt	struct
.	O
y	short
)	O
;	O
DISUpdateWorldCoordinates	function
(	O
&	O
c	pointer
->	O
w	pointer
,	O
tmpPt	struct
.	O
x	float
/	O
smag	double
,	O
tmpPt	struct
.	O
y	short
/	O
smag	double
,	O
smag	double
)	O
;	O
c	pointer
->	O
w	pointer
.	O
z	short
=	O
-	O
FEETtoMETERS	O
(	O
Sg	struct
.	O
z	short
)	O
;	O
VIdentMatrix	function
(	O
&	O
turn	struct
)	O
;	O
VRotate	function
(	O
&	O
turn	struct
,	O
ZRotation	int
,	O
angle	double
)	O
;	O
mtx	struct
=	O
c	pointer
->	O
trihedral	struct
;	O
VMatrixMultByRank	function
(	O
&	O
mtx	struct
,	O
&	O
turn	struct
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
3	int
)	O
;	O
VTransform	function
(	O
&	O
(	O
c	pointer
->	O
Cg	struct
)	O
,	O
&	O
turn	struct
,	O
&	O
tmpPt	struct
)	O
;	O
c	pointer
->	O
Cg	struct
=	O
tmpPt	struct
;	O
c	pointer
->	O
r	pointer
=	O
-	O
angle	double
/	O
deltaT	double
;	O
euler	function
(	O
c	pointer
)	O
;	O
VSetPoint	O
(	O
tmpPt	struct
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
VTransform	function
(	O
&	O
tmpPt	struct
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
&	O
r	pointer
)	O
;	O
smag	double
=	O
sqrt	function
(	O
r	pointer
.	O
x	float
*	O
r	pointer
.	O
x	float
+	O
r	pointer
.	O
y	short
*	O
r	pointer
.	O
y	short
)	O
;	O
}	O
else	O
{	O
VSetPoint	O
(	O
tmpPt	struct
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
VTransform	function
(	O
&	O
tmpPt	struct
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
&	O
r	pointer
)	O
;	O
smag	double
=	O
sqrt	function
(	O
r	pointer
.	O
x	float
*	O
r	pointer
.	O
x	float
+	O
r	pointer
.	O
y	short
*	O
r	pointer
.	O
y	short
)	O
;	O
DISUpdateWorldCoordinates	function
(	O
&	O
c	pointer
->	O
w	pointer
,	O
r	pointer
.	O
x	float
/	O
smag	double
,	O
r	pointer
.	O
y	short
/	O
smag	double
,	O
Sg	struct
.	O
x	float
)	O
;	O
c	pointer
->	O
r	pointer
=	O
0.0	int
;	O
}	O
c	pointer
->	O
Cg	struct
.	O
x	float
=	O
Cg	struct
.	O
x	float
*	O
r	pointer
.	O
x	float
/	O
smag	double
;	O
c	pointer
->	O
Cg	struct
.	O
y	short
=	O
Cg	struct
.	O
x	float
*	O
r	pointer
.	O
y	short
/	O
smag	double
;	O
c	pointer
->	O
Cg	struct
.	O
z	short
=	O
Cg	struct
.	O
z	short
;	O
c	pointer
->	O
groundCgx	double
=	O
Cg	struct
.	O
x	float
;	O
c	pointer
->	O
w	pointer
.	O
z	short
=	O
-	O
Sg	struct
.	O
z	short
+	O
local_z	double
;	O
c	pointer
->	O
curPitch	double
=	O
-	O
theta	double
;	O
c	pointer
->	O
curRoll	double
=	O
0.0	int
;	O
c	pointer
->	O
p	pointer
=	O
0.0	int
;	O
c	pointer
->	O
q	double
=	O
-	O
theta_dot	double
;	O
buildEulerMatrix	function
(	O
c	pointer
->	O
curRoll	double
,	O
c	pointer
->	O
curPitch	double
,	O
c	pointer
->	O
curHeading	double
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
)	O
;	O
c	pointer
->	O
linAcc	struct
.	O
x	float
=	O
(	O
Ftot	struct
.	O
x	float
*	O
cosTheta	double
-	O
Ftot	struct
.	O
z	short
*	O
sinTheta	double
)	O
/	O
(	O
niter	int
*	O
m	float
)	O
;	O
c	pointer
->	O
linAcc	struct
.	O
y	short
=	O
0.0	int
;	O
c	pointer
->	O
linAcc	struct
.	O
z	short
=	O
-	O
(	O
Ftot	struct
.	O
x	float
*	O
sinTheta	double
+	O
Ftot	struct
.	O
z	short
*	O
cosTheta	double
)	O
/	O
(	O
niter	int
*	O
m	float
)	O
;	O
c	pointer
->	O
G	struct
.	O
z	short
=	O
c	pointer
->	O
linAcc	struct
.	O
x	float
/	O
earth_g	int
;	O
c	pointer
->	O
G	struct
.	O
y	short
=	O
c	pointer
->	O
linAcc	struct
.	O
y	short
/	O
earth_g	int
;	O
c	pointer
->	O
G	struct
.	O
z	short
=	O
c	pointer
->	O
linAcc	struct
.	O
z	short
/	O
earth_g	int
-	O
1.0	int
;	O
if	O
(	O
(	O
cm	double
>=	O
p	pointer
->	O
cmMax	double
)	O
&&	O
(	O
cn	int
>=	O
p	pointer
->	O
cnMax	double
)	O
)	O
{	O
cosTheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
sinTheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
cm	double
=	O
-	O
(	O
Sg	struct
.	O
z	short
+	O
p	pointer
->	O
rm	struct
.	O
x	float
*	O
sinTheta	double
)	O
/	O
cosTheta	double
-	O
p	pointer
->	O
Gm	double
-	O
p	pointer
->	O
rm	struct
.	O
z	short
;	O
cn	int
=	O
-	O
(	O
Sg	struct
.	O
z	short
+	O
p	pointer
->	O
rn	struct
.	O
x	float
*	O
sinTheta	double
)	O
/	O
cosTheta	double
-	O
p	pointer
->	O
Gn	double
-	O
p	pointer
->	O
rn	struct
.	O
z	short
;	O
if	O
(	O
(	O
cm	double
>=	O
p	pointer
->	O
cmMax	double
)	O
&&	O
(	O
cn	int
>=	O
p	pointer
->	O
cnMax	double
)	O
)	O
{	O
c	pointer
->	O
flags	short
&=	O
~	O
FL_GND_CONTACT	O
;	O
c	pointer
->	O
groundCgx	double
=	O
0.0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
