const	O
char	O
*	O
short_illegals	pointer
=	O
";+=[]',\"*\\<>/?:|"	pointer
;	O
const	O
char	O
*	O
long_illegals	pointer
=	O
"\"*\\<>/?:|\005"	pointer
;	O
static	O
void	O
autorename	function
(	O
char	O
*	O
name	pointer
,	O
char	O
tilda	char
,	O
char	O
dot	char
,	O
const	O
char	O
*	O
illegals	pointer
,	O
int	O
limit	int
,	O
int	O
bump	int
)	O
{	O
int	O
tildapos	int
,	O
dotpos	int
;	O
unsigned	O
int	O
seqnum	int
=	O
0	int
,	O
maxseq	int
=	O
0	int
;	O
char	O
tmp	char
;	O
char	O
*	O
p	pointer
;	O
tildapos	int
=	O
-	O
1	int
;	O
for	O
(	O
p	pointer
=	O
name	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strchr	function
(	O
illegals	pointer
,	O
*	O
p	pointer
)	O
)	O
{	O
*	O
p	pointer
=	O
'_'	O
;	O
bump	int
=	O
0	int
;	O
}	O
for	O
(	O
dotpos	int
=	O
0	int
;	O
name	pointer
[	O
dotpos	int
]	O
&&	O
dotpos	int
<	O
limit	int
&&	O
name	pointer
[	O
dotpos	int
]	O
!=	O
dot	char
;	O
dotpos	int
++	O
)	O
{	O
if	O
(	O
name	pointer
[	O
dotpos	int
]	O
==	O
tilda	char
)	O
{	O
tildapos	int
=	O
dotpos	int
;	O
seqnum	int
=	O
0	int
;	O
maxseq	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
name	pointer
[	O
dotpos	int
]	O
>=	O
'0'	O
&&	O
name	pointer
[	O
dotpos	int
]	O
<=	O
'9'	O
)	O
{	O
seqnum	int
=	O
seqnum	int
*	O
10	int
+	O
name	pointer
[	O
dotpos	int
]	O
-	O
'0'	O
;	O
maxseq	int
=	O
maxseq	int
*	O
10	int
;	O
}	O
else	O
tildapos	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
tildapos	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
dotpos	int
>	O
limit	int
-	O
2	int
)	O
{	O
tildapos	int
=	O
limit	int
-	O
2	int
;	O
dotpos	int
=	O
limit	int
;	O
}	O
else	O
{	O
tildapos	int
=	O
dotpos	int
;	O
dotpos	int
+=	O
2	int
;	O
}	O
seqnum	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
bump	int
)	O
seqnum	int
++	O
;	O
if	O
(	O
seqnum	int
>	O
999999	int
)	O
{	O
seqnum	int
=	O
1	int
;	O
tildapos	int
=	O
dotpos	int
-	O
2	int
;	O
}	O
if	O
(	O
seqnum	int
==	O
maxseq	int
)	O
{	O
if	O
(	O
dotpos	int
>=	O
limit	int
)	O
tildapos	int
--	O
;	O
else	O
dotpos	int
++	O
;	O
}	O
}	O
tmp	char
=	O
name	pointer
[	O
dotpos	int
]	O
;	O
if	O
(	O
(	O
bump	int
&&	O
seqnum	int
==	O
1	int
)	O
||	O
seqnum	int
>	O
1	int
||	O
mtools_numeric_tail	int
)	O
sprintf	function
(	O
name	pointer
+	O
tildapos	int
,	O
"%c%d"	pointer
,	O
tilda	char
,	O
seqnum	int
)	O
;	O
if	O
(	O
dot	char
)	O
name	pointer
[	O
dotpos	int
]	O
=	O
tmp	char
;	O
}	O
void	O
autorename_short	function
(	O
dos_name_t	struct
*	O
name	pointer
,	O
int	O
bump	int
)	O
{	O
autorename	function
(	O
name	pointer
->	O
base	int
,	O
'~'	O
,	O
' '	O
,	O
short_illegals	pointer
,	O
8	int
,	O
bump	int
)	O
;	O
}	O
void	O
autorename_long	function
(	O
char	O
*	O
name	pointer
,	O
int	O
bump	int
)	O
{	O
autorename	function
(	O
name	pointer
,	O
'-'	O
,	O
'\0'	O
,	O
long_illegals	pointer
,	O
255	int
,	O
bump	int
)	O
;	O
}	O
static	O
__inline__	O
int	O
unicode_read	function
(	O
struct	O
unicode_char	struct
*	O
in	pointer
,	O
wchar_t	int
*	O
out	pointer
,	O
int	O
num	int
)	O
{	O
wchar_t	int
*	O
end_out	pointer
=	O
out	pointer
+	O
num	int
;	O
while	O
(	O
out	pointer
<	O
end_out	pointer
)	O
{	O
*	O
out	pointer
=	O
in	pointer
->	O
lchar	char
|	O
(	O
(	O
in	pointer
->	O
uchar	char
)	O
<<	O
8	int
)	O
;	O
++	O
out	pointer
;	O
++	O
in	pointer
;	O
}	O
return	O
num	int
;	O
}	O
void	O
clear_vfat	function
(	O
struct	O
vfat_state	struct
*	O
v	pointer
)	O
{	O
v	pointer
->	O
subentries	int
=	O
0	int
;	O
v	pointer
->	O
status	int
=	O
0	int
;	O
v	pointer
->	O
present	int
=	O
0	int
;	O
}	O
static	O
__inline__	O
unsigned	O
char	O
sum_shortname	function
(	O
const	O
dos_name_t	struct
*	O
dn	pointer
)	O
{	O
unsigned	O
char	O
sum	char
;	O
const	O
char	O
*	O
name	pointer
=	O
dn	pointer
->	O
base	int
;	O
const	O
char	O
*	O
end	pointer
=	O
name	pointer
+	O
11	int
;	O
for	O
(	O
sum	char
=	O
0	int
;	O
name	pointer
<	O
end	pointer
;	O
++	O
name	pointer
)	O
sum	char
=	O
(	O
(	O
sum	char
&	O
1	int
)	O
?	O
0x80	int
:	O
0	int
)	O
+	O
(	O
sum	char
>>	O
1	int
)	O
+	O
*	O
name	pointer
;	O
return	O
(	O
sum	char
)	O
;	O
}	O
static	O
__inline__	O
void	O
check_vfat	function
(	O
struct	O
vfat_state	struct
*	O
v	pointer
,	O
struct	O
directory	struct
*	O
dir	pointer
)	O
{	O
dos_name_t	struct
dn	pointer
;	O
;	O
if	O
(	O
!	O
v	pointer
->	O
subentries	int
)	O
{	O
return	O
;	O
}	O
memcpy	function
(	O
dn	pointer
.	O
base	int
,	O
(	O
char	O
*	O
)	O
dir	pointer
->	O
name	pointer
,	O
8	int
)	O
;	O
memcpy	function
(	O
dn	pointer
.	O
ext	array
,	O
(	O
char	O
*	O
)	O
dir	pointer
->	O
ext	array
,	O
3	int
)	O
;	O
if	O
(	O
v	pointer
->	O
sum	char
!=	O
sum_shortname	function
(	O
&	O
dn	pointer
)	O
)	O
return	O
;	O
if	O
(	O
(	O
v	pointer
->	O
status	int
&	O
(	O
(	O
1	int
<<	O
v	pointer
->	O
subentries	int
)	O
-	O
1	int
)	O
)	O
!=	O
(	O
1	int
<<	O
v	pointer
->	O
subentries	int
)	O
-	O
1	int
)	O
return	O
;	O
v	pointer
->	O
name	pointer
[	O
VSE_NAMELEN	int
*	O
v	pointer
->	O
subentries	int
]	O
=	O
0	int
;	O
v	pointer
->	O
present	int
=	O
1	int
;	O
}	O
int	O
clear_vses	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
int	O
entrySlot	int
,	O
size_t	long
last	long
)	O
{	O
direntry_t	struct
entry	int
;	O
dirCache_t	struct
*	O
cache	pointer
;	O
int	O
error	pointer
;	O
entry	int
.	O
Dir	pointer
=	O
Dir	pointer
;	O
entry	int
.	O
entry	int
=	O
entrySlot	int
;	O
cache	pointer
=	O
allocDirCache	function
(	O
Dir	pointer
,	O
last	long
)	O
;	O
if	O
(	O
!	O
cache	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in clear_vses\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
addFreeEntry	function
(	O
cache	pointer
,	O
entry	int
.	O
entry	int
,	O
last	long
)	O
;	O
for	O
(	O
;	O
entry	int
.	O
entry	int
<	O
(	O
signed	O
int	O
)	O
last	long
;	O
++	O
entry	int
.	O
entry	int
)	O
{	O
dir_read	function
(	O
&	O
entry	int
,	O
&	O
error	pointer
)	O
;	O
if	O
(	O
error	pointer
)	O
return	O
error	pointer
;	O
if	O
(	O
!	O
entry	int
.	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
||	O
entry	int
.	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
DELMARK	O
)	O
break	O
;	O
entry	int
.	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
=	O
DELMARK	O
;	O
if	O
(	O
entry	int
.	O
dir	pointer
.	O
attr	char
==	O
0xf	int
)	O
entry	int
.	O
dir	pointer
.	O
attr	char
=	O
'\0'	O
;	O
low_level_dir_write	function
(	O
&	O
entry	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
write_vfat	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
dos_name_t	struct
*	O
shortname	pointer
,	O
char	O
*	O
longname	pointer
,	O
int	O
start	array
,	O
direntry_t	struct
*	O
mainEntry	pointer
)	O
{	O
struct	O
vfat_subentry	struct
*	O
vse	pointer
;	O
int	O
vse_id	int
,	O
num_vses	int
;	O
wchar_t	int
*	O
c	pointer
;	O
direntry_t	struct
entry	int
;	O
dirCache_t	struct
*	O
cache	pointer
;	O
wchar_t	int
unixyName	array
[	O
13	int
]	O
;	O
doscp_t	struct
*	O
cp	pointer
=	O
GET_DOSCONVERT	O
(	O
Dir	pointer
)	O
;	O
wchar_t	int
wlongname	array
[	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
int	O
wlen	int
;	O
if	O
(	O
longname	pointer
)	O
{	O
entry	int
.	O
Dir	pointer
=	O
Dir	pointer
;	O
vse	pointer
=	O
(	O
struct	O
vfat_subentry	struct
*	O
)	O
&	O
entry	int
.	O
dir	pointer
;	O
vse	pointer
->	O
attribute	char
=	O
0x0f	int
;	O
vse	pointer
->	O
hash1	char
=	O
vse	pointer
->	O
sector_l	char
=	O
vse	pointer
->	O
sector_u	char
=	O
0	int
;	O
vse	pointer
->	O
sum	char
=	O
sum_shortname	function
(	O
shortname	pointer
)	O
;	O
wlen	int
=	O
native_to_wchar	function
(	O
longname	pointer
,	O
wlongname	array
,	O
MAX_VNAMELEN	O
+	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
num_vses	int
=	O
(	O
wlen	int
+	O
VSE_NAMELEN	int
-	O
1	int
)	O
/	O
VSE_NAMELEN	int
;	O
for	O
(	O
vse_id	int
=	O
num_vses	int
;	O
vse_id	int
;	O
--	O
vse_id	int
)	O
{	O
int	O
end	pointer
=	O
0	int
;	O
c	pointer
=	O
wlongname	array
+	O
(	O
vse_id	int
-	O
1	int
)	O
*	O
VSE_NAMELEN	int
;	O
c	pointer
+=	O
unicode_write	function
(	O
c	pointer
,	O
vse	pointer
->	O
text1	array
,	O
VSE1SIZE	int
,	O
&	O
end	pointer
)	O
;	O
c	pointer
+=	O
unicode_write	function
(	O
c	pointer
,	O
vse	pointer
->	O
text2	array
,	O
VSE2SIZE	int
,	O
&	O
end	pointer
)	O
;	O
c	pointer
+=	O
unicode_write	function
(	O
c	pointer
,	O
vse	pointer
->	O
text3	array
,	O
VSE3SIZE	int
,	O
&	O
end	pointer
)	O
;	O
vse	pointer
->	O
id	char
=	O
(	O
vse_id	int
==	O
num_vses	int
)	O
?	O
(	O
vse_id	int
|	O
VSE_LAST	int
)	O
:	O
vse_id	int
;	O
entry	int
.	O
entry	int
=	O
start	array
+	O
num_vses	int
-	O
vse_id	int
;	O
low_level_dir_write	function
(	O
&	O
entry	int
)	O
;	O
}	O
}	O
else	O
{	O
num_vses	int
=	O
0	int
;	O
wlongname	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
cache	pointer
=	O
allocDirCache	function
(	O
Dir	pointer
,	O
start	array
+	O
num_vses	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
unix_name	function
(	O
cp	pointer
,	O
shortname	pointer
->	O
base	int
,	O
shortname	pointer
->	O
ext	array
,	O
0	int
,	O
unixyName	array
)	O
;	O
addUsedEntry	function
(	O
cache	pointer
,	O
start	array
,	O
start	array
+	O
num_vses	int
+	O
1	int
,	O
wlongname	array
,	O
unixyName	array
,	O
&	O
mainEntry	pointer
->	O
dir	pointer
)	O
;	O
low_level_dir_write	function
(	O
mainEntry	pointer
)	O
;	O
return	O
start	array
+	O
num_vses	int
;	O
}	O
void	O
dir_write	function
(	O
direntry_t	struct
*	O
entry	int
)	O
{	O
dirCacheEntry_t	struct
*	O
dce	pointer
;	O
dirCache_t	struct
*	O
cache	pointer
;	O
if	O
(	O
entry	int
->	O
entry	int
==	O
-	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Attempt to write root directory pointer\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
cache	pointer
=	O
allocDirCache	function
(	O
entry	int
->	O
Dir	pointer
,	O
entry	int
->	O
entry	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in dir_write\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dce	pointer
=	O
cache	pointer
->	O
entries	pointer
[	O
entry	int
->	O
entry	int
]	O
;	O
if	O
(	O
dce	pointer
)	O
{	O
if	O
(	O
entry	int
->	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
DELMARK	O
)	O
{	O
addFreeEntry	function
(	O
cache	pointer
,	O
dce	pointer
->	O
beginSlot	int
,	O
dce	pointer
->	O
endSlot	int
)	O
;	O
}	O
else	O
{	O
dce	pointer
->	O
dir	pointer
=	O
entry	int
->	O
dir	pointer
;	O
}	O
}	O
low_level_dir_write	function
(	O
entry	int
)	O
;	O
}	O
static	O
__inline__	O
void	O
parse_vses	function
(	O
direntry_t	struct
*	O
entry	int
,	O
struct	O
vfat_state	struct
*	O
v	pointer
)	O
{	O
struct	O
vfat_subentry	struct
*	O
vse	pointer
;	O
unsigned	O
char	O
id	char
,	O
last_flag	char
;	O
wchar_t	int
*	O
c	pointer
;	O
vse	pointer
=	O
(	O
struct	O
vfat_subentry	struct
*	O
)	O
&	O
entry	int
->	O
dir	pointer
;	O
id	char
=	O
vse	pointer
->	O
id	char
&	O
VSE_MASK	int
;	O
last_flag	char
=	O
(	O
vse	pointer
->	O
id	char
&	O
VSE_LAST	int
)	O
;	O
if	O
(	O
id	char
>	O
MAX_VFAT_SUBENTRIES	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"parse_vses: invalid VSE ID %d at %d.\n"	pointer
,	O
id	char
,	O
entry	int
->	O
entry	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
v	pointer
->	O
sum	char
!=	O
vse	pointer
->	O
sum	char
)	O
{	O
clear_vfat	function
(	O
v	pointer
)	O
;	O
v	pointer
->	O
sum	char
=	O
vse	pointer
->	O
sum	char
;	O
}	O
v	pointer
->	O
status	int
|=	O
1	int
<<	O
(	O
id	char
-	O
1	int
)	O
;	O
if	O
(	O
last_flag	char
)	O
v	pointer
->	O
subentries	int
=	O
id	char
;	O
c	pointer
=	O
&	O
(	O
v	pointer
->	O
name	pointer
[	O
VSE_NAMELEN	int
*	O
(	O
id	char
-	O
1	int
)	O
]	O
)	O
;	O
c	pointer
+=	O
unicode_read	function
(	O
vse	pointer
->	O
text1	array
,	O
c	pointer
,	O
VSE1SIZE	int
)	O
;	O
c	pointer
+=	O
unicode_read	function
(	O
vse	pointer
->	O
text2	array
,	O
c	pointer
,	O
VSE2SIZE	int
)	O
;	O
c	pointer
+=	O
unicode_read	function
(	O
vse	pointer
->	O
text3	array
,	O
c	pointer
,	O
VSE3SIZE	int
)	O
;	O
if	O
(	O
last_flag	char
)	O
*	O
c	pointer
=	O
'\0'	O
;	O
}	O
static	O
dirCacheEntry_t	struct
*	O
vfat_lookup_loop_common	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
direntry_t	struct
*	O
direntry	pointer
,	O
dirCache_t	struct
*	O
cache	pointer
,	O
int	O
lookForFreeSpace	int
,	O
int	O
*	O
io_error	pointer
)	O
{	O
wchar_t	int
newfile	array
[	O
13	int
]	O
;	O
int	O
initpos	int
=	O
direntry	pointer
->	O
entry	int
+	O
1	int
;	O
struct	O
vfat_state	struct
vfat	struct
;	O
wchar_t	int
*	O
longname	pointer
;	O
int	O
error	pointer
;	O
int	O
endmarkSeen	int
=	O
0	int
;	O
*	O
io_error	pointer
=	O
0	int
;	O
clear_vfat	function
(	O
&	O
vfat	struct
)	O
;	O
while	O
(	O
1	int
)	O
{	O
++	O
direntry	pointer
->	O
entry	int
;	O
if	O
(	O
!	O
dir_read	function
(	O
direntry	pointer
,	O
&	O
error	pointer
)	O
)	O
{	O
if	O
(	O
error	pointer
)	O
{	O
*	O
io_error	pointer
=	O
error	pointer
;	O
return	O
NULL	O
;	O
}	O
addFreeEndEntry	function
(	O
cache	pointer
,	O
initpos	int
,	O
direntry	pointer
->	O
entry	int
,	O
endmarkSeen	int
)	O
;	O
return	O
addEndEntry	function
(	O
cache	pointer
,	O
direntry	pointer
->	O
entry	int
)	O
;	O
}	O
if	O
(	O
endmarkSeen	int
||	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
ENDMARK	O
)	O
{	O
if	O
(	O
lookForFreeSpace	int
)	O
{	O
endmarkSeen	int
=	O
1	int
;	O
continue	O
;	O
}	O
return	O
addEndEntry	function
(	O
cache	pointer
,	O
direntry	pointer
->	O
entry	int
)	O
;	O
}	O
if	O
(	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
!=	O
DELMARK	O
&&	O
direntry	pointer
->	O
dir	pointer
.	O
attr	char
==	O
0x0f	int
)	O
parse_vses	function
(	O
direntry	pointer
,	O
&	O
vfat	struct
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
DELMARK	O
)	O
{	O
return	O
addFreeEntry	function
(	O
cache	pointer
,	O
initpos	int
,	O
direntry	pointer
->	O
entry	int
+	O
1	int
)	O
;	O
}	O
check_vfat	function
(	O
&	O
vfat	struct
,	O
&	O
direntry	pointer
->	O
dir	pointer
)	O
;	O
if	O
(	O
!	O
vfat	struct
.	O
present	int
)	O
vfat	struct
.	O
subentries	int
=	O
0	int
;	O
addFreeEntry	function
(	O
cache	pointer
,	O
initpos	int
,	O
direntry	pointer
->	O
entry	int
-	O
vfat	struct
.	O
subentries	int
)	O
;	O
if	O
(	O
direntry	pointer
->	O
dir	pointer
.	O
attr	char
&	O
0x8	int
)	O
{	O
wchar_t	int
*	O
ptr	pointer
=	O
newfile	array
;	O
if	O
(	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
'\x05'	O
)	O
{	O
ptr	pointer
+=	O
dos_to_wchar	function
(	O
cp	pointer
,	O
"\xE5"	pointer
,	O
ptr	pointer
,	O
1	int
)	O
;	O
ptr	pointer
+=	O
dos_to_wchar	function
(	O
cp	pointer
,	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
+	O
1	int
,	O
ptr	pointer
,	O
7	int
)	O
;	O
}	O
else	O
{	O
ptr	pointer
+=	O
dos_to_wchar	function
(	O
cp	pointer
,	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
,	O
ptr	pointer
,	O
8	int
)	O
;	O
}	O
ptr	pointer
+=	O
dos_to_wchar	function
(	O
cp	pointer
,	O
direntry	pointer
->	O
dir	pointer
.	O
ext	array
,	O
ptr	pointer
,	O
3	int
)	O
;	O
*	O
ptr	pointer
=	O
'\0'	O
;	O
}	O
else	O
unix_name	function
(	O
cp	pointer
,	O
direntry	pointer
->	O
dir	pointer
.	O
name	pointer
,	O
direntry	pointer
->	O
dir	pointer
.	O
ext	array
,	O
direntry	pointer
->	O
dir	pointer
.	O
Case	char
,	O
newfile	array
)	O
;	O
if	O
(	O
vfat	struct
.	O
present	int
)	O
longname	pointer
=	O
vfat	struct
.	O
name	pointer
;	O
else	O
longname	pointer
=	O
0	int
;	O
return	O
addUsedEntry	function
(	O
cache	pointer
,	O
direntry	pointer
->	O
entry	int
-	O
vfat	struct
.	O
subentries	int
,	O
direntry	pointer
->	O
entry	int
+	O
1	int
,	O
longname	pointer
,	O
newfile	array
,	O
&	O
direntry	pointer
->	O
dir	pointer
)	O
;	O
}	O
static	O
__inline__	O
dirCacheEntry_t	struct
*	O
vfat_lookup_loop_for_read	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
direntry_t	struct
*	O
direntry	pointer
,	O
dirCache_t	struct
*	O
cache	pointer
,	O
int	O
*	O
io_error	pointer
)	O
{	O
int	O
initpos	int
=	O
direntry	pointer
->	O
entry	int
+	O
1	int
;	O
dirCacheEntry_t	struct
*	O
dce	pointer
;	O
*	O
io_error	pointer
=	O
0	int
;	O
dce	pointer
=	O
cache	pointer
->	O
entries	pointer
[	O
initpos	int
]	O
;	O
if	O
(	O
dce	pointer
)	O
{	O
direntry	pointer
->	O
entry	int
=	O
dce	pointer
->	O
endSlot	int
-	O
1	int
;	O
return	O
dce	pointer
;	O
}	O
else	O
{	O
return	O
vfat_lookup_loop_common	function
(	O
cp	pointer
,	O
direntry	pointer
,	O
cache	pointer
,	O
0	int
,	O
io_error	pointer
)	O
;	O
}	O
}	O
typedef	O
enum	O
result_t	enum
{	O
RES_NOMATCH	int
,	O
RES_MATCH	int
,	O
RES_END	int
,	O
RES_ERROR	int
}	O
result_t	enum
;	O
static	O
result_t	enum
checkNameForMatch	function
(	O
struct	O
direntry_t	struct
*	O
direntry	pointer
,	O
dirCacheEntry_t	struct
*	O
dce	pointer
,	O
const	O
wchar_t	int
*	O
filename	pointer
,	O
int	O
length	int
,	O
int	O
flags	int
)	O
{	O
switch	O
(	O
dce	pointer
->	O
type	enum
)	O
{	O
case	O
DCET_FREE	int
:	O
return	O
RES_NOMATCH	int
;	O
case	O
DCET_END	int
:	O
return	O
RES_END	int
;	O
case	O
DCET_USED	int
:	O
break	O
;	O
}	O
direntry	pointer
->	O
dir	pointer
=	O
dce	pointer
->	O
dir	pointer
;	O
if	O
(	O
(	O
direntry	pointer
->	O
dir	pointer
.	O
attr	char
&	O
0x8	int
)	O
&&	O
!	O
(	O
flags	int
&	O
ACCEPT_LABEL	int
)	O
)	O
return	O
RES_NOMATCH	int
;	O
if	O
(	O
!	O
(	O
(	O
flags	int
&	O
MATCH_ANY	int
)	O
||	O
(	O
dce	pointer
->	O
longName	pointer
&&	O
match	function
(	O
dce	pointer
->	O
longName	pointer
,	O
filename	pointer
,	O
direntry	pointer
->	O
name	pointer
,	O
0	int
,	O
length	int
)	O
)	O
||	O
match	function
(	O
dce	pointer
->	O
shortName	pointer
,	O
filename	pointer
,	O
direntry	pointer
->	O
name	pointer
,	O
1	int
,	O
length	int
)	O
)	O
)	O
{	O
return	O
RES_NOMATCH	int
;	O
}	O
if	O
(	O
IS_DIR	O
(	O
direntry	pointer
)	O
&&	O
!	O
(	O
flags	int
&	O
ACCEPT_DIR	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
(	O
ACCEPT_LABEL	int
|	O
MATCH_ANY	int
|	O
NO_MSG	int
)	O
)	O
)	O
{	O
char	O
tmp	char
[	O
4	int
*	O
13	int
+	O
1	int
]	O
;	O
WCHAR_TO_NATIVE	O
(	O
dce	pointer
->	O
shortName	pointer
,	O
tmp	char
,	O
13	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Skipping \"%s\", is a directory\n"	pointer
,	O
tmp	char
)	O
;	O
}	O
return	O
RES_NOMATCH	int
;	O
}	O
if	O
(	O
!	O
(	O
direntry	pointer
->	O
dir	pointer
.	O
attr	char
&	O
(	O
ATTR_LABEL	int
|	O
ATTR_DIR	int
)	O
)	O
&&	O
!	O
(	O
flags	int
&	O
ACCEPT_PLAIN	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
(	O
ACCEPT_LABEL	int
|	O
MATCH_ANY	int
|	O
NO_MSG	int
)	O
)	O
)	O
{	O
char	O
tmp	char
[	O
4	int
*	O
13	int
+	O
1	int
]	O
;	O
WCHAR_TO_NATIVE	O
(	O
dce	pointer
->	O
shortName	pointer
,	O
tmp	char
,	O
13	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Skipping \"%s\", is not a directory\n"	pointer
,	O
tmp	char
)	O
;	O
}	O
return	O
RES_NOMATCH	int
;	O
}	O
return	O
RES_MATCH	int
;	O
}	O
int	O
vfat_lookup	function
(	O
direntry_t	struct
*	O
direntry	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
length	int
,	O
int	O
flags	int
,	O
char	O
*	O
shortname	pointer
,	O
size_t	long
shortname_size	long
,	O
char	O
*	O
longname	pointer
,	O
size_t	long
longname_size	long
)	O
{	O
dirCacheEntry_t	struct
*	O
dce	pointer
;	O
result_t	enum
result	enum
;	O
dirCache_t	struct
*	O
cache	pointer
;	O
int	O
io_error	pointer
;	O
wchar_t	int
wfilename	array
[	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
doscp_t	struct
*	O
cp	pointer
=	O
GET_DOSCONVERT	O
(	O
direntry	pointer
->	O
Dir	pointer
)	O
;	O
if	O
(	O
length	int
==	O
-	O
1	int
&&	O
filename	pointer
)	O
length	int
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
)	O
length	int
=	O
native_to_wchar	function
(	O
filename	pointer
,	O
wfilename	array
,	O
MAX_VNAMELEN	O
,	O
filename	pointer
+	O
length	int
,	O
0	int
)	O
;	O
else	O
length	int
=	O
0	int
;	O
if	O
(	O
direntry	pointer
->	O
entry	int
==	O
-	O
2	int
)	O
return	O
-	O
1	int
;	O
cache	pointer
=	O
allocDirCache	function
(	O
direntry	pointer
->	O
Dir	pointer
,	O
direntry	pointer
->	O
entry	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in vfat_lookup [0]\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
do	O
{	O
dce	pointer
=	O
vfat_lookup_loop_for_read	function
(	O
cp	pointer
,	O
direntry	pointer
,	O
cache	pointer
,	O
&	O
io_error	pointer
)	O
;	O
if	O
(	O
!	O
dce	pointer
)	O
{	O
if	O
(	O
io_error	pointer
)	O
return	O
-	O
2	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in vfat_lookup\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
result	enum
=	O
checkNameForMatch	function
(	O
direntry	pointer
,	O
dce	pointer
,	O
wfilename	array
,	O
length	int
,	O
flags	int
)	O
;	O
}	O
while	O
(	O
result	enum
==	O
RES_NOMATCH	int
)	O
;	O
if	O
(	O
result	enum
==	O
RES_MATCH	int
)	O
{	O
if	O
(	O
longname	pointer
)	O
{	O
if	O
(	O
dce	pointer
->	O
longName	pointer
)	O
wchar_to_native	function
(	O
dce	pointer
->	O
longName	pointer
,	O
longname	pointer
,	O
MAX_VNAMELEN	O
,	O
longname_size	long
)	O
;	O
else	O
*	O
longname	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
shortname	pointer
)	O
wchar_to_native	function
(	O
dce	pointer
->	O
shortName	pointer
,	O
shortname	pointer
,	O
12	int
,	O
shortname_size	long
)	O
;	O
direntry	pointer
->	O
beginSlot	int
=	O
dce	pointer
->	O
beginSlot	int
;	O
direntry	pointer
->	O
endSlot	int
=	O
dce	pointer
->	O
endSlot	int
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
direntry	pointer
->	O
entry	int
=	O
-	O
2	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
static	O
__inline__	O
dirCacheEntry_t	struct
*	O
vfat_lookup_loop_for_insert	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
direntry_t	struct
*	O
direntry	pointer
,	O
int	O
initpos	int
,	O
dirCache_t	struct
*	O
cache	pointer
)	O
{	O
dirCacheEntry_t	struct
*	O
dce	pointer
;	O
int	O
io_error	pointer
;	O
dce	pointer
=	O
cache	pointer
->	O
entries	pointer
[	O
initpos	int
]	O
;	O
if	O
(	O
dce	pointer
&&	O
dce	pointer
->	O
type	enum
!=	O
DCET_END	int
)	O
{	O
return	O
dce	pointer
;	O
}	O
else	O
{	O
direntry	pointer
->	O
entry	int
=	O
initpos	int
-	O
1	int
;	O
dce	pointer
=	O
vfat_lookup_loop_common	function
(	O
cp	pointer
,	O
direntry	pointer
,	O
cache	pointer
,	O
1	int
,	O
&	O
io_error	pointer
)	O
;	O
if	O
(	O
!	O
dce	pointer
)	O
{	O
if	O
(	O
io_error	pointer
)	O
{	O
return	O
NULL	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in vfat_lookup_loop\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
cache	pointer
->	O
entries	pointer
[	O
initpos	int
]	O
;	O
}	O
}	O
static	O
void	O
accountFreeSlots	function
(	O
struct	O
scan_state	struct
*	O
ssp	pointer
,	O
dirCacheEntry_t	struct
*	O
dce	pointer
)	O
{	O
if	O
(	O
ssp	pointer
->	O
got_slots	int
)	O
return	O
;	O
if	O
(	O
ssp	pointer
->	O
free_end	int
!=	O
dce	pointer
->	O
beginSlot	int
)	O
{	O
ssp	pointer
->	O
free_start	int
=	O
dce	pointer
->	O
beginSlot	int
;	O
}	O
ssp	pointer
->	O
free_end	int
=	O
dce	pointer
->	O
endSlot	int
;	O
if	O
(	O
ssp	pointer
->	O
free_end	int
-	O
ssp	pointer
->	O
free_start	int
>=	O
ssp	pointer
->	O
size_needed	int
)	O
{	O
ssp	pointer
->	O
got_slots	int
=	O
1	int
;	O
ssp	pointer
->	O
slot	int
=	O
ssp	pointer
->	O
free_start	int
+	O
ssp	pointer
->	O
size_needed	int
-	O
1	int
;	O
}	O
}	O
static	O
void	O
clear_scan	function
(	O
wchar_t	int
*	O
longname	pointer
,	O
int	O
use_longname	int
,	O
struct	O
scan_state	struct
*	O
s	pointer
)	O
{	O
s	pointer
->	O
shortmatch	int
=	O
s	pointer
->	O
longmatch	int
=	O
s	pointer
->	O
slot	int
=	O
-	O
1	int
;	O
s	pointer
->	O
free_end	int
=	O
s	pointer
->	O
got_slots	int
=	O
s	pointer
->	O
free_start	int
=	O
0	int
;	O
if	O
(	O
use_longname	int
&	O
1	int
)	O
s	pointer
->	O
size_needed	int
=	O
1	int
+	O
(	O
wcslen	function
(	O
longname	pointer
)	O
+	O
VSE_NAMELEN	int
-	O
1	int
)	O
/	O
VSE_NAMELEN	int
;	O
else	O
s	pointer
->	O
size_needed	int
=	O
1	int
;	O
}	O
int	O
lookupForInsert	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
struct	O
direntry_t	struct
*	O
direntry	pointer
,	O
dos_name_t	struct
*	O
dosname	pointer
,	O
char	O
*	O
longname	pointer
,	O
struct	O
scan_state	struct
*	O
ssp	pointer
,	O
int	O
ignore_entry	int
,	O
int	O
source_entry	int
,	O
int	O
pessimisticShortRename	int
,	O
int	O
use_longname	int
)	O
{	O
direntry_t	struct
entry	int
;	O
int	O
ignore_match	int
;	O
dirCacheEntry_t	struct
*	O
dce	pointer
;	O
dirCache_t	struct
*	O
cache	pointer
;	O
int	O
pos	array
;	O
wchar_t	int
shortName	pointer
[	O
13	int
]	O
;	O
wchar_t	int
wlongname	array
[	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
doscp_t	struct
*	O
cp	pointer
=	O
GET_DOSCONVERT	O
(	O
Dir	pointer
)	O
;	O
native_to_wchar	function
(	O
longname	pointer
,	O
wlongname	array
,	O
MAX_VNAMELEN	O
+	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
clear_scan	function
(	O
wlongname	array
,	O
use_longname	int
,	O
ssp	pointer
)	O
;	O
ignore_match	int
=	O
(	O
ignore_entry	int
==	O
-	O
2	int
)	O
;	O
initializeDirentry	function
(	O
&	O
entry	int
,	O
Dir	pointer
)	O
;	O
ssp	pointer
->	O
match_free	int
=	O
0	int
;	O
cache	pointer
=	O
allocDirCache	function
(	O
Dir	pointer
,	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in lookupForInsert\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
ignore_match	int
)	O
unix_name	function
(	O
cp	pointer
,	O
dosname	pointer
->	O
base	int
,	O
dosname	pointer
->	O
ext	array
,	O
0	int
,	O
shortName	pointer
)	O
;	O
pos	array
=	O
cache	pointer
->	O
nrHashed	int
;	O
if	O
(	O
source_entry	int
>=	O
0	int
||	O
(	O
pos	array
&&	O
isHashed	function
(	O
cache	pointer
,	O
wlongname	array
)	O
)	O
)	O
{	O
pos	array
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pos	array
&&	O
!	O
ignore_match	int
&&	O
isHashed	function
(	O
cache	pointer
,	O
shortName	pointer
)	O
)	O
{	O
if	O
(	O
pessimisticShortRename	int
)	O
{	O
ssp	pointer
->	O
shortmatch	int
=	O
-	O
2	int
;	O
return	O
1	int
;	O
}	O
pos	array
=	O
0	int
;	O
}	O
else	O
if	O
(	O
growDirCache	function
(	O
cache	pointer
,	O
pos	array
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error in vfat_looup [0]\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
do	O
{	O
dce	pointer
=	O
vfat_lookup_loop_for_insert	function
(	O
cp	pointer
,	O
&	O
entry	int
,	O
pos	array
,	O
cache	pointer
)	O
;	O
switch	O
(	O
dce	pointer
->	O
type	enum
)	O
{	O
case	O
DCET_FREE	int
:	O
accountFreeSlots	function
(	O
ssp	pointer
,	O
dce	pointer
)	O
;	O
break	O
;	O
case	O
DCET_USED	int
:	O
if	O
(	O
!	O
(	O
dce	pointer
->	O
dir	pointer
.	O
attr	char
&	O
0x8	int
)	O
&&	O
(	O
signed	O
int	O
)	O
dce	pointer
->	O
endSlot	int
-	O
1	int
==	O
source_entry	int
)	O
accountFreeSlots	function
(	O
ssp	pointer
,	O
dce	pointer
)	O
;	O
if	O
(	O
(	O
dce	pointer
->	O
dir	pointer
.	O
attr	char
&	O
0x8	int
)	O
||	O
(	O
(	O
signed	O
int	O
)	O
dce	pointer
->	O
endSlot	int
-	O
1	int
==	O
ignore_entry	int
)	O
)	O
break	O
;	O
if	O
(	O
(	O
dce	pointer
->	O
longName	pointer
&&	O
!	O
wcscasecmp	function
(	O
dce	pointer
->	O
longName	pointer
,	O
wlongname	array
)	O
)	O
||	O
(	O
dce	pointer
->	O
shortName	pointer
&&	O
!	O
wcscasecmp	function
(	O
dce	pointer
->	O
shortName	pointer
,	O
wlongname	array
)	O
)	O
)	O
{	O
ssp	pointer
->	O
longmatch	int
=	O
dce	pointer
->	O
endSlot	int
-	O
1	int
;	O
direntry	pointer
->	O
beginSlot	int
=	O
dce	pointer
->	O
beginSlot	int
;	O
direntry	pointer
->	O
endSlot	int
=	O
dce	pointer
->	O
endSlot	int
-	O
1	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
ignore_match	int
&&	O
!	O
wcscasecmp	function
(	O
shortName	pointer
,	O
dce	pointer
->	O
shortName	pointer
)	O
)	O
ssp	pointer
->	O
shortmatch	int
=	O
dce	pointer
->	O
endSlot	int
-	O
1	int
;	O
break	O
;	O
case	O
DCET_END	int
:	O
break	O
;	O
}	O
pos	array
=	O
dce	pointer
->	O
endSlot	int
;	O
}	O
while	O
(	O
dce	pointer
->	O
type	enum
!=	O
DCET_END	int
)	O
;	O
if	O
(	O
ssp	pointer
->	O
shortmatch	int
>	O
-	O
1	int
)	O
return	O
1	int
;	O
ssp	pointer
->	O
max_entry	int
=	O
dce	pointer
->	O
beginSlot	int
;	O
if	O
(	O
ssp	pointer
->	O
got_slots	int
)	O
return	O
6	int
;	O
if	O
(	O
!	O
isRootDir	function
(	O
Dir	pointer
)	O
)	O
return	O
5	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"No directory slots\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
