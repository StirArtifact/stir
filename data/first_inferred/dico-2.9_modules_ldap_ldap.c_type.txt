struct	O
_dico_ldap_handle	struct
{	O
LDAP	O
*	O
ldap	pointer
;	O
const	O
char	O
*	O
url	pointer
;	O
char	O
*	O
base	pointer
;	O
char	O
*	O
binddn	pointer
;	O
char	O
*	O
passwd	pointer
;	O
int	O
tls	int
;	O
int	O
debug	int
;	O
char	O
*	O
user_filter	pointer
;	O
char	O
*	O
group_filter	pointer
;	O
}	O
;	O
void	O
free_ldap_handle	function
(	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
)	O
{	O
free	function
(	O
lp	pointer
->	O
base	pointer
)	O
;	O
free	function
(	O
lp	pointer
->	O
binddn	pointer
)	O
;	O
free	function
(	O
lp	pointer
->	O
passwd	pointer
)	O
;	O
free	function
(	O
lp	pointer
->	O
user_filter	pointer
)	O
;	O
free	function
(	O
lp	pointer
->	O
group_filter	pointer
)	O
;	O
free	function
(	O
lp	pointer
)	O
;	O
}	O
static	O
int	O
_dico_conn_setup	function
(	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
)	O
{	O
int	O
rc	int
;	O
LDAP	O
*	O
ld	O
=	O
NULL	O
;	O
int	O
protocol	int
=	O
LDAP_VERSION3	O
;	O
if	O
(	O
lp	pointer
->	O
debug	int
)	O
{	O
if	O
(	O
ber_set_option	function
(	O
NULL	O
,	O
LBER_OPT_DEBUG_LEVEL	O
,	O
&	O
lp	pointer
->	O
debug	int
)	O
!=	O
LBER_OPT_SUCCESS	O
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot set LBER_OPT_DEBUG_LEVEL %d"	pointer
)	O
,	O
lp	pointer
->	O
debug	int
)	O
;	O
if	O
(	O
ldap_set_option	function
(	O
NULL	O
,	O
LDAP_OPT_DEBUG_LEVEL	O
,	O
&	O
lp	pointer
->	O
debug	int
)	O
!=	O
LDAP_OPT_SUCCESS	O
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"could not set LDAP_OPT_DEBUG_LEVEL %d"	pointer
)	O
,	O
lp	pointer
->	O
debug	int
)	O
;	O
}	O
rc	int
=	O
ldap_initialize	function
(	O
&	O
ld	O
,	O
lp	pointer
->	O
url	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot create LDAP session handle for URI=%s (%d): %s"	pointer
)	O
,	O
lp	pointer
->	O
url	pointer
,	O
rc	int
,	O
ldap_err2string	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
lp	pointer
->	O
tls	int
)	O
{	O
rc	int
=	O
ldap_start_tls_s	function
(	O
ld	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"ldap_start_tls failed: %s"	pointer
)	O
,	O
ldap_err2string	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
ldap_set_option	function
(	O
ld	O
,	O
LDAP_OPT_PROTOCOL_VERSION	O
,	O
&	O
protocol	int
)	O
;	O
lp	pointer
->	O
ldap	pointer
=	O
ld	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dico_ldap_bind	function
(	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
)	O
{	O
int	O
msgid	pointer
,	O
err	int
,	O
rc	int
;	O
LDAPMessage	O
*	O
result	pointer
;	O
LDAPControl	O
*	O
*	O
ctrls	O
;	O
char	O
msgbuf	array
[	O
256	int
]	O
;	O
char	O
*	O
matched	pointer
=	O
NULL	O
;	O
char	O
*	O
info	pointer
=	O
NULL	O
;	O
char	O
*	O
*	O
refs	pointer
=	O
NULL	O
;	O
static	O
struct	O
berval	O
passwd	pointer
;	O
passwd	pointer
.	O
bv_val	O
=	O
lp	pointer
->	O
passwd	pointer
;	O
passwd	pointer
.	O
bv_len	O
=	O
passwd	pointer
.	O
bv_val	O
?	O
strlen	function
(	O
passwd	pointer
.	O
bv_val	O
)	O
:	O
0	int
;	O
msgbuf	array
[	O
0	int
]	O
=	O
0	int
;	O
rc	int
=	O
ldap_sasl_bind	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
lp	pointer
->	O
binddn	pointer
,	O
LDAP_SASL_SIMPLE	O
,	O
&	O
passwd	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
msgid	pointer
)	O
;	O
if	O
(	O
msgid	pointer
==	O
-	O
1	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_sasl_bind(SIMPLE) failed: %s"	pointer
,	O
ldap_err2string	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ldap_result	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
msgid	pointer
,	O
LDAP_MSG_ALL	O
,	O
NULL	O
,	O
&	O
result	pointer
)	O
==	O
-	O
1	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_result failed"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
ldap_parse_result	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
result	pointer
,	O
&	O
err	int
,	O
&	O
matched	pointer
,	O
&	O
info	pointer
,	O
&	O
refs	pointer
,	O
&	O
ctrls	O
,	O
1	int
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_parse_result failed: %s"	pointer
,	O
ldap_err2string	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ctrls	O
)	O
ldap_controls_free	function
(	O
ctrls	O
)	O
;	O
if	O
(	O
err	int
!=	O
LDAP_SUCCESS	O
||	O
msgbuf	array
[	O
0	int
]	O
||	O
(	O
matched	pointer
&&	O
matched	pointer
[	O
0	int
]	O
)	O
||	O
(	O
info	pointer
&&	O
info	pointer
[	O
0	int
]	O
)	O
||	O
refs	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_bind: %s (%d)%s"	pointer
,	O
ldap_err2string	function
(	O
err	int
)	O
,	O
err	int
,	O
msgbuf	array
)	O
;	O
if	O
(	O
matched	pointer
&&	O
*	O
matched	pointer
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"matched DN: %s"	pointer
,	O
matched	pointer
)	O
;	O
if	O
(	O
info	pointer
&&	O
*	O
info	pointer
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"additional info: %s"	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
refs	pointer
&&	O
*	O
refs	pointer
)	O
{	O
int	O
i	int
;	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"referrals:"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
refs	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"%s"	pointer
,	O
refs	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
matched	pointer
)	O
ber_memfree	function
(	O
matched	pointer
)	O
;	O
if	O
(	O
info	pointer
)	O
ber_memfree	function
(	O
info	pointer
)	O
;	O
if	O
(	O
refs	pointer
)	O
ber_memvfree	function
(	O
(	O
void	O
*	O
*	O
)	O
refs	pointer
)	O
;	O
return	O
err	int
!=	O
LDAP_SUCCESS	O
;	O
}	O
static	O
void	O
_dico_ldap_unbind	function
(	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
)	O
{	O
if	O
(	O
lp	pointer
->	O
ldap	pointer
)	O
{	O
ldap_set_option	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
LDAP_OPT_SERVER_CONTROLS	O
,	O
NULL	O
)	O
;	O
ldap_unbind_ext	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
int	O
db_open	function
(	O
void	O
*	O
*	O
phandle	pointer
,	O
dico_url_t	pointer
url	pointer
,	O
const	O
char	O
*	O
options	pointer
)	O
{	O
struct	O
_dico_ldap_handle	struct
hstr	struct
,	O
*	O
handle	pointer
;	O
int	O
rc	int
;	O
long	O
debug	int
=	O
0	int
;	O
struct	O
dico_option	struct
option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
base	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct
.	O
base	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
binddn	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct
.	O
binddn	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
passwd	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct
.	O
passwd	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
tls	int
)	O
,	O
dico_opt_bool	int
,	O
&	O
hstr	struct
.	O
tls	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
debug	int
)	O
,	O
dico_opt_long	int
,	O
&	O
debug	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
user	pointer
-	O
filter	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct
.	O
user_filter	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
group	O
-	O
filter	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct
.	O
group_filter	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
memset	function
(	O
&	O
hstr	struct
,	O
0	int
,	O
sizeof	O
(	O
hstr	struct
)	O
)	O
;	O
if	O
(	O
options	pointer
)	O
{	O
struct	O
wordsplit	struct
ws	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
options	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_DEFFLAGS	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot parse options `%s': %s"	pointer
)	O
,	O
options	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
dico_parseopt	function
(	O
option	array
,	O
ws	pointer
.	O
ws_wordc	long
,	O
ws	pointer
.	O
ws_wordv	pointer
,	O
DICO_PARSEOPT_PARSE_ARGV0	int
,	O
NULL	O
)	O
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
hstr	struct
.	O
debug	int
=	O
debug	int
;	O
}	O
hstr	struct
.	O
url	pointer
=	O
url	pointer
->	O
string	pointer
;	O
handle	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
handle	pointer
)	O
)	O
;	O
if	O
(	O
!	O
handle	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot allocate handle"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
handle	pointer
=	O
hstr	struct
;	O
rc	int
=	O
_dico_conn_setup	function
(	O
handle	pointer
)	O
||	O
_dico_ldap_bind	function
(	O
handle	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free_ldap_handle	function
(	O
handle	pointer
)	O
;	O
}	O
else	O
{	O
*	O
phandle	pointer
=	O
handle	pointer
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
db_close	function
(	O
void	O
*	O
handle	pointer
)	O
{	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
=	O
handle	pointer
;	O
_dico_ldap_unbind	function
(	O
lp	pointer
)	O
;	O
free_ldap_handle	function
(	O
lp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
_dico_ldap_expand_user	function
(	O
const	O
char	O
*	O
query	pointer
,	O
const	O
char	O
*	O
user	pointer
)	O
{	O
struct	O
wordsplit	struct
ws	pointer
;	O
const	O
char	O
*	O
env	array
[	O
3	int
]	O
;	O
char	O
*	O
res	pointer
;	O
env	array
[	O
0	int
]	O
=	O
"user"	pointer
;	O
env	array
[	O
1	int
]	O
=	O
user	pointer
;	O
env	array
[	O
2	int
]	O
=	O
NULL	O
;	O
ws	pointer
.	O
ws_env	pointer
=	O
env	array
;	O
if	O
(	O
wordsplit	struct
(	O
query	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_NOSPLIT	int
|	O
WRDSF_NOCMD	int
|	O
WRDSF_ENV	int
|	O
WRDSF_ENV_KV	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot expand query `%s': %s"	pointer
)	O
,	O
query	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
;	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
static	O
LDAPMessage	O
*	O
_dico_ldap_search	function
(	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
,	O
const	O
char	O
*	O
filter_pat	pointer
,	O
const	O
char	O
*	O
attr	pointer
,	O
const	O
char	O
*	O
user	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
filter	pointer
;	O
LDAPMessage	O
*	O
res	pointer
;	O
ber_int_t	O
msgid	pointer
;	O
char	O
*	O
attrs	array
[	O
2	int
]	O
;	O
attrs	array
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
attr	pointer
;	O
attrs	array
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
filter_pat	pointer
)	O
{	O
filter	pointer
=	O
_dico_ldap_expand_user	function
(	O
filter_pat	pointer
,	O
user	pointer
)	O
;	O
if	O
(	O
!	O
filter	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
filter	pointer
=	O
NULL	O
;	O
rc	int
=	O
ldap_search_ext	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
lp	pointer
->	O
base	pointer
,	O
LDAP_SCOPE_SUBTREE	O
,	O
filter	pointer
,	O
attrs	array
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
-	O
1	int
,	O
&	O
msgid	pointer
)	O
;	O
if	O
(	O
filter	pointer
)	O
free	function
(	O
filter	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_search_ext: %s"	pointer
,	O
ldap_err2string	function
(	O
rc	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
rc	int
=	O
ldap_result	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
msgid	pointer
,	O
LDAP_MSG_ALL	O
,	O
NULL	O
,	O
&	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_result failed"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
res	pointer
;	O
}	O
static	O
int	O
db_get_pass	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
qpw	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
char	O
*	O
*	O
ppass	pointer
)	O
{	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
=	O
handle	pointer
;	O
LDAPMessage	O
*	O
res	pointer
,	O
*	O
msg	O
;	O
int	O
rc	int
;	O
struct	O
berval	O
*	O
*	O
values	pointer
;	O
res	pointer
=	O
_dico_ldap_search	function
(	O
lp	pointer
,	O
lp	pointer
->	O
user_filter	pointer
,	O
qpw	pointer
,	O
key	pointer
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
1	int
;	O
rc	int
=	O
ldap_count_entries	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough entires"	pointer
)	O
;	O
ldap_msgfree	function
(	O
res	pointer
)	O
;	O
return	O
1	int
;	O
}	O
msg	O
=	O
ldap_first_entry	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
res	pointer
)	O
;	O
values	pointer
=	O
ldap_get_values_len	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
msg	O
,	O
qpw	pointer
)	O
;	O
if	O
(	O
ldap_count_values_len	function
(	O
values	pointer
)	O
==	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough entires"	pointer
)	O
;	O
ldap_msgfree	function
(	O
res	pointer
)	O
;	O
return	O
1	int
;	O
}	O
*	O
ppass	pointer
=	O
strdup	function
(	O
values	pointer
[	O
0	int
]	O
->	O
bv_val	O
)	O
;	O
rc	int
=	O
*	O
ppass	pointer
==	O
NULL	O
;	O
if	O
(	O
rc	int
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
ldap_value_free_len	function
(	O
values	pointer
)	O
;	O
ldap_msgfree	function
(	O
res	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_free_group	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
db_get_groups	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
qgr	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
dico_list_t	pointer
*	O
pgroups	pointer
)	O
{	O
struct	O
_dico_ldap_handle	struct
*	O
lp	pointer
=	O
handle	pointer
;	O
LDAPMessage	O
*	O
res	pointer
,	O
*	O
msg	O
;	O
int	O
rc	int
;	O
dico_list_t	pointer
groups	pointer
=	O
NULL	O
;	O
res	pointer
=	O
_dico_ldap_search	function
(	O
lp	pointer
,	O
lp	pointer
->	O
group_filter	pointer
,	O
qgr	pointer
,	O
key	pointer
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
1	int
;	O
rc	int
=	O
ldap_count_entries	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dico_log	function
(	O
L_INFO	int
,	O
0	int
,	O
"no groups containing %s"	pointer
,	O
key	pointer
)	O
;	O
ldap_msgfree	function
(	O
res	pointer
)	O
;	O
*	O
pgroups	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
groups	pointer
=	O
dico_list_create	function
(	O
)	O
;	O
dico_list_set_free_item	function
(	O
groups	pointer
,	O
_free_group	function
,	O
NULL	O
)	O
;	O
*	O
pgroups	pointer
=	O
groups	pointer
;	O
rc	int
=	O
0	int
;	O
for	O
(	O
msg	O
=	O
ldap_first_entry	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
res	pointer
)	O
;	O
msg	O
;	O
msg	O
=	O
ldap_next_entry	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
msg	O
)	O
)	O
{	O
struct	O
berval	O
*	O
*	O
values	pointer
;	O
size_t	long
i	int
,	O
count	long
;	O
values	pointer
=	O
ldap_get_values_len	function
(	O
lp	pointer
->	O
ldap	pointer
,	O
msg	O
,	O
qgr	pointer
)	O
;	O
count	long
=	O
ldap_count_values_len	function
(	O
values	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
s	pointer
=	O
strdup	function
(	O
values	pointer
[	O
i	int
]	O
->	O
bv_val	O
)	O
;	O
dico_list_append	function
(	O
groups	pointer
,	O
s	pointer
)	O
;	O
}	O
ldap_value_free_len	function
(	O
values	pointer
)	O
;	O
}	O
ldap_msgfree	function
(	O
res	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
struct	O
dico_udb_def	struct
ldap_udb_def	struct
=	O
{	O
"ldap"	pointer
,	O
db_open	function
,	O
db_close	function
,	O
db_get_pass	function
,	O
db_get_groups	function
}	O
;	O
static	O
int	O
dico_ldap_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
return	O
dico_udb_define	function
(	O
&	O
ldap_udb_def	struct
)	O
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
ldap	pointer
,	O
module	O
)	O
=	O
{	O
DICO_MODULE_VERSION	int
,	O
DICO_CAPA_NODB	int
,	O
dico_ldap_init	function
,	O
}	O
;	O
