static	O
void	O
*	O
call_chunkfun	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
h	pointer
->	O
use_extra_arg	int
)	O
return	O
h	pointer
->	O
chunkfun	union
.	O
extra	pointer
(	O
h	pointer
->	O
extra_arg	pointer
,	O
size	long
)	O
;	O
else	O
return	O
h	pointer
->	O
chunkfun	union
.	O
plain	pointer
(	O
size	long
)	O
;	O
}	O
static	O
void	O
call_freefun	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
void	O
*	O
old_chunk	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
use_extra_arg	int
)	O
h	pointer
->	O
freefun	union
.	O
extra	pointer
(	O
h	pointer
->	O
extra_arg	pointer
,	O
old_chunk	pointer
)	O
;	O
else	O
h	pointer
->	O
freefun	union
.	O
plain	pointer
(	O
old_chunk	pointer
)	O
;	O
}	O
static	O
int	O
_obstack_begin_worker	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
size	long
,	O
_OBSTACK_SIZE_T	O
alignment	long
)	O
{	O
struct	O
_obstack_chunk	struct
*	O
chunk	pointer
;	O
if	O
(	O
alignment	long
==	O
0	int
)	O
alignment	long
=	O
DEFAULT_ALIGNMENT	O
;	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
int	O
extra	pointer
=	O
(	O
(	O
(	O
(	O
12	int
+	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
&	O
~	O
(	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
)	O
+	O
4	int
+	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
&	O
~	O
(	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
)	O
;	O
size	long
=	O
4096	int
-	O
extra	pointer
;	O
}	O
h	pointer
->	O
chunk_size	long
=	O
size	long
;	O
h	pointer
->	O
alignment_mask	long
=	O
alignment	long
-	O
1	int
;	O
chunk	pointer
=	O
h	pointer
->	O
chunk	pointer
=	O
call_chunkfun	function
(	O
h	pointer
,	O
h	pointer
->	O
chunk_size	long
)	O
;	O
if	O
(	O
!	O
chunk	pointer
)	O
(	O
*	O
obstack_alloc_failed_handler	pointer
)	O
(	O
)	O
;	O
h	pointer
->	O
next_free	pointer
=	O
h	pointer
->	O
object_base	pointer
=	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
chunk	pointer
,	O
chunk	pointer
->	O
contents	array
,	O
alignment	long
-	O
1	int
)	O
;	O
h	pointer
->	O
chunk_limit	pointer
=	O
chunk	pointer
->	O
limit	pointer
=	O
(	O
char	O
*	O
)	O
chunk	pointer
+	O
h	pointer
->	O
chunk_size	long
;	O
chunk	pointer
->	O
prev	pointer
=	O
0	int
;	O
h	pointer
->	O
maybe_empty_object	int
=	O
0	int
;	O
h	pointer
->	O
alloc_failed	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
_obstack_begin	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
size	long
,	O
_OBSTACK_SIZE_T	O
alignment	long
,	O
void	O
*	O
(	O
*	O
chunkfun	union
)	O
(	O
size_t	long
)	O
,	O
void	O
(	O
*	O
freefun	union
)	O
(	O
void	O
*	O
)	O
)	O
{	O
h	pointer
->	O
chunkfun	union
.	O
plain	pointer
=	O
chunkfun	union
;	O
h	pointer
->	O
freefun	union
.	O
plain	pointer
=	O
freefun	union
;	O
h	pointer
->	O
use_extra_arg	int
=	O
0	int
;	O
return	O
_obstack_begin_worker	function
(	O
h	pointer
,	O
size	long
,	O
alignment	long
)	O
;	O
}	O
int	O
_obstack_begin_1	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
size	long
,	O
_OBSTACK_SIZE_T	O
alignment	long
,	O
void	O
*	O
(	O
*	O
chunkfun	union
)	O
(	O
void	O
*	O
,	O
size_t	long
)	O
,	O
void	O
(	O
*	O
freefun	union
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
arg	pointer
)	O
{	O
h	pointer
->	O
chunkfun	union
.	O
extra	pointer
=	O
chunkfun	union
;	O
h	pointer
->	O
freefun	union
.	O
extra	pointer
=	O
freefun	union
;	O
h	pointer
->	O
extra_arg	pointer
=	O
arg	pointer
;	O
h	pointer
->	O
use_extra_arg	int
=	O
1	int
;	O
return	O
_obstack_begin_worker	function
(	O
h	pointer
,	O
size	long
,	O
alignment	long
)	O
;	O
}	O
void	O
_obstack_newchunk	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
length	long
)	O
{	O
struct	O
_obstack_chunk	struct
*	O
old_chunk	pointer
=	O
h	pointer
->	O
chunk	pointer
;	O
struct	O
_obstack_chunk	struct
*	O
new_chunk	pointer
=	O
0	int
;	O
size_t	long
obj_size	long
=	O
h	pointer
->	O
next_free	pointer
-	O
h	pointer
->	O
object_base	pointer
;	O
char	O
*	O
object_base	pointer
;	O
size_t	long
sum1	long
=	O
obj_size	long
+	O
length	long
;	O
size_t	long
sum2	long
=	O
sum1	long
+	O
h	pointer
->	O
alignment_mask	long
;	O
size_t	long
new_size	long
=	O
sum2	long
+	O
(	O
obj_size	long
>>	O
3	int
)	O
+	O
100	int
;	O
if	O
(	O
new_size	long
<	O
sum2	long
)	O
new_size	long
=	O
sum2	long
;	O
if	O
(	O
new_size	long
<	O
h	pointer
->	O
chunk_size	long
)	O
new_size	long
=	O
h	pointer
->	O
chunk_size	long
;	O
if	O
(	O
obj_size	long
<=	O
sum1	long
&&	O
sum1	long
<=	O
sum2	long
)	O
new_chunk	pointer
=	O
call_chunkfun	function
(	O
h	pointer
,	O
new_size	long
)	O
;	O
if	O
(	O
!	O
new_chunk	pointer
)	O
(	O
*	O
obstack_alloc_failed_handler	pointer
)	O
(	O
)	O
;	O
h	pointer
->	O
chunk	pointer
=	O
new_chunk	pointer
;	O
new_chunk	pointer
->	O
prev	pointer
=	O
old_chunk	pointer
;	O
new_chunk	pointer
->	O
limit	pointer
=	O
h	pointer
->	O
chunk_limit	pointer
=	O
(	O
char	O
*	O
)	O
new_chunk	pointer
+	O
new_size	long
;	O
object_base	pointer
=	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
new_chunk	pointer
,	O
new_chunk	pointer
->	O
contents	array
,	O
h	pointer
->	O
alignment_mask	long
)	O
;	O
memcpy	function
(	O
object_base	pointer
,	O
h	pointer
->	O
object_base	pointer
,	O
obj_size	long
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
maybe_empty_object	int
&&	O
(	O
h	pointer
->	O
object_base	pointer
==	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
old_chunk	pointer
,	O
old_chunk	pointer
->	O
contents	array
,	O
h	pointer
->	O
alignment_mask	long
)	O
)	O
)	O
{	O
new_chunk	pointer
->	O
prev	pointer
=	O
old_chunk	pointer
->	O
prev	pointer
;	O
call_freefun	function
(	O
h	pointer
,	O
old_chunk	pointer
)	O
;	O
}	O
h	pointer
->	O
object_base	pointer
=	O
object_base	pointer
;	O
h	pointer
->	O
next_free	pointer
=	O
h	pointer
->	O
object_base	pointer
+	O
obj_size	long
;	O
h	pointer
->	O
maybe_empty_object	int
=	O
0	int
;	O
}	O
int	O
_obstack_allocated_p	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
void	O
*	O
obj	pointer
)	O
__attribute_pure__	O
;	O
int	O
_obstack_allocated_p	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
void	O
*	O
obj	pointer
)	O
{	O
struct	O
_obstack_chunk	struct
*	O
lp	pointer
;	O
struct	O
_obstack_chunk	struct
*	O
plp	pointer
;	O
lp	pointer
=	O
(	O
h	pointer
)	O
->	O
chunk	pointer
;	O
while	O
(	O
lp	pointer
!=	O
0	int
&&	O
(	O
(	O
void	O
*	O
)	O
lp	pointer
>=	O
obj	pointer
||	O
(	O
void	O
*	O
)	O
(	O
lp	pointer
)	O
->	O
limit	pointer
<	O
obj	pointer
)	O
)	O
{	O
plp	pointer
=	O
lp	pointer
->	O
prev	pointer
;	O
lp	pointer
=	O
plp	pointer
;	O
}	O
return	O
lp	pointer
!=	O
0	int
;	O
}	O
void	O
_obstack_free	function
(	O
struct	O
obstack	struct
*	O
h	pointer
,	O
void	O
*	O
obj	pointer
)	O
{	O
struct	O
_obstack_chunk	struct
*	O
lp	pointer
;	O
struct	O
_obstack_chunk	struct
*	O
plp	pointer
;	O
lp	pointer
=	O
h	pointer
->	O
chunk	pointer
;	O
while	O
(	O
lp	pointer
!=	O
0	int
&&	O
(	O
(	O
void	O
*	O
)	O
lp	pointer
>=	O
obj	pointer
||	O
(	O
void	O
*	O
)	O
(	O
lp	pointer
)	O
->	O
limit	pointer
<	O
obj	pointer
)	O
)	O
{	O
plp	pointer
=	O
lp	pointer
->	O
prev	pointer
;	O
call_freefun	function
(	O
h	pointer
,	O
lp	pointer
)	O
;	O
lp	pointer
=	O
plp	pointer
;	O
h	pointer
->	O
maybe_empty_object	int
=	O
1	int
;	O
}	O
if	O
(	O
lp	pointer
)	O
{	O
h	pointer
->	O
object_base	pointer
=	O
h	pointer
->	O
next_free	pointer
=	O
(	O
char	O
*	O
)	O
(	O
obj	pointer
)	O
;	O
h	pointer
->	O
chunk_limit	pointer
=	O
lp	pointer
->	O
limit	pointer
;	O
h	pointer
->	O
chunk	pointer
=	O
lp	pointer
;	O
}	O
else	O
if	O
(	O
obj	pointer
!=	O
0	int
)	O
abort	function
(	O
)	O
;	O
}	O
_OBSTACK_SIZE_T	O
_obstack_memory_used	function
(	O
struct	O
obstack	struct
*	O
h	pointer
)	O
{	O
struct	O
_obstack_chunk	struct
*	O
lp	pointer
;	O
_OBSTACK_SIZE_T	O
nbytes	long
=	O
0	int
;	O
for	O
(	O
lp	pointer
=	O
h	pointer
->	O
chunk	pointer
;	O
lp	pointer
!=	O
0	int
;	O
lp	pointer
=	O
lp	pointer
->	O
prev	pointer
)	O
{	O
nbytes	long
+=	O
lp	pointer
->	O
limit	pointer
-	O
(	O
char	O
*	O
)	O
lp	pointer
;	O
}	O
return	O
nbytes	long
;	O
}	O
static	O
_Noreturn	O
void	O
print_and_abort	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
exit	function
(	O
obstack_exit_failure	int
)	O
;	O
}	O
__attribute_noreturn__	O
void	O
(	O
*	O
obstack_alloc_failed_handler	pointer
)	O
(	O
void	O
)	O
=	O
print_and_abort	function
;	O
