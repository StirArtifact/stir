char	O
*	O
dirname	function
(	O
char	O
*	O
path	pointer
)	O
;	O
struct	O
summary	struct
{	O
struct	O
token	struct
*	O
*	O
sum_tokens	pointer
;	O
unsigned	O
char	O
const	O
*	O
sum_hits	pointer
;	O
struct	O
summary	struct
*	O
sum_parent	pointer
;	O
union	O
{	O
struct	O
summary	struct
*	O
u_kids	array
[	O
8	int
]	O
;	O
struct	O
member_file	struct
*	O
u_files	array
[	O
8	int
]	O
;	O
}	O
sum_u	union
;	O
unsigned	O
long	O
sum_tokens_size	long
;	O
unsigned	O
long	O
sum_hits_count	long
;	O
int	O
sum_free_index	int
;	O
int	O
sum_level	int
;	O
}	O
;	O
void	O
usage	function
(	O
void	O
)	O
;	O
static	O
void	O
help_me	function
(	O
void	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
int	O
ceil_log_8	function
(	O
unsigned	O
long	O
n	long
)	O
;	O
int	O
ceil_log_2	function
(	O
unsigned	O
long	O
n	long
)	O
;	O
void	O
assert_writeable	function
(	O
char	O
const	O
*	O
file_name	pointer
)	O
;	O
void	O
scan_files	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
;	O
void	O
scan_member_file	function
(	O
struct	O
member_file	struct
const	O
*	O
member	pointer
)	O
;	O
void	O
scan_member_file_1	function
(	O
get_token_func_t	pointer
get_token	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
FILE	struct
*	O
source_FILE	pointer
)	O
;	O
void	O
report_statistics	function
(	O
void	O
)	O
;	O
void	O
write_id_file	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
;	O
unsigned	O
long	O
token_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
unsigned	O
long	O
token_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
int	O
token_hash_cmp	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
;	O
int	O
token_qsort_cmp	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
;	O
void	O
bump_current_hits_signature	function
(	O
void	O
)	O
;	O
void	O
init_hits_signature	function
(	O
int	O
i	int
)	O
;	O
void	O
free_summary_tokens	function
(	O
void	O
)	O
;	O
void	O
summarize	function
(	O
void	O
)	O
;	O
void	O
init_summary	function
(	O
void	O
)	O
;	O
struct	O
summary	struct
*	O
make_sibling_summary	function
(	O
struct	O
summary	struct
*	O
summary	struct
)	O
;	O
int	O
count_vec_size	function
(	O
struct	O
summary	struct
*	O
summary	struct
,	O
unsigned	O
char	O
const	O
*	O
tail_hits	pointer
)	O
;	O
int	O
count_buf_size	function
(	O
struct	O
summary	struct
*	O
summary	struct
,	O
unsigned	O
char	O
const	O
*	O
tail_hits	pointer
)	O
;	O
void	O
assert_hits	function
(	O
struct	O
summary	struct
*	O
summary	struct
)	O
;	O
void	O
write_hits	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
summary	struct
*	O
summary	struct
,	O
unsigned	O
char	O
const	O
*	O
tail_hits	pointer
)	O
;	O
void	O
sign_token	function
(	O
struct	O
token	struct
*	O
token	struct
)	O
;	O
void	O
add_token_to_summary	function
(	O
struct	O
summary	struct
*	O
summary	struct
,	O
struct	O
token	struct
*	O
token	struct
)	O
;	O
struct	O
hash_table	struct
token_table	struct
;	O
unsigned	O
long	O
input_chars	long
;	O
unsigned	O
long	O
name_tokens	long
;	O
unsigned	O
long	O
number_tokens	long
;	O
unsigned	O
long	O
string_tokens	long
;	O
unsigned	O
long	O
literal_tokens	long
;	O
unsigned	O
long	O
comment_tokens	long
;	O
unsigned	O
long	O
occurrences	long
;	O
unsigned	O
long	O
hits_length	long
=	O
0	int
;	O
unsigned	O
long	O
tokens_length	long
=	O
0	int
;	O
unsigned	O
long	O
output_length	long
=	O
0	int
;	O
int	O
verbose_flag	int
=	O
0	int
;	O
int	O
statistics_flag	int
=	O
0	int
;	O
int	O
file_name_count	int
=	O
0	int
;	O
int	O
levels	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
current_hits_signature	pointer
;	O
struct	O
summary	struct
*	O
summary_root	pointer
;	O
struct	O
summary	struct
*	O
summary_leaf	pointer
;	O
char	O
const	O
*	O
program_name	pointer
;	O
char	O
*	O
lang_map_file_name	pointer
=	O
0	int
;	O
int	O
show_version	int
=	O
0	int
;	O
int	O
show_help	int
=	O
0	int
;	O
struct	O
idhead	struct
idh	struct
;	O
struct	O
file_link	struct
*	O
cw_dlink	pointer
;	O
void	O
usage	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"file"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"output"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"include"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"exclude"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"lang-option"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"lang-map"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"default-lang"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"prune"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"statistics"	pointer
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [FILE]...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Build an identifier database.\n  -o, --output=OUTFILE    file name of ID database output\n  -f, --file=OUTFILE      synonym for --output\n  -i, --include=LANGS     include languages in LANGS (default: \"C C++ asm\")\n  -x, --exclude=LANGS     exclude languages in LANGS\n  -l, --lang-option=L:OPT pass OPT as a default for language L (see below)\n  -m, --lang-map=MAPFILE  use MAPFILE to map file names onto source language\n  -d, --default-lang=LANG make LANG the default source language\n  -p, --prune=NAMES       exclude the named files and/or directories\n  -v, --verbose           report per file statistics\n  -s, --statistics        report statistics at end of run\n\n      --help              display this help and exit\n      --version           output version information and exit\n\nFILE may be a file name, or a directory name to recursively search.\nIf no FILE is given, the current directory is searched by default.\nNote that the `--include' and `--exclude' options are mutually-exclusive.\n\nThe following arguments apply to the language-specific scanners:\n"	pointer
)	O
)	O
;	O
language_help_me	function
(	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nReport bugs to "	pointer
PACKAGE_BUGREPORT	pointer
"\n\n"	pointer
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
*	O
heap_initial	pointer
;	O
void	O
*	O
heap_after_walk	pointer
;	O
void	O
*	O
heap_after_scan	pointer
;	O
static	O
void	O
*	O
get_process_heap	function
(	O
void	O
)	O
{	O
return	O
sbrk	function
(	O
0	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
heap_initial	pointer
=	O
get_process_heap	function
(	O
)	O
;	O
idh	struct
.	O
idh_file_name	pointer
=	O
DEFAULT_ID_FILE_NAME	pointer
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"o:f:i:x:l:m:d:p:vVs"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'o'	O
:	O
case	O
'f'	O
:	O
idh	struct
.	O
idh_file_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'i'	O
:	O
include_languages	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
exclude_languages	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
language_save_arg	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
lang_map_file_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
set_default_language	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
cw_dlink	pointer
==	O
0	int
)	O
cw_dlink	pointer
=	O
init_walker	function
(	O
&	O
idh	struct
)	O
;	O
prune_file_names	function
(	O
optarg	pointer
,	O
cw_dlink	pointer
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
walker_verbose_flag	int
=	O
1	int
;	O
case	O
'v'	O
:	O
verbose_flag	int
=	O
1	int
;	O
case	O
's'	O
:	O
statistics_flag	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
show_version	int
)	O
{	O
printf	function
(	O
"%s - %s\n"	pointer
,	O
program_name	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
help_me	function
(	O
)	O
;	O
argc	int
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
static	O
char	O
dot	array
[	O
]	O
=	O
"."	pointer
;	O
static	O
char	O
*	O
dotp	pointer
=	O
dot	array
;	O
argc	int
=	O
1	int
;	O
argv	pointer
=	O
&	O
dotp	pointer
;	O
}	O
language_getopt	function
(	O
)	O
;	O
assert_writeable	function
(	O
idh	struct
.	O
idh_file_name	pointer
)	O
;	O
if	O
(	O
cw_dlink	pointer
==	O
0	int
)	O
cw_dlink	pointer
=	O
init_walker	function
(	O
&	O
idh	struct
)	O
;	O
parse_language_map	function
(	O
lang_map_file_name	pointer
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
struct	O
file_link	struct
*	O
flink	pointer
=	O
parse_file_name	function
(	O
*	O
argv	pointer
++	O
,	O
cw_dlink	pointer
)	O
;	O
if	O
(	O
flink	pointer
)	O
walk_flink	function
(	O
flink	pointer
,	O
0	int
)	O
;	O
}	O
heap_after_walk	pointer
=	O
get_process_heap	function
(	O
)	O
;	O
mark_member_file_links	function
(	O
&	O
idh	struct
)	O
;	O
log_8_member_files	int
=	O
ceil_log_8	function
(	O
idh	struct
.	O
idh_member_file_table	struct
.	O
ht_fill	long
)	O
;	O
if	O
(	O
log_8_member_files	int
==	O
0	int
)	O
log_8_member_files	int
=	O
1	int
;	O
current_hits_signature	pointer
=	O
xmalloc	function
(	O
log_8_member_files	int
)	O
;	O
if	O
(	O
idh	struct
.	O
idh_member_file_table	struct
.	O
ht_fill	long
)	O
{	O
scan_files	function
(	O
&	O
idh	struct
)	O
;	O
heap_after_scan	pointer
=	O
get_process_heap	function
(	O
)	O
;	O
free_summary_tokens	function
(	O
)	O
;	O
free	function
(	O
token_table	struct
.	O
ht_vec	pointer
)	O
;	O
chdir_to_link	function
(	O
cw_dlink	pointer
)	O
;	O
write_id_file	function
(	O
&	O
idh	struct
)	O
;	O
if	O
(	O
statistics_flag	int
)	O
report_statistics	function
(	O
)	O
;	O
}	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
"nothing to do"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
ceil_log_8	function
(	O
unsigned	O
long	O
n	long
)	O
{	O
int	O
log_8	int
=	O
0	int
;	O
n	long
--	O
;	O
while	O
(	O
n	long
)	O
{	O
log_8	int
++	O
;	O
n	long
>>=	O
3	int
;	O
}	O
return	O
log_8	int
;	O
}	O
int	O
ceil_log_2	function
(	O
unsigned	O
long	O
n	long
)	O
{	O
int	O
log_2	int
=	O
0	int
;	O
n	long
--	O
;	O
while	O
(	O
n	long
)	O
{	O
log_2	int
++	O
;	O
n	long
>>=	O
1	int
;	O
}	O
return	O
log_2	int
;	O
}	O
void	O
assert_writeable	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
access	function
(	O
filename	pointer
,	O
06	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
char	O
*	O
dirname	function
=	O
dir_name	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
access	function
(	O
dirname	function
,	O
06	int
)	O
<	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't create `%s' in `%s'"	pointer
)	O
,	O
base_name	function
(	O
filename	pointer
)	O
,	O
dirname	function
)	O
;	O
free	function
(	O
dirname	function
)	O
;	O
}	O
else	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't modify `%s'"	pointer
)	O
,	O
filename	pointer
)	O
;	O
}	O
}	O
void	O
scan_files	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
struct	O
member_file	struct
*	O
*	O
members_0	pointer
=	O
(	O
struct	O
member_file	struct
*	O
*	O
)	O
hash_dump	function
(	O
&	O
idhp	pointer
->	O
idh_member_file_table	struct
,	O
0	int
,	O
member_file_qsort_compare	function
)	O
;	O
struct	O
member_file	struct
*	O
*	O
end	pointer
=	O
&	O
members_0	pointer
[	O
idhp	pointer
->	O
idh_member_file_table	struct
.	O
ht_fill	long
]	O
;	O
struct	O
member_file	struct
*	O
*	O
members	pointer
=	O
members_0	pointer
;	O
int	O
n	long
=	O
idhp	pointer
->	O
idh_member_file_table	struct
.	O
ht_fill	long
;	O
n	long
=	O
n	long
*	O
ceil_log_2	function
(	O
n	long
)	O
*	O
16	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
n	long
=	O
1024	int
;	O
else	O
if	O
(	O
n	long
>	O
1024	int
*	O
1024	int
)	O
n	long
=	O
1024	int
*	O
1024	int
;	O
hash_init	function
(	O
&	O
token_table	struct
,	O
n	long
,	O
token_hash_1	function
,	O
token_hash_2	function
,	O
token_hash_cmp	function
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
{	O
char	O
offstr	array
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
printf	function
(	O
"files=%ld, largest=%s, slots=%lu\n"	pointer
,	O
idhp	pointer
->	O
idh_member_file_table	struct
.	O
ht_fill	long
,	O
offtostr	function
(	O
largest_member_file	long
,	O
offstr	array
)	O
,	O
token_table	struct
.	O
ht_size	long
)	O
;	O
}	O
init_hits_signature	function
(	O
0	int
)	O
;	O
init_summary	function
(	O
)	O
;	O
obstack_init	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
if	O
(	O
largest_member_file	long
>	O
MAX_LARGEST_MEMBER_FILE	O
)	O
largest_member_file	long
=	O
MAX_LARGEST_MEMBER_FILE	O
;	O
scanner_buffer	pointer
=	O
xmalloc	function
(	O
largest_member_file	long
+	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
member_file	struct
*	O
member	pointer
=	O
*	O
members	pointer
++	O
;	O
scan_member_file	function
(	O
member	pointer
)	O
;	O
if	O
(	O
members	pointer
==	O
end	pointer
)	O
break	O
;	O
if	O
(	O
current_hits_signature	pointer
[	O
0	int
]	O
&	O
0x80	int
)	O
summarize	function
(	O
)	O
;	O
bump_current_hits_signature	function
(	O
)	O
;	O
}	O
free	function
(	O
scanner_buffer	pointer
)	O
;	O
free	function
(	O
members_0	pointer
)	O
;	O
}	O
void	O
scan_member_file	function
(	O
struct	O
member_file	struct
const	O
*	O
member	pointer
)	O
{	O
struct	O
lang_args	struct
const	O
*	O
lang_args	struct
=	O
member	pointer
->	O
mf_lang_args	pointer
;	O
struct	O
language	struct
const	O
*	O
lang	pointer
=	O
lang_args	struct
->	O
la_language	pointer
;	O
get_token_func_t	pointer
get_token	pointer
=	O
lang	pointer
->	O
lg_get_token	pointer
;	O
struct	O
file_link	struct
*	O
flink	pointer
=	O
member	pointer
->	O
mf_link	pointer
;	O
struct	O
stat	struct
st	struct
;	O
FILE	struct
*	O
source_FILE	pointer
;	O
chdir_to_link	function
(	O
flink	pointer
->	O
fl_parent	O
)	O
;	O
source_FILE	pointer
=	O
fopen	function
(	O
flink	pointer
->	O
fl_name	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
source_FILE	pointer
)	O
{	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
statistics_flag	int
)	O
{	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
source_FILE	pointer
)	O
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
{	O
maybe_relative_file_name	function
(	O
file_name	pointer
,	O
flink	pointer
,	O
cw_dlink	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't stat `%s'"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
}	O
else	O
input_chars	long
+=	O
st	struct
.	O
st_size	long
;	O
}	O
if	O
(	O
verbose_flag	int
)	O
{	O
maybe_relative_file_name	function
(	O
file_name	pointer
,	O
flink	pointer
,	O
cw_dlink	pointer
)	O
;	O
printf	function
(	O
"%ld: %s: %s"	pointer
,	O
member	pointer
->	O
mf_index	long
,	O
lang	pointer
->	O
lg_name	pointer
,	O
file_name	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
scan_member_file_1	function
(	O
get_token	pointer
,	O
lang_args	struct
->	O
la_args_digested	pointer
,	O
source_FILE	pointer
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
fclose	function
(	O
source_FILE	pointer
)	O
;	O
}	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't open `%s'"	pointer
)	O
,	O
flink	pointer
->	O
fl_name	array
)	O
;	O
}	O
void	O
scan_member_file_1	function
(	O
get_token_func_t	pointer
get_token	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
FILE	struct
*	O
source_FILE	pointer
)	O
{	O
struct	O
token	struct
*	O
*	O
slot	pointer
;	O
struct	O
token	struct
*	O
token	struct
;	O
int	O
flags	pointer
;	O
int	O
new_tokens	int
=	O
0	int
;	O
int	O
distinct_tokens	int
=	O
0	int
;	O
while	O
(	O
(	O
token	struct
=	O
(	O
*	O
get_token	pointer
)	O
(	O
source_FILE	pointer
,	O
args	pointer
,	O
&	O
flags	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
TOKEN_NAME	O
(	O
token	struct
)	O
==	O
'\0'	O
)	O
{	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
token	struct
)	O
;	O
continue	O
;	O
}	O
slot	pointer
=	O
(	O
struct	O
token	struct
*	O
*	O
)	O
hash_find_slot	function
(	O
&	O
token_table	struct
,	O
token	struct
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
{	O
token	struct
->	O
tok_flags	char
=	O
flags	pointer
;	O
token	struct
->	O
tok_count	short
=	O
1	int
;	O
memset	function
(	O
TOKEN_HITS	O
(	O
token	struct
)	O
,	O
0	int
,	O
log_8_member_files	int
)	O
;	O
sign_token	function
(	O
token	struct
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
{	O
distinct_tokens	int
++	O
;	O
new_tokens	int
++	O
;	O
}	O
hash_insert_at	function
(	O
&	O
token_table	struct
,	O
token	struct
,	O
slot	pointer
)	O
;	O
}	O
else	O
{	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
token	struct
)	O
;	O
token	struct
=	O
*	O
slot	pointer
;	O
token	struct
->	O
tok_flags	char
|=	O
flags	pointer
;	O
if	O
(	O
token	struct
->	O
tok_count	short
<	O
USHRT_MAX	O
)	O
token	struct
->	O
tok_count	short
++	O
;	O
if	O
(	O
!	O
(	O
TOKEN_HITS	O
(	O
token	struct
)	O
[	O
0	int
]	O
&	O
current_hits_signature	pointer
[	O
0	int
]	O
)	O
)	O
{	O
sign_token	function
(	O
token	struct
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
distinct_tokens	int
++	O
;	O
}	O
}	O
}	O
if	O
(	O
verbose_flag	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  new = %d/%d"	pointer
)	O
,	O
new_tokens	int
,	O
distinct_tokens	int
)	O
;	O
if	O
(	O
distinct_tokens	int
!=	O
0	int
)	O
printf	function
(	O
" = %.0f%%"	pointer
,	O
100.0	int
*	O
(	O
double	O
)	O
new_tokens	int
/	O
(	O
double	O
)	O
distinct_tokens	int
)	O
;	O
}	O
}	O
void	O
report_statistics	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Name=%ld, "	pointer
)	O
,	O
name_tokens	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Number=%ld, "	pointer
)	O
,	O
number_tokens	long
)	O
;	O
printf	function
(	O
_	O
(	O
"String=%ld, "	pointer
)	O
,	O
string_tokens	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Literal=%ld, "	pointer
)	O
,	O
literal_tokens	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Comment=%ld\n"	pointer
)	O
,	O
comment_tokens	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Files=%ld, "	pointer
)	O
,	O
idh	struct
.	O
idh_files	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Tokens=%ld, "	pointer
)	O
,	O
occurrences	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Bytes=%ld Kb, "	pointer
)	O
,	O
input_chars	long
/	O
1024	int
)	O
;	O
printf	function
(	O
_	O
(	O
"Heap=%d+%d Kb, "	pointer
)	O
,	O
(	O
heap_after_scan	pointer
-	O
heap_after_walk	pointer
)	O
/	O
1024	int
,	O
(	O
heap_after_walk	pointer
-	O
heap_initial	pointer
)	O
/	O
1024	int
)	O
;	O
printf	function
(	O
_	O
(	O
"Output=%ld (%ld tok, %ld hit)\n"	pointer
)	O
,	O
output_length	long
,	O
tokens_length	long
,	O
hits_length	long
)	O
;	O
hash_print_stats	function
(	O
&	O
token_table	struct
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
", Freq=%ld/%ld=%.2f\n"	pointer
)	O
,	O
occurrences	long
,	O
token_table	struct
.	O
ht_fill	long
,	O
(	O
double	O
)	O
occurrences	long
/	O
(	O
double	O
)	O
token_table	struct
.	O
ht_fill	long
)	O
;	O
}	O
void	O
write_id_file	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
struct	O
token	struct
*	O
*	O
tokens	pointer
;	O
int	O
i	int
;	O
int	O
buf_size	int
;	O
int	O
vec_size	int
;	O
int	O
tok_size	int
;	O
int	O
max_buf_size	int
=	O
0	int
;	O
int	O
max_vec_size	int
=	O
0	int
;	O
if	O
(	O
verbose_flag	int
)	O
printf	function
(	O
_	O
(	O
"Sorting tokens...\n"	pointer
)	O
)	O
;	O
assert	O
(	O
summary_root	pointer
->	O
sum_hits_count	long
==	O
token_table	struct
.	O
ht_fill	long
)	O
;	O
tokens	pointer
=	O
xrealloc	function
(	O
summary_root	pointer
->	O
sum_tokens	pointer
,	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
*	O
token_table	struct
.	O
ht_fill	long
)	O
;	O
qsort	function
(	O
tokens	pointer
,	O
token_table	struct
.	O
ht_fill	long
,	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
,	O
token_qsort_cmp	function
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
printf	function
(	O
_	O
(	O
"Writing `%s'...\n"	pointer
)	O
,	O
idhp	pointer
->	O
idh_file_name	pointer
)	O
;	O
idhp	pointer
->	O
idh_FILE	pointer
=	O
fopen	function
(	O
idhp	pointer
->	O
idh_file_name	pointer
,	O
"w+b"	pointer
)	O
;	O
if	O
(	O
idhp	pointer
->	O
idh_FILE	pointer
==	O
NULL	O
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't create `%s'"	pointer
)	O
,	O
idhp	pointer
->	O
idh_file_name	pointer
)	O
;	O
idhp	pointer
->	O
idh_magic	array
[	O
0	int
]	O
=	O
IDH_MAGIC_0	O
;	O
idhp	pointer
->	O
idh_magic	array
[	O
1	int
]	O
=	O
IDH_MAGIC_1	O
;	O
idhp	pointer
->	O
idh_version	char
=	O
IDH_VERSION	int
;	O
idhp	pointer
->	O
idh_flags	short
=	O
IDH_COUNTS	O
;	O
fseek	function
(	O
idhp	pointer
->	O
idh_FILE	pointer
,	O
sizeof_idhead	function
(	O
)	O
,	O
0	int
)	O
;	O
idhp	pointer
->	O
idh_flinks_offset	long
=	O
ftell	function
(	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
serialize_file_links	function
(	O
idhp	pointer
)	O
;	O
putc	function
(	O
'\0'	O
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
putc	function
(	O
'\0'	O
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
idhp	pointer
->	O
idh_tokens_offset	long
=	O
ftell	function
(	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
token_table	struct
.	O
ht_fill	long
;	O
i	int
++	O
,	O
tokens	pointer
++	O
)	O
{	O
struct	O
token	struct
*	O
token	struct
=	O
*	O
tokens	pointer
;	O
occurrences	long
+=	O
token	struct
->	O
tok_count	short
;	O
if	O
(	O
token	struct
->	O
tok_flags	char
&	O
TOK_NUMBER	int
)	O
number_tokens	long
++	O
;	O
if	O
(	O
token	struct
->	O
tok_flags	char
&	O
TOK_NAME	int
)	O
name_tokens	long
++	O
;	O
if	O
(	O
token	struct
->	O
tok_flags	char
&	O
TOK_STRING	int
)	O
string_tokens	long
++	O
;	O
if	O
(	O
token	struct
->	O
tok_flags	char
&	O
TOK_LITERAL	int
)	O
literal_tokens	long
++	O
;	O
if	O
(	O
token	struct
->	O
tok_flags	char
&	O
TOK_COMMENT	int
)	O
comment_tokens	long
++	O
;	O
fputs	function
(	O
TOKEN_NAME	O
(	O
token	struct
)	O
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
putc	function
(	O
'\0'	O
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
if	O
(	O
token	struct
->	O
tok_count	short
>	O
0xff	int
)	O
token	struct
->	O
tok_flags	char
|=	O
TOK_SHORT_COUNT	int
;	O
putc	function
(	O
token	struct
->	O
tok_flags	char
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
putc	function
(	O
token	struct
->	O
tok_count	short
&	O
0xff	int
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
if	O
(	O
token	struct
->	O
tok_flags	char
&	O
TOK_SHORT_COUNT	int
)	O
putc	function
(	O
token	struct
->	O
tok_count	short
>>	O
8	int
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
vec_size	int
=	O
count_vec_size	function
(	O
summary_root	pointer
,	O
TOKEN_HITS	O
(	O
token	struct
)	O
+	O
levels	int
)	O
;	O
buf_size	int
=	O
count_buf_size	function
(	O
summary_root	pointer
,	O
TOKEN_HITS	O
(	O
token	struct
)	O
+	O
levels	int
)	O
;	O
hits_length	long
+=	O
buf_size	int
;	O
tok_size	int
=	O
strlen	function
(	O
TOKEN_NAME	O
(	O
token	struct
)	O
)	O
+	O
1	int
;	O
tokens_length	long
+=	O
tok_size	int
;	O
buf_size	int
+=	O
tok_size	int
+	O
sizeof	O
(	O
token	struct
->	O
tok_flags	char
)	O
+	O
sizeof	O
(	O
token	struct
->	O
tok_count	short
)	O
+	O
2	int
;	O
if	O
(	O
buf_size	int
>	O
max_buf_size	int
)	O
max_buf_size	int
=	O
buf_size	int
;	O
if	O
(	O
vec_size	int
>	O
max_vec_size	int
)	O
max_vec_size	int
=	O
vec_size	int
;	O
write_hits	function
(	O
idhp	pointer
->	O
idh_FILE	pointer
,	O
summary_root	pointer
,	O
TOKEN_HITS	O
(	O
token	struct
)	O
+	O
levels	int
)	O
;	O
putc	function
(	O
'\0'	O
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
putc	function
(	O
'\0'	O
,	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
}	O
assert_hits	function
(	O
summary_root	pointer
)	O
;	O
idhp	pointer
->	O
idh_tokens	long
=	O
token_table	struct
.	O
ht_fill	long
;	O
output_length	long
=	O
ftell	function
(	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
;	O
idhp	pointer
->	O
idh_end_offset	long
=	O
output_length	long
-	O
2	int
;	O
idhp	pointer
->	O
idh_buf_size	long
=	O
max_buf_size	int
;	O
idhp	pointer
->	O
idh_vec_size	long
=	O
max_vec_size	int
;	O
write_idhead	function
(	O
&	O
idh	struct
)	O
;	O
if	O
(	O
fclose	function
(	O
idhp	pointer
->	O
idh_FILE	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"error closing `%s'"	pointer
)	O
,	O
idhp	pointer
->	O
idh_file_name	pointer
)	O
;	O
}	O
unsigned	O
long	O
token_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
return_STRING_HASH_1	O
(	O
TOKEN_NAME	O
(	O
(	O
struct	O
token	struct
const	O
*	O
)	O
key	pointer
)	O
)	O
;	O
}	O
unsigned	O
long	O
token_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
return_STRING_HASH_2	O
(	O
TOKEN_NAME	O
(	O
(	O
struct	O
token	struct
const	O
*	O
)	O
key	pointer
)	O
)	O
;	O
}	O
int	O
token_hash_cmp	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
{	O
return_STRING_COMPARE	O
(	O
TOKEN_NAME	O
(	O
(	O
struct	O
token	struct
const	O
*	O
)	O
x	pointer
)	O
,	O
TOKEN_NAME	O
(	O
(	O
struct	O
token	struct
const	O
*	O
)	O
y	pointer
)	O
)	O
;	O
}	O
int	O
token_qsort_cmp	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
{	O
return_STRING_COMPARE	O
(	O
TOKEN_NAME	O
(	O
*	O
(	O
struct	O
token	struct
const	O
*	O
const	O
*	O
)	O
x	pointer
)	O
,	O
TOKEN_NAME	O
(	O
*	O
(	O
struct	O
token	struct
const	O
*	O
const	O
*	O
)	O
y	pointer
)	O
)	O
;	O
}	O
void	O
bump_current_hits_signature	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
*	O
hits	pointer
=	O
current_hits_signature	pointer
;	O
while	O
(	O
*	O
hits	pointer
&	O
0x80	int
)	O
*	O
hits	pointer
++	O
=	O
1	int
;	O
*	O
hits	pointer
<<=	O
1	int
;	O
}	O
void	O
init_hits_signature	function
(	O
int	O
i	int
)	O
{	O
unsigned	O
char	O
*	O
hits	pointer
=	O
current_hits_signature	pointer
;	O
unsigned	O
char	O
const	O
*	O
end	pointer
=	O
current_hits_signature	pointer
+	O
log_8_member_files	int
;	O
while	O
(	O
hits	pointer
<	O
end	pointer
)	O
{	O
*	O
hits	pointer
=	O
1	int
<<	O
(	O
i	int
&	O
7	int
)	O
;	O
i	int
>>=	O
3	int
;	O
hits	pointer
++	O
;	O
}	O
}	O
void	O
free_summary_tokens	function
(	O
void	O
)	O
{	O
struct	O
summary	struct
*	O
summary	struct
=	O
summary_leaf	pointer
;	O
while	O
(	O
summary	struct
!=	O
summary_root	pointer
)	O
{	O
free	function
(	O
summary	struct
->	O
sum_tokens	pointer
)	O
;	O
summary	struct
=	O
summary	struct
->	O
sum_parent	pointer
;	O
}	O
}	O
void	O
summarize	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
const	O
*	O
hits_sig	pointer
=	O
current_hits_signature	pointer
;	O
struct	O
summary	struct
*	O
summary	struct
=	O
summary_leaf	pointer
;	O
do	O
{	O
unsigned	O
long	O
count	long
=	O
summary	struct
->	O
sum_hits_count	long
;	O
unsigned	O
char	O
*	O
hits	pointer
=	O
xmalloc	function
(	O
count	long
+	O
1	int
)	O
;	O
unsigned	O
int	O
level	int
=	O
summary	struct
->	O
sum_level	int
;	O
struct	O
token	struct
*	O
*	O
tokens	pointer
=	O
summary	struct
->	O
sum_tokens	pointer
;	O
unsigned	O
long	O
init_size	long
=	O
INIT_TOKENS_SIZE	O
(	O
summary	struct
->	O
sum_level	int
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
printf	function
(	O
_	O
(	O
"level %d: %ld/%ld = %.0f%%\n"	pointer
)	O
,	O
summary	struct
->	O
sum_level	int
,	O
count	long
,	O
init_size	long
,	O
100.0	int
*	O
(	O
double	O
)	O
count	long
/	O
(	O
double	O
)	O
init_size	long
)	O
;	O
qsort	function
(	O
tokens	pointer
,	O
count	long
,	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
,	O
token_qsort_cmp	function
)	O
;	O
summary	struct
->	O
sum_hits	pointer
=	O
hits	pointer
;	O
while	O
(	O
count	long
--	O
)	O
{	O
unsigned	O
char	O
*	O
hit	pointer
=	O
TOKEN_HITS	O
(	O
*	O
tokens	pointer
++	O
)	O
+	O
level	int
;	O
*	O
hits	pointer
++	O
=	O
*	O
hit	pointer
;	O
*	O
hit	pointer
=	O
0	int
;	O
}	O
*	O
hits	pointer
++	O
=	O
0	int
;	O
if	O
(	O
summary	struct
->	O
sum_parent	pointer
)	O
{	O
free	function
(	O
summary	struct
->	O
sum_tokens	pointer
)	O
;	O
summary	struct
->	O
sum_tokens	pointer
=	O
0	int
;	O
}	O
summary	struct
=	O
summary	struct
->	O
sum_parent	pointer
;	O
}	O
while	O
(	O
*	O
++	O
hits_sig	pointer
&	O
0x80	int
)	O
;	O
summary_leaf	pointer
=	O
make_sibling_summary	function
(	O
summary_leaf	pointer
)	O
;	O
}	O
void	O
init_summary	function
(	O
void	O
)	O
{	O
unsigned	O
long	O
size	long
=	O
INIT_TOKENS_SIZE	O
(	O
0	int
)	O
;	O
summary_root	pointer
=	O
summary_leaf	pointer
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
summary	struct
)	O
)	O
;	O
summary_root	pointer
->	O
sum_tokens_size	long
=	O
size	long
;	O
summary_root	pointer
->	O
sum_tokens	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
*	O
size	long
)	O
;	O
}	O
struct	O
summary	struct
*	O
make_sibling_summary	function
(	O
struct	O
summary	struct
*	O
summary	struct
)	O
{	O
struct	O
summary	struct
*	O
parent	pointer
=	O
summary	struct
->	O
sum_parent	pointer
;	O
unsigned	O
long	O
size	long
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
{	O
levels	int
++	O
;	O
summary_root	pointer
=	O
summary	struct
->	O
sum_parent	pointer
=	O
parent	pointer
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
summary	struct
)	O
)	O
;	O
parent	pointer
->	O
sum_level	int
=	O
levels	int
;	O
parent	pointer
->	O
sum_kids	O
[	O
0	int
]	O
=	O
summary	struct
;	O
parent	pointer
->	O
sum_hits_count	long
=	O
summary	struct
->	O
sum_hits_count	long
;	O
parent	pointer
->	O
sum_free_index	int
=	O
1	int
;	O
size	long
=	O
INIT_TOKENS_SIZE	O
(	O
levels	int
)	O
;	O
if	O
(	O
summary	struct
->	O
sum_tokens_size	long
>=	O
size	long
)	O
{	O
parent	pointer
->	O
sum_tokens_size	long
=	O
summary	struct
->	O
sum_tokens_size	long
;	O
parent	pointer
->	O
sum_tokens	pointer
=	O
summary	struct
->	O
sum_tokens	pointer
;	O
}	O
else	O
{	O
parent	pointer
->	O
sum_tokens_size	long
=	O
size	long
;	O
parent	pointer
->	O
sum_tokens	pointer
=	O
xrealloc	function
(	O
summary	struct
->	O
sum_tokens	pointer
,	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
*	O
size	long
)	O
;	O
}	O
summary	struct
->	O
sum_tokens	pointer
=	O
0	int
;	O
}	O
if	O
(	O
parent	pointer
->	O
sum_free_index	int
==	O
8	int
)	O
parent	pointer
=	O
make_sibling_summary	function
(	O
parent	pointer
)	O
;	O
summary	struct
=	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
summary	struct
)	O
)	O
;	O
summary	struct
->	O
sum_level	int
=	O
parent	pointer
->	O
sum_level	int
-	O
1	int
;	O
parent	pointer
->	O
sum_kids	O
[	O
parent	pointer
->	O
sum_free_index	int
++	O
]	O
=	O
summary	struct
;	O
summary	struct
->	O
sum_parent	pointer
=	O
parent	pointer
;	O
size	long
=	O
INIT_TOKENS_SIZE	O
(	O
summary	struct
->	O
sum_level	int
)	O
;	O
summary	struct
->	O
sum_tokens_size	long
=	O
size	long
;	O
summary	struct
->	O
sum_tokens	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
*	O
size	long
)	O
;	O
return	O
summary	struct
;	O
}	O
int	O
count_vec_size	function
(	O
struct	O
summary	struct
*	O
summary	struct
,	O
unsigned	O
char	O
const	O
*	O
tail_hits	pointer
)	O
{	O
struct	O
summary	struct
*	O
*	O
kids	pointer
;	O
unsigned	O
int	O
hits	pointer
=	O
(	O
summary	struct
->	O
sum_hits	pointer
?	O
*	O
summary	struct
->	O
sum_hits	pointer
:	O
*	O
tail_hits	pointer
)	O
;	O
kids	pointer
=	O
summary	struct
->	O
sum_kids	O
;	O
if	O
(	O
*	O
kids	pointer
==	O
NULL	O
)	O
{	O
static	O
char	O
bits_per_nybble	array
[	O
]	O
=	O
{	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
4	int
}	O
;	O
return	O
bits_per_nybble	array
[	O
hits	pointer
&	O
0xf	int
]	O
+	O
bits_per_nybble	array
[	O
hits	pointer
>>	O
4	int
]	O
;	O
}	O
else	O
{	O
int	O
bit	int
;	O
int	O
count	long
=	O
0	int
;	O
--	O
tail_hits	pointer
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
bit	int
&	O
0xff	int
;	O
bit	int
<<=	O
1	int
,	O
++	O
kids	pointer
)	O
if	O
(	O
bit	int
&	O
hits	pointer
)	O
count	long
+=	O
count_vec_size	function
(	O
*	O
kids	pointer
,	O
tail_hits	pointer
)	O
;	O
return	O
count	long
;	O
}	O
}	O
int	O
count_buf_size	function
(	O
struct	O
summary	struct
*	O
summary	struct
,	O
unsigned	O
char	O
const	O
*	O
tail_hits	pointer
)	O
{	O
struct	O
summary	struct
*	O
*	O
kids	pointer
;	O
unsigned	O
int	O
hits	pointer
=	O
(	O
summary	struct
->	O
sum_hits	pointer
?	O
*	O
summary	struct
->	O
sum_hits	pointer
:	O
*	O
tail_hits	pointer
)	O
;	O
kids	pointer
=	O
summary	struct
->	O
sum_kids	O
;	O
if	O
(	O
*	O
kids	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
else	O
{	O
int	O
bit	int
;	O
int	O
count	long
=	O
1	int
;	O
--	O
tail_hits	pointer
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
bit	int
&	O
0xff	int
;	O
bit	int
<<=	O
1	int
,	O
++	O
kids	pointer
)	O
if	O
(	O
bit	int
&	O
hits	pointer
)	O
count	long
+=	O
count_buf_size	function
(	O
*	O
kids	pointer
,	O
tail_hits	pointer
)	O
;	O
return	O
count	long
;	O
}	O
}	O
void	O
assert_hits	function
(	O
struct	O
summary	struct
*	O
summary	struct
)	O
{	O
struct	O
summary	struct
*	O
*	O
kids	pointer
=	O
summary	struct
->	O
sum_kids	O
;	O
struct	O
summary	struct
*	O
*	O
end	pointer
=	O
&	O
kids	pointer
[	O
8	int
]	O
;	O
assert	O
(	O
summary	struct
->	O
sum_hits	pointer
==	O
NULL	O
||	O
*	O
summary	struct
->	O
sum_hits	pointer
==	O
0	int
)	O
;	O
if	O
(	O
end	pointer
[	O
-	O
1	int
]	O
==	O
0	int
)	O
while	O
(	O
*	O
--	O
end	pointer
==	O
0	int
)	O
;	O
while	O
(	O
kids	pointer
<	O
end	pointer
)	O
assert_hits	function
(	O
*	O
kids	pointer
++	O
)	O
;	O
}	O
void	O
write_hits	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
summary	struct
*	O
summary	struct
,	O
unsigned	O
char	O
const	O
*	O
tail_hits	pointer
)	O
{	O
struct	O
summary	struct
*	O
*	O
kids	pointer
;	O
unsigned	O
int	O
hits	pointer
=	O
(	O
summary	struct
->	O
sum_hits	pointer
?	O
*	O
summary	struct
->	O
sum_hits	pointer
++	O
:	O
*	O
tail_hits	pointer
)	O
;	O
assert	O
(	O
hits	pointer
)	O
;	O
putc	function
(	O
hits	pointer
,	O
fp	pointer
)	O
;	O
kids	pointer
=	O
summary	struct
->	O
sum_kids	O
;	O
if	O
(	O
*	O
kids	pointer
)	O
{	O
int	O
bit	int
;	O
--	O
tail_hits	pointer
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
(	O
bit	int
&	O
0xff	int
)	O
&&	O
*	O
kids	pointer
;	O
bit	int
<<=	O
1	int
,	O
++	O
kids	pointer
)	O
if	O
(	O
bit	int
&	O
hits	pointer
)	O
write_hits	function
(	O
fp	pointer
,	O
*	O
kids	pointer
,	O
tail_hits	pointer
)	O
;	O
}	O
}	O
void	O
sign_token	function
(	O
struct	O
token	struct
*	O
token	struct
)	O
{	O
unsigned	O
char	O
*	O
tok_hits	pointer
=	O
TOKEN_HITS	O
(	O
token	struct
)	O
;	O
unsigned	O
char	O
*	O
hits_sig	pointer
=	O
current_hits_signature	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
current_hits_signature	pointer
+	O
log_8_member_files	int
;	O
struct	O
summary	struct
*	O
summary	struct
=	O
summary_leaf	pointer
;	O
while	O
(	O
summary	struct
)	O
{	O
if	O
(	O
*	O
tok_hits	pointer
==	O
0	int
)	O
add_token_to_summary	function
(	O
summary	struct
,	O
token	struct
)	O
;	O
if	O
(	O
*	O
tok_hits	pointer
&	O
*	O
hits_sig	pointer
)	O
break	O
;	O
*	O
tok_hits	pointer
|=	O
*	O
hits_sig	pointer
;	O
summary	struct
=	O
summary	struct
->	O
sum_parent	pointer
;	O
tok_hits	pointer
++	O
;	O
hits_sig	pointer
++	O
;	O
}	O
while	O
(	O
hits_sig	pointer
<	O
end	pointer
)	O
{	O
if	O
(	O
*	O
tok_hits	pointer
&	O
*	O
hits_sig	pointer
)	O
break	O
;	O
*	O
tok_hits	pointer
|=	O
*	O
hits_sig	pointer
;	O
tok_hits	pointer
++	O
;	O
hits_sig	pointer
++	O
;	O
}	O
}	O
void	O
add_token_to_summary	function
(	O
struct	O
summary	struct
*	O
summary	struct
,	O
struct	O
token	struct
*	O
token	struct
)	O
{	O
unsigned	O
long	O
size	long
=	O
summary	struct
->	O
sum_tokens_size	long
;	O
if	O
(	O
summary	struct
->	O
sum_hits_count	long
>=	O
size	long
)	O
{	O
size	long
*=	O
2	int
;	O
summary	struct
->	O
sum_tokens	pointer
=	O
xrealloc	function
(	O
summary	struct
->	O
sum_tokens	pointer
,	O
sizeof	O
(	O
struct	O
token	struct
*	O
)	O
*	O
size	long
)	O
;	O
summary	struct
->	O
sum_tokens_size	long
=	O
size	long
;	O
}	O
summary	struct
->	O
sum_tokens	pointer
[	O
summary	struct
->	O
sum_hits_count	long
++	O
]	O
=	O
token	struct
;	O
}	O
