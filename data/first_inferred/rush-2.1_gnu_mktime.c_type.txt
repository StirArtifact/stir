typedef	O
long	O
int	O
long_int	long
;	O
verify	O
(	O
INT_MAX	O
<=	O
TYPE_MAXIMUM	O
(	O
long_int	long
)	O
/	O
4	int
/	O
366	int
/	O
24	int
/	O
60	int
/	O
60	int
)	O
;	O
static	O
long_int	long
shr	function
(	O
long_int	long
a	long
,	O
int	O
b	int
)	O
{	O
long_int	long
one	long
=	O
1	int
;	O
return	O
(	O
-	O
one	long
>>	O
1	int
==	O
-	O
1	int
?	O
a	long
>>	O
b	int
:	O
a	long
/	O
(	O
one	long
<<	O
b	int
)	O
-	O
(	O
a	long
%	O
(	O
one	long
<<	O
b	int
)	O
<	O
0	int
)	O
)	O
;	O
}	O
static	O
long_int	long
const	O
mktime_min	long
=	O
(	O
(	O
TYPE_SIGNED	O
(	O
time_t	long
)	O
&&	O
TYPE_MINIMUM	O
(	O
time_t	long
)	O
<	O
TYPE_MINIMUM	O
(	O
long_int	long
)	O
)	O
?	O
TYPE_MINIMUM	O
(	O
long_int	long
)	O
:	O
TYPE_MINIMUM	O
(	O
time_t	long
)	O
)	O
;	O
static	O
long_int	long
const	O
mktime_max	long
=	O
(	O
TYPE_MAXIMUM	O
(	O
long_int	long
)	O
<	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
?	O
TYPE_MAXIMUM	O
(	O
long_int	long
)	O
:	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
)	O
;	O
verify	O
(	O
TYPE_IS_INTEGER	O
(	O
time_t	long
)	O
)	O
;	O
verify	O
(	O
TM_YEAR_BASE	int
%	O
100	int
==	O
0	int
)	O
;	O
static	O
bool	bool
leapyear	function
(	O
long_int	long
year	long
)	O
{	O
return	O
(	O
(	O
year	long
&	O
3	int
)	O
==	O
0	int
&&	O
(	O
year	long
%	O
100	int
!=	O
0	int
||	O
(	O
(	O
year	long
/	O
100	int
)	O
&	O
3	int
)	O
==	O
(	O
-	O
(	O
TM_YEAR_BASE	int
/	O
100	int
)	O
&	O
3	int
)	O
)	O
)	O
;	O
}	O
static	O
const	O
unsigned	O
short	O
int	O
__mon_yday	array
[	O
2	int
]	O
[	O
13	int
]	O
=	O
{	O
{	O
0	int
,	O
31	int
,	O
59	int
,	O
90	int
,	O
120	int
,	O
151	int
,	O
181	int
,	O
212	int
,	O
243	int
,	O
273	int
,	O
304	int
,	O
334	int
,	O
365	int
}	O
,	O
{	O
0	int
,	O
31	int
,	O
60	int
,	O
91	int
,	O
121	int
,	O
152	int
,	O
182	int
,	O
213	int
,	O
244	int
,	O
274	int
,	O
305	int
,	O
335	int
,	O
366	int
}	O
}	O
;	O
static	O
bool	bool
isdst_differ	function
(	O
int	O
a	long
,	O
int	O
b	int
)	O
{	O
return	O
(	O
!	O
a	long
!=	O
!	O
b	int
)	O
&&	O
(	O
0	int
<=	O
a	long
)	O
&&	O
(	O
0	int
<=	O
b	int
)	O
;	O
}	O
static	O
long_int	long
ydhms_diff	function
(	O
long_int	long
year1	long
,	O
long_int	long
yday1	long
,	O
int	O
hour1	int
,	O
int	O
min1	int
,	O
int	O
sec1	int
,	O
int	O
year0	int
,	O
int	O
yday0	int
,	O
int	O
hour0	int
,	O
int	O
min0	int
,	O
int	O
sec0	int
)	O
{	O
verify	O
(	O
-	O
1	int
/	O
2	int
==	O
0	int
)	O
;	O
int	O
a4	int
=	O
shr	function
(	O
year1	long
,	O
2	int
)	O
+	O
shr	function
(	O
TM_YEAR_BASE	int
,	O
2	int
)	O
-	O
!	O
(	O
year1	long
&	O
3	int
)	O
;	O
int	O
b4	int
=	O
shr	function
(	O
year0	int
,	O
2	int
)	O
+	O
shr	function
(	O
TM_YEAR_BASE	int
,	O
2	int
)	O
-	O
!	O
(	O
year0	int
&	O
3	int
)	O
;	O
int	O
a100	int
=	O
a4	int
/	O
25	int
-	O
(	O
a4	int
%	O
25	int
<	O
0	int
)	O
;	O
int	O
b100	int
=	O
b4	int
/	O
25	int
-	O
(	O
b4	int
%	O
25	int
<	O
0	int
)	O
;	O
int	O
a400	int
=	O
shr	function
(	O
a100	int
,	O
2	int
)	O
;	O
int	O
b400	int
=	O
shr	function
(	O
b100	int
,	O
2	int
)	O
;	O
int	O
intervening_leap_days	int
=	O
(	O
a4	int
-	O
b4	int
)	O
-	O
(	O
a100	int
-	O
b100	int
)	O
+	O
(	O
a400	int
-	O
b400	int
)	O
;	O
long_int	long
years	long
=	O
year1	long
-	O
year0	int
;	O
long_int	long
days	long
=	O
365	int
*	O
years	long
+	O
yday1	long
-	O
yday0	int
+	O
intervening_leap_days	int
;	O
long_int	long
hours	long
=	O
24	int
*	O
days	long
+	O
hour1	int
-	O
hour0	int
;	O
long_int	long
minutes	long
=	O
60	int
*	O
hours	long
+	O
min1	int
-	O
min0	int
;	O
long_int	long
seconds	long
=	O
60	int
*	O
minutes	long
+	O
sec1	int
-	O
sec0	int
;	O
return	O
seconds	long
;	O
}	O
static	O
long_int	long
long_int_avg	function
(	O
long_int	long
a	long
,	O
long_int	long
b	int
)	O
{	O
return	O
shr	function
(	O
a	long
,	O
1	int
)	O
+	O
shr	function
(	O
b	int
,	O
1	int
)	O
+	O
(	O
(	O
a	long
|	O
b	int
)	O
&	O
1	int
)	O
;	O
}	O
static	O
long_int	long
tm_diff	function
(	O
long_int	long
year	long
,	O
long_int	long
yday	long
,	O
int	O
hour	int
,	O
int	O
min	int
,	O
int	O
sec	int
,	O
struct	O
tm	struct
const	O
*	O
tp	pointer
)	O
{	O
return	O
ydhms_diff	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
tp	pointer
->	O
tm_year	int
,	O
tp	pointer
->	O
tm_yday	int
,	O
tp	pointer
->	O
tm_hour	int
,	O
tp	pointer
->	O
tm_min	int
,	O
tp	pointer
->	O
tm_sec	int
)	O
;	O
}	O
static	O
struct	O
tm	struct
*	O
convert_time	function
(	O
struct	O
tm	struct
*	O
(	O
*	O
convert	pointer
)	O
(	O
const	O
time_t	long
*	O
,	O
struct	O
tm	struct
*	O
)	O
,	O
long_int	long
t	long
,	O
struct	O
tm	struct
*	O
tm	struct
)	O
{	O
time_t	long
x	long
=	O
t	long
;	O
return	O
convert	pointer
(	O
&	O
x	long
,	O
tm	struct
)	O
;	O
}	O
static	O
struct	O
tm	struct
*	O
ranged_convert	function
(	O
struct	O
tm	struct
*	O
(	O
*	O
convert	pointer
)	O
(	O
const	O
time_t	long
*	O
,	O
struct	O
tm	struct
*	O
)	O
,	O
long_int	long
*	O
t	long
,	O
struct	O
tm	struct
*	O
tp	pointer
)	O
{	O
long_int	long
t1	long
=	O
(	O
*	O
t	long
<	O
mktime_min	long
?	O
mktime_min	long
:	O
*	O
t	long
<=	O
mktime_max	long
?	O
*	O
t	long
:	O
mktime_max	long
)	O
;	O
struct	O
tm	struct
*	O
r	pointer
=	O
convert_time	function
(	O
convert	pointer
,	O
t1	long
,	O
tp	pointer
)	O
;	O
if	O
(	O
r	pointer
)	O
{	O
*	O
t	long
=	O
t1	long
;	O
return	O
r	pointer
;	O
}	O
if	O
(	O
errno	O
!=	O
EOVERFLOW	int
)	O
return	O
NULL	O
;	O
long_int	long
bad	long
=	O
t1	long
;	O
long_int	long
ok	long
=	O
0	int
;	O
struct	O
tm	struct
oktm	struct
;	O
oktm	struct
.	O
tm_sec	int
=	O
-	O
1	int
;	O
while	O
(	O
true	int
)	O
{	O
long_int	long
mid	long
=	O
long_int_avg	function
(	O
ok	long
,	O
bad	long
)	O
;	O
if	O
(	O
mid	long
==	O
ok	long
||	O
mid	long
==	O
bad	long
)	O
break	O
;	O
if	O
(	O
convert_time	function
(	O
convert	pointer
,	O
mid	long
,	O
tp	pointer
)	O
)	O
ok	long
=	O
mid	long
,	O
oktm	struct
=	O
*	O
tp	pointer
;	O
else	O
if	O
(	O
errno	O
!=	O
EOVERFLOW	int
)	O
return	O
NULL	O
;	O
else	O
bad	long
=	O
mid	long
;	O
}	O
if	O
(	O
oktm	struct
.	O
tm_sec	int
<	O
0	int
)	O
return	O
NULL	O
;	O
*	O
t	long
=	O
ok	long
;	O
*	O
tp	pointer
=	O
oktm	struct
;	O
return	O
tp	pointer
;	O
}	O
time_t	long
__mktime_internal	O
(	O
struct	O
tm	struct
*	O
tp	pointer
,	O
struct	O
tm	struct
*	O
(	O
*	O
convert	pointer
)	O
(	O
const	O
time_t	long
*	O
,	O
struct	O
tm	struct
*	O
)	O
,	O
mktime_offset_t	long
*	O
offset	long
)	O
{	O
struct	O
tm	struct
tm	struct
;	O
int	O
remaining_probes	int
=	O
6	int
;	O
int	O
sec	int
=	O
tp	pointer
->	O
tm_sec	int
;	O
int	O
min	int
=	O
tp	pointer
->	O
tm_min	int
;	O
int	O
hour	int
=	O
tp	pointer
->	O
tm_hour	int
;	O
int	O
mday	int
=	O
tp	pointer
->	O
tm_mday	int
;	O
int	O
mon	int
=	O
tp	pointer
->	O
tm_mon	int
;	O
int	O
year_requested	int
=	O
tp	pointer
->	O
tm_year	int
;	O
int	O
isdst	int
=	O
tp	pointer
->	O
tm_isdst	int
;	O
int	O
dst2	int
=	O
0	int
;	O
int	O
mon_remainder	int
=	O
mon	int
%	O
12	int
;	O
int	O
negative_mon_remainder	int
=	O
mon_remainder	int
<	O
0	int
;	O
int	O
mon_years	int
=	O
mon	int
/	O
12	int
-	O
negative_mon_remainder	int
;	O
long_int	long
lyear_requested	long
=	O
year_requested	int
;	O
long_int	long
year	long
=	O
lyear_requested	long
+	O
mon_years	int
;	O
int	O
mon_yday	int
=	O
(	O
(	O
__mon_yday	array
[	O
leapyear	function
(	O
year	long
)	O
]	O
[	O
mon_remainder	int
+	O
12	int
*	O
negative_mon_remainder	int
]	O
)	O
-	O
1	int
)	O
;	O
long_int	long
lmday	long
=	O
mday	int
;	O
long_int	long
yday	long
=	O
mon_yday	int
+	O
lmday	long
;	O
mktime_offset_t	long
off	long
=	O
*	O
offset	long
;	O
int	O
negative_offset_guess	int
;	O
int	O
sec_requested	int
=	O
sec	int
;	O
if	O
(	O
LEAP_SECONDS_POSSIBLE	int
)	O
{	O
if	O
(	O
sec	int
<	O
0	int
)	O
sec	int
=	O
0	int
;	O
if	O
(	O
59	int
<	O
sec	int
)	O
sec	int
=	O
59	int
;	O
}	O
INT_SUBTRACT_WRAPV	O
(	O
0	int
,	O
off	long
,	O
&	O
negative_offset_guess	int
)	O
;	O
long_int	long
t0	long
=	O
ydhms_diff	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
EPOCH_YEAR	int
-	O
TM_YEAR_BASE	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
negative_offset_guess	int
)	O
;	O
long_int	long
t	long
=	O
t0	long
,	O
t1	long
=	O
t0	long
,	O
t2	long
=	O
t0	long
;	O
while	O
(	O
true	int
)	O
{	O
if	O
(	O
!	O
ranged_convert	function
(	O
convert	pointer
,	O
&	O
t	long
,	O
&	O
tm	struct
)	O
)	O
return	O
-	O
1	int
;	O
long_int	long
dt	long
=	O
tm_diff	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
&	O
tm	struct
)	O
;	O
if	O
(	O
dt	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
t	long
==	O
t1	long
&&	O
t	long
!=	O
t2	long
&&	O
(	O
tm	struct
.	O
tm_isdst	int
<	O
0	int
||	O
(	O
isdst	int
<	O
0	int
?	O
dst2	int
<=	O
(	O
tm	struct
.	O
tm_isdst	int
!=	O
0	int
)	O
:	O
(	O
isdst	int
!=	O
0	int
)	O
!=	O
(	O
tm	struct
.	O
tm_isdst	int
!=	O
0	int
)	O
)	O
)	O
)	O
goto	O
offset_found	O
;	O
remaining_probes	int
--	O
;	O
if	O
(	O
remaining_probes	int
==	O
0	int
)	O
{	O
__set_errno	O
(	O
EOVERFLOW	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
t1	long
=	O
t2	long
,	O
t2	long
=	O
t	long
,	O
t	long
+=	O
dt	long
,	O
dst2	int
=	O
tm	struct
.	O
tm_isdst	int
!=	O
0	int
;	O
}	O
if	O
(	O
isdst_differ	function
(	O
isdst	int
,	O
tm	struct
.	O
tm_isdst	int
)	O
)	O
{	O
int	O
stride	int
=	O
601200	int
;	O
int	O
duration_max	int
=	O
536454000	int
;	O
int	O
delta_bound	int
=	O
duration_max	int
/	O
2	int
+	O
stride	int
;	O
int	O
delta	int
,	O
direction	int
;	O
for	O
(	O
delta	int
=	O
stride	int
;	O
delta	int
<	O
delta_bound	int
;	O
delta	int
+=	O
stride	int
)	O
for	O
(	O
direction	int
=	O
-	O
1	int
;	O
direction	int
<=	O
1	int
;	O
direction	int
+=	O
2	int
)	O
{	O
long_int	long
ot	long
;	O
if	O
(	O
!	O
INT_ADD_WRAPV	O
(	O
t	long
,	O
delta	int
*	O
direction	int
,	O
&	O
ot	long
)	O
)	O
{	O
struct	O
tm	struct
otm	struct
;	O
if	O
(	O
!	O
ranged_convert	function
(	O
convert	pointer
,	O
&	O
ot	long
,	O
&	O
otm	struct
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
isdst_differ	function
(	O
isdst	int
,	O
otm	struct
.	O
tm_isdst	int
)	O
)	O
{	O
long_int	long
gt	long
=	O
ot	long
+	O
tm_diff	function
(	O
year	long
,	O
yday	long
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
&	O
otm	struct
)	O
;	O
if	O
(	O
mktime_min	long
<=	O
gt	long
&&	O
gt	long
<=	O
mktime_max	long
)	O
{	O
if	O
(	O
convert_time	function
(	O
convert	pointer
,	O
gt	long
,	O
&	O
tm	struct
)	O
)	O
{	O
t	long
=	O
gt	long
;	O
goto	O
offset_found	O
;	O
}	O
if	O
(	O
errno	O
!=	O
EOVERFLOW	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
}	O
__set_errno	O
(	O
EOVERFLOW	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
offset_found	O
:	O
INT_SUBTRACT_WRAPV	O
(	O
t	long
,	O
t0	long
,	O
offset	long
)	O
;	O
INT_SUBTRACT_WRAPV	O
(	O
*	O
offset	long
,	O
negative_offset_guess	int
,	O
offset	long
)	O
;	O
if	O
(	O
LEAP_SECONDS_POSSIBLE	int
&&	O
sec_requested	int
!=	O
tm	struct
.	O
tm_sec	int
)	O
{	O
long_int	long
sec_adjustment	long
=	O
sec	int
==	O
0	int
&&	O
tm	struct
.	O
tm_sec	int
==	O
60	int
;	O
sec_adjustment	long
-=	O
sec	int
;	O
sec_adjustment	long
+=	O
sec_requested	int
;	O
if	O
(	O
INT_ADD_WRAPV	O
(	O
t	long
,	O
sec_adjustment	long
,	O
&	O
t	long
)	O
||	O
!	O
(	O
mktime_min	long
<=	O
t	long
&&	O
t	long
<=	O
mktime_max	long
)	O
)	O
{	O
__set_errno	O
(	O
EOVERFLOW	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
convert_time	function
(	O
convert	pointer
,	O
t	long
,	O
&	O
tm	struct
)	O
)	O
return	O
-	O
1	int
;	O
}	O
*	O
tp	pointer
=	O
tm	struct
;	O
return	O
t	long
;	O
}	O
weak_alias	O
(	O
mktime	function
,	O
timelocal	function
)	O
