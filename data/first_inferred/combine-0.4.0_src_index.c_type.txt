int	O
initialize_index	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
filename	pointer
,	O
index_file	pointer
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
char	O
*	O
filename	pointer
;	O
FILE	struct
*	O
*	O
index_file	pointer
;	O
{	O
comb_index_hdr	struct
index_hdr	struct
;	O
comb_index_hdr_ll	struct
index_hdr_more	struct
;	O
comb_hash_entry_ll	struct
index_entry	struct
;	O
long	O
long	O
int	O
i	long long
;	O
int	O
return_val	int
;	O
*	O
index_file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
*	O
index_file	pointer
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
filename	pointer
)	O
;	O
index_hdr	struct
.	O
magic_number	long
=	O
'DpV!'	O
;	O
index_hdr	struct
.	O
version	long
=	O
1	int
;	O
index_hdr	struct
.	O
hash_method	long
=	O
hash_method	long
;	O
index_hdr	struct
.	O
hash_number_size	long
=	O
number_size	long long
;	O
return_val	int
=	O
fwrite	function
(	O
&	O
index_hdr	struct
,	O
sizeof	O
(	O
index_hdr	struct
)	O
,	O
1	int
,	O
*	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error writing to index file"	pointer
)	O
)	O
;	O
index_hdr_more	struct
.	O
hash_size	long long
=	O
entries	long long
;	O
return_val	int
=	O
fwrite	function
(	O
&	O
index_hdr_more	struct
,	O
sizeof	O
(	O
index_hdr_more	struct
)	O
,	O
1	int
,	O
*	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error writing to index file"	pointer
)	O
)	O
;	O
index_entry	struct
.	O
file_position	long long
=	O
0	int
;	O
index_entry	struct
.	O
record_length	long long
=	O
0	int
;	O
index_entry	struct
.	O
key_position	long long
=	O
0	int
;	O
index_entry	struct
.	O
key_length	long long
=	O
0	int
;	O
index_entry	struct
.	O
next_same_key	long long
=	O
0	int
;	O
index_entry	struct
.	O
prev_same_key	long long
=	O
0	int
;	O
for	O
(	O
i	long long
=	O
0	int
;	O
i	long long
<	O
entries	long long
;	O
i	long long
++	O
)	O
{	O
return_val	int
=	O
fwrite	function
(	O
&	O
index_entry	struct
,	O
sizeof	O
(	O
index_entry	struct
)	O
,	O
1	int
,	O
*	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error writing to index file"	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
open_index	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
filename	pointer
,	O
index_file	pointer
)	O
INDEXNUM	O
*	O
entries	long long
;	O
INDEXNUM	O
*	O
number_size	long long
;	O
INDEXNUM	O
*	O
hash_method	long
;	O
char	O
*	O
filename	pointer
;	O
FILE	struct
*	O
*	O
index_file	pointer
;	O
{	O
int	O
return_val	int
;	O
comb_index_hdr	struct
index_hdr	struct
;	O
comb_index_hdr_ll	struct
index_hdr_more	struct
;	O
*	O
index_file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
*	O
index_file	pointer
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
filename	pointer
)	O
;	O
return_val	int
=	O
fread	function
(	O
&	O
index_hdr	struct
,	O
sizeof	O
(	O
index_hdr	struct
)	O
,	O
1	int
,	O
*	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	pointer
)	O
)	O
;	O
if	O
(	O
index_hdr	struct
.	O
magic_number	long
!=	O
'DpV!'	O
||	O
index_hdr	struct
.	O
version	long
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"invalid index file or unsupported version"	pointer
)	O
)	O
;	O
*	O
hash_method	long
=	O
index_hdr	struct
.	O
hash_method	long
;	O
*	O
number_size	long long
=	O
index_hdr	struct
.	O
hash_number_size	long
;	O
if	O
(	O
*	O
number_size	long long
!=	O
8	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"only long long numbers are supported now"	pointer
)	O
)	O
;	O
return_val	int
=	O
fread	function
(	O
&	O
index_hdr_more	struct
,	O
sizeof	O
(	O
index_hdr_more	struct
)	O
,	O
1	int
,	O
*	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	pointer
)	O
)	O
;	O
*	O
entries	long long
=	O
index_hdr_more	struct
.	O
hash_size	long long
;	O
return	O
0	int
;	O
}	O
INDEXNUM	O
find_index_key	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	pointer
,	O
key	pointer
,	O
next	pointer
,	O
position	pointer
,	O
length	long
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
FILE	struct
*	O
index_file	pointer
;	O
STRINGTYPE	O
*	O
key	pointer
;	O
INDEXNUM	O
*	O
next	pointer
;	O
INDEXNUM	O
*	O
position	pointer
;	O
INDEXNUM	O
*	O
length	long
;	O
{	O
HASHTYPE	O
hash_key	long
;	O
INDEXNUM	O
start_pos	long long
;	O
INDEXNUM	O
curr_pos	long long
;	O
comb_hash_entry_ll	struct
index_entry	struct
;	O
int	O
return_val	int
;	O
if	O
(	O
*	O
next	pointer
==	O
-	O
1	int
)	O
{	O
INDEXNUM	O
orig_pos	long long
;	O
start_pos	long long
=	O
-	O
1	int
;	O
hash_key	long
=	O
calc_hash_key	function
(	O
key	pointer
)	O
;	O
curr_pos	long long
=	O
hash_key	long
%	O
entries	long long
;	O
orig_pos	long long
=	O
curr_pos	long long
;	O
do	O
{	O
char	O
*	O
test_key	pointer
;	O
return_val	int
=	O
fseek	function
(	O
index_file	pointer
,	O
sizeof	O
(	O
comb_index_hdr	struct
)	O
+	O
sizeof	O
(	O
comb_index_hdr_ll	struct
)	O
+	O
curr_pos	long long
*	O
sizeof	O
(	O
comb_hash_entry_ll	struct
)	O
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_val	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to reposition within index"	pointer
)	O
)	O
;	O
return_val	int
=	O
fread	function
(	O
&	O
index_entry	struct
,	O
sizeof	O
(	O
index_entry	struct
)	O
,	O
1	int
,	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	pointer
)	O
)	O
;	O
test_key	pointer
=	O
malloc	function
(	O
index_entry	struct
.	O
key_length	long long
)	O
;	O
if	O
(	O
test_key	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
return_val	int
=	O
fseek	function
(	O
index_file	pointer
,	O
sizeof	O
(	O
comb_index_hdr	struct
)	O
+	O
sizeof	O
(	O
comb_index_hdr_ll	struct
)	O
+	O
entries	long long
*	O
sizeof	O
(	O
comb_hash_entry_ll	struct
)	O
+	O
index_entry	struct
.	O
key_position	long long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_val	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to reposition within index"	pointer
)	O
)	O
;	O
return_val	int
=	O
fread	function
(	O
test_key	pointer
,	O
index_entry	struct
.	O
key_length	long long
,	O
1	int
,	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	pointer
)	O
)	O
;	O
if	O
(	O
key	pointer
->	O
length	long
==	O
index_entry	struct
.	O
key_length	long long
&&	O
memcmp	function
(	O
key	pointer
->	O
string	pointer
,	O
test_key	pointer
,	O
key	pointer
->	O
length	long
)	O
==	O
0	int
)	O
{	O
start_pos	long long
=	O
curr_pos	long long
;	O
orig_pos	long long
=	O
curr_pos	long long
;	O
}	O
else	O
curr_pos	long long
=	O
(	O
curr_pos	long long
+	O
1	int
)	O
%	O
entries	long long
;	O
free	function
(	O
test_key	pointer
)	O
;	O
}	O
while	O
(	O
curr_pos	long long
!=	O
orig_pos	long long
)	O
;	O
}	O
else	O
{	O
start_pos	long long
=	O
*	O
next	pointer
;	O
return_val	int
=	O
fseek	function
(	O
index_file	pointer
,	O
sizeof	O
(	O
comb_index_hdr	struct
)	O
+	O
sizeof	O
(	O
comb_index_hdr_ll	struct
)	O
+	O
start_pos	long long
*	O
sizeof	O
(	O
comb_hash_entry_ll	struct
)	O
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_val	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to reposition within index"	pointer
)	O
)	O
;	O
return_val	int
=	O
fread	function
(	O
&	O
index_entry	struct
,	O
sizeof	O
(	O
index_entry	struct
)	O
,	O
1	int
,	O
index_file	pointer
)	O
;	O
if	O
(	O
return_val	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"error reading index file"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
start_pos	long long
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
next	pointer
!=	O
NULL	O
)	O
*	O
next	pointer
=	O
index_entry	struct
.	O
next_same_key	long long
;	O
if	O
(	O
position	pointer
!=	O
NULL	O
)	O
*	O
position	pointer
=	O
index_entry	struct
.	O
file_position	long long
;	O
if	O
(	O
length	long
!=	O
NULL	O
)	O
*	O
length	long
=	O
index_entry	struct
.	O
record_length	long long
;	O
return	O
0	int
;	O
}	O
INDEXNUM	O
insert_index_where_open	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	pointer
,	O
key	pointer
,	O
position	pointer
,	O
length	long
,	O
hash_key	long
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
FILE	struct
*	O
index_file	pointer
;	O
STRINGTYPE	O
*	O
key	pointer
;	O
INDEXNUM	O
position	pointer
;	O
INDEXNUM	O
length	long
;	O
INDEXNUM	O
hash_key	long
;	O
{	O
INDEXNUM	O
start_pos	long long
;	O
INDEXNUM	O
curr_pos	long long
;	O
start_pos	long long
=	O
position	pointer
;	O
curr_pos	long long
=	O
start_pos	long long
+	O
1	int
;	O
while	O
(	O
curr_pos	long long
!=	O
start_pos	long long
)	O
{	O
if	O
(	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
curr_pos	long long
++	O
;	O
curr_pos	long long
%=	O
entries	long long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
insert_index_key	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	pointer
,	O
key	pointer
,	O
position	pointer
,	O
length	long
,	O
hash_key	long
)	O
INDEXNUM	O
entries	long long
;	O
INDEXNUM	O
number_size	long long
;	O
INDEXNUM	O
hash_method	long
;	O
FILE	struct
*	O
index_file	pointer
;	O
STRINGTYPE	O
*	O
key	pointer
;	O
INDEXNUM	O
*	O
position	pointer
;	O
INDEXNUM	O
*	O
length	long
;	O
INDEXNUM	O
*	O
hash_key	long
;	O
{	O
INDEXNUM	O
return_val	int
;	O
INDEXNUM	O
next	pointer
;	O
return_val	int
=	O
find_index_key	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	pointer
,	O
key	pointer
,	O
&	O
next	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
return_val	int
!=	O
-	O
1	int
&&	O
next	pointer
!=	O
-	O
1	int
)	O
return_val	int
=	O
find_index_key	function
(	O
entries	long long
,	O
number_size	long long
,	O
hash_method	long
,	O
index_file	pointer
,	O
key	pointer
,	O
&	O
next	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
return_val	int
==	O
-	O
1	int
)	O
{	O
}	O
else	O
{	O
}	O
}	O
int	O
find_or_create_index_chunk	function
(	O
df_index_base	struct
*	O
*	O
,	O
INDEXNUM	O
*	O
,	O
df_index_base	struct
*	O
*	O
,	O
INDEXNUM	O
*	O
,	O
int	O
,	O
FILE	struct
*	O
*	O
)	O
;	O
int	O
create_index_record_entry	function
(	O
df_index_base	struct
*	O
,	O
INDEXNUM	O
,	O
int	O
,	O
INDEXNUM	O
,	O
INDEXNUM	O
,	O
FILE	struct
*	O
*	O
)	O
;	O
df_index_base	struct
*	O
create_index_chunk	function
(	O
)	O
;	O
df_index_record	struct
*	O
create_index_record	function
(	O
)	O
;	O
df_index_base	struct
*	O
read_index_chunk	function
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
)	O
;	O
df_index_record	struct
*	O
read_index_record	function
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
)	O
;	O
int	O
write_index_chunk	function
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
,	O
df_index_base	struct
*	O
)	O
;	O
int	O
write_index_record	function
(	O
FILE	struct
*	O
*	O
,	O
INDEXNUM	O
,	O
df_index_record	struct
*	O
)	O
;	O
int	O
add_index_record_entry	function
(	O
fields	pointer
,	O
field_count	int
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	pointer
)	O
DStr_string_descriptor	struct
*	O
*	O
fields	pointer
;	O
int	O
field_count	int
;	O
INDEXNUM	O
data_file_position	long long
;	O
INDEXNUM	O
data_record_length	long long
;	O
FILE	struct
*	O
*	O
streams	pointer
;	O
{	O
int	O
i	long long
;	O
int	O
j	int
;	O
int	O
return_code	int
;	O
int	O
string_loop_limit	int
;	O
df_index_base	struct
*	O
prev_index_node	pointer
;	O
df_index_base	struct
*	O
curr_index_node	pointer
;	O
INDEXNUM	O
prev_position	long long
;	O
INDEXNUM	O
curr_position	long long
;	O
curr_index_node	pointer
=	O
read_index_chunk	function
(	O
streams	pointer
,	O
0	int
)	O
;	O
if	O
(	O
curr_index_node	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
prev_index_node	pointer
=	O
NULL	O
;	O
prev_position	long long
=	O
0	int
;	O
curr_position	long long
=	O
0	int
;	O
for	O
(	O
i	long long
=	O
0	int
;	O
i	long long
<	O
field_count	int
;	O
i	long long
++	O
)	O
{	O
if	O
(	O
fields	pointer
[	O
i	long long
]	O
->	O
length	long
==	O
0	int
&&	O
i	long long
<	O
field_count	int
-	O
1	int
)	O
{	O
return_code	int
=	O
find_or_create_index_chunk	function
(	O
&	O
prev_index_node	pointer
,	O
&	O
prev_position	long long
,	O
&	O
curr_index_node	pointer
,	O
&	O
curr_position	long long
,	O
INDEX_ATOM	int
-	O
2	int
,	O
streams	pointer
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
{	O
if	O
(	O
prev_index_node	pointer
!=	O
NULL	O
)	O
free	function
(	O
prev_index_node	pointer
)	O
;	O
if	O
(	O
curr_index_node	pointer
!=	O
NULL	O
&&	O
curr_index_node	pointer
!=	O
prev_index_node	pointer
)	O
free	function
(	O
curr_index_node	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
string_loop_limit	int
=	O
fields	pointer
[	O
i	long long
]	O
->	O
length	long
;	O
if	O
(	O
i	long long
==	O
field_count	int
-	O
1	int
)	O
string_loop_limit	int
--	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
string_loop_limit	int
;	O
j	int
++	O
)	O
{	O
return_code	int
=	O
find_or_create_index_chunk	function
(	O
&	O
prev_index_node	pointer
,	O
&	O
prev_position	long long
,	O
&	O
curr_index_node	pointer
,	O
&	O
curr_position	long long
,	O
fields	pointer
[	O
i	long long
]	O
->	O
string	pointer
[	O
j	int
]	O
,	O
streams	pointer
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
{	O
if	O
(	O
prev_index_node	pointer
!=	O
NULL	O
)	O
free	function
(	O
prev_index_node	pointer
)	O
;	O
if	O
(	O
curr_index_node	pointer
!=	O
NULL	O
&&	O
curr_index_node	pointer
!=	O
prev_index_node	pointer
)	O
free	function
(	O
curr_index_node	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
i	long long
<	O
field_count	int
-	O
1	int
)	O
{	O
return_code	int
=	O
find_or_create_index_chunk	function
(	O
&	O
prev_index_node	pointer
,	O
&	O
prev_position	long long
,	O
&	O
curr_index_node	pointer
,	O
&	O
curr_position	long long
,	O
INDEX_ATOM	int
-	O
1	int
,	O
streams	pointer
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
{	O
if	O
(	O
prev_index_node	pointer
!=	O
NULL	O
)	O
free	function
(	O
prev_index_node	pointer
)	O
;	O
if	O
(	O
curr_index_node	pointer
!=	O
NULL	O
&&	O
curr_index_node	pointer
!=	O
prev_index_node	pointer
)	O
free	function
(	O
curr_index_node	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
if	O
(	O
fields	pointer
[	O
field_count	int
-	O
1	int
]	O
->	O
length	long
==	O
0	int
)	O
return_code	int
=	O
create_index_record_entry	function
(	O
curr_index_node	pointer
,	O
curr_position	long long
,	O
INDEX_ATOM	int
-	O
2	int
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	pointer
)	O
;	O
else	O
return_code	int
=	O
create_index_record_entry	function
(	O
curr_index_node	pointer
,	O
curr_position	long long
,	O
fields	pointer
[	O
field_count	int
-	O
1	int
]	O
->	O
string	pointer
[	O
fields	pointer
[	O
field_count	int
-	O
1	int
]	O
->	O
length	long
-	O
1	int
]	O
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	pointer
)	O
;	O
if	O
(	O
return_code	int
==	O
EXIT_FAILURE	int
)	O
return	O
EXIT_FAILURE	int
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
find_or_create_index_chunk	function
(	O
prev_index_node	pointer
,	O
prev_position	long long
,	O
curr_index_node	pointer
,	O
curr_position	long long
,	O
index_value	int
,	O
streams	pointer
)	O
df_index_base	struct
*	O
*	O
prev_index_node	pointer
;	O
INDEXNUM	O
*	O
prev_position	long long
;	O
df_index_base	struct
*	O
*	O
curr_index_node	pointer
;	O
INDEXNUM	O
*	O
curr_position	long long
;	O
int	O
index_value	int
;	O
FILE	struct
*	O
*	O
streams	pointer
;	O
{	O
INDEXNUM	O
next_position	long long
;	O
if	O
(	O
*	O
prev_index_node	pointer
!=	O
NULL	O
)	O
free	function
(	O
*	O
prev_index_node	pointer
)	O
;	O
*	O
prev_index_node	pointer
=	O
*	O
curr_index_node	pointer
;	O
*	O
prev_position	long long
=	O
*	O
curr_position	long long
;	O
*	O
curr_position	long long
=	O
(	O
*	O
curr_index_node	pointer
)	O
[	O
index_value	int
]	O
.	O
key_continuation	long long
;	O
if	O
(	O
*	O
curr_position	long long
==	O
0	int
)	O
{	O
*	O
curr_index_node	pointer
=	O
create_index_chunk	function
(	O
)	O
;	O
if	O
(	O
*	O
curr_index_node	pointer
==	O
NULL	O
)	O
{	O
return	O
EXIT_FAILURE	int
;	O
}	O
(	O
*	O
curr_index_node	pointer
)	O
->	O
key_previous	long long
=	O
*	O
prev_position	long long
;	O
*	O
curr_position	long long
=	O
write_index_chunk	function
(	O
streams	pointer
,	O
-	O
1	int
,	O
*	O
curr_index_node	pointer
)	O
;	O
if	O
(	O
*	O
curr_position	long long
==	O
-	O
1	int
)	O
return	O
EXIT_FAILURE	int
;	O
(	O
*	O
prev_index_node	pointer
)	O
[	O
index_value	int
]	O
.	O
key_continuation	long long
=	O
*	O
curr_position	long long
;	O
next_position	long long
=	O
write_index_chunk	function
(	O
streams	pointer
,	O
*	O
prev_position	long long
,	O
*	O
prev_index_node	pointer
)	O
;	O
if	O
(	O
next_position	long long
==	O
-	O
1	int
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
*	O
curr_index_node	pointer
=	O
read_index_chunk	function
(	O
streams	pointer
,	O
*	O
curr_position	long long
)	O
;	O
if	O
(	O
*	O
curr_index_node	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
create_index_record_entry	function
(	O
chunk	pointer
,	O
chunk_position	long long
,	O
key_position	long long
,	O
data_file_position	long long
,	O
data_record_length	long long
,	O
streams	pointer
)	O
df_index_base	struct
*	O
chunk	pointer
;	O
INDEXNUM	O
chunk_position	long long
;	O
int	O
key_position	long long
;	O
INDEXNUM	O
data_file_position	long long
;	O
INDEXNUM	O
data_record_length	long long
;	O
FILE	struct
*	O
*	O
streams	pointer
;	O
{	O
long	O
prev_record_position	long
;	O
long	O
curr_record_position	long
;	O
long	O
new_record_position	long
;	O
long	O
result_position	long
;	O
df_index_record	struct
*	O
curr_record_entry	pointer
;	O
df_index_record	struct
*	O
new_record_entry	pointer
;	O
new_record_entry	pointer
=	O
create_index_record	function
(	O
)	O
;	O
if	O
(	O
new_record_entry	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
new_record_entry	pointer
->	O
file_position	long long
=	O
data_file_position	long long
;	O
new_record_entry	pointer
->	O
record_length	long long
=	O
data_record_length	long long
;	O
new_record_position	long
=	O
write_index_record	function
(	O
streams	pointer
,	O
-	O
1	int
,	O
new_record_entry	pointer
)	O
;	O
if	O
(	O
new_record_position	long
==	O
-	O
1	int
)	O
{	O
free	function
(	O
new_record_entry	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
chunk	pointer
[	O
key_position	long long
]	O
.	O
first_record	long long
==	O
0	int
)	O
{	O
chunk	pointer
[	O
key_position	long long
]	O
.	O
first_record	long long
=	O
new_record_position	long
;	O
write_index_chunk	function
(	O
streams	pointer
,	O
chunk_position	long long
,	O
chunk	pointer
)	O
;	O
}	O
else	O
{	O
prev_record_position	long
=	O
0	int
;	O
curr_record_position	long
=	O
chunk	pointer
[	O
key_position	long long
]	O
.	O
first_record	long long
;	O
curr_record_entry	pointer
=	O
NULL	O
;	O
while	O
(	O
curr_record_position	long
!=	O
0	int
)	O
{	O
prev_record_position	long
=	O
curr_record_position	long
;	O
if	O
(	O
curr_record_entry	pointer
!=	O
NULL	O
)	O
free	function
(	O
curr_record_entry	pointer
)	O
;	O
curr_record_entry	pointer
=	O
read_index_record	function
(	O
streams	pointer
,	O
curr_record_position	long
)	O
;	O
if	O
(	O
curr_record_entry	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
curr_record_position	long
=	O
curr_record_entry	pointer
->	O
next_same_key	long long
;	O
}	O
new_record_entry	pointer
->	O
prev_same_key	long long
=	O
prev_record_position	long
;	O
curr_record_entry	pointer
->	O
next_same_key	long long
=	O
new_record_position	long
;	O
result_position	long
=	O
write_index_record	function
(	O
streams	pointer
,	O
new_record_position	long
,	O
new_record_entry	pointer
)	O
;	O
if	O
(	O
result_position	long
!=	O
new_record_position	long
)	O
return	O
EXIT_FAILURE	int
;	O
result_position	long
=	O
write_index_record	function
(	O
streams	pointer
,	O
prev_record_position	long
,	O
curr_record_entry	pointer
)	O
;	O
if	O
(	O
result_position	long
!=	O
prev_record_position	long
)	O
return	O
EXIT_FAILURE	int
;	O
free	function
(	O
curr_record_entry	pointer
)	O
;	O
free	function
(	O
new_record_entry	pointer
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
df_index_base	struct
*	O
create_index_chunk	function
(	O
)	O
{	O
df_index_base	struct
*	O
return_array	pointer
;	O
int	O
i	long long
;	O
return_array	pointer
=	O
malloc	function
(	O
INDEX_ATOM	int
*	O
sizeof	O
(	O
df_index_base	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
bzero	function
(	O
return_array	pointer
,	O
INDEX_ATOM	int
*	O
sizeof	O
(	O
df_index_base	struct
)	O
)	O
;	O
for	O
(	O
i	long long
=	O
0	int
;	O
i	long long
<	O
256	int
;	O
i	long long
++	O
)	O
return_array	pointer
[	O
i	long long
]	O
.	O
byte_value	char
=	O
i	long long
;	O
return	O
return_array	pointer
;	O
}	O
df_index_record	struct
*	O
create_index_record	function
(	O
)	O
{	O
df_index_record	struct
*	O
return_record	pointer
;	O
return_record	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
df_index_record	struct
)	O
)	O
;	O
if	O
(	O
return_record	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
bzero	function
(	O
return_record	pointer
,	O
sizeof	O
(	O
df_index_record	struct
)	O
)	O
;	O
return	O
return_record	pointer
;	O
}	O
int	O
open_index_file	function
(	O
filename	pointer
,	O
streams	pointer
,	O
new	int
)	O
char	O
*	O
filename	pointer
;	O
FILE	struct
*	O
*	O
streams	pointer
;	O
int	O
new	int
;	O
{	O
char	O
*	O
index_base_file_name	pointer
;	O
char	O
*	O
index_record_file_name	pointer
;	O
int	O
return_code	int
;	O
index_base_file_name	pointer
=	O
malloc	function
(	O
strlen	function
(	O
filename	pointer
)	O
+	O
4	int
)	O
;	O
if	O
(	O
index_base_file_name	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
sprintf	function
(	O
index_base_file_name	pointer
,	O
"%s.ib"	pointer
,	O
filename	pointer
)	O
;	O
streams	pointer
[	O
0	int
]	O
=	O
fopen	function
(	O
index_base_file_name	pointer
,	O
"a+"	pointer
)	O
;	O
if	O
(	O
streams	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
perror	function
(	O
index_base_file_name	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
new	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
truncate	function
(	O
index_base_file_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
index_base_file_name	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
free	function
(	O
index_base_file_name	pointer
)	O
;	O
index_record_file_name	pointer
=	O
malloc	function
(	O
strlen	function
(	O
filename	pointer
)	O
+	O
4	int
)	O
;	O
if	O
(	O
index_record_file_name	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
sprintf	function
(	O
index_record_file_name	pointer
,	O
"%s.ir"	pointer
,	O
filename	pointer
)	O
;	O
streams	pointer
[	O
1	int
]	O
=	O
fopen	function
(	O
index_record_file_name	pointer
,	O
"a+"	pointer
)	O
;	O
if	O
(	O
streams	pointer
[	O
1	int
]	O
==	O
NULL	O
)	O
{	O
perror	function
(	O
index_record_file_name	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
new	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
truncate	function
(	O
index_record_file_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
index_record_file_name	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
free	function
(	O
index_record_file_name	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
initialize_index_file	function
(	O
streams	pointer
)	O
FILE	struct
*	O
*	O
streams	pointer
;	O
{	O
df_index_base	struct
*	O
initial_chunk	pointer
;	O
int	O
return_code	int
;	O
initial_chunk	pointer
=	O
create_index_chunk	function
(	O
)	O
;	O
if	O
(	O
initial_chunk	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
return_code	int
=	O
write_index_chunk	function
(	O
streams	pointer
,	O
0	int
,	O
initial_chunk	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
return	O
EXIT_FAILURE	int
;	O
free	function
(	O
initial_chunk	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
close_index_file	function
(	O
streams	pointer
)	O
FILE	struct
*	O
*	O
streams	pointer
;	O
{	O
int	O
return_code	int
;	O
return_code	int
=	O
fclose	function
(	O
streams	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
NULL	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
return_code	int
=	O
fclose	function
(	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
NULL	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
df_index_base	struct
*	O
read_index_chunk	function
(	O
streams	pointer
,	O
position	pointer
)	O
FILE	struct
*	O
*	O
streams	pointer
;	O
INDEXNUM	O
position	pointer
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
df_index_base	struct
*	O
return_array	pointer
;	O
long_position	long
=	O
position	pointer
;	O
return_code	int
=	O
fseek	function
(	O
streams	pointer
[	O
0	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index base file"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return_array	pointer
=	O
malloc	function
(	O
INDEX_ATOM	int
*	O
sizeof	O
(	O
df_index_base	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return_code	int
=	O
fread	function
(	O
return_array	pointer
,	O
sizeof	O
(	O
df_index_base	struct
)	O
,	O
INDEX_ATOM	int
,	O
streams	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
INDEX_ATOM	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index base file"	pointer
)	O
)	O
;	O
free	function
(	O
return_array	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
return_array	pointer
;	O
}	O
df_index_record	struct
*	O
read_index_record	function
(	O
streams	pointer
,	O
position	pointer
)	O
FILE	struct
*	O
*	O
streams	pointer
;	O
INDEXNUM	O
position	pointer
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
df_index_record	struct
*	O
return_record	pointer
;	O
long_position	long
=	O
position	pointer
;	O
return_code	int
=	O
fseek	function
(	O
streams	pointer
[	O
1	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index record file"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return_record	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
df_index_record	struct
)	O
)	O
;	O
if	O
(	O
return_record	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return_code	int
=	O
fread	function
(	O
return_record	pointer
,	O
sizeof	O
(	O
df_index_record	struct
)	O
,	O
1	int
,	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
1	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index record file"	pointer
)	O
)	O
;	O
free	function
(	O
return_record	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
return_record	pointer
;	O
}	O
int	O
write_index_chunk	function
(	O
streams	pointer
,	O
position	pointer
,	O
chunk	pointer
)	O
FILE	struct
*	O
*	O
streams	pointer
;	O
INDEXNUM	O
position	pointer
;	O
df_index_base	struct
*	O
chunk	pointer
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
long	O
new_position	long
;	O
long_position	long
=	O
position	pointer
;	O
if	O
(	O
long_position	long
>=	O
0	int
)	O
return_code	int
=	O
fseek	function
(	O
streams	pointer
[	O
0	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
else	O
return_code	int
=	O
fseek	function
(	O
streams	pointer
[	O
0	int
]	O
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index base file"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
new_position	long
=	O
ftell	function
(	O
streams	pointer
[	O
0	int
]	O
)	O
;	O
return_code	int
=	O
fwrite	function
(	O
chunk	pointer
,	O
sizeof	O
(	O
df_index_base	struct
)	O
,	O
INDEX_ATOM	int
,	O
streams	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
INDEX_ATOM	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index base file"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
new_position	long
;	O
}	O
int	O
write_index_record	function
(	O
streams	pointer
,	O
position	pointer
,	O
record	pointer
)	O
FILE	struct
*	O
*	O
streams	pointer
;	O
INDEXNUM	O
position	pointer
;	O
df_index_record	struct
*	O
record	pointer
;	O
{	O
int	O
return_code	int
;	O
long	O
long_position	long
;	O
long	O
new_position	long
;	O
long_position	long
=	O
position	pointer
;	O
if	O
(	O
long_position	long
>	O
0	int
)	O
return_code	int
=	O
fseek	function
(	O
streams	pointer
[	O
1	int
]	O
,	O
long_position	long
,	O
SEEK_SET	int
)	O
;	O
else	O
return_code	int
=	O
fseek	function
(	O
streams	pointer
[	O
1	int
]	O
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index record file"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
new_position	long
=	O
ftell	function
(	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
return_code	int
=	O
fwrite	function
(	O
record	pointer
,	O
sizeof	O
(	O
df_index_record	struct
)	O
,	O
1	int
,	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
return_code	int
!=	O
1	int
)	O
{	O
perror	function
(	O
_	O
(	O
"index record file"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
new_position	long
;	O
}	O
