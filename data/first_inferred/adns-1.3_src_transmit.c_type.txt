static	O
adns_status	enum
mkquery_header	function
(	O
adns_state	pointer
ads	pointer
,	O
vbuf	struct
*	O
vb	pointer
,	O
int	O
*	O
id_r	pointer
,	O
int	O
qdlen	int
)	O
{	O
int	O
id	int
;	O
byte	char
*	O
rqp	pointer
;	O
if	O
(	O
!	O
adns__vbuf_ensure	function
(	O
vb	pointer
,	O
DNS_HDRSIZE	int
+	O
qdlen	int
+	O
4	int
)	O
)	O
return	O
adns_s_nomemory	int
;	O
vb	pointer
->	O
used	int
=	O
0	int
;	O
MKQUERY_START	O
(	O
vb	pointer
)	O
;	O
*	O
id_r	pointer
=	O
id	int
=	O
(	O
ads	pointer
->	O
nextid	int
++	O
)	O
&	O
0x0ffff	int
;	O
MKQUERY_ADDW	O
(	O
id	int
)	O
;	O
MKQUERY_ADDB	O
(	O
0x01	int
)	O
;	O
MKQUERY_ADDB	O
(	O
0x00	int
)	O
;	O
MKQUERY_ADDW	O
(	O
1	int
)	O
;	O
MKQUERY_ADDW	O
(	O
0	int
)	O
;	O
MKQUERY_ADDW	O
(	O
0	int
)	O
;	O
MKQUERY_ADDW	O
(	O
0	int
)	O
;	O
MKQUERY_STOP	O
(	O
vb	pointer
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
mkquery_footer	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
adns_rrtype	enum
type	enum
)	O
{	O
byte	char
*	O
rqp	pointer
;	O
MKQUERY_START	O
(	O
vb	pointer
)	O
;	O
MKQUERY_ADDW	O
(	O
type	enum
&	O
adns_rrt_typemask	int
)	O
;	O
MKQUERY_ADDW	O
(	O
DNS_CLASS_IN	int
)	O
;	O
MKQUERY_STOP	O
(	O
vb	pointer
)	O
;	O
assert	O
(	O
vb	pointer
->	O
used	int
<=	O
vb	pointer
->	O
avail	int
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
adns_status	enum
adns__qdpl_normal	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
char	O
*	O
*	O
p_io	pointer
,	O
const	O
char	O
*	O
pe	pointer
,	O
int	O
labelnum	int
,	O
char	O
label_r	array
[	O
]	O
,	O
int	O
*	O
ll_io	pointer
,	O
adns_queryflags	enum
flags	enum
,	O
const	O
typeinfo	struct
*	O
typei	pointer
)	O
{	O
int	O
ll	int
,	O
c	int
;	O
const	O
char	O
*	O
p	pointer
;	O
ll	int
=	O
0	int
;	O
p	pointer
=	O
*	O
p_io	pointer
;	O
while	O
(	O
p	pointer
!=	O
pe	pointer
&&	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
!=	O
'.'	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
!	O
(	O
flags	enum
&	O
adns_qf_quoteok_query	int
)	O
)	O
return	O
adns_s_querydomaininvalid	int
;	O
if	O
(	O
ctype_digit	function
(	O
p	pointer
[	O
0	int
]	O
)	O
)	O
{	O
if	O
(	O
p	pointer
+	O
1	int
==	O
pe	pointer
||	O
p	pointer
+	O
2	int
==	O
pe	pointer
)	O
return	O
adns_s_querydomaininvalid	int
;	O
if	O
(	O
ctype_digit	function
(	O
p	pointer
[	O
1	int
]	O
)	O
&&	O
ctype_digit	function
(	O
p	pointer
[	O
2	int
]	O
)	O
)	O
{	O
c	int
=	O
(	O
*	O
p	pointer
++	O
-	O
'0'	O
)	O
*	O
100	int
;	O
c	int
+=	O
(	O
*	O
p	pointer
++	O
-	O
'0'	O
)	O
*	O
10	int
;	O
c	int
+=	O
(	O
*	O
p	pointer
++	O
-	O
'0'	O
)	O
;	O
if	O
(	O
c	int
>=	O
256	int
)	O
return	O
adns_s_querydomaininvalid	int
;	O
}	O
else	O
{	O
return	O
adns_s_querydomaininvalid	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
)	O
{	O
return	O
adns_s_querydomaininvalid	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
flags	enum
&	O
adns_qf_quoteok_query	int
)	O
)	O
{	O
if	O
(	O
c	int
==	O
'-'	O
)	O
{	O
if	O
(	O
!	O
ll	int
)	O
return	O
adns_s_querydomaininvalid	int
;	O
}	O
else	O
if	O
(	O
!	O
ctype_alpha	function
(	O
c	int
)	O
&&	O
!	O
ctype_digit	function
(	O
c	int
)	O
)	O
{	O
return	O
adns_s_querydomaininvalid	int
;	O
}	O
}	O
if	O
(	O
ll	int
==	O
*	O
ll_io	pointer
)	O
return	O
adns_s_querydomaininvalid	int
;	O
label_r	array
[	O
ll	int
++	O
]	O
=	O
c	int
;	O
}	O
*	O
p_io	pointer
=	O
p	pointer
;	O
*	O
ll_io	pointer
=	O
ll	int
;	O
return	O
adns_s_ok	int
;	O
}	O
adns_status	enum
adns__mkquery	function
(	O
adns_state	pointer
ads	pointer
,	O
vbuf	struct
*	O
vb	pointer
,	O
int	O
*	O
id_r	pointer
,	O
const	O
char	O
*	O
owner	pointer
,	O
int	O
ol	int
,	O
const	O
typeinfo	struct
*	O
typei	pointer
,	O
adns_rrtype	enum
type	enum
,	O
adns_queryflags	enum
flags	enum
)	O
{	O
int	O
labelnum	int
,	O
ll	int
,	O
nbytes	int
;	O
byte	char
label	array
[	O
255	int
]	O
;	O
byte	char
*	O
rqp	pointer
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
pe	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
mkquery_header	function
(	O
ads	pointer
,	O
vb	pointer
,	O
id_r	pointer
,	O
ol	int
+	O
2	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
MKQUERY_START	O
(	O
vb	pointer
)	O
;	O
p	pointer
=	O
owner	pointer
;	O
pe	pointer
=	O
owner	pointer
+	O
ol	int
;	O
nbytes	int
=	O
0	int
;	O
labelnum	int
=	O
0	int
;	O
while	O
(	O
p	pointer
!=	O
pe	pointer
)	O
{	O
ll	int
=	O
sizeof	O
(	O
label	array
)	O
;	O
st	enum
=	O
typei	pointer
->	O
qdparselabel	pointer
(	O
ads	pointer
,	O
&	O
p	pointer
,	O
pe	pointer
,	O
labelnum	int
++	O
,	O
label	array
,	O
&	O
ll	int
,	O
flags	enum
,	O
typei	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
!	O
ll	int
)	O
return	O
adns_s_querydomaininvalid	int
;	O
if	O
(	O
ll	int
>	O
DNS_MAXLABEL	int
)	O
return	O
adns_s_querydomaintoolong	int
;	O
nbytes	int
+=	O
ll	int
+	O
1	int
;	O
if	O
(	O
nbytes	int
>=	O
DNS_MAXDOMAIN	int
)	O
return	O
adns_s_querydomaintoolong	int
;	O
MKQUERY_ADDB	O
(	O
ll	int
)	O
;	O
memcpy	function
(	O
rqp	pointer
,	O
label	array
,	O
ll	int
)	O
;	O
rqp	pointer
+=	O
ll	int
;	O
}	O
MKQUERY_ADDB	O
(	O
0	int
)	O
;	O
MKQUERY_STOP	O
(	O
vb	pointer
)	O
;	O
st	enum
=	O
mkquery_footer	function
(	O
vb	pointer
,	O
type	enum
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
adns_status	enum
adns__mkquery_frdgram	function
(	O
adns_state	pointer
ads	pointer
,	O
vbuf	struct
*	O
vb	pointer
,	O
int	O
*	O
id_r	pointer
,	O
const	O
byte	char
*	O
qd_dgram	pointer
,	O
int	O
qd_dglen	int
,	O
int	O
qd_begin	int
,	O
adns_rrtype	enum
type	enum
,	O
adns_queryflags	enum
flags	enum
)	O
{	O
byte	char
*	O
rqp	pointer
;	O
findlabel_state	struct
fls	pointer
;	O
int	O
lablen	int
,	O
labstart	int
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
mkquery_header	function
(	O
ads	pointer
,	O
vb	pointer
,	O
id_r	pointer
,	O
qd_dglen	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
MKQUERY_START	O
(	O
vb	pointer
)	O
;	O
adns__findlabel_start	function
(	O
&	O
fls	pointer
,	O
ads	pointer
,	O
-	O
1	int
,	O
0	int
,	O
qd_dgram	pointer
,	O
qd_dglen	int
,	O
qd_dglen	int
,	O
qd_begin	int
,	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
st	enum
=	O
adns__findlabel_next	function
(	O
&	O
fls	pointer
,	O
&	O
lablen	int
,	O
&	O
labstart	int
)	O
;	O
assert	O
(	O
!	O
st	enum
)	O
;	O
if	O
(	O
!	O
lablen	int
)	O
break	O
;	O
assert	O
(	O
lablen	int
<	O
255	int
)	O
;	O
MKQUERY_ADDB	O
(	O
lablen	int
)	O
;	O
memcpy	function
(	O
rqp	pointer
,	O
qd_dgram	pointer
+	O
labstart	int
,	O
lablen	int
)	O
;	O
rqp	pointer
+=	O
lablen	int
;	O
}	O
MKQUERY_ADDB	O
(	O
0	int
)	O
;	O
MKQUERY_STOP	O
(	O
vb	pointer
)	O
;	O
st	enum
=	O
mkquery_footer	function
(	O
vb	pointer
,	O
type	enum
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
void	O
adns__querysend_tcp	function
(	O
adns_query	pointer
qu	pointer
,	O
struct	O
timeval	struct
now	pointer
)	O
{	O
byte	char
length	array
[	O
2	int
]	O
;	O
struct	O
iovec	struct
iov	array
[	O
2	int
]	O
;	O
int	O
wr	int
,	O
r	int
;	O
adns_state	pointer
ads	pointer
;	O
if	O
(	O
qu	pointer
->	O
ads	pointer
->	O
tcpstate	enum
!=	O
server_ok	int
)	O
return	O
;	O
assert	O
(	O
qu	pointer
->	O
state	pointer
==	O
query_tcpw	int
)	O
;	O
length	array
[	O
0	int
]	O
=	O
(	O
qu	pointer
->	O
query_dglen	int
&	O
0x0ff00U	int
)	O
>>	O
8	int
;	O
length	array
[	O
1	int
]	O
=	O
(	O
qu	pointer
->	O
query_dglen	int
&	O
0x0ff	int
)	O
;	O
ads	pointer
=	O
qu	pointer
->	O
ads	pointer
;	O
if	O
(	O
!	O
adns__vbuf_ensure	function
(	O
&	O
ads	pointer
->	O
tcpsend	struct
,	O
ads	pointer
->	O
tcpsend	struct
.	O
used	int
+	O
qu	pointer
->	O
query_dglen	int
+	O
2	int
)	O
)	O
return	O
;	O
qu	pointer
->	O
retries	int
++	O
;	O
ads	pointer
->	O
tcptimeout	struct
.	O
tv_sec	long
=	O
ads	pointer
->	O
tcptimeout	struct
.	O
tv_usec	long
=	O
0	int
;	O
if	O
(	O
ads	pointer
->	O
tcpsend	struct
.	O
used	int
)	O
{	O
wr	int
=	O
0	int
;	O
}	O
else	O
{	O
iov	array
[	O
0	int
]	O
.	O
iov_base	pointer
=	O
length	array
;	O
iov	array
[	O
0	int
]	O
.	O
iov_len	long
=	O
2	int
;	O
iov	array
[	O
1	int
]	O
.	O
iov_base	pointer
=	O
qu	pointer
->	O
query_dgram	pointer
;	O
iov	array
[	O
1	int
]	O
.	O
iov_len	long
=	O
qu	pointer
->	O
query_dglen	int
;	O
adns__sigpipe_protect	function
(	O
qu	pointer
->	O
ads	pointer
)	O
;	O
wr	int
=	O
writev	function
(	O
qu	pointer
->	O
ads	pointer
->	O
tcpsocket	int
,	O
iov	array
,	O
2	int
)	O
;	O
adns__sigpipe_unprotect	function
(	O
qu	pointer
->	O
ads	pointer
)	O
;	O
if	O
(	O
wr	int
<	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
errno	O
==	O
EAGAIN	int
||	O
errno	O
==	O
EINTR	int
||	O
errno	O
==	O
ENOSPC	int
||	O
errno	O
==	O
ENOBUFS	int
||	O
errno	O
==	O
ENOMEM	int
)	O
)	O
{	O
adns__tcp_broken	function
(	O
ads	pointer
,	O
"write"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
wr	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
wr	int
<	O
2	int
)	O
{	O
r	int
=	O
adns__vbuf_append	function
(	O
&	O
ads	pointer
->	O
tcpsend	struct
,	O
length	array
,	O
2	int
-	O
wr	int
)	O
;	O
assert	O
(	O
r	int
)	O
;	O
wr	int
=	O
0	int
;	O
}	O
else	O
{	O
wr	int
-=	O
2	int
;	O
}	O
if	O
(	O
wr	int
<	O
qu	pointer
->	O
query_dglen	int
)	O
{	O
r	int
=	O
adns__vbuf_append	function
(	O
&	O
ads	pointer
->	O
tcpsend	struct
,	O
qu	pointer
->	O
query_dgram	pointer
+	O
wr	int
,	O
qu	pointer
->	O
query_dglen	int
-	O
wr	int
)	O
;	O
assert	O
(	O
r	int
)	O
;	O
}	O
}	O
static	O
void	O
query_usetcp	function
(	O
adns_query	pointer
qu	pointer
,	O
struct	O
timeval	struct
now	pointer
)	O
{	O
qu	pointer
->	O
state	pointer
=	O
query_tcpw	int
;	O
qu	pointer
->	O
timeout	struct
=	O
now	pointer
;	O
timevaladd	function
(	O
&	O
qu	pointer
->	O
timeout	struct
,	O
TCPWAITMS	int
)	O
;	O
LIST_LINK_TAIL	O
(	O
qu	pointer
->	O
ads	pointer
->	O
tcpw	struct
,	O
qu	pointer
)	O
;	O
adns__querysend_tcp	function
(	O
qu	pointer
,	O
now	pointer
)	O
;	O
adns__tcp_tryconnect	function
(	O
qu	pointer
->	O
ads	pointer
,	O
now	pointer
)	O
;	O
}	O
void	O
adns__query_send	function
(	O
adns_query	pointer
qu	pointer
,	O
struct	O
timeval	struct
now	pointer
)	O
{	O
struct	O
sockaddr_in	struct
servaddr	struct
;	O
int	O
serv	int
,	O
r	int
;	O
adns_state	pointer
ads	pointer
;	O
assert	O
(	O
qu	pointer
->	O
state	pointer
==	O
query_tosend	int
)	O
;	O
if	O
(	O
(	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_usevc	int
)	O
||	O
(	O
qu	pointer
->	O
query_dglen	int
>	O
DNS_MAXUDP	int
)	O
)	O
{	O
query_usetcp	function
(	O
qu	pointer
,	O
now	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
qu	pointer
->	O
retries	int
>=	O
UDPMAXRETRIES	int
)	O
{	O
adns__query_fail	function
(	O
qu	pointer
,	O
adns_s_timeout	int
)	O
;	O
return	O
;	O
}	O
serv	int
=	O
qu	pointer
->	O
udpnextserver	int
;	O
memset	function
(	O
&	O
servaddr	struct
,	O
0	int
,	O
sizeof	O
(	O
servaddr	struct
)	O
)	O
;	O
ads	pointer
=	O
qu	pointer
->	O
ads	pointer
;	O
servaddr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
servaddr	struct
.	O
sin_addr	struct
=	O
ads	pointer
->	O
servers	array
[	O
serv	int
]	O
.	O
addr	union
;	O
servaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
DNS_PORT	int
)	O
;	O
r	int
=	O
sendto	function
(	O
ads	pointer
->	O
udpsocket	int
,	O
qu	pointer
->	O
query_dgram	pointer
,	O
qu	pointer
->	O
query_dglen	int
,	O
0	int
,	O
(	O
const	O
struct	O
sockaddr	struct
*	O
)	O
&	O
servaddr	struct
,	O
sizeof	O
(	O
servaddr	struct
)	O
)	O
;	O
if	O
(	O
r	int
<	O
0	int
&&	O
errno	O
==	O
EMSGSIZE	int
)	O
{	O
qu	pointer
->	O
retries	int
=	O
0	int
;	O
query_usetcp	function
(	O
qu	pointer
,	O
now	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
r	int
<	O
0	int
&&	O
errno	O
!=	O
EAGAIN	int
)	O
adns__warn	function
(	O
ads	pointer
,	O
serv	int
,	O
0	int
,	O
"sendto failed: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
qu	pointer
->	O
timeout	struct
=	O
now	pointer
;	O
timevaladd	function
(	O
&	O
qu	pointer
->	O
timeout	struct
,	O
UDPRETRYMS	int
)	O
;	O
qu	pointer
->	O
udpsent	long
|=	O
(	O
1	int
<<	O
serv	int
)	O
;	O
qu	pointer
->	O
udpnextserver	int
=	O
(	O
serv	int
+	O
1	int
)	O
%	O
ads	pointer
->	O
nservers	int
;	O
qu	pointer
->	O
retries	int
++	O
;	O
LIST_LINK_TAIL	O
(	O
ads	pointer
->	O
udpw	struct
,	O
qu	pointer
)	O
;	O
}	O
