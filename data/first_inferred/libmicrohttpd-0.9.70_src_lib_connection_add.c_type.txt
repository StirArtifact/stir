static	O
void	O
thread_main_connection_upgrade	function
(	O
struct	O
MHD_Connection	struct
*	O
con	pointer
)	O
{	O
MHD_connection_finish_forward_	function
(	O
con	pointer
)	O
;	O
}	O
static	O
MHD_THRD_RTRN_TYPE_	O
MHD_THRD_CALL_SPEC_	O
thread_main_handle_connection	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
MHD_Connection	struct
*	O
con	pointer
=	O
data	pointer
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
con	pointer
->	O
daemon	function
;	O
int	O
num_ready	int
;	O
fd_set	struct
rs	struct
;	O
fd_set	struct
ws	struct
;	O
fd_set	struct
es	struct
;	O
MHD_socket	int
maxsock	int
;	O
struct	O
timeval	struct
tv	struct
;	O
struct	O
timeval	struct
*	O
tvp	pointer
;	O
time_t	long
now	long
;	O
struct	O
pollfd	struct
p	array
[	O
1	int
+	O
EXTRA_SLOTS	int
]	O
;	O
const	O
bool	bool
use_poll	bool
=	O
(	O
MHD_ELS_POLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
;	O
bool	bool
was_suspended	bool
=	O
false	int
;	O
MHD_thread_init_	O
(	O
&	O
con	pointer
->	O
pid	int
)	O
;	O
while	O
(	O
(	O
!	O
daemon	function
->	O
shutdown	function
)	O
&&	O
(	O
MHD_REQUEST_CLOSED	int
!=	O
con	pointer
->	O
request	pointer
.	O
state	pointer
)	O
)	O
{	O
const	O
time_t	long
timeout	pointer
=	O
daemon	function
->	O
connection_default_timeout	long
;	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
const	O
urh	pointer
=	O
con	pointer
->	O
request	pointer
.	O
urh	pointer
;	O
if	O
(	O
(	O
con	pointer
->	O
suspended	enum
)	O
&&	O
(	O
NULL	O
==	O
urh	pointer
)	O
)	O
{	O
was_suspended	bool
=	O
true	int
;	O
if	O
(	O
!	O
use_poll	bool
)	O
{	O
FD_ZERO	O
(	O
&	O
rs	struct
)	O
;	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
,	O
&	O
rs	struct
,	O
NULL	O
,	O
FD_SETSIZE	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
MHD_SC_SOCKET_OUTSIDE_OF_FDSET_RANGE	int
,	O
_	O
(	O
"Failed to add FD to fd_set\n"	pointer
)	O
)	O
;	O
goto	O
exit	function
;	O
}	O
if	O
(	O
0	int
>	O
MHD_SYS_select_	O
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
+	O
1	int
,	O
&	O
rs	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
MHD_SC_UNEXPECTED_SELECT_ERROR	int
,	O
_	O
(	O
"Error during select (%d): `%s'\n"	pointer
)	O
,	O
err	long
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
p	array
[	O
0	int
]	O
.	O
events	int
=	O
POLLIN	int
;	O
p	array
[	O
0	int
]	O
.	O
fd	int
=	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
p	array
[	O
0	int
]	O
.	O
revents	short
=	O
0	int
;	O
if	O
(	O
0	int
>	O
MHD_sys_poll_	O
(	O
p	array
,	O
1	int
,	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
MHD_SCKT_LAST_ERR_IS_	O
(	O
MHD_SCKT_EINTR_	O
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
MHD_SC_UNEXPECTED_POLL_ERROR	int
,	O
_	O
(	O
"Error during poll: `%s'\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
was_suspended	bool
)	O
{	O
MHD_connection_update_last_activity_	function
(	O
con	pointer
)	O
;	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
was_suspended	bool
=	O
false	int
;	O
}	O
tvp	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_BLOCK	int
==	O
con	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
)	O
{	O
tv	struct
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
tvp	pointer
=	O
&	O
tv	struct
;	O
}	O
if	O
(	O
(	O
NULL	O
==	O
tvp	pointer
)	O
&&	O
(	O
timeout	pointer
>	O
0	int
)	O
)	O
{	O
now	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
now	long
-	O
con	pointer
->	O
last_activity	long
>	O
timeout	pointer
)	O
tv	struct
.	O
tv_sec	long
=	O
0	int
;	O
else	O
{	O
const	O
time_t	long
seconds_left	long
=	O
timeout	pointer
-	O
(	O
now	long
-	O
con	pointer
->	O
last_activity	long
)	O
;	O
tv	struct
.	O
tv_sec	long
=	O
seconds_left	long
;	O
}	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
tvp	pointer
=	O
&	O
tv	struct
;	O
}	O
if	O
(	O
!	O
use_poll	bool
)	O
{	O
bool	bool
err_state	bool
=	O
false	int
;	O
FD_ZERO	O
(	O
&	O
rs	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
ws	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
es	struct
)	O
;	O
maxsock	int
=	O
MHD_INVALID_SOCKET	O
;	O
switch	O
(	O
con	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
{	O
case	O
MHD_EVENT_LOOP_INFO_READ	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
rs	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
err_state	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_WRITE	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
ws	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
err_state	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_BLOCK	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
es	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
err_state	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
:	O
goto	O
exit	function
;	O
}	O
if	O
(	O
err_state	bool
)	O
{	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
MHD_SC_SOCKET_OUTSIDE_OF_FDSET_RANGE	int
,	O
_	O
(	O
"Failed to add FD to fd_set\n"	pointer
)	O
)	O
;	O
goto	O
exit	function
;	O
}	O
num_ready	int
=	O
MHD_SYS_select_	O
(	O
maxsock	int
+	O
1	int
,	O
&	O
rs	struct
,	O
&	O
ws	struct
,	O
&	O
es	struct
,	O
tvp	pointer
)	O
;	O
if	O
(	O
num_ready	int
<	O
0	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
MHD_SC_UNEXPECTED_SELECT_ERROR	int
,	O
_	O
(	O
"Error during select (%d): `%s'\n"	pointer
)	O
,	O
err	long
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
MHD_connection_call_handlers_	function
(	O
con	pointer
,	O
FD_ISSET	O
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
rs	struct
)	O
,	O
FD_ISSET	O
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
ws	struct
)	O
,	O
FD_ISSET	O
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
es	struct
)	O
)	O
)	O
goto	O
exit	function
;	O
}	O
else	O
{	O
memset	function
(	O
&	O
p	array
,	O
0	int
,	O
sizeof	O
(	O
p	array
)	O
)	O
;	O
p	array
[	O
0	int
]	O
.	O
fd	int
=	O
con	pointer
->	O
socket_fd	int
;	O
switch	O
(	O
con	pointer
->	O
request	pointer
.	O
event_loop_info	enum
)	O
{	O
case	O
MHD_EVENT_LOOP_INFO_READ	int
:	O
p	array
[	O
0	int
]	O
.	O
events	int
|=	O
POLLIN	int
|	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_WRITE	int
:	O
p	array
[	O
0	int
]	O
.	O
events	int
|=	O
POLLOUT	int
|	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_BLOCK	int
:	O
p	array
[	O
0	int
]	O
.	O
events	int
|=	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
:	O
goto	O
exit	function
;	O
}	O
if	O
(	O
MHD_sys_poll_	O
(	O
p	array
,	O
1	int
,	O
(	O
NULL	O
==	O
tvp	pointer
)	O
?	O
-	O
1	int
:	O
tv	struct
.	O
tv_sec	long
*	O
1000	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
MHD_SCKT_LAST_ERR_IS_	O
(	O
MHD_SCKT_EINTR_	O
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
MHD_SC_UNEXPECTED_POLL_ERROR	int
,	O
_	O
(	O
"Error during poll: `%s'\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
MHD_connection_call_handlers_	function
(	O
con	pointer
,	O
(	O
0	int
!=	O
(	O
p	array
[	O
0	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
)	O
,	O
(	O
0	int
!=	O
(	O
p	array
[	O
0	int
]	O
.	O
revents	short
&	O
POLLOUT	int
)	O
)	O
,	O
(	O
0	int
!=	O
(	O
p	array
[	O
0	int
]	O
.	O
revents	short
&	O
(	O
POLLERR	int
|	O
MHD_POLL_REVENTS_ERR_DISC	O
)	O
)	O
)	O
)	O
)	O
goto	O
exit	function
;	O
}	O
if	O
(	O
MHD_REQUEST_UPGRADE	int
==	O
con	pointer
->	O
request	pointer
.	O
state	pointer
)	O
{	O
if	O
(	O
NULL	O
!=	O
con	pointer
->	O
request	pointer
.	O
response	pointer
->	O
termination_cb	pointer
)	O
con	pointer
->	O
request	pointer
.	O
response	pointer
->	O
termination_cb	pointer
(	O
con	pointer
->	O
request	pointer
.	O
response	pointer
->	O
termination_cb_cls	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
,	O
con	pointer
->	O
request	pointer
.	O
client_context	pointer
)	O
;	O
thread_main_connection_upgrade	function
(	O
con	pointer
)	O
;	O
con	pointer
->	O
request	pointer
.	O
urh	pointer
->	O
clean_ready	bool
=	O
true	int
;	O
MHD_request_resume	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
return	O
(	O
MHD_THRD_RTRN_TYPE_	O
)	O
0	int
;	O
}	O
}	O
if	O
(	O
MHD_REQUEST_CLOSED	int
!=	O
con	pointer
->	O
request	pointer
.	O
state	pointer
)	O
MHD_connection_close_	function
(	O
con	pointer
,	O
(	O
daemon	function
->	O
shutdown	function
)	O
?	O
MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN	int
:	O
MHD_REQUEST_TERMINATED_WITH_ERROR	int
)	O
;	O
MHD_request_handle_idle_	function
(	O
&	O
con	pointer
->	O
request	pointer
)	O
;	O
exit	function
:	O
if	O
(	O
NULL	O
!=	O
con	pointer
->	O
request	pointer
.	O
response	pointer
)	O
{	O
MHD_response_queue_for_destroy	function
(	O
con	pointer
->	O
request	pointer
.	O
response	pointer
)	O
;	O
con	pointer
->	O
request	pointer
.	O
response	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
con	pointer
->	O
socket_fd	int
)	O
{	O
shutdown	function
(	O
con	pointer
->	O
socket_fd	int
,	O
SHUT_WR	int
)	O
;	O
}	O
return	O
(	O
MHD_THRD_RTRN_TYPE_	O
)	O
0	int
;	O
}	O
static	O
ssize_t	long
recv_param_adapter	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
void	O
*	O
other	pointer
,	O
size_t	long
i	long
)	O
{	O
ssize_t	long
ret	long
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
connection	pointer
->	O
socket_fd	int
)	O
||	O
(	O
MHD_REQUEST_CLOSED	int
==	O
connection	pointer
->	O
request	pointer
.	O
state	pointer
)	O
)	O
{	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
if	O
(	O
i	long
>	O
MHD_SCKT_SEND_MAX_SIZE_	O
)	O
i	long
=	O
MHD_SCKT_SEND_MAX_SIZE_	O
;	O
ret	long
=	O
MHD_recv_	O
(	O
connection	pointer
->	O
socket_fd	int
,	O
other	pointer
,	O
i	long
)	O
;	O
if	O
(	O
0	int
>	O
ret	long
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_READ_READY	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_ERR_AGAIN_	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_ECONNRESET_	O
)	O
)	O
return	O
MHD_ERR_CONNRESET_	O
;	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
else	O
if	O
(	O
i	long
>	O
(	O
size_t	long
)	O
ret	long
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_READ_READY	int
;	O
return	O
ret	long
;	O
}	O
static	O
ssize_t	long
send_param_adapter	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
const	O
void	O
*	O
other	pointer
,	O
size_t	long
i	long
)	O
{	O
ssize_t	long
ret	long
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
connection	pointer
->	O
socket_fd	int
)	O
||	O
(	O
MHD_REQUEST_CLOSED	int
==	O
connection	pointer
->	O
request	pointer
.	O
state	pointer
)	O
)	O
{	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
if	O
(	O
i	long
>	O
MHD_SCKT_SEND_MAX_SIZE_	O
)	O
i	long
=	O
MHD_SCKT_SEND_MAX_SIZE_	O
;	O
ret	long
=	O
MHD_send_	O
(	O
connection	pointer
->	O
socket_fd	int
,	O
other	pointer
,	O
i	long
)	O
;	O
if	O
(	O
0	int
>	O
ret	long
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
MHD_ERR_AGAIN_	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_ERR_AGAIN_	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_ECONNRESET_	O
)	O
)	O
return	O
MHD_ERR_CONNRESET_	O
;	O
return	O
MHD_ERR_NOTCONN_	O
;	O
}	O
else	O
if	O
(	O
i	long
>	O
(	O
size_t	long
)	O
ret	long
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
ret	long
;	O
}	O
static	O
enum	O
MHD_StatusCode	enum
internal_add_connection	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
MHD_socket	int
client_socket	int
,	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
,	O
bool	bool
external_add	bool
,	O
bool	bool
non_blck	bool
)	O
{	O
enum	O
MHD_StatusCode	enum
sc	enum
;	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
;	O
int	O
eno	int
=	O
0	int
;	O
mhd_assert	O
(	O
(	O
NULL	O
==	O
daemon	function
->	O
worker_pool	pointer
)	O
||	O
(	O
external_add	bool
)	O
)	O
;	O
if	O
(	O
(	O
external_add	bool
)	O
&&	O
(	O
NULL	O
!=	O
daemon	function
->	O
worker_pool	pointer
)	O
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
daemon	function
->	O
worker_pool_size	int
;	O
++	O
i	long
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
const	O
worker	pointer
=	O
&	O
daemon	function
->	O
worker_pool	pointer
[	O
(	O
i	long
+	O
client_socket	int
)	O
%	O
daemon	function
->	O
worker_pool_size	int
]	O
;	O
if	O
(	O
worker	pointer
->	O
connections	int
<	O
worker	pointer
->	O
global_connection_limit	int
)	O
return	O
internal_add_connection	function
(	O
worker	pointer
,	O
client_socket	int
,	O
addr	pointer
,	O
addrlen	int
,	O
true	int
,	O
non_blck	bool
)	O
;	O
}	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
errno	O
=	O
ENFILE	int
;	O
return	O
MHD_SC_LIMIT_CONNECTIONS_REACHED	int
;	O
}	O
if	O
(	O
(	O
!	O
MHD_SCKT_FD_FITS_FDSET_	O
(	O
client_socket	int
,	O
NULL	O
)	O
)	O
&&	O
(	O
MHD_ELS_SELECT	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_SOCKET_OUTSIDE_OF_FDSET_RANGE	int
,	O
_	O
(	O
"Socket descriptor larger than FD_SETSIZE: %d > %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
client_socket	int
,	O
(	O
int	O
)	O
FD_SETSIZE	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
MHD_SC_SOCKET_OUTSIDE_OF_FDSET_RANGE	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
connections	int
==	O
daemon	function
->	O
global_connection_limit	int
)	O
||	O
(	O
MHD_NO	int
==	O
MHD_ip_limit_add	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_LIMIT_CONNECTIONS_REACHED	int
,	O
_	O
(	O
"Server reached connection limit. Closing inbound connection.\n"	pointer
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
errno	O
=	O
ENFILE	int
;	O
return	O
MHD_SC_LIMIT_CONNECTIONS_REACHED	int
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
accept_policy_cb	pointer
)	O
&&	O
(	O
MHD_NO	int
==	O
daemon	function
->	O
accept_policy_cb	pointer
(	O
daemon	function
->	O
accept_policy_cb_cls	pointer
,	O
addr	pointer
,	O
addrlen	int
)	O
)	O
)	O
{	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
return	O
MHD_SC_ACCEPT_POLICY_REJECTED	int
;	O
}	O
if	O
(	O
NULL	O
==	O
(	O
connection	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_Connection	struct
)	O
)	O
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_CONNECTION_MALLOC_FAILURE	int
,	O
"Error allocating memory: %s\n"	pointer
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
errno	O
=	O
eno	int
;	O
return	O
MHD_SC_CONNECTION_MALLOC_FAILURE	int
;	O
}	O
connection	pointer
->	O
pool	pointer
=	O
MHD_pool_create	function
(	O
daemon	function
->	O
connection_memory_limit_b	long
)	O
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
->	O
pool	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_POOL_MALLOC_FAILURE	int
,	O
_	O
(	O
"Error allocating memory: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
free	function
(	O
connection	pointer
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
MHD_SC_POOL_MALLOC_FAILURE	int
;	O
}	O
connection	pointer
->	O
connection_timeout	int
=	O
daemon	function
->	O
connection_default_timeout	long
;	O
memcpy	function
(	O
&	O
connection	pointer
->	O
addr	pointer
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
connection	pointer
->	O
addr_len	int
=	O
addrlen	int
;	O
connection	pointer
->	O
socket_fd	int
=	O
client_socket	int
;	O
connection	pointer
->	O
sk_nonblck	bool
=	O
non_blck	bool
;	O
connection	pointer
->	O
daemon	function
=	O
daemon	function
;	O
connection	pointer
->	O
last_activity	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
{	O
connection	pointer
->	O
recv_cls	pointer
=	O
&	O
recv_param_adapter	function
;	O
connection	pointer
->	O
send_cls	pointer
=	O
&	O
send_param_adapter	function
;	O
}	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
daemon	function
->	O
connections	int
>=	O
daemon	function
->	O
global_connection_limit	int
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_LIMIT_CONNECTIONS_REACHED	int
,	O
_	O
(	O
"Server reached connection limit. Closing inbound connection.\n"	pointer
)	O
)	O
;	O
eno	int
=	O
ENFILE	int
;	O
sc	enum
=	O
MHD_SC_LIMIT_CONNECTIONS_REACHED	int
;	O
goto	O
cleanup	O
;	O
}	O
daemon	function
->	O
connections	int
++	O
;	O
if	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
XDLL_insert	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_insert	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_connection_cb	pointer
)	O
daemon	function
->	O
notify_connection_cb	pointer
(	O
daemon	function
->	O
notify_connection_cb_cls	pointer
,	O
connection	pointer
,	O
MHD_CONNECTION_NOTIFY_STARTED	int
)	O
;	O
if	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
==	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
if	O
(	O
!	O
MHD_create_named_thread_	function
(	O
&	O
connection	pointer
->	O
pid	int
,	O
"MHD-connection"	pointer
,	O
daemon	function
->	O
thread_stack_limit_b	long
,	O
&	O
thread_main_handle_connection	function
,	O
connection	pointer
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_THREAD_LAUNCH_FAILURE	int
,	O
"Failed to create a thread: %s\n"	pointer
,	O
MHD_strerror_	O
(	O
eno	int
)	O
)	O
;	O
sc	enum
=	O
MHD_SC_THREAD_LAUNCH_FAILURE	int
;	O
goto	O
cleanup	O
;	O
}	O
}	O
else	O
{	O
connection	pointer
->	O
pid	int
=	O
daemon	function
->	O
pid	int
;	O
}	O
if	O
(	O
MHD_ELS_EPOLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
{	O
if	O
(	O
(	O
!	O
daemon	function
->	O
enable_turbo	bool
)	O
||	O
(	O
external_add	bool
)	O
)	O
{	O
struct	O
epoll_event	struct
event	struct
;	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
|	O
EPOLLOUT	int
|	O
EPOLLPRI	int
|	O
EPOLLET	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
connection	pointer
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
client_socket	int
,	O
&	O
event	struct
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_EPOLL_CTL_ADD_FAILED	int
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
sc	enum
=	O
MHD_SC_EPOLL_CTL_ADD_FAILED	int
;	O
goto	O
cleanup	O
;	O
}	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
else	O
{	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_READ_READY	int
|	O
MHD_EPOLL_STATE_WRITE_READY	int
|	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
&&	O
(	O
external_add	bool
)	O
&&	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"n"	pointer
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ITC_USE_FAILED	int
,	O
_	O
(	O
"Failed to signal new connection via inter-thread communication channel (not necessarily fatal, continuing anyway)."	pointer
)	O
)	O
;	O
}	O
return	O
MHD_SC_OK	int
;	O
cleanup	O
:	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_connection_cb	pointer
)	O
daemon	function
->	O
notify_connection_cb	pointer
(	O
daemon	function
->	O
notify_connection_cb_cls	pointer
,	O
connection	pointer
,	O
MHD_CONNECTION_NOTIFY_CLOSED	int
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_remove	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_pool_destroy	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
free	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
0	int
!=	O
eno	int
)	O
errno	O
=	O
eno	int
;	O
else	O
errno	O
=	O
EINVAL	int
;	O
return	O
sc	enum
;	O
}	O
enum	O
MHD_StatusCode	enum
MHD_daemon_add_connection	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
MHD_socket	int
client_socket	int
,	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
)	O
{	O
bool	bool
sk_nonbl	bool
;	O
if	O
(	O
!	O
MHD_socket_nonblocking_	function
(	O
client_socket	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ACCEPT_CONFIGURE_NONBLOCKING_FAILED	int
,	O
_	O
(	O
"Failed to set nonblocking mode on new client socket: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
sk_nonbl	bool
=	O
false	int
;	O
}	O
else	O
{	O
sk_nonbl	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
enable_turbo	bool
)	O
&&	O
(	O
!	O
MHD_socket_noninheritable_	function
(	O
client_socket	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ACCEPT_CONFIGURE_NOINHERIT_FAILED	int
,	O
_	O
(	O
"Failed to set noninheritable mode on new client socket.\n"	pointer
)	O
)	O
;	O
}	O
return	O
internal_add_connection	function
(	O
daemon	function
,	O
client_socket	int
,	O
addr	pointer
,	O
addrlen	int
,	O
true	int
,	O
sk_nonbl	bool
)	O
;	O
}	O
enum	O
MHD_StatusCode	enum
MHD_accept_connection_	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
sockaddr_storage	struct
addrstorage	struct
;	O
struct	O
sockaddr	struct
*	O
addr	pointer
=	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
addrstorage	struct
;	O
socklen_t	int
addrlen	int
;	O
MHD_socket	int
s	pointer
;	O
MHD_socket	int
fd	int
;	O
bool	bool
sk_nonbl	bool
;	O
addrlen	int
=	O
sizeof	O
(	O
addrstorage	struct
)	O
;	O
memset	function
(	O
addr	pointer
,	O
0	int
,	O
sizeof	O
(	O
addrstorage	struct
)	O
)	O
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
(	O
fd	int
=	O
daemon	function
->	O
listen_socket	int
)	O
)	O
||	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
)	O
return	O
MHD_SC_DAEMON_ALREADY_QUIESCED	int
;	O
s	pointer
=	O
accept4	function
(	O
fd	int
,	O
addr	pointer
,	O
&	O
addrlen	int
,	O
MAYBE_SOCK_CLOEXEC	O
|	O
MAYBE_SOCK_NONBLOCK	O
)	O
;	O
sk_nonbl	bool
=	O
(	O
0	int
!=	O
MAYBE_SOCK_NONBLOCK	O
)	O
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
s	pointer
)	O
||	O
(	O
addrlen	int
<=	O
0	int
)	O
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_EINVAL_	O
)	O
)	O
return	O
MHD_SC_DAEMON_ALREADY_SHUTDOWN	int
;	O
if	O
(	O
MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_	O
(	O
err	long
)	O
)	O
return	O
MHD_SC_ACCEPT_FAST_DISCONNECT	int
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
return	O
MHD_SC_ACCEPT_FAILED_EAGAIN	int
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
s	pointer
)	O
{	O
MHD_socket_close_chk_	O
(	O
s	pointer
)	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_LOW_RESOURCES_	O
(	O
err	long
)	O
)	O
{	O
if	O
(	O
0	int
==	O
daemon	function
->	O
connections	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ACCEPT_SYSTEM_LIMIT_REACHED_INSTANTLY	int
,	O
_	O
(	O
"Hit process or system resource limit at FIRST connection. This is really bad as there is no sane way to proceed. Will try busy waiting for system resources to become magically available.\n"	pointer
)	O
)	O
;	O
return	O
MHD_SC_ACCEPT_SYSTEM_LIMIT_REACHED_INSTANTLY	int
;	O
}	O
else	O
{	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
daemon	function
->	O
at_limit	bool
=	O
true	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ACCEPT_SYSTEM_LIMIT_REACHED	int
,	O
_	O
(	O
"Hit process or system resource limit at %u connections, temporarily suspending accept(). Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\n"	pointer
)	O
,	O
(	O
unsigned	O
int	O
)	O
daemon	function
->	O
connections	int
)	O
;	O
return	O
MHD_SC_ACCEPT_SYSTEM_LIMIT_REACHED	int
;	O
}	O
}	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_ACCEPT_FAILED_UNEXPECTEDLY	int
,	O
_	O
(	O
"Error accepting connection: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
return	O
MHD_SC_ACCEPT_FAILED_UNEXPECTEDLY	int
;	O
}	O
return	O
internal_add_connection	function
(	O
daemon	function
,	O
s	pointer
,	O
addr	pointer
,	O
addrlen	int
,	O
false	int
,	O
sk_nonbl	bool
)	O
;	O
}	O
