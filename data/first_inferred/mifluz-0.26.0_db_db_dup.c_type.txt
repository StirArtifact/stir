static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_dup.c,v 1.5 2000/06/28 16:47:00 loic Exp $"	pointer
;	O
int	O
CDB___db_ditem	function
(	O
dbc	pointer
,	O
pagep	pointer
,	O
indx	short
,	O
nbytes	long
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
u_int32_t	int
indx	short
,	O
nbytes	long
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
ldbt	struct
;	O
db_indx_t	short
cnt	short
,	O
offset	int
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
from	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
ldbt	struct
.	O
data	pointer
=	O
P_ENTRY	O
(	O
pagep	pointer
,	O
indx	short
)	O
;	O
ldbt	struct
.	O
size	int
=	O
nbytes	long
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_addrem_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
0	int
,	O
DB_REM_DUP	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
indx	short
,	O
nbytes	long
,	O
&	O
ldbt	struct
,	O
NULL	O
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
NUM_ENT	O
(	O
pagep	pointer
)	O
==	O
1	int
)	O
{	O
NUM_ENT	O
(	O
pagep	pointer
)	O
=	O
0	int
;	O
HOFFSET	O
(	O
pagep	pointer
)	O
=	O
dbp	pointer
->	O
pgsize	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
from	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
pagep	pointer
+	O
HOFFSET	O
(	O
pagep	pointer
)	O
;	O
memmove	function
(	O
from	pointer
+	O
nbytes	long
,	O
from	pointer
,	O
pagep	pointer
->	O
inp	array
[	O
indx	short
]	O
-	O
HOFFSET	O
(	O
pagep	pointer
)	O
)	O
;	O
HOFFSET	O
(	O
pagep	pointer
)	O
+=	O
nbytes	long
;	O
offset	int
=	O
pagep	pointer
->	O
inp	array
[	O
indx	short
]	O
;	O
for	O
(	O
cnt	short
=	O
0	int
;	O
cnt	short
<	O
NUM_ENT	O
(	O
pagep	pointer
)	O
;	O
++	O
cnt	short
)	O
if	O
(	O
pagep	pointer
->	O
inp	array
[	O
cnt	short
]	O
<	O
offset	int
)	O
pagep	pointer
->	O
inp	array
[	O
cnt	short
]	O
+=	O
nbytes	long
;	O
--	O
NUM_ENT	O
(	O
pagep	pointer
)	O
;	O
if	O
(	O
indx	short
!=	O
NUM_ENT	O
(	O
pagep	pointer
)	O
)	O
memmove	function
(	O
&	O
pagep	pointer
->	O
inp	array
[	O
indx	short
]	O
,	O
&	O
pagep	pointer
->	O
inp	array
[	O
indx	short
+	O
1	int
]	O
,	O
sizeof	O
(	O
db_indx_t	short
)	O
*	O
(	O
NUM_ENT	O
(	O
pagep	pointer
)	O
-	O
indx	short
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
pagep	pointer
,	O
indx	short
,	O
nbytes	long
,	O
hdr	struct
,	O
data	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
u_int32_t	int
indx	short
;	O
u_int32_t	int
nbytes	long
;	O
DBT	struct
*	O
hdr	struct
,	O
*	O
data	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
BKEYDATA	struct
bk	struct
;	O
DBT	struct
thdr	struct
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_addrem_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
0	int
,	O
DB_ADD_DUP	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
indx	short
,	O
nbytes	long
,	O
hdr	struct
,	O
data	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
hdr	struct
==	O
NULL	O
)	O
{	O
B_TSET	O
(	O
bk	struct
.	O
type	enum
,	O
B_KEYDATA	int
,	O
0	int
)	O
;	O
bk	struct
.	O
len	short
=	O
data	pointer
==	O
NULL	O
?	O
0	int
:	O
data	pointer
->	O
size	int
;	O
thdr	struct
.	O
data	pointer
=	O
&	O
bk	struct
;	O
thdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BKEYDATA	struct
,	O
data	pointer
)	O
;	O
hdr	struct
=	O
&	O
thdr	struct
;	O
}	O
if	O
(	O
indx	short
!=	O
NUM_ENT	O
(	O
pagep	pointer
)	O
)	O
memmove	function
(	O
&	O
pagep	pointer
->	O
inp	array
[	O
indx	short
+	O
1	int
]	O
,	O
&	O
pagep	pointer
->	O
inp	array
[	O
indx	short
]	O
,	O
sizeof	O
(	O
db_indx_t	short
)	O
*	O
(	O
NUM_ENT	O
(	O
pagep	pointer
)	O
-	O
indx	short
)	O
)	O
;	O
HOFFSET	O
(	O
pagep	pointer
)	O
-=	O
nbytes	long
;	O
pagep	pointer
->	O
inp	array
[	O
indx	short
]	O
=	O
HOFFSET	O
(	O
pagep	pointer
)	O
;	O
++	O
NUM_ENT	O
(	O
pagep	pointer
)	O
;	O
p	pointer
=	O
P_ENTRY	O
(	O
pagep	pointer
,	O
indx	short
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
hdr	struct
->	O
data	pointer
,	O
hdr	struct
->	O
size	int
)	O
;	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
memcpy	function
(	O
p	pointer
+	O
hdr	struct
->	O
size	int
,	O
data	pointer
->	O
data	pointer
,	O
data	pointer
->	O
size	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_relink	function
(	O
dbc	pointer
,	O
add_rem	int
,	O
pagep	pointer
,	O
new_next	pointer
,	O
needlock	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
add_rem	int
;	O
PAGE	struct
*	O
pagep	pointer
,	O
*	O
*	O
new_next	pointer
;	O
int	O
needlock	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
np	pointer
,	O
*	O
pp	pointer
;	O
DB_LOCK	struct
npl	struct
,	O
ppl	struct
;	O
DB_LSN	struct
*	O
nlsnp	pointer
,	O
*	O
plsnp	pointer
,	O
ret_lsn	struct
;	O
int	O
ret	int
;	O
ret	int
=	O
0	int
;	O
np	pointer
=	O
pp	pointer
=	O
NULL	O
;	O
npl	struct
.	O
off	long
=	O
ppl	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
nlsnp	pointer
=	O
plsnp	pointer
=	O
NULL	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
pagep	pointer
->	O
next_pgno	int
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
needlock	int
&&	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pagep	pointer
->	O
next_pgno	int
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
npl	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pagep	pointer
->	O
next_pgno	int
,	O
0	int
,	O
&	O
np	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___db_pgerr	function
(	O
dbp	pointer
,	O
pagep	pointer
->	O
next_pgno	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
nlsnp	pointer
=	O
&	O
np	pointer
->	O
lsn	struct
;	O
}	O
if	O
(	O
add_rem	int
==	O
DB_REM_PAGE	int
&&	O
pagep	pointer
->	O
prev_pgno	int
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
needlock	int
&&	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pagep	pointer
->	O
prev_pgno	int
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
ppl	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pagep	pointer
->	O
prev_pgno	int
,	O
0	int
,	O
&	O
pp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___db_pgerr	function
(	O
dbp	pointer
,	O
pagep	pointer
->	O
next_pgno	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
plsnp	pointer
=	O
&	O
pp	pointer
->	O
lsn	struct
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_relink_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
ret_lsn	struct
,	O
0	int
,	O
add_rem	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
pagep	pointer
->	O
pgno	int
,	O
&	O
pagep	pointer
->	O
lsn	struct
,	O
pagep	pointer
->	O
prev_pgno	int
,	O
plsnp	pointer
,	O
pagep	pointer
->	O
next_pgno	int
,	O
nlsnp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
np	pointer
!=	O
NULL	O
)	O
np	pointer
->	O
lsn	struct
=	O
ret_lsn	struct
;	O
if	O
(	O
pp	pointer
!=	O
NULL	O
)	O
pp	pointer
->	O
lsn	struct
=	O
ret_lsn	struct
;	O
if	O
(	O
add_rem	int
==	O
DB_REM_PAGE	int
)	O
pagep	pointer
->	O
lsn	struct
=	O
ret_lsn	struct
;	O
}	O
if	O
(	O
np	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
add_rem	int
==	O
DB_ADD_PAGE	int
)	O
np	pointer
->	O
prev_pgno	int
=	O
pagep	pointer
->	O
pgno	int
;	O
else	O
np	pointer
->	O
prev_pgno	int
=	O
pagep	pointer
->	O
prev_pgno	int
;	O
if	O
(	O
new_next	pointer
==	O
NULL	O
)	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
np	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
else	O
{	O
*	O
new_next	pointer
=	O
np	pointer
;	O
ret	int
=	O
CDB_memp_fset	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
np	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
needlock	int
)	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
npl	struct
)	O
;	O
}	O
else	O
if	O
(	O
new_next	pointer
!=	O
NULL	O
)	O
*	O
new_next	pointer
=	O
NULL	O
;	O
if	O
(	O
pp	pointer
!=	O
NULL	O
)	O
{	O
pp	pointer
->	O
next_pgno	int
=	O
pagep	pointer
->	O
next_pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
needlock	int
)	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
ppl	struct
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
np	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
np	pointer
,	O
0	int
)	O
;	O
if	O
(	O
needlock	int
&&	O
npl	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
npl	struct
)	O
;	O
if	O
(	O
pp	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
needlock	int
&&	O
ppl	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
ppl	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
