static	O
symbol	struct
*	O
reverse_symbol_list	function
(	O
symbol	struct
*	O
sym	pointer
)	O
{	O
symbol	struct
*	O
result	pointer
;	O
symbol	struct
*	O
next	pointer
;	O
result	pointer
=	O
NULL	O
;	O
while	O
(	O
sym	pointer
)	O
{	O
next	pointer
=	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
;	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
=	O
result	pointer
;	O
result	pointer
=	O
sym	pointer
;	O
sym	pointer
=	O
next	pointer
;	O
}	O
return	O
result	pointer
;	O
}	O
void	O
produce_frozen_state	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
;	O
size_t	long
h	long
;	O
symbol	struct
*	O
sym	pointer
;	O
const	O
builtin	struct
*	O
bp	pointer
;	O
file	pointer
=	O
fopen	function
(	O
name	pointer
,	O
O_BINARY	int
?	O
"wb"	pointer
:	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot open `%s'"	pointer
,	O
name	pointer
)	O
)	O
;	O
return	O
;	O
}	O
xfprintf	function
(	O
file	pointer
,	O
"# This is a frozen state file generated by %s\n"	pointer
,	O
PACKAGE_STRING	pointer
)	O
;	O
xfprintf	function
(	O
file	pointer
,	O
"V1\n"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
lquote	struct
.	O
string	struct
,	O
DEF_LQUOTE	pointer
)	O
||	O
strcmp	function
(	O
rquote	struct
.	O
string	struct
,	O
DEF_RQUOTE	pointer
)	O
)	O
{	O
xfprintf	function
(	O
file	pointer
,	O
"Q%d,%d\n"	pointer
,	O
(	O
int	O
)	O
lquote	struct
.	O
length	long
,	O
(	O
int	O
)	O
rquote	struct
.	O
length	long
)	O
;	O
fputs	function
(	O
lquote	struct
.	O
string	struct
,	O
file	pointer
)	O
;	O
fputs	function
(	O
rquote	struct
.	O
string	struct
,	O
file	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
bcomm	struct
.	O
string	struct
,	O
DEF_BCOMM	pointer
)	O
||	O
strcmp	function
(	O
ecomm	struct
.	O
string	struct
,	O
DEF_ECOMM	pointer
)	O
)	O
{	O
xfprintf	function
(	O
file	pointer
,	O
"C%d,%d\n"	pointer
,	O
(	O
int	O
)	O
bcomm	struct
.	O
length	long
,	O
(	O
int	O
)	O
ecomm	struct
.	O
length	long
)	O
;	O
fputs	function
(	O
bcomm	struct
.	O
string	struct
,	O
file	pointer
)	O
;	O
fputs	function
(	O
ecomm	struct
.	O
string	struct
,	O
file	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
for	O
(	O
h	long
=	O
0	int
;	O
h	long
<	O
hash_table_size	long
;	O
h	long
++	O
)	O
{	O
symtab	pointer
[	O
h	long
]	O
=	O
reverse_symbol_list	function
(	O
symtab	pointer
[	O
h	long
]	O
)	O
;	O
for	O
(	O
sym	pointer
=	O
symtab	pointer
[	O
h	long
]	O
;	O
sym	pointer
;	O
sym	pointer
=	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
)	O
{	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
xfprintf	function
(	O
file	pointer
,	O
"T%d,%d\n"	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
)	O
,	O
(	O
int	O
)	O
strlen	function
(	O
SYMBOL_TEXT	O
(	O
sym	pointer
)	O
)	O
)	O
;	O
fputs	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
file	pointer
)	O
;	O
fputs	function
(	O
SYMBOL_TEXT	O
(	O
sym	pointer
)	O
,	O
file	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	pointer
=	O
find_builtin_by_addr	function
(	O
SYMBOL_FUNC	O
(	O
sym	pointer
)	O
)	O
;	O
if	O
(	O
bp	pointer
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: builtin not found in builtin table!"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
xfprintf	function
(	O
file	pointer
,	O
"F%d,%d\n"	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
)	O
,	O
(	O
int	O
)	O
strlen	function
(	O
bp	pointer
->	O
name	pointer
)	O
)	O
;	O
fputs	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
file	pointer
)	O
;	O
fputs	function
(	O
bp	pointer
->	O
name	pointer
,	O
file	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type in freeze_one_symbol ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
symtab	pointer
[	O
h	long
]	O
=	O
reverse_symbol_list	function
(	O
symtab	pointer
[	O
h	long
]	O
)	O
;	O
}	O
freeze_diversions	function
(	O
file	pointer
)	O
;	O
fputs	function
(	O
"# End of frozen state file\n"	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
close_stream	function
(	O
file	pointer
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"unable to create frozen state"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
issue_expect_message	function
(	O
int	O
expected	int
)	O
{	O
if	O
(	O
expected	int
==	O
'\n'	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"expecting line feed in frozen file"	pointer
)	O
)	O
;	O
else	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"expecting character `%c' in frozen file"	pointer
,	O
expected	int
)	O
)	O
;	O
}	O
void	O
reload_frozen_state	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
;	O
int	O
character	int
;	O
int	O
operation	int
;	O
char	O
*	O
string	struct
[	O
2	int
]	O
;	O
int	O
allocated	array
[	O
2	int
]	O
;	O
int	O
number	array
[	O
2	int
]	O
;	O
const	O
builtin	struct
*	O
bp	pointer
;	O
bool	bool
advance_line	bool
=	O
true	int
;	O
file	pointer
=	O
m4_path_search	function
(	O
name	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot open %s"	pointer
,	O
name	pointer
)	O
)	O
;	O
current_file	pointer
=	O
name	pointer
;	O
allocated	array
[	O
0	int
]	O
=	O
100	int
;	O
string	struct
[	O
0	int
]	O
=	O
xcharalloc	function
(	O
(	O
size_t	long
)	O
allocated	array
[	O
0	int
]	O
)	O
;	O
allocated	array
[	O
1	int
]	O
=	O
100	int
;	O
string	struct
[	O
1	int
]	O
=	O
xcharalloc	function
(	O
(	O
size_t	long
)	O
allocated	array
[	O
1	int
]	O
)	O
;	O
GET_DIRECTIVE	O
;	O
VALIDATE	O
(	O
'V'	O
)	O
;	O
GET_CHARACTER	O
;	O
GET_NUMBER	O
(	O
number	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
if	O
(	O
number	array
[	O
0	int
]	O
>	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_MISMATCH	int
,	O
0	int
,	O
"frozen file version %d greater than max supported of 1"	pointer
,	O
number	array
[	O
0	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
number	array
[	O
0	int
]	O
<	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"ill-formed frozen file, version directive expected"	pointer
)	O
)	O
;	O
VALIDATE	O
(	O
'\n'	O
)	O
;	O
GET_DIRECTIVE	O
;	O
while	O
(	O
character	int
!=	O
EOF	O
)	O
{	O
switch	O
(	O
character	int
)	O
{	O
default	O
:	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"ill-formed frozen file"	pointer
)	O
)	O
;	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'F'	O
:	O
case	O
'T'	O
:	O
case	O
'Q'	O
:	O
operation	int
=	O
character	int
;	O
GET_CHARACTER	O
;	O
if	O
(	O
operation	int
==	O
'D'	O
&&	O
character	int
==	O
'-'	O
)	O
{	O
GET_CHARACTER	O
;	O
GET_NUMBER	O
(	O
number	array
[	O
0	int
]	O
,	O
true	int
)	O
;	O
number	array
[	O
0	int
]	O
=	O
-	O
number	array
[	O
0	int
]	O
;	O
}	O
else	O
GET_NUMBER	O
(	O
number	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
VALIDATE	O
(	O
','	O
)	O
;	O
GET_CHARACTER	O
;	O
GET_NUMBER	O
(	O
number	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
VALIDATE	O
(	O
'\n'	O
)	O
;	O
if	O
(	O
operation	int
!=	O
'D'	O
)	O
GET_STRING	O
(	O
0	int
)	O
;	O
GET_STRING	O
(	O
1	int
)	O
;	O
GET_CHARACTER	O
;	O
VALIDATE	O
(	O
'\n'	O
)	O
;	O
switch	O
(	O
operation	int
)	O
{	O
case	O
'C'	O
:	O
set_comment	function
(	O
string	struct
[	O
0	int
]	O
,	O
string	struct
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
make_diversion	function
(	O
number	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
number	array
[	O
1	int
]	O
>	O
0	int
)	O
output_text	function
(	O
string	struct
[	O
1	int
]	O
,	O
number	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
bp	pointer
=	O
find_builtin_by_name	function
(	O
string	struct
[	O
1	int
]	O
)	O
;	O
define_builtin	function
(	O
string	struct
[	O
0	int
]	O
,	O
bp	pointer
,	O
SYMBOL_PUSHDEF	int
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
define_user_macro	function
(	O
string	struct
[	O
0	int
]	O
,	O
string	struct
[	O
1	int
]	O
,	O
SYMBOL_PUSHDEF	int
)	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
set_quotes	function
(	O
string	struct
[	O
0	int
]	O
,	O
string	struct
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
GET_DIRECTIVE	O
;	O
}	O
free	function
(	O
string	struct
[	O
0	int
]	O
)	O
;	O
free	function
(	O
string	struct
[	O
1	int
]	O
)	O
;	O
if	O
(	O
close_stream	function
(	O
file	pointer
)	O
!=	O
0	int
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"unable to read frozen state"	pointer
)	O
)	O
;	O
current_file	pointer
=	O
NULL	O
;	O
current_line	int
=	O
0	int
;	O
}	O
