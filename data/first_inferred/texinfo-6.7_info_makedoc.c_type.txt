char	O
*	O
program_name	pointer
=	O
"makedoc"	pointer
;	O
static	O
void	O
fatal_file_error	function
(	O
char	O
*	O
filename	pointer
)	O
;	O
static	O
char	O
*	O
funs_filename	pointer
=	O
"funs.h"	pointer
;	O
static	O
char	O
*	O
doc_filename	pointer
=	O
"doc.c"	pointer
;	O
static	O
char	O
*	O
doc_header	array
[	O
]	O
=	O
{	O
"/* doc.c -- Generated structure containing function names and doc strings."	pointer
,	O
""	pointer
,	O
"   This file was automatically made from various source files with the"	pointer
,	O
"   command `%s'."	pointer
,	O
"   DO NOT EDIT THIS FILE, only `%s.c'."	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
doc_header_1	array
[	O
]	O
=	O
{	O
"   An entry in the array FUNCTION_DOC_ARRAY is made for each command"	pointer
,	O
"   found in the above files; each entry consists of a function pointer,"	pointer
,	O
"   a string which is the user-visible name of the function,"	pointer
,	O
"   and a string which documents its purpose. */"	pointer
,	O
""	pointer
,	O
"#include \"info.h\""	pointer
,	O
"#include \"window.h\""	pointer
,	O
"#include \"funs.h\""	pointer
,	O
""	pointer
,	O
"FUNCTION_DOC function_doc_array[] = {"	pointer
,	O
""	pointer
,	O
NULL	O
}	O
;	O
typedef	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
int	O
line	int
;	O
long	O
char_offset	long
;	O
}	O
EMACS_TAG	struct
;	O
typedef	O
struct	O
{	O
char	O
*	O
filename	pointer
;	O
long	O
entrylen	long
;	O
EMACS_TAG	struct
*	O
*	O
entries	pointer
;	O
size_t	long
entries_index	long
;	O
size_t	long
entries_slots	long
;	O
}	O
EMACS_TAG_BLOCK	struct
;	O
EMACS_TAG_BLOCK	struct
*	O
*	O
emacs_tags	pointer
=	O
NULL	O
;	O
size_t	long
emacs_tags_index	long
=	O
0	int
;	O
size_t	long
emacs_tags_slots	long
=	O
0	int
;	O
static	O
void	O
process_one_file	function
(	O
char	O
*	O
filename	pointer
,	O
FILE	struct
*	O
doc_stream	pointer
,	O
FILE	struct
*	O
funs_stream	pointer
)	O
;	O
static	O
void	O
maybe_dump_tags	function
(	O
FILE	struct
*	O
stream	pointer
)	O
;	O
static	O
FILE	struct
*	O
must_fopen	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
mode	pointer
)	O
;	O
static	O
void	O
init_func_key	function
(	O
unsigned	O
int	O
val	int
)	O
;	O
static	O
unsigned	O
int	O
next_func_key	function
(	O
void	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
register	O
int	O
i	int
;	O
int	O
tags_only	int
=	O
0	int
;	O
FILE	struct
*	O
funs_stream	pointer
,	O
*	O
doc_stream	pointer
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-tags"	pointer
)	O
==	O
0	int
)	O
{	O
tags_only	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
tags_only	int
)	O
{	O
funs_filename	pointer
=	O
NULL_DEVICE	pointer
;	O
doc_filename	pointer
=	O
NULL_DEVICE	pointer
;	O
}	O
funs_stream	pointer
=	O
must_fopen	function
(	O
funs_filename	pointer
,	O
"w"	pointer
)	O
;	O
doc_stream	pointer
=	O
must_fopen	function
(	O
doc_filename	pointer
,	O
"w"	pointer
)	O
;	O
fprintf	function
(	O
funs_stream	pointer
,	O
"/* %s -- Generated declarations for Info commands. */\n\n"	pointer
"#include \"info.h\"\n"	pointer
"#include \"window.h\"\n"	pointer
,	O
funs_filename	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
doc_header	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
doc_stream	pointer
,	O
doc_header	array
[	O
i	int
]	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
fprintf	function
(	O
doc_stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
doc_stream	pointer
,	O
_	O
(	O
"   Source files groveled to make this file include:\n\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
doc_stream	pointer
,	O
"\t%s\n"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
fprintf	function
(	O
doc_stream	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
doc_header_1	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
fprintf	function
(	O
doc_stream	pointer
,	O
"%s\n"	pointer
,	O
doc_header_1	array
[	O
i	int
]	O
)	O
;	O
init_func_key	function
(	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
curfile	pointer
;	O
curfile	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
*	O
curfile	pointer
==	O
'-'	O
)	O
continue	O
;	O
fprintf	function
(	O
doc_stream	pointer
,	O
"/* Commands found in \"%s\". */\n"	pointer
,	O
curfile	pointer
)	O
;	O
fprintf	function
(	O
funs_stream	pointer
,	O
"\n/* Functions declared in \"%s\". */\n"	pointer
,	O
curfile	pointer
)	O
;	O
process_one_file	function
(	O
curfile	pointer
,	O
doc_stream	pointer
,	O
funs_stream	pointer
)	O
;	O
}	O
fprintf	function
(	O
doc_stream	pointer
,	O
"   { NULL, NULL, NULL, NULL }\n};\n"	pointer
)	O
;	O
fprintf	function
(	O
funs_stream	pointer
,	O
"\n#define A_NCOMMANDS %u\n"	pointer
,	O
next_func_key	function
(	O
)	O
)	O
;	O
fclose	function
(	O
funs_stream	pointer
)	O
;	O
fclose	function
(	O
doc_stream	pointer
)	O
;	O
if	O
(	O
tags_only	int
)	O
maybe_dump_tags	function
(	O
stdout	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
maybe_dump_tags	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
size_t	long
i	int
;	O
SET_BINARY	O
(	O
fileno	function
(	O
stream	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
emacs_tags_index	long
;	O
i	int
++	O
)	O
{	O
size_t	long
j	long
;	O
register	O
EMACS_TAG_BLOCK	struct
*	O
block	pointer
;	O
register	O
EMACS_TAG	struct
*	O
etag	pointer
;	O
long	O
block_len	long
;	O
block_len	long
=	O
0	int
;	O
block	pointer
=	O
emacs_tags	pointer
[	O
i	int
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
block	pointer
->	O
entries_index	long
;	O
j	long
++	O
)	O
{	O
char	O
digits	array
[	O
30	int
]	O
;	O
etag	pointer
=	O
block	pointer
->	O
entries	pointer
[	O
j	long
]	O
;	O
block_len	long
+=	O
3	int
+	O
strlen	function
(	O
etag	pointer
->	O
name	pointer
)	O
;	O
sprintf	function
(	O
digits	array
,	O
"%d,%ld"	pointer
,	O
etag	pointer
->	O
line	int
,	O
etag	pointer
->	O
char_offset	long
)	O
;	O
block_len	long
+=	O
strlen	function
(	O
digits	array
)	O
;	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"\f\n%s,%ld\n"	pointer
,	O
block	pointer
->	O
filename	pointer
,	O
block_len	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
block	pointer
->	O
entries_index	long
;	O
j	long
++	O
)	O
{	O
etag	pointer
=	O
block	pointer
->	O
entries	pointer
[	O
j	long
]	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"%s,\177%d,%ld\n"	pointer
,	O
etag	pointer
->	O
name	pointer
,	O
etag	pointer
->	O
line	int
,	O
etag	pointer
->	O
char_offset	long
)	O
;	O
}	O
}	O
}	O
static	O
EMACS_TAG_BLOCK	struct
*	O
make_emacs_tag_block	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
EMACS_TAG_BLOCK	struct
*	O
block	pointer
;	O
block	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
EMACS_TAG_BLOCK	struct
)	O
)	O
;	O
block	pointer
->	O
filename	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
block	pointer
->	O
entrylen	long
=	O
0	int
;	O
block	pointer
->	O
entries	pointer
=	O
NULL	O
;	O
block	pointer
->	O
entries_index	long
=	O
0	int
;	O
block	pointer
->	O
entries_slots	long
=	O
0	int
;	O
return	O
block	pointer
;	O
}	O
static	O
void	O
add_tag_to_block	function
(	O
EMACS_TAG_BLOCK	struct
*	O
block	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
line	int
,	O
long	O
int	O
char_offset	long
)	O
{	O
EMACS_TAG	struct
*	O
tag	pointer
;	O
tag	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
EMACS_TAG	struct
)	O
)	O
;	O
tag	pointer
->	O
name	pointer
=	O
name	pointer
;	O
tag	pointer
->	O
line	int
=	O
line	int
;	O
tag	pointer
->	O
char_offset	long
=	O
char_offset	long
;	O
add_pointer_to_array	O
(	O
tag	pointer
,	O
block	pointer
->	O
entries_index	long
,	O
block	pointer
->	O
entries	pointer
,	O
block	pointer
->	O
entries_slots	long
,	O
50	int
)	O
;	O
}	O
static	O
void	O
process_one_file	function
(	O
char	O
*	O
filename	pointer
,	O
FILE	struct
*	O
doc_stream	pointer
,	O
FILE	struct
*	O
funs_stream	pointer
)	O
{	O
int	O
descriptor	int
,	O
decl_len	int
;	O
char	O
*	O
buffer	pointer
,	O
*	O
decl_str	pointer
;	O
struct	O
stat	struct
finfo	struct
;	O
long	O
offset	long
;	O
long	O
file_size	long
;	O
EMACS_TAG_BLOCK	struct
*	O
block	pointer
;	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
finfo	struct
)	O
==	O
-	O
1	int
)	O
fatal_file_error	function
(	O
filename	pointer
)	O
;	O
descriptor	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDONLY	int
,	O
0666	int
)	O
;	O
if	O
(	O
descriptor	int
==	O
-	O
1	int
)	O
fatal_file_error	function
(	O
filename	pointer
)	O
;	O
file_size	long
=	O
(	O
long	O
)	O
finfo	struct
.	O
st_size	long
;	O
buffer	pointer
=	O
xmalloc	function
(	O
1	int
+	O
file_size	long
)	O
;	O
file_size	long
=	O
read	pointer
(	O
descriptor	int
,	O
buffer	pointer
,	O
file_size	long
)	O
;	O
close	pointer
(	O
descriptor	int
)	O
;	O
offset	long
=	O
0	int
;	O
decl_str	pointer
=	O
DECLARATION_STRING	pointer
;	O
decl_len	int
=	O
strlen	function
(	O
decl_str	pointer
)	O
;	O
block	pointer
=	O
make_emacs_tag_block	function
(	O
filename	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
long	O
point	long
=	O
0	int
;	O
long	O
line_start	long
=	O
0	int
;	O
int	O
line_number	int
=	O
0	int
;	O
char	O
*	O
func	pointer
,	O
*	O
doc	pointer
;	O
char	O
*	O
func_name	pointer
;	O
for	O
(	O
;	O
offset	long
<	O
(	O
file_size	long
-	O
decl_len	int
)	O
;	O
offset	long
++	O
)	O
{	O
if	O
(	O
buffer	pointer
[	O
offset	long
]	O
==	O
'\n'	O
)	O
{	O
line_number	int
++	O
;	O
line_start	long
=	O
offset	long
+	O
1	int
;	O
}	O
if	O
(	O
strncmp	function
(	O
buffer	pointer
+	O
offset	long
,	O
decl_str	pointer
,	O
decl_len	int
)	O
==	O
0	int
)	O
{	O
offset	long
+=	O
decl_len	int
;	O
point	long
=	O
offset	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
point	long
)	O
break	O
;	O
while	O
(	O
point	long
<	O
file_size	long
)	O
{	O
if	O
(	O
buffer	pointer
[	O
point	long
]	O
==	O
'\n'	O
)	O
{	O
line_number	int
++	O
;	O
line_start	long
=	O
point	long
+	O
1	int
;	O
}	O
else	O
if	O
(	O
buffer	pointer
[	O
point	long
]	O
==	O
'('	O
)	O
break	O
;	O
point	long
++	O
;	O
}	O
while	O
(	O
point	long
++	O
<	O
file_size	long
)	O
{	O
if	O
(	O
!	O
whitespace_or_newline	O
(	O
buffer	pointer
[	O
point	long
]	O
)	O
)	O
break	O
;	O
else	O
if	O
(	O
buffer	pointer
[	O
point	long
]	O
==	O
'\n'	O
)	O
{	O
line_number	int
++	O
;	O
line_start	long
=	O
point	long
+	O
1	int
;	O
}	O
}	O
if	O
(	O
point	long
>=	O
file_size	long
)	O
break	O
;	O
for	O
(	O
offset	long
=	O
point	long
;	O
buffer	pointer
[	O
offset	long
]	O
!=	O
','	O
;	O
offset	long
++	O
)	O
;	O
func	pointer
=	O
xmalloc	function
(	O
1	int
+	O
(	O
offset	long
-	O
point	long
)	O
)	O
;	O
strncpy	function
(	O
func	pointer
,	O
buffer	pointer
+	O
point	long
,	O
offset	long
-	O
point	long
)	O
;	O
func	pointer
[	O
offset	long
-	O
point	long
]	O
=	O
'\0'	O
;	O
{	O
char	O
*	O
tag_name	pointer
;	O
tag_name	pointer
=	O
xmalloc	function
(	O
1	int
+	O
(	O
offset	long
-	O
line_start	long
)	O
)	O
;	O
strncpy	function
(	O
tag_name	pointer
,	O
buffer	pointer
+	O
line_start	long
,	O
offset	long
-	O
line_start	long
)	O
;	O
tag_name	pointer
[	O
offset	long
-	O
line_start	long
]	O
=	O
'\0'	O
;	O
add_tag_to_block	function
(	O
block	pointer
,	O
tag_name	pointer
,	O
line_number	int
,	O
point	long
)	O
;	O
}	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
name_start	pointer
;	O
name_start	pointer
=	O
func	pointer
;	O
if	O
(	O
strncmp	function
(	O
name_start	pointer
,	O
"info_"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
name_start	pointer
+=	O
5	int
;	O
func_name	pointer
=	O
xstrdup	function
(	O
name_start	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
func_name	pointer
,	O
"ea_"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
temp_func_name	pointer
;	O
temp_func_name	pointer
=	O
xmalloc	function
(	O
10	int
+	O
strlen	function
(	O
func_name	pointer
)	O
)	O
;	O
strcpy	function
(	O
temp_func_name	pointer
,	O
"echo_area_"	pointer
)	O
;	O
strcat	function
(	O
temp_func_name	pointer
,	O
func_name	pointer
+	O
3	int
)	O
;	O
free	function
(	O
func_name	pointer
)	O
;	O
func_name	pointer
=	O
temp_func_name	pointer
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
func_name	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
func_name	pointer
[	O
i	int
]	O
==	O
'_'	O
)	O
func_name	pointer
[	O
i	int
]	O
=	O
'-'	O
;	O
}	O
point	long
=	O
offset	long
+	O
1	int
;	O
while	O
(	O
point	long
<	O
file_size	long
)	O
{	O
if	O
(	O
buffer	pointer
[	O
point	long
]	O
==	O
'\n'	O
)	O
{	O
line_number	int
++	O
;	O
line_start	long
=	O
point	long
+	O
1	int
;	O
}	O
if	O
(	O
buffer	pointer
[	O
point	long
]	O
==	O
'"'	O
)	O
break	O
;	O
else	O
point	long
++	O
;	O
}	O
offset	long
=	O
point	long
+	O
1	int
;	O
while	O
(	O
offset	long
<	O
file_size	long
)	O
{	O
if	O
(	O
buffer	pointer
[	O
offset	long
]	O
==	O
'\n'	O
)	O
{	O
line_number	int
++	O
;	O
line_start	long
=	O
offset	long
+	O
1	int
;	O
}	O
if	O
(	O
buffer	pointer
[	O
offset	long
]	O
==	O
'\\'	O
)	O
offset	long
+=	O
2	int
;	O
else	O
if	O
(	O
buffer	pointer
[	O
offset	long
]	O
==	O
'"'	O
)	O
break	O
;	O
else	O
offset	long
++	O
;	O
}	O
offset	long
++	O
;	O
if	O
(	O
offset	long
>=	O
file_size	long
)	O
break	O
;	O
doc	pointer
=	O
xmalloc	function
(	O
1	int
+	O
(	O
offset	long
-	O
point	long
)	O
)	O
;	O
strncpy	function
(	O
doc	pointer
,	O
buffer	pointer
+	O
point	long
,	O
offset	long
-	O
point	long
)	O
;	O
doc	pointer
[	O
offset	long
-	O
point	long
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
doc_stream	pointer
,	O
"   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },\n"	pointer
,	O
func	pointer
,	O
func_name	pointer
,	O
doc	pointer
)	O
;	O
free	function
(	O
func_name	pointer
)	O
;	O
fprintf	function
(	O
funs_stream	pointer
,	O
"#define A_%s %u\n"	pointer
,	O
func	pointer
,	O
next_func_key	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
funs_stream	pointer
,	O
"extern void %s (WINDOW *window, int count);\n"	pointer
,	O
func	pointer
)	O
;	O
free	function
(	O
func	pointer
)	O
;	O
free	function
(	O
doc	pointer
)	O
;	O
}	O
free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
block	pointer
->	O
entries	pointer
)	O
add_pointer_to_array	O
(	O
block	pointer
,	O
emacs_tags_index	long
,	O
emacs_tags	pointer
,	O
emacs_tags_slots	long
,	O
10	int
)	O
;	O
else	O
{	O
free	function
(	O
block	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
block	pointer
)	O
;	O
}	O
}	O
static	O
void	O
fatal_file_error	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Couldn't manipulate the file %s.\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
FILE	struct
*	O
must_fopen	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
mode	pointer
)	O
{	O
FILE	struct
*	O
stream	pointer
;	O
stream	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
mode	pointer
)	O
;	O
if	O
(	O
!	O
stream	pointer
)	O
fatal_file_error	function
(	O
filename	pointer
)	O
;	O
return	O
stream	pointer
;	O
}	O
static	O
unsigned	O
int	O
func_key	int
;	O
static	O
void	O
init_func_key	function
(	O
unsigned	O
int	O
val	int
)	O
{	O
func_key	int
=	O
val	int
;	O
}	O
static	O
unsigned	O
int	O
next_func_key	function
(	O
void	O
)	O
{	O
return	O
func_key	int
++	O
;	O
}	O
