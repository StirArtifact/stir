static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
ret	pointer
;	O
ret	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
malloc_check	O
(	O
ret	pointer
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
ret	pointer
;	O
ret	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
realloc_check	O
(	O
ret	pointer
,	O
size	long
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
static	O
char	O
*	O
xstrdup	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
ret	pointer
;	O
ret	pointer
=	O
strdup	function
(	O
s	pointer
)	O
;	O
malloc_check	O
(	O
ret	pointer
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
char	O
*	O
progbasename	pointer
;	O
int	O
sig_pipe	array
[	O
2	int
]	O
;	O
char	O
*	O
logmsg_submit_task	array
[	O
]	O
=	O
{	O
NULL	O
,	O
"unable to open "	pointer
PEXEC_DEFAULT_NULLFILE	pointer
" special file for reading"	pointer
,	O
"unable to redirect from input file: file cannot be opened"	pointer
,	O
"unable to open "	pointer
PEXEC_DEFAULT_NULLFILE	pointer
" special file for writing"	pointer
,	O
"unable to create internal pipes"	pointer
,	O
"unable to redirect to output file: file cannot be created"	pointer
,	O
"unable to redirect to error file: file cannot be created"	pointer
,	O
"unknown error"	pointer
,	O
NULL	O
}	O
;	O
int	O
log_message	function
(	O
logdata	struct
*	O
log	pointer
,	O
int	O
loglevel	int
,	O
parameter	struct
*	O
p	pointer
,	O
char	O
*	O
msg	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
if	O
(	O
log	pointer
->	O
fwlog	pointer
==	O
NULL	O
||	O
log	pointer
->	O
loglevel	int
<	O
loglevel	int
||	O
msg	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
log	pointer
->	O
fwlog	pointer
,	O
"[%s] "	pointer
,	O
p	pointer
->	O
name	pointer
)	O
;	O
va_start	O
(	O
ap	array
,	O
msg	pointer
)	O
;	O
vfprintf	function
(	O
log	pointer
->	O
fwlog	pointer
,	O
msg	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fprintf	function
(	O
log	pointer
->	O
fwlog	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
log	pointer
->	O
fwlog	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
background	function
(	O
int	O
nochdir	int
,	O
int	O
noclose	int
)	O
{	O
int	O
child_pid	int
;	O
int	O
nulldev_fd	int
;	O
child_pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
child_pid	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
child_pid	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
nochdir	int
)	O
chdir	function
(	O
"/"	pointer
)	O
;	O
if	O
(	O
!	O
noclose	int
)	O
{	O
nulldev_fd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
nulldev_fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
isatty	function
(	O
0	int
)	O
)	O
{	O
close	pointer
(	O
0	int
)	O
;	O
dup2	function
(	O
nulldev_fd	int
,	O
0	int
)	O
;	O
}	O
close	pointer
(	O
nulldev_fd	int
)	O
;	O
}	O
nulldev_fd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
nulldev_fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
isatty	function
(	O
1	int
)	O
)	O
{	O
close	pointer
(	O
1	int
)	O
;	O
dup2	function
(	O
nulldev_fd	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
isatty	function
(	O
2	int
)	O
)	O
{	O
close	pointer
(	O
2	int
)	O
;	O
dup2	function
(	O
nulldev_fd	int
,	O
2	int
)	O
;	O
}	O
close	pointer
(	O
nulldev_fd	int
)	O
;	O
}	O
}	O
}	O
else	O
exit	function
(	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
sig_act_child	function
(	O
int	O
signum	int
)	O
{	O
int	O
pid	int
,	O
ret	pointer
,	O
status	int
;	O
signalinfo	struct
sci	struct
;	O
if	O
(	O
sig_pipe	array
[	O
1	int
]	O
<	O
0	int
)	O
return	O
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	function
(	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
{	O
sci	struct
.	O
signal	function
=	O
SIGCHLD	int
;	O
sci	struct
.	O
pid	int
=	O
pid	int
;	O
sci	struct
.	O
exitstatus	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
sci	struct
.	O
exitsignal	int
=	O
WTERMSIG	O
(	O
status	int
)	O
;	O
else	O
sci	struct
.	O
exitsignal	int
=	O
-	O
1	int
;	O
ret	pointer
=	O
write	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
,	O
&	O
sci	struct
,	O
sizeof	O
(	O
signalinfo	struct
)	O
)	O
;	O
}	O
}	O
void	O
sig_act_interrupt	function
(	O
int	O
signum	int
)	O
{	O
signalinfo	struct
sci	struct
;	O
int	O
ret	pointer
;	O
if	O
(	O
sig_pipe	array
[	O
1	int
]	O
<	O
0	int
)	O
return	O
;	O
sci	struct
.	O
signal	function
=	O
signum	int
;	O
sci	struct
.	O
pid	int
=	O
0	int
;	O
sci	struct
.	O
exitstatus	int
=	O
0	int
;	O
sci	struct
.	O
exitsignal	int
=	O
!	O
0	int
;	O
ret	pointer
=	O
write	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
,	O
&	O
sci	struct
,	O
sizeof	O
(	O
signalinfo	struct
)	O
)	O
;	O
}	O
int	O
fdwait	function
(	O
int	O
fd	int
,	O
int	O
timeout	int
)	O
{	O
fd_set	struct
set	struct
;	O
struct	O
timeval	struct
tv	struct
;	O
int	O
ret	pointer
;	O
FD_ZERO	O
(	O
&	O
set	struct
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
timeout	int
>	O
0	int
)	O
{	O
tv	struct
.	O
tv_sec	long
=	O
timeout	int
;	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
ret	pointer
=	O
select	function
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct
)	O
;	O
}	O
else	O
ret	pointer
=	O
select	function
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
int	O
env_export	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
value	pointer
)	O
{	O
int	O
ret	pointer
;	O
ret	pointer
=	O
setenv	function
(	O
name	pointer
,	O
value	pointer
,	O
!	O
0	int
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
int	O
is_nasty_char	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
isalnum	function
(	O
c	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
'-'	O
||	O
c	int
==	O
'+'	O
||	O
c	int
==	O
'@'	O
||	O
c	int
==	O
'^'	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
'_'	O
||	O
c	int
==	O
'='	O
||	O
c	int
==	O
':'	O
||	O
c	int
==	O
'/'	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
','	O
||	O
c	int
==	O
'.'	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
get_nasty_char_number	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
*	O
arg	pointer
;	O
arg	pointer
++	O
)	O
{	O
if	O
(	O
is_nasty_char	function
(	O
*	O
arg	pointer
)	O
)	O
n	int
++	O
;	O
}	O
return	O
(	O
n	int
)	O
;	O
}	O
char	O
*	O
concatenate_arguments	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
command	struct
;	O
int	O
len	int
,	O
i	int
,	O
l	int
;	O
len	int
=	O
0	int
;	O
command	struct
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
l	int
=	O
strlen	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
command	struct
==	O
NULL	O
)	O
command	struct
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
l	int
+	O
1	int
)	O
;	O
else	O
{	O
command	struct
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
command	struct
,	O
len	int
+	O
1	int
+	O
l	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
command	struct
+	O
len	int
,	O
" "	pointer
)	O
;	O
len	int
++	O
;	O
}	O
strcpy	function
(	O
command	struct
+	O
len	int
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
len	int
+=	O
l	int
;	O
}	O
if	O
(	O
command	struct
==	O
NULL	O
)	O
command	struct
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
16	int
)	O
;	O
command	struct
[	O
len	int
]	O
=	O
0	int
;	O
return	O
(	O
command	struct
)	O
;	O
}	O
static	O
int	O
daemon_commandtoken_is_nasty	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
<=	O
32	int
||	O
c	int
>=	O
127	int
||	O
c	int
==	O
'\"'	O
||	O
c	int
==	O
'\''	O
||	O
c	int
==	O
'\\'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
hex_digit	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
'0'	O
<=	O
c	int
&&	O
c	int
<=	O
'9'	O
)	O
return	O
(	O
c	int
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
'a'	O
<=	O
c	int
&&	O
c	int
<=	O
'f'	O
)	O
return	O
(	O
c	int
-	O
'a'	O
+	O
10	int
)	O
;	O
else	O
if	O
(	O
'A'	O
<=	O
c	int
&&	O
c	int
<=	O
'F'	O
)	O
return	O
(	O
c	int
-	O
'A'	O
+	O
10	int
)	O
;	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
char	O
*	O
daemon_commandtoken_escape	function
(	O
char	O
*	O
buff	pointer
,	O
int	O
size	long
)	O
{	O
int	O
l	int
,	O
s	pointer
,	O
c	int
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
out	pointer
;	O
if	O
(	O
buff	pointer
==	O
NULL	O
)	O
return	O
(	O
NULL	O
)	O
;	O
l	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
buff	pointer
,	O
s	pointer
=	O
size	long
;	O
s	pointer
>	O
0	int
;	O
p	pointer
++	O
,	O
s	pointer
--	O
)	O
{	O
if	O
(	O
daemon_commandtoken_is_nasty	function
(	O
(	O
int	O
)	O
(	O
*	O
p	pointer
)	O
)	O
)	O
l	int
+=	O
3	int
;	O
else	O
l	int
++	O
;	O
}	O
out	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
l	int
+	O
1	int
)	O
;	O
for	O
(	O
p	pointer
=	O
buff	pointer
,	O
q	pointer
=	O
out	pointer
,	O
s	pointer
=	O
size	long
;	O
s	pointer
>	O
0	int
;	O
p	pointer
++	O
,	O
s	pointer
--	O
)	O
{	O
if	O
(	O
daemon_commandtoken_is_nasty	function
(	O
(	O
int	O
)	O
(	O
*	O
p	pointer
)	O
)	O
)	O
{	O
c	int
=	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
p	pointer
)	O
;	O
sprintf	function
(	O
q	pointer
,	O
"\\%.2X"	pointer
,	O
c	int
)	O
;	O
q	pointer
+=	O
3	int
;	O
}	O
else	O
{	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
q	pointer
++	O
;	O
}	O
}	O
*	O
q	pointer
=	O
0	int
;	O
return	O
(	O
out	pointer
)	O
;	O
}	O
char	O
*	O
daemon_commandtoken_escape_string	function
(	O
char	O
*	O
buff	pointer
)	O
{	O
int	O
len	int
;	O
if	O
(	O
buff	pointer
==	O
NULL	O
||	O
(	O
len	int
=	O
strlen	function
(	O
buff	pointer
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
NULL	O
)	O
;	O
else	O
return	O
(	O
daemon_commandtoken_escape	function
(	O
buff	pointer
,	O
len	int
)	O
)	O
;	O
}	O
int	O
daemon_commandtoken_unescape	function
(	O
char	O
*	O
buff	pointer
)	O
{	O
char	O
*	O
out	pointer
;	O
int	O
h1	int
,	O
h2	int
,	O
ret	pointer
;	O
ret	pointer
=	O
0	int
;	O
for	O
(	O
out	pointer
=	O
buff	pointer
;	O
*	O
buff	pointer
;	O
)	O
{	O
if	O
(	O
*	O
buff	pointer
==	O
'\\'	O
&&	O
(	O
h1	int
=	O
hex_digit	function
(	O
(	O
int	O
)	O
(	O
*	O
(	O
buff	pointer
+	O
1	int
)	O
)	O
)	O
)	O
>=	O
0	int
&&	O
(	O
h2	int
=	O
hex_digit	function
(	O
(	O
int	O
)	O
(	O
*	O
(	O
buff	pointer
+	O
2	int
)	O
)	O
)	O
)	O
>=	O
0	int
)	O
{	O
*	O
out	pointer
=	O
h1	int
*	O
16	int
+	O
h2	int
;	O
buff	pointer
+=	O
3	int
;	O
out	pointer
++	O
;	O
}	O
else	O
{	O
*	O
out	pointer
=	O
*	O
buff	pointer
;	O
buff	pointer
++	O
;	O
out	pointer
++	O
;	O
}	O
ret	pointer
++	O
;	O
}	O
*	O
out	pointer
=	O
0	int
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
int	O
hprintf	function
(	O
int	O
handle	int
,	O
char	O
*	O
msg	pointer
,	O
...	O
)	O
{	O
char	O
buff	pointer
[	O
HPRINT_BUFFER_SIZE	int
]	O
,	O
*	O
tbuff	pointer
;	O
va_list	array
ap	array
;	O
int	O
n	int
;	O
va_start	O
(	O
ap	array
,	O
msg	pointer
)	O
;	O
n	int
=	O
vsnprintf	function
(	O
buff	pointer
,	O
HPRINT_BUFFER_SIZE	int
,	O
msg	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
n	int
<	O
HPRINT_BUFFER_SIZE	int
)	O
{	O
write	pointer
(	O
handle	int
,	O
buff	pointer
,	O
n	int
)	O
;	O
return	O
(	O
n	int
)	O
;	O
}	O
else	O
{	O
tbuff	pointer
=	O
NULL	O
;	O
va_start	O
(	O
ap	array
,	O
msg	pointer
)	O
;	O
vstrappendf	function
(	O
&	O
tbuff	pointer
,	O
msg	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
tbuff	pointer
!=	O
NULL	O
)	O
{	O
n	int
=	O
strlen	function
(	O
tbuff	pointer
)	O
;	O
write	pointer
(	O
handle	int
,	O
tbuff	pointer
,	O
n	int
)	O
;	O
free	function
(	O
tbuff	pointer
)	O
;	O
}	O
else	O
n	int
=	O
0	int
;	O
return	O
(	O
n	int
)	O
;	O
}	O
}	O
int	O
get_number_of_cpus_proccpuinfo	function
(	O
void	O
)	O
{	O
FILE	struct
*	O
fr	pointer
;	O
char	O
buff	pointer
[	O
BUFF_LEN	int
]	O
;	O
int	O
ncpu	int
,	O
i	int
,	O
j	int
;	O
fr	pointer
=	O
fopen	function
(	O
"/proc/cpuinfo"	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
fr	pointer
!=	O
NULL	O
)	O
{	O
ncpu	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	function
(	O
fr	pointer
)	O
)	O
{	O
if	O
(	O
fgets	function
(	O
buff	pointer
,	O
BUFF_LEN	int
-	O
1	int
,	O
fr	pointer
)	O
==	O
NULL	O
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	function
(	O
buff	pointer
)	O
;	O
)	O
{	O
if	O
(	O
buff	pointer
[	O
i	int
]	O
==	O
10	int
||	O
buff	pointer
[	O
i	int
]	O
==	O
9	int
||	O
buff	pointer
[	O
i	int
]	O
==	O
13	int
||	O
buff	pointer
[	O
i	int
]	O
==	O
32	int
)	O
memmove	function
(	O
buff	pointer
+	O
i	int
,	O
buff	pointer
+	O
i	int
+	O
1	int
,	O
strlen	function
(	O
buff	pointer
+	O
i	int
)	O
)	O
;	O
else	O
i	int
++	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
strlen	function
(	O
buff	pointer
)	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
buff	pointer
[	O
j	int
]	O
==	O
':'	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
strlen	function
(	O
buff	pointer
)	O
)	O
continue	O
;	O
buff	pointer
[	O
j	int
]	O
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
"processor"	pointer
)	O
==	O
0	int
)	O
ncpu	int
++	O
;	O
}	O
;	O
fclose	function
(	O
fr	pointer
)	O
;	O
}	O
else	O
ncpu	int
=	O
0	int
;	O
return	O
(	O
ncpu	int
)	O
;	O
}	O
int	O
get_number_of_cpus_sysconf	function
(	O
void	O
)	O
{	O
int	O
ncpu	int
;	O
ncpu	int
=	O
sysconf	function
(	O
_SC_NPROCESSORS_ONLN	int
)	O
;	O
return	O
(	O
ncpu	int
)	O
;	O
}	O
int	O
get_number_of_cpus	function
(	O
void	O
)	O
{	O
int	O
ncpu	int
,	O
w	int
;	O
ncpu	int
=	O
get_number_of_cpus_proccpuinfo	function
(	O
)	O
;	O
w	int
=	O
get_number_of_cpus_sysconf	function
(	O
)	O
;	O
if	O
(	O
w	int
>	O
0	int
&&	O
ncpu	int
>	O
0	int
)	O
ncpu	int
=	O
(	O
w	int
<	O
ncpu	int
?	O
w	int
:	O
ncpu	int
)	O
;	O
if	O
(	O
ncpu	int
<=	O
0	int
)	O
ncpu	int
=	O
1	int
;	O
return	O
(	O
ncpu	int
)	O
;	O
}	O
int	O
get_bit_size	function
(	O
int	O
n	int
)	O
{	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
n	int
>	O
0	int
;	O
n	int
/=	O
2	int
)	O
{	O
r	int
++	O
;	O
}	O
return	O
(	O
r	int
)	O
;	O
}	O
child	struct
*	O
get_child_by_pid	function
(	O
child	struct
*	O
cc	pointer
,	O
int	O
pid	int
)	O
{	O
for	O
(	O
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
pid	int
==	O
pid	int
)	O
return	O
(	O
cc	pointer
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
child	struct
*	O
get_child_by_id	function
(	O
child	struct
*	O
cc	pointer
,	O
int	O
id	int
)	O
{	O
for	O
(	O
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
id	int
==	O
id	int
)	O
return	O
(	O
cc	pointer
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
imutex	struct
*	O
get_imutex_by_name	function
(	O
imutex	struct
*	O
mx	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
for	O
(	O
;	O
mx	pointer
!=	O
NULL	O
;	O
mx	pointer
=	O
mx	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
mx	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
(	O
mx	pointer
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
int	O
fd_avail	function
(	O
int	O
fd	int
)	O
{	O
fd_set	struct
set	struct
;	O
struct	O
timeval	struct
tv	struct
;	O
FD_ZERO	O
(	O
&	O
set	struct
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
set	struct
)	O
;	O
tv	struct
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
select	function
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
set	struct
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
char	O
*	O
fileformat_replace	function
(	O
char	O
*	O
format	pointer
,	O
parameter	struct
*	O
par	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
format_replace	function
(	O
format	pointer
,	O
0	int
,	O
's'	O
,	O
FORMAT_STRING	int
,	O
par	pointer
->	O
name	pointer
,	O
'k'	O
,	O
FORMAT_STRING	int
,	O
par	pointer
->	O
id	int
,	O
'd'	O
,	O
FORMAT_STRING	int
,	O
par	pointer
->	O
id	int
+	O
1	int
,	O
0	int
)	O
;	O
return	O
(	O
name	pointer
)	O
;	O
}	O
int	O
submit_task	function
(	O
paralleldata	struct
*	O
p	pointer
,	O
parameter	struct
*	O
par	pointer
,	O
child	struct
*	O
c	int
,	O
int	O
no_format_replace	int
,	O
parallelstatus	struct
*	O
ps	pointer
)	O
{	O
int	O
stdfd	array
[	O
3	int
]	O
;	O
int	O
pipeout	array
[	O
2	int
]	O
,	O
pipeerr	array
[	O
2	int
]	O
;	O
int	O
pid	int
;	O
if	O
(	O
par	pointer
->	O
no_touch_std	int
)	O
{	O
stdfd	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
stdfd	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
stdfd	array
[	O
2	int
]	O
=	O
-	O
1	int
;	O
pipeout	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeout	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
in	pointer
==	O
NULL	O
)	O
{	O
stdfd	array
[	O
0	int
]	O
=	O
open	function
(	O
PEXEC_DEFAULT_NULLFILE	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
stdfd	array
[	O
0	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
inname	pointer
;	O
if	O
(	O
no_format_replace	int
)	O
stdfd	array
[	O
0	int
]	O
=	O
open	function
(	O
p	pointer
->	O
in	pointer
,	O
O_RDONLY	int
)	O
;	O
else	O
{	O
inname	pointer
=	O
fileformat_replace	function
(	O
p	pointer
->	O
in	pointer
,	O
par	pointer
)	O
;	O
stdfd	array
[	O
0	int
]	O
=	O
open	function
(	O
inname	pointer
,	O
O_RDONLY	int
)	O
;	O
free	function
(	O
inname	pointer
)	O
;	O
}	O
if	O
(	O
stdfd	array
[	O
0	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
2	int
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
out	pointer
==	O
NULL	O
)	O
{	O
stdfd	array
[	O
1	int
]	O
=	O
open	function
(	O
PEXEC_DEFAULT_NULLFILE	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
stdfd	array
[	O
1	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
3	int
)	O
;	O
pipeout	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeout	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
fwout	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
pipe	function
(	O
pipeout	array
)	O
)	O
return	O
(	O
-	O
4	int
)	O
;	O
stdfd	array
[	O
1	int
]	O
=	O
pipeout	array
[	O
1	int
]	O
;	O
}	O
else	O
{	O
char	O
*	O
outname	pointer
;	O
if	O
(	O
no_format_replace	int
)	O
stdfd	array
[	O
1	int
]	O
=	O
open	function
(	O
p	pointer
->	O
out	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
else	O
{	O
outname	pointer
=	O
fileformat_replace	function
(	O
p	pointer
->	O
out	pointer
,	O
par	pointer
)	O
;	O
stdfd	array
[	O
1	int
]	O
=	O
open	function
(	O
outname	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
free	function
(	O
outname	pointer
)	O
;	O
}	O
if	O
(	O
stdfd	array
[	O
1	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
5	int
)	O
;	O
pipeout	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeout	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
p	pointer
->	O
err	long
==	O
NULL	O
)	O
{	O
stdfd	array
[	O
2	int
]	O
=	O
open	function
(	O
PEXEC_DEFAULT_NULLFILE	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
stdfd	array
[	O
2	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
3	int
)	O
;	O
pipeerr	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
fwerr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
pipe	function
(	O
pipeerr	array
)	O
)	O
return	O
(	O
-	O
4	int
)	O
;	O
stdfd	array
[	O
2	int
]	O
=	O
pipeerr	array
[	O
1	int
]	O
;	O
}	O
else	O
{	O
char	O
*	O
errname	pointer
;	O
if	O
(	O
no_format_replace	int
)	O
stdfd	array
[	O
2	int
]	O
=	O
open	function
(	O
p	pointer
->	O
err	long
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
else	O
{	O
errname	pointer
=	O
fileformat_replace	function
(	O
p	pointer
->	O
err	long
,	O
par	pointer
)	O
;	O
stdfd	array
[	O
2	int
]	O
=	O
open	function
(	O
errname	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
free	function
(	O
errname	pointer
)	O
;	O
}	O
if	O
(	O
stdfd	array
[	O
2	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
6	int
)	O
;	O
pipeerr	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
-	O
4	int
)	O
;	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
if	O
(	O
pipeout	array
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
c	int
->	O
fdstdout	int
=	O
pipeout	array
[	O
0	int
]	O
;	O
close	pointer
(	O
pipeout	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
c	int
->	O
fdstdout	int
=	O
-	O
1	int
;	O
if	O
(	O
stdfd	array
[	O
1	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
stdfd	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
pipeerr	array
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
c	int
->	O
fdstderr	int
=	O
pipeerr	array
[	O
0	int
]	O
;	O
close	pointer
(	O
pipeerr	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
c	int
->	O
fdstderr	int
=	O
-	O
1	int
;	O
if	O
(	O
stdfd	array
[	O
2	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
stdfd	array
[	O
2	int
]	O
)	O
;	O
}	O
if	O
(	O
stdfd	array
[	O
0	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
stdfd	array
[	O
0	int
]	O
)	O
;	O
return	O
(	O
pid	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pipeout	array
[	O
0	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
pipeout	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
pipeerr	array
[	O
0	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
pipeerr	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ps	pointer
!=	O
NULL	O
)	O
{	O
client	struct
*	O
cl	pointer
;	O
child	struct
*	O
cc	pointer
;	O
for	O
(	O
cl	pointer
=	O
ps	pointer
->	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cl	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cl	pointer
->	O
peer	int
>=	O
0	int
)	O
close	pointer
(	O
cl	pointer
->	O
peer	int
)	O
;	O
}	O
if	O
(	O
ps	pointer
->	O
sock	int
>=	O
0	int
)	O
close	pointer
(	O
ps	pointer
->	O
sock	int
)	O
;	O
if	O
(	O
ps	pointer
->	O
hsck	int
>=	O
0	int
)	O
close	pointer
(	O
ps	pointer
->	O
hsck	int
)	O
;	O
for	O
(	O
cc	pointer
=	O
ps	pointer
->	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
)	O
close	pointer
(	O
cc	pointer
->	O
fdstdout	int
)	O
;	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
)	O
close	pointer
(	O
cc	pointer
->	O
fdstderr	int
)	O
;	O
}	O
}	O
if	O
(	O
stdfd	array
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
close	pointer
(	O
0	int
)	O
;	O
dup2	function
(	O
stdfd	array
[	O
0	int
]	O
,	O
0	int
)	O
;	O
close	pointer
(	O
stdfd	array
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
stdfd	array
[	O
1	int
]	O
>=	O
0	int
)	O
{	O
close	pointer
(	O
1	int
)	O
;	O
dup2	function
(	O
stdfd	array
[	O
1	int
]	O
,	O
1	int
)	O
;	O
close	pointer
(	O
stdfd	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
stdfd	array
[	O
2	int
]	O
>=	O
0	int
)	O
{	O
close	pointer
(	O
2	int
)	O
;	O
dup2	function
(	O
stdfd	array
[	O
2	int
]	O
,	O
2	int
)	O
;	O
close	pointer
(	O
stdfd	array
[	O
2	int
]	O
)	O
;	O
}	O
close	pointer
(	O
sig_pipe	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
p	pointer
->	O
envvarname	pointer
!=	O
NULL	O
&&	O
par	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
env_export	function
(	O
p	pointer
->	O
envvarname	pointer
,	O
par	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
par	pointer
->	O
c	int
.	O
is_shell	int
>	O
0	int
)	O
{	O
char	O
*	O
argv	pointer
[	O
4	int
]	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
p	pointer
->	O
shell	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
"-c"	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
concatenate_arguments	function
(	O
par	pointer
->	O
c	int
.	O
argc	int
,	O
par	pointer
->	O
c	int
.	O
argv	pointer
)	O
;	O
argv	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
execv	function
(	O
p	pointer
->	O
shell	pointer
,	O
argv	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unable to execute the shell '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
p	pointer
->	O
shell	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
par	pointer
->	O
c	int
.	O
is_shell	int
<	O
0	int
)	O
{	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
i	int
,	O
argc	int
,	O
n	int
;	O
n	int
=	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
p	pointer
->	O
rshargs	pointer
[	O
n	int
]	O
!=	O
NULL	O
;	O
)	O
n	int
++	O
;	O
argc	int
=	O
n	int
+	O
1	int
+	O
par	pointer
->	O
c	int
.	O
argc	int
+	O
1	int
;	O
argv	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
+	O
1	int
)	O
)	O
;	O
argc	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
argv	pointer
[	O
argc	int
]	O
=	O
p	pointer
->	O
rshargs	pointer
[	O
i	int
]	O
;	O
argc	int
++	O
;	O
}	O
if	O
(	O
par	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
{	O
argv	pointer
[	O
argc	int
]	O
=	O
par	pointer
->	O
name	pointer
;	O
argc	int
++	O
;	O
}	O
else	O
{	O
argv	pointer
[	O
argc	int
]	O
=	O
"localhost"	pointer
;	O
argc	int
++	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
par	pointer
->	O
c	int
.	O
argc	int
;	O
i	int
++	O
)	O
{	O
argv	pointer
[	O
argc	int
]	O
=	O
par	pointer
->	O
c	int
.	O
argv	pointer
[	O
i	int
]	O
;	O
argc	int
++	O
;	O
}	O
argv	pointer
[	O
argc	int
]	O
=	O
NULL	O
;	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unable to execute the remote shell command '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
i	int
,	O
argc	int
;	O
argc	int
=	O
par	pointer
->	O
c	int
.	O
argc	int
;	O
argv	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
argv	pointer
[	O
i	int
]	O
=	O
par	pointer
->	O
c	int
.	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
argv	pointer
[	O
argc	int
]	O
=	O
NULL	O
;	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unable to execute the command '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
}	O
return	O
(	O
-	O
7	int
)	O
;	O
}	O
int	O
send_task	function
(	O
paralleldata	struct
*	O
p	pointer
,	O
parameter	struct
*	O
par	pointer
,	O
child	struct
*	O
cc	pointer
)	O
{	O
char	O
*	O
*	O
args	pointer
,	O
*	O
token	pointer
;	O
int	O
a	int
,	O
i	int
;	O
args	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
16	int
)	O
;	O
for	O
(	O
a	int
=	O
0	int
;	O
a	int
<	O
16	int
;	O
a	int
++	O
)	O
{	O
args	pointer
[	O
a	int
]	O
=	O
NULL	O
;	O
}	O
a	int
=	O
0	int
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"execute"	pointer
)	O
;	O
a	int
++	O
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"identifier=%d"	pointer
,	O
par	pointer
->	O
id	int
)	O
;	O
a	int
++	O
;	O
if	O
(	O
p	pointer
->	O
envvarname	pointer
!=	O
NULL	O
&&	O
par	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
{	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"envname=%s"	pointer
,	O
p	pointer
->	O
envvarname	pointer
)	O
;	O
a	int
++	O
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"envvalue=%s"	pointer
,	O
par	pointer
->	O
name	pointer
)	O
;	O
a	int
++	O
;	O
}	O
if	O
(	O
p	pointer
->	O
in	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
inname	pointer
;	O
inname	pointer
=	O
fileformat_replace	function
(	O
p	pointer
->	O
in	pointer
,	O
par	pointer
)	O
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"in=%s"	pointer
,	O
inname	pointer
)	O
;	O
a	int
++	O
;	O
free	function
(	O
inname	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
out	pointer
!=	O
NULL	O
&&	O
p	pointer
->	O
fwout	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
outname	pointer
;	O
outname	pointer
=	O
fileformat_replace	function
(	O
p	pointer
->	O
out	pointer
,	O
par	pointer
)	O
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"out=%s"	pointer
,	O
outname	pointer
)	O
;	O
a	int
++	O
;	O
free	function
(	O
outname	pointer
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
fwout	pointer
!=	O
NULL	O
)	O
{	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"out=-"	pointer
)	O
;	O
a	int
++	O
;	O
}	O
if	O
(	O
p	pointer
->	O
err	long
!=	O
NULL	O
&&	O
p	pointer
->	O
fwerr	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
errname	pointer
;	O
errname	pointer
=	O
fileformat_replace	function
(	O
p	pointer
->	O
err	long
,	O
par	pointer
)	O
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"err=%s"	pointer
,	O
errname	pointer
)	O
;	O
a	int
++	O
;	O
free	function
(	O
errname	pointer
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
fwerr	pointer
!=	O
NULL	O
)	O
{	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"err=-"	pointer
)	O
;	O
a	int
++	O
;	O
}	O
if	O
(	O
par	pointer
->	O
c	int
.	O
is_shell	int
)	O
{	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"shell=%s"	pointer
,	O
p	pointer
->	O
shell	pointer
)	O
;	O
a	int
++	O
;	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"-"	pointer
)	O
;	O
a	int
++	O
;	O
args	pointer
[	O
a	int
]	O
=	O
concatenate_arguments	function
(	O
par	pointer
->	O
c	int
.	O
argc	int
,	O
par	pointer
->	O
c	int
.	O
argv	pointer
)	O
;	O
a	int
++	O
;	O
}	O
else	O
{	O
strappendf	function
(	O
&	O
args	pointer
[	O
a	int
]	O
,	O
"-"	pointer
)	O
;	O
a	int
++	O
;	O
args	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
args	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
16	int
+	O
par	pointer
->	O
c	int
.	O
argc	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
par	pointer
->	O
c	int
.	O
argc	int
;	O
i	int
++	O
)	O
{	O
args	pointer
[	O
a	int
]	O
=	O
xstrdup	function
(	O
par	pointer
->	O
c	int
.	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
a	int
++	O
;	O
}	O
}	O
args	pointer
[	O
a	int
]	O
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
a	int
;	O
i	int
++	O
)	O
{	O
token	pointer
=	O
daemon_commandtoken_escape_string	function
(	O
args	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
i	int
<	O
a	int
-	O
1	int
)	O
hprintf	function
(	O
cc	pointer
->	O
rs	pointer
->	O
fhsend	int
,	O
"%s "	pointer
,	O
token	pointer
)	O
;	O
else	O
hprintf	function
(	O
cc	pointer
->	O
rs	pointer
->	O
fhsend	int
,	O
"%s\n"	pointer
,	O
token	pointer
)	O
;	O
free	function
(	O
token	pointer
)	O
;	O
free	function
(	O
args	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
args	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
size_t	long
read_fd_block	function
(	O
int	O
fd	int
,	O
void	O
*	O
data	pointer
,	O
size_t	long
size	long
)	O
{	O
char	O
*	O
cdata	pointer
;	O
ssize_t	long
rd	long
;	O
size_t	long
tr	long
;	O
cdata	pointer
=	O
data	pointer
;	O
tr	long
=	O
0	int
;	O
while	O
(	O
size	long
>	O
0	int
)	O
{	O
rd	long
=	O
read	pointer
(	O
fd	int
,	O
cdata	pointer
,	O
size	long
)	O
;	O
if	O
(	O
rd	long
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
else	O
if	O
(	O
rd	long
<=	O
0	int
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
size	long
-=	O
rd	long
;	O
cdata	pointer
+=	O
rd	long
;	O
tr	long
+=	O
rd	long
;	O
}	O
}	O
;	O
return	O
(	O
tr	long
)	O
;	O
}	O
int	O
read_signalinfo	function
(	O
int	O
fd	int
,	O
signalinfo	struct
*	O
sci	struct
)	O
{	O
return	O
(	O
(	O
int	O
)	O
read_fd_block	function
(	O
fd	int
,	O
sci	struct
,	O
sizeof	O
(	O
signalinfo	struct
)	O
)	O
)	O
;	O
}	O
int	O
write_out_line	function
(	O
FILE	struct
*	O
fw	pointer
,	O
char	O
*	O
format	pointer
,	O
char	O
*	O
lbuffer	pointer
,	O
parameter	struct
*	O
p	pointer
,	O
int	O
omit_newlines	int
)	O
{	O
char	O
*	O
outline	pointer
;	O
size_t	long
len	int
;	O
outline	pointer
=	O
format_replace	function
(	O
format	pointer
,	O
1	int
,	O
'k'	O
,	O
FORMAT_INTEGER	int
,	O
p	pointer
->	O
id	int
,	O
'd'	O
,	O
FORMAT_INTEGER	int
,	O
p	pointer
->	O
id	int
+	O
1	int
,	O
's'	O
,	O
FORMAT_STRING	int
,	O
p	pointer
->	O
name	pointer
,	O
'l'	O
,	O
FORMAT_STRING	int
,	O
lbuffer	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
outline	pointer
!=	O
NULL	O
)	O
{	O
len	int
=	O
strlen	function
(	O
outline	pointer
)	O
;	O
if	O
(	O
omit_newlines	int
)	O
fwrite	function
(	O
outline	pointer
,	O
1	int
,	O
len	int
,	O
fw	pointer
)	O
;	O
else	O
fprintf	function
(	O
fw	pointer
,	O
"%s\n"	pointer
,	O
outline	pointer
)	O
;	O
fflush	function
(	O
fw	pointer
)	O
;	O
free	function
(	O
outline	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
write_output	function
(	O
char	O
*	O
buff	pointer
,	O
size_t	long
n	int
,	O
FILE	struct
*	O
fw	pointer
,	O
char	O
*	O
format	pointer
,	O
int	O
omit_newlines	int
,	O
linebuffer	struct
*	O
lb	pointer
,	O
parameter	struct
*	O
p	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
if	O
(	O
fw	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
buff	pointer
==	O
NULL	O
)	O
n	int
=	O
0	int
;	O
if	O
(	O
format	pointer
==	O
NULL	O
||	O
lb	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
n	int
>	O
0	int
&&	O
buff	pointer
!=	O
NULL	O
)	O
{	O
fwrite	function
(	O
buff	pointer
,	O
1	int
,	O
n	int
,	O
fw	pointer
)	O
;	O
fflush	function
(	O
fw	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
format	pointer
!=	O
NULL	O
&&	O
lb	pointer
!=	O
NULL	O
)	O
{	O
linebuffer_concatenate	function
(	O
lb	pointer
,	O
buff	pointer
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
lb	pointer
)	O
)	O
!=	O
NULL	O
||	O
(	O
buff	pointer
==	O
NULL	O
&&	O
(	O
line	pointer
=	O
linebuffer_flush	function
(	O
lb	pointer
)	O
)	O
!=	O
NULL	O
)	O
)	O
{	O
write_out_line	function
(	O
fw	pointer
,	O
format	pointer
,	O
line	pointer
,	O
p	pointer
,	O
omit_newlines	int
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
imutex_cleanup	function
(	O
imutex	struct
*	O
mx	pointer
,	O
int	O
qid	int
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
i	int
,	O
j	int
,	O
r	int
;	O
for	O
(	O
;	O
mx	pointer
!=	O
NULL	O
;	O
mx	pointer
=	O
mx	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
mx	pointer
->	O
pclients	pointer
==	O
NULL	O
||	O
mx	pointer
->	O
npclient	int
<=	O
0	int
)	O
continue	O
;	O
r	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mx	pointer
->	O
npclient	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
.	O
qid	int
==	O
qid	int
&&	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
.	O
data	pointer
==	O
data	pointer
)	O
{	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
.	O
qid	int
=	O
-	O
1	int
;	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
.	O
data	pointer
=	O
NULL	O
;	O
r	int
++	O
;	O
}	O
}	O
if	O
(	O
r	int
==	O
mx	pointer
->	O
npclient	int
)	O
{	O
free	function
(	O
mx	pointer
->	O
pclients	pointer
)	O
;	O
mx	pointer
->	O
pclients	pointer
=	O
NULL	O
;	O
mx	pointer
->	O
npclient	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
r	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
i	int
<	O
mx	pointer
->	O
npclient	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
.	O
qid	int
<	O
0	int
&&	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
.	O
data	pointer
==	O
NULL	O
)	O
)	O
{	O
mx	pointer
->	O
pclients	pointer
[	O
j	int
]	O
=	O
mx	pointer
->	O
pclients	pointer
[	O
i	int
]	O
;	O
j	int
++	O
;	O
}	O
}	O
mx	pointer
->	O
npclient	int
=	O
j	int
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
imutex_lock_get_params	function
(	O
char	O
*	O
*	O
cmd	pointer
,	O
char	O
*	O
*	O
rname	pointer
,	O
int	O
*	O
rmaxnum	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
i	int
,	O
maxnum	int
;	O
name	pointer
=	O
NULL	O
;	O
maxnum	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"-m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"--maximum"	pointer
)	O
==	O
0	int
)	O
&&	O
cmd	pointer
[	O
i	int
+	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
i	int
++	O
;	O
sscanf	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
maxnum	int
)	O
;	O
}	O
else	O
if	O
(	O
cmd	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
cmd	pointer
[	O
i	int
]	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
rname	pointer
=	O
name	pointer
;	O
*	O
rmaxnum	pointer
=	O
maxnum	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
imutex_unlock_get_params	function
(	O
char	O
*	O
*	O
cmd	pointer
,	O
char	O
*	O
*	O
rname	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
i	int
;	O
name	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cmd	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
cmd	pointer
[	O
i	int
]	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
rname	pointer
=	O
name	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
imutex_mutex_get_params	function
(	O
char	O
*	O
*	O
cmd	pointer
,	O
char	O
*	O
*	O
rname	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
i	int
;	O
name	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cmd	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
cmd	pointer
[	O
i	int
]	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
rname	pointer
=	O
name	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_client_master_parse_command_tokens	function
(	O
char	O
*	O
*	O
cmd	pointer
,	O
parallelstatus	struct
*	O
ps	pointer
,	O
int	O
qid	int
,	O
void	O
*	O
dd	pointer
)	O
{	O
time_t	long
tc	long
;	O
int	O
i	int
,	O
ret	pointer
;	O
remoteshell	struct
*	O
rs	pointer
;	O
client	struct
*	O
cl	pointer
;	O
if	O
(	O
qid	int
>=	O
0	int
)	O
{	O
rs	pointer
=	O
(	O
remoteshell	struct
*	O
)	O
dd	pointer
;	O
cl	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
rs	pointer
=	O
NULL	O
;	O
cl	pointer
=	O
(	O
client	struct
*	O
)	O
dd	pointer
;	O
}	O
if	O
(	O
cmd	pointer
==	O
NULL	O
||	O
cmd	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"status"	pointer
)	O
==	O
0	int
)	O
{	O
time	struct
(	O
&	O
tc	long
)	O
;	O
if	O
(	O
qid	int
>=	O
0	int
&&	O
rs	pointer
!=	O
NULL	O
)	O
{	O
hprintf	function
(	O
rs	pointer
->	O
fhsend	int
,	O
"remote %d status %d/%d/%d %d %d\n"	pointer
,	O
qid	int
,	O
ps	pointer
->	O
nfinished	int
,	O
ps	pointer
->	O
npending	int
,	O
ps	pointer
->	O
nparam	int
,	O
(	O
int	O
)	O
ps	pointer
->	O
t0	long
,	O
(	O
int	O
)	O
tc	long
)	O
;	O
}	O
else	O
if	O
(	O
cl	pointer
!=	O
NULL	O
)	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"status %d/%d/%d %d %d\n"	pointer
,	O
ps	pointer
->	O
nfinished	int
,	O
ps	pointer
->	O
npending	int
,	O
ps	pointer
->	O
nparam	int
,	O
(	O
int	O
)	O
ps	pointer
->	O
t0	long
,	O
(	O
int	O
)	O
tc	long
)	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"lock"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
maxnum	int
;	O
imutex	struct
*	O
mx	pointer
;	O
name	pointer
=	O
NULL	O
;	O
maxnum	int
=	O
0	int
;	O
i	int
=	O
imutex_lock_get_params	function
(	O
cmd	pointer
,	O
&	O
name	pointer
,	O
&	O
maxnum	int
)	O
;	O
if	O
(	O
i	int
||	O
name	pointer
==	O
NULL	O
)	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
(	O
mx	pointer
=	O
get_imutex_by_name	function
(	O
ps	pointer
->	O
imutexlist	pointer
,	O
name	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
mx	pointer
->	O
pclients	pointer
=	O
(	O
pendingclient	struct
*	O
)	O
xrealloc	function
(	O
mx	pointer
->	O
pclients	pointer
,	O
sizeof	O
(	O
pendingclient	struct
)	O
*	O
(	O
mx	pointer
->	O
npclient	int
+	O
1	int
)	O
)	O
;	O
mx	pointer
->	O
pclients	pointer
[	O
mx	pointer
->	O
npclient	int
]	O
.	O
qid	int
=	O
qid	int
;	O
mx	pointer
->	O
pclients	pointer
[	O
mx	pointer
->	O
npclient	int
]	O
.	O
data	pointer
=	O
dd	pointer
;	O
mx	pointer
->	O
npclient	int
++	O
;	O
mx	pointer
->	O
state	pointer
++	O
;	O
}	O
else	O
{	O
mx	pointer
=	O
list_new	O
(	O
imutex	struct
)	O
;	O
list_insert_first	O
(	O
ps	pointer
->	O
imutexlist	pointer
,	O
mx	pointer
)	O
;	O
mx	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
mx	pointer
->	O
state	pointer
=	O
1	int
;	O
mx	pointer
->	O
pclients	pointer
=	O
NULL	O
;	O
mx	pointer
->	O
npclient	int
=	O
0	int
;	O
if	O
(	O
qid	int
>=	O
0	int
&&	O
rs	pointer
!=	O
NULL	O
)	O
hprintf	function
(	O
rs	pointer
->	O
fhsend	int
,	O
"remote %d locked \"%s\"\n"	pointer
,	O
qid	int
,	O
mx	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
cl	pointer
!=	O
NULL	O
)	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"locked \"%s\"\n"	pointer
,	O
mx	pointer
->	O
name	pointer
)	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"unlock"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
imutex	struct
*	O
mx	pointer
;	O
pendingclient	struct
pcw	struct
;	O
int	O
is_pcw_set	int
;	O
name	pointer
=	O
NULL	O
;	O
i	int
=	O
imutex_unlock_get_params	function
(	O
cmd	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
(	O
!	O
i	int
)	O
&&	O
name	pointer
!=	O
NULL	O
&&	O
(	O
mx	pointer
=	O
get_imutex_by_name	function
(	O
ps	pointer
->	O
imutexlist	pointer
,	O
name	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
mx	pointer
->	O
state	pointer
--	O
;	O
if	O
(	O
mx	pointer
->	O
pclients	pointer
!=	O
NULL	O
&&	O
mx	pointer
->	O
npclient	int
>	O
0	int
)	O
{	O
memcpy	function
(	O
&	O
pcw	struct
,	O
&	O
mx	pointer
->	O
pclients	pointer
[	O
0	int
]	O
,	O
sizeof	O
(	O
pendingclient	struct
)	O
)	O
;	O
is_pcw_set	int
=	O
1	int
;	O
if	O
(	O
mx	pointer
->	O
npclient	int
>	O
1	int
)	O
memmove	function
(	O
mx	pointer
->	O
pclients	pointer
,	O
mx	pointer
->	O
pclients	pointer
+	O
1	int
,	O
sizeof	O
(	O
pendingclient	struct
)	O
*	O
(	O
mx	pointer
->	O
npclient	int
-	O
1	int
)	O
)	O
;	O
else	O
{	O
free	function
(	O
mx	pointer
->	O
pclients	pointer
)	O
;	O
mx	pointer
->	O
pclients	pointer
=	O
NULL	O
;	O
}	O
mx	pointer
->	O
npclient	int
--	O
;	O
}	O
else	O
is_pcw_set	int
=	O
0	int
;	O
if	O
(	O
is_pcw_set	int
)	O
{	O
if	O
(	O
pcw	struct
.	O
qid	int
>=	O
0	int
&&	O
pcw	struct
.	O
data	pointer
!=	O
NULL	O
)	O
hprintf	function
(	O
(	O
(	O
remoteshell	struct
*	O
)	O
pcw	struct
.	O
data	pointer
)	O
->	O
fhsend	int
,	O
"remote %d locked \"%s\"\n"	pointer
,	O
pcw	struct
.	O
qid	int
,	O
mx	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
pcw	struct
.	O
data	pointer
!=	O
NULL	O
)	O
hprintf	function
(	O
(	O
(	O
client	struct
*	O
)	O
pcw	struct
.	O
data	pointer
)	O
->	O
peer	int
,	O
"locked \"%s\"\n"	pointer
,	O
mx	pointer
->	O
name	pointer
)	O
;	O
}	O
if	O
(	O
mx	pointer
->	O
state	pointer
<=	O
0	int
)	O
{	O
free	function
(	O
mx	pointer
->	O
name	pointer
)	O
;	O
list_remove	O
(	O
ps	pointer
->	O
imutexlist	pointer
,	O
mx	pointer
)	O
;	O
free	function
(	O
mx	pointer
)	O
;	O
}	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"mutex"	pointer
)	O
==	O
0	int
)	O
{	O
imutex	struct
*	O
mx	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
lcnt	int
;	O
name	pointer
=	O
NULL	O
;	O
i	int
=	O
imutex_mutex_get_params	function
(	O
cmd	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
i	int
||	O
name	pointer
==	O
NULL	O
)	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
else	O
{	O
if	O
(	O
(	O
mx	pointer
=	O
get_imutex_by_name	function
(	O
ps	pointer
->	O
imutexlist	pointer
,	O
name	pointer
)	O
)	O
!=	O
NULL	O
)	O
lcnt	int
=	O
mx	pointer
->	O
npclient	int
;	O
else	O
lcnt	int
=	O
0	int
;	O
if	O
(	O
qid	int
>=	O
0	int
&&	O
rs	pointer
!=	O
NULL	O
)	O
hprintf	function
(	O
rs	pointer
->	O
fhsend	int
,	O
"remote %d mutex \"%s\" %d\n"	pointer
,	O
qid	int
,	O
name	pointer
,	O
lcnt	int
)	O
;	O
else	O
if	O
(	O
cl	pointer
!=	O
NULL	O
)	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"mutex \"%s\" %d\n"	pointer
,	O
name	pointer
,	O
lcnt	int
)	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"exit"	pointer
)	O
==	O
0	int
)	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"bye\n"	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
}	O
else	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"error unexpected command '%s'\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
int	O
remote_client_master_parse_command	function
(	O
char	O
*	O
line	pointer
,	O
parallelstatus	struct
*	O
ps	pointer
,	O
int	O
qid	int
,	O
void	O
*	O
dd	pointer
)	O
{	O
int	O
ret	pointer
;	O
char	O
*	O
*	O
cmd	pointer
;	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
free	function
(	O
cmd	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ret	pointer
=	O
remote_client_master_parse_command_tokens	function
(	O
cmd	pointer
,	O
ps	pointer
,	O
qid	int
,	O
dd	pointer
)	O
;	O
free	function
(	O
cmd	pointer
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
int	O
pexec_submit	function
(	O
paralleldata	struct
*	O
p	pointer
,	O
parallelstatus	struct
*	O
ps	pointer
,	O
numhashtable	struct
*	O
ntp	pointer
,	O
numhashtable	struct
*	O
ntf	pointer
,	O
remoteshell	struct
*	O
rs	pointer
,	O
parameter	struct
*	O
cp	pointer
,	O
int	O
n	int
)	O
{	O
child	struct
*	O
cc	pointer
;	O
cc	pointer
=	O
list_new	O
(	O
child	struct
)	O
;	O
cc	pointer
->	O
fdstdout	int
=	O
-	O
1	int
;	O
cc	pointer
->	O
fdstderr	int
=	O
-	O
1	int
;	O
list_insert_first	O
(	O
ps	pointer
->	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
ps	pointer
->	O
achild	int
++	O
;	O
rs	pointer
->	O
achild	int
++	O
;	O
cc	pointer
->	O
rs	pointer
=	O
rs	pointer
;	O
if	O
(	O
!	O
rs	pointer
->	O
num_processes	int
)	O
rs	pointer
->	O
estatus	int
=	O
0	int
;	O
linebuffer_reset	function
(	O
&	O
cc	pointer
->	O
lout	struct
)	O
;	O
linebuffer_reset	function
(	O
&	O
cc	pointer
->	O
lerr	struct
)	O
;	O
if	O
(	O
rs	pointer
->	O
pid	int
>=	O
0	int
)	O
{	O
cc	pointer
->	O
id	int
=	O
n	int
;	O
cc	pointer
->	O
pid	int
=	O
-	O
1	int
;	O
send_task	function
(	O
p	pointer
,	O
cp	pointer
,	O
cc	pointer
)	O
;	O
ps	pointer
->	O
npending	int
++	O
;	O
numhash_add	function
(	O
ntp	pointer
,	O
n	int
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
cc	pointer
->	O
id	int
=	O
n	int
;	O
cc	pointer
->	O
pid	int
=	O
submit_task	function
(	O
p	pointer
,	O
cp	pointer
,	O
cc	pointer
,	O
0	int
,	O
ps	pointer
)	O
;	O
ps	pointer
->	O
npending	int
++	O
;	O
numhash_add	function
(	O
ntp	pointer
,	O
n	int
,	O
NULL	O
)	O
;	O
if	O
(	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
{	O
ps	pointer
->	O
nfinished	int
++	O
;	O
numhash_add	function
(	O
ntf	pointer
,	O
n	int
,	O
NULL	O
)	O
;	O
log_message	function
(	O
p	pointer
->	O
log	pointer
,	O
1	int
,	O
cp	pointer
,	O
"error while invoking task:"	pointer
" %s"	pointer
,	O
logmsg_submit_task	array
[	O
-	O
cc	pointer
->	O
pid	int
]	O
)	O
;	O
list_remove	O
(	O
ps	pointer
->	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
ps	pointer
->	O
achild	int
--	O
;	O
rs	pointer
->	O
achild	int
--	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
remoteshell	struct
*	O
pexec_get_free_remote_shell	function
(	O
remoteshell	struct
*	O
rshells	pointer
,	O
int	O
nrshell	int
)	O
{	O
remoteshell	struct
*	O
rs	pointer
;	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
,	O
rs	pointer
=	O
rshells	pointer
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
if	O
(	O
(	O
0	int
<	O
rs	pointer
->	O
num_processes	int
&&	O
rs	pointer
->	O
achild	int
<	O
rs	pointer
->	O
num_processes	int
)	O
||	O
rs	pointer
->	O
estatus	int
>=	O
2	int
)	O
return	O
(	O
rs	pointer
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
int	O
pexec_do_parallelized_execution	function
(	O
paralleldata	struct
*	O
p	pointer
,	O
parameter	struct
*	O
params	pointer
,	O
int	O
nparam	int
,	O
remoteshell	struct
*	O
rshells	pointer
,	O
int	O
nrshell	int
,	O
int	O
sock	int
,	O
int	O
hsck	int
)	O
{	O
child	struct
*	O
cc	pointer
;	O
struct	O
sigaction	struct
chldact	struct
;	O
signalinfo	struct
sci	struct
;	O
numhashtable	struct
ntp	pointer
,	O
ntf	pointer
;	O
int	O
i	int
,	O
n	int
,	O
r	int
;	O
parameter	struct
*	O
cp	pointer
;	O
fd_set	struct
set	struct
;	O
int	O
spipe	int
,	O
max	int
,	O
status	int
;	O
char	O
*	O
buff	pointer
;	O
int	O
buffsize	int
;	O
remoteshell	struct
*	O
rs	pointer
;	O
client	struct
*	O
cl	pointer
;	O
parallelstatus	struct
ps	pointer
;	O
linebuffer	struct
lhyp	struct
;	O
if	O
(	O
pipe	function
(	O
sig_pipe	array
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
spipe	int
=	O
sig_pipe	array
[	O
0	int
]	O
;	O
chldact	struct
.	O
sa_handler	pointer
=	O
sig_act_child	function
;	O
sigemptyset	function
(	O
&	O
chldact	struct
.	O
sa_mask	struct
)	O
;	O
chldact	struct
.	O
sa_flags	int
=	O
(	O
SA_NOCLDSTOP	int
|	O
SA_RESTART	int
)	O
;	O
sigaction	struct
(	O
SIGCHLD	int
,	O
&	O
chldact	struct
,	O
NULL	O
)	O
;	O
ps	pointer
.	O
childlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
achild	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
,	O
rs	pointer
=	O
rshells	pointer
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
rs	pointer
->	O
achild	int
=	O
0	int
;	O
rs	pointer
->	O
estatus	int
=	O
0	int
;	O
}	O
ps	pointer
.	O
nfinished	int
=	O
0	int
;	O
numhash_init	function
(	O
&	O
ntf	pointer
,	O
get_bit_size	function
(	O
nparam	int
)	O
,	O
4	int
)	O
;	O
ps	pointer
.	O
npending	int
=	O
0	int
;	O
numhash_init	function
(	O
&	O
ntp	pointer
,	O
get_bit_size	function
(	O
nparam	int
)	O
,	O
4	int
)	O
;	O
ps	pointer
.	O
nparam	int
=	O
nparam	int
;	O
buffsize	int
=	O
getpagesize	function
(	O
)	O
;	O
buff	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
buffsize	int
)	O
;	O
ps	pointer
.	O
sock	int
=	O
sock	int
;	O
ps	pointer
.	O
hsck	int
=	O
hsck	int
;	O
ps	pointer
.	O
clientlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
imutexlist	pointer
=	O
NULL	O
;	O
linebuffer_reset	function
(	O
&	O
lhyp	struct
)	O
;	O
time	struct
(	O
&	O
ps	pointer
.	O
t0	long
)	O
;	O
while	O
(	O
ps	pointer
.	O
nfinished	int
<	O
ps	pointer
.	O
nparam	int
)	O
{	O
while	O
(	O
1	int
)	O
{	O
n	int
=	O
numhash_get_smallest_free	function
(	O
&	O
ntp	pointer
)	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>=	O
nparam	int
)	O
break	O
;	O
rs	pointer
=	O
pexec_get_free_remote_shell	function
(	O
rshells	pointer
,	O
nrshell	int
)	O
;	O
if	O
(	O
rs	pointer
==	O
NULL	O
)	O
break	O
;	O
cp	pointer
=	O
&	O
params	pointer
[	O
n	int
]	O
;	O
pexec_submit	function
(	O
p	pointer
,	O
&	O
ps	pointer
,	O
&	O
ntp	pointer
,	O
&	O
ntf	pointer
,	O
rs	pointer
,	O
cp	pointer
,	O
n	int
)	O
;	O
}	O
for	O
(	O
rs	pointer
=	O
rshells	pointer
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
if	O
(	O
!	O
rs	pointer
->	O
num_processes	int
&&	O
!	O
rs	pointer
->	O
estatus	int
)	O
{	O
rs	pointer
->	O
estatus	int
=	O
1	int
;	O
if	O
(	O
rs	pointer
->	O
pid	int
>=	O
0	int
)	O
hprintf	function
(	O
rs	pointer
->	O
fhsend	int
,	O
"request\n"	pointer
)	O
;	O
else	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
hprintf	function
(	O
hsck	int
,	O
"request\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
ps	pointer
.	O
nfinished	int
>=	O
nparam	int
)	O
break	O
;	O
FD_ZERO	O
(	O
&	O
set	struct
)	O
;	O
FD_SET	O
(	O
spipe	int
,	O
&	O
set	struct
)	O
;	O
max	int
=	O
spipe	int
;	O
for	O
(	O
cc	pointer
=	O
ps	pointer
.	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
id	int
<	O
0	int
||	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	pointer
->	O
fdstdout	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cc	pointer
->	O
fdstdout	int
)	O
max	int
=	O
cc	pointer
->	O
fdstdout	int
;	O
}	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	pointer
->	O
fdstderr	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cc	pointer
->	O
fdstderr	int
)	O
max	int
=	O
cc	pointer
->	O
fdstderr	int
;	O
}	O
}	O
for	O
(	O
rs	pointer
=	O
rshells	pointer
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
if	O
(	O
rs	pointer
->	O
pid	int
<	O
0	int
||	O
rs	pointer
->	O
fhsend	int
<	O
0	int
||	O
rs	pointer
->	O
fhrecv	int
<	O
0	int
)	O
continue	O
;	O
FD_SET	O
(	O
rs	pointer
->	O
fhrecv	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
rs	pointer
->	O
fhrecv	int
)	O
max	int
=	O
rs	pointer
->	O
fhrecv	int
;	O
}	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
sock	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
sock	int
)	O
max	int
=	O
sock	int
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
hsck	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
hsck	int
)	O
max	int
=	O
hsck	int
;	O
}	O
for	O
(	O
cl	pointer
=	O
ps	pointer
.	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cl	pointer
->	O
next	pointer
)	O
{	O
FD_SET	O
(	O
cl	pointer
->	O
peer	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cl	pointer
->	O
peer	int
)	O
max	int
=	O
cl	pointer
->	O
peer	int
;	O
}	O
i	int
=	O
select	function
(	O
max	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
FD_ISSET	O
(	O
spipe	int
,	O
&	O
set	struct
)	O
)	O
{	O
if	O
(	O
!	O
(	O
read_signalinfo	function
(	O
spipe	int
,	O
&	O
sci	struct
)	O
>	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: fatal error: read_signalinfo() failed.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sci	struct
.	O
exitsignal	int
<	O
0	int
)	O
{	O
cc	pointer
=	O
get_child_by_pid	function
(	O
ps	pointer
.	O
childlist	pointer
,	O
sci	struct
.	O
pid	int
)	O
;	O
n	int
=	O
cc	pointer
->	O
id	int
;	O
cc	pointer
->	O
id	int
=	O
-	O
1	int
;	O
cc	pointer
->	O
pid	int
=	O
-	O
1	int
;	O
cp	pointer
=	O
&	O
params	pointer
[	O
n	int
]	O
;	O
numhash_add	function
(	O
&	O
ntf	pointer
,	O
n	int
,	O
NULL	O
)	O
;	O
ps	pointer
.	O
nfinished	int
++	O
;	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
&&	O
p	pointer
->	O
fwout	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
fd_avail	function
(	O
cc	pointer
->	O
fdstdout	int
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstdout	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	function
(	O
buff	pointer
,	O
n	int
,	O
p	pointer
->	O
fwout	pointer
,	O
p	pointer
->	O
formatout	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lout	struct
,	O
cp	pointer
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
write_output	function
(	O
NULL	O
,	O
0	int
,	O
p	pointer
->	O
fwout	pointer
,	O
p	pointer
->	O
formatout	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lout	struct
,	O
cp	pointer
)	O
;	O
close	pointer
(	O
cc	pointer
->	O
fdstdout	int
)	O
;	O
cc	pointer
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
&&	O
p	pointer
->	O
fwerr	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
fd_avail	function
(	O
cc	pointer
->	O
fdstderr	int
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstderr	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	function
(	O
buff	pointer
,	O
n	int
,	O
p	pointer
->	O
fwerr	pointer
,	O
p	pointer
->	O
formaterr	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lerr	struct
,	O
cp	pointer
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
write_output	function
(	O
NULL	O
,	O
0	int
,	O
p	pointer
->	O
fwerr	pointer
,	O
p	pointer
->	O
formaterr	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lerr	struct
,	O
cp	pointer
)	O
;	O
close	pointer
(	O
cc	pointer
->	O
fdstderr	int
)	O
;	O
cc	pointer
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
list_remove	O
(	O
ps	pointer
.	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
cc	pointer
->	O
rs	pointer
->	O
achild	int
--	O
;	O
ps	pointer
.	O
achild	int
--	O
;	O
if	O
(	O
!	O
cc	pointer
->	O
rs	pointer
->	O
num_processes	int
&&	O
hsck	int
>=	O
0	int
)	O
hprintf	function
(	O
hsck	int
,	O
"ready\n"	pointer
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
fallback_to_die	int
)	O
{	O
close	pointer
(	O
sig_pipe	array
[	O
0	int
]	O
)	O
;	O
sig_pipe	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
close	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
)	O
;	O
sig_pipe	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
cc	pointer
=	O
ps	pointer
.	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
kill	function
(	O
cc	pointer
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
waitpid	function
(	O
cc	pointer
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
}	O
ps	pointer
.	O
childlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
achild	int
=	O
0	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
cc	pointer
=	O
get_child_by_pid	function
(	O
ps	pointer
.	O
childlist	pointer
,	O
sci	struct
.	O
pid	int
)	O
;	O
numhash_remove	function
(	O
&	O
ntp	pointer
,	O
n	int
)	O
;	O
ps	pointer
.	O
npending	int
--	O
;	O
list_remove	O
(	O
ps	pointer
.	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
cc	pointer
->	O
rs	pointer
->	O
achild	int
--	O
;	O
ps	pointer
.	O
achild	int
--	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
}	O
}	O
for	O
(	O
cc	pointer
=	O
ps	pointer
.	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
id	int
<	O
0	int
||	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
cp	pointer
=	O
&	O
params	pointer
[	O
cc	pointer
->	O
id	int
]	O
;	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
&&	O
p	pointer
->	O
fwout	pointer
!=	O
NULL	O
&&	O
FD_ISSET	O
(	O
cc	pointer
->	O
fdstdout	int
,	O
&	O
set	struct
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstdout	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	function
(	O
buff	pointer
,	O
n	int
,	O
p	pointer
->	O
fwout	pointer
,	O
p	pointer
->	O
formatout	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lout	struct
,	O
cp	pointer
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	pointer
(	O
cc	pointer
->	O
fdstdout	int
)	O
;	O
cc	pointer
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
&&	O
p	pointer
->	O
fwerr	pointer
!=	O
NULL	O
&&	O
FD_ISSET	O
(	O
cc	pointer
->	O
fdstderr	int
,	O
&	O
set	struct
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstderr	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	function
(	O
buff	pointer
,	O
n	int
,	O
p	pointer
->	O
fwerr	pointer
,	O
p	pointer
->	O
formaterr	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lerr	struct
,	O
cp	pointer
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	pointer
(	O
cc	pointer
->	O
fdstderr	int
)	O
;	O
cc	pointer
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
rs	pointer
=	O
rshells	pointer
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
int	O
len	int
;	O
char	O
*	O
line	pointer
,	O
*	O
*	O
cmd	pointer
;	O
if	O
(	O
rs	pointer
->	O
pid	int
<	O
0	int
||	O
rs	pointer
->	O
fhsend	int
<	O
0	int
||	O
rs	pointer
->	O
fhrecv	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
rs	pointer
->	O
fhrecv	int
,	O
&	O
set	struct
)	O
)	O
continue	O
;	O
n	int
=	O
read	pointer
(	O
rs	pointer
->	O
fhrecv	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	function
(	O
&	O
rs	pointer
->	O
lrsh	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
rs	pointer
->	O
lrsh	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
!=	O
NULL	O
&&	O
cmd	pointer
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"output"	pointer
)	O
==	O
0	int
&&	O
cmd	pointer
[	O
1	int
]	O
!=	O
NULL	O
&&	O
cmd	pointer
[	O
2	int
]	O
!=	O
NULL	O
)	O
{	O
sscanf	function
(	O
cmd	pointer
[	O
1	int
]	O
,	O
"%d"	pointer
,	O
&	O
n	int
)	O
;	O
cc	pointer
=	O
get_child_by_id	function
(	O
ps	pointer
.	O
childlist	pointer
,	O
n	int
)	O
;	O
cp	pointer
=	O
&	O
params	pointer
[	O
n	int
]	O
;	O
len	int
=	O
daemon_commandtoken_unescape	function
(	O
cmd	pointer
[	O
2	int
]	O
)	O
;	O
write_output	function
(	O
cmd	pointer
[	O
2	int
]	O
,	O
len	int
,	O
p	pointer
->	O
fwout	pointer
,	O
p	pointer
->	O
formatout	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lout	struct
,	O
cp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"error"	pointer
)	O
==	O
0	int
&&	O
cmd	pointer
[	O
1	int
]	O
!=	O
NULL	O
&&	O
cmd	pointer
[	O
2	int
]	O
!=	O
NULL	O
)	O
{	O
sscanf	function
(	O
cmd	pointer
[	O
1	int
]	O
,	O
"%d"	pointer
,	O
&	O
n	int
)	O
;	O
cc	pointer
=	O
get_child_by_id	function
(	O
ps	pointer
.	O
childlist	pointer
,	O
n	int
)	O
;	O
cp	pointer
=	O
&	O
params	pointer
[	O
n	int
]	O
;	O
len	int
=	O
daemon_commandtoken_unescape	function
(	O
cmd	pointer
[	O
2	int
]	O
)	O
;	O
write_output	function
(	O
cmd	pointer
[	O
2	int
]	O
,	O
len	int
,	O
p	pointer
->	O
fwerr	pointer
,	O
p	pointer
->	O
formaterr	pointer
,	O
p	pointer
->	O
omit_newlines	int
,	O
&	O
cc	pointer
->	O
lerr	struct
,	O
cp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"finish"	pointer
)	O
==	O
0	int
&&	O
cmd	pointer
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
sscanf	function
(	O
cmd	pointer
[	O
1	int
]	O
,	O
"%d"	pointer
,	O
&	O
n	int
)	O
;	O
cc	pointer
=	O
get_child_by_id	function
(	O
ps	pointer
.	O
childlist	pointer
,	O
n	int
)	O
;	O
numhash_add	function
(	O
&	O
ntf	pointer
,	O
n	int
,	O
NULL	O
)	O
;	O
ps	pointer
.	O
nfinished	int
++	O
;	O
list_remove	O
(	O
ps	pointer
.	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
cc	pointer
->	O
rs	pointer
->	O
achild	int
--	O
;	O
ps	pointer
.	O
achild	int
--	O
;	O
if	O
(	O
!	O
cc	pointer
->	O
rs	pointer
->	O
num_processes	int
)	O
hprintf	function
(	O
cc	pointer
->	O
rs	pointer
->	O
fhsend	int
,	O
"ready\n"	pointer
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"remote"	pointer
)	O
==	O
0	int
&&	O
cmd	pointer
[	O
1	int
]	O
!=	O
NULL	O
&&	O
cmd	pointer
[	O
2	int
]	O
!=	O
NULL	O
)	O
{	O
int	O
qid	int
;	O
void	O
*	O
dd	pointer
;	O
if	O
(	O
sscanf	function
(	O
cmd	pointer
[	O
1	int
]	O
,	O
"%d"	pointer
,	O
&	O
qid	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
qid	int
>=	O
0	int
)	O
dd	pointer
=	O
(	O
void	O
*	O
)	O
rs	pointer
;	O
else	O
dd	pointer
=	O
NULL	O
;	O
remote_client_master_parse_command_tokens	function
(	O
cmd	pointer
+	O
2	int
,	O
&	O
ps	pointer
,	O
qid	int
,	O
dd	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"acknowledged"	pointer
)	O
==	O
0	int
)	O
rs	pointer
->	O
estatus	int
=	O
2	int
;	O
}	O
if	O
(	O
cmd	pointer
!=	O
NULL	O
)	O
free	function
(	O
cmd	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
}	O
for	O
(	O
cl	pointer
=	O
ps	pointer
.	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cl	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
int	O
closepeer	int
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
cl	pointer
->	O
peer	int
,	O
&	O
set	struct
)	O
)	O
continue	O
;	O
n	int
=	O
read	pointer
(	O
cl	pointer
->	O
peer	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
close	pointer
(	O
cl	pointer
->	O
peer	int
)	O
;	O
linebuffer_free	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
imutex_cleanup	function
(	O
ps	pointer
.	O
imutexlist	pointer
,	O
-	O
1	int
,	O
(	O
void	O
*	O
)	O
cl	pointer
)	O
;	O
list_remove	O
(	O
ps	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
free	function
(	O
cl	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	function
(	O
&	O
cl	pointer
->	O
lcli	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
closepeer	int
=	O
0	int
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
closepeer	int
=	O
remote_client_master_parse_command	function
(	O
line	pointer
,	O
&	O
ps	pointer
,	O
-	O
1	int
,	O
(	O
void	O
*	O
)	O
cl	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
if	O
(	O
closepeer	int
)	O
break	O
;	O
}	O
;	O
if	O
(	O
closepeer	int
)	O
{	O
close	pointer
(	O
cl	pointer
->	O
peer	int
)	O
;	O
linebuffer_free	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
imutex_cleanup	function
(	O
ps	pointer
.	O
imutexlist	pointer
,	O
-	O
1	int
,	O
(	O
void	O
*	O
)	O
cl	pointer
)	O
;	O
list_remove	O
(	O
ps	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
free	function
(	O
cl	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
hsck	int
,	O
&	O
set	struct
)	O
)	O
{	O
char	O
*	O
line	pointer
,	O
*	O
*	O
cmd	pointer
;	O
n	int
=	O
read	pointer
(	O
hsck	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
linebuffer_concatenate	function
(	O
&	O
lhyp	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
lhyp	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"acknowledged"	pointer
)	O
==	O
0	int
)	O
{	O
for	O
(	O
rs	pointer
=	O
rshells	pointer
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
if	O
(	O
!	O
rs	pointer
->	O
num_processes	int
)	O
rs	pointer
->	O
estatus	int
=	O
2	int
;	O
}	O
}	O
free	function
(	O
cmd	pointer
)	O
;	O
}	O
free	function
(	O
line	pointer
)	O
;	O
}	O
}	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
sock	int
,	O
&	O
set	struct
)	O
)	O
{	O
cl	pointer
=	O
list_new	O
(	O
client	struct
)	O
;	O
cl	pointer
->	O
peer	int
=	O
accept	function
(	O
sock	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
linebuffer_reset	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
list_insert_first	O
(	O
ps	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
cl	pointer
->	O
status	int
=	O
0	int
;	O
}	O
}	O
for	O
(	O
rs	pointer
=	O
rshells	pointer
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
if	O
(	O
!	O
rs	pointer
->	O
num_processes	int
)	O
{	O
if	O
(	O
rs	pointer
->	O
pid	int
>=	O
0	int
)	O
hprintf	function
(	O
rs	pointer
->	O
fhsend	int
,	O
"completed\n"	pointer
)	O
;	O
else	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
hprintf	function
(	O
hsck	int
,	O
"completed\n"	pointer
)	O
;	O
}	O
}	O
free	function
(	O
buff	pointer
)	O
;	O
numhash_free	function
(	O
&	O
ntp	pointer
)	O
;	O
numhash_free	function
(	O
&	O
ntf	pointer
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
close	pointer
(	O
sig_pipe	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_client_daemon_parse_command	function
(	O
char	O
*	O
line	pointer
,	O
client	struct
*	O
cl	pointer
,	O
parallelstatus	struct
*	O
ps	pointer
,	O
int	O
fhsend	int
)	O
{	O
int	O
i	int
,	O
ret	pointer
;	O
char	O
*	O
*	O
cmd	pointer
;	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
free	function
(	O
cmd	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"status"	pointer
)	O
==	O
0	int
)	O
{	O
dqueue	struct
*	O
dq	pointer
;	O
dq	pointer
=	O
list_new	O
(	O
dqueue	struct
)	O
;	O
dq	pointer
->	O
id	int
=	O
ps	pointer
->	O
iqueue	int
;	O
dq	pointer
->	O
qclient	pointer
=	O
cl	pointer
;	O
list_insert_first	O
(	O
ps	pointer
->	O
dqueuelist	pointer
,	O
dq	pointer
)	O
;	O
hprintf	function
(	O
fhsend	int
,	O
"remote %d status\n"	pointer
,	O
dq	pointer
->	O
id	int
)	O
;	O
ps	pointer
->	O
iqueue	int
++	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"lock"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
maxnum	int
;	O
dqueue	struct
*	O
dq	pointer
;	O
name	pointer
=	O
NULL	O
;	O
maxnum	int
=	O
0	int
;	O
i	int
=	O
imutex_lock_get_params	function
(	O
cmd	pointer
,	O
&	O
name	pointer
,	O
&	O
maxnum	int
)	O
;	O
if	O
(	O
i	int
||	O
name	pointer
==	O
NULL	O
)	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
else	O
{	O
dq	pointer
=	O
list_new	O
(	O
dqueue	struct
)	O
;	O
dq	pointer
->	O
id	int
=	O
ps	pointer
->	O
iqueue	int
;	O
dq	pointer
->	O
qclient	pointer
=	O
cl	pointer
;	O
list_insert_first	O
(	O
ps	pointer
->	O
dqueuelist	pointer
,	O
dq	pointer
)	O
;	O
hprintf	function
(	O
fhsend	int
,	O
"remote %d lock \"%s\"\n"	pointer
,	O
dq	pointer
->	O
id	int
,	O
name	pointer
)	O
;	O
ps	pointer
->	O
iqueue	int
++	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"unlock"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
NULL	O
;	O
i	int
=	O
imutex_unlock_get_params	function
(	O
cmd	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
!	O
(	O
i	int
||	O
name	pointer
==	O
NULL	O
)	O
)	O
hprintf	function
(	O
fhsend	int
,	O
"remote -1 unlock \"%s\"\n"	pointer
,	O
name	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"mutex"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
dqueue	struct
*	O
dq	pointer
;	O
name	pointer
=	O
NULL	O
;	O
i	int
=	O
imutex_mutex_get_params	function
(	O
cmd	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
i	int
||	O
name	pointer
==	O
NULL	O
)	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
else	O
{	O
dq	pointer
=	O
list_new	O
(	O
dqueue	struct
)	O
;	O
dq	pointer
->	O
id	int
=	O
ps	pointer
->	O
iqueue	int
;	O
dq	pointer
->	O
qclient	pointer
=	O
cl	pointer
;	O
list_insert_first	O
(	O
ps	pointer
->	O
dqueuelist	pointer
,	O
dq	pointer
)	O
;	O
hprintf	function
(	O
fhsend	int
,	O
"remote %d mutex \"%s\"\n"	pointer
,	O
dq	pointer
->	O
id	int
,	O
name	pointer
)	O
;	O
ps	pointer
->	O
iqueue	int
++	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"exit"	pointer
)	O
==	O
0	int
)	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"bye\n"	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
}	O
else	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"error unexpected command '%s'\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
free	function
(	O
cmd	pointer
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
dqueue	struct
*	O
dqueue_get_queue_by_id	function
(	O
parallelstatus	struct
*	O
ps	pointer
,	O
int	O
id	int
)	O
{	O
dqueue	struct
*	O
dq	pointer
;	O
for	O
(	O
dq	pointer
=	O
ps	pointer
->	O
dqueuelist	pointer
;	O
dq	pointer
!=	O
NULL	O
;	O
dq	pointer
=	O
dq	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
dq	pointer
->	O
id	int
==	O
id	int
)	O
return	O
(	O
dq	pointer
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
int	O
daemon_process_command	function
(	O
parallelstatus	struct
*	O
ps	pointer
,	O
int	O
fhsend	int
,	O
char	O
*	O
*	O
cmd	pointer
)	O
{	O
int	O
i	int
,	O
n	int
,	O
id	int
,	O
zeroarg	int
;	O
char	O
*	O
shell	pointer
,	O
*	O
in	pointer
,	O
*	O
out	pointer
,	O
*	O
err	long
,	O
*	O
envname	pointer
,	O
*	O
envvalue	pointer
,	O
*	O
eoc	pointer
;	O
paralleldata	struct
p	pointer
;	O
parameter	struct
par	pointer
;	O
child	struct
*	O
cc	pointer
;	O
dqueue	struct
*	O
dq	pointer
;	O
if	O
(	O
cmd	pointer
==	O
NULL	O
||	O
cmd	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
cmd	pointer
[	O
n	int
]	O
!=	O
NULL	O
;	O
)	O
n	int
++	O
;	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"exit"	pointer
)	O
==	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"remote"	pointer
)	O
==	O
0	int
&&	O
n	int
>=	O
3	int
)	O
{	O
int	O
qid	int
,	O
j	int
;	O
char	O
*	O
buff	pointer
;	O
if	O
(	O
sscanf	function
(	O
cmd	pointer
[	O
1	int
]	O
,	O
"%d"	pointer
,	O
&	O
qid	int
)	O
<	O
1	int
)	O
qid	int
=	O
-	O
1	int
;	O
dq	pointer
=	O
dqueue_get_queue_by_id	function
(	O
ps	pointer
,	O
qid	int
)	O
;	O
if	O
(	O
dq	pointer
!=	O
NULL	O
)	O
{	O
buff	pointer
=	O
NULL	O
;	O
strappendf	function
(	O
&	O
buff	pointer
,	O
"%s"	pointer
,	O
cmd	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
2	int
]	O
,	O
"locked"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
cmd	pointer
[	O
2	int
]	O
,	O
"mutex"	pointer
)	O
==	O
0	int
)	O
{	O
strappendf	function
(	O
&	O
buff	pointer
,	O
" \"%s\""	pointer
,	O
(	O
cmd	pointer
[	O
3	int
]	O
!=	O
NULL	O
?	O
cmd	pointer
[	O
3	int
]	O
:	O
"-"	pointer
)	O
)	O
;	O
if	O
(	O
cmd	pointer
[	O
3	int
]	O
!=	O
NULL	O
)	O
j	int
=	O
4	int
;	O
else	O
j	int
=	O
3	int
;	O
}	O
else	O
j	int
=	O
3	int
;	O
for	O
(	O
;	O
cmd	pointer
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
strappendf	function
(	O
&	O
buff	pointer
,	O
" %s"	pointer
,	O
cmd	pointer
[	O
j	int
]	O
)	O
;	O
hprintf	function
(	O
dq	pointer
->	O
qclient	pointer
->	O
peer	int
,	O
"%s\n"	pointer
,	O
buff	pointer
)	O
;	O
if	O
(	O
buff	pointer
!=	O
NULL	O
)	O
free	function
(	O
buff	pointer
)	O
;	O
list_remove	O
(	O
ps	pointer
->	O
dqueuelist	pointer
,	O
dq	pointer
)	O
;	O
free	function
(	O
dq	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"execute"	pointer
)	O
==	O
0	int
)	O
{	O
shell	pointer
=	O
NULL	O
;	O
in	pointer
=	O
NULL	O
;	O
out	pointer
=	O
NULL	O
;	O
err	long
=	O
NULL	O
;	O
envname	pointer
=	O
NULL	O
;	O
envvalue	pointer
=	O
NULL	O
;	O
id	int
=	O
-	O
1	int
;	O
zeroarg	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cmd	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
break	O
;	O
}	O
eoc	pointer
=	O
strchr	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
'='	O
)	O
;	O
if	O
(	O
eoc	pointer
==	O
NULL	O
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"invalid argument '%s' for '%s'\"\n"	pointer
,	O
cmd	pointer
[	O
i	int
]	O
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
*	O
eoc	pointer
=	O
0	int
;	O
eoc	pointer
++	O
;	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"id"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"identifier"	pointer
)	O
==	O
0	int
)	O
sscanf	function
(	O
eoc	pointer
,	O
"%d"	pointer
,	O
&	O
id	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"shell"	pointer
)	O
==	O
0	int
)	O
shell	pointer
=	O
eoc	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"in"	pointer
)	O
==	O
0	int
)	O
in	pointer
=	O
eoc	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"out"	pointer
)	O
==	O
0	int
)	O
out	pointer
=	O
eoc	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"err"	pointer
)	O
==	O
0	int
)	O
err	long
=	O
eoc	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"envname"	pointer
)	O
==	O
0	int
)	O
envname	pointer
=	O
eoc	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"envvalue"	pointer
)	O
==	O
0	int
)	O
envvalue	pointer
=	O
eoc	pointer
;	O
else	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"invalid argument '%s' for '%s'\"\n"	pointer
,	O
cmd	pointer
[	O
i	int
]	O
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
zeroarg	int
<	O
0	int
||	O
id	int
<	O
0	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"invalid syntax near '%s'\"\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
zeroarg	int
>=	O
n	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"command specification is missing near '%s'\"\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
in	pointer
==	O
NULL	O
)	O
p	pointer
.	O
in	pointer
=	O
NULL	O
;	O
else	O
p	pointer
.	O
in	pointer
=	O
in	pointer
;	O
if	O
(	O
out	pointer
==	O
NULL	O
)	O
{	O
p	pointer
.	O
out	pointer
=	O
NULL	O
;	O
p	pointer
.	O
fwout	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
out	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
p	pointer
.	O
out	pointer
=	O
out	pointer
;	O
p	pointer
.	O
fwout	pointer
=	O
stdout	pointer
;	O
}	O
else	O
{	O
p	pointer
.	O
out	pointer
=	O
out	pointer
;	O
p	pointer
.	O
fwout	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
err	long
==	O
NULL	O
)	O
{	O
p	pointer
.	O
err	long
=	O
NULL	O
;	O
p	pointer
.	O
fwerr	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
err	long
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
p	pointer
.	O
err	long
=	O
err	long
;	O
p	pointer
.	O
fwerr	pointer
=	O
stderr	pointer
;	O
}	O
else	O
{	O
p	pointer
.	O
err	long
=	O
err	long
;	O
p	pointer
.	O
fwerr	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
envname	pointer
!=	O
NULL	O
&&	O
envvalue	pointer
!=	O
NULL	O
)	O
{	O
p	pointer
.	O
envvarname	pointer
=	O
envname	pointer
;	O
par	pointer
.	O
name	pointer
=	O
envvalue	pointer
;	O
}	O
else	O
{	O
p	pointer
.	O
envvarname	pointer
=	O
NULL	O
;	O
par	pointer
.	O
name	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
shell	pointer
!=	O
NULL	O
)	O
{	O
p	pointer
.	O
shell	pointer
=	O
shell	pointer
;	O
par	pointer
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
par	pointer
.	O
c	int
.	O
argc	int
=	O
n	int
-	O
zeroarg	int
;	O
par	pointer
.	O
c	int
.	O
argv	pointer
=	O
cmd	pointer
+	O
zeroarg	int
;	O
}	O
else	O
{	O
p	pointer
.	O
shell	pointer
=	O
NULL	O
;	O
par	pointer
.	O
c	int
.	O
is_shell	int
=	O
0	int
;	O
par	pointer
.	O
c	int
.	O
argc	int
=	O
n	int
-	O
zeroarg	int
;	O
par	pointer
.	O
c	int
.	O
argv	pointer
=	O
cmd	pointer
+	O
zeroarg	int
;	O
}	O
par	pointer
.	O
no_touch_std	int
=	O
0	int
;	O
cc	pointer
=	O
list_new	O
(	O
child	struct
)	O
;	O
cc	pointer
->	O
fdstdout	int
=	O
-	O
1	int
;	O
cc	pointer
->	O
fdstderr	int
=	O
-	O
1	int
;	O
cc	pointer
->	O
id	int
=	O
id	int
;	O
cc	pointer
->	O
pid	int
=	O
submit_task	function
(	O
&	O
p	pointer
,	O
&	O
par	pointer
,	O
cc	pointer
,	O
!	O
0	int
,	O
ps	pointer
)	O
;	O
if	O
(	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"unable to execute, reason code: %d\"\n"	pointer
,	O
cc	pointer
->	O
pid	int
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
list_insert_first	O
(	O
ps	pointer
->	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"request"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ps	pointer
->	O
hsck	int
<	O
0	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"unexpected 'request': hypervisor has not been connected to daemon\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
hprintf	function
(	O
ps	pointer
->	O
hsck	int
,	O
"request\n"	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"ready"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ps	pointer
->	O
hsck	int
<	O
0	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"unexpected 'ready': hypervisor has not been connected to daemon\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
hprintf	function
(	O
ps	pointer
->	O
hsck	int
,	O
"ready\n"	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"completed"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ps	pointer
->	O
hsck	int
<	O
0	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"unexpected 'completed': hypervisor has not been connected to daemon\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
hprintf	function
(	O
ps	pointer
->	O
hsck	int
,	O
"completed\n"	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"message \"invalid command: %s\"\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
daemon_send_data	function
(	O
int	O
fhsend	int
,	O
char	O
*	O
streamname	pointer
,	O
int	O
id	int
,	O
char	O
*	O
buff	pointer
,	O
int	O
size	long
)	O
{	O
char	O
*	O
out	pointer
;	O
if	O
(	O
buff	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
out	pointer
=	O
daemon_commandtoken_escape	function
(	O
buff	pointer
,	O
size	long
)	O
;	O
hprintf	function
(	O
fhsend	int
,	O
"%s %d "	pointer
,	O
streamname	pointer
,	O
id	int
)	O
;	O
write	pointer
(	O
fhsend	int
,	O
out	pointer
,	O
strlen	function
(	O
out	pointer
)	O
)	O
;	O
free	function
(	O
out	pointer
)	O
;	O
hprintf	function
(	O
fhsend	int
,	O
"\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
daemon_send_output	function
(	O
int	O
fhsend	int
,	O
int	O
id	int
,	O
char	O
*	O
buff	pointer
,	O
int	O
size	long
)	O
{	O
return	O
(	O
daemon_send_data	function
(	O
fhsend	int
,	O
"output"	pointer
,	O
id	int
,	O
buff	pointer
,	O
size	long
)	O
)	O
;	O
}	O
int	O
daemon_send_error	function
(	O
int	O
fhsend	int
,	O
int	O
id	int
,	O
char	O
*	O
buff	pointer
,	O
int	O
size	long
)	O
{	O
return	O
(	O
daemon_send_data	function
(	O
fhsend	int
,	O
"error"	pointer
,	O
id	int
,	O
buff	pointer
,	O
size	long
)	O
)	O
;	O
}	O
int	O
pexec_daemon_main_loop	function
(	O
int	O
fhrecv	int
,	O
int	O
fhsend	int
,	O
int	O
num_processes	int
,	O
int	O
sock	int
,	O
int	O
hsck	int
)	O
{	O
fd_set	struct
set	struct
;	O
parallelstatus	struct
ps	pointer
;	O
child	struct
*	O
cc	pointer
;	O
struct	O
sigaction	struct
chldact	struct
;	O
signalinfo	struct
sci	struct
;	O
int	O
spipe	int
,	O
max	int
,	O
status	int
;	O
int	O
buffsize	int
,	O
i	int
,	O
n	int
;	O
char	O
*	O
buff	pointer
,	O
*	O
*	O
cmd	pointer
,	O
*	O
line	pointer
;	O
int	O
is_in_loop	int
,	O
ret	pointer
;	O
linebuffer	struct
lcmd	struct
,	O
lhyp	struct
;	O
client	struct
*	O
cl	pointer
;	O
hprintf	function
(	O
fhsend	int
,	O
"initialization num_processes=%d\n"	pointer
,	O
num_processes	int
)	O
;	O
buffsize	int
=	O
getpagesize	function
(	O
)	O
;	O
buff	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
buffsize	int
)	O
;	O
if	O
(	O
pipe	function
(	O
sig_pipe	array
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
spipe	int
=	O
sig_pipe	array
[	O
0	int
]	O
;	O
chldact	struct
.	O
sa_handler	pointer
=	O
sig_act_child	function
;	O
sigemptyset	function
(	O
&	O
chldact	struct
.	O
sa_mask	struct
)	O
;	O
chldact	struct
.	O
sa_flags	int
=	O
(	O
SA_NOCLDSTOP	int
|	O
SA_RESTART	int
)	O
;	O
sigaction	struct
(	O
SIGCHLD	int
,	O
&	O
chldact	struct
,	O
NULL	O
)	O
;	O
ps	pointer
.	O
childlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
achild	int
=	O
0	int
;	O
ps	pointer
.	O
clientlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
imutexlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
dqueuelist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
iqueue	int
=	O
0	int
;	O
ps	pointer
.	O
sock	int
=	O
sock	int
;	O
ps	pointer
.	O
hsck	int
=	O
hsck	int
;	O
linebuffer_reset	function
(	O
&	O
lcmd	struct
)	O
;	O
linebuffer_reset	function
(	O
&	O
lhyp	struct
)	O
;	O
is_in_loop	int
=	O
1	int
;	O
while	O
(	O
is_in_loop	int
)	O
{	O
FD_ZERO	O
(	O
&	O
set	struct
)	O
;	O
FD_SET	O
(	O
spipe	int
,	O
&	O
set	struct
)	O
;	O
max	int
=	O
spipe	int
;	O
FD_SET	O
(	O
fhrecv	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
fhrecv	int
)	O
max	int
=	O
fhrecv	int
;	O
for	O
(	O
cc	pointer
=	O
ps	pointer
.	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
id	int
<	O
0	int
||	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	pointer
->	O
fdstdout	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cc	pointer
->	O
fdstdout	int
)	O
max	int
=	O
cc	pointer
->	O
fdstdout	int
;	O
}	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	pointer
->	O
fdstderr	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cc	pointer
->	O
fdstderr	int
)	O
max	int
=	O
cc	pointer
->	O
fdstderr	int
;	O
}	O
}	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
sock	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
sock	int
)	O
max	int
=	O
sock	int
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
hsck	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
hsck	int
)	O
max	int
=	O
hsck	int
;	O
}	O
for	O
(	O
cl	pointer
=	O
ps	pointer
.	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cl	pointer
->	O
next	pointer
)	O
{	O
FD_SET	O
(	O
cl	pointer
->	O
peer	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cl	pointer
->	O
peer	int
)	O
max	int
=	O
cl	pointer
->	O
peer	int
;	O
}	O
i	int
=	O
select	function
(	O
max	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
spipe	int
,	O
&	O
set	struct
)	O
)	O
{	O
if	O
(	O
!	O
(	O
read_signalinfo	function
(	O
spipe	int
,	O
&	O
sci	struct
)	O
>	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: fatal error: read_signalinfo() failed.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sci	struct
.	O
exitsignal	int
<	O
0	int
)	O
{	O
cc	pointer
=	O
get_child_by_pid	function
(	O
ps	pointer
.	O
childlist	pointer
,	O
sci	struct
.	O
pid	int
)	O
;	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
)	O
{	O
while	O
(	O
fd_avail	function
(	O
cc	pointer
->	O
fdstdout	int
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstdout	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_output	function
(	O
fhsend	int
,	O
cc	pointer
->	O
id	int
,	O
buff	pointer
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
close	pointer
(	O
cc	pointer
->	O
fdstdout	int
)	O
;	O
cc	pointer
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
)	O
{	O
while	O
(	O
fd_avail	function
(	O
cc	pointer
->	O
fdstderr	int
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstderr	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_error	function
(	O
fhsend	int
,	O
cc	pointer
->	O
id	int
,	O
buff	pointer
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
close	pointer
(	O
cc	pointer
->	O
fdstderr	int
)	O
;	O
cc	pointer
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
}	O
hprintf	function
(	O
fhsend	int
,	O
"finish %d signal=%d status=%d\n"	pointer
,	O
cc	pointer
->	O
id	int
,	O
sci	struct
.	O
exitsignal	int
,	O
sci	struct
.	O
exitstatus	int
)	O
;	O
list_remove	O
(	O
ps	pointer
.	O
childlist	pointer
,	O
cc	pointer
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
ps	pointer
.	O
achild	int
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fhrecv	int
,	O
&	O
set	struct
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
fhrecv	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
is_in_loop	int
=	O
0	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	function
(	O
&	O
lcmd	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
lcmd	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
cmd	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
daemon_commandtoken_unescape	function
(	O
cmd	pointer
[	O
i	int
]	O
)	O
;	O
ret	pointer
=	O
daemon_process_command	function
(	O
&	O
ps	pointer
,	O
fhsend	int
,	O
cmd	pointer
)	O
;	O
free	function
(	O
cmd	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
if	O
(	O
ret	pointer
>	O
0	int
)	O
{	O
is_in_loop	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
else	O
free	function
(	O
line	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
cc	pointer
=	O
ps	pointer
.	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
id	int
<	O
0	int
||	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
cc	pointer
->	O
fdstdout	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
cc	pointer
->	O
fdstdout	int
,	O
&	O
set	struct
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstdout	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_output	function
(	O
fhsend	int
,	O
cc	pointer
->	O
id	int
,	O
buff	pointer
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	pointer
(	O
cc	pointer
->	O
fdstdout	int
)	O
;	O
cc	pointer
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
cc	pointer
->	O
fdstderr	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
cc	pointer
->	O
fdstderr	int
,	O
&	O
set	struct
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
cc	pointer
->	O
fdstderr	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_error	function
(	O
fhsend	int
,	O
cc	pointer
->	O
id	int
,	O
buff	pointer
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	pointer
(	O
cc	pointer
->	O
fdstderr	int
)	O
;	O
cc	pointer
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
cl	pointer
=	O
ps	pointer
.	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cl	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
int	O
closepeer	int
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
cl	pointer
->	O
peer	int
,	O
&	O
set	struct
)	O
)	O
continue	O
;	O
n	int
=	O
read	pointer
(	O
cl	pointer
->	O
peer	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
close	pointer
(	O
cl	pointer
->	O
peer	int
)	O
;	O
linebuffer_free	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
list_remove	O
(	O
ps	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
free	function
(	O
cl	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	function
(	O
&	O
cl	pointer
->	O
lcli	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
closepeer	int
=	O
0	int
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
closepeer	int
=	O
remote_client_daemon_parse_command	function
(	O
line	pointer
,	O
cl	pointer
,	O
&	O
ps	pointer
,	O
fhsend	int
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
if	O
(	O
closepeer	int
)	O
break	O
;	O
}	O
;	O
if	O
(	O
closepeer	int
)	O
{	O
close	pointer
(	O
cl	pointer
->	O
peer	int
)	O
;	O
linebuffer_free	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
list_remove	O
(	O
ps	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
free	function
(	O
cl	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
hsck	int
,	O
&	O
set	struct
)	O
)	O
{	O
n	int
=	O
read	pointer
(	O
hsck	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
linebuffer_concatenate	function
(	O
&	O
lhyp	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
lhyp	struct
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"acknowledged"	pointer
)	O
==	O
0	int
)	O
{	O
hprintf	function
(	O
fhsend	int
,	O
"acknowledged\n"	pointer
)	O
;	O
}	O
free	function
(	O
cmd	pointer
)	O
;	O
}	O
free	function
(	O
line	pointer
)	O
;	O
}	O
}	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
sock	int
,	O
&	O
set	struct
)	O
)	O
{	O
cl	pointer
=	O
list_new	O
(	O
client	struct
)	O
;	O
cl	pointer
->	O
peer	int
=	O
accept	function
(	O
sock	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
linebuffer_reset	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
list_insert_first	O
(	O
ps	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
cl	pointer
->	O
status	int
=	O
0	int
;	O
}	O
}	O
linebuffer_free	function
(	O
&	O
lcmd	struct
)	O
;	O
free	function
(	O
buff	pointer
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
close	pointer
(	O
sig_pipe	array
[	O
0	int
]	O
)	O
;	O
sig_pipe	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
close	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
)	O
;	O
sig_pipe	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
cc	pointer
=	O
ps	pointer
.	O
childlist	pointer
;	O
cc	pointer
!=	O
NULL	O
;	O
cc	pointer
=	O
cc	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
cc	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
kill	function
(	O
cc	pointer
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
waitpid	function
(	O
cc	pointer
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
free	function
(	O
cc	pointer
)	O
;	O
}	O
ps	pointer
.	O
childlist	pointer
=	O
NULL	O
;	O
ps	pointer
.	O
achild	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
parse_host_data	function
(	O
char	O
*	O
arg	pointer
,	O
remotehost	struct
*	O
*	O
rrhosts	pointer
,	O
int	O
*	O
rnrhost	pointer
)	O
{	O
char	O
*	O
hostlist	pointer
,	O
*	O
*	O
hosts	pointer
,	O
*	O
eoc	pointer
;	O
int	O
j	int
,	O
n	int
,	O
r	int
;	O
remotehost	struct
*	O
rhosts	pointer
;	O
int	O
nrhost	int
;	O
if	O
(	O
arg	pointer
==	O
NULL	O
||	O
*	O
arg	pointer
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
hostlist	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
hosts	pointer
=	O
tokenize_char_dyn	function
(	O
hostlist	pointer
,	O
','	O
)	O
;	O
rhosts	pointer
=	O
NULL	O
;	O
nrhost	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
hosts	pointer
!=	O
NULL	O
&&	O
hosts	pointer
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
eoc	pointer
=	O
strchr	function
(	O
hosts	pointer
[	O
j	int
]	O
,	O
':'	O
)	O
;	O
rhosts	pointer
=	O
(	O
remotehost	struct
*	O
)	O
xrealloc	function
(	O
rhosts	pointer
,	O
sizeof	O
(	O
remotehost	struct
)	O
*	O
(	O
nrhost	int
+	O
1	int
)	O
)	O
;	O
if	O
(	O
eoc	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
hosts	pointer
[	O
j	int
]	O
,	O
PEXEC_ISTR_AUTO	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
hostspec	pointer
=	O
NULL	O
;	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_AUTO	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
hosts	pointer
[	O
j	int
]	O
,	O
PEXEC_ISTR_MANAGED	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
hostspec	pointer
=	O
NULL	O
;	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_MANAGED	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
hosts	pointer
[	O
j	int
]	O
,	O
PEXEC_ISTR_NCPU	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
hostspec	pointer
=	O
NULL	O
;	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
hosts	pointer
[	O
j	int
]	O
,	O
"%d"	pointer
,	O
&	O
n	int
)	O
==	O
1	int
&&	O
n	int
>	O
0	int
)	O
{	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
hostspec	pointer
=	O
NULL	O
;	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
n	int
;	O
}	O
else	O
{	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
hostspec	pointer
=	O
xstrdup	function
(	O
hosts	pointer
[	O
j	int
]	O
)	O
;	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_AUTO	O
;	O
}	O
}	O
else	O
if	O
(	O
eoc	pointer
==	O
hosts	pointer
[	O
j	int
]	O
)	O
{	O
free	function
(	O
rhosts	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
*	O
eoc	pointer
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
eoc	pointer
+	O
1	int
,	O
PEXEC_ISTR_AUTO	pointer
)	O
==	O
0	int
)	O
n	int
=	O
PEXEC_MNP_AUTO	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
eoc	pointer
+	O
1	int
,	O
PEXEC_ISTR_MANAGED	pointer
)	O
==	O
0	int
)	O
n	int
=	O
PEXEC_MNP_MANAGED	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
eoc	pointer
+	O
1	int
,	O
PEXEC_ISTR_NCPU	pointer
)	O
==	O
0	int
)	O
n	int
=	O
PEXEC_MNP_NCPU	O
;	O
else	O
if	O
(	O
(	O
r	int
=	O
sscanf	function
(	O
eoc	pointer
+	O
1	int
,	O
"%d"	pointer
,	O
&	O
n	int
)	O
)	O
==	O
0	int
||	O
(	O
r	int
==	O
1	int
&&	O
n	int
<=	O
0	int
)	O
)	O
{	O
free	function
(	O
rhosts	pointer
)	O
;	O
free	function
(	O
hostlist	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
hostspec	pointer
=	O
xstrdup	function
(	O
hosts	pointer
[	O
j	int
]	O
)	O
;	O
rhosts	pointer
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
n	int
;	O
}	O
nrhost	int
++	O
;	O
}	O
free	function
(	O
hosts	pointer
)	O
;	O
free	function
(	O
hostlist	pointer
)	O
;	O
*	O
rrhosts	pointer
=	O
rhosts	pointer
;	O
*	O
rnrhost	pointer
=	O
nrhost	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_shell_init	function
(	O
char	O
*	O
rsh	pointer
,	O
char	O
*	O
*	O
rshargs	pointer
,	O
char	O
*	O
pexec_self	pointer
,	O
char	O
*	O
ctrlport	pointer
,	O
int	O
timeout	int
,	O
remotehost	struct
*	O
rh	pointer
,	O
remoteshell	struct
*	O
rs	pointer
,	O
int	O
prio	int
)	O
{	O
int	O
pipesend	array
[	O
2	int
]	O
,	O
piperecv	array
[	O
2	int
]	O
;	O
int	O
pid	int
;	O
if	O
(	O
rh	pointer
->	O
hostspec	pointer
==	O
NULL	O
)	O
{	O
rs	pointer
->	O
pid	int
=	O
-	O
1	int
;	O
rs	pointer
->	O
fhsend	int
=	O
rs	pointer
->	O
fhrecv	int
=	O
-	O
1	int
;	O
rs	pointer
->	O
num_processes	int
=	O
rh	pointer
->	O
num_processes	int
;	O
rs	pointer
->	O
achild	int
=	O
0	int
;	O
linebuffer_reset	function
(	O
&	O
rs	pointer
->	O
lrsh	struct
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
pipe	function
(	O
pipesend	array
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
pipe	function
(	O
piperecv	array
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
-	O
2	int
)	O
;	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
char	O
*	O
line	pointer
,	O
*	O
*	O
tokens	pointer
;	O
rs	pointer
->	O
pid	int
=	O
pid	int
;	O
rs	pointer
->	O
fhsend	int
=	O
pipesend	array
[	O
1	int
]	O
;	O
close	pointer
(	O
pipesend	array
[	O
0	int
]	O
)	O
;	O
rs	pointer
->	O
fhrecv	int
=	O
piperecv	array
[	O
0	int
]	O
;	O
close	pointer
(	O
piperecv	array
[	O
1	int
]	O
)	O
;	O
rs	pointer
->	O
achild	int
=	O
0	int
;	O
linebuffer_reset	function
(	O
&	O
rs	pointer
->	O
lrsh	struct
)	O
;	O
line	pointer
=	O
linebuffer_read_line	function
(	O
rs	pointer
->	O
fhrecv	int
,	O
&	O
rs	pointer
->	O
lrsh	struct
,	O
timeout	int
)	O
;	O
if	O
(	O
line	pointer
==	O
NULL	O
)	O
return	O
(	O
-	O
3	int
)	O
;	O
tokens	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
tokens	pointer
!=	O
NULL	O
&&	O
tokens	pointer
[	O
0	int
]	O
!=	O
NULL	O
&&	O
strcmp	function
(	O
tokens	pointer
[	O
0	int
]	O
,	O
"initialization"	pointer
)	O
==	O
0	int
&&	O
tokens	pointer
[	O
1	int
]	O
!=	O
NULL	O
&&	O
sscanf	function
(	O
tokens	pointer
[	O
1	int
]	O
,	O
"num_processes=%d"	pointer
,	O
&	O
rs	pointer
->	O
num_processes	int
)	O
==	O
1	int
&&	O
rs	pointer
->	O
num_processes	int
>=	O
0	int
)	O
{	O
free	function
(	O
tokens	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tokens	pointer
!=	O
NULL	O
)	O
free	function
(	O
tokens	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
return	O
(	O
-	O
4	int
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
,	O
n	int
;	O
char	O
*	O
*	O
argv	pointer
,	O
num_buff	array
[	O
32	int
]	O
,	O
pri_buff	array
[	O
32	int
]	O
;	O
close	pointer
(	O
pipesend	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
piperecv	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
dup2	function
(	O
pipesend	array
[	O
0	int
]	O
,	O
0	int
)	O
;	O
close	pointer
(	O
pipesend	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
dup2	function
(	O
piperecv	array
[	O
1	int
]	O
,	O
1	int
)	O
;	O
close	pointer
(	O
piperecv	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
2	int
)	O
;	O
dup2	function
(	O
1	int
,	O
2	int
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
rshargs	pointer
[	O
n	int
]	O
!=	O
NULL	O
;	O
)	O
n	int
++	O
;	O
argv	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
n	int
+	O
32	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
)	O
{	O
argv	pointer
[	O
i	int
]	O
=	O
rshargs	pointer
[	O
i	int
]	O
;	O
i	int
++	O
;	O
}	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
rh	pointer
->	O
hostspec	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
pexec_self	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--tunnel"	pointer
;	O
if	O
(	O
rh	pointer
->	O
num_processes	int
>	O
0	int
)	O
{	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--number"	pointer
;	O
sprintf	function
(	O
num_buff	array
,	O
"%d"	pointer
,	O
rh	pointer
->	O
num_processes	int
)	O
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
num_buff	array
;	O
}	O
else	O
if	O
(	O
rh	pointer
->	O
num_processes	int
==	O
PEXEC_MNP_AUTO	O
)	O
{	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--number"	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
PEXEC_ISTR_AUTO	pointer
;	O
}	O
else	O
if	O
(	O
rh	pointer
->	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--number"	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
PEXEC_ISTR_MANAGED	pointer
;	O
}	O
else	O
if	O
(	O
rh	pointer
->	O
num_processes	int
==	O
PEXEC_MNP_NCPU	O
)	O
{	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--number"	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
PEXEC_ISTR_NCPU	pointer
;	O
}	O
if	O
(	O
prio	int
>	O
0	int
)	O
{	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--nice"	pointer
;	O
sprintf	function
(	O
pri_buff	array
,	O
"%d"	pointer
,	O
prio	int
-	O
128	int
)	O
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
pri_buff	array
;	O
}	O
if	O
(	O
ctrlport	pointer
!=	O
NULL	O
)	O
{	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"--bind"	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
ctrlport	pointer
;	O
}	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
NULL	O
;	O
execvp	function
(	O
rsh	pointer
,	O
argv	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"initialization execution=failed\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
is_unix_socket_name	function
(	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
strchr	function
(	O
name	pointer
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
is_inet_socket_name	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
port	int
;	O
char	O
*	O
colon	pointer
;	O
if	O
(	O
sscanf	function
(	O
name	pointer
,	O
"%d"	pointer
,	O
&	O
port	int
)	O
==	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
sscanf	function
(	O
name	pointer
,	O
"*:%d"	pointer
,	O
&	O
port	int
)	O
==	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
(	O
colon	pointer
=	O
strchr	function
(	O
name	pointer
,	O
':'	O
)	O
)	O
!=	O
NULL	O
&&	O
sscanf	function
(	O
colon	pointer
+	O
1	int
,	O
"%d"	pointer
,	O
&	O
port	int
)	O
==	O
1	int
)	O
return	O
(	O
2	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_control_port_bind	function
(	O
char	O
*	O
ctrlport	pointer
,	O
char	O
*	O
*	O
rctrlport	pointer
,	O
int	O
allow_auto	int
,	O
int	O
fail_on_existing	int
)	O
{	O
int	O
sock	int
,	O
port	int
,	O
ret	pointer
,	O
pid	int
;	O
char	O
buff	pointer
[	O
256	int
]	O
,	O
*	O
colon	pointer
;	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
ctrlport	pointer
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
allow_auto	int
&&	O
strcmp	function
(	O
ctrlport	pointer
,	O
"inet"	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
sockaddr_in	struct
inaddr	struct
;	O
sock	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
port	int
=	O
11228	int
,	O
ret	pointer
=	O
-	O
1	int
;	O
port	int
<	O
16384	int
;	O
port	int
++	O
)	O
{	O
inaddr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
inaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
inaddr	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
ret	pointer
=	O
bind	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
inaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
!	O
ret	pointer
)	O
break	O
;	O
}	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
sprintf	function
(	O
buff	pointer
,	O
"%d"	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rctrlport	pointer
!=	O
NULL	O
)	O
*	O
rctrlport	pointer
=	O
xstrdup	function
(	O
buff	pointer
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
ctrlport	pointer
,	O
"%d"	pointer
,	O
&	O
port	int
)	O
==	O
1	int
||	O
sscanf	function
(	O
ctrlport	pointer
,	O
"*:%d"	pointer
,	O
&	O
port	int
)	O
==	O
1	int
)	O
{	O
struct	O
sockaddr_in	struct
inaddr	struct
;	O
sock	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
inaddr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
inaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
inaddr	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
ret	pointer
=	O
bind	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
inaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
sprintf	function
(	O
buff	pointer
,	O
"%d"	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rctrlport	pointer
!=	O
NULL	O
)	O
*	O
rctrlport	pointer
=	O
xstrdup	function
(	O
buff	pointer
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
colon	pointer
=	O
strchr	function
(	O
ctrlport	pointer
,	O
':'	O
)	O
)	O
!=	O
NULL	O
&&	O
sscanf	function
(	O
colon	pointer
+	O
1	int
,	O
"%d"	pointer
,	O
&	O
port	int
)	O
==	O
1	int
)	O
{	O
struct	O
sockaddr_in	struct
inaddr	struct
;	O
char	O
*	O
hostname	pointer
;	O
struct	O
hostent	struct
*	O
peer	int
;	O
hostname	pointer
=	O
xmalloc	function
(	O
(	O
size_t	long
)	O
(	O
colon	pointer
-	O
ctrlport	pointer
)	O
+	O
1	int
)	O
;	O
memcpy	function
(	O
hostname	pointer
,	O
ctrlport	pointer
,	O
(	O
colon	pointer
-	O
ctrlport	pointer
)	O
)	O
;	O
hostname	pointer
[	O
(	O
colon	pointer
-	O
ctrlport	pointer
)	O
]	O
=	O
0	int
;	O
peer	int
=	O
gethostbyname	function
(	O
hostname	pointer
)	O
;	O
free	function
(	O
hostname	pointer
)	O
;	O
if	O
(	O
peer	int
==	O
NULL	O
||	O
peer	int
->	O
h_addrtype	int
!=	O
AF_INET	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
sock	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
inaddr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
inaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
memcpy	function
(	O
&	O
inaddr	struct
.	O
sin_addr	struct
.	O
s_addr	int
,	O
peer	int
->	O
h_addr	O
,	O
peer	int
->	O
h_length	int
)	O
;	O
ret	pointer
=	O
bind	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
inaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
rctrlport	pointer
!=	O
NULL	O
)	O
*	O
rctrlport	pointer
=	O
xstrdup	function
(	O
ctrlport	pointer
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
allow_auto	int
&&	O
strcmp	function
(	O
ctrlport	pointer
,	O
"unix"	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
sockaddr_un	struct
unaddr	struct
;	O
sock	int
=	O
socket	function
(	O
PF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
unaddr	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
pid	int
=	O
(	O
int	O
)	O
getpid	function
(	O
)	O
;	O
sprintf	function
(	O
unaddr	struct
.	O
sun_path	array
,	O
"/tmp/pexec.%d.sock"	pointer
,	O
pid	int
)	O
;	O
if	O
(	O
!	O
stat	struct
(	O
unaddr	struct
.	O
sun_path	array
,	O
&	O
st	struct
)	O
&&	O
S_ISSOCK	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
unlink	function
(	O
unaddr	struct
.	O
sun_path	array
)	O
;	O
ret	pointer
=	O
bind	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
unaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
unaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
rctrlport	pointer
!=	O
NULL	O
)	O
*	O
rctrlport	pointer
=	O
xstrdup	function
(	O
unaddr	struct
.	O
sun_path	array
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
is_unix_socket_name	function
(	O
ctrlport	pointer
)	O
)	O
{	O
struct	O
sockaddr_un	struct
unaddr	struct
;	O
sock	int
=	O
socket	function
(	O
PF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
unaddr	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	function
(	O
unaddr	struct
.	O
sun_path	array
,	O
ctrlport	pointer
,	O
UNIX_PATH_MAX	int
-	O
1	int
)	O
;	O
unaddr	struct
.	O
sun_path	array
[	O
UNIX_PATH_MAX	int
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
fail_on_existing	int
&&	O
(	O
!	O
stat	struct
(	O
unaddr	struct
.	O
sun_path	array
,	O
&	O
st	struct
)	O
)	O
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
!	O
stat	struct
(	O
unaddr	struct
.	O
sun_path	array
,	O
&	O
st	struct
)	O
)	O
&&	O
S_ISSOCK	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
unlink	function
(	O
unaddr	struct
.	O
sun_path	array
)	O
;	O
ret	pointer
=	O
bind	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
unaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
unaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
rctrlport	pointer
!=	O
NULL	O
)	O
*	O
rctrlport	pointer
=	O
xstrdup	function
(	O
unaddr	struct
.	O
sun_path	array
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
bind_variable_export	function
(	O
char	O
*	O
envvar	pointer
,	O
char	O
*	O
ctrlport	pointer
)	O
{	O
if	O
(	O
ctrlport	pointer
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
env_export	function
(	O
envvar	pointer
,	O
ctrlport	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_control_port_connect	function
(	O
char	O
*	O
ctrlport	pointer
)	O
{	O
int	O
sock	int
,	O
port	int
,	O
ret	pointer
;	O
struct	O
sockaddr_in	struct
inaddr	struct
;	O
struct	O
sockaddr_un	struct
unaddr	struct
;	O
char	O
*	O
sc	pointer
;	O
if	O
(	O
ctrlport	pointer
==	O
NULL	O
||	O
(	O
!	O
ctrlport	pointer
[	O
0	int
]	O
)	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
is_unix_socket_name	function
(	O
ctrlport	pointer
)	O
)	O
{	O
if	O
(	O
(	O
sock	int
=	O
socket	function
(	O
PF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
unaddr	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	function
(	O
unaddr	struct
.	O
sun_path	array
,	O
ctrlport	pointer
,	O
UNIX_PATH_MAX	int
-	O
1	int
)	O
;	O
unaddr	struct
.	O
sun_path	array
[	O
UNIX_PATH_MAX	int
-	O
1	int
]	O
=	O
0	int
;	O
ret	pointer
=	O
connect	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
unaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
unaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
{	O
inaddr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
sc	pointer
=	O
strchr	function
(	O
ctrlport	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
sc	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
ctrlport	pointer
,	O
"%d"	pointer
,	O
&	O
port	int
)	O
<	O
1	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
inaddr	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
htonl	function
(	O
INADDR_LOOPBACK	O
)	O
;	O
inaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
hostname	pointer
;	O
int	O
len	int
;	O
struct	O
hostent	struct
*	O
peer	int
;	O
if	O
(	O
sscanf	function
(	O
sc	pointer
+	O
1	int
,	O
"%d"	pointer
,	O
&	O
port	int
)	O
<	O
1	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
len	int
=	O
(	O
int	O
)	O
(	O
sc	pointer
-	O
ctrlport	pointer
)	O
;	O
hostname	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
hostname	pointer
,	O
ctrlport	pointer
,	O
len	int
)	O
;	O
hostname	pointer
[	O
len	int
]	O
=	O
0	int
;	O
peer	int
=	O
gethostbyname	function
(	O
hostname	pointer
)	O
;	O
free	function
(	O
hostname	pointer
)	O
;	O
if	O
(	O
peer	int
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
memcpy	function
(	O
&	O
inaddr	struct
.	O
sin_addr	struct
.	O
s_addr	int
,	O
peer	int
->	O
h_addr	O
,	O
peer	int
->	O
h_length	int
)	O
;	O
inaddr	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
}	O
if	O
(	O
(	O
sock	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
ret	pointer
=	O
connect	function
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
(	O
&	O
inaddr	struct
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
sock	int
)	O
;	O
}	O
}	O
int	O
remote_status	function
(	O
int	O
sock	int
,	O
FILE	struct
*	O
fw	pointer
)	O
{	O
linebuffer	struct
lrcv	struct
;	O
char	O
*	O
line	pointer
;	O
hprintf	function
(	O
sock	int
,	O
"status --all\n"	pointer
)	O
;	O
linebuffer_reset	function
(	O
&	O
lrcv	struct
)	O
;	O
line	pointer
=	O
linebuffer_read_line	function
(	O
sock	int
,	O
&	O
lrcv	struct
,	O
0	int
)	O
;	O
if	O
(	O
line	pointer
!=	O
NULL	O
)	O
{	O
remove_newlines_and_comments	function
(	O
line	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"%s\n"	pointer
,	O
line	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_lock	function
(	O
int	O
sock	int
,	O
FILE	struct
*	O
fw	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
linebuffer	struct
lrcv	struct
;	O
char	O
*	O
line	pointer
;	O
hprintf	function
(	O
sock	int
,	O
"lock \"%s\"\n"	pointer
,	O
name	pointer
)	O
;	O
linebuffer_reset	function
(	O
&	O
lrcv	struct
)	O
;	O
line	pointer
=	O
linebuffer_read_line	function
(	O
sock	int
,	O
&	O
lrcv	struct
,	O
0	int
)	O
;	O
if	O
(	O
line	pointer
!=	O
NULL	O
)	O
{	O
remove_newlines_and_comments	function
(	O
line	pointer
)	O
;	O
if	O
(	O
fw	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
fw	pointer
,	O
"%s\n"	pointer
,	O
line	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_unlock	function
(	O
int	O
sock	int
,	O
FILE	struct
*	O
fw	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
hprintf	function
(	O
sock	int
,	O
"unlock \"%s\"\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_copy	function
(	O
int	O
sock	int
,	O
char	O
*	O
name	pointer
,	O
FILE	struct
*	O
frin	pointer
,	O
FILE	struct
*	O
fwout	pointer
)	O
{	O
char	O
*	O
buff	pointer
;	O
int	O
blksize	int
,	O
r	int
,	O
fd	int
;	O
fd_set	struct
set	struct
;	O
FD_ZERO	O
(	O
&	O
set	struct
)	O
;	O
fd	int
=	O
fileno	function
(	O
frin	pointer
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
set	struct
)	O
;	O
select	function
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
name	pointer
!=	O
NULL	O
)	O
remote_lock	function
(	O
sock	int
,	O
NULL	O
,	O
name	pointer
)	O
;	O
blksize	int
=	O
getpagesize	function
(	O
)	O
;	O
buff	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
blksize	int
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
frin	pointer
)	O
)	O
{	O
r	int
=	O
fread	function
(	O
buff	pointer
,	O
1	int
,	O
blksize	int
,	O
frin	pointer
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
)	O
break	O
;	O
else	O
fwrite	function
(	O
buff	pointer
,	O
1	int
,	O
r	int
,	O
fwout	pointer
)	O
;	O
}	O
free	function
(	O
buff	pointer
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
name	pointer
!=	O
NULL	O
)	O
remote_unlock	function
(	O
sock	int
,	O
NULL	O
,	O
name	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_atomic_execute	function
(	O
int	O
is_shell_commands	int
,	O
char	O
*	O
shell	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
sock	int
)	O
{	O
int	O
pid	int
,	O
status	int
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
return	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sock	int
>=	O
0	int
)	O
close	pointer
(	O
sock	int
)	O
;	O
if	O
(	O
is_shell_commands	int
)	O
{	O
char	O
*	O
largv	array
[	O
4	int
]	O
;	O
largv	array
[	O
0	int
]	O
=	O
shell	pointer
;	O
largv	array
[	O
1	int
]	O
=	O
"-c"	pointer
;	O
largv	array
[	O
2	int
]	O
=	O
argv	pointer
[	O
0	int
]	O
;	O
largv	array
[	O
3	int
]	O
=	O
NULL	O
;	O
execv	function
(	O
shell	pointer
,	O
largv	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unable to execute the script '%s'.\n"	pointer
)	O
,	O
shell	pointer
,	O
progbasename	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
*	O
largv	array
;	O
int	O
i	int
,	O
largc	int
;	O
largc	int
=	O
argc	int
;	O
largv	array
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
largv	array
[	O
i	int
]	O
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
largv	array
[	O
argc	int
]	O
=	O
NULL	O
;	O
execvp	function
(	O
largv	array
[	O
0	int
]	O
,	O
largv	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: unable to execute the command '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
remote_disconnect	function
(	O
int	O
sock	int
)	O
{	O
char	O
buff	pointer
[	O
16	int
]	O
;	O
int	O
n	int
;	O
hprintf	function
(	O
sock	int
,	O
"exit\n"	pointer
)	O
;	O
n	int
=	O
read	pointer
(	O
sock	int
,	O
buff	pointer
,	O
16	int
)	O
;	O
return	O
(	O
n	int
)	O
;	O
}	O
int	O
pexec_hypervisor_check_load	function
(	O
int	O
loadtype	int
)	O
{	O
double	O
loadavg	array
[	O
3	int
]	O
;	O
if	O
(	O
!	O
(	O
0	int
<=	O
loadtype	int
&&	O
loadtype	int
<	O
3	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
getloadavg	function
(	O
loadavg	array
,	O
3	int
)	O
;	O
return	O
(	O
(	O
int	O
)	O
loadavg	array
[	O
loadtype	int
]	O
)	O
;	O
}	O
int	O
pexec_hypervisor_request_cleanup	function
(	O
hypervisorstatus	struct
*	O
hs	pointer
,	O
client	struct
*	O
cl	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
hs	pointer
->	O
nrequest	int
;	O
)	O
{	O
if	O
(	O
hs	pointer
->	O
requests	pointer
[	O
i	int
]	O
.	O
cl	pointer
==	O
cl	pointer
)	O
{	O
if	O
(	O
i	int
<	O
hs	pointer
->	O
nrequest	int
-	O
1	int
)	O
{	O
memmove	function
(	O
hs	pointer
->	O
requests	pointer
+	O
i	int
,	O
hs	pointer
->	O
requests	pointer
+	O
i	int
+	O
1	int
,	O
sizeof	O
(	O
request	struct
)	O
*	O
(	O
hs	pointer
->	O
nrequest	int
-	O
i	int
-	O
1	int
)	O
)	O
;	O
}	O
hs	pointer
->	O
nrequest	int
--	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
if	O
(	O
hs	pointer
->	O
nrequest	int
<=	O
0	int
)	O
{	O
free	function
(	O
hs	pointer
->	O
requests	pointer
)	O
;	O
hs	pointer
->	O
requests	pointer
=	O
NULL	O
;	O
hs	pointer
->	O
nrequest	int
=	O
0	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
pexec_hypervisor_acknowledge_pending	function
(	O
hypervisorstatus	struct
*	O
hs	pointer
)	O
{	O
request	struct
*	O
rw	pointer
;	O
while	O
(	O
hs	pointer
->	O
nrequest	int
>	O
0	int
&&	O
hs	pointer
->	O
nrunning	int
<	O
hs	pointer
->	O
num_processes	int
&&	O
pexec_hypervisor_check_load	function
(	O
hs	pointer
->	O
use_load	int
)	O
<	O
hs	pointer
->	O
num_processes	int
)	O
{	O
if	O
(	O
hs	pointer
->	O
use_fifo	int
)	O
rw	pointer
=	O
&	O
hs	pointer
->	O
requests	pointer
[	O
0	int
]	O
;	O
else	O
rw	pointer
=	O
&	O
hs	pointer
->	O
requests	pointer
[	O
hs	pointer
->	O
nrequest	int
-	O
1	int
]	O
;	O
hprintf	function
(	O
rw	pointer
->	O
cl	pointer
->	O
peer	int
,	O
"acknowledged\n"	pointer
)	O
;	O
hs	pointer
->	O
nrunning	int
++	O
;	O
rw	pointer
->	O
cl	pointer
->	O
status	int
++	O
;	O
if	O
(	O
hs	pointer
->	O
nrequest	int
>	O
1	int
&&	O
hs	pointer
->	O
use_fifo	int
)	O
{	O
memmove	function
(	O
hs	pointer
->	O
requests	pointer
,	O
hs	pointer
->	O
requests	pointer
+	O
1	int
,	O
sizeof	O
(	O
request	struct
)	O
*	O
(	O
hs	pointer
->	O
nrequest	int
-	O
1	int
)	O
)	O
;	O
}	O
hs	pointer
->	O
nrequest	int
--	O
;	O
if	O
(	O
hs	pointer
->	O
nrequest	int
<=	O
0	int
)	O
{	O
free	function
(	O
hs	pointer
->	O
requests	pointer
)	O
;	O
hs	pointer
->	O
requests	pointer
=	O
NULL	O
;	O
hs	pointer
->	O
nrequest	int
=	O
0	int
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
pexec_hypervisor_client_parse_command	function
(	O
char	O
*	O
line	pointer
,	O
hypervisorstatus	struct
*	O
hs	pointer
,	O
client	struct
*	O
cl	pointer
)	O
{	O
char	O
*	O
*	O
cmd	pointer
;	O
request	struct
*	O
rw	pointer
;	O
int	O
ret	pointer
;	O
cmd	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
cmd	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
free	function
(	O
cmd	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"request"	pointer
)	O
==	O
0	int
)	O
{	O
hs	pointer
->	O
requests	pointer
=	O
(	O
request	struct
*	O
)	O
xrealloc	function
(	O
hs	pointer
->	O
requests	pointer
,	O
sizeof	O
(	O
request	struct
)	O
*	O
(	O
hs	pointer
->	O
nrequest	int
+	O
1	int
)	O
)	O
;	O
rw	pointer
=	O
&	O
hs	pointer
->	O
requests	pointer
[	O
hs	pointer
->	O
nrequest	int
]	O
;	O
rw	pointer
->	O
cl	pointer
=	O
cl	pointer
;	O
hs	pointer
->	O
nrequest	int
++	O
;	O
pexec_hypervisor_acknowledge_pending	function
(	O
hs	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"ready"	pointer
)	O
==	O
0	int
)	O
{	O
hs	pointer
->	O
nrunning	int
--	O
;	O
cl	pointer
->	O
status	int
--	O
;	O
pexec_hypervisor_acknowledge_pending	function
(	O
hs	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"completed"	pointer
)	O
==	O
0	int
)	O
{	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"status"	pointer
)	O
==	O
0	int
)	O
{	O
double	O
loadavg	array
[	O
3	int
]	O
;	O
getloadavg	function
(	O
loadavg	array
,	O
3	int
)	O
;	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"status num_processes=%d use_load=%d use_fifo=%d nrunning=%d nrequest=%d load=%.2f,%.2f,%.2f\n"	pointer
,	O
hs	pointer
->	O
num_processes	int
,	O
hs	pointer
->	O
use_load	int
,	O
hs	pointer
->	O
use_fifo	int
,	O
hs	pointer
->	O
nrunning	int
,	O
hs	pointer
->	O
nrequest	int
,	O
loadavg	array
[	O
0	int
]	O
,	O
loadavg	array
[	O
1	int
]	O
,	O
loadavg	array
[	O
2	int
]	O
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"set"	pointer
)	O
==	O
0	int
)	O
{	O
int	O
i	int
,	O
w	int
;	O
char	O
*	O
invvar	pointer
;	O
invvar	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"num_processes=%d"	pointer
,	O
&	O
w	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
w	int
=	O
0	int
;	O
hs	pointer
->	O
num_processes	int
=	O
w	int
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"use_load=%d"	pointer
,	O
&	O
w	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
w	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
w	int
>	O
2	int
)	O
w	int
=	O
2	int
;	O
hs	pointer
->	O
use_load	int
=	O
w	int
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
cmd	pointer
[	O
i	int
]	O
,	O
"use_fifo=%d"	pointer
,	O
&	O
w	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
!	O
w	int
)	O
w	int
=	O
0	int
;	O
else	O
w	int
=	O
1	int
;	O
hs	pointer
->	O
use_fifo	int
=	O
w	int
;	O
}	O
else	O
invvar	pointer
=	O
cmd	pointer
[	O
i	int
]	O
;	O
}	O
if	O
(	O
invvar	pointer
!=	O
NULL	O
)	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"message \"invalid variable alternation '%s'\"\n"	pointer
,	O
invvar	pointer
)	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"close"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
[	O
0	int
]	O
,	O
"terminate"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
-	O
1	int
;	O
else	O
{	O
hprintf	function
(	O
cl	pointer
->	O
peer	int
,	O
"message \"invalid command '%s'\"\n"	pointer
,	O
cmd	pointer
[	O
0	int
]	O
)	O
;	O
ret	pointer
=	O
0	int
;	O
}	O
free	function
(	O
cmd	pointer
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
int	O
pexec_hypervisor_main_loop	function
(	O
int	O
sock	int
,	O
int	O
num_processes	int
,	O
int	O
use_load	int
,	O
int	O
use_fifo	int
)	O
{	O
client	struct
*	O
cl	pointer
,	O
*	O
cnext	pointer
;	O
hypervisorstatus	struct
hs	pointer
;	O
fd_set	struct
set	struct
;	O
int	O
i	int
,	O
max	int
,	O
buffsize	int
,	O
n	int
;	O
char	O
*	O
buff	pointer
;	O
int	O
is_in_loop	int
;	O
struct	O
sigaction	struct
intact	struct
;	O
signalinfo	struct
sci	struct
;	O
int	O
spipe	int
;	O
struct	O
timeval	struct
tv	struct
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
hs	pointer
.	O
clientlist	pointer
=	O
NULL	O
;	O
hs	pointer
.	O
num_processes	int
=	O
num_processes	int
;	O
hs	pointer
.	O
use_load	int
=	O
use_load	int
;	O
hs	pointer
.	O
use_fifo	int
=	O
use_fifo	int
;	O
hs	pointer
.	O
requests	pointer
=	O
NULL	O
;	O
hs	pointer
.	O
nrequest	int
=	O
0	int
;	O
hs	pointer
.	O
nrunning	int
=	O
0	int
;	O
buffsize	int
=	O
getpagesize	function
(	O
)	O
;	O
buff	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
(	O
size_t	long
)	O
buffsize	int
)	O
;	O
is_in_loop	int
=	O
1	int
;	O
if	O
(	O
pipe	function
(	O
sig_pipe	array
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
intact	struct
.	O
sa_handler	pointer
=	O
sig_act_interrupt	function
;	O
sigemptyset	function
(	O
&	O
intact	struct
.	O
sa_mask	struct
)	O
;	O
intact	struct
.	O
sa_flags	int
=	O
(	O
SA_NOCLDSTOP	int
|	O
SA_RESTART	int
)	O
;	O
sigaction	struct
(	O
SIGINT	int
,	O
&	O
intact	struct
,	O
NULL	O
)	O
;	O
spipe	int
=	O
sig_pipe	array
[	O
0	int
]	O
;	O
while	O
(	O
is_in_loop	int
)	O
{	O
FD_ZERO	O
(	O
&	O
set	struct
)	O
;	O
FD_SET	O
(	O
sock	int
,	O
&	O
set	struct
)	O
;	O
max	int
=	O
sock	int
;	O
for	O
(	O
cl	pointer
=	O
hs	pointer
.	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cl	pointer
->	O
next	pointer
)	O
{	O
FD_SET	O
(	O
cl	pointer
->	O
peer	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
cl	pointer
->	O
peer	int
)	O
max	int
=	O
cl	pointer
->	O
peer	int
;	O
}	O
if	O
(	O
spipe	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
spipe	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
max	int
<	O
spipe	int
)	O
max	int
=	O
spipe	int
;	O
}	O
if	O
(	O
use_load	int
>=	O
0	int
)	O
{	O
tv	struct
.	O
tv_sec	long
=	O
PEXEC_LOAD_CHECK_PERIOD	int
;	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
i	int
=	O
select	function
(	O
max	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct
)	O
;	O
}	O
else	O
i	int
=	O
select	function
(	O
max	int
+	O
1	int
,	O
&	O
set	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
pexec_hypervisor_acknowledge_pending	function
(	O
&	O
hs	pointer
)	O
;	O
for	O
(	O
cl	pointer
=	O
hs	pointer
.	O
clientlist	pointer
;	O
cl	pointer
!=	O
NULL	O
;	O
cl	pointer
=	O
cnext	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
int	O
closepeer	int
;	O
cnext	pointer
=	O
cl	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
cl	pointer
->	O
peer	int
,	O
&	O
set	struct
)	O
)	O
continue	O
;	O
n	int
=	O
read	pointer
(	O
cl	pointer
->	O
peer	int
,	O
buff	pointer
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
closepeer	int
=	O
1	int
;	O
else	O
closepeer	int
=	O
0	int
;	O
if	O
(	O
n	int
>	O
0	int
&&	O
(	O
!	O
closepeer	int
)	O
)	O
linebuffer_concatenate	function
(	O
&	O
cl	pointer
->	O
lcli	struct
,	O
buff	pointer
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
linebuffer_fetch	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
)	O
!=	O
NULL	O
&&	O
!	O
closepeer	int
)	O
{	O
closepeer	int
=	O
pexec_hypervisor_client_parse_command	function
(	O
line	pointer
,	O
&	O
hs	pointer
,	O
cl	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
if	O
(	O
closepeer	int
)	O
break	O
;	O
}	O
;	O
if	O
(	O
closepeer	int
)	O
{	O
close	pointer
(	O
cl	pointer
->	O
peer	int
)	O
;	O
if	O
(	O
cl	pointer
->	O
status	int
>	O
0	int
)	O
hs	pointer
.	O
nrunning	int
-=	O
cl	pointer
->	O
status	int
;	O
linebuffer_free	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
pexec_hypervisor_request_cleanup	function
(	O
&	O
hs	pointer
,	O
cl	pointer
)	O
;	O
list_remove	O
(	O
hs	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
free	function
(	O
cl	pointer
)	O
;	O
pexec_hypervisor_acknowledge_pending	function
(	O
&	O
hs	pointer
)	O
;	O
}	O
if	O
(	O
closepeer	int
<	O
0	int
)	O
is_in_loop	int
=	O
0	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
spipe	int
,	O
&	O
set	struct
)	O
)	O
{	O
if	O
(	O
!	O
(	O
read_signalinfo	function
(	O
spipe	int
,	O
&	O
sci	struct
)	O
>	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: fatal error: read_signalinfo() failed.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sci	struct
.	O
signal	function
==	O
SIGINT	int
&&	O
sci	struct
.	O
exitsignal	int
)	O
is_in_loop	int
=	O
0	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
sock	int
,	O
&	O
set	struct
)	O
)	O
{	O
cl	pointer
=	O
list_new	O
(	O
client	struct
)	O
;	O
cl	pointer
->	O
peer	int
=	O
accept	function
(	O
sock	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
linebuffer_reset	function
(	O
&	O
cl	pointer
->	O
lcli	struct
)	O
;	O
list_insert_first	O
(	O
hs	pointer
.	O
clientlist	pointer
,	O
cl	pointer
)	O
;	O
cl	pointer
->	O
status	int
=	O
0	int
;	O
}	O
}	O
signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
close	pointer
(	O
sig_pipe	array
[	O
0	int
]	O
)	O
;	O
sig_pipe	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
close	pointer
(	O
sig_pipe	array
[	O
1	int
]	O
)	O
;	O
sig_pipe	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
free	function
(	O
buff	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
pexec_hypervisor_stop	function
(	O
int	O
sock	int
)	O
{	O
hprintf	function
(	O
sock	int
,	O
"terminate\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_parameters	function
(	O
FILE	struct
*	O
fw	pointer
,	O
parameter	struct
*	O
params	pointer
,	O
int	O
nparam	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
fw	pointer
,	O
"name='%s' is_shell=%d "	pointer
,	O
params	pointer
[	O
i	int
]	O
.	O
name	pointer
,	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"args:"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
fw	pointer
,	O
" '%s'"	pointer
,	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
[	O
j	int
]	O
)	O
;	O
}	O
fprintf	function
(	O
fw	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
longhelp_entry	struct
pexec_long_help	array
[	O
]	O
=	O
{	O
LONGHELP_OPTIONS	O
,	O
{	O
"General options:"	pointer
,	O
NULL	O
}	O
,	O
{	O
"-h, --help"	pointer
,	O
"Gives general summary about the command line options."	pointer
}	O
,	O
{	O
"--long-help"	pointer
,	O
"Gives a detailed list of command line options."	pointer
}	O
,	O
{	O
"--version"	pointer
,	O
"Gives some version information about the program."	pointer
}	O
,	O
{	O
"-s, --shell <shell>"	pointer
,	O
"Full path (e.g. /bin/sh) of the shell or interpreter to be used "	pointer
"for script execution."	pointer
}	O
,	O
{	O
"-c, --shell-command"	pointer
,	O
"Use the specified shell to interpret the command(s) instead of "	pointer
"direct execution."	pointer
}	O
,	O
{	O
"-m, --multiple-command"	pointer
,	O
"Allow multiple individual shell command scripts to be executed "	pointer
"in parallel with the variation of the parameters."	pointer
}	O
,	O
{	O
"-e, --environment <variable>"	pointer
,	O
"Name of an environmental variable which is set to the respective "	pointer
"parameter before each execution."	pointer
}	O
,	O
{	O
"-n, --number <number>"	pointer
,	O
"The maximal number of processes running simultaneously. The <number> "	pointer
"itself can even be a complex specification of remote hosts (see "	pointer
"documentation for more details)."	pointer
}	O
,	O
{	O
"-C, --control <port>"	pointer
,	O
"The control port of a hypervisor daemon (full path of a UNIX "	pointer
"socket or an INET host specification)."	pointer
}	O
,	O
{	O
"-p, --list <list>"	pointer
,	O
"The single-argument form of main parameter list."	pointer
}	O
,	O
{	O
"-r, --parameters <list>"	pointer
,	O
"The multiple-argument form of the main parameter list."	pointer
}	O
,	O
{	O
"-f, --listfile <file>"	pointer
,	O
"The main parameter list file."	pointer
}	O
,	O
{	O
"-w, --column <index>"	pointer
,	O
"The column index from where the parameters should be taken if "	pointer
"they are read from a parameter file."	pointer
}	O
,	O
{	O
"-t, --complete"	pointer
,	O
"Threat the whole line as a single parameter if the "	pointer
"parameters are read from a file."	pointer
}	O
,	O
{	O
"-z, --nice"	pointer
,	O
"Sets the scheduling priority of pexec and all children "	pointer
"(executed processes) to the priority defined by this nice value."	pointer
}	O
,	O
{	O
"--"	pointer
,	O
"A marker after which the command to execute begins."	pointer
}	O
,	O
{	O
"Redirecting standard input, output and error:"	pointer
,	O
NULL	O
}	O
,	O
{	O
"-i, --input <input>"	pointer
,	O
"The (optionally formatted) name of the input file which is used "	pointer
"for redirecting the standard input."	pointer
}	O
,	O
{	O
"-o, --output <output>"	pointer
,	O
"The (optionally formatted) name of the output "	pointer
"file which is used for redirecting the standard output."	pointer
}	O
,	O
{	O
"-u, --error <output>"	pointer
,	O
"The (optionally formatted) name of the output "	pointer
"error file, which is used for redirecting the standard error."	pointer
}	O
,	O
{	O
"-R, --normal-redirection"	pointer
,	O
"Equivalent to specifying --output -, --error - and --input /dev/null."	pointer
}	O
,	O
{	O
"-a, --output-format <format>"	pointer
,	O
"The format of the final standard output redirection if the output "	pointer
"of all of the processes are gathered into the same file."	pointer
}	O
,	O
{	O
"-b, --error-format <format>"	pointer
,	O
"The same final redirection format for the standard error."	pointer
}	O
,	O
{	O
"-x, --omit-newlines"	pointer
,	O
"Disable automatic newlines after the output and error formats."	pointer
}	O
,	O
{	O
"Execution using remote hosts:"	pointer
,	O
NULL	O
}	O
,	O
{	O
"-g, --remote-shell <remote_shell>"	pointer
,	O
"The name or full path of the remote shell to be used for building "	pointer
"the tunnel between the local and the peer host(s). "	pointer
"Default: ``/usr/bin/ssh''."	pointer
}	O
,	O
{	O
"-P, --pexec <pexec>"	pointer
,	O
"The full path of the pexec program on the remote hosts. "	pointer
"If this option is omitted, pexec tries to figure out from the "	pointer
"invoking syntax and/or the current path."	pointer
}	O
,	O
{	O
"-T, --tunnel"	pointer
,	O
"Internal use only (pexec will start in tunnel daemon mode)."	pointer
}	O
,	O
{	O
"Remote control, mutual exclusions and atomic command execution:"	pointer
,	O
NULL	O
}	O
,	O
{	O
"-y, --bind <port>"	pointer
,	O
"This option lets pexec to be remote controlled via INET or "	pointer
"UNIX domain sockets."	pointer
}	O
,	O
{	O
"-E, --pexec-connection-variable <env>"	pointer
,	O
"This option overrides the default environment name PEXEC_REMOTE_PORT "	pointer
"to the specified value, which is used by the ``-p|--connect auto'' "	pointer
"combination to determine the control socket with which the running "	pointer
"pexec instance can be controlled."	pointer
}	O
,	O
{	O
"-j, --remote"	pointer
,	O
"Used to remote control and/or poll the status of other running "	pointer
"instances of pexec."	pointer
}	O
,	O
{	O
"-p, --connect <port>"	pointer
,	O
"Remote control port to connect to."	pointer
}	O
,	O
{	O
"-t, --status"	pointer
,	O
"Prints the actual status of the running jobs in a "	pointer
"human-readable form."	pointer
}	O
,	O
{	O
"-l, --lock <mutex>"	pointer
,	O
"Locks the specified mutex (if the mutex is not locked by "	pointer
"someone else, otherwise it will block until the mutex is released)."	pointer
}	O
,	O
{	O
"-u, --unlock <mutex>"	pointer
,	O
"Unlocks the specified mutex."	pointer
}	O
,	O
{	O
"-m, --mutex <mutex>"	pointer
,	O
"Name of the mutex."	pointer
}	O
,	O
{	O
"-d, --dump <filename>"	pointer
,	O
"Dump the content of the given file to standard output, "	pointer
"if ``-m|--mutex'' is given, this will be atomic."	pointer
}	O
,	O
{	O
"-s, --save <filename>"	pointer
,	O
"Save the content of standard input to the given file, "	pointer
"if ``-m|--mutex'' is given, this will be atomic."	pointer
}	O
,	O
{	O
"-a, --atomic <command>"	pointer
,	O
"Execute the given command. If ``-m|--mutex'' is given, the "	pointer
"exectution is going to be atomic with respect to that mutex."	pointer
}	O
,	O
{	O
"Hypervisor mode:"	pointer
,	O
NULL	O
}	O
,	O
{	O
"-H, --hypervisor"	pointer
,	O
"Starts pexec in hypervisor mode."	pointer
}	O
,	O
{	O
"-C, --control <port>"	pointer
,	O
"The control port used by the hypervisor."	pointer
}	O
,	O
{	O
"-l, --load <window>"	pointer
,	O
"Use load also to limit the number of simultaneous processes "	pointer
"with the specified load average interval (0, 1 or 2, or 1min, "	pointer
"5min or 15min, respectively)."	pointer
}	O
,	O
{	O
"-f, --fifo"	pointer
,	O
"First in first out queue processing."	pointer
}	O
,	O
{	O
"-s, --lifo"	pointer
,	O
"Last in first out (stack) queue processing (default)."	pointer
}	O
,	O
{	O
"Logging:"	pointer
,	O
NULL	O
}	O
,	O
{	O
"-L, --log <file>"	pointer
,	O
"The name of the log file."	pointer
}	O
,	O
{	O
"-W, --log-level <level>"	pointer
,	O
"The logging level."	pointer
}	O
,	O
{	O
"-V, --verbose"	pointer
,	O
"Increase the log level by one."	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
int	O
fprint_pexec_long_help	function
(	O
FILE	struct
*	O
fw	pointer
)	O
{	O
fprintf	function
(	O
fw	pointer
,	O
"Usage:\tpexec [options] [-c|-m] [--] command [arguments] | 'compound command'\n"	pointer
"Execute commands or shell scripts in parallel on a single host or\n"	pointer
"on remote hosts using a remote shell.\n\n"	pointer
)	O
;	O
longhelp_fprint	function
(	O
fw	pointer
,	O
pexec_long_help	array
,	O
0	int
,	O
-	O
1	int
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Report bugs to <apal@szofi.elte.hu>\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_pexec_usage	function
(	O
FILE	struct
*	O
fw	pointer
)	O
{	O
fprintf	function
(	O
fw	pointer
,	O
"Usage:\tpexec"	pointer
"\t[options] [--] command [arguments]\n"	pointer
"\t\t[options] -c [--] 'compound command'\n"	pointer
"\t\t[options] -m [--] 'compound command 1' 'compound command 2' ...\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"General Options:\n"	pointer
"\t[-h|--help|--long-help] [--version]\n"	pointer
"\t[-c|--shell-command] [-m|--multiple-command] [-s|--shell <shell>]\n"	pointer
"\t[-e|--environment <environmental_variable_name>]\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"\t[-p|--list <list_of_parametes> [-p ...] [-p ...]]\n"	pointer
"\t[-r|--parameters <list_of_parametes> {--|-<option} [-r ...] [-r ...]]\n"	pointer
"\t[-f|--listfile <parameter_file> [-w|--column <column>|-t|--complete]]\n"	pointer
"\t[-n|--number auto|<num>|managed|ncpu [-C|--control {<port>|</path>}]]\n"	pointer
"\t[-l|--load|--use-load <load>] [-z|--nice <nice>]\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Redirecting input and output:\n"	pointer
"\t[-i|--input <format_for_standard_input_file>]\n"	pointer
"\t[-o|--output <format_for_standard_output_file>]\n"	pointer
"\t[-u|--error <format_for_standard_error_file>]\n"	pointer
"\t[-a|--output-format <format_for_stdout_redirection> [-x]]\n"	pointer
"\t[-b|--error-format <format_for_stderr_redirection> [-x|--omit-newlines]]\n"	pointer
"\t[-R|--normal-redirection]\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Parallelization using remote hosts:\n"	pointer
"\t[-g|--remote-shell \"<remote_shell [options]>\"] [-q|--timeout <sec>]\n"	pointer
"\t-n|--number [<host>:]{auto|<num>|managed|ncpu}[,...],[auto|<num>|...]\n"	pointer
"\t[-P|--pexec <full_pexec_path_on_the_remote_host(s)>] [-k|--local-files]\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Running as a tunnel daemon (only for internal use, see also the manual):\n"	pointer
"\t-T|--tunnel [-z|--nice <nice>]\n"	pointer
"\t[-n|--number auto|<num>|managed|ncpu [-C|--control {<port>|</path>}]]\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Remote control, mutual exclusions and atomic command execution:\n"	pointer
"\t[-y|--bind inet|unix|<port>|/<path>]\n"	pointer
"\t-j|--remote [-p|--connect auto|/<path>|[host:]<port>] [-t|--status]\n"	pointer
"\t[-E|--pexec-connection-variable <env_variable_name>]\n"	pointer
"\t[{-l|--lock|--mutex-lock | -u|--unlock|--mutex-unlock} <name>]\n"	pointer
"\t[-m|--mutex <name> {-d|--dump | -s|--save} <filename> ]\n"	pointer
"\t[-m|--mutex <name> -a|--atomic [-c|--shell-command] [--] command [...]]\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Hypervisor mode and operations:\n"	pointer
"\t-H|--hypervisor [-C|--control {<port>|</path>}] [start|stop]\n"	pointer
"\t[-n|--number auto|<num>] [-l|--load|--use-load <load>]\n"	pointer
"\t[-f|--fifo | -s|--lifo|--stack]\n"	pointer
"\t(default hypervisor socket: %s)\n"	pointer
,	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Logging (for normal and hypervisor modes):\n"	pointer
"\t[-L|--log <log_file>] [-W|--log-level <log_level> | -V|--verbose [...]]\n"	pointer
"Command specifications:\n"	pointer
"\t[--] { command [args] | 'compound' | 'compound 1' ['compound 2'...] }\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"For more information, see --long-help or the full texinfo documentation.\n"	pointer
"Examples can be found in the ``Examples'' section of the documentation.\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_version	function
(	O
FILE	struct
*	O
fw	pointer
)	O
{	O
fprintf	function
(	O
fw	pointer
,	O
"%s %s (%s)\n"	pointer
,	O
progbasename	pointer
,	O
PEXEC_VERSION	pointer
,	O
PEXEC_LAST_MODIFICATION	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"Copyright (C) 2007, 2008-2009; Pal, Andras <apal@szofi.elte.hu>\n\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"This is free software. You may redistribute copies of it under the terms of\n"	pointer
"the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n"	pointer
"There is NO WARRANTY, to the extent permitted by law. \n\n"	pointer
)	O
;	O
fprintf	function
(	O
fw	pointer
,	O
"This software was written by Andras Pal. The core part was written \n"	pointer
"while working for the Hungarian-made Automated Telescope (HAT) project \n"	pointer
"to make the data processing more easier and therefore find many-many \n"	pointer
"extrasolar planets. See more information about this project: \n"	pointer
"http://hatnet.hu. Another internal libraries (e.g. numhash.[ch]) were \n"	pointer
"primarily written for other projects.\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_err_invarg0	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: invalid command line argument '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
arg	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_err_invarg1	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: invalid or missing argument near '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
arg	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_err_invarg2	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: special command line argument '%s' must be the first in the list.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
arg	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
is_shell_commands	int
,	O
is_multi_commands	int
,	O
zeroarg	int
;	O
remotehost	struct
*	O
rhosts	pointer
;	O
int	O
nrhost	int
;	O
char	O
*	O
list	pointer
,	O
*	O
listfile	pointer
,	O
*	O
logfile	pointer
;	O
int	O
listcolumn	int
;	O
paralleldata	struct
p	pointer
;	O
logdata	struct
log	pointer
;	O
int	O
ncmd	int
;	O
int	O
llen	int
;	O
int	O
i	int
,	O
ret	pointer
,	O
prio	int
;	O
parameter	struct
*	O
params	pointer
;	O
int	O
nparam	int
;	O
char	O
*	O
*	O
pnames	pointer
;	O
char	O
*	O
pexec_self	pointer
,	O
*	O
ctrlport	pointer
,	O
*	O
ctrlenv	pointer
,	O
*	O
hypcport	pointer
;	O
int	O
timeout	int
,	O
use_load	int
;	O
int	O
mode	int
;	O
is_shell_commands	int
=	O
0	int
;	O
is_multi_commands	int
=	O
0	int
;	O
zeroarg	int
=	O
-	O
1	int
;	O
list	pointer
=	O
NULL	O
;	O
pnames	pointer
=	O
NULL	O
;	O
listfile	pointer
=	O
logfile	pointer
=	O
NULL	O
;	O
llen	int
=	O
0	int
;	O
rhosts	pointer
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_AUTO	O
;	O
p	pointer
.	O
envvarname	pointer
=	O
NULL	O
;	O
p	pointer
.	O
out	pointer
=	O
p	pointer
.	O
err	long
=	O
p	pointer
.	O
in	pointer
=	O
NULL	O
;	O
p	pointer
.	O
shell	pointer
=	O
PEXEC_DEFAULT_SHELL	pointer
;	O
p	pointer
.	O
rshcmd	pointer
=	O
NULL	O
;	O
prio	int
=	O
0	int
;	O
p	pointer
.	O
formatout	pointer
=	O
NULL	O
;	O
p	pointer
.	O
formaterr	pointer
=	O
NULL	O
;	O
p	pointer
.	O
omit_newlines	int
=	O
0	int
;	O
log	pointer
.	O
loglevel	int
=	O
-	O
1	int
;	O
log	pointer
.	O
fwlog	pointer
=	O
NULL	O
;	O
listcolumn	int
=	O
0	int
;	O
progbasename	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
progbasename	pointer
!=	O
NULL	O
)	O
progbasename	pointer
++	O
;	O
else	O
progbasename	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
mode	int
=	O
PEXEC_MODE_DEFAULT	int
;	O
if	O
(	O
strchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
pexec_self	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
else	O
{	O
pexec_self	pointer
=	O
progbasename	pointer
;	O
}	O
timeout	int
=	O
60	int
;	O
ctrlport	pointer
=	O
NULL	O
;	O
ctrlenv	pointer
=	O
PEXEC_DEFAULT_ENVVARIABLE	pointer
;	O
hypcport	pointer
=	O
NULL	O
;	O
use_load	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-h"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--short-help"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--help"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--help-short"	pointer
)	O
==	O
0	int
)	O
{	O
fprint_pexec_usage	function
(	O
stdout	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--long-help"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--help-long"	pointer
)	O
==	O
0	int
)	O
{	O
fprint_pexec_long_help	function
(	O
stdout	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--version"	pointer
)	O
==	O
0	int
)	O
{	O
fprint_version	function
(	O
stdout	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-c"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--shell-command"	pointer
)	O
==	O
0	int
)	O
is_shell_commands	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--multiple-command"	pointer
)	O
==	O
0	int
)	O
is_multi_commands	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-e"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--environment"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--setenv"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
envvarname	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-s"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--shell"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
shell	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-g"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--remote-shell"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
i	int
++	O
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
rshcmd	pointer
=	O
xstrdup	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-p"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--list"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
{	O
list	pointer
=	O
xstrdup	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
llen	int
=	O
strlen	function
(	O
list	pointer
)	O
;	O
}	O
else	O
{	O
int	O
ilen	int
;	O
ilen	int
=	O
strlen	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
list	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
list	pointer
,	O
llen	int
+	O
ilen	int
+	O
2	int
)	O
;	O
strcpy	function
(	O
list	pointer
+	O
llen	int
,	O
" "	pointer
)	O
;	O
llen	int
++	O
;	O
strcpy	function
(	O
list	pointer
+	O
llen	int
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
llen	int
+=	O
ilen	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-r"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--parameters"	pointer
)	O
==	O
0	int
)	O
{	O
i	int
++	O
;	O
for	O
(	O
;	O
i	int
<	O
argc	int
&&	O
argv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
!=	O
'-'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
{	O
list	pointer
=	O
xstrdup	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
llen	int
=	O
strlen	function
(	O
list	pointer
)	O
;	O
}	O
else	O
{	O
int	O
ilen	int
;	O
ilen	int
=	O
strlen	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
list	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
list	pointer
,	O
llen	int
+	O
ilen	int
+	O
2	int
)	O
;	O
strcpy	function
(	O
list	pointer
+	O
llen	int
,	O
" "	pointer
)	O
;	O
llen	int
++	O
;	O
strcpy	function
(	O
list	pointer
+	O
llen	int
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
llen	int
+=	O
ilen	int
;	O
}	O
}	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-f"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--listfile"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
listfile	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-w"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--column"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
listcolumn	int
)	O
<	O
1	int
||	O
listcolumn	int
<=	O
0	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
listcolumn	int
--	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-t"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--complete"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--complete-line"	pointer
)	O
==	O
0	int
)	O
listcolumn	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-n"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--number"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_AUTO	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_AUTO	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_MANAGED	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_MANAGED	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_NCPU	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_NCPU	O
;	O
}	O
else	O
if	O
(	O
parse_host_data	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
&	O
rhosts	pointer
,	O
&	O
nrhost	int
)	O
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-M"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--managed"	pointer
)	O
==	O
0	int
)	O
{	O
rhosts	pointer
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_MANAGED	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-l"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--load"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--use-load"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"0"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"1m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"1min"	pointer
)	O
==	O
0	int
)	O
use_load	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"1"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"5m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"5min"	pointer
)	O
==	O
0	int
)	O
use_load	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"2"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"15m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"15min"	pointer
)	O
==	O
0	int
)	O
use_load	int
=	O
2	int
;	O
else	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-z"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--nice"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
prio	int
)	O
<	O
1	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
prio	int
+=	O
128	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-q"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--timeout"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
timeout	int
)	O
<	O
1	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
timeout	int
<	O
0	int
)	O
timeout	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-P"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--pexec"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
pexec_self	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-E"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--pexec-connection-variable"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlenv	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-i"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--input"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
in	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-o"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--output"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
out	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-u"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--error"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--output-error"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
err	long
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-R"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--normal-redirection"	pointer
)	O
==	O
0	int
)	O
{	O
p	pointer
.	O
in	pointer
=	O
NULL	O
;	O
p	pointer
.	O
out	pointer
=	O
"-"	pointer
;	O
p	pointer
.	O
err	long
=	O
"-"	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-a"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--output-format"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
formatout	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-b"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--error-format"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	pointer
.	O
formaterr	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-x"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--omit-newlines"	pointer
)	O
==	O
0	int
)	O
p	pointer
.	O
omit_newlines	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-y"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--bind"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlport	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-C"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--control"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
hypcport	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-L"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--log"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
logfile	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-V"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--verbose"	pointer
)	O
==	O
0	int
)	O
log	pointer
.	O
loglevel	int
++	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-W"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--log-level"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
log	pointer
.	O
loglevel	int
)	O
<	O
1	int
||	O
log	pointer
.	O
loglevel	int
<	O
0	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-T"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--tunnel"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
fprint_err_invarg2	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
mode	int
=	O
PEXEC_MODE_DAEMON	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-j"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--remote"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
fprint_err_invarg2	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
mode	int
=	O
PEXEC_MODE_REMOTECONTROL	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-H"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--hypervisor"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
fprint_err_invarg2	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
mode	int
=	O
PEXEC_MODE_HYPERVISOR	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--"	pointer
)	O
==	O
0	int
)	O
{	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
zeroarg	int
>=	O
argc	int
)	O
zeroarg	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
fprint_err_invarg0	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
zeroarg	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
zeroarg	int
<	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_DEFAULT	int
)	O
{	O
remoteshell	struct
*	O
rshells	pointer
,	O
*	O
rs	pointer
;	O
int	O
nrshell	int
,	O
r	int
;	O
int	O
status	int
,	O
sock	int
,	O
hsck	int
;	O
char	O
*	O
pctrlport	pointer
;	O
int	O
is_rhosts_defined	int
,	O
no_touch_std	int
;	O
if	O
(	O
rhosts	pointer
==	O
NULL	O
)	O
{	O
rhosts	pointer
=	O
(	O
remotehost	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
remotehost	struct
)	O
*	O
1	int
)	O
;	O
rhosts	pointer
[	O
0	int
]	O
.	O
hostspec	pointer
=	O
NULL	O
;	O
rhosts	pointer
[	O
0	int
]	O
.	O
num_processes	int
=	O
nrhost	int
;	O
nrhost	int
=	O
1	int
;	O
is_rhosts_defined	int
=	O
0	int
;	O
}	O
else	O
is_rhosts_defined	int
=	O
!	O
0	int
;	O
if	O
(	O
p	pointer
.	O
rshcmd	pointer
==	O
NULL	O
)	O
p	pointer
.	O
rshcmd	pointer
=	O
xstrdup	function
(	O
PEXEC_DEFAULT_RSH	pointer
)	O
;	O
p	pointer
.	O
rshargs	pointer
=	O
tokenize_spaces_dyn	function
(	O
p	pointer
.	O
rshcmd	pointer
)	O
;	O
p	pointer
.	O
rsh	pointer
=	O
p	pointer
.	O
rshargs	pointer
[	O
0	int
]	O
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
&&	O
listfile	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: both parameter list and list file are defined.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
{	O
pnames	pointer
=	O
tokenize_spaces_dyn	function
(	O
list	pointer
)	O
;	O
for	O
(	O
nparam	int
=	O
0	int
;	O
pnames	pointer
!=	O
NULL	O
&&	O
pnames	pointer
[	O
nparam	int
]	O
!=	O
NULL	O
;	O
)	O
nparam	int
++	O
;	O
params	pointer
=	O
(	O
parameter	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
parameter	struct
)	O
*	O
nparam	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
name	pointer
=	O
pnames	pointer
[	O
i	int
]	O
;	O
}	O
}	O
else	O
if	O
(	O
listfile	pointer
!=	O
NULL	O
)	O
{	O
FILE	struct
*	O
fr	pointer
;	O
char	O
*	O
line	pointer
,	O
*	O
*	O
tokens	pointer
;	O
int	O
ntoken	int
;	O
if	O
(	O
strcmp	function
(	O
listfile	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
fr	pointer
=	O
stdin	pointer
;	O
else	O
fr	pointer
=	O
fopen	function
(	O
listfile	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
fr	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to open list file.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
params	pointer
=	O
NULL	O
;	O
nparam	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	function
(	O
fr	pointer
)	O
)	O
{	O
line	pointer
=	O
freadline	function
(	O
fr	pointer
)	O
;	O
if	O
(	O
line	pointer
==	O
NULL	O
)	O
break	O
;	O
remove_newlines_and_comments	function
(	O
line	pointer
)	O
;	O
if	O
(	O
!	O
(	O
strlen	function
(	O
line	pointer
)	O
>	O
0	int
)	O
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
listcolumn	int
<	O
0	int
)	O
{	O
params	pointer
=	O
(	O
parameter	struct
*	O
)	O
xrealloc	function
(	O
params	pointer
,	O
sizeof	O
(	O
parameter	struct
)	O
*	O
(	O
nparam	int
+	O
1	int
)	O
)	O
;	O
params	pointer
[	O
nparam	int
]	O
.	O
name	pointer
=	O
xstrdup	function
(	O
line	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
nparam	int
++	O
;	O
}	O
else	O
{	O
tokens	pointer
=	O
tokenize_spaces_dyn	function
(	O
line	pointer
)	O
;	O
if	O
(	O
tokens	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
ntoken	int
=	O
0	int
;	O
tokens	pointer
[	O
ntoken	int
]	O
!=	O
NULL	O
;	O
)	O
ntoken	int
++	O
;	O
if	O
(	O
listcolumn	int
>=	O
ntoken	int
)	O
{	O
free	function
(	O
tokens	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
continue	O
;	O
}	O
params	pointer
=	O
(	O
parameter	struct
*	O
)	O
xrealloc	function
(	O
params	pointer
,	O
sizeof	O
(	O
parameter	struct
)	O
*	O
(	O
nparam	int
+	O
1	int
)	O
)	O
;	O
params	pointer
[	O
nparam	int
]	O
.	O
name	pointer
=	O
xstrdup	function
(	O
tokens	pointer
[	O
listcolumn	int
]	O
)	O
;	O
free	function
(	O
tokens	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
nparam	int
++	O
;	O
}	O
}	O
if	O
(	O
fileno	function
(	O
fr	pointer
)	O
!=	O
fileno	function
(	O
stdin	pointer
)	O
)	O
fclose	function
(	O
fr	pointer
)	O
;	O
}	O
else	O
{	O
params	pointer
=	O
NULL	O
;	O
nparam	int
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
0	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
NULL	O
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
0	int
;	O
}	O
if	O
(	O
is_multi_commands	int
)	O
ncmd	int
=	O
argc	int
-	O
zeroarg	int
;	O
else	O
ncmd	int
=	O
1	int
;	O
no_touch_std	int
=	O
0	int
;	O
if	O
(	O
nparam	int
>	O
0	int
&&	O
is_multi_commands	int
&&	O
nparam	int
!=	O
ncmd	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: number of parameters and commands mismatch.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
is_multi_commands	int
&&	O
nparam	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
1	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
argv	pointer
+	O
zeroarg	int
+	O
i	int
;	O
}	O
}	O
else	O
if	O
(	O
is_multi_commands	int
)	O
{	O
nparam	int
=	O
ncmd	int
;	O
params	pointer
=	O
(	O
parameter	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
parameter	struct
)	O
*	O
nparam	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ncmd	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
1	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
argv	pointer
+	O
zeroarg	int
+	O
i	int
;	O
}	O
}	O
else	O
if	O
(	O
nparam	int
>	O
0	int
&&	O
is_shell_commands	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
argv	pointer
+	O
zeroarg	int
;	O
}	O
}	O
else	O
if	O
(	O
nparam	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
0	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
argv	pointer
+	O
zeroarg	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
is_rhosts_defined	int
)	O
{	O
nparam	int
=	O
1	int
;	O
params	pointer
=	O
(	O
parameter	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
parameter	struct
)	O
*	O
nparam	int
)	O
;	O
params	pointer
[	O
0	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
params	pointer
[	O
0	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
is_shell_commands	int
;	O
params	pointer
[	O
0	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
argv	pointer
+	O
zeroarg	int
;	O
params	pointer
[	O
0	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
no_touch_std	int
=	O
!	O
0	int
;	O
}	O
else	O
{	O
nparam	int
=	O
nrhost	int
;	O
params	pointer
=	O
(	O
parameter	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
parameter	struct
)	O
*	O
nparam	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
name	pointer
=	O
rhosts	pointer
[	O
i	int
]	O
.	O
hostspec	pointer
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
-	O
1	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argv	pointer
=	O
argv	pointer
+	O
zeroarg	int
;	O
params	pointer
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
}	O
rhosts	pointer
[	O
0	int
]	O
.	O
hostspec	pointer
=	O
NULL	O
;	O
rhosts	pointer
[	O
0	int
]	O
.	O
num_processes	int
=	O
nparam	int
;	O
nrhost	int
=	O
1	int
;	O
no_touch_std	int
=	O
!	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
status	int
=	O
0	int
;	O
params	pointer
[	O
i	int
]	O
.	O
no_touch_std	int
=	O
0	int
;	O
params	pointer
[	O
i	int
]	O
.	O
id	int
=	O
i	int
;	O
}	O
if	O
(	O
(	O
no_touch_std	int
||	O
nparam	int
<=	O
1	int
)	O
&&	O
p	pointer
.	O
in	pointer
==	O
NULL	O
&&	O
p	pointer
.	O
out	pointer
==	O
NULL	O
&&	O
p	pointer
.	O
err	long
==	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	pointer
[	O
i	int
]	O
.	O
no_touch_std	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
p	pointer
.	O
out	pointer
!=	O
NULL	O
&&	O
(	O
!	O
format_check_if_formatted	function
(	O
p	pointer
.	O
out	pointer
,	O
"skd"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
.	O
out	pointer
,	O
"-"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
.	O
out	pointer
,	O
"-1"	pointer
)	O
==	O
0	int
)	O
p	pointer
.	O
fwout	pointer
=	O
stdout	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
.	O
out	pointer
,	O
"-2"	pointer
)	O
==	O
0	int
)	O
p	pointer
.	O
fwout	pointer
=	O
stderr	pointer
;	O
else	O
p	pointer
.	O
fwout	pointer
=	O
fopen	function
(	O
p	pointer
.	O
out	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
p	pointer
.	O
fwout	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to create collective output file '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
p	pointer
.	O
out	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
p	pointer
.	O
fwout	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
.	O
err	long
!=	O
NULL	O
&&	O
(	O
!	O
format_check_if_formatted	function
(	O
p	pointer
.	O
err	long
,	O
"skd"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
.	O
err	long
,	O
"-"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
.	O
err	long
,	O
"-2"	pointer
)	O
==	O
0	int
)	O
p	pointer
.	O
fwerr	pointer
=	O
stderr	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
.	O
err	long
,	O
"-1"	pointer
)	O
==	O
0	int
)	O
p	pointer
.	O
fwerr	pointer
=	O
stdout	pointer
;	O
else	O
p	pointer
.	O
fwerr	pointer
=	O
fopen	function
(	O
p	pointer
.	O
err	long
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
p	pointer
.	O
fwerr	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to create collective error file '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
p	pointer
.	O
err	long
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
p	pointer
.	O
fwerr	pointer
=	O
NULL	O
;	O
if	O
(	O
logfile	pointer
!=	O
NULL	O
&&	O
log	pointer
.	O
loglevel	int
!=	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
logfile	pointer
,	O
"-"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
logfile	pointer
,	O
"-2"	pointer
)	O
==	O
0	int
)	O
log	pointer
.	O
fwlog	pointer
=	O
stderr	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
logfile	pointer
,	O
"-1"	pointer
)	O
==	O
0	int
)	O
log	pointer
.	O
fwlog	pointer
=	O
stdout	pointer
;	O
else	O
log	pointer
.	O
fwlog	pointer
=	O
fopen	function
(	O
logfile	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
log	pointer
.	O
fwlog	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to create log file '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
logfile	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
log	pointer
.	O
loglevel	int
<	O
0	int
)	O
log	pointer
.	O
loglevel	int
=	O
+	O
1	int
;	O
}	O
else	O
if	O
(	O
log	pointer
.	O
loglevel	int
>	O
0	int
)	O
log	pointer
.	O
fwlog	pointer
=	O
stderr	pointer
;	O
else	O
{	O
log	pointer
.	O
fwlog	pointer
=	O
NULL	O
;	O
log	pointer
.	O
loglevel	int
=	O
0	int
;	O
}	O
if	O
(	O
prio	int
>	O
0	int
)	O
{	O
i	int
=	O
setpriority	function
(	O
PRIO_PROCESS	int
,	O
0	int
,	O
prio	int
-	O
128	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: warning: unable to set scheduling priority to %d.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
prio	int
-	O
128	int
)	O
;	O
}	O
}	O
if	O
(	O
ctrlport	pointer
!=	O
NULL	O
)	O
{	O
sock	int
=	O
remote_control_port_bind	function
(	O
ctrlport	pointer
,	O
&	O
pctrlport	pointer
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to create or bind control socket to %s.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
ctrlport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
sock	int
=	O
-	O
1	int
;	O
pctrlport	pointer
=	O
NULL	O
;	O
}	O
p	pointer
.	O
fallback_to_die	int
=	O
1	int
;	O
nrshell	int
=	O
nrhost	int
;	O
rshells	pointer
=	O
(	O
remoteshell	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
remoteshell	struct
)	O
*	O
nrshell	int
)	O
;	O
hsck	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nrhost	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
rhosts	pointer
[	O
i	int
]	O
.	O
hostspec	pointer
==	O
NULL	O
&&	O
(	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
==	O
PEXEC_MNP_AUTO	O
||	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
&&	O
hsck	int
<	O
0	int
)	O
{	O
if	O
(	O
hypcport	pointer
==	O
NULL	O
)	O
hypcport	pointer
=	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	pointer
;	O
hsck	int
=	O
remote_control_port_connect	function
(	O
hypcport	pointer
)	O
;	O
if	O
(	O
hsck	int
<	O
0	int
&&	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to connect hypervisor socket '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
hypcport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
hsck	int
<	O
0	int
)	O
{	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
hsck	int
=	O
-	O
1	int
;	O
}	O
else	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
=	O
0	int
;	O
if	O
(	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
<	O
0	int
)	O
rhosts	pointer
[	O
i	int
]	O
.	O
num_processes	int
=	O
get_number_of_cpus	function
(	O
)	O
;	O
}	O
r	int
=	O
remote_shell_init	function
(	O
p	pointer
.	O
rsh	pointer
,	O
p	pointer
.	O
rshargs	pointer
,	O
pexec_self	pointer
,	O
ctrlport	pointer
,	O
timeout	int
,	O
&	O
rhosts	pointer
[	O
i	int
]	O
,	O
&	O
rshells	pointer
[	O
i	int
]	O
,	O
prio	int
)	O
;	O
if	O
(	O
r	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to connect or initialize remote shell '%s' and/or pexec daemon '%s' to the host '%s' (reason code=%d).\n"	pointer
)	O
,	O
progbasename	pointer
,	O
p	pointer
.	O
rsh	pointer
,	O
pexec_self	pointer
,	O
rhosts	pointer
[	O
i	int
]	O
.	O
hostspec	pointer
,	O
r	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
pctrlport	pointer
!=	O
NULL	O
)	O
bind_variable_export	function
(	O
ctrlenv	pointer
,	O
pctrlport	pointer
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
listen	function
(	O
sock	int
,	O
256	int
)	O
;	O
p	pointer
.	O
log	pointer
=	O
&	O
log	pointer
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
ret	pointer
=	O
pexec_do_parallelized_execution	function
(	O
&	O
p	pointer
,	O
params	pointer
,	O
nparam	int
,	O
rshells	pointer
,	O
nrshell	int
,	O
sock	int
,	O
hsck	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
rs	pointer
=	O
rshells	pointer
;	O
i	int
<	O
nrshell	int
;	O
i	int
++	O
,	O
rs	pointer
++	O
)	O
{	O
if	O
(	O
rs	pointer
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
hprintf	function
(	O
rs	pointer
->	O
fhsend	int
,	O
"exit\n"	pointer
)	O
;	O
waitpid	function
(	O
rs	pointer
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
rshells	pointer
!=	O
NULL	O
)	O
free	function
(	O
rshells	pointer
)	O
;	O
if	O
(	O
log	pointer
.	O
fwlog	pointer
!=	O
NULL	O
&&	O
fileno	function
(	O
log	pointer
.	O
fwlog	pointer
)	O
!=	O
1	int
&&	O
fileno	function
(	O
log	pointer
.	O
fwlog	pointer
)	O
!=	O
2	int
)	O
fclose	function
(	O
log	pointer
.	O
fwlog	pointer
)	O
;	O
if	O
(	O
p	pointer
.	O
fwout	pointer
!=	O
NULL	O
&&	O
fileno	function
(	O
p	pointer
.	O
fwout	pointer
)	O
!=	O
1	int
&&	O
fileno	function
(	O
p	pointer
.	O
fwout	pointer
)	O
!=	O
2	int
)	O
fclose	function
(	O
p	pointer
.	O
fwout	pointer
)	O
;	O
if	O
(	O
p	pointer
.	O
fwerr	pointer
!=	O
NULL	O
&&	O
fileno	function
(	O
p	pointer
.	O
fwerr	pointer
)	O
!=	O
1	int
&&	O
fileno	function
(	O
p	pointer
.	O
fwerr	pointer
)	O
!=	O
2	int
)	O
fclose	function
(	O
p	pointer
.	O
fwerr	pointer
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
if	O
(	O
pctrlport	pointer
!=	O
NULL	O
&&	O
is_unix_socket_name	function
(	O
pctrlport	pointer
)	O
)	O
unlink	function
(	O
pctrlport	pointer
)	O
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
hprintf	function
(	O
hsck	int
,	O
"close\n"	pointer
)	O
;	O
fdwait	function
(	O
hsck	int
,	O
0	int
)	O
;	O
i	int
=	O
close	pointer
(	O
hsck	int
)	O
;	O
}	O
if	O
(	O
pnames	pointer
!=	O
NULL	O
)	O
free	function
(	O
pnames	pointer
)	O
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
free	function
(	O
list	pointer
)	O
;	O
if	O
(	O
params	pointer
!=	O
NULL	O
)	O
free	function
(	O
params	pointer
)	O
;	O
if	O
(	O
pctrlport	pointer
!=	O
NULL	O
)	O
free	function
(	O
pctrlport	pointer
)	O
;	O
free	function
(	O
p	pointer
.	O
rshcmd	pointer
)	O
;	O
free	function
(	O
p	pointer
.	O
rshargs	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nrhost	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
rhosts	pointer
[	O
i	int
]	O
.	O
hostspec	pointer
!=	O
NULL	O
)	O
free	function
(	O
rhosts	pointer
[	O
i	int
]	O
.	O
hostspec	pointer
)	O
;	O
}	O
free	function
(	O
rhosts	pointer
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
else	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_DAEMON	int
)	O
{	O
int	O
fhrecv	int
,	O
fhsend	int
;	O
int	O
num_processes	int
;	O
int	O
sock	int
,	O
hsck	int
;	O
char	O
*	O
pctrlport	pointer
;	O
num_processes	int
=	O
-	O
1	int
;	O
ctrlport	pointer
=	O
NULL	O
;	O
prio	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
zeroarg	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-n"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--number"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_AUTO	pointer
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_AUTO	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_MANAGED	pointer
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_MANAGED	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_NCPU	pointer
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
num_processes	int
)	O
<	O
1	int
||	O
num_processes	int
<=	O
0	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-y"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--bind"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlport	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-C"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--control"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
hypcport	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-z"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--nice"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
prio	int
)	O
<	O
1	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
prio	int
+=	O
128	int
;	O
}	O
else	O
{	O
fprint_err_invarg0	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
num_processes	int
==	O
PEXEC_MNP_AUTO	O
||	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
if	O
(	O
hypcport	pointer
==	O
NULL	O
)	O
hypcport	pointer
=	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	pointer
;	O
hsck	int
=	O
remote_control_port_connect	function
(	O
hypcport	pointer
)	O
;	O
if	O
(	O
hsck	int
<	O
0	int
&&	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to connect hypervisor socket '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
hypcport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
hsck	int
<	O
0	int
)	O
{	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
hsck	int
=	O
-	O
1	int
;	O
}	O
else	O
num_processes	int
=	O
0	int
;	O
}	O
else	O
hsck	int
=	O
-	O
1	int
;	O
if	O
(	O
num_processes	int
<	O
0	int
)	O
num_processes	int
=	O
get_number_of_cpus	function
(	O
)	O
;	O
if	O
(	O
ctrlport	pointer
!=	O
NULL	O
)	O
{	O
sock	int
=	O
remote_control_port_bind	function
(	O
ctrlport	pointer
,	O
&	O
pctrlport	pointer
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to create or bind control socket to %s.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
ctrlport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
sock	int
=	O
-	O
1	int
;	O
pctrlport	pointer
=	O
NULL	O
;	O
}	O
fhrecv	int
=	O
fileno	function
(	O
stdin	pointer
)	O
;	O
fhsend	int
=	O
fileno	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
pctrlport	pointer
!=	O
NULL	O
)	O
bind_variable_export	function
(	O
ctrlenv	pointer
,	O
pctrlport	pointer
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
listen	function
(	O
sock	int
,	O
256	int
)	O
;	O
if	O
(	O
prio	int
>	O
0	int
)	O
{	O
i	int
=	O
setpriority	function
(	O
PRIO_PROCESS	int
,	O
0	int
,	O
prio	int
-	O
128	int
)	O
;	O
}	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
pexec_daemon_main_loop	function
(	O
fhrecv	int
,	O
fhsend	int
,	O
num_processes	int
,	O
sock	int
,	O
hsck	int
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
sock	int
)	O
;	O
if	O
(	O
pctrlport	pointer
!=	O
NULL	O
&&	O
is_unix_socket_name	function
(	O
pctrlport	pointer
)	O
)	O
unlink	function
(	O
pctrlport	pointer
)	O
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
hprintf	function
(	O
hsck	int
,	O
"close\n"	pointer
)	O
;	O
fdwait	function
(	O
hsck	int
,	O
0	int
)	O
;	O
i	int
=	O
close	pointer
(	O
hsck	int
)	O
;	O
}	O
if	O
(	O
pctrlport	pointer
!=	O
NULL	O
)	O
free	function
(	O
pctrlport	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_REMOTECONTROL	int
)	O
{	O
char	O
*	O
ctrlport	pointer
;	O
int	O
sock	int
;	O
int	O
task	int
;	O
char	O
*	O
file	pointer
,	O
*	O
name	pointer
;	O
FILE	struct
*	O
fr	pointer
,	O
*	O
fw	pointer
;	O
int	O
azeroarg	int
;	O
ctrlport	pointer
=	O
NULL	O
;	O
task	int
=	O
PEXEC_REMOTE_STATUS	int
;	O
name	pointer
=	O
NULL	O
;	O
file	pointer
=	O
NULL	O
;	O
is_shell_commands	int
=	O
0	int
;	O
azeroarg	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
zeroarg	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-p"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--connect"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlport	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-t"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--status"	pointer
)	O
==	O
0	int
)	O
task	int
=	O
PEXEC_REMOTE_STATUS	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-l"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--lock"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--mutex-lock"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_LOCK	int
;	O
name	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-u"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--unlock"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--mutex-unlock"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_UNLOCK	int
;	O
name	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--mutex"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
name	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-d"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--dump"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_DUMP	int
;	O
file	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-s"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--save"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_SAVE	int
;	O
file	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-c"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--shell-command"	pointer
)	O
==	O
0	int
)	O
is_shell_commands	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-a"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--atomic"	pointer
)	O
==	O
0	int
)	O
task	int
=	O
PEXEC_REMOTE_ATOMIC	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--"	pointer
)	O
==	O
0	int
&&	O
task	int
==	O
PEXEC_REMOTE_ATOMIC	int
)	O
{	O
azeroarg	int
=	O
i	int
+	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
fprint_err_invarg0	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
task	int
==	O
PEXEC_REMOTE_ATOMIC	int
)	O
{	O
azeroarg	int
=	O
i	int
;	O
break	O
;	O
}	O
else	O
{	O
fprint_err_invarg0	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
ctrlport	pointer
==	O
NULL	O
||	O
strcmp	function
(	O
ctrlport	pointer
,	O
PEXEC_ISTR_AUTO	pointer
)	O
==	O
0	int
)	O
ctrlport	pointer
=	O
getenv	function
(	O
ctrlenv	pointer
)	O
;	O
if	O
(	O
ctrlport	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: connection port has not been defined or set in the environment.\n"	pointer
)	O
,	O
progbasename	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
sock	int
=	O
remote_control_port_connect	function
(	O
ctrlport	pointer
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to connect to '%s'.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
ctrlport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
switch	O
(	O
task	int
)	O
{	O
case	O
PEXEC_REMOTE_STATUS	int
:	O
ret	pointer
=	O
remote_status	function
(	O
sock	int
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
PEXEC_REMOTE_LOCK	int
:	O
ret	pointer
=	O
remote_lock	function
(	O
sock	int
,	O
NULL	O
,	O
name	pointer
)	O
;	O
break	O
;	O
case	O
PEXEC_REMOTE_UNLOCK	int
:	O
ret	pointer
=	O
remote_unlock	function
(	O
sock	int
,	O
NULL	O
,	O
name	pointer
)	O
;	O
break	O
;	O
case	O
PEXEC_REMOTE_DUMP	int
:	O
if	O
(	O
file	pointer
!=	O
NULL	O
&&	O
(	O
fr	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"rb"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
name	pointer
!=	O
NULL	O
)	O
{	O
ret	pointer
=	O
remote_copy	function
(	O
sock	int
,	O
name	pointer
,	O
fr	pointer
,	O
stdout	pointer
)	O
;	O
fclose	function
(	O
fr	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: invalid or unspecified input file (%s).\n"	pointer
)	O
,	O
progbasename	pointer
,	O
(	O
file	pointer
==	O
NULL	O
?	O
"-"	pointer
:	O
file	pointer
)	O
)	O
;	O
ret	pointer
=	O
1	int
;	O
}	O
break	O
;	O
case	O
PEXEC_REMOTE_SAVE	int
:	O
if	O
(	O
file	pointer
!=	O
NULL	O
&&	O
(	O
fw	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"wb"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
name	pointer
!=	O
NULL	O
)	O
{	O
ret	pointer
=	O
remote_copy	function
(	O
sock	int
,	O
name	pointer
,	O
stdin	pointer
,	O
fw	pointer
)	O
;	O
fclose	function
(	O
fw	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: invalid or unspecified output file (%s).\n"	pointer
)	O
,	O
progbasename	pointer
,	O
(	O
file	pointer
==	O
NULL	O
?	O
"-"	pointer
:	O
file	pointer
)	O
)	O
;	O
ret	pointer
=	O
1	int
;	O
}	O
break	O
;	O
case	O
PEXEC_REMOTE_ATOMIC	int
:	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
remote_lock	function
(	O
sock	int
,	O
NULL	O
,	O
name	pointer
)	O
;	O
if	O
(	O
azeroarg	int
<	O
argc	int
)	O
ret	pointer
=	O
remote_atomic_execute	function
(	O
is_shell_commands	int
,	O
p	pointer
.	O
shell	pointer
,	O
argc	int
-	O
azeroarg	int
,	O
argv	pointer
+	O
azeroarg	int
,	O
sock	int
)	O
;	O
else	O
ret	pointer
=	O
0	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
remote_unlock	function
(	O
sock	int
,	O
NULL	O
,	O
name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
remote_disconnect	function
(	O
sock	int
)	O
;	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
ret	pointer
)	O
;	O
}	O
else	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_HYPERVISOR	int
)	O
{	O
int	O
startstop	int
;	O
int	O
num_processes	int
,	O
use_load	int
,	O
use_fifo	int
;	O
int	O
sock	int
;	O
hypcport	pointer
=	O
NULL	O
;	O
startstop	int
=	O
-	O
1	int
;	O
num_processes	int
=	O
-	O
1	int
;	O
use_load	int
=	O
-	O
1	int
;	O
use_fifo	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
zeroarg	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-n"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--number"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_AUTO	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
PEXEC_ISTR_NCPU	pointer
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
num_processes	int
)	O
<	O
1	int
||	O
num_processes	int
<=	O
0	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-l"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--load"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--use-load"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"0"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"1m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"1min"	pointer
)	O
==	O
0	int
)	O
use_load	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"1"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"5m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"5min"	pointer
)	O
==	O
0	int
)	O
use_load	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"2"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"15m"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"15min"	pointer
)	O
==	O
0	int
)	O
use_load	int
=	O
2	int
;	O
else	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-C"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--control"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
hypcport	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-L"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--log"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
logfile	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-V"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--verbose"	pointer
)	O
==	O
0	int
)	O
log	pointer
.	O
loglevel	int
++	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-W"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--log-level"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
&	O
log	pointer
.	O
loglevel	int
)	O
<	O
1	int
||	O
log	pointer
.	O
loglevel	int
<	O
0	int
)	O
{	O
fprint_err_invarg1	function
(	O
argv	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-f"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--fifo"	pointer
)	O
==	O
0	int
)	O
use_fifo	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-s"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--lifo"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--stack"	pointer
)	O
==	O
0	int
)	O
use_fifo	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"start"	pointer
)	O
==	O
0	int
)	O
startstop	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"stop"	pointer
)	O
==	O
0	int
)	O
startstop	int
=	O
1	int
;	O
else	O
{	O
fprint_err_invarg0	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
num_processes	int
<=	O
0	int
)	O
num_processes	int
=	O
get_number_of_cpus	function
(	O
)	O
;	O
if	O
(	O
hypcport	pointer
==	O
NULL	O
)	O
hypcport	pointer
=	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	pointer
;	O
if	O
(	O
startstop	int
>	O
0	int
)	O
{	O
sock	int
=	O
remote_control_port_connect	function
(	O
hypcport	pointer
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to connect to hypervisor control socket '%s' in order to stop the service.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
hypcport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
pexec_hypervisor_stop	function
(	O
sock	int
)	O
;	O
close	pointer
(	O
sock	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
sock	int
=	O
remote_control_port_bind	function
(	O
hypcport	pointer
,	O
NULL	O
,	O
0	int
,	O
1	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: unable to create or bind control socket to %s.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
hypcport	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
startstop	int
<	O
0	int
)	O
)	O
background	function
(	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
listen	function
(	O
sock	int
,	O
256	int
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
pexec_hypervisor_main_loop	function
(	O
sock	int
,	O
num_processes	int
,	O
use_load	int
,	O
use_fifo	int
)	O
;	O
if	O
(	O
is_unix_socket_name	function
(	O
hypcport	pointer
)	O
)	O
unlink	function
(	O
hypcport	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: internal: invalid mode code %d.\n"	pointer
)	O
,	O
progbasename	pointer
,	O
mode	int
)	O
;	O
return	O
(	O
2	int
)	O
;	O
}	O
}	O
