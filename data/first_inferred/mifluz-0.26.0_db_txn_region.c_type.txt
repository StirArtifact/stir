static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: txn_region.c,v 1.3 2000/06/28 16:47:03 loic Exp $"	pointer
;	O
static	O
int	O
__txn_init	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_TXNMGR	struct
*	O
)	O
)	O
;	O
static	O
int	O
__txn_set_tx_max	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__txn_set_tx_recover	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
int	O
(	O
*	O
)	O
(	O
DB_ENV	struct
*	O
,	O
DBT	struct
*	O
,	O
DB_LSN	struct
*	O
,	O
db_recops	enum
,	O
void	O
*	O
)	O
)	O
)	O
;	O
static	O
int	O
__txn_set_tx_timestamp	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
time_t	long
*	O
)	O
)	O
;	O
void	O
CDB___txn_dbenv_create	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
dbenv	pointer
->	O
tx_max	int
=	O
DEF_MAX_TXNS	int
;	O
dbenv	pointer
->	O
set_tx_max	pointer
=	O
__txn_set_tx_max	function
;	O
dbenv	pointer
->	O
set_tx_recover	pointer
=	O
__txn_set_tx_recover	function
;	O
dbenv	pointer
->	O
set_tx_timestamp	pointer
=	O
__txn_set_tx_timestamp	function
;	O
}	O
static	O
int	O
__txn_set_tx_max	function
(	O
dbenv	pointer
,	O
tx_max	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
tx_max	int
;	O
{	O
ENV_ILLEGAL_AFTER_OPEN	O
(	O
dbenv	pointer
,	O
"set_tx_max"	pointer
)	O
;	O
dbenv	pointer
->	O
tx_max	int
=	O
tx_max	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__txn_set_tx_recover	function
(	O
dbenv	pointer
,	O
tx_recover	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
int	O
(	O
*	O
tx_recover	pointer
)	O
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DBT	struct
*	O
,	O
DB_LSN	struct
*	O
,	O
db_recops	enum
,	O
void	O
*	O
)	O
)	O
;	O
{	O
dbenv	pointer
->	O
tx_recover	pointer
=	O
tx_recover	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__txn_set_tx_timestamp	function
(	O
dbenv	pointer
,	O
timestamp	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
time_t	long
*	O
timestamp	int
;	O
{	O
ENV_ILLEGAL_AFTER_OPEN	O
(	O
dbenv	pointer
,	O
"set_tx_timestamp"	pointer
)	O
;	O
dbenv	pointer
->	O
tx_timestamp	long
=	O
*	O
timestamp	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___txn_open	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_TXNMGR	struct
*	O
tmgrp	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
DB_TXNMGR	struct
)	O
,	O
&	O
tmgrp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
TAILQ_INIT	O
(	O
&	O
tmgrp	pointer
->	O
txn_chain	struct
)	O
;	O
tmgrp	pointer
->	O
dbenv	pointer
=	O
dbenv	pointer
;	O
tmgrp	pointer
->	O
recover	pointer
=	O
dbenv	pointer
->	O
tx_recover	pointer
==	O
NULL	O
?	O
CDB___db_dispatch	function
:	O
dbenv	pointer
->	O
tx_recover	pointer
;	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
id	int
=	O
REG_ID_TXN	int
;	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
mode	enum
=	O
dbenv	pointer
->	O
db_mode	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_CREATE	int
)	O
)	O
F_SET	O
(	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE_OK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_r_attach	function
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
TXN_REGION_SIZE	O
(	O
dbenv	pointer
->	O
tx_max	int
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
__txn_init	function
(	O
dbenv	pointer
,	O
tmgrp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
primary	int
=	O
R_ADDR	O
(	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_mutex_alloc	function
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
&	O
tmgrp	pointer
->	O
mutexp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
detach	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
tmgrp	pointer
->	O
mutexp	pointer
,	O
0	int
,	O
MUTEX_THREAD	int
)	O
)	O
!=	O
0	int
)	O
goto	O
detach	O
;	O
}	O
dbenv	pointer
->	O
tx_handle	pointer
=	O
tmgrp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
F_SET	O
(	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
,	O
REG_DEAD	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
)	O
;	O
detach	O
:	O
(	O
void	O
)	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
0	int
)	O
;	O
}	O
CDB___os_free	function
(	O
tmgrp	pointer
,	O
sizeof	O
(	O
*	O
tmgrp	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__txn_init	function
(	O
dbenv	pointer
,	O
tmgrp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_TXNMGR	struct
*	O
tmgrp	pointer
;	O
{	O
DB_TXNREGION	struct
*	O
region	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
DB_TXNREGION	struct
)	O
,	O
0	int
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory for the transaction region"	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
=	O
R_OFFSET	O
(	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
;	O
region	pointer
=	O
tmgrp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
memset	function
(	O
region	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
region	pointer
)	O
)	O
;	O
region	pointer
->	O
maxtxns	int
=	O
dbenv	pointer
->	O
tx_max	int
;	O
region	pointer
->	O
last_txnid	int
=	O
TXN_MINIMUM	int
;	O
ZERO_LSN	O
(	O
region	pointer
->	O
pending_ckp	struct
)	O
;	O
ZERO_LSN	O
(	O
region	pointer
->	O
last_ckp	struct
)	O
;	O
region	pointer
->	O
time_ckp	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
region	pointer
->	O
logtype	int
=	O
0	int
;	O
region	pointer
->	O
locktype	int
=	O
0	int
;	O
region	pointer
->	O
naborts	int
=	O
0	int
;	O
region	pointer
->	O
ncommits	int
=	O
0	int
;	O
region	pointer
->	O
nbegins	int
=	O
0	int
;	O
region	pointer
->	O
nactive	int
=	O
0	int
;	O
region	pointer
->	O
maxnactive	int
=	O
0	int
;	O
SH_TAILQ_INIT	O
(	O
&	O
region	pointer
->	O
active_txn	struct
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___txn_close	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_TXN	struct
*	O
txnp	pointer
;	O
DB_TXNMGR	struct
*	O
tmgrp	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
ret	int
=	O
0	int
;	O
tmgrp	pointer
=	O
dbenv	pointer
->	O
tx_handle	pointer
;	O
while	O
(	O
(	O
txnp	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
tmgrp	pointer
->	O
txn_chain	struct
)	O
)	O
!=	O
TAILQ_END	O
(	O
&	O
tmgrp	pointer
->	O
txn_chain	struct
)	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_txn_abort	function
(	O
txnp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to abort transaction 0x%x: %s\n"	pointer
,	O
txnp	pointer
->	O
txnid	int
,	O
CDB_db_strerror	function
(	O
t_ret	int
)	O
)	O
;	O
CDB___txn_end	function
(	O
txnp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
==	O
0	int
?	O
0	int
:	O
DB_RUNRECOVERY	O
;	O
}	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
t_ret	int
=	O
CDB_log_flush	function
(	O
dbenv	pointer
,	O
NULL	O
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
tmgrp	pointer
->	O
mutexp	pointer
!=	O
NULL	O
)	O
CDB___db_mutex_free	function
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
tmgrp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
tmgrp	pointer
->	O
reginfo	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
CDB___os_free	function
(	O
tmgrp	pointer
,	O
sizeof	O
(	O
*	O
tmgrp	pointer
)	O
)	O
;	O
dbenv	pointer
->	O
tx_handle	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_txn_stat	function
(	O
dbenv	pointer
,	O
statp	pointer
,	O
db_malloc	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_TXN_STAT	struct
*	O
*	O
statp	pointer
;	O
void	O
*	O
(	O
*	O
db_malloc	pointer
)	O
__P	O
(	O
(	O
size_t	long
)	O
)	O
;	O
{	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
DB_TXNREGION	struct
*	O
region	pointer
;	O
DB_TXN_STAT	struct
*	O
stats	pointer
;	O
TXN_DETAIL	struct
*	O
txnp	pointer
;	O
size_t	long
nbytes	long
;	O
u_int32_t	int
nactive	int
,	O
ndx	int
;	O
int	O
ret	int
,	O
slop	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
tx_handle	pointer
,	O
DB_INIT_TXN	int
)	O
;	O
*	O
statp	pointer
=	O
NULL	O
;	O
slop	int
=	O
200	int
;	O
mgr	pointer
=	O
dbenv	pointer
->	O
tx_handle	pointer
;	O
region	pointer
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
retry	O
:	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
nactive	int
=	O
region	pointer
->	O
nactive	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
nbytes	long
=	O
sizeof	O
(	O
DB_TXN_STAT	struct
)	O
+	O
sizeof	O
(	O
DB_TXN_ACTIVE	struct
)	O
*	O
(	O
nactive	int
+	O
slop	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
nbytes	long
,	O
db_malloc	pointer
,	O
&	O
stats	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
stats	pointer
->	O
st_last_txnid	int
=	O
region	pointer
->	O
last_txnid	int
;	O
stats	pointer
->	O
st_last_ckp	struct
=	O
region	pointer
->	O
last_ckp	struct
;	O
stats	pointer
->	O
st_maxtxns	int
=	O
region	pointer
->	O
maxtxns	int
;	O
stats	pointer
->	O
st_naborts	int
=	O
region	pointer
->	O
naborts	int
;	O
stats	pointer
->	O
st_nbegins	int
=	O
region	pointer
->	O
nbegins	int
;	O
stats	pointer
->	O
st_ncommits	int
=	O
region	pointer
->	O
ncommits	int
;	O
stats	pointer
->	O
st_pending_ckp	struct
=	O
region	pointer
->	O
pending_ckp	struct
;	O
stats	pointer
->	O
st_time_ckp	long
=	O
region	pointer
->	O
time_ckp	long
;	O
stats	pointer
->	O
st_nactive	int
=	O
region	pointer
->	O
nactive	int
;	O
if	O
(	O
stats	pointer
->	O
st_nactive	int
>	O
nactive	int
+	O
200	int
)	O
{	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
slop	int
*=	O
2	int
;	O
goto	O
retry	O
;	O
}	O
stats	pointer
->	O
st_maxnactive	int
=	O
region	pointer
->	O
maxnactive	int
;	O
stats	pointer
->	O
st_txnarray	pointer
=	O
(	O
DB_TXN_ACTIVE	struct
*	O
)	O
&	O
stats	pointer
[	O
1	int
]	O
;	O
ndx	int
=	O
0	int
;	O
for	O
(	O
txnp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
region	pointer
->	O
active_txn	struct
,	O
__txn_detail	struct
)	O
;	O
txnp	pointer
!=	O
NULL	O
;	O
txnp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
txnp	pointer
,	O
links	struct
,	O
__txn_detail	struct
)	O
)	O
{	O
stats	pointer
->	O
st_txnarray	pointer
[	O
ndx	int
]	O
.	O
txnid	int
=	O
txnp	pointer
->	O
txnid	int
;	O
if	O
(	O
txnp	pointer
->	O
parent	pointer
==	O
INVALID_ROFF	int
)	O
stats	pointer
->	O
st_txnarray	pointer
[	O
ndx	int
]	O
.	O
parentid	int
=	O
TXN_INVALID_ID	int
;	O
else	O
stats	pointer
->	O
st_txnarray	pointer
[	O
ndx	int
]	O
.	O
parentid	int
=	O
(	O
(	O
TXN_DETAIL	struct
*	O
)	O
R_ADDR	O
(	O
&	O
mgr	pointer
->	O
reginfo	pointer
,	O
txnp	pointer
->	O
parent	pointer
)	O
)	O
->	O
txnid	int
;	O
stats	pointer
->	O
st_txnarray	pointer
[	O
ndx	int
]	O
.	O
lsn	struct
=	O
txnp	pointer
->	O
begin_lsn	struct
;	O
ndx	int
++	O
;	O
if	O
(	O
ndx	int
>=	O
stats	pointer
->	O
st_nactive	int
)	O
break	O
;	O
}	O
stats	pointer
->	O
st_region_wait	int
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
mutex	union
.	O
mutex_set_wait	int
;	O
stats	pointer
->	O
st_region_nowait	int
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
mutex	union
.	O
mutex_set_nowait	int
;	O
stats	pointer
->	O
st_regsize	int
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
size	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
*	O
statp	pointer
=	O
stats	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
