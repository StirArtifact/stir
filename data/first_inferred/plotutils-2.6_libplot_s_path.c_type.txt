static	O
const	O
char	O
*	O
const	O
svg_join_style	array
[	O
PL_NUM_JOIN_TYPES	int
]	O
=	O
{	O
"miter"	pointer
,	O
"round"	pointer
,	O
"bevel"	pointer
,	O
"round"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
svg_cap_style	array
[	O
PL_NUM_CAP_TYPES	int
]	O
=	O
{	O
"butt"	pointer
,	O
"round"	pointer
,	O
"square"	pointer
,	O
"round"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
svg_fill_style	array
[	O
PL_NUM_FILL_RULES	int
]	O
=	O
{	O
"evenodd"	pointer
,	O
"nonzero"	pointer
}	O
;	O
static	O
const	O
double	O
identity_matrix	array
[	O
6	int
]	O
=	O
{	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
}	O
;	O
static	O
void	O
write_svg_path_data	function
(	O
plOutbuf	struct
*	O
page	pointer
,	O
const	O
plPath	struct
*	O
path	pointer
)	O
;	O
static	O
void	O
write_svg_path_style	function
(	O
plOutbuf	struct
*	O
page	pointer
,	O
const	O
plDrawState	struct
*	O
drawstate	pointer
,	O
bool	enum
need_cap	enum
,	O
bool	enum
need_join	enum
)	O
;	O
void	O
_pl_s_paint_path	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
PATH_SEGMENT_LIST	int
:	O
{	O
bool	enum
closed	enum
,	O
lines_only	enum
;	O
int	O
i	int
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
>=	O
3	int
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
closed	enum
=	O
true	int
;	O
else	O
closed	enum
=	O
false	int
;	O
lines_only	enum
=	O
true	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPathSegmentType	enum
element_type	enum
;	O
element_type	enum
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
;	O
if	O
(	O
element_type	enum
!=	O
S_LINE	int
)	O
{	O
lines_only	enum
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
lines_only	enum
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
2	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<line "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"x1=\"%.5g\" y1=\"%.5g\" x2=\"%.5g\" y2=\"%.5g\" "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
p	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
true	int
,	O
false	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
else	O
if	O
(	O
lines_only	enum
&&	O
!	O
closed	enum
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<polyline "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"points=\""	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPoint	struct
p	struct
;	O
p	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.5g,%.5g "	pointer
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\" "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
true	int
,	O
true	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
else	O
if	O
(	O
lines_only	enum
&&	O
closed	enum
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<polygon "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"points=\""	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
plPoint	struct
p	struct
;	O
p	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.5g,%.5g "	pointer
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\" "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
false	int
,	O
true	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<path "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"d=\""	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_data	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\" "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
true	int
,	O
true	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_BOX	int
:	O
{	O
plPoint	struct
p0	struct
,	O
p1	struct
;	O
double	O
xmin	double
,	O
ymin	double
,	O
xmax	double
,	O
ymax	double
;	O
p0	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
;	O
p1	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
;	O
xmin	double
=	O
DMIN	O
(	O
p0	struct
.	O
x	double
,	O
p1	struct
.	O
x	double
)	O
;	O
ymin	double
=	O
DMIN	O
(	O
p0	struct
.	O
y	double
,	O
p1	struct
.	O
y	double
)	O
;	O
xmax	double
=	O
DMAX	O
(	O
p0	struct
.	O
x	double
,	O
p1	struct
.	O
x	double
)	O
;	O
ymax	double
=	O
DMAX	O
(	O
p0	struct
.	O
y	double
,	O
p1	struct
.	O
y	double
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<rect "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"x=\"%.5g\" y=\"%.5g\" width=\"%.5g\" height=\"%.5g\" "	pointer
,	O
xmin	double
,	O
ymin	double
,	O
xmax	double
-	O
xmin	double
,	O
ymax	double
-	O
ymin	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
false	int
,	O
true	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_CIRCLE	int
:	O
{	O
plPoint	struct
pc	struct
;	O
double	O
radius	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
radius	double
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<circle "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"cx=\"%.5g\" cy=\"%.5g\" r=\"%.5g\" "	pointer
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
,	O
radius	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
false	int
,	O
false	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_ELLIPSE	int
:	O
{	O
plPoint	struct
pc	struct
;	O
double	O
rx	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
rx	double
;	O
double	O
ry	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
ry	double
;	O
double	O
angle	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
angle	double
;	O
double	O
local_matrix	array
[	O
6	int
]	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<ellipse "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
;	O
local_matrix	array
[	O
0	int
]	O
=	O
cos	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
local_matrix	array
[	O
1	int
]	O
=	O
sin	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
local_matrix	array
[	O
2	int
]	O
=	O
-	O
sin	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
local_matrix	array
[	O
3	int
]	O
=	O
cos	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
local_matrix	array
[	O
4	int
]	O
=	O
pc	struct
.	O
x	double
;	O
local_matrix	array
[	O
5	int
]	O
=	O
pc	struct
.	O
y	double
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
local_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"rx=\"%.5g\" ry=\"%.5g\" "	pointer
,	O
rx	double
,	O
ry	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
false	int
,	O
false	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
bool	enum
_pl_s_paint_paths	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
int	O
i	int
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<path "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"d=\""	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
plPath	struct
*	O
path	pointer
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
paths	pointer
[	O
i	int
]	O
;	O
switch	O
(	O
(	O
int	O
)	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
PATH_SEGMENT_LIST	int
:	O
write_svg_path_data	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
path	pointer
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_CIRCLE	int
:	O
{	O
plPoint	struct
pc	struct
;	O
double	O
radius	double
;	O
pc	struct
=	O
path	pointer
->	O
pc	struct
;	O
radius	double
=	O
path	pointer
->	O
radius	double
;	O
if	O
(	O
path	pointer
->	O
clockwise	enum
==	O
false	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z "	pointer
,	O
pc	struct
.	O
x	double
+	O
radius	double
,	O
pc	struct
.	O
y	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
radius	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
-	O
radius	double
,	O
pc	struct
.	O
y	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
-	O
radius	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
+	O
radius	double
,	O
pc	struct
.	O
y	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z "	pointer
,	O
pc	struct
.	O
x	double
+	O
radius	double
,	O
pc	struct
.	O
y	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
-	O
radius	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
-	O
radius	double
,	O
pc	struct
.	O
y	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
radius	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
+	O
radius	double
,	O
pc	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_ELLIPSE	int
:	O
{	O
plPoint	struct
pc	struct
;	O
double	O
rx	double
,	O
ry	double
,	O
angle	double
;	O
plVector	struct
v1	struct
,	O
v2	struct
;	O
pc	struct
=	O
path	pointer
->	O
pc	struct
;	O
rx	double
=	O
path	pointer
->	O
rx	double
;	O
ry	double
=	O
path	pointer
->	O
ry	double
;	O
angle	double
=	O
path	pointer
->	O
angle	double
;	O
v1	struct
.	O
x	double
=	O
rx	double
*	O
cos	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
v1	struct
.	O
y	double
=	O
rx	double
*	O
sin	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
v2	struct
.	O
x	double
=	O
-	O
ry	double
*	O
sin	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
v2	struct
.	O
y	double
=	O
ry	double
*	O
cos	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
if	O
(	O
path	pointer
->	O
clockwise	enum
==	O
false	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z "	pointer
,	O
pc	struct
.	O
x	double
+	O
v1	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
v1	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
+	O
v2	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
v2	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
-	O
v1	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
-	O
v1	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
-	O
v2	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
-	O
v2	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
1	int
,	O
pc	struct
.	O
x	double
+	O
v1	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
v1	struct
.	O
y	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g Z "	pointer
,	O
pc	struct
.	O
x	double
+	O
v1	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
v1	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
-	O
v2	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
-	O
v2	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
-	O
v1	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
-	O
v1	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
+	O
v2	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
v2	struct
.	O
y	double
,	O
rx	double
,	O
ry	double
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
pc	struct
.	O
x	double
+	O
v1	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
+	O
v1	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_BOX	int
:	O
{	O
plPoint	struct
p0	struct
,	O
p1	struct
;	O
bool	enum
x_move_is_first	enum
;	O
p0	struct
=	O
path	pointer
->	O
p0	struct
;	O
p1	struct
=	O
path	pointer
->	O
p1	struct
;	O
x_move_is_first	enum
=	O
(	O
(	O
p1	struct
.	O
x	double
>=	O
p0	struct
.	O
x	double
&&	O
p1	struct
.	O
y	double
>=	O
p0	struct
.	O
y	double
)	O
||	O
(	O
p1	struct
.	O
x	double
<	O
p0	struct
.	O
x	double
&&	O
p1	struct
.	O
y	double
<	O
p0	struct
.	O
y	double
)	O
?	O
true	int
:	O
false	int
)	O
;	O
if	O
(	O
path	pointer
->	O
clockwise	enum
)	O
x_move_is_first	enum
=	O
(	O
x_move_is_first	enum
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
if	O
(	O
x_move_is_first	enum
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g H%.5g V%.5g H%.5g Z "	pointer
,	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
,	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
,	O
p0	struct
.	O
x	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g V%.5g H%.5g V%.5g Z "	pointer
,	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
,	O
p1	struct
.	O
y	double
,	O
p1	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\" "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_path_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
,	O
true	int
,	O
true	int
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
return	O
true	int
;	O
}	O
static	O
void	O
write_svg_path_data	function
(	O
plOutbuf	struct
*	O
page	pointer
,	O
const	O
plPath	struct
*	O
path	pointer
)	O
{	O
bool	enum
closed	enum
;	O
plPoint	struct
p	struct
,	O
oldpoint	struct
;	O
int	O
i	int
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
)	O
return	O
;	O
if	O
(	O
(	O
path	pointer
->	O
num_segments	int
>=	O
3	int
)	O
&&	O
(	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
)	O
&&	O
(	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
closed	enum
=	O
true	int
;	O
else	O
closed	enum
=	O
false	int
;	O
p	struct
=	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
;	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"M%.5g,%.5g "	pointer
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
oldpoint	struct
=	O
p	struct
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPathSegmentType	enum
type	enum
;	O
plPoint	struct
pc	struct
,	O
pd	struct
;	O
type	enum
=	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
;	O
p	struct
=	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
;	O
pc	struct
=	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pc	struct
;	O
pd	struct
=	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pd	struct
;	O
if	O
(	O
closed	enum
&&	O
i	int
==	O
path	pointer
->	O
num_segments	int
-	O
1	int
&&	O
type	enum
==	O
S_LINE	int
)	O
continue	O
;	O
switch	O
(	O
(	O
int	O
)	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
S_LINE	int
:	O
if	O
(	O
p	struct
.	O
y	double
==	O
oldpoint	struct
.	O
y	double
)	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"H%.5g "	pointer
,	O
p	struct
.	O
x	double
)	O
;	O
else	O
if	O
(	O
p	struct
.	O
x	double
==	O
oldpoint	struct
.	O
x	double
)	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"V%.5g "	pointer
,	O
p	struct
.	O
y	double
)	O
;	O
else	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"L%.5g,%.5g "	pointer
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ARC	int
:	O
{	O
double	O
radius	double
;	O
double	O
angle	double
;	O
angle	double
=	O
_angle_of_arc	function
(	O
oldpoint	struct
,	O
p	struct
,	O
pc	struct
)	O
;	O
radius	double
=	O
sqrt	function
(	O
(	O
p	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
)	O
*	O
(	O
p	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
)	O
+	O
(	O
p	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
)	O
*	O
(	O
p	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
)	O
)	O
;	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g "	pointer
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
0	int
,	O
angle	double
>=	O
0.0	int
?	O
1	int
:	O
0	int
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ELLARC	int
:	O
{	O
double	O
cross	double
,	O
mixing_angle	double
,	O
rx	double
,	O
ry	double
,	O
theta	double
;	O
plVector	struct
u	struct
,	O
v	pointer
,	O
semi_axis_1	struct
,	O
semi_axis_2	struct
;	O
bool	enum
clockwise	enum
;	O
u	struct
.	O
x	double
=	O
oldpoint	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
u	struct
.	O
y	double
=	O
oldpoint	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
v	pointer
.	O
x	double
=	O
p	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v	pointer
.	O
y	double
=	O
p	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
cross	double
=	O
u	struct
.	O
x	double
*	O
v	pointer
.	O
y	double
-	O
v	pointer
.	O
x	double
*	O
u	struct
.	O
y	double
;	O
clockwise	enum
=	O
cross	double
<	O
0.0	int
?	O
true	int
:	O
false	int
;	O
mixing_angle	double
=	O
0.5	int
*	O
_xatan2	function
(	O
2.0	int
*	O
(	O
u	struct
.	O
x	double
*	O
v	pointer
.	O
x	double
+	O
u	struct
.	O
y	double
*	O
v	pointer
.	O
y	double
)	O
,	O
u	struct
.	O
x	double
*	O
u	struct
.	O
x	double
+	O
u	struct
.	O
y	double
*	O
u	struct
.	O
y	double
-	O
v	pointer
.	O
x	double
*	O
v	pointer
.	O
x	double
+	O
v	pointer
.	O
y	double
*	O
v	pointer
.	O
y	double
)	O
;	O
semi_axis_1	struct
.	O
x	double
=	O
u	struct
.	O
x	double
*	O
cos	function
(	O
mixing_angle	double
)	O
+	O
v	pointer
.	O
x	double
*	O
sin	function
(	O
mixing_angle	double
)	O
;	O
semi_axis_1	struct
.	O
y	double
=	O
u	struct
.	O
y	double
*	O
cos	function
(	O
mixing_angle	double
)	O
+	O
v	pointer
.	O
y	double
*	O
sin	function
(	O
mixing_angle	double
)	O
;	O
semi_axis_2	struct
.	O
x	double
=	O
(	O
u	struct
.	O
x	double
*	O
cos	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
+	O
v	pointer
.	O
x	double
*	O
sin	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
)	O
;	O
semi_axis_2	struct
.	O
y	double
=	O
(	O
u	struct
.	O
y	double
*	O
cos	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
+	O
v	pointer
.	O
y	double
*	O
sin	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
)	O
;	O
rx	double
=	O
sqrt	function
(	O
semi_axis_1	struct
.	O
x	double
*	O
semi_axis_1	struct
.	O
x	double
+	O
semi_axis_1	struct
.	O
y	double
*	O
semi_axis_1	struct
.	O
y	double
)	O
;	O
ry	double
=	O
sqrt	function
(	O
semi_axis_2	struct
.	O
x	double
*	O
semi_axis_2	struct
.	O
x	double
+	O
semi_axis_2	struct
.	O
y	double
*	O
semi_axis_2	struct
.	O
y	double
)	O
;	O
theta	double
=	O
_xatan2	function
(	O
semi_axis_1	struct
.	O
y	double
,	O
semi_axis_1	struct
.	O
x	double
)	O
;	O
if	O
(	O
theta	double
<	O
VERY_SMALL_ANGLE	int
&&	O
theta	double
>	O
-	O
(	O
VERY_SMALL_ANGLE	int
)	O
)	O
theta	double
=	O
0.0	int
;	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"A%.5g,%.5g,%.5g,%d,%d,%.5g,%.5g "	pointer
,	O
rx	double
,	O
ry	double
,	O
theta	double
*	O
180.0	int
/	O
M_PI	int
,	O
0	int
,	O
clockwise	enum
?	O
0	int
:	O
1	int
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
S_QUAD	int
:	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"Q%.5g,%.5g,%.5g,%.5g "	pointer
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_CUBIC	int
:	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"C%.5g,%.5g,%.5g,%.5g,%.5g,%.5g "	pointer
,	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
,	O
pd	struct
.	O
x	double
,	O
pd	struct
.	O
y	double
,	O
p	struct
.	O
x	double
,	O
p	struct
.	O
y	double
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
oldpoint	struct
=	O
p	struct
;	O
}	O
if	O
(	O
closed	enum
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"Z "	pointer
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_svg_path_style	function
(	O
plOutbuf	struct
*	O
page	pointer
,	O
const	O
plDrawState	struct
*	O
drawstate	pointer
,	O
bool	enum
need_cap	enum
,	O
bool	enum
need_join	enum
)	O
{	O
char	O
color_buf	array
[	O
8	int
]	O
;	O
if	O
(	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
if	O
(	O
drawstate	pointer
->	O
fgcolor	struct
.	O
red	int
!=	O
0	int
||	O
drawstate	pointer
->	O
fgcolor	struct
.	O
green	int
!=	O
0	int
||	O
drawstate	pointer
->	O
fgcolor	struct
.	O
blue	int
!=	O
0	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke=\"%s\" "	pointer
,	O
_libplot_color_to_svg_color	function
(	O
drawstate	pointer
->	O
fgcolor	struct
,	O
color_buf	array
)	O
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke-width=\"%.5g\" "	pointer
,	O
drawstate	pointer
->	O
line_width	double
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
if	O
(	O
need_cap	enum
)	O
{	O
if	O
(	O
drawstate	pointer
->	O
cap_type	int
!=	O
PL_CAP_BUTT	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke-linecap=\"%s\" "	pointer
,	O
svg_cap_style	array
[	O
drawstate	pointer
->	O
cap_type	int
]	O
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
}	O
if	O
(	O
need_join	enum
)	O
{	O
if	O
(	O
drawstate	pointer
->	O
join_type	int
!=	O
PL_JOIN_MITER	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke-linejoin=\"%s\" "	pointer
,	O
svg_join_style	array
[	O
drawstate	pointer
->	O
join_type	int
]	O
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
if	O
(	O
drawstate	pointer
->	O
join_type	int
==	O
PL_JOIN_MITER	int
&&	O
drawstate	pointer
->	O
miter_limit	double
!=	O
PL_DEFAULT_MITER_LIMIT	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke-miterlimit=\"%.5g\" "	pointer
,	O
drawstate	pointer
->	O
miter_limit	double
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
drawstate	pointer
->	O
dash_array_in_effect	enum
&&	O
drawstate	pointer
->	O
dash_array_len	int
>	O
0	int
)	O
||	O
(	O
drawstate	pointer
->	O
dash_array_in_effect	enum
==	O
false	int
&&	O
drawstate	pointer
->	O
line_type	int
!=	O
PL_L_SOLID	int
)	O
)	O
{	O
int	O
i	int
;	O
double	O
*	O
dashbuf	pointer
,	O
offset	array
;	O
int	O
num_dashes	int
;	O
if	O
(	O
drawstate	pointer
->	O
dash_array_in_effect	enum
)	O
{	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
(	O
drawstate	pointer
->	O
dash_array	pointer
)	O
;	O
num_dashes	int
=	O
drawstate	pointer
->	O
dash_array_len	int
;	O
offset	array
=	O
drawstate	pointer
->	O
dash_offset	double
;	O
}	O
else	O
{	O
const	O
int	O
*	O
dash_array	pointer
;	O
double	O
min_sing_val	pointer
,	O
max_sing_val	pointer
,	O
min_width	double
,	O
scale	double
;	O
_matrix_sing_vals	function
(	O
drawstate	pointer
->	O
transform	struct
.	O
m_user_to_ndc	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
if	O
(	O
max_sing_val	pointer
!=	O
0.0	int
)	O
min_width	double
=	O
PL_DEFAULT_LINE_WIDTH_AS_FRACTION_OF_DISPLAY_SIZE	O
/	O
max_sing_val	pointer
;	O
else	O
min_width	double
=	O
0.0	int
;	O
scale	double
=	O
DMAX	O
(	O
drawstate	pointer
->	O
line_width	double
,	O
min_width	double
)	O
;	O
dash_array	pointer
=	O
_pl_g_line_styles	array
[	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array	pointer
;	O
num_dashes	int
=	O
_pl_g_line_styles	array
[	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array_len	int
;	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
dashbuf	pointer
[	O
i	int
]	O
=	O
scale	double
*	O
dash_array	pointer
[	O
i	int
]	O
;	O
offset	array
=	O
0.0	int
;	O
}	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke-dasharray=\""	pointer
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"%.5g%s"	pointer
,	O
dashbuf	pointer
[	O
i	int
]	O
,	O
i	int
<	O
num_dashes	int
-	O
1	int
?	O
", "	pointer
:	O
"\""	pointer
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
if	O
(	O
offset	array
!=	O
0.0	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke-dashoffset=\"%.5g\" "	pointer
,	O
offset	array
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
if	O
(	O
drawstate	pointer
->	O
dash_array_in_effect	enum
==	O
false	int
)	O
free	function
(	O
dashbuf	pointer
)	O
;	O
}	O
else	O
{	O
}	O
}	O
else	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke=\"none\" "	pointer
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
if	O
(	O
drawstate	pointer
->	O
fill_type	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"fill=\"%s\" "	pointer
,	O
_libplot_color_to_svg_color	function
(	O
drawstate	pointer
->	O
fillcolor	struct
,	O
color_buf	array
)	O
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
if	O
(	O
drawstate	pointer
->	O
fill_rule_type	int
!=	O
PL_FILL_ODD_WINDING	int
)	O
{	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"fill-rule=\"%s\" "	pointer
,	O
svg_fill_style	array
[	O
drawstate	pointer
->	O
fill_rule_type	int
]	O
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
}	O
}	O
