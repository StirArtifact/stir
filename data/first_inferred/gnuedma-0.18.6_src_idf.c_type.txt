ESint32	long
EDMAPROC	O
_edma_read_class_interface	function
(	O
EUint32	long
ClassId	long
,	O
EPChar	pointer
Name	pointer
)	O
{	O
CLASSID	long
CId	long
,	O
aux_cid	long
;	O
EChar	char
FilePath	array
[	O
256	int
]	O
;	O
static	O
EChar	char
Buffer	array
[	O
200	int
]	O
;	O
EChar	char
IFaceKey	array
[	O
256	int
]	O
;	O
EChar	char
IFaceValue	array
[	O
256	int
]	O
;	O
ESint32	long
*	O
IFaceList	pointer
;	O
EChar	char
Ver	array
[	O
100	int
]	O
;	O
EDWord	long
Result	long
;	O
FILE	struct
*	O
f	pointer
;	O
EUint32	long
nProp	short
,	O
nMet	short
,	O
nNot	short
,	O
i	long
,	O
j	long
,	O
ii	long
,	O
indx	long
;	O
EUint32	long
nTotalProp	long
,	O
nTotalMet	long
,	O
nTotalNot	long
;	O
ESint32	long
nIFaces	long
;	O
ESint32	long
n_vmets	long
;	O
HMEM	long
h	long
,	O
h1	long
,	O
h2	long
;	O
EUint32	long
DataSize	long
;	O
EPChar	pointer
*	O
clist	pointer
;	O
EPChar	pointer
*	O
idlist	pointer
,	O
*	O
idlist1	pointer
,	O
aux	pointer
,	O
aux1	pointer
;	O
PINIFILE	pointer
pi	pointer
;	O
if	O
(	O
Name	pointer
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[_edma_read_class_interface] Interface name "	pointer
"invalid"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ClassId	long
==	O
-	O
1	int
)	O
CId	long
=	O
edma_get_class_id	function
(	O
Name	pointer
)	O
;	O
else	O
CId	long
=	O
ClassId	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
ClassId	long
,	O
"_edma_read_class_interface"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ProcMapTable	pointer
[	O
CId	long
]	O
>=	O
CLASS_ILOADED	int
)	O
{	O
edma_printf	function
(	O
"[_edma_read_class_interface] Interface for Class %d is "	pointer
"already loaded"	pointer
,	O
CId	long
)	O
;	O
if	O
(	O
ProcMapTable	pointer
[	O
CId	long
]	O
>=	O
CLASS_IMAPPED	int
)	O
return	O
0	int
;	O
}	O
ProcMapTable	pointer
[	O
CId	long
]	O
=	O
CLASS_TEMP	int
;	O
strcpy	function
(	O
Ver	array
,	O
""	pointer
)	O
;	O
if	O
(	O
strchr	function
(	O
Name	pointer
,	O
':'	O
)	O
==	O
0	int
)	O
{	O
strncpy	function
(	O
FilePath	array
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
CId	long
]	O
->	O
repo_id	long
)	O
,	O
256	int
)	O
;	O
if	O
(	O
edma_repo_manager_get_repo_type	function
(	O
gClass	O
[	O
CId	long
]	O
->	O
repo_id	long
)	O
==	O
EDMA_SHARED_REPO	int
)	O
{	O
strncat	function
(	O
FilePath	array
,	O
IDFDIR	pointer
,	O
256	int
)	O
;	O
}	O
else	O
{	O
strncat	function
(	O
FilePath	array
,	O
edma_repo_manager_get_repo_name	function
(	O
gClass	O
[	O
CId	long
]	O
->	O
repo_id	long
)	O
,	O
256	int
)	O
;	O
strncat	function
(	O
FilePath	array
,	O
"/idf/"	pointer
,	O
256	int
)	O
;	O
}	O
strncat	function
(	O
FilePath	array
,	O
gClass	O
[	O
CId	long
]	O
->	O
NameSpace	array
,	O
256	int
)	O
;	O
strncat	function
(	O
FilePath	array
,	O
"/"	pointer
,	O
256	int
)	O
;	O
strncat	function
(	O
FilePath	array
,	O
Name	pointer
,	O
256	int
)	O
;	O
if	O
(	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
MajorVer	char
==	O
0	int
)	O
&&	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
MinorVer	char
==	O
0	int
)	O
)	O
strncat	function
(	O
FilePath	array
,	O
".idf"	pointer
,	O
256	int
)	O
;	O
else	O
{	O
sprintf	function
(	O
Ver	array
,	O
"_%d_%d"	pointer
,	O
gClass	O
[	O
CId	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
CId	long
]	O
->	O
MinorVer	char
)	O
;	O
strncat	function
(	O
FilePath	array
,	O
Ver	array
,	O
256	int
)	O
;	O
strncat	function
(	O
FilePath	array
,	O
".idf"	pointer
,	O
256	int
)	O
;	O
}	O
}	O
else	O
strncpy	function
(	O
FilePath	array
,	O
Name	pointer
,	O
256	int
)	O
;	O
if	O
(	O
(	O
f	pointer
=	O
fopen	function
(	O
FilePath	array
,	O
"rt"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Interface definition "	pointer
"file %s not found"	pointer
,	O
FilePath	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
pi	pointer
=	O
edma_open_ini	function
(	O
FilePath	array
)	O
;	O
nProp	short
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
"Definition"	pointer
,	O
"PropertiesNum"	pointer
,	O
0	int
)	O
;	O
nMet	short
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
"Definition"	pointer
,	O
"MethodsNum"	pointer
,	O
0	int
)	O
;	O
nNot	short
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
"Definition"	pointer
,	O
"NotificationsNum"	pointer
,	O
0	int
)	O
;	O
nIFaces	long
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
"Definition"	pointer
,	O
"InterfacesNum"	pointer
,	O
0	int
)	O
;	O
nTotalProp	long
=	O
nProp	short
;	O
nTotalMet	long
=	O
nMet	short
;	O
nTotalNot	long
=	O
nNot	short
;	O
if	O
(	O
nIFaces	long
)	O
{	O
if	O
(	O
(	O
h	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
ESint32	long
)	O
*	O
nIFaces	long
)	O
)	O
==	O
(	O
HMEM	long
)	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Can't allocate memory"	pointer
" for interface processing on Class %d"	pointer
,	O
CId	long
)	O
;	O
}	O
else	O
{	O
IFaceList	pointer
=	O
(	O
ESint32	long
*	O
)	O
edma_pget	function
(	O
h	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nIFaces	long
;	O
i	long
++	O
)	O
{	O
snprintf	function
(	O
IFaceKey	array
,	O
256	int
,	O
"Interface%ld"	pointer
,	O
i	long
)	O
;	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
"Interface"	pointer
,	O
IFaceKey	array
,	O
NULL	O
,	O
IFaceValue	array
,	O
256	int
)	O
;	O
IFaceList	pointer
[	O
i	long
]	O
=	O
edma_get_class_id	function
(	O
IFaceValue	array
)	O
;	O
if	O
(	O
IFaceList	pointer
[	O
i	long
]	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Interface "	pointer
"%d:'%s' does not exists"	pointer
,	O
i	long
,	O
IFaceValue	array
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ProcMapTable	pointer
[	O
IFaceList	pointer
[	O
i	long
]	O
]	O
<	O
CLASS_ILOADED	int
)	O
if	O
(	O
(	O
edma_load_class_int	function
(	O
IFaceList	pointer
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
IFaceList	pointer
[	O
i	long
]	O
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
nTotalProp	long
+=	O
gClass	O
[	O
IFaceList	pointer
[	O
i	long
]	O
]	O
->	O
nProp	short
;	O
nTotalMet	long
+=	O
gClass	O
[	O
IFaceList	pointer
[	O
i	long
]	O
]	O
->	O
nMet	short
;	O
}	O
}	O
}	O
if	O
(	O
(	O
edma_idf_set_def	function
(	O
CId	long
,	O
nTotalProp	long
,	O
nTotalMet	long
,	O
nNot	short
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Build Property class "	pointer
"failed for class %d"	pointer
,	O
CId	long
)	O
;	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Oops!... "	pointer
"this shouldn't happen"	pointer
)	O
;	O
}	O
DataSize	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nProp	short
;	O
i	long
++	O
)	O
{	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Off	short
=	O
DataSize	long
;	O
DataSize	long
+=	O
_edma_read_edmaidf_prop	function
(	O
pi	pointer
,	O
CId	long
,	O
i	long
)	O
;	O
}	O
indx	long
=	O
nProp	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nIFaces	long
;	O
i	long
++	O
)	O
if	O
(	O
IFaceList	pointer
[	O
i	long
]	O
!=	O
-	O
1	int
)	O
{	O
aux_cid	long
=	O
IFaceList	pointer
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gClass	O
[	O
aux_cid	long
]	O
->	O
nProp	short
;	O
j	long
++	O
,	O
indx	long
++	O
)	O
{	O
strncpy	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
IdProp	array
,	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Prop	pointer
[	O
j	long
]	O
.	O
IdProp	array
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Tipo	long
=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Prop	pointer
[	O
j	long
]	O
.	O
Tipo	long
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
ioTipo	char
=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Prop	pointer
[	O
j	long
]	O
.	O
ioTipo	char
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
nElem	long
=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Prop	pointer
[	O
j	long
]	O
.	O
nElem	long
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Off	short
=	O
DataSize	long
;	O
DataSize	long
+=	O
(	O
tipo	array
[	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Prop	pointer
[	O
j	long
]	O
.	O
Tipo	long
]	O
.	O
tam	long
*	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Prop	pointer
[	O
j	long
]	O
.	O
nElem	long
)	O
;	O
}	O
}	O
gClass	O
[	O
CId	long
]	O
->	O
TamDatos	long
=	O
DataSize	long
;	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
=	O
indx	long
;	O
n_vmets	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nMet	short
;	O
i	long
++	O
)	O
n_vmets	long
+=	O
_edma_read_edmaidf_met	function
(	O
pi	pointer
,	O
CId	long
,	O
i	long
)	O
;	O
indx	long
=	O
nMet	short
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nIFaces	long
;	O
i	long
++	O
)	O
if	O
(	O
IFaceList	pointer
[	O
i	long
]	O
!=	O
-	O
1	int
)	O
{	O
aux_cid	long
=	O
IFaceList	pointer
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gClass	O
[	O
aux_cid	long
]	O
->	O
nMet	short
;	O
j	long
++	O
,	O
indx	long
++	O
)	O
{	O
strncpy	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
IdMet	array
,	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Met	pointer
[	O
j	long
]	O
.	O
IdMet	array
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
strncpy	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Sign	array
,	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Met	pointer
[	O
j	long
]	O
.	O
Sign	array
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Virtual	char
=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Met	pointer
[	O
j	long
]	O
.	O
Virtual	char
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Abstract	char
=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Met	pointer
[	O
j	long
]	O
.	O
Abstract	char
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Static	char
=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Met	pointer
[	O
j	long
]	O
.	O
Static	char
;	O
n_vmets	long
+=	O
pClass	pointer
[	O
aux_cid	long
]	O
->	O
Met	pointer
[	O
j	long
]	O
.	O
Virtual	char
;	O
}	O
}	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
=	O
indx	long
;	O
gClass	O
[	O
CId	long
]	O
->	O
nMetVir	long
=	O
n_vmets	long
;	O
if	O
(	O
nIFaces	long
)	O
edma_pfree	function
(	O
h	long
,	O
IFaceList	pointer
)	O
;	O
Buffer	array
[	O
0	int
]	O
=	O
0	int
;	O
Result	long
=	O
0	int
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
"Definition"	pointer
,	O
"SCList"	pointer
,	O
NULL	O
,	O
Buffer	array
,	O
200	int
)	O
;	O
if	O
(	O
Result	long
!=	O
0	int
)	O
{	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
Result	long
;	O
i	long
++	O
)	O
if	O
(	O
Buffer	array
[	O
i	long
]	O
==	O
','	O
)	O
j	long
++	O
;	O
j	long
++	O
;	O
edma_printf_dbg	function
(	O
12	int
,	O
-	O
1	int
,	O
"[_edma_read_class_interface] %d superclases "	pointer
"located :"	pointer
,	O
j	long
)	O
;	O
gClass	O
[	O
CId	long
]	O
->	O
Derived	long
=	O
j	long
;	O
if	O
(	O
(	O
h	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
EPChar	pointer
)	O
*	O
(	O
j	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Can't create "	pointer
"inheritance info"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
clist	pointer
=	O
(	O
EPChar	pointer
*	O
)	O
edma_pget	function
(	O
h	long
)	O
;	O
clist	pointer
[	O
0	int
]	O
=	O
Buffer	array
;	O
if	O
(	O
(	O
h1	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
EPChar	pointer
)	O
*	O
(	O
j	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Can't create "	pointer
"anchor point info..."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
idlist	pointer
=	O
(	O
EPChar	pointer
*	O
)	O
edma_pget	function
(	O
h1	long
)	O
;	O
if	O
(	O
(	O
h2	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
EPChar	pointer
)	O
*	O
(	O
j	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_class_interface] Can't create "	pointer
"anchor point info..."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
idlist1	pointer
=	O
(	O
EPChar	pointer
*	O
)	O
edma_pget	function
(	O
h2	long
)	O
;	O
ii	long
=	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
Result	long
+	O
1	int
;	O
i	long
++	O
)	O
if	O
(	O
(	O
Buffer	array
[	O
i	long
]	O
==	O
','	O
)	O
||	O
(	O
Buffer	array
[	O
i	long
]	O
==	O
0	int
)	O
)	O
{	O
clist	pointer
[	O
j	long
]	O
=	O
(	O
Buffer	array
+	O
ii	long
)	O
;	O
Buffer	array
[	O
i	long
]	O
=	O
0	int
;	O
if	O
(	O
(	O
aux	pointer
=	O
strchr	function
(	O
clist	pointer
[	O
j	long
]	O
,	O
':'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
idlist	pointer
[	O
j	long
]	O
=	O
aux	pointer
+	O
1	int
;	O
*	O
aux	pointer
=	O
0	int
;	O
if	O
(	O
(	O
aux1	pointer
=	O
strchr	function
(	O
idlist	pointer
[	O
j	long
]	O
,	O
'|'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
idlist1	pointer
[	O
j	long
]	O
=	O
aux1	pointer
+	O
1	int
;	O
*	O
aux1	pointer
=	O
0	int
;	O
}	O
else	O
idlist1	pointer
[	O
j	long
]	O
=	O
NULL	O
;	O
}	O
else	O
idlist	pointer
[	O
j	long
]	O
=	O
NULL	O
;	O
j	long
++	O
;	O
ii	long
=	O
i	long
+	O
1	int
;	O
}	O
clist	pointer
[	O
j	long
]	O
=	O
0	int
;	O
idlist	pointer
[	O
j	long
]	O
=	O
0	int
;	O
idlist1	pointer
[	O
j	long
]	O
=	O
0	int
;	O
gClass	O
[	O
CId	long
]	O
->	O
Status	char
=	O
CLASS_ILOADED	int
;	O
ProcMapTable	pointer
[	O
CId	long
]	O
=	O
CLASS_IMAPPED	int
;	O
if	O
(	O
(	O
edma_derive_class	function
(	O
gClass	O
[	O
CId	long
]	O
->	O
ClassName	array
,	O
clist	pointer
,	O
idlist	pointer
,	O
idlist1	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"Can't load interfaz for class %s"	pointer
,	O
gClass	O
[	O
CId	long
]	O
->	O
ClassName	array
)	O
;	O
edma_pfree	function
(	O
h	long
,	O
clist	pointer
)	O
;	O
edma_pfree	function
(	O
h1	long
,	O
idlist	pointer
)	O
;	O
edma_pfree	function
(	O
h2	long
,	O
idlist1	pointer
)	O
;	O
edma_close_ini	function
(	O
pi	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_pfree	function
(	O
h	long
,	O
clist	pointer
)	O
;	O
edma_pfree	function
(	O
h1	long
,	O
idlist	pointer
)	O
;	O
edma_pfree	function
(	O
h2	long
,	O
idlist1	pointer
)	O
;	O
}	O
pClass	pointer
[	O
CId	long
]	O
->	O
met_dict	pointer
=	O
edma_dict_new	function
(	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
edma_dict_add_entry	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
met_dict	pointer
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
i	long
)	O
;	O
pClass	pointer
[	O
CId	long
]	O
->	O
prop_dict	pointer
=	O
edma_dict_new	function
(	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
edma_dict_add_entry	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
prop_dict	pointer
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
IdProp	array
,	O
i	long
)	O
;	O
edma_close_ini	function
(	O
pi	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_free_class_interface	function
(	O
EUint32	long
ClassId	long
,	O
EPChar	pointer
Name	pointer
)	O
{	O
CLASSID	long
CId	long
;	O
if	O
(	O
(	O
ClassId	long
==	O
-	O
1	int
)	O
&&	O
(	O
Name	pointer
==	O
NULL	O
)	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[_edma_free_class_interface] Not enough "	pointer
"information to locate class"	pointer
)	O
;	O
}	O
if	O
(	O
ClassId	long
==	O
-	O
1	int
)	O
CId	long
=	O
edma_get_class_id	function
(	O
Name	pointer
)	O
;	O
else	O
CId	long
=	O
ClassId	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
ClassId	long
,	O
"_edma_free_class_interface"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ProcMapTable	pointer
[	O
CId	long
]	O
>=	O
CLASS_ILOADED	int
)	O
{	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
Derived	long
)	O
{	O
edma_sunget	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SCList	pointer
)	O
;	O
edma_sunget	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SCIdList	pointer
)	O
;	O
}	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
)	O
edma_sunget	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
)	O
edma_sunget	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nNot	short
)	O
edma_sunget	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
Not	pointer
)	O
;	O
ProcMapTable	pointer
[	O
CId	long
]	O
=	O
CLASS_ILOADED	int
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
Ocurrences	long
==	O
0	int
)	O
{	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
Derived	long
)	O
{	O
edma_sfree	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SysClass	struct
.	O
hSCList	long
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
SCList	pointer
)	O
;	O
edma_sfree	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SysClass	struct
.	O
hSCIdList	long
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
SCIdList	pointer
)	O
;	O
}	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nProp	short
)	O
edma_sfree	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SysClass	struct
.	O
hProp	long
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
Prop	pointer
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nMet	short
)	O
edma_sfree	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SysClass	struct
.	O
hMet	long
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
Met	pointer
)	O
;	O
if	O
(	O
gClass	O
[	O
CId	long
]	O
->	O
nNot	short
)	O
edma_sfree	function
(	O
pClass	pointer
[	O
CId	long
]	O
->	O
SysClass	struct
.	O
hNot	long
,	O
pClass	pointer
[	O
CId	long
]	O
->	O
Not	pointer
)	O
;	O
ProcMapTable	pointer
[	O
CId	long
]	O
=	O
CLASS_DEF	int
;	O
gClass	O
[	O
CId	long
]	O
->	O
Status	char
=	O
CLASS_DEF	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
EUint32	long
_edma_read_edmaidf_prop	function
(	O
PINIFILE	pointer
pi	pointer
,	O
EUint32	long
class_id	long
,	O
EUint32	long
property_indx	long
)	O
{	O
EChar	char
prop_name	array
[	O
EDMA_PROP_NAME_LEN	O
]	O
;	O
EChar	char
prop_type	array
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
EChar	char
prop_access	array
[	O
EDMA_GENERAL_ID_LEN	int
]	O
;	O
EChar	char
user_data	array
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
EChar	char
Aux	array
[	O
100	int
]	O
;	O
EDWord	long
Result	long
;	O
EUint32	long
n_elems	long
,	O
size	long
;	O
size	long
=	O
0	int
;	O
sprintf	function
(	O
Aux	array
,	O
"Prop%ld"	pointer
,	O
property_indx	long
)	O
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Name"	pointer
,	O
NULL	O
,	O
prop_name	array
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Type"	pointer
,	O
NULL	O
,	O
prop_type	array
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
Aux	array
,	O
"UserType"	pointer
,	O
NULL	O
,	O
user_data	array
,	O
EDMA_CLASS_NAME_LEN	int
)	O
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Access"	pointer
,	O
NULL	O
,	O
prop_access	array
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
n_elems	long
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
Aux	array
,	O
"ArrayElems"	pointer
,	O
0	int
)	O
;	O
size	long
=	O
edma_idf_set_prop	function
(	O
class_id	long
,	O
property_indx	long
,	O
prop_name	array
,	O
prop_type	array
,	O
prop_access	array
,	O
n_elems	long
,	O
user_data	array
)	O
;	O
if	O
(	O
size	long
<	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"[_edma_read_edmaidf_prop] Error reading property "	pointer
"%s on class %s:%d"	pointer
,	O
prop_name	array
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
size	long
;	O
}	O
EUint32	long
_edma_read_edmaidf_met	function
(	O
PINIFILE	pointer
pi	pointer
,	O
EUint32	long
class_id	long
,	O
EUint32	long
method_indx	long
)	O
{	O
EChar	char
method_name	array
[	O
EDMA_MET_NAME_LEN	O
]	O
;	O
EChar	char
method_sig	array
[	O
EDMA_MET_SIG_LEN	int
]	O
;	O
EChar	char
Aux	array
[	O
100	int
]	O
;	O
EDWord	long
Result	long
;	O
ESint32	long
m_abstract	long
,	O
m_static	long
,	O
m_virtual	long
;	O
sprintf	function
(	O
Aux	array
,	O
"Met%ld"	pointer
,	O
method_indx	long
)	O
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Name"	pointer
,	O
NULL	O
,	O
method_name	array
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
Result	long
=	O
edma_get_ini_string	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Signature"	pointer
,	O
NULL	O
,	O
method_sig	array
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
m_static	long
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Static"	pointer
,	O
0	int
)	O
;	O
m_abstract	long
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Abstract"	pointer
,	O
0	int
)	O
;	O
m_virtual	long
=	O
edma_get_ini_int	function
(	O
pi	pointer
,	O
Aux	array
,	O
"Virtual"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
m_abstract	long
)	O
if	O
(	O
m_virtual	long
==	O
0	int
)	O
{	O
edma_log	function
(	O
"[_edma_read_edmaidf_met] WARNNING. Method '%s' declared "	pointer
"abstract but not virtual. Setting virtual flag"	pointer
,	O
method_name	array
)	O
;	O
m_virtual	long
=	O
1	int
;	O
}	O
edma_idf_set_met	function
(	O
class_id	long
,	O
method_indx	long
,	O
method_name	array
,	O
method_sig	array
,	O
m_virtual	long
,	O
m_abstract	long
,	O
m_static	long
)	O
;	O
return	O
m_virtual	long
;	O
}	O
