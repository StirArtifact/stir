const	O
char	O
*	O
whitespace_chars	pointer
=	O
" \t\f\v\r\n"	pointer
;	O
int	O
xs_abort_empty_line	function
(	O
HV	struct
*	O
self	pointer
,	O
HV	struct
*	O
current	pointer
,	O
SV	struct
*	O
additional_spaces_in	pointer
)	O
{	O
char	O
*	O
additional_spaces	pointer
;	O
AV	struct
*	O
contents_array	pointer
;	O
SV	struct
*	O
*	O
svp	pointer
;	O
int	O
contents_num	int
;	O
HV	struct
*	O
spaces_elt	pointer
;	O
HV	struct
*	O
test_extra	pointer
=	O
0	int
;	O
HV	struct
*	O
command_extra	pointer
=	O
0	int
;	O
HV	struct
*	O
owning_elt	pointer
=	O
0	int
;	O
char	O
*	O
type	char
;	O
SV	struct
*	O
existing_text_sv	pointer
;	O
dTHX	O
;	O
if	O
(	O
additional_spaces_in	pointer
)	O
{	O
STRLEN	long
len	long
;	O
static	O
char	O
*	O
new_string	pointer
;	O
additional_spaces	pointer
=	O
SvPV	O
(	O
additional_spaces_in	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
SvUTF8	O
(	O
additional_spaces_in	pointer
)	O
)	O
{	O
free	function
(	O
new_string	pointer
)	O
;	O
new_string	pointer
=	O
bytes_to_utf8	O
(	O
additional_spaces	pointer
,	O
&	O
len	long
)	O
;	O
additional_spaces	pointer
=	O
new_string	pointer
;	O
}	O
}	O
else	O
additional_spaces	pointer
=	O
""	pointer
;	O
svp	pointer
=	O
hv_fetch	O
(	O
current	pointer
,	O
"contents"	pointer
,	O
strlen	function
(	O
"contents"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
return	O
0	int
;	O
contents_array	pointer
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	pointer
)	O
;	O
contents_num	int
=	O
av_len	O
(	O
contents_array	pointer
)	O
+	O
1	int
;	O
if	O
(	O
contents_num	int
==	O
0	int
)	O
return	O
0	int
;	O
spaces_elt	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
av_fetch	O
(	O
contents_array	pointer
,	O
contents_num	int
-	O
1	int
,	O
0	int
)	O
)	O
;	O
svp	pointer
=	O
hv_fetch	O
(	O
spaces_elt	pointer
,	O
"type"	pointer
,	O
strlen	function
(	O
"type"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
return	O
0	int
;	O
type	char
=	O
SvPV_nolen	O
(	O
*	O
svp	pointer
)	O
;	O
if	O
(	O
!	O
type	char
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
type	char
,	O
"empty_line"	pointer
)	O
&&	O
strcmp	function
(	O
type	char
,	O
"empty_line_after_command"	pointer
)	O
&&	O
strcmp	function
(	O
type	char
,	O
"empty_spaces_before_argument"	pointer
)	O
&&	O
strcmp	function
(	O
type	char
,	O
"empty_spaces_after_close_brace"	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
svp	pointer
=	O
hv_fetch	O
(	O
spaces_elt	pointer
,	O
"extra"	pointer
,	O
strlen	function
(	O
"extra"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	pointer
)	O
{	O
test_extra	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	pointer
)	O
;	O
svp	pointer
=	O
hv_fetch	O
(	O
test_extra	pointer
,	O
"command"	pointer
,	O
strlen	function
(	O
"command"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	pointer
)	O
{	O
owning_elt	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	pointer
)	O
;	O
svp	pointer
=	O
hv_fetch	O
(	O
owning_elt	pointer
,	O
"extra"	pointer
,	O
strlen	function
(	O
"extra"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	pointer
)	O
command_extra	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	pointer
)	O
;	O
}	O
}	O
svp	pointer
=	O
hv_fetch	O
(	O
spaces_elt	pointer
,	O
"text"	pointer
,	O
strlen	function
(	O
"text"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
return	O
0	int
;	O
existing_text_sv	pointer
=	O
*	O
svp	pointer
;	O
sv_utf8_upgrade	O
(	O
existing_text_sv	pointer
)	O
;	O
sv_catpv	O
(	O
existing_text_sv	pointer
,	O
additional_spaces	pointer
)	O
;	O
if	O
(	O
!	O
*	O
SvPV_nolen	O
(	O
existing_text_sv	pointer
)	O
)	O
{	O
av_pop	O
(	O
contents_array	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_line"	pointer
)	O
)	O
{	O
char	O
*	O
current_type	pointer
;	O
AV	struct
*	O
context_stack	pointer
;	O
SV	struct
*	O
top_context_sv	pointer
;	O
char	O
*	O
top_context	pointer
;	O
int	O
top_index	int
;	O
svp	pointer
=	O
hv_fetch	O
(	O
current	pointer
,	O
"type"	pointer
,	O
strlen	function
(	O
"type"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
current_type	pointer
=	O
0	int
;	O
else	O
current_type	pointer
=	O
SvPV_nolen	O
(	O
*	O
svp	pointer
)	O
;	O
if	O
(	O
current_type	pointer
&&	O
strcmp	function
(	O
current_type	pointer
,	O
"before_item"	pointer
)	O
&&	O
strcmp	function
(	O
current_type	pointer
,	O
"text_root"	pointer
)	O
&&	O
strcmp	function
(	O
current_type	pointer
,	O
"document_root"	pointer
)	O
&&	O
strcmp	function
(	O
current_type	pointer
,	O
"brace_command_context"	pointer
)	O
)	O
goto	O
delete_type	O
;	O
svp	pointer
=	O
hv_fetch	O
(	O
self	pointer
,	O
"context_stack"	pointer
,	O
strlen	function
(	O
"context_stack"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
goto	O
delete_type	O
;	O
context_stack	pointer
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	pointer
)	O
;	O
top_index	int
=	O
av_len	O
(	O
context_stack	pointer
)	O
;	O
if	O
(	O
top_index	int
<	O
0	int
)	O
goto	O
delete_type	O
;	O
svp	pointer
=	O
av_fetch	O
(	O
context_stack	pointer
,	O
top_index	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
goto	O
delete_type	O
;	O
top_context_sv	pointer
=	O
*	O
svp	pointer
;	O
top_context	pointer
=	O
SvPV_nolen	O
(	O
top_context_sv	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
top_context	pointer
,	O
"math"	pointer
)	O
&&	O
strcmp	function
(	O
top_context	pointer
,	O
"menu"	pointer
)	O
&&	O
strcmp	function
(	O
top_context	pointer
,	O
"preformatted"	pointer
)	O
&&	O
strcmp	function
(	O
top_context	pointer
,	O
"rawpreformatted"	pointer
)	O
&&	O
strcmp	function
(	O
top_context	pointer
,	O
"def"	pointer
)	O
&&	O
strcmp	function
(	O
top_context	pointer
,	O
"inlineraw"	pointer
)	O
)	O
{	O
hv_store	O
(	O
spaces_elt	pointer
,	O
"type"	pointer
,	O
strlen	function
(	O
"type"	pointer
)	O
,	O
newSVpv	O
(	O
"empty_spaces_before_paragraph"	pointer
,	O
0	int
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
delete_type	O
:	O
hv_delete	O
(	O
spaces_elt	pointer
,	O
"type"	pointer
,	O
strlen	function
(	O
"type"	pointer
)	O
,	O
G_DISCARD	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_line_after_command"	pointer
)	O
||	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_spaces_before_argument"	pointer
)	O
)	O
{	O
STRLEN	long
len	long
;	O
char	O
*	O
ptr	pointer
;	O
if	O
(	O
owning_elt	pointer
)	O
{	O
av_pop	O
(	O
contents_array	pointer
)	O
;	O
ptr	pointer
=	O
SvPV	O
(	O
existing_text_sv	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
command_extra	pointer
)	O
{	O
command_extra	pointer
=	O
newHV	O
(	O
)	O
;	O
hv_store	O
(	O
owning_elt	pointer
,	O
"extra"	pointer
,	O
strlen	function
(	O
"extra"	pointer
)	O
,	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
command_extra	pointer
)	O
,	O
0	int
)	O
;	O
}	O
hv_store	O
(	O
command_extra	pointer
,	O
"spaces_before_argument"	pointer
,	O
strlen	function
(	O
"spaces_before_argument"	pointer
)	O
,	O
newSVpv	O
(	O
ptr	pointer
,	O
len	long
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
hv_store	O
(	O
spaces_elt	pointer
,	O
"type"	pointer
,	O
strlen	function
(	O
"type"	pointer
)	O
,	O
newSVpv	O
(	O
"empty_spaces_after_command"	pointer
,	O
0	int
)	O
,	O
0	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
HV	struct
*	O
xs_merge_text	function
(	O
HV	struct
*	O
self	pointer
,	O
HV	struct
*	O
current	pointer
,	O
SV	struct
*	O
text_in	pointer
)	O
{	O
AV	struct
*	O
contents_array	pointer
;	O
int	O
no_merge_with_following_text	int
=	O
0	int
;	O
char	O
*	O
text	pointer
;	O
int	O
leading_spaces	int
;	O
SV	struct
*	O
leading_spaces_sv	pointer
=	O
0	int
;	O
int	O
call_ret	int
;	O
SV	struct
*	O
returned_sv	pointer
;	O
SV	struct
*	O
contents_ref	pointer
;	O
int	O
contents_num	int
;	O
HV	struct
*	O
last_elt	pointer
;	O
SV	struct
*	O
existing_text_sv	pointer
;	O
char	O
*	O
existing_text	pointer
;	O
SV	struct
*	O
*	O
svp	pointer
;	O
dTHX	O
;	O
dSP	O
;	O
{	O
STRLEN	long
len	long
;	O
static	O
char	O
*	O
new_string	pointer
;	O
text	pointer
=	O
SvPV	O
(	O
text_in	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
SvUTF8	O
(	O
text_in	pointer
)	O
)	O
{	O
free	function
(	O
new_string	pointer
)	O
;	O
new_string	pointer
=	O
bytes_to_utf8	O
(	O
text	pointer
,	O
&	O
len	long
)	O
;	O
text	pointer
=	O
new_string	pointer
;	O
}	O
}	O
leading_spaces	int
=	O
strspn	function
(	O
text	pointer
,	O
whitespace_chars	pointer
)	O
;	O
if	O
(	O
text	pointer
[	O
leading_spaces	int
]	O
)	O
{	O
int	O
contents_num	int
;	O
if	O
(	O
leading_spaces	int
>	O
0	int
)	O
{	O
leading_spaces_sv	pointer
=	O
newSVpv	O
(	O
text	pointer
,	O
leading_spaces	int
)	O
;	O
}	O
svp	pointer
=	O
hv_fetch	O
(	O
current	pointer
,	O
"contents"	pointer
,	O
strlen	function
(	O
"contents"	pointer
)	O
,	O
0	int
)	O
;	O
contents_array	pointer
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
*	O
svp	pointer
)	O
;	O
contents_num	int
=	O
av_len	O
(	O
contents_array	pointer
)	O
+	O
1	int
;	O
if	O
(	O
contents_num	int
>	O
0	int
)	O
{	O
HV	struct
*	O
last_elt	pointer
;	O
char	O
*	O
type	char
=	O
0	int
;	O
last_elt	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
av_fetch	O
(	O
contents_array	pointer
,	O
contents_num	int
-	O
1	int
,	O
0	int
)	O
)	O
;	O
svp	pointer
=	O
hv_fetch	O
(	O
last_elt	pointer
,	O
"type"	pointer
,	O
strlen	function
(	O
"type"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
svp	pointer
)	O
type	char
=	O
SvPV_nolen	O
(	O
*	O
svp	pointer
)	O
;	O
if	O
(	O
type	char
&&	O
(	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_line_after_command"	pointer
)	O
||	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_spaces_after_command"	pointer
)	O
||	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_spaces_before_argument"	pointer
)	O
||	O
!	O
strcmp	function
(	O
type	char
,	O
"empty_spaces_after_close_brace"	pointer
)	O
)	O
)	O
{	O
no_merge_with_following_text	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
xs_abort_empty_line	function
(	O
self	pointer
,	O
current	pointer
,	O
leading_spaces_sv	pointer
)	O
)	O
{	O
text	pointer
+=	O
leading_spaces	int
;	O
}	O
ENTER	O
;	O
SAVETMPS	O
;	O
PUSHMARK	O
(	O
SP	O
)	O
;	O
XPUSHs	O
(	O
sv_2mortal	O
(	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
self	pointer
)	O
)	O
)	O
;	O
XPUSHs	O
(	O
sv_2mortal	O
(	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
current	pointer
)	O
)	O
)	O
;	O
PUTBACK	O
;	O
call_ret	int
=	O
call_pv	O
(	O
"Texinfo::Parser::_begin_paragraph"	pointer
,	O
G_SCALAR	int
)	O
;	O
SPAGAIN	O
;	O
returned_sv	pointer
=	O
POPs	O
;	O
if	O
(	O
returned_sv	pointer
&&	O
SvRV	O
(	O
returned_sv	pointer
)	O
)	O
{	O
current	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
returned_sv	pointer
)	O
;	O
}	O
FREETMPS	O
;	O
LEAVE	O
;	O
}	O
svp	pointer
=	O
hv_fetch	O
(	O
current	pointer
,	O
"contents"	pointer
,	O
strlen	function
(	O
"contents"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
{	O
contents_array	pointer
=	O
newAV	O
(	O
)	O
;	O
contents_ref	pointer
=	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
contents_array	pointer
)	O
;	O
hv_store	O
(	O
current	pointer
,	O
"contents"	pointer
,	O
strlen	function
(	O
"contents"	pointer
)	O
,	O
contents_ref	pointer
,	O
0	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"NEW CONTENTS %p\n"	pointer
,	O
contents_array	pointer
)	O
;	O
goto	O
NEW_TEXT	O
;	O
}	O
else	O
{	O
contents_ref	pointer
=	O
*	O
svp	pointer
;	O
contents_array	pointer
=	O
(	O
AV	struct
*	O
)	O
SvRV	O
(	O
contents_ref	pointer
)	O
;	O
}	O
if	O
(	O
no_merge_with_following_text	int
)	O
goto	O
NEW_TEXT	O
;	O
contents_num	int
=	O
av_len	O
(	O
contents_array	pointer
)	O
+	O
1	int
;	O
if	O
(	O
contents_num	int
==	O
0	int
)	O
goto	O
NEW_TEXT	O
;	O
last_elt	pointer
=	O
(	O
HV	struct
*	O
)	O
SvRV	O
(	O
*	O
av_fetch	O
(	O
contents_array	pointer
,	O
contents_num	int
-	O
1	int
,	O
0	int
)	O
)	O
;	O
svp	pointer
=	O
hv_fetch	O
(	O
last_elt	pointer
,	O
"text"	pointer
,	O
strlen	function
(	O
"text"	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
svp	pointer
)	O
goto	O
NEW_TEXT	O
;	O
existing_text_sv	pointer
=	O
*	O
svp	pointer
;	O
existing_text	pointer
=	O
SvPV_nolen	O
(	O
existing_text_sv	pointer
)	O
;	O
if	O
(	O
strchr	function
(	O
existing_text	pointer
,	O
'\n'	O
)	O
)	O
goto	O
NEW_TEXT	O
;	O
MERGED_TEXT	O
:	O
sv_catpv	O
(	O
existing_text_sv	pointer
,	O
text	pointer
)	O
;	O
if	O
(	O
0	int
)	O
{	O
HV	struct
*	O
hv	struct
;	O
SV	struct
*	O
sv	struct
;	O
NEW_TEXT	O
:	O
hv	struct
=	O
newHV	O
(	O
)	O
;	O
sv	struct
=	O
newSVpv	O
(	O
text	pointer
,	O
0	int
)	O
;	O
hv_store	O
(	O
hv	struct
,	O
"text"	pointer
,	O
strlen	function
(	O
"text"	pointer
)	O
,	O
sv	struct
,	O
0	int
)	O
;	O
SvUTF8_on	O
(	O
sv	struct
)	O
;	O
hv_store	O
(	O
hv	struct
,	O
"parent"	pointer
,	O
strlen	function
(	O
"parent"	pointer
)	O
,	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
current	pointer
)	O
,	O
0	int
)	O
;	O
av_push	O
(	O
contents_array	pointer
,	O
newRV_inc	O
(	O
(	O
SV	struct
*	O
)	O
hv	struct
)	O
)	O
;	O
}	O
return	O
current	pointer
;	O
}	O
char	O
*	O
xs_process_text	function
(	O
char	O
*	O
text	pointer
)	O
{	O
static	O
char	O
*	O
new	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
dTHX	O
;	O
new	pointer
=	O
realloc	function
(	O
new	pointer
,	O
strlen	function
(	O
text	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
new	pointer
,	O
text	pointer
)	O
;	O
p	pointer
=	O
q	pointer
=	O
new	pointer
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
p	pointer
[	O
2	int
]	O
==	O
'-'	O
)	O
{	O
*	O
q	pointer
=	O
'-'	O
;	O
q	pointer
[	O
1	int
]	O
=	O
'-'	O
;	O
p	pointer
+=	O
3	int
;	O
q	pointer
+=	O
2	int
;	O
}	O
else	O
{	O
*	O
q	pointer
=	O
'-'	O
;	O
p	pointer
+=	O
2	int
;	O
q	pointer
+=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'\''	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'\''	O
)	O
{	O
*	O
q	pointer
=	O
'"'	O
;	O
p	pointer
+=	O
2	int
;	O
q	pointer
+=	O
1	int
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'`'	O
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'`'	O
)	O
{	O
*	O
q	pointer
=	O
'"'	O
;	O
p	pointer
+=	O
2	int
;	O
q	pointer
+=	O
1	int
;	O
}	O
else	O
{	O
*	O
q	pointer
=	O
'\''	O
;	O
p	pointer
+=	O
1	int
;	O
q	pointer
+=	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
}	O
*	O
q	pointer
=	O
'\0'	O
;	O
return	O
new	pointer
;	O
}	O
char	O
*	O
xs_unicode_text	function
(	O
char	O
*	O
text	pointer
,	O
int	O
in_code	int
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
static	O
char	O
*	O
new	pointer
;	O
int	O
new_space	int
,	O
new_len	int
;	O
dTHX	O
;	O
if	O
(	O
in_code	int
)	O
return	O
text	pointer
;	O
p	pointer
=	O
text	pointer
;	O
new_space	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
new	pointer
=	O
realloc	function
(	O
new	pointer
,	O
new_space	int
+	O
1	int
)	O
;	O
new_len	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
q	pointer
=	O
p	pointer
+	O
strcspn	function
(	O
p	pointer
,	O
"-`'"	pointer
)	O
;	O
ADDN	O
(	O
p	pointer
,	O
q	pointer
-	O
p	pointer
)	O
;	O
if	O
(	O
!	O
*	O
q	pointer
)	O
break	O
;	O
switch	O
(	O
*	O
q	pointer
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
!	O
memcmp	function
(	O
q	pointer
,	O
"---"	pointer
,	O
3	int
)	O
)	O
{	O
p	pointer
=	O
q	pointer
+	O
3	int
;	O
ADD3	O
(	O
"\xE2\x80\x94"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
memcmp	function
(	O
q	pointer
,	O
"--"	pointer
,	O
2	int
)	O
)	O
{	O
p	pointer
=	O
q	pointer
+	O
2	int
;	O
ADD3	O
(	O
"\xE2\x80\x93"	pointer
)	O
;	O
}	O
else	O
{	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
ADD1	O
(	O
*	O
q	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'`'	O
:	O
if	O
(	O
!	O
memcmp	function
(	O
q	pointer
,	O
"``"	pointer
,	O
2	int
)	O
)	O
{	O
p	pointer
=	O
q	pointer
+	O
2	int
;	O
ADD3	O
(	O
"\xE2\x80\x9C"	pointer
)	O
;	O
}	O
else	O
{	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
ADD3	O
(	O
"\xE2\x80\x98"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
memcmp	function
(	O
q	pointer
,	O
"''"	pointer
,	O
2	int
)	O
)	O
{	O
p	pointer
=	O
q	pointer
+	O
2	int
;	O
ADD3	O
(	O
"\xE2\x80\x9D"	pointer
)	O
;	O
}	O
else	O
{	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
ADD3	O
(	O
"\xE2\x80\x99"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
new	pointer
[	O
new_len	int
]	O
=	O
'\0'	O
;	O
return	O
new	pointer
;	O
}	O
void	O
xs_parse_texi_regex	function
(	O
SV	struct
*	O
text_in	pointer
,	O
char	O
*	O
*	O
at_command	pointer
,	O
char	O
*	O
*	O
open_brace	pointer
,	O
char	O
*	O
*	O
asterisk	pointer
,	O
char	O
*	O
*	O
single_letter_command	pointer
,	O
char	O
*	O
*	O
separator_match	pointer
,	O
char	O
*	O
*	O
new_text	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
dTHX	O
;	O
if	O
(	O
!	O
SvUTF8	O
(	O
text_in	pointer
)	O
)	O
sv_utf8_upgrade	O
(	O
text_in	pointer
)	O
;	O
text	pointer
=	O
SvPV_nolen	O
(	O
text_in	pointer
)	O
;	O
*	O
at_command	pointer
=	O
*	O
open_brace	pointer
=	O
*	O
asterisk	pointer
=	O
*	O
single_letter_command	pointer
=	O
*	O
separator_match	pointer
=	O
*	O
new_text	pointer
=	O
0	int
;	O
if	O
(	O
*	O
text	pointer
==	O
'@'	O
&&	O
isalnum	function
(	O
text	pointer
[	O
1	int
]	O
)	O
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
static	O
char	O
*	O
s	pointer
;	O
p	pointer
=	O
text	pointer
+	O
1	int
;	O
q	pointer
=	O
text	pointer
+	O
2	int
;	O
while	O
(	O
isalnum	function
(	O
*	O
q	pointer
)	O
||	O
*	O
q	pointer
==	O
'-'	O
||	O
*	O
q	pointer
==	O
'_'	O
)	O
q	pointer
++	O
;	O
s	pointer
=	O
realloc	function
(	O
s	pointer
,	O
q	pointer
-	O
p	pointer
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
p	pointer
,	O
q	pointer
-	O
p	pointer
)	O
;	O
s	pointer
[	O
q	pointer
-	O
p	pointer
]	O
=	O
'\0'	O
;	O
*	O
at_command	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
if	O
(	O
*	O
text	pointer
==	O
'{'	O
)	O
{	O
*	O
open_brace	pointer
=	O
"{"	pointer
;	O
*	O
separator_match	pointer
=	O
"{"	pointer
;	O
}	O
else	O
if	O
(	O
*	O
text	pointer
==	O
'@'	O
&&	O
text	pointer
[	O
1	int
]	O
&&	O
strchr	function
(	O
"([\"'~@&}{,.!?"	pointer
" \t\n"	pointer
"*-^`=:|/\\"	pointer
,	O
text	pointer
[	O
1	int
]	O
)	O
)	O
{	O
static	O
char	O
a	pointer
[	O
2	int
]	O
;	O
*	O
single_letter_command	pointer
=	O
a	pointer
;	O
a	pointer
[	O
0	int
]	O
=	O
text	pointer
[	O
1	int
]	O
;	O
a	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"{}@,:\t.\f"	pointer
,	O
*	O
text	pointer
)	O
)	O
{	O
static	O
char	O
a	pointer
[	O
2	int
]	O
;	O
*	O
separator_match	pointer
=	O
a	pointer
;	O
a	pointer
[	O
0	int
]	O
=	O
*	O
text	pointer
;	O
a	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
*	O
text	pointer
==	O
'*'	O
)	O
*	O
asterisk	pointer
=	O
"*"	pointer
;	O
p	pointer
=	O
text	pointer
;	O
p	pointer
+=	O
strcspn	function
(	O
p	pointer
,	O
"{}@,:\t.\n\f"	pointer
)	O
;	O
if	O
(	O
p	pointer
>	O
text	pointer
)	O
{	O
static	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
realloc	function
(	O
s	pointer
,	O
p	pointer
-	O
text	pointer
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
text	pointer
,	O
p	pointer
-	O
text	pointer
)	O
;	O
s	pointer
[	O
p	pointer
-	O
text	pointer
]	O
=	O
'\0'	O
;	O
*	O
new_text	pointer
=	O
s	pointer
;	O
}	O
}	O
}	O
return	O
;	O
}	O
