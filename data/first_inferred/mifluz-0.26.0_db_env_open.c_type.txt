static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: env_open.c,v 1.4 2014/04/17 20:27:28 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__dbenv_config	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
const	O
char	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__dbenv_refresh	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_home	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
const	O
char	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_parse	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_tmp_open	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
u_int32_t	int
,	O
char	O
*	O
,	O
DB_FH	struct
*	O
)	O
)	O
;	O
char	O
*	O
CDB_db_version	function
(	O
majverp	pointer
,	O
minverp	pointer
,	O
patchp	pointer
)	O
int	O
*	O
majverp	pointer
,	O
*	O
minverp	pointer
,	O
*	O
patchp	pointer
;	O
{	O
if	O
(	O
majverp	pointer
!=	O
NULL	O
)	O
*	O
majverp	pointer
=	O
DB_VERSION_MAJOR	int
;	O
if	O
(	O
minverp	pointer
!=	O
NULL	O
)	O
*	O
minverp	pointer
=	O
DB_VERSION_MINOR	int
;	O
if	O
(	O
patchp	pointer
!=	O
NULL	O
)	O
*	O
patchp	pointer
=	O
DB_VERSION_PATCH	int
;	O
return	O
(	O
(	O
char	O
*	O
)	O
DB_VERSION_STRING	pointer
)	O
;	O
}	O
int	O
CDB___dbenv_open	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
,	O
mode	enum
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
db_home	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
;	O
{	O
DB_ENV	struct
*	O
rm_dbenv	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DBENV->open"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_INIT_CDB	int
)	O
&&	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DBENV->open"	pointer
,	O
flags	int
,	O
OKFLAGS_CDB	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fcchk	function
(	O
dbenv	pointer
,	O
"DBENV->open"	pointer
,	O
flags	int
,	O
DB_PRIVATE	int
,	O
DB_SYSTEM_MEM	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RECOVER	int
|	O
DB_RECOVER_FATAL	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_db_env_create	function
(	O
&	O
rm_dbenv	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbenv	pointer
->	O
remove	function
(	O
rm_dbenv	pointer
,	O
db_home	pointer
,	O
DB_FORCE	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__dbenv_config	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_CREATE	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_LOCKDOWN	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_LOCKDOWN	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_NOMMAP	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_NOMMAP	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_PRIVATE	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_PRIVATE	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_SYSTEM_MEM	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_SYSTEM_MEM	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_THREAD	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TXN_NOSYNC	int
)	O
)	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_TXN_NOSYNC	int
)	O
;	O
dbenv	pointer
->	O
db_mode	int
=	O
mode	enum
==	O
0	int
?	O
CDB___db_omode	function
(	O
"rwrw--"	pointer
)	O
:	O
mode	enum
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_INIT_CDB	int
)	O
)	O
{	O
LF_SET	O
(	O
DB_INIT_LOCK	int
)	O
;	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_CDB	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_e_attach	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_INIT_MPOOL	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_open	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_INIT_LOG	int
|	O
DB_INIT_TXN	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_open	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_INIT_LOCK	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_open	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_INIT_TXN	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___txn_open	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___crdel_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___txn_init_recover	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
dbenv	pointer
->	O
db_recovery_init	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
dbenv	pointer
->	O
db_recovery_init	pointer
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RECOVER	int
|	O
DB_RECOVER_FATAL	int
)	O
&&	O
(	O
ret	int
=	O
CDB___db_apprec	function
(	O
dbenv	pointer
,	O
LF_ISSET	O
(	O
DB_RECOVER	int
|	O
DB_RECOVER_FATAL	int
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
(	O
void	O
)	O
__dbenv_refresh	function
(	O
dbenv	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___dbenv_remove	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
db_home	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
int	O
ret	int
,	O
t_ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DBENV->remove"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__dbenv_config	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ret	int
=	O
CDB___db_e_remove	function
(	O
dbenv	pointer
,	O
LF_ISSET	O
(	O
DB_FORCE	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
__dbenv_refresh	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
memset	function
(	O
dbenv	pointer
,	O
CLEAR_BYTE	int
,	O
sizeof	O
(	O
DB_ENV	struct
)	O
)	O
;	O
CDB___os_free	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
DB_ENV	struct
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__dbenv_config	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
db_home	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
FILE	struct
*	O
fp	pointer
;	O
int	O
ret	int
;	O
char	O
*	O
lp	pointer
,	O
buf	pointer
[	O
MAXPATHLEN	int
*	O
2	int
]	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_home	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
dbenv	pointer
->	O
db_home	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strlen	function
(	O
dbenv	pointer
->	O
db_home	pointer
)	O
+	O
strlen	function
(	O
CONFIG_NAME	pointer
)	O
+	O
1	int
>	O
sizeof	O
(	O
buf	pointer
)	O
)	O
{	O
ret	int
=	O
ENAMETOOLONG	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
(	O
void	O
)	O
strcpy	function
(	O
buf	pointer
,	O
dbenv	pointer
->	O
db_home	pointer
)	O
;	O
(	O
void	O
)	O
strcat	function
(	O
buf	pointer
,	O
CONFIG_NAME	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
buf	pointer
,	O
"r"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
lp	pointer
=	O
strchr	function
(	O
buf	pointer
,	O
'\n'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: line too long"	pointer
,	O
CONFIG_NAME	pointer
)	O
;	O
(	O
void	O
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
*	O
lp	pointer
=	O
'\0'	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
buf	pointer
[	O
0	int
]	O
==	O
'#'	O
||	O
isspace	function
(	O
(	O
int	O
)	O
buf	pointer
[	O
0	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_parse	function
(	O
dbenv	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
(	O
void	O
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
}	O
if	O
(	O
dbenv	pointer
->	O
db_tmp_dir	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___os_tmpdir	function
(	O
dbenv	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
*	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
,	O
&	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbenv	pointer
->	O
lockfhp	pointer
->	O
fd	pointer
=	O
-	O
1	int
;	O
F_SET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___dbenv_close	function
(	O
dbenv	pointer
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
flags	int
)	O
{	O
}	O
int	O
ret	int
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ret	int
=	O
__dbenv_refresh	function
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_USER_ALLOC	int
)	O
)	O
{	O
memset	function
(	O
dbenv	pointer
,	O
CLEAR_BYTE	int
,	O
sizeof	O
(	O
DB_ENV	struct
)	O
)	O
;	O
CDB___os_free	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
DB_ENV	struct
)	O
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__dbenv_refresh	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
int	O
ret	int
,	O
t_ret	int
;	O
char	O
*	O
*	O
p	pointer
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___txn_close	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___lock_close	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
CDB___lock_dbenv_close	function
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___log_close	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
MPOOL_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___memp_close	function
(	O
dbenv	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
dbenv	pointer
->	O
reginfo	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_e_detach	function
(	O
dbenv	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
dbenv	pointer
->	O
db_panic	int
=	O
0	int
;	O
if	O
(	O
dbenv	pointer
->	O
db_home	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_freestr	function
(	O
dbenv	pointer
->	O
db_home	pointer
)	O
;	O
dbenv	pointer
->	O
db_home	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dbenv	pointer
->	O
db_log_dir	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_freestr	function
(	O
dbenv	pointer
->	O
db_log_dir	pointer
)	O
;	O
dbenv	pointer
->	O
db_log_dir	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dbenv	pointer
->	O
db_tmp_dir	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_freestr	function
(	O
dbenv	pointer
->	O
db_tmp_dir	pointer
)	O
;	O
dbenv	pointer
->	O
db_tmp_dir	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dbenv	pointer
->	O
db_data_dir	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
p	pointer
=	O
dbenv	pointer
->	O
db_data_dir	pointer
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
++	O
p	pointer
)	O
CDB___os_freestr	function
(	O
*	O
p	pointer
)	O
;	O
CDB___os_free	function
(	O
dbenv	pointer
->	O
db_data_dir	pointer
,	O
dbenv	pointer
->	O
data_cnt	int
*	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
dbenv	pointer
->	O
db_data_dir	pointer
=	O
NULL	O
;	O
}	O
dbenv	pointer
->	O
data_cnt	int
=	O
dbenv	pointer
->	O
data_next	int
=	O
0	int
;	O
dbenv	pointer
->	O
db_mode	int
=	O
0	int
;	O
if	O
(	O
dbenv	pointer
->	O
lockfhp	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_free	function
(	O
dbenv	pointer
->	O
lockfhp	pointer
,	O
sizeof	O
(	O
*	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
)	O
;	O
dbenv	pointer
->	O
lockfhp	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dbenv	pointer
->	O
dtab	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_free	function
(	O
dbenv	pointer
->	O
dtab	pointer
,	O
dbenv	pointer
->	O
dtab_size	long
*	O
sizeof	O
(	O
dbenv	pointer
->	O
dtab	pointer
[	O
0	int
]	O
)	O
)	O
;	O
dbenv	pointer
->	O
dtab	pointer
=	O
NULL	O
;	O
dbenv	pointer
->	O
dtab_size	long
=	O
0	int
;	O
}	O
dbenv	pointer
->	O
mp_mmapsize	long
=	O
0	int
;	O
dbenv	pointer
->	O
links	struct
.	O
tqe_next	pointer
=	O
NULL	O
;	O
dbenv	pointer
->	O
links	struct
.	O
tqe_prev	pointer
=	O
NULL	O
;	O
dbenv	pointer
->	O
xa_rmid	int
=	O
0	int
;	O
dbenv	pointer
->	O
xa_txn	pointer
=	O
0	int
;	O
F_CLR	O
(	O
dbenv	pointer
,	O
~	O
(	O
DB_ENV_STANDALONE	int
|	O
DB_ENV_USER_ALLOC	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
appname	enum
,	O
dir	pointer
,	O
file	int
,	O
tmp_oflags	int
,	O
fhp	pointer
,	O
namep	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
APPNAME	enum
appname	enum
;	O
const	O
char	O
*	O
dir	pointer
,	O
*	O
file	int
;	O
u_int32_t	int
tmp_oflags	int
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
char	O
*	O
*	O
namep	pointer
;	O
{	O
DB_ENV	struct
etmp	struct
;	O
size_t	long
len	short
,	O
str_len	long
;	O
int	O
data_entry	int
,	O
ret	int
,	O
slash	int
,	O
tmp_create	int
,	O
tmp_free	int
;	O
const	O
char	O
*	O
a	pointer
,	O
*	O
b	pointer
,	O
*	O
c	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
str	pointer
;	O
a	pointer
=	O
b	pointer
=	O
c	pointer
=	O
NULL	O
;	O
data_entry	int
=	O
-	O
1	int
;	O
tmp_create	int
=	O
tmp_free	int
=	O
0	int
;	O
if	O
(	O
fhp	pointer
!=	O
NULL	O
)	O
F_CLR	O
(	O
fhp	pointer
,	O
DB_FH_VALID	int
)	O
;	O
if	O
(	O
namep	pointer
!=	O
NULL	O
)	O
*	O
namep	pointer
=	O
NULL	O
;	O
if	O
(	O
file	int
!=	O
NULL	O
&&	O
CDB___os_abspath	function
(	O
file	int
)	O
)	O
return	O
(	O
CDB___os_strdup	function
(	O
dbenv	pointer
,	O
file	int
,	O
namep	pointer
)	O
)	O
;	O
if	O
(	O
dir	pointer
!=	O
NULL	O
&&	O
CDB___os_abspath	function
(	O
dir	pointer
)	O
)	O
{	O
a	pointer
=	O
dir	pointer
;	O
goto	O
done	O
;	O
}	O
retry	O
:	O
switch	O
(	O
appname	enum
)	O
{	O
case	O
DB_APP_NONE	int
:	O
if	O
(	O
dbenv	pointer
==	O
NULL	O
||	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
{	O
if	O
(	O
dir	pointer
==	O
NULL	O
)	O
goto	O
tmp	O
;	O
a	pointer
=	O
dir	pointer
;	O
}	O
else	O
{	O
a	pointer
=	O
dbenv	pointer
->	O
db_home	pointer
;	O
b	pointer
=	O
dir	pointer
;	O
}	O
break	O
;	O
case	O
DB_APP_DATA	int
:	O
if	O
(	O
dir	pointer
!=	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"DB_APP_DATA: illegal directory specification"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
file	int
==	O
NULL	O
)	O
{	O
tmp_create	int
=	O
1	int
;	O
goto	O
tmp	O
;	O
}	O
if	O
(	O
dbenv	pointer
==	O
NULL	O
||	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
a	pointer
=	O
PATH_DOT	pointer
;	O
else	O
{	O
a	pointer
=	O
dbenv	pointer
->	O
db_home	pointer
;	O
if	O
(	O
dbenv	pointer
->	O
db_data_dir	pointer
!=	O
NULL	O
&&	O
(	O
b	pointer
=	O
dbenv	pointer
->	O
db_data_dir	pointer
[	O
++	O
data_entry	int
]	O
)	O
==	O
NULL	O
)	O
{	O
data_entry	int
=	O
-	O
1	int
;	O
b	pointer
=	O
dbenv	pointer
->	O
db_data_dir	pointer
[	O
0	int
]	O
;	O
}	O
}	O
break	O
;	O
case	O
DB_APP_LOG	int
:	O
if	O
(	O
dbenv	pointer
==	O
NULL	O
||	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
{	O
if	O
(	O
dir	pointer
==	O
NULL	O
)	O
goto	O
tmp	O
;	O
a	pointer
=	O
dir	pointer
;	O
}	O
else	O
{	O
a	pointer
=	O
dbenv	pointer
->	O
db_home	pointer
;	O
b	pointer
=	O
dbenv	pointer
->	O
db_log_dir	pointer
;	O
c	pointer
=	O
dir	pointer
;	O
}	O
break	O
;	O
case	O
DB_APP_TMP	int
:	O
if	O
(	O
dir	pointer
!=	O
NULL	O
||	O
file	int
!=	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"DB_APP_TMP: illegal directory or file specification"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
tmp_create	int
=	O
1	int
;	O
if	O
(	O
dbenv	pointer
==	O
NULL	O
||	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
goto	O
tmp	O
;	O
else	O
{	O
a	pointer
=	O
dbenv	pointer
->	O
db_home	pointer
;	O
b	pointer
=	O
dbenv	pointer
->	O
db_tmp_dir	pointer
;	O
}	O
break	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
tmp	O
:	O
if	O
(	O
dbenv	pointer
==	O
NULL	O
||	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
{	O
memset	function
(	O
&	O
etmp	struct
,	O
0	int
,	O
sizeof	O
(	O
etmp	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_tmpdir	function
(	O
&	O
etmp	struct
,	O
DB_USE_ENVIRON	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
tmp_free	int
=	O
1	int
;	O
a	pointer
=	O
etmp	struct
.	O
db_tmp_dir	pointer
;	O
}	O
else	O
a	pointer
=	O
dbenv	pointer
->	O
db_tmp_dir	pointer
;	O
}	O
done	O
:	O
len	short
=	O
(	O
a	pointer
==	O
NULL	O
?	O
0	int
:	O
strlen	function
(	O
a	pointer
)	O
+	O
1	int
)	O
+	O
(	O
b	pointer
==	O
NULL	O
?	O
0	int
:	O
strlen	function
(	O
b	pointer
)	O
+	O
1	int
)	O
+	O
(	O
c	pointer
==	O
NULL	O
?	O
0	int
:	O
strlen	function
(	O
c	pointer
)	O
+	O
1	int
)	O
+	O
(	O
file	int
==	O
NULL	O
?	O
0	int
:	O
strlen	function
(	O
file	int
)	O
+	O
1	int
)	O
;	O
str_len	long
=	O
len	short
+	O
sizeof	O
(	O
DB_TRAIL	pointer
)	O
+	O
10	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
str_len	long
,	O
NULL	O
,	O
&	O
str	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
tmp_free	int
)	O
CDB___os_freestr	function
(	O
etmp	struct
.	O
db_tmp_dir	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
slash	int
=	O
0	int
;	O
p	pointer
=	O
str	pointer
;	O
DB_ADDSTR	O
(	O
a	pointer
)	O
;	O
DB_ADDSTR	O
(	O
b	pointer
)	O
;	O
DB_ADDSTR	O
(	O
file	int
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
tmp_free	int
)	O
{	O
CDB___os_freestr	function
(	O
etmp	struct
.	O
db_tmp_dir	pointer
)	O
;	O
tmp_free	int
=	O
0	int
;	O
}	O
if	O
(	O
data_entry	int
!=	O
-	O
1	int
&&	O
CDB___os_exists	function
(	O
str	pointer
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_free	function
(	O
str	pointer
,	O
str_len	long
)	O
;	O
a	pointer
=	O
b	pointer
=	O
c	pointer
=	O
NULL	O
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
tmp_create	int
&&	O
(	O
ret	int
=	O
__db_tmp_open	function
(	O
dbenv	pointer
,	O
tmp_oflags	int
,	O
str	pointer
,	O
fhp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_free	function
(	O
str	pointer
,	O
str_len	long
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
namep	pointer
==	O
NULL	O
)	O
CDB___os_free	function
(	O
str	pointer
,	O
str_len	long
)	O
;	O
else	O
*	O
namep	pointer
=	O
str	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_home	function
(	O
dbenv	pointer
,	O
db_home	pointer
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
db_home	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
db_home	pointer
)	O
==	O
NULL	O
&&	O
(	O
LF_ISSET	O
(	O
DB_USE_ENVIRON	int
)	O
||	O
(	O
LF_ISSET	O
(	O
DB_USE_ENVIRON_ROOT	int
)	O
&&	O
CDB___os_isroot	function
(	O
)	O
==	O
0	int
)	O
)	O
&&	O
(	O
p	pointer
=	O
getenv	function
(	O
"DB_HOME"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
p	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"illegal DB_HOME environment variable"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
p	pointer
==	O
NULL	O
?	O
0	int
:	O
CDB___os_strdup	function
(	O
dbenv	pointer
,	O
p	pointer
,	O
&	O
dbenv	pointer
->	O
db_home	pointer
)	O
)	O
;	O
}	O
static	O
int	O
__db_parse	function
(	O
dbenv	pointer
,	O
s	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
char	O
*	O
s	pointer
;	O
{	O
u_long	long
v1	long
,	O
v2	long
,	O
v3	long
;	O
u_int32_t	int
flags	int
;	O
char	O
*	O
name	pointer
,	O
*	O
p	pointer
,	O
*	O
value	pointer
,	O
v4	char
;	O
char	O
arg	array
[	O
40	int
]	O
;	O
name	pointer
=	O
s	pointer
;	O
for	O
(	O
p	pointer
=	O
name	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
&&	O
!	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
;	O
++	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
||	O
p	pointer
==	O
name	pointer
)	O
goto	O
illegal	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
for	O
(	O
++	O
p	pointer
;	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
;	O
++	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
goto	O
illegal	O
;	O
value	pointer
=	O
p	pointer
;	O
for	O
(	O
++	O
p	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
++	O
p	pointer
)	O
;	O
for	O
(	O
--	O
p	pointer
;	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
;	O
--	O
p	pointer
)	O
;	O
++	O
p	pointer
;	O
if	O
(	O
p	pointer
==	O
value	pointer
)	O
{	O
illegal	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"mis-formatted name-value pair: %s"	pointer
,	O
s	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_cachesize"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %lu %lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v2	long
,	O
&	O
v3	long
,	O
&	O
v4	char
)	O
!=	O
3	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_cachesize	pointer
(	O
dbenv	pointer
,	O
v1	long
,	O
v2	long
,	O
v3	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_data_dir"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"db_data_dir"	pointer
)	O
)	O
return	O
(	O
dbenv	pointer
->	O
set_data_dir	pointer
(	O
dbenv	pointer
,	O
value	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_lg_bsize"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_lg_bsize	pointer
(	O
dbenv	pointer
,	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_lg_max"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_lg_max	pointer
(	O
dbenv	pointer
,	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_lg_dir"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"db_log_dir"	pointer
)	O
)	O
return	O
(	O
dbenv	pointer
->	O
set_lg_dir	pointer
(	O
dbenv	pointer
,	O
value	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_lk_detect"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%40s %c"	pointer
,	O
arg	array
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_lock_default"	pointer
)	O
)	O
flags	int
=	O
DB_LOCK_DEFAULT	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_lock_oldest"	pointer
)	O
)	O
flags	int
=	O
DB_LOCK_OLDEST	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_lock_random"	pointer
)	O
)	O
flags	int
=	O
DB_LOCK_RANDOM	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_lock_youngest"	pointer
)	O
)	O
flags	int
=	O
DB_LOCK_YOUNGEST	int
;	O
else	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_lk_detect	pointer
(	O
dbenv	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_lk_max"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_lk_max	pointer
(	O
dbenv	pointer
,	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_mp_mmapsize"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_mp_mmapsize	pointer
(	O
dbenv	pointer
,	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_region_init"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
||	O
v1	long
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
CDB_db_env_set_region_init	function
(	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_shm_key"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_shm_key	pointer
(	O
dbenv	pointer
,	O
(	O
long	O
)	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_tas_spins"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
CDB_db_env_set_tas_spins	function
(	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_tmp_dir"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"db_tmp_dir"	pointer
)	O
)	O
return	O
(	O
dbenv	pointer
->	O
set_tmp_dir	pointer
(	O
dbenv	pointer
,	O
value	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_tx_max"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%lu %c"	pointer
,	O
&	O
v1	long
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_tx_max	pointer
(	O
dbenv	pointer
,	O
v1	long
)	O
)	O
;	O
}	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"set_verbose"	pointer
)	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
"%40s %c"	pointer
,	O
arg	array
,	O
&	O
v4	char
)	O
!=	O
1	int
)	O
goto	O
badarg	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_verb_chkpoint"	pointer
)	O
)	O
flags	int
=	O
DB_VERB_CHKPOINT	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_verb_deadlock"	pointer
)	O
)	O
flags	int
=	O
DB_VERB_DEADLOCK	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_verb_recovery"	pointer
)	O
)	O
flags	int
=	O
DB_VERB_RECOVERY	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
value	pointer
,	O
"db_verb_waitsfor"	pointer
)	O
)	O
flags	int
=	O
DB_VERB_WAITSFOR	int
;	O
else	O
goto	O
badarg	O
;	O
return	O
(	O
dbenv	pointer
->	O
set_verbose	pointer
(	O
dbenv	pointer
,	O
flags	int
,	O
1	int
)	O
)	O
;	O
}	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"unrecognized name-value pair: %s"	pointer
,	O
s	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
badarg	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"incorrect arguments for name-value pair: %s"	pointer
,	O
s	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
static	O
int	O
__db_tmp_open	function
(	O
dbenv	pointer
,	O
tmp_oflags	int
,	O
path	pointer
,	O
fhp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
tmp_oflags	int
;	O
char	O
*	O
path	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
{	O
u_long	long
pid	long
;	O
int	O
mode	enum
,	O
isdir	int
,	O
ret	int
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
trv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_exists	function
(	O
path	pointer
,	O
&	O
isdir	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
path	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
!	O
isdir	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
path	pointer
,	O
CDB_db_strerror	function
(	O
EINVAL	int
)	O
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
for	O
(	O
trv	pointer
=	O
path	pointer
;	O
*	O
trv	pointer
!=	O
'\0'	O
;	O
++	O
trv	pointer
)	O
;	O
*	O
trv	pointer
=	O
PATH_SEPARATOR	pointer
[	O
0	int
]	O
;	O
for	O
(	O
p	pointer
=	O
DB_TRAIL	pointer
;	O
(	O
*	O
++	O
trv	pointer
=	O
*	O
p	pointer
)	O
!=	O
'\0'	O
;	O
++	O
p	pointer
)	O
;	O
for	O
(	O
pid	long
=	O
getpid	function
(	O
)	O
;	O
*	O
--	O
trv	pointer
==	O
'X'	O
;	O
pid	long
/=	O
10	int
)	O
switch	O
(	O
pid	long
%	O
10	int
)	O
{	O
case	O
0	int
:	O
*	O
trv	pointer
=	O
'0'	O
;	O
break	O
;	O
case	O
1	int
:	O
*	O
trv	pointer
=	O
'1'	O
;	O
break	O
;	O
case	O
2	int
:	O
*	O
trv	pointer
=	O
'2'	O
;	O
break	O
;	O
case	O
3	int
:	O
*	O
trv	pointer
=	O
'3'	O
;	O
break	O
;	O
case	O
4	int
:	O
*	O
trv	pointer
=	O
'4'	O
;	O
break	O
;	O
case	O
5	int
:	O
*	O
trv	pointer
=	O
'5'	O
;	O
break	O
;	O
case	O
6	int
:	O
*	O
trv	pointer
=	O
'6'	O
;	O
break	O
;	O
case	O
7	int
:	O
*	O
trv	pointer
=	O
'7'	O
;	O
break	O
;	O
case	O
8	int
:	O
*	O
trv	pointer
=	O
'8'	O
;	O
break	O
;	O
case	O
9	int
:	O
*	O
trv	pointer
=	O
'9'	O
;	O
break	O
;	O
}	O
++	O
trv	pointer
;	O
mode	enum
=	O
CDB___db_omode	function
(	O
"rw----"	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
path	pointer
,	O
tmp_oflags	int
|	O
DB_OSO_CREATE	int
|	O
DB_OSO_EXCL	int
,	O
mode	enum
,	O
fhp	pointer
)	O
)	O
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
ret	int
!=	O
EEXIST	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"tmp_open: %s: %s"	pointer
,	O
path	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
trv	pointer
==	O
'\0'	O
)	O
return	O
(	O
EINVAL	int
)	O
;	O
if	O
(	O
*	O
trv	pointer
==	O
'z'	O
)	O
*	O
trv	pointer
++	O
=	O
'a'	O
;	O
else	O
{	O
if	O
(	O
isdigit	function
(	O
(	O
int	O
)	O
*	O
trv	pointer
)	O
)	O
*	O
trv	pointer
=	O
'a'	O
;	O
else	O
++	O
*	O
trv	pointer
;	O
break	O
;	O
}	O
}	O
}	O
}	O
