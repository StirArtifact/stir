struct	O
debug_option_assoc	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
val	array
;	O
char	O
*	O
docstring	pointer
;	O
}	O
;	O
static	O
struct	O
debug_option_assoc	struct
debugassoc	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
DebugHelp	int
,	O
"Explain the various -D options"	pointer
}	O
,	O
{	O
"tree"	pointer
,	O
DebugExpressionTree	int
,	O
"Display the expression tree"	pointer
}	O
,	O
{	O
"search"	pointer
,	O
DebugSearch	int
,	O
"Navigate the directory tree verbosely"	pointer
}	O
,	O
{	O
"stat"	pointer
,	O
DebugStat	int
,	O
"Trace calls to stat(2) and lstat(2)"	pointer
}	O
,	O
{	O
"rates"	pointer
,	O
DebugSuccessRates	int
,	O
"Indicate how often each predicate succeeded"	pointer
}	O
,	O
{	O
"opt"	pointer
,	O
DebugExpressionTree	int
|	O
DebugTreeOpt	int
,	O
"Show diagnostic information relating to optimisation"	pointer
}	O
,	O
{	O
"exec"	pointer
,	O
DebugExec	int
,	O
"Show diagnostic information relating to -exec, -execdir, -ok and -okdir"	pointer
}	O
}	O
;	O
struct	O
predicate	struct
*	O
insert_primary_withpred	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
PRED_FUNC	pointer
pred_func	pointer
,	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
struct	O
predicate	struct
*	O
new_pred	pointer
;	O
new_pred	pointer
=	O
get_new_pred_chk_op	function
(	O
entry	pointer
,	O
arg	pointer
)	O
;	O
new_pred	pointer
->	O
pred_func	pointer
=	O
pred_func	pointer
;	O
new_pred	pointer
->	O
p_name	pointer
=	O
entry	pointer
->	O
parser_name	pointer
;	O
new_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
NULL	O
;	O
new_pred	pointer
->	O
p_type	enum
=	O
PRIMARY_TYPE	int
;	O
new_pred	pointer
->	O
p_prec	enum
=	O
NO_PREC	int
;	O
return	O
new_pred	pointer
;	O
}	O
struct	O
predicate	struct
*	O
insert_primary	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
assert	O
(	O
entry	pointer
->	O
pred_func	pointer
!=	O
NULL	O
)	O
;	O
return	O
insert_primary_withpred	function
(	O
entry	pointer
,	O
entry	pointer
->	O
pred_func	pointer
,	O
arg	pointer
)	O
;	O
}	O
struct	O
predicate	struct
*	O
insert_primary_noarg	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
)	O
{	O
return	O
insert_primary	function
(	O
entry	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
show_valid_debug_options	function
(	O
FILE	struct
*	O
fp	pointer
,	O
int	O
full	int
)	O
{	O
size_t	long
i	int
;	O
if	O
(	O
full	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"Valid arguments for -D:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
N_DEBUGASSOC	O
;	O
++	O
i	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%-10s %s\n"	pointer
,	O
debugassoc	array
[	O
i	int
]	O
.	O
name	pointer
,	O
debugassoc	array
[	O
i	int
]	O
.	O
docstring	pointer
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
N_DEBUGASSOC	O
;	O
++	O
i	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s%s"	pointer
,	O
(	O
i	int
>	O
0	int
?	O
"|"	pointer
:	O
""	pointer
)	O
,	O
debugassoc	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
}	O
}	O
}	O
void	O
usage	function
(	O
FILE	struct
*	O
fp	pointer
,	O
int	O
status	int
,	O
char	O
*	O
msg	pointer
)	O
{	O
if	O
(	O
msg	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s: %s\n"	pointer
,	O
program_name	pointer
,	O
msg	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"Usage: %s [-H] [-L] [-P] [-Olevel] [-D "	pointer
)	O
,	O
program_name	pointer
)	O
;	O
show_valid_debug_options	function
(	O
fp	pointer
,	O
0	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"] [path...] [expression]\n"	pointer
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
status	int
)	O
exit	function
(	O
status	int
)	O
;	O
}	O
void	O
set_stat_placeholders	function
(	O
struct	O
stat	struct
*	O
p	pointer
)	O
{	O
(	O
void	O
)	O
p	pointer
;	O
}	O
int	O
get_statinfo	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
state	pointer
.	O
have_stat	bool
)	O
{	O
set_stat_placeholders	function
(	O
p	pointer
)	O
;	O
if	O
(	O
0	int
==	O
(	O
*	O
options	struct
.	O
xstat	pointer
)	O
(	O
name	pointer
,	O
p	pointer
)	O
)	O
{	O
if	O
(	O
00000	int
==	O
p	pointer
->	O
st_mode	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"WARNING: file %s appears to have mode 0000"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
name	pointer
)	O
)	O
;	O
error_severity	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
options	struct
.	O
ignore_readdir_race	bool
||	O
(	O
errno	O
!=	O
ENOENT	int
)	O
)	O
{	O
nonfatal_target_file_error	function
(	O
errno	O
,	O
pathname	pointer
)	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
state	pointer
.	O
have_stat	bool
=	O
true	int
;	O
state	pointer
.	O
have_type	bool
=	O
true	int
;	O
state	pointer
.	O
type	enum
=	O
p	pointer
->	O
st_mode	int
;	O
return	O
0	int
;	O
}	O
int	O
get_info	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
,	O
struct	O
predicate	struct
*	O
pred_ptr	pointer
)	O
{	O
bool	bool
todo	int
=	O
false	int
;	O
if	O
(	O
pred_ptr	pointer
->	O
need_stat	bool
)	O
{	O
todo	int
=	O
true	int
;	O
}	O
else	O
if	O
(	O
pred_ptr	pointer
->	O
need_type	bool
&&	O
!	O
state	pointer
.	O
have_type	bool
)	O
{	O
todo	int
=	O
true	int
;	O
}	O
else	O
if	O
(	O
pred_ptr	pointer
->	O
need_inum	bool
)	O
{	O
if	O
(	O
!	O
p	pointer
->	O
st_ino	long
)	O
{	O
todo	int
=	O
true	int
;	O
}	O
else	O
if	O
(	O
(	O
!	O
state	pointer
.	O
have_type	bool
)	O
||	O
S_ISDIR	O
(	O
p	pointer
->	O
st_mode	int
)	O
)	O
{	O
todo	int
=	O
true	int
;	O
}	O
}	O
if	O
(	O
todo	int
)	O
{	O
int	O
result	pointer
=	O
get_statinfo	function
(	O
pathname	pointer
,	O
state	pointer
.	O
rel_pathname	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
result	pointer
!=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
pred_ptr	pointer
->	O
need_type	bool
)	O
{	O
assert	O
(	O
state	pointer
.	O
have_type	bool
)	O
;	O
}	O
if	O
(	O
pred_ptr	pointer
->	O
need_inum	bool
)	O
{	O
assert	O
(	O
p	pointer
->	O
st_ino	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
bool	bool
check_nofollow	function
(	O
void	O
)	O
{	O
struct	O
utsname	struct
uts	struct
;	O
float	O
release	array
;	O
if	O
(	O
0	int
==	O
O_NOFOLLOW	O
)	O
{	O
return	O
false	int
;	O
}	O
if	O
(	O
0	int
==	O
uname	function
(	O
&	O
uts	struct
)	O
)	O
{	O
double	O
(	O
*	O
conversion	pointer
)	O
(	O
const	O
char	O
*	O
)	O
=	O
atof	function
;	O
release	array
=	O
conversion	pointer
(	O
uts	struct
.	O
release	array
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"Linux"	pointer
,	O
uts	struct
.	O
sysname	array
)	O
)	O
{	O
return	O
release	array
>=	O
2.2	int
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"FreeBSD"	pointer
,	O
uts	struct
.	O
sysname	array
)	O
)	O
{	O
return	O
release	array
>=	O
3.1	int
;	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
int	O
exec_cb	function
(	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
exec_val	struct
*	O
execp	pointer
=	O
context	pointer
;	O
bc_do_exec	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
do_exec	function
(	O
struct	O
exec_val	struct
*	O
execp	pointer
)	O
{	O
run_in_dir	function
(	O
execp	pointer
->	O
wd_for_exec	pointer
,	O
exec_cb	function
,	O
execp	pointer
)	O
;	O
if	O
(	O
execp	pointer
->	O
wd_for_exec	pointer
!=	O
initial_wd	pointer
)	O
{	O
free_cwd	function
(	O
execp	pointer
->	O
wd_for_exec	pointer
)	O
;	O
free	function
(	O
execp	pointer
->	O
wd_for_exec	pointer
)	O
;	O
execp	pointer
->	O
wd_for_exec	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
do_complete_pending_execdirs	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
p	pointer
)	O
return	O
;	O
assert	O
(	O
state	pointer
.	O
execdirs_outstanding	bool
)	O
;	O
do_complete_pending_execdirs	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_execdir	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_okdir	function
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
)	O
{	O
struct	O
exec_val	struct
*	O
execp	pointer
=	O
&	O
p	pointer
->	O
args	union
.	O
exec_vec	struct
;	O
if	O
(	O
execp	pointer
->	O
state	pointer
.	O
todo	int
)	O
{	O
do_exec	function
(	O
execp	pointer
)	O
;	O
}	O
}	O
}	O
do_complete_pending_execdirs	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
}	O
void	O
complete_pending_execdirs	function
(	O
void	O
)	O
{	O
if	O
(	O
state	pointer
.	O
execdirs_outstanding	bool
)	O
{	O
do_complete_pending_execdirs	function
(	O
get_eval_tree	function
(	O
)	O
)	O
;	O
state	pointer
.	O
execdirs_outstanding	bool
=	O
false	int
;	O
}	O
}	O
void	O
complete_pending_execs	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
p	pointer
)	O
return	O
;	O
complete_pending_execs	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_exec	function
)	O
&&	O
p	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
)	O
{	O
struct	O
exec_val	struct
*	O
execp	pointer
=	O
&	O
p	pointer
->	O
args	union
.	O
exec_vec	struct
;	O
if	O
(	O
execp	pointer
->	O
state	pointer
.	O
todo	int
)	O
{	O
bc_do_exec	function
(	O
&	O
execp	pointer
->	O
ctl	pointer
,	O
&	O
execp	pointer
->	O
state	pointer
)	O
;	O
}	O
}	O
complete_pending_execs	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
}	O
void	O
record_initial_cwd	function
(	O
void	O
)	O
{	O
initial_wd	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
initial_wd	pointer
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
save_cwd	function
(	O
initial_wd	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to save initial working directory%s%s"	pointer
)	O
,	O
(	O
initial_wd	pointer
->	O
desc	int
<	O
0	int
&&	O
initial_wd	pointer
->	O
name	pointer
)	O
?	O
": "	pointer
:	O
""	pointer
,	O
(	O
initial_wd	pointer
->	O
desc	int
<	O
0	int
&&	O
initial_wd	pointer
->	O
name	pointer
)	O
?	O
initial_wd	pointer
->	O
name	pointer
:	O
""	pointer
)	O
;	O
}	O
}	O
static	O
void	O
cleanup_initial_cwd	function
(	O
void	O
)	O
{	O
if	O
(	O
0	int
==	O
restore_cwd	function
(	O
initial_wd	pointer
)	O
)	O
{	O
free_cwd	function
(	O
initial_wd	pointer
)	O
;	O
free	function
(	O
initial_wd	pointer
)	O
;	O
initial_wd	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Failed to restore initial working directory%s%s"	pointer
)	O
,	O
(	O
initial_wd	pointer
->	O
desc	int
<	O
0	int
&&	O
initial_wd	pointer
->	O
name	pointer
)	O
?	O
": "	pointer
:	O
""	pointer
,	O
(	O
initial_wd	pointer
->	O
desc	int
<	O
0	int
&&	O
initial_wd	pointer
->	O
name	pointer
)	O
?	O
initial_wd	pointer
->	O
name	pointer
:	O
""	pointer
)	O
;	O
_exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
static	O
void	O
traverse_tree	function
(	O
struct	O
predicate	struct
*	O
tree	pointer
,	O
void	O
(	O
*	O
callback	pointer
)	O
(	O
struct	O
predicate	struct
*	O
)	O
)	O
{	O
if	O
(	O
tree	pointer
->	O
pred_left	pointer
)	O
traverse_tree	function
(	O
tree	pointer
->	O
pred_left	pointer
,	O
callback	pointer
)	O
;	O
callback	pointer
(	O
tree	pointer
)	O
;	O
if	O
(	O
tree	pointer
->	O
pred_right	pointer
)	O
traverse_tree	function
(	O
tree	pointer
->	O
pred_right	pointer
,	O
callback	pointer
)	O
;	O
}	O
static	O
void	O
undangle_file_pointers	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_fprint	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_fprintf	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_fls	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_fprint0	function
)	O
)	O
{	O
p	pointer
->	O
args	union
.	O
printf_vec	struct
.	O
stream	pointer
=	O
NULL	O
;	O
}	O
}	O
bool	bool
fd_leak_check_is_enabled	function
(	O
void	O
)	O
{	O
if	O
(	O
getenv	function
(	O
"GNU_FINDUTILS_FD_LEAK_CHECK"	pointer
)	O
)	O
return	O
true	int
;	O
else	O
return	O
false	int
;	O
}	O
void	O
cleanup	function
(	O
void	O
)	O
{	O
struct	O
predicate	struct
*	O
eval_tree	pointer
=	O
get_eval_tree	function
(	O
)	O
;	O
if	O
(	O
eval_tree	pointer
)	O
{	O
traverse_tree	function
(	O
eval_tree	pointer
,	O
complete_pending_execs	function
)	O
;	O
complete_pending_execdirs	function
(	O
)	O
;	O
}	O
sharefile_destroy	function
(	O
state	pointer
.	O
shared_files	pointer
)	O
;	O
if	O
(	O
eval_tree	pointer
)	O
traverse_tree	function
(	O
eval_tree	pointer
,	O
undangle_file_pointers	function
)	O
;	O
cleanup_initial_cwd	function
(	O
)	O
;	O
if	O
(	O
fd_leak_check_is_enabled	function
(	O
)	O
)	O
{	O
complain_about_leaky_fds	function
(	O
)	O
;	O
forget_non_cloexec_fds	function
(	O
)	O
;	O
}	O
if	O
(	O
fflush	function
(	O
stdout	pointer
)	O
==	O
EOF	O
)	O
nonfatal_nontarget_file_error	function
(	O
errno	O
,	O
"standard output"	pointer
)	O
;	O
}	O
static	O
int	O
fallback_stat	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
,	O
int	O
prev_rv	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
ENOENT	int
:	O
case	O
ENOTDIR	int
:	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugStat	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"fallback_stat(): stat(%s) failed; falling back on lstat()\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
fstatat	function
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
name	pointer
,	O
p	pointer
,	O
AT_SYMLINK_NOFOLLOW	int
)	O
;	O
case	O
EACCES	int
:	O
case	O
EIO	int
:	O
case	O
ELOOP	int
:	O
case	O
ENAMETOOLONG	int
:	O
case	O
EOVERFLOW	int
:	O
default	O
:	O
return	O
prev_rv	int
;	O
}	O
}	O
int	O
optionh_stat	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
AT_FDCWD	O
!=	O
state	pointer
.	O
cwd_dir_fd	int
)	O
assert	O
(	O
state	pointer
.	O
cwd_dir_fd	int
>=	O
0	int
)	O
;	O
set_stat_placeholders	function
(	O
p	pointer
)	O
;	O
if	O
(	O
0	int
==	O
state	pointer
.	O
curdepth	int
)	O
{	O
int	O
rv	int
;	O
rv	int
=	O
fstatat	function
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
name	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
0	int
==	O
rv	int
)	O
return	O
0	int
;	O
else	O
return	O
fallback_stat	function
(	O
name	pointer
,	O
p	pointer
,	O
rv	int
)	O
;	O
}	O
else	O
{	O
return	O
fstatat	function
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
name	pointer
,	O
p	pointer
,	O
AT_SYMLINK_NOFOLLOW	int
)	O
;	O
}	O
}	O
int	O
optionl_stat	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
)	O
{	O
int	O
rv	int
;	O
if	O
(	O
AT_FDCWD	O
!=	O
state	pointer
.	O
cwd_dir_fd	int
)	O
assert	O
(	O
state	pointer
.	O
cwd_dir_fd	int
>=	O
0	int
)	O
;	O
set_stat_placeholders	function
(	O
p	pointer
)	O
;	O
rv	int
=	O
fstatat	function
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
name	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
0	int
==	O
rv	int
)	O
return	O
0	int
;	O
else	O
return	O
fallback_stat	function
(	O
name	pointer
,	O
p	pointer
,	O
rv	int
)	O
;	O
}	O
int	O
optionp_stat	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
p	pointer
)	O
{	O
assert	O
(	O
(	O
state	pointer
.	O
cwd_dir_fd	int
>=	O
0	int
)	O
||	O
(	O
state	pointer
.	O
cwd_dir_fd	int
==	O
AT_FDCWD	O
)	O
)	O
;	O
set_stat_placeholders	function
(	O
p	pointer
)	O
;	O
return	O
fstatat	function
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
name	pointer
,	O
p	pointer
,	O
AT_SYMLINK_NOFOLLOW	int
)	O
;	O
}	O
static	O
uintmax_t	long
stat_count	long
=	O
0u	int
;	O
int	O
debug_stat	function
(	O
const	O
char	O
*	O
file	pointer
,	O
struct	O
stat	struct
*	O
bufp	pointer
)	O
{	O
++	O
stat_count	long
;	O
fprintf	function
(	O
stderr	pointer
,	O
"debug_stat (%s)\n"	pointer
,	O
file	pointer
)	O
;	O
switch	O
(	O
options	struct
.	O
symlink_handling	enum
)	O
{	O
case	O
SYMLINK_ALWAYS_DEREF	int
:	O
return	O
optionl_stat	function
(	O
file	pointer
,	O
bufp	pointer
)	O
;	O
case	O
SYMLINK_DEREF_ARGSONLY	int
:	O
return	O
optionh_stat	function
(	O
file	pointer
,	O
bufp	pointer
)	O
;	O
case	O
SYMLINK_NEVER_DEREF	int
:	O
return	O
optionp_stat	function
(	O
file	pointer
,	O
bufp	pointer
)	O
;	O
}	O
assert	O
(	O
0	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
bool	bool
following_links	function
(	O
void	O
)	O
{	O
switch	O
(	O
options	struct
.	O
symlink_handling	enum
)	O
{	O
case	O
SYMLINK_ALWAYS_DEREF	int
:	O
return	O
true	int
;	O
case	O
SYMLINK_DEREF_ARGSONLY	int
:	O
return	O
(	O
state	pointer
.	O
curdepth	int
==	O
0	int
)	O
;	O
case	O
SYMLINK_NEVER_DEREF	int
:	O
default	O
:	O
return	O
false	int
;	O
}	O
}	O
bool	bool
digest_mode	function
(	O
mode_t	int
*	O
mode	int
,	O
const	O
char	O
*	O
pathname	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
pstat	pointer
,	O
bool	bool
leaf	bool
)	O
{	O
if	O
(	O
*	O
mode	int
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
*	O
mode	int
)	O
&&	O
following_links	function
(	O
)	O
)	O
{	O
if	O
(	O
get_statinfo	function
(	O
pathname	pointer
,	O
name	pointer
,	O
pstat	pointer
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
*	O
mode	int
=	O
state	pointer
.	O
type	enum
=	O
pstat	pointer
->	O
st_mode	int
;	O
state	pointer
.	O
have_type	bool
=	O
true	int
;	O
}	O
else	O
{	O
state	pointer
.	O
have_type	bool
=	O
true	int
;	O
pstat	pointer
->	O
st_mode	int
=	O
state	pointer
.	O
type	enum
=	O
*	O
mode	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
leaf	bool
)	O
{	O
state	pointer
.	O
have_stat	bool
=	O
false	int
;	O
state	pointer
.	O
have_type	bool
=	O
false	int
;	O
state	pointer
.	O
type	enum
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
get_statinfo	function
(	O
pathname	pointer
,	O
name	pointer
,	O
pstat	pointer
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
state	pointer
.	O
type	enum
=	O
*	O
mode	int
=	O
pstat	pointer
->	O
st_mode	int
;	O
state	pointer
.	O
have_type	bool
=	O
true	int
;	O
}	O
}	O
return	O
true	int
;	O
}	O
bool	bool
default_prints	function
(	O
struct	O
predicate	struct
*	O
pred	pointer
)	O
{	O
while	O
(	O
pred	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
pred	pointer
->	O
no_default_print	bool
)	O
return	O
(	O
false	int
)	O
;	O
pred	pointer
=	O
pred	pointer
->	O
pred_next	pointer
;	O
}	O
return	O
(	O
true	int
)	O
;	O
}	O
bool	bool
looks_like_expression	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
bool	bool
leading	bool
)	O
{	O
switch	O
(	O
arg	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
arg	pointer
[	O
1	int
]	O
)	O
return	O
true	int
;	O
else	O
return	O
false	int
;	O
break	O
;	O
case	O
')'	O
:	O
case	O
','	O
:	O
if	O
(	O
arg	pointer
[	O
1	int
]	O
)	O
return	O
false	int
;	O
else	O
return	O
!	O
leading	bool
;	O
case	O
'!'	O
:	O
case	O
'('	O
:	O
if	O
(	O
arg	pointer
[	O
1	int
]	O
)	O
return	O
false	int
;	O
else	O
return	O
true	int
;	O
default	O
:	O
return	O
false	int
;	O
}	O
}	O
static	O
void	O
process_debug_options	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
token_context	pointer
=	O
NULL	O
;	O
const	O
char	O
delimiters	array
[	O
]	O
=	O
","	pointer
;	O
bool	bool
empty	bool
=	O
true	int
;	O
size_t	long
i	int
;	O
p	pointer
=	O
strtok_r	function
(	O
arg	pointer
,	O
delimiters	array
,	O
&	O
token_context	pointer
)	O
;	O
while	O
(	O
p	pointer
)	O
{	O
empty	bool
=	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
N_DEBUGASSOC	O
;	O
++	O
i	int
)	O
{	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
debugassoc	array
[	O
i	int
]	O
.	O
name	pointer
,	O
p	pointer
)	O
)	O
{	O
options	struct
.	O
debug_options	long
|=	O
debugassoc	array
[	O
i	int
]	O
.	O
val	array
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
>=	O
N_DEBUGASSOC	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Ignoring unrecognised debug flag %s"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
arg	pointer
)	O
)	O
;	O
}	O
p	pointer
=	O
strtok_r	function
(	O
NULL	O
,	O
delimiters	array
,	O
&	O
token_context	pointer
)	O
;	O
}	O
if	O
(	O
empty	bool
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Empty argument to the -D option."	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugHelp	int
)	O
{	O
show_valid_debug_options	function
(	O
stdout	pointer
,	O
1	int
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
static	O
void	O
process_optimisation_option	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
0	int
==	O
arg	pointer
[	O
0	int
]	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The -O option must be immediately followed by a decimal integer"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
unsigned	O
long	O
opt_level	long
;	O
char	O
*	O
end	pointer
;	O
if	O
(	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
arg	pointer
[	O
0	int
]	O
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Please specify a decimal number immediately after -O"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
int	O
prev_errno	int
=	O
errno	O
;	O
errno	O
=	O
0	int
;	O
opt_level	long
=	O
strtoul	function
(	O
arg	pointer
,	O
&	O
end	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
0	int
==	O
opt_level	long
)	O
&&	O
(	O
end	pointer
==	O
arg	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Please specify a decimal number immediately after -O"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
end	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid optimisation level %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ULONG_MAX	O
==	O
opt_level	long
)	O
&&	O
errno	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Invalid optimisation level %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
opt_level	long
>	O
USHRT_MAX	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Optimisation level %lu is too high.  "	pointer
"If you want to find files very quickly, "	pointer
"consider using GNU locate."	pointer
)	O
,	O
opt_level	long
)	O
;	O
}	O
else	O
{	O
options	struct
.	O
optimisation_level	short
=	O
opt_level	long
;	O
errno	O
=	O
prev_errno	int
;	O
}	O
}	O
}	O
}	O
int	O
process_leading_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
i	int
,	O
end_of_leading_options	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
end_of_leading_options	int
=	O
i	int
)	O
<	O
argc	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"-H"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
)	O
{	O
set_follow_state	function
(	O
SYMLINK_DEREF_ARGSONLY	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"-L"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
)	O
{	O
set_follow_state	function
(	O
SYMLINK_ALWAYS_DEREF	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"-P"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
)	O
{	O
set_follow_state	function
(	O
SYMLINK_NEVER_DEREF	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"--"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
)	O
{	O
end_of_leading_options	int
=	O
i	int
+	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"-D"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
)	O
{	O
process_debug_options	function
(	O
argv	array
[	O
i	int
+	O
1	int
]	O
)	O
;	O
++	O
i	int
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strncmp	function
(	O
"-O"	pointer
,	O
argv	array
[	O
i	int
]	O
,	O
2	int
)	O
)	O
{	O
process_optimisation_option	function
(	O
argv	array
[	O
i	int
]	O
+	O
2	int
)	O
;	O
}	O
else	O
{	O
end_of_leading_options	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
return	O
end_of_leading_options	int
;	O
}	O
static	O
struct	O
timespec	struct
now	function
(	O
void	O
)	O
{	O
struct	O
timespec	struct
retval	struct
;	O
struct	O
timeval	struct
tv	struct
;	O
time_t	long
t	long
;	O
if	O
(	O
0	int
==	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
)	O
{	O
retval	struct
.	O
tv_sec	long
=	O
tv	struct
.	O
tv_sec	long
;	O
retval	struct
.	O
tv_nsec	long
=	O
tv	struct
.	O
tv_usec	long
*	O
1000	int
;	O
return	O
retval	struct
;	O
}	O
t	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
assert	O
(	O
t	long
!=	O
(	O
time_t	long
)	O
-	O
1	int
)	O
;	O
retval	struct
.	O
tv_sec	long
=	O
t	long
;	O
retval	struct
.	O
tv_nsec	long
=	O
0	int
;	O
return	O
retval	struct
;	O
}	O
void	O
set_option_defaults	function
(	O
struct	O
options	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
getenv	function
(	O
"POSIXLY_CORRECT"	pointer
)	O
)	O
p	pointer
->	O
posixly_correct	bool
=	O
true	int
;	O
else	O
p	pointer
->	O
posixly_correct	bool
=	O
false	int
;	O
p	pointer
->	O
open_nofollow_available	bool
=	O
check_nofollow	function
(	O
)	O
;	O
p	pointer
->	O
regex_options	int
=	O
RE_SYNTAX_EMACS	int
;	O
if	O
(	O
isatty	function
(	O
0	int
)	O
)	O
{	O
p	pointer
->	O
warnings	bool
=	O
true	int
;	O
p	pointer
->	O
literal_control_chars	bool
=	O
false	int
;	O
}	O
else	O
{	O
p	pointer
->	O
warnings	bool
=	O
false	int
;	O
p	pointer
->	O
literal_control_chars	bool
=	O
false	int
;	O
}	O
if	O
(	O
p	pointer
->	O
posixly_correct	bool
)	O
{	O
p	pointer
->	O
warnings	bool
=	O
false	int
;	O
}	O
p	pointer
->	O
do_dir_first	bool
=	O
true	int
;	O
p	pointer
->	O
explicit_depth	bool
=	O
false	int
;	O
p	pointer
->	O
maxdepth	int
=	O
p	pointer
->	O
mindepth	int
=	O
-	O
1	int
;	O
p	pointer
->	O
start_time	struct
=	O
now	function
(	O
)	O
;	O
p	pointer
->	O
cur_day_start	struct
.	O
tv_sec	long
=	O
p	pointer
->	O
start_time	struct
.	O
tv_sec	long
-	O
DAYSECS	int
;	O
p	pointer
->	O
cur_day_start	struct
.	O
tv_nsec	long
=	O
p	pointer
->	O
start_time	struct
.	O
tv_nsec	long
;	O
p	pointer
->	O
full_days	bool
=	O
false	int
;	O
p	pointer
->	O
stay_on_filesystem	bool
=	O
false	int
;	O
p	pointer
->	O
ignore_readdir_race	bool
=	O
false	int
;	O
if	O
(	O
p	pointer
->	O
posixly_correct	bool
)	O
p	pointer
->	O
output_block_size	int
=	O
512	int
;	O
else	O
p	pointer
->	O
output_block_size	int
=	O
1024	int
;	O
p	pointer
->	O
debug_options	long
=	O
0uL	int
;	O
p	pointer
->	O
optimisation_level	short
=	O
2	int
;	O
if	O
(	O
getenv	function
(	O
"FIND_BLOCK_SIZE"	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The environment variable FIND_BLOCK_SIZE is not supported, the only thing that affects the block size is the POSIXLY_CORRECT environment variable"	pointer
)	O
)	O
;	O
}	O
p	pointer
->	O
no_leaf_check	bool
=	O
false	int
;	O
set_follow_state	function
(	O
SYMLINK_NEVER_DEREF	int
)	O
;	O
p	pointer
->	O
err_quoting_style	enum
=	O
locale_quoting_style	int
;	O
}	O
bool	bool
apply_predicate	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
struct	O
stat	struct
*	O
stat_buf	pointer
,	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
++	O
p	pointer
->	O
perf	struct
.	O
visits	long
;	O
if	O
(	O
p	pointer
->	O
need_stat	bool
||	O
p	pointer
->	O
need_type	bool
||	O
p	pointer
->	O
need_inum	bool
)	O
{	O
if	O
(	O
get_info	function
(	O
pathname	pointer
,	O
stat_buf	pointer
,	O
p	pointer
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
}	O
if	O
(	O
(	O
p	pointer
->	O
pred_func	pointer
)	O
(	O
pathname	pointer
,	O
stat_buf	pointer
,	O
p	pointer
)	O
)	O
{	O
++	O
(	O
p	pointer
->	O
perf	struct
.	O
successes	long
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
bool	bool
is_exec_in_local_dir	function
(	O
const	O
PRED_FUNC	pointer
pred_func	pointer
)	O
{	O
return	O
pred_execdir	function
==	O
pred_func	pointer
||	O
pred_okdir	function
==	O
pred_func	pointer
;	O
}	O
const	O
char	O
*	O
safely_quote_err_filename	function
(	O
int	O
n	long
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
return	O
quotearg_n_style	function
(	O
n	long
,	O
options	struct
.	O
err_quoting_style	enum
,	O
arg	pointer
)	O
;	O
}	O
void	O
error_severity	function
(	O
int	O
level	pointer
)	O
{	O
if	O
(	O
state	pointer
.	O
exit_status	int
<	O
level	pointer
)	O
state	pointer
.	O
exit_status	int
=	O
level	pointer
;	O
}	O
static	O
void	O
report_file_err	function
(	O
int	O
exitval	int
,	O
int	O
errno_value	int
,	O
bool	bool
is_target_file	bool
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
!	O
is_target_file	bool
||	O
!	O
state	pointer
.	O
already_issued_stat_error_msg	bool
)	O
{	O
error	function
(	O
exitval	int
,	O
errno_value	int
,	O
"%s"	pointer
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
name	pointer
)	O
)	O
;	O
error_severity	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
is_target_file	bool
)	O
{	O
state	pointer
.	O
already_issued_stat_error_msg	bool
=	O
true	int
;	O
}	O
}	O
void	O
nonfatal_target_file_error	function
(	O
int	O
errno_value	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
report_file_err	function
(	O
0	int
,	O
errno_value	int
,	O
true	int
,	O
name	pointer
)	O
;	O
}	O
void	O
fatal_target_file_error	function
(	O
int	O
errno_value	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
report_file_err	function
(	O
1	int
,	O
errno_value	int
,	O
true	int
,	O
name	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
nonfatal_nontarget_file_error	function
(	O
int	O
errno_value	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
report_file_err	function
(	O
0	int
,	O
errno_value	int
,	O
false	int
,	O
name	pointer
)	O
;	O
}	O
void	O
fatal_nontarget_file_error	function
(	O
int	O
errno_value	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
state	pointer
.	O
already_issued_stat_error_msg	bool
=	O
false	int
;	O
report_file_err	function
(	O
1	int
,	O
errno_value	int
,	O
false	int
,	O
name	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
