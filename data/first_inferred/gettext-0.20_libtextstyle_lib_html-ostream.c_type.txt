const	O
typeinfo_t	O
html_ostream_typeinfo	O
=	O
{	O
"html_ostream"	pointer
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
html_ostream_superclasses	array
[	O
]	O
=	O
{	O
html_ostream_SUPERCLASSES	O
}	O
;	O
static	O
void	O
verify_invariants	function
(	O
html_ostream_t	O
stream	int
)	O
{	O
if	O
(	O
gl_list_size	O
(	O
stream	int
->	O
class_stack	O
)	O
!=	O
MAX	function
(	O
stream	int
->	O
curr_class_stack_size	O
,	O
stream	int
->	O
last_class_stack_size	O
)	O
)	O
abort	O
(	O
)	O
;	O
}	O
static	O
void	O
shrink_class_stack	function
(	O
html_ostream_t	O
stream	int
)	O
{	O
size_t	O
keep	O
=	O
MAX	function
(	O
stream	int
->	O
curr_class_stack_size	O
,	O
stream	int
->	O
last_class_stack_size	O
)	O
;	O
size_t	O
i	O
=	O
gl_list_size	O
(	O
stream	int
->	O
class_stack	O
)	O
;	O
while	O
(	O
i	O
>	O
keep	O
)	O
{	O
i	O
--	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
gl_list_get_at	O
(	O
stream	int
->	O
class_stack	O
,	O
i	O
)	O
)	O
;	O
gl_list_remove_at	O
(	O
stream	int
->	O
class_stack	O
,	O
i	O
)	O
;	O
}	O
}	O
static	O
void	O
emit_pending_spans	function
(	O
html_ostream_t	O
stream	int
,	O
bool	O
shrink_stack	int
)	O
{	O
if	O
(	O
stream	int
->	O
curr_class_stack_size	O
>	O
stream	int
->	O
last_class_stack_size	O
)	O
{	O
size_t	O
i	O
;	O
for	O
(	O
i	O
=	O
stream	int
->	O
last_class_stack_size	O
;	O
i	O
<	O
stream	int
->	O
curr_class_stack_size	O
;	O
i	O
++	O
)	O
{	O
char	O
*	O
classname	pointer
=	O
(	O
char	O
*	O
)	O
gl_list_get_at	O
(	O
stream	int
->	O
class_stack	O
,	O
i	O
)	O
;	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"<span class=\""	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
classname	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"\">"	pointer
)	O
;	O
}	O
stream	int
->	O
last_class_stack_size	O
=	O
stream	int
->	O
curr_class_stack_size	O
;	O
}	O
else	O
if	O
(	O
stream	int
->	O
curr_class_stack_size	O
<	O
stream	int
->	O
last_class_stack_size	O
)	O
{	O
size_t	O
i	O
;	O
for	O
(	O
i	O
=	O
stream	int
->	O
last_class_stack_size	O
;	O
i	O
>	O
stream	int
->	O
curr_class_stack_size	O
;	O
i	O
--	O
)	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"</span>"	pointer
)	O
;	O
stream	int
->	O
last_class_stack_size	O
=	O
stream	int
->	O
curr_class_stack_size	O
;	O
if	O
(	O
shrink_stack	int
)	O
shrink_class_stack	function
(	O
stream	int
)	O
;	O
}	O
if	O
(	O
shrink_stack	int
)	O
verify_invariants	function
(	O
stream	int
)	O
;	O
}	O
static	O
void	O
html_ostream__write_mem	function
(	O
html_ostream_t	O
stream	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	O
len	int
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
char	O
inbuffer	array
[	O
BUFFERSIZE	int
]	O
;	O
size_t	O
inbufcount	O
;	O
inbufcount	O
=	O
stream	int
->	O
buflen	O
;	O
if	O
(	O
inbufcount	O
>	O
0	int
)	O
memcpy	O
(	O
inbuffer	array
,	O
stream	int
->	O
buf	O
,	O
inbufcount	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
{	O
size_t	O
n	O
=	O
(	O
len	int
<=	O
BUFFERSIZE	int
-	O
inbufcount	O
?	O
len	int
:	O
BUFFERSIZE	int
-	O
inbufcount	O
)	O
;	O
if	O
(	O
n	O
>	O
0	int
)	O
{	O
memcpy	O
(	O
inbuffer	array
+	O
inbufcount	O
,	O
data	pointer
,	O
n	O
)	O
;	O
data	pointer
=	O
(	O
char	O
*	O
)	O
data	pointer
+	O
n	O
;	O
inbufcount	O
+=	O
n	O
;	O
len	int
-=	O
n	O
;	O
}	O
}	O
{	O
const	O
char	O
*	O
inptr	pointer
=	O
inbuffer	array
;	O
size_t	O
insize	O
=	O
inbufcount	O
;	O
while	O
(	O
insize	O
>	O
0	int
)	O
{	O
unsigned	O
char	O
c0	char
;	O
ucs4_t	O
uc	O
;	O
int	O
nbytes	int
;	O
c0	char
=	O
(	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
inptr	pointer
)	O
[	O
0	int
]	O
;	O
if	O
(	O
insize	O
<	O
(	O
c0	char
<	O
0xc0	int
?	O
1	int
:	O
c0	char
<	O
0xe0	int
?	O
2	int
:	O
c0	char
<	O
0xf0	int
?	O
3	int
:	O
c0	char
<	O
0xf8	int
?	O
4	int
:	O
c0	char
<	O
0xfc	int
?	O
5	int
:	O
6	int
)	O
)	O
break	O
;	O
nbytes	int
=	O
u8_mbtouc	O
(	O
&	O
uc	O
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
inptr	pointer
,	O
insize	O
)	O
;	O
if	O
(	O
uc	O
==	O
'\n'	O
)	O
{	O
verify_invariants	function
(	O
stream	int
)	O
;	O
size_t	O
prev_class_stack_size	O
=	O
stream	int
->	O
curr_class_stack_size	O
;	O
stream	int
->	O
curr_class_stack_size	O
=	O
0	int
;	O
emit_pending_spans	function
(	O
stream	int
,	O
false	O
)	O
;	O
stream	int
->	O
curr_class_stack_size	O
=	O
prev_class_stack_size	O
;	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"<br/>"	pointer
)	O
;	O
shrink_class_stack	function
(	O
stream	int
)	O
;	O
verify_invariants	function
(	O
stream	int
)	O
;	O
}	O
else	O
{	O
emit_pending_spans	function
(	O
stream	int
,	O
true	O
)	O
;	O
switch	O
(	O
uc	O
)	O
{	O
case	O
'"'	O
:	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"&quot;"	pointer
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"&amp;"	pointer
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"&lt;"	pointer
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"&gt;"	pointer
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
"&nbsp;"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
uc	O
>=	O
0x20	int
&&	O
uc	O
<	O
0x7F	int
)	O
{	O
char	O
bytes	array
[	O
1	int
]	O
;	O
bytes	array
[	O
0	int
]	O
=	O
uc	O
;	O
ostream_write_mem	function
(	O
stream	int
->	O
destination	int
,	O
bytes	array
,	O
1	int
)	O
;	O
}	O
else	O
{	O
char	O
bytes	array
[	O
32	int
]	O
;	O
sprintf	O
(	O
bytes	array
,	O
"&#%d;"	pointer
,	O
(	O
int	O
)	O
uc	O
)	O
;	O
ostream_write_str	function
(	O
stream	int
->	O
destination	int
,	O
bytes	array
)	O
;	O
}	O
break	O
;	O
}	O
}	O
inptr	pointer
+=	O
nbytes	int
;	O
insize	O
-=	O
nbytes	int
;	O
}	O
if	O
(	O
insize	O
>	O
BUFSIZE	O
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
{	O
if	O
(	O
insize	O
>	O
0	int
)	O
memcpy	O
(	O
stream	int
->	O
buf	O
,	O
inptr	pointer
,	O
insize	O
)	O
;	O
stream	int
->	O
buflen	O
=	O
insize	O
;	O
break	O
;	O
}	O
if	O
(	O
insize	O
>	O
0	int
)	O
memmove	O
(	O
inbuffer	array
,	O
inptr	pointer
,	O
insize	O
)	O
;	O
inbufcount	O
=	O
insize	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
html_ostream__flush	function
(	O
html_ostream_t	O
stream	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
verify_invariants	function
(	O
stream	int
)	O
;	O
size_t	O
prev_class_stack_size	O
=	O
stream	int
->	O
curr_class_stack_size	O
;	O
stream	int
->	O
curr_class_stack_size	O
=	O
0	int
;	O
emit_pending_spans	function
(	O
stream	int
,	O
false	O
)	O
;	O
stream	int
->	O
curr_class_stack_size	O
=	O
prev_class_stack_size	O
;	O
shrink_class_stack	function
(	O
stream	int
)	O
;	O
verify_invariants	function
(	O
stream	int
)	O
;	O
if	O
(	O
scope	int
!=	O
FLUSH_THIS_STREAM	O
)	O
ostream_flush	function
(	O
stream	int
->	O
destination	int
,	O
scope	int
)	O
;	O
}	O
static	O
void	O
html_ostream__free	function
(	O
html_ostream_t	O
stream	int
)	O
{	O
stream	int
->	O
curr_class_stack_size	O
=	O
0	int
;	O
emit_pending_spans	function
(	O
stream	int
,	O
true	O
)	O
;	O
verify_invariants	function
(	O
stream	int
)	O
;	O
gl_list_free	O
(	O
stream	int
->	O
class_stack	O
)	O
;	O
free	function
(	O
stream	int
)	O
;	O
}	O
static	O
void	O
html_ostream__begin_span	function
(	O
html_ostream_t	O
stream	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
verify_invariants	function
(	O
stream	int
)	O
;	O
if	O
(	O
stream	int
->	O
last_class_stack_size	O
>	O
stream	int
->	O
curr_class_stack_size	O
&&	O
strcmp	O
(	O
(	O
char	O
*	O
)	O
gl_list_get_at	O
(	O
stream	int
->	O
class_stack	O
,	O
stream	int
->	O
curr_class_stack_size	O
)	O
,	O
classname	pointer
)	O
!=	O
0	int
)	O
emit_pending_spans	function
(	O
stream	int
,	O
true	O
)	O
;	O
if	O
(	O
stream	int
->	O
last_class_stack_size	O
<=	O
stream	int
->	O
curr_class_stack_size	O
)	O
gl_list_add_at	O
(	O
stream	int
->	O
class_stack	O
,	O
stream	int
->	O
curr_class_stack_size	O
,	O
xstrdup	O
(	O
classname	pointer
)	O
)	O
;	O
stream	int
->	O
curr_class_stack_size	O
++	O
;	O
verify_invariants	function
(	O
stream	int
)	O
;	O
}	O
static	O
void	O
html_ostream__end_span	function
(	O
html_ostream_t	O
stream	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
verify_invariants	function
(	O
stream	int
)	O
;	O
if	O
(	O
stream	int
->	O
curr_class_stack_size	O
>	O
0	int
)	O
{	O
char	O
*	O
innermost_active_span	pointer
=	O
(	O
char	O
*	O
)	O
gl_list_get_at	O
(	O
stream	int
->	O
class_stack	O
,	O
stream	int
->	O
curr_class_stack_size	O
-	O
1	int
)	O
;	O
if	O
(	O
strcmp	O
(	O
innermost_active_span	pointer
,	O
classname	pointer
)	O
==	O
0	int
)	O
{	O
stream	int
->	O
curr_class_stack_size	O
--	O
;	O
shrink_class_stack	function
(	O
stream	int
)	O
;	O
verify_invariants	function
(	O
stream	int
)	O
;	O
return	O
;	O
}	O
}	O
abort	O
(	O
)	O
;	O
}	O
static	O
void	O
html_ostream__flush_to_current_style	function
(	O
html_ostream_t	O
stream	int
)	O
{	O
verify_invariants	function
(	O
stream	int
)	O
;	O
emit_pending_spans	function
(	O
stream	int
,	O
true	O
)	O
;	O
verify_invariants	function
(	O
stream	int
)	O
;	O
}	O
html_ostream_t	O
html_ostream_create	function
(	O
ostream_t	O
destination	int
)	O
{	O
html_ostream_t	O
stream	int
=	O
XMALLOC	O
(	O
struct	O
html_ostream_representation	O
)	O
;	O
stream	int
->	O
base	O
.	O
vtable	pointer
=	O
&	O
html_ostream_vtable	O
;	O
stream	int
->	O
destination	int
=	O
destination	int
;	O
stream	int
->	O
class_stack	O
=	O
gl_list_create_empty	O
(	O
GL_ARRAY_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	O
)	O
;	O
stream	int
->	O
curr_class_stack_size	O
=	O
0	int
;	O
stream	int
->	O
last_class_stack_size	O
=	O
0	int
;	O
stream	int
->	O
buflen	O
=	O
0	int
;	O
return	O
stream	int
;	O
}	O
const	O
struct	O
html_ostream_implementation	O
html_ostream_vtable	O
=	O
{	O
html_ostream_superclasses	array
,	O
sizeof	O
(	O
html_ostream_superclasses	array
)	O
/	O
sizeof	O
(	O
html_ostream_superclasses	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
html_ostream_representation	O
)	O
,	O
html_ostream__write_mem	function
,	O
html_ostream__flush	function
,	O
html_ostream__free	function
,	O
html_ostream__begin_span	function
,	O
html_ostream__end_span	function
,	O
html_ostream__flush_to_current_style	function
,	O
}	O
;	O
void	O
html_ostream_write_mem	function
(	O
html_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	O
len	int
)	O
{	O
const	O
struct	O
html_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
html_ostream_representation_header	O
*	O
)	O
(	O
struct	O
html_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
write_mem	O
(	O
first_arg	int
,	O
data	pointer
,	O
len	int
)	O
;	O
}	O
void	O
html_ostream_flush	function
(	O
html_ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
html_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
html_ostream_representation_header	O
*	O
)	O
(	O
struct	O
html_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
html_ostream_free	function
(	O
html_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
html_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
html_ostream_representation_header	O
*	O
)	O
(	O
struct	O
html_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
free	function
(	O
first_arg	int
)	O
;	O
}	O
void	O
html_ostream_begin_span	function
(	O
html_ostream_t	O
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
const	O
struct	O
html_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
html_ostream_representation_header	O
*	O
)	O
(	O
struct	O
html_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
begin_span	O
(	O
first_arg	int
,	O
classname	pointer
)	O
;	O
}	O
void	O
html_ostream_end_span	function
(	O
html_ostream_t	O
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
const	O
struct	O
html_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
html_ostream_representation_header	O
*	O
)	O
(	O
struct	O
html_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
end_span	O
(	O
first_arg	int
,	O
classname	pointer
)	O
;	O
}	O
void	O
html_ostream_flush_to_current_style	function
(	O
html_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
html_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
html_ostream_representation_header	O
*	O
)	O
(	O
struct	O
html_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush_to_current_style	O
(	O
first_arg	int
)	O
;	O
}	O
