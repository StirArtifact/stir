static	O
bfd_boolean	int
generic_link_add_object_symbols	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
generic_link_check_archive_element	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
bfd_boolean	int
generic_link_add_symbol_list	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
bfd_size_type	long
count	int
,	O
asymbol	struct
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
generic_add_output_symbol	function
(	O
bfd	struct
*	O
,	O
size_t	long
*	O
psymalloc	pointer
,	O
asymbol	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
default_data_link_order	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
bfd_link_order	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
default_indirect_link_order	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
bfd_link_order	struct
*	O
,	O
bfd_boolean	int
)	O
;	O
struct	O
bfd_hash_entry	struct
*	O
_bfd_link_hash_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
entry	pointer
=	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
bfd_link_hash_entry	struct
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
entry	pointer
;	O
}	O
entry	pointer
=	O
bfd_hash_newfunc	function
(	O
entry	pointer
,	O
table	pointer
,	O
string	pointer
)	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
entry	pointer
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
h	pointer
->	O
root	struct
+	O
sizeof	O
(	O
h	pointer
->	O
root	struct
)	O
,	O
0	int
,	O
sizeof	O
(	O
*	O
h	pointer
)	O
-	O
sizeof	O
(	O
h	pointer
->	O
root	struct
)	O
)	O
;	O
}	O
return	O
entry	pointer
;	O
}	O
bfd_boolean	int
_bfd_link_hash_table_init	function
(	O
struct	O
bfd_link_hash_table	struct
*	O
table	pointer
,	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_hash_entry	struct
*	O
(	O
*	O
newfunc	pointer
)	O
(	O
struct	O
bfd_hash_entry	struct
*	O
,	O
struct	O
bfd_hash_table	struct
*	O
,	O
const	O
char	O
*	O
)	O
,	O
unsigned	O
int	O
entsize	int
)	O
{	O
bfd_boolean	int
ret	pointer
;	O
BFD_ASSERT	O
(	O
!	O
abfd	pointer
->	O
is_linker_output	int
&&	O
!	O
abfd	pointer
->	O
link	function
.	O
hash	long
)	O
;	O
table	pointer
->	O
undefs	pointer
=	O
NULL	O
;	O
table	pointer
->	O
undefs_tail	pointer
=	O
NULL	O
;	O
table	pointer
->	O
type	enum
=	O
bfd_link_generic_hash_table	int
;	O
ret	pointer
=	O
bfd_hash_table_init	function
(	O
&	O
table	pointer
->	O
table	pointer
,	O
newfunc	pointer
,	O
entsize	int
)	O
;	O
if	O
(	O
ret	pointer
)	O
{	O
table	pointer
->	O
hash_table_free	pointer
=	O
_bfd_generic_link_hash_table_free	function
;	O
abfd	pointer
->	O
link	function
.	O
hash	long
=	O
table	pointer
;	O
abfd	pointer
->	O
is_linker_output	int
=	O
TRUE	int
;	O
}	O
return	O
ret	pointer
;	O
}	O
struct	O
bfd_link_hash_entry	struct
*	O
bfd_link_hash_lookup	function
(	O
struct	O
bfd_link_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
bfd_boolean	int
create	int
,	O
bfd_boolean	int
copy	int
,	O
bfd_boolean	int
follow	int
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
ret	pointer
;	O
if	O
(	O
table	pointer
==	O
NULL	O
||	O
string	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
ret	pointer
=	O
(	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
bfd_hash_lookup	function
(	O
&	O
table	pointer
->	O
table	pointer
,	O
string	pointer
,	O
create	int
,	O
copy	int
)	O
)	O
;	O
if	O
(	O
follow	int
&&	O
ret	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
ret	pointer
->	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
ret	pointer
->	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
ret	pointer
=	O
ret	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
;	O
}	O
return	O
ret	pointer
;	O
}	O
struct	O
bfd_link_hash_entry	struct
*	O
bfd_wrapped_link_hash_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
bfd_boolean	int
create	int
,	O
bfd_boolean	int
copy	int
,	O
bfd_boolean	int
follow	int
)	O
{	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
info	pointer
->	O
wrap_hash	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
l	pointer
;	O
char	O
prefix	char
=	O
'\0'	O
;	O
l	pointer
=	O
string	pointer
;	O
if	O
(	O
*	O
l	pointer
==	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
||	O
*	O
l	pointer
==	O
info	pointer
->	O
wrap_char	char
)	O
{	O
prefix	char
=	O
*	O
l	pointer
;	O
++	O
l	pointer
;	O
}	O
if	O
(	O
bfd_hash_lookup	function
(	O
info	pointer
->	O
wrap_hash	pointer
,	O
l	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
n	long
;	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
amt	long
=	O
strlen	function
(	O
l	pointer
)	O
+	O
sizeof	O
WRAP	pointer
+	O
1	int
;	O
n	long
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
NULL	O
;	O
n	long
[	O
0	int
]	O
=	O
prefix	char
;	O
n	long
[	O
1	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
n	long
,	O
WRAP	pointer
)	O
;	O
strcat	function
(	O
n	long
,	O
l	pointer
)	O
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
n	long
,	O
create	int
,	O
TRUE	int
,	O
follow	int
)	O
;	O
free	function
(	O
n	long
)	O
;	O
return	O
h	pointer
;	O
}	O
if	O
(	O
*	O
l	pointer
==	O
'_'	O
&&	O
CONST_STRNEQ	O
(	O
l	pointer
,	O
REAL	pointer
)	O
&&	O
bfd_hash_lookup	function
(	O
info	pointer
->	O
wrap_hash	pointer
,	O
l	pointer
+	O
sizeof	O
REAL	pointer
-	O
1	int
,	O
FALSE	int
,	O
FALSE	int
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
n	long
;	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
amt	long
=	O
strlen	function
(	O
l	pointer
+	O
sizeof	O
REAL	pointer
-	O
1	int
)	O
+	O
2	int
;	O
n	long
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
NULL	O
;	O
n	long
[	O
0	int
]	O
=	O
prefix	char
;	O
n	long
[	O
1	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
n	long
,	O
l	pointer
+	O
sizeof	O
REAL	pointer
-	O
1	int
)	O
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
n	long
,	O
create	int
,	O
TRUE	int
,	O
follow	int
)	O
;	O
free	function
(	O
n	long
)	O
;	O
return	O
h	pointer
;	O
}	O
}	O
return	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
string	pointer
,	O
create	int
,	O
copy	int
,	O
follow	int
)	O
;	O
}	O
struct	O
bfd_link_hash_entry	struct
*	O
unwrap_hash_lookup	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
const	O
char	O
*	O
l	pointer
=	O
h	pointer
->	O
root	struct
.	O
string	pointer
;	O
if	O
(	O
*	O
l	pointer
==	O
bfd_get_symbol_leading_char	function
(	O
input_bfd	pointer
)	O
||	O
*	O
l	pointer
==	O
info	pointer
->	O
wrap_char	char
)	O
++	O
l	pointer
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
l	pointer
,	O
WRAP	pointer
)	O
)	O
{	O
l	pointer
+=	O
sizeof	O
WRAP	pointer
-	O
1	int
;	O
if	O
(	O
bfd_hash_lookup	function
(	O
info	pointer
->	O
wrap_hash	pointer
,	O
l	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
!=	O
NULL	O
)	O
{	O
char	O
save	char
=	O
0	int
;	O
if	O
(	O
l	pointer
-	O
(	O
sizeof	O
WRAP	pointer
-	O
1	int
)	O
!=	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
{	O
--	O
l	pointer
;	O
save	char
=	O
*	O
l	pointer
;	O
*	O
(	O
char	O
*	O
)	O
l	pointer
=	O
*	O
h	pointer
->	O
root	struct
.	O
string	pointer
;	O
}	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
l	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
save	char
)	O
*	O
(	O
char	O
*	O
)	O
l	pointer
=	O
save	char
;	O
}	O
}	O
return	O
h	pointer
;	O
}	O
void	O
bfd_link_hash_traverse	function
(	O
struct	O
bfd_link_hash_table	struct
*	O
htab	struct
,	O
bfd_boolean	int
(	O
*	O
func	pointer
)	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
info	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
htab	struct
->	O
table	pointer
.	O
frozen	int
=	O
1	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
htab	struct
->	O
table	pointer
.	O
size	long
;	O
i	pointer
++	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
p	pointer
;	O
p	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
htab	struct
->	O
table	pointer
.	O
table	pointer
[	O
i	pointer
]	O
;	O
for	O
(	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
p	pointer
->	O
root	struct
.	O
next	pointer
)	O
if	O
(	O
!	O
(	O
*	O
func	pointer
)	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_link_hash_warning	int
?	O
p	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
:	O
p	pointer
,	O
info	pointer
)	O
)	O
goto	O
out	O
;	O
}	O
out	O
:	O
htab	struct
->	O
table	pointer
.	O
frozen	int
=	O
0	int
;	O
}	O
void	O
bfd_link_add_undef	function
(	O
struct	O
bfd_link_hash_table	struct
*	O
table	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
BFD_ASSERT	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
==	O
NULL	O
)	O
;	O
if	O
(	O
table	pointer
->	O
undefs_tail	pointer
!=	O
NULL	O
)	O
table	pointer
->	O
undefs_tail	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
=	O
h	pointer
;	O
if	O
(	O
table	pointer
->	O
undefs	pointer
==	O
NULL	O
)	O
table	pointer
->	O
undefs	pointer
=	O
h	pointer
;	O
table	pointer
->	O
undefs_tail	pointer
=	O
h	pointer
;	O
}	O
void	O
bfd_link_repair_undef_list	function
(	O
struct	O
bfd_link_hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
pun	pointer
;	O
pun	pointer
=	O
&	O
table	pointer
->	O
undefs	pointer
;	O
while	O
(	O
*	O
pun	pointer
!=	O
NULL	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
=	O
*	O
pun	pointer
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
*	O
pun	pointer
=	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
h	pointer
==	O
table	pointer
->	O
undefs_tail	pointer
)	O
{	O
if	O
(	O
pun	pointer
==	O
&	O
table	pointer
->	O
undefs	pointer
)	O
table	pointer
->	O
undefs_tail	pointer
=	O
NULL	O
;	O
else	O
table	pointer
->	O
undefs_tail	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
(	O
(	O
char	O
*	O
)	O
pun	pointer
-	O
(	O
(	O
char	O
*	O
)	O
&	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
-	O
(	O
char	O
*	O
)	O
h	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
pun	pointer
=	O
&	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
;	O
}	O
}	O
struct	O
bfd_hash_entry	struct
*	O
_bfd_generic_link_hash_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
{	O
entry	pointer
=	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
generic_link_hash_entry	struct
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
entry	pointer
;	O
}	O
entry	pointer
=	O
_bfd_link_hash_newfunc	function
(	O
entry	pointer
,	O
table	pointer
,	O
string	pointer
)	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
struct	O
generic_link_hash_entry	struct
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
struct	O
generic_link_hash_entry	struct
*	O
)	O
entry	pointer
;	O
ret	pointer
->	O
written	int
=	O
FALSE	int
;	O
ret	pointer
->	O
sym	pointer
=	O
NULL	O
;	O
}	O
return	O
entry	pointer
;	O
}	O
struct	O
bfd_link_hash_table	struct
*	O
_bfd_generic_link_hash_table_create	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
generic_link_hash_table	struct
*	O
ret	pointer
;	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
generic_link_hash_table	struct
)	O
;	O
ret	pointer
=	O
(	O
struct	O
generic_link_hash_table	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
_bfd_link_hash_table_init	function
(	O
&	O
ret	pointer
->	O
root	struct
,	O
abfd	pointer
,	O
_bfd_generic_link_hash_newfunc	function
,	O
sizeof	O
(	O
struct	O
generic_link_hash_entry	struct
)	O
)	O
)	O
{	O
free	function
(	O
ret	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
&	O
ret	pointer
->	O
root	struct
;	O
}	O
void	O
_bfd_generic_link_hash_table_free	function
(	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
struct	O
generic_link_hash_table	struct
*	O
ret	pointer
;	O
BFD_ASSERT	O
(	O
obfd	pointer
->	O
is_linker_output	int
&&	O
obfd	pointer
->	O
link	function
.	O
hash	long
)	O
;	O
ret	pointer
=	O
(	O
struct	O
generic_link_hash_table	struct
*	O
)	O
obfd	pointer
->	O
link	function
.	O
hash	long
;	O
bfd_hash_table_free	function
(	O
&	O
ret	pointer
->	O
root	struct
.	O
table	pointer
)	O
;	O
free	function
(	O
ret	pointer
)	O
;	O
obfd	pointer
->	O
link	function
.	O
hash	long
=	O
NULL	O
;	O
obfd	pointer
->	O
is_linker_output	int
=	O
FALSE	int
;	O
}	O
bfd_boolean	int
bfd_generic_link_read_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
==	O
NULL	O
)	O
{	O
long	O
symsize	long
;	O
long	O
symcount	int
;	O
symsize	long
=	O
bfd_get_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
symsize	long
<	O
0	int
)	O
return	O
FALSE	int
;	O
abfd	pointer
->	O
outsymbols	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
symsize	long
)	O
;	O
if	O
(	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
==	O
NULL	O
&&	O
symsize	long
!=	O
0	int
)	O
return	O
FALSE	int
;	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
abfd	pointer
,	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
return	O
FALSE	int
;	O
abfd	pointer
->	O
symcount	int
=	O
symcount	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_generic_link_just_syms	function
(	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
sec	pointer
->	O
sec_info_type	int
=	O
SEC_INFO_TYPE_JUST_SYMS	int
;	O
sec	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
sec	pointer
->	O
output_offset	long
=	O
sec	pointer
->	O
vma	long
;	O
}	O
void	O
_bfd_generic_copy_link_hash_symbol_type	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
hdest	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
hsrc	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
bfd_boolean	int
_bfd_generic_link_add_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_boolean	int
ret	pointer
;	O
switch	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_object	int
:	O
ret	pointer
=	O
generic_link_add_object_symbols	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
break	O
;	O
case	O
bfd_archive	int
:	O
ret	pointer
=	O
(	O
_bfd_generic_link_add_archive_symbols	function
(	O
abfd	pointer
,	O
info	pointer
,	O
generic_link_check_archive_element	function
)	O
)	O
;	O
break	O
;	O
default	O
:	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
}	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
generic_link_add_object_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_size_type	long
symcount	int
;	O
struct	O
bfd_symbol	struct
*	O
*	O
outsyms	pointer
;	O
if	O
(	O
!	O
bfd_generic_link_read_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
symcount	int
=	O
_bfd_generic_link_get_symcount	O
(	O
abfd	pointer
)	O
;	O
outsyms	pointer
=	O
_bfd_generic_link_get_symbols	O
(	O
abfd	pointer
)	O
;	O
return	O
generic_link_add_symbol_list	function
(	O
abfd	pointer
,	O
info	pointer
,	O
symcount	int
,	O
outsyms	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_generic_link_add_archive_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_boolean	int
(	O
*	O
checkfn	pointer
)	O
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
)	O
)	O
{	O
bfd_boolean	int
loop	int
;	O
bfd_size_type	long
amt	long
;	O
unsigned	O
char	O
*	O
included	pointer
;	O
if	O
(	O
!	O
bfd_has_map	function
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
bfd_openr_next_archived_file	function
(	O
abfd	pointer
,	O
NULL	O
)	O
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
bfd_set_error	function
(	O
bfd_error_no_armap	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
amt	long
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdef_count	long
;	O
if	O
(	O
amt	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
amt	long
*=	O
sizeof	O
(	O
*	O
included	pointer
)	O
;	O
included	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
bfd_zmalloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
included	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
do	O
{	O
carsym	struct
*	O
arsyms	pointer
;	O
carsym	struct
*	O
arsym_end	pointer
;	O
carsym	struct
*	O
arsym	pointer
;	O
unsigned	O
int	O
indx	int
;	O
file_ptr	long
last_ar_offset	long
=	O
-	O
1	int
;	O
bfd_boolean	int
needed	int
=	O
FALSE	int
;	O
bfd	struct
*	O
element	pointer
=	O
NULL	O
;	O
loop	int
=	O
FALSE	int
;	O
arsyms	pointer
=	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdefs	pointer
;	O
arsym_end	pointer
=	O
arsyms	pointer
+	O
bfd_ardata	O
(	O
abfd	pointer
)	O
->	O
symdef_count	long
;	O
for	O
(	O
arsym	pointer
=	O
arsyms	pointer
,	O
indx	int
=	O
0	int
;	O
arsym	pointer
<	O
arsym_end	pointer
;	O
arsym	pointer
++	O
,	O
indx	int
++	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
undefs_tail	pointer
;	O
if	O
(	O
included	pointer
[	O
indx	int
]	O
)	O
continue	O
;	O
if	O
(	O
needed	int
&&	O
arsym	pointer
->	O
file_offset	long
==	O
last_ar_offset	long
)	O
{	O
included	pointer
[	O
indx	int
]	O
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
arsym	pointer
->	O
name	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
arsym	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
info	pointer
->	O
pei386_auto_import	int
&&	O
CONST_STRNEQ	O
(	O
arsym	pointer
->	O
name	pointer
,	O
"__imp_"	pointer
)	O
)	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
arsym	pointer
->	O
name	pointer
+	O
6	int
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_undefined	int
&&	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_common	int
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_undefweak	int
)	O
included	pointer
[	O
indx	int
]	O
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
last_ar_offset	long
!=	O
arsym	pointer
->	O
file_offset	long
)	O
{	O
last_ar_offset	long
=	O
arsym	pointer
->	O
file_offset	long
;	O
element	pointer
=	O
_bfd_get_elt_at_filepos	function
(	O
abfd	pointer
,	O
last_ar_offset	long
)	O
;	O
if	O
(	O
element	pointer
==	O
NULL	O
||	O
!	O
bfd_check_format	function
(	O
element	pointer
,	O
bfd_object	int
)	O
)	O
goto	O
error_return	O
;	O
}	O
undefs_tail	pointer
=	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
;	O
if	O
(	O
!	O
(	O
*	O
checkfn	pointer
)	O
(	O
element	pointer
,	O
info	pointer
,	O
h	pointer
,	O
arsym	pointer
->	O
name	pointer
,	O
&	O
needed	int
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
needed	int
)	O
{	O
unsigned	O
int	O
mark	int
;	O
mark	int
=	O
indx	int
;	O
do	O
{	O
included	pointer
[	O
mark	int
]	O
=	O
1	int
;	O
if	O
(	O
mark	int
==	O
0	int
)	O
break	O
;	O
--	O
mark	int
;	O
}	O
while	O
(	O
arsyms	pointer
[	O
mark	int
]	O
.	O
file_offset	long
==	O
last_ar_offset	long
)	O
;	O
if	O
(	O
undefs_tail	pointer
!=	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
)	O
loop	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
while	O
(	O
loop	int
)	O
;	O
free	function
(	O
included	pointer
)	O
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
free	function
(	O
included	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
generic_link_check_archive_element	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
*	O
pneeded	pointer
)	O
{	O
asymbol	struct
*	O
*	O
pp	pointer
,	O
*	O
*	O
ppend	pointer
;	O
*	O
pneeded	pointer
=	O
FALSE	int
;	O
if	O
(	O
!	O
bfd_generic_link_read_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
pp	pointer
=	O
_bfd_generic_link_get_symbols	O
(	O
abfd	pointer
)	O
;	O
ppend	pointer
=	O
pp	pointer
+	O
_bfd_generic_link_get_symcount	O
(	O
abfd	pointer
)	O
;	O
for	O
(	O
;	O
pp	pointer
<	O
ppend	pointer
;	O
pp	pointer
++	O
)	O
{	O
asymbol	struct
*	O
p	pointer
;	O
p	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
bfd_is_com_section	function
(	O
p	pointer
->	O
section	pointer
)	O
&&	O
(	O
p	pointer
->	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_INDIRECT	O
|	O
BSF_WEAK	O
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
bfd_asymbol_name	function
(	O
p	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_undefined	int
&&	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_common	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
bfd_is_com_section	function
(	O
p	pointer
->	O
section	pointer
)	O
||	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefined	int
&&	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
==	O
NULL	O
)	O
)	O
{	O
*	O
pneeded	pointer
=	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
add_archive_element	pointer
)	O
(	O
info	pointer
,	O
abfd	pointer
,	O
bfd_asymbol_name	function
(	O
p	pointer
)	O
,	O
&	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
bfd_link_add_symbols	O
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
{	O
bfd	struct
*	O
symbfd	pointer
;	O
bfd_vma	long
size	long
;	O
unsigned	O
int	O
power	int
;	O
symbfd	pointer
=	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
;	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_common	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
=	O
(	O
struct	O
bfd_link_hash_common_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
sizeof	O
(	O
struct	O
bfd_link_hash_common_entry	struct
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
size	long
=	O
bfd_asymbol_value	function
(	O
p	pointer
)	O
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
=	O
size	long
;	O
power	int
=	O
bfd_log2	function
(	O
size	long
)	O
;	O
if	O
(	O
power	int
>	O
4	int
)	O
power	int
=	O
4	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
power	int
;	O
if	O
(	O
p	pointer
->	O
section	pointer
==	O
bfd_com_section_ptr	O
)	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
symbfd	pointer
,	O
"COMMON"	pointer
)	O
;	O
else	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
symbfd	pointer
,	O
p	pointer
->	O
section	pointer
->	O
name	pointer
)	O
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
}	O
else	O
{	O
if	O
(	O
bfd_asymbol_value	function
(	O
p	pointer
)	O
>	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
)	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
=	O
bfd_asymbol_value	function
(	O
p	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
generic_link_add_symbol_list	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_size_type	long
symbol_count	long
,	O
asymbol	struct
*	O
*	O
symbols	pointer
)	O
{	O
asymbol	struct
*	O
*	O
pp	pointer
,	O
*	O
*	O
ppend	pointer
;	O
pp	pointer
=	O
symbols	pointer
;	O
ppend	pointer
=	O
symbols	pointer
+	O
symbol_count	long
;	O
for	O
(	O
;	O
pp	pointer
<	O
ppend	pointer
;	O
pp	pointer
++	O
)	O
{	O
asymbol	struct
*	O
p	pointer
;	O
p	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
(	O
p	pointer
->	O
flags	int
&	O
(	O
BSF_INDIRECT	O
|	O
BSF_WARNING	O
|	O
BSF_GLOBAL	O
|	O
BSF_CONSTRUCTOR	O
|	O
BSF_WEAK	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
)	O
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
)	O
||	O
bfd_is_ind_section	function
(	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
)	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
string	pointer
;	O
struct	O
generic_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
bh	pointer
;	O
string	pointer
=	O
name	pointer
=	O
bfd_asymbol_name	function
(	O
p	pointer
)	O
;	O
if	O
(	O
(	O
(	O
p	pointer
->	O
flags	int
&	O
BSF_INDIRECT	O
)	O
!=	O
0	int
||	O
bfd_is_ind_section	function
(	O
p	pointer
->	O
section	pointer
)	O
)	O
&&	O
pp	pointer
+	O
1	int
<	O
ppend	pointer
)	O
{	O
pp	pointer
++	O
;	O
string	pointer
=	O
bfd_asymbol_name	function
(	O
*	O
pp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
p	pointer
->	O
flags	int
&	O
BSF_WARNING	O
)	O
!=	O
0	int
&&	O
pp	pointer
+	O
1	int
<	O
ppend	pointer
)	O
{	O
pp	pointer
++	O
;	O
name	pointer
=	O
bfd_asymbol_name	function
(	O
*	O
pp	pointer
)	O
;	O
}	O
bh	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
_bfd_generic_link_add_one_symbol	function
(	O
info	pointer
,	O
abfd	pointer
,	O
name	pointer
,	O
p	pointer
->	O
flags	int
,	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
,	O
p	pointer
->	O
value	long
,	O
string	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
&	O
bh	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
(	O
struct	O
generic_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
if	O
(	O
(	O
p	pointer
->	O
flags	int
&	O
BSF_CONSTRUCTOR	O
)	O
!=	O
0	int
&&	O
(	O
h	pointer
==	O
NULL	O
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
)	O
)	O
{	O
p	pointer
->	O
udata	union
.	O
p	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
if	O
(	O
info	pointer
->	O
output_bfd	pointer
->	O
xvec	pointer
==	O
abfd	pointer
->	O
xvec	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
sym	pointer
==	O
NULL	O
||	O
(	O
!	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
)	O
&&	O
(	O
!	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
)	O
||	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
h	pointer
->	O
sym	pointer
)	O
)	O
)	O
)	O
)	O
{	O
h	pointer
->	O
sym	pointer
=	O
p	pointer
;	O
if	O
(	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
p	pointer
)	O
)	O
)	O
p	pointer
->	O
flags	int
|=	O
BSF_OLD_COMMON	O
;	O
}	O
}	O
p	pointer
->	O
udata	union
.	O
p	pointer
=	O
h	pointer
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
enum	O
link_row	enum
{	O
UNDEF_ROW	int
,	O
UNDEFW_ROW	int
,	O
DEF_ROW	int
,	O
DEFW_ROW	int
,	O
COMMON_ROW	int
,	O
INDR_ROW	int
,	O
WARN_ROW	int
,	O
SET_ROW	int
}	O
;	O
enum	O
link_action	enum
{	O
FAIL	int
,	O
UND	int
,	O
WEAK	int
,	O
DEF	int
,	O
DEFW	int
,	O
COM	int
,	O
REF	int
,	O
CREF	int
,	O
CDEF	int
,	O
NOACT	int
,	O
BIG	int
,	O
MDEF	int
,	O
MIND	int
,	O
IND	int
,	O
CIND	int
,	O
SET	int
,	O
MWARN	int
,	O
WARN	int
,	O
CYCLE	int
,	O
REFC	int
,	O
WARNC	int
}	O
;	O
static	O
const	O
enum	O
link_action	enum
link_action	enum
[	O
8	int
]	O
[	O
8	int
]	O
=	O
{	O
{	O
UND	int
,	O
NOACT	int
,	O
UND	int
,	O
REF	int
,	O
REF	int
,	O
NOACT	int
,	O
REFC	int
,	O
WARNC	int
}	O
,	O
{	O
WEAK	int
,	O
NOACT	int
,	O
NOACT	int
,	O
REF	int
,	O
REF	int
,	O
NOACT	int
,	O
REFC	int
,	O
WARNC	int
}	O
,	O
{	O
DEF	int
,	O
DEF	int
,	O
DEF	int
,	O
MDEF	int
,	O
DEF	int
,	O
CDEF	int
,	O
MDEF	int
,	O
CYCLE	int
}	O
,	O
{	O
DEFW	int
,	O
DEFW	int
,	O
DEFW	int
,	O
NOACT	int
,	O
NOACT	int
,	O
NOACT	int
,	O
NOACT	int
,	O
CYCLE	int
}	O
,	O
{	O
COM	int
,	O
COM	int
,	O
COM	int
,	O
CREF	int
,	O
COM	int
,	O
BIG	int
,	O
REFC	int
,	O
WARNC	int
}	O
,	O
{	O
IND	int
,	O
IND	int
,	O
IND	int
,	O
MDEF	int
,	O
IND	int
,	O
CIND	int
,	O
MIND	int
,	O
CYCLE	int
}	O
,	O
{	O
MWARN	int
,	O
WARN	int
,	O
WARN	int
,	O
WARN	int
,	O
WARN	int
,	O
WARN	int
,	O
WARN	int
,	O
NOACT	int
}	O
,	O
{	O
SET	int
,	O
SET	int
,	O
SET	int
,	O
SET	int
,	O
SET	int
,	O
SET	int
,	O
CYCLE	int
,	O
CYCLE	int
}	O
}	O
;	O
static	O
bfd	struct
*	O
hash_entry_bfd	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
while	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
;	O
switch	O
(	O
h	pointer
->	O
type	enum
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
case	O
bfd_link_hash_undefweak	int
:	O
return	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
;	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
return	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
;	O
case	O
bfd_link_hash_common	int
:	O
return	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
owner	pointer
;	O
}	O
}	O
bfd_boolean	int
_bfd_generic_link_add_one_symbol	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
flagword	int
flags	int
,	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
value	long
,	O
const	O
char	O
*	O
string	pointer
,	O
bfd_boolean	int
copy	int
,	O
bfd_boolean	int
collect	int
,	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
hashp	pointer
)	O
{	O
enum	O
link_row	enum
row	enum
;	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
inh	pointer
=	O
NULL	O
;	O
bfd_boolean	int
cycle	int
;	O
BFD_ASSERT	O
(	O
section	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
bfd_is_ind_section	function
(	O
section	pointer
)	O
||	O
(	O
flags	int
&	O
BSF_INDIRECT	O
)	O
!=	O
0	int
)	O
{	O
row	enum
=	O
INDR_ROW	int
;	O
inh	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
abfd	pointer
,	O
info	pointer
,	O
string	pointer
,	O
TRUE	int
,	O
copy	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
inh	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_WARNING	O
)	O
!=	O
0	int
)	O
row	enum
=	O
WARN_ROW	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_CONSTRUCTOR	O
)	O
!=	O
0	int
)	O
row	enum
=	O
SET_ROW	int
;	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
section	pointer
)	O
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
)	O
row	enum
=	O
UNDEFW_ROW	int
;	O
else	O
row	enum
=	O
UNDEF_ROW	int
;	O
}	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
)	O
row	enum
=	O
DEFW_ROW	int
;	O
else	O
if	O
(	O
bfd_is_com_section	function
(	O
section	pointer
)	O
)	O
{	O
row	enum
=	O
COMMON_ROW	int
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'_'	O
&&	O
strcmp	function
(	O
name	pointer
+	O
(	O
name	pointer
[	O
2	int
]	O
==	O
'_'	O
)	O
,	O
"__gnu_lto_slim"	pointer
)	O
==	O
0	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: plugin needed to handle lto object"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
}	O
else	O
row	enum
=	O
DEF_ROW	int
;	O
if	O
(	O
hashp	pointer
!=	O
NULL	O
&&	O
*	O
hashp	pointer
!=	O
NULL	O
)	O
h	pointer
=	O
*	O
hashp	pointer
;	O
else	O
{	O
if	O
(	O
row	enum
==	O
UNDEF_ROW	int
||	O
row	enum
==	O
UNDEFW_ROW	int
)	O
h	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
abfd	pointer
,	O
info	pointer
,	O
name	pointer
,	O
TRUE	int
,	O
copy	int
,	O
FALSE	int
)	O
;	O
else	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
name	pointer
,	O
TRUE	int
,	O
copy	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
hashp	pointer
!=	O
NULL	O
)	O
*	O
hashp	pointer
=	O
NULL	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
info	pointer
->	O
notice_all	int
||	O
(	O
info	pointer
->	O
notice_hash	pointer
!=	O
NULL	O
&&	O
bfd_hash_lookup	function
(	O
info	pointer
->	O
notice_hash	pointer
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
notice	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
inh	pointer
,	O
abfd	pointer
,	O
section	pointer
,	O
value	long
,	O
flags	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
hashp	pointer
!=	O
NULL	O
)	O
*	O
hashp	pointer
=	O
h	pointer
;	O
do	O
{	O
enum	O
link_action	enum
action	enum
;	O
int	O
prev	pointer
;	O
prev	pointer
=	O
h	pointer
->	O
type	enum
;	O
if	O
(	O
h	pointer
->	O
ldscript_def	int
)	O
prev	pointer
=	O
bfd_link_hash_undefined	int
;	O
cycle	int
=	O
FALSE	int
;	O
action	enum
=	O
link_action	enum
[	O
(	O
int	O
)	O
row	enum
]	O
[	O
prev	pointer
]	O
;	O
switch	O
(	O
action	enum
)	O
{	O
case	O
FAIL	int
:	O
abort	function
(	O
)	O
;	O
case	O
NOACT	int
:	O
break	O
;	O
case	O
UND	int
:	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
bfd_link_add_undef	function
(	O
info	pointer
->	O
hash	long
,	O
h	pointer
)	O
;	O
break	O
;	O
case	O
WEAK	int
:	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefweak	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
break	O
;	O
case	O
CDEF	int
:	O
BFD_ASSERT	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
)	O
;	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_common	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
abfd	pointer
,	O
bfd_link_hash_defined	int
,	O
0	int
)	O
;	O
case	O
DEF	int
:	O
case	O
DEFW	int
:	O
{	O
enum	O
bfd_link_hash_type	enum
oldtype	enum
;	O
oldtype	enum
=	O
h	pointer
->	O
type	enum
;	O
if	O
(	O
action	enum
==	O
DEFW	int
)	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_defweak	int
;	O
else	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
section	pointer
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
value	long
;	O
h	pointer
->	O
linker_def	int
=	O
0	int
;	O
h	pointer
->	O
ldscript_def	int
=	O
0	int
;	O
if	O
(	O
collect	int
&&	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
name	pointer
+	O
1	int
;	O
while	O
(	O
*	O
s	pointer
==	O
'_'	O
)	O
++	O
s	pointer
;	O
if	O
(	O
s	pointer
[	O
0	int
]	O
==	O
'G'	O
&&	O
CONST_STRNEQ	O
(	O
s	pointer
,	O
CONS_PREFIX	pointer
)	O
)	O
{	O
char	O
c	struct
;	O
c	struct
=	O
s	pointer
[	O
CONS_PREFIX_LEN	O
+	O
1	int
]	O
;	O
if	O
(	O
(	O
c	struct
==	O
'I'	O
||	O
c	struct
==	O
'D'	O
)	O
&&	O
s	pointer
[	O
CONS_PREFIX_LEN	O
]	O
==	O
s	pointer
[	O
CONS_PREFIX_LEN	O
+	O
2	int
]	O
)	O
{	O
if	O
(	O
oldtype	enum
==	O
bfd_link_hash_defweak	int
)	O
abort	function
(	O
)	O
;	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
constructor	int
)	O
(	O
info	pointer
,	O
c	struct
==	O
'I'	O
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
,	O
abfd	pointer
,	O
section	pointer
,	O
value	long
)	O
;	O
}	O
}	O
}	O
}	O
break	O
;	O
case	O
COM	int
:	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
)	O
bfd_link_add_undef	function
(	O
info	pointer
->	O
hash	long
,	O
h	pointer
)	O
;	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_common	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
=	O
(	O
struct	O
bfd_link_hash_common_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
sizeof	O
(	O
struct	O
bfd_link_hash_common_entry	struct
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
=	O
value	long
;	O
{	O
unsigned	O
int	O
power	int
;	O
power	int
=	O
bfd_log2	function
(	O
value	long
)	O
;	O
if	O
(	O
power	int
>	O
4	int
)	O
power	int
=	O
4	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
power	int
;	O
}	O
if	O
(	O
section	pointer
==	O
bfd_com_section_ptr	O
)	O
{	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
abfd	pointer
,	O
"COMMON"	pointer
)	O
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
owner	pointer
!=	O
abfd	pointer
)	O
{	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
abfd	pointer
,	O
section	pointer
->	O
name	pointer
)	O
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
}	O
else	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
section	pointer
;	O
h	pointer
->	O
linker_def	int
=	O
0	int
;	O
h	pointer
->	O
ldscript_def	int
=	O
0	int
;	O
break	O
;	O
case	O
REF	int
:	O
if	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
==	O
NULL	O
&&	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
!=	O
h	pointer
)	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
=	O
h	pointer
;	O
break	O
;	O
case	O
BIG	int
:	O
BFD_ASSERT	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
)	O
;	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_common	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
abfd	pointer
,	O
bfd_link_hash_common	int
,	O
value	long
)	O
;	O
if	O
(	O
value	long
>	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
)	O
{	O
unsigned	O
int	O
power	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
=	O
value	long
;	O
power	int
=	O
bfd_log2	function
(	O
value	long
)	O
;	O
if	O
(	O
power	int
>	O
4	int
)	O
power	int
=	O
4	int
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
power	int
;	O
if	O
(	O
section	pointer
==	O
bfd_com_section_ptr	O
)	O
{	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
abfd	pointer
,	O
"COMMON"	pointer
)	O
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
owner	pointer
!=	O
abfd	pointer
)	O
{	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
abfd	pointer
,	O
section	pointer
->	O
name	pointer
)	O
;	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
}	O
else	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
section	pointer
;	O
}	O
break	O
;	O
case	O
CREF	int
:	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_common	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
abfd	pointer
,	O
bfd_link_hash_common	int
,	O
value	long
)	O
;	O
break	O
;	O
case	O
MIND	int
:	O
if	O
(	O
strcmp	function
(	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
->	O
root	struct
.	O
string	pointer
,	O
string	pointer
)	O
==	O
0	int
)	O
break	O
;	O
case	O
MDEF	int
:	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_definition	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
abfd	pointer
,	O
section	pointer
,	O
value	long
)	O
;	O
break	O
;	O
case	O
CIND	int
:	O
BFD_ASSERT	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
)	O
;	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
multiple_common	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
abfd	pointer
,	O
bfd_link_hash_indirect	int
,	O
0	int
)	O
;	O
case	O
IND	int
:	O
if	O
(	O
inh	pointer
->	O
type	enum
==	O
bfd_link_hash_indirect	int
&&	O
inh	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
==	O
h	pointer
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: indirect symbol `%s' to `%s' is a loop"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
,	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
inh	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
)	O
{	O
inh	pointer
->	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
inh	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
bfd_link_add_undef	function
(	O
info	pointer
->	O
hash	long
,	O
inh	pointer
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_new	int
)	O
{	O
row	enum
=	O
UNDEF_ROW	int
;	O
cycle	int
=	O
TRUE	int
;	O
}	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_indirect	int
;	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
=	O
inh	pointer
;	O
break	O
;	O
case	O
SET	int
:	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
add_to_set	pointer
)	O
(	O
info	pointer
,	O
h	pointer
,	O
BFD_RELOC_CTOR	int
,	O
abfd	pointer
,	O
section	pointer
,	O
value	long
)	O
;	O
break	O
;	O
case	O
WARNC	int
:	O
if	O
(	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
warning	pointer
!=	O
NULL	O
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
==	O
0	int
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
warning	pointer
)	O
(	O
info	pointer
,	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
warning	pointer
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
,	O
abfd	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
warning	pointer
=	O
NULL	O
;	O
}	O
case	O
CYCLE	int
:	O
h	pointer
=	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
;	O
cycle	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
REFC	int
:	O
if	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
==	O
NULL	O
&&	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
!=	O
h	pointer
)	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
=	O
h	pointer
;	O
h	pointer
=	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
;	O
cycle	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
WARN	int
:	O
if	O
(	O
(	O
!	O
info	pointer
->	O
lto_plugin_active	int
&&	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
!=	O
NULL	O
||	O
info	pointer
->	O
hash	long
->	O
undefs_tail	pointer
==	O
h	pointer
)	O
)	O
||	O
h	pointer
->	O
non_ir_ref_regular	int
||	O
h	pointer
->	O
non_ir_ref_dynamic	int
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
warning	pointer
)	O
(	O
info	pointer
,	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
,	O
hash_entry_bfd	function
(	O
h	pointer
)	O
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
MWARN	int
:	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
sub	pointer
;	O
sub	pointer
=	O
(	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
(	O
(	O
*	O
info	pointer
->	O
hash	long
->	O
table	pointer
.	O
newfunc	pointer
)	O
(	O
NULL	O
,	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
h	pointer
->	O
root	struct
.	O
string	pointer
)	O
)	O
)	O
;	O
if	O
(	O
sub	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
*	O
sub	pointer
=	O
*	O
h	pointer
;	O
sub	pointer
->	O
type	enum
=	O
bfd_link_hash_warning	int
;	O
sub	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
=	O
h	pointer
;	O
if	O
(	O
!	O
copy	int
)	O
sub	pointer
->	O
u	union
.	O
i	pointer
.	O
warning	pointer
=	O
string	pointer
;	O
else	O
{	O
char	O
*	O
w	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
;	O
w	pointer
=	O
(	O
char	O
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
len	long
)	O
;	O
if	O
(	O
w	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
w	pointer
,	O
string	pointer
,	O
len	long
)	O
;	O
sub	pointer
->	O
u	union
.	O
i	pointer
.	O
warning	pointer
=	O
w	pointer
;	O
}	O
bfd_hash_replace	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
h	pointer
,	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
sub	pointer
)	O
;	O
if	O
(	O
hashp	pointer
!=	O
NULL	O
)	O
*	O
hashp	pointer
=	O
sub	pointer
;	O
}	O
break	O
;	O
}	O
}	O
while	O
(	O
cycle	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_final_link	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
sub	pointer
;	O
asection	struct
*	O
o	pointer
;	O
struct	O
bfd_link_order	struct
*	O
p	pointer
;	O
size_t	long
outsymalloc	long
;	O
struct	O
generic_write_global_symbol_info	struct
wginfo	struct
;	O
abfd	pointer
->	O
outsymbols	pointer
=	O
NULL	O
;	O
abfd	pointer
->	O
symcount	int
=	O
0	int
;	O
outsymalloc	long
=	O
0	int
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
linker_mark	int
=	O
TRUE	int
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
!	O
_bfd_generic_link_output_symbols	function
(	O
abfd	pointer
,	O
sub	pointer
,	O
info	pointer
,	O
&	O
outsymalloc	long
)	O
)	O
return	O
FALSE	int
;	O
wginfo	struct
.	O
info	pointer
=	O
info	pointer
;	O
wginfo	struct
.	O
output_bfd	pointer
=	O
abfd	pointer
;	O
wginfo	struct
.	O
psymalloc	pointer
=	O
&	O
outsymalloc	long
;	O
_bfd_generic_link_hash_traverse	O
(	O
_bfd_generic_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_generic_link_write_global_symbol	function
,	O
&	O
wginfo	struct
)	O
;	O
if	O
(	O
!	O
generic_add_output_symbol	function
(	O
abfd	pointer
,	O
&	O
outsymalloc	long
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
o	pointer
->	O
reloc_count	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
||	O
p	pointer
->	O
type	enum
==	O
bfd_symbol_reloc_link_order	int
)	O
++	O
o	pointer
->	O
reloc_count	int
;	O
else	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
asection	struct
*	O
input_section	pointer
;	O
bfd	struct
*	O
input_bfd	pointer
;	O
long	O
relsize	long
;	O
arelent	struct
*	O
*	O
relocs	pointer
;	O
asymbol	struct
*	O
*	O
symbols	pointer
;	O
long	O
reloc_count	int
;	O
input_section	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
input_bfd	pointer
=	O
input_section	pointer
->	O
owner	pointer
;	O
relsize	long
=	O
bfd_get_reloc_upper_bound	function
(	O
input_bfd	pointer
,	O
input_section	pointer
)	O
;	O
if	O
(	O
relsize	long
<	O
0	int
)	O
return	O
FALSE	int
;	O
relocs	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
relsize	long
)	O
;	O
if	O
(	O
!	O
relocs	pointer
&&	O
relsize	long
!=	O
0	int
)	O
return	O
FALSE	int
;	O
symbols	pointer
=	O
_bfd_generic_link_get_symbols	O
(	O
input_bfd	pointer
)	O
;	O
reloc_count	int
=	O
bfd_canonicalize_reloc	function
(	O
input_bfd	pointer
,	O
input_section	pointer
,	O
relocs	pointer
,	O
symbols	pointer
)	O
;	O
free	function
(	O
relocs	pointer
)	O
;	O
if	O
(	O
reloc_count	int
<	O
0	int
)	O
return	O
FALSE	int
;	O
BFD_ASSERT	O
(	O
(	O
unsigned	O
long	O
)	O
reloc_count	int
==	O
input_section	pointer
->	O
reloc_count	int
)	O
;	O
o	pointer
->	O
reloc_count	int
+=	O
reloc_count	int
;	O
}	O
}	O
if	O
(	O
o	pointer
->	O
reloc_count	int
>	O
0	int
)	O
{	O
bfd_size_type	long
amt	long
;	O
amt	long
=	O
o	pointer
->	O
reloc_count	int
;	O
amt	long
*=	O
sizeof	O
(	O
arelent	struct
*	O
)	O
;	O
o	pointer
->	O
orelocation	pointer
=	O
(	O
struct	O
reloc_cache_entry	struct
*	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
!	O
o	pointer
->	O
orelocation	pointer
)	O
return	O
FALSE	int
;	O
o	pointer
->	O
flags	int
|=	O
SEC_RELOC	int
;	O
o	pointer
->	O
reloc_count	int
=	O
0	int
;	O
}	O
}	O
}	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
p	pointer
->	O
type	enum
)	O
{	O
case	O
bfd_section_reloc_link_order	int
:	O
case	O
bfd_symbol_reloc_link_order	int
:	O
if	O
(	O
!	O
_bfd_generic_reloc_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
p	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
bfd_indirect_link_order	int
:	O
if	O
(	O
!	O
default_indirect_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
p	pointer
,	O
TRUE	int
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
_bfd_default_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
p	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
generic_add_output_symbol	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
size_t	long
*	O
psymalloc	pointer
,	O
asymbol	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
bfd_get_symcount	function
(	O
output_bfd	pointer
)	O
>=	O
*	O
psymalloc	pointer
)	O
{	O
asymbol	struct
*	O
*	O
newsyms	pointer
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
*	O
psymalloc	pointer
==	O
0	int
)	O
*	O
psymalloc	pointer
=	O
124	int
;	O
else	O
*	O
psymalloc	pointer
*=	O
2	int
;	O
amt	long
=	O
*	O
psymalloc	pointer
;	O
amt	long
*=	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
;	O
newsyms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_realloc	function
(	O
bfd_get_outsymbols	function
(	O
output_bfd	pointer
)	O
,	O
amt	long
)	O
;	O
if	O
(	O
newsyms	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
output_bfd	pointer
->	O
outsymbols	pointer
=	O
newsyms	pointer
;	O
}	O
output_bfd	pointer
->	O
outsymbols	pointer
[	O
output_bfd	pointer
->	O
symcount	int
]	O
=	O
sym	pointer
;	O
if	O
(	O
sym	pointer
!=	O
NULL	O
)	O
++	O
output_bfd	pointer
->	O
symcount	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_link_output_symbols	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
size_t	long
*	O
psymalloc	pointer
)	O
{	O
asymbol	struct
*	O
*	O
sym_ptr	pointer
;	O
asymbol	struct
*	O
*	O
sym_end	pointer
;	O
if	O
(	O
!	O
bfd_generic_link_read_symbols	function
(	O
input_bfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
create_object_symbols_section	pointer
!=	O
NULL	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
for	O
(	O
sec	pointer
=	O
input_bfd	pointer
->	O
sections	pointer
;	O
sec	pointer
!=	O
NULL	O
;	O
sec	pointer
=	O
sec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
output_section	pointer
==	O
info	pointer
->	O
create_object_symbols_section	pointer
)	O
{	O
asymbol	struct
*	O
newsym	pointer
;	O
newsym	pointer
=	O
bfd_make_empty_symbol	O
(	O
input_bfd	pointer
)	O
;	O
if	O
(	O
!	O
newsym	pointer
)	O
return	O
FALSE	int
;	O
newsym	pointer
->	O
name	pointer
=	O
input_bfd	pointer
->	O
filename	pointer
;	O
newsym	pointer
->	O
value	long
=	O
0	int
;	O
newsym	pointer
->	O
flags	int
=	O
BSF_LOCAL	O
|	O
BSF_FILE	O
;	O
newsym	pointer
->	O
section	pointer
=	O
sec	pointer
;	O
if	O
(	O
!	O
generic_add_output_symbol	function
(	O
output_bfd	pointer
,	O
psymalloc	pointer
,	O
newsym	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
}	O
sym_ptr	pointer
=	O
_bfd_generic_link_get_symbols	O
(	O
input_bfd	pointer
)	O
;	O
sym_end	pointer
=	O
sym_ptr	pointer
+	O
_bfd_generic_link_get_symcount	O
(	O
input_bfd	pointer
)	O
;	O
for	O
(	O
;	O
sym_ptr	pointer
<	O
sym_end	pointer
;	O
sym_ptr	pointer
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
;	O
struct	O
generic_link_hash_entry	struct
*	O
h	pointer
;	O
bfd_boolean	int
output	pointer
;	O
h	pointer
=	O
NULL	O
;	O
sym	pointer
=	O
*	O
sym_ptr	pointer
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_INDIRECT	O
|	O
BSF_WARNING	O
|	O
BSF_GLOBAL	O
|	O
BSF_CONSTRUCTOR	O
|	O
BSF_WEAK	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
||	O
bfd_is_ind_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
{	O
if	O
(	O
sym	pointer
->	O
udata	union
.	O
p	pointer
!=	O
NULL	O
)	O
h	pointer
=	O
(	O
struct	O
generic_link_hash_entry	struct
*	O
)	O
sym	pointer
->	O
udata	union
.	O
p	pointer
;	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_CONSTRUCTOR	O
)	O
!=	O
0	int
)	O
{	O
h	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
h	pointer
=	O
(	O
(	O
struct	O
generic_link_hash_entry	struct
*	O
)	O
bfd_wrapped_link_hash_lookup	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
)	O
;	O
else	O
h	pointer
=	O
_bfd_generic_link_hash_lookup	O
(	O
_bfd_generic_hash_table	O
(	O
info	pointer
)	O
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
info	pointer
->	O
output_bfd	pointer
->	O
xvec	pointer
==	O
input_bfd	pointer
->	O
xvec	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
sym	pointer
!=	O
NULL	O
)	O
*	O
sym_ptr	pointer
=	O
sym	pointer
=	O
h	pointer
->	O
sym	pointer
;	O
}	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
default	O
:	O
case	O
bfd_link_hash_new	int
:	O
abort	function
(	O
)	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
break	O
;	O
case	O
bfd_link_hash_undefweak	int
:	O
sym	pointer
->	O
flags	int
|=	O
BSF_WEAK	O
;	O
break	O
;	O
case	O
bfd_link_hash_indirect	int
:	O
h	pointer
=	O
(	O
struct	O
generic_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
case	O
bfd_link_hash_defined	int
:	O
sym	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
sym	pointer
->	O
flags	int
&=	O
~	O
(	O
BSF_WEAK	O
|	O
BSF_CONSTRUCTOR	O
)	O
;	O
sym	pointer
->	O
value	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
sym	pointer
->	O
section	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
break	O
;	O
case	O
bfd_link_hash_defweak	int
:	O
sym	pointer
->	O
flags	int
|=	O
BSF_WEAK	O
;	O
sym	pointer
->	O
flags	int
&=	O
~	O
BSF_CONSTRUCTOR	O
;	O
sym	pointer
->	O
value	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
sym	pointer
->	O
section	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
break	O
;	O
case	O
bfd_link_hash_common	int
:	O
sym	pointer
->	O
value	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
size	long
;	O
sym	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
if	O
(	O
!	O
bfd_is_com_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
{	O
BFD_ASSERT	O
(	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
;	O
sym	pointer
->	O
section	pointer
=	O
bfd_com_section_ptr	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_KEEP	O
)	O
==	O
0	int
&&	O
(	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
||	O
(	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
bfd_hash_lookup	function
(	O
info	pointer
->	O
keep_hash	pointer
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
)	O
)	O
output	pointer
=	O
FALSE	int
;	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
|	O
BSF_GNU_UNIQUE	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
bfd_asymbol_bfd	function
(	O
sym	pointer
)	O
==	O
input_bfd	pointer
&&	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_NOT_AT_END	O
)	O
!=	O
0	int
)	O
output	pointer
=	O
TRUE	int
;	O
else	O
output	pointer
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_KEEP	O
)	O
!=	O
0	int
)	O
output	pointer
=	O
TRUE	int
;	O
else	O
if	O
(	O
bfd_is_ind_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
output	pointer
=	O
FALSE	int
;	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
info	pointer
->	O
strip	enum
==	O
strip_none	int
)	O
output	pointer
=	O
TRUE	int
;	O
else	O
output	pointer
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
||	O
bfd_is_com_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
output	pointer
=	O
FALSE	int
;	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_WARNING	O
)	O
!=	O
0	int
)	O
output	pointer
=	O
FALSE	int
;	O
else	O
{	O
switch	O
(	O
info	pointer
->	O
discard	enum
)	O
{	O
default	O
:	O
case	O
discard_all	int
:	O
output	pointer
=	O
FALSE	int
;	O
break	O
;	O
case	O
discard_sec_merge	int
:	O
output	pointer
=	O
TRUE	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
||	O
!	O
(	O
sym	pointer
->	O
section	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
)	O
break	O
;	O
case	O
discard_l	int
:	O
if	O
(	O
bfd_is_local_label	function
(	O
input_bfd	pointer
,	O
sym	pointer
)	O
)	O
output	pointer
=	O
FALSE	int
;	O
else	O
output	pointer
=	O
TRUE	int
;	O
break	O
;	O
case	O
discard_none	int
:	O
output	pointer
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_CONSTRUCTOR	O
)	O
)	O
{	O
if	O
(	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
)	O
output	pointer
=	O
TRUE	int
;	O
else	O
output	pointer
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
sym	pointer
->	O
flags	int
==	O
0	int
&&	O
(	O
sym	pointer
->	O
section	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
output	pointer
=	O
FALSE	int
;	O
else	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_is_abs_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
&&	O
bfd_section_removed_from_list	function
(	O
output_bfd	pointer
,	O
sym	pointer
->	O
section	pointer
->	O
output_section	pointer
)	O
)	O
output	pointer
=	O
FALSE	int
;	O
if	O
(	O
output	pointer
)	O
{	O
if	O
(	O
!	O
generic_add_output_symbol	function
(	O
output_bfd	pointer
,	O
psymalloc	pointer
,	O
sym	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
h	pointer
->	O
written	int
=	O
TRUE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
set_symbol_from_hash	function
(	O
asymbol	struct
*	O
sym	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
switch	O
(	O
h	pointer
->	O
type	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
break	O
;	O
case	O
bfd_link_hash_new	int
:	O
if	O
(	O
sym	pointer
->	O
section	pointer
!=	O
NULL	O
)	O
{	O
BFD_ASSERT	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_CONSTRUCTOR	O
)	O
!=	O
0	int
)	O
;	O
}	O
else	O
{	O
sym	pointer
->	O
flags	int
|=	O
BSF_CONSTRUCTOR	O
;	O
sym	pointer
->	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
sym	pointer
->	O
value	long
=	O
0	int
;	O
}	O
break	O
;	O
case	O
bfd_link_hash_undefined	int
:	O
sym	pointer
->	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
sym	pointer
->	O
value	long
=	O
0	int
;	O
break	O
;	O
case	O
bfd_link_hash_undefweak	int
:	O
sym	pointer
->	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
sym	pointer
->	O
value	long
=	O
0	int
;	O
sym	pointer
->	O
flags	int
|=	O
BSF_WEAK	O
;	O
break	O
;	O
case	O
bfd_link_hash_defined	int
:	O
sym	pointer
->	O
section	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
sym	pointer
->	O
value	long
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
;	O
break	O
;	O
case	O
bfd_link_hash_defweak	int
:	O
sym	pointer
->	O
flags	int
|=	O
BSF_WEAK	O
;	O
sym	pointer
->	O
section	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
sym	pointer
->	O
value	long
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
;	O
break	O
;	O
case	O
bfd_link_hash_common	int
:	O
sym	pointer
->	O
value	long
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
;	O
if	O
(	O
sym	pointer
->	O
section	pointer
==	O
NULL	O
)	O
sym	pointer
->	O
section	pointer
=	O
bfd_com_section_ptr	O
;	O
else	O
if	O
(	O
!	O
bfd_is_com_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
{	O
BFD_ASSERT	O
(	O
bfd_is_und_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
;	O
sym	pointer
->	O
section	pointer
=	O
bfd_com_section_ptr	O
;	O
}	O
break	O
;	O
case	O
bfd_link_hash_indirect	int
:	O
case	O
bfd_link_hash_warning	int
:	O
break	O
;	O
}	O
}	O
bfd_boolean	int
_bfd_generic_link_write_global_symbol	function
(	O
struct	O
generic_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
generic_write_global_symbol_info	struct
*	O
wginfo	struct
=	O
(	O
struct	O
generic_write_global_symbol_info	struct
*	O
)	O
data	pointer
;	O
asymbol	struct
*	O
sym	pointer
;	O
if	O
(	O
h	pointer
->	O
written	int
)	O
return	O
TRUE	int
;	O
h	pointer
->	O
written	int
=	O
TRUE	int
;	O
if	O
(	O
wginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
||	O
(	O
wginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
bfd_hash_lookup	function
(	O
wginfo	struct
->	O
info	pointer
->	O
keep_hash	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
sym	pointer
!=	O
NULL	O
)	O
sym	pointer
=	O
h	pointer
->	O
sym	pointer
;	O
else	O
{	O
sym	pointer
=	O
bfd_make_empty_symbol	O
(	O
wginfo	struct
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
!	O
sym	pointer
)	O
return	O
FALSE	int
;	O
sym	pointer
->	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
sym	pointer
->	O
flags	int
=	O
0	int
;	O
}	O
set_symbol_from_hash	function
(	O
sym	pointer
,	O
&	O
h	pointer
->	O
root	struct
)	O
;	O
sym	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
if	O
(	O
!	O
generic_add_output_symbol	function
(	O
wginfo	struct
->	O
output_bfd	pointer
,	O
wginfo	struct
->	O
psymalloc	pointer
,	O
sym	pointer
)	O
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_reloc_link_order	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
)	O
{	O
arelent	struct
*	O
r	pointer
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
sec	pointer
->	O
orelocation	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
r	pointer
=	O
(	O
arelent	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
arelent	struct
)	O
)	O
;	O
if	O
(	O
r	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
r	pointer
->	O
address	long
=	O
link_order	pointer
->	O
offset	long
;	O
r	pointer
->	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
abfd	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
reloc	enum
)	O
;	O
if	O
(	O
r	pointer
->	O
howto	pointer
==	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
)	O
r	pointer
->	O
sym_ptr_ptr	pointer
=	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
section	pointer
->	O
symbol_ptr_ptr	pointer
;	O
else	O
{	O
struct	O
generic_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
(	O
(	O
struct	O
generic_link_hash_entry	struct
*	O
)	O
bfd_wrapped_link_hash_lookup	function
(	O
abfd	pointer
,	O
info	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
!	O
h	pointer
->	O
written	int
)	O
{	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
unattached_reloc	pointer
)	O
(	O
info	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
r	pointer
->	O
sym_ptr_ptr	pointer
=	O
&	O
h	pointer
->	O
sym	pointer
;	O
}	O
if	O
(	O
!	O
r	pointer
->	O
howto	pointer
->	O
partial_inplace	int
)	O
r	pointer
->	O
addend	long
=	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
;	O
else	O
{	O
bfd_size_type	long
size	long
;	O
bfd_reloc_status_type	enum
rstat	enum
;	O
bfd_byte	char
*	O
buf	pointer
;	O
bfd_boolean	int
ok	int
;	O
file_ptr	long
loc	pointer
;	O
size	long
=	O
bfd_get_reloc_size	function
(	O
r	pointer
->	O
howto	pointer
)	O
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_zmalloc	function
(	O
size	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
&&	O
size	long
!=	O
0	int
)	O
return	O
FALSE	int
;	O
rstat	enum
=	O
_bfd_relocate_contents	function
(	O
r	pointer
->	O
howto	pointer
,	O
abfd	pointer
,	O
(	O
bfd_vma	long
)	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
,	O
buf	pointer
)	O
;	O
switch	O
(	O
rstat	enum
)	O
{	O
case	O
bfd_reloc_ok	int
:	O
break	O
;	O
default	O
:	O
case	O
bfd_reloc_outofrange	int
:	O
abort	function
(	O
)	O
;	O
case	O
bfd_reloc_overflow	int
:	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
info	pointer
,	O
NULL	O
,	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
?	O
bfd_section_name	function
(	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
section	pointer
)	O
:	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
)	O
,	O
r	pointer
->	O
howto	pointer
->	O
name	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
loc	pointer
=	O
link_order	pointer
->	O
offset	long
*	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
ok	int
=	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
buf	pointer
,	O
loc	pointer
,	O
size	long
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
FALSE	int
;	O
r	pointer
->	O
addend	long
=	O
0	int
;	O
}	O
sec	pointer
->	O
orelocation	pointer
[	O
sec	pointer
->	O
reloc_count	int
]	O
=	O
r	pointer
;	O
++	O
sec	pointer
->	O
reloc_count	int
;	O
return	O
TRUE	int
;	O
}	O
struct	O
bfd_link_order	struct
*	O
bfd_new_link_order	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
bfd_link_order	struct
)	O
;	O
struct	O
bfd_link_order	struct
*	O
new_lo	pointer
;	O
new_lo	pointer
=	O
(	O
struct	O
bfd_link_order	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
!	O
new_lo	pointer
)	O
return	O
NULL	O
;	O
new_lo	pointer
->	O
type	enum
=	O
bfd_undefined_link_order	int
;	O
if	O
(	O
section	pointer
->	O
map_tail	union
.	O
link_order	pointer
!=	O
NULL	O
)	O
section	pointer
->	O
map_tail	union
.	O
link_order	pointer
->	O
next	pointer
=	O
new_lo	pointer
;	O
else	O
section	pointer
->	O
map_head	union
.	O
link_order	pointer
=	O
new_lo	pointer
;	O
section	pointer
->	O
map_tail	union
.	O
link_order	pointer
=	O
new_lo	pointer
;	O
return	O
new_lo	pointer
;	O
}	O
bfd_boolean	int
_bfd_default_link_order	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
)	O
{	O
switch	O
(	O
link_order	pointer
->	O
type	enum
)	O
{	O
case	O
bfd_undefined_link_order	int
:	O
case	O
bfd_section_reloc_link_order	int
:	O
case	O
bfd_symbol_reloc_link_order	int
:	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
bfd_indirect_link_order	int
:	O
return	O
default_indirect_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
,	O
link_order	pointer
,	O
FALSE	int
)	O
;	O
case	O
bfd_data_link_order	int
:	O
return	O
default_data_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
,	O
link_order	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
default_data_link_order	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
)	O
{	O
bfd_size_type	long
size	long
;	O
size_t	long
fill_size	long
;	O
bfd_byte	char
*	O
fill	pointer
;	O
file_ptr	long
loc	pointer
;	O
bfd_boolean	int
result	int
;	O
BFD_ASSERT	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
!=	O
0	int
)	O
;	O
size	long
=	O
link_order	pointer
->	O
size	long
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
fill	pointer
=	O
link_order	pointer
->	O
u	union
.	O
data	pointer
.	O
contents	pointer
;	O
fill_size	long
=	O
link_order	pointer
->	O
u	union
.	O
data	pointer
.	O
size	long
;	O
if	O
(	O
fill_size	long
==	O
0	int
)	O
{	O
fill	pointer
=	O
abfd	pointer
->	O
arch_info	pointer
->	O
fill	pointer
(	O
size	long
,	O
info	pointer
->	O
big_endian	int
,	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
fill	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
fill_size	long
<	O
size	long
)	O
{	O
bfd_byte	char
*	O
p	pointer
;	O
fill	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
fill	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
p	pointer
=	O
fill	pointer
;	O
if	O
(	O
fill_size	long
==	O
1	int
)	O
memset	function
(	O
p	pointer
,	O
(	O
int	O
)	O
link_order	pointer
->	O
u	union
.	O
data	pointer
.	O
contents	pointer
[	O
0	int
]	O
,	O
(	O
size_t	long
)	O
size	long
)	O
;	O
else	O
{	O
do	O
{	O
memcpy	function
(	O
p	pointer
,	O
link_order	pointer
->	O
u	union
.	O
data	pointer
.	O
contents	pointer
,	O
fill_size	long
)	O
;	O
p	pointer
+=	O
fill_size	long
;	O
size	long
-=	O
fill_size	long
;	O
}	O
while	O
(	O
size	long
>=	O
fill_size	long
)	O
;	O
if	O
(	O
size	long
!=	O
0	int
)	O
memcpy	function
(	O
p	pointer
,	O
link_order	pointer
->	O
u	union
.	O
data	pointer
.	O
contents	pointer
,	O
(	O
size_t	long
)	O
size	long
)	O
;	O
size	long
=	O
link_order	pointer
->	O
size	long
;	O
}	O
}	O
loc	pointer
=	O
link_order	pointer
->	O
offset	long
*	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
result	int
=	O
bfd_set_section_contents	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
fill	pointer
,	O
loc	pointer
,	O
size	long
)	O
;	O
if	O
(	O
fill	pointer
!=	O
link_order	pointer
->	O
u	union
.	O
data	pointer
.	O
contents	pointer
)	O
free	function
(	O
fill	pointer
)	O
;	O
return	O
result	int
;	O
}	O
static	O
bfd_boolean	int
default_indirect_link_order	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
output_section	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
,	O
bfd_boolean	int
generic_linker	int
)	O
{	O
asection	struct
*	O
input_section	pointer
;	O
bfd	struct
*	O
input_bfd	pointer
;	O
bfd_byte	char
*	O
contents	pointer
=	O
NULL	O
;	O
bfd_byte	char
*	O
new_contents	pointer
;	O
bfd_size_type	long
sec_size	long
;	O
file_ptr	long
loc	pointer
;	O
BFD_ASSERT	O
(	O
(	O
output_section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
!=	O
0	int
)	O
;	O
input_section	pointer
=	O
link_order	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
input_bfd	pointer
=	O
input_section	pointer
->	O
owner	pointer
;	O
if	O
(	O
input_section	pointer
->	O
size	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
BFD_ASSERT	O
(	O
input_section	pointer
->	O
output_section	pointer
==	O
output_section	pointer
)	O
;	O
BFD_ASSERT	O
(	O
input_section	pointer
->	O
output_offset	long
==	O
link_order	pointer
->	O
offset	long
)	O
;	O
BFD_ASSERT	O
(	O
input_section	pointer
->	O
size	long
==	O
link_order	pointer
->	O
size	long
)	O
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
input_section	pointer
->	O
reloc_count	int
>	O
0	int
&&	O
output_section	pointer
->	O
orelocation	pointer
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"attempt to do relocatable link with %s input and %s output"	pointer
)	O
,	O
bfd_get_target	function
(	O
input_bfd	pointer
)	O
,	O
bfd_get_target	function
(	O
output_bfd	pointer
)	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
generic_linker	int
)	O
{	O
asymbol	struct
*	O
*	O
sympp	pointer
;	O
asymbol	struct
*	O
*	O
symppend	pointer
;	O
if	O
(	O
!	O
bfd_generic_link_read_symbols	function
(	O
input_bfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
sympp	pointer
=	O
_bfd_generic_link_get_symbols	O
(	O
input_bfd	pointer
)	O
;	O
symppend	pointer
=	O
sympp	pointer
+	O
_bfd_generic_link_get_symcount	O
(	O
input_bfd	pointer
)	O
;	O
for	O
(	O
;	O
sympp	pointer
<	O
symppend	pointer
;	O
sympp	pointer
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
sym	pointer
=	O
*	O
sympp	pointer
;	O
if	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_INDIRECT	O
|	O
BSF_WARNING	O
|	O
BSF_GLOBAL	O
|	O
BSF_CONSTRUCTOR	O
|	O
BSF_WEAK	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
||	O
bfd_is_ind_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
{	O
if	O
(	O
sym	pointer
->	O
udata	union
.	O
p	pointer
!=	O
NULL	O
)	O
h	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
sym	pointer
->	O
udata	union
.	O
p	pointer
;	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
h	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
else	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
set_symbol_from_hash	function
(	O
sym	pointer
,	O
h	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
output_section	pointer
->	O
flags	int
&	O
(	O
SEC_GROUP	int
|	O
SEC_LINKER_CREATED	int
)	O
)	O
==	O
SEC_GROUP	int
&&	O
input_section	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
output_bfd	pointer
->	O
output_has_begun	int
)	O
{	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
output_section	pointer
,	O
""	pointer
,	O
0	int
,	O
1	int
)	O
)	O
goto	O
error_return	O
;	O
}	O
new_contents	pointer
=	O
output_section	pointer
->	O
contents	pointer
;	O
BFD_ASSERT	O
(	O
new_contents	pointer
!=	O
NULL	O
)	O
;	O
BFD_ASSERT	O
(	O
input_section	pointer
->	O
output_offset	long
==	O
0	int
)	O
;	O
}	O
else	O
{	O
sec_size	long
=	O
(	O
input_section	pointer
->	O
rawsize	long
>	O
input_section	pointer
->	O
size	long
?	O
input_section	pointer
->	O
rawsize	long
:	O
input_section	pointer
->	O
size	long
)	O
;	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
sec_size	long
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
&&	O
sec_size	long
!=	O
0	int
)	O
goto	O
error_return	O
;	O
new_contents	pointer
=	O
(	O
bfd_get_relocated_section_contents	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
link_order	pointer
,	O
contents	pointer
,	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
,	O
_bfd_generic_link_get_symbols	O
(	O
input_bfd	pointer
)	O
)	O
)	O
;	O
if	O
(	O
!	O
new_contents	pointer
)	O
goto	O
error_return	O
;	O
}	O
loc	pointer
=	O
(	O
input_section	pointer
->	O
output_offset	long
*	O
bfd_octets_per_byte	function
(	O
output_bfd	pointer
,	O
output_section	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
output_section	pointer
,	O
new_contents	pointer
,	O
loc	pointer
,	O
input_section	pointer
->	O
size	long
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
contents	pointer
!=	O
NULL	O
)	O
free	function
(	O
contents	pointer
)	O
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
contents	pointer
!=	O
NULL	O
)	O
free	function
(	O
contents	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
unsigned	O
int	O
_bfd_count_link_order_relocs	function
(	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
)	O
{	O
register	O
unsigned	O
int	O
c	struct
;	O
register	O
struct	O
bfd_link_order	struct
*	O
l	pointer
;	O
c	struct
=	O
0	int
;	O
for	O
(	O
l	pointer
=	O
link_order	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
||	O
l	pointer
->	O
type	enum
==	O
bfd_symbol_reloc_link_order	int
)	O
++	O
c	struct
;	O
}	O
return	O
c	struct
;	O
}	O
bfd_boolean	int
_bfd_generic_link_split_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
FALSE	int
;	O
}	O
static	O
struct	O
bfd_hash_table	struct
_bfd_section_already_linked_table	struct
;	O
void	O
bfd_section_already_linked_table_traverse	function
(	O
bfd_boolean	int
(	O
*	O
func	pointer
)	O
(	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
info	pointer
)	O
{	O
bfd_hash_traverse	function
(	O
&	O
_bfd_section_already_linked_table	struct
,	O
(	O
bfd_boolean	int
(	O
*	O
)	O
(	O
struct	O
bfd_hash_entry	struct
*	O
,	O
void	O
*	O
)	O
)	O
func	pointer
,	O
info	pointer
)	O
;	O
}	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
bfd_section_already_linked_table_lookup	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
(	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
)	O
bfd_hash_lookup	function
(	O
&	O
_bfd_section_already_linked_table	struct
,	O
name	pointer
,	O
TRUE	int
,	O
FALSE	int
)	O
)	O
;	O
}	O
bfd_boolean	int
bfd_section_already_linked_table_insert	function
(	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
already_linked_list	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
bfd_section_already_linked	function
*	O
l	pointer
;	O
l	pointer
=	O
(	O
struct	O
bfd_section_already_linked	function
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
_bfd_section_already_linked_table	struct
,	O
sizeof	O
*	O
l	pointer
)	O
;	O
if	O
(	O
l	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
l	pointer
->	O
sec	pointer
=	O
sec	pointer
;	O
l	pointer
->	O
next	pointer
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
already_linked_list	pointer
->	O
entry	pointer
=	O
l	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
struct	O
bfd_hash_entry	struct
*	O
already_linked_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
ret	pointer
=	O
(	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
*	O
ret	pointer
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
ret	pointer
->	O
entry	pointer
=	O
NULL	O
;	O
return	O
&	O
ret	pointer
->	O
root	struct
;	O
}	O
bfd_boolean	int
bfd_section_already_linked_table_init	function
(	O
void	O
)	O
{	O
return	O
bfd_hash_table_init_n	function
(	O
&	O
_bfd_section_already_linked_table	struct
,	O
already_linked_newfunc	function
,	O
sizeof	O
(	O
struct	O
bfd_section_already_linked_hash_entry	struct
)	O
,	O
42	int
)	O
;	O
}	O
void	O
bfd_section_already_linked_table_free	function
(	O
void	O
)	O
{	O
bfd_hash_table_free	function
(	O
&	O
_bfd_section_already_linked_table	struct
)	O
;	O
}	O
bfd_boolean	int
_bfd_handle_already_linked	function
(	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_section_already_linked	function
*	O
l	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
switch	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINK_DUPLICATES	int
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
SEC_LINK_DUPLICATES_DISCARD	int
:	O
if	O
(	O
sec	pointer
->	O
owner	pointer
->	O
lto_output	int
&&	O
(	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
{	O
l	pointer
->	O
sec	pointer
=	O
sec	pointer
;	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
SEC_LINK_DUPLICATES_ONE_ONLY	int
:	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%pB: ignoring duplicate section `%pA'\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
break	O
;	O
case	O
SEC_LINK_DUPLICATES_SAME_SIZE	int
:	O
if	O
(	O
(	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
;	O
else	O
if	O
(	O
sec	pointer
->	O
size	long
!=	O
l	pointer
->	O
sec	pointer
->	O
size	long
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%pB: duplicate section `%pA' has different size\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
break	O
;	O
case	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
:	O
if	O
(	O
(	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
;	O
else	O
if	O
(	O
sec	pointer
->	O
size	long
!=	O
l	pointer
->	O
sec	pointer
->	O
size	long
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%pB: duplicate section `%pA' has different size\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
else	O
if	O
(	O
sec	pointer
->	O
size	long
!=	O
0	int
)	O
{	O
bfd_byte	char
*	O
sec_contents	pointer
,	O
*	O
l_sec_contents	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
,	O
&	O
sec_contents	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%pB: could not read contents of section `%pA'\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
else	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
,	O
l	pointer
->	O
sec	pointer
,	O
&	O
l_sec_contents	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%pB: could not read contents of section `%pA'\n"	pointer
)	O
,	O
l	pointer
->	O
sec	pointer
->	O
owner	pointer
,	O
l	pointer
->	O
sec	pointer
)	O
;	O
else	O
if	O
(	O
memcmp	function
(	O
sec_contents	pointer
,	O
l_sec_contents	pointer
,	O
sec	pointer
->	O
size	long
)	O
!=	O
0	int
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%pB: duplicate section `%pA' has different contents\n"	pointer
)	O
,	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
sec_contents	pointer
)	O
free	function
(	O
sec_contents	pointer
)	O
;	O
if	O
(	O
l_sec_contents	pointer
)	O
free	function
(	O
l_sec_contents	pointer
)	O
;	O
}	O
break	O
;	O
}	O
sec	pointer
->	O
output_section	pointer
=	O
bfd_abs_section_ptr	O
;	O
sec	pointer
->	O
kept_section	pointer
=	O
l	pointer
->	O
sec	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_section_already_linked	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
bfd_section_already_linked	function
*	O
l	pointer
;	O
struct	O
bfd_section_already_linked_hash_entry	struct
*	O
already_linked_list	pointer
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_LINK_ONCE	int
)	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
already_linked_list	pointer
=	O
bfd_section_already_linked_table_lookup	function
(	O
name	pointer
)	O
;	O
l	pointer
=	O
already_linked_list	pointer
->	O
entry	pointer
;	O
if	O
(	O
l	pointer
!=	O
NULL	O
)	O
{	O
return	O
_bfd_handle_already_linked	function
(	O
sec	pointer
,	O
l	pointer
,	O
info	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bfd_section_already_linked_table_insert	function
(	O
already_linked_list	pointer
,	O
sec	pointer
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: already_linked_table: %E\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
asection	struct
*	O
_bfd_nearby_section	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
asection	struct
*	O
s	pointer
,	O
bfd_vma	long
addr	pointer
)	O
{	O
asection	struct
*	O
next	pointer
,	O
*	O
prev	pointer
,	O
*	O
best	pointer
;	O
for	O
(	O
prev	pointer
=	O
s	pointer
->	O
prev	pointer
;	O
prev	pointer
!=	O
NULL	O
;	O
prev	pointer
=	O
prev	pointer
->	O
prev	pointer
)	O
if	O
(	O
(	O
prev	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
!	O
bfd_section_removed_from_list	function
(	O
obfd	pointer
,	O
prev	pointer
)	O
)	O
break	O
;	O
if	O
(	O
s	pointer
->	O
prev	pointer
!=	O
NULL	O
)	O
next	pointer
=	O
s	pointer
->	O
prev	pointer
->	O
next	pointer
;	O
else	O
next	pointer
=	O
s	pointer
->	O
owner	pointer
->	O
sections	pointer
;	O
for	O
(	O
;	O
next	pointer
!=	O
NULL	O
;	O
next	pointer
=	O
next	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
next	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
!	O
bfd_section_removed_from_list	function
(	O
obfd	pointer
,	O
next	pointer
)	O
)	O
break	O
;	O
best	pointer
=	O
next	pointer
;	O
if	O
(	O
prev	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
best	pointer
=	O
bfd_abs_section_ptr	O
;	O
}	O
else	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
best	pointer
=	O
prev	pointer
;	O
else	O
if	O
(	O
(	O
(	O
prev	pointer
->	O
flags	int
^	O
next	pointer
->	O
flags	int
)	O
&	O
(	O
SEC_ALLOC	int
|	O
SEC_THREAD_LOCAL	int
|	O
SEC_LOAD	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
(	O
next	pointer
->	O
flags	int
^	O
s	pointer
->	O
flags	int
)	O
&	O
(	O
SEC_ALLOC	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
!=	O
0	int
||	O
(	O
(	O
prev	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
(	O
next	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
)	O
)	O
best	pointer
=	O
prev	pointer
;	O
}	O
else	O
if	O
(	O
(	O
(	O
prev	pointer
->	O
flags	int
^	O
next	pointer
->	O
flags	int
)	O
&	O
SEC_READONLY	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
(	O
next	pointer
->	O
flags	int
^	O
s	pointer
->	O
flags	int
)	O
&	O
SEC_READONLY	int
)	O
!=	O
0	int
)	O
best	pointer
=	O
prev	pointer
;	O
}	O
else	O
if	O
(	O
(	O
(	O
prev	pointer
->	O
flags	int
^	O
next	pointer
->	O
flags	int
)	O
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
(	O
next	pointer
->	O
flags	int
^	O
s	pointer
->	O
flags	int
)	O
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
best	pointer
=	O
prev	pointer
;	O
}	O
else	O
{	O
if	O
(	O
addr	pointer
<	O
next	pointer
->	O
vma	long
)	O
best	pointer
=	O
prev	pointer
;	O
}	O
return	O
best	pointer
;	O
}	O
static	O
bfd_boolean	int
fix_syms	function
(	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
bfd	struct
*	O
obfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
{	O
asection	struct
*	O
s	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
->	O
output_section	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
!=	O
0	int
&&	O
bfd_section_removed_from_list	function
(	O
obfd	pointer
,	O
s	pointer
->	O
output_section	pointer
)	O
)	O
{	O
asection	struct
*	O
op	pointer
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
+=	O
s	pointer
->	O
output_offset	long
+	O
s	pointer
->	O
output_section	pointer
->	O
vma	long
;	O
op	pointer
=	O
_bfd_nearby_section	function
(	O
obfd	pointer
,	O
s	pointer
->	O
output_section	pointer
,	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
)	O
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
-=	O
op	pointer
->	O
vma	long
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
op	pointer
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_fix_excluded_sec_syms	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_link_hash_traverse	function
(	O
info	pointer
->	O
hash	long
,	O
fix_syms	function
,	O
obfd	pointer
)	O
;	O
}	O
bfd_boolean	int
bfd_generic_define_common_symbol	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
unsigned	O
int	O
power_of_two	int
;	O
bfd_vma	long
alignment	long
,	O
size	long
;	O
asection	struct
*	O
section	pointer
;	O
BFD_ASSERT	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
)	O
;	O
size	long
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
size	long
;	O
power_of_two	int
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
;	O
section	pointer
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
;	O
alignment	long
=	O
bfd_octets_per_byte	function
(	O
output_bfd	pointer
,	O
section	pointer
)	O
<<	O
power_of_two	int
;	O
BFD_ASSERT	O
(	O
alignment	long
!=	O
0	int
&&	O
(	O
alignment	long
&	O
-	O
alignment	long
)	O
==	O
alignment	long
)	O
;	O
section	pointer
->	O
size	long
+=	O
alignment	long
-	O
1	int
;	O
section	pointer
->	O
size	long
&=	O
-	O
alignment	long
;	O
if	O
(	O
power_of_two	int
>	O
section	pointer
->	O
alignment_power	int
)	O
section	pointer
->	O
alignment_power	int
=	O
power_of_two	int
;	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
section	pointer
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
section	pointer
->	O
size	long
;	O
section	pointer
->	O
size	long
+=	O
size	long
;	O
section	pointer
->	O
flags	int
|=	O
SEC_ALLOC	int
;	O
section	pointer
->	O
flags	int
&=	O
~	O
(	O
SEC_IS_COMMON	int
|	O
SEC_HAS_CONTENTS	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
void	O
_bfd_generic_link_hide_symbol	function
(	O
bfd	struct
*	O
output_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
struct	O
bfd_link_hash_entry	struct
*	O
bfd_generic_define_start_stop	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
symbol	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
info	pointer
->	O
hash	long
,	O
symbol	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
)	O
{	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
sec	pointer
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
0	int
;	O
return	O
h	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
bfd_elf_version_tree	struct
*	O
bfd_find_version_for_sym	function
(	O
struct	O
bfd_elf_version_tree	struct
*	O
verdefs	pointer
,	O
const	O
char	O
*	O
sym_name	pointer
,	O
bfd_boolean	int
*	O
hide	pointer
)	O
{	O
struct	O
bfd_elf_version_tree	struct
*	O
t	pointer
;	O
struct	O
bfd_elf_version_tree	struct
*	O
local_ver	pointer
,	O
*	O
global_ver	pointer
,	O
*	O
exist_ver	pointer
;	O
struct	O
bfd_elf_version_tree	struct
*	O
star_local_ver	pointer
,	O
*	O
star_global_ver	pointer
;	O
local_ver	pointer
=	O
NULL	O
;	O
global_ver	pointer
=	O
NULL	O
;	O
star_local_ver	pointer
=	O
NULL	O
;	O
star_global_ver	pointer
=	O
NULL	O
;	O
exist_ver	pointer
=	O
NULL	O
;	O
for	O
(	O
t	pointer
=	O
verdefs	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
t	pointer
->	O
globals	struct
.	O
list	pointer
!=	O
NULL	O
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
d	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
d	pointer
=	O
(	O
*	O
t	pointer
->	O
match	pointer
)	O
(	O
&	O
t	pointer
->	O
globals	struct
,	O
d	pointer
,	O
sym_name	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
d	pointer
->	O
literal	int
||	O
strcmp	function
(	O
d	pointer
->	O
pattern	pointer
,	O
"*"	pointer
)	O
!=	O
0	int
)	O
global_ver	pointer
=	O
t	pointer
;	O
else	O
star_global_ver	pointer
=	O
t	pointer
;	O
if	O
(	O
d	pointer
->	O
symver	int
)	O
exist_ver	pointer
=	O
t	pointer
;	O
d	pointer
->	O
script	int
=	O
1	int
;	O
if	O
(	O
d	pointer
->	O
literal	int
)	O
break	O
;	O
}	O
if	O
(	O
d	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
t	pointer
->	O
locals	struct
.	O
list	pointer
!=	O
NULL	O
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
d	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
d	pointer
=	O
(	O
*	O
t	pointer
->	O
match	pointer
)	O
(	O
&	O
t	pointer
->	O
locals	struct
,	O
d	pointer
,	O
sym_name	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
d	pointer
->	O
literal	int
||	O
strcmp	function
(	O
d	pointer
->	O
pattern	pointer
,	O
"*"	pointer
)	O
!=	O
0	int
)	O
local_ver	pointer
=	O
t	pointer
;	O
else	O
star_local_ver	pointer
=	O
t	pointer
;	O
if	O
(	O
d	pointer
->	O
literal	int
)	O
{	O
global_ver	pointer
=	O
NULL	O
;	O
star_global_ver	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
d	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
global_ver	pointer
==	O
NULL	O
&&	O
local_ver	pointer
==	O
NULL	O
)	O
global_ver	pointer
=	O
star_global_ver	pointer
;	O
if	O
(	O
global_ver	pointer
!=	O
NULL	O
)	O
{	O
*	O
hide	pointer
=	O
exist_ver	pointer
==	O
global_ver	pointer
;	O
return	O
global_ver	pointer
;	O
}	O
if	O
(	O
local_ver	pointer
==	O
NULL	O
)	O
local_ver	pointer
=	O
star_local_ver	pointer
;	O
if	O
(	O
local_ver	pointer
!=	O
NULL	O
)	O
{	O
*	O
hide	pointer
=	O
TRUE	int
;	O
return	O
local_ver	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
bfd_boolean	int
bfd_hide_sym_by_version	function
(	O
struct	O
bfd_elf_version_tree	struct
*	O
verdefs	pointer
,	O
const	O
char	O
*	O
sym_name	pointer
)	O
{	O
bfd_boolean	int
hidden	int
=	O
FALSE	int
;	O
bfd_find_version_for_sym	function
(	O
verdefs	pointer
,	O
sym_name	pointer
,	O
&	O
hidden	int
)	O
;	O
return	O
hidden	int
;	O
}	O
bfd_boolean	int
bfd_link_check_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
return	O
BFD_SEND	O
(	O
abfd	pointer
,	O
_bfd_link_check_relocs	pointer
,	O
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
;	O
}	O
bfd_boolean	int
_bfd_generic_link_check_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_generic_verify_endian_match	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd	struct
*	O
obfd	pointer
=	O
info	pointer
->	O
output_bfd	pointer
;	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
!=	O
obfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
&&	O
ibfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
!=	O
BFD_ENDIAN_UNKNOWN	int
&&	O
obfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
!=	O
BFD_ENDIAN_UNKNOWN	int
)	O
{	O
if	O
(	O
bfd_big_endian	function
(	O
ibfd	pointer
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: compiled for a big endian system "	pointer
"and target is little endian"	pointer
)	O
,	O
ibfd	pointer
)	O
;	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: compiled for a little endian system "	pointer
"and target is big endian"	pointer
)	O
,	O
ibfd	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
int	O
_bfd_nolink_sizeof_headers	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
0	int
;	O
}	O
bfd_boolean	int
_bfd_nolink_bfd_relax_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
*	O
again	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd_byte	char
*	O
_bfd_nolink_bfd_get_relocated_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_byte	char
*	O
data	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
relocatable	int
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
*	O
symbols	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
(	O
bfd_byte	char
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_nolink_bfd_lookup_section_flags	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
flag_info	struct
*	O
flaginfo	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
section	pointer
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
section	pointer
->	O
owner	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_nolink_bfd_is_group_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
abfd	pointer
)	O
;	O
}	O
const	O
char	O
*	O
_bfd_nolink_bfd_group_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_ptr_bfd_null_error	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_nolink_bfd_discard_group	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
abfd	pointer
)	O
;	O
}	O
struct	O
bfd_link_hash_table	struct
*	O
_bfd_nolink_bfd_link_hash_table_create	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
(	O
struct	O
bfd_link_hash_table	struct
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
abfd	pointer
)	O
;	O
}	O
void	O
_bfd_nolink_bfd_link_just_syms	function
(	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
void	O
_bfd_nolink_bfd_copy_link_hash_symbol_type	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
from	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
to	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
}	O
bfd_boolean	int
_bfd_nolink_bfd_link_split_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_nolink_section_already_linked	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd_boolean	int
_bfd_nolink_bfd_define_common_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_bool_bfd_false_error	function
(	O
abfd	pointer
)	O
;	O
}	O
struct	O
bfd_link_hash_entry	struct
*	O
_bfd_nolink_bfd_define_start_stop	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
return	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
sec	pointer
->	O
owner	pointer
)	O
;	O
}	O
