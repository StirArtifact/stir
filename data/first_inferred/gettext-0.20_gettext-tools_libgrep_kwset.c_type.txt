struct	O
tree	struct
{	O
struct	O
tree	struct
*	O
llink	pointer
;	O
struct	O
tree	struct
*	O
rlink	pointer
;	O
struct	O
trie	pointer
*	O
trie	pointer
;	O
unsigned	O
char	O
label	char
;	O
char	O
balance	char
;	O
}	O
;	O
struct	O
trie	pointer
{	O
unsigned	O
int	O
accepting	int
;	O
struct	O
tree	struct
*	O
links	pointer
;	O
struct	O
trie	pointer
*	O
parent	pointer
;	O
struct	O
trie	pointer
*	O
next	pointer
;	O
struct	O
trie	pointer
*	O
fail	pointer
;	O
int	O
depth	int
;	O
int	O
shift	int
;	O
int	O
maxshift	int
;	O
}	O
;	O
struct	O
kwset	struct
{	O
struct	O
obstack	struct
obstack	struct
;	O
int	O
words	int
;	O
struct	O
trie	pointer
*	O
trie	pointer
;	O
int	O
mind	int
;	O
int	O
maxd	int
;	O
unsigned	O
char	O
delta	array
[	O
NCHAR	O
]	O
;	O
struct	O
trie	pointer
*	O
next	pointer
[	O
NCHAR	O
]	O
;	O
char	O
*	O
target	pointer
;	O
int	O
mind2	int
;	O
char	O
const	O
*	O
trans	pointer
;	O
}	O
;	O
kwset_t	pointer
kwsalloc	function
(	O
char	O
const	O
*	O
trans	pointer
)	O
{	O
struct	O
kwset	struct
*	O
kwset	struct
;	O
kwset	struct
=	O
(	O
struct	O
kwset	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
kwset	struct
)	O
)	O
;	O
if	O
(	O
!	O
kwset	struct
)	O
return	O
NULL	O
;	O
obstack_init	O
(	O
&	O
kwset	struct
->	O
obstack	struct
)	O
;	O
kwset	struct
->	O
words	int
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
=	O
(	O
struct	O
trie	pointer
*	O
)	O
obstack_alloc	O
(	O
&	O
kwset	struct
->	O
obstack	struct
,	O
sizeof	O
(	O
struct	O
trie	pointer
)	O
)	O
;	O
if	O
(	O
!	O
kwset	struct
->	O
trie	pointer
)	O
{	O
kwsfree	function
(	O
kwset	struct
)	O
;	O
return	O
NULL	O
;	O
}	O
kwset	struct
->	O
trie	pointer
->	O
accepting	int
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
->	O
links	pointer
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
->	O
parent	pointer
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
->	O
next	pointer
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
->	O
fail	pointer
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
->	O
depth	int
=	O
0	int
;	O
kwset	struct
->	O
trie	pointer
->	O
shift	int
=	O
0	int
;	O
kwset	struct
->	O
mind	int
=	O
INT_MAX	O
;	O
kwset	struct
->	O
maxd	int
=	O
-	O
1	int
;	O
kwset	struct
->	O
target	pointer
=	O
0	int
;	O
kwset	struct
->	O
trans	pointer
=	O
trans	pointer
;	O
return	O
kwset	struct
;	O
}	O
const	O
char	O
*	O
kwsincr	function
(	O
kwset_t	pointer
kws	pointer
,	O
char	O
const	O
*	O
text	pointer
,	O
size_t	long
len	long
)	O
{	O
struct	O
kwset	struct
*	O
kwset	struct
;	O
register	O
struct	O
trie	pointer
*	O
trie	pointer
;	O
kwset	struct
=	O
(	O
struct	O
kwset	struct
*	O
)	O
kws	pointer
;	O
trie	pointer
=	O
kwset	struct
->	O
trie	pointer
;	O
text	pointer
+=	O
len	long
;	O
while	O
(	O
len	long
--	O
)	O
{	O
register	O
unsigned	O
char	O
label	char
;	O
register	O
struct	O
tree	struct
*	O
link	pointer
;	O
register	O
int	O
depth	int
;	O
struct	O
tree	struct
*	O
links	pointer
[	O
12	int
]	O
;	O
enum	O
{	O
L	int
,	O
R	int
}	O
dirs	array
[	O
12	int
]	O
;	O
label	char
=	O
kwset	struct
->	O
trans	pointer
?	O
kwset	struct
->	O
trans	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
--	O
text	pointer
]	O
:	O
*	O
--	O
text	pointer
;	O
link	pointer
=	O
trie	pointer
->	O
links	pointer
;	O
links	pointer
[	O
0	int
]	O
=	O
(	O
struct	O
tree	struct
*	O
)	O
&	O
trie	pointer
->	O
links	pointer
;	O
dirs	array
[	O
0	int
]	O
=	O
L	int
;	O
depth	int
=	O
1	int
;	O
while	O
(	O
link	pointer
&&	O
label	char
!=	O
link	pointer
->	O
label	char
)	O
{	O
links	pointer
[	O
depth	int
]	O
=	O
link	pointer
;	O
if	O
(	O
label	char
<	O
link	pointer
->	O
label	char
)	O
dirs	array
[	O
depth	int
++	O
]	O
=	O
L	int
,	O
link	pointer
=	O
link	pointer
->	O
llink	pointer
;	O
else	O
dirs	array
[	O
depth	int
++	O
]	O
=	O
R	int
,	O
link	pointer
=	O
link	pointer
->	O
rlink	pointer
;	O
}	O
if	O
(	O
!	O
link	pointer
)	O
{	O
link	pointer
=	O
(	O
struct	O
tree	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
kwset	struct
->	O
obstack	struct
,	O
sizeof	O
(	O
struct	O
tree	struct
)	O
)	O
;	O
if	O
(	O
!	O
link	pointer
)	O
return	O
_	O
(	O
"memory exhausted"	pointer
)	O
;	O
link	pointer
->	O
llink	pointer
=	O
0	int
;	O
link	pointer
->	O
rlink	pointer
=	O
0	int
;	O
link	pointer
->	O
trie	pointer
=	O
(	O
struct	O
trie	pointer
*	O
)	O
obstack_alloc	O
(	O
&	O
kwset	struct
->	O
obstack	struct
,	O
sizeof	O
(	O
struct	O
trie	pointer
)	O
)	O
;	O
if	O
(	O
!	O
link	pointer
->	O
trie	pointer
)	O
return	O
_	O
(	O
"memory exhausted"	pointer
)	O
;	O
link	pointer
->	O
trie	pointer
->	O
accepting	int
=	O
0	int
;	O
link	pointer
->	O
trie	pointer
->	O
links	pointer
=	O
0	int
;	O
link	pointer
->	O
trie	pointer
->	O
parent	pointer
=	O
trie	pointer
;	O
link	pointer
->	O
trie	pointer
->	O
next	pointer
=	O
0	int
;	O
link	pointer
->	O
trie	pointer
->	O
fail	pointer
=	O
0	int
;	O
link	pointer
->	O
trie	pointer
->	O
depth	int
=	O
trie	pointer
->	O
depth	int
+	O
1	int
;	O
link	pointer
->	O
trie	pointer
->	O
shift	int
=	O
0	int
;	O
link	pointer
->	O
label	char
=	O
label	char
;	O
link	pointer
->	O
balance	char
=	O
0	int
;	O
if	O
(	O
dirs	array
[	O
--	O
depth	int
]	O
==	O
L	int
)	O
links	pointer
[	O
depth	int
]	O
->	O
llink	pointer
=	O
link	pointer
;	O
else	O
links	pointer
[	O
depth	int
]	O
->	O
rlink	pointer
=	O
link	pointer
;	O
while	O
(	O
depth	int
&&	O
!	O
links	pointer
[	O
depth	int
]	O
->	O
balance	char
)	O
{	O
if	O
(	O
dirs	array
[	O
depth	int
]	O
==	O
L	int
)	O
--	O
links	pointer
[	O
depth	int
]	O
->	O
balance	char
;	O
else	O
++	O
links	pointer
[	O
depth	int
]	O
->	O
balance	char
;	O
--	O
depth	int
;	O
}	O
if	O
(	O
depth	int
&&	O
(	O
(	O
dirs	array
[	O
depth	int
]	O
==	O
L	int
&&	O
--	O
links	pointer
[	O
depth	int
]	O
->	O
balance	char
)	O
||	O
(	O
dirs	array
[	O
depth	int
]	O
==	O
R	int
&&	O
++	O
links	pointer
[	O
depth	int
]	O
->	O
balance	char
)	O
)	O
)	O
{	O
struct	O
tree	struct
*	O
t	pointer
;	O
switch	O
(	O
links	pointer
[	O
depth	int
]	O
->	O
balance	char
)	O
{	O
struct	O
tree	struct
*	O
r	pointer
,	O
*	O
l	pointer
,	O
*	O
rl	pointer
,	O
*	O
lr	pointer
;	O
case	O
(	O
char	O
)	O
-	O
2	int
:	O
switch	O
(	O
dirs	array
[	O
depth	int
+	O
1	int
]	O
)	O
{	O
case	O
L	int
:	O
r	pointer
=	O
links	pointer
[	O
depth	int
]	O
,	O
t	pointer
=	O
r	pointer
->	O
llink	pointer
,	O
rl	pointer
=	O
t	pointer
->	O
rlink	pointer
;	O
t	pointer
->	O
rlink	pointer
=	O
r	pointer
,	O
r	pointer
->	O
llink	pointer
=	O
rl	pointer
;	O
t	pointer
->	O
balance	char
=	O
r	pointer
->	O
balance	char
=	O
0	int
;	O
break	O
;	O
case	O
R	int
:	O
r	pointer
=	O
links	pointer
[	O
depth	int
]	O
,	O
l	pointer
=	O
r	pointer
->	O
llink	pointer
,	O
t	pointer
=	O
l	pointer
->	O
rlink	pointer
;	O
rl	pointer
=	O
t	pointer
->	O
rlink	pointer
,	O
lr	pointer
=	O
t	pointer
->	O
llink	pointer
;	O
t	pointer
->	O
llink	pointer
=	O
l	pointer
,	O
l	pointer
->	O
rlink	pointer
=	O
lr	pointer
,	O
t	pointer
->	O
rlink	pointer
=	O
r	pointer
,	O
r	pointer
->	O
llink	pointer
=	O
rl	pointer
;	O
l	pointer
->	O
balance	char
=	O
t	pointer
->	O
balance	char
!=	O
1	int
?	O
0	int
:	O
-	O
1	int
;	O
r	pointer
->	O
balance	char
=	O
t	pointer
->	O
balance	char
!=	O
(	O
char	O
)	O
-	O
1	int
?	O
0	int
:	O
1	int
;	O
t	pointer
->	O
balance	char
=	O
0	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
switch	O
(	O
dirs	array
[	O
depth	int
+	O
1	int
]	O
)	O
{	O
case	O
R	int
:	O
l	pointer
=	O
links	pointer
[	O
depth	int
]	O
,	O
t	pointer
=	O
l	pointer
->	O
rlink	pointer
,	O
lr	pointer
=	O
t	pointer
->	O
llink	pointer
;	O
t	pointer
->	O
llink	pointer
=	O
l	pointer
,	O
l	pointer
->	O
rlink	pointer
=	O
lr	pointer
;	O
t	pointer
->	O
balance	char
=	O
l	pointer
->	O
balance	char
=	O
0	int
;	O
break	O
;	O
case	O
L	int
:	O
l	pointer
=	O
links	pointer
[	O
depth	int
]	O
,	O
r	pointer
=	O
l	pointer
->	O
rlink	pointer
,	O
t	pointer
=	O
r	pointer
->	O
llink	pointer
;	O
lr	pointer
=	O
t	pointer
->	O
llink	pointer
,	O
rl	pointer
=	O
t	pointer
->	O
rlink	pointer
;	O
t	pointer
->	O
llink	pointer
=	O
l	pointer
,	O
l	pointer
->	O
rlink	pointer
=	O
lr	pointer
,	O
t	pointer
->	O
rlink	pointer
=	O
r	pointer
,	O
r	pointer
->	O
llink	pointer
=	O
rl	pointer
;	O
l	pointer
->	O
balance	char
=	O
t	pointer
->	O
balance	char
!=	O
1	int
?	O
0	int
:	O
-	O
1	int
;	O
r	pointer
->	O
balance	char
=	O
t	pointer
->	O
balance	char
!=	O
(	O
char	O
)	O
-	O
1	int
?	O
0	int
:	O
1	int
;	O
t	pointer
->	O
balance	char
=	O
0	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
dirs	array
[	O
depth	int
-	O
1	int
]	O
==	O
L	int
)	O
links	pointer
[	O
depth	int
-	O
1	int
]	O
->	O
llink	pointer
=	O
t	pointer
;	O
else	O
links	pointer
[	O
depth	int
-	O
1	int
]	O
->	O
rlink	pointer
=	O
t	pointer
;	O
}	O
}	O
trie	pointer
=	O
link	pointer
->	O
trie	pointer
;	O
}	O
if	O
(	O
!	O
trie	pointer
->	O
accepting	int
)	O
trie	pointer
->	O
accepting	int
=	O
1	int
+	O
2	int
*	O
kwset	struct
->	O
words	int
;	O
++	O
kwset	struct
->	O
words	int
;	O
if	O
(	O
trie	pointer
->	O
depth	int
<	O
kwset	struct
->	O
mind	int
)	O
kwset	struct
->	O
mind	int
=	O
trie	pointer
->	O
depth	int
;	O
if	O
(	O
trie	pointer
->	O
depth	int
>	O
kwset	struct
->	O
maxd	int
)	O
kwset	struct
->	O
maxd	int
=	O
trie	pointer
->	O
depth	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
enqueue	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
trie	pointer
*	O
*	O
last	pointer
)	O
{	O
if	O
(	O
!	O
tree	struct
)	O
return	O
;	O
enqueue	function
(	O
tree	struct
->	O
llink	pointer
,	O
last	pointer
)	O
;	O
enqueue	function
(	O
tree	struct
->	O
rlink	pointer
,	O
last	pointer
)	O
;	O
(	O
*	O
last	pointer
)	O
=	O
(	O
*	O
last	pointer
)	O
->	O
next	pointer
=	O
tree	struct
->	O
trie	pointer
;	O
}	O
static	O
void	O
treefails	function
(	O
register	O
struct	O
tree	struct
const	O
*	O
tree	struct
,	O
struct	O
trie	pointer
const	O
*	O
fail	pointer
,	O
struct	O
trie	pointer
*	O
recourse	pointer
)	O
{	O
if	O
(	O
!	O
tree	struct
)	O
return	O
;	O
treefails	function
(	O
tree	struct
->	O
llink	pointer
,	O
fail	pointer
,	O
recourse	pointer
)	O
;	O
treefails	function
(	O
tree	struct
->	O
rlink	pointer
,	O
fail	pointer
,	O
recourse	pointer
)	O
;	O
while	O
(	O
fail	pointer
)	O
{	O
register	O
struct	O
tree	struct
*	O
link	pointer
;	O
link	pointer
=	O
fail	pointer
->	O
links	pointer
;	O
while	O
(	O
link	pointer
&&	O
tree	struct
->	O
label	char
!=	O
link	pointer
->	O
label	char
)	O
if	O
(	O
tree	struct
->	O
label	char
<	O
link	pointer
->	O
label	char
)	O
link	pointer
=	O
link	pointer
->	O
llink	pointer
;	O
else	O
link	pointer
=	O
link	pointer
->	O
rlink	pointer
;	O
if	O
(	O
link	pointer
)	O
{	O
tree	struct
->	O
trie	pointer
->	O
fail	pointer
=	O
link	pointer
->	O
trie	pointer
;	O
return	O
;	O
}	O
fail	pointer
=	O
fail	pointer
->	O
fail	pointer
;	O
}	O
tree	struct
->	O
trie	pointer
->	O
fail	pointer
=	O
recourse	pointer
;	O
}	O
static	O
void	O
treedelta	function
(	O
register	O
struct	O
tree	struct
const	O
*	O
tree	struct
,	O
register	O
unsigned	O
int	O
depth	int
,	O
unsigned	O
char	O
delta	array
[	O
]	O
)	O
{	O
if	O
(	O
!	O
tree	struct
)	O
return	O
;	O
treedelta	function
(	O
tree	struct
->	O
llink	pointer
,	O
depth	int
,	O
delta	array
)	O
;	O
treedelta	function
(	O
tree	struct
->	O
rlink	pointer
,	O
depth	int
,	O
delta	array
)	O
;	O
if	O
(	O
depth	int
<	O
delta	array
[	O
tree	struct
->	O
label	char
]	O
)	O
delta	array
[	O
tree	struct
->	O
label	char
]	O
=	O
depth	int
;	O
}	O
static	O
int	O
hasevery	function
(	O
register	O
struct	O
tree	struct
const	O
*	O
a	pointer
,	O
register	O
struct	O
tree	struct
const	O
*	O
b	pointer
)	O
{	O
if	O
(	O
!	O
b	pointer
)	O
return	O
1	int
;	O
if	O
(	O
!	O
hasevery	function
(	O
a	pointer
,	O
b	pointer
->	O
llink	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
hasevery	function
(	O
a	pointer
,	O
b	pointer
->	O
rlink	pointer
)	O
)	O
return	O
0	int
;	O
while	O
(	O
a	pointer
&&	O
b	pointer
->	O
label	char
!=	O
a	pointer
->	O
label	char
)	O
if	O
(	O
b	pointer
->	O
label	char
<	O
a	pointer
->	O
label	char
)	O
a	pointer
=	O
a	pointer
->	O
llink	pointer
;	O
else	O
a	pointer
=	O
a	pointer
->	O
rlink	pointer
;	O
return	O
!	O
!	O
a	pointer
;	O
}	O
static	O
void	O
treenext	function
(	O
struct	O
tree	struct
const	O
*	O
tree	struct
,	O
struct	O
trie	pointer
*	O
next	pointer
[	O
]	O
)	O
{	O
if	O
(	O
!	O
tree	struct
)	O
return	O
;	O
treenext	function
(	O
tree	struct
->	O
llink	pointer
,	O
next	pointer
)	O
;	O
treenext	function
(	O
tree	struct
->	O
rlink	pointer
,	O
next	pointer
)	O
;	O
next	pointer
[	O
tree	struct
->	O
label	char
]	O
=	O
tree	struct
->	O
trie	pointer
;	O
}	O
const	O
char	O
*	O
kwsprep	function
(	O
kwset_t	pointer
kwset	struct
)	O
{	O
unsigned	O
char	O
delta	array
[	O
NCHAR	O
]	O
;	O
{	O
register	O
int	O
i	long
;	O
if	O
(	O
kwset	struct
->	O
mind	int
<	O
256	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
delta	array
[	O
i	long
]	O
=	O
kwset	struct
->	O
mind	int
;	O
else	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
delta	array
[	O
i	long
]	O
=	O
255	int
;	O
}	O
if	O
(	O
kwset	struct
->	O
words	int
==	O
1	int
&&	O
kwset	struct
->	O
trans	pointer
==	O
0	int
)	O
{	O
register	O
int	O
i	long
;	O
register	O
struct	O
trie	pointer
*	O
curr	pointer
;	O
kwset	struct
->	O
target	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
kwset	struct
->	O
obstack	struct
,	O
kwset	struct
->	O
mind	int
)	O
;	O
for	O
(	O
i	long
=	O
kwset	struct
->	O
mind	int
-	O
1	int
,	O
curr	pointer
=	O
kwset	struct
->	O
trie	pointer
;	O
i	long
>=	O
0	int
;	O
--	O
i	long
)	O
{	O
kwset	struct
->	O
target	pointer
[	O
i	long
]	O
=	O
curr	pointer
->	O
links	pointer
->	O
label	char
;	O
curr	pointer
=	O
curr	pointer
->	O
links	pointer
->	O
trie	pointer
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
kwset	struct
->	O
mind	int
;	O
++	O
i	long
)	O
delta	array
[	O
(	O
unsigned	O
char	O
)	O
kwset	struct
->	O
target	pointer
[	O
i	long
]	O
]	O
=	O
kwset	struct
->	O
mind	int
-	O
(	O
i	long
+	O
1	int
)	O
;	O
kwset	struct
->	O
mind2	int
=	O
kwset	struct
->	O
mind	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
kwset	struct
->	O
mind	int
-	O
1	int
;	O
++	O
i	long
)	O
if	O
(	O
kwset	struct
->	O
target	pointer
[	O
i	long
]	O
==	O
kwset	struct
->	O
target	pointer
[	O
kwset	struct
->	O
mind	int
-	O
1	int
]	O
)	O
kwset	struct
->	O
mind2	int
=	O
kwset	struct
->	O
mind	int
-	O
(	O
i	long
+	O
1	int
)	O
;	O
}	O
else	O
{	O
register	O
struct	O
trie	pointer
*	O
curr	pointer
;	O
struct	O
trie	pointer
*	O
last	pointer
;	O
for	O
(	O
curr	pointer
=	O
last	pointer
=	O
kwset	struct
->	O
trie	pointer
;	O
curr	pointer
;	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
)	O
{	O
register	O
struct	O
trie	pointer
*	O
fail	pointer
;	O
enqueue	function
(	O
curr	pointer
->	O
links	pointer
,	O
&	O
last	pointer
)	O
;	O
curr	pointer
->	O
shift	int
=	O
kwset	struct
->	O
mind	int
;	O
curr	pointer
->	O
maxshift	int
=	O
kwset	struct
->	O
mind	int
;	O
treedelta	function
(	O
curr	pointer
->	O
links	pointer
,	O
curr	pointer
->	O
depth	int
,	O
delta	array
)	O
;	O
treefails	function
(	O
curr	pointer
->	O
links	pointer
,	O
curr	pointer
->	O
fail	pointer
,	O
kwset	struct
->	O
trie	pointer
)	O
;	O
for	O
(	O
fail	pointer
=	O
curr	pointer
->	O
fail	pointer
;	O
fail	pointer
;	O
fail	pointer
=	O
fail	pointer
->	O
fail	pointer
)	O
{	O
if	O
(	O
!	O
hasevery	function
(	O
fail	pointer
->	O
links	pointer
,	O
curr	pointer
->	O
links	pointer
)	O
)	O
if	O
(	O
curr	pointer
->	O
depth	int
-	O
fail	pointer
->	O
depth	int
<	O
fail	pointer
->	O
shift	int
)	O
fail	pointer
->	O
shift	int
=	O
curr	pointer
->	O
depth	int
-	O
fail	pointer
->	O
depth	int
;	O
if	O
(	O
curr	pointer
->	O
accepting	int
&&	O
fail	pointer
->	O
maxshift	int
>	O
curr	pointer
->	O
depth	int
-	O
fail	pointer
->	O
depth	int
)	O
fail	pointer
->	O
maxshift	int
=	O
curr	pointer
->	O
depth	int
-	O
fail	pointer
->	O
depth	int
;	O
}	O
}	O
for	O
(	O
curr	pointer
=	O
kwset	struct
->	O
trie	pointer
->	O
next	pointer
;	O
curr	pointer
;	O
curr	pointer
=	O
curr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
curr	pointer
->	O
maxshift	int
>	O
curr	pointer
->	O
parent	pointer
->	O
maxshift	int
)	O
curr	pointer
->	O
maxshift	int
=	O
curr	pointer
->	O
parent	pointer
->	O
maxshift	int
;	O
if	O
(	O
curr	pointer
->	O
shift	int
>	O
curr	pointer
->	O
maxshift	int
)	O
curr	pointer
->	O
shift	int
=	O
curr	pointer
->	O
maxshift	int
;	O
}	O
{	O
struct	O
trie	pointer
*	O
next	pointer
[	O
NCHAR	O
]	O
;	O
register	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
next	pointer
[	O
i	long
]	O
=	O
0	int
;	O
treenext	function
(	O
kwset	struct
->	O
trie	pointer
->	O
links	pointer
,	O
next	pointer
)	O
;	O
{	O
register	O
char	O
const	O
*	O
trans	pointer
;	O
if	O
(	O
(	O
trans	pointer
=	O
kwset	struct
->	O
trans	pointer
)	O
!=	O
0	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
kwset	struct
->	O
next	pointer
[	O
i	long
]	O
=	O
next	pointer
[	O
(	O
unsigned	O
char	O
)	O
trans	pointer
[	O
i	long
]	O
]	O
;	O
else	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
kwset	struct
->	O
next	pointer
[	O
i	long
]	O
=	O
next	pointer
[	O
i	long
]	O
;	O
}	O
}	O
}	O
{	O
register	O
char	O
const	O
*	O
trans	pointer
;	O
register	O
int	O
i	long
;	O
if	O
(	O
(	O
trans	pointer
=	O
kwset	struct
->	O
trans	pointer
)	O
!=	O
0	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
kwset	struct
->	O
delta	array
[	O
i	long
]	O
=	O
delta	array
[	O
(	O
unsigned	O
char	O
)	O
trans	pointer
[	O
i	long
]	O
]	O
;	O
else	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NCHAR	O
;	O
++	O
i	long
)	O
kwset	struct
->	O
delta	array
[	O
i	long
]	O
=	O
delta	array
[	O
i	long
]	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
bmexec	function
(	O
kwset_t	pointer
kws	pointer
,	O
char	O
const	O
*	O
text	pointer
,	O
size_t	long
size	array
)	O
{	O
struct	O
kwset	struct
const	O
*	O
kwset	struct
;	O
register	O
int	O
len	long
;	O
kwset	struct
=	O
(	O
struct	O
kwset	struct
const	O
*	O
)	O
kws	pointer
;	O
len	long
=	O
kwset	struct
->	O
mind	int
;	O
if	O
(	O
len	long
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
len	long
>	O
size	array
)	O
return	O
-	O
1	int
;	O
if	O
(	O
len	long
==	O
1	int
)	O
{	O
register	O
char	O
const	O
*	O
tp	pointer
;	O
tp	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
text	pointer
,	O
kwset	struct
->	O
target	pointer
[	O
0	int
]	O
,	O
size	array
)	O
;	O
return	O
tp	pointer
?	O
tp	pointer
-	O
text	pointer
:	O
-	O
1	int
;	O
}	O
{	O
register	O
unsigned	O
char	O
const	O
*	O
d1	pointer
;	O
register	O
char	O
const	O
*	O
sp	pointer
;	O
register	O
int	O
gc	int
;	O
register	O
int	O
md2	int
;	O
register	O
char	O
const	O
*	O
tp	pointer
;	O
d1	pointer
=	O
kwset	struct
->	O
delta	array
;	O
sp	pointer
=	O
kwset	struct
->	O
target	pointer
+	O
len	long
;	O
gc	int
=	O
U	O
(	O
sp	pointer
[	O
-	O
2	int
]	O
)	O
;	O
md2	int
=	O
kwset	struct
->	O
mind2	int
;	O
tp	pointer
=	O
text	pointer
+	O
len	long
;	O
if	O
(	O
size	array
>	O
12	int
*	O
len	long
)	O
{	O
register	O
char	O
const	O
*	O
ep	pointer
;	O
register	O
int	O
d	int
;	O
for	O
(	O
ep	pointer
=	O
text	pointer
+	O
size	array
-	O
11	int
*	O
len	long
;	O
;	O
)	O
{	O
while	O
(	O
tp	pointer
<=	O
ep	pointer
)	O
{	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
if	O
(	O
d	int
==	O
0	int
)	O
goto	O
found	O
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
if	O
(	O
d	int
==	O
0	int
)	O
goto	O
found	O
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
if	O
(	O
d	int
==	O
0	int
)	O
goto	O
found	O
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
,	O
tp	pointer
+=	O
d	int
;	O
}	O
break	O
;	O
found	O
:	O
if	O
(	O
U	O
(	O
tp	pointer
[	O
-	O
2	int
]	O
)	O
==	O
gc	int
)	O
{	O
register	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
3	int
;	O
i	long
<=	O
len	long
&&	O
U	O
(	O
tp	pointer
[	O
-	O
i	long
]	O
)	O
==	O
U	O
(	O
sp	pointer
[	O
-	O
i	long
]	O
)	O
;	O
++	O
i	long
)	O
;	O
if	O
(	O
i	long
>	O
len	long
)	O
return	O
tp	pointer
-	O
len	long
-	O
text	pointer
;	O
}	O
tp	pointer
+=	O
md2	int
;	O
}	O
}	O
{	O
register	O
char	O
const	O
*	O
ep	pointer
;	O
register	O
int	O
d	int
;	O
ep	pointer
=	O
text	pointer
+	O
size	array
;	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
tp	pointer
[	O
-	O
1	int
]	O
)	O
]	O
;	O
while	O
(	O
d	int
<=	O
ep	pointer
-	O
tp	pointer
)	O
{	O
d	int
=	O
d1	pointer
[	O
U	O
(	O
(	O
tp	pointer
+=	O
d	int
)	O
[	O
-	O
1	int
]	O
)	O
]	O
;	O
if	O
(	O
d	int
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
U	O
(	O
tp	pointer
[	O
-	O
2	int
]	O
)	O
==	O
gc	int
)	O
{	O
register	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
3	int
;	O
i	long
<=	O
len	long
&&	O
U	O
(	O
tp	pointer
[	O
-	O
i	long
]	O
)	O
==	O
U	O
(	O
sp	pointer
[	O
-	O
i	long
]	O
)	O
;	O
++	O
i	long
)	O
;	O
if	O
(	O
i	long
>	O
len	long
)	O
return	O
tp	pointer
-	O
len	long
-	O
text	pointer
;	O
}	O
d	int
=	O
md2	int
;	O
}	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
size_t	long
cwexec	function
(	O
kwset_t	pointer
kws	pointer
,	O
char	O
const	O
*	O
text	pointer
,	O
size_t	long
len	long
,	O
struct	O
kwsmatch	struct
*	O
kwsmatch	struct
)	O
{	O
struct	O
kwset	struct
const	O
*	O
kwset	struct
;	O
kwset	struct
=	O
(	O
struct	O
kwset	struct
*	O
)	O
kws	pointer
;	O
if	O
(	O
len	long
<	O
kwset	struct
->	O
mind	int
)	O
return	O
-	O
1	int
;	O
{	O
struct	O
trie	pointer
const	O
*	O
accept	pointer
;	O
struct	O
trie	pointer
*	O
const	O
*	O
next	pointer
;	O
register	O
unsigned	O
char	O
const	O
*	O
delta	array
;	O
register	O
char	O
const	O
*	O
trans	pointer
;	O
char	O
const	O
*	O
lim	pointer
;	O
register	O
char	O
const	O
*	O
end	pointer
;	O
register	O
int	O
d	int
;	O
char	O
const	O
*	O
mch	pointer
;	O
register	O
char	O
const	O
*	O
qlim	pointer
;	O
accept	pointer
=	O
NULL	O
;	O
next	pointer
=	O
kwset	struct
->	O
next	pointer
;	O
delta	array
=	O
kwset	struct
->	O
delta	array
;	O
trans	pointer
=	O
kwset	struct
->	O
trans	pointer
;	O
lim	pointer
=	O
text	pointer
+	O
len	long
;	O
end	pointer
=	O
text	pointer
;	O
if	O
(	O
(	O
d	int
=	O
kwset	struct
->	O
mind	int
)	O
!=	O
0	int
)	O
mch	pointer
=	O
0	int
;	O
else	O
{	O
mch	pointer
=	O
text	pointer
,	O
accept	pointer
=	O
kwset	struct
->	O
trie	pointer
;	O
goto	O
match	O
;	O
}	O
if	O
(	O
len	long
>=	O
4	int
*	O
kwset	struct
->	O
mind	int
)	O
qlim	pointer
=	O
lim	pointer
-	O
4	int
*	O
kwset	struct
->	O
mind	int
;	O
else	O
qlim	pointer
=	O
0	int
;	O
while	O
(	O
lim	pointer
-	O
end	pointer
>=	O
d	int
)	O
{	O
char	O
const	O
*	O
beg	pointer
;	O
struct	O
trie	pointer
const	O
*	O
trie	pointer
;	O
{	O
register	O
unsigned	O
char	O
c	char
;	O
if	O
(	O
qlim	pointer
&&	O
end	pointer
<=	O
qlim	pointer
)	O
{	O
end	pointer
+=	O
d	int
-	O
1	int
;	O
while	O
(	O
(	O
d	int
=	O
delta	array
[	O
c	char
=	O
*	O
end	pointer
]	O
)	O
&&	O
end	pointer
<	O
qlim	pointer
)	O
{	O
end	pointer
+=	O
d	int
;	O
end	pointer
+=	O
delta	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
end	pointer
]	O
;	O
end	pointer
+=	O
delta	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
end	pointer
]	O
;	O
}	O
++	O
end	pointer
;	O
}	O
else	O
d	int
=	O
delta	array
[	O
c	char
=	O
(	O
end	pointer
+=	O
d	int
)	O
[	O
-	O
1	int
]	O
]	O
;	O
if	O
(	O
d	int
)	O
continue	O
;	O
beg	pointer
=	O
end	pointer
-	O
1	int
;	O
trie	pointer
=	O
next	pointer
[	O
c	char
]	O
;	O
}	O
if	O
(	O
trie	pointer
->	O
accepting	int
)	O
{	O
mch	pointer
=	O
beg	pointer
;	O
accept	pointer
=	O
trie	pointer
;	O
}	O
d	int
=	O
trie	pointer
->	O
shift	int
;	O
while	O
(	O
beg	pointer
>	O
text	pointer
)	O
{	O
register	O
unsigned	O
char	O
c	char
;	O
register	O
struct	O
tree	struct
const	O
*	O
tree	struct
;	O
c	char
=	O
trans	pointer
?	O
trans	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
--	O
beg	pointer
]	O
:	O
*	O
--	O
beg	pointer
;	O
tree	struct
=	O
trie	pointer
->	O
links	pointer
;	O
while	O
(	O
tree	struct
&&	O
c	char
!=	O
tree	struct
->	O
label	char
)	O
if	O
(	O
c	char
<	O
tree	struct
->	O
label	char
)	O
tree	struct
=	O
tree	struct
->	O
llink	pointer
;	O
else	O
tree	struct
=	O
tree	struct
->	O
rlink	pointer
;	O
if	O
(	O
tree	struct
)	O
{	O
trie	pointer
=	O
tree	struct
->	O
trie	pointer
;	O
if	O
(	O
trie	pointer
->	O
accepting	int
)	O
{	O
mch	pointer
=	O
beg	pointer
;	O
accept	pointer
=	O
trie	pointer
;	O
}	O
}	O
else	O
break	O
;	O
d	int
=	O
trie	pointer
->	O
shift	int
;	O
}	O
if	O
(	O
mch	pointer
)	O
goto	O
match	O
;	O
}	O
return	O
-	O
1	int
;	O
match	O
:	O
{	O
char	O
const	O
*	O
lmch	pointer
;	O
if	O
(	O
lim	pointer
-	O
mch	pointer
>	O
kwset	struct
->	O
maxd	int
)	O
lim	pointer
=	O
mch	pointer
+	O
kwset	struct
->	O
maxd	int
;	O
lmch	pointer
=	O
0	int
;	O
d	int
=	O
1	int
;	O
while	O
(	O
lim	pointer
-	O
end	pointer
>=	O
d	int
)	O
{	O
char	O
const	O
*	O
beg	pointer
;	O
struct	O
trie	pointer
const	O
*	O
trie	pointer
;	O
{	O
register	O
unsigned	O
char	O
c	char
;	O
if	O
(	O
(	O
d	int
=	O
delta	array
[	O
c	char
=	O
(	O
end	pointer
+=	O
d	int
)	O
[	O
-	O
1	int
]	O
]	O
)	O
!=	O
0	int
)	O
continue	O
;	O
beg	pointer
=	O
end	pointer
-	O
1	int
;	O
if	O
(	O
!	O
(	O
trie	pointer
=	O
next	pointer
[	O
c	char
]	O
)	O
)	O
{	O
d	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
trie	pointer
->	O
accepting	int
&&	O
beg	pointer
<=	O
mch	pointer
)	O
{	O
lmch	pointer
=	O
beg	pointer
;	O
accept	pointer
=	O
trie	pointer
;	O
}	O
d	int
=	O
trie	pointer
->	O
shift	int
;	O
while	O
(	O
beg	pointer
>	O
text	pointer
)	O
{	O
register	O
unsigned	O
char	O
c	char
;	O
register	O
struct	O
tree	struct
const	O
*	O
tree	struct
;	O
c	char
=	O
trans	pointer
?	O
trans	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
--	O
beg	pointer
]	O
:	O
*	O
--	O
beg	pointer
;	O
tree	struct
=	O
trie	pointer
->	O
links	pointer
;	O
while	O
(	O
tree	struct
&&	O
c	char
!=	O
tree	struct
->	O
label	char
)	O
if	O
(	O
c	char
<	O
tree	struct
->	O
label	char
)	O
tree	struct
=	O
tree	struct
->	O
llink	pointer
;	O
else	O
tree	struct
=	O
tree	struct
->	O
rlink	pointer
;	O
if	O
(	O
tree	struct
)	O
{	O
trie	pointer
=	O
tree	struct
->	O
trie	pointer
;	O
if	O
(	O
trie	pointer
->	O
accepting	int
&&	O
beg	pointer
<=	O
mch	pointer
)	O
{	O
lmch	pointer
=	O
beg	pointer
;	O
accept	pointer
=	O
trie	pointer
;	O
}	O
}	O
else	O
break	O
;	O
d	int
=	O
trie	pointer
->	O
shift	int
;	O
}	O
if	O
(	O
lmch	pointer
)	O
{	O
mch	pointer
=	O
lmch	pointer
;	O
goto	O
match	O
;	O
}	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
kwsmatch	struct
)	O
{	O
kwsmatch	struct
->	O
index	int
=	O
accept	pointer
->	O
accepting	int
/	O
2	int
;	O
kwsmatch	struct
->	O
offset	array
[	O
0	int
]	O
=	O
mch	pointer
-	O
text	pointer
;	O
kwsmatch	struct
->	O
size	array
[	O
0	int
]	O
=	O
accept	pointer
->	O
depth	int
;	O
}	O
return	O
mch	pointer
-	O
text	pointer
;	O
}	O
}	O
size_t	long
kwsexec	function
(	O
kwset_t	pointer
kws	pointer
,	O
char	O
const	O
*	O
text	pointer
,	O
size_t	long
size	array
,	O
struct	O
kwsmatch	struct
*	O
kwsmatch	struct
)	O
{	O
struct	O
kwset	struct
const	O
*	O
kwset	struct
=	O
(	O
struct	O
kwset	struct
*	O
)	O
kws	pointer
;	O
if	O
(	O
kwset	struct
->	O
words	int
==	O
1	int
&&	O
kwset	struct
->	O
trans	pointer
==	O
0	int
)	O
{	O
size_t	long
ret	long
=	O
bmexec	function
(	O
kws	pointer
,	O
text	pointer
,	O
size	array
)	O
;	O
if	O
(	O
kwsmatch	struct
!=	O
0	int
&&	O
ret	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
kwsmatch	struct
->	O
index	int
=	O
0	int
;	O
kwsmatch	struct
->	O
offset	array
[	O
0	int
]	O
=	O
ret	long
;	O
kwsmatch	struct
->	O
size	array
[	O
0	int
]	O
=	O
kwset	struct
->	O
mind	int
;	O
}	O
return	O
ret	long
;	O
}	O
else	O
return	O
cwexec	function
(	O
kws	pointer
,	O
text	pointer
,	O
size	array
,	O
kwsmatch	struct
)	O
;	O
}	O
void	O
kwsfree	function
(	O
kwset_t	pointer
kwset	struct
)	O
{	O
obstack_free	O
(	O
&	O
kwset	struct
->	O
obstack	struct
,	O
0	int
)	O
;	O
free	function
(	O
kwset	struct
)	O
;	O
}	O
