int	O
gsl_sf_hermite_prob_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
1.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
x	double
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
if	O
(	O
n	int
-	O
1	int
>	O
GSL_SF_DOUBLEFACT_NMAX	int
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
result	pointer
->	O
val	double
=	O
GSL_IS_ODD	O
(	O
n	int
/	O
2	int
)	O
?	O
GSL_NEGINF	O
:	O
GSL_POSINF	O
;	O
result	pointer
->	O
err	double
=	O
GSL_POSINF	O
;	O
}	O
else	O
{	O
gsl_sf_doublefact_e	function
(	O
n	int
-	O
1	int
,	O
result	pointer
)	O
;	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
/	O
2	int
)	O
)	O
result	pointer
->	O
val	double
=	O
-	O
result	pointer
->	O
val	double
;	O
}	O
return	O
status	int
;	O
}	O
}	O
else	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
const	O
double	O
abs_x	double
=	O
fabs	function
(	O
x	double
)	O
;	O
const	O
double	O
thresh1	double
=	O
abs_x	double
>	O
1.0	int
?	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
abs_x	double
:	O
GSL_DBL_MAX	int
;	O
const	O
double	O
thresh2	double
=	O
0.9	int
*	O
GSL_DBL_MAX	int
;	O
double	O
p_n0	double
=	O
1.0	int
;	O
double	O
p_n1	double
=	O
x	double
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
double	O
e_n0	double
=	O
GSL_DBL_EPSILON	int
;	O
double	O
e_n1	double
=	O
fabs	function
(	O
x	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
double	O
e_n	double
=	O
e_n1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
n	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
p_n1	double
)	O
>	O
thresh1	double
||	O
fabs	function
(	O
p_n0	double
)	O
>	O
thresh2	double
/	O
j	int
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
break	O
;	O
}	O
p_n	double
=	O
x	double
*	O
p_n1	double
-	O
j	int
*	O
p_n0	double
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
e_n	double
=	O
fabs	function
(	O
x	double
)	O
*	O
e_n1	double
+	O
j	int
*	O
e_n0	double
;	O
e_n0	double
=	O
e_n1	double
;	O
e_n1	double
=	O
e_n	double
;	O
}	O
result	pointer
->	O
val	double
=	O
p_n	double
;	O
result	pointer
->	O
err	double
=	O
e_n	double
+	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
return	O
status	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_prob	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_prob_e	function
(	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_prob_deriv_e	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
||	O
m	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
m	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
;	O
double	O
f	pointer
=	O
gsl_sf_choose	function
(	O
n	int
,	O
m	int
)	O
*	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
gsl_sf_result	struct
He	struct
;	O
status	int
=	O
gsl_sf_hermite_prob_e	function
(	O
n	int
-	O
m	int
,	O
x	double
,	O
&	O
He	struct
)	O
;	O
if	O
(	O
status	int
==	O
GSL_SUCCESS	int
)	O
{	O
result	pointer
->	O
val	double
=	O
He	struct
.	O
val	double
*	O
f	pointer
;	O
result	pointer
->	O
err	double
=	O
He	struct
.	O
err	double
*	O
f	pointer
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
else	O
{	O
result	pointer
->	O
val	double
=	O
He	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
GSL_POSINF	O
;	O
}	O
return	O
status	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_prob_deriv	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_prob_deriv_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
1.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
2.0	int
*	O
x	double
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
int	O
m	int
=	O
n	int
>>	O
1	int
;	O
if	O
(	O
n	int
-	O
1	int
>	O
GSL_SF_DOUBLEFACT_NMAX	int
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
result	pointer
->	O
val	double
=	O
GSL_IS_ODD	O
(	O
m	int
)	O
?	O
GSL_NEGINF	O
:	O
GSL_POSINF	O
;	O
result	pointer
->	O
err	double
=	O
GSL_POSINF	O
;	O
}	O
else	O
{	O
double	O
f	pointer
=	O
gsl_pow_int	function
(	O
2.0	int
,	O
m	int
)	O
;	O
gsl_sf_doublefact_e	function
(	O
n	int
-	O
1	int
,	O
result	pointer
)	O
;	O
if	O
(	O
result	pointer
->	O
val	double
>	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
f	pointer
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
result	pointer
->	O
val	double
=	O
GSL_IS_ODD	O
(	O
m	int
)	O
?	O
GSL_NEGINF	O
:	O
GSL_POSINF	O
;	O
result	pointer
->	O
err	double
=	O
GSL_POSINF	O
;	O
}	O
else	O
{	O
result	pointer
->	O
val	double
*=	O
f	pointer
;	O
result	pointer
->	O
err	double
*=	O
f	pointer
;	O
if	O
(	O
GSL_IS_ODD	O
(	O
m	int
)	O
)	O
result	pointer
->	O
val	double
=	O
-	O
result	pointer
->	O
val	double
;	O
}	O
}	O
return	O
status	int
;	O
}	O
}	O
else	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
const	O
double	O
two_x	double
=	O
2.0	int
*	O
x	double
;	O
const	O
double	O
abs_two_x	double
=	O
fabs	function
(	O
two_x	double
)	O
;	O
const	O
double	O
thresh1	double
=	O
abs_two_x	double
>	O
1.0	int
?	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
abs_two_x	double
:	O
GSL_DBL_MAX	int
;	O
const	O
double	O
thresh2	double
=	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
2.0	int
;	O
double	O
p_n0	double
=	O
1.0	int
;	O
double	O
p_n1	double
=	O
two_x	double
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
double	O
e_n0	double
=	O
GSL_DBL_EPSILON	int
;	O
double	O
e_n1	double
=	O
2.	int
*	O
fabs	function
(	O
x	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
double	O
e_n	double
=	O
e_n1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
n	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
p_n1	double
)	O
>	O
thresh1	double
||	O
fabs	function
(	O
p_n0	double
)	O
>	O
thresh2	double
/	O
j	int
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
break	O
;	O
}	O
p_n	double
=	O
two_x	double
*	O
p_n1	double
-	O
2.0	int
*	O
j	int
*	O
p_n0	double
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
e_n	double
=	O
2.	int
*	O
(	O
fabs	function
(	O
x	double
)	O
*	O
e_n1	double
+	O
j	int
*	O
e_n0	double
)	O
;	O
e_n0	double
=	O
e_n1	double
;	O
e_n1	double
=	O
e_n	double
;	O
}	O
result	pointer
->	O
val	double
=	O
p_n	double
;	O
result	pointer
->	O
err	double
=	O
e_n	double
+	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
return	O
status	int
;	O
}	O
}	O
double	O
gsl_sf_hermite	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_e	function
(	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_deriv_e	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
||	O
m	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
m	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
;	O
double	O
f	pointer
=	O
gsl_sf_choose	function
(	O
n	int
,	O
m	int
)	O
*	O
gsl_sf_fact	function
(	O
m	int
)	O
*	O
pow2	O
(	O
m	int
)	O
;	O
gsl_sf_result	struct
H	struct
;	O
status	int
=	O
gsl_sf_hermite_e	function
(	O
n	int
-	O
m	int
,	O
x	double
,	O
&	O
H	struct
)	O
;	O
if	O
(	O
status	int
==	O
GSL_SUCCESS	int
)	O
{	O
result	pointer
->	O
val	double
=	O
H	struct
.	O
val	double
*	O
f	pointer
;	O
result	pointer
->	O
err	double
=	O
H	struct
.	O
err	double
*	O
f	pointer
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
else	O
{	O
result	pointer
->	O
val	double
=	O
H	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
GSL_POSINF	O
;	O
}	O
return	O
status	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_deriv	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_deriv_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_func_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
)	O
{	O
result	pointer
->	O
val	double
=	O
0.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
f	pointer
=	O
(	O
GSL_IS_ODD	O
(	O
n	int
/	O
2	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
n	int
;	O
j	int
+=	O
2	int
)	O
f	pointer
*=	O
sqrt	function
(	O
j	int
/	O
(	O
j	int
+	O
1.0	int
)	O
)	O
;	O
result	pointer
->	O
val	double
=	O
f	pointer
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
M_SQRT2	int
*	O
x	double
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
hi2	double
=	O
1.0	int
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
double	O
hi1	double
=	O
M_SQRT2	int
*	O
x	double
*	O
hi2	double
;	O
double	O
hi	double
=	O
0.0	int
;	O
double	O
sum_log_scale	double
=	O
0.0	int
;	O
double	O
abshi	double
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<=	O
n	int
;	O
++	O
i	int
)	O
{	O
hi	double
=	O
sqrt	function
(	O
2.0	int
/	O
i	int
)	O
*	O
x	double
*	O
hi1	double
-	O
sqrt	function
(	O
(	O
i	int
-	O
1.0	int
)	O
/	O
i	int
)	O
*	O
hi2	double
;	O
hi2	double
=	O
hi1	double
;	O
hi1	double
=	O
hi	double
;	O
abshi	double
=	O
fabs	function
(	O
hi	double
)	O
;	O
if	O
(	O
abshi	double
>	O
1.0	int
)	O
{	O
double	O
log_scale	double
=	O
RND	O
(	O
log	function
(	O
abshi	double
)	O
)	O
;	O
double	O
scale	double
=	O
exp	function
(	O
-	O
log_scale	double
)	O
;	O
hi	double
*=	O
scale	double
;	O
hi1	double
*=	O
scale	double
;	O
hi2	double
*=	O
scale	double
;	O
sum_log_scale	double
+=	O
log_scale	double
;	O
}	O
}	O
result	pointer
->	O
val	double
=	O
hi	double
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
sum_log_scale	double
)	O
;	O
result	pointer
->	O
err	double
=	O
n	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_func	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_func_e	function
(	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_func_fast_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
1000	int
||	O
x	double
==	O
0.0	int
)	O
{	O
return	O
gsl_sf_hermite_func_e	function
(	O
n	int
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
{	O
size_t	long
j	int
;	O
const	O
double	O
k	double
=	O
sqrt	function
(	O
0.5	int
*	O
n	int
)	O
;	O
const	O
size_t	long
steps	long
=	O
(	O
size_t	long
)	O
ceil	function
(	O
6.211	int
*	O
sqrt	function
(	O
n	int
)	O
)	O
;	O
const	O
double	O
dt	double
=	O
M_PI	int
/	O
steps	long
;	O
const	O
double	O
invn2	double
=	O
1.0	int
/	O
(	O
n	int
*	O
n	int
)	O
;	O
double	O
ex	double
,	O
ex_e	double
,	O
cs	double
,	O
cs_e	double
,	O
sn	double
,	O
sn2	double
,	O
t	double
;	O
gsl_sf_result	struct
lngamma	struct
;	O
if	O
(	O
n	int
<	O
36	int
)	O
{	O
gsl_sf_lnfact_e	function
(	O
n	int
,	O
&	O
lngamma	struct
)	O
;	O
lngamma	struct
.	O
val	double
*=	O
0.5	int
;	O
lngamma	struct
.	O
err	double
*=	O
0.5	int
;	O
t	double
=	O
0.5	int
*	O
n	int
*	O
log	function
(	O
n	int
)	O
+	O
0.25	int
*	O
M_LNPI	int
;	O
cs	double
=	O
0.5	int
*	O
n	int
;	O
lngamma	struct
.	O
val	double
+=	O
cs	double
-	O
t	double
;	O
lngamma	struct
.	O
err	double
+=	O
(	O
cs	double
+	O
t	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
}	O
else	O
{	O
lngamma	struct
.	O
val	double
=	O
0.25	int
*	O
log	function
(	O
2	int
*	O
n	int
)	O
;	O
lngamma	struct
.	O
err	double
=	O
(	O
lngamma	struct
.	O
val	double
+	O
(	O
(	O
(	O
(	O
invn2	double
/	O
3360	int
+	O
1.0	int
/	O
2520	int
)	O
*	O
invn2	double
+	O
1.0	int
/	O
720	int
)	O
*	O
invn2	double
)	O
+	O
1.0	int
/	O
24	int
)	O
/	O
n	int
)	O
*	O
GSL_DBL_EPSILON	int
;	O
lngamma	struct
.	O
val	double
-=	O
(	O
(	O
(	O
(	O
invn2	double
/	O
3360	int
-	O
1.0	int
/	O
2520	int
)	O
*	O
invn2	double
+	O
1.0	int
/	O
720	int
)	O
*	O
invn2	double
)	O
-	O
1.0	int
/	O
24	int
)	O
/	O
n	int
;	O
}	O
ex	double
=	O
exp	function
(	O
lngamma	struct
.	O
val	double
-	O
n	int
-	O
0.5	int
*	O
x	double
*	O
x	double
-	O
2	int
*	O
x	double
*	O
k	double
)	O
;	O
cs	double
=	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
?	O
-	O
1	int
:	O
1	int
)	O
;	O
result	pointer
->	O
val	double
=	O
0.5	int
*	O
ex	double
*	O
cs	double
;	O
result	pointer
->	O
err	double
=	O
0.5	int
*	O
ex	double
*	O
(	O
lngamma	struct
.	O
err	double
+	O
(	O
n	int
+	O
0.5	int
*	O
x	double
*	O
x	double
+	O
fabs	function
(	O
2	int
*	O
x	double
*	O
k	double
)	O
+	O
1	int
)	O
*	O
GSL_DBL_EPSILON	int
)	O
;	O
ex	double
=	O
exp	function
(	O
lngamma	struct
.	O
val	double
-	O
n	int
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
2	int
*	O
x	double
*	O
k	double
)	O
;	O
result	pointer
->	O
val	double
+=	O
0.5	int
*	O
ex	double
;	O
result	pointer
->	O
err	double
+=	O
0.5	int
*	O
ex	double
*	O
(	O
lngamma	struct
.	O
err	double
+	O
(	O
n	int
+	O
0.5	int
*	O
x	double
*	O
x	double
+	O
fabs	function
(	O
2	int
*	O
x	double
*	O
k	double
)	O
+	O
1	int
)	O
*	O
GSL_DBL_EPSILON	int
)	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
steps	long
;	O
j	int
++	O
)	O
{	O
t	double
=	O
j	int
*	O
dt	double
;	O
cs	double
=	O
cos	function
(	O
t	double
)	O
;	O
ex	double
=	O
exp	function
(	O
lngamma	struct
.	O
val	double
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
(	O
2	int
*	O
x	double
*	O
k	double
-	O
n	int
*	O
cs	double
)	O
*	O
cs	double
)	O
;	O
ex_e	double
=	O
ex	double
*	O
(	O
lngamma	struct
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
(	O
1	int
+	O
0.5	int
*	O
x	double
*	O
x	double
+	O
(	O
fabs	function
(	O
2	int
*	O
x	double
*	O
k	double
)	O
+	O
fabs	function
(	O
n	int
*	O
cs	double
)	O
)	O
*	O
fabs	function
(	O
cs	double
)	O
)	O
)	O
;	O
sn	double
=	O
sin	function
(	O
t	double
)	O
;	O
sn2	double
=	O
sin	function
(	O
2	int
*	O
t	double
)	O
;	O
cs	double
=	O
cos	function
(	O
2	int
*	O
x	double
*	O
k	double
*	O
sn	double
-	O
0.5	int
*	O
n	int
*	O
sn2	double
-	O
n	int
*	O
t	double
)	O
;	O
cs_e	double
=	O
GSL_MIN	O
(	O
1.0	int
+	O
fabs	function
(	O
cs	double
)	O
,	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
cs	double
)	O
+	O
(	O
fabs	function
(	O
2	int
*	O
x	double
*	O
k	double
*	O
sn	double
)	O
+	O
fabs	function
(	O
0.5	int
*	O
n	int
*	O
sn2	double
)	O
+	O
n	int
*	O
t	double
)	O
*	O
fabs	function
(	O
sin	function
(	O
2	int
*	O
x	double
*	O
k	double
*	O
sn	double
-	O
0.5	int
*	O
n	int
*	O
sn2	double
-	O
n	int
*	O
t	double
)	O
)	O
)	O
)	O
;	O
result	pointer
->	O
val	double
+=	O
ex	double
*	O
cs	double
;	O
result	pointer
->	O
err	double
+=	O
ex	double
*	O
cs_e	double
+	O
ex_e	double
*	O
fabs	function
(	O
cs	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
ex	double
*	O
cs	double
)	O
;	O
}	O
result	pointer
->	O
val	double
*=	O
M_1_PI	int
*	O
dt	double
;	O
result	pointer
->	O
err	double
=	O
M_1_PI	int
*	O
dt	double
*	O
result	pointer
->	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_func_fast	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_func_fast_e	function
(	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_prob_array	function
(	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
nmax	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
0	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
1	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
result_array	pointer
[	O
1	int
]	O
=	O
x	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
const	O
double	O
abs_x	double
=	O
fabs	function
(	O
x	double
)	O
;	O
const	O
double	O
thresh1	double
=	O
abs_x	double
>	O
1.0	int
?	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
abs_x	double
:	O
GSL_DBL_MAX	int
;	O
const	O
double	O
thresh2	double
=	O
0.9	int
*	O
GSL_DBL_MAX	int
;	O
double	O
p_n0	double
=	O
1.0	int
;	O
double	O
p_n1	double
=	O
x	double
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
int	O
j	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
result_array	pointer
[	O
1	int
]	O
=	O
x	double
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
nmax	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
p_n1	double
)	O
>	O
thresh1	double
||	O
fabs	function
(	O
p_n0	double
)	O
>	O
thresh2	double
/	O
j	int
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
break	O
;	O
}	O
p_n	double
=	O
x	double
*	O
p_n1	double
-	O
j	int
*	O
p_n0	double
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
result_array	pointer
[	O
j	int
+	O
1	int
]	O
=	O
p_n	double
;	O
}	O
return	O
status	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_prob_array_deriv	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
nmax	int
<	O
0	int
||	O
m	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
m	int
==	O
0	int
)	O
{	O
gsl_sf_hermite_prob_array	function
(	O
nmax	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
<	O
m	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
nmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
m	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
nmax	int
]	O
=	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
m	int
+	O
1	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
nmax	int
-	O
1	int
]	O
=	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
result_array	pointer
[	O
nmax	int
]	O
=	O
result_array	pointer
[	O
nmax	int
-	O
1	int
]	O
*	O
(	O
m	int
+	O
1	int
)	O
*	O
x	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
p_n0	double
=	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
double	O
p_n1	double
=	O
p_n0	double
*	O
(	O
m	int
+	O
1	int
)	O
*	O
x	double
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
m	int
]	O
=	O
p_n0	double
;	O
result_array	pointer
[	O
m	int
+	O
1	int
]	O
=	O
p_n1	double
;	O
for	O
(	O
j	int
=	O
m	int
+	O
1	int
;	O
j	int
<=	O
nmax	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
p_n	double
=	O
(	O
x	double
*	O
p_n1	double
-	O
j	int
*	O
p_n0	double
)	O
*	O
(	O
j	int
+	O
1.0	int
)	O
/	O
(	O
j	int
-	O
m	int
+	O
1.0	int
)	O
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
result_array	pointer
[	O
j	int
+	O
1	int
]	O
=	O
p_n	double
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_prob_deriv_array	function
(	O
const	O
int	O
mmax	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
||	O
mmax	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
int	O
j	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
mmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
&&	O
mmax	int
>	O
0	int
)	O
{	O
int	O
j	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
x	double
;	O
result_array	pointer
[	O
1	int
]	O
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
2	int
;	O
j	int
<=	O
mmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
mmax	int
==	O
0	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
gsl_sf_hermite_prob	function
(	O
n	int
,	O
x	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
mmax	int
==	O
1	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
gsl_sf_hermite_prob	function
(	O
n	int
,	O
x	double
)	O
;	O
result_array	pointer
[	O
1	int
]	O
=	O
n	int
*	O
gsl_sf_hermite_prob	function
(	O
n	int
-	O
1	int
,	O
x	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
k	double
=	O
GSL_MAX_INT	function
(	O
0	int
,	O
n	int
-	O
mmax	int
)	O
;	O
double	O
p_n0	double
=	O
gsl_sf_hermite_prob	function
(	O
k	double
,	O
x	double
)	O
;	O
double	O
p_n1	double
=	O
gsl_sf_hermite_prob	function
(	O
k	double
+	O
1	int
,	O
x	double
)	O
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
n	int
+	O
1	int
;	O
j	int
<=	O
mmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
GSL_MIN_INT	function
(	O
n	int
,	O
mmax	int
)	O
]	O
=	O
p_n0	double
;	O
result_array	pointer
[	O
GSL_MIN_INT	function
(	O
n	int
,	O
mmax	int
)	O
-	O
1	int
]	O
=	O
p_n1	double
;	O
for	O
(	O
j	int
=	O
GSL_MIN_INT	function
(	O
mmax	int
,	O
n	int
)	O
-	O
1	int
;	O
j	int
>	O
0	int
;	O
j	int
--	O
)	O
{	O
k	double
++	O
;	O
p_n	double
=	O
x	double
*	O
p_n1	double
-	O
k	double
*	O
p_n0	double
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
result_array	pointer
[	O
j	int
-	O
1	int
]	O
=	O
p_n	double
;	O
}	O
p_n	double
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
GSL_MIN_INT	function
(	O
n	int
,	O
mmax	int
)	O
;	O
j	int
++	O
)	O
{	O
p_n	double
=	O
p_n	double
*	O
(	O
n	int
-	O
j	int
+	O
1	int
)	O
;	O
result_array	pointer
[	O
j	int
]	O
=	O
p_n	double
*	O
result_array	pointer
[	O
j	int
]	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_prob_series_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
a	double
[	O
0	int
]	O
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
a	double
[	O
0	int
]	O
+	O
a	double
[	O
1	int
]	O
*	O
x	double
;	O
result	pointer
->	O
err	double
=	O
2.	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
a	double
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
a	double
[	O
1	int
]	O
*	O
x	double
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
b0	double
=	O
0.	int
;	O
double	O
b1	double
=	O
0.	int
;	O
double	O
btmp	double
=	O
0.	int
;	O
double	O
e0	double
=	O
0.	int
;	O
double	O
e1	double
=	O
0.	int
;	O
double	O
etmp	double
=	O
e1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
n	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
btmp	double
=	O
b0	double
;	O
b0	double
=	O
a	double
[	O
j	int
]	O
+	O
x	double
*	O
b0	double
-	O
(	O
j	int
+	O
1	int
)	O
*	O
b1	double
;	O
b1	double
=	O
btmp	double
;	O
etmp	double
=	O
e0	double
;	O
e0	double
=	O
(	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
a	double
[	O
j	int
]	O
)	O
+	O
fabs	function
(	O
x	double
)	O
*	O
e0	double
+	O
(	O
j	int
+	O
1	int
)	O
*	O
e1	double
)	O
;	O
e1	double
=	O
etmp	double
;	O
}	O
result	pointer
->	O
val	double
=	O
b0	double
;	O
result	pointer
->	O
err	double
=	O
e0	double
+	O
fabs	function
(	O
b0	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_prob_series	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_prob_series_e	function
(	O
n	int
,	O
x	double
,	O
a	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_array	function
(	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
nmax	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
0	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
1	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
result_array	pointer
[	O
1	int
]	O
=	O
2.0	int
*	O
x	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
const	O
double	O
two_x	double
=	O
2.0	int
*	O
x	double
;	O
const	O
double	O
abs_two_x	double
=	O
fabs	function
(	O
two_x	double
)	O
;	O
const	O
double	O
thresh1	double
=	O
abs_two_x	double
>	O
1.0	int
?	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
abs_two_x	double
:	O
GSL_DBL_MAX	int
;	O
const	O
double	O
thresh2	double
=	O
0.9	int
*	O
GSL_DBL_MAX	int
/	O
2.0	int
;	O
double	O
p_n0	double
=	O
1.0	int
;	O
double	O
p_n1	double
=	O
two_x	double
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
int	O
j	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
result_array	pointer
[	O
1	int
]	O
=	O
2.0	int
*	O
x	double
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
nmax	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
fabs	function
(	O
p_n1	double
)	O
>	O
thresh1	double
||	O
fabs	function
(	O
p_n0	double
)	O
>	O
thresh2	double
/	O
j	int
)	O
{	O
status	int
=	O
GSL_EOVRFLW	int
;	O
}	O
p_n	double
=	O
two_x	double
*	O
p_n1	double
-	O
2.0	int
*	O
j	int
*	O
p_n0	double
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
result_array	pointer
[	O
j	int
+	O
1	int
]	O
=	O
p_n	double
;	O
}	O
return	O
status	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_array_deriv	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
nmax	int
<	O
0	int
||	O
m	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
m	int
==	O
0	int
)	O
{	O
gsl_sf_hermite_array	function
(	O
nmax	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
<	O
m	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
nmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
m	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
nmax	int
]	O
=	O
pow2	O
(	O
m	int
)	O
*	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
m	int
+	O
1	int
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
nmax	int
-	O
1	int
]	O
=	O
pow2	O
(	O
m	int
)	O
*	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
result_array	pointer
[	O
nmax	int
]	O
=	O
result_array	pointer
[	O
nmax	int
-	O
1	int
]	O
*	O
2	int
*	O
(	O
m	int
+	O
1	int
)	O
*	O
x	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
p_n0	double
=	O
pow2	O
(	O
m	int
)	O
*	O
gsl_sf_fact	function
(	O
m	int
)	O
;	O
double	O
p_n1	double
=	O
p_n0	double
*	O
2	int
*	O
(	O
m	int
+	O
1	int
)	O
*	O
x	double
;	O
double	O
p_n	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
m	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
m	int
]	O
=	O
p_n0	double
;	O
result_array	pointer
[	O
m	int
+	O
1	int
]	O
=	O
p_n1	double
;	O
for	O
(	O
j	int
=	O
m	int
+	O
1	int
;	O
j	int
<	O
nmax	int
;	O
++	O
j	int
)	O
{	O
p_n	double
=	O
(	O
x	double
*	O
p_n1	double
-	O
j	int
*	O
p_n0	double
)	O
*	O
2	int
*	O
(	O
j	int
+	O
1.0	int
)	O
/	O
(	O
j	int
-	O
m	int
+	O
1.0	int
)	O
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
result_array	pointer
[	O
j	int
+	O
1	int
]	O
=	O
p_n	double
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_deriv_array	function
(	O
const	O
int	O
mmax	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
||	O
mmax	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
int	O
j	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
mmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
&&	O
mmax	int
>	O
0	int
)	O
{	O
int	O
j	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
2	int
*	O
x	double
;	O
result_array	pointer
[	O
1	int
]	O
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
2	int
;	O
j	int
<=	O
mmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
mmax	int
==	O
0	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
gsl_sf_hermite	function
(	O
n	int
,	O
x	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
mmax	int
==	O
1	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
gsl_sf_hermite	function
(	O
n	int
,	O
x	double
)	O
;	O
result_array	pointer
[	O
1	int
]	O
=	O
2	int
*	O
n	int
*	O
gsl_sf_hermite	function
(	O
n	int
-	O
1	int
,	O
x	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
k	double
=	O
GSL_MAX_INT	function
(	O
0	int
,	O
n	int
-	O
mmax	int
)	O
;	O
double	O
p_n0	double
=	O
gsl_sf_hermite	function
(	O
k	double
,	O
x	double
)	O
;	O
double	O
p_n1	double
=	O
gsl_sf_hermite	function
(	O
k	double
+	O
1	int
,	O
x	double
)	O
;	O
double	O
p_n	double
=	O
p_n1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
n	int
+	O
1	int
;	O
j	int
<=	O
mmax	int
;	O
j	int
++	O
)	O
result_array	pointer
[	O
j	int
]	O
=	O
0.0	int
;	O
result_array	pointer
[	O
GSL_MIN_INT	function
(	O
n	int
,	O
mmax	int
)	O
]	O
=	O
p_n0	double
;	O
result_array	pointer
[	O
GSL_MIN_INT	function
(	O
n	int
,	O
mmax	int
)	O
-	O
1	int
]	O
=	O
p_n1	double
;	O
for	O
(	O
j	int
=	O
GSL_MIN_INT	function
(	O
mmax	int
,	O
n	int
)	O
-	O
1	int
;	O
j	int
>	O
0	int
;	O
j	int
--	O
)	O
{	O
k	double
++	O
;	O
p_n	double
=	O
2	int
*	O
x	double
*	O
p_n1	double
-	O
2	int
*	O
k	double
*	O
p_n0	double
;	O
p_n0	double
=	O
p_n1	double
;	O
p_n1	double
=	O
p_n	double
;	O
result_array	pointer
[	O
j	int
-	O
1	int
]	O
=	O
p_n	double
;	O
}	O
p_n	double
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
GSL_MIN_INT	function
(	O
n	int
,	O
mmax	int
)	O
;	O
j	int
++	O
)	O
{	O
p_n	double
*=	O
2.0	int
*	O
(	O
n	int
-	O
j	int
+	O
1.0	int
)	O
;	O
result_array	pointer
[	O
j	int
]	O
*=	O
p_n	double
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_series_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
a	double
[	O
0	int
]	O
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
a	double
[	O
0	int
]	O
+	O
a	double
[	O
1	int
]	O
*	O
2.	int
*	O
x	double
;	O
result	pointer
->	O
err	double
=	O
2.	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
a	double
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
a	double
[	O
1	int
]	O
*	O
2.	int
*	O
x	double
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
b0	double
=	O
0.	int
;	O
double	O
b1	double
=	O
0.	int
;	O
double	O
btmp	double
=	O
0.	int
;	O
double	O
e0	double
=	O
0.	int
;	O
double	O
e1	double
=	O
0.	int
;	O
double	O
etmp	double
=	O
e1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
n	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
btmp	double
=	O
b0	double
;	O
b0	double
=	O
a	double
[	O
j	int
]	O
+	O
2.	int
*	O
x	double
*	O
b0	double
-	O
2.	int
*	O
(	O
j	int
+	O
1	int
)	O
*	O
b1	double
;	O
b1	double
=	O
btmp	double
;	O
etmp	double
=	O
e0	double
;	O
e0	double
=	O
(	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
a	double
[	O
j	int
]	O
)	O
+	O
fabs	function
(	O
2.	int
*	O
x	double
)	O
*	O
e0	double
+	O
2.	int
*	O
(	O
j	int
+	O
1	int
)	O
*	O
e1	double
)	O
;	O
e1	double
=	O
etmp	double
;	O
}	O
result	pointer
->	O
val	double
=	O
b0	double
;	O
result	pointer
->	O
err	double
=	O
e0	double
+	O
fabs	function
(	O
b0	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_series	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_series_e	function
(	O
n	int
,	O
x	double
,	O
a	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_func_array	function
(	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
nmax	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
0	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
nmax	int
==	O
1	int
)	O
{	O
result_array	pointer
[	O
0	int
]	O
=	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result_array	pointer
[	O
1	int
]	O
=	O
result_array	pointer
[	O
0	int
]	O
*	O
M_SQRT2	int
*	O
x	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
arg	pointer
=	O
-	O
0.5	int
*	O
x	double
*	O
x	double
;	O
double	O
hi2	double
=	O
1.0	int
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
double	O
hi1	double
=	O
M_SQRT2	int
*	O
x	double
*	O
hi2	double
;	O
double	O
hi	double
=	O
0.0	int
;	O
double	O
sum_log_scale	double
=	O
0.0	int
;	O
double	O
abshi	double
;	O
int	O
i	int
;	O
result_array	pointer
[	O
0	int
]	O
=	O
exp	function
(	O
arg	pointer
)	O
*	O
hi2	double
;	O
result_array	pointer
[	O
1	int
]	O
=	O
result_array	pointer
[	O
0	int
]	O
*	O
M_SQRT2	int
*	O
x	double
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<=	O
nmax	int
;	O
++	O
i	int
)	O
{	O
hi	double
=	O
sqrt	function
(	O
2.0	int
/	O
i	int
)	O
*	O
x	double
*	O
hi1	double
-	O
sqrt	function
(	O
(	O
i	int
-	O
1.0	int
)	O
/	O
i	int
)	O
*	O
hi2	double
;	O
hi2	double
=	O
hi1	double
;	O
hi1	double
=	O
hi	double
;	O
abshi	double
=	O
fabs	function
(	O
hi	double
)	O
;	O
if	O
(	O
abshi	double
>	O
1.0	int
)	O
{	O
double	O
log_scale	double
=	O
RND	O
(	O
log	function
(	O
abshi	double
)	O
)	O
;	O
double	O
scale	double
=	O
exp	function
(	O
-	O
log_scale	double
)	O
;	O
hi	double
*=	O
scale	double
;	O
hi1	double
*=	O
scale	double
;	O
hi2	double
*=	O
scale	double
;	O
sum_log_scale	double
+=	O
log_scale	double
;	O
}	O
result_array	pointer
[	O
i	int
]	O
=	O
hi	double
*	O
exp	function
(	O
arg	pointer
+	O
sum_log_scale	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_hermite_func_series_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
a	double
[	O
0	int
]	O
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
(	O
a	double
[	O
0	int
]	O
+	O
a	double
[	O
1	int
]	O
*	O
M_SQRT2	int
*	O
x	double
)	O
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
2.	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
a	double
[	O
0	int
]	O
)	O
+	O
fabs	function
(	O
a	double
[	O
1	int
]	O
*	O
M_SQRT2	int
*	O
x	double
)	O
)	O
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
b0	double
=	O
0.	int
;	O
double	O
b1	double
=	O
0.	int
;	O
double	O
btmp	double
=	O
0.	int
;	O
double	O
e0	double
=	O
0.	int
;	O
double	O
e1	double
=	O
0.	int
;	O
double	O
etmp	double
=	O
e1	double
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
n	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
btmp	double
=	O
b0	double
;	O
b0	double
=	O
a	double
[	O
j	int
]	O
+	O
sqrt	function
(	O
2.	int
/	O
(	O
j	int
+	O
1	int
)	O
)	O
*	O
x	double
*	O
b0	double
-	O
sqrt	function
(	O
(	O
j	int
+	O
1.	int
)	O
/	O
(	O
j	int
+	O
2.	int
)	O
)	O
*	O
b1	double
;	O
b1	double
=	O
btmp	double
;	O
etmp	double
=	O
e0	double
;	O
e0	double
=	O
(	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
a	double
[	O
j	int
]	O
)	O
+	O
sqrt	function
(	O
2.	int
/	O
(	O
j	int
+	O
1	int
)	O
)	O
*	O
fabs	function
(	O
x	double
)	O
*	O
e0	double
+	O
sqrt	function
(	O
(	O
j	int
+	O
1.	int
)	O
/	O
(	O
j	int
+	O
2.	int
)	O
)	O
*	O
e1	double
)	O
;	O
e1	double
=	O
etmp	double
;	O
}	O
result	pointer
->	O
val	double
=	O
b0	double
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
e0	double
+	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
*	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_func_series	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_func_series_e	function
(	O
n	int
,	O
x	double
,	O
a	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_func_der_e	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
m	int
<	O
0	int
||	O
n	int
<	O
0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
m	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_hermite_func_e	function
(	O
n	int
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
m	int
==	O
1	int
)	O
{	O
double	O
hi2	double
=	O
1.0	int
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
double	O
hi1	double
=	O
M_SQRT2	int
*	O
x	double
*	O
hi2	double
;	O
double	O
hi	double
=	O
0.0	int
;	O
double	O
sum_log_scale	double
=	O
0.0	int
;	O
double	O
abshi	double
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<=	O
n	int
;	O
++	O
i	int
)	O
{	O
hi	double
=	O
sqrt	function
(	O
2.0	int
/	O
i	int
)	O
*	O
x	double
*	O
hi1	double
-	O
sqrt	function
(	O
(	O
i	int
-	O
1.0	int
)	O
/	O
i	int
)	O
*	O
hi2	double
;	O
hi2	double
=	O
hi1	double
;	O
hi1	double
=	O
hi	double
;	O
abshi	double
=	O
fabs	function
(	O
hi	double
)	O
;	O
if	O
(	O
abshi	double
>	O
1.0	int
)	O
{	O
double	O
log_scale	double
=	O
RND	O
(	O
log	function
(	O
abshi	double
)	O
)	O
;	O
double	O
scale	double
=	O
exp	function
(	O
-	O
log_scale	double
)	O
;	O
hi	double
*=	O
scale	double
;	O
hi1	double
*=	O
scale	double
;	O
hi2	double
*=	O
scale	double
;	O
sum_log_scale	double
+=	O
log_scale	double
;	O
}	O
}	O
result	pointer
->	O
val	double
=	O
(	O
sqrt	function
(	O
2.0	int
*	O
n	int
)	O
*	O
hi2	double
-	O
x	double
*	O
hi	double
)	O
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
+	O
sum_log_scale	double
)	O
;	O
result	pointer
->	O
err	double
=	O
n	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
j	int
;	O
double	O
r	pointer
,	O
er	double
,	O
b	double
;	O
double	O
h0	double
=	O
1.	int
;	O
double	O
h1	double
=	O
x	double
;	O
double	O
eh0	double
=	O
GSL_DBL_EPSILON	int
;	O
double	O
eh1	double
=	O
GSL_DBL_EPSILON	int
;	O
double	O
p0	double
=	O
1.	int
;	O
double	O
p1	double
=	O
M_SQRT2	int
*	O
x	double
;	O
double	O
ep0	double
=	O
GSL_DBL_EPSILON	int
;	O
double	O
ep1	double
=	O
M_SQRT2	int
*	O
GSL_DBL_EPSILON	int
;	O
double	O
f	pointer
=	O
1.	int
;	O
for	O
(	O
j	int
=	O
GSL_MAX_INT	function
(	O
1	int
,	O
n	int
-	O
m	int
+	O
1	int
)	O
;	O
j	int
<=	O
n	int
;	O
j	int
++	O
)	O
f	pointer
*=	O
sqrt	function
(	O
2.	int
*	O
j	int
)	O
;	O
if	O
(	O
m	int
>	O
n	int
)	O
{	O
f	pointer
=	O
(	O
GSL_IS_ODD	O
(	O
m	int
-	O
n	int
)	O
?	O
-	O
f	pointer
:	O
f	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
GSL_MIN_INT	function
(	O
n	int
,	O
m	int
-	O
n	int
)	O
;	O
j	int
++	O
)	O
f	pointer
*=	O
(	O
m	int
-	O
j	int
)	O
/	O
(	O
j	int
+	O
1.	int
)	O
;	O
}	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
m	int
-	O
n	int
;	O
j	int
++	O
)	O
{	O
b	double
=	O
x	double
*	O
h1	double
-	O
j	int
*	O
h0	double
;	O
h0	double
=	O
h1	double
;	O
h1	double
=	O
b	double
;	O
b	double
=	O
(	O
fabs	function
(	O
x	double
)	O
*	O
eh1	double
+	O
j	int
*	O
eh0	double
)	O
;	O
eh0	double
=	O
eh1	double
;	O
eh1	double
=	O
b	double
;	O
}	O
b	double
=	O
0.	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
n	int
-	O
m	int
;	O
j	int
++	O
)	O
{	O
b	double
=	O
(	O
M_SQRT2	int
*	O
x	double
*	O
p1	double
-	O
sqrt	function
(	O
j	int
)	O
*	O
p0	double
)	O
/	O
sqrt	function
(	O
j	int
+	O
1.	int
)	O
;	O
p0	double
=	O
p1	double
;	O
p1	double
=	O
b	double
;	O
b	double
=	O
(	O
M_SQRT2	int
*	O
fabs	function
(	O
x	double
)	O
*	O
ep1	double
+	O
sqrt	function
(	O
j	int
)	O
*	O
ep0	double
)	O
/	O
sqrt	function
(	O
j	int
+	O
1.	int
)	O
;	O
ep0	double
=	O
ep1	double
;	O
ep1	double
=	O
b	double
;	O
}	O
b	double
=	O
0.	int
;	O
r	pointer
=	O
0.	int
;	O
er	double
=	O
0.	int
;	O
for	O
(	O
j	int
=	O
GSL_MAX_INT	function
(	O
0	int
,	O
m	int
-	O
n	int
)	O
;	O
j	int
<=	O
m	int
;	O
j	int
++	O
)	O
{	O
r	pointer
+=	O
f	pointer
*	O
h0	double
*	O
p0	double
;	O
er	double
+=	O
eh0	double
*	O
fabs	function
(	O
f	pointer
*	O
p0	double
)	O
+	O
ep0	double
*	O
fabs	function
(	O
f	pointer
*	O
h0	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
f	pointer
*	O
h0	double
*	O
p0	double
)	O
;	O
b	double
=	O
x	double
*	O
h1	double
-	O
(	O
j	int
+	O
1.	int
)	O
*	O
h0	double
;	O
h0	double
=	O
h1	double
;	O
h1	double
=	O
b	double
;	O
b	double
=	O
0.5	int
*	O
(	O
fabs	function
(	O
x	double
)	O
*	O
eh1	double
+	O
(	O
j	int
+	O
1.	int
)	O
*	O
eh0	double
)	O
;	O
eh0	double
=	O
eh1	double
;	O
eh1	double
=	O
b	double
;	O
b	double
=	O
(	O
M_SQRT2	int
*	O
x	double
*	O
p1	double
-	O
sqrt	function
(	O
n	int
-	O
m	int
+	O
j	int
+	O
1.	int
)	O
*	O
p0	double
)	O
/	O
sqrt	function
(	O
n	int
-	O
m	int
+	O
j	int
+	O
2.	int
)	O
;	O
p0	double
=	O
p1	double
;	O
p1	double
=	O
b	double
;	O
b	double
=	O
0.5	int
*	O
(	O
M_SQRT2	int
*	O
fabs	function
(	O
x	double
)	O
*	O
ep1	double
+	O
sqrt	function
(	O
n	int
-	O
m	int
+	O
j	int
+	O
1.	int
)	O
*	O
ep0	double
)	O
/	O
sqrt	function
(	O
n	int
-	O
m	int
+	O
j	int
+	O
2.	int
)	O
;	O
ep0	double
=	O
ep1	double
;	O
ep1	double
=	O
b	double
;	O
f	pointer
*=	O
-	O
(	O
m	int
-	O
j	int
)	O
/	O
(	O
j	int
+	O
1.	int
)	O
/	O
sqrt	function
(	O
n	int
-	O
m	int
+	O
j	int
+	O
1.	int
)	O
*	O
M_SQRT1_2	int
;	O
}	O
result	pointer
->	O
val	double
=	O
r	pointer
*	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
;	O
result	pointer
->	O
err	double
=	O
er	double
*	O
fabs	function
(	O
exp	function
(	O
-	O
0.5	int
*	O
x	double
*	O
x	double
)	O
/	O
sqrt	function
(	O
M_SQRTPI	int
)	O
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_func_der	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_func_der_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
static	O
double	O
H_zero_init	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
k	double
)	O
{	O
double	O
p	double
=	O
1.	int
,	O
x	double
=	O
1.	int
,	O
y	double
=	O
1.	int
;	O
if	O
(	O
k	double
==	O
1	int
&&	O
n	int
>	O
50	int
)	O
{	O
x	double
=	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
?	O
1.	int
/	O
sqrt	function
(	O
(	O
n	int
-	O
1	int
)	O
/	O
6.	int
)	O
:	O
1.	int
/	O
sqrt	function
(	O
0.5	int
*	O
n	int
)	O
)	O
;	O
}	O
else	O
{	O
p	double
=	O
-	O
0.7937005259840997373758528196	int
*	O
gsl_sf_airy_zero_Ai	function
(	O
n	int
/	O
2	int
-	O
k	double
+	O
1	int
)	O
;	O
x	double
=	O
sqrt	function
(	O
2	int
*	O
n	int
+	O
1.	int
)	O
;	O
y	double
=	O
pow	function
(	O
2	int
*	O
n	int
+	O
1.	int
,	O
1	int
/	O
6.	int
)	O
;	O
x	double
=	O
x	double
-	O
p	double
/	O
y	double
-	O
0.1	int
*	O
p	double
*	O
p	double
/	O
(	O
x	double
*	O
y	double
*	O
y	double
)	O
+	O
(	O
9	int
/	O
280.	int
-	O
p	double
*	O
p	double
*	O
p	double
*	O
11	int
/	O
350.	int
)	O
/	O
(	O
x	double
*	O
x	double
*	O
x	double
)	O
+	O
(	O
p	double
*	O
277	int
/	O
12600.	int
-	O
gsl_sf_pow_int	function
(	O
p	double
,	O
4	int
)	O
*	O
823	int
/	O
63000.	int
)	O
/	O
gsl_sf_pow_int	function
(	O
x	double
,	O
4	int
)	O
/	O
y	double
;	O
}	O
p	double
=	O
acos	function
(	O
x	double
/	O
sqrt	function
(	O
2	int
*	O
n	int
+	O
1.	int
)	O
)	O
;	O
y	double
=	O
M_PI	int
*	O
(	O
-	O
2	int
*	O
(	O
n	int
/	O
2	int
-	O
k	double
)	O
-	O
1.5	int
)	O
/	O
(	O
n	int
+	O
0.5	int
)	O
;	O
if	O
(	O
gsl_fcmp	function
(	O
y	double
,	O
sin	function
(	O
2.	int
*	O
p	double
)	O
-	O
2	int
*	O
p	double
,	O
GSL_SQRT_DBL_EPSILON	int
)	O
==	O
0	int
)	O
return	O
x	double
;	O
if	O
(	O
y	double
>	O
-	O
GSL_DBL_EPSILON	int
)	O
return	O
sqrt	function
(	O
2	int
*	O
n	int
+	O
1.	int
)	O
;	O
if	O
(	O
p	double
<	O
GSL_DBL_EPSILON	int
)	O
p	double
=	O
GSL_DBL_EPSILON	int
;	O
if	O
(	O
p	double
>	O
M_PI_2	int
)	O
p	double
=	O
M_PI_2	int
;	O
if	O
(	O
sin	function
(	O
2.	int
*	O
p	double
)	O
-	O
2	int
*	O
p	double
>	O
y	double
)	O
{	O
x	double
=	O
GSL_MAX	O
(	O
(	O
sin	function
(	O
2.	int
*	O
p	double
)	O
-	O
2	int
*	O
p	double
-	O
y	double
)	O
/	O
4.	int
,	O
GSL_SQRT_DBL_EPSILON	int
)	O
;	O
do	O
{	O
x	double
*=	O
2.	int
;	O
p	double
+=	O
x	double
;	O
}	O
while	O
(	O
sin	function
(	O
2.	int
*	O
p	double
)	O
-	O
2	int
*	O
p	double
>	O
y	double
)	O
;	O
}	O
do	O
{	O
x	double
=	O
p	double
;	O
p	double
-=	O
(	O
sin	function
(	O
2.	int
*	O
p	double
)	O
-	O
2.	int
*	O
p	double
-	O
y	double
)	O
/	O
(	O
2.	int
*	O
cos	function
(	O
2.	int
*	O
p	double
)	O
-	O
2.	int
)	O
;	O
if	O
(	O
p	double
<	O
0.	int
||	O
p	double
>	O
M_PI_2	int
)	O
p	double
=	O
M_PI_2	int
;	O
}	O
while	O
(	O
gsl_fcmp	function
(	O
x	double
,	O
p	double
,	O
100	int
*	O
GSL_DBL_EPSILON	int
)	O
!=	O
0	int
)	O
;	O
return	O
sqrt	function
(	O
2	int
*	O
n	int
+	O
1.	int
)	O
*	O
cos	function
(	O
p	double
)	O
;	O
}	O
static	O
double	O
He_zero_tab	array
[	O
99	int
]	O
=	O
{	O
1.73205080756887729352744634151	int
,	O
0.741963784302725857648513596726	int
,	O
2.33441421833897723931751226721	int
,	O
1.35562617997426586583052129087	int
,	O
2.85697001387280565416230426401	int
,	O
0.616706590192594152193686099399	int
,	O
1.88917587775371067550566789858	int
,	O
3.32425743355211895236183546247	int
,	O
1.154405394739968127239597758838	int
,	O
2.36675941073454128861885646856	int
,	O
3.75043971772574225630392202571	int
,	O
0.539079811351375108072461918694	int
,	O
1.63651904243510799922544657297	int
,	O
2.80248586128754169911301080618	int
,	O
4.14454718612589433206019783917	int
,	O
1.023255663789132524828148225810	int
,	O
2.07684797867783010652215614374	int
,	O
3.20542900285646994336567590292	int
,	O
4.51274586339978266756667884317	int
,	O
0.484935707515497653046233483105	int
,	O
1.46598909439115818325066466416	int
,	O
2.48432584163895458087625118368	int
,	O
3.58182348355192692277623675546	int
,	O
4.85946282833231215015516494660	int
,	O
0.928868997381063940144111999584	int
,	O
1.87603502015484584534137013967	int
,	O
2.86512316064364499771968407254	int
,	O
3.93616660712997692868589612142	int
,	O
5.18800122437487094818666404539	int
,	O
0.444403001944138945299732445510	int
,	O
1.34037519715161672153112945211	int
,	O
2.25946445100079912386492979448	int
,	O
3.22370982877009747166319001956	int
,	O
4.27182584793228172295999293076	int
,	O
5.50090170446774760081221630899	int
,	O
0.856679493519450033897376121795	int
,	O
1.72541837958823916151095838741	int
,	O
2.62068997343221478063807762201	int
,	O
3.56344438028163409162493844661	int
,	O
4.59139844893652062705231872720	int
,	O
5.80016725238650030586450565322	int
,	O
0.412590457954601838167454145167	int
,	O
1.24268895548546417895063983219	int
,	O
2.08834474570194417097139675101	int
,	O
2.96303657983866750254927123447	int
,	O
3.88692457505976938384755016476	int
,	O
4.89693639734556468372449782879	int
,	O
6.08740954690129132226890147034	int
,	O
0.799129068324547999424888414207	int
,	O
1.60671006902872973652322479373	int
,	O
2.43243682700975804116311571682	int
,	O
3.28908242439876638890856229770	int
,	O
4.19620771126901565957404160583	int
,	O
5.19009359130478119946445431715	int
,	O
6.36394788882983831771116094427	int
,	O
0.386760604500557347721047189801	int
,	O
1.16382910055496477419336819907	int
,	O
1.95198034571633346449212362880	int
,	O
2.76024504763070161684598142269	int
,	O
3.60087362417154828824902745506	int
,	O
4.49295530252001124266582263095	int
,	O
5.47222570594934308841242925805	int
,	O
6.63087819839312848022981922233	int
,	O
0.751842600703896170737870774614	int
,	O
1.50988330779674075905491513417	int
,	O
2.28101944025298889535537879396	int
,	O
3.07379717532819355851658337833	int
,	O
3.90006571719800990903311840097	int
,	O
4.77853158962998382710540812497	int
,	O
5.74446007865940618125547815768	int
,	O
6.88912243989533223256205432938	int
,	O
0.365245755507697595916901619097	int
,	O
1.09839551809150122773848360538	int
,	O
1.83977992150864548966395498992	int
,	O
2.59583368891124032910545091458	int
,	O
3.37473653577809099529779309480	int
,	O
4.18802023162940370448450911428	int
,	O
5.05407268544273984538327527397	int
,	O
6.00774591135959752029303858752	int
,	O
7.13946484914647887560975631213	int
,	O
0.712085044042379940413609979021	int
,	O
1.42887667607837287134157901452	int
,	O
2.15550276131693514033871248449	int
,	O
2.89805127651575312007902775275	int
,	O
3.66441654745063847665304033851	int
,	O
4.46587262683103133615452574019	int
,	O
5.32053637733603803162823765939	int
,	O
6.26289115651325170419416064557	int
,	O
7.38257902403043186766326977122	int
,	O
0.346964157081355927973322447164	int
,	O
1.04294534880275103146136681143	int
,	O
1.74524732081412671493067861704	int
,	O
2.45866361117236775131735057433	int
,	O
3.18901481655338941485371744116	int
,	O
3.94396735065731626033176813604	int
,	O
4.73458133404605534390170946748	int
,	O
5.57873880589320115268040332802	int
,	O
6.51059015701365448636289263918	int
,	O
7.61904854167975829138128156060	int
}	O
;	O
int	O
gsl_sf_hermite_prob_zero_e	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<=	O
0	int
||	O
s	int
<	O
0	int
||	O
s	int
>	O
n	int
/	O
2	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
s	int
==	O
0	int
)	O
{	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
n	int
==	O
2	int
)	O
{	O
result	pointer
->	O
val	double
=	O
1.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
<	O
21	int
)	O
{	O
result	pointer
->	O
val	double
=	O
He_zero_tab	array
[	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
?	O
n	int
/	O
2	int
:	O
0	int
)	O
+	O
(	O
(	O
n	int
/	O
2	int
)	O
*	O
(	O
n	int
/	O
2	int
-	O
1	int
)	O
)	O
+	O
s	int
-	O
2	int
]	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
d	double
=	O
1.	int
,	O
x	double
=	O
1.	int
,	O
x0	double
=	O
1.	int
;	O
int	O
j	int
;	O
x	double
=	O
H_zero_init	function
(	O
n	int
,	O
s	int
)	O
*	O
M_SQRT2	int
;	O
do	O
{	O
x0	double
=	O
x	double
;	O
d	double
=	O
0.	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
n	int
;	O
j	int
++	O
)	O
d	double
=	O
j	int
/	O
(	O
x	double
-	O
d	double
)	O
;	O
x	double
-=	O
(	O
x	double
-	O
d	double
)	O
/	O
n	int
;	O
}	O
while	O
(	O
gsl_fcmp	function
(	O
x	double
,	O
x0	double
,	O
10	int
*	O
GSL_DBL_EPSILON	int
)	O
!=	O
0	int
)	O
;	O
result	pointer
->	O
val	double
=	O
x	double
;	O
result	pointer
->	O
err	double
=	O
2	int
*	O
GSL_DBL_EPSILON	int
*	O
x	double
+	O
fabs	function
(	O
x	double
-	O
x0	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_prob_zero	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_prob_zero_e	function
(	O
n	int
,	O
s	int
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
static	O
double	O
H_zero_tab	array
[	O
99	int
]	O
=	O
{	O
1.22474487139158904909864203735	int
,	O
0.524647623275290317884060253835	int
,	O
1.65068012388578455588334111112	int
,	O
0.958572464613818507112770593893	int
,	O
2.02018287045608563292872408814	int
,	O
0.436077411927616508679215948251	int
,	O
1.335849074013696949714895282970	int
,	O
2.35060497367449222283392198706	int
,	O
0.816287882858964663038710959027	int
,	O
1.67355162876747144503180139830	int
,	O
2.65196135683523349244708200652	int
,	O
0.381186990207322116854718885584	int
,	O
1.157193712446780194720765779063	int
,	O
1.98165675669584292585463063977	int
,	O
2.93063742025724401922350270524	int
,	O
0.723551018752837573322639864579	int
,	O
1.46855328921666793166701573925	int
,	O
2.26658058453184311180209693284	int
,	O
3.19099320178152760723004779538	int
,	O
0.342901327223704608789165025557	int
,	O
1.03661082978951365417749191676	int
,	O
1.75668364929988177345140122011	int
,	O
2.53273167423278979640896079775	int
,	O
3.43615911883773760332672549432	int
,	O
0.656809566882099765024611575383	int
,	O
1.32655708449493285594973473558	int
,	O
2.02594801582575533516591283121	int
,	O
2.78329009978165177083671870152	int
,	O
3.66847084655958251845837146485	int
,	O
0.314240376254359111276611634095	int
,	O
0.947788391240163743704578131060	int
,	O
1.59768263515260479670966277090	int
,	O
2.27950708050105990018772856942	int
,	O
3.02063702512088977171067937518	int
,	O
3.88972489786978191927164274724	int
,	O
0.605763879171060113080537108602	int
,	O
1.22005503659074842622205526637	int
,	O
1.85310765160151214200350644316	int
,	O
2.51973568567823788343040913628	int
,	O
3.24660897837240998812205115236	int
,	O
4.10133759617863964117891508007	int
,	O
0.291745510672562078446113075799	int
,	O
0.878713787329399416114679311861	int
,	O
1.47668273114114087058350654421	int
,	O
2.09518325850771681573497272630	int
,	O
2.74847072498540256862499852415	int
,	O
3.46265693360227055020891736115	int
,	O
4.30444857047363181262129810037	int
,	O
0.565069583255575748526020337198	int
,	O
1.13611558521092066631913490556	int
,	O
1.71999257518648893241583152515	int
,	O
2.32573248617385774545404479449	int
,	O
2.96716692790560324848896036355	int
,	O
3.66995037340445253472922383312	int
,	O
4.49999070730939155366438053053	int
,	O
0.273481046138152452158280401965	int
,	O
0.822951449144655892582454496734	int
,	O
1.38025853919888079637208966969	int
,	O
1.95178799091625397743465541496	int
,	O
2.54620215784748136215932870545	int
,	O
3.17699916197995602681399455926	int
,	O
3.86944790486012269871942409801	int
,	O
4.68873893930581836468849864875	int
,	O
0.531633001342654731349086553718	int
,	O
1.06764872574345055363045773799	int
,	O
1.61292431422123133311288254454	int
,	O
2.17350282666662081927537907149	int
,	O
2.75776291570388873092640349574	int
,	O
3.37893209114149408338327069289	int
,	O
4.06194667587547430689245559698	int
,	O
4.87134519367440308834927655662	int
,	O
0.258267750519096759258116098711	int
,	O
0.776682919267411661316659462284	int
,	O
1.30092085838961736566626555439	int
,	O
1.83553160426162889225383944409	int
,	O
2.38629908916668600026459301424	int
,	O
2.96137750553160684477863254906	int
,	O
3.57376906848626607950067599377	int
,	O
4.24811787356812646302342016090	int
,	O
5.04836400887446676837203757885	int
,	O
0.503520163423888209373811765050	int
,	O
1.01036838713431135136859873726	int
,	O
1.52417061939353303183354859367	int
,	O
2.04923170985061937575050838669	int
,	O
2.59113378979454256492128084112	int
,	O
3.15784881834760228184318034120	int
,	O
3.76218735196402009751489394104	int
,	O
4.42853280660377943723498532226	int
,	O
5.22027169053748216460967142500	int
,	O
0.245340708300901249903836530634	int
,	O
0.737473728545394358705605144252	int
,	O
1.23407621539532300788581834696	int
,	O
1.73853771211658620678086566214	int
,	O
2.25497400208927552308233334473	int
,	O
2.78880605842813048052503375640	int
,	O
3.34785456738321632691492452300	int
,	O
3.94476404011562521037562880052	int
,	O
4.60368244955074427307767524898	int
,	O
5.38748089001123286201690041068	int
}	O
;	O
int	O
gsl_sf_hermite_zero_e	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<=	O
0	int
||	O
s	int
<	O
0	int
||	O
s	int
>	O
n	int
/	O
2	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
s	int
==	O
0	int
)	O
{	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
==	O
1	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
n	int
==	O
2	int
)	O
{	O
result	pointer
->	O
val	double
=	O
M_SQRT1_2	int
;	O
result	pointer
->	O
err	double
=	O
0.	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
n	int
<	O
21	int
)	O
{	O
result	pointer
->	O
val	double
=	O
H_zero_tab	array
[	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
?	O
n	int
/	O
2	int
:	O
0	int
)	O
+	O
(	O
(	O
n	int
/	O
2	int
)	O
*	O
(	O
n	int
/	O
2	int
-	O
1	int
)	O
)	O
+	O
s	int
-	O
2	int
]	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
d	double
=	O
1.	int
,	O
x	double
=	O
1.	int
,	O
x0	double
=	O
1.	int
;	O
int	O
j	int
;	O
x	double
=	O
H_zero_init	function
(	O
n	int
,	O
s	int
)	O
;	O
do	O
{	O
x0	double
=	O
x	double
;	O
d	double
=	O
0.	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
n	int
;	O
j	int
++	O
)	O
d	double
=	O
2	int
*	O
j	int
/	O
(	O
2.	int
*	O
x	double
-	O
d	double
)	O
;	O
x	double
-=	O
(	O
2	int
*	O
x	double
-	O
d	double
)	O
*	O
0.5	int
/	O
n	int
;	O
}	O
while	O
(	O
gsl_fcmp	function
(	O
x	double
,	O
x0	double
,	O
10	int
*	O
GSL_DBL_EPSILON	int
)	O
!=	O
0	int
)	O
;	O
result	pointer
->	O
val	double
=	O
x	double
;	O
result	pointer
->	O
err	double
=	O
2	int
*	O
GSL_DBL_EPSILON	int
*	O
x	double
+	O
fabs	function
(	O
x	double
-	O
x0	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_hermite_zero	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_zero_e	function
(	O
n	int
,	O
s	int
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_func_zero_e	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
return	O
gsl_sf_hermite_zero_e	function
(	O
n	int
,	O
s	int
,	O
result	pointer
)	O
;	O
}	O
double	O
gsl_sf_hermite_func_zero	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_func_zero_e	function
(	O
n	int
,	O
s	int
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
return	O
gsl_sf_hermite_e	function
(	O
n	int
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
double	O
gsl_sf_hermite_phys	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_phys_e	function
(	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_der_e	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
return	O
gsl_sf_hermite_deriv_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
double	O
gsl_sf_hermite_phys_der	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_phys_der_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_array	function
(	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
return	O
gsl_sf_hermite_array	function
(	O
nmax	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_series_e	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
return	O
gsl_sf_hermite_series_e	function
(	O
n	int
,	O
x	double
,	O
a	double
,	O
result	pointer
)	O
;	O
}	O
double	O
gsl_sf_hermite_phys_series	function
(	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
const	O
double	O
*	O
a	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_phys_series_e	function
(	O
n	int
,	O
x	double
,	O
a	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_array_der	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
return	O
gsl_sf_hermite_array_deriv	function
(	O
m	int
,	O
nmax	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_der_array	function
(	O
const	O
int	O
mmax	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
return	O
gsl_sf_hermite_deriv_array	function
(	O
mmax	int
,	O
n	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
}	O
int	O
gsl_sf_hermite_phys_zero_e	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
return	O
gsl_sf_hermite_zero_e	function
(	O
n	int
,	O
s	int
,	O
result	pointer
)	O
;	O
}	O
double	O
gsl_sf_hermite_phys_zero	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
s	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_zero_e	function
(	O
n	int
,	O
s	int
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_hermite_prob_array_der	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
nmax	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
return	O
gsl_sf_hermite_prob_array_deriv	function
(	O
m	int
,	O
nmax	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
}	O
int	O
gsl_sf_hermite_prob_der_array	function
(	O
const	O
int	O
mmax	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
return	O
gsl_sf_hermite_prob_deriv_array	function
(	O
mmax	int
,	O
n	int
,	O
x	double
,	O
result_array	pointer
)	O
;	O
}	O
int	O
gsl_sf_hermite_prob_der_e	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
return	O
gsl_sf_hermite_prob_deriv_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
double	O
gsl_sf_hermite_prob_der	function
(	O
const	O
int	O
m	int
,	O
const	O
int	O
n	int
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hermite_prob_deriv_e	function
(	O
m	int
,	O
n	int
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
