extern	O
dataobs	struct
dap_obs	array
[	O
]	O
;	O
extern	O
int	O
dap_ono	int
;	O
extern	O
FILE	struct
*	O
dap_lst	pointer
;	O
extern	O
FILE	struct
*	O
dap_err	pointer
;	O
extern	O
char	O
*	O
dap_dapname	pointer
;	O
static	O
double	O
*	O
allparam	pointer
;	O
static	O
char	O
*	O
sel	pointer
;	O
static	O
char	O
*	O
selred	pointer
;	O
static	O
double	O
(	O
*	O
ex	pointer
)	O
(	O
)	O
;	O
static	O
double	O
*	O
*	O
tab	pointer
;	O
static	O
int	O
nc	int
;	O
static	O
double	O
loglike	function
(	O
double	O
*	O
selparam	pointer
)	O
{	O
int	O
s	int
;	O
int	O
p	double
;	O
double	O
expected	double
;	O
double	O
ll	double
;	O
int	O
c	int
;	O
for	O
(	O
s	int
=	O
0	int
,	O
p	double
=	O
0	int
;	O
sel	pointer
[	O
s	int
]	O
;	O
s	int
++	O
)	O
{	O
if	O
(	O
sel	pointer
[	O
s	int
]	O
!=	O
'!'	O
)	O
allparam	pointer
[	O
s	int
]	O
=	O
selparam	pointer
[	O
p	double
++	O
]	O
;	O
else	O
allparam	pointer
[	O
s	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
ll	double
=	O
0.0	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nc	int
;	O
c	int
++	O
)	O
{	O
expected	double
=	O
ex	pointer
(	O
allparam	pointer
,	O
tab	pointer
[	O
c	int
]	O
+	O
1	int
)	O
;	O
ll	double
+=	O
tab	pointer
[	O
c	int
]	O
[	O
0	int
]	O
*	O
log	function
(	O
expected	double
)	O
-	O
expected	double
;	O
}	O
return	O
ll	double
;	O
}	O
static	O
int	O
selparse	function
(	O
char	O
*	O
names	pointer
,	O
char	O
*	O
codes	pointer
)	O
{	O
int	O
n	int
;	O
int	O
c	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
names	pointer
[	O
n	int
]	O
==	O
' '	O
;	O
n	int
++	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
names	pointer
[	O
n	int
]	O
;	O
c	int
++	O
)	O
{	O
if	O
(	O
names	pointer
[	O
n	int
]	O
==	O
'!'	O
||	O
names	pointer
[	O
n	int
]	O
==	O
'?'	O
)	O
{	O
codes	pointer
[	O
c	int
]	O
=	O
names	pointer
[	O
n	int
]	O
;	O
for	O
(	O
++	O
n	int
;	O
names	pointer
[	O
n	int
]	O
==	O
' '	O
;	O
n	int
++	O
)	O
;	O
}	O
else	O
codes	pointer
[	O
c	int
]	O
=	O
'1'	O
;	O
while	O
(	O
names	pointer
[	O
n	int
]	O
&&	O
names	pointer
[	O
n	int
]	O
!=	O
' '	O
)	O
n	int
++	O
;	O
while	O
(	O
names	pointer
[	O
n	int
]	O
==	O
' '	O
)	O
n	int
++	O
;	O
}	O
codes	pointer
[	O
c	int
]	O
=	O
'\0'	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
categ1	function
(	O
double	O
*	O
*	O
tab	pointer
,	O
int	O
ncell	int
,	O
int	O
*	O
varv	array
,	O
int	O
nvar	int
,	O
double	O
(	O
*	O
expect	pointer
)	O
(	O
)	O
,	O
double	O
*	O
param	pointer
,	O
char	O
*	O
select	function
,	O
char	O
*	O
selcodes	pointer
,	O
int	O
param1n	int
,	O
int	O
param2n	int
,	O
int	O
covn	int
,	O
int	O
partv	array
[	O
]	O
,	O
int	O
partv2	array
[	O
]	O
,	O
int	O
npart	int
,	O
char	O
*	O
trace	pointer
)	O
{	O
int	O
typen	int
;	O
int	O
sparam	int
;	O
int	O
sparamr	int
;	O
int	O
nparam	int
;	O
int	O
c	int
,	O
c1	int
,	O
c0	int
;	O
double	O
*	O
x	array
;	O
double	O
*	O
xch	pointer
;	O
int	O
p	double
;	O
double	O
step	function
,	O
tol	double
;	O
double	O
tmp	double
;	O
int	O
v	int
;	O
double	O
likerat	double
;	O
double	O
likered	double
;	O
double	O
pearson	double
;	O
double	O
*	O
infomem	pointer
;	O
double	O
*	O
*	O
info	pointer
;	O
int	O
p1	int
,	O
p2	int
;	O
double	O
lpp	double
,	O
lpm	double
,	O
lmp	double
,	O
lmm	double
;	O
double	O
h	double
,	O
halfh	double
;	O
int	O
s	int
,	O
s1	int
;	O
int	O
nonsing	int
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fputs	function
(	O
"(categ1) missing _type_ variable\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
sparamr	int
=	O
0	int
;	O
likered	double
=	O
0.0	int
;	O
nc	int
=	O
ncell	int
;	O
ex	pointer
=	O
expect	pointer
;	O
x	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
strlen	function
(	O
sel	pointer
)	O
,	O
""	pointer
)	O
;	O
xch	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
strlen	function
(	O
sel	pointer
)	O
,	O
""	pointer
)	O
;	O
if	O
(	O
selred	pointer
)	O
{	O
sel	pointer
=	O
selred	pointer
;	O
for	O
(	O
nparam	int
=	O
0	int
,	O
sparamr	int
=	O
0	int
;	O
sel	pointer
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	pointer
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
{	O
allparam	pointer
[	O
nparam	int
]	O
=	O
param	pointer
[	O
nparam	int
]	O
;	O
sparamr	int
++	O
;	O
}	O
else	O
allparam	pointer
[	O
nparam	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
p	double
=	O
0	int
,	O
nparam	int
=	O
0	int
;	O
sel	pointer
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	pointer
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
x	array
[	O
p	double
++	O
]	O
=	O
param	pointer
[	O
nparam	int
]	O
;	O
}	O
for	O
(	O
step	function
=	O
0.0	int
,	O
p	double
=	O
0	int
;	O
p	double
<	O
sparamr	int
;	O
p	double
++	O
)	O
{	O
tmp	double
=	O
x	array
[	O
p	double
]	O
;	O
step	function
+=	O
tmp	double
*	O
tmp	double
;	O
}	O
if	O
(	O
step	function
>	O
0.0	int
)	O
step	function
=	O
0.1	int
*	O
sqrt	function
(	O
step	function
)	O
;	O
else	O
step	function
=	O
0.01	int
;	O
tol	double
=	O
dap_cattol	double
*	O
step	function
;	O
dap_maximize	function
(	O
&	O
loglike	function
,	O
sparamr	int
,	O
x	array
,	O
step	function
,	O
tol	double
,	O
trace	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
likerat	double
=	O
0.0	int
;	O
c	int
<	O
ncell	int
;	O
c	int
++	O
)	O
likered	double
+=	O
(	O
tab	pointer
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
*	O
log	function
(	O
(	O
tab	pointer
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
/	O
expect	pointer
(	O
allparam	pointer
,	O
tab	pointer
[	O
c	int
]	O
+	O
1	int
)	O
)	O
;	O
likered	double
*=	O
2.0	int
;	O
}	O
sel	pointer
=	O
selcodes	pointer
;	O
for	O
(	O
nparam	int
=	O
0	int
,	O
sparam	int
=	O
0	int
;	O
sel	pointer
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	pointer
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
{	O
allparam	pointer
[	O
nparam	int
]	O
=	O
param	pointer
[	O
nparam	int
]	O
;	O
sparam	int
++	O
;	O
}	O
else	O
allparam	pointer
[	O
nparam	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
p	double
=	O
0	int
,	O
nparam	int
=	O
0	int
;	O
sel	pointer
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	pointer
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
x	array
[	O
p	double
++	O
]	O
=	O
param	pointer
[	O
nparam	int
]	O
;	O
}	O
for	O
(	O
step	function
=	O
0.0	int
,	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
{	O
tmp	double
=	O
x	array
[	O
p	double
]	O
;	O
step	function
+=	O
tmp	double
*	O
tmp	double
;	O
}	O
if	O
(	O
step	function
>	O
0.0	int
)	O
step	function
=	O
0.1	int
*	O
sqrt	function
(	O
step	function
)	O
;	O
else	O
step	function
=	O
0.01	int
;	O
tol	double
=	O
dap_cattol	double
*	O
step	function
;	O
dap_maximize	function
(	O
&	O
loglike	function
,	O
sparam	int
,	O
x	array
,	O
step	function
,	O
tol	double
,	O
trace	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
likerat	double
=	O
0.0	int
,	O
pearson	double
=	O
0.0	int
;	O
c	int
<	O
ncell	int
;	O
c	int
++	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
tab	pointer
[	O
c	int
]	O
[	O
v	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"OBS"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"FIT"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
=	O
expect	pointer
(	O
allparam	pointer
,	O
tab	pointer
[	O
c	int
]	O
+	O
1	int
)	O
;	O
likerat	double
+=	O
(	O
tab	pointer
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
*	O
log	function
(	O
(	O
tab	pointer
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
/	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
tmp	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
-	O
tab	pointer
[	O
c	int
]	O
[	O
0	int
]	O
;	O
pearson	double
+=	O
tmp	double
*	O
tmp	double
/	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
;	O
output	function
(	O
)	O
;	O
}	O
likerat	double
*=	O
2.0	int
;	O
infomem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
sparam	int
*	O
sparam	int
,	O
""	pointer
)	O
;	O
info	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
sparam	int
,	O
""	pointer
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
info	pointer
[	O
p	double
]	O
=	O
infomem	pointer
+	O
p	double
*	O
sparam	int
;	O
h	double
=	O
0.0001	int
;	O
halfh	double
=	O
h	double
/	O
2.0	int
;	O
for	O
(	O
p1	int
=	O
0	int
;	O
p1	int
<	O
sparam	int
;	O
p1	int
++	O
)	O
{	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
xch	pointer
[	O
p	double
]	O
=	O
x	array
[	O
p	double
]	O
;	O
lpm	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
xch	pointer
[	O
p1	int
]	O
+=	O
h	double
;	O
lpp	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
xch	pointer
[	O
p1	int
]	O
=	O
x	array
[	O
p1	int
]	O
-	O
h	double
;	O
lmm	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
info	pointer
[	O
p1	int
]	O
[	O
p1	int
]	O
=	O
-	O
(	O
lpp	double
-	O
2.0	int
*	O
lpm	double
+	O
lmm	double
)	O
/	O
(	O
h	double
*	O
h	double
)	O
;	O
}	O
for	O
(	O
p1	int
=	O
0	int
;	O
p1	int
<	O
sparam	int
;	O
p1	int
++	O
)	O
for	O
(	O
p2	int
=	O
0	int
;	O
p2	int
<	O
p1	int
;	O
p2	int
++	O
)	O
{	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
xch	pointer
[	O
p	double
]	O
=	O
x	array
[	O
p	double
]	O
;	O
xch	pointer
[	O
p1	int
]	O
+=	O
halfh	double
;	O
xch	pointer
[	O
p2	int
]	O
+=	O
halfh	double
;	O
lpp	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
xch	pointer
[	O
p1	int
]	O
=	O
x	array
[	O
p1	int
]	O
-	O
halfh	double
;	O
lmp	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
xch	pointer
[	O
p2	int
]	O
=	O
x	array
[	O
p2	int
]	O
-	O
halfh	double
;	O
lmm	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
xch	pointer
[	O
p1	int
]	O
=	O
x	array
[	O
p1	int
]	O
+	O
halfh	double
;	O
lpm	double
=	O
loglike	function
(	O
xch	pointer
)	O
;	O
info	pointer
[	O
p1	int
]	O
[	O
p2	int
]	O
=	O
-	O
(	O
lpp	double
-	O
lpm	double
-	O
lmp	double
+	O
lmm	double
)	O
/	O
(	O
h	double
*	O
h	double
)	O
;	O
info	pointer
[	O
p2	int
]	O
[	O
p1	int
]	O
=	O
info	pointer
[	O
p1	int
]	O
[	O
p2	int
]	O
;	O
}	O
if	O
(	O
!	O
(	O
nonsing	int
=	O
dap_invert	function
(	O
info	pointer
,	O
sparam	int
)	O
)	O
)	O
fputs	function
(	O
"(categ1) covariance matrix is singular\n"	pointer
,	O
dap_err	pointer
)	O
;	O
dap_ono	int
=	O
1	int
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(categ1) output dataset has no _type_ variable\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
npart	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
partv2	array
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
partv2	array
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
;	O
else	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
partv2	array
[	O
v	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
)	O
;	O
}	O
fputs	function
(	O
"Maximum likelihood estimation\n\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Cell count: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
0	int
]	O
]	O
)	O
;	O
fputs	function
(	O
"Class and aux variables:"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
v	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fputs	function
(	O
"\nStatistic              df      Prob\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"G2[Model]   = %6.2f  %3d    %.4f\n"	pointer
,	O
likerat	double
,	O
ncell	int
-	O
sparam	int
,	O
(	O
(	O
ncell	int
>	O
sparam	int
)	O
?	O
(	O
ceil	function
(	O
10000.0	int
*	O
probchisq	function
(	O
likerat	double
,	O
ncell	int
-	O
sparam	int
)	O
)	O
/	O
10000.0	int
)	O
:	O
1.0	int
)	O
)	O
;	O
if	O
(	O
selred	pointer
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"G2[Reduced] = %6.2f  %3d    %.4f\n"	pointer
,	O
likered	double
,	O
ncell	int
-	O
sparamr	int
,	O
ceil	function
(	O
10000.0	int
*	O
probchisq	function
(	O
likered	double
,	O
ncell	int
-	O
sparamr	int
)	O
)	O
/	O
10000.0	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"G2[Diff]    = %6.2f  %3d    %.4f\n"	pointer
,	O
likered	double
-	O
likerat	double
,	O
sparam	int
-	O
sparamr	int
,	O
ceil	function
(	O
10000.0	int
*	O
probchisq	function
(	O
likered	double
-	O
likerat	double
,	O
sparam	int
-	O
sparamr	int
)	O
)	O
/	O
10000.0	int
)	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"X2[Model]   = %6.2f  %3d    %.4f\n"	pointer
,	O
pearson	double
,	O
ncell	int
-	O
sparam	int
,	O
(	O
(	O
ncell	int
>	O
sparam	int
)	O
?	O
(	O
ceil	function
(	O
10000.0	int
*	O
probchisq	function
(	O
pearson	double
,	O
ncell	int
-	O
sparam	int
)	O
)	O
/	O
10000.0	int
)	O
:	O
1.0	int
)	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fputs	function
(	O
"    Estimate          ASE  Model  Parameter\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
select	function
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
for	O
(	O
p	double
=	O
0	int
,	O
s	int
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%12g "	pointer
,	O
allparam	pointer
[	O
p	double
]	O
)	O
;	O
if	O
(	O
sel	pointer
[	O
p	double
]	O
==	O
'!'	O
)	O
fputs	function
(	O
"              "	pointer
,	O
dap_lst	pointer
)	O
;	O
else	O
{	O
if	O
(	O
nonsing	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%12g  "	pointer
,	O
sqrt	function
(	O
info	pointer
[	O
s	int
]	O
[	O
s	int
]	O
)	O
)	O
;	O
else	O
fputs	function
(	O
"           ?  "	pointer
,	O
dap_lst	pointer
)	O
;	O
}	O
switch	O
(	O
selcodes	pointer
[	O
p	double
]	O
)	O
{	O
case	O
'1'	O
:	O
fprintf	function
(	O
dap_lst	pointer
,	O
"  *    "	pointer
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
fprintf	function
(	O
dap_lst	pointer
,	O
"  ?    "	pointer
)	O
;	O
for	O
(	O
++	O
c	int
;	O
select	function
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
dap_lst	pointer
,	O
"       "	pointer
)	O
;	O
for	O
(	O
++	O
c	int
;	O
select	function
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
p2	int
=	O
0	int
;	O
select	function
[	O
c	int
]	O
&&	O
select	function
[	O
c	int
]	O
!=	O
' '	O
;	O
c	int
++	O
,	O
p2	int
++	O
)	O
{	O
putc	function
(	O
select	function
[	O
c	int
]	O
,	O
dap_lst	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
select	function
[	O
c	int
]	O
;	O
}	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
select	function
[	O
c	int
]	O
==	O
' '	O
)	O
c	int
++	O
;	O
if	O
(	O
sel	pointer
[	O
p	double
]	O
!=	O
'!'	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"ESTIMATE"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
,	O
""	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
=	O
allparam	pointer
[	O
p	double
]	O
;	O
output	function
(	O
)	O
;	O
s	int
++	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"COVAR"	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
select	function
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
for	O
(	O
p	double
=	O
0	int
,	O
s	int
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
if	O
(	O
selcodes	pointer
[	O
p	double
]	O
!=	O
'1'	O
)	O
{	O
for	O
(	O
++	O
c	int
;	O
select	function
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
}	O
while	O
(	O
select	function
[	O
c	int
]	O
==	O
' '	O
)	O
c	int
++	O
;	O
for	O
(	O
c1	int
=	O
0	int
;	O
select	function
[	O
c1	int
]	O
==	O
' '	O
;	O
c1	int
++	O
)	O
;	O
for	O
(	O
p1	int
=	O
0	int
,	O
s1	int
=	O
0	int
;	O
p1	int
<	O
nparam	int
;	O
p1	int
++	O
)	O
{	O
if	O
(	O
sel	pointer
[	O
p	double
]	O
!=	O
'!'	O
&&	O
sel	pointer
[	O
p1	int
]	O
!=	O
'!'	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
=	O
info	pointer
[	O
s	int
]	O
[	O
s1	int
]	O
;	O
if	O
(	O
sel	pointer
[	O
p1	int
]	O
!=	O
'!'	O
)	O
s1	int
++	O
;	O
if	O
(	O
selcodes	pointer
[	O
p1	int
]	O
!=	O
'1'	O
)	O
{	O
for	O
(	O
++	O
c1	int
;	O
select	function
[	O
c1	int
]	O
==	O
' '	O
;	O
c1	int
++	O
)	O
;	O
}	O
if	O
(	O
sel	pointer
[	O
p	double
]	O
!=	O
'!'	O
&&	O
sel	pointer
[	O
p1	int
]	O
!=	O
'!'	O
)	O
{	O
for	O
(	O
p2	int
=	O
0	int
;	O
select	function
[	O
c1	int
]	O
&&	O
select	function
[	O
c1	int
]	O
!=	O
' '	O
;	O
c1	int
++	O
,	O
p2	int
++	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
select	function
[	O
c1	int
]	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
'\0'	O
;	O
c0	int
=	O
c	int
;	O
if	O
(	O
select	function
[	O
c0	int
]	O
==	O
'?'	O
)	O
{	O
for	O
(	O
c0	int
++	O
;	O
select	function
[	O
c0	int
]	O
==	O
' '	O
;	O
c0	int
++	O
)	O
;	O
}	O
for	O
(	O
p2	int
=	O
0	int
;	O
select	function
[	O
c0	int
]	O
&&	O
select	function
[	O
c0	int
]	O
!=	O
' '	O
;	O
c0	int
++	O
,	O
p2	int
++	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
[	O
p2	int
]	O
=	O
select	function
[	O
c0	int
]	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
[	O
p2	int
]	O
=	O
'\0'	O
;	O
output	function
(	O
)	O
;	O
}	O
while	O
(	O
select	function
[	O
c1	int
]	O
==	O
' '	O
)	O
c1	int
++	O
;	O
}	O
while	O
(	O
select	function
[	O
c	int
]	O
&&	O
select	function
[	O
c	int
]	O
!=	O
' '	O
)	O
c	int
++	O
;	O
if	O
(	O
sel	pointer
[	O
p	double
]	O
!=	O
'!'	O
)	O
s	int
++	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
dap_free	function
(	O
x	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
xch	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
infomem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
info	pointer
,	O
""	pointer
)	O
;	O
}	O
void	O
categ	function
(	O
char	O
*	O
dname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
auxvarlist	pointer
,	O
double	O
(	O
*	O
expect	pointer
)	O
(	O
)	O
,	O
double	O
*	O
param	pointer
,	O
char	O
*	O
select	function
,	O
char	O
*	O
part	pointer
,	O
char	O
*	O
trace	pointer
)	O
{	O
int	O
p	double
;	O
char	O
*	O
filset	pointer
;	O
char	O
*	O
filarg	pointer
;	O
char	O
*	O
catset	pointer
;	O
char	O
*	O
covset	pointer
;	O
int	O
param1n	int
,	O
param2n	int
,	O
covn	int
;	O
int	O
paramlen1	int
,	O
paramlen	int
;	O
char	O
paramstr	array
[	O
12	int
]	O
;	O
char	O
*	O
partstr	pointer
;	O
int	O
*	O
varv	array
;	O
int	O
*	O
partv	array
,	O
*	O
partv2	array
;	O
int	O
ncvar	int
;	O
int	O
navar	int
;	O
int	O
nvar	int
;	O
int	O
npart	int
;	O
int	O
more	int
;	O
int	O
nparam	int
;	O
char	O
*	O
selcodes	pointer
;	O
double	O
*	O
tabmem	pointer
;	O
int	O
v	int
;	O
int	O
ncell	int
;	O
int	O
s	int
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
partv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
partv2	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
filarg	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
strlen	function
(	O
part	pointer
)	O
+	O
8	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
filarg	pointer
,	O
"FILL "	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varlist	array
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
v	int
=	O
5	int
;	O
varlist	array
[	O
s	int
]	O
&&	O
varlist	array
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
filarg	pointer
[	O
v	int
++	O
]	O
=	O
varlist	array
[	O
s	int
++	O
]	O
;	O
filarg	pointer
[	O
v	int
++	O
]	O
=	O
':'	O
;	O
strcpy	function
(	O
filarg	pointer
+	O
v	int
,	O
part	pointer
)	O
;	O
strcat	function
(	O
filarg	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
filarg	pointer
,	O
varlist	array
+	O
s	int
)	O
;	O
filset	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
dname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
filset	pointer
,	O
dname	array
)	O
;	O
strcat	function
(	O
filset	pointer
,	O
".fil"	pointer
)	O
;	O
dataset	function
(	O
dname	array
,	O
filset	pointer
,	O
filarg	pointer
)	O
;	O
catset	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
dname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
catset	pointer
,	O
dname	array
)	O
;	O
strcat	function
(	O
catset	pointer
,	O
".cat"	pointer
)	O
;	O
covset	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
dname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
covset	pointer
,	O
dname	array
)	O
;	O
strcat	function
(	O
covset	pointer
,	O
".cov"	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
,	O
paramlen	int
=	O
0	int
;	O
select	function
[	O
s	int
]	O
;	O
)	O
{	O
while	O
(	O
select	function
[	O
s	int
]	O
==	O
' '	O
||	O
select	function
[	O
s	int
]	O
==	O
'?'	O
||	O
select	function
[	O
s	int
]	O
==	O
'!'	O
)	O
s	int
++	O
;	O
for	O
(	O
paramlen1	int
=	O
0	int
;	O
select	function
[	O
s	int
]	O
&&	O
select	function
[	O
s	int
]	O
!=	O
' '	O
;	O
s	int
++	O
)	O
paramlen1	int
++	O
;	O
if	O
(	O
paramlen1	int
>	O
paramlen	int
)	O
paramlen	int
=	O
paramlen1	int
;	O
}	O
dap_ono	int
=	O
0	int
;	O
inset	function
(	O
filset	pointer
)	O
;	O
ncvar	int
=	O
dap_list	function
(	O
varlist	array
,	O
varv	array
,	O
dap_maxvar	int
)	O
;	O
navar	int
=	O
dap_list	function
(	O
auxvarlist	pointer
,	O
varv	array
+	O
ncvar	int
,	O
dap_maxvar	int
-	O
ncvar	int
)	O
;	O
nvar	int
=	O
ncvar	int
+	O
navar	int
;	O
for	O
(	O
v	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(categ) classification or auxiliary variable not of type double: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
npart	int
=	O
dap_list	function
(	O
part	pointer
,	O
partv	array
,	O
dap_maxvar	int
)	O
;	O
dap_ono	int
=	O
1	int
;	O
dap_clearobs	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_param1_ %d"	pointer
,	O
paramlen	int
)	O
;	O
param1n	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
sprintf	function
(	O
paramstr	array
,	O
"_param2_ %d"	pointer
,	O
paramlen	int
)	O
;	O
param2n	int
=	O
dap_vd	function
(	O
paramstr	array
,	O
0	int
)	O
;	O
covn	int
=	O
dap_vd	function
(	O
"_cov_ -1"	pointer
,	O
0	int
)	O
;	O
partstr	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
part	pointer
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
npart	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
partstr	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
)	O
;	O
sprintf	function
(	O
partstr	pointer
+	O
strlen	function
(	O
partstr	pointer
)	O
,	O
" %d"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
partv	array
[	O
v	int
]	O
]	O
)	O
;	O
partv2	array
[	O
v	int
]	O
=	O
dap_vd	function
(	O
partstr	pointer
,	O
1	int
)	O
;	O
}	O
outset	function
(	O
covset	pointer
,	O
""	pointer
)	O
;	O
dap_ono	int
=	O
0	int
;	O
outset	function
(	O
catset	pointer
,	O
""	pointer
)	O
;	O
tabmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
dap_maxcell	int
,	O
""	pointer
)	O
;	O
tab	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxcell	int
,	O
""	pointer
)	O
;	O
for	O
(	O
ncell	int
=	O
0	int
;	O
ncell	int
<	O
dap_maxcell	int
;	O
ncell	int
++	O
)	O
tab	pointer
[	O
ncell	int
]	O
=	O
tabmem	pointer
+	O
ncell	int
*	O
nvar	int
;	O
selcodes	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
select	function
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
nparam	int
=	O
selparse	function
(	O
select	function
,	O
selcodes	pointer
)	O
;	O
allparam	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
,	O
""	pointer
)	O
;	O
sel	pointer
=	O
selcodes	pointer
;	O
if	O
(	O
index	function
(	O
selcodes	pointer
,	O
'?'	O
)	O
)	O
{	O
selred	pointer
=	O
dap_malloc	function
(	O
nparam	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
selcodes	pointer
[	O
s	int
]	O
;	O
s	int
++	O
)	O
{	O
if	O
(	O
selcodes	pointer
[	O
s	int
]	O
==	O
'?'	O
)	O
selred	pointer
[	O
s	int
]	O
=	O
'!'	O
;	O
else	O
selred	pointer
[	O
s	int
]	O
=	O
selcodes	pointer
[	O
s	int
]	O
;	O
}	O
selred	pointer
[	O
s	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
selred	pointer
=	O
NULL	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
allparam	pointer
[	O
p	double
]	O
=	O
param	pointer
[	O
p	double
]	O
;	O
for	O
(	O
ncell	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
partv	array
,	O
npart	int
)	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
partv	array
,	O
npart	int
)	O
;	O
categ1	function
(	O
tab	pointer
,	O
ncell	int
,	O
varv	array
,	O
nvar	int
,	O
expect	pointer
,	O
param	pointer
,	O
select	function
,	O
selcodes	pointer
,	O
param1n	int
,	O
param2n	int
,	O
covn	int
,	O
partv	array
,	O
partv2	array
,	O
npart	int
,	O
trace	pointer
)	O
;	O
dap_swap	function
(	O
)	O
;	O
ncell	int
=	O
0	int
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
allparam	pointer
[	O
p	double
]	O
=	O
param	pointer
[	O
p	double
]	O
;	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
ncell	int
<	O
dap_maxcell	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
tab	pointer
[	O
ncell	int
]	O
[	O
v	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
ncell	int
++	O
;	O
}	O
else	O
{	O
fputs	function
(	O
"(categ) too many cells\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
selred	pointer
)	O
{	O
dap_free	function
(	O
selred	pointer
,	O
""	pointer
)	O
;	O
selred	pointer
=	O
NULL	O
;	O
}	O
dap_free	function
(	O
filarg	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partv2	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
filset	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
catset	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
covset	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partstr	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
tabmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
tab	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
allparam	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
selcodes	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
*	O
*	O
paramlist	pointer
;	O
static	O
double	O
*	O
maxval	pointer
;	O
static	O
int	O
numparam	int
;	O
static	O
int	O
nclass	int
;	O
static	O
double	O
llexpect	function
(	O
double	O
*	O
param	pointer
,	O
double	O
*	O
class	pointer
)	O
{	O
int	O
p	double
;	O
int	O
c	int
;	O
int	O
neg	array
[	O
MAXCLASS	int
]	O
;	O
double	O
sign	double
;	O
int	O
match	int
;	O
double	O
logc	double
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
neg	array
[	O
c	int
]	O
=	O
(	O
class	pointer
[	O
c	int
]	O
==	O
maxval	pointer
[	O
c	int
]	O
)	O
;	O
for	O
(	O
logc	double
=	O
param	pointer
[	O
0	int
]	O
,	O
p	double
=	O
1	int
;	O
p	double
<	O
numparam	int
;	O
p	double
++	O
)	O
{	O
for	O
(	O
sign	double
=	O
1.0	int
,	O
match	int
=	O
1	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
paramlist	pointer
[	O
p	double
]	O
[	O
c	int
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
neg	array
[	O
c	int
]	O
)	O
sign	double
*=	O
-	O
1.0	int
;	O
else	O
match	int
&=	O
(	O
paramlist	pointer
[	O
p	double
]	O
[	O
c	int
]	O
==	O
(	O
int	O
)	O
class	pointer
[	O
c	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
match	int
)	O
logc	double
+=	O
sign	double
*	O
param	pointer
[	O
p	double
]	O
;	O
}	O
return	O
exp	function
(	O
logc	double
)	O
;	O
}	O
static	O
int	O
findclass	function
(	O
char	O
*	O
cname	pointer
,	O
char	O
*	O
*	O
class	pointer
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
cname	pointer
,	O
class	pointer
[	O
c	int
]	O
)	O
)	O
return	O
c	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
llparse	function
(	O
char	O
*	O
*	O
class	pointer
,	O
int	O
nterm	int
,	O
unsigned	O
int	O
*	O
pattern	pointer
,	O
char	O
*	O
model0	pointer
,	O
char	O
*	O
model1	pointer
,	O
int	O
*	O
term	pointer
)	O
{	O
int	O
classlen1	int
;	O
int	O
classlen	int
;	O
int	O
nt	int
;	O
int	O
c	int
;	O
int	O
l	int
;	O
int	O
cm	int
;	O
char	O
*	O
oneclass	pointer
;	O
int	O
oneterm	int
;	O
int	O
m	int
;	O
int	O
t	int
,	O
t1	double
;	O
int	O
firstclass	int
;	O
for	O
(	O
c	int
=	O
0	int
,	O
classlen	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
(	O
classlen1	int
=	O
strlen	function
(	O
class	pointer
[	O
c	int
]	O
)	O
)	O
>	O
classlen	int
)	O
classlen	int
=	O
classlen1	int
;	O
}	O
oneclass	pointer
=	O
dap_malloc	function
(	O
classlen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
nterm	int
;	O
t	int
++	O
)	O
term	pointer
[	O
t	int
]	O
=	O
0	int
;	O
nterm	int
=	O
0	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
model1	pointer
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
for	O
(	O
oneterm	int
=	O
0	int
;	O
model1	pointer
[	O
m	int
]	O
;	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
model1	pointer
[	O
m	int
]	O
&&	O
model1	pointer
[	O
m	int
]	O
!=	O
'*'	O
&&	O
model1	pointer
[	O
m	int
]	O
!=	O
' '	O
;	O
m	int
++	O
)	O
oneclass	pointer
[	O
c	int
++	O
]	O
=	O
model1	pointer
[	O
m	int
]	O
;	O
oneclass	pointer
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
model1	pointer
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
c	int
=	O
findclass	function
(	O
oneclass	pointer
,	O
class	pointer
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(llparse) Unknown class variable %s in model %s\n"	pointer
,	O
oneclass	pointer
,	O
model1	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
oneterm	int
|=	O
pattern	pointer
[	O
c	int
]	O
;	O
if	O
(	O
model1	pointer
[	O
m	int
]	O
!=	O
'*'	O
)	O
{	O
term	pointer
[	O
oneterm	int
]	O
=	O
1	int
;	O
if	O
(	O
oneterm	int
>	O
nterm	int
)	O
nterm	int
=	O
oneterm	int
;	O
oneterm	int
=	O
0	int
;	O
}	O
else	O
m	int
++	O
;	O
while	O
(	O
model1	pointer
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
for	O
(	O
t1	double
=	O
0	int
;	O
t1	double
<=	O
nterm	int
;	O
t1	double
++	O
)	O
{	O
if	O
(	O
term	pointer
[	O
t1	double
]	O
)	O
{	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
nterm	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
t	int
&	O
~	O
t1	double
)	O
)	O
term	pointer
[	O
t	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
m	int
=	O
0	int
;	O
model0	pointer
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
for	O
(	O
oneterm	int
=	O
0	int
;	O
model0	pointer
[	O
m	int
]	O
;	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
model0	pointer
[	O
m	int
]	O
&&	O
model0	pointer
[	O
m	int
]	O
!=	O
'*'	O
&&	O
model0	pointer
[	O
m	int
]	O
!=	O
' '	O
;	O
m	int
++	O
)	O
oneclass	pointer
[	O
c	int
++	O
]	O
=	O
model0	pointer
[	O
m	int
]	O
;	O
oneclass	pointer
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
model0	pointer
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
c	int
=	O
findclass	function
(	O
oneclass	pointer
,	O
class	pointer
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(llparse) Unknown class variable %s in model %s\n"	pointer
,	O
oneclass	pointer
,	O
model0	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
oneterm	int
|=	O
pattern	pointer
[	O
c	int
]	O
;	O
if	O
(	O
model0	pointer
[	O
m	int
]	O
!=	O
'*'	O
)	O
{	O
if	O
(	O
!	O
term	pointer
[	O
oneterm	int
]	O
)	O
{	O
fputs	function
(	O
"(llparse) Term in model0 ("	pointer
,	O
dap_err	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
firstclass	int
=	O
1	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	pointer
[	O
c	int
]	O
&	O
~	O
oneterm	int
)	O
)	O
{	O
if	O
(	O
firstclass	int
)	O
firstclass	int
=	O
0	int
;	O
else	O
fputs	function
(	O
"*"	pointer
,	O
dap_err	pointer
)	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"%s"	pointer
,	O
class	pointer
[	O
c	int
]	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
dap_err	pointer
,	O
") not in in model1 (%s)\n"	pointer
,	O
model1	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
term	pointer
[	O
oneterm	int
]	O
=	O
2	int
;	O
oneterm	int
=	O
0	int
;	O
}	O
else	O
m	int
++	O
;	O
while	O
(	O
model0	pointer
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
for	O
(	O
t1	double
=	O
0	int
;	O
t1	double
<=	O
nterm	int
;	O
t1	double
++	O
)	O
{	O
if	O
(	O
term	pointer
[	O
t1	double
]	O
==	O
2	int
)	O
{	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
nterm	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
t	int
&	O
~	O
t1	double
)	O
)	O
term	pointer
[	O
t	int
]	O
=	O
2	int
;	O
}	O
}	O
}	O
dap_free	function
(	O
oneclass	pointer
,	O
""	pointer
)	O
;	O
return	O
nterm	int
;	O
}	O
typedef	O
struct	O
node	struct
{	O
char	O
*	O
value	pointer
;	O
struct	O
node	struct
*	O
next	pointer
;	O
}	O
valnode	struct
;	O
void	O
loglin	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
model0	pointer
,	O
char	O
*	O
model1	pointer
,	O
char	O
*	O
part	pointer
)	O
{	O
char	O
*	O
fnamefil	pointer
;	O
char	O
*	O
filarg	pointer
;	O
char	O
*	O
fname1	pointer
;	O
char	O
*	O
catname	pointer
;	O
char	O
*	O
varlist1	pointer
;	O
char	O
*	O
outlist	pointer
;	O
char	O
*	O
vardef	pointer
;	O
int	O
nvar	int
;	O
int	O
l	int
,	O
l1	int
;	O
int	O
vd	int
;	O
int	O
*	O
classv	pointer
;	O
int	O
npart	int
;	O
int	O
c	int
,	O
cc	int
;	O
int	O
nv	int
;	O
int	O
coff	int
;	O
double	O
*	O
maxval1	pointer
;	O
int	O
maxmaxval	int
;	O
int	O
nvl	int
;	O
int	O
firstpart	int
;	O
int	O
more	int
;	O
double	O
oneval	double
;	O
int	O
*	O
term	pointer
;	O
int	O
nterm	int
;	O
double	O
*	O
param	pointer
;	O
int	O
termparam	int
;	O
int	O
nparam0	int
;	O
char	O
*	O
classmem	pointer
;	O
char	O
*	O
*	O
class	pointer
;	O
int	O
cm	int
;	O
char	O
*	O
select	function
;	O
int	O
sellen	int
;	O
int	O
termlen	int
;	O
char	O
*	O
selterm	pointer
;	O
int	O
s	int
;	O
int	O
*	O
sub	pointer
;	O
unsigned	O
int	O
*	O
pattern	pointer
;	O
int	O
t	int
;	O
int	O
*	O
paramlistmem	pointer
;	O
int	O
p	double
;	O
valnode	struct
*	O
*	O
classval	pointer
;	O
valnode	struct
*	O
*	O
endcv	pointer
;	O
int	O
*	O
maxlen	pointer
;	O
int	O
onelen	int
;	O
char	O
formstr	array
[	O
8	int
]	O
;	O
valnode	struct
*	O
nodeptr	pointer
;	O
fnamefil	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
fnamefil	pointer
,	O
fname	array
)	O
;	O
strcat	function
(	O
fnamefil	pointer
,	O
".fil"	pointer
)	O
;	O
filarg	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
strlen	function
(	O
part	pointer
)	O
+	O
8	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
filarg	pointer
,	O
"FILL "	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varlist	array
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
l	int
=	O
5	int
;	O
varlist	array
[	O
s	int
]	O
&&	O
varlist	array
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
filarg	pointer
[	O
l	int
++	O
]	O
=	O
varlist	array
[	O
s	int
++	O
]	O
;	O
filarg	pointer
[	O
l	int
++	O
]	O
=	O
':'	O
;	O
strcpy	function
(	O
filarg	pointer
+	O
l	int
,	O
part	pointer
)	O
;	O
strcat	function
(	O
filarg	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
filarg	pointer
,	O
varlist	array
+	O
s	int
)	O
;	O
dataset	function
(	O
fname	array
,	O
fnamefil	pointer
,	O
filarg	pointer
)	O
;	O
fname1	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
fname1	pointer
,	O
fname	array
)	O
;	O
strcat	function
(	O
fname1	pointer
,	O
".llm"	pointer
)	O
;	O
catname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname1	pointer
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
catname	pointer
,	O
fname1	pointer
)	O
;	O
strcat	function
(	O
catname	pointer
,	O
".cat"	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
,	O
nvar	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
;	O
)	O
{	O
while	O
(	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
if	O
(	O
varlist	array
[	O
l	int
]	O
)	O
{	O
nvar	int
++	O
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
&&	O
varlist	array
[	O
l	int
]	O
!=	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
nclass	int
=	O
nvar	int
-	O
1	int
;	O
varlist1	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
nvar	int
+	O
2	int
,	O
""	pointer
)	O
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
nvar	int
+	O
strlen	function
(	O
part	pointer
)	O
+	O
2	int
,	O
""	pointer
)	O
;	O
vardef	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
4	int
,	O
""	pointer
)	O
;	O
classv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
classval	pointer
=	O
(	O
valnode	struct
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
valnode	struct
*	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
endcv	pointer
=	O
(	O
valnode	struct
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
valnode	struct
*	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
maxlen	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fnamefil	pointer
)	O
;	O
npart	int
=	O
dap_list	function
(	O
part	pointer
,	O
classv	pointer
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
&&	O
varlist	array
[	O
l	int
]	O
!=	O
' '	O
;	O
)	O
{	O
varlist1	pointer
[	O
l1	int
]	O
=	O
varlist	array
[	O
l	int
]	O
;	O
outlist	pointer
[	O
l1	int
++	O
]	O
=	O
varlist	array
[	O
l	int
++	O
]	O
;	O
}	O
coff	int
=	O
l	int
;	O
dap_list	function
(	O
varlist	array
+	O
coff	int
,	O
classv	pointer
+	O
npart	int
,	O
dap_maxvar	int
-	O
npart	int
)	O
;	O
if	O
(	O
nclass	int
>	O
MAXCLASS	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Number of classification variables (%d) exceeds %d.\n"	pointer
,	O
nclass	int
,	O
MAXCLASS	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
varlist1	pointer
[	O
l1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
c	int
=	O
dap_varnum	function
(	O
varlist1	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Count variable %s unknown.\n"	pointer
,	O
varlist1	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
c	int
]	O
>=	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Count variable %s not of type double.\n"	pointer
,	O
varlist1	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
npart	int
+	O
c	int
]	O
]	O
<=	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Classification variable %s not a string.\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
classv	pointer
[	O
npart	int
+	O
c	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
classmem	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
+	O
coff	int
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
class	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
cm	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
;	O
)	O
{	O
while	O
(	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
if	O
(	O
varlist	array
[	O
l	int
]	O
)	O
{	O
varlist1	pointer
[	O
l1	int
]	O
=	O
' '	O
;	O
outlist	pointer
[	O
l1	int
++	O
]	O
=	O
' '	O
;	O
varlist1	pointer
[	O
l1	int
]	O
=	O
'_'	O
;	O
outlist	pointer
[	O
l1	int
++	O
]	O
=	O
'_'	O
;	O
vardef	pointer
[	O
0	int
]	O
=	O
'_'	O
;	O
class	pointer
[	O
c	int
]	O
=	O
classmem	pointer
+	O
cm	int
;	O
for	O
(	O
vd	int
=	O
1	int
;	O
varlist	array
[	O
l	int
]	O
&&	O
varlist	array
[	O
l	int
]	O
!=	O
' '	O
;	O
l	int
++	O
)	O
{	O
classmem	pointer
[	O
cm	int
++	O
]	O
=	O
varlist	array
[	O
l	int
]	O
;	O
vardef	pointer
[	O
vd	int
++	O
]	O
=	O
varlist	array
[	O
l	int
]	O
;	O
varlist1	pointer
[	O
l1	int
]	O
=	O
varlist	array
[	O
l	int
]	O
;	O
outlist	pointer
[	O
l1	int
++	O
]	O
=	O
varlist	array
[	O
l	int
]	O
;	O
}	O
vardef	pointer
[	O
vd	int
]	O
=	O
'\0'	O
;	O
classmem	pointer
[	O
cm	int
++	O
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
vardef	pointer
,	O
" -1"	pointer
)	O
;	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
c	int
++	O
]	O
=	O
dap_vd	function
(	O
vardef	pointer
,	O
0	int
)	O
;	O
}	O
}	O
varlist1	pointer
[	O
l1	int
]	O
=	O
'\0'	O
;	O
outlist	pointer
[	O
l1	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
part	pointer
)	O
;	O
outset	function
(	O
fname1	pointer
,	O
outlist	pointer
)	O
;	O
maxval	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
maxval1	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
maxval1	pointer
[	O
nvl	int
]	O
=	O
0.0	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
c	int
]	O
]	O
=	O
0.0	int
;	O
maxlen	pointer
[	O
c	int
]	O
=	O
0	int
;	O
classval	pointer
[	O
c	int
]	O
=	O
NULL	O
;	O
}	O
for	O
(	O
firstpart	int
=	O
1	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
classv	pointer
,	O
npart	int
)	O
)	O
{	O
if	O
(	O
firstpart	int
)	O
{	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
maxval	pointer
[	O
nvl	int
]	O
=	O
maxval1	pointer
[	O
nvl	int
]	O
;	O
firstpart	int
=	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
{	O
if	O
(	O
maxval	pointer
[	O
nvl	int
]	O
!=	O
maxval1	pointer
[	O
nvl	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Variable %s has different numbers of levels in different parts of dataset %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nvl	int
]	O
]	O
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
{	O
maxval1	pointer
[	O
nvl	int
]	O
=	O
0.0	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
nvl	int
]	O
]	O
=	O
0.0	int
;	O
}	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
dap_newpart	function
(	O
classv	pointer
,	O
npart	int
)	O
)	O
nv	int
=	O
nclass	int
+	O
1	int
;	O
else	O
{	O
for	O
(	O
nv	int
=	O
1	int
;	O
nv	int
<=	O
nclass	int
;	O
nv	int
++	O
)	O
{	O
if	O
(	O
dap_newpart	function
(	O
classv	pointer
,	O
npart	int
+	O
nv	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
nv	int
<=	O
nclass	int
)	O
{	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
nv	int
-	O
1	int
]	O
]	O
+=	O
1.0	int
;	O
oneval	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
nv	int
-	O
1	int
]	O
]	O
;	O
if	O
(	O
oneval	double
>	O
99.0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Number of levels (%g) for %s exceeds maximum (100)\n"	pointer
,	O
oneval	double
+	O
1.0	int
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
nv	int
-	O
1	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
oneval	double
>	O
maxval1	pointer
[	O
nv	int
-	O
1	int
]	O
)	O
{	O
maxval1	pointer
[	O
nv	int
-	O
1	int
]	O
=	O
oneval	double
;	O
onelen	int
=	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nv	int
-	O
1	int
]	O
]	O
)	O
;	O
if	O
(	O
onelen	int
>	O
maxlen	pointer
[	O
nv	int
-	O
1	int
]	O
)	O
maxlen	pointer
[	O
nv	int
-	O
1	int
]	O
=	O
onelen	int
;	O
if	O
(	O
firstpart	int
)	O
{	O
endcv	pointer
[	O
nv	int
-	O
1	int
]	O
->	O
next	pointer
=	O
(	O
valnode	struct
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
valnode	struct
)	O
,	O
""	pointer
)	O
;	O
endcv	pointer
[	O
nv	int
-	O
1	int
]	O
=	O
endcv	pointer
[	O
nv	int
-	O
1	int
]	O
->	O
next	pointer
;	O
endcv	pointer
[	O
nv	int
-	O
1	int
]	O
->	O
value	pointer
=	O
dap_malloc	function
(	O
onelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
endcv	pointer
[	O
nv	int
-	O
1	int
]	O
->	O
next	pointer
=	O
NULL	O
;	O
strcpy	function
(	O
endcv	pointer
[	O
nv	int
-	O
1	int
]	O
->	O
value	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nv	int
-	O
1	int
]	O
]	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
firstpart	int
)	O
{	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
{	O
classval	pointer
[	O
nvl	int
]	O
=	O
(	O
valnode	struct
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
valnode	struct
)	O
,	O
""	pointer
)	O
;	O
endcv	pointer
[	O
nvl	int
]	O
=	O
classval	pointer
[	O
nvl	int
]	O
;	O
onelen	int
=	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nvl	int
]	O
]	O
)	O
;	O
if	O
(	O
onelen	int
>	O
maxlen	pointer
[	O
nvl	int
]	O
)	O
maxlen	pointer
[	O
nvl	int
]	O
=	O
onelen	int
;	O
endcv	pointer
[	O
nvl	int
]	O
->	O
value	pointer
=	O
dap_malloc	function
(	O
onelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
endcv	pointer
[	O
nvl	int
]	O
->	O
next	pointer
=	O
NULL	O
;	O
strcpy	function
(	O
endcv	pointer
[	O
nvl	int
]	O
->	O
value	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nvl	int
]	O
]	O
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
nv	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
c	int
]	O
]	O
!=	O
maxval1	pointer
[	O
c	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(loglin) Variable %s has different numbers of levels\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
classv	pointer
[	O
npart	int
+	O
c	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
npart	int
+	O
nclass	int
+	O
c	int
]	O
]	O
=	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
}	O
dap_head	function
(	O
NULL	O
,	O
0	int
)	O
;	O
fputs	function
(	O
"Loglinear model:\nnumerical indexes of classification variables\n\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
fputs	function
(	O
"Number"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
maxmaxval	int
=	O
0	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
onelen	int
=	O
strlen	function
(	O
class	pointer
[	O
c	int
]	O
)	O
;	O
if	O
(	O
maxlen	pointer
[	O
c	int
]	O
<	O
onelen	int
)	O
maxlen	pointer
[	O
c	int
]	O
=	O
onelen	int
;	O
sprintf	function
(	O
formstr	array
,	O
"  %%-%ds"	pointer
,	O
maxlen	pointer
[	O
c	int
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	array
,	O
class	pointer
[	O
c	int
]	O
)	O
;	O
if	O
(	O
(	O
(	O
int	O
)	O
maxval	pointer
[	O
c	int
]	O
)	O
>	O
maxmaxval	int
)	O
maxmaxval	int
=	O
(	O
(	O
int	O
)	O
maxval	pointer
[	O
c	int
]	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fputs	function
(	O
"------"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
maxlen	pointer
[	O
c	int
]	O
;	O
cc	int
++	O
)	O
putc	function
(	O
'-'	O
,	O
dap_lst	pointer
)	O
;	O
endcv	pointer
[	O
c	int
]	O
=	O
classval	pointer
[	O
c	int
]	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<=	O
maxmaxval	int
;	O
cc	int
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%6d"	pointer
,	O
cc	int
+	O
1	int
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
endcv	pointer
[	O
c	int
]	O
)	O
{	O
sprintf	function
(	O
formstr	array
,	O
"  %%-%ds"	pointer
,	O
maxlen	pointer
[	O
c	int
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	array
,	O
endcv	pointer
[	O
c	int
]	O
->	O
value	pointer
)	O
;	O
endcv	pointer
[	O
c	int
]	O
=	O
endcv	pointer
[	O
c	int
]	O
->	O
next	pointer
;	O
}	O
else	O
{	O
sprintf	function
(	O
formstr	array
,	O
"  %%%ds"	pointer
,	O
maxlen	pointer
[	O
c	int
]	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	array
,	O
""	pointer
)	O
;	O
}	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
nterm	int
=	O
1	int
,	O
nv	int
=	O
0	int
;	O
nv	int
<	O
nclass	int
;	O
nv	int
++	O
)	O
nterm	int
*=	O
2	int
;	O
term	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nterm	int
,	O
""	pointer
)	O
;	O
pattern	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
for	O
(	O
c	int
=	O
1	int
,	O
pattern	pointer
[	O
0	int
]	O
=	O
1	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
pattern	pointer
[	O
c	int
]	O
=	O
2	int
*	O
pattern	pointer
[	O
c	int
-	O
1	int
]	O
;	O
nterm	int
=	O
llparse	function
(	O
class	pointer
,	O
nterm	int
,	O
pattern	pointer
,	O
model0	pointer
,	O
model1	pointer
,	O
term	pointer
)	O
;	O
for	O
(	O
nparam0	int
=	O
1	int
,	O
sellen	int
=	O
5	int
,	O
t	int
=	O
1	int
;	O
t	int
<=	O
nterm	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
term	pointer
[	O
t	int
]	O
)	O
{	O
for	O
(	O
termparam	int
=	O
1	int
,	O
c	int
=	O
0	int
,	O
termlen	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	pointer
[	O
c	int
]	O
&	O
~	O
t	int
)	O
)	O
{	O
termparam	int
*=	O
(	O
int	O
)	O
maxval	pointer
[	O
c	int
]	O
;	O
termlen	int
+=	O
strlen	function
(	O
class	pointer
[	O
c	int
]	O
)	O
+	O
4	int
;	O
}	O
}	O
nparam0	int
+=	O
termparam	int
;	O
sellen	int
+=	O
termparam	int
*	O
(	O
termlen	int
+	O
2	int
)	O
;	O
}	O
}	O
param	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam0	int
,	O
""	pointer
)	O
;	O
paramlistmem	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nparam0	int
*	O
nclass	int
,	O
""	pointer
)	O
;	O
paramlist	pointer
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nparam0	int
,	O
""	pointer
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam0	int
;	O
p	double
++	O
)	O
paramlist	pointer
[	O
p	double
]	O
=	O
paramlistmem	pointer
+	O
p	double
*	O
nclass	int
;	O
select	function
=	O
dap_malloc	function
(	O
sellen	int
,	O
""	pointer
)	O
;	O
selterm	pointer
=	O
dap_malloc	function
(	O
sellen	int
,	O
""	pointer
)	O
;	O
sub	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
""	pointer
)	O
;	O
for	O
(	O
t	int
=	O
1	int
,	O
strcpy	function
(	O
select	function
,	O
"_mu"	pointer
)	O
,	O
numparam	int
=	O
0	int
;	O
t	int
<=	O
nterm	int
;	O
t	int
++	O
)	O
{	O
selterm	pointer
[	O
0	int
]	O
=	O
' '	O
;	O
selterm	pointer
[	O
1	int
]	O
=	O
' '	O
;	O
if	O
(	O
term	pointer
[	O
t	int
]	O
)	O
{	O
if	O
(	O
term	pointer
[	O
t	int
]	O
==	O
2	int
||	O
!	O
model0	pointer
[	O
0	int
]	O
)	O
selterm	pointer
[	O
1	int
]	O
=	O
' '	O
;	O
else	O
selterm	pointer
[	O
1	int
]	O
=	O
'?'	O
;	O
selterm	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	pointer
[	O
c	int
]	O
&	O
~	O
t	int
)	O
)	O
{	O
if	O
(	O
!	O
selterm	pointer
[	O
2	int
]	O
)	O
strcat	function
(	O
selterm	pointer
,	O
class	pointer
[	O
c	int
]	O
)	O
;	O
else	O
{	O
strcat	function
(	O
selterm	pointer
,	O
"*"	pointer
)	O
;	O
strcat	function
(	O
selterm	pointer
,	O
class	pointer
[	O
c	int
]	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
sub	pointer
[	O
c	int
]	O
=	O
1	int
;	O
do	O
{	O
numparam	int
++	O
;	O
strcat	function
(	O
select	function
,	O
selterm	pointer
)	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nclass	int
;	O
cc	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	pointer
[	O
cc	int
]	O
&	O
~	O
t	int
)	O
)	O
{	O
strcat	function
(	O
select	function
,	O
":"	pointer
)	O
;	O
sprintf	function
(	O
select	function
+	O
strlen	function
(	O
select	function
)	O
,	O
"%d"	pointer
,	O
sub	pointer
[	O
cc	int
]	O
)	O
;	O
paramlist	pointer
[	O
numparam	int
]	O
[	O
cc	int
]	O
=	O
sub	pointer
[	O
cc	int
]	O
-	O
1	int
;	O
}	O
else	O
paramlist	pointer
[	O
numparam	int
]	O
[	O
cc	int
]	O
=	O
-	O
1	int
;	O
}	O
for	O
(	O
c	int
=	O
nclass	int
-	O
1	int
;	O
c	int
>=	O
0	int
;	O
c	int
--	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	pointer
[	O
c	int
]	O
&	O
~	O
t	int
)	O
&&	O
sub	pointer
[	O
c	int
]	O
<	O
(	O
int	O
)	O
maxval	pointer
[	O
c	int
]	O
)	O
{	O
sub	pointer
[	O
c	int
]	O
++	O
;	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nclass	int
;	O
cc	int
++	O
)	O
sub	pointer
[	O
cc	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
while	O
(	O
c	int
>=	O
0	int
)	O
;	O
}	O
}	O
numparam	int
++	O
;	O
param	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
p	double
=	O
1	int
;	O
p	double
<	O
numparam	int
;	O
p	double
++	O
)	O
param	pointer
[	O
p	double
]	O
=	O
0.0	int
;	O
categ	function
(	O
fname1	pointer
,	O
varlist1	pointer
,	O
""	pointer
,	O
&	O
llexpect	function
,	O
param	pointer
,	O
select	function
,	O
part	pointer
,	O
""	pointer
)	O
;	O
inset	function
(	O
catname	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
strcpy	function
(	O
vardef	pointer
,	O
class	pointer
[	O
c	int
]	O
)	O
;	O
sprintf	function
(	O
vardef	pointer
+	O
strlen	function
(	O
vardef	pointer
)	O
,	O
" %d"	pointer
,	O
maxlen	pointer
[	O
c	int
]	O
)	O
;	O
classv	pointer
[	O
c	int
]	O
=	O
dap_vd	function
(	O
vardef	pointer
,	O
0	int
)	O
;	O
}	O
outset	function
(	O
fname1	pointer
,	O
""	pointer
)	O
;	O
dap_list	function
(	O
varlist1	pointer
,	O
classv	pointer
+	O
nclass	int
,	O
nclass	int
+	O
1	int
)	O
;	O
while	O
(	O
step	function
(	O
)	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
for	O
(	O
nodeptr	pointer
=	O
classval	pointer
[	O
c	int
]	O
,	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
(	O
int	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
nclass	int
+	O
1	int
+	O
c	int
]	O
]	O
;	O
nvl	int
++	O
)	O
nodeptr	pointer
=	O
nodeptr	pointer
->	O
next	pointer
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
,	O
nodeptr	pointer
->	O
value	pointer
)	O
;	O
}	O
output	function
(	O
)	O
;	O
}	O
dap_free	function
(	O
fnamefil	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
filarg	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
fname1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
catname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varlist1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outlist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
vardef	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
classv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
maxval	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
maxval1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
term	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
param	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
select	function
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
selterm	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sub	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
classmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
class	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
pattern	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
paramlistmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
paramlist	pointer
,	O
""	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
while	O
(	O
classval	pointer
[	O
c	int
]	O
)	O
{	O
dap_free	function
(	O
classval	pointer
[	O
c	int
]	O
->	O
value	pointer
,	O
""	pointer
)	O
;	O
endcv	pointer
[	O
c	int
]	O
=	O
classval	pointer
[	O
c	int
]	O
->	O
next	pointer
;	O
dap_free	function
(	O
classval	pointer
[	O
c	int
]	O
,	O
""	pointer
)	O
;	O
classval	pointer
[	O
c	int
]	O
=	O
endcv	pointer
[	O
c	int
]	O
;	O
}	O
}	O
dap_free	function
(	O
classval	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
endcv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
maxlen	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
findparam	function
(	O
char	O
*	O
pname	pointer
,	O
char	O
*	O
param	pointer
[	O
]	O
,	O
int	O
nparam	int
)	O
{	O
int	O
p	double
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
pname	pointer
,	O
param	pointer
[	O
p	double
]	O
)	O
)	O
return	O
p	double
;	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
estimate	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
parameters	pointer
,	O
char	O
*	O
definitions	pointer
,	O
char	O
*	O
part	pointer
)	O
{	O
char	O
*	O
parammem	pointer
;	O
char	O
*	O
*	O
param	pointer
;	O
int	O
start	int
,	O
end	int
;	O
int	O
nparam	int
;	O
int	O
p	double
,	O
p1	int
;	O
int	O
defstate	int
;	O
double	O
*	O
defmem	pointer
;	O
double	O
*	O
*	O
def	pointer
;	O
double	O
coeff	double
;	O
double	O
sign	double
;	O
double	O
place	double
;	O
int	O
pnum1	int
,	O
pnum2	int
,	O
pnum3	int
;	O
int	O
defnum	int
;	O
int	O
ninput	int
;	O
double	O
*	O
estimate	function
;	O
double	O
*	O
covmem	pointer
;	O
double	O
*	O
*	O
cov	pointer
;	O
int	O
typen	int
,	O
param1n	int
,	O
param2n	int
,	O
covn	int
;	O
int	O
more	int
;	O
int	O
*	O
partv	array
;	O
int	O
npart	int
;	O
parammem	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
parameters	pointer
)	O
+	O
strlen	function
(	O
definitions	pointer
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
nparam	int
=	O
(	O
strlen	function
(	O
parameters	pointer
)	O
+	O
strlen	function
(	O
definitions	pointer
)	O
)	O
/	O
2	int
;	O
param	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nparam	int
,	O
""	pointer
)	O
;	O
defmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
*	O
nparam	int
,	O
""	pointer
)	O
;	O
def	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nparam	int
,	O
""	pointer
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
def	pointer
[	O
p	double
]	O
=	O
defmem	pointer
+	O
p	double
*	O
nparam	int
;	O
for	O
(	O
p1	int
=	O
0	int
;	O
p1	int
<	O
nparam	int
;	O
p1	int
++	O
)	O
def	pointer
[	O
p	double
]	O
[	O
p1	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
start	int
=	O
0	int
;	O
parameters	pointer
[	O
start	int
]	O
==	O
' '	O
;	O
start	int
++	O
)	O
;	O
for	O
(	O
nparam	int
=	O
0	int
,	O
p	double
=	O
0	int
;	O
parameters	pointer
[	O
start	int
]	O
;	O
start	int
=	O
end	int
)	O
{	O
param	pointer
[	O
nparam	int
++	O
]	O
=	O
parammem	pointer
+	O
p	double
;	O
for	O
(	O
end	int
=	O
start	int
;	O
parameters	pointer
[	O
end	int
]	O
&&	O
parameters	pointer
[	O
end	int
]	O
!=	O
' '	O
;	O
)	O
parammem	pointer
[	O
p	double
++	O
]	O
=	O
parameters	pointer
[	O
end	int
++	O
]	O
;	O
parammem	pointer
[	O
p	double
++	O
]	O
=	O
'\0'	O
;	O
while	O
(	O
parameters	pointer
[	O
end	int
]	O
==	O
' '	O
)	O
end	int
++	O
;	O
}	O
ninput	int
=	O
nparam	int
;	O
for	O
(	O
start	int
=	O
0	int
;	O
definitions	pointer
[	O
start	int
]	O
==	O
' '	O
;	O
start	int
++	O
)	O
;	O
for	O
(	O
defstate	int
=	O
0	int
;	O
definitions	pointer
[	O
start	int
]	O
;	O
start	int
=	O
end	int
)	O
{	O
param	pointer
[	O
nparam	int
]	O
=	O
parammem	pointer
+	O
p	double
;	O
if	O
(	O
definitions	pointer
[	O
start	int
]	O
==	O
'+'	O
||	O
definitions	pointer
[	O
start	int
]	O
==	O
'-'	O
)	O
{	O
sign	double
=	O
2.0	int
*	O
(	O
(	O
double	O
)	O
(	O
definitions	pointer
[	O
start	int
]	O
==	O
'+'	O
)	O
)	O
-	O
1.0	int
;	O
for	O
(	O
start	int
++	O
;	O
definitions	pointer
[	O
start	int
]	O
==	O
' '	O
;	O
start	int
++	O
)	O
;	O
}	O
if	O
(	O
definitions	pointer
[	O
start	int
]	O
==	O
'.'	O
||	O
(	O
'0'	O
<=	O
definitions	pointer
[	O
start	int
]	O
&&	O
definitions	pointer
[	O
start	int
]	O
<=	O
'9'	O
)	O
)	O
{	O
for	O
(	O
coeff	double
=	O
0.0	int
,	O
place	double
=	O
0.0	int
;	O
definitions	pointer
[	O
start	int
]	O
==	O
'.'	O
||	O
(	O
'0'	O
<=	O
definitions	pointer
[	O
start	int
]	O
&&	O
definitions	pointer
[	O
start	int
]	O
<=	O
'9'	O
)	O
;	O
start	int
++	O
)	O
{	O
if	O
(	O
definitions	pointer
[	O
start	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
place	double
>	O
0.0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) bad coefficient in definition: %s\n"	pointer
,	O
definitions	pointer
+	O
start	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
place	double
=	O
1.0	int
;	O
}	O
else	O
{	O
coeff	double
=	O
10.0	int
*	O
coeff	double
+	O
(	O
double	O
)	O
(	O
definitions	pointer
[	O
start	int
]	O
-	O
'0'	O
)	O
;	O
if	O
(	O
place	double
>	O
0.0	int
)	O
place	double
*=	O
10.0	int
;	O
}	O
}	O
coeff	double
*=	O
sign	double
;	O
if	O
(	O
place	double
>	O
0.0	int
)	O
coeff	double
/=	O
place	double
;	O
while	O
(	O
definitions	pointer
[	O
start	int
]	O
==	O
' '	O
)	O
start	int
++	O
;	O
}	O
else	O
coeff	double
=	O
sign	double
;	O
for	O
(	O
end	int
=	O
start	int
;	O
definitions	pointer
[	O
end	int
]	O
&&	O
definitions	pointer
[	O
end	int
]	O
!=	O
' '	O
&&	O
definitions	pointer
[	O
end	int
]	O
!=	O
'='	O
&&	O
definitions	pointer
[	O
end	int
]	O
!=	O
'+'	O
&&	O
definitions	pointer
[	O
end	int
]	O
!=	O
'-'	O
;	O
)	O
parammem	pointer
[	O
p	double
++	O
]	O
=	O
definitions	pointer
[	O
end	int
++	O
]	O
;	O
parammem	pointer
[	O
p	double
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
pnum1	int
=	O
findparam	function
(	O
param	pointer
[	O
nparam	int
]	O
,	O
param	pointer
,	O
nparam	int
)	O
)	O
<	O
0	int
)	O
nparam	int
++	O
;	O
else	O
p	double
=	O
param	pointer
[	O
nparam	int
]	O
-	O
parammem	pointer
;	O
while	O
(	O
definitions	pointer
[	O
end	int
]	O
==	O
' '	O
)	O
end	int
++	O
;	O
switch	O
(	O
defstate	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
definitions	pointer
[	O
end	int
]	O
==	O
'='	O
)	O
{	O
defstate	int
=	O
1	int
;	O
for	O
(	O
end	int
++	O
;	O
definitions	pointer
[	O
end	int
]	O
==	O
' '	O
;	O
end	int
++	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) definition starting at %s missing an =\n"	pointer
,	O
definitions	pointer
+	O
start	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
defnum	int
=	O
nparam	int
-	O
1	int
;	O
sign	double
=	O
1.0	int
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
pnum1	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) undefined parameter %s in definition\n"	pointer
,	O
param	pointer
[	O
nparam	int
-	O
1	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sign	double
==	O
0.0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) missing sign or coefficient for parameter %s in definition\n"	pointer
,	O
param	pointer
[	O
nparam	int
-	O
1	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
def	pointer
[	O
defnum	int
]	O
[	O
pnum1	int
]	O
=	O
coeff	double
;	O
if	O
(	O
definitions	pointer
[	O
end	int
]	O
!=	O
'+'	O
&&	O
definitions	pointer
[	O
end	int
]	O
!=	O
'-'	O
)	O
defstate	int
=	O
0	int
;	O
sign	double
=	O
0.0	int
;	O
break	O
;	O
}	O
}	O
estimate	function
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
,	O
""	pointer
)	O
;	O
covmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
*	O
nparam	int
,	O
""	pointer
)	O
;	O
cov	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nparam	int
,	O
""	pointer
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
cov	pointer
[	O
p	double
]	O
=	O
covmem	pointer
+	O
nparam	int
*	O
p	double
;	O
inset	function
(	O
fname	array
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) missing _type_ variable in dataset %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
param1n	int
=	O
dap_varnum	function
(	O
"_param1_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) missing _param1_ variable in dataset %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
param2n	int
=	O
dap_varnum	function
(	O
"_param2_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) missing _param2_ variable in dataset %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
covn	int
=	O
dap_varnum	function
(	O
"_cov_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) missing _cov_ variable in dataset %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
partv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
npart	int
=	O
dap_list	function
(	O
part	pointer
,	O
partv	array
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
pnum1	int
=	O
0	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
estimate	function
[	O
pnum1	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
nparam	int
;	O
pnum2	int
++	O
)	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
for	O
(	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
partv	array
,	O
npart	int
)	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
partv	array
,	O
npart	int
)	O
;	O
fputs	function
(	O
"    Estimate           SE  Parameter\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
pnum1	int
=	O
ninput	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
estimate	function
[	O
pnum1	int
]	O
=	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
pnum1	int
;	O
pnum2	int
++	O
)	O
{	O
if	O
(	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
&&	O
!	O
finite	function
(	O
estimate	function
[	O
pnum2	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(estimate) estimate for parameter %s not in dataset %s\n"	pointer
,	O
param	pointer
[	O
pnum2	int
]	O
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
estimate	function
[	O
pnum1	int
]	O
+=	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
*	O
estimate	function
[	O
pnum2	int
]	O
;	O
}	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum1	int
]	O
=	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
pnum1	int
;	O
pnum2	int
++	O
)	O
{	O
for	O
(	O
pnum3	int
=	O
0	int
;	O
pnum3	int
<	O
pnum1	int
;	O
pnum3	int
++	O
)	O
{	O
coeff	double
=	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
*	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum3	int
]	O
;	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum1	int
]	O
+=	O
coeff	double
*	O
cov	pointer
[	O
pnum2	int
]	O
[	O
pnum3	int
]	O
;	O
}	O
}	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
pnum1	int
;	O
pnum2	int
++	O
)	O
{	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
0.0	int
;	O
for	O
(	O
pnum3	int
=	O
0	int
;	O
pnum3	int
<	O
pnum1	int
;	O
pnum3	int
++	O
)	O
{	O
coeff	double
=	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
;	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
+=	O
coeff	double
*	O
cov	pointer
[	O
pnum2	int
]	O
[	O
pnum3	int
]	O
;	O
}	O
cov	pointer
[	O
pnum2	int
]	O
[	O
pnum1	int
]	O
=	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
;	O
}	O
}	O
for	O
(	O
pnum1	int
=	O
ninput	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%12g %12g  %s ="	pointer
,	O
estimate	function
[	O
pnum1	int
]	O
,	O
sqrt	function
(	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum1	int
]	O
)	O
,	O
param	pointer
[	O
pnum1	int
]	O
)	O
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
nparam	int
;	O
pnum2	int
++	O
)	O
{	O
if	O
(	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
!=	O
0.0	int
)	O
{	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
>	O
0.0	int
)	O
putc	function
(	O
'+'	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
==	O
1.0	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s"	pointer
,	O
param	pointer
[	O
pnum2	int
]	O
)	O
;	O
else	O
if	O
(	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
==	O
-	O
1.0	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" -%s"	pointer
,	O
param	pointer
[	O
pnum2	int
]	O
)	O
;	O
else	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%g%s"	pointer
,	O
def	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
,	O
param	pointer
[	O
pnum2	int
]	O
)	O
;	O
}	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
for	O
(	O
pnum1	int
=	O
0	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
estimate	function
[	O
pnum1	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
nparam	int
;	O
pnum2	int
++	O
)	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"ESTIMATE"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
pnum2	int
=	O
findparam	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
,	O
param	pointer
,	O
ninput	int
)	O
)	O
>=	O
0	int
)	O
estimate	function
[	O
pnum2	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"COVAR"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
pnum1	int
=	O
findparam	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param1n	int
]	O
,	O
param	pointer
,	O
ninput	int
)	O
)	O
>=	O
0	int
&&	O
(	O
pnum2	int
=	O
findparam	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
param2n	int
]	O
,	O
param	pointer
,	O
ninput	int
)	O
)	O
>=	O
0	int
)	O
cov	pointer
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
covn	int
]	O
;	O
}	O
}	O
}	O
dap_free	function
(	O
parammem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
param	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
defmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
def	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
estimate	function
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
covmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
cov	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partv	array
,	O
""	pointer
)	O
;	O
}	O
