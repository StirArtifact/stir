int	O
sort_option	int
;	O
int	O
prefix_len	int
;	O
static	O
int	O
compare_response	function
(	O
void	O
const	O
*	O
a	pointer
,	O
void	O
const	O
*	O
b	pointer
)	O
{	O
struct	O
mu_list_response	struct
const	O
*	O
ra	pointer
=	O
a	pointer
;	O
struct	O
mu_list_response	struct
const	O
*	O
rb	pointer
=	O
b	pointer
;	O
if	O
(	O
ra	pointer
->	O
depth	int
<	O
rb	pointer
->	O
depth	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ra	pointer
->	O
depth	int
>	O
rb	pointer
->	O
depth	int
)	O
return	O
1	int
;	O
return	O
strcmp	function
(	O
ra	pointer
->	O
name	pointer
,	O
rb	pointer
->	O
name	pointer
)	O
;	O
}	O
static	O
int	O
_print_list_entry	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_list_response	struct
*	O
resp	pointer
=	O
item	pointer
;	O
int	O
len	int
=	O
data	pointer
?	O
*	O
(	O
int	O
*	O
)	O
data	pointer
:	O
0	int
;	O
mu_printf	function
(	O
"%c%c %c %4d %s\n"	pointer
,	O
(	O
resp	pointer
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
?	O
'd'	O
:	O
'-'	O
,	O
(	O
resp	pointer
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
)	O
?	O
'f'	O
:	O
'-'	O
,	O
resp	pointer
->	O
separator	int
?	O
resp	pointer
->	O
separator	int
:	O
' '	O
,	O
resp	pointer
->	O
depth	int
,	O
resp	pointer
->	O
name	pointer
+	O
len	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_list	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
options	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
mu_folder_t	pointer
folder	pointer
=	O
env	pointer
;	O
int	O
rc	int
;	O
mu_list_t	pointer
list	pointer
;	O
mu_printf	function
(	O
"listing '%s' '%s'\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_list	function
(	O
folder	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
,	O
0	int
,	O
&	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_list"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
{	O
if	O
(	O
sort_option	int
)	O
mu_list_sort	function
(	O
list	pointer
,	O
compare_response	function
)	O
;	O
mu_list_foreach	function
(	O
list	pointer
,	O
_print_list_entry	function
,	O
&	O
prefix_len	int
)	O
;	O
mu_list_destroy	function
(	O
&	O
list	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_lsub	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
options	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
mu_folder_t	pointer
folder	pointer
=	O
env	pointer
;	O
int	O
rc	int
;	O
mu_list_t	pointer
list	pointer
;	O
mu_printf	function
(	O
"listing subscriptions for '%s' '%s'\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_lsub	function
(	O
folder	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
,	O
&	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_lsub"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
{	O
if	O
(	O
sort_option	int
)	O
mu_list_sort	function
(	O
list	pointer
,	O
compare_response	function
)	O
;	O
mu_list_foreach	function
(	O
list	pointer
,	O
_print_list_entry	function
,	O
NULL	O
)	O
;	O
mu_list_destroy	function
(	O
&	O
list	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
com_rename	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
options	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
int	O
rc	int
;	O
mu_folder_t	pointer
folder	pointer
=	O
env	pointer
;	O
mu_printf	function
(	O
"renaming %s to %s\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_rename	function
(	O
folder	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_rename"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"rename successful\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_subscribe	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
options	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
mu_folder_t	pointer
folder	pointer
=	O
env	pointer
;	O
int	O
rc	int
;	O
mu_printf	function
(	O
"subscribing %s\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_subscribe	function
(	O
folder	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_subscribe"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"subscribe successful\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_unsubscribe	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
options	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
mu_folder_t	pointer
folder	pointer
=	O
env	pointer
;	O
int	O
rc	int
;	O
mu_printf	function
(	O
"unsubscribing %s\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_unsubscribe	function
(	O
folder	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_unsubscribe"	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"unsubscribe successful\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
com_scan	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
options	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
mu_folder_t	pointer
folder	pointer
=	O
env	pointer
;	O
struct	O
mu_folder_scanner	struct
scn	pointer
=	O
MU_FOLDER_SCANNER_INITIALIZER	O
;	O
char	O
*	O
s	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
scn	pointer
.	O
refname	pointer
=	O
argv	pointer
[	O
1	int
]	O
;	O
if	O
(	O
argc	int
==	O
3	int
)	O
scn	pointer
.	O
pattern	pointer
=	O
argv	pointer
[	O
2	int
]	O
;	O
}	O
mu_list_create	function
(	O
&	O
scn	pointer
.	O
result	pointer
)	O
;	O
if	O
(	O
mu_assoc_lookup	function
(	O
options	pointer
,	O
"maxdepth"	pointer
,	O
&	O
s	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
errno	O
=	O
0	int
;	O
scn	pointer
.	O
max_depth	long
=	O
strtoul	function
(	O
s	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
||	O
*	O
p	pointer
)	O
{	O
mu_error	function
(	O
"-maxdepth=%s: invalid depth"	pointer
,	O
s	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
mu_assoc_lookup	function
(	O
options	pointer
,	O
"type"	pointer
,	O
&	O
s	pointer
)	O
==	O
0	int
)	O
{	O
mu_record_t	pointer
rec	pointer
;	O
rc	int
=	O
mu_registrar_lookup_scheme	function
(	O
s	pointer
,	O
&	O
rec	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
scn	pointer
.	O
records	pointer
)	O
MU_ASSERT	O
(	O
mu_list_create	function
(	O
&	O
scn	pointer
.	O
records	pointer
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_list_append	function
(	O
scn	pointer
.	O
records	pointer
,	O
rec	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
mu_error	function
(	O
"%s: no such record found"	pointer
,	O
s	pointer
)	O
;	O
else	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_registrar_lookup_scheme"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
mu_list_destroy	function
(	O
&	O
scn	pointer
.	O
records	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
rc	int
=	O
mu_folder_scan	function
(	O
folder	pointer
,	O
&	O
scn	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_scan"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
else	O
{	O
if	O
(	O
sort_option	int
)	O
mu_list_sort	function
(	O
scn	pointer
.	O
result	pointer
,	O
compare_response	function
)	O
;	O
mu_list_foreach	function
(	O
scn	pointer
.	O
result	pointer
,	O
_print_list_entry	function
,	O
&	O
prefix_len	int
)	O
;	O
mu_list_destroy	function
(	O
&	O
scn	pointer
.	O
result	pointer
)	O
;	O
}	O
mu_list_destroy	function
(	O
&	O
scn	pointer
.	O
records	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_tesh_command	struct
comtab	array
[	O
]	O
=	O
{	O
{	O
"list"	pointer
,	O
"REF MBX"	pointer
,	O
com_list	function
}	O
,	O
{	O
"lsub"	pointer
,	O
"REF MBX"	pointer
,	O
com_lsub	function
}	O
,	O
{	O
"rename"	pointer
,	O
"OLD NEW"	pointer
,	O
com_rename	function
}	O
,	O
{	O
"subscribe"	pointer
,	O
"MBX"	pointer
,	O
com_subscribe	function
}	O
,	O
{	O
"unsubscribe"	pointer
,	O
"MBX"	pointer
,	O
com_unsubscribe	function
}	O
,	O
{	O
"scan"	pointer
,	O
"[-maxdepth=N] [-type=TYPE] [REF PATTERN]"	pointer
,	O
com_scan	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
void	O
)	O
{	O
mu_printf	function
(	O
"usage: %s [-debug=SPEC] -name=URL [-sort] [-glob] OP ARG... [\\; OP ARG...]...]\n"	pointer
,	O
mu_program_name	pointer
)	O
;	O
mu_printf	function
(	O
"OPerations and corresponding ARGuments are:\n"	pointer
)	O
;	O
mu_tesh_help	function
(	O
comtab	array
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
_always_is_scheme	function
(	O
mu_record_t	pointer
record	pointer
,	O
mu_url_t	pointer
url	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
res	pointer
=	O
0	int
;	O
char	O
const	O
*	O
p	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
rc	int
=	O
mu_url_sget_path	function
(	O
url	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_url_sget_path"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
lstat	function
(	O
p	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"lstat"	pointer
,	O
p	pointer
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
res	pointer
|=	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
;	O
if	O
(	O
S_ISREG	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
res	pointer
|=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
res	pointer
|=	O
MU_FOLDER_ATTRIBUTE_LINK	int
;	O
return	O
res	pointer
&	O
flags	int
;	O
}	O
static	O
struct	O
_mu_record	struct
any_record	struct
=	O
{	O
10	int
,	O
"any"	pointer
,	O
MU_RECORD_LOCAL	int
,	O
MU_URL_SCHEME	int
|	O
MU_URL_PATH	int
,	O
MU_URL_PATH	int
,	O
mu_url_expand_path	function
,	O
NULL	O
,	O
NULL	O
,	O
_mu_fsfolder_init	function
,	O
NULL	O
,	O
_always_is_scheme	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
int	O
_reg_is_scheme	function
(	O
mu_record_t	pointer
record	pointer
,	O
mu_url_t	pointer
url	pointer
,	O
int	O
flags	int
)	O
{	O
return	O
_always_is_scheme	function
(	O
record	pointer
,	O
url	pointer
,	O
flags	int
)	O
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
}	O
static	O
struct	O
_mu_record	struct
reg_record	struct
=	O
{	O
0	int
,	O
"reg"	pointer
,	O
MU_RECORD_LOCAL	int
,	O
MU_URL_SCHEME	int
|	O
MU_URL_PATH	int
,	O
MU_URL_PATH	int
,	O
mu_url_expand_path	function
,	O
NULL	O
,	O
NULL	O
,	O
_mu_fsfolder_init	function
,	O
NULL	O
,	O
_reg_is_scheme	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
int	O
rc	int
;	O
mu_folder_t	pointer
folder	pointer
;	O
char	O
*	O
fname	pointer
=	O
NULL	O
;	O
int	O
glob_option	int
=	O
0	int
;	O
mu_tesh_init	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
mu_registrar_record	function
(	O
&	O
any_record	struct
)	O
;	O
mu_registrar_record	function
(	O
&	O
reg_record	struct
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
usage	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-debug="	pointer
,	O
7	int
)	O
==	O
0	int
)	O
mu_debug_parse_spec	function
(	O
argv	pointer
[	O
i	int
]	O
+	O
7	int
)	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-name="	pointer
,	O
6	int
)	O
==	O
0	int
)	O
fname	pointer
=	O
argv	pointer
[	O
i	int
]	O
+	O
6	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-sort"	pointer
)	O
==	O
0	int
)	O
sort_option	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"-glob"	pointer
)	O
==	O
0	int
)	O
glob_option	int
=	O
1	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
fname	pointer
)	O
{	O
mu_error	function
(	O
"name not specified"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fname	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
cwd	pointer
=	O
mu_getcwd	function
(	O
)	O
;	O
prefix_len	int
=	O
strlen	function
(	O
cwd	pointer
)	O
;	O
if	O
(	O
cwd	pointer
[	O
prefix_len	int
-	O
1	int
]	O
!=	O
'/'	O
)	O
prefix_len	int
++	O
;	O
fname	pointer
=	O
mu_make_file_name	O
(	O
cwd	pointer
,	O
fname	pointer
)	O
;	O
free	function
(	O
cwd	pointer
)	O
;	O
}	O
rc	int
=	O
mu_folder_create	function
(	O
&	O
folder	pointer
,	O
fname	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_create"	pointer
,	O
fname	pointer
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_folder_open	function
(	O
folder	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_open"	pointer
,	O
fname	pointer
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
glob_option	int
)	O
mu_folder_set_match	function
(	O
folder	pointer
,	O
mu_folder_glob_match	function
)	O
;	O
mu_tesh_read_and_eval	function
(	O
argc	int
-	O
i	int
,	O
argv	pointer
+	O
i	int
,	O
comtab	array
,	O
folder	pointer
)	O
;	O
mu_folder_close	function
(	O
folder	pointer
)	O
;	O
mu_folder_destroy	function
(	O
&	O
folder	pointer
)	O
;	O
return	O
0	int
;	O
}	O
