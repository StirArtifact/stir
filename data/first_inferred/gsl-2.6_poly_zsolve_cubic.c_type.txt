int	O
gsl_poly_complex_solve_cubic	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
c	array
,	O
gsl_complex	struct
*	O
z0	pointer
,	O
gsl_complex	struct
*	O
z1	pointer
,	O
gsl_complex	struct
*	O
z2	pointer
)	O
{	O
double	O
q	double
=	O
(	O
a	double
*	O
a	double
-	O
3	int
*	O
b	double
)	O
;	O
double	O
r	double
=	O
(	O
2	int
*	O
a	double
*	O
a	double
*	O
a	double
-	O
9	int
*	O
a	double
*	O
b	double
+	O
27	int
*	O
c	array
)	O
;	O
double	O
Q	double
=	O
q	double
/	O
9	int
;	O
double	O
R	double
=	O
r	double
/	O
54	int
;	O
double	O
Q3	double
=	O
Q	double
*	O
Q	double
*	O
Q	double
;	O
double	O
R2	double
=	O
R	double
*	O
R	double
;	O
double	O
CR2	double
=	O
729	int
*	O
r	double
*	O
r	double
;	O
double	O
CQ3	double
=	O
2916	int
*	O
q	double
*	O
q	double
*	O
q	double
;	O
if	O
(	O
R	double
==	O
0	int
&&	O
Q	double
==	O
0	int
)	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z2	pointer
)	O
=	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z2	pointer
)	O
=	O
0	int
;	O
return	O
3	int
;	O
}	O
else	O
if	O
(	O
CR2	double
==	O
CQ3	double
)	O
{	O
double	O
sqrtQ	double
=	O
sqrt	function
(	O
Q	double
)	O
;	O
if	O
(	O
R	double
>	O
0	int
)	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
2	int
*	O
sqrtQ	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
sqrtQ	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z2	pointer
)	O
=	O
sqrtQ	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z2	pointer
)	O
=	O
0	int
;	O
}	O
else	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
sqrtQ	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
sqrtQ	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z2	pointer
)	O
=	O
2	int
*	O
sqrtQ	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z2	pointer
)	O
=	O
0	int
;	O
}	O
return	O
3	int
;	O
}	O
else	O
if	O
(	O
R2	double
<	O
Q3	double
)	O
{	O
double	O
sgnR	double
=	O
(	O
R	double
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
double	O
ratio	double
=	O
sgnR	double
*	O
sqrt	function
(	O
R2	double
/	O
Q3	double
)	O
;	O
double	O
theta	double
=	O
acos	function
(	O
ratio	double
)	O
;	O
double	O
norm	double
=	O
-	O
2	int
*	O
sqrt	function
(	O
Q	double
)	O
;	O
double	O
r0	double
=	O
norm	double
*	O
cos	function
(	O
theta	double
/	O
3	int
)	O
-	O
a	double
/	O
3	int
;	O
double	O
r1	double
=	O
norm	double
*	O
cos	function
(	O
(	O
theta	double
+	O
2.0	int
*	O
M_PI	int
)	O
/	O
3	int
)	O
-	O
a	double
/	O
3	int
;	O
double	O
r2	double
=	O
norm	double
*	O
cos	function
(	O
(	O
theta	double
-	O
2.0	int
*	O
M_PI	int
)	O
/	O
3	int
)	O
-	O
a	double
/	O
3	int
;	O
if	O
(	O
r0	double
>	O
r1	double
)	O
SWAP	O
(	O
r0	double
,	O
r1	double
)	O
;	O
if	O
(	O
r1	double
>	O
r2	double
)	O
{	O
SWAP	O
(	O
r1	double
,	O
r2	double
)	O
;	O
if	O
(	O
r0	double
>	O
r1	double
)	O
SWAP	O
(	O
r0	double
,	O
r1	double
)	O
;	O
}	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
r0	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
r1	double
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z2	pointer
)	O
=	O
r2	double
;	O
GSL_IMAG	O
(	O
*	O
z2	pointer
)	O
=	O
0	int
;	O
return	O
3	int
;	O
}	O
else	O
{	O
double	O
sgnR	double
=	O
(	O
R	double
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
double	O
A	double
=	O
-	O
sgnR	double
*	O
pow	function
(	O
fabs	function
(	O
R	double
)	O
+	O
sqrt	function
(	O
R2	double
-	O
Q3	double
)	O
,	O
1.0	int
/	O
3.0	int
)	O
;	O
double	O
B	double
=	O
Q	double
/	O
A	double
;	O
if	O
(	O
A	double
+	O
B	double
<	O
0	int
)	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
A	double
+	O
B	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
0.5	int
*	O
(	O
A	double
+	O
B	double
)	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
(	O
sqrt	function
(	O
3.0	int
)	O
/	O
2.0	int
)	O
*	O
fabs	function
(	O
A	double
-	O
B	double
)	O
;	O
GSL_REAL	O
(	O
*	O
z2	pointer
)	O
=	O
-	O
0.5	int
*	O
(	O
A	double
+	O
B	double
)	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z2	pointer
)	O
=	O
(	O
sqrt	function
(	O
3.0	int
)	O
/	O
2.0	int
)	O
*	O
fabs	function
(	O
A	double
-	O
B	double
)	O
;	O
}	O
else	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
0.5	int
*	O
(	O
A	double
+	O
B	double
)	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
(	O
sqrt	function
(	O
3.0	int
)	O
/	O
2.0	int
)	O
*	O
fabs	function
(	O
A	double
-	O
B	double
)	O
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
0.5	int
*	O
(	O
A	double
+	O
B	double
)	O
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
(	O
sqrt	function
(	O
3.0	int
)	O
/	O
2.0	int
)	O
*	O
fabs	function
(	O
A	double
-	O
B	double
)	O
;	O
GSL_REAL	O
(	O
*	O
z2	pointer
)	O
=	O
A	double
+	O
B	double
-	O
a	double
/	O
3	int
;	O
GSL_IMAG	O
(	O
*	O
z2	pointer
)	O
=	O
0	int
;	O
}	O
return	O
3	int
;	O
}	O
}	O
