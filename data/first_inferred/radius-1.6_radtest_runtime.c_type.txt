static	O
jmp_buf	array
errbuf	array
;	O
static	O
int	O
break_level	int
;	O
static	O
int	O
continue_loop	int
;	O
static	O
radtest_variable_t	struct
function_result	struct
;	O
static	O
grad_list_t	struct
*	O
curenv	pointer
;	O
static	O
void	O
rt_eval_stmt_list	function
(	O
grad_list_t	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
rt_eval_expr	function
(	O
radtest_node_t	struct
*	O
node	pointer
,	O
radtest_variable_t	struct
*	O
result	pointer
)	O
;	O
static	O
void	O
rt_eval	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
)	O
;	O
static	O
void	O
rt_eval_variable	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_variable_t	struct
*	O
var	pointer
)	O
;	O
static	O
char	O
*	O
cast_to_string	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
const	O
*	O
var	pointer
)	O
;	O
static	O
void	O
runtime_error	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
if	O
(	O
locus	struct
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: "	pointer
,	O
locus	struct
->	O
file	pointer
,	O
locus	struct
->	O
line	long
)	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
longjmp	function
(	O
errbuf	array
,	O
1	int
)	O
;	O
}	O
void	O
var_asgn	function
(	O
radtest_variable_t	struct
*	O
var	pointer
,	O
radtest_variable_t	struct
*	O
result	pointer
)	O
{	O
var	pointer
->	O
type	int
=	O
result	pointer
->	O
type	int
;	O
switch	O
(	O
result	pointer
->	O
type	int
)	O
{	O
case	O
rtv_undefined	int
:	O
case	O
rtv_integer	int
:	O
case	O
rtv_ipaddress	int
:	O
var	pointer
->	O
datum	union
=	O
result	pointer
->	O
datum	union
;	O
break	O
;	O
case	O
rtv_bstring	int
:	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
ptr	pointer
=	O
grad_emalloc	function
(	O
result	pointer
->	O
datum	union
.	O
bstring	struct
.	O
length	short
)	O
;	O
memcpy	function
(	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
ptr	pointer
,	O
result	pointer
->	O
datum	union
.	O
bstring	struct
.	O
ptr	pointer
,	O
result	pointer
->	O
datum	union
.	O
bstring	struct
.	O
length	short
)	O
;	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
length	short
=	O
result	pointer
->	O
datum	union
.	O
bstring	struct
.	O
length	short
;	O
break	O
;	O
case	O
rtv_string	int
:	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
grad_estrdup	function
(	O
result	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
var	pointer
->	O
datum	union
.	O
avl	pointer
=	O
result	pointer
->	O
datum	union
.	O
avl	pointer
;	O
break	O
;	O
case	O
rtv_pairlist	int
:	O
grad_insist_fail	O
(	O
"rtv_pairlist in assignment"	pointer
)	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"invalid data type in assignment"	pointer
)	O
;	O
}	O
}	O
void	O
radtest_env_add_string	function
(	O
grad_list_t	struct
*	O
env	pointer
,	O
char	O
*	O
string	pointer
)	O
{	O
radtest_variable_t	struct
*	O
var	pointer
;	O
var	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
var	pointer
)	O
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_string	int
;	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
string	pointer
;	O
grad_list_append	function
(	O
env	pointer
,	O
var	pointer
)	O
;	O
}	O
void	O
radtest_env_add	function
(	O
grad_list_t	struct
*	O
env	pointer
,	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
grad_list_append	function
(	O
env	pointer
,	O
var	pointer
)	O
;	O
}	O
radtest_variable_t	struct
*	O
radtest_env_get	function
(	O
grad_list_t	struct
*	O
env	pointer
,	O
int	O
n	long
)	O
{	O
return	O
grad_list_item	function
(	O
env	pointer
,	O
n	long
)	O
;	O
}	O
int	O
radtest_env_shift	function
(	O
grad_list_t	struct
*	O
env	pointer
,	O
int	O
amount	int
)	O
{	O
if	O
(	O
amount	int
>	O
grad_list_count	function
(	O
env	pointer
)	O
-	O
1	int
)	O
return	O
1	int
;	O
while	O
(	O
amount	int
--	O
)	O
grad_list_remove	function
(	O
env	pointer
,	O
grad_list_item	function
(	O
env	pointer
,	O
1	int
)	O
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radtest_env_to_argv	function
(	O
grad_list_t	struct
*	O
env	pointer
,	O
grad_locus_t	struct
*	O
locus	struct
,	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	array
)	O
{	O
int	O
i	int
,	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
argc	int
=	O
grad_list_count	function
(	O
env	pointer
)	O
;	O
argv	pointer
=	O
calloc	function
(	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	pointer
)	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"out of memory"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
radtest_variable_t	struct
*	O
var	pointer
=	O
grad_list_item	function
(	O
env	pointer
,	O
i	int
)	O
;	O
char	O
*	O
p	pointer
=	O
cast_to_string	function
(	O
locus	struct
,	O
var	pointer
)	O
;	O
argv	pointer
[	O
i	int
]	O
=	O
malloc	function
(	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
argv	pointer
[	O
i	int
]	O
)	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"out of memory"	pointer
)	O
)	O
;	O
strcpy	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
p	pointer
)	O
;	O
}	O
argv	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
*	O
pargc	pointer
=	O
argc	int
;	O
*	O
pargv	array
=	O
argv	pointer
;	O
}	O
int	O
radtest_eval	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
,	O
grad_list_t	struct
*	O
env	pointer
)	O
{	O
if	O
(	O
setjmp	function
(	O
errbuf	array
)	O
)	O
return	O
1	int
;	O
break_level	int
=	O
continue_loop	int
=	O
0	int
;	O
curenv	pointer
=	O
env	pointer
;	O
rt_eval	function
(	O
stmt	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
rt_eval_bin_int	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_binop_t	enum
op	enum
,	O
long	O
a	pointer
,	O
long	O
b	pointer
)	O
{	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
RT_EVAL	O
(	O
locus	struct
,	O
result	pointer
,	O
op	enum
,	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
static	O
void	O
rt_eval_bin_uint	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_binop_t	enum
op	enum
,	O
grad_uint32_t	int
a	pointer
,	O
grad_uint32_t	int
b	pointer
)	O
{	O
result	pointer
->	O
type	int
=	O
rtv_ipaddress	int
;	O
RT_EVAL	O
(	O
locus	struct
,	O
result	pointer
,	O
op	enum
,	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
static	O
char	O
*	O
binop_string	array
[	O
]	O
=	O
{	O
N_	O
(	O
"addition"	pointer
)	O
,	O
N_	O
(	O
"subtraction"	pointer
)	O
,	O
N_	O
(	O
"multiplication"	pointer
)	O
,	O
N_	O
(	O
"division"	pointer
)	O
,	O
N_	O
(	O
"division"	pointer
)	O
,	O
N_	O
(	O
"boolean conjunction"	pointer
)	O
,	O
N_	O
(	O
"boolean disjunction"	pointer
)	O
,	O
N_	O
(	O
"comparison"	pointer
)	O
,	O
N_	O
(	O
"comparison"	pointer
)	O
,	O
N_	O
(	O
"comparison"	pointer
)	O
,	O
N_	O
(	O
"comparison"	pointer
)	O
,	O
N_	O
(	O
"comparison"	pointer
)	O
,	O
N_	O
(	O
"comparison"	pointer
)	O
}	O
;	O
static	O
void	O
bin_type_error	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_binop_t	enum
op	enum
)	O
{	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"incompatible types in %s"	pointer
)	O
,	O
gettext	function
(	O
binop_string	array
[	O
op	enum
]	O
)	O
)	O
;	O
}	O
static	O
char	O
*	O
unary_string	array
[	O
]	O
=	O
{	O
N_	O
(	O
"binary negation"	pointer
)	O
,	O
N_	O
(	O
"numeric negation"	pointer
)	O
,	O
}	O
;	O
static	O
void	O
unary_type_error	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_unop_t	enum
op	enum
)	O
{	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"incompatible data type in %s"	pointer
)	O
,	O
gettext	function
(	O
unary_string	array
[	O
op	enum
]	O
)	O
)	O
;	O
}	O
static	O
void	O
rt_eval_bin_str	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_binop_t	enum
op	enum
,	O
char	O
*	O
a	pointer
,	O
char	O
*	O
b	pointer
)	O
{	O
switch	O
(	O
op	enum
)	O
{	O
case	O
radtest_op_add	int
:	O
radtest_start_string	function
(	O
a	pointer
)	O
;	O
radtest_add_string	function
(	O
b	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
break	O
;	O
case	O
radtest_op_eq	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
==	O
0	int
;	O
break	O
;	O
case	O
radtest_op_ne	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
!=	O
0	int
;	O
break	O
;	O
case	O
radtest_op_lt	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
<	O
0	int
;	O
break	O
;	O
case	O
radtest_op_le	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
<=	O
0	int
;	O
break	O
;	O
case	O
radtest_op_gt	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
>	O
0	int
;	O
break	O
;	O
case	O
radtest_op_ge	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
>=	O
0	int
;	O
break	O
;	O
default	O
:	O
bin_type_error	function
(	O
locus	struct
,	O
op	enum
)	O
;	O
}	O
}	O
static	O
int	O
_found_p	function
(	O
void	O
*	O
data	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
)	O
{	O
return	O
grad_avl_find	function
(	O
data	pointer
,	O
pair	pointer
->	O
attribute	int
)	O
!=	O
NULL	O
;	O
}	O
static	O
int	O
_not_found_p	function
(	O
void	O
*	O
data	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
)	O
{	O
return	O
grad_avl_find	function
(	O
data	pointer
,	O
pair	pointer
->	O
attribute	int
)	O
==	O
NULL	O
;	O
}	O
void	O
rt_eval_bin_avl	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_binop_t	enum
op	enum
,	O
grad_avp_t	struct
*	O
a	pointer
,	O
grad_avp_t	struct
*	O
b	pointer
)	O
{	O
switch	O
(	O
op	enum
)	O
{	O
case	O
radtest_op_add	int
:	O
grad_avl_merge	function
(	O
&	O
a	pointer
,	O
&	O
b	pointer
)	O
;	O
grad_avl_free	function
(	O
b	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_avl	int
;	O
result	pointer
->	O
datum	union
.	O
avl	pointer
=	O
a	pointer
;	O
break	O
;	O
case	O
radtest_op_sub	int
:	O
result	pointer
->	O
type	int
=	O
rtv_avl	int
;	O
result	pointer
->	O
datum	union
.	O
avl	pointer
=	O
NULL	O
;	O
grad_avl_move_pairs	function
(	O
&	O
result	pointer
->	O
datum	union
.	O
avl	pointer
,	O
&	O
a	pointer
,	O
_not_found_p	function
,	O
b	pointer
)	O
;	O
break	O
;	O
case	O
radtest_op_mod	int
:	O
result	pointer
->	O
type	int
=	O
rtv_avl	int
;	O
result	pointer
->	O
datum	union
.	O
avl	pointer
=	O
NULL	O
;	O
grad_avl_move_pairs	function
(	O
&	O
result	pointer
->	O
datum	union
.	O
avl	pointer
,	O
&	O
a	pointer
,	O
_found_p	function
,	O
b	pointer
)	O
;	O
break	O
;	O
case	O
radtest_op_eq	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
compare_lists	function
(	O
a	pointer
,	O
b	pointer
)	O
==	O
0	int
;	O
break	O
;	O
case	O
radtest_op_ne	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
compare_lists	function
(	O
a	pointer
,	O
b	pointer
)	O
!=	O
0	int
;	O
break	O
;	O
default	O
:	O
bin_type_error	function
(	O
locus	struct
,	O
op	enum
)	O
;	O
}	O
}	O
static	O
void	O
rt_eval_deref	function
(	O
radtest_node_t	struct
*	O
node	pointer
,	O
radtest_variable_t	struct
*	O
result	pointer
)	O
{	O
radtest_datum_t	union
datum	union
;	O
size_t	long
n	long
;	O
radtest_variable_t	struct
*	O
var	pointer
;	O
char	O
*	O
p	pointer
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
vartab	pointer
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
if	O
(	O
var	pointer
&&	O
var	pointer
->	O
type	int
!=	O
rtv_undefined	int
)	O
{	O
rt_eval_variable	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
var	pointer
)	O
;	O
return	O
;	O
}	O
result	pointer
->	O
type	int
=	O
rtv_undefined	int
;	O
p	pointer
=	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
repl	pointer
;	O
if	O
(	O
p	pointer
)	O
switch	O
(	O
*	O
p	pointer
++	O
)	O
{	O
case	O
'='	O
:	O
if	O
(	O
!	O
var	pointer
)	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	function
(	O
vartab	pointer
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
parse_datum	function
(	O
p	pointer
,	O
&	O
var	pointer
->	O
datum	union
)	O
;	O
radtest_var_copy	function
(	O
result	pointer
,	O
var	pointer
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
switch	O
(	O
result	pointer
->	O
type	int
=	O
parse_datum	function
(	O
p	pointer
,	O
&	O
datum	union
)	O
)	O
{	O
case	O
rtv_undefined	int
:	O
runtime_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"variable `%s' used before definition"	pointer
)	O
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
break	O
;	O
case	O
rtv_integer	int
:	O
case	O
rtv_ipaddress	int
:	O
case	O
rtv_string	int
:	O
result	pointer
->	O
datum	union
=	O
datum	union
;	O
break	O
;	O
default	O
:	O
runtime_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"%s:%d: unknown data type"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
*	O
p	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: variable unset\n"	pointer
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
':'	O
:	O
if	O
(	O
*	O
p	pointer
)	O
printf	function
(	O
"%s"	pointer
,	O
p	pointer
)	O
;	O
else	O
printf	function
(	O
"(%s:%lu)%s? "	pointer
,	O
node	pointer
->	O
locus	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
node	pointer
->	O
locus	struct
.	O
line	long
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
p	pointer
=	O
NULL	O
;	O
n	long
=	O
0	int
;	O
getline	function
(	O
&	O
p	pointer
,	O
&	O
n	long
,	O
stdin	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
radtest_start_string	function
(	O
p	pointer
)	O
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
if	O
(	O
!	O
*	O
p	pointer
)	O
asprintf	function
(	O
&	O
p	pointer
,	O
"(%s:%lu)%s? "	pointer
,	O
node	pointer
->	O
locus	struct
.	O
file	pointer
,	O
node	pointer
->	O
locus	struct
.	O
line	long
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
p	pointer
=	O
getpass	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
exit	function
(	O
0	int
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
radtest_start_string	function
(	O
p	pointer
)	O
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
->	O
type	int
==	O
rtv_undefined	int
)	O
runtime_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"variable `%s' used before definition"	pointer
)	O
,	O
node	pointer
->	O
v	union
.	O
deref	struct
.	O
name	pointer
)	O
;	O
}	O
static	O
void	O
rt_eval_parm	function
(	O
radtest_node_t	struct
*	O
node	pointer
,	O
radtest_variable_t	struct
*	O
result	pointer
)	O
{	O
int	O
num	int
=	O
node	pointer
->	O
v	union
.	O
parm	struct
.	O
number	long
;	O
char	O
*	O
p	pointer
;	O
size_t	long
n	long
;	O
radtest_variable_t	struct
*	O
var	pointer
;	O
var	pointer
=	O
radtest_env_get	function
(	O
curenv	pointer
,	O
num	int
)	O
;	O
if	O
(	O
var	pointer
)	O
{	O
rt_eval_variable	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
var	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
node	pointer
->	O
v	union
.	O
parm	struct
.	O
repl	pointer
)	O
{	O
radtest_start_string	function
(	O
""	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
return	O
;	O
}	O
p	pointer
=	O
node	pointer
->	O
v	union
.	O
parm	struct
.	O
repl	pointer
;	O
switch	O
(	O
*	O
p	pointer
++	O
)	O
{	O
case	O
'='	O
:	O
radtest_start_string	function
(	O
p	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_string	int
;	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
radtest_env_add	function
(	O
curenv	pointer
,	O
var	pointer
)	O
;	O
radtest_var_copy	function
(	O
result	pointer
,	O
var	pointer
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
radtest_start_string	function
(	O
p	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
p	pointer
;	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
*	O
p	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"parameter %d unset\n"	pointer
,	O
num	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
':'	O
:	O
if	O
(	O
*	O
p	pointer
)	O
printf	function
(	O
"%s"	pointer
,	O
p	pointer
)	O
;	O
else	O
printf	function
(	O
"(%s:%lu)%d? "	pointer
,	O
node	pointer
->	O
locus	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
node	pointer
->	O
locus	struct
.	O
line	long
,	O
num	int
)	O
;	O
p	pointer
=	O
NULL	O
;	O
n	long
=	O
0	int
;	O
getline	function
(	O
&	O
p	pointer
,	O
&	O
n	long
,	O
stdin	pointer
)	O
;	O
radtest_start_string	function
(	O
p	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
if	O
(	O
!	O
*	O
p	pointer
)	O
asprintf	function
(	O
&	O
p	pointer
,	O
"(%s:%lu)%d? "	pointer
,	O
node	pointer
->	O
locus	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
node	pointer
->	O
locus	struct
.	O
line	long
,	O
num	int
)	O
;	O
p	pointer
=	O
getpass	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
exit	function
(	O
0	int
)	O
;	O
radtest_start_string	function
(	O
p	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
rt_eval_pairlist	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
grad_avp_t	struct
*	O
plist	pointer
=	O
NULL	O
;	O
radtest_pair_t	struct
*	O
p	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
var	pointer
->	O
datum	union
.	O
list	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
radtest_variable_t	struct
val	array
;	O
grad_avp_t	struct
*	O
pair	pointer
=	O
NULL	O
;	O
grad_uint32_t	int
n	long
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
rt_eval_expr	function
(	O
p	pointer
->	O
node	pointer
,	O
&	O
val	array
)	O
;	O
switch	O
(	O
val	array
.	O
type	int
)	O
{	O
default	O
:	O
grad_insist_fail	O
(	O
"invalid data type in "	pointer
"rt_eval_pairlist"	pointer
)	O
;	O
case	O
rtv_pairlist	int
:	O
case	O
rtv_avl	int
:	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"invalid data type"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
rtv_integer	int
:	O
switch	O
(	O
p	pointer
->	O
attr	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
case	O
GRAD_TYPE_DATE	int
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%ld"	pointer
,	O
val	array
.	O
datum	union
.	O
number	long
)	O
;	O
pair	pointer
=	O
grad_avp_create_string	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
case	O
GRAD_TYPE_IPADDR	int
:	O
pair	pointer
=	O
grad_avp_create_integer	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
val	array
.	O
datum	union
.	O
number	long
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
rtv_ipaddress	int
:	O
switch	O
(	O
p	pointer
->	O
attr	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
case	O
GRAD_TYPE_DATE	int
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
val	array
.	O
datum	union
.	O
ipaddr	int
)	O
;	O
pair	pointer
=	O
grad_avp_create_string	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
case	O
GRAD_TYPE_IPADDR	int
:	O
pair	pointer
=	O
grad_avp_create_integer	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
val	array
.	O
datum	union
.	O
ipaddr	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
rtv_bstring	int
:	O
switch	O
(	O
p	pointer
->	O
attr	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
pair	pointer
=	O
grad_avp_create_binary	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
val	array
.	O
datum	union
.	O
bstring	struct
.	O
length	short
,	O
val	array
.	O
datum	union
.	O
bstring	struct
.	O
ptr	pointer
)	O
;	O
break	O
;	O
default	O
:	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"invalid data type"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
rtv_string	int
:	O
switch	O
(	O
p	pointer
->	O
attr	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
case	O
GRAD_TYPE_DATE	int
:	O
pair	pointer
=	O
grad_avp_create_string	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
val	array
.	O
datum	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
{	O
grad_dict_value_t	struct
*	O
dv	pointer
=	O
grad_value_name_to_value	function
(	O
val	array
.	O
datum	union
.	O
string	pointer
,	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
)	O
;	O
if	O
(	O
dv	pointer
)	O
{	O
pair	pointer
=	O
grad_avp_create_integer	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
dv	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
}	O
}	O
case	O
GRAD_TYPE_IPADDR	int
:	O
n	long
=	O
strtoul	function
(	O
val	array
.	O
datum	union
.	O
string	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
pair	pointer
=	O
grad_avp_create_integer	function
(	O
p	pointer
->	O
attr	pointer
->	O
value	pointer
,	O
n	long
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
grad_insist	O
(	O
pair	pointer
!=	O
NULL	O
)	O
;	O
grad_avl_merge	function
(	O
&	O
plist	pointer
,	O
&	O
pair	pointer
)	O
;	O
grad_avp_free	function
(	O
pair	pointer
)	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_avl	int
;	O
result	pointer
->	O
datum	union
.	O
avl	pointer
=	O
plist	pointer
;	O
}	O
static	O
void	O
rt_eval_variable	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
result	pointer
,	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_pairlist	int
:	O
rt_eval_pairlist	function
(	O
locus	struct
,	O
result	pointer
,	O
var	pointer
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
result	pointer
->	O
type	int
=	O
var	pointer
->	O
type	int
;	O
result	pointer
->	O
datum	union
.	O
avl	pointer
=	O
grad_avl_dup	function
(	O
var	pointer
->	O
datum	union
.	O
avl	pointer
)	O
;	O
break	O
;	O
default	O
:	O
*	O
result	pointer
=	O
*	O
var	pointer
;	O
}	O
}	O
static	O
void	O
rt_eval_call	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
,	O
radtest_variable_t	struct
*	O
result	pointer
)	O
{	O
grad_list_t	struct
*	O
env	pointer
,	O
*	O
tmp	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
radtest_node_t	struct
*	O
expr	pointer
;	O
radtest_variable_t	struct
*	O
var	pointer
;	O
env	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
var	pointer
=	O
radtest_var_alloc	function
(	O
rtv_string	int
)	O
;	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
stmt	pointer
->	O
v	union
.	O
call	struct
.	O
fun	pointer
->	O
name	pointer
;	O
radtest_env_add	function
(	O
env	pointer
,	O
var	pointer
)	O
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
stmt	pointer
->	O
v	union
.	O
call	struct
.	O
args	pointer
)	O
;	O
for	O
(	O
expr	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
expr	pointer
;	O
expr	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
rt_eval_expr	function
(	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
radtest_env_add	function
(	O
env	pointer
,	O
radtest_var_dup	function
(	O
&	O
result	pointer
)	O
)	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
tmp	pointer
=	O
curenv	pointer
;	O
curenv	pointer
=	O
env	pointer
;	O
function_result	struct
.	O
type	int
=	O
rtv_undefined	int
;	O
rt_eval_stmt_list	function
(	O
stmt	pointer
->	O
v	union
.	O
call	struct
.	O
fun	pointer
->	O
body	pointer
)	O
;	O
grad_list_destroy	function
(	O
&	O
env	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
curenv	pointer
=	O
tmp	pointer
;	O
if	O
(	O
result	pointer
)	O
*	O
result	pointer
=	O
function_result	struct
;	O
break_level	int
=	O
0	int
;	O
}	O
static	O
char	O
*	O
type_string	array
[	O
]	O
=	O
{	O
N_	O
(	O
"undefined"	pointer
)	O
,	O
N_	O
(	O
"integer"	pointer
)	O
,	O
N_	O
(	O
"ipaddress"	pointer
)	O
,	O
N_	O
(	O
"string"	pointer
)	O
,	O
N_	O
(	O
"binary string"	pointer
)	O
,	O
N_	O
(	O
"pairlist"	pointer
)	O
,	O
N_	O
(	O
"A/V list"	pointer
)	O
}	O
;	O
static	O
char	O
*	O
type_string_to	array
[	O
]	O
=	O
{	O
N_	O
(	O
"to undefined"	pointer
)	O
,	O
N_	O
(	O
"to integer"	pointer
)	O
,	O
N_	O
(	O
"to ipaddress"	pointer
)	O
,	O
N_	O
(	O
"to string"	pointer
)	O
,	O
N_	O
(	O
"to binary string"	pointer
)	O
,	O
N_	O
(	O
"to pairlist"	pointer
)	O
,	O
N_	O
(	O
"to A/V list"	pointer
)	O
}	O
;	O
static	O
void	O
typecast_error	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_data_type	enum
from	pointer
,	O
radtest_data_type	enum
to	pointer
)	O
{	O
runtime_error	function
(	O
locus	struct
,	O
_	O
(	O
"cannot convert %s %s"	pointer
)	O
,	O
gettext	function
(	O
type_string	array
[	O
from	pointer
]	O
)	O
,	O
gettext	function
(	O
type_string_to	array
[	O
to	pointer
]	O
)	O
)	O
;	O
}	O
typedef	O
int	O
(	O
*	O
typecast_proc_t	pointer
)	O
(	O
radtest_variable_t	struct
*	O
)	O
;	O
static	O
int	O
tc_error	function
(	O
radtest_variable_t	struct
*	O
var	pointer
ARG_UNUSED	O
)	O
{	O
return	O
1	int
;	O
}	O
static	O
int	O
int_to_ip	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
=	O
var	pointer
->	O
datum	union
.	O
number	long
;	O
var	pointer
->	O
type	int
=	O
rtv_ipaddress	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ip_to_int	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
var	pointer
->	O
datum	union
.	O
number	long
=	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
int_to_str	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
static	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%ld"	pointer
,	O
var	pointer
->	O
datum	union
.	O
number	long
)	O
;	O
radtest_start_string	function
(	O
buf	pointer
)	O
;	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_string	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ip_to_str	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
radtest_start_string	function
(	O
grad_ip_iptostr	function
(	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
,	O
NULL	O
)	O
)	O
;	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_string	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
str_to_int	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
long	O
v	union
;	O
if	O
(	O
isdigit	function
(	O
var	pointer
->	O
datum	union
.	O
string	pointer
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
v	union
=	O
strtol	function
(	O
var	pointer
->	O
datum	union
.	O
string	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
v	union
=	O
grad_request_name_to_code	function
(	O
var	pointer
->	O
datum	union
.	O
string	pointer
)	O
)	O
==	O
0	int
)	O
return	O
1	int
;	O
var	pointer
->	O
datum	union
.	O
number	long
=	O
v	union
;	O
var	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
str_to_ip	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
=	O
grad_ip_gethostaddr	function
(	O
var	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_ipaddress	int
;	O
return	O
0	int
;	O
}	O
typecast_proc_t	pointer
typecast_proc	array
[	O
]	O
[	O
RTV_MAX	O
]	O
=	O
{	O
{	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
{	O
tc_error	function
,	O
NULL	O
,	O
int_to_ip	function
,	O
int_to_str	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
{	O
tc_error	function
,	O
ip_to_int	function
,	O
NULL	O
,	O
ip_to_str	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
{	O
tc_error	function
,	O
str_to_int	function
,	O
str_to_ip	function
,	O
NULL	O
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
{	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
NULL	O
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
{	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
{	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
,	O
tc_error	function
}	O
,	O
}	O
;	O
static	O
int	O
try_typecast	function
(	O
radtest_variable_t	struct
*	O
var	pointer
,	O
radtest_data_type	enum
t	enum
)	O
{	O
typecast_proc_t	pointer
proc	pointer
=	O
typecast_proc	array
[	O
var	pointer
->	O
type	int
]	O
[	O
t	enum
]	O
;	O
return	O
proc	pointer
&&	O
proc	pointer
(	O
var	pointer
)	O
;	O
}	O
static	O
void	O
typecast	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
*	O
var	pointer
,	O
radtest_data_type	enum
t	enum
)	O
{	O
if	O
(	O
try_typecast	function
(	O
var	pointer
,	O
t	enum
)	O
)	O
typecast_error	function
(	O
locus	struct
,	O
var	pointer
->	O
type	int
,	O
t	enum
)	O
;	O
}	O
static	O
char	O
*	O
cast_to_string	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
const	O
*	O
var	pointer
)	O
{	O
static	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_string	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
string	pointer
;	O
case	O
rtv_integer	int
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%ld"	pointer
,	O
var	pointer
->	O
datum	union
.	O
number	long
)	O
;	O
break	O
;	O
case	O
rtv_ipaddress	int
:	O
grad_ip_iptostr	function
(	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
,	O
buf	pointer
)	O
;	O
break	O
;	O
default	O
:	O
typecast_error	function
(	O
locus	struct
,	O
var	pointer
->	O
type	int
,	O
rtv_string	int
)	O
;	O
}	O
return	O
buf	pointer
;	O
}	O
static	O
int	O
cast_to_boolean	function
(	O
grad_locus_t	struct
*	O
locus	struct
,	O
radtest_variable_t	struct
const	O
*	O
var	pointer
)	O
{	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_string	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
string	pointer
[	O
0	int
]	O
;	O
case	O
rtv_integer	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
number	long
;	O
case	O
rtv_ipaddress	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
!=	O
0	int
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
avl	pointer
!=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
typecast_error	function
(	O
locus	struct
,	O
var	pointer
->	O
type	int
,	O
rtv_string	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
strnum_p	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
var	pointer
->	O
type	int
!=	O
rtv_string	int
)	O
return	O
0	int
;	O
for	O
(	O
p	pointer
=	O
var	pointer
->	O
datum	union
.	O
string	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
isspace	function
(	O
*	O
p	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
return	O
0	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
||	O
*	O
p	pointer
==	O
'-'	O
)	O
p	pointer
++	O
;	O
for	O
(	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
p	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
number_p	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
return	O
var	pointer
->	O
type	int
==	O
rtv_integer	int
||	O
var	pointer
->	O
type	int
==	O
rtv_ipaddress	int
;	O
}	O
static	O
void	O
rt_eval_expr	function
(	O
radtest_node_t	struct
*	O
node	pointer
,	O
radtest_variable_t	struct
*	O
result	pointer
)	O
{	O
radtest_variable_t	struct
left	pointer
,	O
right	pointer
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
result	pointer
->	O
type	int
=	O
rtv_undefined	int
;	O
return	O
;	O
}	O
switch	O
(	O
node	pointer
->	O
type	int
)	O
{	O
case	O
radtest_node_value	int
:	O
rt_eval_variable	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
node	pointer
->	O
v	union
.	O
var	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_bin	int
:	O
rt_eval_expr	function
(	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
left	pointer
,	O
&	O
left	pointer
)	O
;	O
if	O
(	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
==	O
radtest_op_and	int
||	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
==	O
radtest_op_or	int
)	O
{	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
==	O
radtest_op_or	int
;	O
if	O
(	O
cast_to_boolean	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
)	O
==	O
result	pointer
->	O
datum	union
.	O
number	long
)	O
break	O
;	O
}	O
rt_eval_expr	function
(	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
right	pointer
,	O
&	O
right	pointer
)	O
;	O
if	O
(	O
left	pointer
.	O
type	int
!=	O
right	pointer
.	O
type	int
)	O
{	O
if	O
(	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
left	pointer
->	O
type	int
==	O
radtest_node_value	int
&&	O
try_typecast	function
(	O
&	O
right	pointer
,	O
left	pointer
.	O
type	int
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
right	pointer
->	O
type	int
==	O
radtest_node_value	int
&&	O
try_typecast	function
(	O
&	O
left	pointer
,	O
right	pointer
.	O
type	int
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strnum_p	function
(	O
&	O
left	pointer
)	O
&&	O
number_p	function
(	O
&	O
right	pointer
)	O
)	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
right	pointer
,	O
left	pointer
.	O
type	int
)	O
;	O
else	O
if	O
(	O
strnum_p	function
(	O
&	O
right	pointer
)	O
&&	O
number_p	function
(	O
&	O
left	pointer
)	O
)	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
,	O
right	pointer
.	O
type	int
)	O
;	O
else	O
if	O
(	O
left	pointer
.	O
type	int
==	O
rtv_ipaddress	int
&&	O
right	pointer
.	O
type	int
==	O
rtv_integer	int
)	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
right	pointer
,	O
left	pointer
.	O
type	int
)	O
;	O
else	O
if	O
(	O
right	pointer
.	O
type	int
==	O
rtv_ipaddress	int
&&	O
left	pointer
.	O
type	int
==	O
rtv_integer	int
)	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
,	O
right	pointer
.	O
type	int
)	O
;	O
else	O
if	O
(	O
left	pointer
.	O
type	int
==	O
rtv_string	int
)	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
right	pointer
,	O
left	pointer
.	O
type	int
)	O
;	O
else	O
if	O
(	O
right	pointer
.	O
type	int
==	O
rtv_string	int
)	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
,	O
right	pointer
.	O
type	int
)	O
;	O
else	O
bin_type_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
)	O
;	O
}	O
grad_insist	O
(	O
left	pointer
.	O
type	int
==	O
right	pointer
.	O
type	int
)	O
;	O
switch	O
(	O
left	pointer
.	O
type	int
)	O
{	O
case	O
rtv_undefined	int
:	O
grad_insist_fail	O
(	O
"bad datatype"	pointer
)	O
;	O
case	O
rtv_integer	int
:	O
rt_eval_bin_int	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
,	O
left	pointer
.	O
datum	union
.	O
number	long
,	O
right	pointer
.	O
datum	union
.	O
number	long
)	O
;	O
break	O
;	O
case	O
rtv_ipaddress	int
:	O
rt_eval_bin_uint	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
,	O
left	pointer
.	O
datum	union
.	O
number	long
,	O
right	pointer
.	O
datum	union
.	O
ipaddr	int
)	O
;	O
break	O
;	O
case	O
rtv_string	int
:	O
rt_eval_bin_str	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
,	O
left	pointer
.	O
datum	union
.	O
string	pointer
,	O
right	pointer
.	O
datum	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
rtv_pairlist	int
:	O
grad_insist_fail	O
(	O
"a value cannot evaluate to "	pointer
"rtv_pairlist"	pointer
)	O
;	O
case	O
rtv_avl	int
:	O
rt_eval_bin_avl	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
result	pointer
,	O
node	pointer
->	O
v	union
.	O
bin	struct
.	O
op	enum
,	O
left	pointer
.	O
datum	union
.	O
avl	pointer
,	O
right	pointer
.	O
datum	union
.	O
avl	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
radtest_node_unary	int
:	O
rt_eval_expr	function
(	O
node	pointer
->	O
v	union
.	O
unary	struct
.	O
operand	pointer
,	O
&	O
left	pointer
)	O
;	O
switch	O
(	O
node	pointer
->	O
v	union
.	O
unary	struct
.	O
op	enum
)	O
{	O
case	O
radtest_op_neg	int
:	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
,	O
rtv_integer	int
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
-	O
left	pointer
.	O
datum	union
.	O
number	long
;	O
break	O
;	O
case	O
radtest_op_not	int
:	O
switch	O
(	O
left	pointer
.	O
type	int
)	O
{	O
case	O
rtv_string	int
:	O
if	O
(	O
strnum_p	function
(	O
&	O
left	pointer
)	O
)	O
{	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
,	O
rtv_integer	int
)	O
;	O
}	O
else	O
{	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
left	pointer
.	O
datum	union
.	O
string	pointer
[	O
0	int
]	O
==	O
0	int
;	O
break	O
;	O
}	O
case	O
rtv_integer	int
:	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
!	O
left	pointer
.	O
datum	union
.	O
number	long
;	O
break	O
;	O
case	O
rtv_ipaddress	int
:	O
typecast	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
left	pointer
,	O
rtv_integer	int
)	O
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
!	O
left	pointer
.	O
datum	union
.	O
number	long
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
left	pointer
.	O
datum	union
.	O
avl	pointer
==	O
NULL	O
;	O
break	O
;	O
default	O
:	O
unary_type_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
node	pointer
->	O
v	union
.	O
unary	struct
.	O
op	enum
)	O
;	O
}	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
}	O
break	O
;	O
case	O
radtest_node_deref	int
:	O
rt_eval_deref	function
(	O
node	pointer
,	O
result	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_parm	int
:	O
rt_eval_parm	function
(	O
node	pointer
,	O
result	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_attr	int
:	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
rt_eval_expr	function
(	O
node	pointer
->	O
v	union
.	O
attr	pointer
.	O
node	pointer
,	O
&	O
left	pointer
)	O
;	O
if	O
(	O
left	pointer
.	O
type	int
!=	O
rtv_avl	int
)	O
runtime_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"not a pair list"	pointer
)	O
)	O
;	O
p	pointer
=	O
grad_avl_find	function
(	O
left	pointer
.	O
datum	union
.	O
avl	pointer
,	O
node	pointer
->	O
v	union
.	O
attr	pointer
.	O
dict	pointer
->	O
value	pointer
)	O
;	O
switch	O
(	O
node	pointer
->	O
v	union
.	O
attr	pointer
.	O
dict	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
if	O
(	O
node	pointer
->	O
v	union
.	O
attr	pointer
.	O
all	int
)	O
{	O
size_t	long
len	int
=	O
1	int
;	O
for	O
(	O
p	pointer
=	O
left	pointer
.	O
datum	union
.	O
avl	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
attribute	int
==	O
node	pointer
->	O
v	union
.	O
attr	pointer
.	O
dict	pointer
->	O
value	pointer
)	O
len	int
+=	O
p	pointer
->	O
avp_strlength	O
;	O
}	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
grad_emalloc	function
(	O
len	int
)	O
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
left	pointer
.	O
datum	union
.	O
avl	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
attribute	int
==	O
node	pointer
->	O
v	union
.	O
attr	pointer
.	O
dict	pointer
->	O
value	pointer
)	O
strcat	function
(	O
result	pointer
->	O
datum	union
.	O
string	pointer
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
}	O
}	O
else	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
p	pointer
?	O
p	pointer
->	O
avp_strvalue	O
:	O
""	pointer
;	O
break	O
;	O
case	O
GRAD_TYPE_DATE	int
:	O
result	pointer
->	O
type	int
=	O
rtv_string	int
;	O
result	pointer
->	O
datum	union
.	O
string	pointer
=	O
p	pointer
?	O
p	pointer
->	O
avp_strvalue	O
:	O
""	pointer
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
p	pointer
?	O
p	pointer
->	O
avp_lvalue	O
:	O
0	int
;	O
break	O
;	O
case	O
GRAD_TYPE_IPADDR	int
:	O
result	pointer
->	O
type	int
=	O
rtv_ipaddress	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
p	pointer
?	O
p	pointer
->	O
avp_lvalue	O
:	O
0	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
radtest_node_getopt	int
:	O
{	O
char	O
buf	pointer
[	O
3	int
]	O
;	O
if	O
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
<=	O
0	int
)	O
{	O
optind	int
=	O
0	int
;	O
radtest_env_to_argv	function
(	O
curenv	pointer
,	O
&	O
node	pointer
->	O
locus	struct
,	O
&	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
argc	int
,	O
&	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
argv	pointer
)	O
;	O
}	O
opterr	int
=	O
0	int
;	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
=	O
getopt	function
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
argc	int
,	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
argv	pointer
,	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
optstr	pointer
)	O
;	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
!=	O
EOF	O
;	O
if	O
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
==	O
EOF	O
)	O
grad_argcv_free	function
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
argc	int
,	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
argv	pointer
)	O
;	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
var	pointer
->	O
type	int
=	O
rtv_string	int
;	O
grad_free	function
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
var	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"-%c"	pointer
,	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
==	O
EOF	O
?	O
'-'	O
:	O
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
==	O
'?'	O
?	O
optopt	int
:	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
last	int
)	O
)	O
;	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
grad_estrdup	function
(	O
buf	pointer
)	O
;	O
grad_free	function
(	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
arg	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
if	O
(	O
!	O
optarg	pointer
)	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
arg	pointer
->	O
type	int
=	O
rtv_undefined	int
;	O
else	O
{	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
arg	pointer
->	O
type	int
=	O
rtv_string	int
;	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
arg	pointer
->	O
datum	union
.	O
string	pointer
=	O
grad_estrdup	function
(	O
optarg	pointer
)	O
;	O
}	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
ind	int
->	O
type	int
=	O
rtv_integer	int
;	O
node	pointer
->	O
v	union
.	O
gopt	struct
.	O
ind	int
->	O
datum	union
.	O
number	long
=	O
optind	int
;	O
break	O
;	O
}	O
case	O
radtest_node_argcount	int
:	O
result	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
result	pointer
->	O
datum	union
.	O
number	long
=	O
grad_list_count	function
(	O
curenv	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
radtest_node_call	int
:	O
rt_eval_call	function
(	O
node	pointer
,	O
result	pointer
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected node type"	pointer
)	O
;	O
}	O
var_asgn	function
(	O
grad_sym_lookup_or_install	function
(	O
vartab	pointer
,	O
"_"	pointer
,	O
1	int
)	O
,	O
result	pointer
)	O
;	O
}	O
static	O
int	O
_printer	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
rt_eval_expr	function
(	O
item	pointer
,	O
&	O
result	pointer
)	O
;	O
var_print	function
(	O
&	O
result	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
rt_print	function
(	O
grad_list_t	struct
*	O
list	pointer
)	O
{	O
grad_list_iterate	function
(	O
list	pointer
,	O
_printer	function
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
rt_asgn	function
(	O
radtest_node_t	struct
*	O
node	pointer
)	O
{	O
radtest_variable_t	struct
*	O
var	pointer
;	O
radtest_variable_t	struct
result	pointer
;	O
rt_eval_expr	function
(	O
node	pointer
->	O
v	union
.	O
asgn	struct
.	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup_or_install	function
(	O
vartab	pointer
,	O
node	pointer
->	O
v	union
.	O
asgn	struct
.	O
name	pointer
,	O
1	int
)	O
;	O
var_asgn	function
(	O
var	pointer
,	O
&	O
result	pointer
)	O
;	O
}	O
static	O
void	O
rt_send	function
(	O
radtest_node_t	struct
*	O
node	pointer
)	O
{	O
radtest_node_send_t	struct
*	O
send	struct
=	O
&	O
node	pointer
->	O
v	union
.	O
send	struct
;	O
grad_avp_t	struct
*	O
avl	pointer
=	O
NULL	O
;	O
if	O
(	O
send	struct
->	O
expr	pointer
)	O
{	O
radtest_variable_t	struct
val	array
;	O
rt_eval_expr	function
(	O
send	struct
->	O
expr	pointer
,	O
&	O
val	array
)	O
;	O
if	O
(	O
val	array
.	O
type	int
!=	O
rtv_avl	int
)	O
runtime_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"invalid data type in send statement "	pointer
"(expected A/V list)"	pointer
)	O
)	O
;	O
avl	pointer
=	O
val	array
.	O
datum	union
.	O
avl	pointer
;	O
}	O
radtest_send	function
(	O
send	struct
->	O
port_type	int
,	O
send	struct
->	O
code	char
,	O
avl	pointer
,	O
send	struct
->	O
cntl	pointer
)	O
;	O
grad_symtab_free	function
(	O
&	O
send	struct
->	O
cntl	pointer
)	O
;	O
grad_avl_free	function
(	O
avl	pointer
)	O
;	O
}	O
static	O
void	O
rt_expect	function
(	O
radtest_node_t	struct
*	O
node	pointer
)	O
{	O
radtest_node_expect_t	struct
*	O
exp	pointer
=	O
&	O
node	pointer
->	O
v	union
.	O
expect	struct
;	O
int	O
pass	int
=	O
1	int
;	O
if	O
(	O
verbose	int
)	O
{	O
printf	function
(	O
_	O
(	O
"expect %s\n"	pointer
)	O
,	O
grad_request_code_to_name	function
(	O
exp	pointer
->	O
code	char
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"got    %s\n"	pointer
)	O
,	O
grad_request_code_to_name	function
(	O
reply_code	int
)	O
)	O
;	O
}	O
if	O
(	O
reply_code	int
!=	O
exp	pointer
->	O
code	char
)	O
pass	int
=	O
0	int
;	O
if	O
(	O
exp	pointer
->	O
expr	pointer
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
rt_eval_expr	function
(	O
exp	pointer
->	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
result	pointer
.	O
type	int
!=	O
rtv_avl	int
)	O
runtime_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"expected A/V pair list"	pointer
)	O
)	O
;	O
if	O
(	O
compare_lists	function
(	O
reply_list	pointer
,	O
result	pointer
.	O
datum	union
.	O
avl	pointer
)	O
)	O
pass	int
=	O
0	int
;	O
grad_avl_free	function
(	O
result	pointer
.	O
datum	union
.	O
avl	pointer
)	O
;	O
}	O
printf	function
(	O
"%s\n"	pointer
,	O
pass	int
?	O
"PASS"	pointer
:	O
"FAIL"	pointer
)	O
;	O
}	O
static	O
void	O
rt_exit	function
(	O
radtest_node_t	struct
*	O
expr	pointer
)	O
{	O
int	O
code	char
=	O
0	int
;	O
if	O
(	O
expr	pointer
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
rt_eval_expr	function
(	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
switch	O
(	O
result	pointer
.	O
type	int
)	O
{	O
case	O
rtv_integer	int
:	O
code	char
=	O
result	pointer
.	O
datum	union
.	O
number	long
;	O
break	O
;	O
case	O
rtv_string	int
:	O
code	char
=	O
strtoul	function
(	O
result	pointer
.	O
datum	union
.	O
string	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
parse_error_loc	function
(	O
&	O
expr	pointer
->	O
locus	struct
,	O
_	O
(	O
"invalid data type in exit statement"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
exit	function
(	O
code	char
)	O
;	O
}	O
static	O
int	O
rt_true_p	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_integer	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
number	long
;	O
case	O
rtv_ipaddress	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
!=	O
0	int
;	O
case	O
rtv_string	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
string	pointer
[	O
0	int
]	O
;	O
case	O
rtv_pairlist	int
:	O
return	O
grad_list_count	function
(	O
var	pointer
->	O
datum	union
.	O
list	pointer
)	O
>	O
0	int
;	O
case	O
rtv_avl	int
:	O
return	O
var	pointer
->	O
datum	union
.	O
avl	pointer
!=	O
NULL	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected data type"	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
rt_eval_loop	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
)	O
{	O
radtest_node_loop_t	struct
*	O
loop	struct
=	O
&	O
stmt	pointer
->	O
v	union
.	O
loop	struct
;	O
int	O
restart	int
;	O
if	O
(	O
loop	struct
->	O
first_pass	int
)	O
rt_eval	function
(	O
loop	struct
->	O
body	pointer
)	O
;	O
do	O
{	O
radtest_variable_t	struct
result	pointer
;	O
restart	int
=	O
0	int
;	O
while	O
(	O
break_level	int
==	O
0	int
)	O
{	O
rt_eval_expr	function
(	O
loop	struct
->	O
cond	pointer
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
!	O
rt_true_p	function
(	O
&	O
result	pointer
)	O
)	O
break	O
;	O
rt_eval	function
(	O
loop	struct
->	O
body	pointer
)	O
;	O
}	O
if	O
(	O
break_level	int
)	O
{	O
break_level	int
--	O
;	O
restart	int
=	O
continue_loop	int
;	O
continue_loop	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
restart	int
)	O
;	O
}	O
static	O
void	O
rt_eval_input	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
size_t	long
n	long
=	O
0	int
;	O
radtest_variable_t	struct
*	O
var	pointer
;	O
if	O
(	O
stmt	pointer
->	O
v	union
.	O
input	pointer
.	O
expr	pointer
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
rt_eval_expr	function
(	O
stmt	pointer
->	O
v	union
.	O
input	pointer
.	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
cast_to_string	function
(	O
&	O
stmt	pointer
->	O
locus	struct
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
getline	function
(	O
&	O
p	pointer
,	O
&	O
n	long
,	O
stdin	pointer
)	O
;	O
var	pointer
=	O
stmt	pointer
->	O
v	union
.	O
input	pointer
.	O
var	pointer
;	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_string	int
:	O
grad_free	function
(	O
var	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
grad_avl_free	function
(	O
var	pointer
->	O
datum	union
.	O
avl	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
var	pointer
->	O
type	int
=	O
rtv_string	int
;	O
n	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
n	long
>	O
1	int
&&	O
p	pointer
[	O
n	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
p	pointer
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
var	pointer
->	O
datum	union
.	O
string	pointer
=	O
grad_estrdup	function
(	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
static	O
void	O
rt_eval_case	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
char	O
*	O
sample	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
radtest_case_branch_t	struct
*	O
bp	pointer
;	O
rt_eval_expr	function
(	O
stmt	pointer
->	O
v	union
.	O
branch	struct
.	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
sample	pointer
=	O
cast_to_string	function
(	O
&	O
stmt	pointer
->	O
locus	struct
,	O
&	O
result	pointer
)	O
;	O
radtest_start_string	function
(	O
sample	pointer
)	O
;	O
sample	pointer
=	O
radtest_end_string	function
(	O
)	O
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
stmt	pointer
->	O
v	union
.	O
branch	struct
.	O
branchlist	pointer
)	O
;	O
for	O
(	O
bp	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
bp	pointer
;	O
bp	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
regex_t	struct
rx	struct
;	O
int	O
rc	int
;	O
rt_eval_expr	function
(	O
bp	pointer
->	O
cond	pointer
,	O
&	O
result	pointer
)	O
;	O
p	pointer
=	O
cast_to_string	function
(	O
&	O
bp	pointer
->	O
cond	pointer
->	O
locus	struct
,	O
&	O
result	pointer
)	O
;	O
rc	int
=	O
regcomp	O
(	O
&	O
rx	struct
,	O
p	pointer
,	O
REG_EXTENDED	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
char	O
errbuf	array
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	int
,	O
&	O
rx	struct
,	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
)	O
;	O
runtime_error	function
(	O
&	O
bp	pointer
->	O
cond	pointer
->	O
locus	struct
,	O
"%s"	pointer
,	O
errbuf	array
)	O
;	O
}	O
rc	int
=	O
regexec	O
(	O
&	O
rx	struct
,	O
sample	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
regfree	O
(	O
&	O
rx	struct
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rt_eval	function
(	O
bp	pointer
->	O
node	pointer
)	O
;	O
break	O
;	O
}	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
static	O
void	O
rt_eval	function
(	O
radtest_node_t	struct
*	O
stmt	pointer
)	O
{	O
radtest_variable_t	struct
result	pointer
;	O
if	O
(	O
!	O
stmt	pointer
)	O
return	O
;	O
if	O
(	O
break_level	int
)	O
return	O
;	O
switch	O
(	O
stmt	pointer
->	O
type	int
)	O
{	O
case	O
radtest_node_stmt	int
:	O
rt_eval_stmt_list	function
(	O
stmt	pointer
->	O
v	union
.	O
list	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_print	int
:	O
rt_print	function
(	O
stmt	pointer
->	O
v	union
.	O
list	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_asgn	int
:	O
rt_asgn	function
(	O
stmt	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_send	int
:	O
rt_send	function
(	O
stmt	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_expect	int
:	O
rt_expect	function
(	O
stmt	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_exit	int
:	O
rt_exit	function
(	O
stmt	pointer
->	O
v	union
.	O
expr	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_continue	int
:	O
break_level	int
=	O
stmt	pointer
->	O
v	union
.	O
level	int
;	O
continue_loop	int
=	O
1	int
;	O
break	O
;	O
case	O
radtest_node_break	int
:	O
break_level	int
=	O
stmt	pointer
->	O
v	union
.	O
level	int
;	O
continue_loop	int
=	O
0	int
;	O
break	O
;	O
case	O
radtest_node_loop	int
:	O
rt_eval_loop	function
(	O
stmt	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_cond	int
:	O
rt_eval_expr	function
(	O
stmt	pointer
->	O
v	union
.	O
cond	pointer
.	O
cond	pointer
,	O
&	O
result	pointer
)	O
;	O
rt_eval	function
(	O
rt_true_p	function
(	O
&	O
result	pointer
)	O
?	O
stmt	pointer
->	O
v	union
.	O
cond	pointer
.	O
iftrue	pointer
:	O
stmt	pointer
->	O
v	union
.	O
cond	pointer
.	O
iffalse	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_input	int
:	O
rt_eval_input	function
(	O
stmt	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_set	int
:	O
radtest_parse_options	function
(	O
stmt	pointer
->	O
v	union
.	O
set	struct
.	O
argc	int
,	O
stmt	pointer
->	O
v	union
.	O
set	struct
.	O
argv	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_shift	int
:	O
{	O
int	O
level	int
;	O
if	O
(	O
!	O
stmt	pointer
->	O
v	union
.	O
expr	pointer
)	O
level	int
=	O
1	int
;	O
else	O
{	O
rt_eval_expr	function
(	O
stmt	pointer
->	O
v	union
.	O
expr	pointer
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
result	pointer
.	O
type	int
!=	O
rtv_integer	int
)	O
runtime_error	function
(	O
&	O
stmt	pointer
->	O
locus	struct
,	O
_	O
(	O
"invalid data type in `shift'"	pointer
)	O
)	O
;	O
level	int
=	O
result	pointer
.	O
datum	union
.	O
number	long
;	O
}	O
if	O
(	O
level	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
radtest_env_shift	function
(	O
curenv	pointer
,	O
level	int
)	O
)	O
runtime_error	function
(	O
&	O
stmt	pointer
->	O
locus	struct
,	O
_	O
(	O
"not enough arguments to shift"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
radtest_node_case	int
:	O
rt_eval_case	function
(	O
stmt	pointer
)	O
;	O
break	O
;	O
case	O
radtest_node_call	int
:	O
rt_eval_call	function
(	O
stmt	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
radtest_node_return	int
:	O
rt_eval_expr	function
(	O
stmt	pointer
->	O
v	union
.	O
expr	pointer
,	O
&	O
function_result	struct
)	O
;	O
break_level	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected instruction code"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
rt_eval_stmt_list	function
(	O
grad_list_t	struct
*	O
list	pointer
)	O
{	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
list	pointer
)	O
;	O
radtest_node_t	struct
*	O
node	pointer
;	O
for	O
(	O
node	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
node	pointer
;	O
node	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
rt_eval	function
(	O
node	pointer
)	O
;	O
}	O
struct	O
memory_chunk	struct
{	O
void	O
*	O
ptr	pointer
;	O
void	O
(	O
*	O
destructor	pointer
)	O
(	O
void	O
*	O
)	O
;	O
}	O
;	O
static	O
grad_list_t	struct
*	O
memory_pool	pointer
;	O
static	O
void	O
register_chunk	function
(	O
void	O
*	O
ptr	pointer
,	O
void	O
(	O
*	O
destructor	pointer
)	O
(	O
void	O
*	O
)	O
)	O
{	O
struct	O
memory_chunk	struct
*	O
p	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
if	O
(	O
!	O
memory_pool	pointer
)	O
memory_pool	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
p	pointer
->	O
ptr	pointer
=	O
ptr	pointer
;	O
p	pointer
->	O
destructor	pointer
=	O
destructor	pointer
;	O
grad_list_append	function
(	O
memory_pool	pointer
,	O
p	pointer
)	O
;	O
}	O
static	O
int	O
free_mem	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
memory_chunk	struct
*	O
p	pointer
=	O
item	pointer
;	O
if	O
(	O
p	pointer
->	O
destructor	pointer
)	O
p	pointer
->	O
destructor	pointer
(	O
p	pointer
->	O
ptr	pointer
)	O
;	O
grad_free	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radtest_free_mem	function
(	O
)	O
{	O
grad_list_destroy	function
(	O
&	O
memory_pool	pointer
,	O
free_mem	function
,	O
NULL	O
)	O
;	O
radtest_free_strings	function
(	O
)	O
;	O
}	O
void	O
radtest_fix_mem	function
(	O
)	O
{	O
memory_pool	pointer
=	O
NULL	O
;	O
radtest_fix_strings	function
(	O
)	O
;	O
}	O
radtest_node_t	struct
*	O
radtest_node_alloc	function
(	O
radtest_node_type	enum
type	int
)	O
{	O
radtest_node_t	struct
*	O
node	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
node	pointer
)	O
)	O
;	O
node	pointer
->	O
type	int
=	O
type	int
;	O
node	pointer
->	O
locus	struct
=	O
source_locus	struct
;	O
register_chunk	function
(	O
node	pointer
,	O
grad_free	function
)	O
;	O
return	O
node	pointer
;	O
}	O
static	O
void	O
_free_var	function
(	O
void	O
*	O
item	pointer
)	O
{	O
radtest_variable_t	struct
*	O
var	pointer
=	O
item	pointer
;	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_avl	int
:	O
grad_avl_free	function
(	O
var	pointer
->	O
datum	union
.	O
avl	pointer
)	O
;	O
break	O
;	O
case	O
rtv_pairlist	int
:	O
grad_list_destroy	function
(	O
&	O
var	pointer
->	O
datum	union
.	O
list	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
grad_free	function
(	O
var	pointer
)	O
;	O
}	O
radtest_variable_t	struct
*	O
radtest_var_alloc	function
(	O
radtest_data_type	enum
type	int
)	O
{	O
radtest_variable_t	struct
*	O
var	pointer
;	O
var	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
var	pointer
)	O
)	O
;	O
var	pointer
->	O
type	int
=	O
type	int
;	O
register_chunk	function
(	O
var	pointer
,	O
_free_var	function
)	O
;	O
return	O
var	pointer
;	O
}	O
void	O
radtest_var_copy	function
(	O
radtest_variable_t	struct
*	O
dst	pointer
,	O
radtest_variable_t	struct
*	O
src	pointer
)	O
{	O
dst	pointer
->	O
type	int
=	O
src	pointer
->	O
type	int
;	O
dst	pointer
->	O
datum	union
=	O
src	pointer
->	O
datum	union
;	O
}	O
radtest_variable_t	struct
*	O
radtest_var_dup	function
(	O
radtest_variable_t	struct
*	O
src	pointer
)	O
{	O
radtest_variable_t	struct
*	O
dst	pointer
=	O
radtest_var_alloc	function
(	O
src	pointer
->	O
type	int
)	O
;	O
radtest_var_copy	function
(	O
dst	pointer
,	O
src	pointer
)	O
;	O
return	O
dst	pointer
;	O
}	O
radtest_case_branch_t	struct
*	O
radtest_branch_alloc	function
(	O
)	O
{	O
radtest_case_branch_t	struct
*	O
p	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
register_chunk	function
(	O
p	pointer
,	O
grad_free	function
)	O
;	O
return	O
p	pointer
;	O
}	O
radtest_pair_t	struct
*	O
radtest_pair_alloc	function
(	O
)	O
{	O
radtest_pair_t	struct
*	O
p	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
register_chunk	function
(	O
p	pointer
,	O
grad_free	function
)	O
;	O
return	O
p	pointer
;	O
}	O
